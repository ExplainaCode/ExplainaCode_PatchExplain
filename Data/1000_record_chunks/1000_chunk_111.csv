record_number,buggy_code,fixed_code,code_similarity
110001,"private static YtVideoHtmlResult parseYtVideoHtml(BufferedReader brdr) throws LocalException {
  YtVideoHtmlResult result=new YtVideoHtmlResult();
  String line=""String_Node_Str"";
  while (null != line) {
    try {
      line=brdr.readLine();
    }
 catch (    IOException e) {
      throw new LocalException(Err.IO_NET);
    }
    if (null == line)     break;
    if (line.contains(""String_Node_Str"")) {
      result.playable=false;
      break;
    }
 else     if (line.contains(""String_Node_Str"")) {
      Matcher m=sYtUrlGenerate204Pattern.matcher(line);
      if (m.matches()) {
        line=m.group(1);
        line=line.replaceAll(""String_Node_Str"",""String_Node_Str"");
        line=line.replaceAll(""String_Node_Str"",""String_Node_Str"");
        result.generate_204_url=line;
      }
    }
 else     if (line.contains(""String_Node_Str"")) {
      Matcher m=sYtUrlStreamMapPattern.matcher(line);
      if (m.matches()) {
        line=m.group(1);
        String[] vidElemUrls=line.split(""String_Node_Str"");
        ArrayList<YtVideoElem> al=new ArrayList<>(vidElemUrls.length);
        for (        String s : vidElemUrls) {
          YtVideoElem ve=YtVideoElem.parse(s);
          if (null != ve)           al.add(ve);
        }
        result.vids=al.toArray(new YtVideoElem[al.size()]);
      }
    }
  }
  result.tmstamp=System.currentTimeMillis();
  return result;
}","private static YtVideoHtmlResult parseYtVideoHtml(BufferedReader brdr) throws LocalException {
  YtVideoHtmlResult result=new YtVideoHtmlResult();
  String line=""String_Node_Str"";
  String content=""String_Node_Str"";
  while (null != line) {
    try {
      line=brdr.readLine();
    }
 catch (    IOException e) {
      throw new LocalException(Err.IO_NET);
    }
    if (null == line)     break;
    content+=line + ""String_Node_Str"";
    if (line.contains(""String_Node_Str"")) {
      ;
    }
 else     if (line.contains(""String_Node_Str"")) {
      Matcher m=sYtUrlGenerate204Pattern.matcher(line);
      if (m.matches()) {
        line=m.group(1);
        line=line.replaceAll(""String_Node_Str"",""String_Node_Str"");
        line=line.replaceAll(""String_Node_Str"",""String_Node_Str"");
        result.generate_204_url=line;
      }
    }
 else     if (line.contains(""String_Node_Str"")) {
      Matcher m=sYtUrlStreamMapPattern.matcher(line);
      if (m.matches()) {
        line=m.group(1);
        String[] vidElemUrls=line.split(""String_Node_Str"");
        ArrayList<YtVideoElem> al=new ArrayList<>(vidElemUrls.length);
        for (        String s : vidElemUrls) {
          YtVideoElem ve=YtVideoElem.parse(s);
          if (null != ve)           al.add(ve);
        }
        result.vids=al.toArray(new YtVideoElem[al.size()]);
      }
    }
  }
  P.i(content);
  result.tmstamp=System.currentTimeMillis();
  return result;
}",0.955404923296468
110002,"private void pvOnMoreButtonClicked(View v){
  final YTPlayer.Video video=mMp.getActiveVideo();
  if (null == video)   return;
  final int[] opts;
  final Long vid=(Long)mDb.getVideoInfo(video.ytvid,ColVideo.ID);
  if (null != vid)   opts=new int[]{R.string.detail_info,R.string.set_bookmark,R.string.bookmarks,R.string.add_to,R.string.volume,R.string.delete};
 else   opts=new int[]{R.string.add_to,R.string.delete,R.string.volume};
  final CharSequence[] items=new CharSequence[opts.length];
  for (int i=0; i < opts.length; i++)   items[i]=Utils.getResText(opts[i]);
  AlertDialog.Builder builder=new AlertDialog.Builder(mVActivity);
  builder.setTitle(R.string.player_extra_control_title);
  builder.setItems(items,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int item){
switch (opts[item]) {
case R.string.detail_info:
        pvMoreControlDetailInfo(vid);
      break;
case R.string.set_bookmark:
    pvMoreControlSetBookmark(vid);
  break;
case R.string.bookmarks:
UiUtils.showBookmarkDialog(mVActivity,video.ytvid,video.title);
break;
case R.string.add_to:
pvMoreControlAddTo(vid,video);
break;
case R.string.volume:
changeVideoVolume(video.title,video.ytvid);
break;
case R.string.delete:
pvMoreControlDelete(vid,video.ytvid);
break;
default :
eAssert(false);
}
}
}
);
builder.create().show();
}","private void pvOnMoreButtonClicked(View v){
  final YTPlayer.Video video=mMp.getActiveVideo();
  if (null == video)   return;
  final int[] opts;
  final Long vid=(Long)mDb.getVideoInfo(video.ytvid,ColVideo.ID);
  if (null != vid)   opts=new int[]{R.string.detail_info,R.string.set_bookmark,R.string.bookmarks,R.string.add_to,R.string.volume,R.string.delete};
 else   opts=new int[]{R.string.add_to,R.string.volume};
  final CharSequence[] items=new CharSequence[opts.length];
  for (int i=0; i < opts.length; i++)   items[i]=Utils.getResText(opts[i]);
  AlertDialog.Builder builder=new AlertDialog.Builder(mVActivity);
  builder.setTitle(R.string.player_extra_control_title);
  builder.setItems(items,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int item){
switch (opts[item]) {
case R.string.detail_info:
        pvMoreControlDetailInfo(vid);
      break;
case R.string.set_bookmark:
    pvMoreControlSetBookmark(vid);
  break;
case R.string.bookmarks:
UiUtils.showBookmarkDialog(mVActivity,video.ytvid,video.title);
break;
case R.string.add_to:
pvMoreControlAddTo(vid,video);
break;
case R.string.volume:
changeVideoVolume(video.title,video.ytvid);
break;
case R.string.delete:
pvMoreControlDelete(vid,video.ytvid);
break;
default :
eAssert(false);
}
}
}
);
builder.create().show();
}",0.9940915805022156
110003,"@Override public void onDrawerOpened(){
  if (!mMp.hasActiveVideo())   return;
  ListView lv=(ListView)mPlayerLDrawer.findViewById(R.id.mplayer_list);
  int topPos=mMp.getActiveVideoIndex() - 1;
  if (topPos < 0)   topPos=0;
  lv.setSelectionFromTop(topPos,0);
}","@Override public void onDrawerOpened(){
  if (!mMp.hasActiveVideo() || null == mPlayerLDrawer)   return;
  ListView lv=(ListView)mPlayerLDrawer.findViewById(R.id.mplayer_list);
  int topPos=mMp.getActiveVideoIndex() - 1;
  if (topPos < 0)   topPos=0;
  lv.setSelectionFromTop(topPos,0);
}",0.9527272727272728
110004,"private void pvInit(ViewGroup playerv,ViewGroup playerLDrawer,SurfaceView surfacev){
  mMp.addPlayerStateListener(this,new YTPlayer.PlayerStateListener(){
    @Override public void onStateChanged(    YTPlayer.MPState from,    int fromFlag,    YTPlayer.MPState to,    int toFlag){
      pvConfigureAll(mPlayerv,mPlayerLDrawer,from,fromFlag,to,toFlag);
      notiConfigure(from,fromFlag,to,toFlag);
    }
    @Override public void onBufferingChanged(    int percent){
      mUpdateProg.updateSecondary(percent);
    }
  }
);
  ViewGroup progv=(ViewGroup)playerv.findViewById(R.id.mplayer_progress);
  SeekBar sb=(SeekBar)progv.findViewById(R.id.mplayer_seekbar);
  sb.setMax(SEEKBAR_MAX);
  sb.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
    @Override public void onStopTrackingTouch(    SeekBar seekBar){
      mMp.playerSeekTo((int)(seekBar.getProgress() * (long)mMp.playerGetDuration() / SEEKBAR_MAX));
    }
    @Override public void onStartTrackingTouch(    SeekBar seekBar){
    }
    @Override public void onProgressChanged(    SeekBar seekBar,    int progress,    boolean fromUser){
    }
  }
);
  mUpdateProg.setProgressView(progv);
  if (null != playerLDrawer) {
    ListView lv=(ListView)playerLDrawer.findViewById(R.id.mplayer_list);
    lv.setOnItemClickListener(new AdapterView.OnItemClickListener(){
      @Override public void onItemClick(      AdapterView<?> parent,      View view,      int position,      long id){
        if (!mMp.hasActiveVideo())         return;
        mMp.startVideoAt(position);
      }
    }
);
    mMp.addVideosStateListener(this,new YTPlayer.VideosStateListener(){
      @Override public void onStopped(      YTPlayer.StopState state){
        boolean needToNotification=true;
        CharSequence msg=""String_Node_Str"";
switch (state) {
case DONE:
          needToNotification=false;
        msg=mRes.getText(R.string.msg_playing_done);
      break;
case FORCE_STOPPED:
    needToNotification=false;
  msg=mRes.getText(R.string.msg_playing_stopped);
break;
case NETWORK_UNAVAILABLE:
msg=mRes.getText(R.string.err_network_unavailable);
break;
case UNKNOWN_ERROR:
msg=mRes.getText(R.string.msg_playing_err_unknown);
break;
}
if (null != mPlayerv) {
TextView titlev=(TextView)mPlayerv.findViewById(R.id.mplayer_title);
pvSetTitle(titlev,mRes.getText(R.string.msg_playing_done));
}
if (needToNotification) NotiManager.get().putPlayerNotification(NotiManager.NotiType.ALERT,(String)msg);
}
@Override public void onStarted(){
if (null != mPlayerv) pvEnableLDrawer(mPlayerLDrawer);
}
@Override public void onChanged(){
if (null != mPlayerv) pvConfigureControl((ViewGroup)mPlayerv.findViewById(R.id.mplayer_control),YTPlayer.MPState.INVALID,YTPlayer.MPSTATE_FLAG_IDLE,mMp.playerGetState(),mMp.playerGetStateFlag());
if (null == mPlayerLDrawer) return;
if (mMp.hasActiveVideo()) {
ListView lv=(ListView)mPlayerLDrawer.findViewById(R.id.mplayer_list);
YTPlayerVideoListAdapter adapter=(YTPlayerVideoListAdapter)lv.getAdapter();
if (null != adapter) adapter.setVidArray(mMp.getVideoList());
}
 else pvDisableLDrawer(mPlayerLDrawer);
}
}
);
final SlidingDrawer drawer=(SlidingDrawer)playerLDrawer.findViewById(R.id.mplayer_ldrawer);
drawer.setOnDrawerOpenListener(new SlidingDrawer.OnDrawerOpenListener(){
@Override public void onDrawerOpened(){
if (!mMp.hasActiveVideo()) return;
ListView lv=(ListView)mPlayerLDrawer.findViewById(R.id.mplayer_list);
int topPos=mMp.getActiveVideoIndex() - 1;
if (topPos < 0) topPos=0;
lv.setSelectionFromTop(topPos,0);
}
}
);
}
pvEnableLDrawer(playerLDrawer);
pvSetupStatusBar(playerv);
pvSetupControlButton(playerv);
mUpdateProg.update(mMp.playerGetDuration(),mMp.playerGetPosition());
pvConfigureAll(playerv,playerLDrawer,YTPlayer.MPState.INVALID,YTPlayer.MPSTATE_FLAG_IDLE,mMp.playerGetState(),mMp.playerGetStateFlag());
}","private void pvInit(ViewGroup playerv,ViewGroup playerLDrawer,SurfaceView surfacev){
  mMp.addPlayerStateListener(this,new YTPlayer.PlayerStateListener(){
    @Override public void onStateChanged(    YTPlayer.MPState from,    int fromFlag,    YTPlayer.MPState to,    int toFlag){
      pvConfigureAll(mPlayerv,mPlayerLDrawer,from,fromFlag,to,toFlag);
      notiConfigure(from,fromFlag,to,toFlag);
    }
    @Override public void onBufferingChanged(    int percent){
      mUpdateProg.updateSecondary(percent);
    }
  }
);
  ViewGroup progv=(ViewGroup)playerv.findViewById(R.id.mplayer_progress);
  SeekBar sb=(SeekBar)progv.findViewById(R.id.mplayer_seekbar);
  sb.setMax(SEEKBAR_MAX);
  sb.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
    @Override public void onStopTrackingTouch(    SeekBar seekBar){
      mMp.playerSeekTo((int)(seekBar.getProgress() * (long)mMp.playerGetDuration() / SEEKBAR_MAX));
    }
    @Override public void onStartTrackingTouch(    SeekBar seekBar){
    }
    @Override public void onProgressChanged(    SeekBar seekBar,    int progress,    boolean fromUser){
    }
  }
);
  mUpdateProg.setProgressView(progv);
  if (null != playerLDrawer) {
    ListView lv=(ListView)playerLDrawer.findViewById(R.id.mplayer_list);
    lv.setOnItemClickListener(new AdapterView.OnItemClickListener(){
      @Override public void onItemClick(      AdapterView<?> parent,      View view,      int position,      long id){
        if (!mMp.hasActiveVideo())         return;
        mMp.startVideoAt(position);
      }
    }
);
    mMp.addVideosStateListener(this,new YTPlayer.VideosStateListener(){
      @Override public void onStopped(      YTPlayer.StopState state){
        boolean needToNotification=true;
        CharSequence msg=""String_Node_Str"";
switch (state) {
case DONE:
          needToNotification=false;
        msg=mRes.getText(R.string.msg_playing_done);
      break;
case FORCE_STOPPED:
    needToNotification=false;
  msg=mRes.getText(R.string.msg_playing_stopped);
break;
case NETWORK_UNAVAILABLE:
msg=mRes.getText(R.string.err_network_unavailable);
break;
case UNKNOWN_ERROR:
msg=mRes.getText(R.string.msg_playing_err_unknown);
break;
}
if (null != mPlayerv) {
TextView titlev=(TextView)mPlayerv.findViewById(R.id.mplayer_title);
pvSetTitle(titlev,mRes.getText(R.string.msg_playing_done));
}
if (needToNotification) NotiManager.get().putPlayerNotification(NotiManager.NotiType.ALERT,(String)msg);
}
@Override public void onStarted(){
if (null != mPlayerv) pvEnableLDrawer(mPlayerLDrawer);
}
@Override public void onChanged(){
if (null != mPlayerv) pvConfigureControl((ViewGroup)mPlayerv.findViewById(R.id.mplayer_control),YTPlayer.MPState.INVALID,YTPlayer.MPSTATE_FLAG_IDLE,mMp.playerGetState(),mMp.playerGetStateFlag());
if (null == mPlayerLDrawer) return;
if (mMp.hasActiveVideo()) {
ListView lv=(ListView)mPlayerLDrawer.findViewById(R.id.mplayer_list);
YTPlayerVideoListAdapter adapter=(YTPlayerVideoListAdapter)lv.getAdapter();
if (null != adapter) adapter.setVidArray(mMp.getVideoList());
}
 else pvDisableLDrawer(mPlayerLDrawer);
}
}
);
final SlidingDrawer drawer=(SlidingDrawer)playerLDrawer.findViewById(R.id.mplayer_ldrawer);
drawer.setOnDrawerOpenListener(new SlidingDrawer.OnDrawerOpenListener(){
@Override public void onDrawerOpened(){
if (!mMp.hasActiveVideo() || null == mPlayerLDrawer) return;
ListView lv=(ListView)mPlayerLDrawer.findViewById(R.id.mplayer_list);
int topPos=mMp.getActiveVideoIndex() - 1;
if (topPos < 0) topPos=0;
lv.setSelectionFromTop(topPos,0);
}
}
);
}
pvEnableLDrawer(playerLDrawer);
pvSetupStatusBar(playerv);
pvSetupControlButton(playerv);
mUpdateProg.update(mMp.playerGetDuration(),mMp.playerGetPosition());
pvConfigureAll(playerv,playerLDrawer,YTPlayer.MPState.INVALID,YTPlayer.MPSTATE_FLAG_IDLE,mMp.playerGetState(),mMp.playerGetStateFlag());
}",0.9966021955044432
110005,"private void pvOnMoreButtonClicked(View v){
  final YTPlayer.Video video=mMp.getActiveVideo();
  final int[] opts;
  final Long vid=(Long)mDb.getVideoInfo(video.ytvid,ColVideo.ID);
  if (null != vid)   opts=new int[]{R.string.detail_info,R.string.set_bookmark,R.string.bookmarks,R.string.add_to,R.string.volume,R.string.delete};
 else   opts=new int[]{R.string.add_to,R.string.delete,R.string.volume};
  final CharSequence[] items=new CharSequence[opts.length];
  for (int i=0; i < opts.length; i++)   items[i]=Utils.getResText(opts[i]);
  AlertDialog.Builder builder=new AlertDialog.Builder(mVActivity);
  builder.setTitle(R.string.player_extra_control_title);
  builder.setItems(items,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int item){
switch (opts[item]) {
case R.string.detail_info:
        pvMoreControlDetailInfo(vid);
      break;
case R.string.set_bookmark:
    pvMoreControlSetBookmark(vid);
  break;
case R.string.bookmarks:
UiUtils.showBookmarkDialog(mVActivity,video.ytvid,video.title);
break;
case R.string.add_to:
pvMoreControlAddTo(vid,video);
break;
case R.string.volume:
changeVideoVolume(video.title,video.ytvid);
break;
case R.string.delete:
pvMoreControlDelete(vid,video.ytvid);
break;
default :
eAssert(false);
}
}
}
);
builder.create().show();
}","private void pvOnMoreButtonClicked(View v){
  final YTPlayer.Video video=mMp.getActiveVideo();
  if (null == video)   return;
  final int[] opts;
  final Long vid=(Long)mDb.getVideoInfo(video.ytvid,ColVideo.ID);
  if (null != vid)   opts=new int[]{R.string.detail_info,R.string.set_bookmark,R.string.bookmarks,R.string.add_to,R.string.volume,R.string.delete};
 else   opts=new int[]{R.string.add_to,R.string.delete,R.string.volume};
  final CharSequence[] items=new CharSequence[opts.length];
  for (int i=0; i < opts.length; i++)   items[i]=Utils.getResText(opts[i]);
  AlertDialog.Builder builder=new AlertDialog.Builder(mVActivity);
  builder.setTitle(R.string.player_extra_control_title);
  builder.setItems(items,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int item){
switch (opts[item]) {
case R.string.detail_info:
        pvMoreControlDetailInfo(vid);
      break;
case R.string.set_bookmark:
    pvMoreControlSetBookmark(vid);
  break;
case R.string.bookmarks:
UiUtils.showBookmarkDialog(mVActivity,video.ytvid,video.title);
break;
case R.string.add_to:
pvMoreControlAddTo(vid,video);
break;
case R.string.volume:
changeVideoVolume(video.title,video.ytvid);
break;
case R.string.delete:
pvMoreControlDelete(vid,video.ytvid);
break;
default :
eAssert(false);
}
}
}
);
builder.create().show();
}",0.9884886743408836
110006,"void playerStop(){
  mpStop();
}","void playerStop(){
  if (null != mYtHack)   mYtHack.forceCancel();
  mpStop();
}",0.5714285714285714
110007,"private void startVideo(final String ytvid,final int volume,final String title,boolean recovery){
  eAssert(0 <= volume && volume <= 100);
  setVideoSizeReady(false);
  mStartVideoRecovery.cancel();
  cleanCache(false);
  if (recovery) {
    mErrRetry--;
    if (mErrRetry <= 0) {
      if (Utils.isNetworkAvailable()) {
        if (mVlm.hasNextVideo()) {
          if (mVlm.hasActiveVideo()) {
            Video v=mVlm.getActiveVideo();
            if (DBG) {
              P.w(""String_Node_Str"");
              P.w(""String_Node_Str"" + v.ytvid);
              P.w(""String_Node_Str"" + v.title);
            }
          }
          startNext();
        }
 else         stopPlay(StopState.UNKNOWN_ERROR);
      }
 else       stopPlay(StopState.NETWORK_UNAVAILABLE);
      return;
    }
  }
 else   mErrRetry=PLAYER_ERR_RETRY;
  mpStop();
  mpRelease();
  mpNewInstance();
  mpReset();
  mpSetVolume(volume);
  new Thread(new Runnable(){
    @Override public void run(){
      try {
        mDb.updateVideoTimePlayed(ytvid,System.currentTimeMillis());
      }
 catch (      Exception ignored) {
      }
    }
  }
).start();
  prepareNext();
  Runnable action=new Runnable(){
    @Override public void run(){
      File cachedVid=getCachedVideo(ytvid);
      if (cachedVid.exists() && cachedVid.canRead())       prepareCachedVideo(cachedVid);
 else {
        if (!Utils.isNetworkAvailable())         mStartVideoRecovery.executeRecoveryStart(new Video(ytvid,""String_Node_Str"",""String_Node_Str"",volume,0,0),1000);
 else         prepareVideoStreaming(ytvid);
      }
    }
  }
;
  if (Utils.isPrefHeadTTS()) {
    String text=Utils.getResText(R.string.tts_title_head_pre) + ""String_Node_Str"" + title+ ""String_Node_Str""+ Utils.getResText(R.string.tts_title_head_post);
    ttsSpeak(text,ytvid,action);
  }
 else   action.run();
}","private void startVideo(final String ytvid,final int volume,final String title,boolean recovery){
  eAssert(0 <= volume && volume <= 100);
  setVideoSizeReady(false);
  mStartVideoRecovery.cancel();
  cleanCache(false);
  if (recovery) {
    mErrRetry--;
    if (mErrRetry <= 0) {
      if (Utils.isNetworkAvailable()) {
        if (mVlm.hasNextVideo()) {
          if (mVlm.hasActiveVideo()) {
            Video v=mVlm.getActiveVideo();
            if (DBG) {
              P.w(""String_Node_Str"");
              P.w(""String_Node_Str"" + v.ytvid);
              P.w(""String_Node_Str"" + v.title);
            }
          }
          startNext();
        }
 else         stopPlay(StopState.UNKNOWN_ERROR);
      }
 else       stopPlay(StopState.NETWORK_UNAVAILABLE);
      return;
    }
  }
 else   mErrRetry=PLAYER_ERR_RETRY;
  if (null != mYtHack)   mYtHack.forceCancel();
  mpStop();
  mpRelease();
  mpNewInstance();
  mpReset();
  mpSetVolume(volume);
  new Thread(new Runnable(){
    @Override public void run(){
      try {
        mDb.updateVideoTimePlayed(ytvid,System.currentTimeMillis());
      }
 catch (      Exception ignored) {
      }
    }
  }
).start();
  prepareNext();
  Runnable action=new Runnable(){
    @Override public void run(){
      File cachedVid=getCachedVideo(ytvid);
      if (cachedVid.exists() && cachedVid.canRead())       prepareCachedVideo(cachedVid);
 else {
        if (!Utils.isNetworkAvailable())         mStartVideoRecovery.executeRecoveryStart(new Video(ytvid,""String_Node_Str"",""String_Node_Str"",volume,0,0),1000);
 else         prepareVideoStreaming(ytvid);
      }
    }
  }
;
  if (Utils.isPrefHeadTTS()) {
    String text=Utils.getResText(R.string.tts_title_head_pre) + ""String_Node_Str"" + title+ ""String_Node_Str""+ Utils.getResText(R.string.tts_title_head_post);
    ttsSpeak(text,ytvid,action);
  }
 else   action.run();
}",0.9869918699186992
110008,"public final boolean cancel(final boolean interrupt){
  if (mCancelled.getAndSet(true) || State.RUNNING != mState.get())   return false;
  mOwner.post(new Runnable(){
    @Override public void run(){
      onCancel();
synchronized (mPostRunKeeperLock) {
        if (interrupt && State.RUNNING == mState.get())         mThread.interrupt();
      }
    }
  }
);
  return true;
}","/** 
 * @param interrupt
 * @return 'false' if task is already cancelled - cancel() is called more than once!
 */
public final boolean cancel(final boolean interrupt){
  if (mUserCancel.getAndSet(true))   return false;
  mOwner.post(new Runnable(){
    @Override public void run(){
synchronized (mStateLock) {
switch (getStateLocked()) {
case STARTED:
case RUNNING:
          setStateLocked(State.CANCELING);
        if (DBG)         P.v(""String_Node_Str"");
      onCancel();
    if (interrupt)     mThread.interrupt();
  break;
default :
}
}
}
}
);
return true;
}",0.2957446808510638
110009,"public final boolean isCancelled(){
  return mCancelled.get();
}","/** 
 * Is task cancelled by user? (by calling 'cancel()') This function returns 'true' even if task is under CANCELING state.
 * @return
 */
public final boolean isCancelled(){
  return mUserCancel.get();
}",0.4059040590405904
110010,"@Override public void run(){
  onPreRun();
  mThread.start();
}","@Override public void run(){
  boolean canRun=false;
synchronized (mStateLock) {
    if (State.READY == getStateLocked()) {
      setStateLocked(State.STARTED);
      canRun=true;
    }
  }
  if (canRun) {
    onPreRun();
    mThread.start();
  }
}",0.3987138263665595
110011,"private void postOnCancelled(){
  mOwner.post(new Runnable(){
    @Override public void run(){
      onCancelled();
      mState.set(State.TERMINATED);
    }
  }
);
}","private void postOnCancelled(){
  if (DBG)   P.v(""String_Node_Str"");
  mOwner.post(new Runnable(){
    @Override public void run(){
      onCancelled();
synchronized (mStateLock) {
        setStateLocked(State.TERMINATED_CANCELLED);
      }
    }
  }
);
}",0.6603325415676959
110012,"private void postOnPostRun(final R r){
  mOwner.post(new Runnable(){
    @Override public void run(){
      onPostRun(r);
      mState.set(State.TERMINATED);
    }
  }
);
}","private void postOnPostRun(final R r){
  if (DBG)   P.v(""String_Node_Str"");
  mOwner.post(new Runnable(){
    @Override public void run(){
      onPostRun(r);
synchronized (mStateLock) {
        setStateLocked(State.TERMINATED);
      }
    }
  }
);
}",0.7186761229314421
110013,"private void bgRun(){
  R r=null;
  try {
    mState.set(State.RUNNING);
    if (mCancelled.get())     return;
    r=doAsyncTask();
  }
  finally {
synchronized (mPostRunKeeperLock) {
      mState.set(State.DONE);
      if (mCancelled.get())       postOnCancelled();
 else       postOnPostRun(r);
    }
  }
}","private void bgRun(){
  R r=null;
  try {
synchronized (mStateLock) {
switch (getStateLocked()) {
case CANCELING:
        return;
case STARTED:
      setStateLocked(State.RUNNING);
    break;
default :
  if (DBG)   P.w(""String_Node_Str"" + getStateLocked().name() + ""String_Node_Str"");
return;
}
}
r=doAsyncTask();
}
  finally {
synchronized (mStateLock) {
switch (getStateLocked()) {
case CANCELING:
setStateLocked(State.CANCELLED);
postOnCancelled();
break;
case RUNNING:
setStateLocked(State.DONE);
postOnPostRun(r);
break;
default :
;
}
}
}
}",0.208675263774912
110014,"public final State getState(){
  return mState.get();
}","public final State getState(){
synchronized (mStateLock) {
    return getStateLocked();
  }
}",0.6891891891891891
110015,"@Override public void onDbUpdated(YTPlayer.DBUpdateType ty){
switch (ty) {
case PLAYLIST:
    showLoadingLookAndFeel();
  checkDupAsync(null,(YTVideoFeed.Entry[])getAdapter().getEntries());
}
}","@Override public void onDbUpdated(YTPlayer.DBUpdateType ty){
switch (ty) {
case PLAYLIST:
    showLoadingLookAndFeel();
  YTVideoSearchAdapter adapter=getAdapter();
if (null != adapter) checkDupAsync(null,(YTVideoFeed.Entry[])adapter.getEntries());
}
}",0.8134831460674158
110016,"@Override protected Err doAsyncTask(){
  Err ret=Err.NO_ERR;
  if (null != mWorker)   ret=mWorker.doBackgroundWork(this);
  return ret;
}","@Override protected Err doAsyncTask(){
  try {
    Err ret=Err.NO_ERR;
    if (null != mWorker)     ret=mWorker.doBackgroundWork(this);
    return ret;
  }
 catch (  Throwable e) {
    return Err.UNKNOWN;
  }
}",0.7204610951008645
110017,"@Override public Integer doJob(){
  if (insertVideoToPlaylist(plid,e))   mtpr.nrDone.incrementAndGet();
 else   mtpr.nrIgnored.incrementAndGet();
  return 0;
}","@Override public Integer doJob(){
  boolean r=false;
  try {
    r=insertVideoToPlaylist(plid,e);
    return 0;
  }
  finally {
    if (r)     mtpr.nrDone.incrementAndGet();
 else     mtpr.nrIgnored.incrementAndGet();
  }
}",0.7591623036649214
110018,"private Err doBackgroundImportYtPlaylist(final ImportYtPlaylistResult mtpr,MultiThreadRunner mtrunner,final long plid,final String ytplid,final ProgressListener progl) throws InterruptedException {
  DB db=DB.get();
  YTSearchHelper.SearchArg sarg=new YTSearchHelper.SearchArg(null,YTSearchHelper.SearchType.VID_PLAYLIST,ytplid,""String_Node_Str"",1,YTConstants.MAX_RESULTS_PER_PAGE);
  YTSearchHelper.SearchReturn sr;
  int maxPage=-1;
  int curPage=1;
  HashMap<String,YTVideoFeed.Entry> map=new HashMap<String,YTVideoFeed.Entry>();
  int lastPv=-1;
  int pvBase=0;
  int pvPortion=10;
  do {
    sarg.starti=YTConstants.MAX_RESULTS_PER_PAGE * (curPage - 1) + 1;
    sr=YTSearchHelper.search(sarg);
    checkInterrupted();
    if (YTSearchHelper.Err.NO_ERR != sr.err)     return Err.map(sr.err);
    if (maxPage < 0) {
      int total;
      try {
        total=Integer.parseInt(sr.r.header.totalResults);
      }
 catch (      NumberFormatException e) {
        return Err.YTSEARCH;
      }
      maxPage=total / YTConstants.MAX_RESULTS_PER_PAGE + 1;
    }
    YTVideoFeed.Entry[] ents=(YTVideoFeed.Entry[])sr.r.entries;
    for (    YTVideoFeed.Entry e : ents) {
      if (!db.containsVideo(plid,e.media.videoId))       map.put(e.media.videoId,e);
    }
    int curPv=pvBase + (curPage * 100 / maxPage) * pvPortion / 100;
    if (lastPv < curPv && null != progl) {
      lastPv=curPv;
      progl.onProgress(curPv);
    }
  }
 while (++curPage <= maxPage);
  pvBase+=pvPortion;
  pvPortion=100 - pvBase;
  final int progressBase=pvBase;
  MultiThreadRunner.OnProgressListener progListener=new MultiThreadRunner.OnProgressListener(){
    @Override public void onProgress(    float prog){
      progl.onProgress((int)(progressBase + prog * 100));
    }
  }
;
  mtrunner.setOnProgressListener(progListener);
  Err err=Err.NO_ERR;
  Map.Entry<String,YTVideoFeed.Entry>[] mes=map.entrySet().toArray(new Map.Entry[0]);
  for (  Map.Entry<String,YTVideoFeed.Entry> me : mes) {
    final YTVideoFeed.Entry e=me.getValue();
    mtrunner.appendJob(new Job<Integer>((float)pvPortion / (float)100 / mes.length){
      @Override public Integer doJob(){
        if (insertVideoToPlaylist(plid,e))         mtpr.nrDone.incrementAndGet();
 else         mtpr.nrIgnored.incrementAndGet();
        return 0;
      }
    }
);
  }
  mtrunner.waitAllDone();
  progl.onProgress(100);
  return err;
}","private Err doBackgroundImportYtPlaylist(final ImportYtPlaylistResult mtpr,MultiThreadRunner mtrunner,final long plid,final String ytplid,final ProgressListener progl) throws InterruptedException {
  DB db=DB.get();
  YTSearchHelper.SearchArg sarg=new YTSearchHelper.SearchArg(null,YTSearchHelper.SearchType.VID_PLAYLIST,ytplid,""String_Node_Str"",1,YTConstants.MAX_RESULTS_PER_PAGE);
  YTSearchHelper.SearchReturn sr;
  int maxPage=-1;
  int curPage=1;
  HashMap<String,YTVideoFeed.Entry> map=new HashMap<String,YTVideoFeed.Entry>();
  int lastPv=-1;
  int pvBase=0;
  int pvPortion=10;
  do {
    sarg.starti=YTConstants.MAX_RESULTS_PER_PAGE * (curPage - 1) + 1;
    sr=YTSearchHelper.search(sarg);
    checkInterrupted();
    if (YTSearchHelper.Err.NO_ERR != sr.err)     return Err.map(sr.err);
    if (maxPage < 0) {
      int total;
      try {
        total=Integer.parseInt(sr.r.header.totalResults);
      }
 catch (      NumberFormatException e) {
        return Err.YTSEARCH;
      }
      maxPage=total / YTConstants.MAX_RESULTS_PER_PAGE + 1;
    }
    YTVideoFeed.Entry[] ents=(YTVideoFeed.Entry[])sr.r.entries;
    for (    YTVideoFeed.Entry e : ents) {
      if (!db.containsVideo(plid,e.media.videoId))       map.put(e.media.videoId,e);
    }
    int curPv=pvBase + (curPage * 100 / maxPage) * pvPortion / 100;
    if (lastPv < curPv && null != progl) {
      lastPv=curPv;
      progl.onProgress(curPv);
    }
  }
 while (++curPage <= maxPage);
  pvBase+=pvPortion;
  pvPortion=100 - pvBase;
  final int progressBase=pvBase;
  MultiThreadRunner.OnProgressListener progListener=new MultiThreadRunner.OnProgressListener(){
    @Override public void onProgress(    float prog){
      progl.onProgress((int)(progressBase + prog * 100));
    }
  }
;
  mtrunner.setOnProgressListener(progListener);
  Err err=Err.NO_ERR;
  Map.Entry<String,YTVideoFeed.Entry>[] mes=map.entrySet().toArray(new Map.Entry[0]);
  for (  Map.Entry<String,YTVideoFeed.Entry> me : mes) {
    final YTVideoFeed.Entry e=me.getValue();
    mtrunner.appendJob(new Job<Integer>((float)pvPortion / (float)100 / mes.length){
      @Override public Integer doJob(){
        boolean r=false;
        try {
          r=insertVideoToPlaylist(plid,e);
          return 0;
        }
  finally {
          if (r)           mtpr.nrDone.incrementAndGet();
 else           mtpr.nrIgnored.incrementAndGet();
        }
      }
    }
);
  }
  mtrunner.waitAllDone();
  progl.onProgress(100);
  return err;
}",0.9752475247524752
110019,"@Override protected R doAsyncTask(){
  R r=_mJob.doJob();
  return r;
}","@Override protected R doAsyncTask(){
  R r=null;
  r=_mJob.doJob();
  return r;
}",0.9342105263157896
110020,"@Override public Integer doJob(){
  LoadThumbnailReturn r=doLoadThumbnail(arg);
  sendLoadThumbnailDone(arg,r.bm,r.err);
  return 0;
}","@Override public Integer doJob(){
  LoadThumbnailReturn r=null;
  try {
    r=doLoadThumbnail(arg);
  }
  finally {
    if (null == r)     sendLoadThumbnailDone(arg,null,YTSearchHelper.Err.UNKNOWN);
 else     sendLoadThumbnailDone(arg,r.bm,r.err);
  }
  return 0;
}",0.5012531328320802
110021,"@Override public void handleMessage(final Message msg){
  if (_mClosed)   return;
switch (msg.what) {
case MSG_WHAT_OPEN:
{
      eAssert(null == _mMtrunner);
      _mMtrunner=new MultiThreadRunner(this,Policy.YTSEARCH_MAX_LOAD_THUMBNAIL_THREAD);
    }
  break;
case MSG_WHAT_CLOSE:
{
  _mClosed=true;
  ((HandlerThread)getLooper().getThread()).quit();
}
break;
case MSG_WHAT_SEARCH:
{
SearchArg arg=(SearchArg)msg.obj;
SearchReturn r=doSearch(arg);
sendFeedDone(arg,r.r,r.err);
}
break;
case MSG_WHAT_LOAD_THUMBNAIL:
{
final LoadThumbnailArg arg=(LoadThumbnailArg)msg.obj;
MultiThreadRunner.Job<Integer> job=new MultiThreadRunner.Job<Integer>(true,0){
@Override public Integer doJob(){
LoadThumbnailReturn r=doLoadThumbnail(arg);
sendLoadThumbnailDone(arg,r.bm,r.err);
return 0;
}
}
;
_mMtrunner.appendJob(job);
}
break;
}
}","@Override public void handleMessage(final Message msg){
  if (_mClosed)   return;
switch (msg.what) {
case MSG_WHAT_OPEN:
{
      eAssert(null == _mMtrunner);
      _mMtrunner=new MultiThreadRunner(this,Policy.YTSEARCH_MAX_LOAD_THUMBNAIL_THREAD);
    }
  break;
case MSG_WHAT_CLOSE:
{
  _mClosed=true;
  ((HandlerThread)getLooper().getThread()).quit();
}
break;
case MSG_WHAT_SEARCH:
{
SearchArg arg=(SearchArg)msg.obj;
SearchReturn r=doSearch(arg);
sendFeedDone(arg,r.r,r.err);
}
break;
case MSG_WHAT_LOAD_THUMBNAIL:
{
final LoadThumbnailArg arg=(LoadThumbnailArg)msg.obj;
MultiThreadRunner.Job<Integer> job=new MultiThreadRunner.Job<Integer>(true,0){
@Override public Integer doJob(){
LoadThumbnailReturn r=null;
try {
r=doLoadThumbnail(arg);
}
  finally {
if (null == r) sendLoadThumbnailDone(arg,null,YTSearchHelper.Err.UNKNOWN);
 else sendLoadThumbnailDone(arg,r.bm,r.err);
}
return 0;
}
}
;
_mMtrunner.appendJob(job);
}
break;
}
}",0.899488926746167
110022,"YTSearchAdapter(Context context,YTSearchHelper helper,int rowLayout,YTFeed.Entry[] entries){
  super();
  mCxt=context;
  mHelper=helper;
  mEntries=entries;
  mItemViews=new View[mEntries.length];
  mThumbnails=new Bitmap[mEntries.length];
  mHelper.setLoadThumbnailDoneRecevier(this);
  long delay=0;
  for (int i=0; i < mItemViews.length; i++) {
    mItemViews[i]=UiUtils.inflateLayout(Utils.getAppContext(),rowLayout);
    UiUtils.setThumbnailImageView((ImageView)mItemViews[i].findViewById(R.id.thumbnail),null);
    setViewInvalid(mItemViews[i]);
    final YTSearchHelper.LoadThumbnailArg arg=new YTSearchHelper.LoadThumbnailArg(i,mEntries[i].media.thumbnailUrl,mCxt.getResources().getDimensionPixelSize(R.dimen.thumbnail_width),mCxt.getResources().getDimensionPixelSize(R.dimen.thumbnail_height));
    mThumbnails[i]=null;
    Utils.getUiHandler().postDelayed(new Runnable(){
      @Override public void run(){
        if (null != mHelper)         mHelper.loadThumbnailAsync(arg);
      }
    }
,delay);
    delay+=Policy.YTSEARCH_LOAD_THUMBNAIL_INTERVAL;
  }
}","YTSearchAdapter(Context context,YTSearchHelper helper,int rowLayout,YTFeed.Entry[] entries){
  super();
  mCxt=context;
  mHelper=helper;
  mEntries=entries;
  mItemViews=new View[mEntries.length];
  mThumbnails=new Bitmap[mEntries.length];
  mHelper.setLoadThumbnailDoneRecevier(this);
  for (int i=0; i < mItemViews.length; i++) {
    mItemViews[i]=UiUtils.inflateLayout(Utils.getAppContext(),rowLayout);
    UiUtils.setThumbnailImageView((ImageView)mItemViews[i].findViewById(R.id.thumbnail),null);
    setViewInvalid(mItemViews[i]);
    final YTSearchHelper.LoadThumbnailArg arg=new YTSearchHelper.LoadThumbnailArg(i,mEntries[i].media.thumbnailUrl,mCxt.getResources().getDimensionPixelSize(R.dimen.thumbnail_width),mCxt.getResources().getDimensionPixelSize(R.dimen.thumbnail_height));
    mThumbnails[i]=null;
    if (null != mHelper)     mHelper.loadThumbnailAsync(arg);
  }
}",0.8465879938429964
110023,"public void loadThumbnailAsync(LoadThumbnailArg arg){
  Message msg=mBgHandler.obtainMessage(MSG_WHAT_LOAD_THUMBNAIL,arg);
  mBgHandler.sendMessage(msg);
}","public void loadThumbnailAsync(LoadThumbnailArg arg){
  if (null == mBgHandler)   return;
  Message msg=mBgHandler.obtainMessage(MSG_WHAT_LOAD_THUMBNAIL,arg);
  mBgHandler.sendMessage(msg);
}",0.8959537572254336
110024,"/** 
 * This function download thumbnail image through network synchronously.
 */
public static boolean insertVideoToPlaylist(long plid,String ytvid,String title,String author,int playtime,int volume){
  YTSearchHelper.LoadThumbnailReturn tr=loadYtVideoThumbnail(ytvid);
  DB.Err err=DB.get().insertVideoToPlaylist(plid,ytvid,title,author,playtime,ImageUtils.compressBitmap(tr.bm),Policy.DEFAULT_VIDEO_VOLUME);
  if (null != tr.bm)   tr.bm.recycle();
  if (DB.Err.NO_ERR != err)   return false;
  return true;
}","/** 
 * This function download thumbnail image through network synchronously.
 */
public static boolean insertVideoToPlaylist(long plid,String ytvid,String title,String author,int playtime,int volume){
  YTSearchHelper.LoadThumbnailReturn tr=loadYtVideoThumbnail(ytvid);
  if (null == tr.bm)   return false;
  DB.Err err=DB.get().insertVideoToPlaylist(plid,ytvid,title,author,playtime,ImageUtils.compressBitmap(tr.bm),Policy.DEFAULT_VIDEO_VOLUME);
  tr.bm.recycle();
  if (DB.Err.NO_ERR != err)   return false;
  return true;
}",0.9441233140655106
110025,"private Err doBackgroundImportYtPlaylist(final ImportYtPlaylistResult mtpr,MultiThreadRunner mtrunner,final long plid,final String ytplid,final ProgressListener progl) throws InterruptedException {
  DB db=DB.get();
  YTSearchHelper.SearchArg sarg=new YTSearchHelper.SearchArg(null,YTSearchHelper.SearchType.VID_PLAYLIST,ytplid,""String_Node_Str"",1,YTSearchHelper.MAX_NR_RESULT_PER_PAGE);
  YTSearchHelper.SearchReturn sr;
  int maxPage=-1;
  int curPage=1;
  LinkedList<YTVideoFeed.Entry> plvl=new LinkedList<YTVideoFeed.Entry>();
  int lastPv=-1;
  int pvBase=0;
  int pvPortion=10;
  do {
    sarg.starti=YTSearchHelper.MAX_NR_RESULT_PER_PAGE * (curPage - 1) + 1;
    sr=YTSearchHelper.search(sarg);
    checkInterrupted();
    if (YTSearchHelper.Err.NO_ERR != sr.err)     return Err.map(sr.err);
    if (maxPage < 0) {
      int total;
      try {
        total=Integer.parseInt(sr.r.header.totalResults);
      }
 catch (      NumberFormatException e) {
        return Err.YTSEARCH;
      }
      maxPage=total / YTSearchHelper.MAX_NR_RESULT_PER_PAGE + 1;
    }
    YTVideoFeed.Entry[] ents=(YTVideoFeed.Entry[])sr.r.entries;
    for (    YTVideoFeed.Entry e : ents) {
      if (!db.containsVideo(plid,e.media.videoId))       plvl.addLast(e);
    }
    int curPv=pvBase + (curPage * 100 / maxPage) * pvPortion / 100;
    if (lastPv < curPv && null != progl) {
      lastPv=curPv;
      progl.onProgress(curPv);
    }
  }
 while (++curPage <= maxPage);
  pvBase+=pvPortion;
  pvPortion=100 - pvBase;
  Iterator<YTVideoFeed.Entry> itr=plvl.iterator();
  final int progressBase=pvBase;
  MultiThreadRunner.OnProgressListener progListener=new MultiThreadRunner.OnProgressListener(){
    @Override public void onProgress(    float prog){
      progl.onProgress((int)(progressBase + prog * 100));
    }
  }
;
  mtrunner.setOnProgressListener(progListener);
  Err err=Err.NO_ERR;
  while (itr.hasNext()) {
    final YTVideoFeed.Entry e=itr.next();
    mtrunner.appendJob(new Job<Integer>((float)pvPortion / (float)100 / plvl.size()){
      @Override public Integer doJob(){
        if (insertVideoToPlaylist(plid,e))         mtpr.nrDone.incrementAndGet();
 else         mtpr.nrIgnored.incrementAndGet();
        return 0;
      }
    }
);
  }
  mtrunner.waitAllDone();
  progl.onProgress(100);
  return err;
}","private Err doBackgroundImportYtPlaylist(final ImportYtPlaylistResult mtpr,MultiThreadRunner mtrunner,final long plid,final String ytplid,final ProgressListener progl) throws InterruptedException {
  DB db=DB.get();
  YTSearchHelper.SearchArg sarg=new YTSearchHelper.SearchArg(null,YTSearchHelper.SearchType.VID_PLAYLIST,ytplid,""String_Node_Str"",1,YTSearchHelper.MAX_NR_RESULT_PER_PAGE);
  YTSearchHelper.SearchReturn sr;
  int maxPage=-1;
  int curPage=1;
  HashMap<String,YTVideoFeed.Entry> map=new HashMap<String,YTVideoFeed.Entry>();
  int lastPv=-1;
  int pvBase=0;
  int pvPortion=10;
  do {
    sarg.starti=YTSearchHelper.MAX_NR_RESULT_PER_PAGE * (curPage - 1) + 1;
    sr=YTSearchHelper.search(sarg);
    checkInterrupted();
    if (YTSearchHelper.Err.NO_ERR != sr.err)     return Err.map(sr.err);
    if (maxPage < 0) {
      int total;
      try {
        total=Integer.parseInt(sr.r.header.totalResults);
      }
 catch (      NumberFormatException e) {
        return Err.YTSEARCH;
      }
      maxPage=total / YTSearchHelper.MAX_NR_RESULT_PER_PAGE + 1;
    }
    YTVideoFeed.Entry[] ents=(YTVideoFeed.Entry[])sr.r.entries;
    for (    YTVideoFeed.Entry e : ents) {
      if (!db.containsVideo(plid,e.media.videoId))       map.put(e.media.videoId,e);
    }
    int curPv=pvBase + (curPage * 100 / maxPage) * pvPortion / 100;
    if (lastPv < curPv && null != progl) {
      lastPv=curPv;
      progl.onProgress(curPv);
    }
  }
 while (++curPage <= maxPage);
  pvBase+=pvPortion;
  pvPortion=100 - pvBase;
  final int progressBase=pvBase;
  MultiThreadRunner.OnProgressListener progListener=new MultiThreadRunner.OnProgressListener(){
    @Override public void onProgress(    float prog){
      progl.onProgress((int)(progressBase + prog * 100));
    }
  }
;
  mtrunner.setOnProgressListener(progListener);
  Err err=Err.NO_ERR;
  Map.Entry<String,YTVideoFeed.Entry>[] mes=map.entrySet().toArray(new Map.Entry[0]);
  for (  Map.Entry<String,YTVideoFeed.Entry> me : mes) {
    final YTVideoFeed.Entry e=me.getValue();
    mtrunner.appendJob(new Job<Integer>((float)pvPortion / (float)100 / mes.length){
      @Override public Integer doJob(){
        if (insertVideoToPlaylist(plid,e))         mtpr.nrDone.incrementAndGet();
 else         mtpr.nrIgnored.incrementAndGet();
        return 0;
      }
    }
);
  }
  mtrunner.waitAllDone();
  progl.onProgress(100);
  return err;
}",0.9284802043422732
110026,"YTSearchAdapter(Context context,YTSearchHelper helper,int rowLayout,YTFeed.Entry[] entries){
  super();
  mCxt=context;
  mHelper=helper;
  mEntries=entries;
  mItemViews=new View[mEntries.length];
  mThumbnails=new Bitmap[mEntries.length];
  mHelper.setLoadThumbnailDoneRecevier(this);
  long delay=0;
  for (int i=0; i < mItemViews.length; i++) {
    mItemViews[i]=UiUtils.inflateLayout(Utils.getAppContext(),rowLayout);
    setViewInvalid(mItemViews[i]);
    final YTSearchHelper.LoadThumbnailArg arg=new YTSearchHelper.LoadThumbnailArg(i,mEntries[i].media.thumbnailUrl,mCxt.getResources().getDimensionPixelSize(R.dimen.thumbnail_width),mCxt.getResources().getDimensionPixelSize(R.dimen.thumbnail_height));
    mThumbnails[i]=null;
    Utils.getUiHandler().postDelayed(new Runnable(){
      @Override public void run(){
        if (null != mHelper)         mHelper.loadThumbnailAsync(arg);
      }
    }
,delay);
    delay+=Policy.YTSEARCH_LOAD_THUMBNAIL_INTERVAL;
  }
}","YTSearchAdapter(Context context,YTSearchHelper helper,int rowLayout,YTFeed.Entry[] entries){
  super();
  mCxt=context;
  mHelper=helper;
  mEntries=entries;
  mItemViews=new View[mEntries.length];
  mThumbnails=new Bitmap[mEntries.length];
  mHelper.setLoadThumbnailDoneRecevier(this);
  long delay=0;
  for (int i=0; i < mItemViews.length; i++) {
    mItemViews[i]=UiUtils.inflateLayout(Utils.getAppContext(),rowLayout);
    UiUtils.setThumbnailImageView((ImageView)mItemViews[i].findViewById(R.id.thumbnail),null);
    setViewInvalid(mItemViews[i]);
    final YTSearchHelper.LoadThumbnailArg arg=new YTSearchHelper.LoadThumbnailArg(i,mEntries[i].media.thumbnailUrl,mCxt.getResources().getDimensionPixelSize(R.dimen.thumbnail_width),mCxt.getResources().getDimensionPixelSize(R.dimen.thumbnail_height));
    mThumbnails[i]=null;
    Utils.getUiHandler().postDelayed(new Runnable(){
      @Override public void run(){
        if (null != mHelper)         mHelper.loadThumbnailAsync(arg);
      }
    }
,delay);
    delay+=Policy.YTSEARCH_LOAD_THUMBNAIL_INTERVAL;
  }
}",0.953454189122979
110027,"@Override protected void setItemView(int position,View v,YTFeed.Entry arge){
  eAssert(null != v);
  if (!arge.available)   v.setVisibility(View.INVISIBLE);
  YTVideoFeed.Entry e=(YTVideoFeed.Entry)arge;
  TextView titlev=(TextView)v.findViewById(R.id.title);
  titlev.setText(arge.media.title);
  ImageView thumbnailv=(ImageView)v.findViewById(R.id.thumbnail);
  UiUtils.setThumbnailImageView(thumbnailv,null);
  String playtmtext=""String_Node_Str"";
  try {
    playtmtext=Utils.secsToMinSecText(Integer.parseInt(e.media.playTime));
  }
 catch (  NumberFormatException ex) {
  }
  ((TextView)v.findViewById(R.id.playtime)).setText(playtmtext);
  String dateText;
  dateText=e.media.uploadedTime;
  Date date=Utils.parseDateString(dateText);
  if (null != date)   dateText=android.text.format.DateFormat.getDateFormat(mCxt).format(date);
  ((TextView)v.findViewById(R.id.uploadedtime)).setText(""String_Node_Str"" + dateText + ""String_Node_Str"");
  ((TextView)v.findViewById(R.id.author)).setText(e.author.name);
  if (mDupSet.contains(position))   setToDup(v);
 else   setToNew(v);
  setViewValid(v);
}","@Override protected void setItemView(int position,View v,YTFeed.Entry arge){
  eAssert(null != v);
  if (!arge.available)   v.setVisibility(View.INVISIBLE);
  YTVideoFeed.Entry e=(YTVideoFeed.Entry)arge;
  TextView titlev=(TextView)v.findViewById(R.id.title);
  titlev.setText(arge.media.title);
  String playtmtext=""String_Node_Str"";
  try {
    playtmtext=Utils.secsToMinSecText(Integer.parseInt(e.media.playTime));
  }
 catch (  NumberFormatException ex) {
  }
  ((TextView)v.findViewById(R.id.playtime)).setText(playtmtext);
  String dateText;
  dateText=e.media.uploadedTime;
  Date date=Utils.parseDateString(dateText);
  if (null != date)   dateText=android.text.format.DateFormat.getDateFormat(mCxt).format(date);
  ((TextView)v.findViewById(R.id.uploadedtime)).setText(""String_Node_Str"" + dateText + ""String_Node_Str"");
  ((TextView)v.findViewById(R.id.author)).setText(e.author.name);
  if (mDupSet.contains(position))   setToDup(v);
 else   setToNew(v);
  setViewValid(v);
}",0.9443911792905082
110028,"/** 
 * This function is a kind of HACK to save memory used by thumbnail. Very dangerous and difficult at maintenance. But, I failed to find any better way to save memory for thumbnail display. NOTE If exception like ""Exception : try to used recycled bitmap ..."" is shown up, read and understand what this function does with highest priority!
 * @param v
 * @param imgdata
 */
public static void setThumbnailImageView(ImageView v,byte[] imgdata){
  Bitmap thumbnailBm;
  if (null != imgdata && imgdata.length > 0)   thumbnailBm=BitmapFactory.decodeByteArray(imgdata,0,imgdata.length);
 else   thumbnailBm=BitmapFactory.decodeResource(Utils.getAppContext().getResources(),R.drawable.ic_unknown_image);
  Drawable drawable=v.getDrawable();
  if (drawable instanceof BitmapDrawable) {
    BitmapDrawable bmd=(BitmapDrawable)drawable;
    Bitmap bitmap=bmd.getBitmap();
    bitmap.recycle();
  }
  v.setImageBitmap(thumbnailBm);
}","/** 
 * This function is a kind of HACK - actually FULL OF HACK - to save memory used by thumbnail. Very dangerous and difficult at maintenance. But, I failed to find any better way to save memory for thumbnail display. NOTE If exception like ""Exception : try to used recycled bitmap ..."" is shown up, read and understand what this function does with highest priority!
 * @param v
 * @param imgdata
 */
public static void setThumbnailImageView(ImageView v,byte[] imgdata){
  Bitmap thumbnailBm;
  if (null != imgdata && imgdata.length > 0)   thumbnailBm=BitmapFactory.decodeByteArray(imgdata,0,imgdata.length);
 else   thumbnailBm=sBmIcUnknownImage;
  Drawable drawable=v.getDrawable();
  if (drawable instanceof BitmapDrawable) {
    BitmapDrawable bmd=(BitmapDrawable)drawable;
    Bitmap bitmap=bmd.getBitmap();
    if (bitmap != sBmIcUnknownImage)     bitmap.recycle();
  }
  v.setImageBitmap(thumbnailBm);
}",0.912948857453754
110029,"@Override public void bindView(View v,Context context,Cursor cur){
  ImageView checkv=(ImageView)v.findViewById(R.id.checkbtn);
  ImageView thumbnailv=(ImageView)v.findViewById(R.id.thumbnail);
  TextView titlev=(TextView)v.findViewById(R.id.title);
  TextView authorv=(TextView)v.findViewById(R.id.author);
  TextView playtmv=(TextView)v.findViewById(R.id.playtime);
  TextView uploadtmv=(TextView)v.findViewById(R.id.uploadedtime);
  int pos=cur.getPosition();
  checkv.setTag(VTAGKEY_POS,pos);
  checkv.setOnClickListener(mItemCheckOnClick);
  if (mCheckedMap.containsKey(pos))   checkv.setImageResource(R.drawable.btncheck_on);
 else   checkv.setImageResource(R.drawable.btncheck_off);
  titlev.setText(cur.getString(COLI_TITLE));
  String author=cur.getString(COLI_AUTHOR);
  if (Utils.isValidValue(author))   authorv.setText(author);
 else   authorv.setVisibility(View.GONE);
  uploadtmv.setVisibility(View.GONE);
  playtmv.setText(Utils.secsToMinSecText(cur.getInt(COLI_PLAYTIME)));
  byte[] thumbnailData=(byte[])DB.get().getVideoInfo(cur.getString(COLI_VIDEOID),ColVideo.THUMBNAIL);
  UiUtils.setThumbnailImageView(thumbnailv,thumbnailData);
}","@Override public void bindView(View v,Context context,Cursor cur){
  ImageView checkv=(ImageView)v.findViewById(R.id.checkbtn);
  ImageView thumbnailv=(ImageView)v.findViewById(R.id.thumbnail);
  TextView titlev=(TextView)v.findViewById(R.id.title);
  TextView authorv=(TextView)v.findViewById(R.id.author);
  TextView playtmv=(TextView)v.findViewById(R.id.playtime);
  TextView uploadtmv=(TextView)v.findViewById(R.id.uploadedtime);
  int pos=cur.getPosition();
  checkv.setTag(VTAGKEY_POS,pos);
  checkv.setOnClickListener(mItemCheckOnClick);
  if (mCheckedMap.containsKey(pos))   checkv.setImageResource(R.drawable.btncheck_on);
 else   checkv.setImageResource(R.drawable.btncheck_off);
  titlev.setText(cur.getString(COLI_TITLE));
  String author=cur.getString(COLI_AUTHOR);
  if (Utils.isValidValue(author)) {
    authorv.setVisibility(View.VISIBLE);
    authorv.setText(author);
  }
 else   authorv.setVisibility(View.GONE);
  uploadtmv.setVisibility(View.GONE);
  playtmv.setText(Utils.secsToMinSecText(cur.getInt(COLI_PLAYTIME)));
  byte[] thumbnailData=(byte[])DB.get().getVideoInfo(cur.getString(COLI_VIDEOID),ColVideo.THUMBNAIL);
  UiUtils.setThumbnailImageView(thumbnailv,thumbnailData);
}",0.9570760730981726
110030,"private void addTo(final int[] poss,final boolean move){
  long plid=UiUtils.isUserPlaylist(mPlid) ? mPlid : DB.INVALID_PLAYLIST_ID;
  MusicsAdapter adpr=getAdapter();
  final long[] mids=new long[poss.length];
  for (int i=0; i < mids.length; i++)   mids[i]=adpr.getItemId(poss[i]);
  UiUtils.OnPostExecuteListener listener=new UiUtils.OnPostExecuteListener(){
    @Override public void onPostExecute(    Err result,    Object user){
      if (Err.NO_ERR != result)       UiUtils.showTextToast(MusicsActivity.this,result.getMessage());
      if (move)       getAdapter().reloadCursorAsync();
 else {
        getAdapter().clearCheckState();
        getAdapter().notifyDataSetChanged();
      }
    }
  }
;
  UiUtils.addVideosTo(this,null,listener,plid,mids,move);
}","private void addTo(final int[] poss,final boolean move){
  MusicsAdapter adpr=getAdapter();
  final long[] mids=new long[poss.length];
  for (int i=0; i < mids.length; i++)   mids[i]=adpr.getItemId(poss[i]);
  UiUtils.OnPostExecuteListener listener=new UiUtils.OnPostExecuteListener(){
    @Override public void onPostExecute(    Err result,    Object user){
      if (Err.NO_ERR != result)       UiUtils.showTextToast(MusicsActivity.this,result.getMessage());
      if (move)       getAdapter().reloadCursorAsync();
 else {
        getAdapter().clearCheckState();
        getAdapter().notifyDataSetChanged();
      }
    }
  }
;
  UiUtils.addVideosTo(this,null,listener,mPlid,mids,move);
}",0.945704467353952
110031,"public static void doAddVideosTo(final Activity activity,final Object user,final OnPostExecuteListener listener,final long plid,final long[] vids,final boolean move){
  DiagAsyncTask.Worker worker=new DiagAsyncTask.Worker(){
    @Override public void onPostExecute(    DiagAsyncTask task,    Err result){
      listener.onPostExecute(result,user);
    }
    @Override public Err doBackgroundWork(    DiagAsyncTask task){
      DB db=DB.get();
      db.beginTransaction();
      try {
        for (        long mid : vids) {
          DB.Err err=db.insertVideoToPlaylist(plid,mid);
          if (DB.Err.NO_ERR != err) {
            if (DB.Err.DUPLICATED != err)             return Err.DB_DUPLICATED;
 else             if (1 == vids.length && !move)             return Err.map(err);
          }
          if (move) {
            if (UiUtils.isUserPlaylist(plid))             db.deleteVideoFrom(plid,mid);
 else             db.deleteVideoExcept(plid,mid);
          }
        }
        db.setTransactionSuccessful();
      }
  finally {
        db.endTransaction();
      }
      return Err.NO_ERR;
    }
  }
;
  new DiagAsyncTask(activity,worker,DiagAsyncTask.Style.SPIN,move ? R.string.moving : R.string.adding).run();
}","public static void doAddVideosTo(final Activity activity,final Object user,final OnPostExecuteListener listener,final long dstPlid,final long srcPlid,final long[] vids,final boolean move){
  DiagAsyncTask.Worker worker=new DiagAsyncTask.Worker(){
    @Override public void onPostExecute(    DiagAsyncTask task,    Err result){
      listener.onPostExecute(result,user);
    }
    @Override public Err doBackgroundWork(    DiagAsyncTask task){
      DB db=DB.get();
      db.beginTransaction();
      try {
        for (        long mid : vids) {
          DB.Err err=db.insertVideoToPlaylist(dstPlid,mid);
          if (DB.Err.NO_ERR != err) {
            if (DB.Err.DUPLICATED != err)             return Err.DB_DUPLICATED;
 else             if (1 == vids.length && !move)             return Err.map(err);
          }
          if (move) {
            if (UiUtils.isUserPlaylist(srcPlid))             db.deleteVideoFrom(srcPlid,mid);
 else             db.deleteVideoExcept(dstPlid,mid);
          }
        }
        db.setTransactionSuccessful();
      }
  finally {
        db.endTransaction();
      }
      return Err.NO_ERR;
    }
  }
;
  new DiagAsyncTask(activity,worker,DiagAsyncTask.Style.SPIN,move ? R.string.moving : R.string.adding).run();
}",0.913430420711974
110032,"@Override public void onPlaylist(long plid,Object user){
  doAddVideosTo(activity,user,listener,plid,vids,move);
}","@Override public void onPlaylist(long plid,Object user){
  doAddVideosTo(activity,user,listener,plid,srcPlid,vids,move);
}",0.9661016949152542
110033,"public static void addVideosTo(final Activity activity,final Object user,final OnPostExecuteListener listener,final long plidExcluded,final long[] vids,final boolean move){
  UiUtils.OnPlaylistSelectedListener action=new UiUtils.OnPlaylistSelectedListener(){
    @Override public void onPlaylist(    long plid,    Object user){
      doAddVideosTo(activity,user,listener,plid,vids,move);
    }
    @Override public void onUserMenu(    int pos,    Object user){
    }
  }
;
  UiUtils.buildSelectPlaylistDialog(DB.get(),activity,move ? R.string.move_to : R.string.add_to,null,action,plidExcluded,null).show();
}","public static void addVideosTo(final Activity activity,final Object user,final OnPostExecuteListener listener,final long plid,final long[] vids,final boolean move){
  final long srcPlid=UiUtils.isUserPlaylist(plid) ? plid : DB.INVALID_PLAYLIST_ID;
  UiUtils.OnPlaylistSelectedListener action=new UiUtils.OnPlaylistSelectedListener(){
    @Override public void onPlaylist(    long plid,    Object user){
      doAddVideosTo(activity,user,listener,plid,srcPlid,vids,move);
    }
    @Override public void onUserMenu(    int pos,    Object user){
    }
  }
;
  UiUtils.buildSelectPlaylistDialog(DB.get(),activity,move ? R.string.move_to : R.string.add_to,null,action,srcPlid,null).show();
}",0.375
110034,"void removeVideo(String ytvid){
  int nextIdx=mVlm.findVideoExcept(mVlm.getActiveVideoIndex(),ytvid);
  if (nextIdx < 0)   stopPlay(StopState.DONE);
 else   startAt(nextIdx);
  mVlm.removeVideo(ytvid);
}","void removeVideo(String ytvid){
  int avi=mVlm.getActiveVideoIndex();
  avi=mVlm.findVideoExcept(avi,ytvid);
  if (mVlm.isValidVideoIndex(avi)) {
    startAt(avi);
    mVlm.removeVideo(ytvid);
  }
 else {
    mVlm.removeVideo(ytvid);
    stopPlay(StopState.DONE);
  }
}",0.4025423728813559
110035,"public final boolean cancel(final boolean interrupt){
  mCancelled.set(true);
  if (mCancelled.get() || State.READY == mState.get() || State.TERMINATED == mState.get())   return false;
  mOwner.post(new Runnable(){
    @Override public void run(){
      onCancel();
      if (interrupt)       mThread.interrupt();
    }
  }
);
  return true;
}","public final boolean cancel(final boolean interrupt){
  if (mCancelled.getAndSet(true) || State.READY == mState.get() || State.TERMINATED == mState.get())   return false;
  mOwner.post(new Runnable(){
    @Override public void run(){
      onCancel();
      if (interrupt)       mThread.interrupt();
    }
  }
);
  return true;
}",0.9345238095238096
110036,"public final void cancel(final boolean interrupt){
  mCancelled.set(true);
  mOwner.post(new Runnable(){
    @Override public void run(){
      onCancel();
      if (interrupt)       mThread.interrupt();
    }
  }
);
}","public final boolean cancel(final boolean interrupt){
  mCancelled.set(true);
  if (mCancelled.get() || State.READY == mState.get() || State.TERMINATED == mState.get())   return false;
  mOwner.post(new Runnable(){
    @Override public void run(){
      onCancel();
      if (interrupt)       mThread.interrupt();
    }
  }
);
  return true;
}",0.7629233511586453
110037,"public final boolean isCancelled(){
  eAssert(isCurrentOwnerThread());
  return mCancelled.get();
}","public final boolean isCancelled(){
  return mCancelled.get();
}",0.7852760736196319
110038,"private void bgRun(){
  if (mCancelled.get())   return;
  mState.set(State.RUNNING);
  final R r=doAsyncTask();
  mState.set(State.DONE);
  if (mCancelled.get())   mOwner.post(new Runnable(){
    @Override public void run(){
      onCancelled();
    }
  }
);
 else   mOwner.post(new Runnable(){
    @Override public void run(){
      onPostRun(r);
    }
  }
);
}","private void bgRun(){
  if (mCancelled.get())   return;
  mState.set(State.RUNNING);
  R r=null;
  try {
    r=doAsyncTask();
  }
  finally {
    mState.set(State.DONE);
    if (mCancelled.get())     mOwner.post(new Runnable(){
      @Override public void run(){
        onCancelled();
        mState.set(State.TERMINATED);
      }
    }
);
 else {
      final R result=r;
      mOwner.post(new Runnable(){
        @Override public void run(){
          onPostRun(result);
          mState.set(State.TERMINATED);
        }
      }
);
    }
  }
}",0.7144432194046306
110039,"@Override public void onCancelled(){
  mDialog.dismiss();
  if (null != mWorker)   mWorker.onCancelled(this);
}","@Override public void onCancelled(){
  if (null != mWorker)   mWorker.onCancelled(this);
  mDialog.dismiss();
}",0.8108108108108109
110040,"@Override public void onClick(DialogInterface dialogI,int which){
  if (!mCancelable)   return;
  mUserCancelled=true;
  mDialog.setMessage(mContext.getResources().getText(R.string.msg_wait_cancel));
  if (null != mWorker)   mWorker.onCancel(this);
  super.cancel(mInterruptOnCancel);
}","@Override public void onClick(DialogInterface dialogI,int which){
  eAssert(mCancelable);
  mUserCancelled=true;
  mDialog.setMessage(mContext.getResources().getText(R.string.msg_wait_cancel));
  if (null != mWorker)   mWorker.onCancel(this);
  super.cancel(mInterruptOnCancel);
}",0.96113074204947
110041,"@Override public void onDismiss(DialogInterface dialog){
}","@Override public void onDismiss(DialogInterface dialogI){
  if (null != mOnDismissListener)   mOnDismissListener.onDismiss(dialogI);
}",0.6041666666666666
110042,"@Override protected void onPreRun(){
  mDialog=new ProgressDialog(mContext);
  mDialog.setMessage(mContext.getResources().getText(mMsgid));
  mDialog.setProgressStyle(mStyle.getStyle());
  mDialog.setMax(100);
  mDialog.setCanceledOnTouchOutside(false);
  if (mCancelable)   mDialog.setButton(mContext.getResources().getText(R.string.cancel),this);
 else   mDialog.setCancelable(false);
  mDialog.setOnDismissListener(this);
  mDialog.show();
}","@Override protected void onPreRun(){
  mDialog=new ProgressDialog(mContext);
  mDialog.setMessage(mContext.getResources().getText(mMsgid));
  mDialog.setProgressStyle(mStyle.getStyle());
  mDialog.setMax(100);
  mDialog.setCancelable(false);
  mDialog.setOnKeyListener(new DialogInterface.OnKeyListener(){
    @Override public boolean onKey(    DialogInterface dialog,    int keyCode,    KeyEvent event){
      if (KeyEvent.KEYCODE_SEARCH == keyCode && 0 == event.getRepeatCount()) {
        return true;
      }
      return false;
    }
  }
);
  if (mCancelable)   mDialog.setButton(mContext.getResources().getText(R.string.cancel),this);
  mDialog.setOnDismissListener(this);
  mDialog.show();
}",0.4378283712784588
110043,"DiagAsyncTask(Context context,Worker listener,Style style,int msgid){
  this(context,listener,style,msgid,true,true);
}","public DiagAsyncTask(Context context,Worker listener,Style style,int msgid){
  this(context,listener,style,msgid,false,true);
}",0.943089430894309
110044,"@Override protected void onPostRun(Err result){
  mDialog.dismiss();
  if (mUserCancelled)   return;
  if (null != mWorker)   mWorker.onPostExecute(this,result);
}","@Override protected void onPostRun(Err result){
  if (!mUserCancelled && null != mWorker)   mWorker.onPostExecute(this,result);
  mDialog.dismiss();
}",0.805111821086262
110045,"@Override public void searchDone(YTSearchHelper helper,YTSearchHelper.SearchArg arg,YTFeed.Result result,Err err){
  if (!handleSearchResult(helper,arg,result,err))   return;
  mDbHelper=new DBHelper();
  mDbHelper.setCheckExistDoneReceiver(this);
  mDbHelper.open();
  mDbHelper.checkExistAsync(new DBHelper.CheckExistArg(arg,(YTVideoFeed.Entry[])result.entries));
}","@Override public void searchDone(YTSearchHelper helper,YTSearchHelper.SearchArg arg,YTFeed.Result result,Err err){
  if (!handleSearchResult(helper,arg,result,err))   return;
  mDbHelper.close();
  mDbHelper=new DBHelper();
  mDbHelper.setCheckExistDoneReceiver(this);
  mDbHelper.open();
  mDbHelper.checkExistAsync(new DBHelper.CheckExistArg(arg,(YTVideoFeed.Entry[])result.entries));
}",0.9721854304635762
110046,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case MSG_WHAT_CHECK_EXIST:
    handleCheckExist((CheckExistArg)msg.obj);
  break;
}
}","@Override public void handleMessage(Message msg){
  if (closed)   return;
switch (msg.what) {
case MSG_WHAT_CLOSE:
    closed=true;
  ((HandlerThread)getLooper().getThread()).quit();
break;
case MSG_WHAT_CHECK_EXIST:
handleCheckExist((CheckExistArg)msg.obj);
break;
}
}",0.7028301886792453
110047,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case MSG_WHAT_DOWNLOAD:
    handleDownload((DnArg)msg.obj);
  break;
}
}","@Override public void handleMessage(Message msg){
  if (closed)   return;
switch (msg.what) {
case MSG_WHAT_CLOSE:
    closed=true;
  if (null != loader)   loader.close();
((HandlerThread)getLooper().getThread()).quit();
break;
case MSG_WHAT_DOWNLOAD:
handleDownload((DnArg)msg.obj);
break;
}
}",0.6238532110091743
110048,"@Override public void run(){
  LoadThumbnailReturn r=doLoadThumbnail(arg);
  sendLoadThumbnailDone(arg,r.bm,r.err);
  Message doneMsg=BGHandler.this.obtainMessage(MSG_WHAT_LOAD_THUMBNAIL_DONE,this);
  BGHandler.this.sendMessage(doneMsg);
}","@Override public void run(){
  LoadThumbnailReturn r=doLoadThumbnail(arg);
  sendLoadThumbnailDone(arg,r.bm,r.err);
  Message doneMsg=BGHandler.this.obtainMessage(MSG_WHAT_LOAD_THUMBNAIL_DONE,this);
  sendMessage(doneMsg);
}",0.9676025917926566
110049,"@Override public void handleMessage(final Message msg){
switch (msg.what) {
case MSG_WHAT_SEARCH:
{
      SearchArg arg=(SearchArg)msg.obj;
      SearchReturn r=doSearch(arg);
      sendFeedDone(arg,r.r,r.err);
    }
  break;
case MSG_WHAT_LOAD_THUMBNAIL:
{
  final LoadThumbnailArg arg=(LoadThumbnailArg)msg.obj;
  if (activeLoadThumbnaill.size() < Policy.YTSEARCH_MAX_LOAD_THUMBNAIL_THREAD) {
    Thread thd=new Thread(){
      @Override public void run(){
        LoadThumbnailReturn r=doLoadThumbnail(arg);
        sendLoadThumbnailDone(arg,r.bm,r.err);
        Message doneMsg=BGHandler.this.obtainMessage(MSG_WHAT_LOAD_THUMBNAIL_DONE,this);
        BGHandler.this.sendMessage(doneMsg);
      }
    }
;
    thd.setPriority(Thread.MIN_PRIORITY);
    thd.start();
    activeLoadThumbnaill.add(thd);
  }
 else {
    Message retryMsg=BGHandler.this.obtainMessage(MSG_WHAT_LOAD_THUMBNAIL,arg);
    BGHandler.this.sendMessageDelayed(retryMsg,Policy.YTSEARCH_LOAD_THUMBNAIL_INTERVAL);
  }
}
break;
case MSG_WHAT_LOAD_THUMBNAIL_DONE:
activeLoadThumbnaill.remove(msg.obj);
break;
}
}","@Override public void handleMessage(final Message msg){
  if (closed)   return;
switch (msg.what) {
case MSG_WHAT_CLOSE:
{
      closed=true;
      Iterator<Thread> iter=activeLoadThumbnaill.iterator();
      while (iter.hasNext())       iter.next().interrupt();
      activeLoadThumbnaill.clear();
      ((HandlerThread)getLooper().getThread()).quit();
    }
  break;
case MSG_WHAT_SEARCH:
{
  SearchArg arg=(SearchArg)msg.obj;
  SearchReturn r=doSearch(arg);
  sendFeedDone(arg,r.r,r.err);
}
break;
case MSG_WHAT_LOAD_THUMBNAIL:
{
final LoadThumbnailArg arg=(LoadThumbnailArg)msg.obj;
if (activeLoadThumbnaill.size() < Policy.YTSEARCH_MAX_LOAD_THUMBNAIL_THREAD) {
Thread thd=new Thread(){
  @Override public void run(){
    LoadThumbnailReturn r=doLoadThumbnail(arg);
    sendLoadThumbnailDone(arg,r.bm,r.err);
    Message doneMsg=BGHandler.this.obtainMessage(MSG_WHAT_LOAD_THUMBNAIL_DONE,this);
    sendMessage(doneMsg);
  }
}
;
thd.setPriority(Thread.MIN_PRIORITY);
thd.start();
activeLoadThumbnaill.add(thd);
}
 else {
Message retryMsg=BGHandler.this.obtainMessage(MSG_WHAT_LOAD_THUMBNAIL,arg);
sendMessageDelayed(retryMsg,Policy.YTSEARCH_LOAD_THUMBNAIL_INTERVAL);
}
}
break;
case MSG_WHAT_LOAD_THUMBNAIL_DONE:
activeLoadThumbnaill.remove(msg.obj);
break;
}
}",0.7989756722151088
110050,"public static void init(){
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(Intent.ACTION_SCREEN_ON);
  ScreenMonitor rcvr=new ScreenMonitor();
  Utils.getAppContext().registerReceiver(rcvr,filter);
}","public static void init(){
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_SCREEN_ON);
  ScreenMonitor rcvr=new ScreenMonitor();
  Utils.getAppContext().registerReceiver(rcvr,filter);
}",0.902127659574468
110051,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED);
  setContentView(R.layout.lockscreen);
  findViewById(R.id.close).setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      finish();
    }
  }
);
  mMp.addVideosStateListener(this,this);
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mForeground=getIntent().getBooleanExtra(INTENT_KEY_APP_FOREGROUND,false);
  getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED);
  setContentView(R.layout.lockscreen);
  findViewById(R.id.close).setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      close();
    }
  }
);
  mMp.addVideosStateListener(this,this);
}",0.9010238907849828
110052,"@Override public void onClick(View v){
  finish();
}","@Override public void onClick(View v){
  close();
}",0.912621359223301
110053,"@Override public void onReceive(Context context,Intent intent){
  Intent i=new Intent(Utils.getAppContext(),LockScreenActivity.class);
  i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
  if (Intent.ACTION_SCREEN_OFF.equals(intent.getAction())) {
    i.putExtra(INTENT_KEY_SCREEN,false);
  }
 else   if (Intent.ACTION_SCREEN_ON.equals(intent.getAction())) {
    i.putExtra(INTENT_KEY_SCREEN,true);
    if (Utils.isPrefLockScreen() && YTPlayer.get().hasActiveVideo())     context.startActivity(i);
  }
}","@Override public void onReceive(Context context,Intent intent){
  Intent i=new Intent(Utils.getAppContext(),LockScreenActivity.class);
  i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
  if (Intent.ACTION_SCREEN_ON.equals(intent.getAction())) {
    i.putExtra(INTENT_KEY_APP_FOREGROUND,Utils.isAppForeground());
    if (Utils.isPrefLockScreen() && YTPlayer.get().hasActiveVideo())     context.startActivity(i);
  }
}",0.8492890995260663
110054,"@Override public void onStopped(StopState state){
  finish();
}","@Override public void onStopped(StopState state){
  close();
}",0.928
110055,"@Override public void onBackPressed(){
  super.onBackPressed();
}","@Override public void onBackPressed(){
  close();
  super.onBackPressed();
}",0.9219858156028368
110056,"@Override protected void onPause(){
  mMp.unsetController(this);
  super.onPause();
  mDb.registerToPlaylistTableWatcher(this);
}","@Override protected void onPause(){
  mMp.unsetController(this);
  mDb.registerToPlaylistTableWatcher(this);
  super.onPause();
}",0.8527131782945736
110057,"@Override protected void onDestroy(){
  super.onDestroy();
}","@Override protected void onDestroy(){
  mDb.unregisterToPlaylistTableWatcher(this);
  super.onDestroy();
}",0.7228915662650602
110058,"@Override protected void onResume(){
  super.onResume();
  ViewGroup playerv=(ViewGroup)findViewById(R.id.player);
  mMp.setController(this,playerv,(ViewGroup)findViewById(R.id.list_drawer),null,mMp.getVideoToolButton());
  if (mMp.hasActiveVideo())   playerv.setVisibility(View.VISIBLE);
 else   playerv.setVisibility(View.GONE);
  if (mDb.isRegisteredToPlaylistTableWatcher(this) && mDb.isPlaylistTableUpdated(this))   getAdapter().reloadCursorAsync();
}","@Override protected void onResume(){
  super.onResume();
  ViewGroup playerv=(ViewGroup)findViewById(R.id.player);
  mMp.setController(this,playerv,(ViewGroup)findViewById(R.id.list_drawer),null,mMp.getVideoToolButton());
  if (mMp.hasActiveVideo())   playerv.setVisibility(View.VISIBLE);
 else   playerv.setVisibility(View.GONE);
  if (mDb.isRegisteredToPlaylistTableWatcher(this)) {
    if (mDb.isPlaylistTableUpdated(this))     getAdapter().reloadCursorAsync();
    mDb.unregisterToPlaylistTableWatcher(this);
  }
}",0.9281314168377824
110059,"protected void stopLoadingLookAndFeel(){
  View listv=findViewById(R.id.list);
  View loadingv=findViewById(R.id.loading);
  ImageView iv=(ImageView)loadingv.findViewById(R.id.loading_img);
  if (null != iv.getAnimation()) {
    iv.getAnimation().cancel();
    iv.getAnimation().reset();
  }
  loadingv.setVisibility(View.GONE);
  listv.setVisibility(View.VISIBLE);
}","protected void stopLoadingLookAndFeel(){
  View loadingv=findViewById(R.id.loading);
  if (View.VISIBLE != loadingv.getVisibility()) {
    eAssert(View.VISIBLE == mListv.getVisibility());
    return;
  }
  ImageView iv=(ImageView)loadingv.findViewById(R.id.loading_img);
  if (null != iv.getAnimation()) {
    iv.getAnimation().cancel();
    iv.getAnimation().reset();
  }
  loadingv.setVisibility(View.GONE);
  mListv.setVisibility(View.VISIBLE);
}",0.7745098039215687
110060,"protected void showLoadingLookAndFeel(){
  View listv=findViewById(R.id.list);
  View loadingv=findViewById(R.id.loading);
  ImageView iv=(ImageView)loadingv.findViewById(R.id.loading_img);
  TextView tv=(TextView)loadingv.findViewById(R.id.loading_msg);
  tv.setText(R.string.loading);
  loadingv.setVisibility(View.VISIBLE);
  listv.setVisibility(View.GONE);
  iv.startAnimation(AnimationUtils.loadAnimation(YTSearchActivity.this,R.anim.rotate));
}","protected void showLoadingLookAndFeel(){
  View loadingv=findViewById(R.id.loading);
  if (View.VISIBLE == loadingv.getVisibility()) {
    eAssert(View.VISIBLE != mListv.getVisibility());
    return;
  }
  ImageView iv=(ImageView)loadingv.findViewById(R.id.loading_img);
  TextView tv=(TextView)loadingv.findViewById(R.id.loading_msg);
  tv.setText(R.string.loading);
  loadingv.setVisibility(View.VISIBLE);
  mListv.setVisibility(View.GONE);
  iv.startAnimation(AnimationUtils.loadAnimation(YTSearchActivity.this,R.anim.rotate));
}",0.5519348268839104
110061,"@Override protected void onPause(){
  super.onPause();
}","@Override protected void onPause(){
  mDb.registerToVideoTableWatcher(this);
  super.onPause();
}",0.7320261437908496
110062,"private void onContextMenuVideosOfThisAuthor(final int position){
  loadFirstPage(YTSearchHelper.SearchType.VID_AUTHOR,getAdapter().getItemAuthor(position),getAdapter().getItemAuthor(position));
}","private void onContextMenuVideosOfThisAuthor(final int position){
  Intent i=new Intent(this,YTVideoSearchActivity.class);
  i.putExtra(INTENT_KEY_SEARCH_TYPE,YTSearchHelper.SearchType.VID_AUTHOR.name());
  i.putExtra(INTENT_KEY_SEARCH_TEXT,getAdapter().getItemAuthor(position));
  i.putExtra(INTENT_KEY_SEARCH_TITLE,getAdapter().getItemAuthor(position));
  startActivity(i);
}",0.6422338568935427
110063,"@Override public void searchDone(YTSearchHelper helper,YTSearchHelper.SearchArg arg,YTFeed.Result result,Err err){
  if (!handleSearchResult(helper,arg,result,err))   return;
  mDbHelper.close();
  mDbHelper=new DBHelper();
  mDbHelper.setCheckExistDoneReceiver(this);
  mDbHelper.open();
  mDbHelper.checkExistAsync(new DBHelper.CheckExistArg(arg,(YTVideoFeed.Entry[])result.entries));
}","@Override public void searchDone(YTSearchHelper helper,YTSearchHelper.SearchArg arg,YTFeed.Result result,Err err){
  if (!handleSearchResult(helper,arg,result,err))   return;
  checkDupAsync(arg,(YTVideoFeed.Entry[])result.entries);
}",0.729903536977492
110064,"@Override protected void onDestroy(){
  mDbHelper.close();
  super.onDestroy();
}","@Override protected void onDestroy(){
  mDbHelper.close();
  mDb.unregisterToVideoTableWatcher(this);
  super.onDestroy();
}",0.7902439024390244
110065,"/** 
 * @return 0 for success, otherwise error message id.
 */
private int addToPlaylist(final long plid,final int pos,final int volume){
  eAssert(plid >= 0);
  Bitmap bm=getAdapter().getItemThumbnail(pos);
  if (null == bm) {
    return R.string.msg_no_thumbnail;
  }
  final YTVideoFeed.Entry entry=(YTVideoFeed.Entry)getAdapter().getItem(pos);
  int playtm=0;
  try {
    playtm=Integer.parseInt(entry.media.playTime);
  }
 catch (  NumberFormatException ex) {
    return R.string.msg_unknown_format;
  }
  Err err=mDb.insertVideoToPlaylist(plid,entry.media.title,entry.media.description,entry.media.videoId,playtm,Utils.compressBitmap(bm),volume);
  if (Err.NO_ERR != err) {
    if (Err.DB_DUPLICATED == err)     return R.string.msg_existing_muisc;
 else     return err.getMessage();
  }
  runOnUiThread(new Runnable(){
    @Override public void run(){
      getAdapter().markEntryExist(pos);
    }
  }
);
  return 0;
}","/** 
 * @return 0 for success, otherwise error message id.
 */
private int addToPlaylist(final long plid,final int pos,final int volume){
  eAssert(plid >= 0);
  Bitmap bm=getAdapter().getItemThumbnail(pos);
  if (null == bm) {
    return R.string.msg_no_thumbnail;
  }
  final YTVideoFeed.Entry entry=(YTVideoFeed.Entry)getAdapter().getItem(pos);
  int playtm=0;
  try {
    playtm=Integer.parseInt(entry.media.playTime);
  }
 catch (  NumberFormatException ex) {
    return R.string.msg_unknown_format;
  }
  Err err=mDb.insertVideoToPlaylist(plid,entry.media.title,entry.media.description,entry.media.videoId,playtm,Utils.compressBitmap(bm),volume);
  if (Err.NO_ERR != err) {
    if (Err.DB_DUPLICATED == err)     return R.string.msg_existing_muisc;
 else     return err.getMessage();
  }
  runOnUiThread(new Runnable(){
    @Override public void run(){
      getAdapter().markEntryExist(pos,true);
    }
  }
);
  return 0;
}",0.9973016729627632
110066,"@Override protected void onResume(){
  super.onResume();
}","@Override protected void onResume(){
  super.onResume();
  if (mDb.isRegisteredToVideoTableWatcher(this)) {
    if (mDb.isVideoTableUpdated(this)) {
      showLoadingLookAndFeel();
      checkDupAsync(null,(YTVideoFeed.Entry[])getAdapter().getEntries());
    }
    mDb.unregisterToVideoTableWatcher(this);
  }
}",0.3143631436314363
110067,"public void markEntryExist(int pos){
  YTFeed.Entry e=mEntries[pos];
  e.uflag=Utils.bitSet(e.uflag,FENT_EXIST_DUP,MENT_EXIST);
  setToExist(mItemViews[pos]);
}","public void markEntryExist(int pos,boolean exist){
  YTFeed.Entry e=mEntries[pos];
  long olduflag=e.uflag;
  e.uflag=Utils.bitSet(e.uflag,exist ? FENT_EXIST_DUP : FENT_EXIST_NEW,MENT_EXIST);
  if (olduflag != e.uflag)   setToExist(mItemViews[pos]);
}",0.7785888077858881
110068,"public static String getFeedUrlByUser(String user,int start,int maxCount){
  return ""String_Node_Str"" + Uri.encode(user,null) + ""String_Node_Str"";
}","public static String getFeedUrlByUser(String user,int start,int maxCount){
  return ""String_Node_Str"" + Uri.encode(user,null) + ""String_Node_Str""+ ""String_Node_Str""+ start+ ""String_Node_Str""+ maxCount;
}",0.8433048433048433
110069,"private void storePlayerState(){
  if (null == mMp)   return;
  int storedPos=0;
  int storedVol=Policy.DEFAULT_VIDEO_VOLUME;
  if (mVlm.hasActiveVideo()) {
    Long vol=(Long)mDb.getVideoInfo(mVlm.getActiveVideo().videoId,DB.ColVideo.VOLUME);
    if (null != vol)     storedVol=vol.intValue();
  }
  if (haveStoredPlayerState()) {
    storedPos=mStoredPState.pos;
    storedVol=mStoredPState.vol;
  }
  clearStoredPlayerState();
  mStoredPState=new PlayerState();
  mStoredPState.mpState=mpGetState();
  mStoredPState.vidobj=mVlm.getActiveVideo();
switch (mpGetState()) {
case STARTED:
case PAUSED:
    mStoredPState.pos=mpGetCurrentPosition();
  mStoredPState.vol=mpGetVolume();
break;
default :
mStoredPState.pos=storedPos;
mStoredPState.vol=storedVol;
}
}","private void storePlayerState(){
  if (null == mMp)   return;
  int storedPos=0;
  int storedVol=Policy.DEFAULT_VIDEO_VOLUME;
  if (mVlm.hasActiveVideo()) {
    Long vol=(Long)mDb.getVideoInfo(mVlm.getActiveVideo().videoId,DB.ColVideo.VOLUME);
    if (null != vol)     storedVol=vol.intValue();
  }
  if (haveStoredPlayerState()) {
    storedPos=mStoredPState.pos;
    storedVol=mStoredPState.vol;
  }
  clearStoredPlayerState();
  mStoredPState=new PlayerState();
  mStoredPState.mpState=mpGetState();
  mStoredPState.vidobj=mVlm.getActiveVideo();
switch (mpGetState()) {
case STARTED:
case PAUSED:
case PREPARED_AUDIO:
case PREPARED:
    mStoredPState.pos=mpGetCurrentPosition();
  mStoredPState.vol=mpGetVolume();
break;
default :
mStoredPState.pos=storedPos;
mStoredPState.vol=storedVol;
}
}",0.9768339768339768
110070,"private boolean isStoredPlayerStatePaused(){
  return MPState.PAUSED == mStoredPState.mpState;
}","private boolean isStoredPlayerStatePaused(){
switch (mStoredPState.mpState) {
case PAUSED:
case PREPARED_AUDIO:
case PREPARED:
    return true;
}
return false;
}",0.5447470817120622
110071,"private void fitVideoSurfaceToScreen(boolean statusBarShown){
  SurfaceHolder holder=mSurfv.getHolder();
  int vw=mMp.getVideoWidth();
  int vh=mMp.getVideoHeight();
  if (0 >= vw || 0 >= vh)   return;
  int sw, sh;
  if (statusBarShown) {
    sw=Utils.getVisibleFrameWidth(this);
    sh=Utils.getVisibleFrameHeight(this);
  }
 else {
    sw=((WindowManager)Utils.getAppContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getWidth();
    sh=((WindowManager)Utils.getAppContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getHeight();
  }
  if (sw < sh) {
    int tmp=sw;
    sw=sh;
    sh=tmp;
  }
  int[] sz=new int[2];
  Utils.fitFixedRatio(sw,sh,vw,vh,sz);
  holder.setFixedSize(sz[0],sz[1]);
  ViewGroup.LayoutParams lp=mSurfv.getLayoutParams();
  lp.width=sz[0];
  lp.height=sz[1];
  mSurfv.setLayoutParams(lp);
  mSurfv.requestLayout();
}","private void fitVideoSurfaceToScreen(boolean statusBarShown){
  SurfaceHolder holder=mSurfv.getHolder();
  int vw=mMp.getVideoWidth();
  int vh=mMp.getVideoHeight();
  if (0 >= vw || 0 >= vh)   return;
  int sw=Utils.getVisibleFrameWidth(this);
  int sh=Utils.getVisibleFrameHeight(this);
  if (statusBarShown)   sh-=mStatusBarHeight;
  if (sw < sh) {
    int tmp=sw;
    sw=sh;
    sh=tmp;
  }
  int[] sz=new int[2];
  Utils.fitFixedRatio(sw,sh,vw,vh,sz);
  holder.setFixedSize(sz[0],sz[1]);
  ViewGroup.LayoutParams lp=mSurfv.getLayoutParams();
  lp.width=sz[0];
  lp.height=sz[1];
  mSurfv.setLayoutParams(lp);
  mSurfv.requestLayout();
}",0.7173770491803279
110072,"public static int getVisibleFrameHeight(Activity activity){
  Rect rect=new Rect();
  Window window=activity.getWindow();
  window.getDecorView().getWindowVisibleDisplayFrame(rect);
  return rect.bottom - rect.top;
}","public static int getVisibleFrameHeight(Activity activity){
  Rect rect=new Rect();
  Window window=activity.getWindow();
  window.getDecorView().getWindowVisibleDisplayFrame(rect);
  return rect.bottom;
}",0.973871733966746
110073,"private int mpGetCurrentPosition(){
  if (null == mMp)   return 0;
switch (mpGetState()) {
case IDLE:
case INITIALIZED:
case PREPARED_AUDIO:
case PREPARED:
case STARTED:
case PAUSED:
case STOPPED:
case PLAYBACK_COMPLETED:
    return mMp.getCurrentPosition();
}
logI(""String_Node_Str"" + mpGetState().name() + ""String_Node_Str"");
return 0;
}","private int mpGetCurrentPosition(){
  if (null == mMp)   return 0;
switch (mpGetState()) {
case PREPARED_AUDIO:
case PREPARED:
case STARTED:
case PAUSED:
case STOPPED:
case PLAYBACK_COMPLETED:
    return mMp.getCurrentPosition();
}
logI(""String_Node_Str"" + mpGetState().name() + ""String_Node_Str"");
return 0;
}",0.9553158705701078
110074,"private void addCheckedMusicsToPlaylist(final long plid){
  final YTVideoSearchAdapter adpr=getAdapter();
  final int[] checkedItems=adpr.getCheckedItemPositions();
  for (  int i : checkedItems) {
    if (null == adpr.getItemThumbnail(i)) {
      UiUtils.showTextToast(this,R.string.msg_no_all_thumbnail);
      return;
    }
  }
  DiagAsyncTask.Worker worker=new DiagAsyncTask.Worker(){
    private int failedCnt=0;
    @Override public void onPostExecute(    DiagAsyncTask task,    Err result){
      adpr.cleanItemCheck();
      if (failedCnt > 0) {
        CharSequence msg=getResources().getText(R.string.msg_fails_to_add);
        UiUtils.showTextToast(YTVideoSearchActivity.this,msg + ""String_Node_Str"" + failedCnt);
      }
    }
    @Override public void onCancel(    DiagAsyncTask task){
    }
    @Override public Err doBackgroundWork(    DiagAsyncTask task,    Object... objs){
      mDb.beginTransaction();
      try {
        for (        int i : checkedItems) {
          int r=addToPlaylist(plid,i,adpr.getItemVolume(i));
          if (0 != r && R.string.msg_existing_muisc != r)           failedCnt++;
        }
        mDb.setTransactionSuccessful();
      }
  finally {
        mDb.endTransaction();
      }
      return Err.NO_ERR;
    }
  }
;
  new DiagAsyncTask(YTVideoSearchActivity.this,worker,DiagAsyncTask.Style.SPIN,R.string.adding,false).execute();
}","private void addCheckedMusicsToPlaylist(final long plid){
  final YTVideoSearchAdapter adpr=getAdapter();
  final int[] checkedItems=adpr.getCheckedItemPositions();
  final int[] itemVolumes=new int[checkedItems.length];
  for (int i=0; i < checkedItems.length; i++) {
    int pos=checkedItems[i];
    if (null == adpr.getItemThumbnail(pos)) {
      UiUtils.showTextToast(this,R.string.msg_no_all_thumbnail);
      return;
    }
    itemVolumes[i]=adpr.getItemVolume(pos);
  }
  DiagAsyncTask.Worker worker=new DiagAsyncTask.Worker(){
    private int failedCnt=0;
    @Override public void onPostExecute(    DiagAsyncTask task,    Err result){
      adpr.cleanItemCheck();
      if (failedCnt > 0) {
        CharSequence msg=getResources().getText(R.string.msg_fails_to_add);
        UiUtils.showTextToast(YTVideoSearchActivity.this,msg + ""String_Node_Str"" + failedCnt);
      }
    }
    @Override public void onCancel(    DiagAsyncTask task){
    }
    @Override public Err doBackgroundWork(    DiagAsyncTask task,    Object... objs){
      mDb.beginTransaction();
      try {
        for (int i=0; i < checkedItems.length; i++) {
          int pos=checkedItems[i];
          int r=addToPlaylist(plid,pos,itemVolumes[i]);
          if (0 != r && R.string.msg_existing_muisc != r)           failedCnt++;
        }
        mDb.setTransactionSuccessful();
      }
  finally {
        mDb.endTransaction();
      }
      return Err.NO_ERR;
    }
  }
;
  new DiagAsyncTask(this,worker,DiagAsyncTask.Style.SPIN,R.string.adding,false).execute();
}",0.8990071893187265
110075,"@Override public Err doBackgroundWork(DiagAsyncTask task,Object... objs){
  mDb.beginTransaction();
  try {
    for (    int i : checkedItems) {
      int r=addToPlaylist(plid,i,adpr.getItemVolume(i));
      if (0 != r && R.string.msg_existing_muisc != r)       failedCnt++;
    }
    mDb.setTransactionSuccessful();
  }
  finally {
    mDb.endTransaction();
  }
  return Err.NO_ERR;
}","@Override public Err doBackgroundWork(DiagAsyncTask task,Object... objs){
  mDb.beginTransaction();
  try {
    for (int i=0; i < checkedItems.length; i++) {
      int pos=checkedItems[i];
      int r=addToPlaylist(plid,pos,itemVolumes[i]);
      if (0 != r && R.string.msg_existing_muisc != r)       failedCnt++;
    }
    mDb.setTransactionSuccessful();
  }
  finally {
    mDb.endTransaction();
  }
  return Err.NO_ERR;
}",0.8899876390605687
110076,"@Override public void onClick(DialogInterface dialog,int which){
  eAssert(which >= 0);
  dialog.dismiss();
  if (userMenus.length > which) {
    action.onUserMenu(which,user);
  }
 else   if (userMenus.length == which) {
    UiUtils.EditTextAction edAction=new UiUtils.EditTextAction(){
      @Override public void prepare(      Dialog dialog,      EditText edit){
      }
      @Override public void onOk(      Dialog dialog,      EditText edit){
        String title=edit.getText().toString();
        if (db.containsPlaylist(title)) {
          UiUtils.showTextToast(context,R.string.msg_existing_playlist);
          return;
        }
        long plid=db.insertPlaylist(title,""String_Node_Str"");
        if (plid < 0) {
          UiUtils.showTextToast(context,R.string.err_db_unknown);
          return;
        }
        action.onPlaylist(plid,user);
      }
    }
;
    AlertDialog diag=UiUtils.buildOneLineEditTextDialog(context,R.string.enter_playlist_title,R.string.enter_playlist_title,edAction);
    diag.show();
  }
 else   action.onPlaylist(ids[which],user);
}","@Override public void onClick(DialogInterface dialog,int which){
  eAssert(which >= 0);
  dialog.dismiss();
  if (userMenus.length > which) {
    action.onUserMenu(which,user);
  }
 else   if (userMenus.length == which) {
    UiUtils.EditTextAction edAction=new UiUtils.EditTextAction(){
      @Override public void prepare(      Dialog dialog,      EditText edit){
      }
      @Override public void onOk(      Dialog dialog,      EditText edit){
        String title=edit.getText().toString();
        if (db.containsPlaylist(title)) {
          UiUtils.showTextToast(context,R.string.msg_existing_playlist);
          return;
        }
        long plid=db.insertPlaylist(title,""String_Node_Str"");
        if (plid < 0) {
          UiUtils.showTextToast(context,R.string.err_db_unknown);
          return;
        }
        action.onPlaylist(plid,user);
      }
    }
;
    UiUtils.buildOneLineEditTextDialog(context,R.string.enter_playlist_title,R.string.enter_playlist_title,edAction).show();
  }
 else   action.onPlaylist(ids[which],user);
}",0.9872821479039096
110077,"public static AlertDialog buildSelectPlaylistDialog(final DB db,final Context context,final int diagTitle,final String[] userMenuStrings,final OnPlaylistSelectedListener action,long excludedPlid,final Object user){
  final String[] userMenus=(null == userMenuStrings) ? new String[0] : userMenuStrings;
  final Cursor c=db.queryPlaylist(new DB.ColPlaylist[]{DB.ColPlaylist.ID,DB.ColPlaylist.TITLE});
  final int iTitle=c.getColumnIndex(DB.ColPlaylist.TITLE.getName());
  final int iId=c.getColumnIndex(DB.ColPlaylist.ID.getName());
  LinkedList<String> menul=new LinkedList<String>();
  LinkedList<Long> idl=new LinkedList<Long>();
  for (int i=0; i < userMenus.length; i++) {
    menul.add(userMenus[i]);
    idl.add((long)i);
  }
  menul.add(context.getResources().getText(R.string.new_playlist).toString());
  idl.add((long)userMenus.length);
  if (c.moveToFirst()) {
    do {
      if (excludedPlid != c.getLong(iId)) {
        menul.add(c.getString(iTitle));
        idl.add(c.getLong(iId));
      }
    }
 while (c.moveToNext());
  }
  c.close();
  final String[] menus=menul.toArray(new String[0]);
  final long[] ids=Utils.convertArrayLongTolong(idl.toArray(new Long[0]));
  AlertDialog.Builder bldr=new AlertDialog.Builder(context);
  if (diagTitle > 0)   bldr.setTitle(diagTitle);
  ArrayAdapter<String> adapter=new ArrayAdapter<String>(context,android.R.layout.select_dialog_item,menus);
  bldr.setAdapter(adapter,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      eAssert(which >= 0);
      dialog.dismiss();
      if (userMenus.length > which) {
        action.onUserMenu(which,user);
      }
 else       if (userMenus.length == which) {
        UiUtils.EditTextAction edAction=new UiUtils.EditTextAction(){
          @Override public void prepare(          Dialog dialog,          EditText edit){
          }
          @Override public void onOk(          Dialog dialog,          EditText edit){
            String title=edit.getText().toString();
            if (db.containsPlaylist(title)) {
              UiUtils.showTextToast(context,R.string.msg_existing_playlist);
              return;
            }
            long plid=db.insertPlaylist(title,""String_Node_Str"");
            if (plid < 0) {
              UiUtils.showTextToast(context,R.string.err_db_unknown);
              return;
            }
            action.onPlaylist(plid,user);
          }
        }
;
        AlertDialog diag=UiUtils.buildOneLineEditTextDialog(context,R.string.enter_playlist_title,R.string.enter_playlist_title,edAction);
        diag.show();
      }
 else       action.onPlaylist(ids[which],user);
    }
  }
);
  return bldr.create();
}","public static AlertDialog buildSelectPlaylistDialog(final DB db,final Context context,final int diagTitle,final String[] userMenuStrings,final OnPlaylistSelectedListener action,long excludedPlid,final Object user){
  final String[] userMenus=(null == userMenuStrings) ? new String[0] : userMenuStrings;
  final Cursor c=db.queryPlaylist(new DB.ColPlaylist[]{DB.ColPlaylist.ID,DB.ColPlaylist.TITLE});
  final int iTitle=c.getColumnIndex(DB.ColPlaylist.TITLE.getName());
  final int iId=c.getColumnIndex(DB.ColPlaylist.ID.getName());
  LinkedList<String> menul=new LinkedList<String>();
  LinkedList<Long> idl=new LinkedList<Long>();
  for (int i=0; i < userMenus.length; i++) {
    menul.add(userMenus[i]);
    idl.add((long)i);
  }
  menul.add(context.getResources().getText(R.string.new_playlist).toString());
  idl.add((long)userMenus.length);
  if (c.moveToFirst()) {
    do {
      if (excludedPlid != c.getLong(iId)) {
        menul.add(c.getString(iTitle));
        idl.add(c.getLong(iId));
      }
    }
 while (c.moveToNext());
  }
  c.close();
  final String[] menus=menul.toArray(new String[0]);
  final long[] ids=Utils.convertArrayLongTolong(idl.toArray(new Long[0]));
  AlertDialog.Builder bldr=new AlertDialog.Builder(context);
  if (diagTitle > 0)   bldr.setTitle(diagTitle);
  ArrayAdapter<String> adapter=new ArrayAdapter<String>(context,android.R.layout.select_dialog_item,menus);
  bldr.setAdapter(adapter,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      eAssert(which >= 0);
      dialog.dismiss();
      if (userMenus.length > which) {
        action.onUserMenu(which,user);
      }
 else       if (userMenus.length == which) {
        UiUtils.EditTextAction edAction=new UiUtils.EditTextAction(){
          @Override public void prepare(          Dialog dialog,          EditText edit){
          }
          @Override public void onOk(          Dialog dialog,          EditText edit){
            String title=edit.getText().toString();
            if (db.containsPlaylist(title)) {
              UiUtils.showTextToast(context,R.string.msg_existing_playlist);
              return;
            }
            long plid=db.insertPlaylist(title,""String_Node_Str"");
            if (plid < 0) {
              UiUtils.showTextToast(context,R.string.err_db_unknown);
              return;
            }
            action.onPlaylist(plid,user);
          }
        }
;
        UiUtils.buildOneLineEditTextDialog(context,R.string.enter_playlist_title,R.string.enter_playlist_title,edAction).show();
      }
 else       action.onPlaylist(ids[which],user);
    }
  }
);
  return bldr.create();
}",0.9942518078991284
110078,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.videoplayer);
  getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
  mSurfv=(SurfaceView)findViewById(R.id.surface);
  mMp.setSurfaceHolder(mSurfv.getHolder());
  findViewById(R.id.touch_ground).setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      ViewGroup playerv=(ViewGroup)findViewById(R.id.player);
      if (View.GONE == playerv.getVisibility())       showController();
 else       hideController();
    }
  }
);
  mMp.addPlayerStateListener(this,this);
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.videoplayer);
  mSurfv=(SurfaceView)findViewById(R.id.surface);
  mMp.setSurfaceHolder(mSurfv.getHolder());
  findViewById(R.id.touch_ground).setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      ViewGroup playerv=(ViewGroup)findViewById(R.id.player);
      if (View.GONE == playerv.getVisibility())       showController();
 else       hideController();
    }
  }
);
  if (mMp.hasActiveVideo())   getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
  mMp.addPlayerStateListener(this,this);
  mMp.addVideosStateListener(this,this);
}",0.3272461650840029
110079,"@Override protected void onDestroy(){
  mMp.unsetSurfaceHolder(mSurfv.getHolder());
  mMp.removePlayerStateListener(this);
  super.onDestroy();
}","@Override protected void onDestroy(){
  mMp.unsetSurfaceHolder(mSurfv.getHolder());
  mMp.removePlayerStateListener(this);
  mMp.removeVideosStateListener(this);
  super.onDestroy();
}",0.8814589665653495
110080,"@Override public void onStateChanged(YTPlayer.MPState from,YTPlayer.MPState to){
switch (to) {
case IDLE:
    showLoadingSpinProgress();
  break;
case STOPPED:
case STARTED:
case PAUSED:
hideLoadingSpinProgress();
}
}","@Override public void onStateChanged(YTPlayer.MPState from,YTPlayer.MPState to){
switch (to) {
case IDLE:
    showLoadingSpinProgress();
  break;
case PREPARED:
case STOPPED:
case ERROR:
hideLoadingSpinProgress();
break;
}
}",0.8934240362811792
110081,"private File getCachedVideo(String ytvid){
  return new File(Policy.APPDATA_CACHEDIR + ytvid + ""String_Node_Str"");
}","private static File getCachedVideo(String ytvid){
  return new File(getCachedVideoFilePath(ytvid,Utils.getPrefQuality()));
}",0.625
110082,"private void cleanCache(boolean allClear){
  if (!mVlm.hasActiveVideo())   return;
  HashSet<String> skipSet=new HashSet<String>();
  if (!allClear) {
    skipSet.add(sCacheDir.getAbsolutePath());
    skipSet.add(getCachedVideo(mVlm.getActiveVideo().videoId).getAbsolutePath());
    Video nextVid=mVlm.getNextVideo();
    if (null != nextVid)     skipSet.add(getCachedVideo(nextVid.videoId).getAbsolutePath());
  }
  Utils.removeFileRecursive(sCacheDir,skipSet);
}","private void cleanCache(boolean allClear){
  if (!mVlm.hasActiveVideo())   return;
  HashSet<String> skipSet=new HashSet<String>();
  if (!allClear) {
    skipSet.add(sCacheDir.getAbsolutePath());
    for (    Utils.PrefQuality pq : Utils.PrefQuality.values()) {
      skipSet.add(new File(getCachedVideoFilePath(mVlm.getActiveVideo().videoId,pq)).getAbsolutePath());
      Video nextVid=mVlm.getNextVideo();
      if (null != nextVid)       skipSet.add(new File(getCachedVideoFilePath(nextVid.videoId,pq)).getAbsolutePath());
    }
  }
  Utils.removeFileRecursive(sCacheDir,skipSet);
}",0.8304761904761905
110083,"private void prepareCachedVideo(File cachedVid){
  logI(""String_Node_Str"" + cachedVid.getAbsolutePath());
  try {
    mpSetDataSource(cachedVid.getAbsolutePath());
    mpSetVideoSurface(mSurfHolder);
  }
 catch (  IOException e) {
    cleanCache(true);
    logW(""String_Node_Str"" + e.getMessage());
    mStartVideoRecovery.executeRecoveryStart(mVlm.getActiveVideo());
  }
  mpPrepareAsync();
  prepareNext();
}","private void prepareCachedVideo(File cachedVid){
  logI(""String_Node_Str"" + cachedVid.getAbsolutePath());
  try {
    mpSetDataSource(cachedVid.getAbsolutePath());
  }
 catch (  IOException e) {
    cleanCache(true);
    logW(""String_Node_Str"" + e.getMessage());
    mStartVideoRecovery.executeRecoveryStart(mVlm.getActiveVideo());
    return;
  }
  final MediaPlayer mp=mpGet();
  Utils.getUiHandler().post(new Runnable(){
    private int retry=20;
    @Override public void run(){
      if (mp != mpGet())       return;
      if (retry < 0) {
        logW(""String_Node_Str"");
        mpStop();
        return;
      }
      if (null == mSurfHolder || isSurfaceReady()) {
        mpSetVideoSurface(mSurfHolder);
        mpPrepareAsync();
      }
 else {
        --retry;
        Utils.getUiHandler().postDelayed(this,100);
      }
    }
  }
);
  prepareNext();
}",0.584446190102121
110084,"@Override protected void onDestroy(){
  mMp.unsetController(this);
  super.onDestroy();
}","@Override protected void onDestroy(){
  super.onDestroy();
}",0.8053691275167785
110085,"@Override protected void onPause(){
  mMp.unsetController(this);
  super.onPause();
}","@Override protected void onPause(){
  mMp.backupPlayerState();
  mMp.unsetController(this);
  super.onPause();
}",0.8629441624365483
110086,"private void storePlayerState(){
  if (null == mMp)   return;
  clearStoredPlayerState();
switch (mpGetState()) {
case STARTED:
case PAUSED:
    mStoredPState=new PlayerState();
  mStoredPState.pos=mpGetCurrentPosition();
mStoredPState.vol=mpGetVolume();
mStoredPState.mpState=mpGetState();
break;
}
}","private void storePlayerState(){
  if (null == mMp)   return;
  clearStoredPlayerState();
switch (mpGetState()) {
case STARTED:
case PAUSED:
    mStoredPState=new PlayerState();
  mStoredPState.vidobj=mVlm.getActiveVideo();
mStoredPState.pos=mpGetCurrentPosition();
mStoredPState.vol=mpGetVolume();
mStoredPState.mpState=mpGetState();
break;
}
}",0.9318885448916407
110087,"private void setVideoSurface(SurfaceView surfv){
  if (null == surfv)   return;
  SurfaceHolder holder=(null == surfv) ? null : surfv.getHolder();
  mpSetVideoSurface(holder);
  int vw=mpGetVideoWidth();
  int vh=mpGetVideoHeight();
  if (0 >= vw || 0 >= vh)   return;
  int sw=((WindowManager)Utils.getAppContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getWidth();
  int sh=((WindowManager)Utils.getAppContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getHeight();
  int[] sz=new int[2];
  Utils.fitFixedRatio(sw,sh,vw,vh,sz);
  ViewGroup.LayoutParams lp=surfv.getLayoutParams();
  lp.width=sz[0];
  lp.height=sz[1];
  surfv.setLayoutParams(lp);
  surfv.requestLayout();
}","private void setVideoSurface(SurfaceView surfv){
  if (null == surfv)   return;
  SurfaceHolder holder=(null == surfv) ? null : surfv.getHolder();
  int vw=mpGetVideoWidth();
  int vh=mpGetVideoHeight();
  if (0 >= vw || 0 >= vh)   return;
  int sw=((WindowManager)Utils.getAppContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getWidth();
  int sh=((WindowManager)Utils.getAppContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getHeight();
  int[] sz=new int[2];
  Utils.fitFixedRatio(sw,sh,vw,vh,sz);
  ViewGroup.LayoutParams lp=surfv.getLayoutParams();
  lp.width=sz[0];
  lp.height=sz[1];
  surfv.setLayoutParams(lp);
  surfv.requestLayout();
  mpSetVideoSurface(holder);
}",0.9596662030598052
110088,"private void restorePlayerState(){
  if (!haveStoredPlayerState())   return;
  mpSeekTo(mStoredPState.pos);
  mpSetVolume(mStoredPState.vol);
  clearStoredPlayerState();
}","private void restorePlayerState(){
  if (!haveStoredPlayerState())   return;
  if (mVlm.getActiveVideo() == mStoredPState.vidobj) {
    mpSeekTo(mStoredPState.pos);
    mpSetVolume(mStoredPState.vol);
  }
  clearStoredPlayerState();
}",0.8444444444444444
110089,"@Override public void onClick(View v){
  if (!mMp.hasActiveVideo() || null == mVActivity)   return;
  mMp.prepareTransitionMPMode();
  mVActivity.startActivity(new Intent(mVActivity,VideoPlayerActivity.class));
}","@Override public void onClick(View v){
  if (!mMp.hasActiveVideo() || null == mVActivity)   return;
  mMp.backupPlayerState();
  mVActivity.startActivity(new Intent(mVActivity,VideoPlayerActivity.class));
}",0.9138755980861244
110090,"private void pvSetupControlButton(final ViewGroup playerv){
  ImageView btn=(ImageView)playerv.findViewById(R.id.mplayer_btnplay);
  btn.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      YTPlayer.MPState nextst=(YTPlayer.MPState)v.getTag();
      if (null == nextst)       return;
switch (nextst) {
case STARTED:
        mMp.playerStart();
      break;
case PAUSED:
    mMp.playerPause();
  break;
case STOPPED:
mMp.stopVideos();
break;
default :
;
}
}
}
);
btn=(ImageView)playerv.findViewById(R.id.mplayer_btnprev);
btn.setOnClickListener(new View.OnClickListener(){
@Override public void onClick(View v){
mMp.startPrevVideo();
pvDisableControlButton(playerv);
}
}
);
btn=(ImageView)playerv.findViewById(R.id.mplayer_btnnext);
btn.setOnClickListener(new View.OnClickListener(){
@Override public void onClick(View v){
mMp.startNextVideo();
pvDisableControlButton(playerv);
}
}
);
btn=(ImageView)playerv.findViewById(R.id.mplayer_btnvol);
btn.setOnClickListener(new View.OnClickListener(){
@Override public void onClick(View v){
if (!mMp.hasActiveVideo()) return;
changeVideoVolume(mMp.getActiveVideo().title,mMp.getActiveVideo().videoId);
}
}
);
btn=(ImageView)playerv.findViewById(R.id.mplayer_btnextra);
View.OnClickListener onClick;
if (null == mCustomExtraBtn) {
btn.setImageResource(R.drawable.ic_media_video);
onClick=new View.OnClickListener(){
@Override public void onClick(View v){
if (!mMp.hasActiveVideo() || null == mVActivity) return;
mMp.prepareTransitionMPMode();
mVActivity.startActivity(new Intent(mVActivity,VideoPlayerActivity.class));
}
}
;
}
 else {
btn.setImageResource(mCustomExtraBtn.mDrawable);
onClick=mCustomExtraBtn.mExtraBtnClick;
}
btn.setOnClickListener(onClick);
if (null != mSurfacev) btn.setVisibility(View.GONE);
}","private void pvSetupControlButton(final ViewGroup playerv){
  ImageView btn=(ImageView)playerv.findViewById(R.id.mplayer_btnplay);
  btn.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      YTPlayer.MPState nextst=(YTPlayer.MPState)v.getTag();
      if (null == nextst)       return;
switch (nextst) {
case STARTED:
        mMp.playerStart();
      break;
case PAUSED:
    mMp.playerPause();
  break;
case STOPPED:
mMp.stopVideos();
break;
default :
;
}
}
}
);
btn=(ImageView)playerv.findViewById(R.id.mplayer_btnprev);
btn.setOnClickListener(new View.OnClickListener(){
@Override public void onClick(View v){
mMp.startPrevVideo();
pvDisableControlButton(playerv);
}
}
);
btn=(ImageView)playerv.findViewById(R.id.mplayer_btnnext);
btn.setOnClickListener(new View.OnClickListener(){
@Override public void onClick(View v){
mMp.startNextVideo();
pvDisableControlButton(playerv);
}
}
);
btn=(ImageView)playerv.findViewById(R.id.mplayer_btnvol);
btn.setOnClickListener(new View.OnClickListener(){
@Override public void onClick(View v){
if (!mMp.hasActiveVideo()) return;
changeVideoVolume(mMp.getActiveVideo().title,mMp.getActiveVideo().videoId);
}
}
);
btn=(ImageView)playerv.findViewById(R.id.mplayer_btnextra);
View.OnClickListener onClick;
if (null == mCustomExtraBtn) {
btn.setImageResource(R.drawable.ic_media_video);
onClick=new View.OnClickListener(){
@Override public void onClick(View v){
if (!mMp.hasActiveVideo() || null == mVActivity) return;
mMp.backupPlayerState();
mVActivity.startActivity(new Intent(mVActivity,VideoPlayerActivity.class));
}
}
;
}
 else {
btn.setImageResource(mCustomExtraBtn.mDrawable);
onClick=mCustomExtraBtn.mExtraBtnClick;
}
btn.setOnClickListener(onClick);
if (null != mSurfacev) btn.setVisibility(View.GONE);
}",0.989977728285078
110091,"private void pvInit(ViewGroup playerv,ViewGroup playerLDrawer,SurfaceView surfacev){
  mMp.addPlayerStateListener(this,new YTPlayer.PlayerStateListener(){
    @Override public void onStateChanged(    YTPlayer.MPState from,    YTPlayer.MPState to){
      pvConfigureAll(mPlayerv,mPlayerLDrawer,from,to);
      notiConfigure(from,to);
    }
    @Override public void onBufferingChanged(    int percent){
      mUpdateProg.updateSecondary(percent);
    }
  }
);
  ViewGroup progv=(ViewGroup)playerv.findViewById(R.id.mplayer_progress);
  SeekBar sb=(SeekBar)progv.findViewById(R.id.mplayer_seekbar);
  sb.setMax(SEEKBAR_MAX);
  sb.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
    @Override public void onStopTrackingTouch(    SeekBar seekBar){
      mMp.playerSeekTo((int)(seekBar.getProgress() * (long)mMp.playerGetDuration() / SEEKBAR_MAX));
    }
    @Override public void onStartTrackingTouch(    SeekBar seekBar){
    }
    @Override public void onProgressChanged(    SeekBar seekBar,    int progress,    boolean fromUser){
    }
  }
);
  mUpdateProg.setProgressView(progv);
  if (null != playerLDrawer) {
    mMp.addVideosStateListener(this,new YTPlayer.VideosStateListener(){
      @Override public void onStopped(      YTPlayer.StopState state){
        boolean needToNotification=true;
        CharSequence msg=""String_Node_Str"";
switch (state) {
case DONE:
          needToNotification=false;
        msg=mRes.getText(R.string.msg_playing_done);
      break;
case FORCE_STOPPED:
    needToNotification=false;
  msg=mRes.getText(R.string.msg_playing_stopped);
break;
case NETWORK_UNAVAILABLE:
msg=mRes.getText(R.string.err_network_unavailable);
break;
case UNKNOWN_ERROR:
msg=mRes.getText(R.string.msg_playing_err_unknown);
break;
}
if (null != mPlayerv) {
TextView titlev=(TextView)mPlayerv.findViewById(R.id.mplayer_title);
pvSetTitle(titlev,mRes.getText(R.string.msg_playing_done));
}
if (needToNotification) NotiManager.get().putNotification(NotiManager.NotiType.ALERT,(String)msg);
}
@Override public void onStarted(){
eAssert(null != mPlayerv);
pvEnableLDrawer(mPlayerLDrawer);
}
@Override public void onChanged(){
if (null != mPlayerv) pvConfigureControl((ViewGroup)mPlayerv.findViewById(R.id.mplayer_control),mMp.playerGetState(),mMp.playerGetState());
if (null == mPlayerLDrawer) return;
if (mMp.hasActiveVideo()) {
ListView lv=(ListView)mPlayerLDrawer.findViewById(R.id.mplayer_list);
YTPlayerVidArrayAdapter adapter=(YTPlayerVidArrayAdapter)lv.getAdapter();
if (null != adapter) {
adapter.setVidArray(mMp.getVideoList());
adapter.notifyDataSetChanged();
}
}
 else pvDisableLDrawer(mPlayerLDrawer);
}
}
);
final SlidingDrawer drawer=(SlidingDrawer)playerLDrawer.findViewById(R.id.mplayer_ldrawer);
drawer.setOnDrawerOpenListener(new SlidingDrawer.OnDrawerOpenListener(){
@Override public void onDrawerOpened(){
if (!mMp.hasActiveVideo()) return;
ListView lv=(ListView)mPlayerLDrawer.findViewById(R.id.mplayer_list);
int topPos=mMp.getActiveVideoIndex() - 1;
if (topPos < 0) topPos=0;
lv.setSelectionFromTop(topPos,0);
}
}
);
}
pvEnableLDrawer(playerLDrawer);
pvSetupControlButton(playerv);
pvConfigureAll(playerv,playerLDrawer,YTPlayer.MPState.INVALID,mMp.playerGetState());
}","private void pvInit(ViewGroup playerv,ViewGroup playerLDrawer,SurfaceView surfacev){
  mMp.addPlayerStateListener(this,new YTPlayer.PlayerStateListener(){
    @Override public void onStateChanged(    YTPlayer.MPState from,    YTPlayer.MPState to){
      pvConfigureAll(mPlayerv,mPlayerLDrawer,from,to);
      notiConfigure(from,to);
    }
    @Override public void onBufferingChanged(    int percent){
      mUpdateProg.updateSecondary(percent);
    }
  }
);
  ViewGroup progv=(ViewGroup)playerv.findViewById(R.id.mplayer_progress);
  SeekBar sb=(SeekBar)progv.findViewById(R.id.mplayer_seekbar);
  sb.setMax(SEEKBAR_MAX);
  sb.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
    @Override public void onStopTrackingTouch(    SeekBar seekBar){
      mMp.playerSeekTo((int)(seekBar.getProgress() * (long)mMp.playerGetDuration() / SEEKBAR_MAX));
    }
    @Override public void onStartTrackingTouch(    SeekBar seekBar){
    }
    @Override public void onProgressChanged(    SeekBar seekBar,    int progress,    boolean fromUser){
    }
  }
);
  mUpdateProg.setProgressView(progv);
  if (null != playerLDrawer) {
    mMp.addVideosStateListener(this,new YTPlayer.VideosStateListener(){
      @Override public void onStopped(      YTPlayer.StopState state){
        boolean needToNotification=true;
        CharSequence msg=""String_Node_Str"";
switch (state) {
case DONE:
          needToNotification=false;
        msg=mRes.getText(R.string.msg_playing_done);
      break;
case FORCE_STOPPED:
    needToNotification=false;
  msg=mRes.getText(R.string.msg_playing_stopped);
break;
case NETWORK_UNAVAILABLE:
msg=mRes.getText(R.string.err_network_unavailable);
break;
case UNKNOWN_ERROR:
msg=mRes.getText(R.string.msg_playing_err_unknown);
break;
}
if (null != mPlayerv) {
TextView titlev=(TextView)mPlayerv.findViewById(R.id.mplayer_title);
pvSetTitle(titlev,mRes.getText(R.string.msg_playing_done));
}
if (needToNotification) NotiManager.get().putNotification(NotiManager.NotiType.ALERT,(String)msg);
}
@Override public void onStarted(){
eAssert(null != mPlayerv);
pvEnableLDrawer(mPlayerLDrawer);
}
@Override public void onChanged(){
if (null != mPlayerv) pvConfigureControl((ViewGroup)mPlayerv.findViewById(R.id.mplayer_control),mMp.playerGetState(),mMp.playerGetState());
if (null == mPlayerLDrawer) return;
if (mMp.hasActiveVideo()) {
ListView lv=(ListView)mPlayerLDrawer.findViewById(R.id.mplayer_list);
YTPlayerVidArrayAdapter adapter=(YTPlayerVidArrayAdapter)lv.getAdapter();
if (null != adapter) {
adapter.setVidArray(mMp.getVideoList());
adapter.notifyDataSetChanged();
}
}
 else pvDisableLDrawer(mPlayerLDrawer);
}
}
);
final SlidingDrawer drawer=(SlidingDrawer)playerLDrawer.findViewById(R.id.mplayer_ldrawer);
drawer.setOnDrawerOpenListener(new SlidingDrawer.OnDrawerOpenListener(){
@Override public void onDrawerOpened(){
if (!mMp.hasActiveVideo()) return;
ListView lv=(ListView)mPlayerLDrawer.findViewById(R.id.mplayer_list);
int topPos=mMp.getActiveVideoIndex() - 1;
if (topPos < 0) topPos=0;
lv.setSelectionFromTop(topPos,0);
}
}
);
}
pvEnableLDrawer(playerLDrawer);
pvSetupControlButton(playerv);
mUpdateProg.update(mMp.playerGetDuration(),mMp.playerGetPosition());
pvConfigureAll(playerv,playerLDrawer,YTPlayer.MPState.INVALID,mMp.playerGetState());
}",0.989376443418014
110092,"private void pvConfigureTitle(TextView titlev,YTPlayer.MPState from,YTPlayer.MPState to){
  if (null == titlev)   return;
  CharSequence videoTitle=""String_Node_Str"";
  if (mMp.hasActiveVideo())   videoTitle=mMp.getActiveVideo().title;
switch (to) {
case BUFFERING:
{
      eAssert(null != videoTitle);
      pvSetTitle(titlev,""String_Node_Str"" + mRes.getText(R.string.buffering) + ""String_Node_Str""+ videoTitle);
    }
  break;
case PREPARED:
case PAUSED:
case STARTED:
eAssert(null != videoTitle);
if (null != videoTitle) pvSetTitle(titlev,videoTitle);
break;
case ERROR:
pvSetTitle(titlev,mRes.getText(R.string.msg_ytplayer_err));
break;
default :
if (Utils.isValidValue(videoTitle)) pvSetTitle(titlev,""String_Node_Str"" + mRes.getText(R.string.preparing) + ""String_Node_Str""+ videoTitle);
 else pvSetTitle(titlev,mRes.getText(R.string.msg_preparing_mplayer));
}
}","private void pvConfigureTitle(TextView titlev,YTPlayer.MPState from,YTPlayer.MPState to){
  if (null == titlev)   return;
  CharSequence videoTitle=""String_Node_Str"";
  if (mMp.hasActiveVideo())   videoTitle=mMp.getActiveVideo().title;
switch (to) {
case BUFFERING:
{
      eAssert(null != videoTitle);
      pvSetTitle(titlev,""String_Node_Str"" + mRes.getText(R.string.buffering) + ""String_Node_Str""+ videoTitle);
    }
  break;
case PREPARED:
case PAUSED:
case STARTED:
eAssert(null != videoTitle);
if (null != videoTitle) pvSetTitle(titlev,videoTitle);
break;
case ERROR:
pvSetTitle(titlev,mRes.getText(R.string.msg_ytplayer_err));
break;
default :
if (Utils.isValidValue(videoTitle)) pvSetTitle(titlev,""String_Node_Str"" + mRes.getText(R.string.preparing) + ""String_Node_Str""+ videoTitle);
 else pvSetTitle(titlev,""String_Node_Str"");
}
}",0.9642228739002932
110093,"private void prepareVideoStreaming(final String videoId){
  logI(""String_Node_Str"" + videoId);
  YTHacker.YtHackListener listener=new YTHacker.YtHackListener(){
    @Override public void onPreHack(    YTHacker ythack,    String ytvid,    Object user){
    }
    @Override public void onPostHack(    final YTHacker ythack,    Err result,    final NetLoader loader,    String ytvid,    Object user){
      if (mYtHack != ythack) {
        logD(""String_Node_Str"");
        loader.close();
        return;
      }
      mYtHack=null;
      if (null != mLoader)       mLoader.close();
      mLoader=loader;
      if (Err.NO_ERR != result) {
        logW(""String_Node_Str"" + result.name());
        mStartVideoRecovery.executeRecoveryStart(mVlm.getActiveVideo());
        return;
      }
      YTHacker.YtVideo ytv=ythack.getVideo(getVideoQualityScore());
      try {
        mpSetDataSource(Uri.parse(ytv.url));
      }
 catch (      IOException e) {
        logW(""String_Node_Str"" + e.getMessage());
        mStartVideoRecovery.executeRecoveryStart(mVlm.getActiveVideo(),500);
        return;
      }
      new Thread(new Runnable(){
        @Override public void run(){
          mDb.updateVideo(DB.ColVideo.VIDEOID,videoId,DB.ColVideo.TIME_PLAYED,System.currentTimeMillis());
        }
      }
).start();
      mpPrepareAsync();
    }
    @Override public void onHackCancelled(    YTHacker ythack,    String ytvid,    Object user){
      if (mYtHack != ythack) {
        logD(""String_Node_Str"");
        return;
      }
      mYtHack=null;
    }
  }
;
  mYtHack=new YTHacker(videoId,null,listener);
  mYtHack.startAsync();
}","private void prepareVideoStreaming(final String videoId){
  logI(""String_Node_Str"" + videoId);
  YTHacker.YtHackListener listener=new YTHacker.YtHackListener(){
    @Override public void onPreHack(    YTHacker ythack,    String ytvid,    Object user){
    }
    @Override public void onPostHack(    final YTHacker ythack,    Err result,    final NetLoader loader,    String ytvid,    Object user){
      if (mYtHack != ythack) {
        logD(""String_Node_Str"");
        loader.close();
        return;
      }
      mYtHack=null;
      if (null != mLoader)       mLoader.close();
      mLoader=loader;
      if (Err.NO_ERR != result) {
        logW(""String_Node_Str"" + result.name());
        mStartVideoRecovery.executeRecoveryStart(mVlm.getActiveVideo());
        return;
      }
      YTHacker.YtVideo ytv=ythack.getVideo(getVideoQualityScore());
      try {
        mpSetDataSource(Uri.parse(ytv.url));
      }
 catch (      IOException e) {
        logW(""String_Node_Str"" + e.getMessage());
        mStartVideoRecovery.executeRecoveryStart(mVlm.getActiveVideo(),500);
        return;
      }
      mpPrepareAsync();
    }
    @Override public void onHackCancelled(    YTHacker ythack,    String ytvid,    Object user){
      if (mYtHack != ythack) {
        logD(""String_Node_Str"");
        return;
      }
      mYtHack=null;
    }
  }
;
  mYtHack=new YTHacker(videoId,null,listener);
  mYtHack.startAsync();
}",0.9321922317314022
110094,"@Override public void onPostHack(final YTHacker ythack,Err result,final NetLoader loader,String ytvid,Object user){
  if (mYtHack != ythack) {
    logD(""String_Node_Str"");
    loader.close();
    return;
  }
  mYtHack=null;
  if (null != mLoader)   mLoader.close();
  mLoader=loader;
  if (Err.NO_ERR != result) {
    logW(""String_Node_Str"" + result.name());
    mStartVideoRecovery.executeRecoveryStart(mVlm.getActiveVideo());
    return;
  }
  YTHacker.YtVideo ytv=ythack.getVideo(getVideoQualityScore());
  try {
    mpSetDataSource(Uri.parse(ytv.url));
  }
 catch (  IOException e) {
    logW(""String_Node_Str"" + e.getMessage());
    mStartVideoRecovery.executeRecoveryStart(mVlm.getActiveVideo(),500);
    return;
  }
  new Thread(new Runnable(){
    @Override public void run(){
      mDb.updateVideo(DB.ColVideo.VIDEOID,videoId,DB.ColVideo.TIME_PLAYED,System.currentTimeMillis());
    }
  }
).start();
  mpPrepareAsync();
}","@Override public void onPostHack(final YTHacker ythack,Err result,final NetLoader loader,String ytvid,Object user){
  if (mYtHack != ythack) {
    logD(""String_Node_Str"");
    loader.close();
    return;
  }
  mYtHack=null;
  if (null != mLoader)   mLoader.close();
  mLoader=loader;
  if (Err.NO_ERR != result) {
    logW(""String_Node_Str"" + result.name());
    mStartVideoRecovery.executeRecoveryStart(mVlm.getActiveVideo());
    return;
  }
  YTHacker.YtVideo ytv=ythack.getVideo(getVideoQualityScore());
  try {
    mpSetDataSource(Uri.parse(ytv.url));
  }
 catch (  IOException e) {
    logW(""String_Node_Str"" + e.getMessage());
    mStartVideoRecovery.executeRecoveryStart(mVlm.getActiveVideo(),500);
    return;
  }
  mpPrepareAsync();
}",0.8888888888888888
110095,"public void unsetController(Context context){
  if (context == mVContext) {
    mPlayerv=null;
    mVContext=null;
    mVlm.clearOnListChangedListener();
  }
}","public void unsetController(Context context){
  if (context == mVContext) {
    mPlayerv=null;
    mVContext=null;
    mPlayerDrawer=null;
    mVlm.clearOnListChangedListener();
  }
}",0.9298245614035088
110096,"private void pvEnableDrawer(ViewGroup playerDrawer){
  if (null == playerDrawer || !mVlm.hasActiveVideo())   return;
  eAssert(null != mVContext);
  ListView lv=(ListView)playerDrawer.findViewById(R.id.music_player_drawer_content);
  playerDrawer.setVisibility(View.VISIBLE);
  lv=(ListView)playerDrawer.findViewById(R.id.music_player_drawer_content);
  YTPlayerVidArrayAdapter adapter=new YTPlayerVidArrayAdapter(mVContext,mVlm.getVideoList());
  adapter.setActiveItem(mVlm.getActiveVideoIndex());
  lv.setAdapter(adapter);
}","private void pvEnableDrawer(ViewGroup playerDrawer){
  if (null == playerDrawer || !mVlm.hasActiveVideo())   return;
  eAssert(null != mVContext);
  ListView lv=(ListView)playerDrawer.findViewById(R.id.music_player_drawer_content);
  SlidingDrawer drawer=(SlidingDrawer)playerDrawer.findViewById(R.id.music_player_sliding_drawer);
  playerDrawer.setVisibility(View.VISIBLE);
  lv=(ListView)playerDrawer.findViewById(R.id.music_player_drawer_content);
  YTPlayerVidArrayAdapter adapter=new YTPlayerVidArrayAdapter(mVContext,mVlm.getVideoList());
  adapter.setActiveItem(mVlm.getActiveVideoIndex());
  lv.setAdapter(adapter);
  drawer.close();
}",0.8999144568006844
110097,"private void pvInit(ViewGroup playerv,ViewGroup playerDrawer){
  ViewGroup progv=(ViewGroup)playerv.findViewById(R.id.music_player_progress);
  SeekBar sb=(SeekBar)progv.findViewById(R.id.music_player_seekbar);
  sb.setMax(SEEKBAR_MAX);
  sb.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
    @Override public void onStopTrackingTouch(    SeekBar seekBar){
      mpSeekTo((int)((long)seekBar.getProgress() * (long)mpGetDuration() / SEEKBAR_MAX));
    }
    @Override public void onStartTrackingTouch(    SeekBar seekBar){
    }
    @Override public void onProgressChanged(    SeekBar seekBar,    int progress,    boolean fromUser){
    }
  }
);
  mUpdateProg.setProgressView(progv);
  if (null != playerDrawer) {
    mVlm.setOnListChangedListener(new VideoListManager.OnListChangedListener(){
      @Override public void onListChanged(      VideoListManager vlm){
        if (null == mPlayerDrawer)         return;
        if (mVlm.hasActiveVideo()) {
          ListView lv=(ListView)mPlayerDrawer.findViewById(R.id.music_player_drawer_content);
          YTPlayerVidArrayAdapter adapter=(YTPlayerVidArrayAdapter)lv.getAdapter();
          if (null != adapter) {
            adapter.setVidArray(mVlm.getVideoList());
            adapter.notifyDataSetChanged();
          }
        }
 else         pvDisableDrawer(mPlayerDrawer);
      }
    }
);
    SlidingDrawer drawer=(SlidingDrawer)playerDrawer.findViewById(R.id.music_player_sliding_drawer);
    drawer.setOnDrawerOpenListener(new SlidingDrawer.OnDrawerOpenListener(){
      @Override public void onDrawerOpened(){
        if (!mVlm.hasActiveVideo())         return;
        ListView lv=(ListView)mPlayerDrawer.findViewById(R.id.music_player_drawer_content);
        int topPos=mVlm.getActiveVideoIndex() - 1;
        if (topPos < 0)         topPos=0;
        lv.setSelectionFromTop(topPos,0);
      }
    }
);
  }
  pvSetupControlButton(playerv);
  pvConfigureAll(playerv,playerDrawer,MPState.INVALID,mpGetState());
}","private void pvInit(ViewGroup playerv,ViewGroup playerDrawer){
  ViewGroup progv=(ViewGroup)playerv.findViewById(R.id.music_player_progress);
  SeekBar sb=(SeekBar)progv.findViewById(R.id.music_player_seekbar);
  sb.setMax(SEEKBAR_MAX);
  sb.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
    @Override public void onStopTrackingTouch(    SeekBar seekBar){
      mpSeekTo((int)((long)seekBar.getProgress() * (long)mpGetDuration() / SEEKBAR_MAX));
    }
    @Override public void onStartTrackingTouch(    SeekBar seekBar){
    }
    @Override public void onProgressChanged(    SeekBar seekBar,    int progress,    boolean fromUser){
    }
  }
);
  mUpdateProg.setProgressView(progv);
  if (null != playerDrawer) {
    mVlm.setOnListChangedListener(new VideoListManager.OnListChangedListener(){
      @Override public void onListChanged(      VideoListManager vlm){
        if (null == mPlayerDrawer)         return;
        if (mVlm.hasActiveVideo()) {
          ListView lv=(ListView)mPlayerDrawer.findViewById(R.id.music_player_drawer_content);
          YTPlayerVidArrayAdapter adapter=(YTPlayerVidArrayAdapter)lv.getAdapter();
          if (null != adapter) {
            adapter.setVidArray(mVlm.getVideoList());
            adapter.notifyDataSetChanged();
          }
        }
 else         pvDisableDrawer(mPlayerDrawer);
      }
    }
);
    SlidingDrawer drawer=(SlidingDrawer)playerDrawer.findViewById(R.id.music_player_sliding_drawer);
    drawer.setOnDrawerOpenListener(new SlidingDrawer.OnDrawerOpenListener(){
      @Override public void onDrawerOpened(){
        if (!mVlm.hasActiveVideo())         return;
        ListView lv=(ListView)mPlayerDrawer.findViewById(R.id.music_player_drawer_content);
        int topPos=mVlm.getActiveVideoIndex() - 1;
        if (topPos < 0)         topPos=0;
        lv.setSelectionFromTop(topPos,0);
      }
    }
);
  }
  pvEnableDrawer(playerDrawer);
  pvSetupControlButton(playerv);
  pvConfigureAll(playerv,playerDrawer,MPState.INVALID,mpGetState());
}",0.9920318725099602
110098,"private void adjustPageUserAction(){
  int lastPage=getLastPage();
  eAssert(mSearchSt.curPage >= 1 && mSearchSt.curPage <= lastPage);
  View barv=findViewById(R.id.bottombar);
  ImageView nextBtn=(ImageView)barv.findViewById(R.id.next);
  ImageView prevBtn=(ImageView)barv.findViewById(R.id.prev);
  prevBtn.setVisibility(View.VISIBLE);
  nextBtn.setVisibility(View.VISIBLE);
  if (1 == mSearchSt.curPage)   prevBtn.setVisibility(View.INVISIBLE);
  if (lastPage == mSearchSt.curPage)   nextBtn.setVisibility(View.INVISIBLE);
  LinearLayout ll=(LinearLayout)findViewById(R.id.indexgroup);
  ll.removeAllViews();
  int nrPages=mSearchSt.totalResults / NR_ENTRY_PER_PAGE + 1;
  int mini=mSearchSt.curPage - (Policy.YTSEARCH_NR_PAGE_INDEX / 2);
  if (mini < 1)   mini=1;
  int maxi=mini + Policy.YTSEARCH_NR_PAGE_INDEX - 1;
  if (maxi > nrPages)   maxi=nrPages;
  for (int i=mini; i <= maxi; i++) {
    int bi=i - mini;
    mPageBtnHolder[bi].setText(""String_Node_Str"" + i);
    mPageBtnHolder[bi].setTag(i);
    mPageBtnHolder[bi].setBackgroundResource(R.drawable.btnbg_normal);
    ll.addView(mPageBtnHolder[bi],mPageBtnLPHolder);
  }
  mPageBtnHolder[mSearchSt.curPage - mini].setBackgroundResource(R.drawable.btnbg_focused);
}","private void adjustPageUserAction(){
  int lastPage=getLastPage();
  eAssert(mSearchSt.curPage >= 1 && mSearchSt.curPage <= lastPage);
  View barv=findViewById(R.id.bottombar);
  ImageView nextBtn=(ImageView)barv.findViewById(R.id.next);
  ImageView prevBtn=(ImageView)barv.findViewById(R.id.prev);
  prevBtn.setVisibility(View.VISIBLE);
  nextBtn.setVisibility(View.VISIBLE);
  if (1 == mSearchSt.curPage)   prevBtn.setVisibility(View.INVISIBLE);
  if (lastPage == mSearchSt.curPage)   nextBtn.setVisibility(View.INVISIBLE);
  LinearLayout ll=(LinearLayout)findViewById(R.id.indexgroup);
  ll.removeAllViews();
  int nrPages=mSearchSt.totalResults / NR_ENTRY_PER_PAGE + 1;
  int mini=mSearchSt.curPage - (Policy.YTSEARCH_NR_PAGE_INDEX / 2);
  if (mini < 1)   mini=1;
  int maxi=mini + Policy.YTSEARCH_NR_PAGE_INDEX - 1;
  if (maxi > nrPages) {
    maxi=nrPages;
    mini=maxi - Policy.YTSEARCH_NR_PAGE_INDEX + 1;
    if (mini < 1)     mini=1;
  }
  for (int i=mini; i <= maxi; i++) {
    int bi=i - mini;
    mPageBtnHolder[bi].setText(""String_Node_Str"" + i);
    mPageBtnHolder[bi].setTag(i);
    mPageBtnHolder[bi].setBackgroundResource(R.drawable.btnbg_normal);
    ll.addView(mPageBtnHolder[bi],mPageBtnLPHolder);
  }
  mPageBtnHolder[mSearchSt.curPage - mini].setBackgroundResource(R.drawable.btnbg_focused);
}",0.9650019661816752
110099,"@Override protected void onResume(){
  super.onResume();
  ViewGroup playerv=(ViewGroup)findViewById(R.id.player);
  mMp.setController(this,playerv);
  if (mMp.isVideoPlaying())   playerv.setVisibility(View.VISIBLE);
 else   playerv.setVisibility(View.GONE);
}","@Override protected void onResume(){
  super.onResume();
  ViewGroup playerv=(ViewGroup)findViewById(R.id.player);
  mMp.setController(this,playerv);
  if (mMp.hasActiveVideo())   playerv.setVisibility(View.VISIBLE);
 else   playerv.setVisibility(View.GONE);
}",0.946153846153846
110100,"@Override protected void onResume(){
  super.onResume();
  ViewGroup playerv=(ViewGroup)findViewById(R.id.player);
  mMp.setController(this,playerv);
  if (mMp.isVideoPlaying())   playerv.setVisibility(View.VISIBLE);
 else   playerv.setVisibility(View.GONE);
  if (mDb.isRegisteredToPlaylistTableWatcher(this) && mDb.isPlaylistTableUpdated(this))   getAdapter().reloadCursorAsync();
}","@Override protected void onResume(){
  super.onResume();
  ViewGroup playerv=(ViewGroup)findViewById(R.id.player);
  mMp.setController(this,playerv);
  if (mMp.hasActiveVideo())   playerv.setVisibility(View.VISIBLE);
 else   playerv.setVisibility(View.GONE);
  if (mDb.isRegisteredToPlaylistTableWatcher(this) && mDb.isPlaylistTableUpdated(this))   getAdapter().reloadCursorAsync();
}",0.9635416666666666
110101,"@Override protected void onResume(){
  super.onResume();
  ViewGroup playerv=(ViewGroup)findViewById(R.id.player);
  mMp.setController(this,playerv);
  if (mMp.isVideoPlaying())   playerv.setVisibility(View.VISIBLE);
 else   playerv.setVisibility(View.GONE);
}","@Override protected void onResume(){
  super.onResume();
  ViewGroup playerv=(ViewGroup)findViewById(R.id.player);
  mMp.setController(this,playerv);
  if (mMp.hasActiveVideo())   playerv.setVisibility(View.VISIBLE);
 else   playerv.setVisibility(View.GONE);
}",0.946153846153846
110102,"void pauseVideo(){
  if (isVideoPlaying())   mpPause();
}","void pauseVideo(){
  if (isVideoPlaying() && MPState.PREPARING != mpGetState())   mpPause();
}",0.7549668874172185
110103,"void startVideo(){
  if (isVideoPlaying())   mpStart();
}","void startVideo(){
  if (isVideoPlaying() && MPState.PREPARING != mpGetState())   mpStart();
}",0.7549668874172185
110104,"public boolean isVideoPlaying(){
  return mVlm.hasActiveVideo() && MPState.ERROR != mMpS && MPState.END != mMpS && MPState.PREPARING != mMpS;
}","private boolean isVideoPlaying(){
  return mVlm.hasActiveVideo() && MPState.ERROR != mMpS && MPState.END != mMpS;
}",0.8527131782945736
110105,"boolean hasActiveVideo(){
  return null != getActiveVideo();
}","public boolean hasActiveVideo(){
  return mVlm.hasActiveVideo();
}",0.8125
110106,"@Override public void onConnCancelled(YTVideoConnector ytconn,String ytvid,Object user){
  mYtConn=null;
}","void onConnCancelled(YTVideoConnector ytconn,String ytvid,Object user){
  if (mYtConn != ytconn) {
    logD(""String_Node_Str"");
    return;
  }
  mYtConn=null;
}",0.6666666666666666
110107,"private void startVideo(final String videoId,int volume,boolean recovery){
  eAssert(0 <= volume && volume <= 100);
  if (recovery) {
    mErrRetry--;
    if (mErrRetry <= 0) {
      stopPlay(StopState.UNKNOWN_ERROR);
      return;
    }
  }
 else   mErrRetry=PLAYER_ERR_RETRY;
  mpStop();
  mpRelease();
  mpNewInstance();
  mpReset();
  mpSetVolume(volume);
  YTVideoConnector.YtVideoConnListener listener=new YTVideoConnector.YtVideoConnListener(){
    @Override public void onPreConn(    YTVideoConnector ytconn,    String ytvid,    Object user){
    }
    @Override public void onPostConn(    YTVideoConnector ytconn,    Err result,    String ytvid,    Object user){
      mYtConn=null;
      if (Err.NO_ERR != result) {
        logW(""String_Node_Str"" + result.name());
        startVideo(mVlm.getActiveVideo(),true);
        return;
      }
      YTVideoConnector.YtVideo ytv=ytconn.getVideo(YTVideoConnector.YTQUALITY_SCORE_LOWEST);
      try {
        mpSetDataSource(Uri.parse(ytv.url));
      }
 catch (      IOException e) {
        eAssert(false);
      }
      mpPrepareAsync();
    }
    @Override public void onConnCancelled(    YTVideoConnector ytconn,    String ytvid,    Object user){
      mYtConn=null;
    }
  }
;
  mYtConn=new YTVideoConnector(videoId,volume,listener);
  mYtConn.execute();
}","private void startVideo(final String videoId,final int volume,boolean recovery){
}",0.1088825214899713
110108,"private void startNext(){
  if (!mVlm.hasActiveVideo())   return;
  if (mVlm.moveToNext())   startVideo(mVlm.getActiveVideo(),false);
 else   stopPlay(StopState.DONE);
}","void startNext(){
  if (!mVlm.hasActiveVideo())   return;
  if (mVlm.moveToNext())   startVideo(mVlm.getActiveVideo(),false);
 else   stopPlay(StopState.DONE);
}",0.9757575757575756
110109,"@Override public void onPrepared(MediaPlayer mp){
  logD(""String_Node_Str"");
  mpSetState(MPState.PREPARED);
  mpStart();
}","@Override public void onPrepared(MediaPlayer mp){
  if (mp != mpGet()) {
    logD(""String_Node_Str"");
    return;
  }
  logD(""String_Node_Str"");
  mpSetState(MPState.PREPARED);
  mpStart();
}",0.7834394904458599
110110,"private void initMediaPlayer(MediaPlayer mp){
  mp.setOnBufferingUpdateListener(this);
  mp.setOnCompletionListener(this);
  mp.setOnPreparedListener(this);
  mp.setOnVideoSizeChangedListener(this);
  mp.setOnSeekCompleteListener(this);
  mp.setOnErrorListener(this);
  mp.setOnInfoListener(this);
  mp.setScreenOnWhilePlaying(false);
  mp.setAudioStreamType(AudioManager.STREAM_MUSIC);
}","private void initMediaPlayer(MediaPlayer mp){
  mp.setOnBufferingUpdateListener(this);
  mp.setOnCompletionListener(this);
  mp.setOnVideoSizeChangedListener(this);
  mp.setOnSeekCompleteListener(this);
  mp.setOnErrorListener(this);
  mp.setOnInfoListener(this);
  mp.setScreenOnWhilePlaying(false);
  mp.setAudioStreamType(AudioManager.STREAM_MUSIC);
  mp.setOnPreparedListener(this);
}",0.9123711340206184
110111,"@Override public void onCreateContextMenu(ContextMenu menu,View v,ContextMenuInfo menuInfo){
  super.onCreateContextMenu(menu,v,menuInfo);
  MenuInflater inflater=getMenuInflater();
  inflater.inflate(R.menu.musics_context,menu);
  if (isUserPlayList(mPlid))   menu.findItem(R.id.plthumbnail).setVisible(true);
 else   menu.findItem(R.id.plthumbnail).setVisible(false);
}","@Override public void onCreateContextMenu(ContextMenu menu,View v,ContextMenuInfo menuInfo){
  super.onCreateContextMenu(menu,v,menuInfo);
  MenuInflater inflater=getMenuInflater();
  inflater.inflate(R.menu.musics_context,menu);
  if (isUserPlayList(mPlid)) {
    menu.findItem(R.id.plthumbnail).setVisible(true);
    menu.findItem(R.id.delete).setVisible(true);
  }
 else {
    menu.findItem(R.id.plthumbnail).setVisible(false);
    menu.findItem(R.id.delete).setVisible(false);
  }
}",0.8564760793465578
110112,"private String dbgStateName(int state){
switch (state) {
case YTPSTATE_UNSTARTED:
    return ""String_Node_Str"";
case YTPSTATE_ENDED:
  return ""String_Node_Str"";
case YTPSTATE_PLAYING:
return ""String_Node_Str"";
case YTPSTATE_PAUSED:
return ""String_Node_Str"";
case YTPSTATE_BUFFERING:
return ""String_Node_Str"";
case YTPSTATE_VIDEO_CUED:
return ""String_Node_Str"";
case YTPSTATE_ERROR:
return ""String_Node_Str"";
default :
eAssert(false);
}
return null;
}","private String dbgStateName(int state){
switch (state) {
case YTPSTATE_UNSTARTED:
    return ""String_Node_Str"";
case YTPSTATE_ENDED:
  return ""String_Node_Str"";
case YTPSTATE_PLAYING:
return ""String_Node_Str"";
case YTPSTATE_PAUSED:
return ""String_Node_Str"";
case YTPSTATE_BUFFERING:
return ""String_Node_Str"";
case YTPSTATE_VIDEO_CUED:
return ""String_Node_Str"";
case YTPSTATE_ERROR:
return ""String_Node_Str"";
case YTPSTATE_INVALID:
return ""String_Node_Str"";
default :
eAssert(false);
}
return null;
}",0.9483667017913592
110113,"public Err init(){
  new File(Utils.getAppContext().getFilesDir().getAbsolutePath() + ""String_Node_Str"" + YTPLAYER_SCRIPT).delete();
  Utils.copyAssetFile(YTPLAYER_SCRIPT);
  try {
    new NanoHTTPD(WEBSERVER_PORT,Utils.getAppContext().getFilesDir());
  }
 catch (  IOException e) {
    logI(""String_Node_Str"");
  }
  return Err.NO_ERR;
}","public Err init(){
  File fScript=new File(Utils.getAppContext().getFilesDir().getAbsolutePath() + ""String_Node_Str"" + YTPLAYER_SCRIPT);
  if (!fScript.exists())   Utils.copyAssetFile(YTPLAYER_SCRIPT);
  try {
    new NanoHTTPD(WEBSERVER_PORT,Utils.getAppContext().getFilesDir());
  }
 catch (  IOException e) {
    logI(""String_Node_Str"");
  }
  return Err.NO_ERR;
}",0.9276595744680852
110114,"public boolean isPlayerReady(){
  return null != mWv;
}","public boolean isPlayerReady(){
  return YTPSTATE_INVALID != ytpGetState();
}",0.7272727272727273
110115,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (YTJSPlayer.get().isPlayerReady()) {
    launchPlaylistActivity();
    return;
  }
  setContentView(R.layout.main);
  ImageView progimg=(ImageView)findViewById(R.id.progressimg);
  if (!Utils.isNetworkAvailable()) {
    progimg.setImageResource(R.drawable.ic_block);
    UiUtils.showTextToast(this,R.string.msg_appinit_network_unavailable);
    delayedFinish(APPINIT_FAIL_NOTI_DURATION);
    return;
  }
  ((ImageView)findViewById(R.id.progressimg)).startAnimation(AnimationUtils.loadAnimation(this,R.anim.rotate));
  final WebView wv=(WebView)findViewById(R.id.webview);
  YTJSPlayer.get().prepare(wv,this);
  Utils.getUiHandler().postDelayed(mAppInitTimeOut,APPINIT_TIMEOUT);
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (YTJSPlayer.get().isPlayerReady()) {
    launchPlaylistActivity();
    return;
  }
  setContentView(R.layout.main);
  if (!Utils.isNetworkAvailable()) {
    UiUtils.showTextToast(this,R.string.msg_appinit_network_unavailable);
    finish();
    return;
  }
  ((ImageView)findViewById(R.id.progressimg)).startAnimation(AnimationUtils.loadAnimation(this,R.anim.rotate));
  final WebView wv=(WebView)findViewById(R.id.webview);
  YTJSPlayer.get().prepare(wv,this);
  Utils.getUiHandler().postDelayed(mAppInitTimeOut,Policy.Constants.APPINIT_TIMEOUT);
}",0.8840782122905028
110116,"@Override public void run(){
  YTMPActivity.this.finish();
}","@Override public void run(){
  ImageView prog=(ImageView)findViewById(R.id.progressimg);
  prog.clearAnimation();
  prog.setVisibility(View.GONE);
  UiUtils.showTextToast(YTMPActivity.this,R.string.msg_appinit_fail);
  finish();
}",0.4068965517241379
110117,"public static void showTextToast(Context context,int textid){
  Toast t=Toast.makeText(context,textid,Toast.LENGTH_SHORT);
  t.setGravity(Gravity.CENTER,0,0);
  t.show();
}","public static void showTextToast(Context context,int textid){
  Toast t=Toast.makeText(context,textid,Toast.LENGTH_LONG);
  t.setGravity(Gravity.CENTER,0,0);
  t.show();
}",0.979591836734694
110118,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.main);
  ImageView progimg=(ImageView)findViewById(R.id.progressimg);
  if (!Utils.isNetworkAvailable()) {
    progimg.setImageResource(R.drawable.ic_block);
    UiUtils.showTextToast(this,R.string.msg_appinit_network_unavailable);
    delayedFinish(APPINIT_FAIL_NOTI_DURATION);
    return;
  }
  ((TextView)findViewById(R.id.message)).setText(R.string.msg_initialize_app);
  ((ImageView)findViewById(R.id.progressimg)).startAnimation(AnimationUtils.loadAnimation(this,R.anim.rotate));
  final WebView wv=(WebView)findViewById(R.id.webview);
  YTJSPlayer.get().prepare(wv,this);
  Utils.getUiHandler().postDelayed(mAppInitTimeOut,APPINIT_TIMEOUT);
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (YTJSPlayer.get().isPlayerReady()) {
    launchPlaylistActivity();
    return;
  }
  setContentView(R.layout.main);
  ImageView progimg=(ImageView)findViewById(R.id.progressimg);
  if (!Utils.isNetworkAvailable()) {
    progimg.setImageResource(R.drawable.ic_block);
    UiUtils.showTextToast(this,R.string.msg_appinit_network_unavailable);
    delayedFinish(APPINIT_FAIL_NOTI_DURATION);
    return;
  }
  ((TextView)findViewById(R.id.message)).setText(R.string.msg_initialize_app);
  ((ImageView)findViewById(R.id.progressimg)).startAnimation(AnimationUtils.loadAnimation(this,R.anim.rotate));
  final WebView wv=(WebView)findViewById(R.id.webview);
  YTJSPlayer.get().prepare(wv,this);
  Utils.getUiHandler().postDelayed(mAppInitTimeOut,APPINIT_TIMEOUT);
}",0.946078431372549
110119,"@Override public void onPlayerReady(WebView wv){
  Utils.getUiHandler().removeCallbacks(mAppInitTimeOut);
  Intent i=new Intent(this,PlaylistActivity.class);
  startActivity(i);
  finish();
}","@Override public void onPlayerReady(WebView wv){
  Utils.getUiHandler().removeCallbacks(mAppInitTimeOut);
  launchPlaylistActivity();
}",0.803680981595092
110120,"/** 
 * Execute the command.
 * @param sender  the sender of the command
 * @param command the command being done
 * @param label   the name of the command
 * @param args    the arguments supplied
 */
@Override public void execute(CommandSender sender,Command command,String label,String[] args){
  if (!hasPermission()) {
    sender.sendMessage(PlugMan.getInstance().getMessageFormatter().format(""String_Node_Str""));
    return;
  }
  if (args.length < 2) {
    sender.sendMessage(PlugMan.getInstance().getMessageFormatter().format(""String_Node_Str""));
    sendUsage();
    return;
  }
  Plugin plugin=PluginUtil.findByCommand(args[1]);
  if (plugin == null) {
    sender.sendMessage(PlugMan.getInstance().getMessageFormatter().format(""String_Node_Str"",args[1]));
    return;
  }
  sender.sendMessage(PlugMan.getInstance().getMessageFormatter().format(""String_Node_Str"",args[1],plugin.getName()));
}","/** 
 * Execute the command.
 * @param sender  the sender of the command
 * @param command the command being done
 * @param label   the name of the command
 * @param args    the arguments supplied
 */
@Override public void execute(CommandSender sender,Command command,String label,String[] args){
  if (!hasPermission()) {
    sender.sendMessage(PlugMan.getInstance().getMessageFormatter().format(""String_Node_Str""));
    return;
  }
  if (args.length < 2) {
    sender.sendMessage(PlugMan.getInstance().getMessageFormatter().format(""String_Node_Str""));
    sendUsage();
    return;
  }
  List<String> plugins=PluginUtil.findByCommand(args[1]);
  if (plugins.isEmpty()) {
    sender.sendMessage(PlugMan.getInstance().getMessageFormatter().format(""String_Node_Str"",args[1]));
    return;
  }
  sender.sendMessage(PlugMan.getInstance().getMessageFormatter().format(""String_Node_Str"",args[1],Joiner.on(""String_Node_Str"").join(plugins)));
}",0.9422657952069716
110121,"/** 
 * Find which plugin has a given command registered.
 * @param command the command.
 * @return the plugin.
 */
public static Plugin findByCommand(String command){
  for (  Plugin plugin : Bukkit.getPluginManager().getPlugins()) {
    Map<String,Map<String,Object>> commands=plugin.getDescription().getCommands();
    if (commands != null) {
      Iterator<Map.Entry<String,Map<String,Object>>> commandIterator=commands.entrySet().iterator();
      while (commandIterator.hasNext()) {
        Map.Entry<String,Map<String,Object>> commandNext=commandIterator.next();
        if (commandNext.getKey().equalsIgnoreCase(command)) {
          return plugin;
        }
        Iterator<Map.Entry<String,Object>> attributeIterator=commandNext.getValue().entrySet().iterator();
        while (attributeIterator.hasNext()) {
          Map.Entry<String,Object> attributeNext=attributeIterator.next();
          if (attributeNext.getKey().equals(""String_Node_Str"")) {
            Object aliases=attributeNext.getValue();
            if (aliases instanceof String) {
              if (((String)aliases).equalsIgnoreCase(command)) {
                return plugin;
              }
            }
 else {
              List<String> array=(List<String>)aliases;
              for (              String str : array) {
                if (str.equalsIgnoreCase(command)) {
                  return plugin;
                }
              }
            }
          }
        }
      }
    }
  }
  return null;
}","/** 
 * Find which plugin has a given command registered.
 * @param command the command.
 * @return the plugin.
 */
public static List<String> findByCommand(String command){
  List<String> plugins=new ArrayList<>();
  for (  Plugin plugin : Bukkit.getPluginManager().getPlugins()) {
    Map<String,Map<String,Object>> commands=plugin.getDescription().getCommands();
    if (commands != null) {
      Iterator<Map.Entry<String,Map<String,Object>>> commandIterator=commands.entrySet().iterator();
      while (commandIterator.hasNext()) {
        Map.Entry<String,Map<String,Object>> commandNext=commandIterator.next();
        if (commandNext.getKey().equalsIgnoreCase(command)) {
          plugins.add(plugin.getName());
          continue;
        }
        Iterator<Map.Entry<String,Object>> attributeIterator=commandNext.getValue().entrySet().iterator();
        while (attributeIterator.hasNext()) {
          Map.Entry<String,Object> attributeNext=attributeIterator.next();
          if (attributeNext.getKey().equals(""String_Node_Str"")) {
            Object aliases=attributeNext.getValue();
            if (aliases instanceof String) {
              if (((String)aliases).equalsIgnoreCase(command)) {
                plugins.add(plugin.getName());
                continue;
              }
            }
 else {
              List<String> array=(List<String>)aliases;
              for (              String str : array) {
                if (str.equalsIgnoreCase(command)) {
                  plugins.add(plugin.getName());
                  continue;
                }
              }
            }
          }
        }
      }
    }
  }
  return plugins;
}",0.91426763682379
110122,"/** 
 * TkSaveEmail can save email.
 * @throws Exception If there is some problem inside
 */
@Test public void savesEmail() throws Exception {
  final MkBase base=new MkBase();
  final String urn=""String_Node_Str"";
  final User user=base.user(new URN(urn));
  user.aliases().add(""String_Node_Str"");
  final Alias alias=user.aliases().iterate().iterator().next();
  alias.email(""String_Node_Str"");
  new TkAuth(new TkSaveEmail(base,false),new PsFixed(new Identity.Simple(urn))).act(new RqForm.Fake(new RqFake(),TkSaveEmailTest.EMAIL,""String_Node_Str""));
  MatcherAssert.assertThat(alias.email(),Matchers.equalTo(""String_Node_Str""));
}","/** 
 * TkSaveEmail can save email.
 * @throws Exception If there is some problem inside
 */
@Test public void savesEmail() throws Exception {
  final Base base=new CdBase(new MkBase());
  final String urn=""String_Node_Str"";
  final User user=base.user(new URN(urn));
  user.aliases().add(""String_Node_Str"");
  final Alias alias=user.aliases().iterate().iterator().next();
  alias.email(""String_Node_Str"");
  new TkAuth(new TkSaveEmail(base,false),new PsFixed(new Identity.Simple(urn))).act(new RqForm.Fake(new RqFake(),TkSaveEmailTest.EMAIL,""String_Node_Str""));
  MatcherAssert.assertThat(alias.email(),Matchers.equalTo(""String_Node_Str""));
}",0.9655172413793104
110123,"@Override public Response act(final Request req) throws IOException {
  final Href href=new RqHref.Base(req).href();
  final Iterator<String> token=href.param(""String_Node_Str"").iterator();
  String key=""String_Node_Str"";
  long diff=0;
  final Inbox inbox;
  while (token.hasNext()) {
    key=token.next();
  }
  if (key.isEmpty()) {
    inbox=new RqAlias(this.base,req).alias().inbox();
  }
 else   if (this.tokens.containsKey(key)) {
    final Pair<Date,Inbox> cached=this.tokens.get(key);
    diff=(new Date()).getTime() - (cached.getLeft()).getTime();
    if ((TimeUnit.MILLISECONDS.toDays(diff)) <= 2) {
      inbox=cached.getRight();
    }
 else {
      this.tokens.remove(key);
      inbox=new RqAlias(this.base,req).alias().inbox();
    }
  }
 else {
    inbox=new RqAlias(this.base,req).alias().inbox();
    this.tokens.put(key,Pair.of(new Date(),inbox));
  }
  diff=(new Date()).getTime() - lastChecked.getTime();
  if ((TimeUnit.MILLISECONDS.toHours(diff)) >= 1) {
    lastChecked=new Date();
    clearCache();
  }
  final long number=inbox.start();
  final Bout bout=inbox.bout(number);
  final StringBuilder msg=new StringBuilder(String.format(""String_Node_Str"",number));
  this.rename(bout,msg,href);
  this.invite(bout,msg,href);
  final Iterator<String> post=href.param(""String_Node_Str"").iterator();
  while (post.hasNext()) {
    try {
      bout.messages().post(post.next());
    }
 catch (    final Messages.BrokenPostException ex) {
      this.discard(bout);
      throw new RsFailure(ex);
    }
    msg.append(""String_Node_Str"");
  }
  throw new RsForward(new RsFlash(msg.toString()),new RqHref.Smart(new RqHref.Base(req)).home().path(""String_Node_Str"").path(Long.toString(number)));
}","@Override public Response act(final Request req) throws IOException {
  final Href href=new RqHref.Base(req).href();
  final Iterator<String> token=href.param(""String_Node_Str"").iterator();
  String key=""String_Node_Str"";
  long diff=0;
  final Inbox inbox;
  while (token.hasNext()) {
    key=token.next();
  }
  if (key.isEmpty()) {
    inbox=new RqAlias(this.base,req).alias().inbox();
  }
 else   if (this.tokens.containsKey(key)) {
    final Pair<Date,Inbox> cached=this.tokens.get(key);
    diff=(new Date()).getTime() - (cached.getLeft()).getTime();
    if ((TimeUnit.MILLISECONDS.toDays(diff)) <= 2) {
      inbox=cached.getRight();
    }
 else {
      this.tokens.remove(key);
      inbox=new RqAlias(this.base,req).alias().inbox();
    }
  }
 else {
    inbox=new RqAlias(this.base,req).alias().inbox();
    this.tokens.put(key,Pair.of(new Date(),inbox));
  }
  diff=(new Date()).getTime() - checked.getTime();
  if ((TimeUnit.MILLISECONDS.toHours(diff)) >= 1) {
    checked=new Date();
    clearCache();
  }
  final long number=inbox.start();
  final Bout bout=inbox.bout(number);
  final StringBuilder msg=new StringBuilder(String.format(""String_Node_Str"",number));
  this.rename(bout,msg,href);
  this.invite(bout,msg,href);
  final Iterator<String> post=href.param(""String_Node_Str"").iterator();
  while (post.hasNext()) {
    try {
      bout.messages().post(post.next());
    }
 catch (    final Messages.BrokenPostException ex) {
      this.discard(bout);
      throw new RsFailure(ex);
    }
    msg.append(""String_Node_Str"");
  }
  throw new RsForward(new RsFlash(msg.toString()),new RqHref.Smart(new RqHref.Base(req)).home().path(""String_Node_Str"").path(Long.toString(number)));
}",0.9964788732394366
110124,"@Override public Response act(final Request req) throws IOException {
  final Inbox inbox=new RqAlias(this.base,req).alias().inbox();
  final long number=inbox.start();
  final Bout bout=inbox.bout(number);
  final StringBuilder msg=new StringBuilder(String.format(""String_Node_Str"",number));
  final Href href=new RqHref.Base(req).href();
  this.rename(bout,msg,href);
  this.invite(bout,msg,href);
  final Iterator<String> post=href.param(""String_Node_Str"").iterator();
  while (post.hasNext()) {
    try {
      bout.messages().post(post.next());
    }
 catch (    final Messages.BrokenPostException ex) {
      this.discard(bout);
      throw new RsFailure(ex);
    }
    msg.append(""String_Node_Str"");
  }
  throw new RsForward(new RsFlash(msg.toString()),new RqHref.Smart(new RqHref.Base(req)).home().path(""String_Node_Str"").path(Long.toString(number)));
}","@Override public Response act(final Request req) throws IOException {
  final Href href=new RqHref.Base(req).href();
  final Iterator<String> token=href.param(""String_Node_Str"").iterator();
  String key=""String_Node_Str"";
  long diff=0;
  final Inbox inbox;
  while (token.hasNext()) {
    key=token.next();
  }
  if (key.isEmpty()) {
    inbox=new RqAlias(this.base,req).alias().inbox();
  }
 else   if (this.tokens.containsKey(key)) {
    final Pair<Date,Inbox> cached=this.tokens.get(key);
    diff=(new Date()).getTime() - (cached.getLeft()).getTime();
    if ((TimeUnit.MILLISECONDS.toDays(diff)) <= 2) {
      inbox=cached.getRight();
    }
 else {
      this.tokens.remove(key);
      inbox=new RqAlias(this.base,req).alias().inbox();
    }
  }
 else {
    inbox=new RqAlias(this.base,req).alias().inbox();
    this.tokens.put(key,Pair.of(new Date(),inbox));
  }
  diff=(new Date()).getTime() - checked.getTime();
  if ((TimeUnit.MILLISECONDS.toHours(diff)) >= 1) {
    checked=new Date();
    clearCache();
  }
  final long number=inbox.start();
  final Bout bout=inbox.bout(number);
  final StringBuilder msg=new StringBuilder(String.format(""String_Node_Str"",number));
  this.rename(bout,msg,href);
  this.invite(bout,msg,href);
  final Iterator<String> post=href.param(""String_Node_Str"").iterator();
  while (post.hasNext()) {
    try {
      bout.messages().post(post.next());
    }
 catch (    final Messages.BrokenPostException ex) {
      this.discard(bout);
      throw new RsFailure(ex);
    }
    msg.append(""String_Node_Str"");
  }
  throw new RsForward(new RsFlash(msg.toString()),new RqHref.Smart(new RqHref.Base(req)).home().path(""String_Node_Str"").path(Long.toString(number)));
}",0.3013270882123341
110125,"@Override public Response act(final Request req) throws IOException {
  final Href href=new RqHref.Base(req).href();
  final Iterator<String> token=href.param(""String_Node_Str"").iterator();
  String tokenkey=""String_Node_Str"";
  final Inbox inbox;
  while (token.hasNext()) {
    tokenkey=token.next();
  }
  if (tokenkey.isEmpty()) {
    inbox=new RqAlias(this.base,req).alias().inbox();
  }
 else   if (this.tokens.containsKey(tokenkey)) {
    final Object[] cache=this.tokens.get(tokenkey);
    final Date today=new Date();
    final long diff=today.getTime() - ((Date)cache[0]).getTime();
    if ((TimeUnit.MILLISECONDS.toDays(diff)) <= 2) {
      inbox=(Inbox)cache[1];
    }
 else {
      this.tokens.remove(tokenkey);
      inbox=new RqAlias(this.base,req).alias().inbox();
    }
  }
 else {
    inbox=new RqAlias(this.base,req).alias().inbox();
    this.tokens.put(tokenkey,new Object[]{new Date(),inbox});
  }
  final long number=inbox.start();
  final Bout bout=inbox.bout(number);
  final StringBuilder msg=new StringBuilder(String.format(""String_Node_Str"",number));
  this.rename(bout,msg,href);
  this.invite(bout,msg,href);
  final Iterator<String> post=href.param(""String_Node_Str"").iterator();
  while (post.hasNext()) {
    try {
      bout.messages().post(post.next());
    }
 catch (    final Messages.BrokenPostException ex) {
      this.discard(bout);
      throw new RsFailure(ex);
    }
    msg.append(""String_Node_Str"");
  }
  throw new RsForward(new RsFlash(msg.toString()),new RqHref.Smart(new RqHref.Base(req)).home().path(""String_Node_Str"").path(Long.toString(number)));
}","@Override public Response act(final Request req) throws IOException {
  final Href href=new RqHref.Base(req).href();
  final Iterator<String> token=href.param(""String_Node_Str"").iterator();
  String key=""String_Node_Str"";
  final Inbox inbox;
  while (token.hasNext()) {
    key=token.next();
  }
  if (key.isEmpty()) {
    inbox=new RqAlias(this.base,req).alias().inbox();
  }
 else   if (this.tokens.containsKey(key)) {
    final Pair<Date,Inbox> cached=this.tokens.get(key);
    final long diff=(new Date()).getTime() - (cached.getLeft()).getTime();
    if ((TimeUnit.MILLISECONDS.toDays(diff)) <= 2) {
      inbox=cached.getRight();
    }
 else {
      this.tokens.remove(key);
      inbox=new RqAlias(this.base,req).alias().inbox();
    }
  }
 else {
    inbox=new RqAlias(this.base,req).alias().inbox();
    this.tokens.put(key,Pair.of(new Date(),inbox));
  }
  final long number=inbox.start();
  final Bout bout=inbox.bout(number);
  final StringBuilder msg=new StringBuilder(String.format(""String_Node_Str"",number));
  this.rename(bout,msg,href);
  this.invite(bout,msg,href);
  final Iterator<String> post=href.param(""String_Node_Str"").iterator();
  while (post.hasNext()) {
    try {
      bout.messages().post(post.next());
    }
 catch (    final Messages.BrokenPostException ex) {
      this.discard(bout);
      throw new RsFailure(ex);
    }
    msg.append(""String_Node_Str"");
  }
  throw new RsForward(new RsFlash(msg.toString()),new RqHref.Smart(new RqHref.Base(req)).home().path(""String_Node_Str"").path(Long.toString(number)));
}",0.8948204639339054
110126,"@Override public Response act(final Request req) throws IOException {
  final Href href=new RqHref.Base(req).href();
  final Iterator<String> token=href.param(""String_Node_Str"").iterator();
  String key=""String_Node_Str"";
  final Inbox inbox;
  while (token.hasNext()) {
    key=token.next();
  }
  if (key.isEmpty()) {
    inbox=new RqAlias(this.base,req).alias().inbox();
  }
 else   if (this.tokens.containsKey(key)) {
    final Pair<Date,Inbox> cached=this.tokens.get(key);
    final long diff=(new Date()).getTime() - (cached.getLeft()).getTime();
    if ((TimeUnit.MILLISECONDS.toDays(diff)) <= 2) {
      inbox=cached.getRight();
    }
 else {
      this.tokens.remove(key);
      inbox=new RqAlias(this.base,req).alias().inbox();
    }
  }
 else {
    inbox=new RqAlias(this.base,req).alias().inbox();
    this.tokens.put(key,Pair.of(new Date(),inbox));
  }
  final long number=inbox.start();
  final Bout bout=inbox.bout(number);
  final StringBuilder msg=new StringBuilder(String.format(""String_Node_Str"",number));
  this.rename(bout,msg,href);
  this.invite(bout,msg,href);
  final Iterator<String> post=href.param(""String_Node_Str"").iterator();
  while (post.hasNext()) {
    try {
      bout.messages().post(post.next());
    }
 catch (    final Messages.BrokenPostException ex) {
      this.discard(bout);
      throw new RsFailure(ex);
    }
    msg.append(""String_Node_Str"");
  }
  throw new RsForward(new RsFlash(msg.toString()),new RqHref.Smart(new RqHref.Base(req)).home().path(""String_Node_Str"").path(Long.toString(number)));
}","@Override public Response act(final Request req) throws IOException {
  final Href href=new RqHref.Base(req).href();
  final Iterator<String> token=href.param(""String_Node_Str"").iterator();
  String key=""String_Node_Str"";
  long diff=0;
  final Inbox inbox;
  while (token.hasNext()) {
    key=token.next();
  }
  if (key.isEmpty()) {
    inbox=new RqAlias(this.base,req).alias().inbox();
  }
 else   if (this.tokens.containsKey(key)) {
    final Pair<Date,Inbox> cached=this.tokens.get(key);
    diff=(new Date()).getTime() - (cached.getLeft()).getTime();
    if ((TimeUnit.MILLISECONDS.toDays(diff)) <= 2) {
      inbox=cached.getRight();
    }
 else {
      this.tokens.remove(key);
      inbox=new RqAlias(this.base,req).alias().inbox();
    }
  }
 else {
    inbox=new RqAlias(this.base,req).alias().inbox();
    this.tokens.put(key,Pair.of(new Date(),inbox));
  }
  diff=(new Date()).getTime() - lastChecked.getTime();
  if ((TimeUnit.MILLISECONDS.toHours(diff)) >= 1) {
    lastChecked=new Date();
    clearCache();
  }
  final long number=inbox.start();
  final Bout bout=inbox.bout(number);
  final StringBuilder msg=new StringBuilder(String.format(""String_Node_Str"",number));
  this.rename(bout,msg,href);
  this.invite(bout,msg,href);
  final Iterator<String> post=href.param(""String_Node_Str"").iterator();
  while (post.hasNext()) {
    try {
      bout.messages().post(post.next());
    }
 catch (    final Messages.BrokenPostException ex) {
      this.discard(bout);
      throw new RsFailure(ex);
    }
    msg.append(""String_Node_Str"");
  }
  throw new RsForward(new RsFlash(msg.toString()),new RqHref.Smart(new RqHref.Base(req)).home().path(""String_Node_Str"").path(Long.toString(number)));
}",0.943778801843318
110127,"@Override public Response act(final Request req) throws IOException {
  final Inbox inbox=new RqAlias(this.base,req).alias().inbox();
  final long number=inbox.start();
  final Bout bout=inbox.bout(number);
  final StringBuilder msg=new StringBuilder(String.format(""String_Node_Str"",number));
  final Href href=new RqHref.Base(req).href();
  this.rename(bout,msg,href);
  this.invite(bout,msg,href);
  final Iterator<String> post=href.param(""String_Node_Str"").iterator();
  while (post.hasNext()) {
    try {
      bout.messages().post(post.next());
    }
 catch (    final Messages.BrokenPostException ex) {
      this.discard(bout);
      throw new RsFailure(ex);
    }
    msg.append(""String_Node_Str"");
  }
  throw new RsForward(new RsFlash(msg.toString()),new RqHref.Smart(new RqHref.Base(req)).home().path(""String_Node_Str"").path(Long.toString(number)));
}","@Override public Response act(final Request req) throws IOException {
  final Href href=new RqHref.Base(req).href();
  final Iterator<String> token=href.param(""String_Node_Str"").iterator();
  String tokenkey=""String_Node_Str"";
  final Inbox inbox;
  long number=0;
  while (token.hasNext()) {
    tokenkey=token.next();
  }
  if (tokenkey.equals(""String_Node_Str"")) {
    inbox=new RqAlias(this.base,req).alias().inbox();
  }
 else {
    if (this.tokencache.containsKey(tokenkey)) {
      final int hoursInDay=24;
      final int minsInHours=60;
      final int secsInMins=60;
      final int micsInSecs=1000;
      final Object[] cache=this.tokencache.get(tokenkey);
      final Date today=new Date();
      final long diff=Math.abs(today.getTime() - ((Date)cache[0]).getTime());
      final long diffDays=diff / (hoursInDay * minsInHours * secsInMins* micsInSecs);
      if (diffDays <= 2) {
        inbox=(Inbox)cache[1];
      }
 else {
        this.tokencache.remove(tokenkey);
        inbox=new RqAlias(this.base,req).alias().inbox();
      }
    }
 else {
      inbox=new RqAlias(this.base,req).alias().inbox();
      this.tokencache.put(tokenkey,new Object[]{new Date(),inbox});
    }
  }
  number=inbox.start();
  final Bout bout=inbox.bout(number);
  final StringBuilder msg=new StringBuilder(String.format(""String_Node_Str"",number));
  this.rename(bout,msg,href);
  this.invite(bout,msg,href);
  final Iterator<String> post=href.param(""String_Node_Str"").iterator();
  while (post.hasNext()) {
    try {
      bout.messages().post(post.next());
    }
 catch (    final Messages.BrokenPostException ex) {
      this.discard(bout);
      throw new RsFailure(ex);
    }
    msg.append(""String_Node_Str"");
  }
  throw new RsForward(new RsFlash(msg.toString()),new RqHref.Smart(new RqHref.Base(req)).home().path(""String_Node_Str"").path(Long.toString(number)));
}",0.2755588127519238
110128,"/** 
 * Regex takes.
 * @param base Base
 * @return Take
 * @throws IOException If fails
 */
private static Take regex(final Base base) throws IOException {
  return new TkFork(new FkParams(PsByFlag.class.getSimpleName(),Pattern.compile(""String_Node_Str""),new TkRedirect()),new FkRegex(""String_Node_Str"",""String_Node_Str""),new FkRegex(""String_Node_Str"",new TkWithType(TkApp.refresh(""String_Node_Str""),""String_Node_Str"")),new FkRegex(""String_Node_Str"",new TkWithType(TkApp.refresh(""String_Node_Str""),""String_Node_Str"")),new FkRegex(""String_Node_Str"",new TkWithType(TkApp.refresh(""String_Node_Str""),""String_Node_Str"")),new FkRegex(""String_Node_Str"",new TkWithType(TkApp.refresh(""String_Node_Str""),""String_Node_Str"")),new FkRegex(""String_Node_Str"",new TkFavicon()),new FkAnonymous(new TkFork(new FkRegex(""String_Node_Str"",new TkHome(base)),new FkFixed(new Take(){
    @Override public Response act(    final Request req) throws IOException {
      return new RsReturn(new RsRedirect(""String_Node_Str""),new RqHref.Base(req).href().bare());
    }
  }
))),new FkAuthenticated(new TkFork(new FkRegistered(base,new TkFork(new FkRegex(""String_Node_Str"",new TkReturn(new TkInbox(base))),new FkRegex(""String_Node_Str"",new TkReturn(new TkInbox(base))),new FkRegex(""String_Node_Str"",new TkStart(base)),new FkRegex(""String_Node_Str"",new TkBout(base)),new FkRegex(""String_Node_Str"",new TkAccount(base)),new FkRegex(""String_Node_Str"",new TkFriend(base)))),new FkRegex(""String_Node_Str"",new RsRedirect(""String_Node_Str"")),new FkRegex(""String_Node_Str"",new TkLogin(base)))));
}","/** 
 * Regex takes.
 * @param base Base
 * @return Take
 * @throws IOException If fails
 */
private static Take regex(final Base base) throws IOException {
  return new TkFork(new FkParams(PsByFlag.class.getSimpleName(),Pattern.compile(""String_Node_Str""),new TkRedirect()),new FkRegex(""String_Node_Str"",""String_Node_Str""),new FkRegex(""String_Node_Str"",new TkWithType(TkApp.refresh(""String_Node_Str""),""String_Node_Str"")),new FkRegex(""String_Node_Str"",new TkWithType(TkApp.refresh(""String_Node_Str""),""String_Node_Str"")),new FkRegex(""String_Node_Str"",new TkWithType(TkApp.refresh(""String_Node_Str""),""String_Node_Str"")),new FkRegex(""String_Node_Str"",new TkWithType(TkApp.refresh(""String_Node_Str""),""String_Node_Str"")),new FkRegex(""String_Node_Str"",new TkFavicon()),new FkAnonymous(new TkFork(new FkRegex(""String_Node_Str"",new TkHome(base)),new FkFixed(new Take(){
    @Override public Response act(    final Request req) throws IOException {
      return new RsReturn(new RsRedirect(""String_Node_Str""),new RqHref.Base(req).href().toString());
    }
  }
))),new FkAuthenticated(new TkFork(new FkRegistered(base,new TkFork(new FkRegex(""String_Node_Str"",new TkReturn(new TkInbox(base))),new FkRegex(""String_Node_Str"",new TkReturn(new TkInbox(base))),new FkRegex(""String_Node_Str"",new TkStart(base)),new FkRegex(""String_Node_Str"",new TkBout(base)),new FkRegex(""String_Node_Str"",new TkAccount(base)),new FkRegex(""String_Node_Str"",new TkFriend(base)))),new FkRegex(""String_Node_Str"",new RsRedirect(""String_Node_Str"")),new FkRegex(""String_Node_Str"",new TkLogin(base)))));
}",0.9961563100576554
110129,"@Override public Response act(final Request req) throws IOException {
  return new RsReturn(new RsRedirect(""String_Node_Str""),new RqHref.Base(req).href().bare());
}","@Override public Response act(final Request req) throws IOException {
  return new RsReturn(new RsRedirect(""String_Node_Str""),new RqHref.Base(req).href().toString());
}",0.9698795180722892
110130,"/** 
 * Create alias.
 * @return Alias
 * @throws IOException If fails
 */
public Alias alias(final String name) throws IOException {
  final User user=user(URN.create(String.format(""String_Node_Str"",new SecureRandom().nextInt(Integer.MAX_VALUE))));
  final Aliases aliases=user.aliases();
  aliases.add(name);
  final Alias alias=aliases.iterate().iterator().next();
  alias.email(String.format(""String_Node_Str"",alias.name()));
  return alias;
}","/** 
 * Create alias.
 * @param name Name of the alias
 * @return Alias
 * @throws IOException If fails
 */
public Alias alias(final String name) throws IOException {
  final User user=this.user(URN.create(String.format(""String_Node_Str"",new SecureRandom().nextInt(Integer.MAX_VALUE))));
  final Aliases aliases=user.aliases();
  aliases.add(name);
  final Alias alias=aliases.iterate().iterator().next();
  alias.email(String.format(""String_Node_Str"",alias.name()));
  return alias;
}",0.9592274678111588
110131,"/** 
 * Random alias.
 * @return Alias
 * @throws IOException If fails
 */
public Alias randomAlias() throws IOException {
  return alias(String.format(""String_Node_Str"",MkBase.RANDOM.nextInt(Integer.MAX_VALUE)));
}","/** 
 * Random alias.
 * @return Alias
 * @throws IOException If fails
 */
public Alias randomAlias() throws IOException {
  return this.alias(String.format(""String_Node_Str"",MkBase.RANDOM.nextInt(Integer.MAX_VALUE)));
}",0.9885057471264368
110132,"/** 
 * Read text from stream.
 * @param stream Stream to read from
 * @throws IOException If cant write
 */
public static BigText read(final DataInputStream stream) throws IOException {
  final byte[] bytes=new byte[stream.readInt()];
  for (int num=0; num < bytes.length; ++num) {
    bytes[num]=stream.readByte();
  }
  return new BigText(new String(bytes,CharEncoding.UTF_8));
}","/** 
 * Read text from stream.
 * @param stream Stream to read from
 * @return New instance of this class, with text inside
 * @throws IOException If cant write
 */
public static BigText read(final DataInputStream stream) throws IOException {
  final byte[] bytes=new byte[stream.readInt()];
  for (int num=0; num < bytes.length; ++num) {
    bytes[num]=stream.readByte();
  }
  return new BigText(new String(bytes,CharEncoding.UTF_8));
}",0.9317073170731708
110133,"/** 
 * Write text to stream.
 * @param stream Stream to write to
 * @throws IOException If cant write
 */
public void write(final DataOutputStream stream) throws IOException {
  final byte[] bytes=text.getBytes(CharEncoding.UTF_8);
  stream.writeInt(bytes.length);
  for (  byte data : bytes) {
    stream.writeByte(data);
  }
}","/** 
 * Write text to stream.
 * @param stream Stream to write to
 * @throws IOException If cant write
 */
public void write(final DataOutputStream stream) throws IOException {
  final byte[] bytes=this.text.getBytes(CharEncoding.UTF_8);
  stream.writeInt(bytes.length);
  for (  byte data : bytes) {
    stream.writeByte(data);
  }
}",0.9924585218702866
110134,"/** 
 * {@inheritDoc}
 */
@Override public MessageNotice read(final DataInputStream stream) throws IOException {
  final long number=stream.readLong();
  final Urn author=Urn.create(stream.readUTF());
  final String text=stream.readUTF();
  final Date date=new Date(stream.readLong());
  final Bout bout=new BoutNotice.Serial().read(stream).bout();
  return new MessageNotice(){
    @Override public Message message(){
      return new Message(){
        @Override public int hashCode(){
          return this.number().hashCode();
        }
        @Override public boolean equals(        final Object msg){
          return this == msg || (msg instanceof Message && this.number().equals(Message.class.cast(msg).number()));
        }
        @Override public Long number(){
          return number;
        }
        @Override public String text(){
          return text;
        }
        @Override public Identity author(){
          return IdentityNotice.Serial.toIdentity(author);
        }
        @Override public Boolean seen(){
          throw new UnsupportedOperationException();
        }
        @Override public Date date(){
          return date;
        }
        @Override public int compareTo(        final Message msg){
          return this.number().compareTo(msg.number());
        }
        @Override public Bout bout(){
          return bout;
        }
      }
;
    }
  }
;
}","/** 
 * {@inheritDoc}
 */
@Override public MessageNotice read(final DataInputStream stream) throws IOException {
  final long number=stream.readLong();
  final Urn author=Urn.create(stream.readUTF());
  final String text=BigText.read(stream).toString();
  final Date date=new Date(stream.readLong());
  final Bout bout=new BoutNotice.Serial().read(stream).bout();
  return new MessageNotice(){
    @Override public Message message(){
      return new Message(){
        @Override public int hashCode(){
          return this.number().hashCode();
        }
        @Override public boolean equals(        final Object msg){
          return this == msg || (msg instanceof Message && this.number().equals(Message.class.cast(msg).number()));
        }
        @Override public Long number(){
          return number;
        }
        @Override public String text(){
          return text;
        }
        @Override public Identity author(){
          return IdentityNotice.Serial.toIdentity(author);
        }
        @Override public Boolean seen(){
          throw new UnsupportedOperationException();
        }
        @Override public Date date(){
          return date;
        }
        @Override public int compareTo(        final Message msg){
          return this.number().compareTo(msg.number());
        }
        @Override public Bout bout(){
          return bout;
        }
      }
;
    }
  }
;
}",0.9854040583837664
110135,"/** 
 * {@inheritDoc}
 */
@Override public void write(final MessageNotice notice,final DataOutputStream stream) throws IOException {
  stream.writeLong(notice.message().number());
  stream.writeUTF(notice.message().author().name().toString());
  stream.writeUTF(notice.message().text());
  stream.writeLong(notice.message().date().getTime());
  new BoutNotice.Serial().write(new BoutNotice(){
    @Override public Bout bout(){
      return notice.message().bout();
    }
  }
,stream);
}","/** 
 * {@inheritDoc}
 */
@Override public void write(final MessageNotice notice,final DataOutputStream stream) throws IOException {
  stream.writeLong(notice.message().number());
  stream.writeUTF(notice.message().author().name().toString());
  new BigText(notice.message().text()).write(stream);
  stream.writeLong(notice.message().date().getTime());
  new BoutNotice.Serial().write(new BoutNotice(){
    @Override public Bout bout(){
      return notice.message().bout();
    }
  }
,stream);
}",0.920570264765784
110136,"/** 
 * Clean some previous apprequests (or all of them).
 * @param marker The marker to avoid duplicate reminders (or empty stringif you want ALL apprequests to be cleaned for this person)
 * @return Is it clean now and we should post again?
 */
@SuppressWarnings(""String_Node_Str"") public boolean clean(final String marker){
  final Connection<AppRequest> reqs=this.client.fetchConnection(this.path,AppRequest.class);
  boolean clean=true;
  if (!reqs.getData().isEmpty()) {
    for (    AppRequest request : reqs.getData()) {
      if (request.getData().equals(marker) && !marker.isEmpty()) {
        clean=false;
      }
 else {
        this.client.deleteObject(request.getId());
        Logger.info(this,""String_Node_Str"",marker,request.getId());
      }
    }
  }
  return clean;
}","/** 
 * Clean some previous apprequests (or all of them).
 * @param marker The marker to avoid duplicate reminders (or empty stringif you want ALL apprequests to be cleaned for this person)
 * @return Is it clean now and we should post again?
 */
@SuppressWarnings(""String_Node_Str"") public boolean clean(final String marker){
  final Connection<AppRequest> reqs=this.client.fetchConnection(this.path,AppRequest.class);
  boolean clean=true;
  if (!reqs.getData().isEmpty()) {
    for (    AppRequest request : reqs.getData()) {
      if (request.getData().equals(marker) && !marker.isEmpty()) {
        clean=false;
      }
 else {
        this.client.deleteObject(request.getId());
        Logger.info(this,""String_Node_Str"",marker,request.getId());
      }
    }
  }
  Logger.info(this,""String_Node_Str"",marker,clean);
  return clean;
}",0.953259532595326
110137,"/** 
 * Get application access token.
 * @return The token
 */
public String build(){
  final URI uri=UriBuilder.fromPath(""String_Node_Str"").replaceQueryParam(""String_Node_Str"",""String_Node_Str"").replaceQueryParam(""String_Node_Str"",""String_Node_Str"").replaceQueryParam(""String_Node_Str"",""String_Node_Str"").build(Manifests.read(""String_Node_Str""),Manifests.read(""String_Node_Str""));
  final String response=RestTester.start(uri).get(""String_Node_Str"").assertStatus(HttpURLConnection.HTTP_OK).assertBody(Matchers.startsWith(""String_Node_Str"")).getBody();
  return response.split(""String_Node_Str"",2)[1];
}","/** 
 * Get application access token.
 * @return The token
 */
public String build(){
  final URI uri=UriBuilder.fromPath(""String_Node_Str"").queryParam(""String_Node_Str"",""String_Node_Str"").queryParam(""String_Node_Str"",""String_Node_Str"").queryParam(""String_Node_Str"",""String_Node_Str"").build(Manifests.read(""String_Node_Str""),Manifests.read(""String_Node_Str""));
  final String response=RestTester.start(uri).get(""String_Node_Str"").assertStatus(HttpURLConnection.HTTP_OK).assertBody(Matchers.startsWith(""String_Node_Str"")).getBody();
  return response.split(""String_Node_Str"",2)[1];
}",0.9772151898734176
110138,"/** 
 * Login page.
 * @return The JAX-RS response
 * @see <a href=""http://developers.facebook.com/docs/authentication/"">facebook.com</a>
 */
@GET @SuppressWarnings(""String_Node_Str"") public Response login(){
  final UriBuilder fburi=UriBuilder.fromUri(UriBuilder.fromPath(""String_Node_Str"").replaceQueryParam(""String_Node_Str"",""String_Node_Str"").replaceQueryParam(""String_Node_Str"",""String_Node_Str"").build(Manifests.read(""String_Node_Str""),this.base().path(""String_Node_Str"").build()));
  return new PageBuilder().stylesheet(""String_Node_Str"").build(BasePage.class).init(this,false).link(""String_Node_Str"",fburi).render().preserved().build();
}","/** 
 * Login page.
 * @return The JAX-RS response
 * @see <a href=""http://developers.facebook.com/docs/authentication/"">facebook.com</a>
 */
@GET @SuppressWarnings(""String_Node_Str"") public Response login(){
  final UriBuilder fburi=UriBuilder.fromUri(UriBuilder.fromPath(""String_Node_Str"").queryParam(""String_Node_Str"",""String_Node_Str"").queryParam(""String_Node_Str"",""String_Node_Str"").build(Manifests.read(""String_Node_Str""),this.base().path(""String_Node_Str"").build()));
  return new PageBuilder().stylesheet(""String_Node_Str"").build(BasePage.class).init(this,false).link(""String_Node_Str"",fburi).render().preserved().build();
}",0.9859154929577464
110139,"/** 
 * Authenticate as remote identity.
 * @param iname Identity name
 * @param secret Secret word
 * @return Identity
 * @throws IOException If some problem
 */
private RemoteIdentity remote(final Urn iname,final String secret) throws IOException {
  RemoteIdentity remote;
  URL entry;
  try {
    entry=this.resolver.authority(iname);
  }
 catch (  com.netbout.spi.UnreachableUrnException ex) {
    throw new IOException(ex);
  }
  final URI uri=UriBuilder.fromUri(entry.toString()).replaceQueryParam(""String_Node_Str"",""String_Node_Str"").replaceQueryParam(""String_Node_Str"",""String_Node_Str"").build(iname,secret);
  try {
    remote=this.load(uri);
  }
 catch (  IOException ex) {
    throw new IOException(String.format(""String_Node_Str"",iname,uri),ex);
  }
  if (!remote.name().equals(iname) && !iname.nss().isEmpty()) {
    throw new IOException(String.format(""String_Node_Str"",remote.name(),uri,iname));
  }
  return remote;
}","/** 
 * Authenticate as remote identity.
 * @param iname Identity name
 * @param secret Secret word
 * @return Identity
 * @throws IOException If some problem
 */
private RemoteIdentity remote(final Urn iname,final String secret) throws IOException {
  RemoteIdentity remote;
  URL entry;
  try {
    entry=this.resolver.authority(iname);
  }
 catch (  com.netbout.spi.UnreachableUrnException ex) {
    throw new IOException(ex);
  }
  final URI uri=UriBuilder.fromUri(entry.toString()).queryParam(""String_Node_Str"",""String_Node_Str"").queryParam(""String_Node_Str"",""String_Node_Str"").build(iname,secret);
  try {
    remote=this.load(uri);
  }
 catch (  IOException ex) {
    throw new IOException(String.format(""String_Node_Str"",iname,uri),ex);
  }
  if (!remote.name().equals(iname) && !iname.nss().isEmpty()) {
    throw new IOException(String.format(""String_Node_Str"",remote.name(),uri,iname));
  }
  return remote;
}",0.9902912621359224
110140,"/** 
 * Set goto URI.
 * @param uri The URI
 */
@CookieParam(RestSession.GOTO_COOKIE) public void setGoto(final String uri){
  if (uri != null) {
    try {
      this.forward=new URI(SecureString.valueOf(uri).toString());
    }
 catch (    com.netbout.text.StringDecryptionException ex) {
      Logger.warn(this,""String_Node_Str"",uri,ex);
    }
catch (    java.net.URISyntaxException ex) {
      Logger.warn(this,""String_Node_Str"",uri,ex);
    }
  }
  System.out.println(""String_Node_Str"" + this.forward);
}","/** 
 * Set goto URI.
 * @param uri The URI
 */
@CookieParam(RestSession.GOTO_COOKIE) public void setGoto(final String uri){
  if (uri != null) {
    try {
      this.forward=new URI(SecureString.valueOf(uri).text());
    }
 catch (    com.netbout.text.StringDecryptionException ex) {
      Logger.warn(this,""String_Node_Str"",uri,ex);
    }
catch (    java.net.URISyntaxException ex) {
      Logger.warn(this,""String_Node_Str"",uri,ex);
    }
  }
}",0.9308176100628932
110141,"/** 
 * Post something to this stage.
 * @param body Raw HTTP post body
 * @return The JAX-RS response
 */
@POST public Response post(final String body){
  this.coords.normalize(this.hub(),this.bout);
  final String dest=this.hub().make(""String_Node_Str"").synchronously().inBout(this.bout).arg(this.bout.number()).arg(this.identity().name()).arg(this.coords.stage()).arg(this.coords.place()).arg(body).asDefault(""String_Node_Str"").exec();
  return new PageBuilder().build(AbstractPage.class).init(this).authenticated(this.identity()).status(Response.Status.SEE_OTHER).location(this.base().path(""String_Node_Str"").queryParam(BoutRs.PLACE_PARAM,dest).build(this.bout.number())).build();
}","/** 
 * Post something to this stage.
 * @param body Raw HTTP post body
 * @return The JAX-RS response
 */
@POST public Response post(final String body){
  this.coords.normalize(this.hub(),this.bout);
  final String dest=this.hub().make(""String_Node_Str"").synchronously().inBout(this.bout).arg(this.bout.number()).arg(this.identity().name()).arg(this.coords.stage()).arg(this.coords.place()).arg(body).asDefault(""String_Node_Str"").exec();
  return new PageBuilder().build(AbstractPage.class).init(this).authenticated(this.identity()).status(Response.Status.SEE_OTHER).location(this.base().path(""String_Node_Str"").queryParam(BoutRs.PLACE_PARAM,""String_Node_Str"").build(this.bout.number(),dest)).build();
}",0.981294964028777
110142,"/** 
 * Retrieve facebook access token.
 * @param code Facebook ""authorization code""
 * @return The token
 * @throws IOException If some problem with FB
 */
private String token(final String code) throws IOException {
  final String response=this.retrieve(UriBuilder.fromPath(""String_Node_Str"").queryParam(""String_Node_Str"",Manifests.read(""String_Node_Str"")).queryParam(""String_Node_Str"",this.base().path(""String_Node_Str"").build()).queryParam(""String_Node_Str"",Manifests.read(""String_Node_Str"")).queryParam(""String_Node_Str"",code).build());
  final String[] sectors=response.split(""String_Node_Str"");
  for (  String sector : sectors) {
    final String[] pair=sector.split(""String_Node_Str"");
    if (pair.length != 2) {
      throw new IOException(String.format(""String_Node_Str"",response));
    }
    if (""String_Node_Str"".equals(pair[0])) {
      return pair[1];
    }
  }
  throw new IOException(String.format(""String_Node_Str"",response));
}","/** 
 * Retrieve facebook access token.
 * @param code Facebook ""authorization code""
 * @return The token
 * @throws IOException If some problem with FB
 */
private String token(final String code) throws IOException {
  final String response=this.retrieve(UriBuilder.fromPath(""String_Node_Str"").queryParam(""String_Node_Str"",""String_Node_Str"").queryParam(""String_Node_Str"",""String_Node_Str"").queryParam(""String_Node_Str"",""String_Node_Str"").queryParam(""String_Node_Str"",""String_Node_Str"").build(Manifests.read(""String_Node_Str""),this.base().path(""String_Node_Str"").build(),Manifests.read(""String_Node_Str""),code));
  final String[] sectors=response.split(""String_Node_Str"");
  for (  String sector : sectors) {
    final String[] pair=sector.split(""String_Node_Str"");
    if (pair.length != 2) {
      throw new IOException(String.format(""String_Node_Str"",response));
    }
    if (""String_Node_Str"".equals(pair[0])) {
      return pair[1];
    }
  }
  throw new IOException(String.format(""String_Node_Str"",response));
}",0.843765903307888
110143,"/** 
 * Build link to period.
 * @param name Name of this link
 * @param title The title of it
 * @return The link
 */
private Link link(final String name,final String title){
  return new Link(name,String.format(""String_Node_Str"",title,this.total),this.base.clone().queryParam(this.param,this.period));
}","/** 
 * Build link to period.
 * @param name Name of this link
 * @param title The title of it
 * @return The link
 */
private Link link(final String name,final String title){
  return new Link(name,String.format(""String_Node_Str"",title,this.total),UriBuilder.fromUri(this.base.clone().queryParam(this.param,""String_Node_Str"").build(this.period)));
}",0.8977099236641222
110144,"/** 
 * Utc can save date to prepared statement.
 * @throws Exception If there is some problem inside
 */
@Test public void savesDateWithUtcTimezone() throws Exception {
  final Long message=new MessageRowMocker(new BoutRowMocker().mock()).mock();
  this.fmt.setCalendar(new GregorianCalendar(TimeZone.getTimeZone(""String_Node_Str"")));
  final Date date=this.fmt.parse(""String_Node_Str"");
  final Connection conn=Database.connection();
  String saved;
  try {
    final PreparedStatement ustmt=conn.prepareStatement(""String_Node_Str"");
    Utc.setTimestamp(ustmt,1,date);
    ustmt.setLong(2,message);
    ustmt.executeUpdate();
    final PreparedStatement rstmt=conn.prepareStatement(""String_Node_Str"");
    rstmt.setLong(1,message);
    final ResultSet rset=rstmt.executeQuery();
    try {
      if (!rset.next()) {
        throw new IllegalArgumentException();
      }
      saved=rset.getString(1);
    }
  finally {
      rset.close();
    }
  }
  finally {
    conn.close();
  }
  MatcherAssert.assertThat(saved,Matchers.equalTo(""String_Node_Str""));
}","/** 
 * Utc can save date to prepared statement.
 * @throws Exception If there is some problem inside
 */
@Test public void savesDateWithUtcTimezone() throws Exception {
  final Long message=new MessageRowMocker(new BoutRowMocker().mock()).mock();
  this.fmt.setCalendar(new GregorianCalendar(TimeZone.getTimeZone(""String_Node_Str"")));
  final Date date=this.fmt.parse(""String_Node_Str"");
  final Connection conn=Database.connection();
  String saved;
  try {
    final PreparedStatement ustmt=conn.prepareStatement(""String_Node_Str"");
    Utc.setTimestamp(ustmt,1,date);
    ustmt.setLong(2,message);
    ustmt.executeUpdate();
    final PreparedStatement rstmt=conn.prepareStatement(""String_Node_Str"");
    rstmt.setLong(1,message);
    final ResultSet rset=rstmt.executeQuery();
    try {
      if (!rset.next()) {
        throw new IllegalArgumentException();
      }
      saved=rset.getString(1);
    }
  finally {
      rset.close();
    }
  }
  finally {
    conn.close();
  }
  MatcherAssert.assertThat(saved,Matchers.startsWith(""String_Node_Str""));
}",0.9919697685403872
110145,"/** 
 * Utc can set and read message date, with different timezone.
 * @throws Exception If there is some problem inside
 */
@Test public void setsAndReadsDateWithDifferentTimezone() throws Exception {
  final Long message=new MessageRowMocker(new BoutRowMocker().mock()).mock();
  final Date date=new Date();
  new MessageFarm().changedMessageDate(message,date);
  final Connection conn=Database.connection();
  String saved;
  try {
    final PreparedStatement stmt=conn.prepareStatement(""String_Node_Str"");
    stmt.setLong(1,message);
    final ResultSet rset=stmt.executeQuery();
    try {
      if (!rset.next()) {
        throw new IllegalStateException();
      }
      saved=rset.getString(1);
    }
  finally {
      rset.close();
    }
  }
  finally {
    conn.close();
  }
  this.fmt.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
  final Date absolute=this.fmt.parse(saved);
  MatcherAssert.assertThat(absolute,Matchers.equalTo(date));
}","/** 
 * Utc can set and read message date, with different timezone.
 * @throws Exception If there is some problem inside
 */
@Test public void setsAndReadsDateWithDifferentTimezone() throws Exception {
  final Long message=new MessageRowMocker(new BoutRowMocker().mock()).mock();
  final Date date=new Date();
  new MessageFarm().changedMessageDate(message,date);
  final Connection conn=Database.connection();
  String saved;
  try {
    final PreparedStatement stmt=conn.prepareStatement(""String_Node_Str"");
    stmt.setLong(1,message);
    final ResultSet rset=stmt.executeQuery();
    try {
      if (!rset.next()) {
        throw new IllegalStateException();
      }
      saved=rset.getString(1);
    }
  finally {
      rset.close();
    }
  }
  finally {
    conn.close();
  }
  this.fmt.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
  final Date absolute=this.fmt.parse(saved);
  MatcherAssert.assertThat(absolute.toString(),Matchers.equalTo(date.toString()));
}",0.9886363636363636
110146,"/** 
 * Utc can load date from result set.
 * @throws Exception If there is some problem inside
 */
@Test public void loadsDateWithUtcTimezone() throws Exception {
  final Long message=new MessageRowMocker(new BoutRowMocker().mock()).mock();
  final Connection conn=Database.connection();
  Date loaded;
  try {
    final PreparedStatement ustmt=conn.prepareStatement(""String_Node_Str"");
    ustmt.setString(1,""String_Node_Str"");
    ustmt.setLong(2,message);
    ustmt.executeUpdate();
    final PreparedStatement rstmt=conn.prepareStatement(""String_Node_Str"");
    rstmt.setLong(1,message);
    final ResultSet rset=rstmt.executeQuery();
    try {
      if (!rset.next()) {
        throw new IllegalArgumentException();
      }
      loaded=Utc.getTimestamp(rset,1);
    }
  finally {
      rset.close();
    }
  }
  finally {
    conn.close();
  }
  this.fmt.setCalendar(new GregorianCalendar(TimeZone.getTimeZone(""String_Node_Str"")));
  MatcherAssert.assertThat(this.fmt.format(loaded),Matchers.equalTo(""String_Node_Str""));
}","/** 
 * Utc can load date from result set.
 * @throws Exception If there is some problem inside
 */
@Test public void loadsDateWithUtcTimezone() throws Exception {
  final Long message=new MessageRowMocker(new BoutRowMocker().mock()).mock();
  final Connection conn=Database.connection();
  Date loaded;
  try {
    final PreparedStatement ustmt=conn.prepareStatement(""String_Node_Str"");
    ustmt.setString(1,""String_Node_Str"");
    ustmt.setLong(2,message);
    ustmt.executeUpdate();
    final PreparedStatement rstmt=conn.prepareStatement(""String_Node_Str"");
    rstmt.setLong(1,message);
    final ResultSet rset=rstmt.executeQuery();
    try {
      if (!rset.next()) {
        throw new IllegalArgumentException();
      }
      loaded=Utc.getTimestamp(rset,1);
    }
  finally {
      rset.close();
    }
  }
  finally {
    conn.close();
  }
  this.fmt.setCalendar(new GregorianCalendar(TimeZone.getTimeZone(""String_Node_Str"")));
  MatcherAssert.assertThat(this.fmt.format(loaded),Matchers.startsWith(""String_Node_Str""));
}",0.9917515769044152
110147,"/** 
 * Changed message date.
 * @param number The bout where it happened
 * @param date The date of the message to change
 * @throws SQLException If some SQL problem inside
 */
@Operation(""String_Node_Str"") public void changedMessageDate(final Long number,final Date date) throws SQLException {
  final long start=System.currentTimeMillis();
  final Connection conn=Database.connection();
  try {
    final PreparedStatement stmt=conn.prepareStatement(""String_Node_Str"");
    stmt.setTimestamp(1,new Timestamp(date.getTime()));
    stmt.setLong(2,number);
    final int updated=stmt.executeUpdate();
    if (updated != 1) {
      throw new SQLException(String.format(""String_Node_Str"",number,date));
    }
  }
  finally {
    conn.close();
  }
  Logger.debug(this,""String_Node_Str"",number,date,System.currentTimeMillis() - start);
}","/** 
 * Changed message date.
 * @param number The bout where it happened
 * @param date The date of the message to change
 * @throws SQLException If some SQL problem inside
 */
@Operation(""String_Node_Str"") public void changedMessageDate(final Long number,final Date date) throws SQLException {
  final long start=System.currentTimeMillis();
  final Connection conn=Database.connection();
  try {
    final PreparedStatement stmt=conn.prepareStatement(""String_Node_Str"");
    Utc.setTimestamp(stmt,1,date);
    stmt.setLong(2,number);
    final int updated=stmt.executeUpdate();
    if (updated != 1) {
      throw new SQLException(String.format(""String_Node_Str"",number,date));
    }
  }
  finally {
    conn.close();
  }
  Logger.debug(this,""String_Node_Str"",number,date,System.currentTimeMillis() - start);
}",0.972644376899696
110148,"/** 
 * Get message date.
 * @param number Number of the message
 * @return The date
 * @throws SQLException If some SQL problem inside
 */
@Operation(""String_Node_Str"") public Date getMessageDate(final Long number) throws SQLException {
  final long start=System.currentTimeMillis();
  final Connection conn=Database.connection();
  Date date;
  try {
    final PreparedStatement stmt=conn.prepareStatement(""String_Node_Str"");
    stmt.setLong(1,number);
    final ResultSet rset=stmt.executeQuery();
    try {
      if (!rset.next()) {
        throw new IllegalArgumentException(String.format(""String_Node_Str"",number));
      }
      date=new Date(rset.getTimestamp(1).getTime());
    }
  finally {
      rset.close();
    }
  }
  finally {
    conn.close();
  }
  Logger.debug(this,""String_Node_Str"",number,date,System.currentTimeMillis() - start);
  return date;
}","/** 
 * Get message date.
 * @param number Number of the message
 * @return The date
 * @throws SQLException If some SQL problem inside
 */
@Operation(""String_Node_Str"") public Date getMessageDate(final Long number) throws SQLException {
  final long start=System.currentTimeMillis();
  final Connection conn=Database.connection();
  Date date;
  try {
    final PreparedStatement stmt=conn.prepareStatement(""String_Node_Str"");
    stmt.setLong(1,number);
    final ResultSet rset=stmt.executeQuery();
    try {
      if (!rset.next()) {
        throw new IllegalArgumentException(String.format(""String_Node_Str"",number));
      }
      date=Utc.getTimestamp(rset,1);
    }
  finally {
      rset.close();
    }
  }
  finally {
    conn.close();
  }
  Logger.debug(this,""String_Node_Str"",number,date,System.currentTimeMillis() - start);
  return date;
}",0.9814169570267132
110149,"/** 
 * Facebook authentication page (callback hits it).
 * @param code Facebook ""authorization code""
 * @return The JAX-RS response
 */
@GET @Path(""String_Node_Str"") public Response fbauth(@QueryParam(""String_Node_Str"") final String code){
  this.logoff();
  final Identity remote=(Identity)new FacebookRs().auth(Urn.create(""String_Node_Str""),code).getEntity();
  Identity identity;
  try {
    identity=this.hub().identity(remote.name());
  }
 catch (  com.netbout.spi.UnreachableUrnException ex) {
    throw new LoginRequiredException(this,ex);
  }
  return new PageBuilder().build(AbstractPage.class).init(this).authenticated(identity).status(Response.Status.SEE_OTHER).location(this.base().build()).build();
}","/** 
 * Facebook authentication page (callback hits it).
 * @param code Facebook ""authorization code""
 * @return The JAX-RS response
 */
@GET @Path(""String_Node_Str"") public Response fbauth(@QueryParam(""String_Node_Str"") final String code){
  this.logoff();
  Identity remote;
  try {
    remote=new AuthMediator(this.hub().resolver()).authenticate(new Urn(""String_Node_Str"",""String_Node_Str""),code);
  }
 catch (  java.io.IOException ex) {
    throw new LoginRequiredException(this,ex);
  }
  Identity identity;
  try {
    identity=this.hub().identity(remote.name());
  }
 catch (  com.netbout.spi.UnreachableUrnException ex) {
    throw new LoginRequiredException(this,ex);
  }
  return new PageBuilder().build(AbstractPage.class).init(this).authenticated(identity).status(Response.Status.SEE_OTHER).location(this.base().build()).build();
}",0.8439306358381503
110150,"/** 
 * Authenticate the user through facebook.
 * @param iname Identity name
 * @param secret Secret word
 * @return The identity found
 */
private Identity authenticate(final Urn iname,final String secret){
  final Identity remote=this.remote(iname,secret);
  Identity identity;
  try {
    identity=this.hub().identity(iname);
  }
 catch (  com.netbout.spi.UnreachableUrnException ex) {
    throw new LoginRequiredException(this,ex);
  }
  for (  String alias : remote.aliases()) {
    identity.alias(alias);
  }
  identity.setPhoto(remote.photo());
  return identity;
}","/** 
 * Authenticate the user through facebook.
 * @param iname Identity name
 * @param secret Secret word
 * @return The identity found
 */
private Identity authenticate(final Urn iname,final String secret){
  Identity remote;
  try {
    remote=new AuthMediator(this.hub().resolver()).authenticate(iname,secret);
  }
 catch (  java.io.IOException ex) {
    throw new LoginRequiredException(this,ex);
  }
  Identity identity;
  try {
    identity=this.hub().identity(iname);
  }
 catch (  com.netbout.spi.UnreachableUrnException ex) {
    throw new LoginRequiredException(this,ex);
  }
  for (  String alias : remote.aliases()) {
    identity.alias(alias);
  }
  identity.setPhoto(remote.photo());
  return identity;
}",0.8173374613003096
110151,"/** 
 * Authentication page.
 * @param iname Name of identity
 * @param secret The secret code
 * @return The JAX-RS response
 */
@GET public Response auth(@QueryParam(""String_Node_Str"") final Urn iname,@QueryParam(""String_Node_Str"") final String secret){
  if (iname == null || secret == null) {
    throw new LoginRequiredException(this,""String_Node_Str"");
  }
  Identity identity;
  try {
    identity=this.authenticate(secret);
  }
 catch (  IOException ex) {
    throw new LoginRequiredException(this,ex);
  }
  Logger.debug(this,""String_Node_Str"",iname,secret);
  return new PageBuilder().build(AbstractPage.class).init(this).authenticated(identity).build();
}","/** 
 * Authentication page.
 * @param iname Name of identity
 * @param secret The secret code
 * @return The JAX-RS response
 */
@GET public Response auth(@QueryParam(""String_Node_Str"") final Urn iname,@QueryParam(""String_Node_Str"") final String secret){
  if (iname == null || secret == null) {
    throw new LoginRequiredException(this,""String_Node_Str"");
  }
  Identity identity;
  try {
    identity=this.authenticate(secret);
  }
 catch (  IOException ex) {
    Logger.warn(this,""String_Node_Str"",secret,ex);
    throw new LoginRequiredException(this,ex);
  }
  Logger.debug(this,""String_Node_Str"",iname,secret);
  return new PageBuilder().build(AbstractPage.class).init(this).authenticated(identity).build();
}",0.9631236442516268
110152,"@SuppressWarnings(""String_Node_Str"") protected void loadLocationFile(String filename) throws JsonParseException, JsonMappingException, IOException {
  ObjectMapper mapper=new ObjectMapper();
  Scanner inputScanner=new Scanner(new FileInputStream(filename));
  while (inputScanner.hasNextLine()) {
    String line=inputScanner.nextLine();
    Map<String,Object> locationObj=mapper.readValue(line,Map.class);
    Location location=Location.parseLocationFromJsonObj(locationObj);
    List<String> aliases=(List<String>)locationObj.get(""String_Node_Str"");
    this.idToLocation.put(location.getId(),location);
    this.locationToId.put(location,location.getId());
    HashSet<String> justAddedAliases=new HashSet<String>();
    for (    String alias : aliases) {
      if (justAddedAliases.contains(alias))       continue;
      if (this.locationNameToLocation.containsKey(alias))       logger.warn(""String_Node_Str"" + alias);
 else       this.locationNameToLocation.put(alias,location);
      justAddedAliases.add(alias);
      String newEntry=alias.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
      if (justAddedAliases.contains(newEntry))       continue;
      if (!newEntry.equals(alias)) {
        if (this.locationNameToLocation.containsKey(newEntry))         logger.warn(""String_Node_Str"" + newEntry);
 else         this.locationNameToLocation.put(newEntry,location);
      }
      justAddedAliases.add(newEntry);
    }
  }
  inputScanner.close();
}","@SuppressWarnings(""String_Node_Str"") protected void loadLocationFile(String filename) throws JsonParseException, JsonMappingException, IOException {
  ObjectMapper mapper=new ObjectMapper();
  Scanner inputScanner=new Scanner(new FileInputStream(filename));
  while (inputScanner.hasNextLine()) {
    String line=inputScanner.nextLine();
    Map<String,Object> locationObj=mapper.readValue(line,Map.class);
    Location location=Location.parseLocationFromJsonObj(locationObj);
    List<String> aliases=(List<String>)locationObj.get(""String_Node_Str"");
    this.idToLocation.put(location.getId(),location);
    this.locationToId.put(location,location.getId());
    HashSet<String> justAddedAliases=new HashSet<String>();
    if (aliases != null) {
      for (      String alias : aliases) {
        if (justAddedAliases.contains(alias))         continue;
        if (this.locationNameToLocation.containsKey(alias))         logger.warn(""String_Node_Str"" + alias);
 else         this.locationNameToLocation.put(alias,location);
        justAddedAliases.add(alias);
        String newEntry=alias.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
        if (justAddedAliases.contains(newEntry))         continue;
        if (!newEntry.equals(alias)) {
          if (this.locationNameToLocation.containsKey(newEntry))           logger.warn(""String_Node_Str"" + newEntry);
 else           this.locationNameToLocation.put(newEntry,location);
        }
        justAddedAliases.add(newEntry);
      }
    }
  }
  inputScanner.close();
}",0.9477102955505036
110153,"protected LocationResolver() throws IOException {
  logger.info(""String_Node_Str"");
  this.usePlace=CarmenProperties.getBoolean(""String_Node_Str"");
  this.useGeocodes=CarmenProperties.getBoolean(""String_Node_Str"");
  this.useUserString=CarmenProperties.getBoolean(""String_Node_Str"");
  this.useKnownParentForUnknownPlaces=CarmenProperties.getBoolean(""String_Node_Str"");
  this.useUnknownPlaces=CarmenProperties.getBoolean(""String_Node_Str"");
  logger.info(""String_Node_Str"");
  if (this.usePlace)   logger.info(""String_Node_Str"");
  if (this.useGeocodes)   logger.info(""String_Node_Str"");
  if (this.useUserString)   logger.info(""String_Node_Str"");
  logger.info(""String_Node_Str"");
  loadLocationFile(CarmenProperties.getString(""String_Node_Str""));
  this.idToLocation.put(-1,Location.getNoneLocation());
  HashSet<Location> knownLocations=new HashSet<Location>();
  for (  Location location : this.idToLocation.values()) {
    knownLocations.add(location);
  }
  for (  Location location : knownLocations) {
    Location parent=this.idToLocation.get(location.getParentId());
    if (parent != null) {
      this.locationToParent.put(location,parent);
      if (!this.locationToChildren.containsKey(parent))       this.locationToChildren.put(parent,new LinkedList<Location>());
      this.locationToChildren.get(parent).add(location);
    }
  }
  if (this.usePlace) {
    loadNameAndAbbreviation(CarmenProperties.getString(""String_Node_Str""),null,this.placeNameToNormalizedPlaceName,false);
  }
  loadNameAndAbbreviation(CarmenProperties.getString(""String_Node_Str""),this.stateFullNames,this.stateAbbreviationToFullName,true);
  loadNameAndAbbreviation(CarmenProperties.getString(""String_Node_Str""),this.countryFullNames,this.countryAbbreviationToFullName,true);
  if (this.useGeocodes) {
    this.geocodeLocationResolver=new GeocodeLocationResolver();
    for (    Location location : this.idToLocation.values())     this.geocodeLocationResolver.addLocation(location);
  }
}","protected LocationResolver() throws IOException {
  this.usePlace=CarmenProperties.getBoolean(""String_Node_Str"");
  this.useGeocodes=CarmenProperties.getBoolean(""String_Node_Str"");
  this.useUserString=CarmenProperties.getBoolean(""String_Node_Str"");
  this.useKnownParentForUnknownPlaces=CarmenProperties.getBoolean(""String_Node_Str"");
  this.useUnknownPlaces=CarmenProperties.getBoolean(""String_Node_Str"");
  logger.info(""String_Node_Str"");
  if (this.usePlace)   logger.info(""String_Node_Str"");
  if (this.useGeocodes)   logger.info(""String_Node_Str"");
  if (this.useUserString)   logger.info(""String_Node_Str"");
  logger.info(""String_Node_Str"" + useKnownParentForUnknownPlaces);
  logger.info(""String_Node_Str"" + useUnknownPlaces);
  logger.info(""String_Node_Str"");
  loadLocationFile(CarmenProperties.getString(""String_Node_Str""));
  this.idToLocation.put(-1,Location.getNoneLocation());
  HashSet<Location> knownLocations=new HashSet<Location>();
  for (  Location location : this.idToLocation.values()) {
    knownLocations.add(location);
  }
  for (  Location location : knownLocations) {
    Location parent=this.idToLocation.get(location.getParentId());
    if (parent != null) {
      this.locationToParent.put(location,parent);
      if (!this.locationToChildren.containsKey(parent))       this.locationToChildren.put(parent,new LinkedList<Location>());
      this.locationToChildren.get(parent).add(location);
    }
  }
  if (this.usePlace) {
    loadNameAndAbbreviation(CarmenProperties.getString(""String_Node_Str""),null,this.placeNameToNormalizedPlaceName,false);
  }
  loadNameAndAbbreviation(CarmenProperties.getString(""String_Node_Str""),this.stateFullNames,this.stateAbbreviationToFullName,true);
  loadNameAndAbbreviation(CarmenProperties.getString(""String_Node_Str""),this.countryFullNames,this.countryAbbreviationToFullName,true);
  if (this.useGeocodes) {
    this.geocodeLocationResolver=new GeocodeLocationResolver();
    for (    Location location : this.idToLocation.values())     this.geocodeLocationResolver.addLocation(location);
  }
}",0.9618623080733036
110154,"public Location resolveLocationFromTweet(Map<String,Object> tweet){
  Location location=null;
  Location provisionalLocation=null;
  if (this.usePlace) {
    location=resolveLocationUsingPlace(tweet);
    if (location != null) {
      location.setResolutionMethod(ResolutionMethod.PLACE);
      if (!location.isKnownLocation()) {
        if (this.useUnknownPlaces)         registerNewLocation(location);
 else         if (this.useKnownParentForUnknownPlaces) {
          Location parent=this.createParentOfLocation(location,false);
          while (parent != null && !parent.isKnownLocation()) {
            parent=this.createParentOfLocation(parent,false);
          }
          if (parent != null && parent.isKnownLocation())           provisionalLocation=parent;
        }
 else         location=null;
      }
    }
  }
  if (location == null && this.useGeocodes) {
    location=resolveLocationUsingGeocodes(tweet);
    if (location != null)     location.setResolutionMethod(ResolutionMethod.COORDINATES);
  }
  if (location == null && this.useUserString) {
    location=resolveLocationUsingUserLocation(tweet);
    if (location != null)     location.setResolutionMethod(ResolutionMethod.USER_LOCATION);
  }
  if (location == null && provisionalLocation != null)   location=provisionalLocation;
  return location;
}","public Location resolveLocationFromTweet(Map<String,Object> tweet){
  Location location=null;
  Location provisionalLocation=null;
  if (this.usePlace) {
    location=resolveLocationUsingPlace(tweet);
    if (location != null) {
      location.setResolutionMethod(ResolutionMethod.PLACE);
      if (!location.isKnownLocation()) {
        if (this.useUnknownPlaces)         registerNewLocation(location);
 else         if (this.useKnownParentForUnknownPlaces) {
          Location parent=this.createParentOfLocation(location,false);
          location=null;
          while (parent != null && !parent.isKnownLocation()) {
            parent=this.createParentOfLocation(parent,false);
          }
          if (parent != null && parent.isKnownLocation())           provisionalLocation=parent;
        }
 else         location=null;
      }
    }
  }
  if (location == null && this.useGeocodes) {
    location=resolveLocationUsingGeocodes(tweet);
    if (location != null)     location.setResolutionMethod(ResolutionMethod.COORDINATES);
  }
  if (location == null && this.useUserString) {
    location=resolveLocationUsingUserLocation(tweet);
    if (location != null)     location.setResolutionMethod(ResolutionMethod.USER_LOCATION);
  }
  if (location == null && provisionalLocation != null)   location=provisionalLocation;
  return location;
}",0.9906050357008644
110155,"public static Location parseLocationFromJsonObj(Map<String,Object> locationMap){
  String country=Utils.getNullForEmptyString((String)locationMap.get(""String_Node_Str""));
  String state=Utils.getNullForEmptyString((String)locationMap.get(""String_Node_Str""));
  String county=Utils.getNullForEmptyString((String)locationMap.get(""String_Node_Str""));
  String city=Utils.getNullForEmptyString((String)locationMap.get(""String_Node_Str""));
  int id=Integer.parseInt((String)locationMap.get(""String_Node_Str""));
  double latitude=Double.parseDouble((String)locationMap.get(""String_Node_Str""));
  double longitude=Double.parseDouble((String)locationMap.get(""String_Node_Str""));
  int parentId=Integer.parseInt((String)locationMap.get(""String_Node_Str""));
  return new Location(country,state,county,city,latitude,longitude,id,parentId,true);
}","public static Location parseLocationFromJsonObj(Map<String,Object> locationMap){
  String country=Utils.getNullForEmptyString((String)locationMap.get(""String_Node_Str""));
  String state=Utils.getNullForEmptyString((String)locationMap.get(""String_Node_Str""));
  String county=Utils.getNullForEmptyString((String)locationMap.get(""String_Node_Str""));
  String city=Utils.getNullForEmptyString((String)locationMap.get(""String_Node_Str""));
  int id=Integer.parseInt((String)locationMap.get(""String_Node_Str""));
  double latitude=0;
  double longitude=0;
  if (locationMap.containsKey(""String_Node_Str""))   latitude=Double.parseDouble((String)locationMap.get(""String_Node_Str""));
  if (locationMap.containsKey(""String_Node_Str""))   longitude=Double.parseDouble((String)locationMap.get(""String_Node_Str""));
  int parentId=Integer.parseInt((String)locationMap.get(""String_Node_Str""));
  return new Location(country,state,county,city,latitude,longitude,id,parentId,true);
}",0.8482490272373541
110156,"/** 
 * Does this location object contain the provided location?
 * @param location
 * @return
 * @throws ClassNotFoundException 
 * @throws IOException 
 */
public boolean containsLocation(Location location) throws IOException, ClassNotFoundException {
  while (location != null) {
    if (this.equals(location))     return true;
    location=LocationResolver.getLocationResolver().getParent(location);
  }
  return false;
}","/** 
 * Does this location object contain the provided location?
 * @param location
 * @return
 * @throws ClassNotFoundException 
 * @throws IOException 
 */
public boolean containsLocation(Location location) throws IOException, ClassNotFoundException {
  while (location != null && !location.isNone()) {
    if (this.equals(location))     return true;
    location=LocationResolver.getLocationResolver().getParent(location);
  }
  return false;
}",0.9747706422018348
110157,"public static void main(String[] args) throws ParseException, FileNotFoundException, IOException, ClassNotFoundException {
  String[] manditory_args={""String_Node_Str""};
  createCommandLineOptions();
  CommandLineUtilities.initCommandLineParameters(args,LocationResolverDemo.options,manditory_args);
  String inputFile=CommandLineUtilities.getOptionValue(""String_Node_Str"");
  String outputFile=null;
  if (CommandLineUtilities.hasArg(""String_Node_Str"")) {
    outputFile=CommandLineUtilities.getOptionValue(""String_Node_Str"");
  }
  logger.info(""String_Node_Str"");
  LocationResolver resolver=LocationResolver.getLocationResolver();
  Scanner scanner=Utils.createScanner(inputFile);
  Writer writer=null;
  if (outputFile != null) {
    writer=Utils.createWriter(outputFile);
    logger.info(""String_Node_Str"" + outputFile);
  }
  ObjectMapper mapper=new ObjectMapper();
  int numResolved=0;
  int total=0;
  while (scanner.hasNextLine()) {
    String line=scanner.nextLine();
    @SuppressWarnings(""String_Node_Str"") HashMap<String,Object> tweet=(HashMap<String,Object>)mapper.readValue(line,Map.class);
    total++;
    Location location=resolver.resolveLocationFromTweet(tweet);
    if (location != null) {
      logger.debug(""String_Node_Str"" + location.toString());
      numResolved++;
    }
    if (writer != null) {
      if (location != null) {
        tweet.put(""String_Node_Str"",Location.createJsonFromLocation(location));
      }
      mapper.writeValue(writer,tweet);
      writer.write(""String_Node_Str"");
    }
  }
  scanner.close();
  writer.close();
  logger.info(""String_Node_Str"" + numResolved + ""String_Node_Str""+ total+ ""String_Node_Str"");
}","public static void main(String[] args) throws ParseException, FileNotFoundException, IOException, ClassNotFoundException {
  String[] manditory_args={""String_Node_Str""};
  createCommandLineOptions();
  CommandLineUtilities.initCommandLineParameters(args,LocationResolverDemo.options,manditory_args);
  String inputFile=CommandLineUtilities.getOptionValue(""String_Node_Str"");
  String outputFile=null;
  if (CommandLineUtilities.hasArg(""String_Node_Str"")) {
    outputFile=CommandLineUtilities.getOptionValue(""String_Node_Str"");
  }
  logger.info(""String_Node_Str"");
  LocationResolver resolver=LocationResolver.getLocationResolver();
  Scanner scanner=Utils.createScanner(inputFile);
  Writer writer=null;
  if (outputFile != null) {
    writer=Utils.createWriter(outputFile);
    logger.info(""String_Node_Str"" + outputFile);
  }
  ObjectMapper mapper=new ObjectMapper();
  int numResolved=0;
  int total=0;
  while (scanner.hasNextLine()) {
    String line=scanner.nextLine();
    @SuppressWarnings(""String_Node_Str"") HashMap<String,Object> tweet=(HashMap<String,Object>)mapper.readValue(line,Map.class);
    total++;
    Location location=resolver.resolveLocationFromTweet(tweet);
    if (location != null) {
      logger.debug(""String_Node_Str"" + location.toString());
      numResolved++;
    }
    if (writer != null) {
      if (location != null) {
        tweet.put(""String_Node_Str"",Location.createJsonFromLocation(location));
      }
      mapper.writeValue(writer,tweet);
      writer.write(""String_Node_Str"");
    }
  }
  scanner.close();
  if (writer != null)   writer.close();
  logger.info(""String_Node_Str"" + numResolved + ""String_Node_Str""+ total+ ""String_Node_Str"");
}",0.9934289127837514
110158,"@Override public void onError(Throwable e){
  mIsLoading=false;
  mHasError=true;
  if (mList == null || mList.isEmpty()) {
    mView.contentLoadingError();
  }
}","@Override public void onError(Throwable e){
  mIsLoading=false;
  mHasError=true;
  mCurPage--;
  if (mList == null || mList.isEmpty()) {
    mView.contentLoadingError();
  }
  mView.loadDataComplete(null);
}",0.8756756756756757
110159,"@Override public void loadDataNext(){
  ++mCurPage;
  mIsLoading=true;
  mModel.loadData(mParams,mCurPage).subscribe(new Observer<IPageModel<B>>(){
    @Override public void onError(    Throwable e){
      mIsLoading=false;
      mHasError=true;
      if (mList == null || mList.isEmpty()) {
        mView.contentLoadingError();
      }
    }
    @Override public void onComplete(){
      mIsLoading=false;
      mHasError=false;
      if (mList == null || mList.isEmpty()) {
        mView.contentLoadingEmpty();
      }
 else {
        mView.contentLoadingComplete();
      }
      mView.loadDataComplete(mCurrentPageList);
    }
    @Override public void onSubscribe(    @NonNull Disposable d){
      mRxManage.add(d);
    }
    @Override public void onNext(    IPageModel<B> pageModel){
      mPageModel=pageModel;
      if (mCurPage == 1) {
        mList.clear();
      }
      if (pageModel.getDataList() != null && !pageModel.getDataList().isEmpty()) {
        mList.addAll(pageModel.getDataList());
        mCurrentPageList.clear();
        mCurrentPageList.addAll(pageModel.getDataList());
      }
    }
  }
);
}","@Override public void loadDataNext(){
  ++mCurPage;
  mIsLoading=true;
  mModel.loadData(mParams,mCurPage).subscribe(new Observer<IPageModel<B>>(){
    @Override public void onError(    Throwable e){
      mIsLoading=false;
      mHasError=true;
      mCurPage--;
      if (mList == null || mList.isEmpty()) {
        mView.contentLoadingError();
      }
      mView.loadDataComplete(null);
    }
    @Override public void onComplete(){
      mIsLoading=false;
      mHasError=false;
      if (mList == null || mList.isEmpty()) {
        mView.contentLoadingEmpty();
      }
 else {
        mView.contentLoadingComplete();
      }
      mView.loadDataComplete(mCurrentPageList);
    }
    @Override public void onSubscribe(    @NonNull Disposable d){
      mRxManage.add(d);
    }
    @Override public void onNext(    IPageModel<B> pageModel){
      mPageModel=pageModel;
      if (mCurPage == 1) {
        mList.clear();
      }
      if (pageModel.getDataList() != null && !pageModel.getDataList().isEmpty()) {
        mList.addAll(pageModel.getDataList());
        mCurrentPageList.clear();
        mCurrentPageList.addAll(pageModel.getDataList());
      }
    }
  }
);
}",0.976460331299041
110160,"@Override protected void onHandleIntent(Intent intent){
  mNotifyManager=(NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);
  mBuilder=new Builder(this);
  String appName=getString(getApplicationInfo().labelRes);
  int icon=getApplicationInfo().icon;
  mBuilder.setContentTitle(appName).setSmallIcon(icon);
  String urlStr=intent.getStringExtra(Constants.APK_DOWNLOAD_URL);
  InputStream in=null;
  FileOutputStream out=null;
  try {
    URL url=new URL(urlStr);
    HttpURLConnection urlConnection=(HttpURLConnection)url.openConnection();
    urlConnection.setRequestMethod(""String_Node_Str"");
    urlConnection.setDoOutput(false);
    urlConnection.setConnectTimeout(10 * 1000);
    urlConnection.setReadTimeout(10 * 1000);
    urlConnection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    urlConnection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    urlConnection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    urlConnection.connect();
    long bytetotal=urlConnection.getContentLength();
    long bytesum=0;
    int byteread=0;
    in=urlConnection.getInputStream();
    File dir=StorageUtils.getCacheDirectory(this);
    String apkName=urlStr.substring(urlStr.lastIndexOf(""String_Node_Str"") + 1,urlStr.length());
    File apkFile=new File(dir,apkName);
    out=new FileOutputStream(apkFile);
    byte[] buffer=new byte[BUFFER_SIZE];
    int oldProgress=0;
    while ((byteread=in.read(buffer)) != -1) {
      bytesum+=byteread;
      out.write(buffer,0,byteread);
      int progress=(int)(bytesum * 100L / bytetotal);
      if (progress != oldProgress) {
        updateProgress(progress);
      }
      oldProgress=progress;
    }
    mBuilder.setContentText(getString(R.string.arad_download_success)).setProgress(0,0,false);
    Intent installAPKIntent=new Intent(Intent.ACTION_VIEW);
    String[] command={""String_Node_Str"",""String_Node_Str"",apkFile.toString()};
    ProcessBuilder builder=new ProcessBuilder(command);
    builder.start();
    installAPKIntent.setDataAndType(Uri.fromFile(apkFile),""String_Node_Str"");
    PendingIntent pendingIntent=PendingIntent.getActivity(this,0,installAPKIntent,PendingIntent.FLAG_UPDATE_CURRENT);
    mBuilder.setContentIntent(pendingIntent);
    Notification noti=mBuilder.build();
    noti.flags=Notification.FLAG_AUTO_CANCEL;
    mNotifyManager.notify(0,noti);
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
 finally {
    if (out != null) {
      try {
        out.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
    if (in != null) {
      try {
        in.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
}","@Override protected void onHandleIntent(Intent intent){
  mNotifyManager=(NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);
  mBuilder=new Builder(this);
  String appName=getString(getApplicationInfo().labelRes);
  int icon=getApplicationInfo().icon;
  mBuilder.setContentTitle(appName).setSmallIcon(icon);
  String urlStr=intent.getStringExtra(UpdateChecker.APP_UPDATE_URL);
  InputStream in=null;
  FileOutputStream out=null;
  try {
    URL url=new URL(urlStr);
    HttpURLConnection urlConnection=(HttpURLConnection)url.openConnection();
    urlConnection.setRequestMethod(""String_Node_Str"");
    urlConnection.setDoOutput(false);
    urlConnection.setConnectTimeout(10 * 1000);
    urlConnection.setReadTimeout(10 * 1000);
    urlConnection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    urlConnection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    urlConnection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    urlConnection.connect();
    long bytetotal=urlConnection.getContentLength();
    long bytesum=0;
    int byteread=0;
    in=urlConnection.getInputStream();
    File dir=StorageUtils.getCacheDirectory(this);
    String apkName=urlStr.substring(urlStr.lastIndexOf(""String_Node_Str"") + 1,urlStr.length());
    File apkFile=new File(dir,apkName);
    out=new FileOutputStream(apkFile);
    byte[] buffer=new byte[BUFFER_SIZE];
    int oldProgress=0;
    while ((byteread=in.read(buffer)) != -1) {
      bytesum+=byteread;
      out.write(buffer,0,byteread);
      int progress=(int)(bytesum * 100L / bytetotal);
      if (progress != oldProgress) {
        updateProgress(progress);
      }
      oldProgress=progress;
    }
    mBuilder.setContentText(getString(R.string.arad_download_success)).setProgress(0,0,false);
    Intent installAPKIntent=new Intent(Intent.ACTION_VIEW);
    String[] command={""String_Node_Str"",""String_Node_Str"",apkFile.toString()};
    ProcessBuilder builder=new ProcessBuilder(command);
    builder.start();
    installAPKIntent.setDataAndType(Uri.fromFile(apkFile),""String_Node_Str"");
    PendingIntent pendingIntent=PendingIntent.getActivity(this,0,installAPKIntent,PendingIntent.FLAG_UPDATE_CURRENT);
    mBuilder.setContentIntent(pendingIntent);
    Notification noti=mBuilder.build();
    noti.flags=Notification.FLAG_AUTO_CANCEL;
    mNotifyManager.notify(0,noti);
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
 finally {
    if (out != null) {
      try {
        out.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
    if (in != null) {
      try {
        in.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
}",0.9937706119457675
110161,"public JsonNode handleResult(String result) throws AradException {
  try {
    JsonNode node=JsonUtil.json2node(result);
    JsonNode error=node.findValue(errorKey);
    if (error == null || errorCodes.contains(error.asText())) {
      return node;
    }
 else {
      String statue=error.asText();
      AradException e=new AradException();
      e.setError_code(statue);
      throw e;
    }
  }
 catch (  JsonProcessingException e1) {
    e1.printStackTrace();
    AradException exception=new AradException(e1.getMessage());
    throw exception;
  }
catch (  IOException e1) {
    e1.printStackTrace();
    AradException exception=new AradException(e1.getMessage());
    throw exception;
  }
}","public JsonNode handleResult(String result) throws AradException {
  try {
    JsonNode node=JsonUtil.json2node(result);
    JsonNode error=node.get(errorKey);
    if (error == null || errorCodes.contains(error.asText())) {
      return node;
    }
 else {
      String statue=error.asText();
      AradException e=new AradException();
      e.setError_code(statue);
      throw e;
    }
  }
 catch (  JsonProcessingException e1) {
    e1.printStackTrace();
    AradException exception=new AradException(e1.getMessage());
    throw exception;
  }
catch (  IOException e1) {
    e1.printStackTrace();
    AradException exception=new AradException(e1.getMessage());
    throw exception;
  }
}",0.9913419913419912
110162,"private ImageLoader(Context ctx,String cacheFolder){
  finalBitmap=FinalBitmap.create(ctx,BitmapCommonUtils.getDiskCacheDir(ctx,cacheFolder).getAbsolutePath());
}","private ImageLoader(Context ctx,String cacheFolder){
  finalBitmap=FinalBitmap.create(ctx,BitmapCommonUtils.getDiskCacheDir(ctx,cacheFolder).getAbsolutePath());
  finalBitmap.configCompressFormat(CompressFormat.PNG);
}",0.8526315789473684
110163,"@Override public void display(String url,ImageView imageView,int loadingImage){
  finalBitmap.configLoadingImage(loadingImage);
  finalBitmap.display(imageView,url);
}","@Override public void display(String url,ImageView imageView,int loadingImage){
  finalBitmap.configLoadingImage(loadingImage);
  finalBitmap.configLoadfailImage(loadingImage);
  finalBitmap.display(imageView,url);
}",0.8720626631853786
110164,"private ImageLoader(Context ctx){
  finalBitmap=FinalBitmap.create(ctx);
}","private ImageLoader(Context ctx){
  finalBitmap=FinalBitmap.create(ctx,BitmapCommonUtils.getDiskCacheDir(ctx,""String_Node_Str"").getAbsolutePath());
}",0.6636771300448431
110165,"@Override public <T>int countByWhere(Class<T> clazz,String strWhere){
  TableInfo table=TableInfo.get(clazz);
  DbModel model=db.findDbModelBySQL(clazz,""String_Node_Str"" + table.getTableName() + ""String_Node_Str""+ strWhere);
  if (model != null) {
    return model.getInt(""String_Node_Str"");
  }
  return 0;
}","@Override public <T>int countByWhere(Class<T> clazz,String strWhere){
  TableInfo table=TableInfo.get(clazz);
  DbModel model=db.findDbModelBySQL(""String_Node_Str"" + table.getTableName() + ""String_Node_Str""+ strWhere);
  if (model != null) {
    return model.getInt(""String_Node_Str"");
  }
  return 0;
}",0.9901960784313726
110166,"private ImageLoader(Context ctx,String cacheFolder){
  finalBitmap=FinalBitmap.create(ctx,BitmapCommonUtils.getDiskCacheDir(ctx,cacheFolder).getAbsolutePath());
  finalBitmap.configCompressFormat(CompressFormat.PNG);
}","private ImageLoader(Context ctx,String cacheFolder){
  finalBitmap=FinalBitmap.create(ctx);
}",0.5980707395498392
110167,"@Override public TrackOutput track(int id,int type){
  int trackCount=sampleQueues.length;
  if (type == C.TRACK_TYPE_AUDIO) {
    if (audioSampleQueueIndex != C.INDEX_UNSET) {
      if (audioSampleQueueMappingDone) {
        return sampleQueueTrackIds[audioSampleQueueIndex] == id ? sampleQueues[audioSampleQueueIndex] : createDummyTrackOutput(id,type);
      }
      audioSampleQueueMappingDone=true;
      sampleQueueTrackIds[audioSampleQueueIndex]=id;
      return sampleQueues[audioSampleQueueIndex];
    }
 else     if (tracksEnded) {
      return createDummyTrackOutput(id,type);
    }
  }
 else   if (type == C.TRACK_TYPE_VIDEO) {
    if (videoSampleQueueIndex != C.INDEX_UNSET) {
      if (videoSampleQueueMappingDone) {
        return sampleQueueTrackIds[videoSampleQueueIndex] == id ? sampleQueues[videoSampleQueueIndex] : createDummyTrackOutput(id,type);
      }
      videoSampleQueueMappingDone=true;
      sampleQueueTrackIds[videoSampleQueueIndex]=id;
      return sampleQueues[videoSampleQueueIndex];
    }
 else     if (tracksEnded) {
      return createDummyTrackOutput(id,type);
    }
  }
 else {
    for (int i=0; i < trackCount; i++) {
      if (sampleQueueTrackIds[i] == id) {
        return sampleQueues[i];
      }
    }
    if (tracksEnded) {
      return createDummyTrackOutput(id,type);
    }
  }
  SampleQueue trackOutput=new SampleQueue(allocator);
  trackOutput.setSampleOffsetUs(sampleOffsetUs);
  trackOutput.setUpstreamFormatChangeListener(this);
  sampleQueueTrackIds=Arrays.copyOf(sampleQueueTrackIds,trackCount + 1);
  sampleQueueTrackIds[trackCount]=id;
  sampleQueues=Arrays.copyOf(sampleQueues,trackCount + 1);
  sampleQueues[trackCount]=trackOutput;
  sampleQueueIsAudioVideoFlags=Arrays.copyOf(sampleQueueIsAudioVideoFlags,trackCount + 1);
  sampleQueueIsAudioVideoFlags[trackCount]=type == C.TRACK_TYPE_AUDIO || type == C.TRACK_TYPE_VIDEO;
  haveAudioVideoSampleQueues|=sampleQueueIsAudioVideoFlags[trackCount];
  if (type == C.TRACK_TYPE_AUDIO) {
    audioSampleQueueMappingDone=true;
    audioSampleQueueIndex=trackCount;
  }
 else   if (type == C.TRACK_TYPE_VIDEO) {
    videoSampleQueueMappingDone=true;
    videoSampleQueueIndex=trackCount;
  }
  sampleQueuesEnabledStates=Arrays.copyOf(sampleQueuesEnabledStates,trackCount + 1);
  return trackOutput;
}","@Override public TrackOutput track(int id,int type){
  int trackCount=sampleQueues.length;
  if (type == C.TRACK_TYPE_AUDIO) {
    if (audioSampleQueueIndex != C.INDEX_UNSET) {
      if (audioSampleQueueMappingDone) {
        return sampleQueueTrackIds[audioSampleQueueIndex] == id ? sampleQueues[audioSampleQueueIndex] : createDummyTrackOutput(id,type);
      }
      audioSampleQueueMappingDone=true;
      sampleQueueTrackIds[audioSampleQueueIndex]=id;
      return sampleQueues[audioSampleQueueIndex];
    }
 else     if (tracksEnded) {
      return createDummyTrackOutput(id,type);
    }
  }
 else   if (type == C.TRACK_TYPE_VIDEO) {
    if (videoSampleQueueIndex != C.INDEX_UNSET) {
      if (videoSampleQueueMappingDone) {
        return sampleQueueTrackIds[videoSampleQueueIndex] == id ? sampleQueues[videoSampleQueueIndex] : createDummyTrackOutput(id,type);
      }
      videoSampleQueueMappingDone=true;
      sampleQueueTrackIds[videoSampleQueueIndex]=id;
      return sampleQueues[videoSampleQueueIndex];
    }
 else     if (tracksEnded) {
      return createDummyTrackOutput(id,type);
    }
  }
 else {
    for (int i=0; i < trackCount; i++) {
      if (sampleQueueTrackIds[i] == id) {
        return sampleQueues[i];
      }
    }
    if (tracksEnded) {
      return createDummyTrackOutput(id,type);
    }
  }
  SampleQueue trackOutput=new SampleQueue(allocator);
  trackOutput.sourceId(chunkUid);
  trackOutput.setSampleOffsetUs(sampleOffsetUs);
  trackOutput.setUpstreamFormatChangeListener(this);
  sampleQueueTrackIds=Arrays.copyOf(sampleQueueTrackIds,trackCount + 1);
  sampleQueueTrackIds[trackCount]=id;
  sampleQueues=Arrays.copyOf(sampleQueues,trackCount + 1);
  sampleQueues[trackCount]=trackOutput;
  sampleQueueIsAudioVideoFlags=Arrays.copyOf(sampleQueueIsAudioVideoFlags,trackCount + 1);
  sampleQueueIsAudioVideoFlags[trackCount]=type == C.TRACK_TYPE_AUDIO || type == C.TRACK_TYPE_VIDEO;
  haveAudioVideoSampleQueues|=sampleQueueIsAudioVideoFlags[trackCount];
  if (type == C.TRACK_TYPE_AUDIO) {
    audioSampleQueueMappingDone=true;
    audioSampleQueueIndex=trackCount;
  }
 else   if (type == C.TRACK_TYPE_VIDEO) {
    videoSampleQueueMappingDone=true;
    videoSampleQueueIndex=trackCount;
  }
  sampleQueuesEnabledStates=Arrays.copyOf(sampleQueuesEnabledStates,trackCount + 1);
  return trackOutput;
}",0.9926660914581537
110168,"/** 
 * Initializes the wrapper for loading a chunk.
 * @param chunkUid The chunk's uid.
 * @param shouldSpliceIn Whether the samples parsed from the chunk should be spliced into anysamples already queued to the wrapper.
 * @param reusingExtractor Whether the extractor for the chunk has already been used for precedingchunks.
 */
public void init(int chunkUid,boolean shouldSpliceIn,boolean reusingExtractor){
  if (!reusingExtractor) {
    audioSampleQueueMappingDone=false;
    videoSampleQueueMappingDone=false;
  }
  for (  SampleQueue sampleQueue : sampleQueues) {
    sampleQueue.sourceId(chunkUid);
  }
  if (shouldSpliceIn) {
    for (    SampleQueue sampleQueue : sampleQueues) {
      sampleQueue.splice();
    }
  }
}","/** 
 * Initializes the wrapper for loading a chunk.
 * @param chunkUid The chunk's uid.
 * @param shouldSpliceIn Whether the samples parsed from the chunk should be spliced into anysamples already queued to the wrapper.
 * @param reusingExtractor Whether the extractor for the chunk has already been used for precedingchunks.
 */
public void init(int chunkUid,boolean shouldSpliceIn,boolean reusingExtractor){
  if (!reusingExtractor) {
    audioSampleQueueMappingDone=false;
    videoSampleQueueMappingDone=false;
  }
  this.chunkUid=chunkUid;
  for (  SampleQueue sampleQueue : sampleQueues) {
    sampleQueue.sourceId(chunkUid);
  }
  if (shouldSpliceIn) {
    for (    SampleQueue sampleQueue : sampleQueues) {
      sampleQueue.splice();
    }
  }
}",0.9824797843665768
110169,"/** 
 * Dequeues the playing period holder from the front of the queue and advances the playing period holder to be the next item in the queue. If the playing period holder is unset, set it to the item in the front of the queue.
 * @return The updated playing period holder, or null if the queue is or becomes empty.
 */
public MediaPeriodHolder advancePlayingPeriod(){
  if (playing != null) {
    if (playing == reading) {
      reading=playing.next;
    }
    playing.release();
    playing=playing.next;
    length--;
    if (length == 0) {
      loading=null;
    }
  }
 else {
    playing=loading;
    reading=loading;
  }
  return playing;
}","/** 
 * Dequeues the playing period holder from the front of the queue and advances the playing period holder to be the next item in the queue. If the playing period holder is unset, set it to the item in the front of the queue.
 * @return The updated playing period holder, or null if the queue is or becomes empty.
 */
public MediaPeriodHolder advancePlayingPeriod(){
  if (playing != null) {
    if (playing == reading) {
      reading=playing.next;
    }
    playing.release();
    length--;
    if (length == 0) {
      loading=null;
      oldFrontPeriodUid=playing.uid;
      oldFrontPeriodWindowSequenceNumber=playing.info.id.windowSequenceNumber;
    }
    playing=playing.next;
  }
 else {
    playing=loading;
    reading=loading;
  }
  return playing;
}",0.8810198300283286
110170,"/** 
 * @deprecated Use {@link ConcatenatingMediaSource#ConcatenatingMediaSource(boolean,ShuffleOrder)} instead.
 */
@Deprecated public DynamicConcatenatingMediaSource(boolean isAtomic,ShuffleOrder shuffleOrder){
  super(isAtomic,shuffleOrder);
}","/** 
 * @deprecated Use {@link ConcatenatingMediaSource#ConcatenatingMediaSource(boolean,ShuffleOrder,MediaSource)} instead.
 */
@Deprecated public DynamicConcatenatingMediaSource(boolean isAtomic,ShuffleOrder shuffleOrder){
  super(isAtomic,shuffleOrder);
}",0.9761904761904762
110171,"private void updatePlayingPeriodRenderers(@Nullable MediaPeriodHolder oldPlayingPeriodHolder) throws ExoPlaybackException {
  MediaPeriodHolder newPlayingPeriodHolder=queue.getPlayingPeriod();
  if (newPlayingPeriodHolder == null || oldPlayingPeriodHolder == newPlayingPeriodHolder) {
    return;
  }
  int enabledRendererCount=0;
  boolean[] rendererWasEnabledFlags=new boolean[renderers.length];
  for (int i=0; i < renderers.length; i++) {
    Renderer renderer=renderers[i];
    rendererWasEnabledFlags[i]=renderer.getState() != Renderer.STATE_DISABLED;
    if (newPlayingPeriodHolder.trackSelectorResult.isRendererEnabled(i)) {
      enabledRendererCount++;
    }
    if (rendererWasEnabledFlags[i] && (!newPlayingPeriodHolder.trackSelectorResult.isRendererEnabled(i) || (renderer.isCurrentStreamFinal() && renderer.getStream() == oldPlayingPeriodHolder.sampleStreams[i]))) {
      disableRenderer(renderer);
    }
  }
  playbackInfo=playbackInfo.copyWithTrackInfo(newPlayingPeriodHolder.trackGroups,newPlayingPeriodHolder.trackSelectorResult);
  enableRenderers(rendererWasEnabledFlags,enabledRendererCount);
}","@SuppressWarnings(""String_Node_Str"") private void updatePlayingPeriodRenderers(@Nullable MediaPeriodHolder oldPlayingPeriodHolder) throws ExoPlaybackException {
  MediaPeriodHolder newPlayingPeriodHolder=queue.getPlayingPeriod();
  if (newPlayingPeriodHolder == null || oldPlayingPeriodHolder == newPlayingPeriodHolder) {
    return;
  }
  int enabledRendererCount=0;
  boolean[] rendererWasEnabledFlags=new boolean[renderers.length];
  for (int i=0; i < renderers.length; i++) {
    Renderer renderer=renderers[i];
    rendererWasEnabledFlags[i]=renderer.getState() != Renderer.STATE_DISABLED;
    if (newPlayingPeriodHolder.trackSelectorResult.isRendererEnabled(i)) {
      enabledRendererCount++;
    }
    if (rendererWasEnabledFlags[i] && (!newPlayingPeriodHolder.trackSelectorResult.isRendererEnabled(i) || (renderer.isCurrentStreamFinal() && renderer.getStream() == oldPlayingPeriodHolder.sampleStreams[i]))) {
      disableRenderer(renderer);
    }
  }
  playbackInfo=playbackInfo.copyWithTrackInfo(newPlayingPeriodHolder.trackGroups,newPlayingPeriodHolder.trackSelectorResult);
  enableRenderers(rendererWasEnabledFlags,enabledRendererCount);
}",0.983693256941384
110172,"/** 
 * @param inputBuffers An array of nulls that will be used to store references to input buffers.
 * @param outputBuffers An array of nulls that will be used to store references to output buffers.
 */
protected SimpleDecoder(I[] inputBuffers,O[] outputBuffers){
  lock=new Object();
  queuedInputBuffers=new LinkedList<>();
  queuedOutputBuffers=new LinkedList<>();
  availableInputBuffers=inputBuffers;
  availableInputBufferCount=inputBuffers.length;
  for (int i=0; i < availableInputBufferCount; i++) {
    availableInputBuffers[i]=createInputBuffer();
  }
  availableOutputBuffers=outputBuffers;
  availableOutputBufferCount=outputBuffers.length;
  for (int i=0; i < availableOutputBufferCount; i++) {
    availableOutputBuffers[i]=createOutputBuffer();
  }
  decodeThread=new Thread(){
    @Override public void run(){
      SimpleDecoder.this.run();
    }
  }
;
  decodeThread.start();
}","/** 
 * @param inputBuffers An array of nulls that will be used to store references to input buffers.
 * @param outputBuffers An array of nulls that will be used to store references to output buffers.
 */
protected SimpleDecoder(I[] inputBuffers,O[] outputBuffers){
  lock=new Object();
  queuedInputBuffers=new ArrayDeque<>();
  queuedOutputBuffers=new ArrayDeque<>();
  availableInputBuffers=inputBuffers;
  availableInputBufferCount=inputBuffers.length;
  for (int i=0; i < availableInputBufferCount; i++) {
    availableInputBuffers[i]=createInputBuffer();
  }
  availableOutputBuffers=outputBuffers;
  availableOutputBufferCount=outputBuffers.length;
  for (int i=0; i < availableOutputBufferCount; i++) {
    availableOutputBuffers[i]=createOutputBuffer();
  }
  decodeThread=new Thread(){
    @Override public void run(){
      SimpleDecoder.this.run();
    }
  }
;
  decodeThread.start();
}",0.977728285077951
110173,"@Override public byte[] executeProvisionRequest(UUID uuid,ProvisionRequest request) throws IOException {
  String url=request.getDefaultUrl() + ""String_Node_Str"" + new String(request.getData());
  return executePost(dataSourceFactory,url,new byte[0],null);
}","@Override public byte[] executeProvisionRequest(UUID uuid,ProvisionRequest request) throws IOException {
  String url=request.getDefaultUrl() + ""String_Node_Str"" + Util.fromUtf8Bytes(request.getData());
  return executePost(dataSourceFactory,url,new byte[0],null);
}",0.9465648854961832
110174,"@Override public boolean read(ExtractorInput input) throws IOException, InterruptedException {
  Assertions.checkState(output != null);
  while (true) {
    if (!masterElementsStack.isEmpty() && input.getPosition() >= masterElementsStack.peek().elementEndPosition) {
      output.endMasterElement(masterElementsStack.pop().elementId);
      return true;
    }
    if (elementState == ELEMENT_STATE_READ_ID) {
      long result=varintReader.readUnsignedVarint(input,true,false,MAX_ID_BYTES);
      if (result == C.RESULT_MAX_LENGTH_EXCEEDED) {
        result=maybeResyncToNextLevel1Element(input);
      }
      if (result == C.RESULT_END_OF_INPUT) {
        return false;
      }
      elementId=(int)result;
      elementState=ELEMENT_STATE_READ_CONTENT_SIZE;
    }
    if (elementState == ELEMENT_STATE_READ_CONTENT_SIZE) {
      elementContentSize=varintReader.readUnsignedVarint(input,false,true,MAX_LENGTH_BYTES);
      elementState=ELEMENT_STATE_READ_CONTENT;
    }
    @EbmlReaderOutput.ElementType int type=output.getElementType(elementId);
switch (type) {
case EbmlReaderOutput.TYPE_MASTER:
      long elementContentPosition=input.getPosition();
    long elementEndPosition=elementContentPosition + elementContentSize;
  masterElementsStack.add(new MasterElement(elementId,elementEndPosition));
output.startMasterElement(elementId,elementContentPosition,elementContentSize);
elementState=ELEMENT_STATE_READ_ID;
return true;
case EbmlReaderOutput.TYPE_UNSIGNED_INT:
if (elementContentSize > MAX_INTEGER_ELEMENT_SIZE_BYTES) {
throw new ParserException(""String_Node_Str"" + elementContentSize);
}
output.integerElement(elementId,readInteger(input,(int)elementContentSize));
elementState=ELEMENT_STATE_READ_ID;
return true;
case EbmlReaderOutput.TYPE_FLOAT:
if (elementContentSize != VALID_FLOAT32_ELEMENT_SIZE_BYTES && elementContentSize != VALID_FLOAT64_ELEMENT_SIZE_BYTES) {
throw new ParserException(""String_Node_Str"" + elementContentSize);
}
output.floatElement(elementId,readFloat(input,(int)elementContentSize));
elementState=ELEMENT_STATE_READ_ID;
return true;
case EbmlReaderOutput.TYPE_STRING:
if (elementContentSize > Integer.MAX_VALUE) {
throw new ParserException(""String_Node_Str"" + elementContentSize);
}
output.stringElement(elementId,readString(input,(int)elementContentSize));
elementState=ELEMENT_STATE_READ_ID;
return true;
case EbmlReaderOutput.TYPE_BINARY:
output.binaryElement(elementId,(int)elementContentSize,input);
elementState=ELEMENT_STATE_READ_ID;
return true;
case EbmlReaderOutput.TYPE_UNKNOWN:
input.skipFully((int)elementContentSize);
elementState=ELEMENT_STATE_READ_ID;
break;
default :
throw new ParserException(""String_Node_Str"" + type);
}
}
}","@Override public boolean read(ExtractorInput input) throws IOException, InterruptedException {
  Assertions.checkState(output != null);
  while (true) {
    if (!masterElementsStack.isEmpty() && input.getPosition() >= masterElementsStack.peek().elementEndPosition) {
      output.endMasterElement(masterElementsStack.pop().elementId);
      return true;
    }
    if (elementState == ELEMENT_STATE_READ_ID) {
      long result=varintReader.readUnsignedVarint(input,true,false,MAX_ID_BYTES);
      if (result == C.RESULT_MAX_LENGTH_EXCEEDED) {
        result=maybeResyncToNextLevel1Element(input);
      }
      if (result == C.RESULT_END_OF_INPUT) {
        return false;
      }
      elementId=(int)result;
      elementState=ELEMENT_STATE_READ_CONTENT_SIZE;
    }
    if (elementState == ELEMENT_STATE_READ_CONTENT_SIZE) {
      elementContentSize=varintReader.readUnsignedVarint(input,false,true,MAX_LENGTH_BYTES);
      elementState=ELEMENT_STATE_READ_CONTENT;
    }
    @EbmlReaderOutput.ElementType int type=output.getElementType(elementId);
switch (type) {
case EbmlReaderOutput.TYPE_MASTER:
      long elementContentPosition=input.getPosition();
    long elementEndPosition=elementContentPosition + elementContentSize;
  masterElementsStack.push(new MasterElement(elementId,elementEndPosition));
output.startMasterElement(elementId,elementContentPosition,elementContentSize);
elementState=ELEMENT_STATE_READ_ID;
return true;
case EbmlReaderOutput.TYPE_UNSIGNED_INT:
if (elementContentSize > MAX_INTEGER_ELEMENT_SIZE_BYTES) {
throw new ParserException(""String_Node_Str"" + elementContentSize);
}
output.integerElement(elementId,readInteger(input,(int)elementContentSize));
elementState=ELEMENT_STATE_READ_ID;
return true;
case EbmlReaderOutput.TYPE_FLOAT:
if (elementContentSize != VALID_FLOAT32_ELEMENT_SIZE_BYTES && elementContentSize != VALID_FLOAT64_ELEMENT_SIZE_BYTES) {
throw new ParserException(""String_Node_Str"" + elementContentSize);
}
output.floatElement(elementId,readFloat(input,(int)elementContentSize));
elementState=ELEMENT_STATE_READ_ID;
return true;
case EbmlReaderOutput.TYPE_STRING:
if (elementContentSize > Integer.MAX_VALUE) {
throw new ParserException(""String_Node_Str"" + elementContentSize);
}
output.stringElement(elementId,readString(input,(int)elementContentSize));
elementState=ELEMENT_STATE_READ_ID;
return true;
case EbmlReaderOutput.TYPE_BINARY:
output.binaryElement(elementId,(int)elementContentSize,input);
elementState=ELEMENT_STATE_READ_ID;
return true;
case EbmlReaderOutput.TYPE_UNKNOWN:
input.skipFully((int)elementContentSize);
elementState=ELEMENT_STATE_READ_ID;
break;
default :
throw new ParserException(""String_Node_Str"" + type);
}
}
}",0.9986957331842744
110175,"/** 
 * @see com.google.android.exoplayer2.extractor.Extractor#sniff(ExtractorInput)
 */
public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
  long inputLength=input.getLength();
  int bytesToSearch=(int)(inputLength == C.LENGTH_UNSET || inputLength > SEARCH_LENGTH ? SEARCH_LENGTH : inputLength);
  input.peekFully(scratch.data,0,4);
  long tag=scratch.readUnsignedInt();
  peekLength=4;
  while (tag != ID_EBML) {
    if (++peekLength == bytesToSearch) {
      return false;
    }
    input.peekFully(scratch.data,0,1);
    tag=(tag << 8) & 0xFFFFFF00;
    tag|=scratch.data[0] & 0xFF;
  }
  long headerSize=readUint(input);
  long headerStart=peekLength;
  if (headerSize == Long.MIN_VALUE || (inputLength != C.LENGTH_UNSET && headerStart + headerSize >= inputLength)) {
    return false;
  }
  while (peekLength < headerStart + headerSize) {
    long id=readUint(input);
    if (id == Long.MIN_VALUE) {
      return false;
    }
    long size=readUint(input);
    if (size < 0 || size > Integer.MAX_VALUE) {
      return false;
    }
    if (size != 0) {
      input.advancePeekPosition((int)size);
      peekLength+=size;
    }
  }
  return peekLength == headerStart + headerSize;
}","/** 
 * @see com.google.android.exoplayer2.extractor.Extractor#sniff(ExtractorInput)
 */
public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
  long inputLength=input.getLength();
  int bytesToSearch=(int)(inputLength == C.LENGTH_UNSET || inputLength > SEARCH_LENGTH ? SEARCH_LENGTH : inputLength);
  input.peekFully(scratch.data,0,4);
  long tag=scratch.readUnsignedInt();
  peekLength=4;
  while (tag != ID_EBML) {
    if (++peekLength == bytesToSearch) {
      return false;
    }
    input.peekFully(scratch.data,0,1);
    tag=(tag << 8) & 0xFFFFFF00;
    tag|=scratch.data[0] & 0xFF;
  }
  long headerSize=readUint(input);
  long headerStart=peekLength;
  if (headerSize == Long.MIN_VALUE || (inputLength != C.LENGTH_UNSET && headerStart + headerSize >= inputLength)) {
    return false;
  }
  while (peekLength < headerStart + headerSize) {
    long id=readUint(input);
    if (id == Long.MIN_VALUE) {
      return false;
    }
    long size=readUint(input);
    if (size < 0 || size > Integer.MAX_VALUE) {
      return false;
    }
    if (size != 0) {
      int sizeInt=(int)size;
      input.advancePeekPosition(sizeInt);
      peekLength+=sizeInt;
    }
  }
  return peekLength == headerStart + headerSize;
}",0.9838187702265372
110176,"/** 
 * @param flags Flags that control the extractor's behavior.
 * @param timestampAdjuster Adjusts sample timestamps. May be null if no adjustment is needed.
 * @param sideloadedTrack Sideloaded track information, in the case that the extractor will notreceive a moov box in the input data. Null if a moov box is expected.
 * @param sideloadedDrmInitData The {@link DrmInitData} to use for encrypted tracks. If null, thepssh boxes (if present) will be used.
 * @param closedCaptionFormats For tracks that contain SEI messages, the formats of the closedcaption channels to expose.
 * @param additionalEmsgTrackOutput An extra track output that will receive all emsg messagestargeting the player, even if  {@link #FLAG_ENABLE_EMSG_TRACK} is not set. Null if specialhandling of emsg messages for players is not required.
 */
public FragmentedMp4Extractor(@Flags int flags,@Nullable TimestampAdjuster timestampAdjuster,@Nullable Track sideloadedTrack,@Nullable DrmInitData sideloadedDrmInitData,List<Format> closedCaptionFormats,@Nullable TrackOutput additionalEmsgTrackOutput){
  this.flags=flags | (sideloadedTrack != null ? FLAG_SIDELOADED : 0);
  this.timestampAdjuster=timestampAdjuster;
  this.sideloadedTrack=sideloadedTrack;
  this.sideloadedDrmInitData=sideloadedDrmInitData;
  this.closedCaptionFormats=Collections.unmodifiableList(closedCaptionFormats);
  this.additionalEmsgTrackOutput=additionalEmsgTrackOutput;
  atomHeader=new ParsableByteArray(Atom.LONG_HEADER_SIZE);
  nalStartCode=new ParsableByteArray(NalUnitUtil.NAL_START_CODE);
  nalPrefix=new ParsableByteArray(5);
  nalBuffer=new ParsableByteArray();
  extendedTypeScratch=new byte[16];
  containerAtoms=new Stack<>();
  pendingMetadataSampleInfos=new ArrayDeque<>();
  trackBundles=new SparseArray<>();
  durationUs=C.TIME_UNSET;
  pendingSeekTimeUs=C.TIME_UNSET;
  segmentIndexEarliestPresentationTimeUs=C.TIME_UNSET;
  enterReadingAtomHeaderState();
}","/** 
 * @param flags Flags that control the extractor's behavior.
 * @param timestampAdjuster Adjusts sample timestamps. May be null if no adjustment is needed.
 * @param sideloadedTrack Sideloaded track information, in the case that the extractor will notreceive a moov box in the input data. Null if a moov box is expected.
 * @param sideloadedDrmInitData The {@link DrmInitData} to use for encrypted tracks. If null, thepssh boxes (if present) will be used.
 * @param closedCaptionFormats For tracks that contain SEI messages, the formats of the closedcaption channels to expose.
 * @param additionalEmsgTrackOutput An extra track output that will receive all emsg messagestargeting the player, even if  {@link #FLAG_ENABLE_EMSG_TRACK} is not set. Null if specialhandling of emsg messages for players is not required.
 */
public FragmentedMp4Extractor(@Flags int flags,@Nullable TimestampAdjuster timestampAdjuster,@Nullable Track sideloadedTrack,@Nullable DrmInitData sideloadedDrmInitData,List<Format> closedCaptionFormats,@Nullable TrackOutput additionalEmsgTrackOutput){
  this.flags=flags | (sideloadedTrack != null ? FLAG_SIDELOADED : 0);
  this.timestampAdjuster=timestampAdjuster;
  this.sideloadedTrack=sideloadedTrack;
  this.sideloadedDrmInitData=sideloadedDrmInitData;
  this.closedCaptionFormats=Collections.unmodifiableList(closedCaptionFormats);
  this.additionalEmsgTrackOutput=additionalEmsgTrackOutput;
  atomHeader=new ParsableByteArray(Atom.LONG_HEADER_SIZE);
  nalStartCode=new ParsableByteArray(NalUnitUtil.NAL_START_CODE);
  nalPrefix=new ParsableByteArray(5);
  nalBuffer=new ParsableByteArray();
  extendedTypeScratch=new byte[16];
  containerAtoms=new ArrayDeque<>();
  pendingMetadataSampleInfos=new ArrayDeque<>();
  trackBundles=new SparseArray<>();
  durationUs=C.TIME_UNSET;
  pendingSeekTimeUs=C.TIME_UNSET;
  segmentIndexEarliestPresentationTimeUs=C.TIME_UNSET;
  enterReadingAtomHeaderState();
}",0.9961129826379892
110177,"private boolean readAtomHeader(ExtractorInput input) throws IOException, InterruptedException {
  if (atomHeaderBytesRead == 0) {
    if (!input.readFully(atomHeader.data,0,Atom.HEADER_SIZE,true)) {
      return false;
    }
    atomHeaderBytesRead=Atom.HEADER_SIZE;
    atomHeader.setPosition(0);
    atomSize=atomHeader.readUnsignedInt();
    atomType=atomHeader.readInt();
  }
  if (atomSize == Atom.DEFINES_LARGE_SIZE) {
    int headerBytesRemaining=Atom.LONG_HEADER_SIZE - Atom.HEADER_SIZE;
    input.readFully(atomHeader.data,Atom.HEADER_SIZE,headerBytesRemaining);
    atomHeaderBytesRead+=headerBytesRemaining;
    atomSize=atomHeader.readUnsignedLongToLong();
  }
 else   if (atomSize == Atom.EXTENDS_TO_END_SIZE) {
    long endPosition=input.getLength();
    if (endPosition == C.LENGTH_UNSET && !containerAtoms.isEmpty()) {
      endPosition=containerAtoms.peek().endPosition;
    }
    if (endPosition != C.LENGTH_UNSET) {
      atomSize=endPosition - input.getPosition() + atomHeaderBytesRead;
    }
  }
  if (atomSize < atomHeaderBytesRead) {
    throw new ParserException(""String_Node_Str"");
  }
  long atomPosition=input.getPosition() - atomHeaderBytesRead;
  if (atomType == Atom.TYPE_moof) {
    int trackCount=trackBundles.size();
    for (int i=0; i < trackCount; i++) {
      TrackFragment fragment=trackBundles.valueAt(i).fragment;
      fragment.atomPosition=atomPosition;
      fragment.auxiliaryDataPosition=atomPosition;
      fragment.dataPosition=atomPosition;
    }
  }
  if (atomType == Atom.TYPE_mdat) {
    currentTrackBundle=null;
    endOfMdatPosition=atomPosition + atomSize;
    if (!haveOutputSeekMap) {
      extractorOutput.seekMap(new SeekMap.Unseekable(durationUs,atomPosition));
      haveOutputSeekMap=true;
    }
    parserState=STATE_READING_ENCRYPTION_DATA;
    return true;
  }
  if (shouldParseContainerAtom(atomType)) {
    long endPosition=input.getPosition() + atomSize - Atom.HEADER_SIZE;
    containerAtoms.add(new ContainerAtom(atomType,endPosition));
    if (atomSize == atomHeaderBytesRead) {
      processAtomEnded(endPosition);
    }
 else {
      enterReadingAtomHeaderState();
    }
  }
 else   if (shouldParseLeafAtom(atomType)) {
    if (atomHeaderBytesRead != Atom.HEADER_SIZE) {
      throw new ParserException(""String_Node_Str"");
    }
    if (atomSize > Integer.MAX_VALUE) {
      throw new ParserException(""String_Node_Str"");
    }
    atomData=new ParsableByteArray((int)atomSize);
    System.arraycopy(atomHeader.data,0,atomData.data,0,Atom.HEADER_SIZE);
    parserState=STATE_READING_ATOM_PAYLOAD;
  }
 else {
    if (atomSize > Integer.MAX_VALUE) {
      throw new ParserException(""String_Node_Str"");
    }
    atomData=null;
    parserState=STATE_READING_ATOM_PAYLOAD;
  }
  return true;
}","private boolean readAtomHeader(ExtractorInput input) throws IOException, InterruptedException {
  if (atomHeaderBytesRead == 0) {
    if (!input.readFully(atomHeader.data,0,Atom.HEADER_SIZE,true)) {
      return false;
    }
    atomHeaderBytesRead=Atom.HEADER_SIZE;
    atomHeader.setPosition(0);
    atomSize=atomHeader.readUnsignedInt();
    atomType=atomHeader.readInt();
  }
  if (atomSize == Atom.DEFINES_LARGE_SIZE) {
    int headerBytesRemaining=Atom.LONG_HEADER_SIZE - Atom.HEADER_SIZE;
    input.readFully(atomHeader.data,Atom.HEADER_SIZE,headerBytesRemaining);
    atomHeaderBytesRead+=headerBytesRemaining;
    atomSize=atomHeader.readUnsignedLongToLong();
  }
 else   if (atomSize == Atom.EXTENDS_TO_END_SIZE) {
    long endPosition=input.getLength();
    if (endPosition == C.LENGTH_UNSET && !containerAtoms.isEmpty()) {
      endPosition=containerAtoms.peek().endPosition;
    }
    if (endPosition != C.LENGTH_UNSET) {
      atomSize=endPosition - input.getPosition() + atomHeaderBytesRead;
    }
  }
  if (atomSize < atomHeaderBytesRead) {
    throw new ParserException(""String_Node_Str"");
  }
  long atomPosition=input.getPosition() - atomHeaderBytesRead;
  if (atomType == Atom.TYPE_moof) {
    int trackCount=trackBundles.size();
    for (int i=0; i < trackCount; i++) {
      TrackFragment fragment=trackBundles.valueAt(i).fragment;
      fragment.atomPosition=atomPosition;
      fragment.auxiliaryDataPosition=atomPosition;
      fragment.dataPosition=atomPosition;
    }
  }
  if (atomType == Atom.TYPE_mdat) {
    currentTrackBundle=null;
    endOfMdatPosition=atomPosition + atomSize;
    if (!haveOutputSeekMap) {
      extractorOutput.seekMap(new SeekMap.Unseekable(durationUs,atomPosition));
      haveOutputSeekMap=true;
    }
    parserState=STATE_READING_ENCRYPTION_DATA;
    return true;
  }
  if (shouldParseContainerAtom(atomType)) {
    long endPosition=input.getPosition() + atomSize - Atom.HEADER_SIZE;
    containerAtoms.push(new ContainerAtom(atomType,endPosition));
    if (atomSize == atomHeaderBytesRead) {
      processAtomEnded(endPosition);
    }
 else {
      enterReadingAtomHeaderState();
    }
  }
 else   if (shouldParseLeafAtom(atomType)) {
    if (atomHeaderBytesRead != Atom.HEADER_SIZE) {
      throw new ParserException(""String_Node_Str"");
    }
    if (atomSize > Integer.MAX_VALUE) {
      throw new ParserException(""String_Node_Str"");
    }
    atomData=new ParsableByteArray((int)atomSize);
    System.arraycopy(atomHeader.data,0,atomData.data,0,Atom.HEADER_SIZE);
    parserState=STATE_READING_ATOM_PAYLOAD;
  }
 else {
    if (atomSize > Integer.MAX_VALUE) {
      throw new ParserException(""String_Node_Str"");
    }
    atomData=null;
    parserState=STATE_READING_ATOM_PAYLOAD;
  }
  return true;
}",0.9987325728770596
110178,"/** 
 * Creates a new extractor for unfragmented MP4 streams, using the specified flags to control the extractor's behavior.
 * @param flags Flags that control the extractor's behavior.
 */
public Mp4Extractor(@Flags int flags){
  this.flags=flags;
  atomHeader=new ParsableByteArray(Atom.LONG_HEADER_SIZE);
  containerAtoms=new Stack<>();
  nalStartCode=new ParsableByteArray(NalUnitUtil.NAL_START_CODE);
  nalLength=new ParsableByteArray(4);
  sampleTrackIndex=C.INDEX_UNSET;
}","/** 
 * Creates a new extractor for unfragmented MP4 streams, using the specified flags to control the extractor's behavior.
 * @param flags Flags that control the extractor's behavior.
 */
public Mp4Extractor(@Flags int flags){
  this.flags=flags;
  atomHeader=new ParsableByteArray(Atom.LONG_HEADER_SIZE);
  containerAtoms=new ArrayDeque<>();
  nalStartCode=new ParsableByteArray(NalUnitUtil.NAL_START_CODE);
  nalLength=new ParsableByteArray(4);
  sampleTrackIndex=C.INDEX_UNSET;
}",0.9844236760124612
110179,"private boolean readAtomHeader(ExtractorInput input) throws IOException, InterruptedException {
  if (atomHeaderBytesRead == 0) {
    if (!input.readFully(atomHeader.data,0,Atom.HEADER_SIZE,true)) {
      return false;
    }
    atomHeaderBytesRead=Atom.HEADER_SIZE;
    atomHeader.setPosition(0);
    atomSize=atomHeader.readUnsignedInt();
    atomType=atomHeader.readInt();
  }
  if (atomSize == Atom.DEFINES_LARGE_SIZE) {
    int headerBytesRemaining=Atom.LONG_HEADER_SIZE - Atom.HEADER_SIZE;
    input.readFully(atomHeader.data,Atom.HEADER_SIZE,headerBytesRemaining);
    atomHeaderBytesRead+=headerBytesRemaining;
    atomSize=atomHeader.readUnsignedLongToLong();
  }
 else   if (atomSize == Atom.EXTENDS_TO_END_SIZE) {
    long endPosition=input.getLength();
    if (endPosition == C.LENGTH_UNSET && !containerAtoms.isEmpty()) {
      endPosition=containerAtoms.peek().endPosition;
    }
    if (endPosition != C.LENGTH_UNSET) {
      atomSize=endPosition - input.getPosition() + atomHeaderBytesRead;
    }
  }
  if (atomSize < atomHeaderBytesRead) {
    throw new ParserException(""String_Node_Str"");
  }
  if (shouldParseContainerAtom(atomType)) {
    long endPosition=input.getPosition() + atomSize - atomHeaderBytesRead;
    containerAtoms.add(new ContainerAtom(atomType,endPosition));
    if (atomSize == atomHeaderBytesRead) {
      processAtomEnded(endPosition);
    }
 else {
      enterReadingAtomHeaderState();
    }
  }
 else   if (shouldParseLeafAtom(atomType)) {
    Assertions.checkState(atomHeaderBytesRead == Atom.HEADER_SIZE);
    Assertions.checkState(atomSize <= Integer.MAX_VALUE);
    atomData=new ParsableByteArray((int)atomSize);
    System.arraycopy(atomHeader.data,0,atomData.data,0,Atom.HEADER_SIZE);
    parserState=STATE_READING_ATOM_PAYLOAD;
  }
 else {
    atomData=null;
    parserState=STATE_READING_ATOM_PAYLOAD;
  }
  return true;
}","private boolean readAtomHeader(ExtractorInput input) throws IOException, InterruptedException {
  if (atomHeaderBytesRead == 0) {
    if (!input.readFully(atomHeader.data,0,Atom.HEADER_SIZE,true)) {
      return false;
    }
    atomHeaderBytesRead=Atom.HEADER_SIZE;
    atomHeader.setPosition(0);
    atomSize=atomHeader.readUnsignedInt();
    atomType=atomHeader.readInt();
  }
  if (atomSize == Atom.DEFINES_LARGE_SIZE) {
    int headerBytesRemaining=Atom.LONG_HEADER_SIZE - Atom.HEADER_SIZE;
    input.readFully(atomHeader.data,Atom.HEADER_SIZE,headerBytesRemaining);
    atomHeaderBytesRead+=headerBytesRemaining;
    atomSize=atomHeader.readUnsignedLongToLong();
  }
 else   if (atomSize == Atom.EXTENDS_TO_END_SIZE) {
    long endPosition=input.getLength();
    if (endPosition == C.LENGTH_UNSET && !containerAtoms.isEmpty()) {
      endPosition=containerAtoms.peek().endPosition;
    }
    if (endPosition != C.LENGTH_UNSET) {
      atomSize=endPosition - input.getPosition() + atomHeaderBytesRead;
    }
  }
  if (atomSize < atomHeaderBytesRead) {
    throw new ParserException(""String_Node_Str"");
  }
  if (shouldParseContainerAtom(atomType)) {
    long endPosition=input.getPosition() + atomSize - atomHeaderBytesRead;
    containerAtoms.push(new ContainerAtom(atomType,endPosition));
    if (atomSize == atomHeaderBytesRead) {
      processAtomEnded(endPosition);
    }
 else {
      enterReadingAtomHeaderState();
    }
  }
 else   if (shouldParseLeafAtom(atomType)) {
    Assertions.checkState(atomHeaderBytesRead == Atom.HEADER_SIZE);
    Assertions.checkState(atomSize <= Integer.MAX_VALUE);
    atomData=new ParsableByteArray((int)atomSize);
    System.arraycopy(atomHeader.data,0,atomData.data,0,Atom.HEADER_SIZE);
    parserState=STATE_READING_ATOM_PAYLOAD;
  }
 else {
    atomData=null;
    parserState=STATE_READING_ATOM_PAYLOAD;
  }
  return true;
}",0.9981298423724284
110180,"/** 
 * Builds a PSSH atom for the given system id, containing the given key ids and data.
 * @param systemId The system id of the scheme.
 * @param keyIds The key ids for a version 1 PSSH atom, or null for a version 0 PSSH atom.
 * @param data The scheme specific data.
 * @return The PSSH atom.
 */
public static byte[] buildPsshAtom(UUID systemId,@Nullable UUID[] keyIds,@Nullable byte[] data){
  boolean buildV1Atom=keyIds != null;
  int dataLength=data != null ? data.length : 0;
  int psshBoxLength=Atom.FULL_HEADER_SIZE + 16 + 4+ dataLength;
  if (buildV1Atom) {
    psshBoxLength+=4 + (keyIds.length * 16);
  }
  ByteBuffer psshBox=ByteBuffer.allocate(psshBoxLength);
  psshBox.putInt(psshBoxLength);
  psshBox.putInt(Atom.TYPE_pssh);
  psshBox.putInt(buildV1Atom ? 0x01000000 : 0);
  psshBox.putLong(systemId.getMostSignificantBits());
  psshBox.putLong(systemId.getLeastSignificantBits());
  if (buildV1Atom) {
    psshBox.putInt(keyIds.length);
    for (    UUID keyId : keyIds) {
      psshBox.putLong(keyId.getMostSignificantBits());
      psshBox.putLong(keyId.getLeastSignificantBits());
    }
  }
  if (dataLength != 0) {
    psshBox.putInt(data.length);
    psshBox.put(data);
  }
  return psshBox.array();
}","/** 
 * Builds a PSSH atom for the given system id, containing the given key ids and data.
 * @param systemId The system id of the scheme.
 * @param keyIds The key ids for a version 1 PSSH atom, or null for a version 0 PSSH atom.
 * @param data The scheme specific data.
 * @return The PSSH atom.
 */
@SuppressWarnings(""String_Node_Str"") public static byte[] buildPsshAtom(UUID systemId,@Nullable UUID[] keyIds,@Nullable byte[] data){
  boolean buildV1Atom=keyIds != null;
  int dataLength=data != null ? data.length : 0;
  int psshBoxLength=Atom.FULL_HEADER_SIZE + 16 + 4+ dataLength;
  if (buildV1Atom) {
    psshBoxLength+=4 + (keyIds.length * 16);
  }
  ByteBuffer psshBox=ByteBuffer.allocate(psshBoxLength);
  psshBox.putInt(psshBoxLength);
  psshBox.putInt(Atom.TYPE_pssh);
  psshBox.putInt(buildV1Atom ? 0x01000000 : 0);
  psshBox.putLong(systemId.getMostSignificantBits());
  psshBox.putLong(systemId.getLeastSignificantBits());
  if (buildV1Atom) {
    psshBox.putInt(keyIds.length);
    for (    UUID keyId : keyIds) {
      psshBox.putLong(keyId.getMostSignificantBits());
      psshBox.putLong(keyId.getLeastSignificantBits());
    }
  }
  if (dataLength != 0) {
    psshBox.putInt(data.length);
    psshBox.put(data);
  }
  return psshBox.array();
}",0.985122637716124
110181,"/** 
 * Returns the duration of the given audio packet.
 * @param packet Contains audio data.
 * @return Returns the duration of the given audio packet.
 */
private long getPacketDurationUs(byte[] packet){
  int toc=packet[0] & 0xFF;
  int frames;
switch (toc & 0x3) {
case 0:
    frames=1;
  break;
case 1:
case 2:
frames=2;
break;
default :
frames=packet[1] & 0x3F;
break;
}
int config=toc >> 3;
int length=config & 0x3;
if (config >= 16) {
length=2500 << length;
}
 else if (config >= 12) {
length=10000 << (length & 0x1);
}
 else if (length == 3) {
length=60000;
}
 else {
length=10000 << length;
}
return frames * length;
}","/** 
 * Returns the duration of the given audio packet.
 * @param packet Contains audio data.
 * @return Returns the duration of the given audio packet.
 */
private long getPacketDurationUs(byte[] packet){
  int toc=packet[0] & 0xFF;
  int frames;
switch (toc & 0x3) {
case 0:
    frames=1;
  break;
case 1:
case 2:
frames=2;
break;
default :
frames=packet[1] & 0x3F;
break;
}
int config=toc >> 3;
int length=config & 0x3;
if (config >= 16) {
length=2500 << length;
}
 else if (config >= 12) {
length=10000 << (length & 0x1);
}
 else if (length == 3) {
length=60000;
}
 else {
length=10000 << length;
}
return (long)frames * length;
}",0.9952456418383518
110182,"private static CodeBook readBook(VorbisBitArray bitArray) throws ParserException {
  if (bitArray.readBits(24) != 0x564342) {
    throw new ParserException(""String_Node_Str"" + bitArray.getPosition());
  }
  int dimensions=bitArray.readBits(16);
  int entries=bitArray.readBits(24);
  long[] lengthMap=new long[entries];
  boolean isOrdered=bitArray.readBit();
  if (!isOrdered) {
    boolean isSparse=bitArray.readBit();
    for (int i=0; i < lengthMap.length; i++) {
      if (isSparse) {
        if (bitArray.readBit()) {
          lengthMap[i]=bitArray.readBits(5) + 1;
        }
 else {
          lengthMap[i]=0;
        }
      }
 else {
        lengthMap[i]=bitArray.readBits(5) + 1;
      }
    }
  }
 else {
    int length=bitArray.readBits(5) + 1;
    for (int i=0; i < lengthMap.length; ) {
      int num=bitArray.readBits(iLog(entries - i));
      for (int j=0; j < num && i < lengthMap.length; i++, j++) {
        lengthMap[i]=length;
      }
      length++;
    }
  }
  int lookupType=bitArray.readBits(4);
  if (lookupType > 2) {
    throw new ParserException(""String_Node_Str"" + lookupType);
  }
 else   if (lookupType == 1 || lookupType == 2) {
    bitArray.skipBits(32);
    bitArray.skipBits(32);
    int valueBits=bitArray.readBits(4) + 1;
    bitArray.skipBits(1);
    long lookupValuesCount;
    if (lookupType == 1) {
      if (dimensions != 0) {
        lookupValuesCount=mapType1QuantValues(entries,dimensions);
      }
 else {
        lookupValuesCount=0;
      }
    }
 else {
      lookupValuesCount=entries * dimensions;
    }
    bitArray.skipBits((int)(lookupValuesCount * valueBits));
  }
  return new CodeBook(dimensions,entries,lengthMap,lookupType,isOrdered);
}","private static CodeBook readBook(VorbisBitArray bitArray) throws ParserException {
  if (bitArray.readBits(24) != 0x564342) {
    throw new ParserException(""String_Node_Str"" + bitArray.getPosition());
  }
  int dimensions=bitArray.readBits(16);
  int entries=bitArray.readBits(24);
  long[] lengthMap=new long[entries];
  boolean isOrdered=bitArray.readBit();
  if (!isOrdered) {
    boolean isSparse=bitArray.readBit();
    for (int i=0; i < lengthMap.length; i++) {
      if (isSparse) {
        if (bitArray.readBit()) {
          lengthMap[i]=(long)(bitArray.readBits(5) + 1);
        }
 else {
          lengthMap[i]=0;
        }
      }
 else {
        lengthMap[i]=(long)(bitArray.readBits(5) + 1);
      }
    }
  }
 else {
    int length=bitArray.readBits(5) + 1;
    for (int i=0; i < lengthMap.length; ) {
      int num=bitArray.readBits(iLog(entries - i));
      for (int j=0; j < num && i < lengthMap.length; i++, j++) {
        lengthMap[i]=length;
      }
      length++;
    }
  }
  int lookupType=bitArray.readBits(4);
  if (lookupType > 2) {
    throw new ParserException(""String_Node_Str"" + lookupType);
  }
 else   if (lookupType == 1 || lookupType == 2) {
    bitArray.skipBits(32);
    bitArray.skipBits(32);
    int valueBits=bitArray.readBits(4) + 1;
    bitArray.skipBits(1);
    long lookupValuesCount;
    if (lookupType == 1) {
      if (dimensions != 0) {
        lookupValuesCount=mapType1QuantValues(entries,dimensions);
      }
 else {
        lookupValuesCount=0;
      }
    }
 else {
      lookupValuesCount=(long)entries * dimensions;
    }
    bitArray.skipBits((int)(lookupValuesCount * valueBits));
  }
  return new CodeBook(dimensions,entries,lengthMap,lookupType,isOrdered);
}",0.9935521688159438
110183,"/** 
 * Initializes the download, returning a list of   {@link Segment}s that need to be downloaded. 
 */
private List<Segment> initDownload() throws IOException, InterruptedException {
  M manifest=getManifest(dataSource,manifestUri);
  if (!streamKeys.isEmpty()) {
    manifest=manifest.copy(streamKeys);
  }
  List<Segment> segments=getSegments(dataSource,manifest,false);
  CachingCounters cachingCounters=new CachingCounters();
  totalSegments=segments.size();
  downloadedSegments=0;
  downloadedBytes=0;
  for (int i=segments.size() - 1; i >= 0; i--) {
    Segment segment=segments.get(i);
    CacheUtil.getCached(segment.dataSpec,cache,cachingCounters);
    downloadedBytes+=cachingCounters.alreadyCachedBytes;
    if (cachingCounters.alreadyCachedBytes == cachingCounters.contentLength) {
      downloadedSegments++;
      segments.remove(i);
    }
  }
  return segments;
}","/** 
 * Initializes the download, returning a list of   {@link Segment}s that need to be downloaded. 
 */
@SuppressWarnings(""String_Node_Str"") private List<Segment> initDownload() throws IOException, InterruptedException {
  M manifest=getManifest(dataSource,manifestUri);
  if (!streamKeys.isEmpty()) {
    manifest=manifest.copy(streamKeys);
  }
  List<Segment> segments=getSegments(dataSource,manifest,false);
  CachingCounters cachingCounters=new CachingCounters();
  totalSegments=segments.size();
  downloadedSegments=0;
  downloadedBytes=0;
  for (int i=segments.size() - 1; i >= 0; i--) {
    Segment segment=segments.get(i);
    CacheUtil.getCached(segment.dataSpec,cache,cachingCounters);
    downloadedBytes+=cachingCounters.alreadyCachedBytes;
    if (cachingCounters.alreadyCachedBytes == cachingCounters.contentLength) {
      downloadedSegments++;
      segments.remove(i);
    }
  }
  return segments;
}",0.9794558578567464
110184,"/** 
 * Returns the index of the track with the given format in the group.
 * @param format The format.
 * @return The index of the track, or {@link C#INDEX_UNSET} if no such track exists.
 */
public int indexOf(Format format){
  for (int i=0; i < formats.length; i++) {
    if (format == formats[i]) {
      return i;
    }
  }
  return C.INDEX_UNSET;
}","/** 
 * Returns the index of the track with the given format in the group. The format is located by identity so, for example,   {@code group.indexOf(group.getFormat(index)) == index} even ifmultiple tracks have formats that contain the same values.
 * @param format The format.
 * @return The index of the track, or {@link C#INDEX_UNSET} if no such track exists.
 */
@SuppressWarnings(""String_Node_Str"") public int indexOf(Format format){
  for (int i=0; i < formats.length; i++) {
    if (format == formats[i]) {
      return i;
    }
  }
  return C.INDEX_UNSET;
}",0.7704026115342764
110185,"@Override protected void decode(SubtitleInputBuffer inputBuffer){
  ccData.reset(inputBuffer.data.array(),inputBuffer.data.limit());
  while (ccData.bytesLeft() >= 3) {
    int ccTypeAndValid=(ccData.readUnsignedByte() & 0x07);
    int ccType=ccTypeAndValid & (DTVCC_PACKET_DATA | DTVCC_PACKET_START);
    boolean ccValid=(ccTypeAndValid & CC_VALID_FLAG) == CC_VALID_FLAG;
    byte ccData1=(byte)ccData.readUnsignedByte();
    byte ccData2=(byte)ccData.readUnsignedByte();
    if (ccType != DTVCC_PACKET_DATA && ccType != DTVCC_PACKET_START) {
      continue;
    }
    if (!ccValid) {
      continue;
    }
    if (ccType == DTVCC_PACKET_START) {
      finalizeCurrentPacket();
      int sequenceNumber=(ccData1 & 0xC0) >> 6;
      int packetSize=ccData1 & 0x3F;
      if (packetSize == 0) {
        packetSize=64;
      }
      currentDtvCcPacket=new DtvCcPacket(sequenceNumber,packetSize);
      currentDtvCcPacket.packetData[currentDtvCcPacket.currentIndex++]=ccData2;
    }
 else {
      Assertions.checkArgument(ccType == DTVCC_PACKET_DATA);
      if (currentDtvCcPacket == null) {
        Log.e(TAG,""String_Node_Str"");
        continue;
      }
      currentDtvCcPacket.packetData[currentDtvCcPacket.currentIndex++]=ccData1;
      currentDtvCcPacket.packetData[currentDtvCcPacket.currentIndex++]=ccData2;
    }
    if (currentDtvCcPacket.currentIndex == (currentDtvCcPacket.packetSize * 2 - 1)) {
      finalizeCurrentPacket();
    }
  }
}","@Override protected void decode(SubtitleInputBuffer inputBuffer){
  @SuppressWarnings(""String_Node_Str"") byte[] inputBufferData=inputBuffer.data.array();
  ccData.reset(inputBufferData,inputBuffer.data.limit());
  while (ccData.bytesLeft() >= 3) {
    int ccTypeAndValid=(ccData.readUnsignedByte() & 0x07);
    int ccType=ccTypeAndValid & (DTVCC_PACKET_DATA | DTVCC_PACKET_START);
    boolean ccValid=(ccTypeAndValid & CC_VALID_FLAG) == CC_VALID_FLAG;
    byte ccData1=(byte)ccData.readUnsignedByte();
    byte ccData2=(byte)ccData.readUnsignedByte();
    if (ccType != DTVCC_PACKET_DATA && ccType != DTVCC_PACKET_START) {
      continue;
    }
    if (!ccValid) {
      continue;
    }
    if (ccType == DTVCC_PACKET_START) {
      finalizeCurrentPacket();
      int sequenceNumber=(ccData1 & 0xC0) >> 6;
      int packetSize=ccData1 & 0x3F;
      if (packetSize == 0) {
        packetSize=64;
      }
      currentDtvCcPacket=new DtvCcPacket(sequenceNumber,packetSize);
      currentDtvCcPacket.packetData[currentDtvCcPacket.currentIndex++]=ccData2;
    }
 else {
      Assertions.checkArgument(ccType == DTVCC_PACKET_DATA);
      if (currentDtvCcPacket == null) {
        Log.e(TAG,""String_Node_Str"");
        continue;
      }
      currentDtvCcPacket.packetData[currentDtvCcPacket.currentIndex++]=ccData1;
      currentDtvCcPacket.packetData[currentDtvCcPacket.currentIndex++]=ccData2;
    }
    if (currentDtvCcPacket.currentIndex == (currentDtvCcPacket.packetSize * 2 - 1)) {
      finalizeCurrentPacket();
    }
  }
}",0.9579266240323124
110186,"public CueBuilder(){
  rolledUpCaptions=new LinkedList<>();
  captionStringBuilder=new SpannableStringBuilder();
  reset();
}","public CueBuilder(){
  rolledUpCaptions=new ArrayList<>();
  captionStringBuilder=new SpannableStringBuilder();
  reset();
}",0.9558232931726908
110187,"public CeaDecoder(){
  availableInputBuffers=new LinkedList<>();
  for (int i=0; i < NUM_INPUT_BUFFERS; i++) {
    availableInputBuffers.add(new CeaInputBuffer());
  }
  availableOutputBuffers=new LinkedList<>();
  for (int i=0; i < NUM_OUTPUT_BUFFERS; i++) {
    availableOutputBuffers.add(new CeaOutputBuffer());
  }
  queuedInputBuffers=new PriorityQueue<>();
}","public CeaDecoder(){
  availableInputBuffers=new ArrayDeque<>();
  for (int i=0; i < NUM_INPUT_BUFFERS; i++) {
    availableInputBuffers.add(new CeaInputBuffer());
  }
  availableOutputBuffers=new ArrayDeque<>();
  for (int i=0; i < NUM_OUTPUT_BUFFERS; i++) {
    availableOutputBuffers.add(new CeaOutputBuffer());
  }
  queuedInputBuffers=new PriorityQueue<>();
}",0.945054945054945
110188,"/** 
 * @param initializationData Optional initialization data for the decoder. If not null or empty,the initialization data must consist of two byte arrays. The first must contain an SSA format line. The second must contain an SSA header that will be assumed common to all samples.
 */
public SsaDecoder(List<byte[]> initializationData){
  super(""String_Node_Str"");
  if (initializationData != null && !initializationData.isEmpty()) {
    haveInitializationData=true;
    String formatLine=new String(initializationData.get(0));
    Assertions.checkArgument(formatLine.startsWith(FORMAT_LINE_PREFIX));
    parseFormatLine(formatLine);
    parseHeader(new ParsableByteArray(initializationData.get(1)));
  }
 else {
    haveInitializationData=false;
  }
}","/** 
 * @param initializationData Optional initialization data for the decoder. If not null or empty,the initialization data must consist of two byte arrays. The first must contain an SSA format line. The second must contain an SSA header that will be assumed common to all samples.
 */
public SsaDecoder(List<byte[]> initializationData){
  super(""String_Node_Str"");
  if (initializationData != null && !initializationData.isEmpty()) {
    haveInitializationData=true;
    String formatLine=Util.fromUtf8Bytes(initializationData.get(0));
    Assertions.checkArgument(formatLine.startsWith(FORMAT_LINE_PREFIX));
    parseFormatLine(formatLine);
    parseHeader(new ParsableByteArray(initializationData.get(1)));
  }
 else {
    haveInitializationData=false;
  }
}",0.9815303430079156
110189,"@Override public void addTextOutput(TextOutput listener){
  listener.onCues(currentCues);
  textOutputs.add(listener);
}","@Override public void addTextOutput(TextOutput listener){
  if (currentCues != null) {
    listener.onCues(currentCues);
  }
  textOutputs.add(listener);
}",0.8727272727272727
110190,"@Override public void close() throws IOException {
  cipherInputStream=null;
  upstream.close();
}","@Override public void close() throws IOException {
  if (cipherInputStream != null) {
    cipherInputStream=null;
    upstream.close();
  }
}",0.8200836820083682
110191,"@Override public long open(DataSpec dataSpec) throws IOException {
  Cipher cipher;
  try {
    cipher=Cipher.getInstance(""String_Node_Str"");
  }
 catch (  NoSuchAlgorithmException|NoSuchPaddingException e) {
    throw new RuntimeException(e);
  }
  Key cipherKey=new SecretKeySpec(encryptionKey,""String_Node_Str"");
  AlgorithmParameterSpec cipherIV=new IvParameterSpec(encryptionIv);
  try {
    cipher.init(Cipher.DECRYPT_MODE,cipherKey,cipherIV);
  }
 catch (  InvalidKeyException|InvalidAlgorithmParameterException e) {
    throw new RuntimeException(e);
  }
  cipherInputStream=new CipherInputStream(new DataSourceInputStream(upstream,dataSpec),cipher);
  return C.LENGTH_UNSET;
}","@Override public long open(DataSpec dataSpec) throws IOException {
  Cipher cipher;
  try {
    cipher=Cipher.getInstance(""String_Node_Str"");
  }
 catch (  NoSuchAlgorithmException|NoSuchPaddingException e) {
    throw new RuntimeException(e);
  }
  Key cipherKey=new SecretKeySpec(encryptionKey,""String_Node_Str"");
  AlgorithmParameterSpec cipherIV=new IvParameterSpec(encryptionIv);
  try {
    cipher.init(Cipher.DECRYPT_MODE,cipherKey,cipherIV);
  }
 catch (  InvalidKeyException|InvalidAlgorithmParameterException e) {
    throw new RuntimeException(e);
  }
  DataSourceInputStream inputStream=new DataSourceInputStream(upstream,dataSpec);
  cipherInputStream=new CipherInputStream(inputStream,cipher);
  inputStream.open();
  return C.LENGTH_UNSET;
}",0.878556557945871
110192,"/** 
 * Returns the track groups for the given period. Must not be called until after preparation completes.
 * @param periodIndex The period index.
 * @return The track groups for the period. May be {@link TrackGroupArray.EMPTY} for single streamcontent.
 */
public abstract TrackGroupArray getTrackGroups(int periodIndex);","/** 
 * Returns the track groups for the given period. Must not be called until after preparation completes.
 * @param periodIndex The period index.
 * @return The track groups for the period. May be {@link TrackGroupArray#EMPTY} for single streamcontent.
 */
public abstract TrackGroupArray getTrackGroups(int periodIndex);",0.9969135802469136
110193,"/** 
 * @param initialValues The {@link Parameters} from which the initial values of the builder areobtained.
 */
private ParametersBuilder(Parameters initialValues){
  selectionOverrides=initialValues.selectionOverrides.clone();
  rendererDisabledFlags=initialValues.rendererDisabledFlags.clone();
  preferredAudioLanguage=initialValues.preferredAudioLanguage;
  preferredTextLanguage=initialValues.preferredTextLanguage;
  selectUndeterminedTextLanguage=initialValues.selectUndeterminedTextLanguage;
  disabledTextTrackSelectionFlags=initialValues.disabledTextTrackSelectionFlags;
  forceLowestBitrate=initialValues.forceLowestBitrate;
  allowMixedMimeAdaptiveness=initialValues.allowMixedMimeAdaptiveness;
  allowNonSeamlessAdaptiveness=initialValues.allowNonSeamlessAdaptiveness;
  maxVideoWidth=initialValues.maxVideoWidth;
  maxVideoHeight=initialValues.maxVideoHeight;
  maxVideoBitrate=initialValues.maxVideoBitrate;
  exceedVideoConstraintsIfNecessary=initialValues.exceedVideoConstraintsIfNecessary;
  exceedRendererCapabilitiesIfNecessary=initialValues.exceedRendererCapabilitiesIfNecessary;
  viewportWidth=initialValues.viewportWidth;
  viewportHeight=initialValues.viewportHeight;
  viewportOrientationMayChange=initialValues.viewportOrientationMayChange;
  tunnelingAudioSessionId=initialValues.tunnelingAudioSessionId;
}","/** 
 * @param initialValues The {@link Parameters} from which the initial values of the builder areobtained.
 */
private ParametersBuilder(Parameters initialValues){
  selectionOverrides=cloneSelectionOverrides(initialValues.selectionOverrides);
  rendererDisabledFlags=initialValues.rendererDisabledFlags.clone();
  preferredAudioLanguage=initialValues.preferredAudioLanguage;
  preferredTextLanguage=initialValues.preferredTextLanguage;
  selectUndeterminedTextLanguage=initialValues.selectUndeterminedTextLanguage;
  disabledTextTrackSelectionFlags=initialValues.disabledTextTrackSelectionFlags;
  forceLowestBitrate=initialValues.forceLowestBitrate;
  allowMixedMimeAdaptiveness=initialValues.allowMixedMimeAdaptiveness;
  allowNonSeamlessAdaptiveness=initialValues.allowNonSeamlessAdaptiveness;
  maxVideoWidth=initialValues.maxVideoWidth;
  maxVideoHeight=initialValues.maxVideoHeight;
  maxVideoBitrate=initialValues.maxVideoBitrate;
  exceedVideoConstraintsIfNecessary=initialValues.exceedVideoConstraintsIfNecessary;
  exceedRendererCapabilitiesIfNecessary=initialValues.exceedRendererCapabilitiesIfNecessary;
  viewportWidth=initialValues.viewportWidth;
  viewportHeight=initialValues.viewportHeight;
  viewportOrientationMayChange=initialValues.viewportOrientationMayChange;
  tunnelingAudioSessionId=initialValues.tunnelingAudioSessionId;
}",0.978058757902566
110194,"@Override public void onRequestPermissionsResult(int requestCode,@NonNull String[] permissions,@NonNull int[] grantResults){
  if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
    initializePlayer();
  }
 else {
    showToast(R.string.storage_permission_denied);
    finish();
  }
}","@Override public void onRequestPermissionsResult(int requestCode,@NonNull String[] permissions,@NonNull int[] grantResults){
  if (grantResults.length > 0) {
    if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {
      initializePlayer();
    }
 else {
      showToast(R.string.storage_permission_denied);
      finish();
    }
  }
 else {
  }
}",0.8991097922848664
110195,"/** 
 * Attempts to extract the next sample in the current mdat atom. <p> If there are no more samples in the current mdat atom then the parser state is transitioned to   {@link #STATE_READING_ATOM_HEADER} and {@code false} is returned.<p> It is possible for a sample to be extracted in part in the case that an exception is thrown. In this case the method can be called again to extract the remainder of the sample.
 * @param input The {@link ExtractorInput} from which to read data.
 * @return Whether a sample was extracted.
 * @throws IOException If an error occurs reading from the input.
 * @throws InterruptedException If the thread is interrupted.
 */
private boolean readSample(ExtractorInput input) throws IOException, InterruptedException {
  if (parserState == STATE_READING_SAMPLE_START) {
    if (currentTrackBundle == null) {
      TrackBundle currentTrackBundle=getNextFragmentRun(trackBundles);
      if (currentTrackBundle == null) {
        int bytesToSkip=(int)(endOfMdatPosition - input.getPosition());
        if (bytesToSkip < 0) {
          throw new ParserException(""String_Node_Str"");
        }
        input.skipFully(bytesToSkip);
        enterReadingAtomHeaderState();
        return false;
      }
      long nextDataPosition=currentTrackBundle.fragment.trunDataPosition[currentTrackBundle.currentTrackRunIndex];
      int bytesToSkip=(int)(nextDataPosition - input.getPosition());
      if (bytesToSkip < 0) {
        Log.w(TAG,""String_Node_Str"");
        bytesToSkip=0;
      }
      input.skipFully(bytesToSkip);
      this.currentTrackBundle=currentTrackBundle;
    }
    sampleSize=currentTrackBundle.fragment.sampleSizeTable[currentTrackBundle.currentSampleIndex];
    if (currentTrackBundle.fragment.definesEncryptionData) {
      sampleBytesWritten=appendSampleEncryptionData(currentTrackBundle);
      sampleSize+=sampleBytesWritten;
    }
 else {
      sampleBytesWritten=0;
    }
    if (currentTrackBundle.track.sampleTransformation == Track.TRANSFORMATION_CEA608_CDAT) {
      sampleSize-=Atom.HEADER_SIZE;
      input.skipFully(Atom.HEADER_SIZE);
    }
    parserState=STATE_READING_SAMPLE_CONTINUE;
    sampleCurrentNalBytesRemaining=0;
  }
  TrackFragment fragment=currentTrackBundle.fragment;
  Track track=currentTrackBundle.track;
  TrackOutput output=currentTrackBundle.output;
  int sampleIndex=currentTrackBundle.currentSampleIndex;
  if (track.nalUnitLengthFieldLength != 0) {
    byte[] nalPrefixData=nalPrefix.data;
    nalPrefixData[0]=0;
    nalPrefixData[1]=0;
    nalPrefixData[2]=0;
    int nalUnitPrefixLength=track.nalUnitLengthFieldLength + 1;
    int nalUnitLengthFieldLengthDiff=4 - track.nalUnitLengthFieldLength;
    while (sampleBytesWritten < sampleSize) {
      if (sampleCurrentNalBytesRemaining == 0) {
        input.readFully(nalPrefixData,nalUnitLengthFieldLengthDiff,nalUnitPrefixLength);
        nalPrefix.setPosition(0);
        sampleCurrentNalBytesRemaining=nalPrefix.readUnsignedIntToInt() - 1;
        nalStartCode.setPosition(0);
        output.sampleData(nalStartCode,4);
        output.sampleData(nalPrefix,1);
        processSeiNalUnitPayload=cea608TrackOutputs.length > 0 && NalUnitUtil.isNalUnitSei(track.format.sampleMimeType,nalPrefixData[4]);
        sampleBytesWritten+=5;
        sampleSize+=nalUnitLengthFieldLengthDiff;
      }
 else {
        int writtenBytes;
        if (processSeiNalUnitPayload) {
          nalBuffer.reset(sampleCurrentNalBytesRemaining);
          input.readFully(nalBuffer.data,0,sampleCurrentNalBytesRemaining);
          output.sampleData(nalBuffer,sampleCurrentNalBytesRemaining);
          writtenBytes=sampleCurrentNalBytesRemaining;
          int unescapedLength=NalUnitUtil.unescapeStream(nalBuffer.data,nalBuffer.limit());
          nalBuffer.setPosition(MimeTypes.VIDEO_H265.equals(track.format.sampleMimeType) ? 1 : 0);
          nalBuffer.setLimit(unescapedLength);
          CeaUtil.consume(fragment.getSamplePresentationTime(sampleIndex) * 1000L,nalBuffer,cea608TrackOutputs);
        }
 else {
          writtenBytes=output.sampleData(input,sampleCurrentNalBytesRemaining,false);
        }
        sampleBytesWritten+=writtenBytes;
        sampleCurrentNalBytesRemaining-=writtenBytes;
      }
    }
  }
 else {
    while (sampleBytesWritten < sampleSize) {
      int writtenBytes=output.sampleData(input,sampleSize - sampleBytesWritten,false);
      sampleBytesWritten+=writtenBytes;
    }
  }
  long sampleTimeUs=fragment.getSamplePresentationTime(sampleIndex) * 1000L;
  if (timestampAdjuster != null) {
    sampleTimeUs=timestampAdjuster.adjustSampleTimestamp(sampleTimeUs);
  }
  @C.BufferFlags int sampleFlags=fragment.sampleIsSyncFrameTable[sampleIndex] ? C.BUFFER_FLAG_KEY_FRAME : 0;
  TrackOutput.CryptoData cryptoData=null;
  if (fragment.definesEncryptionData) {
    sampleFlags|=C.BUFFER_FLAG_ENCRYPTED;
    TrackEncryptionBox encryptionBox=fragment.trackEncryptionBox != null ? fragment.trackEncryptionBox : track.getSampleDescriptionEncryptionBox(fragment.header.sampleDescriptionIndex);
    cryptoData=encryptionBox.cryptoData;
  }
  output.sampleMetadata(sampleTimeUs,sampleFlags,sampleSize,0,cryptoData);
  outputPendingMetadataSamples(sampleTimeUs);
  currentTrackBundle.currentSampleIndex++;
  currentTrackBundle.currentSampleInTrackRun++;
  if (currentTrackBundle.currentSampleInTrackRun == fragment.trunLength[currentTrackBundle.currentTrackRunIndex]) {
    currentTrackBundle.currentTrackRunIndex++;
    currentTrackBundle.currentSampleInTrackRun=0;
    currentTrackBundle=null;
  }
  parserState=STATE_READING_SAMPLE_START;
  return true;
}","/** 
 * Attempts to extract the next sample in the current mdat atom. <p> If there are no more samples in the current mdat atom then the parser state is transitioned to   {@link #STATE_READING_ATOM_HEADER} and {@code false} is returned.<p> It is possible for a sample to be extracted in part in the case that an exception is thrown. In this case the method can be called again to extract the remainder of the sample.
 * @param input The {@link ExtractorInput} from which to read data.
 * @return Whether a sample was extracted.
 * @throws IOException If an error occurs reading from the input.
 * @throws InterruptedException If the thread is interrupted.
 */
private boolean readSample(ExtractorInput input) throws IOException, InterruptedException {
  if (parserState == STATE_READING_SAMPLE_START) {
    if (currentTrackBundle == null) {
      TrackBundle currentTrackBundle=getNextFragmentRun(trackBundles);
      if (currentTrackBundle == null) {
        int bytesToSkip=(int)(endOfMdatPosition - input.getPosition());
        if (bytesToSkip < 0) {
          throw new ParserException(""String_Node_Str"");
        }
        input.skipFully(bytesToSkip);
        enterReadingAtomHeaderState();
        return false;
      }
      long nextDataPosition=currentTrackBundle.fragment.trunDataPosition[currentTrackBundle.currentTrackRunIndex];
      int bytesToSkip=(int)(nextDataPosition - input.getPosition());
      if (bytesToSkip < 0) {
        Log.w(TAG,""String_Node_Str"");
        bytesToSkip=0;
      }
      input.skipFully(bytesToSkip);
      this.currentTrackBundle=currentTrackBundle;
    }
    sampleSize=currentTrackBundle.fragment.sampleSizeTable[currentTrackBundle.currentSampleIndex];
    if (currentTrackBundle.track.sampleTransformation == Track.TRANSFORMATION_CEA608_CDAT) {
      sampleSize-=Atom.HEADER_SIZE;
      input.skipFully(Atom.HEADER_SIZE);
    }
    if (currentTrackBundle.fragment.definesEncryptionData) {
      sampleBytesWritten=appendSampleEncryptionData(currentTrackBundle);
      sampleSize+=sampleBytesWritten;
    }
 else {
      sampleBytesWritten=0;
    }
    parserState=STATE_READING_SAMPLE_CONTINUE;
    sampleCurrentNalBytesRemaining=0;
  }
  TrackFragment fragment=currentTrackBundle.fragment;
  Track track=currentTrackBundle.track;
  TrackOutput output=currentTrackBundle.output;
  int sampleIndex=currentTrackBundle.currentSampleIndex;
  if (track.nalUnitLengthFieldLength != 0) {
    byte[] nalPrefixData=nalPrefix.data;
    nalPrefixData[0]=0;
    nalPrefixData[1]=0;
    nalPrefixData[2]=0;
    int nalUnitPrefixLength=track.nalUnitLengthFieldLength + 1;
    int nalUnitLengthFieldLengthDiff=4 - track.nalUnitLengthFieldLength;
    while (sampleBytesWritten < sampleSize) {
      if (sampleCurrentNalBytesRemaining == 0) {
        input.readFully(nalPrefixData,nalUnitLengthFieldLengthDiff,nalUnitPrefixLength);
        nalPrefix.setPosition(0);
        sampleCurrentNalBytesRemaining=nalPrefix.readUnsignedIntToInt() - 1;
        nalStartCode.setPosition(0);
        output.sampleData(nalStartCode,4);
        output.sampleData(nalPrefix,1);
        processSeiNalUnitPayload=cea608TrackOutputs.length > 0 && NalUnitUtil.isNalUnitSei(track.format.sampleMimeType,nalPrefixData[4]);
        sampleBytesWritten+=5;
        sampleSize+=nalUnitLengthFieldLengthDiff;
      }
 else {
        int writtenBytes;
        if (processSeiNalUnitPayload) {
          nalBuffer.reset(sampleCurrentNalBytesRemaining);
          input.readFully(nalBuffer.data,0,sampleCurrentNalBytesRemaining);
          output.sampleData(nalBuffer,sampleCurrentNalBytesRemaining);
          writtenBytes=sampleCurrentNalBytesRemaining;
          int unescapedLength=NalUnitUtil.unescapeStream(nalBuffer.data,nalBuffer.limit());
          nalBuffer.setPosition(MimeTypes.VIDEO_H265.equals(track.format.sampleMimeType) ? 1 : 0);
          nalBuffer.setLimit(unescapedLength);
          CeaUtil.consume(fragment.getSamplePresentationTime(sampleIndex) * 1000L,nalBuffer,cea608TrackOutputs);
        }
 else {
          writtenBytes=output.sampleData(input,sampleCurrentNalBytesRemaining,false);
        }
        sampleBytesWritten+=writtenBytes;
        sampleCurrentNalBytesRemaining-=writtenBytes;
      }
    }
  }
 else {
    while (sampleBytesWritten < sampleSize) {
      int writtenBytes=output.sampleData(input,sampleSize - sampleBytesWritten,false);
      sampleBytesWritten+=writtenBytes;
    }
  }
  long sampleTimeUs=fragment.getSamplePresentationTime(sampleIndex) * 1000L;
  if (timestampAdjuster != null) {
    sampleTimeUs=timestampAdjuster.adjustSampleTimestamp(sampleTimeUs);
  }
  @C.BufferFlags int sampleFlags=fragment.sampleIsSyncFrameTable[sampleIndex] ? C.BUFFER_FLAG_KEY_FRAME : 0;
  TrackOutput.CryptoData cryptoData=null;
  if (fragment.definesEncryptionData) {
    sampleFlags|=C.BUFFER_FLAG_ENCRYPTED;
    TrackEncryptionBox encryptionBox=fragment.trackEncryptionBox != null ? fragment.trackEncryptionBox : track.getSampleDescriptionEncryptionBox(fragment.header.sampleDescriptionIndex);
    cryptoData=encryptionBox.cryptoData;
  }
  output.sampleMetadata(sampleTimeUs,sampleFlags,sampleSize,0,cryptoData);
  outputPendingMetadataSamples(sampleTimeUs);
  currentTrackBundle.currentSampleIndex++;
  currentTrackBundle.currentSampleInTrackRun++;
  if (currentTrackBundle.currentSampleInTrackRun == fragment.trunLength[currentTrackBundle.currentTrackRunIndex]) {
    currentTrackBundle.currentTrackRunIndex++;
    currentTrackBundle.currentSampleInTrackRun=0;
    currentTrackBundle=null;
  }
  parserState=STATE_READING_SAMPLE_START;
  return true;
}",0.9606791778373548
110196,"private void handleAdGroupLoadError(){
  int adGroupIndex=this.adGroupIndex == C.INDEX_UNSET ? expectedAdGroupIndex : this.adGroupIndex;
  AdPlaybackState.AdGroup adGroup=adPlaybackState.adGroups[adGroupIndex];
  if (adGroup.count == C.LENGTH_UNSET) {
    adPlaybackState=adPlaybackState.withAdCount(adGroupIndex,Math.max(1,adGroup.states.length));
  }
  for (int i=0; i < adGroup.count; i++) {
    if (adGroup.states[i] == AdPlaybackState.AD_STATE_UNAVAILABLE) {
      if (DEBUG) {
        Log.d(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ adGroupIndex);
      }
      adPlaybackState=adPlaybackState.withAdLoadError(adGroupIndex,i);
    }
  }
  updateAdPlaybackState();
}","private void handleAdGroupLoadError(){
  int adGroupIndex=this.adGroupIndex == C.INDEX_UNSET ? expectedAdGroupIndex : this.adGroupIndex;
  if (adGroupIndex == C.INDEX_UNSET) {
    return;
  }
  AdPlaybackState.AdGroup adGroup=adPlaybackState.adGroups[adGroupIndex];
  if (adGroup.count == C.LENGTH_UNSET) {
    adPlaybackState=adPlaybackState.withAdCount(adGroupIndex,Math.max(1,adGroup.states.length));
    adGroup=adPlaybackState.adGroups[adGroupIndex];
  }
  for (int i=0; i < adGroup.count; i++) {
    if (adGroup.states[i] == AdPlaybackState.AD_STATE_UNAVAILABLE) {
      if (DEBUG) {
        Log.d(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ adGroupIndex);
      }
      adPlaybackState=adPlaybackState.withAdLoadError(adGroupIndex,i);
    }
  }
  updateAdPlaybackState();
}",0.9266620973269364
110197,"@Override public VideoProgressUpdate getContentProgress(){
  if (player == null) {
    return lastContentProgress;
  }
  boolean hasContentDuration=contentDurationMs != C.TIME_UNSET;
  long contentPositionMs;
  if (pendingContentPositionMs != C.TIME_UNSET) {
    sentPendingContentPositionMs=true;
    contentPositionMs=pendingContentPositionMs;
    expectedAdGroupIndex=adPlaybackState.getAdGroupIndexForPositionUs(C.msToUs(contentPositionMs));
  }
 else   if (fakeContentProgressElapsedRealtimeMs != C.TIME_UNSET) {
    long elapsedSinceEndMs=SystemClock.elapsedRealtime() - fakeContentProgressElapsedRealtimeMs;
    contentPositionMs=fakeContentProgressOffsetMs + elapsedSinceEndMs;
    expectedAdGroupIndex=adPlaybackState.getAdGroupIndexForPositionUs(C.msToUs(contentPositionMs));
  }
 else   if (imaAdState == IMA_AD_STATE_NONE && hasContentDuration) {
    contentPositionMs=player.getCurrentPosition();
    expectedAdGroupIndex=adPlaybackState.getAdGroupIndexAfterPositionUs(C.msToUs(contentPositionMs));
  }
 else {
    return VideoProgressUpdate.VIDEO_TIME_NOT_READY;
  }
  long contentDurationMs=hasContentDuration ? this.contentDurationMs : IMA_DURATION_UNSET;
  return new VideoProgressUpdate(contentPositionMs,contentDurationMs);
}","@Override public VideoProgressUpdate getContentProgress(){
  if (player == null) {
    return lastContentProgress;
  }
  boolean hasContentDuration=contentDurationMs != C.TIME_UNSET;
  long contentPositionMs;
  if (pendingContentPositionMs != C.TIME_UNSET) {
    sentPendingContentPositionMs=true;
    contentPositionMs=pendingContentPositionMs;
    expectedAdGroupIndex=adPlaybackState.getAdGroupIndexForPositionUs(C.msToUs(contentPositionMs));
  }
 else   if (fakeContentProgressElapsedRealtimeMs != C.TIME_UNSET) {
    long elapsedSinceEndMs=SystemClock.elapsedRealtime() - fakeContentProgressElapsedRealtimeMs;
    contentPositionMs=fakeContentProgressOffsetMs + elapsedSinceEndMs;
    expectedAdGroupIndex=adPlaybackState.getAdGroupIndexForPositionUs(C.msToUs(contentPositionMs));
  }
 else   if (imaAdState == IMA_AD_STATE_NONE && hasContentDuration) {
    contentPositionMs=player.getCurrentPosition();
    int nextAdGroupIndex=adPlaybackState.getAdGroupIndexAfterPositionUs(C.msToUs(contentPositionMs));
    if (nextAdGroupIndex != expectedAdGroupIndex && nextAdGroupIndex != C.INDEX_UNSET && C.usToMs(adPlaybackState.adGroupTimesUs[nextAdGroupIndex]) - contentPositionMs < MAXIMUM_PRELOAD_DURATION_MS) {
      expectedAdGroupIndex=nextAdGroupIndex;
    }
  }
 else {
    return VideoProgressUpdate.VIDEO_TIME_NOT_READY;
  }
  long contentDurationMs=hasContentDuration ? this.contentDurationMs : IMA_DURATION_UNSET;
  return new VideoProgressUpdate(contentPositionMs,contentDurationMs);
}",0.9021897810218978
110198,"/** 
 * Updates media periods in the queue to take into account the latest timeline, and returns whether the timeline change has been fully handled. If not, it is necessary to seek to the current playback position.
 * @param playingPeriodId The current playing media period identifier.
 * @param rendererPositionUs The current renderer position in microseconds.
 * @return Whether the timeline change has been handled completely.
 */
public boolean updateQueuedPeriods(MediaPeriodId playingPeriodId,long rendererPositionUs){
  int periodIndex=playingPeriodId.periodIndex;
  MediaPeriodHolder previousPeriodHolder=null;
  MediaPeriodHolder periodHolder=getFrontPeriod();
  while (periodHolder != null) {
    if (previousPeriodHolder == null) {
      periodHolder.info=getUpdatedMediaPeriodInfo(periodHolder.info,periodIndex);
    }
 else {
      MediaPeriodInfo periodInfo=getFollowingMediaPeriodInfo(previousPeriodHolder,rendererPositionUs);
      if (periodInfo == null) {
        return !removeAfter(previousPeriodHolder);
      }
      periodHolder.info=getUpdatedMediaPeriodInfo(periodHolder.info,periodIndex);
      if (!canKeepMediaPeriodHolder(periodHolder,periodInfo)) {
        return !removeAfter(previousPeriodHolder);
      }
    }
    if (periodHolder.info.isLastInTimelinePeriod) {
      periodIndex=timeline.getNextPeriodIndex(periodIndex,period,window,repeatMode,shuffleModeEnabled);
      if (periodIndex == C.INDEX_UNSET || !periodHolder.uid.equals(timeline.getPeriod(periodIndex,period,true).uid)) {
        return previousPeriodHolder == null || !removeAfter(previousPeriodHolder);
      }
    }
    previousPeriodHolder=periodHolder;
    periodHolder=periodHolder.next;
  }
  return true;
}","/** 
 * Updates media periods in the queue to take into account the latest timeline, and returns whether the timeline change has been fully handled. If not, it is necessary to seek to the current playback position. The method assumes that the first media period in the queue is still consistent with the new timeline.
 * @param playingPeriodId The current playing media period identifier.
 * @param rendererPositionUs The current renderer position in microseconds.
 * @return Whether the timeline change has been handled completely.
 */
public boolean updateQueuedPeriods(MediaPeriodId playingPeriodId,long rendererPositionUs){
  int periodIndex=playingPeriodId.periodIndex;
  MediaPeriodHolder previousPeriodHolder=null;
  MediaPeriodHolder periodHolder=getFrontPeriod();
  while (periodHolder != null) {
    if (previousPeriodHolder == null) {
      periodHolder.info=getUpdatedMediaPeriodInfo(periodHolder.info,periodIndex);
    }
 else {
      if (periodIndex == C.INDEX_UNSET || !periodHolder.uid.equals(timeline.getPeriod(periodIndex,period,true).uid)) {
        return !removeAfter(previousPeriodHolder);
      }
      MediaPeriodInfo periodInfo=getFollowingMediaPeriodInfo(previousPeriodHolder,rendererPositionUs);
      if (periodInfo == null) {
        return !removeAfter(previousPeriodHolder);
      }
      periodHolder.info=getUpdatedMediaPeriodInfo(periodHolder.info,periodIndex);
      if (!canKeepMediaPeriodHolder(periodHolder,periodInfo)) {
        return !removeAfter(previousPeriodHolder);
      }
    }
    if (periodHolder.info.isLastInTimelinePeriod) {
      periodIndex=timeline.getNextPeriodIndex(periodIndex,period,window,repeatMode,shuffleModeEnabled);
    }
    previousPeriodHolder=periodHolder;
    periodHolder=periodHolder.next;
  }
  return true;
}",0.645863154881191
110199,"private void handleAdGroupLoadError(){
  int adGroupIndex=this.adGroupIndex == C.INDEX_UNSET ? expectedAdGroupIndex : this.adGroupIndex;
  AdPlaybackState.AdGroup adGroup=adPlaybackState.adGroups[adGroupIndex];
  if (adGroup.count == C.LENGTH_UNSET) {
    adPlaybackState=adPlaybackState.withAdCount(adGroupIndex,Math.max(1,adGroup.states.length));
  }
  for (int i=0; i < adGroup.count; i++) {
    if (adGroup.states[i] == AdPlaybackState.AD_STATE_UNAVAILABLE) {
      if (DEBUG) {
        Log.d(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ adGroupIndex);
      }
      adPlaybackState=adPlaybackState.withAdLoadError(adGroupIndex,i);
    }
  }
  updateAdPlaybackState();
}","private void handleAdGroupLoadError(){
  int adGroupIndex=this.adGroupIndex == C.INDEX_UNSET ? expectedAdGroupIndex : this.adGroupIndex;
  if (adGroupIndex == C.INDEX_UNSET) {
    return;
  }
  AdPlaybackState.AdGroup adGroup=adPlaybackState.adGroups[adGroupIndex];
  if (adGroup.count == C.LENGTH_UNSET) {
    adPlaybackState=adPlaybackState.withAdCount(adGroupIndex,Math.max(1,adGroup.states.length));
    adGroup=adPlaybackState.adGroups[adGroupIndex];
  }
  for (int i=0; i < adGroup.count; i++) {
    if (adGroup.states[i] == AdPlaybackState.AD_STATE_UNAVAILABLE) {
      if (DEBUG) {
        Log.d(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ adGroupIndex);
      }
      adPlaybackState=adPlaybackState.withAdLoadError(adGroupIndex,i);
    }
  }
  updateAdPlaybackState();
}",0.9266620973269364
110200,"@Override public VideoProgressUpdate getContentProgress(){
  if (player == null) {
    return lastContentProgress;
  }
  boolean hasContentDuration=contentDurationMs != C.TIME_UNSET;
  long contentPositionMs;
  if (pendingContentPositionMs != C.TIME_UNSET) {
    sentPendingContentPositionMs=true;
    contentPositionMs=pendingContentPositionMs;
    expectedAdGroupIndex=adPlaybackState.getAdGroupIndexForPositionUs(C.msToUs(contentPositionMs));
  }
 else   if (fakeContentProgressElapsedRealtimeMs != C.TIME_UNSET) {
    long elapsedSinceEndMs=SystemClock.elapsedRealtime() - fakeContentProgressElapsedRealtimeMs;
    contentPositionMs=fakeContentProgressOffsetMs + elapsedSinceEndMs;
    expectedAdGroupIndex=adPlaybackState.getAdGroupIndexForPositionUs(C.msToUs(contentPositionMs));
  }
 else   if (imaAdState == IMA_AD_STATE_NONE && hasContentDuration) {
    contentPositionMs=player.getCurrentPosition();
    expectedAdGroupIndex=adPlaybackState.getAdGroupIndexAfterPositionUs(C.msToUs(contentPositionMs));
  }
 else {
    return VideoProgressUpdate.VIDEO_TIME_NOT_READY;
  }
  long contentDurationMs=hasContentDuration ? this.contentDurationMs : IMA_DURATION_UNSET;
  return new VideoProgressUpdate(contentPositionMs,contentDurationMs);
}","@Override public VideoProgressUpdate getContentProgress(){
  if (player == null) {
    return lastContentProgress;
  }
  boolean hasContentDuration=contentDurationMs != C.TIME_UNSET;
  long contentPositionMs;
  if (pendingContentPositionMs != C.TIME_UNSET) {
    sentPendingContentPositionMs=true;
    contentPositionMs=pendingContentPositionMs;
    expectedAdGroupIndex=adPlaybackState.getAdGroupIndexForPositionUs(C.msToUs(contentPositionMs));
  }
 else   if (fakeContentProgressElapsedRealtimeMs != C.TIME_UNSET) {
    long elapsedSinceEndMs=SystemClock.elapsedRealtime() - fakeContentProgressElapsedRealtimeMs;
    contentPositionMs=fakeContentProgressOffsetMs + elapsedSinceEndMs;
    expectedAdGroupIndex=adPlaybackState.getAdGroupIndexForPositionUs(C.msToUs(contentPositionMs));
  }
 else   if (imaAdState == IMA_AD_STATE_NONE && hasContentDuration) {
    contentPositionMs=player.getCurrentPosition();
    int nextAdGroupIndex=adPlaybackState.getAdGroupIndexAfterPositionUs(C.msToUs(contentPositionMs));
    if (nextAdGroupIndex != expectedAdGroupIndex && nextAdGroupIndex != C.INDEX_UNSET && C.usToMs(adPlaybackState.adGroupTimesUs[nextAdGroupIndex]) - contentPositionMs < MAXIMUM_PRELOAD_DURATION_MS) {
      expectedAdGroupIndex=nextAdGroupIndex;
    }
  }
 else {
    return VideoProgressUpdate.VIDEO_TIME_NOT_READY;
  }
  long contentDurationMs=hasContentDuration ? this.contentDurationMs : IMA_DURATION_UNSET;
  return new VideoProgressUpdate(contentPositionMs,contentDurationMs);
}",0.9021897810218978
110201,"/** 
 * Updates media periods in the queue to take into account the latest timeline, and returns whether the timeline change has been fully handled. If not, it is necessary to seek to the current playback position.
 * @param playingPeriodId The current playing media period identifier.
 * @param rendererPositionUs The current renderer position in microseconds.
 * @return Whether the timeline change has been handled completely.
 */
public boolean updateQueuedPeriods(MediaPeriodId playingPeriodId,long rendererPositionUs){
  int periodIndex=playingPeriodId.periodIndex;
  MediaPeriodHolder previousPeriodHolder=null;
  MediaPeriodHolder periodHolder=getFrontPeriod();
  while (periodHolder != null) {
    if (previousPeriodHolder == null) {
      periodHolder.info=getUpdatedMediaPeriodInfo(periodHolder.info,periodIndex);
    }
 else {
      MediaPeriodInfo periodInfo=getFollowingMediaPeriodInfo(previousPeriodHolder,rendererPositionUs);
      if (periodInfo == null) {
        return !removeAfter(previousPeriodHolder);
      }
      periodHolder.info=getUpdatedMediaPeriodInfo(periodHolder.info,periodIndex);
      if (!canKeepMediaPeriodHolder(periodHolder,periodInfo)) {
        return !removeAfter(previousPeriodHolder);
      }
    }
    if (periodHolder.info.isLastInTimelinePeriod) {
      periodIndex=timeline.getNextPeriodIndex(periodIndex,period,window,repeatMode,shuffleModeEnabled);
      if (periodIndex == C.INDEX_UNSET || !periodHolder.uid.equals(timeline.getPeriod(periodIndex,period,true).uid)) {
        return previousPeriodHolder == null || !removeAfter(previousPeriodHolder);
      }
    }
    previousPeriodHolder=periodHolder;
    periodHolder=periodHolder.next;
  }
  return true;
}","/** 
 * Updates media periods in the queue to take into account the latest timeline, and returns whether the timeline change has been fully handled. If not, it is necessary to seek to the current playback position. The method assumes that the first media period in the queue is still consistent with the new timeline.
 * @param playingPeriodId The current playing media period identifier.
 * @param rendererPositionUs The current renderer position in microseconds.
 * @return Whether the timeline change has been handled completely.
 */
public boolean updateQueuedPeriods(MediaPeriodId playingPeriodId,long rendererPositionUs){
  int periodIndex=playingPeriodId.periodIndex;
  MediaPeriodHolder previousPeriodHolder=null;
  MediaPeriodHolder periodHolder=getFrontPeriod();
  while (periodHolder != null) {
    if (previousPeriodHolder == null) {
      periodHolder.info=getUpdatedMediaPeriodInfo(periodHolder.info,periodIndex);
    }
 else {
      if (periodIndex == C.INDEX_UNSET || !periodHolder.uid.equals(timeline.getPeriod(periodIndex,period,true).uid)) {
        return !removeAfter(previousPeriodHolder);
      }
      MediaPeriodInfo periodInfo=getFollowingMediaPeriodInfo(previousPeriodHolder,rendererPositionUs);
      if (periodInfo == null) {
        return !removeAfter(previousPeriodHolder);
      }
      periodHolder.info=getUpdatedMediaPeriodInfo(periodHolder.info,periodIndex);
      if (!canKeepMediaPeriodHolder(periodHolder,periodInfo)) {
        return !removeAfter(previousPeriodHolder);
      }
    }
    if (periodHolder.info.isLastInTimelinePeriod) {
      periodIndex=timeline.getNextPeriodIndex(periodIndex,period,window,repeatMode,shuffleModeEnabled);
    }
    previousPeriodHolder=periodHolder;
    periodHolder=periodHolder.next;
  }
  return true;
}",0.645863154881191
110202,"public ConcatenatedTimeline(Collection<MediaSourceHolder> mediaSourceHolders,int windowCount,int periodCount,ShuffleOrder shuffleOrder){
  super(shuffleOrder);
  this.windowCount=windowCount;
  this.periodCount=periodCount;
  int childCount=mediaSourceHolders.size();
  firstPeriodInChildIndices=new int[childCount];
  firstWindowInChildIndices=new int[childCount];
  timelines=new Timeline[childCount];
  uids=new int[childCount];
  childIndexByUid=new SparseIntArray();
  int index=0;
  for (  MediaSourceHolder mediaSourceHolder : mediaSourceHolders) {
    timelines[index]=mediaSourceHolder.timeline;
    firstPeriodInChildIndices[index]=mediaSourceHolder.firstPeriodIndexInChild;
    firstWindowInChildIndices[index]=mediaSourceHolder.firstWindowIndexInChild;
    uids[index]=(int)mediaSourceHolder.uid;
    childIndexByUid.put(uids[index],index++);
  }
}","public ConcatenatedTimeline(Collection<MediaSourceHolder> mediaSourceHolders,int windowCount,int periodCount,ShuffleOrder shuffleOrder){
  super(shuffleOrder);
  this.windowCount=windowCount;
  this.periodCount=periodCount;
  int childCount=mediaSourceHolders.size();
  firstPeriodInChildIndices=new int[childCount];
  firstWindowInChildIndices=new int[childCount];
  timelines=new Timeline[childCount];
  uids=new int[childCount];
  childIndexByUid=new SparseIntArray();
  int index=0;
  for (  MediaSourceHolder mediaSourceHolder : mediaSourceHolders) {
    timelines[index]=mediaSourceHolder.timeline;
    firstPeriodInChildIndices[index]=mediaSourceHolder.firstPeriodIndexInChild;
    firstWindowInChildIndices[index]=mediaSourceHolder.firstWindowIndexInChild;
    uids[index]=mediaSourceHolder.uid;
    childIndexByUid.put(uids[index],index++);
  }
}",0.9970845481049564
110203,"public MediaSourceHolder(MediaSource mediaSource,DeferredTimeline timeline,int window,int period,Object uid){
  this.mediaSource=mediaSource;
  this.timeline=timeline;
  this.firstWindowIndexInChild=window;
  this.firstPeriodIndexInChild=period;
  this.uid=uid;
}","public MediaSourceHolder(MediaSource mediaSource,DeferredTimeline timeline,int childIndex,int window,int period){
  this.mediaSource=mediaSource;
  this.timeline=timeline;
  this.childIndex=childIndex;
  this.firstWindowIndexInChild=window;
  this.firstPeriodIndexInChild=period;
  this.uid=System.identityHashCode(this);
}",0.8293515358361775
110204,"private void correctOffsets(int startIndex,int windowOffsetUpdate,int periodOffsetUpdate){
  windowCount+=windowOffsetUpdate;
  periodCount+=periodOffsetUpdate;
  for (int i=startIndex; i < mediaSourceHolders.size(); i++) {
    mediaSourceHolders.get(i).firstWindowIndexInChild+=windowOffsetUpdate;
    mediaSourceHolders.get(i).firstPeriodIndexInChild+=periodOffsetUpdate;
  }
}","private void correctOffsets(int startIndex,int childIndexUpdate,int windowOffsetUpdate,int periodOffsetUpdate){
  windowCount+=windowOffsetUpdate;
  periodCount+=periodOffsetUpdate;
  for (int i=startIndex; i < mediaSourceHolders.size(); i++) {
    mediaSourceHolders.get(i).childIndex+=childIndexUpdate;
    mediaSourceHolders.get(i).firstWindowIndexInChild+=windowOffsetUpdate;
    mediaSourceHolders.get(i).firstPeriodIndexInChild+=periodOffsetUpdate;
  }
}",0.8748510131108462
110205,"private void addMediaSourceInternal(int newIndex,MediaSource newMediaSource){
  final MediaSourceHolder newMediaSourceHolder;
  Object newUid=System.identityHashCode(newMediaSource);
  DeferredTimeline newTimeline=new DeferredTimeline();
  if (newIndex > 0) {
    MediaSourceHolder previousHolder=mediaSourceHolders.get(newIndex - 1);
    newMediaSourceHolder=new MediaSourceHolder(newMediaSource,newTimeline,previousHolder.firstWindowIndexInChild + previousHolder.timeline.getWindowCount(),previousHolder.firstPeriodIndexInChild + previousHolder.timeline.getPeriodCount(),newUid);
  }
 else {
    newMediaSourceHolder=new MediaSourceHolder(newMediaSource,newTimeline,0,0,newUid);
  }
  correctOffsets(newIndex,newTimeline.getWindowCount(),newTimeline.getPeriodCount());
  mediaSourceHolders.add(newIndex,newMediaSourceHolder);
  prepareChildSource(newMediaSourceHolder,newMediaSourceHolder.mediaSource);
}","private void addMediaSourceInternal(int newIndex,MediaSource newMediaSource){
  final MediaSourceHolder newMediaSourceHolder;
  DeferredTimeline newTimeline=new DeferredTimeline();
  if (newIndex > 0) {
    MediaSourceHolder previousHolder=mediaSourceHolders.get(newIndex - 1);
    newMediaSourceHolder=new MediaSourceHolder(newMediaSource,newTimeline,newIndex,previousHolder.firstWindowIndexInChild + previousHolder.timeline.getWindowCount(),previousHolder.firstPeriodIndexInChild + previousHolder.timeline.getPeriodCount());
  }
 else {
    newMediaSourceHolder=new MediaSourceHolder(newMediaSource,newTimeline,0,0,0);
  }
  correctOffsets(newIndex,1,newTimeline.getWindowCount(),newTimeline.getPeriodCount());
  mediaSourceHolders.add(newIndex,newMediaSourceHolder);
  prepareChildSource(newMediaSourceHolder,newMediaSourceHolder.mediaSource);
}",0.7251995438996579
110206,"private void updateMediaSourceInternal(MediaSourceHolder mediaSourceHolder,Timeline timeline){
  if (mediaSourceHolder == null) {
    throw new IllegalArgumentException();
  }
  DeferredTimeline deferredTimeline=mediaSourceHolder.timeline;
  if (deferredTimeline.getTimeline() == timeline) {
    return;
  }
  int windowOffsetUpdate=timeline.getWindowCount() - deferredTimeline.getWindowCount();
  int periodOffsetUpdate=timeline.getPeriodCount() - deferredTimeline.getPeriodCount();
  if (windowOffsetUpdate != 0 || periodOffsetUpdate != 0) {
    int index=findMediaSourceHolderByPeriodIndex(mediaSourceHolder.firstPeriodIndexInChild);
    correctOffsets(index + 1,windowOffsetUpdate,periodOffsetUpdate);
  }
  mediaSourceHolder.timeline=deferredTimeline.cloneWithNewTimeline(timeline);
  if (!mediaSourceHolder.isPrepared) {
    for (int i=deferredMediaPeriods.size() - 1; i >= 0; i--) {
      if (deferredMediaPeriods.get(i).mediaSource == mediaSourceHolder.mediaSource) {
        deferredMediaPeriods.get(i).createPeriod();
        deferredMediaPeriods.remove(i);
      }
    }
  }
  mediaSourceHolder.isPrepared=true;
  maybeNotifyListener(null);
}","private void updateMediaSourceInternal(MediaSourceHolder mediaSourceHolder,Timeline timeline){
  if (mediaSourceHolder == null) {
    throw new IllegalArgumentException();
  }
  DeferredTimeline deferredTimeline=mediaSourceHolder.timeline;
  if (deferredTimeline.getTimeline() == timeline) {
    return;
  }
  int windowOffsetUpdate=timeline.getWindowCount() - deferredTimeline.getWindowCount();
  int periodOffsetUpdate=timeline.getPeriodCount() - deferredTimeline.getPeriodCount();
  if (windowOffsetUpdate != 0 || periodOffsetUpdate != 0) {
    correctOffsets(mediaSourceHolder.childIndex + 1,0,windowOffsetUpdate,periodOffsetUpdate);
  }
  mediaSourceHolder.timeline=deferredTimeline.cloneWithNewTimeline(timeline);
  if (!mediaSourceHolder.isPrepared) {
    for (int i=deferredMediaPeriods.size() - 1; i >= 0; i--) {
      if (deferredMediaPeriods.get(i).mediaSource == mediaSourceHolder.mediaSource) {
        deferredMediaPeriods.get(i).createPeriod();
        deferredMediaPeriods.remove(i);
      }
    }
  }
  mediaSourceHolder.isPrepared=true;
  maybeNotifyListener(null);
}",0.9490616621983914
110207,"private void removeMediaSourceInternal(int index){
  MediaSourceHolder holder=mediaSourceHolders.get(index);
  mediaSourceHolders.remove(index);
  Timeline oldTimeline=holder.timeline;
  correctOffsets(index,-oldTimeline.getWindowCount(),-oldTimeline.getPeriodCount());
  releaseChildSource(holder);
}","private void removeMediaSourceInternal(int index){
  MediaSourceHolder holder=mediaSourceHolders.get(index);
  mediaSourceHolders.remove(index);
  Timeline oldTimeline=holder.timeline;
  correctOffsets(index,-1,-oldTimeline.getWindowCount(),-oldTimeline.getPeriodCount());
  releaseChildSource(holder);
}",0.9950413223140496
110208,"private void closeCurrentSource() throws IOException {
  if (currentDataSource == null) {
    return;
  }
  try {
    currentDataSource.close();
    currentDataSource=null;
    currentDataSpecLengthUnset=false;
  }
  finally {
    if (currentHoleSpan != null) {
      cache.releaseHoleSpan(currentHoleSpan);
      currentHoleSpan=null;
    }
  }
}","private void closeCurrentSource() throws IOException {
  if (currentDataSource == null) {
    return;
  }
  try {
    currentDataSource.close();
  }
  finally {
    currentDataSource=null;
    currentDataSpecLengthUnset=false;
    if (currentHoleSpan != null) {
      cache.releaseHoleSpan(currentHoleSpan);
      currentHoleSpan=null;
    }
  }
}",0.9452449567723344
110209,"/** 
 * Opens the next source. If the cache contains data spanning the current read position then  {@link #cacheReadDataSource} is opened to read from it. Else {@link #upstreamDataSource} isopened to read from the upstream source and write into the cache.
 * @param checkCache If true tries to switch reading from or writing to cache instead of readingfrom upstream. If the switch isn't possible then returns without changing source.
 */
private void openNextSource(boolean checkCache) throws IOException {
  CacheSpan nextSpan;
  if (currentRequestIgnoresCache) {
    nextSpan=null;
  }
 else   if (blockOnCache) {
    try {
      nextSpan=cache.startReadWrite(key,readPosition);
    }
 catch (    InterruptedException e) {
      throw new InterruptedIOException();
    }
  }
 else {
    nextSpan=cache.startReadWriteNonBlocking(key,readPosition);
  }
  DataSpec nextDataSpec;
  DataSource nextDataSource;
  if (nextSpan == null) {
    nextDataSource=upstreamDataSource;
    nextDataSpec=new DataSpec(uri,readPosition,bytesRemaining,key,flags);
  }
 else   if (nextSpan.isCached) {
    Uri fileUri=Uri.fromFile(nextSpan.file);
    long filePosition=readPosition - nextSpan.position;
    long length=nextSpan.length - filePosition;
    if (bytesRemaining != C.LENGTH_UNSET) {
      length=Math.min(length,bytesRemaining);
    }
    nextDataSpec=new DataSpec(fileUri,readPosition,filePosition,length,key,flags);
    nextDataSource=cacheReadDataSource;
  }
 else {
    long length;
    if (nextSpan.isOpenEnded()) {
      length=bytesRemaining;
    }
 else {
      length=nextSpan.length;
      if (bytesRemaining != C.LENGTH_UNSET) {
        length=Math.min(length,bytesRemaining);
      }
    }
    nextDataSpec=new DataSpec(uri,readPosition,length,key,flags);
    if (cacheWriteDataSource != null) {
      nextDataSource=cacheWriteDataSource;
    }
 else {
      nextDataSource=upstreamDataSource;
      cache.releaseHoleSpan(nextSpan);
      nextSpan=null;
    }
  }
  if (!currentRequestIgnoresCache && nextDataSource == upstreamDataSource) {
    checkCachePosition=readPosition + MIN_READ_BEFORE_CHECKING_CACHE;
    if (checkCache) {
      return;
    }
  }
 else {
    checkCachePosition=Long.MAX_VALUE;
  }
  closeCurrentSource();
  if (nextSpan != null && nextSpan.isHoleSpan()) {
    currentHoleSpan=nextSpan;
  }
  currentDataSource=nextDataSource;
  currentDataSpecLengthUnset=nextDataSpec.length == C.LENGTH_UNSET;
  long resolvedLength=nextDataSource.open(nextDataSpec);
  if (currentDataSpecLengthUnset && resolvedLength != C.LENGTH_UNSET) {
    setBytesRemaining(resolvedLength);
  }
}","/** 
 * Opens the next source. If the cache contains data spanning the current read position then  {@link #cacheReadDataSource} is opened to read from it. Else {@link #upstreamDataSource} isopened to read from the upstream source and write into the cache. <p>There must not be a currently open source when this method is called, except in the case that  {@code checkCache} is true. If {@code checkCache} is true then there must be a currentlyopen source, and it must be  {@link #upstreamDataSource}. It will be closed and a new source opened if it's possible to switch to reading from or writing to the cache. If a switch isn't possible then the current source is left unchanged.
 * @param checkCache If true tries to switch to reading from or writing to cache instead ofreading from  {@link #upstreamDataSource}, which is the currently open source.
 */
private void openNextSource(boolean checkCache) throws IOException {
  CacheSpan nextSpan;
  if (currentRequestIgnoresCache) {
    nextSpan=null;
  }
 else   if (blockOnCache) {
    try {
      nextSpan=cache.startReadWrite(key,readPosition);
    }
 catch (    InterruptedException e) {
      throw new InterruptedIOException();
    }
  }
 else {
    nextSpan=cache.startReadWriteNonBlocking(key,readPosition);
  }
  DataSpec nextDataSpec;
  DataSource nextDataSource;
  if (nextSpan == null) {
    nextDataSource=upstreamDataSource;
    nextDataSpec=new DataSpec(uri,readPosition,bytesRemaining,key,flags);
  }
 else   if (nextSpan.isCached) {
    Uri fileUri=Uri.fromFile(nextSpan.file);
    long filePosition=readPosition - nextSpan.position;
    long length=nextSpan.length - filePosition;
    if (bytesRemaining != C.LENGTH_UNSET) {
      length=Math.min(length,bytesRemaining);
    }
    nextDataSpec=new DataSpec(fileUri,readPosition,filePosition,length,key,flags);
    nextDataSource=cacheReadDataSource;
  }
 else {
    long length;
    if (nextSpan.isOpenEnded()) {
      length=bytesRemaining;
    }
 else {
      length=nextSpan.length;
      if (bytesRemaining != C.LENGTH_UNSET) {
        length=Math.min(length,bytesRemaining);
      }
    }
    nextDataSpec=new DataSpec(uri,readPosition,length,key,flags);
    if (cacheWriteDataSource != null) {
      nextDataSource=cacheWriteDataSource;
    }
 else {
      nextDataSource=upstreamDataSource;
      cache.releaseHoleSpan(nextSpan);
      nextSpan=null;
    }
  }
  checkCachePosition=!currentRequestIgnoresCache && nextDataSource == upstreamDataSource ? readPosition + MIN_READ_BEFORE_CHECKING_CACHE : Long.MAX_VALUE;
  if (checkCache) {
    Assertions.checkState(currentDataSource == upstreamDataSource);
    if (nextDataSource == upstreamDataSource) {
      return;
    }
    try {
      closeCurrentSource();
    }
 catch (    Throwable e) {
      if (nextSpan.isHoleSpan()) {
        cache.releaseHoleSpan(nextSpan);
      }
      throw e;
    }
  }
  if (nextSpan != null && nextSpan.isHoleSpan()) {
    currentHoleSpan=nextSpan;
  }
  currentDataSource=nextDataSource;
  currentDataSpecLengthUnset=nextDataSpec.length == C.LENGTH_UNSET;
  long resolvedLength=nextDataSource.open(nextDataSpec);
  if (currentDataSpecLengthUnset && resolvedLength != C.LENGTH_UNSET) {
    setBytesRemaining(resolvedLength);
  }
}",0.8124036320027411
110210,"@Override public void onLoadCanceled(ParsingLoadable<SsManifest> loadable,long elapsedRealtimeMs,long loadDurationMs,boolean released){
  eventDispatcher.loadCompleted(loadable.dataSpec,loadable.type,elapsedRealtimeMs,loadDurationMs,loadable.bytesLoaded());
}","@Override public void onLoadCanceled(ParsingLoadable<SsManifest> loadable,long elapsedRealtimeMs,long loadDurationMs,boolean released){
  eventDispatcher.loadCanceled(loadable.dataSpec,loadable.type,elapsedRealtimeMs,loadDurationMs,loadable.bytesLoaded());
}",0.9787234042553192
110211,"private void processEndOfStream() throws ExoPlaybackException {
  outputStreamEnded=true;
  try {
    audioSink.playToEndOfStream();
  }
 catch (  AudioSink.WriteException e) {
    throw ExoPlaybackException.createForRenderer(drmSession.getError(),getIndex());
  }
}","private void processEndOfStream() throws ExoPlaybackException {
  outputStreamEnded=true;
  try {
    audioSink.playToEndOfStream();
  }
 catch (  AudioSink.WriteException e) {
    throw ExoPlaybackException.createForRenderer(e,getIndex());
  }
}",0.95703125
110212,"public void testAddGetRemove() throws Exception {
  final String key1=""String_Node_Str"";
  final String key2=""String_Node_Str"";
  final String key3=""String_Node_Str"";
  CachedContent cachedContent1=new CachedContent(5,key1,10);
  index.addNew(cachedContent1);
  CachedContent cachedContent2=index.add(key2);
  assertTrue(cachedContent1.id != cachedContent2.id);
  File cacheSpanFile=SimpleCacheSpanTest.createCacheSpanFile(cacheDir,cachedContent1.id,10,20,30);
  SimpleCacheSpan span=SimpleCacheSpan.createCacheEntry(cacheSpanFile,index);
  assertNotNull(span);
  cachedContent1.addSpan(span);
  assertEquals(cachedContent1,index.get(key1));
  assertEquals(cachedContent2,index.get(key2));
  assertNull(index.get(key3));
  Collection<CachedContent> cachedContents=index.getAll();
  assertEquals(2,cachedContents.size());
  assertTrue(Arrays.asList(cachedContent1,cachedContent2).containsAll(cachedContents));
  Set<String> keys=index.getKeys();
  assertEquals(2,keys.size());
  assertTrue(Arrays.asList(key1,key2).containsAll(keys));
  assertEquals(key1,index.getKeyForId(cachedContent1.id));
  assertEquals(key2,index.getKeyForId(cachedContent2.id));
  index.removeEmpty(key2);
  index.removeEmpty(key3);
  assertEquals(cachedContent1,index.get(key1));
  assertNull(index.get(key2));
  assertTrue(cacheSpanFile.exists());
  index.addNew(cachedContent2);
  index.removeEmpty();
  assertEquals(cachedContent1,index.get(key1));
  assertNull(index.get(key2));
  assertTrue(cacheSpanFile.exists());
}","public void testAddGetRemove() throws Exception {
  final String key1=""String_Node_Str"";
  final String key2=""String_Node_Str"";
  final String key3=""String_Node_Str"";
  CachedContent cachedContent1=new CachedContent(5,key1,10);
  index.addNew(cachedContent1);
  CachedContent cachedContent2=index.getOrAdd(key2);
  assertTrue(cachedContent1.id != cachedContent2.id);
  File cacheSpanFile=SimpleCacheSpanTest.createCacheSpanFile(cacheDir,cachedContent1.id,10,20,30);
  SimpleCacheSpan span=SimpleCacheSpan.createCacheEntry(cacheSpanFile,index);
  assertNotNull(span);
  cachedContent1.addSpan(span);
  assertEquals(cachedContent1,index.get(key1));
  assertEquals(cachedContent2,index.get(key2));
  assertNull(index.get(key3));
  Collection<CachedContent> cachedContents=index.getAll();
  assertEquals(2,cachedContents.size());
  assertTrue(Arrays.asList(cachedContent1,cachedContent2).containsAll(cachedContents));
  Set<String> keys=index.getKeys();
  assertEquals(2,keys.size());
  assertTrue(Arrays.asList(key1,key2).containsAll(keys));
  assertEquals(key1,index.getKeyForId(cachedContent1.id));
  assertEquals(key2,index.getKeyForId(cachedContent2.id));
  index.maybeRemove(key2);
  index.maybeRemove(key3);
  assertEquals(cachedContent1,index.get(key1));
  assertNull(index.get(key2));
  assertTrue(cacheSpanFile.exists());
  index.addNew(cachedContent2);
  index.removeEmpty();
  assertEquals(cachedContent1,index.get(key1));
  assertNull(index.get(key2));
  assertTrue(cacheSpanFile.exists());
}",0.8621955288621955
110213,"private void assertStoredAndLoadedEqual(CachedContentIndex index,CachedContentIndex index2) throws IOException {
  index.addNew(new CachedContent(5,""String_Node_Str"",10));
  index.add(""String_Node_Str"");
  index.store();
  index2.load();
  Set<String> keys=index.getKeys();
  Set<String> keys2=index2.getKeys();
  assertEquals(keys,keys2);
  for (  String key : keys) {
    assertEquals(index.getContentLength(key),index2.getContentLength(key));
    assertEquals(index.get(key).getSpans(),index2.get(key).getSpans());
  }
}","private void assertStoredAndLoadedEqual(CachedContentIndex index,CachedContentIndex index2) throws IOException {
  index.addNew(new CachedContent(5,""String_Node_Str"",10));
  index.getOrAdd(""String_Node_Str"");
  index.store();
  index2.load();
  Set<String> keys=index.getKeys();
  Set<String> keys2=index2.getKeys();
  assertEquals(keys,keys2);
  for (  String key : keys) {
    assertEquals(index.getContentLength(key),index2.getContentLength(key));
    assertEquals(index.get(key).getSpans(),index2.get(key).getSpans());
  }
}",0.9933396764985728
110214,"@Override public int read(byte[] buffer,int offset,int readLength) throws IOException {
  if (readLength == 0) {
    return 0;
  }
  if (bytesRemaining == 0) {
    return C.RESULT_END_OF_INPUT;
  }
  try {
    if (readPosition >= checkCachePosition) {
      openNextSource();
    }
    int bytesRead=currentDataSource.read(buffer,offset,readLength);
    if (bytesRead != C.RESULT_END_OF_INPUT) {
      if (currentDataSource == cacheReadDataSource) {
        totalCachedBytesRead+=bytesRead;
      }
      readPosition+=bytesRead;
      if (bytesRemaining != C.LENGTH_UNSET) {
        bytesRemaining-=bytesRead;
      }
    }
 else     if (currentDataSpecLengthUnset) {
      setBytesRemaining(0);
    }
 else     if (bytesRemaining > 0 || bytesRemaining == C.LENGTH_UNSET) {
      openNextSource();
      return read(buffer,offset,readLength);
    }
    return bytesRead;
  }
 catch (  IOException e) {
    if (currentDataSpecLengthUnset && isCausedByPositionOutOfRange(e)) {
      setBytesRemaining(0);
      return C.RESULT_END_OF_INPUT;
    }
    handleBeforeThrow(e);
    throw e;
  }
}","@Override public int read(byte[] buffer,int offset,int readLength) throws IOException {
  if (readLength == 0) {
    return 0;
  }
  if (bytesRemaining == 0) {
    return C.RESULT_END_OF_INPUT;
  }
  try {
    if (readPosition >= checkCachePosition) {
      openNextSource(true);
    }
    int bytesRead=currentDataSource.read(buffer,offset,readLength);
    if (bytesRead != C.RESULT_END_OF_INPUT) {
      if (currentDataSource == cacheReadDataSource) {
        totalCachedBytesRead+=bytesRead;
      }
      readPosition+=bytesRead;
      if (bytesRemaining != C.LENGTH_UNSET) {
        bytesRemaining-=bytesRead;
      }
    }
 else {
      closeCurrentSource();
      if (currentDataSpecLengthUnset) {
        setBytesRemaining(0);
      }
 else       if (bytesRemaining > 0 || bytesRemaining == C.LENGTH_UNSET) {
        openNextSource(false);
        return read(buffer,offset,readLength);
      }
    }
    return bytesRead;
  }
 catch (  IOException e) {
    if (currentDataSpecLengthUnset && isCausedByPositionOutOfRange(e)) {
      setBytesRemaining(0);
      return C.RESULT_END_OF_INPUT;
    }
    handleBeforeThrow(e);
    throw e;
  }
}",0.9709691826708352
110215,"/** 
 * Opens the next source. If the cache contains data spanning the current read position then  {@link #cacheReadDataSource} is opened to read from it. Else {@link #upstreamDataSource} isopened to read from the upstream source and write into the cache.
 */
private void openNextSource() throws IOException {
  CacheSpan nextSpan;
  if (currentRequestIgnoresCache) {
    nextSpan=null;
  }
 else   if (blockOnCache) {
    try {
      nextSpan=cache.startReadWrite(key,readPosition);
    }
 catch (    InterruptedException e) {
      throw new InterruptedIOException();
    }
  }
 else {
    nextSpan=cache.startReadWriteNonBlocking(key,readPosition);
  }
  DataSpec nextDataSpec;
  DataSource nextDataSource;
  if (nextSpan == null) {
    nextDataSource=upstreamDataSource;
    nextDataSpec=new DataSpec(uri,readPosition,bytesRemaining,key,flags);
  }
 else   if (nextSpan.isCached) {
    Uri fileUri=Uri.fromFile(nextSpan.file);
    long filePosition=readPosition - nextSpan.position;
    long length=nextSpan.length - filePosition;
    if (bytesRemaining != C.LENGTH_UNSET) {
      length=Math.min(length,bytesRemaining);
    }
    nextDataSpec=new DataSpec(fileUri,readPosition,filePosition,length,key,flags);
    nextDataSource=cacheReadDataSource;
  }
 else {
    long length;
    if (nextSpan.isOpenEnded()) {
      length=bytesRemaining;
    }
 else {
      length=nextSpan.length;
      if (bytesRemaining != C.LENGTH_UNSET) {
        length=Math.min(length,bytesRemaining);
      }
    }
    nextDataSpec=new DataSpec(uri,readPosition,length,key,flags);
    if (cacheWriteDataSource != null) {
      nextDataSource=cacheWriteDataSource;
    }
 else {
      nextDataSource=upstreamDataSource;
      cache.releaseHoleSpan(nextSpan);
      nextSpan=null;
    }
  }
  if (nextDataSource == upstreamDataSource) {
    checkCachePosition=readPosition + MIN_READ_BEFORE_CHECKING_CACHE;
    if (currentDataSource == upstreamDataSource) {
      return;
    }
  }
 else {
    checkCachePosition=Long.MAX_VALUE;
  }
  closeCurrentSource();
  if (nextSpan != null && nextSpan.isHoleSpan()) {
    currentHoleSpan=nextSpan;
  }
  currentDataSource=nextDataSource;
  currentDataSpecLengthUnset=nextDataSpec.length == C.LENGTH_UNSET;
  long resolvedLength=nextDataSource.open(nextDataSpec);
  if (currentDataSpecLengthUnset && resolvedLength != C.LENGTH_UNSET) {
    setBytesRemaining(resolvedLength);
  }
}","/** 
 * Opens the next source. If the cache contains data spanning the current read position then  {@link #cacheReadDataSource} is opened to read from it. Else {@link #upstreamDataSource} isopened to read from the upstream source and write into the cache.
 * @param checkCache If true tries to switch reading from or writing to cache instead of readingfrom upstream. If the switch isn't possible then returns without changing source.
 */
private void openNextSource(boolean checkCache) throws IOException {
  CacheSpan nextSpan;
  if (currentRequestIgnoresCache) {
    nextSpan=null;
  }
 else   if (blockOnCache) {
    try {
      nextSpan=cache.startReadWrite(key,readPosition);
    }
 catch (    InterruptedException e) {
      throw new InterruptedIOException();
    }
  }
 else {
    nextSpan=cache.startReadWriteNonBlocking(key,readPosition);
  }
  DataSpec nextDataSpec;
  DataSource nextDataSource;
  if (nextSpan == null) {
    nextDataSource=upstreamDataSource;
    nextDataSpec=new DataSpec(uri,readPosition,bytesRemaining,key,flags);
  }
 else   if (nextSpan.isCached) {
    Uri fileUri=Uri.fromFile(nextSpan.file);
    long filePosition=readPosition - nextSpan.position;
    long length=nextSpan.length - filePosition;
    if (bytesRemaining != C.LENGTH_UNSET) {
      length=Math.min(length,bytesRemaining);
    }
    nextDataSpec=new DataSpec(fileUri,readPosition,filePosition,length,key,flags);
    nextDataSource=cacheReadDataSource;
  }
 else {
    long length;
    if (nextSpan.isOpenEnded()) {
      length=bytesRemaining;
    }
 else {
      length=nextSpan.length;
      if (bytesRemaining != C.LENGTH_UNSET) {
        length=Math.min(length,bytesRemaining);
      }
    }
    nextDataSpec=new DataSpec(uri,readPosition,length,key,flags);
    if (cacheWriteDataSource != null) {
      nextDataSource=cacheWriteDataSource;
    }
 else {
      nextDataSource=upstreamDataSource;
      cache.releaseHoleSpan(nextSpan);
      nextSpan=null;
    }
  }
  if (!currentRequestIgnoresCache && nextDataSource == upstreamDataSource) {
    checkCachePosition=readPosition + MIN_READ_BEFORE_CHECKING_CACHE;
    if (checkCache) {
      return;
    }
  }
 else {
    checkCachePosition=Long.MAX_VALUE;
  }
  closeCurrentSource();
  if (nextSpan != null && nextSpan.isHoleSpan()) {
    currentHoleSpan=nextSpan;
  }
  currentDataSource=nextDataSource;
  currentDataSpecLengthUnset=nextDataSpec.length == C.LENGTH_UNSET;
  long resolvedLength=nextDataSource.open(nextDataSpec);
  if (currentDataSpecLengthUnset && resolvedLength != C.LENGTH_UNSET) {
    setBytesRemaining(resolvedLength);
  }
}",0.9456
110216,"@Override public long open(DataSpec dataSpec) throws IOException {
  try {
    uri=dataSpec.uri;
    flags=dataSpec.flags;
    key=CacheUtil.getKey(dataSpec);
    readPosition=dataSpec.position;
    currentRequestIgnoresCache=(ignoreCacheOnError && seenCacheError) || (dataSpec.length == C.LENGTH_UNSET && ignoreCacheForUnsetLengthRequests);
    if (dataSpec.length != C.LENGTH_UNSET || currentRequestIgnoresCache) {
      bytesRemaining=dataSpec.length;
    }
 else {
      bytesRemaining=cache.getContentLength(key);
      if (bytesRemaining != C.LENGTH_UNSET) {
        bytesRemaining-=dataSpec.position;
        if (bytesRemaining <= 0) {
          throw new DataSourceException(DataSourceException.POSITION_OUT_OF_RANGE);
        }
      }
    }
    openNextSource();
    return bytesRemaining;
  }
 catch (  IOException e) {
    handleBeforeThrow(e);
    throw e;
  }
}","@Override public long open(DataSpec dataSpec) throws IOException {
  try {
    uri=dataSpec.uri;
    flags=dataSpec.flags;
    key=CacheUtil.getKey(dataSpec);
    readPosition=dataSpec.position;
    currentRequestIgnoresCache=(ignoreCacheOnError && seenCacheError) || (dataSpec.length == C.LENGTH_UNSET && ignoreCacheForUnsetLengthRequests);
    if (dataSpec.length != C.LENGTH_UNSET || currentRequestIgnoresCache) {
      bytesRemaining=dataSpec.length;
    }
 else {
      bytesRemaining=cache.getContentLength(key);
      if (bytesRemaining != C.LENGTH_UNSET) {
        bytesRemaining-=dataSpec.position;
        if (bytesRemaining <= 0) {
          throw new DataSourceException(DataSourceException.POSITION_OUT_OF_RANGE);
        }
      }
    }
    openNextSource(false);
    return bytesRemaining;
  }
 catch (  IOException e) {
    handleBeforeThrow(e);
    throw e;
  }
}",0.9971509971509972
110217,"/** 
 * Removes empty   {@link CachedContent} instances from index. 
 */
public void removeEmpty(){
  ArrayList<String> cachedContentToBeRemoved=new ArrayList<>();
  for (  CachedContent cachedContent : keyToContent.values()) {
    if (cachedContent.isEmpty()) {
      cachedContentToBeRemoved.add(cachedContent.key);
    }
  }
  for (int i=0; i < cachedContentToBeRemoved.size(); i++) {
    removeEmpty(cachedContentToBeRemoved.get(i));
  }
}","/** 
 * Removes empty and not locked   {@link CachedContent} instances from index. 
 */
public void removeEmpty(){
  String[] keys=new String[keyToContent.size()];
  keyToContent.keySet().toArray(keys);
  for (  String key : keys) {
    maybeRemove(key);
  }
}",0.364153627311522
110218,"/** 
 * Returns an existing or new id assigned to the given key. 
 */
public int assignIdForKey(String key){
  return add(key).id;
}","/** 
 * Returns an existing or new id assigned to the given key. 
 */
public int assignIdForKey(String key){
  return getOrAdd(key).id;
}",0.9739776951672864
110219,"/** 
 * Adds a cached span to the in-memory representation.
 * @param span The span to be added.
 */
private void addSpan(SimpleCacheSpan span){
  index.add(span.key).addSpan(span);
  totalSpace+=span.length;
  notifySpanAdded(span);
}","/** 
 * Adds a cached span to the in-memory representation.
 * @param span The span to be added.
 */
private void addSpan(SimpleCacheSpan span){
  index.getOrAdd(span.key).addSpan(span);
  totalSpace+=span.length;
  notifySpanAdded(span);
}",0.9852631578947368
110220,"@Override public synchronized File startFile(String key,long position,long maxLength) throws CacheException {
  Assertions.checkState(lockedSpans.containsKey(key));
  if (!cacheDir.exists()) {
    removeStaleSpansAndCachedContents();
    cacheDir.mkdirs();
  }
  evictor.onStartFile(this,key,position,maxLength);
  return SimpleCacheSpan.getCacheFile(cacheDir,index.assignIdForKey(key),position,System.currentTimeMillis());
}","@Override public synchronized File startFile(String key,long position,long maxLength) throws CacheException {
  CachedContent cachedContent=index.get(key);
  Assertions.checkNotNull(cachedContent);
  Assertions.checkState(cachedContent.isLocked());
  if (!cacheDir.exists()) {
    removeStaleSpansAndCachedContents();
    cacheDir.mkdirs();
  }
  evictor.onStartFile(this,key,position,maxLength);
  return SimpleCacheSpan.getCacheFile(cacheDir,cachedContent.id,position,System.currentTimeMillis());
}",0.7697297297297298
110221,"@Override public synchronized void releaseHoleSpan(CacheSpan holeSpan){
  Assertions.checkState(holeSpan == lockedSpans.remove(holeSpan.key));
  notifyAll();
}","@Override public synchronized void releaseHoleSpan(CacheSpan holeSpan){
  CachedContent cachedContent=index.get(holeSpan.key);
  Assertions.checkNotNull(cachedContent);
  Assertions.checkState(cachedContent.isLocked());
  cachedContent.setLocked(false);
  notifyAll();
}",0.5081585081585082
110222,"/** 
 * Constructs the cache. The cache will delete any unrecognized files from the directory. Hence the directory cannot be used to store other files.
 * @param cacheDir A dedicated cache directory.
 * @param evictor The evictor to be used.
 * @param index The CachedContentIndex to be used.
 */
SimpleCache(File cacheDir,CacheEvictor evictor,CachedContentIndex index){
  this.cacheDir=cacheDir;
  this.evictor=evictor;
  this.lockedSpans=new HashMap<>();
  this.index=index;
  this.listeners=new HashMap<>();
  final ConditionVariable conditionVariable=new ConditionVariable();
  new Thread(""String_Node_Str""){
    @Override public void run(){
synchronized (SimpleCache.this) {
        conditionVariable.open();
        initialize();
        SimpleCache.this.evictor.onCacheInitialized();
      }
    }
  }
.start();
  conditionVariable.block();
}","/** 
 * Constructs the cache. The cache will delete any unrecognized files from the directory. Hence the directory cannot be used to store other files.
 * @param cacheDir A dedicated cache directory.
 * @param evictor The evictor to be used.
 * @param index The CachedContentIndex to be used.
 */
SimpleCache(File cacheDir,CacheEvictor evictor,CachedContentIndex index){
  this.cacheDir=cacheDir;
  this.evictor=evictor;
  this.index=index;
  this.listeners=new HashMap<>();
  final ConditionVariable conditionVariable=new ConditionVariable();
  new Thread(""String_Node_Str""){
    @Override public void run(){
synchronized (SimpleCache.this) {
        conditionVariable.open();
        initialize();
        SimpleCache.this.evictor.onCacheInitialized();
      }
    }
  }
.start();
  conditionVariable.block();
}",0.9446450060168472
110223,"@Override public synchronized void commitFile(File file) throws CacheException {
  SimpleCacheSpan span=SimpleCacheSpan.createCacheEntry(file,index);
  Assertions.checkState(span != null);
  Assertions.checkState(lockedSpans.containsKey(span.key));
  if (!file.exists()) {
    return;
  }
  if (file.length() == 0) {
    file.delete();
    return;
  }
  Long length=getContentLength(span.key);
  if (length != C.LENGTH_UNSET) {
    Assertions.checkState((span.position + span.length) <= length);
  }
  addSpan(span);
  index.store();
  notifyAll();
}","@Override public synchronized void commitFile(File file) throws CacheException {
  SimpleCacheSpan span=SimpleCacheSpan.createCacheEntry(file,index);
  Assertions.checkState(span != null);
  CachedContent cachedContent=index.get(span.key);
  Assertions.checkNotNull(cachedContent);
  Assertions.checkState(cachedContent.isLocked());
  if (!file.exists()) {
    return;
  }
  if (file.length() == 0) {
    file.delete();
    return;
  }
  Long length=cachedContent.getLength();
  if (length != C.LENGTH_UNSET) {
    Assertions.checkState((span.position + span.length) <= length);
  }
  addSpan(span);
  index.store();
  notifyAll();
}",0.8436179205409975
110224,"@Override public synchronized SimpleCacheSpan startReadWriteNonBlocking(String key,long position) throws CacheException {
  SimpleCacheSpan cacheSpan=getSpan(key,position);
  if (cacheSpan.isCached) {
    SimpleCacheSpan newCacheSpan=index.get(key).touch(cacheSpan);
    notifySpanTouched(cacheSpan,newCacheSpan);
    return newCacheSpan;
  }
  if (!lockedSpans.containsKey(key)) {
    lockedSpans.put(key,cacheSpan);
    return cacheSpan;
  }
  return null;
}","@Override public synchronized SimpleCacheSpan startReadWriteNonBlocking(String key,long position) throws CacheException {
  SimpleCacheSpan cacheSpan=getSpan(key,position);
  if (cacheSpan.isCached) {
    SimpleCacheSpan newCacheSpan=index.get(key).touch(cacheSpan);
    notifySpanTouched(cacheSpan,newCacheSpan);
    return newCacheSpan;
  }
  CachedContent cachedContent=index.getOrAdd(key);
  if (!cachedContent.isLocked()) {
    cachedContent.setLocked(true);
    return cacheSpan;
  }
  return null;
}",0.8405797101449275
110225,"/** 
 * Asserts that the cache contains the given data for   {@code uriString} or not.
 * @throws IOException If an error occurred reading from the Cache.
 */
public static void assertDataCached(Cache cache,Uri uri,byte[] expected) throws IOException {
  CacheDataSource dataSource=new CacheDataSource(cache,DummyDataSource.INSTANCE,0);
  ByteArrayOutputStream outputStream=new ByteArrayOutputStream();
  DataSourceInputStream inputStream=new DataSourceInputStream(dataSource,new DataSpec(uri,DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH));
  try {
    inputStream.open();
    byte[] buffer=new byte[1024];
    int bytesRead;
    while ((bytesRead=inputStream.read(buffer)) != -1) {
      outputStream.write(buffer,0,bytesRead);
    }
  }
 catch (  IOException e) {
  }
 finally {
    inputStream.close();
  }
  assertWithMessage(""String_Node_Str"" + uri + ""String_Node_Str"").that(outputStream.toByteArray()).isEqualTo(expected);
}","/** 
 * Asserts that the cache contains the given data for   {@code uriString} or not.
 * @throws IOException If an error occurred reading from the Cache.
 */
public static void assertDataCached(Cache cache,Uri uri,byte[] expected) throws IOException {
  DataSource dataSource=new CacheDataSource(cache,DummyDataSource.INSTANCE,0);
  DataSpec dataSpec=new DataSpec(uri,DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH);
  String messageToPrepend=""String_Node_Str"" + uri + ""String_Node_Str"";
  assertReadData(dataSource,dataSpec,expected,messageToPrepend);
}",0.539553752535497
110226,"@Override protected void tearDown() throws Exception {
  offlineLicenseHelper.release();
  offlineLicenseHelper=null;
}","@Override protected void tearDown() throws Exception {
  offlineLicenseHelper.release();
  offlineLicenseHelper=null;
  super.tearDown();
}",0.9224806201550388
110227,"@Override protected void setUp() throws Exception {
  MockitoUtil.setUpMockito(this);
  when(mediaDrm.openSession()).thenReturn(new byte[]{1,2,3});
  offlineLicenseHelper=new OfflineLicenseHelper<>(C.WIDEVINE_UUID,mediaDrm,mediaDrmCallback,null);
}","@Override protected void setUp() throws Exception {
  super.setUp();
  MockitoUtil.setUpMockito(this);
  when(mediaDrm.openSession()).thenReturn(new byte[]{1,2,3});
  offlineLicenseHelper=new OfflineLicenseHelper<>(C.WIDEVINE_UUID,mediaDrm,mediaDrmCallback,null);
}",0.9668615984405458
110228,"@Override protected void setUp() throws Exception {
  FakeExtractorOutput fakeExtractorOutput=new FakeExtractorOutput();
  adtsOutput=fakeExtractorOutput.track(0,C.TRACK_TYPE_AUDIO);
  id3Output=fakeExtractorOutput.track(1,C.TRACK_TYPE_METADATA);
  adtsReader=new AdtsReader(true);
  TrackIdGenerator idGenerator=new TrackIdGenerator(0,1);
  adtsReader.createTracks(fakeExtractorOutput,idGenerator);
  data=new ParsableByteArray(TEST_DATA);
  firstFeed=true;
}","@Override protected void setUp() throws Exception {
  super.setUp();
  FakeExtractorOutput fakeExtractorOutput=new FakeExtractorOutput();
  adtsOutput=fakeExtractorOutput.track(0,C.TRACK_TYPE_AUDIO);
  id3Output=fakeExtractorOutput.track(1,C.TRACK_TYPE_METADATA);
  adtsReader=new AdtsReader(true);
  TrackIdGenerator idGenerator=new TrackIdGenerator(0,1);
  adtsReader.createTracks(fakeExtractorOutput,idGenerator);
  data=new ParsableByteArray(TEST_DATA);
  firstFeed=true;
}",0.9818569903948772
110229,"@Override public void setUp() throws Exception {
  cacheDir=Util.createTempDirectory(getInstrumentation().getContext(),""String_Node_Str"");
  index=new CachedContentIndex(cacheDir);
}","@Override public void setUp() throws Exception {
  super.setUp();
  cacheDir=Util.createTempDirectory(getInstrumentation().getContext(),""String_Node_Str"");
  index=new CachedContentIndex(cacheDir);
}",0.9553805774278216
110230,"@Override protected void tearDown() throws Exception {
  Util.recursiveDelete(cacheDir);
}","@Override protected void tearDown() throws Exception {
  Util.recursiveDelete(cacheDir);
  super.tearDown();
}",0.9
110231,"@Override protected void setUp() throws Exception {
  MockitoUtil.setUpMockito(this);
  tracker=new CachedRegionTracker(cache,CACHE_KEY,CHUNK_INDEX);
  cacheDir=Util.createTempDirectory(getInstrumentation().getContext(),""String_Node_Str"");
  index=new CachedContentIndex(cacheDir);
}","@Override protected void setUp() throws Exception {
  super.setUp();
  MockitoUtil.setUpMockito(this);
  tracker=new CachedRegionTracker(cache,CACHE_KEY,CHUNK_INDEX);
  cacheDir=Util.createTempDirectory(getInstrumentation().getContext(),""String_Node_Str"");
  index=new CachedContentIndex(cacheDir);
}",0.9708404802744426
110232,"@Override protected void tearDown() throws Exception {
  Util.recursiveDelete(cacheDir);
}","@Override protected void tearDown() throws Exception {
  Util.recursiveDelete(cacheDir);
  super.tearDown();
}",0.9
110233,"@Override protected void setUp() throws Exception {
  cacheDir=Util.createTempDirectory(getInstrumentation().getContext(),""String_Node_Str"");
  index=new CachedContentIndex(cacheDir);
}","@Override protected void setUp() throws Exception {
  super.setUp();
  cacheDir=Util.createTempDirectory(getInstrumentation().getContext(),""String_Node_Str"");
  index=new CachedContentIndex(cacheDir);
}",0.9560723514211886
110234,"@Override protected void tearDown() throws Exception {
  Util.recursiveDelete(cacheDir);
}","@Override protected void tearDown() throws Exception {
  Util.recursiveDelete(cacheDir);
  super.tearDown();
}",0.9
110235,"/** 
 * Resets the channel mapping. After calling this method, call   {@link #configure(int,int,int)}to start using the new channel map.
 */
public void setChannelMap(int[] outputChannels){
  pendingOutputChannels=outputChannels;
}","/** 
 * Resets the channel mapping. After calling this method, call   {@link #configure(int,int,int)}to start using the new channel map.
 * @see AudioSink#configure(int,int,int,int,int[],int,int)
 */
public void setChannelMap(int[] outputChannels){
  pendingOutputChannels=outputChannels;
}",0.783109404990403
110236,"@Override public void queueInput(ByteBuffer inputBuffer){
  int position=inputBuffer.position();
  int limit=inputBuffer.limit();
  int size=limit - position;
  int resampledSize;
switch (encoding) {
case C.ENCODING_PCM_8BIT:
    resampledSize=size * 2;
  break;
case C.ENCODING_PCM_24BIT:
resampledSize=(size / 3) * 2;
break;
case C.ENCODING_PCM_32BIT:
resampledSize=size / 2;
break;
case C.ENCODING_PCM_16BIT:
case C.ENCODING_INVALID:
case Format.NO_VALUE:
default :
throw new IllegalStateException();
}
if (buffer.capacity() < resampledSize) {
buffer=ByteBuffer.allocateDirect(resampledSize).order(ByteOrder.nativeOrder());
}
 else {
buffer.clear();
}
switch (encoding) {
case C.ENCODING_PCM_8BIT:
for (int i=position; i < limit; i++) {
buffer.put((byte)0);
buffer.put((byte)((inputBuffer.get(i) & 0xFF) - 128));
}
break;
case C.ENCODING_PCM_24BIT:
for (int i=position; i < limit; i+=3) {
buffer.put(inputBuffer.get(i + 1));
buffer.put(inputBuffer.get(i + 2));
}
break;
case C.ENCODING_PCM_32BIT:
for (int i=position; i < limit; i+=4) {
buffer.put(inputBuffer.get(i + 2));
buffer.put(inputBuffer.get(i + 3));
}
break;
case C.ENCODING_PCM_16BIT:
case C.ENCODING_INVALID:
case Format.NO_VALUE:
default :
throw new IllegalStateException();
}
inputBuffer.position(inputBuffer.limit());
buffer.flip();
outputBuffer=buffer;
}","@Override public void queueInput(ByteBuffer inputBuffer){
  int position=inputBuffer.position();
  int limit=inputBuffer.limit();
  int size=limit - position;
  int resampledSize;
switch (encoding) {
case C.ENCODING_PCM_8BIT:
    resampledSize=size * 2;
  break;
case C.ENCODING_PCM_24BIT:
resampledSize=(size / 3) * 2;
break;
case C.ENCODING_PCM_32BIT:
resampledSize=size / 2;
break;
case C.ENCODING_PCM_16BIT:
case C.ENCODING_PCM_FLOAT:
case C.ENCODING_INVALID:
case Format.NO_VALUE:
default :
throw new IllegalStateException();
}
if (buffer.capacity() < resampledSize) {
buffer=ByteBuffer.allocateDirect(resampledSize).order(ByteOrder.nativeOrder());
}
 else {
buffer.clear();
}
switch (encoding) {
case C.ENCODING_PCM_8BIT:
for (int i=position; i < limit; i++) {
buffer.put((byte)0);
buffer.put((byte)((inputBuffer.get(i) & 0xFF) - 128));
}
break;
case C.ENCODING_PCM_24BIT:
for (int i=position; i < limit; i+=3) {
buffer.put(inputBuffer.get(i + 1));
buffer.put(inputBuffer.get(i + 2));
}
break;
case C.ENCODING_PCM_32BIT:
for (int i=position; i < limit; i+=4) {
buffer.put(inputBuffer.get(i + 2));
buffer.put(inputBuffer.get(i + 3));
}
break;
case C.ENCODING_PCM_16BIT:
case C.ENCODING_INVALID:
case Format.NO_VALUE:
default :
throw new IllegalStateException();
}
inputBuffer.position(inputBuffer.limit());
buffer.flip();
outputBuffer=buffer;
}",0.989891426432048
110237,"/** 
 * Parses a StreamMuxConfig as defined in ISO/IEC 14496-3:2009 Section 1.7.3.1, Table 1.42.
 */
private void parseStreamMuxConfig(ParsableBitArray data) throws ParserException {
  audioMuxVersion=data.readBits(1);
  audioMuxVersionA=audioMuxVersion == 1 ? data.readBits(1) : 0;
  if (audioMuxVersionA == 0) {
    if (audioMuxVersion == 1) {
      latmGetValue(data);
    }
    if (!data.readBit()) {
      throw new ParserException();
    }
    numSubframes=data.readBits(6);
    int numProgram=data.readBits(4);
    int numLayer=data.readBits(3);
    if (numProgram != 0 || numLayer != 0) {
      throw new ParserException();
    }
    if (audioMuxVersion == 0) {
      int startPosition=data.getPosition();
      int readBits=parseAudioSpecificConfig(data);
      data.setPosition(startPosition);
      byte[] initData=new byte[(readBits + 7) / 8];
      data.readBits(initData,0,readBits);
      Format format=Format.createAudioSampleFormat(formatId,MimeTypes.AUDIO_AAC,null,Format.NO_VALUE,Format.NO_VALUE,channelCount,sampleRateHz,Collections.singletonList(initData),null,0,language);
      if (!format.equals(this.format)) {
        this.format=format;
        sampleDurationUs=(C.MICROS_PER_SECOND * 1024) / format.sampleRate;
        output.format(format);
      }
    }
 else {
      int ascLen=(int)latmGetValue(data);
      int bitsRead=parseAudioSpecificConfig(data);
      data.skipBits(ascLen - bitsRead);
    }
    parseFrameLength(data);
    otherDataPresent=data.readBit();
    otherDataLenBits=0;
    if (otherDataPresent) {
      if (audioMuxVersion == 1) {
        otherDataLenBits=latmGetValue(data);
      }
 else {
        boolean otherDataLenEsc;
        do {
          otherDataLenEsc=data.readBit();
          otherDataLenBits=(otherDataLenBits << 8) + data.readBits(8);
        }
 while (otherDataLenEsc);
      }
    }
    boolean crcCheckPresent=data.readBit();
    if (crcCheckPresent) {
      data.skipBits(8);
    }
  }
 else {
    throw new ParserException();
  }
}","/** 
 * Parses a StreamMuxConfig as defined in ISO/IEC 14496-3:2009 Section 1.7.3.1, Table 1.42.
 */
private void parseStreamMuxConfig(ParsableBitArray data) throws ParserException {
  int audioMuxVersion=data.readBits(1);
  audioMuxVersionA=audioMuxVersion == 1 ? data.readBits(1) : 0;
  if (audioMuxVersionA == 0) {
    if (audioMuxVersion == 1) {
      latmGetValue(data);
    }
    if (!data.readBit()) {
      throw new ParserException();
    }
    numSubframes=data.readBits(6);
    int numProgram=data.readBits(4);
    int numLayer=data.readBits(3);
    if (numProgram != 0 || numLayer != 0) {
      throw new ParserException();
    }
    if (audioMuxVersion == 0) {
      int startPosition=data.getPosition();
      int readBits=parseAudioSpecificConfig(data);
      data.setPosition(startPosition);
      byte[] initData=new byte[(readBits + 7) / 8];
      data.readBits(initData,0,readBits);
      Format format=Format.createAudioSampleFormat(formatId,MimeTypes.AUDIO_AAC,null,Format.NO_VALUE,Format.NO_VALUE,channelCount,sampleRateHz,Collections.singletonList(initData),null,0,language);
      if (!format.equals(this.format)) {
        this.format=format;
        sampleDurationUs=(C.MICROS_PER_SECOND * 1024) / format.sampleRate;
        output.format(format);
      }
    }
 else {
      int ascLen=(int)latmGetValue(data);
      int bitsRead=parseAudioSpecificConfig(data);
      data.skipBits(ascLen - bitsRead);
    }
    parseFrameLength(data);
    otherDataPresent=data.readBit();
    otherDataLenBits=0;
    if (otherDataPresent) {
      if (audioMuxVersion == 1) {
        otherDataLenBits=latmGetValue(data);
      }
 else {
        boolean otherDataLenEsc;
        do {
          otherDataLenEsc=data.readBit();
          otherDataLenBits=(otherDataLenBits << 8) + data.readBits(8);
        }
 while (otherDataLenEsc);
      }
    }
    boolean crcCheckPresent=data.readBit();
    if (crcCheckPresent) {
      data.skipBits(8);
    }
  }
 else {
    throw new ParserException();
  }
}",0.999002493765586
110238,"/** 
 * Compares the score of the current track format with another   {@link AudioTrackScore}.
 * @param other The other score to compare to.
 * @return A positive integer if this score is better than the other. Zero if they areequal. A negative integer if this score is worse than the other.
 */
@Override public int compareTo(AudioTrackScore other){
  if (this.withinRendererCapabilitiesScore != other.withinRendererCapabilitiesScore) {
    return compareInts(this.withinRendererCapabilitiesScore,other.withinRendererCapabilitiesScore);
  }
 else   if (this.matchLanguageScore != other.matchLanguageScore) {
    return compareInts(this.matchLanguageScore,other.matchLanguageScore);
  }
 else   if (this.defaultSelectionFlagScore != other.defaultSelectionFlagScore) {
    return compareInts(this.defaultSelectionFlagScore,other.defaultSelectionFlagScore);
  }
 else   if (parameters.forceLowestBitrate) {
    return compareInts(other.bitrate,this.bitrate);
  }
 else {
    int resultSign=withinRendererCapabilitiesScore == 1 ? 1 : -1;
    if (this.channelCount != other.channelCount) {
      return resultSign * compareInts(this.channelCount,other.channelCount);
    }
 else     if (this.sampleRate != other.sampleRate) {
      return resultSign * compareInts(this.sampleRate,other.sampleRate);
    }
    return resultSign * compareInts(this.bitrate,other.bitrate);
  }
}","/** 
 * Compares the score of the current track format with another   {@link AudioTrackScore}.
 * @param other The other score to compare to.
 * @return A positive integer if this score is better than the other. Zero if they are equal. Anegative integer if this score is worse than the other.
 */
@Override public int compareTo(@NonNull AudioTrackScore other){
  if (this.withinRendererCapabilitiesScore != other.withinRendererCapabilitiesScore) {
    return compareInts(this.withinRendererCapabilitiesScore,other.withinRendererCapabilitiesScore);
  }
 else   if (this.matchLanguageScore != other.matchLanguageScore) {
    return compareInts(this.matchLanguageScore,other.matchLanguageScore);
  }
 else   if (this.defaultSelectionFlagScore != other.defaultSelectionFlagScore) {
    return compareInts(this.defaultSelectionFlagScore,other.defaultSelectionFlagScore);
  }
 else   if (parameters.forceLowestBitrate) {
    return compareInts(other.bitrate,this.bitrate);
  }
 else {
    int resultSign=withinRendererCapabilitiesScore == 1 ? 1 : -1;
    if (this.channelCount != other.channelCount) {
      return resultSign * compareInts(this.channelCount,other.channelCount);
    }
 else     if (this.sampleRate != other.sampleRate) {
      return resultSign * compareInts(this.sampleRate,other.sampleRate);
    }
    return resultSign * compareInts(this.bitrate,other.bitrate);
  }
}",0.9960043588812204
110239,"@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null || getClass() != obj.getClass()) {
    return false;
  }
  ColorInfo other=(ColorInfo)obj;
  if (colorSpace != other.colorSpace || colorRange != other.colorRange || colorTransfer != other.colorTransfer || !Arrays.equals(hdrStaticInfo,other.hdrStaticInfo)) {
    return false;
  }
  return true;
}","@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null || getClass() != obj.getClass()) {
    return false;
  }
  ColorInfo other=(ColorInfo)obj;
  return colorSpace == other.colorSpace && colorRange == other.colorRange && colorTransfer == other.colorTransfer && Arrays.equals(hdrStaticInfo,other.hdrStaticInfo);
}",0.90718954248366
110240,"private boolean haveSufficientBuffer(boolean rebuffering,long rendererPositionUs,long bufferedPositionUs){
  if (bufferedPositionUs == C.TIME_END_OF_SOURCE) {
    return true;
  }
  return loadControl.shouldStartPlayback(bufferedPositionUs - rendererPositionUs,1f,rebuffering);
}","private boolean haveSufficientBuffer(boolean rebuffering,long rendererPositionUs,long bufferedPositionUs){
  return bufferedPositionUs == C.TIME_END_OF_SOURCE || loadControl.shouldStartPlayback(bufferedPositionUs - rendererPositionUs,1f,rebuffering);
}",0.911487758945386
110241,"@Override public int readData(FormatHolder formatHolder,DecoderInputBuffer buffer,boolean requireFormat){
  if (isPendingInitialDiscontinuity()) {
    return C.RESULT_NOTHING_READ;
  }
  if (sentEos) {
    buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
    return C.RESULT_BUFFER_READ;
  }
  int result=childStream.readData(formatHolder,buffer,requireFormat);
  if (result == C.RESULT_FORMAT_READ) {
    Format format=formatHolder.format;
    int encoderDelay=startUs != 0 ? 0 : format.encoderDelay;
    int encoderPadding=endUs != C.TIME_END_OF_SOURCE ? 0 : format.encoderPadding;
    formatHolder.format=format.copyWithGaplessInfo(encoderDelay,encoderPadding);
    return C.RESULT_FORMAT_READ;
  }
  if (endUs != C.TIME_END_OF_SOURCE && ((result == C.RESULT_BUFFER_READ && buffer.timeUs >= endUs) || (result == C.RESULT_NOTHING_READ && mediaPeriod.getBufferedPositionUs() == C.TIME_END_OF_SOURCE))) {
    buffer.clear();
    buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
    sentEos=true;
    return C.RESULT_BUFFER_READ;
  }
  if (result == C.RESULT_BUFFER_READ && !buffer.isEndOfStream()) {
    buffer.timeUs-=startUs;
  }
  return result;
}","@Override public int readData(FormatHolder formatHolder,DecoderInputBuffer buffer,boolean requireFormat){
  if (isPendingInitialDiscontinuity()) {
    return C.RESULT_NOTHING_READ;
  }
  if (sentEos) {
    buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
    return C.RESULT_BUFFER_READ;
  }
  int result=childStream.readData(formatHolder,buffer,requireFormat);
  if (result == C.RESULT_FORMAT_READ) {
    Format format=formatHolder.format;
    int encoderDelay=startUs != 0 ? 0 : format.encoderDelay;
    int encoderPadding=endUs != C.TIME_END_OF_SOURCE ? 0 : format.encoderPadding;
    formatHolder.format=format.copyWithGaplessInfo(encoderDelay,encoderPadding);
    return C.RESULT_FORMAT_READ;
  }
  if (endUs != C.TIME_END_OF_SOURCE && ((result == C.RESULT_BUFFER_READ && buffer.timeUs >= endUs) || (result == C.RESULT_NOTHING_READ && getBufferedPositionUs() == C.TIME_END_OF_SOURCE))) {
    buffer.clear();
    buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
    sentEos=true;
    return C.RESULT_BUFFER_READ;
  }
  if (result == C.RESULT_BUFFER_READ && !buffer.isEndOfStream()) {
    buffer.timeUs-=startUs;
  }
  return result;
}",0.9947275922671354
110242,"@Override public int readData(FormatHolder formatHolder,DecoderInputBuffer buffer,boolean requireFormat){
  if (pendingDiscontinuity) {
    return C.RESULT_NOTHING_READ;
  }
  if (sentEos) {
    buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
    return C.RESULT_BUFFER_READ;
  }
  int result=stream.readData(formatHolder,buffer,requireFormat);
  if (result == C.RESULT_FORMAT_READ) {
    Format format=formatHolder.format;
    int encoderDelay=startUs != 0 ? 0 : format.encoderDelay;
    int encoderPadding=endUs != C.TIME_END_OF_SOURCE ? 0 : format.encoderPadding;
    formatHolder.format=format.copyWithGaplessInfo(encoderDelay,encoderPadding);
    return C.RESULT_FORMAT_READ;
  }
  if (endUs != C.TIME_END_OF_SOURCE && ((result == C.RESULT_BUFFER_READ && buffer.timeUs >= endUs) || (result == C.RESULT_NOTHING_READ && mediaPeriod.getBufferedPositionUs() == C.TIME_END_OF_SOURCE))) {
    buffer.clear();
    buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
    sentEos=true;
    return C.RESULT_BUFFER_READ;
  }
  if (result == C.RESULT_BUFFER_READ && !buffer.isEndOfStream()) {
    buffer.timeUs-=startUs;
  }
  return result;
}","@Override public int readData(FormatHolder formatHolder,DecoderInputBuffer buffer,boolean requireFormat){
  if (pendingDiscontinuity) {
    return C.RESULT_NOTHING_READ;
  }
  if (sentEos) {
    buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
    return C.RESULT_BUFFER_READ;
  }
  int result=stream.readData(formatHolder,buffer,requireFormat);
  if (result == C.RESULT_FORMAT_READ) {
    Format format=formatHolder.format;
    int encoderDelay=startUs != 0 ? 0 : format.encoderDelay;
    int encoderPadding=endUs != C.TIME_END_OF_SOURCE ? 0 : format.encoderPadding;
    formatHolder.format=format.copyWithGaplessInfo(encoderDelay,encoderPadding);
    return C.RESULT_FORMAT_READ;
  }
  if (endUs != C.TIME_END_OF_SOURCE && ((result == C.RESULT_BUFFER_READ && buffer.timeUs >= endUs) || (result == C.RESULT_NOTHING_READ && getBufferedPositionUs() == C.TIME_END_OF_SOURCE))) {
    buffer.clear();
    buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
    sentEos=true;
    return C.RESULT_BUFFER_READ;
  }
  if (result == C.RESULT_BUFFER_READ && !buffer.isEndOfStream()) {
    buffer.timeUs-=startUs;
  }
  return result;
}",0.9946524064171124
110243,"/** 
 * Resets the channel mapping. After calling this method, call   {@link #configure(int,int,int)}to start using the new channel map.
 * @see AudioSink#configure(String,int,int,int,int,int[],int,int)
 */
public void setChannelMap(int[] outputChannels){
  pendingOutputChannels=outputChannels;
}","/** 
 * Resets the channel mapping. After calling this method, call   {@link #configure(int,int,int)}to start using the new channel map.
 */
public void setChannelMap(int[] outputChannels){
  pendingOutputChannels=outputChannels;
}",0.7765151515151515
110244,"private void initInternal(@SecureMode int secureMode){
  display=eglGetDisplay(EGL_DEFAULT_DISPLAY);
  Assertions.checkState(display != null,""String_Node_Str"");
  int[] version=new int[2];
  boolean eglInitialized=eglInitialize(display,version,0,version,1);
  Assertions.checkState(eglInitialized,""String_Node_Str"");
  int[] eglAttributes=new int[]{EGL_RENDERABLE_TYPE,EGL_OPENGL_ES2_BIT,EGL_RED_SIZE,8,EGL_GREEN_SIZE,8,EGL_BLUE_SIZE,8,EGL_ALPHA_SIZE,8,EGL_DEPTH_SIZE,0,EGL_CONFIG_CAVEAT,EGL_NONE,EGL_SURFACE_TYPE,EGL_WINDOW_BIT,EGL_NONE};
  EGLConfig[] configs=new EGLConfig[1];
  int[] numConfigs=new int[1];
  boolean eglChooseConfigSuccess=eglChooseConfig(display,eglAttributes,0,configs,0,1,numConfigs,0);
  Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,""String_Node_Str"");
  EGLConfig config=configs[0];
  int[] glAttributes;
  if (secureMode == SECURE_MODE_NONE) {
    glAttributes=new int[]{EGL_CONTEXT_CLIENT_VERSION,2,EGL_NONE};
  }
 else {
    glAttributes=new int[]{EGL_CONTEXT_CLIENT_VERSION,2,EGL_PROTECTED_CONTENT_EXT,EGL_TRUE,EGL_NONE};
  }
  context=eglCreateContext(display,config,android.opengl.EGL14.EGL_NO_CONTEXT,glAttributes,0);
  Assertions.checkState(context != null,""String_Node_Str"");
  EGLSurface surface;
  if (secureMode == SECURE_MODE_SURFACELESS_CONTEXT) {
    surface=EGL_NO_SURFACE;
  }
 else {
    int[] pbufferAttributes;
    if (secureMode == SECURE_MODE_PROTECTED_PBUFFER) {
      pbufferAttributes=new int[]{EGL_WIDTH,1,EGL_HEIGHT,1,EGL_PROTECTED_CONTENT_EXT,EGL_TRUE,EGL_NONE};
    }
 else {
      pbufferAttributes=new int[]{EGL_WIDTH,1,EGL_HEIGHT,1,EGL_NONE};
    }
    pbuffer=eglCreatePbufferSurface(display,config,pbufferAttributes,0);
    Assertions.checkState(pbuffer != null,""String_Node_Str"");
    surface=pbuffer;
  }
  boolean eglMadeCurrent=eglMakeCurrent(display,surface,surface,context);
  Assertions.checkState(eglMadeCurrent,""String_Node_Str"");
  glGenTextures(1,textureIdHolder,0);
  surfaceTexture=new SurfaceTexture(textureIdHolder[0]);
  surfaceTexture.setOnFrameAvailableListener(this);
  this.surface=new DummySurface(this,surfaceTexture,secureMode != SECURE_MODE_NONE);
}","private void initInternal(@SecureMode int secureMode){
  display=eglGetDisplay(EGL_DEFAULT_DISPLAY);
  Assertions.checkState(display != null,""String_Node_Str"");
  int[] version=new int[2];
  boolean eglInitialized=eglInitialize(display,version,0,version,1);
  Assertions.checkState(eglInitialized,""String_Node_Str"");
  int[] eglAttributes=new int[]{EGL_RENDERABLE_TYPE,EGL_OPENGL_ES2_BIT,EGL_RED_SIZE,8,EGL_GREEN_SIZE,8,EGL_BLUE_SIZE,8,EGL_ALPHA_SIZE,8,EGL_DEPTH_SIZE,0,EGL_CONFIG_CAVEAT,EGL_NONE,EGL_SURFACE_TYPE,EGL_WINDOW_BIT,EGL_NONE};
  EGLConfig[] configs=new EGLConfig[1];
  int[] numConfigs=new int[1];
  boolean eglChooseConfigSuccess=eglChooseConfig(display,eglAttributes,0,configs,0,1,numConfigs,0);
  Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,""String_Node_Str"");
  EGLConfig config=configs[0];
  int[] glAttributes;
  if (secureMode == SECURE_MODE_NONE) {
    glAttributes=new int[]{EGL_CONTEXT_CLIENT_VERSION,2,EGL_NONE};
  }
 else {
    glAttributes=new int[]{EGL_CONTEXT_CLIENT_VERSION,2,EGL_PROTECTED_CONTENT_EXT,EGL_TRUE,EGL_NONE};
  }
  context=eglCreateContext(display,config,android.opengl.EGL14.EGL_NO_CONTEXT,glAttributes,0);
  Assertions.checkState(context != null,""String_Node_Str"");
  EGLSurface surface;
  if (secureMode == SECURE_MODE_SURFACELESS_CONTEXT) {
    surface=EGL14.EGL_NO_SURFACE;
  }
 else {
    int[] pbufferAttributes;
    if (secureMode == SECURE_MODE_PROTECTED_PBUFFER) {
      pbufferAttributes=new int[]{EGL_WIDTH,1,EGL_HEIGHT,1,EGL_PROTECTED_CONTENT_EXT,EGL_TRUE,EGL_NONE};
    }
 else {
      pbufferAttributes=new int[]{EGL_WIDTH,1,EGL_HEIGHT,1,EGL_NONE};
    }
    pbuffer=eglCreatePbufferSurface(display,config,pbufferAttributes,0);
    Assertions.checkState(pbuffer != null,""String_Node_Str"");
    surface=pbuffer;
  }
  boolean eglMadeCurrent=eglMakeCurrent(display,surface,surface,context);
  Assertions.checkState(eglMadeCurrent,""String_Node_Str"");
  glGenTextures(1,textureIdHolder,0);
  surfaceTexture=new SurfaceTexture(textureIdHolder[0]);
  surfaceTexture.setOnFrameAvailableListener(this);
  this.surface=new DummySurface(this,surfaceTexture,secureMode != SECURE_MODE_NONE);
}",0.9986232216613126
110245,"/** 
 * Resets the channel mapping. After calling this method, call   {@link #configure(int,int,int)}to start using the new channel map.
 * @see AudioSink#configure(String,int,int,int,int,int[],int,int)
 */
public void setChannelMap(int[] outputChannels){
  pendingOutputChannels=outputChannels;
}","/** 
 * Resets the channel mapping. After calling this method, call   {@link #configure(int,int,int)}to start using the new channel map.
 */
public void setChannelMap(int[] outputChannels){
  pendingOutputChannels=outputChannels;
}",0.7765151515151515
110246,"private void initInternal(@SecureMode int secureMode){
  display=eglGetDisplay(EGL_DEFAULT_DISPLAY);
  Assertions.checkState(display != null,""String_Node_Str"");
  int[] version=new int[2];
  boolean eglInitialized=eglInitialize(display,version,0,version,1);
  Assertions.checkState(eglInitialized,""String_Node_Str"");
  int[] eglAttributes=new int[]{EGL_RENDERABLE_TYPE,EGL_OPENGL_ES2_BIT,EGL_RED_SIZE,8,EGL_GREEN_SIZE,8,EGL_BLUE_SIZE,8,EGL_ALPHA_SIZE,8,EGL_DEPTH_SIZE,0,EGL_CONFIG_CAVEAT,EGL_NONE,EGL_SURFACE_TYPE,EGL_WINDOW_BIT,EGL_NONE};
  EGLConfig[] configs=new EGLConfig[1];
  int[] numConfigs=new int[1];
  boolean eglChooseConfigSuccess=eglChooseConfig(display,eglAttributes,0,configs,0,1,numConfigs,0);
  Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,""String_Node_Str"");
  EGLConfig config=configs[0];
  int[] glAttributes;
  if (secureMode == SECURE_MODE_NONE) {
    glAttributes=new int[]{EGL_CONTEXT_CLIENT_VERSION,2,EGL_NONE};
  }
 else {
    glAttributes=new int[]{EGL_CONTEXT_CLIENT_VERSION,2,EGL_PROTECTED_CONTENT_EXT,EGL_TRUE,EGL_NONE};
  }
  context=eglCreateContext(display,config,android.opengl.EGL14.EGL_NO_CONTEXT,glAttributes,0);
  Assertions.checkState(context != null,""String_Node_Str"");
  EGLSurface surface;
  if (secureMode == SECURE_MODE_SURFACELESS_CONTEXT) {
    surface=EGL_NO_SURFACE;
  }
 else {
    int[] pbufferAttributes;
    if (secureMode == SECURE_MODE_PROTECTED_PBUFFER) {
      pbufferAttributes=new int[]{EGL_WIDTH,1,EGL_HEIGHT,1,EGL_PROTECTED_CONTENT_EXT,EGL_TRUE,EGL_NONE};
    }
 else {
      pbufferAttributes=new int[]{EGL_WIDTH,1,EGL_HEIGHT,1,EGL_NONE};
    }
    pbuffer=eglCreatePbufferSurface(display,config,pbufferAttributes,0);
    Assertions.checkState(pbuffer != null,""String_Node_Str"");
    surface=pbuffer;
  }
  boolean eglMadeCurrent=eglMakeCurrent(display,surface,surface,context);
  Assertions.checkState(eglMadeCurrent,""String_Node_Str"");
  glGenTextures(1,textureIdHolder,0);
  surfaceTexture=new SurfaceTexture(textureIdHolder[0]);
  surfaceTexture.setOnFrameAvailableListener(this);
  this.surface=new DummySurface(this,surfaceTexture,secureMode != SECURE_MODE_NONE);
}","private void initInternal(@SecureMode int secureMode){
  display=eglGetDisplay(EGL_DEFAULT_DISPLAY);
  Assertions.checkState(display != null,""String_Node_Str"");
  int[] version=new int[2];
  boolean eglInitialized=eglInitialize(display,version,0,version,1);
  Assertions.checkState(eglInitialized,""String_Node_Str"");
  int[] eglAttributes=new int[]{EGL_RENDERABLE_TYPE,EGL_OPENGL_ES2_BIT,EGL_RED_SIZE,8,EGL_GREEN_SIZE,8,EGL_BLUE_SIZE,8,EGL_ALPHA_SIZE,8,EGL_DEPTH_SIZE,0,EGL_CONFIG_CAVEAT,EGL_NONE,EGL_SURFACE_TYPE,EGL_WINDOW_BIT,EGL_NONE};
  EGLConfig[] configs=new EGLConfig[1];
  int[] numConfigs=new int[1];
  boolean eglChooseConfigSuccess=eglChooseConfig(display,eglAttributes,0,configs,0,1,numConfigs,0);
  Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,""String_Node_Str"");
  EGLConfig config=configs[0];
  int[] glAttributes;
  if (secureMode == SECURE_MODE_NONE) {
    glAttributes=new int[]{EGL_CONTEXT_CLIENT_VERSION,2,EGL_NONE};
  }
 else {
    glAttributes=new int[]{EGL_CONTEXT_CLIENT_VERSION,2,EGL_PROTECTED_CONTENT_EXT,EGL_TRUE,EGL_NONE};
  }
  context=eglCreateContext(display,config,android.opengl.EGL14.EGL_NO_CONTEXT,glAttributes,0);
  Assertions.checkState(context != null,""String_Node_Str"");
  EGLSurface surface;
  if (secureMode == SECURE_MODE_SURFACELESS_CONTEXT) {
    surface=EGL14.EGL_NO_SURFACE;
  }
 else {
    int[] pbufferAttributes;
    if (secureMode == SECURE_MODE_PROTECTED_PBUFFER) {
      pbufferAttributes=new int[]{EGL_WIDTH,1,EGL_HEIGHT,1,EGL_PROTECTED_CONTENT_EXT,EGL_TRUE,EGL_NONE};
    }
 else {
      pbufferAttributes=new int[]{EGL_WIDTH,1,EGL_HEIGHT,1,EGL_NONE};
    }
    pbuffer=eglCreatePbufferSurface(display,config,pbufferAttributes,0);
    Assertions.checkState(pbuffer != null,""String_Node_Str"");
    surface=pbuffer;
  }
  boolean eglMadeCurrent=eglMakeCurrent(display,surface,surface,context);
  Assertions.checkState(eglMadeCurrent,""String_Node_Str"");
  glGenTextures(1,textureIdHolder,0);
  surfaceTexture=new SurfaceTexture(textureIdHolder[0]);
  surfaceTexture.setOnFrameAvailableListener(this);
  this.surface=new DummySurface(this,surfaceTexture,secureMode != SECURE_MODE_NONE);
}",0.9986232216613126
110247,"@Override public final boolean continueLoading(long positionUs){
  boolean madeProgress=false;
  boolean madeProgressThisIteration;
  do {
    madeProgressThisIteration=false;
    long nextLoadPositionUs=getNextLoadPositionUs();
    if (nextLoadPositionUs == C.TIME_END_OF_SOURCE) {
      break;
    }
    for (    SequenceableLoader loader : loaders) {
      if (loader.getNextLoadPositionUs() == nextLoadPositionUs) {
        madeProgressThisIteration|=loader.continueLoading(positionUs);
      }
    }
    madeProgress|=madeProgressThisIteration;
  }
 while (madeProgressThisIteration);
  return madeProgress;
}","@Override public final boolean continueLoading(long positionUs){
  boolean madeProgress=false;
  boolean madeProgressThisIteration;
  do {
    madeProgressThisIteration=false;
    long nextLoadPositionUs=getNextLoadPositionUs();
    if (nextLoadPositionUs == C.TIME_END_OF_SOURCE) {
      break;
    }
    for (    SequenceableLoader loader : loaders) {
      long loaderNextLoadPositionUs=loader.getNextLoadPositionUs();
      boolean isLoaderBehind=loaderNextLoadPositionUs != C.TIME_END_OF_SOURCE && loaderNextLoadPositionUs <= positionUs;
      if (loaderNextLoadPositionUs == nextLoadPositionUs || isLoaderBehind) {
        madeProgressThisIteration|=loader.continueLoading(positionUs);
      }
    }
    madeProgress|=madeProgressThisIteration;
  }
 while (madeProgressThisIteration);
  return madeProgress;
}",0.8467459762071379
110248,"@Override public final boolean continueLoading(long positionUs){
  boolean madeProgress=false;
  boolean madeProgressThisIteration;
  do {
    madeProgressThisIteration=false;
    long nextLoadPositionUs=getNextLoadPositionUs();
    if (nextLoadPositionUs == C.TIME_END_OF_SOURCE) {
      break;
    }
    for (    SequenceableLoader loader : loaders) {
      if (loader.getNextLoadPositionUs() == nextLoadPositionUs) {
        madeProgressThisIteration|=loader.continueLoading(positionUs);
      }
    }
    madeProgress|=madeProgressThisIteration;
  }
 while (madeProgressThisIteration);
  return madeProgress;
}","@Override public final boolean continueLoading(long positionUs){
  boolean madeProgress=false;
  boolean madeProgressThisIteration;
  do {
    madeProgressThisIteration=false;
    long nextLoadPositionUs=getNextLoadPositionUs();
    if (nextLoadPositionUs == C.TIME_END_OF_SOURCE) {
      break;
    }
    for (    SequenceableLoader loader : loaders) {
      long loaderNextLoadPositionUs=loader.getNextLoadPositionUs();
      boolean isLoaderBehind=loaderNextLoadPositionUs != C.TIME_END_OF_SOURCE && loaderNextLoadPositionUs <= positionUs;
      if (loaderNextLoadPositionUs == nextLoadPositionUs || isLoaderBehind) {
        madeProgressThisIteration|=loader.continueLoading(positionUs);
      }
    }
    madeProgress|=madeProgressThisIteration;
  }
 while (madeProgressThisIteration);
  return madeProgress;
}",0.8467459762071379
110249,"private void setSync(double defaultDisplayRefreshRate){
  if (useDefaultDisplayVsync) {
    vsyncSampler=VSyncSampler.getInstance();
    vsyncDurationNs=(long)(C.NANOS_PER_SECOND / defaultDisplayRefreshRate);
    vsyncOffsetNs=(vsyncDurationNs * VSYNC_OFFSET_PERCENTAGE) / 100;
  }
}","private void setSync(double defaultDisplayRefreshRate){
  if (useDefaultDisplayVsync) {
    vsyncDurationNs=(long)(C.NANOS_PER_SECOND / defaultDisplayRefreshRate);
    vsyncOffsetNs=(vsyncDurationNs * VSYNC_OFFSET_PERCENTAGE) / 100;
  }
}",0.9136276391554704
110250,"private VideoFrameReleaseTimeHelper(double defaultDisplayRefreshRate){
  useDefaultDisplayVsync=defaultDisplayRefreshRate != DISPLAY_REFRESH_RATE_UNKNOWN;
}","private VideoFrameReleaseTimeHelper(double defaultDisplayRefreshRate){
  useDefaultDisplayVsync=defaultDisplayRefreshRate != DISPLAY_REFRESH_RATE_UNKNOWN;
  if (useDefaultDisplayVsync) {
    vsyncSampler=VSyncSampler.getInstance();
  }
}",0.7938931297709924
110251,"@Override protected void parsePayload(ParsableByteArray data,long timeUs) throws ParserException {
  int packetType=data.readUnsignedByte();
  int compositionTimeMs=data.readUnsignedInt24();
  compositionTimeMs=(compositionTimeMs & 0x800000) >> 23 == 1 ? (compositionTimeMs & 0xff000000) : compositionTimeMs;
  timeUs+=compositionTimeMs * 1000L;
  if (packetType == AVC_PACKET_TYPE_SEQUENCE_HEADER && !hasOutputFormat) {
    ParsableByteArray videoSequence=new ParsableByteArray(new byte[data.bytesLeft()]);
    data.readBytes(videoSequence.data,0,data.bytesLeft());
    AvcConfig avcConfig=AvcConfig.parse(videoSequence);
    nalUnitLengthFieldLength=avcConfig.nalUnitLengthFieldLength;
    Format format=Format.createVideoSampleFormat(null,MimeTypes.VIDEO_H264,null,Format.NO_VALUE,Format.NO_VALUE,avcConfig.width,avcConfig.height,Format.NO_VALUE,avcConfig.initializationData,Format.NO_VALUE,avcConfig.pixelWidthAspectRatio,null);
    output.format(format);
    hasOutputFormat=true;
  }
 else   if (packetType == AVC_PACKET_TYPE_AVC_NALU && hasOutputFormat) {
    byte[] nalLengthData=nalLength.data;
    nalLengthData[0]=0;
    nalLengthData[1]=0;
    nalLengthData[2]=0;
    int nalUnitLengthFieldLengthDiff=4 - nalUnitLengthFieldLength;
    int bytesWritten=0;
    int bytesToWrite;
    while (data.bytesLeft() > 0) {
      data.readBytes(nalLength.data,nalUnitLengthFieldLengthDiff,nalUnitLengthFieldLength);
      nalLength.setPosition(0);
      bytesToWrite=nalLength.readUnsignedIntToInt();
      nalStartCode.setPosition(0);
      output.sampleData(nalStartCode,4);
      bytesWritten+=4;
      output.sampleData(data,bytesToWrite);
      bytesWritten+=bytesToWrite;
    }
    output.sampleMetadata(timeUs,frameType == VIDEO_FRAME_KEYFRAME ? C.BUFFER_FLAG_KEY_FRAME : 0,bytesWritten,0,null);
  }
}","@Override protected void parsePayload(ParsableByteArray data,long timeUs) throws ParserException {
  int packetType=data.readUnsignedByte();
  int compositionTimeMs=data.readUnsignedInt24();
  compositionTimeMs=(compositionTimeMs & 0x800000L) >>> 23 == 1 ? (compositionTimeMs | 0xff000000) : compositionTimeMs;
  timeUs+=compositionTimeMs * 1000L;
  if (packetType == AVC_PACKET_TYPE_SEQUENCE_HEADER && !hasOutputFormat) {
    ParsableByteArray videoSequence=new ParsableByteArray(new byte[data.bytesLeft()]);
    data.readBytes(videoSequence.data,0,data.bytesLeft());
    AvcConfig avcConfig=AvcConfig.parse(videoSequence);
    nalUnitLengthFieldLength=avcConfig.nalUnitLengthFieldLength;
    Format format=Format.createVideoSampleFormat(null,MimeTypes.VIDEO_H264,null,Format.NO_VALUE,Format.NO_VALUE,avcConfig.width,avcConfig.height,Format.NO_VALUE,avcConfig.initializationData,Format.NO_VALUE,avcConfig.pixelWidthAspectRatio,null);
    output.format(format);
    hasOutputFormat=true;
  }
 else   if (packetType == AVC_PACKET_TYPE_AVC_NALU && hasOutputFormat) {
    byte[] nalLengthData=nalLength.data;
    nalLengthData[0]=0;
    nalLengthData[1]=0;
    nalLengthData[2]=0;
    int nalUnitLengthFieldLengthDiff=4 - nalUnitLengthFieldLength;
    int bytesWritten=0;
    int bytesToWrite;
    while (data.bytesLeft() > 0) {
      data.readBytes(nalLength.data,nalUnitLengthFieldLengthDiff,nalUnitLengthFieldLength);
      nalLength.setPosition(0);
      bytesToWrite=nalLength.readUnsignedIntToInt();
      nalStartCode.setPosition(0);
      output.sampleData(nalStartCode,4);
      bytesWritten+=4;
      output.sampleData(data,bytesToWrite);
      bytesWritten+=bytesToWrite;
    }
    output.sampleMetadata(timeUs,frameType == VIDEO_FRAME_KEYFRAME ? C.BUFFER_FLAG_KEY_FRAME : 0,bytesWritten,0,null);
  }
}",0.9988944168048646
110252,"/** 
 * @param uuid The UUID of the drm scheme.
 * @param mediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
 * @param callback Performs key and provisioning requests.
 * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argumentto  {@link ExoMediaDrm#getKeyRequest(byte[],byte[],String,int,HashMap)}. May be null.
 * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be null if delivery of events is not required.
 * @param eventListener A listener of events. May be null if delivery of events is not required.
 * @param multiSession A boolean that specify whether multiple key session support is enabled.Default is false.
 */
public DefaultDrmSessionManager(UUID uuid,ExoMediaDrm<T> mediaDrm,MediaDrmCallback callback,HashMap<String,String> optionalKeyRequestParameters,Handler eventHandler,EventListener eventListener,boolean multiSession){
  Assertions.checkNotNull(uuid);
  Assertions.checkNotNull(mediaDrm);
  Assertions.checkArgument(!C.COMMON_PSSH_UUID.equals(uuid),""String_Node_Str"");
  this.uuid=uuid;
  this.mediaDrm=mediaDrm;
  this.callback=callback;
  this.optionalKeyRequestParameters=optionalKeyRequestParameters;
  this.eventHandler=eventHandler;
  this.eventListener=eventListener;
  this.multiSession=multiSession;
  mode=MODE_PLAYBACK;
  sessions=new ArrayList<>();
  provisioningInProgress=new AtomicBoolean(false);
  if (multiSession) {
    mediaDrm.setPropertyString(""String_Node_Str"",""String_Node_Str"");
  }
}","/** 
 * @param uuid The UUID of the drm scheme.
 * @param mediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
 * @param callback Performs key and provisioning requests.
 * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argumentto  {@link ExoMediaDrm#getKeyRequest(byte[],byte[],String,int,HashMap)}. May be null.
 * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be null if delivery of events is not required.
 * @param eventListener A listener of events. May be null if delivery of events is not required.
 * @param multiSession A boolean that specify whether multiple key session support is enabled.Default is false.
 */
public DefaultDrmSessionManager(UUID uuid,ExoMediaDrm<T> mediaDrm,MediaDrmCallback callback,HashMap<String,String> optionalKeyRequestParameters,Handler eventHandler,EventListener eventListener,boolean multiSession){
  Assertions.checkNotNull(uuid);
  Assertions.checkNotNull(mediaDrm);
  Assertions.checkArgument(!C.COMMON_PSSH_UUID.equals(uuid),""String_Node_Str"");
  this.uuid=uuid;
  this.mediaDrm=mediaDrm;
  this.callback=callback;
  this.optionalKeyRequestParameters=optionalKeyRequestParameters;
  this.eventHandler=eventHandler;
  this.eventListener=eventListener;
  this.multiSession=multiSession;
  mode=MODE_PLAYBACK;
  sessions=new ArrayList<>();
  provisioningInProgress=new AtomicBoolean(false);
  if (multiSession) {
    mediaDrm.setPropertyString(""String_Node_Str"",""String_Node_Str"");
  }
  mediaDrm.setOnEventListener(new MediaDrmEventListener());
}",0.9807073954983924
110253,"@Override public void releaseSession(DrmSession<T> session){
  DefaultDrmSession<T> drmSession=(DefaultDrmSession<T>)session;
  if (drmSession.release()) {
    sessions.remove(drmSession);
  }
  if (sessions.isEmpty()) {
    mediaDrm.setOnEventListener(null);
    mediaDrmHandler.removeCallbacksAndMessages(null);
    mediaDrmHandler=null;
    playbackLooper=null;
  }
}","@Override public void releaseSession(DrmSession<T> session){
  DefaultDrmSession<T> drmSession=(DefaultDrmSession<T>)session;
  if (drmSession.release()) {
    sessions.remove(drmSession);
  }
}",0.6879432624113475
110254,"@Override public DrmSession<T> acquireSession(Looper playbackLooper,DrmInitData drmInitData){
  Assertions.checkState(this.playbackLooper == null || this.playbackLooper == playbackLooper);
  if (sessions.isEmpty()) {
    this.playbackLooper=playbackLooper;
    mediaDrmHandler=new MediaDrmHandler(playbackLooper);
    mediaDrm.setOnEventListener(new MediaDrmEventListener());
  }
  DefaultDrmSession<T> session=null;
  byte[] initData=null;
  String mimeType=null;
  if (offlineLicenseKeySetId == null) {
    SchemeData data=getSchemeData(drmInitData,uuid);
    if (data == null) {
      if (eventHandler != null && eventListener != null) {
        eventHandler.post(new Runnable(){
          @Override public void run(){
            eventListener.onDrmSessionManagerError(new IllegalStateException(""String_Node_Str"" + uuid));
          }
        }
);
      }
    }
 else {
      initData=getSchemeInitData(data,uuid);
      mimeType=getSchemeMimeType(data,uuid);
    }
  }
  for (  DefaultDrmSession<T> s : sessions) {
    if (!multiSession || s.canReuse(initData)) {
      session=s;
      break;
    }
  }
  if (session == null) {
    session=new DefaultDrmSession<T>(uuid,mediaDrm,initData,mimeType,mode,offlineLicenseKeySetId,optionalKeyRequestParameters,callback,playbackLooper,eventHandler,eventListener,provisioningInProgress,this);
    sessions.add(session);
  }
  session.acquire();
  return session;
}","@Override public DrmSession<T> acquireSession(Looper playbackLooper,DrmInitData drmInitData){
  Assertions.checkState(this.playbackLooper == null || this.playbackLooper == playbackLooper);
  if (sessions.isEmpty()) {
    this.playbackLooper=playbackLooper;
    if (mediaDrmHandler == null) {
      mediaDrmHandler=new MediaDrmHandler(playbackLooper);
    }
  }
  DefaultDrmSession<T> session=null;
  byte[] initData=null;
  String mimeType=null;
  if (offlineLicenseKeySetId == null) {
    SchemeData data=getSchemeData(drmInitData,uuid);
    if (data == null) {
      if (eventHandler != null && eventListener != null) {
        eventHandler.post(new Runnable(){
          @Override public void run(){
            eventListener.onDrmSessionManagerError(new IllegalStateException(""String_Node_Str"" + uuid));
          }
        }
);
      }
    }
 else {
      initData=getSchemeInitData(data,uuid);
      mimeType=getSchemeMimeType(data,uuid);
    }
  }
  for (  DefaultDrmSession<T> s : sessions) {
    if (!multiSession || s.canReuse(initData)) {
      session=s;
      break;
    }
  }
  if (session == null) {
    session=new DefaultDrmSession<T>(uuid,mediaDrm,initData,mimeType,mode,offlineLicenseKeySetId,optionalKeyRequestParameters,callback,playbackLooper,eventHandler,eventListener,provisioningInProgress,this);
    sessions.add(session);
  }
  session.acquire();
  return session;
}",0.966131907308378
110255,"/** 
 * Instantiates a new DRM session.
 * @param uuid The UUID of the drm scheme.
 * @param mediaDrm The media DRM.
 * @param initData The DRM init data.
 * @param mode The DRM mode.
 * @param offlineLicenseKeySetId The offlineLicense KeySetId.
 * @param optionalKeyRequestParameters The optional key request parameters.
 * @param callback The media DRM callback.
 * @param playbackLooper The playback looper.
 * @param eventHandler The handler to post listener events.
 * @param eventListener The DRM session manager event listener.
 */
public DefaultDrmSession(UUID uuid,ExoMediaDrm<T> mediaDrm,byte[] initData,String mimeType,@DefaultDrmSessionManager.Mode int mode,byte[] offlineLicenseKeySetId,HashMap<String,String> optionalKeyRequestParameters,MediaDrmCallback callback,Looper playbackLooper,Handler eventHandler,DefaultDrmSessionManager.EventListener eventListener,AtomicBoolean provisioningInProgress,EventListener sessionEventListener){
  this.uuid=uuid;
  this.mediaDrm=mediaDrm;
  this.mode=mode;
  this.offlineLicenseKeySetId=offlineLicenseKeySetId;
  this.optionalKeyRequestParameters=optionalKeyRequestParameters;
  this.callback=callback;
  this.eventHandler=eventHandler;
  this.eventListener=eventListener;
  this.provisioningInProgress=provisioningInProgress;
  this.sessionEventListener=sessionEventListener;
  state=STATE_OPENING;
  postResponseHandler=new PostResponseHandler(playbackLooper);
  requestHandlerThread=new HandlerThread(""String_Node_Str"");
  requestHandlerThread.start();
  postRequestHandler=new PostRequestHandler(requestHandlerThread.getLooper());
  if (offlineLicenseKeySetId == null) {
    this.initData=initData;
    this.mimeType=mimeType;
  }
 else {
    this.initData=null;
    this.mimeType=null;
  }
}","/** 
 * Instantiates a new DRM session.
 * @param uuid The UUID of the drm scheme.
 * @param mediaDrm The media DRM.
 * @param provisioningManager The manager for provisioning.
 * @param initData The DRM init data.
 * @param mode The DRM mode.
 * @param offlineLicenseKeySetId The offlineLicense KeySetId.
 * @param optionalKeyRequestParameters The optional key request parameters.
 * @param callback The media DRM callback.
 * @param playbackLooper The playback looper.
 * @param eventHandler The handler to post listener events.
 * @param eventListener The DRM session manager event listener.
 */
public DefaultDrmSession(UUID uuid,ExoMediaDrm<T> mediaDrm,ProvisioningManager<T> provisioningManager,byte[] initData,String mimeType,@DefaultDrmSessionManager.Mode int mode,byte[] offlineLicenseKeySetId,HashMap<String,String> optionalKeyRequestParameters,MediaDrmCallback callback,Looper playbackLooper,Handler eventHandler,DefaultDrmSessionManager.EventListener eventListener){
  this.uuid=uuid;
  this.provisioningManager=provisioningManager;
  this.mediaDrm=mediaDrm;
  this.mode=mode;
  this.offlineLicenseKeySetId=offlineLicenseKeySetId;
  this.optionalKeyRequestParameters=optionalKeyRequestParameters;
  this.callback=callback;
  this.eventHandler=eventHandler;
  this.eventListener=eventListener;
  state=STATE_OPENING;
  postResponseHandler=new PostResponseHandler(playbackLooper);
  requestHandlerThread=new HandlerThread(""String_Node_Str"");
  requestHandlerThread.start();
  postRequestHandler=new PostRequestHandler(requestHandlerThread.getLooper());
  if (offlineLicenseKeySetId == null) {
    this.initData=initData;
    this.mimeType=mimeType;
  }
 else {
    this.initData=null;
    this.mimeType=null;
  }
}",0.9058450906996832
110256,"@SuppressWarnings(""String_Node_Str"") public void onMediaDrmEvent(int what){
  if (!isOpen()) {
    return;
  }
switch (what) {
case ExoMediaDrm.EVENT_KEY_REQUIRED:
    doLicense();
  break;
case ExoMediaDrm.EVENT_KEY_EXPIRED:
onKeysExpired();
break;
case ExoMediaDrm.EVENT_PROVISION_REQUIRED:
state=STATE_OPENED;
postProvisionRequest();
break;
default :
break;
}
}","@SuppressWarnings(""String_Node_Str"") public void onMediaDrmEvent(int what){
  if (!isOpen()) {
    return;
  }
switch (what) {
case ExoMediaDrm.EVENT_KEY_REQUIRED:
    doLicense();
  break;
case ExoMediaDrm.EVENT_KEY_EXPIRED:
onKeysExpired();
break;
case ExoMediaDrm.EVENT_PROVISION_REQUIRED:
state=STATE_OPENED;
provisioningManager.provisionRequired(this);
break;
default :
break;
}
}",0.9506008010680908
110257,"public void onProvisionCompleted(){
  if (state != STATE_OPENING && !isOpen()) {
    return;
  }
  if (openInternal(false)) {
    doLicense();
  }
}","public void onProvisionCompleted(){
  if (openInternal(false)) {
    doLicense();
  }
}",0.7404255319148936
110258,"private void onProvisionResponse(Object response){
  provisioningInProgress.set(false);
  if (response instanceof Exception) {
    onError((Exception)response);
    return;
  }
  try {
    mediaDrm.provideProvisionResponse((byte[])response);
  }
 catch (  DeniedByServerException e) {
    onError(e);
    return;
  }
  if (sessionEventListener != null) {
    sessionEventListener.onProvisionCompleted();
  }
}","private void onProvisionResponse(Object response){
  if (state != STATE_OPENING && !isOpen()) {
    return;
  }
  if (response instanceof Exception) {
    provisioningManager.onProvisionError((Exception)response);
    return;
  }
  try {
    mediaDrm.provideProvisionResponse((byte[])response);
  }
 catch (  DeniedByServerException e) {
    provisioningManager.onProvisionError(e);
    return;
  }
  provisioningManager.onProvisionCompleted();
}",0.591812865497076
110259,"/** 
 * Try to open a session, do provisioning if necessary.
 * @param allowProvisioning if provisioning is allowed, set this to false when calling fromprocessing provision response.
 * @return true on success, false otherwise.
 */
private boolean openInternal(boolean allowProvisioning){
  if (isOpen()) {
    return true;
  }
  try {
    sessionId=mediaDrm.openSession();
    mediaCrypto=mediaDrm.createMediaCrypto(sessionId);
    state=STATE_OPENED;
    return true;
  }
 catch (  NotProvisionedException e) {
    if (allowProvisioning) {
      postProvisionRequest();
    }
 else {
      onError(e);
    }
  }
catch (  Exception e) {
    onError(e);
  }
  return false;
}","/** 
 * Try to open a session, do provisioning if necessary.
 * @param allowProvisioning if provisioning is allowed, set this to false when calling fromprocessing provision response.
 * @return true on success, false otherwise.
 */
private boolean openInternal(boolean allowProvisioning){
  if (isOpen()) {
    return true;
  }
  try {
    sessionId=mediaDrm.openSession();
    mediaCrypto=mediaDrm.createMediaCrypto(sessionId);
    state=STATE_OPENED;
    return true;
  }
 catch (  NotProvisionedException e) {
    if (allowProvisioning) {
      provisioningManager.provisionRequired(this);
    }
 else {
      onError(e);
    }
  }
catch (  Exception e) {
    onError(e);
  }
  return false;
}",0.9730123997082422
110260,"private void onKeysError(Exception e){
  if (e instanceof NotProvisionedException) {
    postProvisionRequest();
  }
 else {
    onError(e);
  }
}","private void onKeysError(Exception e){
  if (e instanceof NotProvisionedException) {
    provisioningManager.provisionRequired(this);
  }
 else {
    onError(e);
  }
}",0.9073482428115016
110261,"/** 
 * @param uuid The UUID of the drm scheme.
 * @param mediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
 * @param callback Performs key and provisioning requests.
 * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argumentto  {@link ExoMediaDrm#getKeyRequest(byte[],byte[],String,int,HashMap)}. May be null.
 * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be null if delivery of events is not required.
 * @param eventListener A listener of events. May be null if delivery of events is not required.
 * @param multiSession A boolean that specify whether multiple key session support is enabled.Default is false.
 */
public DefaultDrmSessionManager(UUID uuid,ExoMediaDrm<T> mediaDrm,MediaDrmCallback callback,HashMap<String,String> optionalKeyRequestParameters,Handler eventHandler,EventListener eventListener,boolean multiSession){
  Assertions.checkNotNull(uuid);
  Assertions.checkNotNull(mediaDrm);
  Assertions.checkArgument(!C.COMMON_PSSH_UUID.equals(uuid),""String_Node_Str"");
  this.uuid=uuid;
  this.mediaDrm=mediaDrm;
  this.callback=callback;
  this.optionalKeyRequestParameters=optionalKeyRequestParameters;
  this.eventHandler=eventHandler;
  this.eventListener=eventListener;
  this.multiSession=multiSession;
  mode=MODE_PLAYBACK;
  sessions=new ArrayList<>();
  provisioningInProgress=new AtomicBoolean(false);
  if (multiSession) {
    mediaDrm.setPropertyString(""String_Node_Str"",""String_Node_Str"");
  }
  mediaDrm.setOnEventListener(new MediaDrmEventListener());
}","/** 
 * @param uuid The UUID of the drm scheme.
 * @param mediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
 * @param callback Performs key and provisioning requests.
 * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argumentto  {@link ExoMediaDrm#getKeyRequest(byte[],byte[],String,int,HashMap)}. May be null.
 * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be null if delivery of events is not required.
 * @param eventListener A listener of events. May be null if delivery of events is not required.
 * @param multiSession A boolean that specify whether multiple key session support is enabled.Default is false.
 */
public DefaultDrmSessionManager(UUID uuid,ExoMediaDrm<T> mediaDrm,MediaDrmCallback callback,HashMap<String,String> optionalKeyRequestParameters,Handler eventHandler,EventListener eventListener,boolean multiSession){
  Assertions.checkNotNull(uuid);
  Assertions.checkNotNull(mediaDrm);
  Assertions.checkArgument(!C.COMMON_PSSH_UUID.equals(uuid),""String_Node_Str"");
  this.uuid=uuid;
  this.mediaDrm=mediaDrm;
  this.callback=callback;
  this.optionalKeyRequestParameters=optionalKeyRequestParameters;
  this.eventHandler=eventHandler;
  this.eventListener=eventListener;
  this.multiSession=multiSession;
  mode=MODE_PLAYBACK;
  sessions=new ArrayList<>();
  provisioningSessions=new ArrayList<>();
  if (multiSession) {
    mediaDrm.setPropertyString(""String_Node_Str"",""String_Node_Str"");
  }
  mediaDrm.setOnEventListener(new MediaDrmEventListener());
}",0.9863967099019296
110262,"@Override public void onProvisionCompleted(){
  for (  DefaultDrmSession<T> session : sessions) {
    session.onProvisionCompleted();
  }
}","@Override public void onProvisionCompleted(){
  for (  DefaultDrmSession<T> session : provisioningSessions) {
    session.onProvisionCompleted();
  }
  provisioningSessions.clear();
}",0.8633540372670807
110263,"@Override public void releaseSession(DrmSession<T> session){
  DefaultDrmSession<T> drmSession=(DefaultDrmSession<T>)session;
  if (drmSession.release()) {
    sessions.remove(drmSession);
  }
}","@Override public void releaseSession(DrmSession<T> session){
  DefaultDrmSession<T> drmSession=(DefaultDrmSession<T>)session;
  if (drmSession.release()) {
    sessions.remove(drmSession);
    if (provisioningSessions.size() > 1 && provisioningSessions.get(0) == drmSession) {
      provisioningSessions.get(1).provision();
    }
    provisioningSessions.remove(drmSession);
  }
}",0.6759581881533101
110264,"@Override public DrmSession<T> acquireSession(Looper playbackLooper,DrmInitData drmInitData){
  Assertions.checkState(this.playbackLooper == null || this.playbackLooper == playbackLooper);
  if (sessions.isEmpty()) {
    this.playbackLooper=playbackLooper;
    if (mediaDrmHandler == null) {
      mediaDrmHandler=new MediaDrmHandler(playbackLooper);
    }
  }
  DefaultDrmSession<T> session=null;
  byte[] initData=null;
  String mimeType=null;
  if (offlineLicenseKeySetId == null) {
    SchemeData data=getSchemeData(drmInitData,uuid);
    if (data == null) {
      if (eventHandler != null && eventListener != null) {
        eventHandler.post(new Runnable(){
          @Override public void run(){
            eventListener.onDrmSessionManagerError(new IllegalStateException(""String_Node_Str"" + uuid));
          }
        }
);
      }
    }
 else {
      initData=getSchemeInitData(data,uuid);
      mimeType=getSchemeMimeType(data,uuid);
    }
  }
  for (  DefaultDrmSession<T> s : sessions) {
    if (!multiSession || s.canReuse(initData)) {
      session=s;
      break;
    }
  }
  if (session == null) {
    session=new DefaultDrmSession<T>(uuid,mediaDrm,initData,mimeType,mode,offlineLicenseKeySetId,optionalKeyRequestParameters,callback,playbackLooper,eventHandler,eventListener,provisioningInProgress,this);
    sessions.add(session);
  }
  session.acquire();
  return session;
}","@Override public DrmSession<T> acquireSession(Looper playbackLooper,DrmInitData drmInitData){
  Assertions.checkState(this.playbackLooper == null || this.playbackLooper == playbackLooper);
  if (sessions.isEmpty()) {
    this.playbackLooper=playbackLooper;
    if (mediaDrmHandler == null) {
      mediaDrmHandler=new MediaDrmHandler(playbackLooper);
    }
  }
  DefaultDrmSession<T> session=null;
  byte[] initData=null;
  String mimeType=null;
  if (offlineLicenseKeySetId == null) {
    SchemeData data=getSchemeData(drmInitData,uuid);
    if (data == null) {
      if (eventHandler != null && eventListener != null) {
        eventHandler.post(new Runnable(){
          @Override public void run(){
            eventListener.onDrmSessionManagerError(new IllegalStateException(""String_Node_Str"" + uuid));
          }
        }
);
      }
    }
 else {
      initData=getSchemeInitData(data,uuid);
      mimeType=getSchemeMimeType(data,uuid);
    }
  }
  if (!multiSession) {
    for (    DefaultDrmSession<T> existingSession : sessions) {
      if (existingSession.hasInitData(initData)) {
        session=existingSession;
        break;
      }
    }
  }
  if (session == null) {
    session=new DefaultDrmSession<>(uuid,mediaDrm,this,initData,mimeType,mode,offlineLicenseKeySetId,optionalKeyRequestParameters,callback,playbackLooper,eventHandler,eventListener);
    sessions.add(session);
  }
  session.acquire();
  return session;
}",0.9304132815259626
110265,"@Override public int compareTo(@NonNull SubtitleInputBuffer other){
  long delta=timeUs - other.timeUs;
  if (delta == 0) {
    return 0;
  }
  return delta > 0 ? 1 : -1;
}","@Override public int compareTo(@NonNull SubtitleInputBuffer other){
  if (isEndOfStream() != other.isEndOfStream()) {
    return isEndOfStream() ? 1 : -1;
  }
  long delta=timeUs - other.timeUs;
  if (delta == 0) {
    return 0;
  }
  return delta > 0 ? 1 : -1;
}",0.7908045977011494
110266,"private long getNextEventTime(){
  return ((nextSubtitleEventIndex == C.INDEX_UNSET) || (nextSubtitleEventIndex >= subtitle.getEventTimeCount())) ? Long.MAX_VALUE : (subtitle.getEventTime(nextSubtitleEventIndex));
}","private long getNextEventTime(){
  return nextSubtitleEventIndex == C.INDEX_UNSET || nextSubtitleEventIndex >= subtitle.getEventTimeCount() ? Long.MAX_VALUE : subtitle.getEventTime(nextSubtitleEventIndex);
}",0.8815165876777251
110267,"@Override public void queueInputBuffer(SubtitleInputBuffer inputBuffer) throws SubtitleDecoderException {
  Assertions.checkArgument(inputBuffer != null);
  Assertions.checkArgument(inputBuffer == dequeuedInputBuffer);
  if (inputBuffer.isDecodeOnly()) {
    releaseInputBuffer(inputBuffer);
  }
 else {
    queuedInputBuffers.add(inputBuffer);
  }
  dequeuedInputBuffer=null;
}","@Override public void queueInputBuffer(SubtitleInputBuffer inputBuffer) throws SubtitleDecoderException {
  Assertions.checkArgument(inputBuffer == dequeuedInputBuffer);
  if (inputBuffer.isDecodeOnly()) {
    releaseInputBuffer(inputBuffer);
  }
 else {
    queuedInputBuffers.add(inputBuffer);
  }
  dequeuedInputBuffer=null;
}",0.9306930693069309
110268,"@Override public void flush(){
  playbackPositionUs=0;
  while (!queuedInputBuffers.isEmpty()) {
    releaseInputBuffer(queuedInputBuffers.pollFirst());
  }
  if (dequeuedInputBuffer != null) {
    releaseInputBuffer(dequeuedInputBuffer);
    dequeuedInputBuffer=null;
  }
}","@Override public void flush(){
  playbackPositionUs=0;
  while (!queuedInputBuffers.isEmpty()) {
    releaseInputBuffer(queuedInputBuffers.poll());
  }
  if (dequeuedInputBuffer != null) {
    releaseInputBuffer(dequeuedInputBuffer);
    dequeuedInputBuffer=null;
  }
}",0.990791896869245
110269,"public CeaDecoder(){
  availableInputBuffers=new LinkedList<>();
  for (int i=0; i < NUM_INPUT_BUFFERS; i++) {
    availableInputBuffers.add(new SubtitleInputBuffer());
  }
  availableOutputBuffers=new LinkedList<>();
  for (int i=0; i < NUM_OUTPUT_BUFFERS; i++) {
    availableOutputBuffers.add(new CeaOutputBuffer(this));
  }
  queuedInputBuffers=new TreeSet<>();
}","public CeaDecoder(){
  availableInputBuffers=new LinkedList<>();
  for (int i=0; i < NUM_INPUT_BUFFERS; i++) {
    availableInputBuffers.add(new SubtitleInputBuffer());
  }
  availableOutputBuffers=new LinkedList<>();
  for (int i=0; i < NUM_OUTPUT_BUFFERS; i++) {
    availableOutputBuffers.add(new CeaOutputBuffer(this));
  }
  queuedInputBuffers=new PriorityQueue<>();
}",0.972972972972973
110270,"@Override public SubtitleOutputBuffer dequeueOutputBuffer() throws SubtitleDecoderException {
  if (availableOutputBuffers.isEmpty()) {
    return null;
  }
  while (!queuedInputBuffers.isEmpty() && queuedInputBuffers.first().timeUs <= playbackPositionUs) {
    SubtitleInputBuffer inputBuffer=queuedInputBuffers.pollFirst();
    if (inputBuffer.isEndOfStream()) {
      SubtitleOutputBuffer outputBuffer=availableOutputBuffers.pollFirst();
      outputBuffer.addFlag(C.BUFFER_FLAG_END_OF_STREAM);
      releaseInputBuffer(inputBuffer);
      return outputBuffer;
    }
    decode(inputBuffer);
    if (isNewSubtitleDataAvailable()) {
      Subtitle subtitle=createSubtitle();
      if (!inputBuffer.isDecodeOnly()) {
        SubtitleOutputBuffer outputBuffer=availableOutputBuffers.pollFirst();
        outputBuffer.setContent(inputBuffer.timeUs,subtitle,Format.OFFSET_SAMPLE_RELATIVE);
        releaseInputBuffer(inputBuffer);
        return outputBuffer;
      }
    }
    releaseInputBuffer(inputBuffer);
  }
  return null;
}","@Override public SubtitleOutputBuffer dequeueOutputBuffer() throws SubtitleDecoderException {
  if (availableOutputBuffers.isEmpty()) {
    return null;
  }
  while (!queuedInputBuffers.isEmpty() && queuedInputBuffers.peek().timeUs <= playbackPositionUs) {
    SubtitleInputBuffer inputBuffer=queuedInputBuffers.poll();
    if (inputBuffer.isEndOfStream()) {
      SubtitleOutputBuffer outputBuffer=availableOutputBuffers.pollFirst();
      outputBuffer.addFlag(C.BUFFER_FLAG_END_OF_STREAM);
      releaseInputBuffer(inputBuffer);
      return outputBuffer;
    }
    decode(inputBuffer);
    if (isNewSubtitleDataAvailable()) {
      Subtitle subtitle=createSubtitle();
      if (!inputBuffer.isDecodeOnly()) {
        SubtitleOutputBuffer outputBuffer=availableOutputBuffers.pollFirst();
        outputBuffer.setContent(inputBuffer.timeUs,subtitle,Format.OFFSET_SAMPLE_RELATIVE);
        releaseInputBuffer(inputBuffer);
        return outputBuffer;
      }
    }
    releaseInputBuffer(inputBuffer);
  }
  return null;
}",0.99317738791423
110271,"@Override public int compareTo(@NonNull SubtitleInputBuffer other){
  long delta=timeUs - other.timeUs;
  if (delta == 0) {
    return 0;
  }
  return delta > 0 ? 1 : -1;
}","@Override public int compareTo(@NonNull SubtitleInputBuffer other){
  if (isEndOfStream() != other.isEndOfStream()) {
    return isEndOfStream() ? 1 : -1;
  }
  long delta=timeUs - other.timeUs;
  if (delta == 0) {
    return 0;
  }
  return delta > 0 ? 1 : -1;
}",0.7908045977011494
110272,"private long getNextEventTime(){
  return ((nextSubtitleEventIndex == C.INDEX_UNSET) || (nextSubtitleEventIndex >= subtitle.getEventTimeCount())) ? Long.MAX_VALUE : (subtitle.getEventTime(nextSubtitleEventIndex));
}","private long getNextEventTime(){
  return nextSubtitleEventIndex == C.INDEX_UNSET || nextSubtitleEventIndex >= subtitle.getEventTimeCount() ? Long.MAX_VALUE : subtitle.getEventTime(nextSubtitleEventIndex);
}",0.8815165876777251
110273,"@Override public void queueInputBuffer(SubtitleInputBuffer inputBuffer) throws SubtitleDecoderException {
  Assertions.checkArgument(inputBuffer != null);
  Assertions.checkArgument(inputBuffer == dequeuedInputBuffer);
  if (inputBuffer.isDecodeOnly()) {
    releaseInputBuffer(inputBuffer);
  }
 else {
    queuedInputBuffers.add(inputBuffer);
  }
  dequeuedInputBuffer=null;
}","@Override public void queueInputBuffer(SubtitleInputBuffer inputBuffer) throws SubtitleDecoderException {
  Assertions.checkArgument(inputBuffer == dequeuedInputBuffer);
  if (inputBuffer.isDecodeOnly()) {
    releaseInputBuffer(inputBuffer);
  }
 else {
    queuedInputBuffers.add(inputBuffer);
  }
  dequeuedInputBuffer=null;
}",0.9306930693069309
110274,"@Override public void flush(){
  playbackPositionUs=0;
  while (!queuedInputBuffers.isEmpty()) {
    releaseInputBuffer(queuedInputBuffers.pollFirst());
  }
  if (dequeuedInputBuffer != null) {
    releaseInputBuffer(dequeuedInputBuffer);
    dequeuedInputBuffer=null;
  }
}","@Override public void flush(){
  playbackPositionUs=0;
  while (!queuedInputBuffers.isEmpty()) {
    releaseInputBuffer(queuedInputBuffers.poll());
  }
  if (dequeuedInputBuffer != null) {
    releaseInputBuffer(dequeuedInputBuffer);
    dequeuedInputBuffer=null;
  }
}",0.990791896869245
110275,"public CeaDecoder(){
  availableInputBuffers=new LinkedList<>();
  for (int i=0; i < NUM_INPUT_BUFFERS; i++) {
    availableInputBuffers.add(new SubtitleInputBuffer());
  }
  availableOutputBuffers=new LinkedList<>();
  for (int i=0; i < NUM_OUTPUT_BUFFERS; i++) {
    availableOutputBuffers.add(new CeaOutputBuffer(this));
  }
  queuedInputBuffers=new TreeSet<>();
}","public CeaDecoder(){
  availableInputBuffers=new LinkedList<>();
  for (int i=0; i < NUM_INPUT_BUFFERS; i++) {
    availableInputBuffers.add(new SubtitleInputBuffer());
  }
  availableOutputBuffers=new LinkedList<>();
  for (int i=0; i < NUM_OUTPUT_BUFFERS; i++) {
    availableOutputBuffers.add(new CeaOutputBuffer(this));
  }
  queuedInputBuffers=new PriorityQueue<>();
}",0.972972972972973
110276,"@Override public SubtitleOutputBuffer dequeueOutputBuffer() throws SubtitleDecoderException {
  if (availableOutputBuffers.isEmpty()) {
    return null;
  }
  while (!queuedInputBuffers.isEmpty() && queuedInputBuffers.first().timeUs <= playbackPositionUs) {
    SubtitleInputBuffer inputBuffer=queuedInputBuffers.pollFirst();
    if (inputBuffer.isEndOfStream()) {
      SubtitleOutputBuffer outputBuffer=availableOutputBuffers.pollFirst();
      outputBuffer.addFlag(C.BUFFER_FLAG_END_OF_STREAM);
      releaseInputBuffer(inputBuffer);
      return outputBuffer;
    }
    decode(inputBuffer);
    if (isNewSubtitleDataAvailable()) {
      Subtitle subtitle=createSubtitle();
      if (!inputBuffer.isDecodeOnly()) {
        SubtitleOutputBuffer outputBuffer=availableOutputBuffers.pollFirst();
        outputBuffer.setContent(inputBuffer.timeUs,subtitle,Format.OFFSET_SAMPLE_RELATIVE);
        releaseInputBuffer(inputBuffer);
        return outputBuffer;
      }
    }
    releaseInputBuffer(inputBuffer);
  }
  return null;
}","@Override public SubtitleOutputBuffer dequeueOutputBuffer() throws SubtitleDecoderException {
  if (availableOutputBuffers.isEmpty()) {
    return null;
  }
  while (!queuedInputBuffers.isEmpty() && queuedInputBuffers.peek().timeUs <= playbackPositionUs) {
    SubtitleInputBuffer inputBuffer=queuedInputBuffers.poll();
    if (inputBuffer.isEndOfStream()) {
      SubtitleOutputBuffer outputBuffer=availableOutputBuffers.pollFirst();
      outputBuffer.addFlag(C.BUFFER_FLAG_END_OF_STREAM);
      releaseInputBuffer(inputBuffer);
      return outputBuffer;
    }
    decode(inputBuffer);
    if (isNewSubtitleDataAvailable()) {
      Subtitle subtitle=createSubtitle();
      if (!inputBuffer.isDecodeOnly()) {
        SubtitleOutputBuffer outputBuffer=availableOutputBuffers.pollFirst();
        outputBuffer.setContent(inputBuffer.timeUs,subtitle,Format.OFFSET_SAMPLE_RELATIVE);
        releaseInputBuffer(inputBuffer);
        return outputBuffer;
      }
    }
    releaseInputBuffer(inputBuffer);
  }
  return null;
}",0.99317738791423
110277,"@Override public void run(){
  action.doActionAndScheduleNext(player,trackSelector,surface,mainHandler,next);
  if (repeatIntervalMs != C.TIME_UNSET) {
    clock.postDelayed(mainHandler,this,repeatIntervalMs);
  }
}","@Override public void run(){
  action.doActionAndScheduleNext(player,trackSelector,surface,mainHandler,null);
  clock.postDelayed(mainHandler,this,repeatIntervalMs);
}",0.8586387434554974
110278,"/** 
 * Schedules a new source preparation action to be executed.
 * @see ExoPlayer#prepare(MediaSource, boolean, boolean).
 * @return The builder, for convenience.
 */
public Builder prepareSource(MediaSource mediaSource,boolean resetPosition,boolean resetState){
  return apply(new PrepareSource(tag,mediaSource,resetPosition,resetState));
}","/** 
 * Schedules a new source preparation action to be executed.
 * @see com.google.android.exoplayer2.ExoPlayer#prepare(MediaSource, boolean, boolean).
 * @return The builder, for convenience.
 */
public Builder prepareSource(MediaSource mediaSource,boolean resetPosition,boolean resetState){
  return apply(new PrepareSource(tag,mediaSource,resetPosition,resetState));
}",0.9581005586592178
110279,"/** 
 * Gets the view onto which video is rendered. This is either a   {@link SurfaceView} (default)or a  {@link TextureView} if the {@code use_texture_view} view attribute has been set to true.
 * @return Either a {@link SurfaceView} or a {@link TextureView}.
 */
public View getVideoSurfaceView(){
  return surfaceView;
}","/** 
 * Gets the view onto which video is rendered. This is a: <ul> <li>  {@link SurfaceView} by default, or if the {@code surface_type} attribute is set to{@code surface_view}.</li> <li>  {@link TextureView} if {@code surface_type} is {@code texture_view}.</li> <li>  {@code null} if {@code surface_type} is {@code none}.</li> </ul>
 * @return The {@link SurfaceView},   {@link TextureView} or {@code null}.
 */
public View getVideoSurfaceView(){
  return surfaceView;
}",0.5365239294710328
110280,"@Override public void getNextChunk(MediaChunk previous,long playbackPositionUs,ChunkHolder out){
  long bufferedDurationUs=previous != null ? (previous.endTimeUs - playbackPositionUs) : 0;
  trackSelection.updateSelectedTrack(bufferedDurationUs);
  int chunkIndex=previous == null ? dataSet.getChunkIndexByPosition(playbackPositionUs) : previous.getNextChunkIndex();
  if (chunkIndex >= dataSet.getChunkCount()) {
    out.endOfStream=true;
  }
 else {
    Format selectedFormat=trackSelection.getSelectedFormat();
    long startTimeUs=dataSet.getStartTime(chunkIndex);
    long endTimeUs=startTimeUs + dataSet.getChunkDuration(chunkIndex);
    String uri=dataSet.getUri(trackSelection.getSelectedIndex());
    Segment fakeDataChunk=dataSet.getData(uri).getSegments().get(chunkIndex);
    DataSpec dataSpec=new DataSpec(Uri.parse(uri),fakeDataChunk.byteOffset,fakeDataChunk.length,null);
    int trackType=MimeTypes.getTrackType(selectedFormat.sampleMimeType);
    out.chunk=new SingleSampleMediaChunk(dataSource,dataSpec,selectedFormat,trackSelection.getSelectionReason(),trackSelection.getSelectionData(),startTimeUs,endTimeUs,chunkIndex,trackType,selectedFormat);
  }
}","@Override public void getNextChunk(MediaChunk previous,long playbackPositionUs,ChunkHolder out){
  long bufferedDurationUs=previous != null ? (previous.endTimeUs - playbackPositionUs) : 0;
  trackSelection.updateSelectedTrack(bufferedDurationUs);
  int chunkIndex=previous == null ? dataSet.getChunkIndexByPosition(playbackPositionUs) : previous.getNextChunkIndex();
  if (chunkIndex >= dataSet.getChunkCount()) {
    out.endOfStream=true;
  }
 else {
    Format selectedFormat=trackSelection.getSelectedFormat();
    long startTimeUs=dataSet.getStartTime(chunkIndex);
    long endTimeUs=startTimeUs + dataSet.getChunkDuration(chunkIndex);
    int trackGroupIndex=trackSelection.getIndexInTrackGroup(trackSelection.getSelectedIndex());
    String uri=dataSet.getUri(trackGroupIndex);
    Segment fakeDataChunk=dataSet.getData(uri).getSegments().get(chunkIndex);
    DataSpec dataSpec=new DataSpec(Uri.parse(uri),fakeDataChunk.byteOffset,fakeDataChunk.length,null);
    int trackType=MimeTypes.getTrackType(selectedFormat.sampleMimeType);
    out.chunk=new SingleSampleMediaChunk(dataSource,dataSpec,selectedFormat,trackSelection.getSelectionReason(),trackSelection.getSelectionData(),startTimeUs,endTimeUs,chunkIndex,trackType,selectedFormat);
  }
}",0.9487603305785124
110281,"/** 
 * Gets the view onto which video is rendered. This is either a   {@link SurfaceView} (default)or a  {@link TextureView} if the {@code use_texture_view} view attribute has been set to true.
 * @return Either a {@link SurfaceView} or a {@link TextureView}.
 */
public View getVideoSurfaceView(){
  return surfaceView;
}","/** 
 * Gets the view onto which video is rendered. This is a: <ul> <li>  {@link SurfaceView} by default, or if the {@code surface_type} attribute is set to{@code surface_view}.</li> <li>  {@link TextureView} if {@code surface_type} is {@code texture_view}.</li> <li>  {@code null} if {@code surface_type} is {@code none}.</li> </ul>
 * @return The {@link SurfaceView},   {@link TextureView} or {@code null}.
 */
public View getVideoSurfaceView(){
  return surfaceView;
}",0.5365239294710328
110282,"public long getChunkDuration(int chunkIndex){
  return chunkIndex == getAllData().size() - 1 ? lastChunkDurationUs : chunkDurationUs;
}","public long getChunkDuration(int chunkIndex){
  return chunkIndex == getChunkCount() - 1 ? lastChunkDurationUs : chunkDurationUs;
}",0.9172932330827068
110283,"public FakeAdaptiveDataSet(TrackSelection trackSelection,long mediaDurationUs,long chunkDurationUs){
  this.chunkDurationUs=chunkDurationUs;
  int selectionCount=trackSelection.length();
  long lastChunkDurationUs=mediaDurationUs % chunkDurationUs;
  int fullChunks=(int)(mediaDurationUs / chunkDurationUs);
  for (int i=0; i < selectionCount; i++) {
    String uri=getUri(i);
    Format format=trackSelection.getFormat(i);
    int chunkLength=(int)(format.bitrate * chunkDurationUs / (8 * C.MICROS_PER_SECOND));
    FakeData newData=this.newData(uri);
    for (int j=0; j < fullChunks; j++) {
      newData.appendReadData(chunkLength);
    }
    if (lastChunkDurationUs > 0) {
      int lastChunkLength=(int)(format.bitrate * (mediaDurationUs % chunkDurationUs) / (8 * C.MICROS_PER_SECOND));
      newData.appendReadData(lastChunkLength);
    }
  }
  this.lastChunkDurationUs=lastChunkDurationUs == 0 ? chunkDurationUs : lastChunkDurationUs;
}","public FakeAdaptiveDataSet(TrackSelection trackSelection,long mediaDurationUs,long chunkDurationUs){
  this.chunkDurationUs=chunkDurationUs;
  int selectionCount=trackSelection.length();
  long lastChunkDurationUs=mediaDurationUs % chunkDurationUs;
  int fullChunks=(int)(mediaDurationUs / chunkDurationUs);
  for (int i=0; i < selectionCount; i++) {
    String uri=getUri(i);
    Format format=trackSelection.getFormat(i);
    int chunkLength=(int)(format.bitrate * chunkDurationUs / (8 * C.MICROS_PER_SECOND));
    FakeData newData=this.newData(uri);
    for (int j=0; j < fullChunks; j++) {
      newData.appendReadData(chunkLength);
    }
    if (lastChunkDurationUs > 0) {
      int lastChunkLength=(int)(format.bitrate * (mediaDurationUs % chunkDurationUs) / (8 * C.MICROS_PER_SECOND));
      newData.appendReadData(lastChunkLength);
    }
  }
  this.lastChunkDurationUs=lastChunkDurationUs == 0 ? chunkDurationUs : lastChunkDurationUs;
  this.chunkCount=lastChunkDurationUs == 0 ? fullChunks : fullChunks + 1;
}",0.9622833843017328
110284,"/** 
 * Paint a 2-bit/pixel code string, as defined by ETSI EN 300 743 7.2.5.2, to a canvas.
 */
private static int paint2BitPixelCodeString(ParsableBitArray data,int[] clutEntries,byte[] clutMapTable,int column,int line,Paint paint,Canvas canvas){
  boolean endOfPixelCodeString=false;
  do {
    int runLength=0;
    int clutIndex=0;
    int peek=data.readBits(2);
    if (!data.readBit()) {
      runLength=1;
      clutIndex=peek;
    }
 else     if (data.readBit()) {
      runLength=3 + data.readBits(3);
      clutIndex=data.readBits(2);
    }
 else     if (!data.readBit()) {
switch (data.readBits(2)) {
case 0x00:
        endOfPixelCodeString=true;
      break;
case 0x01:
    runLength=2;
  break;
case 0x02:
runLength=12 + data.readBits(4);
clutIndex=data.readBits(2);
break;
case 0x03:
runLength=29 + data.readBits(8);
clutIndex=data.readBits(2);
break;
}
}
if (runLength != 0 && paint != null) {
paint.setColor(clutEntries[clutMapTable != null ? clutMapTable[clutIndex] : clutIndex]);
canvas.drawRect(column,line,column + runLength,line + 1,paint);
}
column+=runLength;
}
 while (!endOfPixelCodeString);
return column;
}","/** 
 * Paint a 2-bit/pixel code string, as defined by ETSI EN 300 743 7.2.5.2, to a canvas.
 */
private static int paint2BitPixelCodeString(ParsableBitArray data,int[] clutEntries,byte[] clutMapTable,int column,int line,Paint paint,Canvas canvas){
  boolean endOfPixelCodeString=false;
  do {
    int runLength=0;
    int clutIndex=0;
    int peek=data.readBits(2);
    if (peek != 0x00) {
      runLength=1;
      clutIndex=peek;
    }
 else     if (data.readBit()) {
      runLength=3 + data.readBits(3);
      clutIndex=data.readBits(2);
    }
 else     if (data.readBit()) {
      runLength=1;
    }
 else {
switch (data.readBits(2)) {
case 0x00:
        endOfPixelCodeString=true;
      break;
case 0x01:
    runLength=2;
  break;
case 0x02:
runLength=12 + data.readBits(4);
clutIndex=data.readBits(2);
break;
case 0x03:
runLength=29 + data.readBits(8);
clutIndex=data.readBits(2);
break;
}
}
if (runLength != 0 && paint != null) {
paint.setColor(clutEntries[clutMapTable != null ? clutMapTable[clutIndex] : clutIndex]);
canvas.drawRect(column,line,column + runLength,line + 1,paint);
}
column+=runLength;
}
 while (!endOfPixelCodeString);
return column;
}",0.8505446623093682
110285,"/** 
 * Paint a 2-bit/pixel code string, as defined by ETSI EN 300 743 7.2.5.2, to a canvas.
 */
private static int paint2BitPixelCodeString(ParsableBitArray data,int[] clutEntries,byte[] clutMapTable,int column,int line,Paint paint,Canvas canvas){
  boolean endOfPixelCodeString=false;
  do {
    int runLength=0;
    int clutIndex=0;
    int peek=data.readBits(2);
    if (!data.readBit()) {
      runLength=1;
      clutIndex=peek;
    }
 else     if (data.readBit()) {
      runLength=3 + data.readBits(3);
      clutIndex=data.readBits(2);
    }
 else     if (!data.readBit()) {
switch (data.readBits(2)) {
case 0x00:
        endOfPixelCodeString=true;
      break;
case 0x01:
    runLength=2;
  break;
case 0x02:
runLength=12 + data.readBits(4);
clutIndex=data.readBits(2);
break;
case 0x03:
runLength=29 + data.readBits(8);
clutIndex=data.readBits(2);
break;
}
}
if (runLength != 0 && paint != null) {
paint.setColor(clutEntries[clutMapTable != null ? clutMapTable[clutIndex] : clutIndex]);
canvas.drawRect(column,line,column + runLength,line + 1,paint);
}
column+=runLength;
}
 while (!endOfPixelCodeString);
return column;
}","/** 
 * Paint a 2-bit/pixel code string, as defined by ETSI EN 300 743 7.2.5.2, to a canvas.
 */
private static int paint2BitPixelCodeString(ParsableBitArray data,int[] clutEntries,byte[] clutMapTable,int column,int line,Paint paint,Canvas canvas){
  boolean endOfPixelCodeString=false;
  do {
    int runLength=0;
    int clutIndex=0;
    int peek=data.readBits(2);
    if (peek != 0x00) {
      runLength=1;
      clutIndex=peek;
    }
 else     if (data.readBit()) {
      runLength=3 + data.readBits(3);
      clutIndex=data.readBits(2);
    }
 else     if (data.readBit()) {
      runLength=1;
    }
 else {
switch (data.readBits(2)) {
case 0x00:
        endOfPixelCodeString=true;
      break;
case 0x01:
    runLength=2;
  break;
case 0x02:
runLength=12 + data.readBits(4);
clutIndex=data.readBits(2);
break;
case 0x03:
runLength=29 + data.readBits(8);
clutIndex=data.readBits(2);
break;
}
}
if (runLength != 0 && paint != null) {
paint.setColor(clutEntries[clutMapTable != null ? clutMapTable[clutIndex] : clutIndex]);
canvas.drawRect(column,line,column + runLength,line + 1,paint);
}
column+=runLength;
}
 while (!endOfPixelCodeString);
return column;
}",0.8505446623093682
110286,"@Override public long selectTracks(TrackSelection[] selections,boolean[] mayRetainStreamFlags,SampleStream[] streams,boolean[] streamResetFlags,long positionUs){
  Assertions.checkState(prepared);
  int oldEnabledTrackCount=enabledTrackCount;
  for (int i=0; i < selections.length; i++) {
    if (streams[i] != null && (selections[i] == null || !mayRetainStreamFlags[i])) {
      int track=((SampleStreamImpl)streams[i]).track;
      Assertions.checkState(trackEnabledStates[track]);
      enabledTrackCount--;
      trackEnabledStates[track]=false;
      streams[i]=null;
    }
  }
  boolean seekRequired=seenFirstTrackSelection ? oldEnabledTrackCount == 0 : positionUs != 0;
  for (int i=0; i < selections.length; i++) {
    if (streams[i] == null && selections[i] != null) {
      TrackSelection selection=selections[i];
      Assertions.checkState(selection.length() == 1);
      Assertions.checkState(selection.getIndexInTrackGroup(0) == 0);
      int track=tracks.indexOf(selection.getTrackGroup());
      Assertions.checkState(!trackEnabledStates[track]);
      enabledTrackCount++;
      trackEnabledStates[track]=true;
      streams[i]=new SampleStreamImpl(track);
      streamResetFlags[i]=true;
      if (!seekRequired) {
        SampleQueue sampleQueue=sampleQueues[i];
        sampleQueue.rewind();
        seekRequired=!sampleQueue.advanceTo(positionUs,true,true) && sampleQueue.getReadIndex() != 0;
      }
    }
  }
  if (enabledTrackCount == 0) {
    notifyReset=false;
    if (loader.isLoading()) {
      loader.cancelLoading();
    }
  }
 else   if (seekRequired) {
    positionUs=seekToUs(positionUs);
    for (int i=0; i < streams.length; i++) {
      if (streams[i] != null) {
        streamResetFlags[i]=true;
      }
    }
  }
  seenFirstTrackSelection=true;
  return positionUs;
}","@Override public long selectTracks(TrackSelection[] selections,boolean[] mayRetainStreamFlags,SampleStream[] streams,boolean[] streamResetFlags,long positionUs){
  Assertions.checkState(prepared);
  int oldEnabledTrackCount=enabledTrackCount;
  for (int i=0; i < selections.length; i++) {
    if (streams[i] != null && (selections[i] == null || !mayRetainStreamFlags[i])) {
      int track=((SampleStreamImpl)streams[i]).track;
      Assertions.checkState(trackEnabledStates[track]);
      enabledTrackCount--;
      trackEnabledStates[track]=false;
      streams[i]=null;
    }
  }
  boolean seekRequired=seenFirstTrackSelection ? oldEnabledTrackCount == 0 : positionUs != 0;
  for (int i=0; i < selections.length; i++) {
    if (streams[i] == null && selections[i] != null) {
      TrackSelection selection=selections[i];
      Assertions.checkState(selection.length() == 1);
      Assertions.checkState(selection.getIndexInTrackGroup(0) == 0);
      int track=tracks.indexOf(selection.getTrackGroup());
      Assertions.checkState(!trackEnabledStates[track]);
      enabledTrackCount++;
      trackEnabledStates[track]=true;
      streams[i]=new SampleStreamImpl(track);
      streamResetFlags[i]=true;
      if (!seekRequired) {
        SampleQueue sampleQueue=sampleQueues[track];
        sampleQueue.rewind();
        seekRequired=!sampleQueue.advanceTo(positionUs,true,true) && sampleQueue.getReadIndex() != 0;
      }
    }
  }
  if (enabledTrackCount == 0) {
    notifyReset=false;
    if (loader.isLoading()) {
      loader.cancelLoading();
    }
  }
 else   if (seekRequired) {
    positionUs=seekToUs(positionUs);
    for (int i=0; i < streams.length; i++) {
      if (streams[i] != null) {
        streamResetFlags[i]=true;
      }
    }
  }
  seenFirstTrackSelection=true;
  return positionUs;
}",0.9983397897066962
110287,"@Override public void updateSelectedTrack(long bufferedDurationUs){
  long nowMs=SystemClock.elapsedRealtime();
  int currentSelectedIndex=selectedIndex;
  Format currentFormat=getSelectedFormat();
  int idealSelectedIndex=determineIdealSelectedIndex(nowMs);
  Format idealFormat=getFormat(idealSelectedIndex);
  selectedIndex=idealSelectedIndex;
  if (currentFormat != null && !isBlacklisted(selectedIndex,nowMs)) {
    if (idealFormat.bitrate > currentFormat.bitrate && bufferedDurationUs < minDurationForQualityIncreaseUs) {
      selectedIndex=currentSelectedIndex;
    }
 else     if (idealFormat.bitrate < currentFormat.bitrate && bufferedDurationUs >= maxDurationForQualityDecreaseUs) {
      selectedIndex=currentSelectedIndex;
    }
  }
  if (selectedIndex != currentSelectedIndex) {
    reason=C.SELECTION_REASON_ADAPTIVE;
  }
}","@Override public void updateSelectedTrack(long bufferedDurationUs){
  long nowMs=SystemClock.elapsedRealtime();
  int currentSelectedIndex=selectedIndex;
  int idealSelectedIndex=determineIdealSelectedIndex(nowMs);
  selectedIndex=idealSelectedIndex;
  if (!isBlacklisted(currentSelectedIndex,nowMs)) {
    Format currentFormat=getFormat(currentSelectedIndex);
    Format idealFormat=getFormat(idealSelectedIndex);
    if (idealFormat.bitrate > currentFormat.bitrate && bufferedDurationUs < minDurationForQualityIncreaseUs) {
      selectedIndex=currentSelectedIndex;
    }
 else     if (idealFormat.bitrate < currentFormat.bitrate && bufferedDurationUs >= maxDurationForQualityDecreaseUs) {
      selectedIndex=currentSelectedIndex;
    }
  }
  if (selectedIndex != currentSelectedIndex) {
    reason=C.SELECTION_REASON_ADAPTIVE;
  }
}",0.8124253285543608
110288,"@Override public void updateSelectedTrack(long bufferedDurationUs){
  long nowMs=SystemClock.elapsedRealtime();
  int currentSelectedIndex=selectedIndex;
  Format currentFormat=getSelectedFormat();
  int idealSelectedIndex=determineIdealSelectedIndex(nowMs);
  Format idealFormat=getFormat(idealSelectedIndex);
  selectedIndex=idealSelectedIndex;
  if (currentFormat != null && !isBlacklisted(selectedIndex,nowMs)) {
    if (idealFormat.bitrate > currentFormat.bitrate && bufferedDurationUs < minDurationForQualityIncreaseUs) {
      selectedIndex=currentSelectedIndex;
    }
 else     if (idealFormat.bitrate < currentFormat.bitrate && bufferedDurationUs >= maxDurationForQualityDecreaseUs) {
      selectedIndex=currentSelectedIndex;
    }
  }
  if (selectedIndex != currentSelectedIndex) {
    reason=C.SELECTION_REASON_ADAPTIVE;
  }
}","@Override public void updateSelectedTrack(long bufferedDurationUs){
  long nowMs=SystemClock.elapsedRealtime();
  int currentSelectedIndex=selectedIndex;
  int idealSelectedIndex=determineIdealSelectedIndex(nowMs);
  selectedIndex=idealSelectedIndex;
  if (!isBlacklisted(currentSelectedIndex,nowMs)) {
    Format currentFormat=getFormat(currentSelectedIndex);
    Format idealFormat=getFormat(idealSelectedIndex);
    if (idealFormat.bitrate > currentFormat.bitrate && bufferedDurationUs < minDurationForQualityIncreaseUs) {
      selectedIndex=currentSelectedIndex;
    }
 else     if (idealFormat.bitrate < currentFormat.bitrate && bufferedDurationUs >= maxDurationForQualityDecreaseUs) {
      selectedIndex=currentSelectedIndex;
    }
  }
  if (selectedIndex != currentSelectedIndex) {
    reason=C.SELECTION_REASON_ADAPTIVE;
  }
}",0.8124253285543608
110289,"/** 
 * Creates a new time bar.
 */
public DefaultTimeBar(Context context,AttributeSet attrs){
  super(context,attrs);
  seekBounds=new Rect();
  progressBar=new Rect();
  bufferedBar=new Rect();
  scrubberBar=new Rect();
  progressPaint=new Paint();
  bufferedPaint=new Paint();
  scrubberPaint=new Paint();
  adMarkerPaint=new Paint();
  Resources res=context.getResources();
  DisplayMetrics displayMetrics=res.getDisplayMetrics();
  fineScrubYThreshold=dpToPx(displayMetrics,FINE_SCRUB_Y_THRESHOLD);
  int defaultBarHeight=dpToPx(displayMetrics,DEFAULT_BAR_HEIGHT);
  int defaultTouchTargetHeight=dpToPx(displayMetrics,DEFAULT_TOUCH_TARGET_HEIGHT);
  int defaultAdMarkerWidth=dpToPx(displayMetrics,DEFAULT_AD_MARKER_WIDTH);
  int defaultScrubberEnabledSize=dpToPx(displayMetrics,DEFAULT_SCRUBBER_ENABLED_SIZE);
  int defaultScrubberDisabledSize=dpToPx(displayMetrics,DEFAULT_SCRUBBER_DISABLED_SIZE);
  int defaultScrubberDraggedSize=dpToPx(displayMetrics,DEFAULT_SCRUBBER_DRAGGED_SIZE);
  if (attrs != null) {
    TypedArray a=context.getTheme().obtainStyledAttributes(attrs,R.styleable.DefaultTimeBar,0,0);
    try {
      barHeight=a.getDimensionPixelSize(R.styleable.DefaultTimeBar_bar_height,defaultBarHeight);
      touchTargetHeight=a.getDimensionPixelSize(R.styleable.DefaultTimeBar_touch_target_height,defaultTouchTargetHeight);
      adMarkerWidth=a.getDimensionPixelSize(R.styleable.DefaultTimeBar_ad_marker_width,defaultAdMarkerWidth);
      scrubberEnabledSize=a.getDimensionPixelSize(R.styleable.DefaultTimeBar_scrubber_enabled_size,defaultScrubberEnabledSize);
      scrubberDisabledSize=a.getDimensionPixelSize(R.styleable.DefaultTimeBar_scrubber_disabled_size,defaultScrubberDisabledSize);
      scrubberDraggedSize=a.getDimensionPixelSize(R.styleable.DefaultTimeBar_scrubber_dragged_size,defaultScrubberDraggedSize);
      int playedColor=a.getInt(R.styleable.DefaultTimeBar_played_color,DEFAULT_PLAYED_COLOR);
      int bufferedColor=a.getInt(R.styleable.DefaultTimeBar_buffered_color,DEFAULT_BUFFERED_COLOR);
      int adMarkerColor=a.getInt(R.styleable.DefaultTimeBar_ad_marker_color,DEFAULT_AD_MARKER_COLOR);
      progressPaint.setColor(playedColor);
      scrubberPaint.setColor(OPAQUE_COLOR | playedColor);
      bufferedPaint.setColor(bufferedColor);
      adMarkerPaint.setColor(adMarkerColor);
    }
  finally {
      a.recycle();
    }
  }
 else {
    barHeight=defaultBarHeight;
    touchTargetHeight=defaultTouchTargetHeight;
    adMarkerWidth=defaultAdMarkerWidth;
    scrubberEnabledSize=defaultScrubberEnabledSize;
    scrubberDisabledSize=defaultScrubberDisabledSize;
    scrubberDraggedSize=defaultScrubberDraggedSize;
    scrubberPaint.setColor(OPAQUE_COLOR | DEFAULT_PLAYED_COLOR);
    progressPaint.setColor(DEFAULT_PLAYED_COLOR);
    bufferedPaint.setColor(DEFAULT_BUFFERED_COLOR);
    adMarkerPaint.setColor(DEFAULT_AD_MARKER_COLOR);
  }
  formatBuilder=new StringBuilder();
  formatter=new Formatter(formatBuilder,Locale.getDefault());
  stopScrubbingRunnable=new Runnable(){
    @Override public void run(){
      stopScrubbing(false);
    }
  }
;
  scrubberSize=scrubberEnabledSize;
  scrubberPadding=(Math.max(scrubberDisabledSize,Math.max(scrubberEnabledSize,scrubberDraggedSize)) + 1) / 2;
  duration=C.TIME_UNSET;
  keyTimeIncrement=C.TIME_UNSET;
  keyCountIncrement=DEFAULT_INCREMENT_COUNT;
  setFocusable(true);
  if (Util.SDK_INT >= 16 && getImportantForAccessibility() == View.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
    setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
  }
}","/** 
 * Creates a new time bar.
 */
public DefaultTimeBar(Context context,AttributeSet attrs){
  super(context,attrs);
  seekBounds=new Rect();
  progressBar=new Rect();
  bufferedBar=new Rect();
  scrubberBar=new Rect();
  progressPaint=new Paint();
  bufferedPaint=new Paint();
  scrubberPaint=new Paint();
  adMarkerPaint=new Paint();
  Resources res=context.getResources();
  DisplayMetrics displayMetrics=res.getDisplayMetrics();
  fineScrubYThreshold=dpToPx(displayMetrics,FINE_SCRUB_Y_THRESHOLD);
  int defaultBarHeight=dpToPx(displayMetrics,DEFAULT_BAR_HEIGHT);
  int defaultTouchTargetHeight=dpToPx(displayMetrics,DEFAULT_TOUCH_TARGET_HEIGHT);
  int defaultAdMarkerWidth=dpToPx(displayMetrics,DEFAULT_AD_MARKER_WIDTH);
  int defaultScrubberEnabledSize=dpToPx(displayMetrics,DEFAULT_SCRUBBER_ENABLED_SIZE);
  int defaultScrubberDisabledSize=dpToPx(displayMetrics,DEFAULT_SCRUBBER_DISABLED_SIZE);
  int defaultScrubberDraggedSize=dpToPx(displayMetrics,DEFAULT_SCRUBBER_DRAGGED_SIZE);
  if (attrs != null) {
    TypedArray a=context.getTheme().obtainStyledAttributes(attrs,R.styleable.DefaultTimeBar,0,0);
    try {
      barHeight=a.getDimensionPixelSize(R.styleable.DefaultTimeBar_bar_height,defaultBarHeight);
      touchTargetHeight=a.getDimensionPixelSize(R.styleable.DefaultTimeBar_touch_target_height,defaultTouchTargetHeight);
      adMarkerWidth=a.getDimensionPixelSize(R.styleable.DefaultTimeBar_ad_marker_width,defaultAdMarkerWidth);
      scrubberEnabledSize=a.getDimensionPixelSize(R.styleable.DefaultTimeBar_scrubber_enabled_size,defaultScrubberEnabledSize);
      scrubberDisabledSize=a.getDimensionPixelSize(R.styleable.DefaultTimeBar_scrubber_disabled_size,defaultScrubberDisabledSize);
      scrubberDraggedSize=a.getDimensionPixelSize(R.styleable.DefaultTimeBar_scrubber_dragged_size,defaultScrubberDraggedSize);
      int playedColor=a.getInt(R.styleable.DefaultTimeBar_played_color,DEFAULT_PLAYED_COLOR);
      int bufferedColor=a.getInt(R.styleable.DefaultTimeBar_buffered_color,DEFAULT_BUFFERED_COLOR);
      int adMarkerColor=a.getInt(R.styleable.DefaultTimeBar_ad_marker_color,DEFAULT_AD_MARKER_COLOR);
      progressPaint.setColor(playedColor);
      scrubberPaint.setColor(OPAQUE_COLOR | playedColor);
      bufferedPaint.setColor(bufferedColor);
      adMarkerPaint.setColor(adMarkerColor);
    }
  finally {
      a.recycle();
    }
  }
 else {
    barHeight=defaultBarHeight;
    touchTargetHeight=defaultTouchTargetHeight;
    adMarkerWidth=defaultAdMarkerWidth;
    scrubberEnabledSize=defaultScrubberEnabledSize;
    scrubberDisabledSize=defaultScrubberDisabledSize;
    scrubberDraggedSize=defaultScrubberDraggedSize;
    scrubberPaint.setColor(OPAQUE_COLOR | DEFAULT_PLAYED_COLOR);
    progressPaint.setColor(DEFAULT_PLAYED_COLOR);
    bufferedPaint.setColor(DEFAULT_BUFFERED_COLOR);
    adMarkerPaint.setColor(DEFAULT_AD_MARKER_COLOR);
  }
  formatBuilder=new StringBuilder();
  formatter=new Formatter(formatBuilder,Locale.getDefault());
  stopScrubbingRunnable=new Runnable(){
    @Override public void run(){
      stopScrubbing(false);
    }
  }
;
  scrubberSize=scrubberEnabledSize;
  scrubberPadding=(Math.max(scrubberDisabledSize,Math.max(scrubberEnabledSize,scrubberDraggedSize)) + 1) / 2;
  duration=C.TIME_UNSET;
  keyTimeIncrement=C.TIME_UNSET;
  keyCountIncrement=DEFAULT_INCREMENT_COUNT;
  setFocusable(true);
  if (Util.SDK_INT >= 16) {
    maybeSetImportantForAccessibilityV16();
  }
}",0.9803921568627452
110290,"@TargetApi(14) @Override public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info){
  super.onInitializeAccessibilityNodeInfo(info);
  info.setClassName(DefaultTimeBar.class.getCanonicalName());
  info.setContentDescription(getProgressText());
  if (duration <= 0) {
    return;
  }
  if (Util.SDK_INT >= 21) {
    info.addAction(AccessibilityAction.ACTION_SCROLL_FORWARD);
    info.addAction(AccessibilityAction.ACTION_SCROLL_BACKWARD);
  }
 else   if (Util.SDK_INT >= 16) {
    info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);
    info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);
  }
}","@TargetApi(21) @Override public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info){
  super.onInitializeAccessibilityNodeInfo(info);
  info.setClassName(DefaultTimeBar.class.getCanonicalName());
  info.setContentDescription(getProgressText());
  if (duration <= 0) {
    return;
  }
  if (Util.SDK_INT >= 21) {
    info.addAction(AccessibilityAction.ACTION_SCROLL_FORWARD);
    info.addAction(AccessibilityAction.ACTION_SCROLL_BACKWARD);
  }
 else   if (Util.SDK_INT >= 16) {
    info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);
    info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);
  }
}",0.998407643312102
110291,"private void handleC1Command(int command){
  int window;
switch (command) {
case COMMAND_CW0:
case COMMAND_CW1:
case COMMAND_CW2:
case COMMAND_CW3:
case COMMAND_CW4:
case COMMAND_CW5:
case COMMAND_CW6:
case COMMAND_CW7:
    window=(command - COMMAND_CW0);
  if (currentWindow != window) {
    currentWindow=window;
    currentCueBuilder=cueBuilders[window];
  }
break;
case COMMAND_CLW:
for (int i=1; i <= NUM_WINDOWS; i++) {
if (serviceBlockPacket.readBit()) {
  cueBuilders[NUM_WINDOWS - i].clear();
}
}
break;
case COMMAND_DSW:
for (int i=1; i <= NUM_WINDOWS; i++) {
if (serviceBlockPacket.readBit()) {
cueBuilders[NUM_WINDOWS - i].setVisibility(true);
}
}
break;
case COMMAND_HDW:
for (int i=1; i <= NUM_WINDOWS; i++) {
if (serviceBlockPacket.readBit()) {
cueBuilders[NUM_WINDOWS - i].setVisibility(false);
}
}
break;
case COMMAND_TGW:
for (int i=1; i <= NUM_WINDOWS; i++) {
if (serviceBlockPacket.readBit()) {
CueBuilder cueBuilder=cueBuilders[NUM_WINDOWS - i];
cueBuilder.setVisibility(!cueBuilder.isVisible());
}
}
break;
case COMMAND_DLW:
for (int i=1; i <= NUM_WINDOWS; i++) {
if (serviceBlockPacket.readBit()) {
cueBuilders[NUM_WINDOWS - i].reset();
}
}
break;
case COMMAND_DLY:
serviceBlockPacket.skipBits(8);
break;
case COMMAND_DLC:
break;
case COMMAND_RST:
resetCueBuilders();
break;
case COMMAND_SPA:
if (!currentCueBuilder.isDefined()) {
serviceBlockPacket.skipBits(16);
}
 else {
handleSetPenAttributes();
}
break;
case COMMAND_SPC:
if (!currentCueBuilder.isDefined()) {
serviceBlockPacket.skipBits(24);
}
 else {
handleSetPenColor();
}
break;
case COMMAND_SPL:
if (!currentCueBuilder.isDefined()) {
serviceBlockPacket.skipBits(16);
}
 else {
handleSetPenLocation();
}
break;
case COMMAND_SWA:
if (!currentCueBuilder.isDefined()) {
serviceBlockPacket.skipBits(32);
}
 else {
handleSetWindowAttributes();
}
break;
case COMMAND_DF0:
case COMMAND_DF1:
case COMMAND_DF2:
case COMMAND_DF3:
case COMMAND_DS4:
case COMMAND_DF5:
case COMMAND_DF6:
case COMMAND_DF7:
window=(command - COMMAND_DF0);
handleDefineWindow(window);
break;
default :
Log.w(TAG,""String_Node_Str"" + command);
}
}","private void handleC1Command(int command){
  int window;
switch (command) {
case COMMAND_CW0:
case COMMAND_CW1:
case COMMAND_CW2:
case COMMAND_CW3:
case COMMAND_CW4:
case COMMAND_CW5:
case COMMAND_CW6:
case COMMAND_CW7:
    window=(command - COMMAND_CW0);
  if (currentWindow != window) {
    currentWindow=window;
    currentCueBuilder=cueBuilders[window];
  }
break;
case COMMAND_CLW:
for (int i=1; i <= NUM_WINDOWS; i++) {
if (serviceBlockPacket.readBit()) {
  cueBuilders[NUM_WINDOWS - i].clear();
}
}
break;
case COMMAND_DSW:
for (int i=1; i <= NUM_WINDOWS; i++) {
if (serviceBlockPacket.readBit()) {
cueBuilders[NUM_WINDOWS - i].setVisibility(true);
}
}
break;
case COMMAND_HDW:
for (int i=1; i <= NUM_WINDOWS; i++) {
if (serviceBlockPacket.readBit()) {
cueBuilders[NUM_WINDOWS - i].setVisibility(false);
}
}
break;
case COMMAND_TGW:
for (int i=1; i <= NUM_WINDOWS; i++) {
if (serviceBlockPacket.readBit()) {
CueBuilder cueBuilder=cueBuilders[NUM_WINDOWS - i];
cueBuilder.setVisibility(!cueBuilder.isVisible());
}
}
break;
case COMMAND_DLW:
for (int i=1; i <= NUM_WINDOWS; i++) {
if (serviceBlockPacket.readBit()) {
cueBuilders[NUM_WINDOWS - i].reset();
}
}
break;
case COMMAND_DLY:
serviceBlockPacket.skipBits(8);
break;
case COMMAND_DLC:
break;
case COMMAND_RST:
resetCueBuilders();
break;
case COMMAND_SPA:
if (!currentCueBuilder.isDefined()) {
serviceBlockPacket.skipBits(16);
}
 else {
handleSetPenAttributes();
}
break;
case COMMAND_SPC:
if (!currentCueBuilder.isDefined()) {
serviceBlockPacket.skipBits(24);
}
 else {
handleSetPenColor();
}
break;
case COMMAND_SPL:
if (!currentCueBuilder.isDefined()) {
serviceBlockPacket.skipBits(16);
}
 else {
handleSetPenLocation();
}
break;
case COMMAND_SWA:
if (!currentCueBuilder.isDefined()) {
serviceBlockPacket.skipBits(32);
}
 else {
handleSetWindowAttributes();
}
break;
case COMMAND_DF0:
case COMMAND_DF1:
case COMMAND_DF2:
case COMMAND_DF3:
case COMMAND_DS4:
case COMMAND_DF5:
case COMMAND_DF6:
case COMMAND_DF7:
window=(command - COMMAND_DF0);
handleDefineWindow(window);
if (currentWindow != window) {
currentWindow=window;
currentCueBuilder=cueBuilders[window];
}
break;
default :
Log.w(TAG,""String_Node_Str"" + command);
}
}",0.9780476412891173
110292,"public void clear(){
  rolledUpCaptions.clear();
  captionStringBuilder.clear();
  italicsStartPosition=C.POSITION_UNSET;
  underlineStartPosition=C.POSITION_UNSET;
  foregroundColorStartPosition=C.POSITION_UNSET;
  backgroundColorStartPosition=C.POSITION_UNSET;
}","public void clear(){
  rolledUpCaptions.clear();
  captionStringBuilder.clear();
  italicsStartPosition=C.POSITION_UNSET;
  underlineStartPosition=C.POSITION_UNSET;
  foregroundColorStartPosition=C.POSITION_UNSET;
  backgroundColorStartPosition=C.POSITION_UNSET;
  row=0;
}",0.9832402234636872
110293,"public void setPenLocation(int row,int column){
}","public void setPenLocation(int row,int column){
  if (this.row != row) {
    append('\n');
  }
  this.row=row;
}",0.6086956521739131
110294,"private void processCurrentPacket(){
  if (currentDtvCcPacket.currentIndex != (currentDtvCcPacket.packetSize * 2 - 1)) {
    Log.w(TAG,""String_Node_Str"" + (currentDtvCcPacket.packetSize * 2 - 1) + ""String_Node_Str""+ currentDtvCcPacket.currentIndex+ ""String_Node_Str""+ currentDtvCcPacket.sequenceNumber+ ""String_Node_Str"");
    return;
  }
  serviceBlockPacket.reset(currentDtvCcPacket.packetData,currentDtvCcPacket.currentIndex);
  int serviceNumber=serviceBlockPacket.readBits(3);
  int blockSize=serviceBlockPacket.readBits(5);
  if (serviceNumber == 7) {
    serviceBlockPacket.skipBits(2);
    serviceNumber+=serviceBlockPacket.readBits(6);
  }
  if (blockSize == 0) {
    if (serviceNumber != 0) {
      Log.w(TAG,""String_Node_Str"" + serviceNumber + ""String_Node_Str"");
    }
    return;
  }
  if (serviceNumber != selectedServiceNumber) {
    return;
  }
  while (serviceBlockPacket.bitsLeft() > 0) {
    int command=serviceBlockPacket.readBits(8);
    if (command != COMMAND_EXT1) {
      if (command <= GROUP_C0_END) {
        handleC0Command(command);
      }
 else       if (command <= GROUP_G0_END) {
        handleG0Character(command);
      }
 else       if (command <= GROUP_C1_END) {
        handleC1Command(command);
        cues=getDisplayCues();
      }
 else       if (command <= GROUP_G1_END) {
        handleG1Character(command);
      }
 else {
        Log.w(TAG,""String_Node_Str"" + command);
      }
    }
 else {
      command=serviceBlockPacket.readBits(8);
      if (command <= GROUP_C2_END) {
        handleC2Command(command);
      }
 else       if (command <= GROUP_G2_END) {
        handleG2Character(command);
      }
 else       if (command <= GROUP_C3_END) {
        handleC3Command(command);
      }
 else       if (command <= GROUP_G3_END) {
        handleG3Character(command);
      }
 else {
        Log.w(TAG,""String_Node_Str"" + command);
      }
    }
  }
}","private void processCurrentPacket(){
  if (currentDtvCcPacket.currentIndex != (currentDtvCcPacket.packetSize * 2 - 1)) {
    Log.w(TAG,""String_Node_Str"" + (currentDtvCcPacket.packetSize * 2 - 1) + ""String_Node_Str""+ currentDtvCcPacket.currentIndex+ ""String_Node_Str""+ currentDtvCcPacket.sequenceNumber+ ""String_Node_Str"");
    return;
  }
  serviceBlockPacket.reset(currentDtvCcPacket.packetData,currentDtvCcPacket.currentIndex);
  int serviceNumber=serviceBlockPacket.readBits(3);
  int blockSize=serviceBlockPacket.readBits(5);
  if (serviceNumber == 7) {
    serviceBlockPacket.skipBits(2);
    serviceNumber+=serviceBlockPacket.readBits(6);
  }
  if (blockSize == 0) {
    if (serviceNumber != 0) {
      Log.w(TAG,""String_Node_Str"" + serviceNumber + ""String_Node_Str"");
    }
    return;
  }
  if (serviceNumber != selectedServiceNumber) {
    return;
  }
  boolean cuesNeedUpdate=false;
  while (serviceBlockPacket.bitsLeft() > 0) {
    int command=serviceBlockPacket.readBits(8);
    if (command != COMMAND_EXT1) {
      if (command <= GROUP_C0_END) {
        handleC0Command(command);
      }
 else       if (command <= GROUP_G0_END) {
        handleG0Character(command);
        cuesNeedUpdate=true;
      }
 else       if (command <= GROUP_C1_END) {
        handleC1Command(command);
        cuesNeedUpdate=true;
      }
 else       if (command <= GROUP_G1_END) {
        handleG1Character(command);
        cuesNeedUpdate=true;
      }
 else {
        Log.w(TAG,""String_Node_Str"" + command);
      }
    }
 else {
      command=serviceBlockPacket.readBits(8);
      if (command <= GROUP_C2_END) {
        handleC2Command(command);
      }
 else       if (command <= GROUP_G2_END) {
        handleG2Character(command);
        cuesNeedUpdate=true;
      }
 else       if (command <= GROUP_C3_END) {
        handleC3Command(command);
      }
 else       if (command <= GROUP_G3_END) {
        handleG3Character(command);
        cuesNeedUpdate=true;
      }
 else {
        Log.w(TAG,""String_Node_Str"" + command);
      }
    }
  }
  if (cuesNeedUpdate) {
    cues=getDisplayCues();
  }
}",0.941647883796644
110295,"private void setupBitmapLayout(){
  int parentWidth=parentRight - parentLeft;
  int parentHeight=parentBottom - parentTop;
  float anchorX=parentLeft + (parentWidth * cuePosition);
  float anchorY=parentTop + (parentHeight * cueLine);
  int width=(int)(parentWidth * cueSize);
  int height=(int)(width * ((float)cueBitmap.getHeight() / cueBitmap.getWidth()));
  int x=(int)(cueLineAnchor == Cue.ANCHOR_TYPE_END ? (anchorX - width) : cueLineAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorX - (width / 2)) : anchorX);
  int y=(int)(cuePositionAnchor == Cue.ANCHOR_TYPE_END ? (anchorY - width) : cuePositionAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorY - (width / 2)) : anchorY);
  bitmapRect=new Rect(x,y,x + width,y + height);
}","private void setupBitmapLayout(){
  int parentWidth=parentRight - parentLeft;
  int parentHeight=parentBottom - parentTop;
  float anchorX=parentLeft + (parentWidth * cuePosition);
  float anchorY=parentTop + (parentHeight * cueLine);
  int width=(int)(parentWidth * cueSize);
  int height=(int)(width * ((float)cueBitmap.getHeight() / cueBitmap.getWidth()));
  int x=(int)(cueLineAnchor == Cue.ANCHOR_TYPE_END ? (anchorX - width) : cueLineAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorX - (width / 2)) : anchorX);
  int y=(int)(cuePositionAnchor == Cue.ANCHOR_TYPE_END ? (anchorY - height) : cuePositionAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorY - (height / 2)) : anchorY);
  bitmapRect=new Rect(x,y,x + width,y + height);
}",0.984743411927878
110296,"private void setupTextLayout(){
  int parentWidth=parentRight - parentLeft;
  int parentHeight=parentBottom - parentTop;
  textPaint.setTextSize(textSizePx);
  int textPaddingX=(int)(textSizePx * INNER_PADDING_RATIO + 0.5f);
  int availableWidth=parentWidth - textPaddingX * 2;
  if (cueSize != Cue.DIMEN_UNSET) {
    availableWidth=(int)(availableWidth * cueSize);
  }
  if (availableWidth <= 0) {
    Log.w(TAG,""String_Node_Str"");
    return;
  }
  Alignment textAlignment=cueTextAlignment == null ? Alignment.ALIGN_CENTER : cueTextAlignment;
  textLayout=new StaticLayout(cueText,textPaint,availableWidth,textAlignment,spacingMult,spacingAdd,true);
  int textHeight=textLayout.getHeight();
  int textWidth=0;
  int lineCount=textLayout.getLineCount();
  for (int i=0; i < lineCount; i++) {
    textWidth=Math.max((int)Math.ceil(textLayout.getLineWidth(i)),textWidth);
  }
  if (cueSize != Cue.DIMEN_UNSET && textWidth < availableWidth) {
    textWidth=availableWidth;
  }
  textWidth+=textPaddingX * 2;
  int textLeft;
  int textRight;
  if (cuePosition != Cue.DIMEN_UNSET) {
    int anchorPosition=Math.round(parentWidth * cuePosition) + parentLeft;
    textLeft=cuePositionAnchor == Cue.ANCHOR_TYPE_END ? anchorPosition - textWidth : cuePositionAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorPosition * 2 - textWidth) / 2 : anchorPosition;
    textLeft=Math.max(textLeft,parentLeft);
    textRight=Math.min(textLeft + textWidth,parentRight);
  }
 else {
    textLeft=(parentWidth - textWidth) / 2;
    textRight=textLeft + textWidth;
  }
  int textTop;
  if (cueLine != Cue.DIMEN_UNSET) {
    int anchorPosition;
    if (cueLineType == Cue.LINE_TYPE_FRACTION) {
      anchorPosition=Math.round(parentHeight * cueLine) + parentTop;
    }
 else {
      int firstLineHeight=textLayout.getLineBottom(0) - textLayout.getLineTop(0);
      if (cueLine >= 0) {
        anchorPosition=Math.round(cueLine * firstLineHeight) + parentTop;
      }
 else {
        anchorPosition=Math.round(cueLine * firstLineHeight) + parentBottom;
      }
    }
    textTop=cueLineAnchor == Cue.ANCHOR_TYPE_END ? anchorPosition - textHeight : cueLineAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorPosition * 2 - textHeight) / 2 : anchorPosition;
    if (textTop + textHeight > parentBottom) {
      textTop=parentBottom - textHeight;
    }
 else     if (textTop < parentTop) {
      textTop=parentTop;
    }
  }
 else {
    textTop=parentBottom - textHeight - (int)(parentHeight * bottomPaddingFraction);
  }
  textWidth=textRight - textLeft;
  this.textLayout=new StaticLayout(cueText,textPaint,textWidth,textAlignment,spacingMult,spacingAdd,true);
  this.textLeft=textLeft;
  this.textTop=textTop;
  this.textPaddingX=textPaddingX;
}","private void setupTextLayout(){
  int parentWidth=parentRight - parentLeft;
  int parentHeight=parentBottom - parentTop;
  textPaint.setTextSize(textSizePx);
  int textPaddingX=(int)(textSizePx * INNER_PADDING_RATIO + 0.5f);
  int availableWidth=parentWidth - textPaddingX * 2;
  if (cueSize != Cue.DIMEN_UNSET) {
    availableWidth=(int)(availableWidth * cueSize);
  }
  if (availableWidth <= 0) {
    Log.w(TAG,""String_Node_Str"");
    return;
  }
  Alignment textAlignment=cueTextAlignment == null ? Alignment.ALIGN_CENTER : cueTextAlignment;
  textLayout=new StaticLayout(cueText,textPaint,availableWidth,textAlignment,spacingMult,spacingAdd,true);
  int textHeight=textLayout.getHeight();
  int textWidth=0;
  int lineCount=textLayout.getLineCount();
  for (int i=0; i < lineCount; i++) {
    textWidth=Math.max((int)Math.ceil(textLayout.getLineWidth(i)),textWidth);
  }
  if (cueSize != Cue.DIMEN_UNSET && textWidth < availableWidth) {
    textWidth=availableWidth;
  }
  textWidth+=textPaddingX * 2;
  int textLeft;
  int textRight;
  if (cuePosition != Cue.DIMEN_UNSET) {
    int anchorPosition=Math.round(parentWidth * cuePosition) + parentLeft;
    textLeft=cuePositionAnchor == Cue.ANCHOR_TYPE_END ? anchorPosition - textWidth : cuePositionAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorPosition * 2 - textWidth) / 2 : anchorPosition;
    textLeft=Math.max(textLeft,parentLeft);
    textRight=Math.min(textLeft + textWidth,parentRight);
  }
 else {
    textLeft=(parentWidth - textWidth) / 2;
    textRight=textLeft + textWidth;
  }
  int textTop;
  if (cueLine != Cue.DIMEN_UNSET) {
    int anchorPosition;
    if (cueLineType == Cue.LINE_TYPE_FRACTION) {
      anchorPosition=Math.round(parentHeight * cueLine) + parentTop;
    }
 else {
      int firstLineHeight=textLayout.getLineBottom(0) - textLayout.getLineTop(0);
      if (cueLine >= 0) {
        anchorPosition=Math.round(cueLine * firstLineHeight) + parentTop;
      }
 else {
        anchorPosition=Math.round((cueLine + 1) * firstLineHeight) + parentBottom;
      }
    }
    textTop=cueLineAnchor == Cue.ANCHOR_TYPE_END ? anchorPosition - textHeight : cueLineAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorPosition * 2 - textHeight) / 2 : anchorPosition;
    if (textTop + textHeight > parentBottom) {
      textTop=parentBottom - textHeight;
    }
 else     if (textTop < parentTop) {
      textTop=parentTop;
    }
  }
 else {
    textTop=parentBottom - textHeight - (int)(parentHeight * bottomPaddingFraction);
  }
  textWidth=textRight - textLeft;
  this.textLayout=new StaticLayout(cueText,textPaint,textWidth,textAlignment,spacingMult,spacingAdd,true);
  this.textLeft=textLeft;
  this.textTop=textTop;
  this.textPaddingX=textPaddingX;
}",0.9963031423290204
110297,"/** 
 * Draws the provided   {@link Cue} into a canvas with the specified styling.<p> A call to this method is able to use cached results of calculations made during the previous call, and so an instance of this class is able to optimize repeated calls to this method in which the same parameters are passed.
 * @param cue The cue to draw.
 * @param applyEmbeddedStyles Whether styling embedded within the cue should be applied.
 * @param style The style to use when drawing the cue text.
 * @param textSizePx The text size to use when drawing the cue text, in pixels.
 * @param bottomPaddingFraction The bottom padding fraction to apply when {@link Cue#line} is{@link Cue#DIMEN_UNSET}, as a fraction of the viewport height
 * @param canvas The canvas into which to draw.
 * @param cueBoxLeft The left position of the enclosing cue box.
 * @param cueBoxTop The top position of the enclosing cue box.
 * @param cueBoxRight The right position of the enclosing cue box.
 * @param cueBoxBottom The bottom position of the enclosing cue box.
 */
public void draw(Cue cue,boolean applyEmbeddedStyles,CaptionStyleCompat style,float textSizePx,float bottomPaddingFraction,Canvas canvas,int cueBoxLeft,int cueBoxTop,int cueBoxRight,int cueBoxBottom){
  boolean isTextCue=cue.bitmap == null;
  CharSequence cueText=null;
  Bitmap cueBitmap=null;
  if (isTextCue) {
    cueText=cue.text;
    if (TextUtils.isEmpty(cueText)) {
      return;
    }
    if (!applyEmbeddedStyles) {
      cueText=cueText.toString();
      windowColor=style.windowColor;
    }
  }
 else {
    cueBitmap=cue.bitmap;
  }
  if (areCharSequencesEqual(this.cueText,cueText) && Util.areEqual(this.cueTextAlignment,cue.textAlignment) && this.cueBitmap == cueBitmap && this.cueLine == cue.line && this.cueLineType == cue.lineType && Util.areEqual(this.cueLineAnchor,cue.lineAnchor) && this.cuePosition == cue.position && Util.areEqual(this.cuePositionAnchor,cue.positionAnchor) && this.cueSize == cue.size && this.applyEmbeddedStyles == applyEmbeddedStyles && this.foregroundColor == style.foregroundColor && this.backgroundColor == style.backgroundColor && this.windowColor == style.windowColor && this.edgeType == style.edgeType && this.edgeColor == style.edgeColor && Util.areEqual(this.textPaint.getTypeface(),style.typeface) && this.textSizePx == textSizePx && this.bottomPaddingFraction == bottomPaddingFraction && this.parentLeft == cueBoxLeft && this.parentTop == cueBoxTop && this.parentRight == cueBoxRight && this.parentBottom == cueBoxBottom) {
    drawLayout(canvas,isTextCue);
    return;
  }
  this.cueText=cueText;
  this.cueTextAlignment=cue.textAlignment;
  this.cueBitmap=cueBitmap;
  this.cueLine=cue.line;
  this.cueLineType=cue.lineType;
  this.cueLineAnchor=cue.lineAnchor;
  this.cuePosition=cue.position;
  this.cuePositionAnchor=cue.positionAnchor;
  this.cueSize=cue.size;
  this.applyEmbeddedStyles=applyEmbeddedStyles;
  this.foregroundColor=style.foregroundColor;
  this.backgroundColor=style.backgroundColor;
  this.windowColor=windowColor;
  this.edgeType=style.edgeType;
  this.edgeColor=style.edgeColor;
  this.textPaint.setTypeface(style.typeface);
  this.textSizePx=textSizePx;
  this.bottomPaddingFraction=bottomPaddingFraction;
  this.parentLeft=cueBoxLeft;
  this.parentTop=cueBoxTop;
  this.parentRight=cueBoxRight;
  this.parentBottom=cueBoxBottom;
  if (isTextCue) {
    setupTextLayout();
  }
 else {
    setupBitmapLayout();
  }
  drawLayout(canvas,isTextCue);
}","/** 
 * Draws the provided   {@link Cue} into a canvas with the specified styling.<p> A call to this method is able to use cached results of calculations made during the previous call, and so an instance of this class is able to optimize repeated calls to this method in which the same parameters are passed.
 * @param cue The cue to draw.
 * @param applyEmbeddedStyles Whether styling embedded within the cue should be applied.
 * @param style The style to use when drawing the cue text.
 * @param textSizePx The text size to use when drawing the cue text, in pixels.
 * @param bottomPaddingFraction The bottom padding fraction to apply when {@link Cue#line} is{@link Cue#DIMEN_UNSET}, as a fraction of the viewport height
 * @param canvas The canvas into which to draw.
 * @param cueBoxLeft The left position of the enclosing cue box.
 * @param cueBoxTop The top position of the enclosing cue box.
 * @param cueBoxRight The right position of the enclosing cue box.
 * @param cueBoxBottom The bottom position of the enclosing cue box.
 */
public void draw(Cue cue,boolean applyEmbeddedStyles,CaptionStyleCompat style,float textSizePx,float bottomPaddingFraction,Canvas canvas,int cueBoxLeft,int cueBoxTop,int cueBoxRight,int cueBoxBottom){
  boolean isTextCue=cue.bitmap == null;
  CharSequence cueText=null;
  Bitmap cueBitmap=null;
  int windowColor=Color.BLACK;
  if (isTextCue) {
    cueText=cue.text;
    if (TextUtils.isEmpty(cueText)) {
      return;
    }
    windowColor=cue.windowColorSet ? cue.windowColor : style.windowColor;
    if (!applyEmbeddedStyles) {
      cueText=cueText.toString();
      windowColor=style.windowColor;
    }
  }
 else {
    cueBitmap=cue.bitmap;
  }
  if (areCharSequencesEqual(this.cueText,cueText) && Util.areEqual(this.cueTextAlignment,cue.textAlignment) && this.cueBitmap == cueBitmap && this.cueLine == cue.line && this.cueLineType == cue.lineType && Util.areEqual(this.cueLineAnchor,cue.lineAnchor) && this.cuePosition == cue.position && Util.areEqual(this.cuePositionAnchor,cue.positionAnchor) && this.cueSize == cue.size && this.applyEmbeddedStyles == applyEmbeddedStyles && this.foregroundColor == style.foregroundColor && this.backgroundColor == style.backgroundColor && this.windowColor == windowColor && this.edgeType == style.edgeType && this.edgeColor == style.edgeColor && Util.areEqual(this.textPaint.getTypeface(),style.typeface) && this.textSizePx == textSizePx && this.bottomPaddingFraction == bottomPaddingFraction && this.parentLeft == cueBoxLeft && this.parentTop == cueBoxTop && this.parentRight == cueBoxRight && this.parentBottom == cueBoxBottom) {
    drawLayout(canvas,isTextCue);
    return;
  }
  this.cueText=cueText;
  this.cueTextAlignment=cue.textAlignment;
  this.cueBitmap=cueBitmap;
  this.cueLine=cue.line;
  this.cueLineType=cue.lineType;
  this.cueLineAnchor=cue.lineAnchor;
  this.cuePosition=cue.position;
  this.cuePositionAnchor=cue.positionAnchor;
  this.cueSize=cue.size;
  this.applyEmbeddedStyles=applyEmbeddedStyles;
  this.foregroundColor=style.foregroundColor;
  this.backgroundColor=style.backgroundColor;
  this.windowColor=windowColor;
  this.edgeType=style.edgeType;
  this.edgeColor=style.edgeColor;
  this.textPaint.setTypeface(style.typeface);
  this.textSizePx=textSizePx;
  this.bottomPaddingFraction=bottomPaddingFraction;
  this.parentLeft=cueBoxLeft;
  this.parentTop=cueBoxTop;
  this.parentRight=cueBoxRight;
  this.parentBottom=cueBoxBottom;
  if (isTextCue) {
    setupTextLayout();
  }
 else {
    setupBitmapLayout();
  }
  drawLayout(canvas,isTextCue);
}",0.9842037853991746
110298,"private boolean handleCtrl(byte cc1,byte cc2){
  boolean isRepeatableControl=isRepeatable(cc1);
  if (isRepeatableControl) {
    if (repeatableControlSet && repeatableControlCc1 == cc1 && repeatableControlCc2 == cc2) {
      repeatableControlSet=false;
      return true;
    }
 else {
      repeatableControlSet=true;
      repeatableControlCc1=cc1;
      repeatableControlCc2=cc2;
    }
  }
  if (isMidrowCtrlCode(cc1,cc2)) {
    handleMidrowCtrl(cc2);
  }
 else   if (isPreambleAddressCode(cc1,cc2)) {
    handlePreambleAddressCode(cc1,cc2);
  }
 else   if (isTabCtrlCode(cc1,cc2)) {
    currentCueBuilder.tab(cc2 - 0x20);
  }
 else   if (isMiscCode(cc1,cc2)) {
    handleMiscCode(cc2);
  }
  return isRepeatableControl;
}","private boolean handleCtrl(byte cc1,byte cc2){
  boolean isRepeatableControl=isRepeatable(cc1);
  if (isRepeatableControl) {
    if (repeatableControlSet && repeatableControlCc1 == cc1 && repeatableControlCc2 == cc2) {
      repeatableControlSet=false;
      return true;
    }
 else {
      repeatableControlSet=true;
      repeatableControlCc1=cc1;
      repeatableControlCc2=cc2;
    }
  }
  if (isMidrowCtrlCode(cc1,cc2)) {
    handleMidrowCtrl(cc2);
  }
 else   if (isPreambleAddressCode(cc1,cc2)) {
    handlePreambleAddressCode(cc1,cc2);
  }
 else   if (isTabCtrlCode(cc1,cc2)) {
    currentCueBuilder.setTab(cc2 - 0x20);
  }
 else   if (isMiscCode(cc1,cc2)) {
    handleMiscCode(cc2);
  }
  return isRepeatableControl;
}",0.9965588437715072
110299,"/** 
 * Returns whether the track at the specified index in the selection is blaclisted.
 * @param index The index of the track in the selection.
 * @param nowMs The current time in the timebase of {@link SystemClock#elapsedRealtime()}.
 */
protected final boolean isBlacklisted(int index,long nowMs){
  return blacklistUntilTimes[index] > nowMs;
}","/** 
 * Returns whether the track at the specified index in the selection is blacklisted.
 * @param index The index of the track in the selection.
 * @param nowMs The current time in the timebase of {@link SystemClock#elapsedRealtime()}.
 */
protected final boolean isBlacklisted(int index,long nowMs){
  return blacklistUntilTimes[index] > nowMs;
}",0.9985652797704448
110300,"private void setCaptionMode(int captionMode){
  if (this.captionMode == captionMode) {
    return;
  }
  this.captionMode=captionMode;
  resetCueBuilders();
  if (captionMode == CC_MODE_ROLL_UP || captionMode == CC_MODE_UNKNOWN) {
    cues=null;
  }
}","private void setCaptionMode(int captionMode){
  if (this.captionMode == captionMode) {
    return;
  }
  int oldCaptionMode=this.captionMode;
  this.captionMode=captionMode;
  resetCueBuilders();
  if (oldCaptionMode == CC_MODE_PAINT_ON || captionMode == CC_MODE_ROLL_UP || captionMode == CC_MODE_UNKNOWN) {
    cues=null;
  }
}",0.8635578583765112
110301,"@Override protected void decode(SubtitleInputBuffer inputBuffer){
  ccData.reset(inputBuffer.data.array(),inputBuffer.data.limit());
  while (ccData.bytesLeft() >= 3) {
    int ccTypeAndValid=(ccData.readUnsignedByte() & 0x07);
    int ccType=ccTypeAndValid & (DTVCC_PACKET_DATA | DTVCC_PACKET_START);
    boolean ccValid=(ccTypeAndValid & CC_VALID_FLAG) == CC_VALID_FLAG;
    byte ccData1=(byte)ccData.readUnsignedByte();
    byte ccData2=(byte)ccData.readUnsignedByte();
    if (ccType != DTVCC_PACKET_DATA && ccType != DTVCC_PACKET_START) {
      continue;
    }
    if (!ccValid) {
      finalizeCurrentPacket();
      continue;
    }
    if (ccType == DTVCC_PACKET_START) {
      finalizeCurrentPacket();
      int sequenceNumber=(ccData1 & 0xC0) >> 6;
      int packetSize=ccData1 & 0x3F;
      if (packetSize == 0) {
        packetSize=64;
      }
      currentDtvCcPacket=new DtvCcPacket(sequenceNumber,packetSize);
      currentDtvCcPacket.packetData[currentDtvCcPacket.currentIndex++]=ccData2;
    }
 else {
      Assertions.checkArgument(ccType == DTVCC_PACKET_DATA);
      if (currentDtvCcPacket == null) {
        Log.e(TAG,""String_Node_Str"");
        continue;
      }
      currentDtvCcPacket.packetData[currentDtvCcPacket.currentIndex++]=ccData1;
      currentDtvCcPacket.packetData[currentDtvCcPacket.currentIndex++]=ccData2;
    }
    if (currentDtvCcPacket.currentIndex == (currentDtvCcPacket.packetSize * 2 - 1)) {
      finalizeCurrentPacket();
    }
  }
}","@Override protected void decode(SubtitleInputBuffer inputBuffer){
  ccData.reset(inputBuffer.data.array(),inputBuffer.data.limit());
  while (ccData.bytesLeft() >= 3) {
    int ccTypeAndValid=(ccData.readUnsignedByte() & 0x07);
    int ccType=ccTypeAndValid & (DTVCC_PACKET_DATA | DTVCC_PACKET_START);
    boolean ccValid=(ccTypeAndValid & CC_VALID_FLAG) == CC_VALID_FLAG;
    byte ccData1=(byte)ccData.readUnsignedByte();
    byte ccData2=(byte)ccData.readUnsignedByte();
    if (ccType != DTVCC_PACKET_DATA && ccType != DTVCC_PACKET_START) {
      continue;
    }
    if (!ccValid) {
      continue;
    }
    if (ccType == DTVCC_PACKET_START) {
      finalizeCurrentPacket();
      int sequenceNumber=(ccData1 & 0xC0) >> 6;
      int packetSize=ccData1 & 0x3F;
      if (packetSize == 0) {
        packetSize=64;
      }
      currentDtvCcPacket=new DtvCcPacket(sequenceNumber,packetSize);
      currentDtvCcPacket.packetData[currentDtvCcPacket.currentIndex++]=ccData2;
    }
 else {
      Assertions.checkArgument(ccType == DTVCC_PACKET_DATA);
      if (currentDtvCcPacket == null) {
        Log.e(TAG,""String_Node_Str"");
        continue;
      }
      currentDtvCcPacket.packetData[currentDtvCcPacket.currentIndex++]=ccData1;
      currentDtvCcPacket.packetData[currentDtvCcPacket.currentIndex++]=ccData2;
    }
    if (currentDtvCcPacket.currentIndex == (currentDtvCcPacket.packetSize * 2 - 1)) {
      finalizeCurrentPacket();
    }
  }
}",0.989394457748888
110302,"private void processCurrentPacket(){
  if (currentDtvCcPacket.currentIndex != (currentDtvCcPacket.packetSize * 2 - 1)) {
    Log.w(TAG,""String_Node_Str"" + (currentDtvCcPacket.packetSize * 2 - 1) + ""String_Node_Str""+ currentDtvCcPacket.currentIndex+ ""String_Node_Str""+ currentDtvCcPacket.sequenceNumber+ ""String_Node_Str"");
  }
  serviceBlockPacket.reset(currentDtvCcPacket.packetData,currentDtvCcPacket.currentIndex);
  int serviceNumber=serviceBlockPacket.readBits(3);
  int blockSize=serviceBlockPacket.readBits(5);
  if (serviceNumber == 7) {
    serviceBlockPacket.skipBits(2);
    serviceNumber+=serviceBlockPacket.readBits(6);
  }
  if (blockSize == 0) {
    if (serviceNumber != 0) {
      Log.w(TAG,""String_Node_Str"" + serviceNumber + ""String_Node_Str"");
    }
    return;
  }
  if (serviceNumber != selectedServiceNumber) {
    return;
  }
  while (serviceBlockPacket.bitsLeft() > 0) {
    int command=serviceBlockPacket.readBits(8);
    if (command != COMMAND_EXT1) {
      if (command <= GROUP_C0_END) {
        handleC0Command(command);
      }
 else       if (command <= GROUP_G0_END) {
        handleG0Character(command);
      }
 else       if (command <= GROUP_C1_END) {
        handleC1Command(command);
        cues=getDisplayCues();
      }
 else       if (command <= GROUP_G1_END) {
        handleG1Character(command);
      }
 else {
        Log.w(TAG,""String_Node_Str"" + command);
      }
    }
 else {
      command=serviceBlockPacket.readBits(8);
      if (command <= GROUP_C2_END) {
        handleC2Command(command);
      }
 else       if (command <= GROUP_G2_END) {
        handleG2Character(command);
      }
 else       if (command <= GROUP_C3_END) {
        handleC3Command(command);
      }
 else       if (command <= GROUP_G3_END) {
        handleG3Character(command);
      }
 else {
        Log.w(TAG,""String_Node_Str"" + command);
      }
    }
  }
}","private void processCurrentPacket(){
  if (currentDtvCcPacket.currentIndex != (currentDtvCcPacket.packetSize * 2 - 1)) {
    Log.w(TAG,""String_Node_Str"" + (currentDtvCcPacket.packetSize * 2 - 1) + ""String_Node_Str""+ currentDtvCcPacket.currentIndex+ ""String_Node_Str""+ currentDtvCcPacket.sequenceNumber+ ""String_Node_Str"");
    return;
  }
  serviceBlockPacket.reset(currentDtvCcPacket.packetData,currentDtvCcPacket.currentIndex);
  int serviceNumber=serviceBlockPacket.readBits(3);
  int blockSize=serviceBlockPacket.readBits(5);
  if (serviceNumber == 7) {
    serviceBlockPacket.skipBits(2);
    serviceNumber+=serviceBlockPacket.readBits(6);
  }
  if (blockSize == 0) {
    if (serviceNumber != 0) {
      Log.w(TAG,""String_Node_Str"" + serviceNumber + ""String_Node_Str"");
    }
    return;
  }
  if (serviceNumber != selectedServiceNumber) {
    return;
  }
  while (serviceBlockPacket.bitsLeft() > 0) {
    int command=serviceBlockPacket.readBits(8);
    if (command != COMMAND_EXT1) {
      if (command <= GROUP_C0_END) {
        handleC0Command(command);
      }
 else       if (command <= GROUP_G0_END) {
        handleG0Character(command);
      }
 else       if (command <= GROUP_C1_END) {
        handleC1Command(command);
        cues=getDisplayCues();
      }
 else       if (command <= GROUP_G1_END) {
        handleG1Character(command);
      }
 else {
        Log.w(TAG,""String_Node_Str"" + command);
      }
    }
 else {
      command=serviceBlockPacket.readBits(8);
      if (command <= GROUP_C2_END) {
        handleC2Command(command);
      }
 else       if (command <= GROUP_G2_END) {
        handleG2Character(command);
      }
 else       if (command <= GROUP_C3_END) {
        handleC3Command(command);
      }
 else       if (command <= GROUP_G3_END) {
        handleG3Character(command);
      }
 else {
        Log.w(TAG,""String_Node_Str"" + command);
      }
    }
  }
}",0.9968253968253968
110303,"@Override public void onPositionDiscontinuity(){
}","@Override public void onPositionDiscontinuity(){
  if (playerNeedsSource) {
    updateResumePosition();
  }
}",0.6289308176100629
110304,"@Override public void render(long positionUs,long elapsedRealtimeUs) throws ExoPlaybackException {
  if (outputStreamEnded) {
    return;
  }
  if (nextSubtitle == null) {
    decoder.setPositionUs(positionUs);
    try {
      nextSubtitle=decoder.dequeueOutputBuffer();
    }
 catch (    SubtitleDecoderException e) {
      throw ExoPlaybackException.createForRenderer(e,getIndex());
    }
  }
  if (getState() != STATE_STARTED) {
    return;
  }
  boolean textRendererNeedsUpdate=false;
  if (subtitle != null) {
    long subtitleNextEventTimeUs=getNextEventTime();
    while (subtitleNextEventTimeUs <= positionUs) {
      nextSubtitleEventIndex++;
      subtitleNextEventTimeUs=getNextEventTime();
      textRendererNeedsUpdate=true;
    }
  }
  if (nextSubtitle != null) {
    if (nextSubtitle.isEndOfStream()) {
      if (!textRendererNeedsUpdate && getNextEventTime() == Long.MAX_VALUE) {
        if (subtitle != null) {
          subtitle.release();
          subtitle=null;
        }
        nextSubtitle.release();
        nextSubtitle=null;
        outputStreamEnded=true;
      }
    }
 else     if (nextSubtitle.timeUs <= positionUs) {
      if (subtitle != null) {
        subtitle.release();
      }
      subtitle=nextSubtitle;
      nextSubtitle=null;
      nextSubtitleEventIndex=subtitle.getNextEventTimeIndex(positionUs);
      textRendererNeedsUpdate=true;
    }
  }
  if (textRendererNeedsUpdate) {
    updateOutput(subtitle.getCues(positionUs));
  }
  try {
    while (!inputStreamEnded) {
      if (nextInputBuffer == null) {
        nextInputBuffer=decoder.dequeueInputBuffer();
        if (nextInputBuffer == null) {
          return;
        }
      }
      int result=readSource(formatHolder,nextInputBuffer);
      if (result == C.RESULT_BUFFER_READ) {
        nextInputBuffer.clearFlag(C.BUFFER_FLAG_DECODE_ONLY);
        if (nextInputBuffer.isEndOfStream()) {
          inputStreamEnded=true;
        }
 else {
          nextInputBuffer.subsampleOffsetUs=formatHolder.format.subsampleOffsetUs;
          nextInputBuffer.flip();
        }
        decoder.queueInputBuffer(nextInputBuffer);
        nextInputBuffer=null;
      }
 else       if (result == C.RESULT_NOTHING_READ) {
        break;
      }
    }
  }
 catch (  SubtitleDecoderException e) {
    throw ExoPlaybackException.createForRenderer(e,getIndex());
  }
}","@Override public void render(long positionUs,long elapsedRealtimeUs) throws ExoPlaybackException {
  if (outputStreamEnded) {
    return;
  }
  if (nextSubtitle == null) {
    decoder.setPositionUs(positionUs);
    try {
      nextSubtitle=decoder.dequeueOutputBuffer();
    }
 catch (    SubtitleDecoderException e) {
      throw ExoPlaybackException.createForRenderer(e,getIndex());
    }
  }
  if (getState() != STATE_STARTED) {
    return;
  }
  boolean textRendererNeedsUpdate=false;
  if (subtitle != null) {
    long subtitleNextEventTimeUs=getNextEventTime();
    while (subtitleNextEventTimeUs <= positionUs) {
      nextSubtitleEventIndex++;
      subtitleNextEventTimeUs=getNextEventTime();
      textRendererNeedsUpdate=true;
    }
  }
  if (nextSubtitle != null) {
    if (nextSubtitle.isEndOfStream()) {
      if (!textRendererNeedsUpdate && getNextEventTime() == Long.MAX_VALUE) {
        if (subtitle != null) {
          subtitle.release();
          subtitle=null;
        }
        nextSubtitle.release();
        nextSubtitle=null;
        outputStreamEnded=true;
      }
    }
 else     if (nextSubtitle.timeUs <= positionUs) {
      if (subtitle != null) {
        subtitle.release();
      }
      subtitle=nextSubtitle;
      nextSubtitle=null;
      nextSubtitleEventIndex=subtitle.getNextEventTimeIndex(positionUs);
      textRendererNeedsUpdate=true;
    }
  }
  if (textRendererNeedsUpdate) {
    updateOutput(subtitle.getCues(positionUs));
  }
  try {
    while (!inputStreamEnded) {
      if (nextInputBuffer == null) {
        nextInputBuffer=decoder.dequeueInputBuffer();
        if (nextInputBuffer == null) {
          return;
        }
      }
      int result=readSource(formatHolder,nextInputBuffer);
      if (result == C.RESULT_BUFFER_READ) {
        if (nextInputBuffer.isEndOfStream()) {
          inputStreamEnded=true;
        }
 else {
          nextInputBuffer.subsampleOffsetUs=formatHolder.format.subsampleOffsetUs;
          nextInputBuffer.flip();
        }
        decoder.queueInputBuffer(nextInputBuffer);
        nextInputBuffer=null;
      }
 else       if (result == C.RESULT_NOTHING_READ) {
        break;
      }
    }
  }
 catch (  SubtitleDecoderException e) {
    throw ExoPlaybackException.createForRenderer(e,getIndex());
  }
}",0.9866379310344828
110305,"@Override public void queueInputBuffer(SubtitleInputBuffer inputBuffer) throws SubtitleDecoderException {
  Assertions.checkArgument(inputBuffer != null);
  Assertions.checkArgument(inputBuffer == dequeuedInputBuffer);
  queuedInputBuffers.add(inputBuffer);
  dequeuedInputBuffer=null;
}","@Override public void queueInputBuffer(SubtitleInputBuffer inputBuffer) throws SubtitleDecoderException {
  Assertions.checkArgument(inputBuffer != null);
  Assertions.checkArgument(inputBuffer == dequeuedInputBuffer);
  if (inputBuffer.isDecodeOnly()) {
    releaseInputBuffer(inputBuffer);
  }
 else {
    queuedInputBuffers.add(inputBuffer);
  }
  dequeuedInputBuffer=null;
}",0.8631578947368421
110306,"private void onMoovContainerAtomRead(ContainerAtom moov) throws ParserException {
  Assertions.checkState(sideloadedTrack == null,""String_Node_Str"");
  DrmInitData drmInitData=getDrmInitDataFromAtoms(moov.leafChildren);
  ContainerAtom mvex=moov.getContainerAtomOfType(Atom.TYPE_mvex);
  SparseArray<DefaultSampleValues> defaultSampleValuesArray=new SparseArray<>();
  long duration=C.TIME_UNSET;
  int mvexChildrenSize=mvex.leafChildren.size();
  for (int i=0; i < mvexChildrenSize; i++) {
    Atom.LeafAtom atom=mvex.leafChildren.get(i);
    if (atom.type == Atom.TYPE_trex) {
      Pair<Integer,DefaultSampleValues> trexData=parseTrex(atom.data);
      defaultSampleValuesArray.put(trexData.first,trexData.second);
    }
 else     if (atom.type == Atom.TYPE_mehd) {
      duration=parseMehd(atom.data);
    }
  }
  SparseArray<Track> tracks=new SparseArray<>();
  int moovContainerChildrenSize=moov.containerChildren.size();
  for (int i=0; i < moovContainerChildrenSize; i++) {
    Atom.ContainerAtom atom=moov.containerChildren.get(i);
    if (atom.type == Atom.TYPE_trak) {
      Track track=AtomParsers.parseTrak(atom,moov.getLeafAtomOfType(Atom.TYPE_mvhd),duration,drmInitData,false);
      if (track != null) {
        tracks.put(track.id,track);
      }
    }
  }
  int trackCount=tracks.size();
  if (trackBundles.size() == 0) {
    for (int i=0; i < trackCount; i++) {
      Track track=tracks.valueAt(i);
      trackBundles.put(track.id,new TrackBundle(extractorOutput.track(i)));
      durationUs=Math.max(durationUs,track.durationUs);
    }
    maybeInitExtraTracks();
    extractorOutput.endTracks();
  }
 else {
    Assertions.checkState(trackBundles.size() == trackCount);
  }
  for (int i=0; i < trackCount; i++) {
    Track track=tracks.valueAt(i);
    trackBundles.get(track.id).init(track,defaultSampleValuesArray.get(track.id));
  }
}","private void onMoovContainerAtomRead(ContainerAtom moov) throws ParserException {
  Assertions.checkState(sideloadedTrack == null,""String_Node_Str"");
  DrmInitData drmInitData=getDrmInitDataFromAtoms(moov.leafChildren);
  ContainerAtom mvex=moov.getContainerAtomOfType(Atom.TYPE_mvex);
  SparseArray<DefaultSampleValues> defaultSampleValuesArray=new SparseArray<>();
  long duration=C.TIME_UNSET;
  int mvexChildrenSize=mvex.leafChildren.size();
  for (int i=0; i < mvexChildrenSize; i++) {
    Atom.LeafAtom atom=mvex.leafChildren.get(i);
    if (atom.type == Atom.TYPE_trex) {
      Pair<Integer,DefaultSampleValues> trexData=parseTrex(atom.data);
      defaultSampleValuesArray.put(trexData.first,trexData.second);
    }
 else     if (atom.type == Atom.TYPE_mehd) {
      duration=parseMehd(atom.data);
    }
  }
  SparseArray<Track> tracks=new SparseArray<>();
  int moovContainerChildrenSize=moov.containerChildren.size();
  for (int i=0; i < moovContainerChildrenSize; i++) {
    Atom.ContainerAtom atom=moov.containerChildren.get(i);
    if (atom.type == Atom.TYPE_trak) {
      Track track=AtomParsers.parseTrak(atom,moov.getLeafAtomOfType(Atom.TYPE_mvhd),duration,drmInitData,false);
      if (track != null) {
        tracks.put(track.id,track);
      }
    }
  }
  int trackCount=tracks.size();
  if (trackBundles.size() == 0) {
    for (int i=0; i < trackCount; i++) {
      Track track=tracks.valueAt(i);
      TrackBundle trackBundle=new TrackBundle(extractorOutput.track(i));
      trackBundle.init(track,defaultSampleValuesArray.get(track.id));
      trackBundles.put(track.id,trackBundle);
      durationUs=Math.max(durationUs,track.durationUs);
    }
    maybeInitExtraTracks();
    extractorOutput.endTracks();
  }
 else {
    Assertions.checkState(trackBundles.size() == trackCount);
    for (int i=0; i < trackCount; i++) {
      Track track=tracks.valueAt(i);
      trackBundles.get(track.id).init(track,defaultSampleValuesArray.get(track.id));
    }
  }
}",0.9434159061277704
110307,"private void maybeInitExtraTracks(){
  if ((flags & FLAG_ENABLE_EMSG_TRACK) != 0 && eventMessageTrackOutput == null) {
    eventMessageTrackOutput=extractorOutput.track(trackBundles.size());
    eventMessageTrackOutput.format(Format.createSampleFormat(null,MimeTypes.APPLICATION_EMSG,Format.OFFSET_SAMPLE_RELATIVE));
  }
  if ((flags & FLAG_ENABLE_CEA608_TRACK) != 0 && cea608TrackOutput == null) {
    cea608TrackOutput=extractorOutput.track(trackBundles.size());
    cea608TrackOutput.format(Format.createTextSampleFormat(null,MimeTypes.APPLICATION_CEA608,null,Format.NO_VALUE,0,null,null));
  }
}","private void maybeInitExtraTracks(){
  if ((flags & FLAG_ENABLE_EMSG_TRACK) != 0 && eventMessageTrackOutput == null) {
    eventMessageTrackOutput=extractorOutput.track(trackBundles.size());
    eventMessageTrackOutput.format(Format.createSampleFormat(null,MimeTypes.APPLICATION_EMSG,Format.OFFSET_SAMPLE_RELATIVE));
  }
  if ((flags & FLAG_ENABLE_CEA608_TRACK) != 0 && cea608TrackOutput == null) {
    cea608TrackOutput=extractorOutput.track(trackBundles.size() + 1);
    cea608TrackOutput.format(Format.createTextSampleFormat(null,MimeTypes.APPLICATION_CEA608,null,Format.NO_VALUE,0,null,null));
  }
}",0.9966722129783694
110308,"private void onKeyResponse(Object response){
  if (state != STATE_OPENED && state != STATE_OPENED_WITH_KEYS) {
    return;
  }
  if (response instanceof Exception) {
    onKeysError((Exception)response);
    return;
  }
  try {
    if (mode == MODE_RELEASE) {
      mediaDrm.provideKeyResponse(offlineLicenseKeySetId,(byte[])response);
      if (eventHandler != null && eventListener != null) {
        eventHandler.post(new Runnable(){
          @Override public void run(){
            eventListener.onDrmKeysRemoved();
          }
        }
);
      }
    }
 else {
      byte[] keySetId=mediaDrm.provideKeyResponse(sessionId,(byte[])response);
      if (offlineLicenseKeySetId != null && (keySetId == null || keySetId.length == 0)) {
      }
 else {
        offlineLicenseKeySetId=keySetId;
      }
      state=STATE_OPENED_WITH_KEYS;
      if (eventHandler != null && eventListener != null) {
        eventHandler.post(new Runnable(){
          @Override public void run(){
            eventListener.onDrmKeysLoaded();
          }
        }
);
      }
    }
  }
 catch (  Exception e) {
    onKeysError(e);
  }
}","private void onKeyResponse(Object response){
  if (state != STATE_OPENED && state != STATE_OPENED_WITH_KEYS) {
    return;
  }
  if (response instanceof Exception) {
    onKeysError((Exception)response);
    return;
  }
  try {
    if (mode == MODE_RELEASE) {
      mediaDrm.provideKeyResponse(offlineLicenseKeySetId,(byte[])response);
      if (eventHandler != null && eventListener != null) {
        eventHandler.post(new Runnable(){
          @Override public void run(){
            eventListener.onDrmKeysRemoved();
          }
        }
);
      }
    }
 else {
      byte[] keySetId=mediaDrm.provideKeyResponse(sessionId,(byte[])response);
      if (keySetId != null && keySetId.length != 0) {
        offlineLicenseKeySetId=keySetId;
      }
      state=STATE_OPENED_WITH_KEYS;
      if (eventHandler != null && eventListener != null) {
        eventHandler.post(new Runnable(){
          @Override public void run(){
            eventListener.onDrmKeysLoaded();
          }
        }
);
      }
    }
  }
 catch (  Exception e) {
    onKeysError(e);
  }
}",0.9743354720439964
110309,"private void printMetadata(Metadata metadata,String prefix){
  for (int i=0; i < metadata.length(); i++) {
    Metadata.Entry entry=metadata.get(i);
    if (entry instanceof TextInformationFrame) {
      TextInformationFrame textInformationFrame=(TextInformationFrame)entry;
      Log.d(TAG,prefix + String.format(""String_Node_Str"",textInformationFrame.id,textInformationFrame.value));
    }
 else     if (entry instanceof PrivFrame) {
      PrivFrame privFrame=(PrivFrame)entry;
      Log.d(TAG,prefix + String.format(""String_Node_Str"",privFrame.id,privFrame.owner));
    }
 else     if (entry instanceof GeobFrame) {
      GeobFrame geobFrame=(GeobFrame)entry;
      Log.d(TAG,prefix + String.format(""String_Node_Str"",geobFrame.id,geobFrame.mimeType,geobFrame.filename,geobFrame.description));
    }
 else     if (entry instanceof ApicFrame) {
      ApicFrame apicFrame=(ApicFrame)entry;
      Log.d(TAG,prefix + String.format(""String_Node_Str"",apicFrame.id,apicFrame.mimeType,apicFrame.description));
    }
 else     if (entry instanceof CommentFrame) {
      CommentFrame commentFrame=(CommentFrame)entry;
      Log.d(TAG,prefix + String.format(""String_Node_Str"",commentFrame.id,commentFrame.language,commentFrame.description));
    }
 else     if (entry instanceof Id3Frame) {
      Id3Frame id3Frame=(Id3Frame)entry;
      Log.d(TAG,prefix + String.format(""String_Node_Str"",id3Frame.id));
    }
  }
}","private void printMetadata(Metadata metadata,String prefix){
  for (int i=0; i < metadata.length(); i++) {
    Metadata.Entry entry=metadata.get(i);
    if (entry instanceof TextInformationFrame) {
      TextInformationFrame textInformationFrame=(TextInformationFrame)entry;
      Log.d(TAG,prefix + String.format(""String_Node_Str"",textInformationFrame.id,textInformationFrame.value));
    }
 else     if (entry instanceof UrlLinkFrame) {
      UrlLinkFrame urlLinkFrame=(UrlLinkFrame)entry;
      Log.d(TAG,prefix + String.format(""String_Node_Str"",urlLinkFrame.id,urlLinkFrame.url));
    }
 else     if (entry instanceof PrivFrame) {
      PrivFrame privFrame=(PrivFrame)entry;
      Log.d(TAG,prefix + String.format(""String_Node_Str"",privFrame.id,privFrame.owner));
    }
 else     if (entry instanceof GeobFrame) {
      GeobFrame geobFrame=(GeobFrame)entry;
      Log.d(TAG,prefix + String.format(""String_Node_Str"",geobFrame.id,geobFrame.mimeType,geobFrame.filename,geobFrame.description));
    }
 else     if (entry instanceof ApicFrame) {
      ApicFrame apicFrame=(ApicFrame)entry;
      Log.d(TAG,prefix + String.format(""String_Node_Str"",apicFrame.id,apicFrame.mimeType,apicFrame.description));
    }
 else     if (entry instanceof CommentFrame) {
      CommentFrame commentFrame=(CommentFrame)entry;
      Log.d(TAG,prefix + String.format(""String_Node_Str"",commentFrame.id,commentFrame.language,commentFrame.description));
    }
 else     if (entry instanceof Id3Frame) {
      Id3Frame id3Frame=(Id3Frame)entry;
      Log.d(TAG,prefix + String.format(""String_Node_Str"",id3Frame.id));
    }
  }
}",0.7412819661242113
110310,"private static ChapterFrame decodeChapterFrame(ParsableByteArray id3Data,int frameSize,int majorVersion,boolean unsignedIntFrameSizeHack,int frameHeaderSize) throws UnsupportedEncodingException {
  int framePosition=id3Data.getPosition();
  int chapterIdEndIndex=indexOfZeroByte(id3Data.data,framePosition);
  String chapterId=new String(id3Data.data,framePosition,chapterIdEndIndex - framePosition,""String_Node_Str"");
  id3Data.setPosition(chapterIdEndIndex + 1);
  int startTime=id3Data.readUnsignedByte();
  int endTime=id3Data.readUnsignedByte();
  int startOffset=id3Data.readUnsignedByte();
  int endOffset=id3Data.readUnsignedByte();
  ArrayList<Id3Frame> subFrames=new ArrayList<>();
  int limit=framePosition + frameSize;
  while (id3Data.getPosition() < limit) {
    Id3Frame frame=decodeFrame(majorVersion,id3Data,unsignedIntFrameSizeHack,frameHeaderSize);
    if (frame != null) {
      subFrames.add(frame);
    }
  }
  Id3Frame[] subFrameArray=new Id3Frame[subFrames.size()];
  subFrames.toArray(subFrameArray);
  return new ChapterFrame(chapterId,startTime,endTime,startOffset,endOffset,subFrameArray);
}","private static ChapterFrame decodeChapterFrame(ParsableByteArray id3Data,int frameSize,int majorVersion,boolean unsignedIntFrameSizeHack,int frameHeaderSize) throws UnsupportedEncodingException {
  int framePosition=id3Data.getPosition();
  int chapterIdEndIndex=indexOfZeroByte(id3Data.data,framePosition);
  String chapterId=new String(id3Data.data,framePosition,chapterIdEndIndex - framePosition,""String_Node_Str"");
  id3Data.setPosition(chapterIdEndIndex + 1);
  int startTime=id3Data.readInt();
  int endTime=id3Data.readInt();
  int startOffset=id3Data.readInt();
  int endOffset=id3Data.readInt();
  ArrayList<Id3Frame> subFrames=new ArrayList<>();
  int limit=framePosition + frameSize;
  while (id3Data.getPosition() < limit) {
    Id3Frame frame=decodeFrame(majorVersion,id3Data,unsignedIntFrameSizeHack,frameHeaderSize);
    if (frame != null) {
      subFrames.add(frame);
    }
  }
  Id3Frame[] subFrameArray=new Id3Frame[subFrames.size()];
  subFrames.toArray(subFrameArray);
  return new ChapterFrame(chapterId,startTime,endTime,startOffset,endOffset,subFrameArray);
}",0.9727520435967304
110311,"private static UrlLinkFrame decodeWxxxFrame(ParsableByteArray id3Data,int frameSize) throws UnsupportedEncodingException {
  int encoding=id3Data.readUnsignedByte();
  String charset=getCharsetName(encoding);
  byte[] data=new byte[frameSize - 1];
  id3Data.readBytes(data,0,frameSize - 1);
  int descriptionEndIndex=indexOfEos(data,0,encoding);
  String description=new String(data,0,descriptionEndIndex,charset);
  String url;
  int urlStartIndex=descriptionEndIndex + delimiterLength(encoding);
  if (urlStartIndex < data.length) {
    int urlEndIndex=indexOfZeroByte(data,0);
    url=new String(data,urlStartIndex,urlEndIndex - urlStartIndex,""String_Node_Str"");
  }
 else {
    url=""String_Node_Str"";
  }
  return new UrlLinkFrame(""String_Node_Str"",description,url);
}","private static UrlLinkFrame decodeWxxxFrame(ParsableByteArray id3Data,int frameSize) throws UnsupportedEncodingException {
  int encoding=id3Data.readUnsignedByte();
  String charset=getCharsetName(encoding);
  byte[] data=new byte[frameSize - 1];
  id3Data.readBytes(data,0,frameSize - 1);
  int descriptionEndIndex=indexOfEos(data,0,encoding);
  String description=new String(data,0,descriptionEndIndex,charset);
  String url;
  int urlStartIndex=descriptionEndIndex + delimiterLength(encoding);
  if (urlStartIndex < data.length) {
    int urlEndIndex=indexOfZeroByte(data,urlStartIndex);
    url=new String(data,urlStartIndex,urlEndIndex - urlStartIndex,""String_Node_Str"");
  }
 else {
    url=""String_Node_Str"";
  }
  return new UrlLinkFrame(""String_Node_Str"",description,url);
}",0.9910025706940874
110312,"private static ChapterTOCFrame decodeChapterTOCFrame(ParsableByteArray id3Data,int frameSize,int majorVersion,boolean unsignedIntFrameSizeHack,int frameHeaderSize) throws UnsupportedEncodingException {
  int framePosition=id3Data.getPosition();
  int elementIdEndIndex=indexOfZeroByte(id3Data.data,framePosition);
  String elementId=new String(id3Data.data,framePosition,elementIdEndIndex - framePosition,""String_Node_Str"");
  id3Data.setPosition(elementIdEndIndex + 1);
  int ctocFlags=id3Data.readUnsignedByte();
  boolean isRoot=(ctocFlags & 0x0002) != 0;
  boolean isOrdered=(ctocFlags & 0x0001) != 0;
  int childCount=id3Data.readUnsignedByte();
  String[] children=new String[childCount];
  for (int i=0; i < childCount; i++) {
    int startIndex=id3Data.getPosition();
    int endIndex=indexOfZeroByte(id3Data.data,startIndex);
    children[i]=new String(id3Data.data,startIndex,endIndex - startIndex,""String_Node_Str"");
  }
  ArrayList<Id3Frame> subFrames=new ArrayList<>();
  int limit=framePosition + frameSize;
  while (id3Data.getPosition() < limit) {
    Id3Frame frame=decodeFrame(majorVersion,id3Data,unsignedIntFrameSizeHack,frameHeaderSize);
    if (frame != null) {
      subFrames.add(frame);
    }
  }
  Id3Frame[] subFrameArray=new Id3Frame[subFrames.size()];
  subFrames.toArray(subFrameArray);
  return new ChapterTOCFrame(elementId,isRoot,isOrdered,children,subFrameArray);
}","private static ChapterTOCFrame decodeChapterTOCFrame(ParsableByteArray id3Data,int frameSize,int majorVersion,boolean unsignedIntFrameSizeHack,int frameHeaderSize) throws UnsupportedEncodingException {
  int framePosition=id3Data.getPosition();
  int elementIdEndIndex=indexOfZeroByte(id3Data.data,framePosition);
  String elementId=new String(id3Data.data,framePosition,elementIdEndIndex - framePosition,""String_Node_Str"");
  id3Data.setPosition(elementIdEndIndex + 1);
  int ctocFlags=id3Data.readUnsignedByte();
  boolean isRoot=(ctocFlags & 0x0002) != 0;
  boolean isOrdered=(ctocFlags & 0x0001) != 0;
  int childCount=id3Data.readUnsignedByte();
  String[] children=new String[childCount];
  for (int i=0; i < childCount; i++) {
    int startIndex=id3Data.getPosition();
    int endIndex=indexOfZeroByte(id3Data.data,startIndex);
    children[i]=new String(id3Data.data,startIndex,endIndex - startIndex,""String_Node_Str"");
    id3Data.setPosition(endIndex + 1);
  }
  ArrayList<Id3Frame> subFrames=new ArrayList<>();
  int limit=framePosition + frameSize;
  while (id3Data.getPosition() < limit) {
    Id3Frame frame=decodeFrame(majorVersion,id3Data,unsignedIntFrameSizeHack,frameHeaderSize);
    if (frame != null) {
      subFrames.add(frame);
    }
  }
  Id3Frame[] subFrameArray=new Id3Frame[subFrames.size()];
  subFrames.toArray(subFrameArray);
  return new ChapterTOCFrame(elementId,isRoot,isOrdered,children,subFrameArray);
}",0.9862530842439196
110313,"private void handlePreambleAddressCode(byte cc1,byte cc2){
  int row=ROW_INDICES[cc1 & 0x07];
  boolean nextRowDown=(cc2 & 0x20) != 0;
  if (row != currentCueBuilder.getRow() || nextRowDown) {
    if (!currentCueBuilder.isEmpty()) {
      currentCueBuilder=new CueBuilder(captionMode,captionRowCount);
      cueBuilders.add(currentCueBuilder);
    }
    currentCueBuilder.setRow(nextRowDown ? ++row : row);
  }
  if ((cc2 & 0x01) == 0x01) {
    currentCueBuilder.setPreambleStyle(new UnderlineSpan());
  }
  int attribute=cc2 >> 1 & 0x0F;
  if (attribute <= 0x07) {
    if (attribute == 0x07) {
      currentCueBuilder.setPreambleStyle(new StyleSpan(Typeface.ITALIC));
      currentCueBuilder.setPreambleStyle(new ForegroundColorSpan(Color.WHITE));
    }
 else {
      currentCueBuilder.setPreambleStyle(new ForegroundColorSpan(COLORS[attribute]));
    }
  }
 else {
    currentCueBuilder.setIndent(COLUMN_INDICES[attribute & 0x07]);
  }
}","private void handlePreambleAddressCode(byte cc1,byte cc2){
  int row=ROW_INDICES[cc1 & 0x07];
  boolean nextRowDown=(cc2 & 0x20) != 0;
  if (row != currentCueBuilder.getRow() || nextRowDown) {
    if (captionMode != CC_MODE_ROLL_UP && !currentCueBuilder.isEmpty()) {
      currentCueBuilder=new CueBuilder(captionMode,captionRowCount);
      cueBuilders.add(currentCueBuilder);
    }
    currentCueBuilder.setRow(nextRowDown ? ++row : row);
  }
  if ((cc2 & 0x01) == 0x01) {
    currentCueBuilder.setPreambleStyle(new UnderlineSpan());
  }
  int attribute=cc2 >> 1 & 0x0F;
  if (attribute <= 0x07) {
    if (attribute == 0x07) {
      currentCueBuilder.setPreambleStyle(new StyleSpan(Typeface.ITALIC));
      currentCueBuilder.setPreambleStyle(new ForegroundColorSpan(Color.WHITE));
    }
 else {
      currentCueBuilder.setPreambleStyle(new ForegroundColorSpan(COLORS[attribute]));
    }
  }
 else {
    currentCueBuilder.setIndent(COLUMN_INDICES[attribute & 0x07]);
  }
}",0.9822175732217572
110314,"/** 
 * Attempts to locate the keyframe before the specified time, if it's present in the buffer.
 * @param timeUs The seek time.
 * @return The offset of the keyframe's data if the keyframe was present.{@link C#POSITION_UNSET} otherwise.
 */
public synchronized long skipToKeyframeBefore(long timeUs){
  if (queueSize == 0 || timeUs < timesUs[relativeReadIndex]) {
    return C.POSITION_UNSET;
  }
  int lastWriteIndex=(relativeWriteIndex == 0 ? capacity : relativeWriteIndex) - 1;
  long lastTimeUs=timesUs[lastWriteIndex];
  if (timeUs > lastTimeUs) {
    return C.POSITION_UNSET;
  }
  int sampleCount=0;
  int sampleCountToKeyframe=-1;
  int searchIndex=relativeReadIndex;
  while (searchIndex != relativeWriteIndex) {
    if (timesUs[searchIndex] > timeUs) {
      break;
    }
 else     if ((flags[searchIndex] & C.BUFFER_FLAG_KEY_FRAME) != 0) {
      sampleCountToKeyframe=sampleCount;
    }
    searchIndex=(searchIndex + 1) % capacity;
    sampleCount++;
  }
  if (sampleCountToKeyframe == -1) {
    return C.POSITION_UNSET;
  }
  queueSize-=sampleCountToKeyframe;
  relativeReadIndex=(relativeReadIndex + sampleCountToKeyframe) % capacity;
  absoluteReadIndex+=sampleCountToKeyframe;
  return offsets[relativeReadIndex];
}","/** 
 * Attempts to locate the keyframe before the specified time, if it's present in the buffer.
 * @param timeUs The seek time.
 * @return The offset of the keyframe's data if the keyframe was present.{@link C#POSITION_UNSET} otherwise.
 */
public synchronized long skipToKeyframeBefore(long timeUs){
  if (queueSize == 0 || timeUs < timesUs[relativeReadIndex]) {
    return C.POSITION_UNSET;
  }
  if (timeUs > largestQueuedTimestampUs) {
    return C.POSITION_UNSET;
  }
  int sampleCount=0;
  int sampleCountToKeyframe=-1;
  int searchIndex=relativeReadIndex;
  while (searchIndex != relativeWriteIndex) {
    if (timesUs[searchIndex] > timeUs) {
      break;
    }
 else     if ((flags[searchIndex] & C.BUFFER_FLAG_KEY_FRAME) != 0) {
      sampleCountToKeyframe=sampleCount;
    }
    searchIndex=(searchIndex + 1) % capacity;
    sampleCount++;
  }
  if (sampleCountToKeyframe == -1) {
    return C.POSITION_UNSET;
  }
  queueSize-=sampleCountToKeyframe;
  relativeReadIndex=(relativeReadIndex + sampleCountToKeyframe) % capacity;
  absoluteReadIndex+=sampleCountToKeyframe;
  return offsets[relativeReadIndex];
}",0.9247768805779856
110315,"private static ApicFrame decodeApicFrame(ParsableByteArray id3Data,int frameSize,int majorVersion) throws UnsupportedEncodingException {
  int encoding=id3Data.readUnsignedByte();
  String charset=getCharsetName(encoding);
  byte[] data=new byte[frameSize - 1];
  id3Data.readBytes(data,0,frameSize - 1);
  String mimeType;
  int mimeTypeEndIndex;
  if (majorVersion == 2) {
    mimeTypeEndIndex=2;
    mimeType=""String_Node_Str"" + new String(data,0,3,""String_Node_Str"").toLowerCase();
    if (mimeType.equals(""String_Node_Str"")) {
      mimeType=""String_Node_Str"";
    }
  }
 else {
    mimeTypeEndIndex=indexOfZeroByte(data,0);
    mimeType=new String(data,0,mimeTypeEndIndex,""String_Node_Str"").toLowerCase();
    if (mimeType.indexOf('/') == -1) {
      mimeType=""String_Node_Str"" + mimeType;
    }
  }
  int pictureType=data[mimeTypeEndIndex + 1] & 0xFF;
  int descriptionStartIndex=mimeTypeEndIndex + 2;
  int descriptionEndIndex=indexOfEos(data,descriptionStartIndex,encoding);
  String description=new String(data,descriptionStartIndex,descriptionEndIndex - descriptionStartIndex,charset);
  int pictureDataStartIndex=descriptionEndIndex + delimiterLength(encoding);
  byte[] pictureData=Arrays.copyOfRange(data,pictureDataStartIndex,data.length);
  return new ApicFrame(mimeType,description,pictureType,pictureData);
}","private static ApicFrame decodeApicFrame(ParsableByteArray id3Data,int frameSize,int majorVersion) throws UnsupportedEncodingException {
  int encoding=id3Data.readUnsignedByte();
  String charset=getCharsetName(encoding);
  byte[] data=new byte[frameSize - 1];
  id3Data.readBytes(data,0,frameSize - 1);
  String mimeType;
  int mimeTypeEndIndex;
  if (majorVersion == 2) {
    mimeTypeEndIndex=2;
    mimeType=""String_Node_Str"" + Util.toLowerInvariant(new String(data,0,3,""String_Node_Str""));
    if (mimeType.equals(""String_Node_Str"")) {
      mimeType=""String_Node_Str"";
    }
  }
 else {
    mimeTypeEndIndex=indexOfZeroByte(data,0);
    mimeType=Util.toLowerInvariant(new String(data,0,mimeTypeEndIndex,""String_Node_Str""));
    if (mimeType.indexOf('/') == -1) {
      mimeType=""String_Node_Str"" + mimeType;
    }
  }
  int pictureType=data[mimeTypeEndIndex + 1] & 0xFF;
  int descriptionStartIndex=mimeTypeEndIndex + 2;
  int descriptionEndIndex=indexOfEos(data,descriptionStartIndex,encoding);
  String description=new String(data,descriptionStartIndex,descriptionEndIndex - descriptionStartIndex,charset);
  int pictureDataStartIndex=descriptionEndIndex + delimiterLength(encoding);
  byte[] pictureData=Arrays.copyOfRange(data,pictureDataStartIndex,data.length);
  return new ApicFrame(mimeType,description,pictureType,pictureData);
}",0.9737827715355806
110316,"public void testParseXsDateTime() throws Exception {
  assertEquals(1403219262000L,Util.parseXsDateTime(""String_Node_Str""));
  assertEquals(1407322800000L,Util.parseXsDateTime(""String_Node_Str""));
}","public void testParseXsDateTime() throws Exception {
  assertEquals(1403219262000L,Util.parseXsDateTime(""String_Node_Str""));
  assertEquals(1407322800000L,Util.parseXsDateTime(""String_Node_Str""));
  assertEquals(1411161535000L,Util.parseXsDateTime(""String_Node_Str""));
  assertEquals(1411161535000L,Util.parseXsDateTime(""String_Node_Str""));
}",0.7333333333333333
110317,"private void closeCurrentOutputStream() throws IOException {
  if (outputStream == null) {
    return;
  }
  boolean success=false;
  try {
    outputStream.flush();
    underlyingFileOutputStream.getFD().sync();
    success=true;
  }
  finally {
    Util.closeQuietly(outputStream);
    if (success) {
      cache.commitFile(file);
    }
 else {
      file.delete();
    }
    outputStream=null;
    file=null;
  }
}","@SuppressWarnings(""String_Node_Str"") private void closeCurrentOutputStream() throws IOException {
  if (outputStream == null) {
    return;
  }
  boolean success=false;
  try {
    outputStream.flush();
    underlyingFileOutputStream.getFD().sync();
    success=true;
  }
  finally {
    Util.closeQuietly(outputStream);
    outputStream=null;
    File fileToCommit=file;
    file=null;
    if (success) {
      cache.commitFile(fileToCommit);
    }
 else {
      fileToCommit.delete();
    }
  }
}",0.7628415300546448
110318,"/** 
 * Called when cache has beeen initialized.
 */
void onCacheInitialized();","/** 
 * Called when cache has been initialized.
 */
void onCacheInitialized();",0.9936305732484076
110319,"/** 
 * Converts a   {@link SeekPosition} into the corresponding (periodIndex, periodPositionUs) for theinternal timeline.
 * @param seekPosition The position to resolve.
 * @return The resolved position, or null if resolution was not successful.
 */
private Pair<Integer,Long> resolveSeekPosition(SeekPosition seekPosition){
  Timeline seekTimeline=seekPosition.timeline;
  if (seekTimeline == null) {
    seekTimeline=timeline;
    Assertions.checkIndex(seekPosition.windowIndex,0,timeline.getWindowCount());
  }
  Pair<Integer,Long> periodPosition=getPeriodPosition(seekTimeline,seekPosition.windowIndex,seekPosition.windowPositionUs);
  if (timeline == seekTimeline) {
    return periodPosition;
  }
  int periodIndex=timeline.getIndexOfPeriod(seekTimeline.getPeriod(periodPosition.first,period,true).uid);
  if (periodIndex != C.INDEX_UNSET) {
    return Pair.create(periodIndex,periodPosition.second);
  }
  periodIndex=resolveSubsequentPeriod(periodPosition.first,seekTimeline,timeline);
  if (periodIndex != C.INDEX_UNSET) {
    return getPeriodPosition(timeline.getPeriod(periodIndex,period).windowIndex,C.TIME_UNSET);
  }
  return null;
}","/** 
 * Converts a   {@link SeekPosition} into the corresponding (periodIndex, periodPositionUs) for theinternal timeline.
 * @param seekPosition The position to resolve.
 * @return The resolved position, or null if resolution was not successful.
 */
private Pair<Integer,Long> resolveSeekPosition(SeekPosition seekPosition){
  Timeline seekTimeline=seekPosition.timeline;
  if (seekTimeline.isEmpty()) {
    seekTimeline=timeline;
    Assertions.checkIndex(seekPosition.windowIndex,0,timeline.getWindowCount());
  }
  Pair<Integer,Long> periodPosition=getPeriodPosition(seekTimeline,seekPosition.windowIndex,seekPosition.windowPositionUs);
  if (timeline == seekTimeline) {
    return periodPosition;
  }
  int periodIndex=timeline.getIndexOfPeriod(seekTimeline.getPeriod(periodPosition.first,period,true).uid);
  if (periodIndex != C.INDEX_UNSET) {
    return Pair.create(periodIndex,periodPosition.second);
  }
  periodIndex=resolveSubsequentPeriod(periodPosition.first,seekTimeline,timeline);
  if (periodIndex != C.INDEX_UNSET) {
    return getPeriodPosition(timeline.getPeriod(periodIndex,period).windowIndex,C.TIME_UNSET);
  }
  return null;
}",0.9921671018276762
110320,"/** 
 * Returns the index of the period currently being played, or   {@link C#INDEX_UNSET} if unknown.
 */
int getCurrentPeriodIndex();","/** 
 * Returns the index of the period currently being played.
 */
int getCurrentPeriodIndex();",0.8311688311688312
110321,"/** 
 * Called when timeline and/or manifest has been refreshed.
 * @param timeline The latest timeline, or null if the timeline is being cleared.
 * @param manifest The latest manifest, or null if the manifest is being cleared.
 */
void onTimelineChanged(Timeline timeline,Object manifest);","/** 
 * Called when the timeline and/or manifest has been refreshed. <p> Note that if the timeline has changed then a position discontinuity may also have occurred. For example the current period index may have changed as a result of periods being added or removed from the timeline. The will <em>not</em> be reported via a separate call to  {@link #onPositionDiscontinuity()}.
 * @param timeline The latest timeline, or null if the timeline is being cleared.
 * @param manifest The latest manifest, or null if the manifest is being cleared.
 */
void onTimelineChanged(Timeline timeline,Object manifest);",0.6502793296089385
110322,"/** 
 * Called when a position discontinuity occurs. Position discontinuities occur when seeks are performed, when playbacks transition from one period in the timeline to the next, and when the player introduces discontinuities internally.
 */
void onPositionDiscontinuity();","/** 
 * Called when a position discontinuity occurs without a change to the timeline. A position discontinuity occurs when the current window or period index changes (as a result of playback transitioning from one period in the timeline to the next), or when the playback position jumps within the period currently being played (as a result of a seek being performed, or when the source introduces a discontinuity internally). <p> When a position discontinuity occurs as a result of a change to the timeline this method is <em>not</em> called.   {@link #onTimelineChanged(Timeline,Object)} is called in this case.
 */
void onPositionDiscontinuity();",0.2294372294372294
110323,"void handleEvent(Message msg){
switch (msg.what) {
case ExoPlayerImplInternal.MSG_STATE_CHANGED:
{
      playbackState=msg.arg1;
      for (      EventListener listener : listeners) {
        listener.onPlayerStateChanged(playWhenReady,playbackState);
      }
      break;
    }
case ExoPlayerImplInternal.MSG_LOADING_CHANGED:
{
    isLoading=msg.arg1 != 0;
    for (    EventListener listener : listeners) {
      listener.onLoadingChanged(isLoading);
    }
    break;
  }
case ExoPlayerImplInternal.MSG_TRACKS_CHANGED:
{
  TrackInfo trackInfo=(TrackInfo)msg.obj;
  tracksSelected=true;
  trackGroups=trackInfo.groups;
  trackSelections=trackInfo.selections;
  trackSelector.onSelectionActivated(trackInfo.info);
  for (  EventListener listener : listeners) {
    listener.onTracksChanged(trackGroups,trackSelections);
  }
  break;
}
case ExoPlayerImplInternal.MSG_SEEK_ACK:
{
pendingSeekAcks-=msg.arg1;
if (pendingSeekAcks == 0) {
  playbackInfo=(ExoPlayerImplInternal.PlaybackInfo)msg.obj;
  for (  EventListener listener : listeners) {
    listener.onPositionDiscontinuity();
  }
}
break;
}
case ExoPlayerImplInternal.MSG_POSITION_DISCONTINUITY:
{
if (pendingSeekAcks == 0) {
playbackInfo=(ExoPlayerImplInternal.PlaybackInfo)msg.obj;
for (EventListener listener : listeners) {
  listener.onPositionDiscontinuity();
}
}
break;
}
case ExoPlayerImplInternal.MSG_SOURCE_INFO_REFRESHED:
{
@SuppressWarnings(""String_Node_Str"") Pair<Timeline,Object> timelineAndManifest=(Pair<Timeline,Object>)msg.obj;
timeline=timelineAndManifest.first;
manifest=timelineAndManifest.second;
for (EventListener listener : listeners) {
listener.onTimelineChanged(timeline,manifest);
}
break;
}
case ExoPlayerImplInternal.MSG_ERROR:
{
ExoPlaybackException exception=(ExoPlaybackException)msg.obj;
for (EventListener listener : listeners) {
listener.onPlayerError(exception);
}
break;
}
}
}","void handleEvent(Message msg){
switch (msg.what) {
case ExoPlayerImplInternal.MSG_STATE_CHANGED:
{
      playbackState=msg.arg1;
      for (      EventListener listener : listeners) {
        listener.onPlayerStateChanged(playWhenReady,playbackState);
      }
      break;
    }
case ExoPlayerImplInternal.MSG_LOADING_CHANGED:
{
    isLoading=msg.arg1 != 0;
    for (    EventListener listener : listeners) {
      listener.onLoadingChanged(isLoading);
    }
    break;
  }
case ExoPlayerImplInternal.MSG_TRACKS_CHANGED:
{
  TrackInfo trackInfo=(TrackInfo)msg.obj;
  tracksSelected=true;
  trackGroups=trackInfo.groups;
  trackSelections=trackInfo.selections;
  trackSelector.onSelectionActivated(trackInfo.info);
  for (  EventListener listener : listeners) {
    listener.onTracksChanged(trackGroups,trackSelections);
  }
  break;
}
case ExoPlayerImplInternal.MSG_SEEK_ACK:
{
if (--pendingSeekAcks == 0) {
  playbackInfo=(ExoPlayerImplInternal.PlaybackInfo)msg.obj;
  for (  EventListener listener : listeners) {
    listener.onPositionDiscontinuity();
  }
}
break;
}
case ExoPlayerImplInternal.MSG_POSITION_DISCONTINUITY:
{
if (pendingSeekAcks == 0) {
playbackInfo=(ExoPlayerImplInternal.PlaybackInfo)msg.obj;
for (EventListener listener : listeners) {
  listener.onPositionDiscontinuity();
}
}
break;
}
case ExoPlayerImplInternal.MSG_SOURCE_INFO_REFRESHED:
{
SourceInfo sourceInfo=(SourceInfo)msg.obj;
timeline=sourceInfo.timeline;
manifest=sourceInfo.manifest;
playbackInfo=sourceInfo.playbackInfo;
pendingSeekAcks-=sourceInfo.seekAcks;
for (EventListener listener : listeners) {
listener.onTimelineChanged(timeline,manifest);
}
break;
}
case ExoPlayerImplInternal.MSG_ERROR:
{
ExoPlaybackException exception=(ExoPlaybackException)msg.obj;
for (EventListener listener : listeners) {
listener.onPlayerError(exception);
}
break;
}
}
}",0.896328293736501
110324,"private void handleSourceInfoRefreshed(Pair<Timeline,Object> timelineAndManifest) throws ExoPlaybackException, IOException {
  eventHandler.obtainMessage(MSG_SOURCE_INFO_REFRESHED,timelineAndManifest).sendToTarget();
  Timeline oldTimeline=this.timeline;
  this.timeline=timelineAndManifest.first;
  if (pendingInitialSeekCount > 0) {
    Pair<Integer,Long> periodPosition=resolveSeekPosition(pendingSeekPosition);
    if (periodPosition == null) {
      stopInternal();
      return;
    }
    playbackInfo=new PlaybackInfo(periodPosition.first,periodPosition.second);
    eventHandler.obtainMessage(MSG_SEEK_ACK,pendingInitialSeekCount,0,playbackInfo).sendToTarget();
    pendingInitialSeekCount=0;
    pendingSeekPosition=null;
  }
  if (playingPeriodHolder != null) {
    int index=timeline.getIndexOfPeriod(playingPeriodHolder.uid);
    if (index == C.INDEX_UNSET) {
      attemptRestart(playingPeriodHolder.index,oldTimeline,timeline);
      return;
    }
    timeline.getPeriod(index,period,true);
    playingPeriodHolder.setIndex(timeline,timeline.getWindow(period.windowIndex,window),index);
    MediaPeriodHolder previousPeriodHolder=playingPeriodHolder;
    boolean seenReadingPeriod=false;
    bufferAheadPeriodCount=0;
    while (previousPeriodHolder.next != null) {
      MediaPeriodHolder periodHolder=previousPeriodHolder.next;
      index++;
      timeline.getPeriod(index,period,true);
      if (!periodHolder.uid.equals(period.uid)) {
        if (!seenReadingPeriod) {
          index=playingPeriodHolder.index;
          releasePeriodHoldersFrom(playingPeriodHolder);
          playingPeriodHolder=null;
          readingPeriodHolder=null;
          loadingPeriodHolder=null;
          long newPositionUs=seekToPeriodPosition(index,playbackInfo.positionUs);
          if (newPositionUs != playbackInfo.positionUs) {
            playbackInfo=new PlaybackInfo(index,newPositionUs);
            eventHandler.obtainMessage(MSG_POSITION_DISCONTINUITY,playbackInfo).sendToTarget();
          }
          return;
        }
        loadingPeriodHolder=previousPeriodHolder;
        loadingPeriodHolder.next=null;
        releasePeriodHoldersFrom(periodHolder);
        break;
      }
      bufferAheadPeriodCount++;
      int windowIndex=timeline.getPeriod(index,period).windowIndex;
      periodHolder.setIndex(timeline,timeline.getWindow(windowIndex,window),index);
      if (periodHolder == readingPeriodHolder) {
        seenReadingPeriod=true;
      }
      previousPeriodHolder=periodHolder;
    }
  }
 else   if (loadingPeriodHolder != null) {
    Object uid=loadingPeriodHolder.uid;
    int index=timeline.getIndexOfPeriod(uid);
    if (index == C.INDEX_UNSET) {
      attemptRestart(loadingPeriodHolder.index,oldTimeline,timeline);
      return;
    }
 else {
      int windowIndex=timeline.getPeriod(index,this.period).windowIndex;
      loadingPeriodHolder.setIndex(timeline,timeline.getWindow(windowIndex,window),index);
    }
  }
  if (oldTimeline != null) {
    int newPlayingIndex=playingPeriodHolder != null ? playingPeriodHolder.index : loadingPeriodHolder != null ? loadingPeriodHolder.index : C.INDEX_UNSET;
    if (newPlayingIndex != C.INDEX_UNSET && newPlayingIndex != playbackInfo.periodIndex) {
      playbackInfo=new PlaybackInfo(newPlayingIndex,playbackInfo.positionUs);
      updatePlaybackPositions();
      eventHandler.obtainMessage(MSG_POSITION_DISCONTINUITY,playbackInfo).sendToTarget();
    }
  }
}","private void handleSourceInfoRefreshed(Pair<Timeline,Object> timelineAndManifest) throws ExoPlaybackException, IOException {
  Timeline oldTimeline=timeline;
  timeline=timelineAndManifest.first;
  Object manifest=timelineAndManifest.second;
  if (oldTimeline == null) {
    if (pendingInitialSeekCount > 0) {
      Pair<Integer,Long> periodPosition=resolveSeekPosition(pendingSeekPosition);
      if (periodPosition == null) {
        finishSourceInfoRefresh(manifest,false);
        stopInternal();
        return;
      }
      playbackInfo=new PlaybackInfo(periodPosition.first,periodPosition.second);
    }
 else     if (playbackInfo.startPositionUs == C.TIME_UNSET) {
      Pair<Integer,Long> defaultPosition=getPeriodPosition(0,C.TIME_UNSET);
      playbackInfo=new PlaybackInfo(defaultPosition.first,defaultPosition.second);
    }
  }
  if (playingPeriodHolder != null) {
    int index=timeline.getIndexOfPeriod(playingPeriodHolder.uid);
    if (index == C.INDEX_UNSET) {
      boolean restarted=attemptRestart(playingPeriodHolder.index,oldTimeline,timeline);
      finishSourceInfoRefresh(manifest,true);
      if (!restarted) {
        stopInternal();
      }
      return;
    }
    timeline.getPeriod(index,period,true);
    playingPeriodHolder.setIndex(timeline,timeline.getWindow(period.windowIndex,window),index);
    MediaPeriodHolder previousPeriodHolder=playingPeriodHolder;
    boolean seenReadingPeriod=false;
    bufferAheadPeriodCount=0;
    while (previousPeriodHolder.next != null) {
      MediaPeriodHolder periodHolder=previousPeriodHolder.next;
      index++;
      timeline.getPeriod(index,period,true);
      if (!periodHolder.uid.equals(period.uid)) {
        if (!seenReadingPeriod) {
          index=playingPeriodHolder.index;
          releasePeriodHoldersFrom(playingPeriodHolder);
          playingPeriodHolder=null;
          readingPeriodHolder=null;
          loadingPeriodHolder=null;
          long newPositionUs=seekToPeriodPosition(index,playbackInfo.positionUs);
          if (newPositionUs != playbackInfo.positionUs) {
            playbackInfo=new PlaybackInfo(index,newPositionUs);
          }
          finishSourceInfoRefresh(manifest,true);
          return;
        }
        loadingPeriodHolder=previousPeriodHolder;
        loadingPeriodHolder.next=null;
        releasePeriodHoldersFrom(periodHolder);
        break;
      }
      bufferAheadPeriodCount++;
      int windowIndex=timeline.getPeriod(index,period).windowIndex;
      periodHolder.setIndex(timeline,timeline.getWindow(windowIndex,window),index);
      if (periodHolder == readingPeriodHolder) {
        seenReadingPeriod=true;
      }
      previousPeriodHolder=periodHolder;
    }
  }
 else   if (loadingPeriodHolder != null) {
    Object uid=loadingPeriodHolder.uid;
    int index=timeline.getIndexOfPeriod(uid);
    if (index == C.INDEX_UNSET) {
      boolean restarted=attemptRestart(playingPeriodHolder.index,oldTimeline,timeline);
      finishSourceInfoRefresh(manifest,true);
      if (!restarted) {
        stopInternal();
      }
      return;
    }
 else {
      int windowIndex=timeline.getPeriod(index,this.period).windowIndex;
      loadingPeriodHolder.setIndex(timeline,timeline.getWindow(windowIndex,window),index);
    }
  }
  if (oldTimeline != null) {
    int newPlayingIndex=playingPeriodHolder != null ? playingPeriodHolder.index : loadingPeriodHolder != null ? loadingPeriodHolder.index : C.INDEX_UNSET;
    if (newPlayingIndex != C.INDEX_UNSET && newPlayingIndex != playbackInfo.periodIndex) {
      playbackInfo=new PlaybackInfo(newPlayingIndex,playbackInfo.positionUs);
      updatePlaybackPositions();
    }
  }
  finishSourceInfoRefresh(manifest,true);
}",0.7716447184085178
110325,"private void attemptRestart(int oldPeriodIndex,Timeline oldTimeline,Timeline newTimeline){
  int newPeriodIndex=resolveSubsequentPeriod(oldPeriodIndex,oldTimeline,newTimeline);
  if (newPeriodIndex == C.INDEX_UNSET) {
    stopInternal();
    return;
  }
  releasePeriodHoldersFrom(playingPeriodHolder != null ? playingPeriodHolder : loadingPeriodHolder);
  bufferAheadPeriodCount=0;
  playingPeriodHolder=null;
  readingPeriodHolder=null;
  loadingPeriodHolder=null;
  Pair<Integer,Long> defaultPosition=getPeriodPosition(timeline.getPeriod(newPeriodIndex,period).windowIndex,C.TIME_UNSET);
  newPeriodIndex=defaultPosition.first;
  long newPlayingPositionUs=defaultPosition.second;
  playbackInfo=new PlaybackInfo(newPeriodIndex,newPlayingPositionUs);
  eventHandler.obtainMessage(MSG_POSITION_DISCONTINUITY,playbackInfo).sendToTarget();
}","private boolean attemptRestart(int oldPeriodIndex,Timeline oldTimeline,Timeline newTimeline){
  int newPeriodIndex=resolveSubsequentPeriod(oldPeriodIndex,oldTimeline,newTimeline);
  if (newPeriodIndex == C.INDEX_UNSET) {
    return false;
  }
  releasePeriodHoldersFrom(playingPeriodHolder != null ? playingPeriodHolder : loadingPeriodHolder);
  bufferAheadPeriodCount=0;
  playingPeriodHolder=null;
  readingPeriodHolder=null;
  loadingPeriodHolder=null;
  Pair<Integer,Long> defaultPosition=getPeriodPosition(timeline.getPeriod(newPeriodIndex,period).windowIndex,C.TIME_UNSET);
  newPeriodIndex=defaultPosition.first;
  long newPlayingPositionUs=defaultPosition.second;
  playbackInfo=new PlaybackInfo(newPeriodIndex,newPlayingPositionUs);
  return true;
}",0.9111389236545682
110326,"private long seekToPeriodPosition(int periodIndex,long periodPositionUs) throws ExoPlaybackException {
  stopRenderers();
  rebuffering=false;
  setState(ExoPlayer.STATE_BUFFERING);
  if (periodPositionUs == C.TIME_UNSET || (readingPeriodHolder != playingPeriodHolder && (periodIndex == playingPeriodHolder.index || periodIndex == readingPeriodHolder.index))) {
    periodIndex=C.INDEX_UNSET;
  }
  MediaPeriodHolder newPlayingPeriodHolder=null;
  if (playingPeriodHolder == null) {
    if (loadingPeriodHolder != null) {
      loadingPeriodHolder.release();
    }
  }
 else {
    MediaPeriodHolder periodHolder=playingPeriodHolder;
    while (periodHolder != null) {
      if (periodHolder.index == periodIndex && periodHolder.prepared) {
        newPlayingPeriodHolder=periodHolder;
      }
 else {
        periodHolder.release();
      }
      periodHolder=periodHolder.next;
    }
  }
  if (newPlayingPeriodHolder != playingPeriodHolder) {
    for (    Renderer renderer : enabledRenderers) {
      renderer.disable();
    }
    enabledRenderers=new Renderer[0];
    rendererMediaClock=null;
    rendererMediaClockSource=null;
  }
  bufferAheadPeriodCount=0;
  if (newPlayingPeriodHolder != null) {
    newPlayingPeriodHolder.next=null;
    setPlayingPeriodHolder(newPlayingPeriodHolder);
    updateTimelineState();
    readingPeriodHolder=playingPeriodHolder;
    loadingPeriodHolder=playingPeriodHolder;
    if (playingPeriodHolder.hasEnabledTracks) {
      periodPositionUs=playingPeriodHolder.mediaPeriod.seekToUs(periodPositionUs);
    }
    resetRendererPosition(periodPositionUs);
    maybeContinueLoading();
  }
 else {
    playingPeriodHolder=null;
    readingPeriodHolder=null;
    loadingPeriodHolder=null;
    if (periodPositionUs != C.TIME_UNSET) {
      resetRendererPosition(periodPositionUs);
    }
  }
  updatePlaybackPositions();
  handler.sendEmptyMessage(MSG_DO_SOME_WORK);
  return periodPositionUs;
}","private long seekToPeriodPosition(int periodIndex,long periodPositionUs) throws ExoPlaybackException {
  stopRenderers();
  rebuffering=false;
  setState(ExoPlayer.STATE_BUFFERING);
  if (readingPeriodHolder != playingPeriodHolder && (periodIndex == playingPeriodHolder.index || periodIndex == readingPeriodHolder.index)) {
    periodIndex=C.INDEX_UNSET;
  }
  MediaPeriodHolder newPlayingPeriodHolder=null;
  if (playingPeriodHolder == null) {
    if (loadingPeriodHolder != null) {
      loadingPeriodHolder.release();
    }
  }
 else {
    MediaPeriodHolder periodHolder=playingPeriodHolder;
    while (periodHolder != null) {
      if (periodHolder.index == periodIndex && periodHolder.prepared) {
        newPlayingPeriodHolder=periodHolder;
      }
 else {
        periodHolder.release();
      }
      periodHolder=periodHolder.next;
    }
  }
  if (newPlayingPeriodHolder != playingPeriodHolder) {
    for (    Renderer renderer : enabledRenderers) {
      renderer.disable();
    }
    enabledRenderers=new Renderer[0];
    rendererMediaClock=null;
    rendererMediaClockSource=null;
  }
  bufferAheadPeriodCount=0;
  if (newPlayingPeriodHolder != null) {
    newPlayingPeriodHolder.next=null;
    setPlayingPeriodHolder(newPlayingPeriodHolder);
    updateTimelineState();
    readingPeriodHolder=playingPeriodHolder;
    loadingPeriodHolder=playingPeriodHolder;
    if (playingPeriodHolder.hasEnabledTracks) {
      periodPositionUs=playingPeriodHolder.mediaPeriod.seekToUs(periodPositionUs);
    }
    resetRendererPosition(periodPositionUs);
    maybeContinueLoading();
  }
 else {
    playingPeriodHolder=null;
    readingPeriodHolder=null;
    loadingPeriodHolder=null;
    resetRendererPosition(periodPositionUs);
  }
  updatePlaybackPositions();
  handler.sendEmptyMessage(MSG_DO_SOME_WORK);
  return periodPositionUs;
}",0.9160021265284424
110327,"private void updatePeriods() throws ExoPlaybackException, IOException {
  if (timeline == null) {
    mediaSource.maybeThrowSourceInfoRefreshError();
    return;
  }
  if (loadingPeriodHolder == null || (loadingPeriodHolder.isFullyBuffered() && !loadingPeriodHolder.isLast && bufferAheadPeriodCount < MAXIMUM_BUFFER_AHEAD_PERIODS)) {
    int newLoadingPeriodIndex=loadingPeriodHolder == null ? playbackInfo.periodIndex : loadingPeriodHolder.index + 1;
    if (newLoadingPeriodIndex >= timeline.getPeriodCount()) {
      mediaSource.maybeThrowSourceInfoRefreshError();
    }
 else {
      int windowIndex=timeline.getPeriod(newLoadingPeriodIndex,period).windowIndex;
      boolean isFirstPeriodInWindow=newLoadingPeriodIndex == timeline.getWindow(windowIndex,window).firstPeriodIndex;
      long periodStartPositionUs=loadingPeriodHolder == null ? playbackInfo.positionUs : (isFirstPeriodInWindow ? C.TIME_UNSET : 0);
      if (periodStartPositionUs == C.TIME_UNSET) {
        long defaultPositionProjectionUs=loadingPeriodHolder == null ? 0 : (loadingPeriodHolder.rendererPositionOffsetUs + timeline.getPeriod(loadingPeriodHolder.index,period).getDurationUs() - loadingPeriodHolder.startPositionUs - rendererPositionUs);
        Pair<Integer,Long> defaultPosition=getPeriodPosition(timeline,windowIndex,C.TIME_UNSET,Math.max(0,defaultPositionProjectionUs));
        if (defaultPosition == null) {
          newLoadingPeriodIndex=C.INDEX_UNSET;
          periodStartPositionUs=C.TIME_UNSET;
        }
 else {
          newLoadingPeriodIndex=defaultPosition.first;
          periodStartPositionUs=defaultPosition.second;
        }
      }
      if (newLoadingPeriodIndex != C.INDEX_UNSET) {
        Object newPeriodUid=timeline.getPeriod(newLoadingPeriodIndex,period,true).uid;
        MediaPeriod newMediaPeriod=mediaSource.createPeriod(newLoadingPeriodIndex,loadControl.getAllocator(),periodStartPositionUs);
        newMediaPeriod.prepare(this);
        MediaPeriodHolder newPeriodHolder=new MediaPeriodHolder(renderers,rendererCapabilities,trackSelector,mediaSource,newMediaPeriod,newPeriodUid,periodStartPositionUs);
        timeline.getWindow(windowIndex,window);
        newPeriodHolder.setIndex(timeline,window,newLoadingPeriodIndex);
        if (loadingPeriodHolder != null) {
          loadingPeriodHolder.setNext(newPeriodHolder);
          newPeriodHolder.rendererPositionOffsetUs=loadingPeriodHolder.rendererPositionOffsetUs + timeline.getPeriod(loadingPeriodHolder.index,period).getDurationUs() - loadingPeriodHolder.startPositionUs;
        }
 else {
          newPeriodHolder.rendererPositionOffsetUs=periodStartPositionUs;
        }
        bufferAheadPeriodCount++;
        loadingPeriodHolder=newPeriodHolder;
        setIsLoading(true);
      }
    }
  }
  if (loadingPeriodHolder == null || loadingPeriodHolder.isFullyBuffered()) {
    setIsLoading(false);
  }
 else   if (loadingPeriodHolder != null && loadingPeriodHolder.needsContinueLoading) {
    maybeContinueLoading();
  }
  if (playingPeriodHolder == null) {
    return;
  }
  while (playingPeriodHolder != readingPeriodHolder && playingPeriodHolder.next != null && rendererPositionUs >= playingPeriodHolder.next.rendererPositionOffsetUs) {
    playingPeriodHolder.release();
    setPlayingPeriodHolder(playingPeriodHolder.next);
    bufferAheadPeriodCount--;
    playbackInfo=new PlaybackInfo(playingPeriodHolder.index,playingPeriodHolder.startPositionUs);
    updatePlaybackPositions();
    eventHandler.obtainMessage(MSG_POSITION_DISCONTINUITY,playbackInfo).sendToTarget();
  }
  updateTimelineState();
  if (readingPeriodHolder.isLast) {
    for (    Renderer renderer : enabledRenderers) {
      renderer.setCurrentStreamIsFinal();
    }
    return;
  }
  for (  Renderer renderer : enabledRenderers) {
    if (!renderer.hasReadStreamToEnd()) {
      return;
    }
  }
  if (readingPeriodHolder.next != null && readingPeriodHolder.next.prepared) {
    TrackSelectionArray oldTrackSelections=readingPeriodHolder.trackSelections;
    readingPeriodHolder=readingPeriodHolder.next;
    TrackSelectionArray newTrackSelections=readingPeriodHolder.trackSelections;
    for (int i=0; i < renderers.length; i++) {
      Renderer renderer=renderers[i];
      TrackSelection oldSelection=oldTrackSelections.get(i);
      TrackSelection newSelection=newTrackSelections.get(i);
      if (oldSelection != null) {
        if (newSelection != null) {
          Format[] formats=new Format[newSelection.length()];
          for (int j=0; j < formats.length; j++) {
            formats[j]=newSelection.getFormat(j);
          }
          renderer.replaceStream(formats,readingPeriodHolder.sampleStreams[i],readingPeriodHolder.getRendererOffset());
        }
 else {
          renderer.setCurrentStreamIsFinal();
        }
      }
    }
  }
}","private void updatePeriods() throws ExoPlaybackException, IOException {
  if (timeline == null) {
    mediaSource.maybeThrowSourceInfoRefreshError();
    return;
  }
  if (loadingPeriodHolder == null || (loadingPeriodHolder.isFullyBuffered() && !loadingPeriodHolder.isLast && bufferAheadPeriodCount < MAXIMUM_BUFFER_AHEAD_PERIODS)) {
    int newLoadingPeriodIndex=loadingPeriodHolder == null ? playbackInfo.periodIndex : loadingPeriodHolder.index + 1;
    if (newLoadingPeriodIndex >= timeline.getPeriodCount()) {
      mediaSource.maybeThrowSourceInfoRefreshError();
    }
 else {
      int windowIndex=timeline.getPeriod(newLoadingPeriodIndex,period).windowIndex;
      boolean isFirstPeriodInWindow=newLoadingPeriodIndex == timeline.getWindow(windowIndex,window).firstPeriodIndex;
      long periodStartPositionUs;
      if (loadingPeriodHolder == null) {
        periodStartPositionUs=playbackInfo.startPositionUs;
      }
 else       if (!isFirstPeriodInWindow) {
        periodStartPositionUs=0;
      }
 else {
        long defaultPositionProjectionUs=loadingPeriodHolder.rendererPositionOffsetUs + timeline.getPeriod(loadingPeriodHolder.index,period).getDurationUs() - loadingPeriodHolder.startPositionUs - rendererPositionUs;
        Pair<Integer,Long> defaultPosition=getPeriodPosition(timeline,windowIndex,C.TIME_UNSET,Math.max(0,defaultPositionProjectionUs));
        if (defaultPosition == null) {
          newLoadingPeriodIndex=C.INDEX_UNSET;
          periodStartPositionUs=C.TIME_UNSET;
        }
 else {
          newLoadingPeriodIndex=defaultPosition.first;
          periodStartPositionUs=defaultPosition.second;
        }
      }
      if (newLoadingPeriodIndex != C.INDEX_UNSET) {
        Object newPeriodUid=timeline.getPeriod(newLoadingPeriodIndex,period,true).uid;
        MediaPeriod newMediaPeriod=mediaSource.createPeriod(newLoadingPeriodIndex,loadControl.getAllocator(),periodStartPositionUs);
        newMediaPeriod.prepare(this);
        MediaPeriodHolder newPeriodHolder=new MediaPeriodHolder(renderers,rendererCapabilities,trackSelector,mediaSource,newMediaPeriod,newPeriodUid,periodStartPositionUs);
        timeline.getWindow(windowIndex,window);
        newPeriodHolder.setIndex(timeline,window,newLoadingPeriodIndex);
        if (loadingPeriodHolder != null) {
          loadingPeriodHolder.setNext(newPeriodHolder);
          newPeriodHolder.rendererPositionOffsetUs=loadingPeriodHolder.rendererPositionOffsetUs + timeline.getPeriod(loadingPeriodHolder.index,period).getDurationUs() - loadingPeriodHolder.startPositionUs;
        }
 else {
          newPeriodHolder.rendererPositionOffsetUs=periodStartPositionUs;
        }
        bufferAheadPeriodCount++;
        loadingPeriodHolder=newPeriodHolder;
        setIsLoading(true);
      }
    }
  }
  if (loadingPeriodHolder == null || loadingPeriodHolder.isFullyBuffered()) {
    setIsLoading(false);
  }
 else   if (loadingPeriodHolder != null && loadingPeriodHolder.needsContinueLoading) {
    maybeContinueLoading();
  }
  if (playingPeriodHolder == null) {
    return;
  }
  while (playingPeriodHolder != readingPeriodHolder && playingPeriodHolder.next != null && rendererPositionUs >= playingPeriodHolder.next.rendererPositionOffsetUs) {
    playingPeriodHolder.release();
    setPlayingPeriodHolder(playingPeriodHolder.next);
    bufferAheadPeriodCount--;
    playbackInfo=new PlaybackInfo(playingPeriodHolder.index,playingPeriodHolder.startPositionUs);
    updatePlaybackPositions();
    eventHandler.obtainMessage(MSG_POSITION_DISCONTINUITY,playbackInfo).sendToTarget();
  }
  updateTimelineState();
  if (readingPeriodHolder.isLast) {
    for (    Renderer renderer : enabledRenderers) {
      renderer.setCurrentStreamIsFinal();
    }
    return;
  }
  for (  Renderer renderer : enabledRenderers) {
    if (!renderer.hasReadStreamToEnd()) {
      return;
    }
  }
  if (readingPeriodHolder.next != null && readingPeriodHolder.next.prepared) {
    TrackSelectionArray oldTrackSelections=readingPeriodHolder.trackSelections;
    readingPeriodHolder=readingPeriodHolder.next;
    TrackSelectionArray newTrackSelections=readingPeriodHolder.trackSelections;
    for (int i=0; i < renderers.length; i++) {
      Renderer renderer=renderers[i];
      TrackSelection oldSelection=oldTrackSelections.get(i);
      TrackSelection newSelection=newTrackSelections.get(i);
      if (oldSelection != null) {
        if (newSelection != null) {
          Format[] formats=new Format[newSelection.length()];
          for (int j=0; j < formats.length; j++) {
            formats[j]=newSelection.getFormat(j);
          }
          renderer.replaceStream(formats,readingPeriodHolder.sampleStreams[i],readingPeriodHolder.getRendererOffset());
        }
 else {
          renderer.setCurrentStreamIsFinal();
        }
      }
    }
  }
}",0.9615544472152951
110328,"private void seekToInternal(SeekPosition seekPosition) throws ExoPlaybackException {
  if (timeline == null) {
    pendingInitialSeekCount++;
    pendingSeekPosition=seekPosition;
    return;
  }
  Pair<Integer,Long> periodPosition=resolveSeekPosition(seekPosition);
  if (periodPosition == null) {
    stopInternal();
    return;
  }
  int periodIndex=periodPosition.first;
  long periodPositionUs=periodPosition.second;
  try {
    if (periodIndex == playbackInfo.periodIndex && ((periodPositionUs == C.TIME_UNSET && playbackInfo.positionUs == C.TIME_UNSET) || ((periodPositionUs / 1000) == (playbackInfo.positionUs / 1000)))) {
      return;
    }
    periodPositionUs=seekToPeriodPosition(periodIndex,periodPositionUs);
  }
  finally {
    playbackInfo=new PlaybackInfo(periodIndex,periodPositionUs);
    eventHandler.obtainMessage(MSG_SEEK_ACK,1,0,playbackInfo).sendToTarget();
  }
}","private void seekToInternal(SeekPosition seekPosition) throws ExoPlaybackException {
  if (timeline == null) {
    pendingInitialSeekCount++;
    pendingSeekPosition=seekPosition;
    return;
  }
  Pair<Integer,Long> periodPosition=resolveSeekPosition(seekPosition);
  if (periodPosition == null) {
    stopInternal();
    return;
  }
  int periodIndex=periodPosition.first;
  long periodPositionUs=periodPosition.second;
  try {
    if (periodIndex == playbackInfo.periodIndex && ((periodPositionUs / 1000) == (playbackInfo.positionUs / 1000))) {
      return;
    }
    periodPositionUs=seekToPeriodPosition(periodIndex,periodPositionUs);
  }
  finally {
    playbackInfo=new PlaybackInfo(periodIndex,periodPositionUs);
    eventHandler.obtainMessage(MSG_SEEK_ACK,playbackInfo).sendToTarget();
  }
}",0.9484902309058616
110329,"@Override public long getBufferedPositionUs(){
  if (loadingFinished) {
    return C.TIME_END_OF_SOURCE;
  }
 else   if (isPendingReset()) {
    return pendingResetPositionUs;
  }
 else {
    long largestQueuedTimestampUs=getLargestQueuedTimestampUs();
    return largestQueuedTimestampUs == Long.MIN_VALUE ? lastSeekPositionUs : largestQueuedTimestampUs;
  }
}","@Override public long getBufferedPositionUs(){
  if (loadingFinished) {
    return C.TIME_END_OF_SOURCE;
  }
 else   if (isPendingReset()) {
    return pendingResetPositionUs;
  }
  long largestQueuedTimestampUs;
  if (haveAudioVideoTracks) {
    largestQueuedTimestampUs=Long.MAX_VALUE;
    int trackCount=sampleQueues.size();
    for (int i=0; i < trackCount; i++) {
      if (trackIsAudioVideoFlags[i]) {
        largestQueuedTimestampUs=Math.min(largestQueuedTimestampUs,sampleQueues.valueAt(i).getLargestQueuedTimestampUs());
      }
    }
  }
 else {
    largestQueuedTimestampUs=getLargestQueuedTimestampUs();
  }
  return largestQueuedTimestampUs == Long.MIN_VALUE ? lastSeekPositionUs : largestQueuedTimestampUs;
}",0.5830258302583026
110330,"private void maybeFinishPrepare(){
  if (released || prepared || seekMap == null || !tracksBuilt) {
    return;
  }
  int trackCount=sampleQueues.size();
  for (int i=0; i < trackCount; i++) {
    if (sampleQueues.valueAt(i).getUpstreamFormat() == null) {
      return;
    }
  }
  loadCondition.close();
  TrackGroup[] trackArray=new TrackGroup[trackCount];
  trackEnabledStates=new boolean[trackCount];
  durationUs=seekMap.getDurationUs();
  for (int i=0; i < trackCount; i++) {
    trackArray[i]=new TrackGroup(sampleQueues.valueAt(i).getUpstreamFormat());
  }
  tracks=new TrackGroupArray(trackArray);
  prepared=true;
  sourceListener.onSourceInfoRefreshed(new SinglePeriodTimeline(durationUs,seekMap.isSeekable()),null);
  callback.onPrepared(this);
}","private void maybeFinishPrepare(){
  if (released || prepared || seekMap == null || !tracksBuilt) {
    return;
  }
  int trackCount=sampleQueues.size();
  for (int i=0; i < trackCount; i++) {
    if (sampleQueues.valueAt(i).getUpstreamFormat() == null) {
      return;
    }
  }
  loadCondition.close();
  TrackGroup[] trackArray=new TrackGroup[trackCount];
  trackIsAudioVideoFlags=new boolean[trackCount];
  trackEnabledStates=new boolean[trackCount];
  durationUs=seekMap.getDurationUs();
  for (int i=0; i < trackCount; i++) {
    Format trackFormat=sampleQueues.valueAt(i).getUpstreamFormat();
    trackArray[i]=new TrackGroup(trackFormat);
    String mimeType=trackFormat.sampleMimeType;
    boolean isAudioVideo=MimeTypes.isVideo(mimeType) || MimeTypes.isAudio(mimeType);
    trackIsAudioVideoFlags[i]=isAudioVideo;
    haveAudioVideoTracks|=isAudioVideo;
  }
  tracks=new TrackGroupArray(trackArray);
  prepared=true;
  sourceListener.onSourceInfoRefreshed(new SinglePeriodTimeline(durationUs,seekMap.isSeekable()),null);
  callback.onPrepared(this);
}",0.5706432105552501
110331,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  if (videoAspectRatio == 0) {
    return;
  }
  int width=getMeasuredWidth();
  int height=getMeasuredHeight();
  float viewAspectRatio=(float)width / height;
  float aspectDeformation=videoAspectRatio / viewAspectRatio - 1;
  if (Math.abs(aspectDeformation) <= MAX_ASPECT_RATIO_DEFORMATION_FRACTION) {
    return;
  }
switch (resizeMode) {
case RESIZE_MODE_FIXED_WIDTH:
    height=(int)(width / videoAspectRatio);
  break;
case RESIZE_MODE_FIXED_HEIGHT:
width=(int)(height * videoAspectRatio);
break;
default :
if (aspectDeformation > 0) {
height=(int)(width / videoAspectRatio);
}
 else {
width=(int)(height * videoAspectRatio);
}
break;
}
super.onMeasure(MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY),MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY));
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  if (resizeMode == RESIZE_MODE_FILL || videoAspectRatio <= 0) {
    return;
  }
  int width=getMeasuredWidth();
  int height=getMeasuredHeight();
  float viewAspectRatio=(float)width / height;
  float aspectDeformation=videoAspectRatio / viewAspectRatio - 1;
  if (Math.abs(aspectDeformation) <= MAX_ASPECT_RATIO_DEFORMATION_FRACTION) {
    return;
  }
switch (resizeMode) {
case RESIZE_MODE_FIXED_WIDTH:
    height=(int)(width / videoAspectRatio);
  break;
case RESIZE_MODE_FIXED_HEIGHT:
width=(int)(height * videoAspectRatio);
break;
default :
if (aspectDeformation > 0) {
height=(int)(width / videoAspectRatio);
}
 else {
width=(int)(height * videoAspectRatio);
}
break;
}
super.onMeasure(MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY),MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY));
}",0.9805405405405404
110332,"@Override public void onVideoSizeChanged(int width,int height,int unappliedRotationDegrees,float pixelWidthHeightRatio){
  if (aspectRatioVideoFrame != null) {
    float aspectRatio=height == 0 ? 1 : (width * pixelWidthHeightRatio) / height;
    aspectRatioVideoFrame.setAspectRatio(aspectRatio);
  }
}","@Override public void onVideoSizeChanged(int width,int height,int unappliedRotationDegrees,float pixelWidthHeightRatio){
  if (contentFrame != null) {
    float aspectRatio=height == 0 ? 1 : (width * pixelWidthHeightRatio) / height;
    contentFrame.setAspectRatio(aspectRatio);
  }
}",0.9215017064846416
110333,"private void updateForCurrentTrackSelections(){
  if (player == null) {
    return;
  }
  TrackSelectionArray selections=player.getCurrentTrackSelections();
  for (int i=0; i < selections.length; i++) {
    if (player.getRendererType(i) == C.TRACK_TYPE_VIDEO && selections.get(i) != null) {
      hideArtwork();
      return;
    }
  }
  if (shutterView != null) {
    shutterView.setVisibility(VISIBLE);
  }
  if (useArtwork) {
    for (int i=0; i < selections.length; i++) {
      TrackSelection selection=selections.get(i);
      if (selection != null) {
        for (int j=0; j < selection.length(); j++) {
          Metadata metadata=selection.getFormat(j).metadata;
          if (metadata != null) {
            for (int k=0; k < metadata.length(); k++) {
              Metadata.Entry metadataEntry=metadata.get(k);
              if (metadataEntry instanceof ApicFrame) {
                byte[] data=((ApicFrame)metadataEntry).pictureData;
                ;
                artworkView.setImageBitmap(BitmapFactory.decodeByteArray(data,0,data.length));
                artworkView.setVisibility(VISIBLE);
                return;
              }
            }
          }
        }
      }
    }
  }
  hideArtwork();
}","private void updateForCurrentTrackSelections(){
  if (player == null) {
    return;
  }
  TrackSelectionArray selections=player.getCurrentTrackSelections();
  for (int i=0; i < selections.length; i++) {
    if (player.getRendererType(i) == C.TRACK_TYPE_VIDEO && selections.get(i) != null) {
      hideArtwork();
      return;
    }
  }
  if (shutterView != null) {
    shutterView.setVisibility(VISIBLE);
  }
  if (useArtwork) {
    for (int i=0; i < selections.length; i++) {
      TrackSelection selection=selections.get(i);
      if (selection != null) {
        for (int j=0; j < selection.length(); j++) {
          Metadata metadata=selection.getFormat(j).metadata;
          if (metadata != null && setArtworkFromMetadata(metadata)) {
            return;
          }
        }
      }
    }
  }
  hideArtwork();
}",0.6891825746451297
110334,"/** 
 * Sets the resize mode.
 * @param resizeMode The resize mode.
 */
public void setResizeMode(@ResizeMode int resizeMode){
  Assertions.checkState(aspectRatioVideoFrame != null);
  aspectRatioVideoFrame.setResizeMode(resizeMode);
}","/** 
 * Sets the resize mode.
 * @param resizeMode The resize mode.
 */
public void setResizeMode(@ResizeMode int resizeMode){
  Assertions.checkState(contentFrame != null);
  contentFrame.setResizeMode(resizeMode);
}",0.8982300884955752
110335,"public SimpleExoPlayerView(Context context,AttributeSet attrs,int defStyleAttr){
  super(context,attrs,defStyleAttr);
  int playerLayoutId=R.layout.exo_simple_player_view;
  boolean useArtwork=true;
  boolean useController=true;
  int surfaceType=SURFACE_TYPE_SURFACE_VIEW;
  int resizeMode=AspectRatioFrameLayout.RESIZE_MODE_FIT;
  int rewindMs=PlaybackControlView.DEFAULT_REWIND_MS;
  int fastForwardMs=PlaybackControlView.DEFAULT_FAST_FORWARD_MS;
  int controllerShowTimeoutMs=PlaybackControlView.DEFAULT_SHOW_TIMEOUT_MS;
  if (attrs != null) {
    TypedArray a=context.getTheme().obtainStyledAttributes(attrs,R.styleable.SimpleExoPlayerView,0,0);
    try {
      playerLayoutId=a.getResourceId(R.styleable.SimpleExoPlayerView_player_layout_id,playerLayoutId);
      useArtwork=a.getBoolean(R.styleable.SimpleExoPlayerView_use_artwork,useArtwork);
      useController=a.getBoolean(R.styleable.SimpleExoPlayerView_use_controller,useController);
      surfaceType=a.getInt(R.styleable.SimpleExoPlayerView_surface_type,surfaceType);
      resizeMode=a.getInt(R.styleable.SimpleExoPlayerView_resize_mode,resizeMode);
      rewindMs=a.getInt(R.styleable.SimpleExoPlayerView_rewind_increment,rewindMs);
      fastForwardMs=a.getInt(R.styleable.SimpleExoPlayerView_fastforward_increment,fastForwardMs);
      controllerShowTimeoutMs=a.getInt(R.styleable.SimpleExoPlayerView_show_timeout,controllerShowTimeoutMs);
    }
  finally {
      a.recycle();
    }
  }
  LayoutInflater.from(context).inflate(playerLayoutId,this);
  componentListener=new ComponentListener();
  videoFrame=(ViewGroup)findViewById(R.id.exo_video_frame);
  if (videoFrame != null) {
    if (videoFrame instanceof AspectRatioFrameLayout) {
      aspectRatioVideoFrame=(AspectRatioFrameLayout)videoFrame;
      setResizeModeRaw(aspectRatioVideoFrame,resizeMode);
    }
 else {
      aspectRatioVideoFrame=null;
    }
    shutterView=Assertions.checkNotNull(videoFrame.findViewById(R.id.exo_shutter));
    if (surfaceType != SURFACE_TYPE_NONE) {
      ViewGroup.LayoutParams params=new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);
      surfaceView=surfaceType == SURFACE_TYPE_TEXTURE_VIEW ? new TextureView(context) : new SurfaceView(context);
      surfaceView.setLayoutParams(params);
      videoFrame.addView(surfaceView,0);
    }
 else {
      surfaceView=null;
    }
  }
 else {
    aspectRatioVideoFrame=null;
    shutterView=null;
    surfaceView=null;
  }
  artworkView=(ImageView)findViewById(R.id.exo_artwork);
  this.useArtwork=useArtwork && artworkView != null;
  subtitleView=(SubtitleView)findViewById(R.id.exo_subtitles);
  if (subtitleView != null) {
    subtitleView.setUserDefaultStyle();
    subtitleView.setUserDefaultTextSize();
  }
  PlaybackControlView controller=(PlaybackControlView)findViewById(R.id.exo_controller);
  if (controller != null) {
    controller.setRewindIncrementMs(rewindMs);
    controller.setFastForwardIncrementMs(fastForwardMs);
  }
 else {
    View controllerPlaceholder=findViewById(R.id.exo_controller_placeholder);
    if (controllerPlaceholder != null) {
      controller=new PlaybackControlView(context,attrs);
      controller.setLayoutParams(controllerPlaceholder.getLayoutParams());
      ViewGroup parent=((ViewGroup)controllerPlaceholder.getParent());
      int controllerIndex=parent.indexOfChild(controllerPlaceholder);
      parent.removeView(controllerPlaceholder);
      parent.addView(controller,controllerIndex);
    }
  }
  this.controller=controller;
  this.controllerShowTimeoutMs=controller != null ? controllerShowTimeoutMs : 0;
  this.useController=useController && controller != null;
  hideController();
}","public SimpleExoPlayerView(Context context,AttributeSet attrs,int defStyleAttr){
  super(context,attrs,defStyleAttr);
  int playerLayoutId=R.layout.exo_simple_player_view;
  boolean useArtwork=true;
  boolean useController=true;
  int surfaceType=SURFACE_TYPE_SURFACE_VIEW;
  int resizeMode=AspectRatioFrameLayout.RESIZE_MODE_FIT;
  int rewindMs=PlaybackControlView.DEFAULT_REWIND_MS;
  int fastForwardMs=PlaybackControlView.DEFAULT_FAST_FORWARD_MS;
  int controllerShowTimeoutMs=PlaybackControlView.DEFAULT_SHOW_TIMEOUT_MS;
  if (attrs != null) {
    TypedArray a=context.getTheme().obtainStyledAttributes(attrs,R.styleable.SimpleExoPlayerView,0,0);
    try {
      playerLayoutId=a.getResourceId(R.styleable.SimpleExoPlayerView_player_layout_id,playerLayoutId);
      useArtwork=a.getBoolean(R.styleable.SimpleExoPlayerView_use_artwork,useArtwork);
      useController=a.getBoolean(R.styleable.SimpleExoPlayerView_use_controller,useController);
      surfaceType=a.getInt(R.styleable.SimpleExoPlayerView_surface_type,surfaceType);
      resizeMode=a.getInt(R.styleable.SimpleExoPlayerView_resize_mode,resizeMode);
      rewindMs=a.getInt(R.styleable.SimpleExoPlayerView_rewind_increment,rewindMs);
      fastForwardMs=a.getInt(R.styleable.SimpleExoPlayerView_fastforward_increment,fastForwardMs);
      controllerShowTimeoutMs=a.getInt(R.styleable.SimpleExoPlayerView_show_timeout,controllerShowTimeoutMs);
    }
  finally {
      a.recycle();
    }
  }
  LayoutInflater.from(context).inflate(playerLayoutId,this);
  componentListener=new ComponentListener();
  contentFrame=(AspectRatioFrameLayout)findViewById(R.id.exo_content_frame);
  if (contentFrame != null) {
    setResizeModeRaw(contentFrame,resizeMode);
  }
  shutterView=findViewById(R.id.exo_shutter);
  if (contentFrame != null && surfaceType != SURFACE_TYPE_NONE) {
    ViewGroup.LayoutParams params=new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);
    surfaceView=surfaceType == SURFACE_TYPE_TEXTURE_VIEW ? new TextureView(context) : new SurfaceView(context);
    surfaceView.setLayoutParams(params);
    contentFrame.addView(surfaceView,0);
  }
 else {
    surfaceView=null;
  }
  artworkView=(ImageView)findViewById(R.id.exo_artwork);
  this.useArtwork=useArtwork && artworkView != null;
  subtitleView=(SubtitleView)findViewById(R.id.exo_subtitles);
  if (subtitleView != null) {
    subtitleView.setUserDefaultStyle();
    subtitleView.setUserDefaultTextSize();
  }
  PlaybackControlView controller=(PlaybackControlView)findViewById(R.id.exo_controller);
  if (controller != null) {
    controller.setRewindIncrementMs(rewindMs);
    controller.setFastForwardIncrementMs(fastForwardMs);
  }
 else {
    View controllerPlaceholder=findViewById(R.id.exo_controller_placeholder);
    if (controllerPlaceholder != null) {
      controller=new PlaybackControlView(context,attrs);
      controller.setLayoutParams(controllerPlaceholder.getLayoutParams());
      ViewGroup parent=((ViewGroup)controllerPlaceholder.getParent());
      int controllerIndex=parent.indexOfChild(controllerPlaceholder);
      parent.removeView(controllerPlaceholder);
      parent.addView(controller,controllerIndex);
    }
  }
  this.controller=controller;
  this.controllerShowTimeoutMs=controller != null ? controllerShowTimeoutMs : 0;
  this.useController=useController && controller != null;
  hideController();
}",0.91049817056009
110336,"private void processManifest(){
  for (int i=0; i < periodsById.size(); i++) {
    int id=periodsById.keyAt(i);
    if (id >= firstPeriodId) {
      periodsById.valueAt(i).updateManifest(manifest,id - firstPeriodId);
    }
 else {
    }
  }
  handler.removeCallbacks(simulateManifestRefreshRunnable);
  int lastPeriodIndex=manifest.getPeriodCount() - 1;
  PeriodSeekInfo firstPeriodSeekInfo=PeriodSeekInfo.createPeriodSeekInfo(manifest.getPeriod(0),manifest.getPeriodDurationUs(0));
  PeriodSeekInfo lastPeriodSeekInfo=PeriodSeekInfo.createPeriodSeekInfo(manifest.getPeriod(lastPeriodIndex),manifest.getPeriodDurationUs(lastPeriodIndex));
  long currentStartTimeUs=firstPeriodSeekInfo.availableStartTimeUs;
  long currentEndTimeUs=lastPeriodSeekInfo.availableEndTimeUs;
  if (manifest.dynamic && !lastPeriodSeekInfo.isIndexExplicit) {
    long liveStreamDurationUs=getNowUnixTimeUs() - C.msToUs(manifest.availabilityStartTime);
    long liveStreamEndPositionInLastPeriodUs=liveStreamDurationUs - C.msToUs(manifest.getPeriod(lastPeriodIndex).startMs);
    currentEndTimeUs=Math.min(liveStreamEndPositionInLastPeriodUs,currentEndTimeUs);
    if (manifest.timeShiftBufferDepth != C.TIME_UNSET) {
      long timeShiftBufferDepthUs=C.msToUs(manifest.timeShiftBufferDepth);
      long offsetInPeriodUs=currentEndTimeUs - timeShiftBufferDepthUs;
      int periodIndex=lastPeriodIndex;
      while (offsetInPeriodUs < 0 && periodIndex > 0) {
        offsetInPeriodUs+=manifest.getPeriodDurationUs(--periodIndex);
      }
      if (periodIndex == 0) {
        currentStartTimeUs=Math.max(currentStartTimeUs,offsetInPeriodUs);
      }
 else {
        currentStartTimeUs=manifest.getPeriodDurationUs(0);
      }
    }
    handler.postDelayed(simulateManifestRefreshRunnable,NOTIFY_MANIFEST_INTERVAL_MS);
  }
  long windowDurationUs=currentEndTimeUs - currentStartTimeUs;
  for (int i=0; i < manifest.getPeriodCount() - 1; i++) {
    windowDurationUs+=manifest.getPeriodDurationUs(i);
  }
  long windowDefaultStartPositionUs=0;
  if (manifest.dynamic) {
    long presentationDelayForManifestMs=livePresentationDelayMs;
    if (presentationDelayForManifestMs == DEFAULT_LIVE_PRESENTATION_DELAY_PREFER_MANIFEST_MS) {
      presentationDelayForManifestMs=manifest.suggestedPresentationDelay != C.TIME_UNSET ? manifest.suggestedPresentationDelay : DEFAULT_LIVE_PRESENTATION_DELAY_FIXED_MS;
    }
    long defaultStartPositionUs=windowDurationUs - C.msToUs(presentationDelayForManifestMs);
    if (defaultStartPositionUs < MIN_LIVE_DEFAULT_START_POSITION_US) {
      defaultStartPositionUs=Math.min(MIN_LIVE_DEFAULT_START_POSITION_US,windowDurationUs / 2);
    }
    int periodIndex=0;
    long defaultStartPositionInPeriodUs=currentStartTimeUs + defaultStartPositionUs;
    long periodDurationUs=manifest.getPeriodDurationUs(periodIndex);
    while (periodIndex < manifest.getPeriodCount() - 1 && defaultStartPositionInPeriodUs >= periodDurationUs) {
      defaultStartPositionInPeriodUs-=periodDurationUs;
      periodIndex++;
      periodDurationUs=manifest.getPeriodDurationUs(periodIndex);
    }
    Period period=manifest.getPeriod(periodIndex);
    int videoAdaptationSetIndex=period.getAdaptationSetIndex(C.TRACK_TYPE_VIDEO);
    if (videoAdaptationSetIndex != C.INDEX_UNSET) {
      DashSegmentIndex index=period.adaptationSets.get(videoAdaptationSetIndex).representations.get(0).getIndex();
      int segmentNum=index.getSegmentNum(defaultStartPositionInPeriodUs,periodDurationUs);
      windowDefaultStartPositionUs=defaultStartPositionUs - defaultStartPositionInPeriodUs + index.getTimeUs(segmentNum);
    }
 else {
      windowDefaultStartPositionUs=defaultStartPositionUs;
    }
  }
  long windowStartTimeMs=manifest.availabilityStartTime + manifest.getPeriod(0).startMs + C.usToMs(currentStartTimeUs);
  DashTimeline timeline=new DashTimeline(manifest.availabilityStartTime,windowStartTimeMs,firstPeriodId,currentStartTimeUs,windowDurationUs,windowDefaultStartPositionUs,manifest);
  sourceListener.onSourceInfoRefreshed(timeline,manifest);
}","private void processManifest(){
  for (int i=0; i < periodsById.size(); i++) {
    int id=periodsById.keyAt(i);
    if (id >= firstPeriodId) {
      periodsById.valueAt(i).updateManifest(manifest,id - firstPeriodId);
    }
 else {
    }
  }
  handler.removeCallbacks(simulateManifestRefreshRunnable);
  int lastPeriodIndex=manifest.getPeriodCount() - 1;
  PeriodSeekInfo firstPeriodSeekInfo=PeriodSeekInfo.createPeriodSeekInfo(manifest.getPeriod(0),manifest.getPeriodDurationUs(0));
  PeriodSeekInfo lastPeriodSeekInfo=PeriodSeekInfo.createPeriodSeekInfo(manifest.getPeriod(lastPeriodIndex),manifest.getPeriodDurationUs(lastPeriodIndex));
  long currentStartTimeUs=firstPeriodSeekInfo.availableStartTimeUs;
  long currentEndTimeUs=lastPeriodSeekInfo.availableEndTimeUs;
  if (manifest.dynamic && !lastPeriodSeekInfo.isIndexExplicit) {
    long liveStreamDurationUs=getNowUnixTimeUs() - C.msToUs(manifest.availabilityStartTime);
    long liveStreamEndPositionInLastPeriodUs=liveStreamDurationUs - C.msToUs(manifest.getPeriod(lastPeriodIndex).startMs);
    currentEndTimeUs=Math.min(liveStreamEndPositionInLastPeriodUs,currentEndTimeUs);
    if (manifest.timeShiftBufferDepth != C.TIME_UNSET) {
      long timeShiftBufferDepthUs=C.msToUs(manifest.timeShiftBufferDepth);
      long offsetInPeriodUs=currentEndTimeUs - timeShiftBufferDepthUs;
      int periodIndex=lastPeriodIndex;
      while (offsetInPeriodUs < 0 && periodIndex > 0) {
        offsetInPeriodUs+=manifest.getPeriodDurationUs(--periodIndex);
      }
      if (periodIndex == 0) {
        currentStartTimeUs=Math.max(currentStartTimeUs,offsetInPeriodUs);
      }
 else {
        currentStartTimeUs=manifest.getPeriodDurationUs(0);
      }
    }
    handler.postDelayed(simulateManifestRefreshRunnable,NOTIFY_MANIFEST_INTERVAL_MS);
  }
  long windowDurationUs=currentEndTimeUs - currentStartTimeUs;
  for (int i=0; i < manifest.getPeriodCount() - 1; i++) {
    windowDurationUs+=manifest.getPeriodDurationUs(i);
  }
  long windowDefaultStartPositionUs=0;
  if (manifest.dynamic) {
    long presentationDelayForManifestMs=livePresentationDelayMs;
    if (presentationDelayForManifestMs == DEFAULT_LIVE_PRESENTATION_DELAY_PREFER_MANIFEST_MS) {
      presentationDelayForManifestMs=manifest.suggestedPresentationDelay != C.TIME_UNSET ? manifest.suggestedPresentationDelay : DEFAULT_LIVE_PRESENTATION_DELAY_FIXED_MS;
    }
    long defaultStartPositionUs=windowDurationUs - C.msToUs(presentationDelayForManifestMs);
    if (defaultStartPositionUs < MIN_LIVE_DEFAULT_START_POSITION_US) {
      defaultStartPositionUs=Math.min(MIN_LIVE_DEFAULT_START_POSITION_US,windowDurationUs / 2);
    }
    int periodIndex=0;
    long defaultStartPositionInPeriodUs=currentStartTimeUs + defaultStartPositionUs;
    long periodDurationUs=manifest.getPeriodDurationUs(periodIndex);
    while (periodIndex < manifest.getPeriodCount() - 1 && defaultStartPositionInPeriodUs >= periodDurationUs) {
      defaultStartPositionInPeriodUs-=periodDurationUs;
      periodIndex++;
      periodDurationUs=manifest.getPeriodDurationUs(periodIndex);
    }
    Period period=manifest.getPeriod(periodIndex);
    int videoAdaptationSetIndex=period.getAdaptationSetIndex(C.TRACK_TYPE_VIDEO);
    if (videoAdaptationSetIndex != C.INDEX_UNSET) {
      DashSegmentIndex index=period.adaptationSets.get(videoAdaptationSetIndex).representations.get(0).getIndex();
      if (index != null) {
        int segmentNum=index.getSegmentNum(defaultStartPositionInPeriodUs,periodDurationUs);
        windowDefaultStartPositionUs=defaultStartPositionUs - defaultStartPositionInPeriodUs + index.getTimeUs(segmentNum);
      }
 else {
        windowDefaultStartPositionUs=defaultStartPositionUs;
      }
    }
 else {
      windowDefaultStartPositionUs=defaultStartPositionUs;
    }
  }
  long windowStartTimeMs=manifest.availabilityStartTime + manifest.getPeriod(0).startMs + C.usToMs(currentStartTimeUs);
  DashTimeline timeline=new DashTimeline(manifest.availabilityStartTime,windowStartTimeMs,firstPeriodId,currentStartTimeUs,windowDurationUs,windowDefaultStartPositionUs,manifest);
  sourceListener.onSourceInfoRefreshed(timeline,manifest);
}",0.9858467545143972
110337,"private Class<?> getDecoderClass(String mimeType){
  try {
switch (mimeType) {
case MimeTypes.TEXT_VTT:
      return Class.forName(""String_Node_Str"");
case MimeTypes.APPLICATION_TTML:
    return Class.forName(""String_Node_Str"");
case MimeTypes.APPLICATION_MP4VTT:
  return Class.forName(""String_Node_Str"");
case MimeTypes.APPLICATION_SUBRIP:
return Class.forName(""String_Node_Str"");
case MimeTypes.APPLICATION_TX3G:
return Class.forName(""String_Node_Str"");
case MimeTypes.APPLICATION_CEA608:
return Class.forName(""String_Node_Str"");
default :
return null;
}
}
 catch (ClassNotFoundException e) {
return null;
}
}","private Class<?> getDecoderClass(String mimeType){
  if (mimeType == null) {
    return null;
  }
  try {
switch (mimeType) {
case MimeTypes.TEXT_VTT:
      return Class.forName(""String_Node_Str"");
case MimeTypes.APPLICATION_TTML:
    return Class.forName(""String_Node_Str"");
case MimeTypes.APPLICATION_MP4VTT:
  return Class.forName(""String_Node_Str"");
case MimeTypes.APPLICATION_SUBRIP:
return Class.forName(""String_Node_Str"");
case MimeTypes.APPLICATION_TX3G:
return Class.forName(""String_Node_Str"");
case MimeTypes.APPLICATION_CEA608:
return Class.forName(""String_Node_Str"");
default :
return null;
}
}
 catch (ClassNotFoundException e) {
return null;
}
}",0.963021243115657
110338,"/** 
 * Whether the top-level type of   {@code mimeType} is video.
 * @param mimeType The mimeType to test.
 * @return Whether the top level type is video.
 */
public static boolean isVideo(String mimeType){
  return getTopLevelType(mimeType).equals(BASE_TYPE_VIDEO);
}","/** 
 * Whether the top-level type of   {@code mimeType} is video.
 * @param mimeType The mimeType to test.
 * @return Whether the top level type is video.
 */
public static boolean isVideo(String mimeType){
  return BASE_TYPE_VIDEO.equals(getTopLevelType(mimeType));
}",0.8773234200743495
110339,"/** 
 * Returns the top-level type of   {@code mimeType}.
 * @param mimeType The mimeType whose top-level type is required.
 * @return The top-level type.
 */
private static String getTopLevelType(String mimeType){
  int indexOfSlash=mimeType.indexOf('/');
  if (indexOfSlash == -1) {
    throw new IllegalArgumentException(""String_Node_Str"" + mimeType);
  }
  return mimeType.substring(0,indexOfSlash);
}","/** 
 * Returns the top-level type of   {@code mimeType}.
 * @param mimeType The mimeType whose top-level type is required.
 * @return The top-level type, or null if the mimeType is null.
 */
private static String getTopLevelType(String mimeType){
  if (mimeType == null) {
    return null;
  }
  int indexOfSlash=mimeType.indexOf('/');
  if (indexOfSlash == -1) {
    throw new IllegalArgumentException(""String_Node_Str"" + mimeType);
  }
  return mimeType.substring(0,indexOfSlash);
}",0.9101123595505618
110340,"/** 
 * Whether the top-level type of   {@code mimeType} is audio.
 * @param mimeType The mimeType to test.
 * @return Whether the top level type is audio.
 */
public static boolean isAudio(String mimeType){
  return getTopLevelType(mimeType).equals(BASE_TYPE_AUDIO);
}","/** 
 * Whether the top-level type of   {@code mimeType} is audio.
 * @param mimeType The mimeType to test.
 * @return Whether the top level type is audio.
 */
public static boolean isAudio(String mimeType){
  return BASE_TYPE_AUDIO.equals(getTopLevelType(mimeType));
}",0.8773234200743495
110341,"/** 
 * Whether the top-level type of   {@code mimeType} is text.
 * @param mimeType The mimeType to test.
 * @return Whether the top level type is text.
 */
public static boolean isText(String mimeType){
  return getTopLevelType(mimeType).equals(BASE_TYPE_TEXT);
}","/** 
 * Whether the top-level type of   {@code mimeType} is text.
 * @param mimeType The mimeType to test.
 * @return Whether the top level type is text.
 */
public static boolean isText(String mimeType){
  return BASE_TYPE_TEXT.equals(getTopLevelType(mimeType));
}",0.8754716981132076
110342,"/** 
 * Whether the top-level type of   {@code mimeType} is application.
 * @param mimeType The mimeType to test.
 * @return Whether the top level type is application.
 */
public static boolean isApplication(String mimeType){
  return getTopLevelType(mimeType).equals(BASE_TYPE_APPLICATION);
}","/** 
 * Whether the top-level type of   {@code mimeType} is application.
 * @param mimeType The mimeType to test.
 * @return Whether the top level type is application.
 */
public static boolean isApplication(String mimeType){
  return BASE_TYPE_APPLICATION.equals(getTopLevelType(mimeType));
}",0.8873720136518771
110343,"@Override public long open(DataSpec dataSpec) throws HttpDataSourceException {
  Assertions.checkNotNull(dataSpec);
synchronized (this) {
    Assertions.checkState(connectionState == IDLE_CONNECTION,""String_Node_Str"");
    connectionState=OPENING_CONNECTION;
  }
  operation.close();
  resetConnectTimeout();
  currentDataSpec=dataSpec;
  UrlRequest.Builder urlRequestBuilder=new UrlRequest.Builder(dataSpec.uri.toString(),this,executor,cronetEngine);
  fillCurrentRequestHeader(urlRequestBuilder);
  fillCurrentRequestPostBody(urlRequestBuilder,dataSpec);
  currentUrlRequest=urlRequestBuilder.build();
  currentUrlRequest.start();
  boolean requestStarted=blockUntilConnectTimeout();
  if (exception != null) {
    throw exception;
  }
 else   if (!requestStarted) {
    throw new OpenException(new SocketTimeoutException(),dataSpec,getStatus(currentUrlRequest));
  }
  if (listener != null) {
    listener.onTransferStart(this,dataSpec);
  }
  connectionState=OPEN_CONNECTION;
  return contentLength;
}","@Override public long open(DataSpec dataSpec) throws HttpDataSourceException {
  Assertions.checkNotNull(dataSpec);
synchronized (this) {
    Assertions.checkState(connectionState == IDLE_CONNECTION,""String_Node_Str"");
    connectionState=OPENING_CONNECTION;
  }
  operation.close();
  resetConnectTimeout();
  currentDataSpec=dataSpec;
  currentUrlRequest=buildRequest(dataSpec);
  currentUrlRequest.start();
  boolean requestStarted=blockUntilConnectTimeout();
  if (exception != null) {
    throw exception;
  }
 else   if (!requestStarted) {
    throw new OpenException(new SocketTimeoutException(),dataSpec,getStatus(currentUrlRequest));
  }
  if (listener != null) {
    listener.onTransferStart(this,dataSpec);
  }
  connectionState=OPEN_CONNECTION;
  return contentLength;
}",0.8505875769445999
110344,"/** 
 * Rolls up the Cue one row.
 * @return true if rolling was possible.
 */
public boolean rollUp(){
  if (row < 1) {
    return false;
  }
  setRow(row - 1);
  return true;
}","/** 
 * Rolls up the Cue one row.
 * @return true if rolling was possible.
 */
public boolean rollUp(){
  if (row <= 1) {
    return false;
  }
  setRow(row - 1);
  return true;
}",0.9971988795518208
110345,"private void handleMiscCode(byte cc2){
switch (cc2) {
case CTRL_ROLL_UP_CAPTIONS_2_ROWS:
    captionRowCount=2;
  setCaptionMode(CC_MODE_ROLL_UP);
return;
case CTRL_ROLL_UP_CAPTIONS_3_ROWS:
captionRowCount=3;
setCaptionMode(CC_MODE_ROLL_UP);
return;
case CTRL_ROLL_UP_CAPTIONS_4_ROWS:
captionRowCount=4;
setCaptionMode(CC_MODE_ROLL_UP);
return;
case CTRL_RESUME_CAPTION_LOADING:
setCaptionMode(CC_MODE_POP_ON);
return;
case CTRL_RESUME_DIRECT_CAPTIONING:
setCaptionMode(CC_MODE_PAINT_ON);
return;
}
if (captionMode == CC_MODE_UNKNOWN) {
return;
}
switch (cc2) {
case CTRL_ERASE_DISPLAYED_MEMORY:
if (captionMode == CC_MODE_ROLL_UP || captionMode == CC_MODE_PAINT_ON) {
currentCue=new Eia608CueBuilder();
cues.clear();
}
subtitle.setCues(Collections.<Cue>emptyList());
return;
case CTRL_ERASE_NON_DISPLAYED_MEMORY:
currentCue=new Eia608CueBuilder();
cues.clear();
return;
case CTRL_END_OF_CAPTION:
renderCues();
cues.clear();
return;
case CTRL_CARRIAGE_RETURN:
if (captionMode == CC_MODE_ROLL_UP) {
for (Eia608CueBuilder cue : cues) {
if (!cue.rollUp()) {
cues.remove(cue);
}
}
currentCue=new Eia608CueBuilder();
cues.add(currentCue);
while (cues.size() > captionRowCount) {
cues.pollFirst();
}
}
return;
case CTRL_BACKSPACE:
currentCue.backspace();
return;
case CTRL_DELETE_TO_END_OF_ROW:
return;
}
}","private void handleMiscCode(byte cc2){
switch (cc2) {
case CTRL_ROLL_UP_CAPTIONS_2_ROWS:
    captionRowCount=2;
  setCaptionMode(CC_MODE_ROLL_UP);
return;
case CTRL_ROLL_UP_CAPTIONS_3_ROWS:
captionRowCount=3;
setCaptionMode(CC_MODE_ROLL_UP);
return;
case CTRL_ROLL_UP_CAPTIONS_4_ROWS:
captionRowCount=4;
setCaptionMode(CC_MODE_ROLL_UP);
return;
case CTRL_RESUME_CAPTION_LOADING:
setCaptionMode(CC_MODE_POP_ON);
return;
case CTRL_RESUME_DIRECT_CAPTIONING:
setCaptionMode(CC_MODE_PAINT_ON);
return;
}
if (captionMode == CC_MODE_UNKNOWN) {
return;
}
switch (cc2) {
case CTRL_ERASE_DISPLAYED_MEMORY:
if (captionMode == CC_MODE_ROLL_UP || captionMode == CC_MODE_PAINT_ON) {
currentCue=new Eia608CueBuilder();
cues.clear();
}
subtitle.setCues(Collections.<Cue>emptyList());
return;
case CTRL_ERASE_NON_DISPLAYED_MEMORY:
currentCue=new Eia608CueBuilder();
cues.clear();
return;
case CTRL_END_OF_CAPTION:
renderCues();
cues.clear();
return;
case CTRL_CARRIAGE_RETURN:
if (captionMode == CC_MODE_ROLL_UP) {
Iterator<Eia608CueBuilder> iterator=cues.iterator();
while (iterator.hasNext()) {
Eia608CueBuilder cue=iterator.next();
if (!cue.rollUp()) {
iterator.remove();
}
}
currentCue=new Eia608CueBuilder();
cues.add(currentCue);
while (cues.size() > captionRowCount) {
cues.pollFirst();
}
}
return;
case CTRL_BACKSPACE:
currentCue.backspace();
return;
case CTRL_DELETE_TO_END_OF_ROW:
return;
}
}",0.913221601489758
110346,"@Override public long getBufferedPosition(){
  if (timeline == null || pendingSeekAcks > 0) {
    return maskingWindowPositionMs;
  }
 else {
    int periodIndex=playbackInfo.periodIndex;
    timeline.getPeriod(periodIndex,period);
    int windowIndex=period.windowIndex;
    timeline.getWindow(windowIndex,window);
    if (window.firstPeriodIndex == periodIndex && window.lastPeriodIndex == periodIndex && window.getPositionInFirstPeriodUs() == 0 && window.getDurationUs() == period.getDurationUs()) {
      return C.usToMs(playbackInfo.bufferedPositionUs);
    }
    return getCurrentPosition();
  }
}","@Override public long getBufferedPosition(){
  if (timeline == null || pendingSeekAcks > 0) {
    return maskingWindowPositionMs;
  }
 else {
    timeline.getPeriod(playbackInfo.periodIndex,period);
    return period.getPositionInWindowMs() + C.usToMs(playbackInfo.bufferedPositionUs);
  }
}",0.4295302013422818
110347,"private void maybeContinueLoading(){
  long nextLoadPositionUs=loadingPeriodHolder.mediaPeriod.getNextLoadPositionUs();
  if (nextLoadPositionUs != C.TIME_END_OF_SOURCE) {
    long loadingPeriodPositionUs=rendererPositionUs - loadingPeriodHolder.rendererPositionOffsetUs + loadingPeriodHolder.startPositionUs;
    long bufferedDurationUs=nextLoadPositionUs - loadingPeriodPositionUs;
    boolean continueLoading=loadControl.shouldContinueLoading(bufferedDurationUs);
    setIsLoading(continueLoading);
    if (continueLoading) {
      loadingPeriodHolder.needsContinueLoading=false;
      loadingPeriodHolder.mediaPeriod.continueLoading(loadingPeriodPositionUs);
    }
 else {
      loadingPeriodHolder.needsContinueLoading=true;
    }
  }
 else {
    setIsLoading(false);
  }
}","private void maybeContinueLoading(){
  long nextLoadPositionUs=loadingPeriodHolder.mediaPeriod.getNextLoadPositionUs();
  if (nextLoadPositionUs != C.TIME_END_OF_SOURCE) {
    long loadingPeriodPositionUs=rendererPositionUs - loadingPeriodHolder.rendererPositionOffsetUs;
    long bufferedDurationUs=nextLoadPositionUs - loadingPeriodPositionUs;
    boolean continueLoading=loadControl.shouldContinueLoading(bufferedDurationUs);
    setIsLoading(continueLoading);
    if (continueLoading) {
      loadingPeriodHolder.needsContinueLoading=false;
      loadingPeriodHolder.mediaPeriod.continueLoading(loadingPeriodPositionUs);
    }
 else {
      loadingPeriodHolder.needsContinueLoading=true;
    }
  }
 else {
    setIsLoading(false);
  }
}",0.9749670619235836
110348,"/** 
 * Returns the stream info read from the available descriptors, or -1 if no descriptors are present. Sets   {@code data}'s position to the end of the descriptors.
 * @param data A buffer with its position set to the start of the first descriptor.
 * @param length The length of descriptors to read from the current position in {@code data}.
 * @return The stream info read from the available descriptors, or -1 if nodescriptors are present.
 */
private EsInfo readEsInfo(ParsableByteArray data,int length){
  int descriptorsEndPosition=data.getPosition() + length;
  int streamType=-1;
  int audioType=-1;
  String language=null;
  while (data.getPosition() < descriptorsEndPosition) {
    int descriptorTag=data.readUnsignedByte();
    int descriptorLength=data.readUnsignedByte();
    if (descriptorTag == TS_PMT_DESC_REGISTRATION) {
      long formatIdentifier=data.readUnsignedInt();
      if (formatIdentifier == AC3_FORMAT_IDENTIFIER) {
        streamType=TS_STREAM_TYPE_AC3;
      }
 else       if (formatIdentifier == E_AC3_FORMAT_IDENTIFIER) {
        streamType=TS_STREAM_TYPE_E_AC3;
      }
 else       if (formatIdentifier == HEVC_FORMAT_IDENTIFIER) {
        streamType=TS_STREAM_TYPE_H265;
      }
      break;
    }
 else     if (descriptorTag == TS_PMT_DESC_AC3) {
      streamType=TS_STREAM_TYPE_AC3;
    }
 else     if (descriptorTag == TS_PMT_DESC_EAC3) {
      streamType=TS_STREAM_TYPE_E_AC3;
    }
 else     if (descriptorTag == TS_PMT_DESC_DTS) {
      streamType=TS_STREAM_TYPE_DTS;
    }
 else     if (descriptorTag == TS_PMT_DESC_ISO639_LANG) {
      language=new String(data.data,data.getPosition(),3).trim();
      audioType=data.data[data.getPosition() + 3];
    }
    data.skipBytes(descriptorLength);
  }
  data.setPosition(descriptorsEndPosition);
  return new EsInfo(streamType,audioType,language);
}","/** 
 * Returns the stream info read from the available descriptors, or -1 if no descriptors are present. Sets   {@code data}'s position to the end of the descriptors.
 * @param data A buffer with its position set to the start of the first descriptor.
 * @param length The length of descriptors to read from the current position in {@code data}.
 * @return The stream info read from the available descriptors, or -1 if nodescriptors are present.
 */
private EsInfo readEsInfo(ParsableByteArray data,int length){
  int descriptorsEndPosition=data.getPosition() + length;
  int streamType=-1;
  int audioType=-1;
  String language=null;
  while (data.getPosition() < descriptorsEndPosition) {
    int descriptorTag=data.readUnsignedByte();
    int descriptorLength=data.readUnsignedByte();
    int positionOfNextDescriptor=data.getPosition() + descriptorLength;
    if (descriptorTag == TS_PMT_DESC_REGISTRATION) {
      long formatIdentifier=data.readUnsignedInt();
      if (formatIdentifier == AC3_FORMAT_IDENTIFIER) {
        streamType=TS_STREAM_TYPE_AC3;
      }
 else       if (formatIdentifier == E_AC3_FORMAT_IDENTIFIER) {
        streamType=TS_STREAM_TYPE_E_AC3;
      }
 else       if (formatIdentifier == HEVC_FORMAT_IDENTIFIER) {
        streamType=TS_STREAM_TYPE_H265;
      }
    }
 else     if (descriptorTag == TS_PMT_DESC_AC3) {
      streamType=TS_STREAM_TYPE_AC3;
    }
 else     if (descriptorTag == TS_PMT_DESC_EAC3) {
      streamType=TS_STREAM_TYPE_E_AC3;
    }
 else     if (descriptorTag == TS_PMT_DESC_DTS) {
      streamType=TS_STREAM_TYPE_DTS;
    }
 else     if (descriptorTag == TS_PMT_DESC_ISO639_LANG) {
      language=new String(data.data,data.getPosition(),3).trim();
      audioType=data.data[data.getPosition() + 3];
    }
    data.skipBytes(positionOfNextDescriptor - data.getPosition());
  }
  data.setPosition(descriptorsEndPosition);
  return new EsInfo(streamType,audioType,language);
}",0.961211477151966
110349,"/** 
 * Parses a udta atom for metadata, including gapless playback information.
 * @param udtaAtom The udta (user data) atom to decode.
 * @param isQuickTime True for QuickTime media. False otherwise.
 * @return metadata stored in the user data, or {@code null} if not present.
 */
public static Metadata parseUdta(Atom.LeafAtom udtaAtom,boolean isQuickTime){
  if (isQuickTime) {
    return null;
  }
  ParsableByteArray udtaData=udtaAtom.data;
  udtaData.setPosition(Atom.HEADER_SIZE);
  while (udtaData.bytesLeft() >= Atom.HEADER_SIZE) {
    int atomSize=udtaData.readInt();
    int atomType=udtaData.readInt();
    if (atomType == Atom.TYPE_meta) {
      udtaData.setPosition(udtaData.getPosition() - Atom.HEADER_SIZE);
      udtaData.setLimit(udtaData.getPosition() + atomSize);
      parseMetaAtom(udtaData);
      break;
    }
    udtaData.skipBytes(atomSize - Atom.HEADER_SIZE);
  }
  return null;
}","/** 
 * Parses a udta atom for metadata, including gapless playback information.
 * @param udtaAtom The udta (user data) atom to decode.
 * @param isQuickTime True for QuickTime media. False otherwise.
 * @return metadata stored in the user data, or {@code null} if not present.
 */
public static Metadata parseUdta(Atom.LeafAtom udtaAtom,boolean isQuickTime){
  if (isQuickTime) {
    return null;
  }
  ParsableByteArray udtaData=udtaAtom.data;
  udtaData.setPosition(Atom.HEADER_SIZE);
  while (udtaData.bytesLeft() >= Atom.HEADER_SIZE) {
    int atomSize=udtaData.readInt();
    int atomType=udtaData.readInt();
    if (atomType == Atom.TYPE_meta) {
      udtaData.setPosition(udtaData.getPosition() - Atom.HEADER_SIZE);
      udtaData.setLimit(udtaData.getPosition() + atomSize);
      return parseMetaAtom(udtaData);
    }
    udtaData.skipBytes(atomSize - Atom.HEADER_SIZE);
  }
  return null;
}",0.988950276243094
110350,"private void initializePlayer(){
  Intent intent=getIntent();
  if (player == null) {
    boolean preferExtensionDecoders=intent.getBooleanExtra(PREFER_EXTENSION_DECODERS,false);
    UUID drmSchemeUuid=intent.hasExtra(DRM_SCHEME_UUID_EXTRA) ? UUID.fromString(intent.getStringExtra(DRM_SCHEME_UUID_EXTRA)) : null;
    DrmSessionManager drmSessionManager=null;
    if (drmSchemeUuid != null) {
      String drmLicenseUrl=intent.getStringExtra(DRM_LICENSE_URL);
      try {
        drmSessionManager=buildDrmSessionManager(drmSchemeUuid,drmLicenseUrl);
      }
 catch (      UnsupportedDrmException e) {
        int errorStringId=Util.SDK_INT < 18 ? R.string.error_drm_not_supported : (e.reason == UnsupportedDrmException.REASON_UNSUPPORTED_SCHEME ? R.string.error_drm_unsupported_scheme : R.string.error_drm_unknown);
        showToast(errorStringId);
        return;
      }
    }
    eventLogger=new EventLogger();
    TrackSelection.Factory videoTrackSelectionFactory=new AdaptiveVideoTrackSelection.Factory(BANDWIDTH_METER);
    trackSelector=new DefaultTrackSelector(mainHandler,videoTrackSelectionFactory);
    trackSelector.addListener(this);
    trackSelector.addListener(eventLogger);
    trackSelectionHelper=new TrackSelectionHelper(trackSelector,videoTrackSelectionFactory);
    player=ExoPlayerFactory.newSimpleInstance(this,trackSelector,new DefaultLoadControl(),drmSessionManager,preferExtensionDecoders);
    player.addListener(this);
    player.addListener(eventLogger);
    player.setDebugListener(eventLogger);
    player.setId3Output(eventLogger);
    player.setTextOutput(subtitleView);
    player.setVideoListener(this);
    player.setVideoSurfaceHolder(surfaceView.getHolder());
    if (shouldRestorePosition) {
      player.seekInPeriod(playerPeriodIndex,playerPosition);
    }
    player.setPlayWhenReady(true);
    mediaController.setMediaPlayer(new PlayerControl(player));
    mediaController.setPrevNextListeners(new MediaControllerPrevNextClickListener(player,true),new MediaControllerPrevNextClickListener(player,false));
    mediaController.setAnchorView(rootView);
    debugViewHelper=new DebugTextViewHelper(player,debugTextView);
    debugViewHelper.start();
    playerNeedsSource=true;
  }
  if (playerNeedsSource) {
    String action=intent.getAction();
    Uri[] uris;
    String[] extensions;
    if (ACTION_VIEW.equals(action)) {
      uris=new Uri[]{intent.getData()};
      extensions=new String[]{intent.getStringExtra(EXTENSION_EXTRA)};
    }
 else     if (ACTION_VIEW_LIST.equals(action)) {
      String[] uriStrings=intent.getStringArrayExtra(URI_LIST_EXTRA);
      uris=new Uri[uriStrings.length];
      for (int i=0; i < uriStrings.length; i++) {
        uris[i]=Uri.parse(uriStrings[i]);
      }
      extensions=intent.getStringArrayExtra(EXTENSION_LIST_EXTRA);
      if (extensions == null) {
        extensions=new String[uriStrings.length];
      }
    }
 else {
      showToast(getString(R.string.unexpected_intent_action,action));
      return;
    }
    if (Util.maybeRequestReadExternalStoragePermission(this,uris)) {
      return;
    }
    MediaSource[] mediaSources=new MediaSource[uris.length];
    for (int i=0; i < uris.length; i++) {
      mediaSources[i]=buildMediaSource(uris[i],extensions[i]);
    }
    MediaSource mediaSource=mediaSources.length == 1 ? mediaSources[0] : new ConcatenatingMediaSource(mediaSources);
    player.setMediaSource(mediaSource,!shouldRestorePosition);
    playerNeedsSource=false;
    updateButtonVisibilities();
  }
}","private void initializePlayer(){
  Intent intent=getIntent();
  if (player == null) {
    boolean preferExtensionDecoders=intent.getBooleanExtra(PREFER_EXTENSION_DECODERS,false);
    UUID drmSchemeUuid=intent.hasExtra(DRM_SCHEME_UUID_EXTRA) ? UUID.fromString(intent.getStringExtra(DRM_SCHEME_UUID_EXTRA)) : null;
    DrmSessionManager drmSessionManager=null;
    if (drmSchemeUuid != null) {
      String drmLicenseUrl=intent.getStringExtra(DRM_LICENSE_URL);
      try {
        drmSessionManager=buildDrmSessionManager(drmSchemeUuid,drmLicenseUrl);
      }
 catch (      UnsupportedDrmException e) {
        int errorStringId=Util.SDK_INT < 18 ? R.string.error_drm_not_supported : (e.reason == UnsupportedDrmException.REASON_UNSUPPORTED_SCHEME ? R.string.error_drm_unsupported_scheme : R.string.error_drm_unknown);
        showToast(errorStringId);
        return;
      }
    }
    eventLogger=new EventLogger();
    TrackSelection.Factory videoTrackSelectionFactory=new AdaptiveVideoTrackSelection.Factory(BANDWIDTH_METER);
    trackSelector=new DefaultTrackSelector(mainHandler,videoTrackSelectionFactory);
    trackSelector.addListener(this);
    trackSelector.addListener(eventLogger);
    trackSelectionHelper=new TrackSelectionHelper(trackSelector,videoTrackSelectionFactory);
    player=ExoPlayerFactory.newSimpleInstance(this,trackSelector,new DefaultLoadControl(),drmSessionManager,preferExtensionDecoders);
    player.addListener(this);
    player.addListener(eventLogger);
    player.setDebugListener(eventLogger);
    player.setId3Output(eventLogger);
    player.setTextOutput(subtitleView);
    player.setVideoListener(this);
    player.setVideoSurfaceHolder(surfaceView.getHolder());
    if (shouldRestorePosition) {
      if (playerPosition == -1) {
        player.seekToDefaultPositionForPeriod(playerPeriod);
      }
 else {
        player.seekInPeriod(playerPeriod,playerPosition);
      }
    }
    player.setPlayWhenReady(true);
    mediaController.setMediaPlayer(new PlayerControl(player));
    mediaController.setPrevNextListeners(new MediaControllerPrevNextClickListener(player,true),new MediaControllerPrevNextClickListener(player,false));
    mediaController.setAnchorView(rootView);
    debugViewHelper=new DebugTextViewHelper(player,debugTextView);
    debugViewHelper.start();
    playerNeedsSource=true;
  }
  if (playerNeedsSource) {
    String action=intent.getAction();
    Uri[] uris;
    String[] extensions;
    if (ACTION_VIEW.equals(action)) {
      uris=new Uri[]{intent.getData()};
      extensions=new String[]{intent.getStringExtra(EXTENSION_EXTRA)};
    }
 else     if (ACTION_VIEW_LIST.equals(action)) {
      String[] uriStrings=intent.getStringArrayExtra(URI_LIST_EXTRA);
      uris=new Uri[uriStrings.length];
      for (int i=0; i < uriStrings.length; i++) {
        uris[i]=Uri.parse(uriStrings[i]);
      }
      extensions=intent.getStringArrayExtra(EXTENSION_LIST_EXTRA);
      if (extensions == null) {
        extensions=new String[uriStrings.length];
      }
    }
 else {
      showToast(getString(R.string.unexpected_intent_action,action));
      return;
    }
    if (Util.maybeRequestReadExternalStoragePermission(this,uris)) {
      return;
    }
    MediaSource[] mediaSources=new MediaSource[uris.length];
    for (int i=0; i < uris.length; i++) {
      mediaSources[i]=buildMediaSource(uris[i],extensions[i]);
    }
    MediaSource mediaSource=mediaSources.length == 1 ? mediaSources[0] : new ConcatenatingMediaSource(mediaSources);
    player.setMediaSource(mediaSource,!shouldRestorePosition);
    playerNeedsSource=false;
    updateButtonVisibilities();
  }
}",0.9823430493273544
110351,"@Override public void onNewIntent(Intent intent){
  releasePlayer();
  playerPosition=0;
  setIntent(intent);
}","@Override public void onNewIntent(Intent intent){
  releasePlayer();
  shouldRestorePosition=false;
  setIntent(intent);
}",0.9184549356223176
110352,"private void releasePlayer(){
  if (player != null) {
    shutterView.setVisibility(View.VISIBLE);
    debugViewHelper.stop();
    debugViewHelper=null;
    playerPeriodIndex=player.getCurrentPeriodIndex();
    playerPosition=player.getCurrentPositionInPeriod();
    shouldRestorePosition=false;
    Timeline playerTimeline=player.getCurrentTimeline();
    if (playerTimeline != null) {
      Window window=playerTimeline.getWindow(playerPeriodIndex);
      if (window.isSeekable && !window.isDynamic) {
        shouldRestorePosition=true;
      }
    }
    player.release();
    player=null;
    trackSelector=null;
    trackSelectionHelper=null;
    eventLogger=null;
  }
}","private void releasePlayer(){
  if (player != null) {
    shutterView.setVisibility(View.VISIBLE);
    debugViewHelper.stop();
    debugViewHelper=null;
    shouldRestorePosition=false;
    Timeline playerTimeline=player.getCurrentTimeline();
    if (playerTimeline != null) {
      Window window=playerTimeline.getWindow(player.getCurrentWindowIndex());
      if (!window.isDynamic) {
        shouldRestorePosition=true;
        playerPeriod=player.getCurrentPeriodIndex();
        playerPosition=window.isSeekable ? player.getCurrentPositionInPeriod() : -1;
      }
    }
    player.release();
    player=null;
    trackSelector=null;
    trackSelectionHelper=null;
    eventLogger=null;
  }
}",0.5416058394160584
110353,"/** 
 * Parses a trun atom (defined in 14496-12).
 * @param trackBundle The {@link TrackBundle} that contains the {@link TrackFragment} intowhich parsed data should be placed.
 * @param index Index of the track run in the fragment.
 * @param decodeTime The decode time of the first sample in the fragment run.
 * @param flags Flags to allow any required workaround to be executed.
 * @param trun The trun atom to decode.
 * @return The starting position of samples for the next run.
 */
private static int parseTrun(TrackBundle trackBundle,int index,long decodeTime,int flags,ParsableByteArray trun,int trackRunStart){
  trun.setPosition(Atom.HEADER_SIZE);
  int fullAtom=trun.readInt();
  int atomFlags=Atom.parseFullAtomFlags(fullAtom);
  Track track=trackBundle.track;
  TrackFragment fragment=trackBundle.fragment;
  DefaultSampleValues defaultSampleValues=fragment.header;
  fragment.trunLength[index]=trun.readUnsignedIntToInt();
  if ((atomFlags & 0x01) != 0) {
    fragment.trunDataPosition[index]=fragment.dataPosition + trun.readInt();
  }
  boolean firstSampleFlagsPresent=(atomFlags & 0x04) != 0;
  int firstSampleFlags=defaultSampleValues.flags;
  if (firstSampleFlagsPresent) {
    firstSampleFlags=trun.readUnsignedIntToInt();
  }
  boolean sampleDurationsPresent=(atomFlags & 0x100) != 0;
  boolean sampleSizesPresent=(atomFlags & 0x200) != 0;
  boolean sampleFlagsPresent=(atomFlags & 0x400) != 0;
  boolean sampleCompositionTimeOffsetsPresent=(atomFlags & 0x800) != 0;
  long edtsOffset=0;
  if (track.editListDurations != null && track.editListDurations.length == 1 && track.editListDurations[0] == 0) {
    edtsOffset=Util.scaleLargeTimestamp(track.editListMediaTimes[0],1000,track.timescale);
  }
  int[] sampleSizeTable=fragment.sampleSizeTable;
  int[] sampleCompositionTimeOffsetTable=fragment.sampleCompositionTimeOffsetTable;
  long[] sampleDecodingTimeTable=fragment.sampleDecodingTimeTable;
  boolean[] sampleIsSyncFrameTable=fragment.sampleIsSyncFrameTable;
  boolean workaroundEveryVideoFrameIsSyncFrame=track.type == C.TRACK_TYPE_VIDEO && (flags & FLAG_WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME) != 0;
  int trackRunEnd=trackRunStart + fragment.trunLength[index];
  long timescale=track.timescale;
  long cumulativeTime=index > 0 ? fragment.nextFragmentDecodeTime : decodeTime;
  for (int i=trackRunStart; i < trackRunEnd; i++) {
    int sampleDuration=sampleDurationsPresent ? trun.readUnsignedIntToInt() : defaultSampleValues.duration;
    int sampleSize=sampleSizesPresent ? trun.readUnsignedIntToInt() : defaultSampleValues.size;
    int sampleFlags=(i == 0 && firstSampleFlagsPresent) ? firstSampleFlags : sampleFlagsPresent ? trun.readInt() : defaultSampleValues.flags;
    if (sampleCompositionTimeOffsetsPresent) {
      int sampleOffset=trun.readInt();
      sampleCompositionTimeOffsetTable[i]=(int)((sampleOffset * 1000) / timescale);
    }
 else {
      sampleCompositionTimeOffsetTable[i]=0;
    }
    sampleDecodingTimeTable[i]=Util.scaleLargeTimestamp(cumulativeTime,1000,timescale) - edtsOffset;
    sampleSizeTable[i]=sampleSize;
    sampleIsSyncFrameTable[i]=((sampleFlags >> 16) & 0x1) == 0 && (!workaroundEveryVideoFrameIsSyncFrame || i == 0);
    cumulativeTime+=sampleDuration;
  }
  fragment.nextFragmentDecodeTime=cumulativeTime;
  return trackRunEnd;
}","/** 
 * Parses a trun atom (defined in 14496-12).
 * @param trackBundle The {@link TrackBundle} that contains the {@link TrackFragment} intowhich parsed data should be placed.
 * @param index Index of the track run in the fragment.
 * @param decodeTime The decode time of the first sample in the fragment run.
 * @param flags Flags to allow any required workaround to be executed.
 * @param trun The trun atom to decode.
 * @return The starting position of samples for the next run.
 */
private static int parseTrun(TrackBundle trackBundle,int index,long decodeTime,int flags,ParsableByteArray trun,int trackRunStart){
  trun.setPosition(Atom.HEADER_SIZE);
  int fullAtom=trun.readInt();
  int atomFlags=Atom.parseFullAtomFlags(fullAtom);
  Track track=trackBundle.track;
  TrackFragment fragment=trackBundle.fragment;
  DefaultSampleValues defaultSampleValues=fragment.header;
  fragment.trunLength[index]=trun.readUnsignedIntToInt();
  fragment.trunDataPosition[index]=fragment.dataPosition;
  if ((atomFlags & 0x01) != 0) {
    fragment.trunDataPosition[index]+=trun.readInt();
  }
  boolean firstSampleFlagsPresent=(atomFlags & 0x04) != 0;
  int firstSampleFlags=defaultSampleValues.flags;
  if (firstSampleFlagsPresent) {
    firstSampleFlags=trun.readUnsignedIntToInt();
  }
  boolean sampleDurationsPresent=(atomFlags & 0x100) != 0;
  boolean sampleSizesPresent=(atomFlags & 0x200) != 0;
  boolean sampleFlagsPresent=(atomFlags & 0x400) != 0;
  boolean sampleCompositionTimeOffsetsPresent=(atomFlags & 0x800) != 0;
  long edtsOffset=0;
  if (track.editListDurations != null && track.editListDurations.length == 1 && track.editListDurations[0] == 0) {
    edtsOffset=Util.scaleLargeTimestamp(track.editListMediaTimes[0],1000,track.timescale);
  }
  int[] sampleSizeTable=fragment.sampleSizeTable;
  int[] sampleCompositionTimeOffsetTable=fragment.sampleCompositionTimeOffsetTable;
  long[] sampleDecodingTimeTable=fragment.sampleDecodingTimeTable;
  boolean[] sampleIsSyncFrameTable=fragment.sampleIsSyncFrameTable;
  boolean workaroundEveryVideoFrameIsSyncFrame=track.type == C.TRACK_TYPE_VIDEO && (flags & FLAG_WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME) != 0;
  int trackRunEnd=trackRunStart + fragment.trunLength[index];
  long timescale=track.timescale;
  long cumulativeTime=index > 0 ? fragment.nextFragmentDecodeTime : decodeTime;
  for (int i=trackRunStart; i < trackRunEnd; i++) {
    int sampleDuration=sampleDurationsPresent ? trun.readUnsignedIntToInt() : defaultSampleValues.duration;
    int sampleSize=sampleSizesPresent ? trun.readUnsignedIntToInt() : defaultSampleValues.size;
    int sampleFlags=(i == 0 && firstSampleFlagsPresent) ? firstSampleFlags : sampleFlagsPresent ? trun.readInt() : defaultSampleValues.flags;
    if (sampleCompositionTimeOffsetsPresent) {
      int sampleOffset=trun.readInt();
      sampleCompositionTimeOffsetTable[i]=(int)((sampleOffset * 1000) / timescale);
    }
 else {
      sampleCompositionTimeOffsetTable[i]=0;
    }
    sampleDecodingTimeTable[i]=Util.scaleLargeTimestamp(cumulativeTime,1000,timescale) - edtsOffset;
    sampleSizeTable[i]=sampleSize;
    sampleIsSyncFrameTable[i]=((sampleFlags >> 16) & 0x1) == 0 && (!workaroundEveryVideoFrameIsSyncFrame || i == 0);
    cumulativeTime+=sampleDuration;
  }
  fragment.nextFragmentDecodeTime=cumulativeTime;
  return trackRunEnd;
}",0.9875244250713964
110354,"private void doSomeWork() throws ExoPlaybackException, IOException {
  long operationStartTimeMs=SystemClock.elapsedRealtime();
  updatePeriods();
  if (playingPeriod == null) {
    maybeThrowPeriodPrepareError();
    scheduleNextOperation(MSG_DO_SOME_WORK,operationStartTimeMs,PREPARING_SOURCE_INTERVAL_MS);
    return;
  }
  TraceUtil.beginSection(""String_Node_Str"");
  updatePlaybackPositions();
  boolean allRenderersEnded=true;
  boolean allRenderersReadyOrEnded=true;
  for (  Renderer renderer : enabledRenderers) {
    renderer.render(internalPositionUs,elapsedRealtimeUs);
    allRenderersEnded=allRenderersEnded && renderer.isEnded();
    boolean rendererReadyOrEnded=renderer.isReady() || renderer.isEnded();
    if (!rendererReadyOrEnded) {
      renderer.maybeThrowStreamError();
    }
    allRenderersReadyOrEnded=allRenderersReadyOrEnded && rendererReadyOrEnded;
  }
  if (!allRenderersReadyOrEnded) {
    maybeThrowPeriodPrepareError();
  }
  if (allRenderersEnded && (playbackInfo.durationUs == C.UNSET_TIME_US || playbackInfo.durationUs <= playbackInfo.positionUs) && isTimelineEnded) {
    setState(ExoPlayer.STATE_ENDED);
    stopRenderers();
  }
 else   if (state == ExoPlayer.STATE_BUFFERING) {
    if ((enabledRenderers.length > 0 ? allRenderersReadyOrEnded : isTimelineReady) && haveSufficientBuffer(rebuffering)) {
      setState(ExoPlayer.STATE_READY);
      if (playWhenReady) {
        startRenderers();
      }
    }
  }
 else   if (state == ExoPlayer.STATE_READY) {
    if (enabledRenderers.length > 0 ? !allRenderersReadyOrEnded : !isTimelineReady) {
      rebuffering=playWhenReady;
      setState(ExoPlayer.STATE_BUFFERING);
      stopRenderers();
    }
  }
  if (state == ExoPlayer.STATE_BUFFERING) {
    for (    Renderer renderer : enabledRenderers) {
      renderer.maybeThrowStreamError();
    }
  }
  handler.removeMessages(MSG_DO_SOME_WORK);
  if ((playWhenReady && state == ExoPlayer.STATE_READY) || state == ExoPlayer.STATE_BUFFERING) {
    scheduleNextOperation(MSG_DO_SOME_WORK,operationStartTimeMs,RENDERING_INTERVAL_MS);
  }
 else   if (enabledRenderers.length != 0) {
    scheduleNextOperation(MSG_DO_SOME_WORK,operationStartTimeMs,IDLE_INTERVAL_MS);
  }
  TraceUtil.endSection();
}","private void doSomeWork() throws ExoPlaybackException, IOException {
  long operationStartTimeMs=SystemClock.elapsedRealtime();
  updatePeriods();
  if (playingPeriod == null) {
    maybeThrowPeriodPrepareError();
    scheduleNextOperation(MSG_DO_SOME_WORK,operationStartTimeMs,PREPARING_SOURCE_INTERVAL_MS);
    return;
  }
  TraceUtil.beginSection(""String_Node_Str"");
  updatePlaybackPositions();
  boolean allRenderersEnded=true;
  boolean allRenderersReadyOrEnded=true;
  for (  Renderer renderer : enabledRenderers) {
    renderer.render(internalPositionUs,elapsedRealtimeUs);
    allRenderersEnded=allRenderersEnded && renderer.isEnded();
    boolean rendererReadyOrEnded=renderer.isReady() || renderer.isEnded();
    if (!rendererReadyOrEnded) {
      renderer.maybeThrowStreamError();
    }
    allRenderersReadyOrEnded=allRenderersReadyOrEnded && rendererReadyOrEnded;
  }
  if (!allRenderersReadyOrEnded) {
    maybeThrowPeriodPrepareError();
  }
  if (allRenderersEnded && (playbackInfo.durationUs == C.UNSET_TIME_US || playbackInfo.durationUs <= playbackInfo.positionUs) && isTimelineEnded) {
    setState(ExoPlayer.STATE_ENDED);
    stopRenderers();
  }
 else   if (state == ExoPlayer.STATE_BUFFERING) {
    if ((enabledRenderers.length > 0 ? (allRenderersReadyOrEnded && haveSufficientBuffer(rebuffering)) : isTimelineReady)) {
      setState(ExoPlayer.STATE_READY);
      if (playWhenReady) {
        startRenderers();
      }
    }
  }
 else   if (state == ExoPlayer.STATE_READY) {
    if (enabledRenderers.length > 0 ? !allRenderersReadyOrEnded : !isTimelineReady) {
      rebuffering=playWhenReady;
      setState(ExoPlayer.STATE_BUFFERING);
      stopRenderers();
    }
  }
  if (state == ExoPlayer.STATE_BUFFERING) {
    for (    Renderer renderer : enabledRenderers) {
      renderer.maybeThrowStreamError();
    }
  }
  handler.removeMessages(MSG_DO_SOME_WORK);
  if ((playWhenReady && state == ExoPlayer.STATE_READY) || state == ExoPlayer.STATE_BUFFERING) {
    scheduleNextOperation(MSG_DO_SOME_WORK,operationStartTimeMs,RENDERING_INTERVAL_MS);
  }
 else   if (enabledRenderers.length != 0) {
    scheduleNextOperation(MSG_DO_SOME_WORK,operationStartTimeMs,IDLE_INTERVAL_MS);
  }
  TraceUtil.endSection();
}",0.980269058295964
110355,"private void reselectTracksInternal() throws ExoPlaybackException {
  if (playingPeriod == null) {
    return;
  }
  Period period=playingPeriod;
  boolean selectionsChangedForReadPeriod=true;
  while (true) {
    if (period == null || !period.prepared) {
      return;
    }
    if (period.selectTracks()) {
      break;
    }
    if (period == readingPeriod) {
      selectionsChangedForReadPeriod=false;
    }
    period=period.nextPeriod;
  }
  if (selectionsChangedForReadPeriod) {
    releasePeriodsFrom(playingPeriod.nextPeriod);
    playingPeriod.nextPeriod=null;
    readingPeriod=playingPeriod;
    loadingPeriod=playingPeriod;
    playingPeriodEndPositionUs=C.UNSET_TIME_US;
    bufferAheadPeriodCount=0;
    boolean recreateStreams=readingPeriod != playingPeriod;
    boolean[] streamResetFlags=playingPeriod.updatePeriodTrackSelection(playbackInfo.positionUs,loadControl,recreateStreams);
    int enabledRendererCount=0;
    boolean[] rendererWasEnabledFlags=new boolean[renderers.length];
    for (int i=0; i < renderers.length; i++) {
      Renderer renderer=renderers[i];
      rendererWasEnabledFlags[i]=renderer.getState() != Renderer.STATE_DISABLED;
      SampleStream sampleStream=playingPeriod.sampleStreams[i];
      if (sampleStream != null) {
        enabledRendererCount++;
      }
      if (rendererWasEnabledFlags[i]) {
        if (sampleStream != renderer.getStream()) {
          if (renderer == rendererMediaClockSource) {
            if (sampleStream == null) {
              standaloneMediaClock.setPositionUs(rendererMediaClock.getPositionUs());
            }
            rendererMediaClock=null;
            rendererMediaClockSource=null;
          }
          ensureStopped(renderer);
          renderer.disable();
        }
 else         if (streamResetFlags[i]) {
          renderer.resetPosition(playbackInfo.positionUs);
        }
      }
    }
    trackSelector.onSelectionActivated(playingPeriod.trackSelectionData);
    enableRenderers(rendererWasEnabledFlags,enabledRendererCount);
  }
 else {
    loadingPeriod=period;
    period=loadingPeriod.nextPeriod;
    while (period != null) {
      period.release();
      period=period.nextPeriod;
      bufferAheadPeriodCount--;
    }
    loadingPeriod.nextPeriod=null;
    long positionUs=Math.max(0,internalPositionUs - loadingPeriod.offsetUs);
    loadingPeriod.updatePeriodTrackSelection(positionUs,loadControl,false);
  }
  maybeContinueLoading();
  updatePlaybackPositions();
  handler.sendEmptyMessage(MSG_DO_SOME_WORK);
}","private void reselectTracksInternal() throws ExoPlaybackException {
  if (playingPeriod == null) {
    return;
  }
  Period period=playingPeriod;
  boolean selectionsChangedForReadPeriod=true;
  while (true) {
    if (period == null || !period.prepared) {
      return;
    }
    if (period.selectTracks()) {
      break;
    }
    if (period == readingPeriod) {
      selectionsChangedForReadPeriod=false;
    }
    period=period.nextPeriod;
  }
  if (selectionsChangedForReadPeriod) {
    releasePeriodsFrom(playingPeriod.nextPeriod);
    playingPeriod.nextPeriod=null;
    readingPeriod=playingPeriod;
    loadingPeriod=playingPeriod;
    playingPeriodEndPositionUs=C.UNSET_TIME_US;
    bufferAheadPeriodCount=0;
    boolean recreateStreams=readingPeriod != playingPeriod;
    boolean[] streamResetFlags=new boolean[renderers.length];
    long positionUs=playingPeriod.updatePeriodTrackSelection(playbackInfo.positionUs,loadControl,recreateStreams,streamResetFlags);
    if (positionUs != playbackInfo.positionUs) {
      playbackInfo.positionUs=positionUs;
      resetInternalPosition(positionUs);
    }
    int enabledRendererCount=0;
    boolean[] rendererWasEnabledFlags=new boolean[renderers.length];
    for (int i=0; i < renderers.length; i++) {
      Renderer renderer=renderers[i];
      rendererWasEnabledFlags[i]=renderer.getState() != Renderer.STATE_DISABLED;
      SampleStream sampleStream=playingPeriod.sampleStreams[i];
      if (sampleStream != null) {
        enabledRendererCount++;
      }
      if (rendererWasEnabledFlags[i]) {
        if (sampleStream != renderer.getStream()) {
          if (renderer == rendererMediaClockSource) {
            if (sampleStream == null) {
              standaloneMediaClock.setPositionUs(rendererMediaClock.getPositionUs());
            }
            rendererMediaClock=null;
            rendererMediaClockSource=null;
          }
          ensureStopped(renderer);
          renderer.disable();
        }
 else         if (streamResetFlags[i]) {
          renderer.resetPosition(playbackInfo.positionUs);
        }
      }
    }
    trackSelector.onSelectionActivated(playingPeriod.trackSelectionData);
    enableRenderers(rendererWasEnabledFlags,enabledRendererCount);
  }
 else {
    loadingPeriod=period;
    period=loadingPeriod.nextPeriod;
    while (period != null) {
      period.release();
      period=period.nextPeriod;
      bufferAheadPeriodCount--;
    }
    loadingPeriod.nextPeriod=null;
    long positionUs=Math.max(0,internalPositionUs - loadingPeriod.offsetUs);
    loadingPeriod.updatePeriodTrackSelection(positionUs,loadControl,false);
  }
  maybeContinueLoading();
  updatePlaybackPositions();
  handler.sendEmptyMessage(MSG_DO_SOME_WORK);
}",0.9599236641221374
110356,"public boolean[] updatePeriodTrackSelection(long positionUs,LoadControl loadControl,boolean forceRecreateStreams) throws ExoPlaybackException {
  for (int i=0; i < trackSelections.length; i++) {
    mayRetainStreamFlags[i]=!forceRecreateStreams && Util.areEqual(periodTrackSelections == null ? null : periodTrackSelections.get(i),trackSelections.get(i));
  }
  boolean[] streamResetFlags=new boolean[renderers.length];
  mediaPeriod.selectTracks(trackSelections.getAll(),mayRetainStreamFlags,sampleStreams,streamResetFlags,positionUs);
  periodTrackSelections=trackSelections;
  hasEnabledTracks=false;
  for (int i=0; i < sampleStreams.length; i++) {
    if (sampleStreams[i] != null) {
      hasEnabledTracks=true;
      break;
    }
  }
  loadControl.onTrackSelections(renderers,mediaPeriod.getTrackGroups(),trackSelections);
  return streamResetFlags;
}","public long updatePeriodTrackSelection(long positionUs,LoadControl loadControl,boolean forceRecreateStreams,boolean[] streamResetFlags) throws ExoPlaybackException {
  for (int i=0; i < trackSelections.length; i++) {
    mayRetainStreamFlags[i]=!forceRecreateStreams && Util.areEqual(periodTrackSelections == null ? null : periodTrackSelections.get(i),trackSelections.get(i));
  }
  positionUs=mediaPeriod.selectTracks(trackSelections.getAll(),mayRetainStreamFlags,sampleStreams,streamResetFlags,positionUs);
  periodTrackSelections=trackSelections;
  hasEnabledTracks=false;
  for (int i=0; i < sampleStreams.length; i++) {
    if (sampleStreams[i] != null) {
      hasEnabledTracks=true;
      break;
    }
  }
  loadControl.onTrackSelections(renderers,mediaPeriod.getTrackGroups(),trackSelections);
  return positionUs;
}",0.8209399167162403
110357,"public void handlePrepared(long positionUs,LoadControl loadControl) throws ExoPlaybackException {
  prepared=true;
  selectTracks();
  updatePeriodTrackSelection(positionUs,loadControl,false);
}","public void handlePrepared(long positionUs,LoadControl loadControl) throws ExoPlaybackException {
  prepared=true;
  selectTracks();
  startPositionUs=updatePeriodTrackSelection(positionUs,loadControl,false);
}",0.9603960396039604
110358,"@Override public void selectTracks(TrackSelection[] selections,boolean[] mayRetainStreamFlags,SampleStream[] streams,boolean[] streamResetFlags,long positionUs){
  Assertions.checkState(prepared);
  for (int i=0; i < selections.length; i++) {
    if (streams[i] != null && (selections[i] == null || !mayRetainStreamFlags[i])) {
      int track=((SampleStreamImpl)streams[i]).track;
      Assertions.checkState(trackEnabledStates[track]);
      enabledTrackCount--;
      trackEnabledStates[track]=false;
      sampleQueues[track].disable();
      streams[i]=null;
    }
  }
  boolean selectedNewTracks=false;
  for (int i=0; i < selections.length; i++) {
    if (streams[i] == null && selections[i] != null) {
      TrackSelection selection=selections[i];
      Assertions.checkState(selection.length() == 1);
      Assertions.checkState(selection.getIndexInTrackGroup(0) == 0);
      int track=tracks.indexOf(selection.getTrackGroup());
      Assertions.checkState(!trackEnabledStates[track]);
      enabledTrackCount++;
      trackEnabledStates[track]=true;
      streams[i]=new SampleStreamImpl(track);
      streamResetFlags[i]=true;
      selectedNewTracks=true;
    }
  }
  if (!seenFirstTrackSelection) {
    for (int i=0; i < sampleQueues.length; i++) {
      if (!trackEnabledStates[i]) {
        sampleQueues[i].disable();
      }
    }
  }
  if (enabledTrackCount == 0) {
    notifyReset=false;
    if (loader.isLoading()) {
      loader.cancelLoading();
    }
  }
 else   if (seenFirstTrackSelection ? selectedNewTracks : positionUs != 0) {
    seekToUs(positionUs);
    for (int i=0; i < streams.length; i++) {
      if (streams[i] != null) {
        streamResetFlags[i]=true;
      }
    }
  }
  seenFirstTrackSelection=true;
}","@Override public long selectTracks(TrackSelection[] selections,boolean[] mayRetainStreamFlags,SampleStream[] streams,boolean[] streamResetFlags,long positionUs){
  Assertions.checkState(prepared);
  for (int i=0; i < selections.length; i++) {
    if (streams[i] != null && (selections[i] == null || !mayRetainStreamFlags[i])) {
      int track=((SampleStreamImpl)streams[i]).track;
      Assertions.checkState(trackEnabledStates[track]);
      enabledTrackCount--;
      trackEnabledStates[track]=false;
      sampleQueues[track].disable();
      streams[i]=null;
    }
  }
  boolean selectedNewTracks=false;
  for (int i=0; i < selections.length; i++) {
    if (streams[i] == null && selections[i] != null) {
      TrackSelection selection=selections[i];
      Assertions.checkState(selection.length() == 1);
      Assertions.checkState(selection.getIndexInTrackGroup(0) == 0);
      int track=tracks.indexOf(selection.getTrackGroup());
      Assertions.checkState(!trackEnabledStates[track]);
      enabledTrackCount++;
      trackEnabledStates[track]=true;
      streams[i]=new SampleStreamImpl(track);
      streamResetFlags[i]=true;
      selectedNewTracks=true;
    }
  }
  if (!seenFirstTrackSelection) {
    for (int i=0; i < sampleQueues.length; i++) {
      if (!trackEnabledStates[i]) {
        sampleQueues[i].disable();
      }
    }
  }
  if (enabledTrackCount == 0) {
    notifyReset=false;
    if (loader.isLoading()) {
      loader.cancelLoading();
    }
  }
 else   if (seenFirstTrackSelection ? selectedNewTracks : positionUs != 0) {
    positionUs=seekToUs(positionUs);
    for (int i=0; i < streams.length; i++) {
      if (streams[i] != null) {
        streamResetFlags[i]=true;
      }
    }
  }
  seenFirstTrackSelection=true;
  return positionUs;
}",0.9886169607285143
110359,"/** 
 * Performs a track selection. <p> The call receives track   {@code selections} for each renderer, {@code mayRetainStreamFlags}indicating whether the existing   {@code SampleStream} can be retained for each selection, andthe existing  {@code stream}s themselves. The call will update   {@code streams} to reflect theprovided selections, clearing, setting and replacing entries as required. If an existing sample stream is retained but with the requirement that the consuming renderer be reset, then the corresponding flag in  {@code streamResetFlags} will be set to true. This flag will also be setif a new sample stream is created. <p> This method should only be called after the period has been prepared.
 * @param selections The renderer track selections.
 * @param mayRetainStreamFlags Flags indicating whether the existing sample stream can be retainedfor each selection. A  {@code true} value indicates that the selection is unchanged, andthat the caller does not require that the sample stream be recreated.
 * @param streams The existing sample streams, which will be updated to reflect the providedselections.
 * @param streamResetFlags Will be updated to indicate new sample streams, and sample streams thathave been retained but with the requirement that the consuming renderer be reset.
 * @param positionUs The current playback position in microseconds.
 */
void selectTracks(TrackSelection[] selections,boolean[] mayRetainStreamFlags,SampleStream[] streams,boolean[] streamResetFlags,long positionUs);","/** 
 * Performs a track selection. <p> The call receives track   {@code selections} for each renderer, {@code mayRetainStreamFlags}indicating whether the existing   {@code SampleStream} can be retained for each selection, andthe existing  {@code stream}s themselves. The call will update   {@code streams} to reflect theprovided selections, clearing, setting and replacing entries as required. If an existing sample stream is retained but with the requirement that the consuming renderer be reset, then the corresponding flag in  {@code streamResetFlags} will be set to true. This flag will also be setif a new sample stream is created. <p> This method should only be called after the period has been prepared.
 * @param selections The renderer track selections.
 * @param mayRetainStreamFlags Flags indicating whether the existing sample stream can be retainedfor each selection. A  {@code true} value indicates that the selection is unchanged, andthat the caller does not require that the sample stream be recreated.
 * @param streams The existing sample streams, which will be updated to reflect the providedselections.
 * @param streamResetFlags Will be updated to indicate new sample streams, and sample streams thathave been retained but with the requirement that the consuming renderer be reset.
 * @param positionUs The current playback position in microseconds.
 * @return The actual position at which the tracks were enabled, in microseconds.
 */
long selectTracks(TrackSelection[] selections,boolean[] mayRetainStreamFlags,SampleStream[] streams,boolean[] streamResetFlags,long positionUs);",0.9711723254324152
110360,"@Override public void selectTracks(TrackSelection[] selections,boolean[] mayRetainStreamFlags,SampleStream[] streams,boolean[] streamResetFlags,long positionUs){
  int[] streamChildIndices=new int[selections.length];
  int[] selectionChildIndices=new int[selections.length];
  for (int i=0; i < selections.length; i++) {
    streamChildIndices[i]=streams[i] == null ? -1 : streamPeriodIndices.get(streams[i]);
    selectionChildIndices[i]=-1;
    if (selections[i] != null) {
      TrackGroup trackGroup=selections[i].getTrackGroup();
      for (int j=0; j < periods.length; j++) {
        if (periods[j].getTrackGroups().indexOf(trackGroup) != -1) {
          selectionChildIndices[i]=j;
          break;
        }
      }
    }
  }
  streamPeriodIndices.clear();
  SampleStream[] childStreams=new SampleStream[selections.length];
  TrackSelection[] childSelections=new TrackSelection[selections.length];
  ArrayList<MediaPeriod> enabledPeriodsList=new ArrayList<>(periods.length);
  for (int i=0; i < periods.length; i++) {
    for (int j=0; j < selections.length; j++) {
      childStreams[j]=streamChildIndices[j] == i ? streams[j] : null;
      childSelections[j]=selectionChildIndices[j] == i ? selections[j] : null;
    }
    periods[i].selectTracks(childSelections,mayRetainStreamFlags,childStreams,streamResetFlags,positionUs);
    boolean periodEnabled=false;
    for (int j=0; j < selections.length; j++) {
      if (selectionChildIndices[j] == i) {
        streams[j]=childStreams[j];
        if (childStreams[j] != null) {
          periodEnabled=true;
          streamPeriodIndices.put(childStreams[j],i);
        }
      }
    }
    if (periodEnabled) {
      enabledPeriodsList.add(periods[i]);
    }
  }
  enabledPeriods=new MediaPeriod[enabledPeriodsList.size()];
  enabledPeriodsList.toArray(enabledPeriods);
  sequenceableLoader=new CompositeSequenceableLoader(enabledPeriods);
}","@Override public long selectTracks(TrackSelection[] selections,boolean[] mayRetainStreamFlags,SampleStream[] streams,boolean[] streamResetFlags,long positionUs){
  int[] streamChildIndices=new int[selections.length];
  int[] selectionChildIndices=new int[selections.length];
  for (int i=0; i < selections.length; i++) {
    streamChildIndices[i]=streams[i] == null ? -1 : streamPeriodIndices.get(streams[i]);
    selectionChildIndices[i]=-1;
    if (selections[i] != null) {
      TrackGroup trackGroup=selections[i].getTrackGroup();
      for (int j=0; j < periods.length; j++) {
        if (periods[j].getTrackGroups().indexOf(trackGroup) != -1) {
          selectionChildIndices[i]=j;
          break;
        }
      }
    }
  }
  streamPeriodIndices.clear();
  SampleStream[] childStreams=new SampleStream[selections.length];
  TrackSelection[] childSelections=new TrackSelection[selections.length];
  ArrayList<MediaPeriod> enabledPeriodsList=new ArrayList<>(periods.length);
  for (int i=0; i < periods.length; i++) {
    for (int j=0; j < selections.length; j++) {
      childStreams[j]=streamChildIndices[j] == i ? streams[j] : null;
      childSelections[j]=selectionChildIndices[j] == i ? selections[j] : null;
    }
    long selectPositionUs=periods[i].selectTracks(childSelections,mayRetainStreamFlags,childStreams,streamResetFlags,positionUs);
    if (i == 0) {
      positionUs=selectPositionUs;
    }
 else     if (selectPositionUs != positionUs) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    boolean periodEnabled=false;
    for (int j=0; j < selections.length; j++) {
      if (selectionChildIndices[j] == i) {
        streams[j]=childStreams[j];
        if (childStreams[j] != null) {
          periodEnabled=true;
          streamPeriodIndices.put(childStreams[j],i);
        }
      }
    }
    if (periodEnabled) {
      enabledPeriodsList.add(periods[i]);
    }
  }
  enabledPeriods=new MediaPeriod[enabledPeriodsList.size()];
  enabledPeriodsList.toArray(enabledPeriods);
  sequenceableLoader=new CompositeSequenceableLoader(enabledPeriods);
  return positionUs;
}",0.944666001994018
110361,"@Override public void selectTracks(TrackSelection[] selections,boolean[] mayRetainStreamFlags,SampleStream[] streams,boolean[] streamResetFlags,long positionUs){
  for (int i=0; i < selections.length; i++) {
    if (streams[i] != null && (selections[i] == null || !mayRetainStreamFlags[i])) {
      sampleStreams.remove(streams[i]);
      streams[i]=null;
    }
    if (streams[i] == null && selections[i] != null) {
      SampleStreamImpl stream=new SampleStreamImpl();
      sampleStreams.add(stream);
      streams[i]=stream;
      streamResetFlags[i]=true;
    }
  }
}","@Override public long selectTracks(TrackSelection[] selections,boolean[] mayRetainStreamFlags,SampleStream[] streams,boolean[] streamResetFlags,long positionUs){
  for (int i=0; i < selections.length; i++) {
    if (streams[i] != null && (selections[i] == null || !mayRetainStreamFlags[i])) {
      sampleStreams.remove(streams[i]);
      streams[i]=null;
    }
    if (streams[i] == null && selections[i] != null) {
      SampleStreamImpl stream=new SampleStreamImpl();
      sampleStreams.add(stream);
      streams[i]=stream;
      streamResetFlags[i]=true;
    }
  }
  return positionUs;
}",0.975107296137339
110362,"@Override public void selectTracks(TrackSelection[] selections,boolean[] mayRetainStreamFlags,SampleStream[] streams,boolean[] streamResetFlags,long positionUs){
  ArrayList<ChunkSampleStream<DashChunkSource>> sampleStreamsList=new ArrayList<>();
  for (int i=0; i < selections.length; i++) {
    if (streams[i] != null) {
      @SuppressWarnings(""String_Node_Str"") ChunkSampleStream<DashChunkSource> stream=(ChunkSampleStream<DashChunkSource>)streams[i];
      if (selections[i] == null || !mayRetainStreamFlags[i]) {
        stream.release();
        streams[i]=null;
      }
 else {
        sampleStreamsList.add(stream);
      }
    }
    if (streams[i] == null && selections[i] != null) {
      ChunkSampleStream<DashChunkSource> stream=buildSampleStream(selections[i],positionUs);
      sampleStreamsList.add(stream);
      streams[i]=stream;
      streamResetFlags[i]=true;
    }
  }
  sampleStreams=newSampleStreamArray(sampleStreamsList.size());
  sampleStreamsList.toArray(sampleStreams);
  sequenceableLoader=new CompositeSequenceableLoader(sampleStreams);
}","@Override public long selectTracks(TrackSelection[] selections,boolean[] mayRetainStreamFlags,SampleStream[] streams,boolean[] streamResetFlags,long positionUs){
  ArrayList<ChunkSampleStream<DashChunkSource>> sampleStreamsList=new ArrayList<>();
  for (int i=0; i < selections.length; i++) {
    if (streams[i] != null) {
      @SuppressWarnings(""String_Node_Str"") ChunkSampleStream<DashChunkSource> stream=(ChunkSampleStream<DashChunkSource>)streams[i];
      if (selections[i] == null || !mayRetainStreamFlags[i]) {
        stream.release();
        streams[i]=null;
      }
 else {
        sampleStreamsList.add(stream);
      }
    }
    if (streams[i] == null && selections[i] != null) {
      ChunkSampleStream<DashChunkSource> stream=buildSampleStream(selections[i],positionUs);
      sampleStreamsList.add(stream);
      streams[i]=stream;
      streamResetFlags[i]=true;
    }
  }
  sampleStreams=newSampleStreamArray(sampleStreamsList.size());
  sampleStreamsList.toArray(sampleStreams);
  sequenceableLoader=new CompositeSequenceableLoader(sampleStreams);
  return positionUs;
}",0.986567855488652
110363,"@Override public void selectTracks(TrackSelection[] selections,boolean[] mayRetainStreamFlags,SampleStream[] streams,boolean[] streamResetFlags,long positionUs){
  int[] streamChildIndices=new int[selections.length];
  int[] selectionChildIndices=new int[selections.length];
  for (int i=0; i < selections.length; i++) {
    streamChildIndices[i]=streams[i] == null ? -1 : streamWrapperIndices.get(streams[i]);
    selectionChildIndices[i]=-1;
    if (selections[i] != null) {
      TrackGroup trackGroup=selections[i].getTrackGroup();
      for (int j=0; j < sampleStreamWrappers.length; j++) {
        if (sampleStreamWrappers[j].getTrackGroups().indexOf(trackGroup) != -1) {
          selectionChildIndices[i]=j;
          break;
        }
      }
    }
  }
  boolean selectedNewTracks=false;
  streamWrapperIndices.clear();
  SampleStream[] childStreams=new SampleStream[selections.length];
  TrackSelection[] childSelections=new TrackSelection[selections.length];
  ArrayList<HlsSampleStreamWrapper> enabledSampleStreamWrapperList=new ArrayList<>(sampleStreamWrappers.length);
  for (int i=0; i < sampleStreamWrappers.length; i++) {
    for (int j=0; j < selections.length; j++) {
      childStreams[j]=streamChildIndices[j] == i ? streams[j] : null;
      childSelections[j]=selectionChildIndices[j] == i ? selections[j] : null;
    }
    selectedNewTracks|=sampleStreamWrappers[i].selectTracks(childSelections,mayRetainStreamFlags,childStreams,streamResetFlags,!seenFirstTrackSelection);
    boolean wrapperEnabled=false;
    for (int j=0; j < selections.length; j++) {
      if (selectionChildIndices[j] == i) {
        streams[j]=childStreams[j];
        if (childStreams[j] != null) {
          wrapperEnabled=true;
          streamWrapperIndices.put(childStreams[j],i);
        }
      }
    }
    if (wrapperEnabled) {
      enabledSampleStreamWrapperList.add(sampleStreamWrappers[i]);
    }
  }
  enabledSampleStreamWrappers=new HlsSampleStreamWrapper[enabledSampleStreamWrapperList.size()];
  enabledSampleStreamWrapperList.toArray(enabledSampleStreamWrappers);
  sequenceableLoader=new CompositeSequenceableLoader(enabledSampleStreamWrappers);
  if (seenFirstTrackSelection && selectedNewTracks) {
    seekToUs(positionUs);
    for (int i=0; i < selections.length; i++) {
      if (streams[i] != null) {
        streamResetFlags[i]=true;
      }
    }
  }
  seenFirstTrackSelection=true;
}","@Override public long selectTracks(TrackSelection[] selections,boolean[] mayRetainStreamFlags,SampleStream[] streams,boolean[] streamResetFlags,long positionUs){
  int[] streamChildIndices=new int[selections.length];
  int[] selectionChildIndices=new int[selections.length];
  for (int i=0; i < selections.length; i++) {
    streamChildIndices[i]=streams[i] == null ? -1 : streamWrapperIndices.get(streams[i]);
    selectionChildIndices[i]=-1;
    if (selections[i] != null) {
      TrackGroup trackGroup=selections[i].getTrackGroup();
      for (int j=0; j < sampleStreamWrappers.length; j++) {
        if (sampleStreamWrappers[j].getTrackGroups().indexOf(trackGroup) != -1) {
          selectionChildIndices[i]=j;
          break;
        }
      }
    }
  }
  boolean selectedNewTracks=false;
  streamWrapperIndices.clear();
  SampleStream[] childStreams=new SampleStream[selections.length];
  TrackSelection[] childSelections=new TrackSelection[selections.length];
  ArrayList<HlsSampleStreamWrapper> enabledSampleStreamWrapperList=new ArrayList<>(sampleStreamWrappers.length);
  for (int i=0; i < sampleStreamWrappers.length; i++) {
    for (int j=0; j < selections.length; j++) {
      childStreams[j]=streamChildIndices[j] == i ? streams[j] : null;
      childSelections[j]=selectionChildIndices[j] == i ? selections[j] : null;
    }
    selectedNewTracks|=sampleStreamWrappers[i].selectTracks(childSelections,mayRetainStreamFlags,childStreams,streamResetFlags,!seenFirstTrackSelection);
    boolean wrapperEnabled=false;
    for (int j=0; j < selections.length; j++) {
      if (selectionChildIndices[j] == i) {
        streams[j]=childStreams[j];
        if (childStreams[j] != null) {
          wrapperEnabled=true;
          streamWrapperIndices.put(childStreams[j],i);
        }
      }
    }
    if (wrapperEnabled) {
      enabledSampleStreamWrapperList.add(sampleStreamWrappers[i]);
    }
  }
  enabledSampleStreamWrappers=new HlsSampleStreamWrapper[enabledSampleStreamWrapperList.size()];
  enabledSampleStreamWrapperList.toArray(enabledSampleStreamWrappers);
  sequenceableLoader=new CompositeSequenceableLoader(enabledSampleStreamWrappers);
  if (seenFirstTrackSelection && selectedNewTracks) {
    seekToUs(positionUs);
    for (int i=0; i < selections.length; i++) {
      if (streams[i] != null) {
        streamResetFlags[i]=true;
      }
    }
  }
  seenFirstTrackSelection=true;
  return positionUs;
}",0.9939946158624974
110364,"@Override public void selectTracks(TrackSelection[] selections,boolean[] mayRetainStreamFlags,SampleStream[] streams,boolean[] streamResetFlags,long positionUs){
  ArrayList<ChunkSampleStream<SsChunkSource>> sampleStreamsList=new ArrayList<>();
  for (int i=0; i < selections.length; i++) {
    if (streams[i] != null) {
      @SuppressWarnings(""String_Node_Str"") ChunkSampleStream<SsChunkSource> stream=(ChunkSampleStream<SsChunkSource>)streams[i];
      if (selections[i] == null || !mayRetainStreamFlags[i]) {
        stream.release();
        streams[i]=null;
      }
 else {
        sampleStreamsList.add(stream);
      }
    }
    if (streams[i] == null && selections[i] != null) {
      ChunkSampleStream<SsChunkSource> stream=buildSampleStream(selections[i],positionUs);
      sampleStreamsList.add(stream);
      streams[i]=stream;
      streamResetFlags[i]=true;
    }
  }
  sampleStreams=newSampleStreamArray(sampleStreamsList.size());
  sampleStreamsList.toArray(sampleStreams);
  sequenceableLoader=new CompositeSequenceableLoader(sampleStreams);
}","@Override public long selectTracks(TrackSelection[] selections,boolean[] mayRetainStreamFlags,SampleStream[] streams,boolean[] streamResetFlags,long positionUs){
  ArrayList<ChunkSampleStream<SsChunkSource>> sampleStreamsList=new ArrayList<>();
  for (int i=0; i < selections.length; i++) {
    if (streams[i] != null) {
      @SuppressWarnings(""String_Node_Str"") ChunkSampleStream<SsChunkSource> stream=(ChunkSampleStream<SsChunkSource>)streams[i];
      if (selections[i] == null || !mayRetainStreamFlags[i]) {
        stream.release();
        streams[i]=null;
      }
 else {
        sampleStreamsList.add(stream);
      }
    }
    if (streams[i] == null && selections[i] != null) {
      ChunkSampleStream<SsChunkSource> stream=buildSampleStream(selections[i],positionUs);
      sampleStreamsList.add(stream);
      streams[i]=stream;
      streamResetFlags[i]=true;
    }
  }
  sampleStreams=newSampleStreamArray(sampleStreamsList.size());
  sampleStreamsList.toArray(sampleStreams);
  sequenceableLoader=new CompositeSequenceableLoader(sampleStreams);
  return positionUs;
}",0.9864675688287448
110365,"private long getNowUnixTimeUs(){
  if (elapsedRealtimeOffsetMs != 0) {
    return SystemClock.elapsedRealtime() * 1000 + elapsedRealtimeOffsetMs;
  }
 else {
    return System.currentTimeMillis() * 1000;
  }
}","private long getNowUnixTimeUs(){
  if (elapsedRealtimeOffsetMs != 0) {
    return (SystemClock.elapsedRealtime() + elapsedRealtimeOffsetMs) * 1000;
  }
 else {
    return System.currentTimeMillis() * 1000;
  }
}",0.961904761904762
110366,"/** 
 * @param manifestLoaderErrorThrower Throws errors affecting loading of manifests.
 * @param manifest The initial manifest.
 * @param periodIndex The index of the period in the manifest.
 * @param adaptationSetIndex The index of the adaptation set in the period.
 * @param trackSelection The track selection.
 * @param dataSource A {@link DataSource} suitable for loading the media data.
 * @param elapsedRealtimeOffsetMs If known, an estimate of the instantaneous difference betweenserver-side unix time and  {@link SystemClock#elapsedRealtime()} in milliseconds, specifiedas the server's unix time minus the local elapsed time. If unknown, set to 0.
 */
public DefaultDashChunkSource(LoaderErrorThrower manifestLoaderErrorThrower,DashManifest manifest,int periodIndex,int adaptationSetIndex,TrackSelection trackSelection,DataSource dataSource,long elapsedRealtimeOffsetMs){
  this.manifestLoaderErrorThrower=manifestLoaderErrorThrower;
  this.manifest=manifest;
  this.adaptationSetIndex=adaptationSetIndex;
  this.trackSelection=trackSelection;
  this.dataSource=dataSource;
  this.periodIndex=periodIndex;
  this.elapsedRealtimeOffsetUs=elapsedRealtimeOffsetMs * 1000;
  long periodDurationUs=manifest.getPeriodDurationUs(periodIndex);
  List<Representation> representations=getRepresentations();
  representationHolders=new RepresentationHolder[trackSelection.length()];
  for (int i=0; i < representationHolders.length; i++) {
    Representation representation=representations.get(trackSelection.getIndexInTrackGroup(i));
    representationHolders[i]=new RepresentationHolder(periodDurationUs,representation);
  }
}","/** 
 * @param manifestLoaderErrorThrower Throws errors affecting loading of manifests.
 * @param manifest The initial manifest.
 * @param periodIndex The index of the period in the manifest.
 * @param adaptationSetIndex The index of the adaptation set in the period.
 * @param trackSelection The track selection.
 * @param dataSource A {@link DataSource} suitable for loading the media data.
 * @param elapsedRealtimeOffsetMs If known, an estimate of the instantaneous difference betweenserver-side unix time and  {@link SystemClock#elapsedRealtime()} in milliseconds, specifiedas the server's unix time minus the local elapsed time. If unknown, set to 0.
 */
public DefaultDashChunkSource(LoaderErrorThrower manifestLoaderErrorThrower,DashManifest manifest,int periodIndex,int adaptationSetIndex,TrackSelection trackSelection,DataSource dataSource,long elapsedRealtimeOffsetMs){
  this.manifestLoaderErrorThrower=manifestLoaderErrorThrower;
  this.manifest=manifest;
  this.adaptationSetIndex=adaptationSetIndex;
  this.trackSelection=trackSelection;
  this.dataSource=dataSource;
  this.periodIndex=periodIndex;
  this.elapsedRealtimeOffsetMs=elapsedRealtimeOffsetMs;
  long periodDurationUs=manifest.getPeriodDurationUs(periodIndex);
  List<Representation> representations=getRepresentations();
  representationHolders=new RepresentationHolder[trackSelection.length()];
  for (int i=0; i < representationHolders.length; i++) {
    Representation representation=representations.get(trackSelection.getIndexInTrackGroup(i));
    representationHolders[i]=new RepresentationHolder(periodDurationUs,representation);
  }
}",0.997226502311248
110367,"private long getNowUnixTimeUs(){
  if (elapsedRealtimeOffsetUs != 0) {
    return (SystemClock.elapsedRealtime() * 1000) + elapsedRealtimeOffsetUs;
  }
 else {
    return System.currentTimeMillis() * 1000;
  }
}","private long getNowUnixTimeUs(){
  if (elapsedRealtimeOffsetMs != 0) {
    return (SystemClock.elapsedRealtime() + elapsedRealtimeOffsetMs) * 1000;
  }
 else {
    return System.currentTimeMillis() * 1000;
  }
}",0.9478672985781992
110368,"public void invalidate(Timeline timeline) throws ExoPlaybackException, IOException {
  Timeline oldTimeline=this.timeline;
  this.timeline=timeline;
  eventHandler.obtainMessage(MSG_TIMELINE_CHANGED,timeline).sendToTarget();
  if (playingPeriod != null) {
    int index=timeline.getIndexOfPeriod(playingPeriod.id);
    if (index == Timeline.NO_PERIOD_INDEX) {
      int newPlayingPeriodIndex=mediaSource.getNewPlayingPeriodIndex(playingPeriod.index,oldTimeline);
      if (newPlayingPeriodIndex == Timeline.NO_PERIOD_INDEX) {
        stopInternal();
        return;
      }
      releasePeriodsFrom(playingPeriod);
      playingPeriod=null;
      seekToPeriodPosition(newPlayingPeriodIndex,0);
      return;
    }
    int periodCount=timeline.getPeriodCount();
    playingPeriod.index=index;
    playingPeriod.isLast=timeline.isFinal() && index == periodCount - 1;
    Period previousPeriod=playingPeriod;
    boolean seenReadingPeriod=false;
    while (previousPeriod != null) {
      Period period=previousPeriod.nextPeriod;
      index++;
      if (!period.id.equals(timeline.getPeriodId(index))) {
        if (!seenReadingPeriod) {
          index=playingPeriod.index;
          releasePeriodsFrom(playingPeriod);
          playingPeriod=null;
          seekToPeriodPosition(index,0);
          return;
        }
        loadingPeriod=previousPeriod;
        loadingPeriod.nextPeriod=null;
        releasePeriodsFrom(period);
        break;
      }
      period.index=index;
      period.isLast=timeline.isFinal() && index == periodCount - 1;
      if (period == readingPeriod) {
        seenReadingPeriod=true;
      }
      previousPeriod=period;
    }
  }
 else   if (loadingPeriod != null) {
    Object id=loadingPeriod.id;
    int index=timeline.getIndexOfPeriod(id);
    if (index == Timeline.NO_PERIOD_INDEX) {
      loadingPeriod.release();
      loadingPeriod=null;
    }
 else {
      int periodCount=timeline.getPeriodCount();
      loadingPeriod.index=index;
      loadingPeriod.isLast=timeline.isFinal() && index == periodCount - 1;
    }
  }
  if (oldTimeline != null) {
    int newPlayingIndex=playingPeriod != null ? playingPeriod.index : loadingPeriod != null ? loadingPeriod.index : mediaSource.getNewPlayingPeriodIndex(playbackInfo.periodIndex,oldTimeline);
    if (newPlayingIndex != Timeline.NO_PERIOD_INDEX && newPlayingIndex != playbackInfo.periodIndex) {
      playbackInfo=new PlaybackInfo(newPlayingIndex);
      updatePlaybackPositions();
      eventHandler.obtainMessage(MSG_PERIOD_CHANGED,playbackInfo).sendToTarget();
    }
  }
}","public void invalidate(Timeline timeline) throws ExoPlaybackException, IOException {
  Timeline oldTimeline=this.timeline;
  this.timeline=timeline;
  eventHandler.obtainMessage(MSG_TIMELINE_CHANGED,timeline).sendToTarget();
  if (playingPeriod != null) {
    int index=timeline.getIndexOfPeriod(playingPeriod.id);
    if (index == Timeline.NO_PERIOD_INDEX) {
      int newPlayingPeriodIndex=mediaSource.getNewPlayingPeriodIndex(playingPeriod.index,oldTimeline);
      if (newPlayingPeriodIndex == Timeline.NO_PERIOD_INDEX) {
        stopInternal();
        return;
      }
      releasePeriodsFrom(playingPeriod);
      playingPeriod=null;
      seekToPeriodPosition(newPlayingPeriodIndex,0);
      return;
    }
    int periodCount=timeline.getPeriodCount();
    playingPeriod.index=index;
    playingPeriod.isLast=timeline.isFinal() && index == periodCount - 1;
    Period previousPeriod=playingPeriod;
    boolean seenReadingPeriod=false;
    while (previousPeriod.nextPeriod != null) {
      Period period=previousPeriod.nextPeriod;
      index++;
      if (!period.id.equals(timeline.getPeriodId(index))) {
        if (!seenReadingPeriod) {
          index=playingPeriod.index;
          releasePeriodsFrom(playingPeriod);
          playingPeriod=null;
          seekToPeriodPosition(index,0);
          return;
        }
        loadingPeriod=previousPeriod;
        loadingPeriod.nextPeriod=null;
        releasePeriodsFrom(period);
        break;
      }
      period.index=index;
      period.isLast=timeline.isFinal() && index == periodCount - 1;
      if (period == readingPeriod) {
        seenReadingPeriod=true;
      }
      previousPeriod=period;
    }
  }
 else   if (loadingPeriod != null) {
    Object id=loadingPeriod.id;
    int index=timeline.getIndexOfPeriod(id);
    if (index == Timeline.NO_PERIOD_INDEX) {
      loadingPeriod.release();
      loadingPeriod=null;
    }
 else {
      int periodCount=timeline.getPeriodCount();
      loadingPeriod.index=index;
      loadingPeriod.isLast=timeline.isFinal() && index == periodCount - 1;
    }
  }
  if (oldTimeline != null) {
    int newPlayingIndex=playingPeriod != null ? playingPeriod.index : loadingPeriod != null ? loadingPeriod.index : mediaSource.getNewPlayingPeriodIndex(playbackInfo.periodIndex,oldTimeline);
    if (newPlayingIndex != Timeline.NO_PERIOD_INDEX && newPlayingIndex != playbackInfo.periodIndex) {
      playbackInfo=new PlaybackInfo(newPlayingIndex);
      updatePlaybackPositions();
      eventHandler.obtainMessage(MSG_PERIOD_CHANGED,playbackInfo).sendToTarget();
    }
  }
}",0.9978586723768736
110369,"@Override public void onContinueLoadingRequested(SampleSource ignored){
  callback.onContinueLoadingRequested(this);
}","@Override public void onContinueLoadingRequested(SampleSource ignored){
  if (trackGroups == null) {
    return;
  }
  callback.onContinueLoadingRequested(this);
}",0.8398576512455516
110370,"/** 
 * @param baseUri The playlist's base uri.
 * @param variants The available variants.
 * @param dataSource A {@link DataSource} suitable for loading the media data.
 * @param timestampAdjusterProvider A provider of {@link PtsTimestampAdjuster} instances. Ifmultiple  {@link HlsChunkSource}s are used for a single playback, they should all share the same provider.
 * @param adaptiveFormatEvaluator For adaptive tracks, selects from the available formats.
 */
public HlsChunkSource(String baseUri,Variant[] variants,DataSource dataSource,PtsTimestampAdjusterProvider timestampAdjusterProvider,FormatEvaluator adaptiveFormatEvaluator){
  this.baseUri=baseUri;
  this.variants=variants;
  this.dataSource=dataSource;
  this.adaptiveFormatEvaluator=adaptiveFormatEvaluator;
  this.timestampAdjusterProvider=timestampAdjusterProvider;
  playlistParser=new HlsPlaylistParser();
  evaluation=new Evaluation();
  variantPlaylists=new HlsMediaPlaylist[variants.length];
  variantLastPlaylistLoadTimesMs=new long[variants.length];
  int[] initialTrackSelection=new int[variants.length];
  for (int i=0; i < variants.length; i++) {
    initialTrackSelection[i]=i;
  }
  selectTracksInternal(initialTrackSelection,false);
  initialEnabledVariantIndex=getEnabledVariantIndex(variants[0].format);
}","/** 
 * @param baseUri The playlist's base uri.
 * @param variants The available variants.
 * @param dataSource A {@link DataSource} suitable for loading the media data.
 * @param timestampAdjusterProvider A provider of {@link PtsTimestampAdjuster} instances. Ifmultiple  {@link HlsChunkSource}s are used for a single playback, they should all share the same provider.
 * @param adaptiveFormatEvaluator For adaptive tracks, selects from the available formats.
 */
public HlsChunkSource(String baseUri,Variant[] variants,DataSource dataSource,PtsTimestampAdjusterProvider timestampAdjusterProvider,FormatEvaluator adaptiveFormatEvaluator){
  this.baseUri=baseUri;
  this.variants=variants;
  this.dataSource=dataSource;
  this.adaptiveFormatEvaluator=adaptiveFormatEvaluator;
  this.timestampAdjusterProvider=timestampAdjusterProvider;
  playlistParser=new HlsPlaylistParser();
  evaluation=new Evaluation();
  variantPlaylists=new HlsMediaPlaylist[variants.length];
  variantLastPlaylistLoadTimesMs=new long[variants.length];
  int[] initialTrackSelection=new int[variants.length];
  for (int i=0; i < variants.length; i++) {
    initialTrackSelection[i]=i;
  }
  selectTracksInternal(initialTrackSelection,false);
}",0.9708582834331336
110371,"private void updateFormatEvaluation(HlsMediaChunk previous,long playbackPositionUs){
  clearStaleBlacklistedVariants();
  if (!seenFirstExternalTrackSelection && !enabledVariantBlacklistFlags[initialEnabledVariantIndex]) {
    evaluation.format=variants[0].format;
  }
 else   if (enabledVariants.length > 1) {
    long bufferedDurationUs;
    if (previous != null) {
      bufferedDurationUs=Math.max(0,previous.startTimeUs - playbackPositionUs);
    }
 else {
      bufferedDurationUs=0;
    }
    adaptiveFormatEvaluator.evaluateFormat(bufferedDurationUs,enabledVariantBlacklistFlags,evaluation);
  }
 else {
    evaluation.format=enabledVariants[0].format;
  }
}","private void updateFormatEvaluation(HlsMediaChunk previous,long playbackPositionUs){
  clearStaleBlacklistedVariants();
  if (!seenFirstExternalTrackSelection) {
    if (!enabledVariantBlacklistFlags[getEnabledVariantIndex(variants[0].format)]) {
      evaluation.format=variants[0].format;
      return;
    }
    for (int i=enabledVariants.length - 1; i >= 0; i--) {
      if (!enabledVariantBlacklistFlags[i]) {
        evaluation.format=enabledVariants[i].format;
        return;
      }
    }
    throw new IllegalStateException();
  }
  if (enabledVariants.length == 1) {
    evaluation.format=enabledVariants[0].format;
    return;
  }
  long bufferedDurationUs;
  if (previous != null) {
    bufferedDurationUs=Math.max(0,previous.startTimeUs - playbackPositionUs);
  }
 else {
    bufferedDurationUs=0;
  }
  adaptiveFormatEvaluator.evaluateFormat(bufferedDurationUs,enabledVariantBlacklistFlags,evaluation);
}",0.6788643533123029
110372,"private void selectTracksInternal(int[] tracks,boolean isExternal){
  seenFirstExternalTrackSelection|=isExternal;
  enabledVariants=new Variant[tracks.length];
  for (int i=0; i < tracks.length; i++) {
    enabledVariants[i]=variants[tracks[i]];
  }
  Arrays.sort(enabledVariants,new Comparator<Variant>(){
    private final Comparator<Format> formatComparator=new Format.DecreasingBandwidthComparator();
    @Override public int compare(    Variant first,    Variant second){
      return formatComparator.compare(first.format,second.format);
    }
  }
);
  enabledVariantBlacklistTimes=new long[enabledVariants.length];
  enabledVariantBlacklistFlags=new boolean[enabledVariants.length];
  if (enabledVariants.length > 1) {
    Format[] formats=new Format[enabledVariants.length];
    for (int i=0; i < formats.length; i++) {
      formats[i]=enabledVariants[i].format;
    }
    adaptiveFormatEvaluator.enable(formats);
    if (!Util.contains(formats,evaluation.format)) {
      evaluation.format=null;
    }
  }
 else {
    evaluation.trigger=FormatEvaluator.TRIGGER_UNKNOWN;
    evaluation.data=null;
  }
}","private void selectTracksInternal(int[] tracks,boolean isExternal){
  seenFirstExternalTrackSelection|=isExternal;
  enabledVariants=new Variant[tracks.length];
  for (int i=0; i < tracks.length; i++) {
    enabledVariants[i]=variants[tracks[i]];
  }
  Arrays.sort(enabledVariants,new Comparator<Variant>(){
    private final Comparator<Format> formatComparator=new Format.DecreasingBandwidthComparator();
    @Override public int compare(    Variant first,    Variant second){
      return formatComparator.compare(first.format,second.format);
    }
  }
);
  enabledVariantBlacklistTimes=new long[enabledVariants.length];
  enabledVariantBlacklistFlags=new boolean[enabledVariants.length];
  if (!isExternal) {
    return;
  }
  if (enabledVariants.length > 1) {
    Format[] formats=new Format[enabledVariants.length];
    for (int i=0; i < formats.length; i++) {
      formats[i]=enabledVariants[i].format;
    }
    adaptiveFormatEvaluator.enable(formats);
    if (!Util.contains(formats,evaluation.format)) {
      evaluation.format=null;
    }
  }
 else {
    evaluation.trigger=FormatEvaluator.TRIGGER_UNKNOWN;
    evaluation.data=null;
  }
}",0.9836355594869528
110373,"@Override public void onContinueLoadingRequested(HlsTrackStreamWrapper trackStreamWrapper){
  callback.onContinueLoadingRequested(this);
}","@Override public void onContinueLoadingRequested(HlsTrackStreamWrapper trackStreamWrapper){
  if (trackGroups == null) {
    return;
  }
  callback.onContinueLoadingRequested(this);
}",0.8598130841121495
110374,"/** 
 * Draws the provided   {@link Cue} into a canvas with the specified styling.<p> A call to this method is able to use cached results of calculations made during the previous call, and so an instance of this class is able to optimize repeated calls to this method in which the same parameters are passed.
 * @param cue The cue to draw.
 * @param applyEmbeddedStyles Whether styling embedded within the cue should be applied.
 * @param style The style to use when drawing the cue text.
 * @param textSizePx The text size to use when drawing the cue text, in pixels.
 * @param bottomPaddingFraction The bottom padding fraction to apply when {@link Cue#line} is{@link Cue#DIMEN_UNSET}, as a fraction of the viewport height
 * @param canvas The canvas into which to draw.
 * @param cueBoxLeft The left position of the enclosing cue box.
 * @param cueBoxTop The top position of the enclosing cue box.
 * @param cueBoxRight The right position of the enclosing cue box.
 * @param cueBoxBottom The bottom position of the enclosing cue box.
 */
public void draw(Cue cue,boolean applyEmbeddedStyles,CaptionStyleCompat style,float textSizePx,float bottomPaddingFraction,Canvas canvas,int cueBoxLeft,int cueBoxTop,int cueBoxRight,int cueBoxBottom){
  CharSequence cueText=cue.text;
  if (TextUtils.isEmpty(cueText)) {
    return;
  }
  if (!applyEmbeddedStyles) {
    cueText=cueText.toString();
  }
  if (areCharSequencesEqual(this.cueText,cueText) && Util.areEqual(this.cueTextAlignment,cue.textAlignment) && this.cueLine == cue.line && this.cueLineType == cue.lineType && Util.areEqual(this.cueLineAnchor,cue.lineAnchor) && this.cuePosition == cue.position && Util.areEqual(this.cuePositionAnchor,cue.positionAnchor) && this.cueSize == cue.size && this.applyEmbeddedStyles == applyEmbeddedStyles && this.foregroundColor == style.foregroundColor && this.backgroundColor == style.backgroundColor && this.windowColor == style.windowColor && this.edgeType == style.edgeType && this.edgeColor == style.edgeColor && Util.areEqual(this.textPaint.getTypeface(),style.typeface) && this.textSizePx == textSizePx && this.bottomPaddingFraction == bottomPaddingFraction && this.parentLeft == cueBoxLeft && this.parentTop == cueBoxTop && this.parentRight == cueBoxRight && this.parentBottom == cueBoxBottom) {
    drawLayout(canvas);
    return;
  }
  this.cueText=cueText;
  this.cueTextAlignment=cue.textAlignment;
  this.cueLine=cue.line;
  this.cueLineType=cue.lineType;
  this.cueLineAnchor=cue.lineAnchor;
  this.cuePosition=cue.position;
  this.cuePositionAnchor=cue.positionAnchor;
  this.cueSize=cue.size;
  this.applyEmbeddedStyles=applyEmbeddedStyles;
  this.foregroundColor=style.foregroundColor;
  this.backgroundColor=style.backgroundColor;
  this.windowColor=style.windowColor;
  this.edgeType=style.edgeType;
  this.edgeColor=style.edgeColor;
  this.textPaint.setTypeface(style.typeface);
  this.textSizePx=textSizePx;
  this.bottomPaddingFraction=bottomPaddingFraction;
  this.parentLeft=cueBoxLeft;
  this.parentTop=cueBoxTop;
  this.parentRight=cueBoxRight;
  this.parentBottom=cueBoxBottom;
  int parentWidth=parentRight - parentLeft;
  int parentHeight=parentBottom - parentTop;
  textPaint.setTextSize(textSizePx);
  int textPaddingX=(int)(textSizePx * INNER_PADDING_RATIO + 0.5f);
  int availableWidth=parentWidth - textPaddingX * 2;
  if (cueSize != Cue.DIMEN_UNSET) {
    availableWidth=(int)(availableWidth * cueSize);
  }
  if (availableWidth <= 0) {
    Log.w(TAG,""String_Node_Str"");
    return;
  }
  Alignment textAlignment=cueTextAlignment == null ? Alignment.ALIGN_CENTER : cueTextAlignment;
  textLayout=new StaticLayout(cueText,textPaint,availableWidth,textAlignment,spacingMult,spacingAdd,true);
  int textHeight=textLayout.getHeight();
  int textWidth=0;
  int lineCount=textLayout.getLineCount();
  for (int i=0; i < lineCount; i++) {
    textWidth=Math.max((int)Math.ceil(textLayout.getLineWidth(i)),textWidth);
  }
  textWidth+=textPaddingX * 2;
  int textLeft;
  int textRight;
  if (cuePosition != Cue.DIMEN_UNSET) {
    int anchorPosition=Math.round(parentWidth * cuePosition) + parentLeft;
    textLeft=cuePositionAnchor == Cue.ANCHOR_TYPE_END ? anchorPosition - textWidth : cuePositionAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorPosition * 2 - textWidth) / 2 : anchorPosition;
    textLeft=Math.max(textLeft,parentLeft);
    textRight=Math.min(textLeft + textWidth,parentRight);
  }
 else {
    textLeft=(parentWidth - textWidth) / 2;
    textRight=textLeft + textWidth;
  }
  int textTop;
  if (cueLine != Cue.DIMEN_UNSET) {
    int anchorPosition;
    if (cueLineType == Cue.LINE_TYPE_FRACTION) {
      anchorPosition=Math.round(parentHeight * cueLine) + parentTop;
    }
 else {
      int firstLineHeight=textLayout.getLineBottom(0) - textLayout.getLineTop(0);
      if (cueLine >= 0) {
        anchorPosition=Math.round(cueLine * firstLineHeight) + parentTop;
      }
 else {
        anchorPosition=Math.round(cueLine * firstLineHeight) + parentBottom;
      }
    }
    textTop=cueLineAnchor == Cue.ANCHOR_TYPE_END ? anchorPosition - textHeight : cueLineAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorPosition * 2 - textHeight) / 2 : anchorPosition;
    if (textTop + textHeight > parentBottom) {
      textTop=parentBottom - textHeight;
    }
 else     if (textTop < parentTop) {
      textTop=parentTop;
    }
  }
 else {
    textTop=parentBottom - textHeight - (int)(parentHeight * bottomPaddingFraction);
  }
  textWidth=textRight - textLeft;
  this.textLayout=new StaticLayout(cueText,textPaint,textWidth,textAlignment,spacingMult,spacingAdd,true);
  this.textLeft=textLeft;
  this.textTop=textTop;
  this.textPaddingX=textPaddingX;
  drawLayout(canvas);
}","/** 
 * Draws the provided   {@link Cue} into a canvas with the specified styling.<p> A call to this method is able to use cached results of calculations made during the previous call, and so an instance of this class is able to optimize repeated calls to this method in which the same parameters are passed.
 * @param cue The cue to draw.
 * @param applyEmbeddedStyles Whether styling embedded within the cue should be applied.
 * @param style The style to use when drawing the cue text.
 * @param textSizePx The text size to use when drawing the cue text, in pixels.
 * @param bottomPaddingFraction The bottom padding fraction to apply when {@link Cue#line} is{@link Cue#DIMEN_UNSET}, as a fraction of the viewport height
 * @param canvas The canvas into which to draw.
 * @param cueBoxLeft The left position of the enclosing cue box.
 * @param cueBoxTop The top position of the enclosing cue box.
 * @param cueBoxRight The right position of the enclosing cue box.
 * @param cueBoxBottom The bottom position of the enclosing cue box.
 */
public void draw(Cue cue,boolean applyEmbeddedStyles,CaptionStyleCompat style,float textSizePx,float bottomPaddingFraction,Canvas canvas,int cueBoxLeft,int cueBoxTop,int cueBoxRight,int cueBoxBottom){
  CharSequence cueText=cue.text;
  if (TextUtils.isEmpty(cueText)) {
    return;
  }
  if (!applyEmbeddedStyles) {
    cueText=cueText.toString();
  }
  if (areCharSequencesEqual(this.cueText,cueText) && Util.areEqual(this.cueTextAlignment,cue.textAlignment) && this.cueLine == cue.line && this.cueLineType == cue.lineType && Util.areEqual(this.cueLineAnchor,cue.lineAnchor) && this.cuePosition == cue.position && Util.areEqual(this.cuePositionAnchor,cue.positionAnchor) && this.cueSize == cue.size && this.applyEmbeddedStyles == applyEmbeddedStyles && this.foregroundColor == style.foregroundColor && this.backgroundColor == style.backgroundColor && this.windowColor == style.windowColor && this.edgeType == style.edgeType && this.edgeColor == style.edgeColor && Util.areEqual(this.textPaint.getTypeface(),style.typeface) && this.textSizePx == textSizePx && this.bottomPaddingFraction == bottomPaddingFraction && this.parentLeft == cueBoxLeft && this.parentTop == cueBoxTop && this.parentRight == cueBoxRight && this.parentBottom == cueBoxBottom) {
    drawLayout(canvas);
    return;
  }
  this.cueText=cueText;
  this.cueTextAlignment=cue.textAlignment;
  this.cueLine=cue.line;
  this.cueLineType=cue.lineType;
  this.cueLineAnchor=cue.lineAnchor;
  this.cuePosition=cue.position;
  this.cuePositionAnchor=cue.positionAnchor;
  this.cueSize=cue.size;
  this.applyEmbeddedStyles=applyEmbeddedStyles;
  this.foregroundColor=style.foregroundColor;
  this.backgroundColor=style.backgroundColor;
  this.windowColor=style.windowColor;
  this.edgeType=style.edgeType;
  this.edgeColor=style.edgeColor;
  this.textPaint.setTypeface(style.typeface);
  this.textSizePx=textSizePx;
  this.bottomPaddingFraction=bottomPaddingFraction;
  this.parentLeft=cueBoxLeft;
  this.parentTop=cueBoxTop;
  this.parentRight=cueBoxRight;
  this.parentBottom=cueBoxBottom;
  int parentWidth=parentRight - parentLeft;
  int parentHeight=parentBottom - parentTop;
  textPaint.setTextSize(textSizePx);
  int textPaddingX=(int)(textSizePx * INNER_PADDING_RATIO + 0.5f);
  int availableWidth=parentWidth - textPaddingX * 2;
  if (cueSize != Cue.DIMEN_UNSET) {
    availableWidth=(int)(availableWidth * cueSize);
  }
  if (availableWidth <= 0) {
    Log.w(TAG,""String_Node_Str"");
    return;
  }
  Alignment textAlignment=cueTextAlignment == null ? Alignment.ALIGN_CENTER : cueTextAlignment;
  textLayout=new StaticLayout(cueText,textPaint,availableWidth,textAlignment,spacingMult,spacingAdd,true);
  int textHeight=textLayout.getHeight();
  int textWidth=0;
  int lineCount=textLayout.getLineCount();
  for (int i=0; i < lineCount; i++) {
    textWidth=Math.max((int)Math.ceil(textLayout.getLineWidth(i)),textWidth);
  }
  if (cueSize != Cue.DIMEN_UNSET && textWidth < availableWidth) {
    textWidth=availableWidth;
  }
  textWidth+=textPaddingX * 2;
  int textLeft;
  int textRight;
  if (cuePosition != Cue.DIMEN_UNSET) {
    int anchorPosition=Math.round(parentWidth * cuePosition) + parentLeft;
    textLeft=cuePositionAnchor == Cue.ANCHOR_TYPE_END ? anchorPosition - textWidth : cuePositionAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorPosition * 2 - textWidth) / 2 : anchorPosition;
    textLeft=Math.max(textLeft,parentLeft);
    textRight=Math.min(textLeft + textWidth,parentRight);
  }
 else {
    textLeft=(parentWidth - textWidth) / 2;
    textRight=textLeft + textWidth;
  }
  int textTop;
  if (cueLine != Cue.DIMEN_UNSET) {
    int anchorPosition;
    if (cueLineType == Cue.LINE_TYPE_FRACTION) {
      anchorPosition=Math.round(parentHeight * cueLine) + parentTop;
    }
 else {
      int firstLineHeight=textLayout.getLineBottom(0) - textLayout.getLineTop(0);
      if (cueLine >= 0) {
        anchorPosition=Math.round(cueLine * firstLineHeight) + parentTop;
      }
 else {
        anchorPosition=Math.round(cueLine * firstLineHeight) + parentBottom;
      }
    }
    textTop=cueLineAnchor == Cue.ANCHOR_TYPE_END ? anchorPosition - textHeight : cueLineAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorPosition * 2 - textHeight) / 2 : anchorPosition;
    if (textTop + textHeight > parentBottom) {
      textTop=parentBottom - textHeight;
    }
 else     if (textTop < parentTop) {
      textTop=parentTop;
    }
  }
 else {
    textTop=parentBottom - textHeight - (int)(parentHeight * bottomPaddingFraction);
  }
  textWidth=textRight - textLeft;
  this.textLayout=new StaticLayout(cueText,textPaint,textWidth,textAlignment,spacingMult,spacingAdd,true);
  this.textLeft=textLeft;
  this.textTop=textTop;
  this.textPaddingX=textPaddingX;
  drawLayout(canvas);
}",0.9785490059295432
110375,"public List<Cue> getCues(long timeUs,Map<String,TtmlStyle> globalStyles,Map<String,TtmlRegion> regionMap){
  TreeMap<String,SpannableStringBuilder> regionOutputs=new TreeMap<>();
  traverseForText(timeUs,false,regionId,regionOutputs);
  traverseForStyle(globalStyles,regionOutputs);
  List<Cue> cues=new ArrayList<>();
  for (  Entry<String,SpannableStringBuilder> entry : regionOutputs.entrySet()) {
    TtmlRegion region=regionMap.get(entry.getKey());
    cues.add(new Cue(cleanUpText(entry.getValue()),null,region.line,Cue.TYPE_UNSET,Cue.TYPE_UNSET,region.position,Cue.TYPE_UNSET,region.width));
  }
  return cues;
}","public List<Cue> getCues(long timeUs,Map<String,TtmlStyle> globalStyles,Map<String,TtmlRegion> regionMap){
  TreeMap<String,SpannableStringBuilder> regionOutputs=new TreeMap<>();
  traverseForText(timeUs,false,regionId,regionOutputs);
  traverseForStyle(globalStyles,regionOutputs);
  List<Cue> cues=new ArrayList<>();
  for (  Entry<String,SpannableStringBuilder> entry : regionOutputs.entrySet()) {
    TtmlRegion region=regionMap.get(entry.getKey());
    cues.add(new Cue(cleanUpText(entry.getValue()),null,region.line,region.lineType,Cue.TYPE_UNSET,region.position,Cue.TYPE_UNSET,region.width));
  }
  return cues;
}",0.9491525423728814
110376,"/** 
 * Parses a region declaration. Supports origin and extent definition but only when defined in terms of percentage of the viewport. Regions that do not correctly declare origin are ignored.
 */
private Pair<String,TtmlRegion> parseRegionAttributes(XmlPullParser xmlParser){
  String regionId=ParserUtil.getAttributeValue(xmlParser,TtmlNode.ATTR_ID);
  String regionOrigin=ParserUtil.getAttributeValue(xmlParser,TtmlNode.ATTR_TTS_ORIGIN);
  String regionExtent=ParserUtil.getAttributeValue(xmlParser,TtmlNode.ATTR_TTS_EXTENT);
  if (regionOrigin == null || regionId == null) {
    return null;
  }
  float position=Cue.DIMEN_UNSET;
  float line=Cue.DIMEN_UNSET;
  Matcher originMatcher=PERCENTAGE_COORDINATES.matcher(regionOrigin);
  if (originMatcher.matches()) {
    try {
      position=Float.parseFloat(originMatcher.group(1)) / 100.f;
      line=Float.parseFloat(originMatcher.group(2)) / 100.f;
    }
 catch (    NumberFormatException e) {
      Log.w(TAG,""String_Node_Str"" + regionOrigin + ""String_Node_Str"",e);
      position=Cue.DIMEN_UNSET;
    }
  }
  float width=Cue.DIMEN_UNSET;
  if (regionExtent != null) {
    Matcher extentMatcher=PERCENTAGE_COORDINATES.matcher(regionExtent);
    if (extentMatcher.matches()) {
      try {
        width=Float.parseFloat(extentMatcher.group(1)) / 100.f;
      }
 catch (      NumberFormatException e) {
        Log.w(TAG,""String_Node_Str"" + regionExtent + ""String_Node_Str"",e);
      }
    }
  }
  return position != Cue.DIMEN_UNSET ? new Pair<>(regionId,new TtmlRegion(position,line,width)) : null;
}","/** 
 * Parses a region declaration. Supports origin and extent definition but only when defined in terms of percentage of the viewport. Regions that do not correctly declare origin are ignored.
 */
private Pair<String,TtmlRegion> parseRegionAttributes(XmlPullParser xmlParser){
  String regionId=ParserUtil.getAttributeValue(xmlParser,TtmlNode.ATTR_ID);
  String regionOrigin=ParserUtil.getAttributeValue(xmlParser,TtmlNode.ATTR_TTS_ORIGIN);
  String regionExtent=ParserUtil.getAttributeValue(xmlParser,TtmlNode.ATTR_TTS_EXTENT);
  if (regionOrigin == null || regionId == null) {
    return null;
  }
  float position=Cue.DIMEN_UNSET;
  float line=Cue.DIMEN_UNSET;
  Matcher originMatcher=PERCENTAGE_COORDINATES.matcher(regionOrigin);
  if (originMatcher.matches()) {
    try {
      position=Float.parseFloat(originMatcher.group(1)) / 100.f;
      line=Float.parseFloat(originMatcher.group(2)) / 100.f;
    }
 catch (    NumberFormatException e) {
      Log.w(TAG,""String_Node_Str"" + regionOrigin + ""String_Node_Str"",e);
      position=Cue.DIMEN_UNSET;
    }
  }
  float width=Cue.DIMEN_UNSET;
  if (regionExtent != null) {
    Matcher extentMatcher=PERCENTAGE_COORDINATES.matcher(regionExtent);
    if (extentMatcher.matches()) {
      try {
        width=Float.parseFloat(extentMatcher.group(1)) / 100.f;
      }
 catch (      NumberFormatException e) {
        Log.w(TAG,""String_Node_Str"" + regionExtent + ""String_Node_Str"",e);
      }
    }
  }
  return position != Cue.DIMEN_UNSET ? new Pair<>(regionId,new TtmlRegion(position,line,Cue.LINE_TYPE_FRACTION,width)) : null;
}",0.9926634768740032
110377,"public TtmlRegion(float position,float line,float width){
  this.position=position;
  this.line=line;
  this.width=width;
}","public TtmlRegion(float position,float line,int lineType,float width){
  this.position=position;
  this.line=line;
  this.lineType=lineType;
  this.width=width;
}",0.8631578947368421
110378,"private void doSomeWork() throws ExoPlaybackException, IOException {
  long operationStartTimeMs=SystemClock.elapsedRealtime();
  timeline.updateSources();
  if (timeline.getSampleSource() == null) {
    timeline.maybeThrowSourcePrepareError();
    scheduleNextOperation(MSG_DO_SOME_WORK,operationStartTimeMs,PREPARING_SOURCE_INTERVAL_MS);
    return;
  }
  TraceUtil.beginSection(""String_Node_Str"");
  updatePlaybackPositions();
  boolean allRenderersEnded=true;
  boolean allRenderersReadyOrEnded=true;
  for (  TrackRenderer renderer : enabledRenderers) {
    renderer.render(internalPositionUs,elapsedRealtimeUs);
    allRenderersEnded=allRenderersEnded && renderer.isEnded();
    boolean rendererReadyOrEnded=isReadyOrEnded(renderer);
    if (!rendererReadyOrEnded) {
      renderer.maybeThrowStreamError();
    }
    allRenderersReadyOrEnded=allRenderersReadyOrEnded && rendererReadyOrEnded;
  }
  if (!allRenderersReadyOrEnded) {
    timeline.maybeThrowSourcePrepareError();
  }
  if (allRenderersEnded && (playbackInfo.durationUs == C.UNSET_TIME_US || playbackInfo.durationUs <= playbackInfo.positionUs) && timeline.isEnded) {
    setState(ExoPlayer.STATE_ENDED);
    stopRenderers();
  }
 else   if (state == ExoPlayer.STATE_BUFFERING) {
    if ((enabledRenderers.length > 0 ? allRenderersReadyOrEnded : timeline.isReady) && bufferingPolicy.haveSufficientBuffer(playbackInfo.bufferedPositionUs,rebuffering)) {
      setState(ExoPlayer.STATE_READY);
      if (playWhenReady) {
        startRenderers();
      }
    }
  }
 else   if (state == ExoPlayer.STATE_READY) {
    if (enabledRenderers.length > 0 ? !allRenderersReadyOrEnded : !timeline.isReady) {
      rebuffering=playWhenReady;
      setState(ExoPlayer.STATE_BUFFERING);
      stopRenderers();
    }
  }
  handler.removeMessages(MSG_DO_SOME_WORK);
  if ((playWhenReady && state == ExoPlayer.STATE_READY) || state == ExoPlayer.STATE_BUFFERING) {
    scheduleNextOperation(MSG_DO_SOME_WORK,operationStartTimeMs,RENDERING_INTERVAL_MS);
  }
 else   if (enabledRenderers.length != 0) {
    scheduleNextOperation(MSG_DO_SOME_WORK,operationStartTimeMs,IDLE_INTERVAL_MS);
  }
  TraceUtil.endSection();
}","private void doSomeWork() throws ExoPlaybackException, IOException {
  long operationStartTimeMs=SystemClock.elapsedRealtime();
  timeline.updateSources();
  if (timeline.getSampleSource() == null) {
    timeline.maybeThrowSourcePrepareError();
    scheduleNextOperation(MSG_DO_SOME_WORK,operationStartTimeMs,PREPARING_SOURCE_INTERVAL_MS);
    return;
  }
  TraceUtil.beginSection(""String_Node_Str"");
  updatePlaybackPositions();
  boolean allRenderersEnded=true;
  boolean allRenderersReadyOrEnded=true;
  for (  TrackRenderer renderer : enabledRenderers) {
    renderer.render(internalPositionUs,elapsedRealtimeUs);
    allRenderersEnded=allRenderersEnded && renderer.isEnded();
    boolean rendererReadyOrEnded=renderer.isReady() || renderer.isEnded();
    if (!rendererReadyOrEnded) {
      renderer.maybeThrowStreamError();
    }
    allRenderersReadyOrEnded=allRenderersReadyOrEnded && rendererReadyOrEnded;
  }
  if (!allRenderersReadyOrEnded) {
    timeline.maybeThrowSourcePrepareError();
  }
  if (allRenderersEnded && (playbackInfo.durationUs == C.UNSET_TIME_US || playbackInfo.durationUs <= playbackInfo.positionUs) && timeline.isEnded) {
    setState(ExoPlayer.STATE_ENDED);
    stopRenderers();
  }
 else   if (state == ExoPlayer.STATE_BUFFERING) {
    if ((enabledRenderers.length > 0 ? allRenderersReadyOrEnded : timeline.isReady) && bufferingPolicy.haveSufficientBuffer(playbackInfo.bufferedPositionUs,rebuffering)) {
      setState(ExoPlayer.STATE_READY);
      if (playWhenReady) {
        startRenderers();
      }
    }
  }
 else   if (state == ExoPlayer.STATE_READY) {
    if (enabledRenderers.length > 0 ? !allRenderersReadyOrEnded : !timeline.isReady) {
      rebuffering=playWhenReady;
      setState(ExoPlayer.STATE_BUFFERING);
      stopRenderers();
    }
  }
  handler.removeMessages(MSG_DO_SOME_WORK);
  if ((playWhenReady && state == ExoPlayer.STATE_READY) || state == ExoPlayer.STATE_BUFFERING) {
    scheduleNextOperation(MSG_DO_SOME_WORK,operationStartTimeMs,RENDERING_INTERVAL_MS);
  }
 else   if (enabledRenderers.length != 0) {
    scheduleNextOperation(MSG_DO_SOME_WORK,operationStartTimeMs,IDLE_INTERVAL_MS);
  }
  TraceUtil.endSection();
}",0.9857142857142858
110379,"@Override public long readDiscontinuity(){
  for (  SampleSource source : enabledSources) {
    if (source.readDiscontinuity() != C.UNSET_TIME_US) {
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
  return C.UNSET_TIME_US;
}","@Override public long readDiscontinuity(){
  long positionUs=enabledSources[0].readDiscontinuity();
  if (positionUs != C.UNSET_TIME_US) {
    for (int i=1; i < enabledSources.length; i++) {
      if (enabledSources[i].seekToUs(positionUs) != positionUs) {
        throw new IllegalStateException(""String_Node_Str"");
      }
    }
  }
  for (int i=1; i < enabledSources.length; i++) {
    if (enabledSources[i].readDiscontinuity() != C.UNSET_TIME_US) {
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
  return positionUs;
}",0.3964421855146124
110380,"@Override public TrackStream[] selectTracks(List<TrackStream> oldStreams,List<TrackSelection> newSelections,long positionUs){
  Assertions.checkState(prepared);
  boolean tracksWereEnabled=enabledTrackCount > 0;
  for (int i=0; i < oldStreams.size(); i++) {
    int track=((TrackStreamImpl)oldStreams.get(i)).track;
    Assertions.checkState(trackEnabledStates[track]);
    enabledTrackCount--;
    trackEnabledStates[track]=false;
    sampleQueues[track].disable();
  }
  TrackStream[] newStreams=new TrackStream[newSelections.size()];
  for (int i=0; i < newStreams.length; i++) {
    TrackSelection selection=newSelections.get(i);
    Assertions.checkState(selection.length == 1);
    Assertions.checkState(selection.getTrack(0) == 0);
    int track=selection.group;
    Assertions.checkState(!trackEnabledStates[track]);
    enabledTrackCount++;
    trackEnabledStates[track]=true;
    newStreams[i]=new TrackStreamImpl(track);
  }
  if (!seenFirstTrackSelection) {
    for (int i=0; i < sampleQueues.length; i++) {
      if (!trackEnabledStates[i]) {
        sampleQueues[i].disable();
      }
    }
  }
  if (enabledTrackCount == 0) {
    if (tracksWereEnabled) {
      loadControl.unregister(this);
      loadCondition.close();
    }
    if (loader.isLoading()) {
      loader.cancelLoading();
    }
  }
 else {
    if (!tracksWereEnabled) {
      loadControl.register(this);
      loadCondition.open();
    }
    if (seenFirstTrackSelection ? newStreams.length > 0 : positionUs != 0) {
      seekToUs(positionUs);
    }
  }
  seenFirstTrackSelection=true;
  return newStreams;
}","@Override public TrackStream[] selectTracks(List<TrackStream> oldStreams,List<TrackSelection> newSelections,long positionUs){
  Assertions.checkState(prepared);
  boolean tracksWereEnabled=enabledTrackCount > 0;
  for (int i=0; i < oldStreams.size(); i++) {
    int track=((TrackStreamImpl)oldStreams.get(i)).track;
    Assertions.checkState(trackEnabledStates[track]);
    enabledTrackCount--;
    trackEnabledStates[track]=false;
    sampleQueues[track].disable();
  }
  TrackStream[] newStreams=new TrackStream[newSelections.size()];
  for (int i=0; i < newStreams.length; i++) {
    TrackSelection selection=newSelections.get(i);
    Assertions.checkState(selection.length == 1);
    Assertions.checkState(selection.getTrack(0) == 0);
    int track=selection.group;
    Assertions.checkState(!trackEnabledStates[track]);
    enabledTrackCount++;
    trackEnabledStates[track]=true;
    newStreams[i]=new TrackStreamImpl(track);
  }
  if (!seenFirstTrackSelection) {
    for (int i=0; i < sampleQueues.length; i++) {
      if (!trackEnabledStates[i]) {
        sampleQueues[i].disable();
      }
    }
  }
  if (enabledTrackCount == 0) {
    if (tracksWereEnabled) {
      loadControl.unregister(this);
      loadCondition.close();
    }
    if (loader.isLoading()) {
      loader.cancelLoading();
    }
  }
 else {
    if (!tracksWereEnabled) {
      loadControl.register(this);
      loadCondition.open();
    }
    if (seenFirstTrackSelection ? newStreams.length > 0 : positionUs != 0) {
      long seekPositionUs=seekToUs(positionUs);
      if (seekPositionUs != positionUs) {
        notifyReset=true;
      }
    }
  }
  seenFirstTrackSelection=true;
  return newStreams;
}",0.966952264381885
110381,"@Override public long seekToUs(long positionUs){
  positionUs=seekMap.isSeekable() ? positionUs : 0;
  lastSeekPositionUs=positionUs;
  notifyReset=true;
  boolean seekInsideBuffer=!isPendingReset();
  for (int i=0; seekInsideBuffer && i < sampleQueues.length; i++) {
    if (trackEnabledStates[i]) {
      seekInsideBuffer=sampleQueues[i].skipToKeyframeBefore(positionUs);
    }
  }
  if (!seekInsideBuffer) {
    restartFrom(positionUs);
  }
  return positionUs;
}","@Override public long seekToUs(long positionUs){
  positionUs=seekMap.isSeekable() ? positionUs : 0;
  lastSeekPositionUs=positionUs;
  boolean seekInsideBuffer=!isPendingReset();
  for (int i=0; seekInsideBuffer && i < sampleQueues.length; i++) {
    if (trackEnabledStates[i]) {
      seekInsideBuffer=sampleQueues[i].skipToKeyframeBefore(positionUs);
    }
  }
  if (!seekInsideBuffer) {
    restartFrom(positionUs);
  }
  notifyReset=false;
  return positionUs;
}",0.3193997856377277
110382,"private void startLoading(){
  ExtractingLoadable loadable=new ExtractingLoadable(uri,dataSource,extractorHolder,loadCondition);
  if (prepared) {
    Assertions.checkState(isPendingReset());
    if (durationUs != C.UNSET_TIME_US && pendingResetPositionUs >= durationUs) {
      loadingFinished=true;
      pendingResetPositionUs=C.UNSET_TIME_US;
      return;
    }
    loadable.setLoadPosition(seekMap.getPosition(pendingResetPositionUs));
    pendingResetPositionUs=C.UNSET_TIME_US;
  }
  extractedSamplesCountAtStartOfLoad=getExtractedSamplesCount();
  int minRetryCount=minLoadableRetryCount;
  if (minRetryCount == MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA) {
    minRetryCount=!prepared || (length != C.LENGTH_UNBOUNDED || (seekMap != null && seekMap.getDurationUs() != C.UNSET_TIME_US)) ? DEFAULT_MIN_LOADABLE_RETRY_COUNT_ON_DEMAND : DEFAULT_MIN_LOADABLE_RETRY_COUNT_LIVE;
  }
  loader.startLoading(loadable,this,minRetryCount);
}","private void startLoading(){
  ExtractingLoadable loadable=new ExtractingLoadable(uri,dataSource,extractorHolder,loadCondition);
  if (prepared) {
    Assertions.checkState(isPendingReset());
    if (durationUs != C.UNSET_TIME_US && pendingResetPositionUs >= durationUs) {
      loadingFinished=true;
      pendingResetPositionUs=C.UNSET_TIME_US;
      return;
    }
    loadable.setLoadPosition(seekMap.getPosition(pendingResetPositionUs));
    pendingResetPositionUs=C.UNSET_TIME_US;
  }
  extractedSamplesCountAtStartOfLoad=getExtractedSamplesCount();
  loader.startLoading(loadable,this,0);
}",0.744429882044561
110383,"public LoadTask(Looper looper,T loadable,Loader.Callback<T> callback,int minRetryCount,long startTimeMs){
  super(looper);
  this.loadable=loadable;
  this.callback=callback;
  this.minRetryCount=minRetryCount;
  this.startTimeMs=startTimeMs;
}","public LoadTask(Looper looper,T loadable,Loader.Callback<T> callback,int defaultMinRetryCount,long startTimeMs){
  super(looper);
  this.loadable=loadable;
  this.callback=callback;
  this.defaultMinRetryCount=defaultMinRetryCount;
  this.startTimeMs=startTimeMs;
}",0.7426326129666012
110384,"/** 
 * Start loading a   {@link Loadable}. <p> The calling thread must be a   {@link Looper} thread, which is the thread on which the{@link Callback} will be invoked.
 * @param loadable The {@link Loadable} to load.
 * @param callback A callback to invoke when the load ends.
 * @param minRetryCount The minimum number of times the load must be retried before{@link #maybeThrowError()} will propagate an error.
 * @throws IllegalStateException If the calling thread does not have an associated {@link Looper}.
 * @return {@link SystemClock#elapsedRealtime} when the load started.
 */
public <T extends Loadable>long startLoading(T loadable,Callback<T> callback,int minRetryCount){
  Looper looper=Looper.myLooper();
  Assertions.checkState(looper != null);
  long startTimeMs=SystemClock.elapsedRealtime();
  new LoadTask<>(looper,loadable,callback,minRetryCount,startTimeMs).start(0);
  return startTimeMs;
}","/** 
 * Start loading a   {@link Loadable}. <p> The calling thread must be a   {@link Looper} thread, which is the thread on which the{@link Callback} will be invoked.
 * @param loadable The {@link Loadable} to load.
 * @param callback A callback to invoke when the load ends.
 * @param defaultMinRetryCount The minimum number of times the load must be retried before{@link #maybeThrowError()} will propagate an error.
 * @throws IllegalStateException If the calling thread does not have an associated {@link Looper}.
 * @return {@link SystemClock#elapsedRealtime} when the load started.
 */
public <T extends Loadable>long startLoading(T loadable,Callback<T> callback,int defaultMinRetryCount){
  Looper looper=Looper.myLooper();
  Assertions.checkState(looper != null);
  long startTimeMs=SystemClock.elapsedRealtime();
  new LoadTask<>(looper,loadable,callback,defaultMinRetryCount,startTimeMs).start(0);
  return startTimeMs;
}",0.9853340575774036
110385,"public void maybeThrowError() throws IOException {
  if (currentError != null && errorCount > minRetryCount) {
    throw currentError;
  }
}","public void maybeThrowError(int minRetryCount) throws IOException {
  if (currentError != null && errorCount > minRetryCount) {
    throw currentError;
  }
}",0.9427609427609428
110386,"/** 
 * Skips to the data in the given WAV input stream and returns its data size. After calling, the input stream's position will point to the start of sample data in the WAV. <p> If an exception is thrown, the input position will be left pointing to a chunk header.
 * @param input Input stream to skip to the data chunk in. Its peek position must be pointing toa valid chunk header.
 * @param wavHeader WAV header to populate with data bounds.
 * @throws ParserException If an error occurs parsing chunks.
 * @throws IOException If reading from the input fails.
 * @throws InterruptedException If interrupted while reading from input.
 */
public static void skipToData(ExtractorInput input,WavHeader wavHeader) throws IOException, InterruptedException {
  Assertions.checkNotNull(input);
  Assertions.checkNotNull(wavHeader);
  ParsableByteArray scratch=new ParsableByteArray(ChunkHeader.SIZE_IN_BYTES);
  ChunkHeader chunkHeader=ChunkHeader.peek(input,scratch);
  while (chunkHeader.id != Util.getIntegerCodeForString(""String_Node_Str"")) {
    Log.w(TAG,""String_Node_Str"" + chunkHeader.id);
    long bytesToSkip=ChunkHeader.SIZE_IN_BYTES + chunkHeader.size;
    if (chunkHeader.id == Util.getIntegerCodeForString(""String_Node_Str"")) {
      bytesToSkip=ChunkHeader.SIZE_IN_BYTES + 4;
    }
    if (bytesToSkip > Integer.MAX_VALUE) {
      throw new ParserException(""String_Node_Str"" + chunkHeader.id);
    }
    input.skipFully((int)bytesToSkip);
    chunkHeader=ChunkHeader.peek(input,scratch);
  }
  input.skipFully(ChunkHeader.SIZE_IN_BYTES);
  wavHeader.setDataBounds(input.getPosition(),chunkHeader.size);
}","/** 
 * Skips to the data in the given WAV input stream and returns its data size. After calling, the input stream's position will point to the start of sample data in the WAV. <p> If an exception is thrown, the input position will be left pointing to a chunk header.
 * @param input Input stream to skip to the data chunk in. Its peek position must be pointing toa valid chunk header.
 * @param wavHeader WAV header to populate with data bounds.
 * @throws ParserException If an error occurs parsing chunks.
 * @throws IOException If reading from the input fails.
 * @throws InterruptedException If interrupted while reading from input.
 */
public static void skipToData(ExtractorInput input,WavHeader wavHeader) throws IOException, InterruptedException {
  Assertions.checkNotNull(input);
  Assertions.checkNotNull(wavHeader);
  input.resetPeekPosition();
  ParsableByteArray scratch=new ParsableByteArray(ChunkHeader.SIZE_IN_BYTES);
  ChunkHeader chunkHeader=ChunkHeader.peek(input,scratch);
  while (chunkHeader.id != Util.getIntegerCodeForString(""String_Node_Str"")) {
    Log.w(TAG,""String_Node_Str"" + chunkHeader.id);
    long bytesToSkip=ChunkHeader.SIZE_IN_BYTES + chunkHeader.size;
    if (chunkHeader.id == Util.getIntegerCodeForString(""String_Node_Str"")) {
      bytesToSkip=ChunkHeader.SIZE_IN_BYTES + 4;
    }
    if (bytesToSkip > Integer.MAX_VALUE) {
      throw new ParserException(""String_Node_Str"" + chunkHeader.id);
    }
    input.skipFully((int)bytesToSkip);
    chunkHeader=ChunkHeader.peek(input,scratch);
  }
  input.skipFully(ChunkHeader.SIZE_IN_BYTES);
  wavHeader.setDataBounds(input.getPosition(),chunkHeader.size);
}",0.9911070223857712
110387,"@Override public boolean isReady(){
  return loadingFinished || !sampleQueue.isEmpty();
}","@Override public boolean isReady(){
  return loadingFinished || (!isPendingReset() && !sampleQueue.isEmpty());
}",0.8855721393034826
110388,"@Override public TrackStream[] selectTracks(List<TrackStream> oldStreams,List<TrackSelection> newSelections,long positionUs){
  Assertions.checkState(prepared);
  Assertions.checkState(oldStreams.size() <= 1);
  Assertions.checkState(newSelections.size() <= 1);
  boolean trackWasEnabled=trackEnabled;
  if (!oldStreams.isEmpty()) {
    Assertions.checkState(trackEnabled);
    trackEnabled=false;
    chunkSource.disable();
  }
  TrackStream[] newStreams=new TrackStream[newSelections.size()];
  if (!newSelections.isEmpty()) {
    Assertions.checkState(!trackEnabled);
    trackEnabled=true;
    chunkSource.enable(newSelections.get(0).getTracks());
    newStreams[0]=this;
  }
  if (!trackEnabled) {
    if (trackWasEnabled) {
      loadControl.unregister(this);
    }
    if (loader.isLoading()) {
      loader.cancelLoading();
    }
 else {
      clearState();
      loadControl.trimAllocator();
    }
  }
 else {
    if (!trackWasEnabled) {
      loadControl.register(this,bufferSizeContribution);
    }
    downstreamFormat=null;
    downstreamSampleFormat=null;
    downstreamPositionUs=positionUs;
    lastSeekPositionUs=positionUs;
    pendingReset=false;
    restartFrom(positionUs);
  }
  return newStreams;
}","@Override public TrackStream[] selectTracks(List<TrackStream> oldStreams,List<TrackSelection> newSelections,long positionUs){
  Assertions.checkState(prepared);
  Assertions.checkState(oldStreams.size() <= 1);
  Assertions.checkState(newSelections.size() <= 1);
  boolean trackWasEnabled=trackEnabled;
  if (!oldStreams.isEmpty()) {
    Assertions.checkState(trackEnabled);
    trackEnabled=false;
    chunkSource.disable();
  }
  TrackStream[] newStreams=new TrackStream[newSelections.size()];
  if (!newSelections.isEmpty()) {
    Assertions.checkState(!trackEnabled);
    trackEnabled=true;
    chunkSource.enable(newSelections.get(0).getTracks());
    newStreams[0]=this;
  }
  if (!trackEnabled) {
    if (trackWasEnabled) {
      loadControl.unregister(this);
    }
    if (loader.isLoading()) {
      loader.cancelLoading();
    }
 else {
      clearState();
      loadControl.trimAllocator();
    }
  }
 else {
    if (!trackWasEnabled) {
      loadControl.register(this,bufferSizeContribution);
    }
    downstreamFormat=null;
    sampleQueue.needDownstreamFormat();
    downstreamPositionUs=positionUs;
    lastSeekPositionUs=positionUs;
    pendingReset=false;
    restartFrom(positionUs);
  }
  return newStreams;
}",0.9873417721518988
110389,"@Override public int readData(FormatHolder formatHolder,DecoderInputBuffer buffer){
  if (pendingReset || isPendingReset()) {
    return NOTHING_READ;
  }
  BaseMediaChunk currentChunk=mediaChunks.getFirst();
  while (mediaChunks.size() > 1 && mediaChunks.get(1).getFirstSampleIndex() <= sampleQueue.getReadIndex()) {
    mediaChunks.removeFirst();
    currentChunk=mediaChunks.getFirst();
  }
  if (downstreamFormat == null || !downstreamFormat.equals(currentChunk.format)) {
    eventDispatcher.downstreamFormatChanged(currentChunk.format,currentChunk.trigger,currentChunk.startTimeUs);
    downstreamFormat=currentChunk.format;
  }
  if (sampleQueue.isEmpty()) {
    if (loadingFinished) {
      buffer.addFlag(C.BUFFER_FLAG_END_OF_STREAM);
      return BUFFER_READ;
    }
    return NOTHING_READ;
  }
  Format sampleFormat=sampleQueue.getDownstreamFormat();
  if (!sampleFormat.equals(downstreamSampleFormat)) {
    formatHolder.format=sampleFormat;
    formatHolder.drmInitData=currentChunk.getDrmInitData();
    downstreamSampleFormat=sampleFormat;
    return FORMAT_READ;
  }
  if (sampleQueue.readSample(buffer)) {
    if (buffer.timeUs < lastSeekPositionUs) {
      buffer.addFlag(C.BUFFER_FLAG_DECODE_ONLY);
    }
    onSampleRead(currentChunk,buffer);
    return BUFFER_READ;
  }
  return NOTHING_READ;
}","@Override public int readData(FormatHolder formatHolder,DecoderInputBuffer buffer){
  if (pendingReset || isPendingReset()) {
    return NOTHING_READ;
  }
  while (mediaChunks.size() > 1 && mediaChunks.get(1).getFirstSampleIndex() <= sampleQueue.getReadIndex()) {
    mediaChunks.removeFirst();
  }
  BaseMediaChunk currentChunk=mediaChunks.getFirst();
  Format currentFormat=currentChunk.format;
  if (downstreamFormat == null || !downstreamFormat.equals(currentFormat)) {
    eventDispatcher.downstreamFormatChanged(currentFormat,currentChunk.trigger,currentChunk.startTimeUs);
    downstreamFormat=currentFormat;
  }
  int result=sampleQueue.readData(formatHolder,buffer,loadingFinished);
switch (result) {
case FORMAT_READ:
    formatHolder.drmInitData=currentChunk.getDrmInitData();
  break;
case BUFFER_READ:
if (!buffer.isEndOfStream()) {
  if (buffer.timeUs < lastSeekPositionUs) {
    buffer.addFlag(C.BUFFER_FLAG_DECODE_ONLY);
  }
  onSampleRead(currentChunk,buffer);
}
break;
}
return result;
}",0.5982758620689655
110390,"@Override public void sampleMetadata(long timeUs,int flags,int size,int offset,byte[] encryptionKey){
  if (pendingSplice) {
    if ((flags & C.BUFFER_FLAG_KEY_FRAME) == 0 || !infoQueue.attemptSplice(timeUs)) {
      return;
    }
    pendingSplice=false;
  }
  if (needKeyframe) {
    if ((flags & C.BUFFER_FLAG_KEY_FRAME) == 0) {
      return;
    }
    needKeyframe=false;
  }
  timeUs+=sampleOffsetUs;
  long absoluteOffset=totalBytesWritten - size - offset;
  infoQueue.commitSample(timeUs,flags,absoluteOffset,size,encryptionKey,upstreamFormat);
}","@Override public void sampleMetadata(long timeUs,int flags,int size,int offset,byte[] encryptionKey){
  if (pendingSplice) {
    if ((flags & C.BUFFER_FLAG_KEY_FRAME) == 0 || !infoQueue.attemptSplice(timeUs)) {
      return;
    }
    pendingSplice=false;
  }
  if (needKeyframe) {
    if ((flags & C.BUFFER_FLAG_KEY_FRAME) == 0) {
      return;
    }
    needKeyframe=false;
  }
  timeUs+=sampleOffsetUs;
  long absoluteOffset=totalBytesWritten - size - offset;
  infoQueue.commitSample(timeUs,flags,absoluteOffset,size,encryptionKey);
}",0.9862511457378552
110391,"public synchronized void commitSample(long timeUs,int sampleFlags,long offset,int size,byte[] encryptionKey,Format format){
  timesUs[relativeWriteIndex]=timeUs;
  offsets[relativeWriteIndex]=offset;
  sizes[relativeWriteIndex]=size;
  flags[relativeWriteIndex]=sampleFlags;
  encryptionKeys[relativeWriteIndex]=encryptionKey;
  formats[relativeWriteIndex]=format;
  largestQueuedTimestampUs=Math.max(largestQueuedTimestampUs,timeUs);
  queueSize++;
  if (queueSize == capacity) {
    int newCapacity=capacity + SAMPLE_CAPACITY_INCREMENT;
    long[] newOffsets=new long[newCapacity];
    long[] newTimesUs=new long[newCapacity];
    int[] newFlags=new int[newCapacity];
    int[] newSizes=new int[newCapacity];
    byte[][] newEncryptionKeys=new byte[newCapacity][];
    Format[] newFormats=new Format[newCapacity];
    int beforeWrap=capacity - relativeReadIndex;
    System.arraycopy(offsets,relativeReadIndex,newOffsets,0,beforeWrap);
    System.arraycopy(timesUs,relativeReadIndex,newTimesUs,0,beforeWrap);
    System.arraycopy(flags,relativeReadIndex,newFlags,0,beforeWrap);
    System.arraycopy(sizes,relativeReadIndex,newSizes,0,beforeWrap);
    System.arraycopy(encryptionKeys,relativeReadIndex,newEncryptionKeys,0,beforeWrap);
    System.arraycopy(formats,relativeReadIndex,newFormats,0,beforeWrap);
    int afterWrap=relativeReadIndex;
    System.arraycopy(offsets,0,newOffsets,beforeWrap,afterWrap);
    System.arraycopy(timesUs,0,newTimesUs,beforeWrap,afterWrap);
    System.arraycopy(flags,0,newFlags,beforeWrap,afterWrap);
    System.arraycopy(sizes,0,newSizes,beforeWrap,afterWrap);
    System.arraycopy(encryptionKeys,0,newEncryptionKeys,beforeWrap,afterWrap);
    System.arraycopy(formats,0,newFormats,beforeWrap,afterWrap);
    offsets=newOffsets;
    timesUs=newTimesUs;
    flags=newFlags;
    sizes=newSizes;
    encryptionKeys=newEncryptionKeys;
    formats=newFormats;
    relativeReadIndex=0;
    relativeWriteIndex=capacity;
    queueSize=capacity;
    capacity=newCapacity;
  }
 else {
    relativeWriteIndex++;
    if (relativeWriteIndex == capacity) {
      relativeWriteIndex=0;
    }
  }
}","public synchronized void commitSample(long timeUs,int sampleFlags,long offset,int size,byte[] encryptionKey){
  timesUs[relativeWriteIndex]=timeUs;
  offsets[relativeWriteIndex]=offset;
  sizes[relativeWriteIndex]=size;
  flags[relativeWriteIndex]=sampleFlags;
  encryptionKeys[relativeWriteIndex]=encryptionKey;
  formats[relativeWriteIndex]=upstreamFormat;
  largestQueuedTimestampUs=Math.max(largestQueuedTimestampUs,timeUs);
  queueSize++;
  if (queueSize == capacity) {
    int newCapacity=capacity + SAMPLE_CAPACITY_INCREMENT;
    long[] newOffsets=new long[newCapacity];
    long[] newTimesUs=new long[newCapacity];
    int[] newFlags=new int[newCapacity];
    int[] newSizes=new int[newCapacity];
    byte[][] newEncryptionKeys=new byte[newCapacity][];
    Format[] newFormats=new Format[newCapacity];
    int beforeWrap=capacity - relativeReadIndex;
    System.arraycopy(offsets,relativeReadIndex,newOffsets,0,beforeWrap);
    System.arraycopy(timesUs,relativeReadIndex,newTimesUs,0,beforeWrap);
    System.arraycopy(flags,relativeReadIndex,newFlags,0,beforeWrap);
    System.arraycopy(sizes,relativeReadIndex,newSizes,0,beforeWrap);
    System.arraycopy(encryptionKeys,relativeReadIndex,newEncryptionKeys,0,beforeWrap);
    System.arraycopy(formats,relativeReadIndex,newFormats,0,beforeWrap);
    int afterWrap=relativeReadIndex;
    System.arraycopy(offsets,0,newOffsets,beforeWrap,afterWrap);
    System.arraycopy(timesUs,0,newTimesUs,beforeWrap,afterWrap);
    System.arraycopy(flags,0,newFlags,beforeWrap,afterWrap);
    System.arraycopy(sizes,0,newSizes,beforeWrap,afterWrap);
    System.arraycopy(encryptionKeys,0,newEncryptionKeys,beforeWrap,afterWrap);
    System.arraycopy(formats,0,newFormats,beforeWrap,afterWrap);
    offsets=newOffsets;
    timesUs=newTimesUs;
    flags=newFlags;
    sizes=newSizes;
    encryptionKeys=newEncryptionKeys;
    formats=newFormats;
    relativeReadIndex=0;
    relativeWriteIndex=capacity;
    queueSize=capacity;
    capacity=newCapacity;
  }
 else {
    relativeWriteIndex++;
    if (relativeWriteIndex == capacity) {
      relativeWriteIndex=0;
    }
  }
}",0.994328922495274
110392,"/** 
 * Returns the current upstream   {@link Format}.
 */
public Format getUpstreamFormat(){
  return upstreamFormat;
}","/** 
 * Returns the upstream   {@link Format} in which samples are being queued.
 */
public synchronized Format getUpstreamFormat(){
  return upstreamFormat;
}",0.8028673835125448
110393,"/** 
 * Reads data from the front of the rolling buffer.
 * @param absolutePosition The absolute position from which data should be read.
 * @param target The array into which data should be written.
 * @param length The number of bytes to read.
 */
private void readData(long absolutePosition,byte[] target,int length){
  int bytesRead=0;
  while (bytesRead < length) {
    dropDownstreamTo(absolutePosition);
    int positionInAllocation=(int)(absolutePosition - totalBytesDropped);
    int toCopy=Math.min(length - bytesRead,allocationLength - positionInAllocation);
    Allocation allocation=dataQueue.peek();
    System.arraycopy(allocation.data,allocation.translateOffset(positionInAllocation),target,bytesRead,toCopy);
    absolutePosition+=toCopy;
    bytesRead+=toCopy;
  }
}","/** 
 * Attempts to read from the queue.
 * @param formatHolder A {@link FormatHolder} to populate in the case of reading a format.
 * @param buffer A {@link DecoderInputBuffer} to populate in the case of reading a sample or theend of the stream. If a sample is read then the buffer is populated with information about the sample, but not its data. The absolute position of the data in the rolling buffer is stored in  {@code extrasHolder}, along with an encryption id if present and the absolute position of the first byte that may still be required after the current sample has been read.
 * @param extrasHolder The holder into which extra sample information should be written.
 * @return The result, which can be {@link TrackStream#NOTHING_READ},  {@link TrackStream#FORMAT_READ} or {@link TrackStream#BUFFER_READ}.
 */
public synchronized int readData(FormatHolder formatHolder,DecoderInputBuffer buffer,Format downstreamFormat,BufferExtrasHolder extrasHolder){
  if (queueSize == 0) {
    if (upstreamFormat != null && !upstreamFormat.equals(downstreamFormat)) {
      formatHolder.format=upstreamFormat;
      return TrackStream.FORMAT_READ;
    }
    return TrackStream.NOTHING_READ;
  }
  if (!formats[relativeReadIndex].equals(downstreamFormat)) {
    formatHolder.format=formats[relativeReadIndex];
    return TrackStream.FORMAT_READ;
  }
  buffer.timeUs=timesUs[relativeReadIndex];
  buffer.size=sizes[relativeReadIndex];
  buffer.setFlags(flags[relativeReadIndex]);
  extrasHolder.offset=offsets[relativeReadIndex];
  extrasHolder.encryptionKeyId=encryptionKeys[relativeReadIndex];
  largestDequeuedTimestampUs=Math.max(largestDequeuedTimestampUs,buffer.timeUs);
  queueSize--;
  relativeReadIndex++;
  absoluteReadIndex++;
  if (relativeReadIndex == capacity) {
    relativeReadIndex=0;
  }
  extrasHolder.nextOffset=queueSize > 0 ? offsets[relativeReadIndex] : extrasHolder.offset + buffer.size;
  return TrackStream.BUFFER_READ;
}",0.0608281421766214
110394,"public synchronized boolean isEmpty(){
  return queueSize == 0;
}","/** 
 * Returns whether the queue is empty.
 */
public synchronized boolean isEmpty(){
  return queueSize == 0;
}",0.7303370786516854
110395,"@Override public void format(Format format){
  upstreamFormat=getAdjustedSampleFormat(format,sampleOffsetUs);
}","public synchronized void format(Format format){
  upstreamFormat=format;
}",0.6594594594594595
110396,"@Override public void onDrawFrame(GL10 unused){
  VpxOutputBuffer pendingOutputBuffer=pendingOutputBufferReference.getAndSet(null);
  if (pendingOutputBuffer == null && renderedOutputBuffer == null) {
    return;
  }
  if (pendingOutputBuffer != null) {
    if (renderedOutputBuffer != null) {
      renderedOutputBuffer.release();
    }
    renderedOutputBuffer=pendingOutputBuffer;
  }
  VpxOutputBuffer outputBuffer=renderedOutputBuffer;
  float[] colorConversion=outputBuffer.colorspace == VpxOutputBuffer.COLORSPACE_BT601 ? kColorConversion601 : kColorConversion709;
  GLES20.glUniformMatrix3fv(colorMatrixLocation,1,false,colorConversion,0);
  for (int i=0; i < 3; i++) {
    int h=(i == 0) ? outputBuffer.height : (outputBuffer.height + 1) / 2;
    GLES20.glActiveTexture(GLES20.GL_TEXTURE0 + i);
    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,yuvTextures[i]);
    GLES20.glPixelStorei(GLES20.GL_UNPACK_ALIGNMENT,1);
    GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,0,GLES20.GL_LUMINANCE,outputBuffer.yuvStrides[i],h,0,GLES20.GL_LUMINANCE,GLES20.GL_UNSIGNED_BYTE,outputBuffer.yuvPlanes[i]);
  }
  if (previousWidth != outputBuffer.width || previousStride != outputBuffer.yuvStrides[0]) {
    float crop=(float)outputBuffer.width / outputBuffer.yuvStrides[0];
    FloatBuffer textureCoords=nativeFloatBuffer(0.0f,0.0f,0.0f,1.0f,crop,0.0f,crop,1.0f);
    GLES20.glVertexAttribPointer(texLocation,2,GLES20.GL_FLOAT,false,0,textureCoords);
    previousWidth=outputBuffer.width;
    previousStride=outputBuffer.yuvStrides[0];
  }
  GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);
  GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP,0,4);
  checkNoGLES2Error();
}","@Override public void onDrawFrame(GL10 unused){
  VpxOutputBuffer pendingOutputBuffer=pendingOutputBufferReference.getAndSet(null);
  if (pendingOutputBuffer == null && renderedOutputBuffer == null) {
    return;
  }
  if (pendingOutputBuffer != null) {
    if (renderedOutputBuffer != null) {
      renderedOutputBuffer.release();
    }
    renderedOutputBuffer=pendingOutputBuffer;
  }
  VpxOutputBuffer outputBuffer=renderedOutputBuffer;
  float[] colorConversion=outputBuffer.colorspace == VpxOutputBuffer.COLORSPACE_BT601 ? kColorConversion601 : kColorConversion709;
  GLES20.glUniformMatrix3fv(colorMatrixLocation,1,false,colorConversion,0);
  for (int i=0; i < 3; i++) {
    int h=(i == 0) ? outputBuffer.height : (outputBuffer.height + 1) / 2;
    GLES20.glActiveTexture(GLES20.GL_TEXTURE0 + i);
    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,yuvTextures[i]);
    GLES20.glPixelStorei(GLES20.GL_UNPACK_ALIGNMENT,1);
    GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,0,GLES20.GL_LUMINANCE,outputBuffer.yuvStrides[i],h,0,GLES20.GL_LUMINANCE,GLES20.GL_UNSIGNED_BYTE,outputBuffer.yuvPlanes[i]);
  }
  if (previousWidth != outputBuffer.width || previousStride != outputBuffer.yuvStrides[0]) {
    float crop=(float)outputBuffer.width / outputBuffer.yuvStrides[0];
    textureCoords=nativeFloatBuffer(0.0f,0.0f,0.0f,1.0f,crop,0.0f,crop,1.0f);
    GLES20.glVertexAttribPointer(texLocation,2,GLES20.GL_FLOAT,false,0,textureCoords);
    previousWidth=outputBuffer.width;
    previousStride=outputBuffer.yuvStrides[0];
  }
  GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);
  GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP,0,4);
  checkNoGLES2Error();
}",0.9963503649635036
110397,"public SmoothStreamingSourceBuilder(DataSourceFactory dataSourceFactory,String url,MediaDrmCallback drmCallback){
  this.dataSourceFactory=dataSourceFactory;
  this.url=url;
  this.drmCallback=drmCallback;
}","public SmoothStreamingSourceBuilder(DataSourceFactory dataSourceFactory,String url,MediaDrmCallback drmCallback){
  this.dataSourceFactory=dataSourceFactory;
  this.url=Util.toLowerInvariant(url).endsWith(""String_Node_Str"") ? url : url + ""String_Node_Str"";
  this.drmCallback=drmCallback;
}",0.8209255533199196
110398,"private void initForManifest(SmoothStreamingManifest manifest){
  for (int i=0; i < manifest.streamElements.length; i++) {
    if (manifest.streamElements[i].type == streamElementType) {
      Format[] formats=manifest.streamElements[i].formats;
      if (formats.length > 0) {
        long timescale=manifest.streamElements[i].timescale;
        extractorWrappers=new ChunkExtractorWrapper[formats.length];
        for (int j=0; j < formats.length; j++) {
          int nalUnitLengthFieldLength=streamElementType == StreamElement.TYPE_VIDEO ? 4 : -1;
          Track track=new Track(j,streamElementType,timescale,C.UNKNOWN_TIME_US,durationUs,formats[j],trackEncryptionBoxes,nalUnitLengthFieldLength,null,null);
          FragmentedMp4Extractor extractor=new FragmentedMp4Extractor(FragmentedMp4Extractor.FLAG_WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME | FragmentedMp4Extractor.FLAG_WORKAROUND_IGNORE_TFDT_BOX,track);
          extractorWrappers[j]=new ChunkExtractorWrapper(extractor);
        }
        elementIndex=i;
        trackGroup=new TrackGroup(adaptiveFormatEvaluator != null,formats);
        return;
      }
    }
  }
  extractorWrappers=null;
  trackGroup=null;
}","private void initForManifest(SmoothStreamingManifest manifest){
  for (int i=0; i < manifest.streamElements.length; i++) {
    if (manifest.streamElements[i].type == streamElementType) {
      Format[] formats=manifest.streamElements[i].formats;
      if (formats.length > 0) {
        long timescale=manifest.streamElements[i].timescale;
        extractorWrappers=new ChunkExtractorWrapper[formats.length];
        for (int j=0; j < formats.length; j++) {
          int nalUnitLengthFieldLength=streamElementType == StreamElement.TYPE_VIDEO ? 4 : -1;
          int mp4TrackType=getMp4TrackType(streamElementType);
          Track track=new Track(j,mp4TrackType,timescale,C.UNKNOWN_TIME_US,durationUs,formats[j],trackEncryptionBoxes,nalUnitLengthFieldLength,null,null);
          FragmentedMp4Extractor extractor=new FragmentedMp4Extractor(FragmentedMp4Extractor.FLAG_WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME | FragmentedMp4Extractor.FLAG_WORKAROUND_IGNORE_TFDT_BOX,track);
          extractorWrappers[j]=new ChunkExtractorWrapper(extractor);
        }
        elementIndex=i;
        trackGroup=new TrackGroup(adaptiveFormatEvaluator != null,formats);
        return;
      }
    }
  }
  extractorWrappers=null;
  trackGroup=null;
}",0.965174129353234
110399,"@Override public final void getNextChunk(MediaChunk previous,long playbackPositionUs,ChunkHolder out){
  if (fatalError != null) {
    return;
  }
  if (enabledFormats.length > 1) {
    long bufferedDurationUs=previous != null ? (previous.endTimeUs - playbackPositionUs) : 0;
    adaptiveFormatEvaluator.evaluateFormat(bufferedDurationUs,adaptiveFormatBlacklistFlags,evaluation);
  }
 else {
    evaluation.format=enabledFormats[0];
    evaluation.trigger=Chunk.TRIGGER_MANUAL;
  }
  Format selectedFormat=evaluation.format;
  if (selectedFormat == null) {
    return;
  }
  StreamElement streamElement=currentManifest.streamElements[elementIndex];
  if (streamElement.chunkCount == 0) {
    if (currentManifest.isLive) {
      needManifestRefresh=true;
    }
 else {
      out.endOfStream=true;
    }
    return;
  }
  int chunkIndex;
  if (previous == null) {
    if (live) {
      playbackPositionUs=getLiveSeekPosition(currentManifest,liveEdgeLatencyUs);
    }
    chunkIndex=streamElement.getChunkIndex(playbackPositionUs);
  }
 else {
    chunkIndex=previous.chunkIndex + 1 - currentManifestChunkOffset;
  }
  if (live && chunkIndex < 0) {
    fatalError=new BehindLiveWindowException();
    return;
  }
 else   if (currentManifest.isLive) {
    if (chunkIndex >= streamElement.chunkCount) {
      needManifestRefresh=true;
      return;
    }
 else     if (chunkIndex == streamElement.chunkCount - 1) {
      needManifestRefresh=true;
    }
  }
 else   if (chunkIndex >= streamElement.chunkCount) {
    out.endOfStream=true;
    return;
  }
  boolean isLastChunk=!currentManifest.isLive && chunkIndex == streamElement.chunkCount - 1;
  long chunkStartTimeUs=streamElement.getStartTimeUs(chunkIndex);
  long chunkEndTimeUs=isLastChunk ? -1 : chunkStartTimeUs + streamElement.getChunkDurationUs(chunkIndex);
  int currentAbsoluteChunkIndex=chunkIndex + currentManifestChunkOffset;
  int trackGroupTrackIndex=getTrackGroupTrackIndex(trackGroup,selectedFormat);
  ChunkExtractorWrapper extractorWrapper=extractorWrappers[trackGroupTrackIndex];
  int manifestTrackIndex=getManifestTrackIndex(streamElement,selectedFormat);
  Uri uri=streamElement.buildRequestUri(manifestTrackIndex,chunkIndex);
  Chunk mediaChunk=newMediaChunk(selectedFormat,dataSource,uri,null,currentAbsoluteChunkIndex,chunkStartTimeUs,chunkEndTimeUs,evaluation.trigger,extractorWrapper,drmInitData,selectedFormat);
  out.chunk=mediaChunk;
}","@Override public final void getNextChunk(MediaChunk previous,long playbackPositionUs,ChunkHolder out){
  if (fatalError != null) {
    return;
  }
  if (enabledFormats.length > 1) {
    long bufferedDurationUs=previous != null ? (previous.endTimeUs - playbackPositionUs) : 0;
    adaptiveFormatEvaluator.evaluateFormat(bufferedDurationUs,adaptiveFormatBlacklistFlags,evaluation);
  }
 else {
    evaluation.format=enabledFormats[0];
    evaluation.trigger=Chunk.TRIGGER_MANUAL;
  }
  Format selectedFormat=evaluation.format;
  if (selectedFormat == null) {
    return;
  }
  StreamElement streamElement=currentManifest.streamElements[elementIndex];
  if (streamElement.chunkCount == 0) {
    if (currentManifest.isLive) {
      needManifestRefresh=true;
    }
 else {
      out.endOfStream=true;
    }
    return;
  }
  int chunkIndex;
  if (previous == null) {
    if (live) {
      playbackPositionUs=getLiveSeekPosition(currentManifest,liveEdgeLatencyUs);
    }
    chunkIndex=streamElement.getChunkIndex(playbackPositionUs);
  }
 else {
    chunkIndex=previous.chunkIndex + 1 - currentManifestChunkOffset;
  }
  if (live && chunkIndex < 0) {
    fatalError=new BehindLiveWindowException();
    return;
  }
 else   if (currentManifest.isLive) {
    if (chunkIndex >= streamElement.chunkCount) {
      needManifestRefresh=true;
      return;
    }
 else     if (chunkIndex == streamElement.chunkCount - 1) {
      needManifestRefresh=true;
    }
  }
 else   if (chunkIndex >= streamElement.chunkCount) {
    out.endOfStream=true;
    return;
  }
  long chunkStartTimeUs=streamElement.getStartTimeUs(chunkIndex);
  long chunkEndTimeUs=chunkStartTimeUs + streamElement.getChunkDurationUs(chunkIndex);
  int currentAbsoluteChunkIndex=chunkIndex + currentManifestChunkOffset;
  int trackGroupTrackIndex=getTrackGroupTrackIndex(trackGroup,selectedFormat);
  ChunkExtractorWrapper extractorWrapper=extractorWrappers[trackGroupTrackIndex];
  int manifestTrackIndex=getManifestTrackIndex(streamElement,selectedFormat);
  Uri uri=streamElement.buildRequestUri(manifestTrackIndex,chunkIndex);
  Chunk mediaChunk=newMediaChunk(selectedFormat,dataSource,uri,null,currentAbsoluteChunkIndex,chunkStartTimeUs,chunkEndTimeUs,evaluation.trigger,extractorWrapper,drmInitData,selectedFormat);
  out.chunk=mediaChunk;
}",0.976240984302079
110400,"/** 
 * Parses an stbl atom (defined in 14496-12).
 * @param track Track to which this sample table corresponds.
 * @param stblAtom stbl (sample table) atom to parse.
 * @return Sample table described by the stbl atom.
 * @throws ParserException If the resulting sample sequence does not contain a sync sample.
 */
public static TrackSampleTable parseStbl(Track track,Atom.ContainerAtom stblAtom) throws ParserException {
  ParsableByteArray stsz=stblAtom.getLeafAtomOfType(Atom.TYPE_stsz).data;
  ParsableByteArray chunkOffsets;
  Atom.LeafAtom chunkOffsetsAtom=stblAtom.getLeafAtomOfType(Atom.TYPE_stco);
  if (chunkOffsetsAtom == null) {
    chunkOffsetsAtom=stblAtom.getLeafAtomOfType(Atom.TYPE_co64);
  }
  chunkOffsets=chunkOffsetsAtom.data;
  ParsableByteArray stsc=stblAtom.getLeafAtomOfType(Atom.TYPE_stsc).data;
  ParsableByteArray stts=stblAtom.getLeafAtomOfType(Atom.TYPE_stts).data;
  Atom.LeafAtom stssAtom=stblAtom.getLeafAtomOfType(Atom.TYPE_stss);
  ParsableByteArray stss=stssAtom != null ? stssAtom.data : null;
  Atom.LeafAtom cttsAtom=stblAtom.getLeafAtomOfType(Atom.TYPE_ctts);
  ParsableByteArray ctts=cttsAtom != null ? cttsAtom.data : null;
  stsz.setPosition(Atom.FULL_HEADER_SIZE);
  int fixedSampleSize=stsz.readUnsignedIntToInt();
  int sampleCount=stsz.readUnsignedIntToInt();
  long[] offsets=new long[sampleCount];
  int[] sizes=new int[sampleCount];
  int maximumSize=0;
  long[] timestamps=new long[sampleCount];
  int[] flags=new int[sampleCount];
  if (sampleCount == 0) {
    return new TrackSampleTable(offsets,sizes,maximumSize,timestamps,flags);
  }
  chunkOffsets.setPosition(Atom.FULL_HEADER_SIZE);
  int chunkCount=chunkOffsets.readUnsignedIntToInt();
  stsc.setPosition(Atom.FULL_HEADER_SIZE);
  int remainingSamplesPerChunkChanges=stsc.readUnsignedIntToInt() - 1;
  Assertions.checkState(stsc.readInt() == 1,""String_Node_Str"");
  int samplesPerChunk=stsc.readUnsignedIntToInt();
  stsc.skipBytes(4);
  int nextSamplesPerChunkChangeChunkIndex=-1;
  if (remainingSamplesPerChunkChanges > 0) {
    nextSamplesPerChunkChangeChunkIndex=stsc.readUnsignedIntToInt() - 1;
  }
  int chunkIndex=0;
  int remainingSamplesInChunk=samplesPerChunk;
  stts.setPosition(Atom.FULL_HEADER_SIZE);
  int remainingTimestampDeltaChanges=stts.readUnsignedIntToInt() - 1;
  int remainingSamplesAtTimestampDelta=stts.readUnsignedIntToInt();
  int timestampDeltaInTimeUnits=stts.readUnsignedIntToInt();
  int remainingSamplesAtTimestampOffset=0;
  int remainingTimestampOffsetChanges=0;
  int timestampOffset=0;
  if (ctts != null) {
    ctts.setPosition(Atom.FULL_HEADER_SIZE);
    remainingTimestampOffsetChanges=ctts.readUnsignedIntToInt() - 1;
    remainingSamplesAtTimestampOffset=ctts.readUnsignedIntToInt();
    timestampOffset=ctts.readInt();
  }
  int nextSynchronizationSampleIndex=-1;
  int remainingSynchronizationSamples=0;
  if (stss != null) {
    stss.setPosition(Atom.FULL_HEADER_SIZE);
    remainingSynchronizationSamples=stss.readUnsignedIntToInt();
    nextSynchronizationSampleIndex=stss.readUnsignedIntToInt() - 1;
  }
  long offsetBytes;
  if (chunkOffsetsAtom.type == Atom.TYPE_stco) {
    offsetBytes=chunkOffsets.readUnsignedInt();
  }
 else {
    offsetBytes=chunkOffsets.readUnsignedLongToLong();
  }
  long timestampTimeUnits=0;
  for (int i=0; i < sampleCount; i++) {
    offsets[i]=offsetBytes;
    sizes[i]=fixedSampleSize == 0 ? stsz.readUnsignedIntToInt() : fixedSampleSize;
    if (sizes[i] > maximumSize) {
      maximumSize=sizes[i];
    }
    timestamps[i]=timestampTimeUnits + timestampOffset;
    flags[i]=stss == null ? C.SAMPLE_FLAG_SYNC : 0;
    if (i == nextSynchronizationSampleIndex) {
      flags[i]=C.SAMPLE_FLAG_SYNC;
      remainingSynchronizationSamples--;
      if (remainingSynchronizationSamples > 0) {
        nextSynchronizationSampleIndex=stss.readUnsignedIntToInt() - 1;
      }
    }
    timestampTimeUnits+=timestampDeltaInTimeUnits;
    remainingSamplesAtTimestampDelta--;
    if (remainingSamplesAtTimestampDelta == 0 && remainingTimestampDeltaChanges > 0) {
      remainingSamplesAtTimestampDelta=stts.readUnsignedIntToInt();
      timestampDeltaInTimeUnits=stts.readUnsignedIntToInt();
      remainingTimestampDeltaChanges--;
    }
    if (ctts != null) {
      remainingSamplesAtTimestampOffset--;
      if (remainingSamplesAtTimestampOffset == 0 && remainingTimestampOffsetChanges > 0) {
        remainingSamplesAtTimestampOffset=ctts.readUnsignedIntToInt();
        timestampOffset=ctts.readInt();
        remainingTimestampOffsetChanges--;
      }
    }
    remainingSamplesInChunk--;
    if (remainingSamplesInChunk == 0) {
      chunkIndex++;
      if (chunkIndex < chunkCount) {
        if (chunkOffsetsAtom.type == Atom.TYPE_stco) {
          offsetBytes=chunkOffsets.readUnsignedInt();
        }
 else {
          offsetBytes=chunkOffsets.readUnsignedLongToLong();
        }
      }
      if (chunkIndex == nextSamplesPerChunkChangeChunkIndex) {
        samplesPerChunk=stsc.readUnsignedIntToInt();
        stsc.skipBytes(4);
        remainingSamplesPerChunkChanges--;
        if (remainingSamplesPerChunkChanges > 0) {
          nextSamplesPerChunkChangeChunkIndex=stsc.readUnsignedIntToInt() - 1;
        }
      }
      if (chunkIndex < chunkCount) {
        remainingSamplesInChunk=samplesPerChunk;
      }
    }
 else {
      offsetBytes+=sizes[i];
    }
  }
  Assertions.checkArgument(remainingSynchronizationSamples == 0);
  Assertions.checkArgument(remainingSamplesAtTimestampDelta == 0);
  Assertions.checkArgument(remainingSamplesInChunk == 0);
  Assertions.checkArgument(remainingTimestampDeltaChanges == 0);
  Assertions.checkArgument(remainingTimestampOffsetChanges == 0);
  if (track.editListDurations == null) {
    Util.scaleLargeTimestampsInPlace(timestamps,C.MICROS_PER_SECOND,track.timescale);
    return new TrackSampleTable(offsets,sizes,maximumSize,timestamps,flags);
  }
  if (track.editListDurations.length == 1 && track.editListDurations[0] == 0) {
    for (int i=0; i < timestamps.length; i++) {
      timestamps[i]=Util.scaleLargeTimestamp(timestamps[i] - track.editListMediaTimes[0],C.MICROS_PER_SECOND,track.timescale);
    }
    return new TrackSampleTable(offsets,sizes,maximumSize,timestamps,flags);
  }
  int editedSampleCount=0;
  int nextSampleIndex=0;
  boolean copyMetadata=false;
  for (int i=0; i < track.editListDurations.length; i++) {
    long mediaTime=track.editListMediaTimes[i];
    if (mediaTime != -1) {
      long duration=Util.scaleLargeTimestamp(track.editListDurations[i],track.timescale,track.movieTimescale);
      int startIndex=Util.binarySearchCeil(timestamps,mediaTime,true,true);
      int endIndex=Util.binarySearchCeil(timestamps,mediaTime + duration,true,false);
      editedSampleCount+=endIndex - startIndex;
      copyMetadata|=nextSampleIndex != startIndex;
      nextSampleIndex=endIndex;
    }
  }
  copyMetadata|=editedSampleCount != sampleCount;
  long[] editedOffsets=copyMetadata ? new long[editedSampleCount] : offsets;
  int[] editedSizes=copyMetadata ? new int[editedSampleCount] : sizes;
  int editedMaximumSize=copyMetadata ? 0 : maximumSize;
  int[] editedFlags=copyMetadata ? new int[editedSampleCount] : flags;
  long[] editedTimestamps=new long[editedSampleCount];
  long pts=0;
  int sampleIndex=0;
  for (int i=0; i < track.editListDurations.length; i++) {
    long mediaTime=track.editListMediaTimes[i];
    long duration=track.editListDurations[i];
    if (mediaTime != -1) {
      long endMediaTime=mediaTime + Util.scaleLargeTimestamp(duration,track.timescale,track.movieTimescale);
      int startIndex=Util.binarySearchCeil(timestamps,mediaTime,true,true);
      int endIndex=Util.binarySearchCeil(timestamps,endMediaTime,true,false);
      if (copyMetadata) {
        int count=endIndex - startIndex;
        System.arraycopy(offsets,startIndex,editedOffsets,sampleIndex,count);
        System.arraycopy(sizes,startIndex,editedSizes,sampleIndex,count);
        System.arraycopy(flags,startIndex,editedFlags,sampleIndex,count);
      }
      for (int j=startIndex; j < endIndex; j++) {
        long ptsUs=Util.scaleLargeTimestamp(pts,C.MICROS_PER_SECOND,track.movieTimescale);
        long timeInSegmentUs=Util.scaleLargeTimestamp(timestamps[j] - mediaTime,C.MICROS_PER_SECOND,track.timescale);
        editedTimestamps[sampleIndex]=ptsUs + timeInSegmentUs;
        if (copyMetadata && editedSizes[sampleIndex] > editedMaximumSize) {
          editedMaximumSize=sizes[j];
        }
        sampleIndex++;
      }
    }
    pts+=duration;
  }
  boolean hasSyncSample=false;
  for (int i=0; i < editedFlags.length && !hasSyncSample; i++) {
    hasSyncSample|=(editedFlags[i] & C.SAMPLE_FLAG_SYNC) != 0;
  }
  if (!hasSyncSample) {
    throw new ParserException(""String_Node_Str"");
  }
  return new TrackSampleTable(editedOffsets,editedSizes,editedMaximumSize,editedTimestamps,editedFlags);
}","/** 
 * Parses an stbl atom (defined in 14496-12).
 * @param track Track to which this sample table corresponds.
 * @param stblAtom stbl (sample table) atom to parse.
 * @return Sample table described by the stbl atom.
 * @throws ParserException If the resulting sample sequence does not contain a sync sample.
 */
public static TrackSampleTable parseStbl(Track track,Atom.ContainerAtom stblAtom) throws ParserException {
  ParsableByteArray stsz=stblAtom.getLeafAtomOfType(Atom.TYPE_stsz).data;
  ParsableByteArray chunkOffsets;
  Atom.LeafAtom chunkOffsetsAtom=stblAtom.getLeafAtomOfType(Atom.TYPE_stco);
  if (chunkOffsetsAtom == null) {
    chunkOffsetsAtom=stblAtom.getLeafAtomOfType(Atom.TYPE_co64);
  }
  chunkOffsets=chunkOffsetsAtom.data;
  ParsableByteArray stsc=stblAtom.getLeafAtomOfType(Atom.TYPE_stsc).data;
  ParsableByteArray stts=stblAtom.getLeafAtomOfType(Atom.TYPE_stts).data;
  Atom.LeafAtom stssAtom=stblAtom.getLeafAtomOfType(Atom.TYPE_stss);
  ParsableByteArray stss=stssAtom != null ? stssAtom.data : null;
  Atom.LeafAtom cttsAtom=stblAtom.getLeafAtomOfType(Atom.TYPE_ctts);
  ParsableByteArray ctts=cttsAtom != null ? cttsAtom.data : null;
  stsz.setPosition(Atom.FULL_HEADER_SIZE);
  int fixedSampleSize=stsz.readUnsignedIntToInt();
  int sampleCount=stsz.readUnsignedIntToInt();
  long[] offsets=new long[sampleCount];
  int[] sizes=new int[sampleCount];
  int maximumSize=0;
  long[] timestamps=new long[sampleCount];
  int[] flags=new int[sampleCount];
  if (sampleCount == 0) {
    return new TrackSampleTable(offsets,sizes,maximumSize,timestamps,flags);
  }
  chunkOffsets.setPosition(Atom.FULL_HEADER_SIZE);
  int chunkCount=chunkOffsets.readUnsignedIntToInt();
  stsc.setPosition(Atom.FULL_HEADER_SIZE);
  int remainingSamplesPerChunkChanges=stsc.readUnsignedIntToInt() - 1;
  Assertions.checkState(stsc.readInt() == 1,""String_Node_Str"");
  int samplesPerChunk=stsc.readUnsignedIntToInt();
  stsc.skipBytes(4);
  int nextSamplesPerChunkChangeChunkIndex=-1;
  if (remainingSamplesPerChunkChanges > 0) {
    nextSamplesPerChunkChangeChunkIndex=stsc.readUnsignedIntToInt() - 1;
  }
  int chunkIndex=0;
  int remainingSamplesInChunk=samplesPerChunk;
  stts.setPosition(Atom.FULL_HEADER_SIZE);
  int remainingTimestampDeltaChanges=stts.readUnsignedIntToInt() - 1;
  int remainingSamplesAtTimestampDelta=stts.readUnsignedIntToInt();
  int timestampDeltaInTimeUnits=stts.readUnsignedIntToInt();
  int remainingSamplesAtTimestampOffset=0;
  int remainingTimestampOffsetChanges=0;
  int timestampOffset=0;
  if (ctts != null) {
    ctts.setPosition(Atom.FULL_HEADER_SIZE);
    remainingTimestampOffsetChanges=ctts.readUnsignedIntToInt();
  }
  int nextSynchronizationSampleIndex=-1;
  int remainingSynchronizationSamples=0;
  if (stss != null) {
    stss.setPosition(Atom.FULL_HEADER_SIZE);
    remainingSynchronizationSamples=stss.readUnsignedIntToInt();
    nextSynchronizationSampleIndex=stss.readUnsignedIntToInt() - 1;
  }
  long offsetBytes;
  if (chunkOffsetsAtom.type == Atom.TYPE_stco) {
    offsetBytes=chunkOffsets.readUnsignedInt();
  }
 else {
    offsetBytes=chunkOffsets.readUnsignedLongToLong();
  }
  long timestampTimeUnits=0;
  for (int i=0; i < sampleCount; i++) {
    if (ctts != null) {
      while (remainingSamplesAtTimestampOffset == 0 && remainingTimestampOffsetChanges > 0) {
        remainingSamplesAtTimestampOffset=ctts.readUnsignedIntToInt();
        timestampOffset=ctts.readInt();
        remainingTimestampOffsetChanges--;
      }
      remainingSamplesAtTimestampOffset--;
    }
    offsets[i]=offsetBytes;
    sizes[i]=fixedSampleSize == 0 ? stsz.readUnsignedIntToInt() : fixedSampleSize;
    if (sizes[i] > maximumSize) {
      maximumSize=sizes[i];
    }
    timestamps[i]=timestampTimeUnits + timestampOffset;
    flags[i]=stss == null ? C.SAMPLE_FLAG_SYNC : 0;
    if (i == nextSynchronizationSampleIndex) {
      flags[i]=C.SAMPLE_FLAG_SYNC;
      remainingSynchronizationSamples--;
      if (remainingSynchronizationSamples > 0) {
        nextSynchronizationSampleIndex=stss.readUnsignedIntToInt() - 1;
      }
    }
    timestampTimeUnits+=timestampDeltaInTimeUnits;
    remainingSamplesAtTimestampDelta--;
    if (remainingSamplesAtTimestampDelta == 0 && remainingTimestampDeltaChanges > 0) {
      remainingSamplesAtTimestampDelta=stts.readUnsignedIntToInt();
      timestampDeltaInTimeUnits=stts.readUnsignedIntToInt();
      remainingTimestampDeltaChanges--;
    }
    remainingSamplesInChunk--;
    if (remainingSamplesInChunk == 0) {
      chunkIndex++;
      if (chunkIndex < chunkCount) {
        if (chunkOffsetsAtom.type == Atom.TYPE_stco) {
          offsetBytes=chunkOffsets.readUnsignedInt();
        }
 else {
          offsetBytes=chunkOffsets.readUnsignedLongToLong();
        }
      }
      if (chunkIndex == nextSamplesPerChunkChangeChunkIndex) {
        samplesPerChunk=stsc.readUnsignedIntToInt();
        stsc.skipBytes(4);
        remainingSamplesPerChunkChanges--;
        if (remainingSamplesPerChunkChanges > 0) {
          nextSamplesPerChunkChangeChunkIndex=stsc.readUnsignedIntToInt() - 1;
        }
      }
      if (chunkIndex < chunkCount) {
        remainingSamplesInChunk=samplesPerChunk;
      }
    }
 else {
      offsetBytes+=sizes[i];
    }
  }
  Assertions.checkArgument(remainingSynchronizationSamples == 0);
  Assertions.checkArgument(remainingSamplesAtTimestampDelta == 0);
  Assertions.checkArgument(remainingSamplesInChunk == 0);
  Assertions.checkArgument(remainingTimestampDeltaChanges == 0);
  Assertions.checkArgument(remainingTimestampOffsetChanges == 0);
  if (track.editListDurations == null) {
    Util.scaleLargeTimestampsInPlace(timestamps,C.MICROS_PER_SECOND,track.timescale);
    return new TrackSampleTable(offsets,sizes,maximumSize,timestamps,flags);
  }
  if (track.editListDurations.length == 1 && track.editListDurations[0] == 0) {
    for (int i=0; i < timestamps.length; i++) {
      timestamps[i]=Util.scaleLargeTimestamp(timestamps[i] - track.editListMediaTimes[0],C.MICROS_PER_SECOND,track.timescale);
    }
    return new TrackSampleTable(offsets,sizes,maximumSize,timestamps,flags);
  }
  int editedSampleCount=0;
  int nextSampleIndex=0;
  boolean copyMetadata=false;
  for (int i=0; i < track.editListDurations.length; i++) {
    long mediaTime=track.editListMediaTimes[i];
    if (mediaTime != -1) {
      long duration=Util.scaleLargeTimestamp(track.editListDurations[i],track.timescale,track.movieTimescale);
      int startIndex=Util.binarySearchCeil(timestamps,mediaTime,true,true);
      int endIndex=Util.binarySearchCeil(timestamps,mediaTime + duration,true,false);
      editedSampleCount+=endIndex - startIndex;
      copyMetadata|=nextSampleIndex != startIndex;
      nextSampleIndex=endIndex;
    }
  }
  copyMetadata|=editedSampleCount != sampleCount;
  long[] editedOffsets=copyMetadata ? new long[editedSampleCount] : offsets;
  int[] editedSizes=copyMetadata ? new int[editedSampleCount] : sizes;
  int editedMaximumSize=copyMetadata ? 0 : maximumSize;
  int[] editedFlags=copyMetadata ? new int[editedSampleCount] : flags;
  long[] editedTimestamps=new long[editedSampleCount];
  long pts=0;
  int sampleIndex=0;
  for (int i=0; i < track.editListDurations.length; i++) {
    long mediaTime=track.editListMediaTimes[i];
    long duration=track.editListDurations[i];
    if (mediaTime != -1) {
      long endMediaTime=mediaTime + Util.scaleLargeTimestamp(duration,track.timescale,track.movieTimescale);
      int startIndex=Util.binarySearchCeil(timestamps,mediaTime,true,true);
      int endIndex=Util.binarySearchCeil(timestamps,endMediaTime,true,false);
      if (copyMetadata) {
        int count=endIndex - startIndex;
        System.arraycopy(offsets,startIndex,editedOffsets,sampleIndex,count);
        System.arraycopy(sizes,startIndex,editedSizes,sampleIndex,count);
        System.arraycopy(flags,startIndex,editedFlags,sampleIndex,count);
      }
      for (int j=startIndex; j < endIndex; j++) {
        long ptsUs=Util.scaleLargeTimestamp(pts,C.MICROS_PER_SECOND,track.movieTimescale);
        long timeInSegmentUs=Util.scaleLargeTimestamp(timestamps[j] - mediaTime,C.MICROS_PER_SECOND,track.timescale);
        editedTimestamps[sampleIndex]=ptsUs + timeInSegmentUs;
        if (copyMetadata && editedSizes[sampleIndex] > editedMaximumSize) {
          editedMaximumSize=sizes[j];
        }
        sampleIndex++;
      }
    }
    pts+=duration;
  }
  boolean hasSyncSample=false;
  for (int i=0; i < editedFlags.length && !hasSyncSample; i++) {
    hasSyncSample|=(editedFlags[i] & C.SAMPLE_FLAG_SYNC) != 0;
  }
  if (!hasSyncSample) {
    throw new ParserException(""String_Node_Str"");
  }
  return new TrackSampleTable(editedOffsets,editedSizes,editedMaximumSize,editedTimestamps,editedFlags);
}",0.9567929235654344
110401,"private boolean readAtomHeader(ExtractorInput input) throws IOException, InterruptedException {
  if (atomHeaderBytesRead == 0) {
    if (!input.readFully(atomHeader.data,0,Atom.HEADER_SIZE,true)) {
      return false;
    }
    atomHeaderBytesRead=Atom.HEADER_SIZE;
    atomHeader.setPosition(0);
    atomSize=atomHeader.readUnsignedInt();
    atomType=atomHeader.readInt();
  }
  if (atomSize == Atom.LONG_SIZE_PREFIX) {
    int headerBytesRemaining=Atom.LONG_HEADER_SIZE - Atom.HEADER_SIZE;
    input.readFully(atomHeader.data,Atom.HEADER_SIZE,headerBytesRemaining);
    atomHeaderBytesRead+=headerBytesRemaining;
    atomSize=atomHeader.readUnsignedLongToLong();
  }
  long atomPosition=input.getPosition() - atomHeaderBytesRead;
  if (atomType == Atom.TYPE_moof) {
    int trackCount=trackBundles.size();
    for (int i=0; i < trackCount; i++) {
      TrackFragment fragment=trackBundles.valueAt(i).fragment;
      fragment.auxiliaryDataPosition=atomPosition;
      fragment.dataPosition=atomPosition;
    }
  }
  if (atomType == Atom.TYPE_mdat) {
    currentTrackBundle=null;
    endOfMdatPosition=atomPosition + atomSize;
    if (!haveOutputSeekMap) {
      extractorOutput.seekMap(new SeekMap.Unseekable(durationUs));
      haveOutputSeekMap=true;
    }
    parserState=STATE_READING_ENCRYPTION_DATA;
    return true;
  }
  if (shouldParseContainerAtom(atomType)) {
    long endPosition=input.getPosition() + atomSize - Atom.HEADER_SIZE;
    containerAtoms.add(new ContainerAtom(atomType,endPosition));
    enterReadingAtomHeaderState();
  }
 else   if (shouldParseLeafAtom(atomType)) {
    if (atomHeaderBytesRead != Atom.HEADER_SIZE) {
      throw new ParserException(""String_Node_Str"");
    }
    if (atomSize > Integer.MAX_VALUE) {
      throw new ParserException(""String_Node_Str"");
    }
    atomData=new ParsableByteArray((int)atomSize);
    System.arraycopy(atomHeader.data,0,atomData.data,0,Atom.HEADER_SIZE);
    parserState=STATE_READING_ATOM_PAYLOAD;
  }
 else {
    if (atomSize > Integer.MAX_VALUE) {
      throw new ParserException(""String_Node_Str"");
    }
    atomData=null;
    parserState=STATE_READING_ATOM_PAYLOAD;
  }
  return true;
}","private boolean readAtomHeader(ExtractorInput input) throws IOException, InterruptedException {
  if (atomHeaderBytesRead == 0) {
    if (!input.readFully(atomHeader.data,0,Atom.HEADER_SIZE,true)) {
      return false;
    }
    atomHeaderBytesRead=Atom.HEADER_SIZE;
    atomHeader.setPosition(0);
    atomSize=atomHeader.readUnsignedInt();
    atomType=atomHeader.readInt();
  }
  if (atomSize == Atom.LONG_SIZE_PREFIX) {
    int headerBytesRemaining=Atom.LONG_HEADER_SIZE - Atom.HEADER_SIZE;
    input.readFully(atomHeader.data,Atom.HEADER_SIZE,headerBytesRemaining);
    atomHeaderBytesRead+=headerBytesRemaining;
    atomSize=atomHeader.readUnsignedLongToLong();
  }
  long atomPosition=input.getPosition() - atomHeaderBytesRead;
  if (atomType == Atom.TYPE_moof) {
    int trackCount=trackBundles.size();
    for (int i=0; i < trackCount; i++) {
      TrackFragment fragment=trackBundles.valueAt(i).fragment;
      fragment.auxiliaryDataPosition=atomPosition;
      fragment.dataPosition=atomPosition;
    }
  }
  if (atomType == Atom.TYPE_mdat) {
    currentTrackBundle=null;
    endOfMdatPosition=atomPosition + atomSize;
    if (!haveOutputSeekMap) {
      extractorOutput.seekMap(new SeekMap.Unseekable(durationUs));
      haveOutputSeekMap=true;
    }
    parserState=STATE_READING_ENCRYPTION_DATA;
    return true;
  }
  if (shouldParseContainerAtom(atomType)) {
    long endPosition=input.getPosition() + atomSize - Atom.HEADER_SIZE;
    containerAtoms.add(new ContainerAtom(atomType,endPosition));
    if (atomSize == atomHeaderBytesRead) {
      processAtomEnded(endPosition);
    }
 else {
      enterReadingAtomHeaderState();
    }
  }
 else   if (shouldParseLeafAtom(atomType)) {
    if (atomHeaderBytesRead != Atom.HEADER_SIZE) {
      throw new ParserException(""String_Node_Str"");
    }
    if (atomSize > Integer.MAX_VALUE) {
      throw new ParserException(""String_Node_Str"");
    }
    atomData=new ParsableByteArray((int)atomSize);
    System.arraycopy(atomHeader.data,0,atomData.data,0,Atom.HEADER_SIZE);
    parserState=STATE_READING_ATOM_PAYLOAD;
  }
 else {
    if (atomSize > Integer.MAX_VALUE) {
      throw new ParserException(""String_Node_Str"");
    }
    atomData=null;
    parserState=STATE_READING_ATOM_PAYLOAD;
  }
  return true;
}",0.9747178329571106
110402,"private void readAtomPayload(ExtractorInput input) throws IOException, InterruptedException {
  int atomPayloadSize=(int)atomSize - atomHeaderBytesRead;
  if (atomData != null) {
    input.readFully(atomData.data,Atom.HEADER_SIZE,atomPayloadSize);
    onLeafAtomRead(new LeafAtom(atomType,atomData),input.getPosition());
  }
 else {
    input.skipFully(atomPayloadSize);
  }
  long currentPosition=input.getPosition();
  while (!containerAtoms.isEmpty() && containerAtoms.peek().endPosition == currentPosition) {
    onContainerAtomRead(containerAtoms.pop());
  }
  enterReadingAtomHeaderState();
}","private void readAtomPayload(ExtractorInput input) throws IOException, InterruptedException {
  int atomPayloadSize=(int)atomSize - atomHeaderBytesRead;
  if (atomData != null) {
    input.readFully(atomData.data,Atom.HEADER_SIZE,atomPayloadSize);
    onLeafAtomRead(new LeafAtom(atomType,atomData),input.getPosition());
  }
 else {
    input.skipFully(atomPayloadSize);
  }
  processAtomEnded(input.getPosition());
}",0.7527093596059113
110403,"private boolean readAtomHeader(ExtractorInput input) throws IOException, InterruptedException {
  if (atomHeaderBytesRead == 0) {
    if (!input.readFully(atomHeader.data,0,Atom.HEADER_SIZE,true)) {
      return false;
    }
    atomHeaderBytesRead=Atom.HEADER_SIZE;
    atomHeader.setPosition(0);
    atomSize=atomHeader.readUnsignedInt();
    atomType=atomHeader.readInt();
  }
  if (atomSize == Atom.LONG_SIZE_PREFIX) {
    int headerBytesRemaining=Atom.LONG_HEADER_SIZE - Atom.HEADER_SIZE;
    input.readFully(atomHeader.data,Atom.HEADER_SIZE,headerBytesRemaining);
    atomHeaderBytesRead+=headerBytesRemaining;
    atomSize=atomHeader.readUnsignedLongToLong();
  }
  if (shouldParseContainerAtom(atomType)) {
    long endPosition=input.getPosition() + atomSize - atomHeaderBytesRead;
    containerAtoms.add(new ContainerAtom(atomType,endPosition));
    enterReadingAtomHeaderState();
  }
 else   if (shouldParseLeafAtom(atomType)) {
    Assertions.checkState(atomHeaderBytesRead == Atom.HEADER_SIZE);
    Assertions.checkState(atomSize <= Integer.MAX_VALUE);
    atomData=new ParsableByteArray((int)atomSize);
    System.arraycopy(atomHeader.data,0,atomData.data,0,Atom.HEADER_SIZE);
    parserState=STATE_READING_ATOM_PAYLOAD;
  }
 else {
    atomData=null;
    parserState=STATE_READING_ATOM_PAYLOAD;
  }
  return true;
}","private boolean readAtomHeader(ExtractorInput input) throws IOException, InterruptedException {
  if (atomHeaderBytesRead == 0) {
    if (!input.readFully(atomHeader.data,0,Atom.HEADER_SIZE,true)) {
      return false;
    }
    atomHeaderBytesRead=Atom.HEADER_SIZE;
    atomHeader.setPosition(0);
    atomSize=atomHeader.readUnsignedInt();
    atomType=atomHeader.readInt();
  }
  if (atomSize == Atom.LONG_SIZE_PREFIX) {
    int headerBytesRemaining=Atom.LONG_HEADER_SIZE - Atom.HEADER_SIZE;
    input.readFully(atomHeader.data,Atom.HEADER_SIZE,headerBytesRemaining);
    atomHeaderBytesRead+=headerBytesRemaining;
    atomSize=atomHeader.readUnsignedLongToLong();
  }
  if (shouldParseContainerAtom(atomType)) {
    long endPosition=input.getPosition() + atomSize - atomHeaderBytesRead;
    containerAtoms.add(new ContainerAtom(atomType,endPosition));
    if (atomSize == atomHeaderBytesRead) {
      processAtomEnded(endPosition);
    }
 else {
      enterReadingAtomHeaderState();
    }
  }
 else   if (shouldParseLeafAtom(atomType)) {
    Assertions.checkState(atomHeaderBytesRead == Atom.HEADER_SIZE);
    Assertions.checkState(atomSize <= Integer.MAX_VALUE);
    atomData=new ParsableByteArray((int)atomSize);
    System.arraycopy(atomHeader.data,0,atomData.data,0,Atom.HEADER_SIZE);
    parserState=STATE_READING_ATOM_PAYLOAD;
  }
 else {
    atomData=null;
    parserState=STATE_READING_ATOM_PAYLOAD;
  }
  return true;
}",0.9630434782608696
110404,"/** 
 * Processes the atom payload. If   {@link #atomData} is null and the size is at or above thethreshold  {@link #RELOAD_MINIMUM_SEEK_DISTANCE},   {@code true} is returned and the caller shouldrestart loading at the position in  {@code positionHolder}. Otherwise, the atom is read/skipped.
 */
private boolean readAtomPayload(ExtractorInput input,PositionHolder positionHolder) throws IOException, InterruptedException {
  long atomPayloadSize=atomSize - atomHeaderBytesRead;
  long atomEndPosition=input.getPosition() + atomPayloadSize;
  boolean seekRequired=false;
  if (atomData != null) {
    input.readFully(atomData.data,atomHeaderBytesRead,(int)atomPayloadSize);
    if (atomType == Atom.TYPE_ftyp) {
      isQuickTime=processFtypAtom(atomData);
    }
 else     if (!containerAtoms.isEmpty()) {
      containerAtoms.peek().add(new Atom.LeafAtom(atomType,atomData));
    }
  }
 else {
    if (atomPayloadSize < RELOAD_MINIMUM_SEEK_DISTANCE) {
      input.skipFully((int)atomPayloadSize);
    }
 else {
      positionHolder.position=input.getPosition() + atomPayloadSize;
      seekRequired=true;
    }
  }
  while (!containerAtoms.isEmpty() && containerAtoms.peek().endPosition == atomEndPosition) {
    Atom.ContainerAtom containerAtom=containerAtoms.pop();
    if (containerAtom.type == Atom.TYPE_moov) {
      processMoovAtom(containerAtom);
      containerAtoms.clear();
      parserState=STATE_READING_SAMPLE;
      return false;
    }
 else     if (!containerAtoms.isEmpty()) {
      containerAtoms.peek().add(containerAtom);
    }
  }
  enterReadingAtomHeaderState();
  return seekRequired;
}","/** 
 * Processes the atom payload. If   {@link #atomData} is null and the size is at or above thethreshold  {@link #RELOAD_MINIMUM_SEEK_DISTANCE},   {@code true} is returned and the caller shouldrestart loading at the position in  {@code positionHolder}. Otherwise, the atom is read/skipped.
 */
private boolean readAtomPayload(ExtractorInput input,PositionHolder positionHolder) throws IOException, InterruptedException {
  long atomPayloadSize=atomSize - atomHeaderBytesRead;
  long atomEndPosition=input.getPosition() + atomPayloadSize;
  boolean seekRequired=false;
  if (atomData != null) {
    input.readFully(atomData.data,atomHeaderBytesRead,(int)atomPayloadSize);
    if (atomType == Atom.TYPE_ftyp) {
      isQuickTime=processFtypAtom(atomData);
    }
 else     if (!containerAtoms.isEmpty()) {
      containerAtoms.peek().add(new Atom.LeafAtom(atomType,atomData));
    }
  }
 else {
    if (atomPayloadSize < RELOAD_MINIMUM_SEEK_DISTANCE) {
      input.skipFully((int)atomPayloadSize);
    }
 else {
      positionHolder.position=input.getPosition() + atomPayloadSize;
      seekRequired=true;
    }
  }
  processAtomEnded(atomEndPosition);
  return seekRequired && parserState != STATE_READING_SAMPLE;
}",0.8120353982300885
110405,"@Override public void seekToUs(long positionUs){
  if (state == STATE_END_OF_STREAM) {
    state=STATE_SEND_SAMPLE;
  }
}","@Override public void seekToUs(long positionUs){
  if (state == STATE_END_OF_STREAM) {
    pendingResetPositionUs=positionUs;
    state=STATE_SEND_SAMPLE;
  }
}",0.8612099644128114
110406,"@Override public TrackStream enable(TrackSelection selection,long positionUs){
  state=STATE_SEND_FORMAT;
  clearCurrentLoadableException();
  maybeStartLoading();
  return this;
}","@Override public TrackStream enable(TrackSelection selection,long positionUs){
  state=STATE_SEND_FORMAT;
  pendingResetPositionUs=NO_RESET;
  clearCurrentLoadableException();
  maybeStartLoading();
  return this;
}",0.9113924050632912
110407,"@Override public long readReset(){
  return TrackStream.NO_RESET;
}","@Override public long readReset(){
  long resetPositionUs=pendingResetPositionUs;
  pendingResetPositionUs=NO_RESET;
  return resetPositionUs;
}",0.5118483412322274
110408,"private boolean synchronize(ExtractorInput input,boolean sniffing) throws IOException, InterruptedException {
  int searched=0;
  int validFrameCount=0;
  int candidateSynchronizedHeaderData=0;
  int peekedId3Bytes=0;
  input.resetPeekPosition();
  if (input.getPosition() == 0) {
    gaplessInfo=Id3Util.parseId3(input);
    peekedId3Bytes=(int)input.getPeekPosition();
  }
  while (true) {
    if (sniffing && searched == MAX_SNIFF_BYTES) {
      return false;
    }
    if (!sniffing && searched == MAX_SYNC_BYTES) {
      throw new ParserException(""String_Node_Str"");
    }
    if (!input.peekFully(scratch.data,0,4,true)) {
      return false;
    }
    scratch.setPosition(0);
    int headerData=scratch.readInt();
    int frameSize;
    if ((candidateSynchronizedHeaderData != 0 && (headerData & HEADER_MASK) != (candidateSynchronizedHeaderData & HEADER_MASK)) || (frameSize=MpegAudioHeader.getFrameSize(headerData)) == -1) {
      validFrameCount=0;
      candidateSynchronizedHeaderData=0;
      searched++;
      if (sniffing) {
        input.resetPeekPosition();
        input.advancePeekPosition(peekedId3Bytes + searched);
      }
 else {
        input.skipFully(1);
      }
    }
 else {
      validFrameCount++;
      if (validFrameCount == 1) {
        MpegAudioHeader.populateHeader(headerData,synchronizedHeader);
        candidateSynchronizedHeaderData=headerData;
      }
 else       if (validFrameCount == 4) {
        break;
      }
      input.advancePeekPosition(frameSize - 4);
    }
  }
  if (sniffing) {
    input.skipFully(peekedId3Bytes + searched);
  }
 else {
    input.resetPeekPosition();
  }
  synchronizedHeaderData=candidateSynchronizedHeaderData;
  return true;
}","private boolean synchronize(ExtractorInput input,boolean sniffing) throws IOException, InterruptedException {
  int searched=0;
  int validFrameCount=0;
  int candidateSynchronizedHeaderData=0;
  int peekedId3Bytes=0;
  input.resetPeekPosition();
  if (input.getPosition() == 0) {
    gaplessInfo=Id3Util.parseId3(input);
    peekedId3Bytes=(int)input.getPeekPosition();
    if (!sniffing) {
      input.skipFully(peekedId3Bytes);
    }
  }
  while (true) {
    if (sniffing && searched == MAX_SNIFF_BYTES) {
      return false;
    }
    if (!sniffing && searched == MAX_SYNC_BYTES) {
      throw new ParserException(""String_Node_Str"");
    }
    if (!input.peekFully(scratch.data,0,4,true)) {
      return false;
    }
    scratch.setPosition(0);
    int headerData=scratch.readInt();
    int frameSize;
    if ((candidateSynchronizedHeaderData != 0 && (headerData & HEADER_MASK) != (candidateSynchronizedHeaderData & HEADER_MASK)) || (frameSize=MpegAudioHeader.getFrameSize(headerData)) == -1) {
      validFrameCount=0;
      candidateSynchronizedHeaderData=0;
      searched++;
      if (sniffing) {
        input.resetPeekPosition();
        input.advancePeekPosition(peekedId3Bytes + searched);
      }
 else {
        input.skipFully(1);
      }
    }
 else {
      validFrameCount++;
      if (validFrameCount == 1) {
        MpegAudioHeader.populateHeader(headerData,synchronizedHeader);
        candidateSynchronizedHeaderData=headerData;
      }
 else       if (validFrameCount == 4) {
        break;
      }
      input.advancePeekPosition(frameSize - 4);
    }
  }
  if (sniffing) {
    input.skipFully(peekedId3Bytes + searched);
  }
 else {
    input.resetPeekPosition();
  }
  synchronizedHeaderData=candidateSynchronizedHeaderData;
  return true;
}",0.9809578765147144
110409,"@Override protected void parsePayload(ParsableByteArray data,long timeUs){
  int packetType=data.readUnsignedByte();
  if (packetType == AAC_PACKET_TYPE_SEQUENCE_HEADER && !hasOutputFormat) {
    ParsableBitArray adtsScratch=new ParsableBitArray(new byte[data.bytesLeft()]);
    data.readBytes(adtsScratch.data,0,data.bytesLeft());
    int audioObjectType=adtsScratch.readBits(5);
    int sampleRateIndex=adtsScratch.readBits(4);
    int channelConfig=adtsScratch.readBits(4);
    byte[] audioSpecificConfig=CodecSpecificDataUtil.buildAacAudioSpecificConfig(audioObjectType,sampleRateIndex,channelConfig);
    Pair<Integer,Integer> audioParams=CodecSpecificDataUtil.parseAacAudioSpecificConfig(audioSpecificConfig);
    MediaFormat mediaFormat=MediaFormat.createAudioFormat(null,MimeTypes.AUDIO_AAC,MediaFormat.NO_VALUE,MediaFormat.NO_VALUE,getDurationUs(),audioParams.second,audioParams.first,Collections.singletonList(audioSpecificConfig),null);
    output.format(mediaFormat);
    hasOutputFormat=true;
  }
 else   if (packetType == AAC_PACKET_TYPE_AAC_RAW) {
    int bytesToWrite=data.bytesLeft();
    output.sampleData(data,bytesToWrite);
    output.sampleMetadata(timeUs,C.SAMPLE_FLAG_SYNC,bytesToWrite,0,null);
  }
}","@Override protected void parsePayload(ParsableByteArray data,long timeUs){
  int packetType=data.readUnsignedByte();
  if (packetType == AAC_PACKET_TYPE_SEQUENCE_HEADER && !hasOutputFormat) {
    byte[] audioSpecifiConfig=new byte[data.bytesLeft()];
    data.readBytes(audioSpecifiConfig,0,audioSpecifiConfig.length);
    Pair<Integer,Integer> audioParams=CodecSpecificDataUtil.parseAacAudioSpecificConfig(audioSpecifiConfig);
    MediaFormat mediaFormat=MediaFormat.createAudioFormat(null,MimeTypes.AUDIO_AAC,MediaFormat.NO_VALUE,MediaFormat.NO_VALUE,getDurationUs(),audioParams.second,audioParams.first,Collections.singletonList(audioSpecifiConfig),null);
    output.format(mediaFormat);
    hasOutputFormat=true;
  }
 else   if (packetType == AAC_PACKET_TYPE_AAC_RAW) {
    int bytesToWrite=data.bytesLeft();
    output.sampleData(data,bytesToWrite);
    output.sampleMetadata(timeUs,C.SAMPLE_FLAG_SYNC,bytesToWrite,0,null);
  }
}",0.7968460111317254
110410,"@Override protected void parsePayload(ParsableByteArray data,long timeUs) throws ParserException {
  int nameType=readAmfType(data);
  if (nameType != AMF_TYPE_STRING) {
    throw new ParserException();
  }
  String name=readAmfString(data);
  if (!NAME_METADATA.equals(name)) {
    return;
  }
  int type=readAmfType(data);
  if (type != AMF_TYPE_ECMA_ARRAY) {
    throw new ParserException();
  }
  Map<String,Object> metadata=readAmfEcmaArray(data);
  if (metadata.containsKey(KEY_DURATION)) {
    double durationSeconds=(double)metadata.get(KEY_DURATION);
    setDurationUs((long)(durationSeconds * C.MICROS_PER_SECOND));
  }
}","@Override protected void parsePayload(ParsableByteArray data,long timeUs) throws ParserException {
  int nameType=readAmfType(data);
  if (nameType != AMF_TYPE_STRING) {
    throw new ParserException();
  }
  String name=readAmfString(data);
  if (!NAME_METADATA.equals(name)) {
    return;
  }
  int type=readAmfType(data);
  if (type != AMF_TYPE_ECMA_ARRAY) {
    throw new ParserException();
  }
  Map<String,Object> metadata=readAmfEcmaArray(data);
  if (metadata.containsKey(KEY_DURATION)) {
    double durationSeconds=(double)metadata.get(KEY_DURATION);
    if (durationSeconds > 0.0) {
      setDurationUs((long)(durationSeconds * C.MICROS_PER_SECOND));
    }
  }
}",0.9685341519570224
110411,"@Override public void onResume(){
  super.onResume();
  Intent intent=getIntent();
  contentUri=intent.getData();
  contentType=intent.getIntExtra(CONTENT_TYPE_EXTRA,inferContentType(contentUri,intent.getStringExtra(CONTENT_EXT_EXTRA)));
  contentId=intent.getStringExtra(CONTENT_ID_EXTRA);
  provider=intent.getStringExtra(PROVIDER_EXTRA);
  configureSubtitleView();
  if (player == null) {
    preparePlayer(true);
  }
 else {
    player.setBackgrounded(false);
  }
}","@Override public void onResume(){
  super.onResume();
  Intent intent=getIntent();
  contentUri=intent.getData();
  contentType=intent.getIntExtra(CONTENT_TYPE_EXTRA,inferContentType(contentUri,intent.getStringExtra(CONTENT_EXT_EXTRA)));
  contentId=intent.getStringExtra(CONTENT_ID_EXTRA);
  provider=intent.getStringExtra(PROVIDER_EXTRA);
  configureSubtitleView();
  if (player == null) {
    if (!maybeRequestPermission()) {
      preparePlayer(true);
    }
  }
 else {
    player.setBackgrounded(false);
  }
}",0.9399796541200408
110412,"@Override protected void parsePayload(ParsableByteArray data,long timeUs){
  int packetType=data.readUnsignedByte();
  if (packetType == AAC_PACKET_TYPE_SEQUENCE_HEADER && !hasOutputFormat) {
    ParsableBitArray adtsScratch=new ParsableBitArray(new byte[data.bytesLeft()]);
    data.readBytes(adtsScratch.data,0,data.bytesLeft());
    int audioObjectType=adtsScratch.readBits(5);
    int sampleRateIndex=adtsScratch.readBits(4);
    int channelConfig=adtsScratch.readBits(4);
    byte[] audioSpecificConfig=CodecSpecificDataUtil.buildAacAudioSpecificConfig(audioObjectType,sampleRateIndex,channelConfig);
    Pair<Integer,Integer> audioParams=CodecSpecificDataUtil.parseAacAudioSpecificConfig(audioSpecificConfig);
    MediaFormat mediaFormat=MediaFormat.createAudioFormat(MimeTypes.AUDIO_AAC,MediaFormat.NO_VALUE,MediaFormat.NO_VALUE,durationUs,audioParams.second,audioParams.first,Collections.singletonList(audioSpecificConfig),null);
    output.format(mediaFormat);
    hasOutputFormat=true;
  }
 else   if (packetType == AAC_PACKET_TYPE_AAC_RAW) {
    int bytesToWrite=data.bytesLeft();
    output.sampleData(data,bytesToWrite);
    output.sampleMetadata(timeUs,C.SAMPLE_FLAG_SYNC,bytesToWrite,0,null);
  }
}","@Override protected void parsePayload(ParsableByteArray data,long timeUs){
  int packetType=data.readUnsignedByte();
  if (packetType == AAC_PACKET_TYPE_SEQUENCE_HEADER && !hasOutputFormat) {
    ParsableBitArray adtsScratch=new ParsableBitArray(new byte[data.bytesLeft()]);
    data.readBytes(adtsScratch.data,0,data.bytesLeft());
    int audioObjectType=adtsScratch.readBits(5);
    int sampleRateIndex=adtsScratch.readBits(4);
    int channelConfig=adtsScratch.readBits(4);
    byte[] audioSpecificConfig=CodecSpecificDataUtil.buildAacAudioSpecificConfig(audioObjectType,sampleRateIndex,channelConfig);
    Pair<Integer,Integer> audioParams=CodecSpecificDataUtil.parseAacAudioSpecificConfig(audioSpecificConfig);
    MediaFormat mediaFormat=MediaFormat.createAudioFormat(MediaFormat.NO_VALUE,MimeTypes.AUDIO_AAC,MediaFormat.NO_VALUE,MediaFormat.NO_VALUE,durationUs,audioParams.second,audioParams.first,Collections.singletonList(audioSpecificConfig),null);
    output.format(mediaFormat);
    hasOutputFormat=true;
  }
 else   if (packetType == AAC_PACKET_TYPE_AAC_RAW) {
    int bytesToWrite=data.bytesLeft();
    output.sampleData(data,bytesToWrite);
    output.sampleMetadata(timeUs,C.SAMPLE_FLAG_SYNC,bytesToWrite,0,null);
  }
}",0.9914180629342052
110413,"@Override protected void parsePayload(ParsableByteArray data,long timeUs){
  int packetType=data.readUnsignedByte();
  int compositionTime=data.readUnsignedInt24();
  if (compositionTime > 0) {
    timeUs+=compositionTime * 1000;
  }
  if (packetType == AVC_PACKET_TYPE_SEQUENCE_HEADER && !hasOutputFormat) {
    ParsableByteArray videoSequence=new ParsableByteArray(new byte[data.bytesLeft()]);
    data.readBytes(videoSequence.data,0,data.bytesLeft());
    AvcSequenceHeaderData avcData;
    try {
      avcData=parseAvcCodecPrivate(videoSequence);
      nalUnitsLength=avcData.nalUnitLengthFieldLength;
    }
 catch (    ParserException e) {
      e.printStackTrace();
      return;
    }
    MediaFormat mediaFormat=MediaFormat.createVideoFormat(MimeTypes.VIDEO_H264,MediaFormat.NO_VALUE,MediaFormat.NO_VALUE,durationUs,avcData.width,avcData.height,avcData.initializationData,MediaFormat.NO_VALUE,avcData.pixelWidthAspectRatio);
    output.format(mediaFormat);
    hasOutputFormat=true;
  }
 else   if (packetType == AVC_PACKET_TYPE_AVC_NALU) {
    byte[] nalLengthData=nalLength.data;
    nalLengthData[0]=0;
    nalLengthData[1]=0;
    nalLengthData[2]=0;
    int nalUnitLengthFieldLength=nalUnitsLength;
    int nalUnitLengthFieldLengthDiff=4 - nalUnitsLength;
    int bytesWritten=0;
    int bytesToWrite;
    while (data.bytesLeft() > 0) {
      data.readBytes(nalLength.data,nalUnitLengthFieldLengthDiff,nalUnitLengthFieldLength);
      nalLength.setPosition(0);
      bytesToWrite=nalLength.readUnsignedIntToInt();
      nalStartCode.setPosition(0);
      output.sampleData(nalStartCode,4);
      bytesWritten+=4;
      output.sampleData(data,bytesToWrite);
      bytesWritten+=bytesToWrite;
    }
    output.sampleMetadata(timeUs,frameType == VIDEO_FRAME_KEYFRAME ? C.SAMPLE_FLAG_SYNC : 0,bytesWritten,0,null);
  }
 else   if (packetType == AVC_PACKET_TYPE_AVC_END_OF_SEQUENCE) {
    Log.d(TAG,""String_Node_Str"");
  }
}","@Override protected void parsePayload(ParsableByteArray data,long timeUs){
  int packetType=data.readUnsignedByte();
  int compositionTime=data.readUnsignedInt24();
  if (compositionTime > 0) {
    timeUs+=compositionTime * 1000;
  }
  if (packetType == AVC_PACKET_TYPE_SEQUENCE_HEADER && !hasOutputFormat) {
    ParsableByteArray videoSequence=new ParsableByteArray(new byte[data.bytesLeft()]);
    data.readBytes(videoSequence.data,0,data.bytesLeft());
    AvcSequenceHeaderData avcData;
    try {
      avcData=parseAvcCodecPrivate(videoSequence);
      nalUnitsLength=avcData.nalUnitLengthFieldLength;
    }
 catch (    ParserException e) {
      e.printStackTrace();
      return;
    }
    MediaFormat mediaFormat=MediaFormat.createVideoFormat(MediaFormat.NO_VALUE,MimeTypes.VIDEO_H264,MediaFormat.NO_VALUE,MediaFormat.NO_VALUE,durationUs,avcData.width,avcData.height,avcData.initializationData,MediaFormat.NO_VALUE,avcData.pixelWidthAspectRatio);
    output.format(mediaFormat);
    hasOutputFormat=true;
  }
 else   if (packetType == AVC_PACKET_TYPE_AVC_NALU) {
    byte[] nalLengthData=nalLength.data;
    nalLengthData[0]=0;
    nalLengthData[1]=0;
    nalLengthData[2]=0;
    int nalUnitLengthFieldLength=nalUnitsLength;
    int nalUnitLengthFieldLengthDiff=4 - nalUnitsLength;
    int bytesWritten=0;
    int bytesToWrite;
    while (data.bytesLeft() > 0) {
      data.readBytes(nalLength.data,nalUnitLengthFieldLengthDiff,nalUnitLengthFieldLength);
      nalLength.setPosition(0);
      bytesToWrite=nalLength.readUnsignedIntToInt();
      nalStartCode.setPosition(0);
      output.sampleData(nalStartCode,4);
      bytesWritten+=4;
      output.sampleData(data,bytesToWrite);
      bytesWritten+=bytesToWrite;
    }
    output.sampleMetadata(timeUs,frameType == VIDEO_FRAME_KEYFRAME ? C.SAMPLE_FLAG_SYNC : 0,bytesWritten,0,null);
  }
 else   if (packetType == AVC_PACKET_TYPE_AVC_END_OF_SEQUENCE) {
    Log.d(TAG,""String_Node_Str"");
  }
}",0.9945918104558332
110414,"/** 
 * Chooses a suitable subset from a number of video formats. <p> A format is filtered (i.e. not selected) if: <ul> <li>  {@code allowedContainerMimeTypes} is non-null and the format does not have one of thepermitted mime types. <li> {@code filterHdFormats} is true and the format is HD.<li>It's determined that the video decoder isn't powerful enough to decode the format. <li>There exists another format of lower resolution whose resolution exceeds the maximum size in pixels that the video can be rendered within the viewport. </ul>
 * @param formatWrappers Wrapped formats from which to select.
 * @param allowedContainerMimeTypes An array of allowed container mime types. Null allows allmime types.
 * @param filterHdFormats True to filter HD formats. False otherwise.
 * @param orientationMayChange True if the video's orientation may change with respect to theviewport during playback.
 * @param viewportWidth The width in pixels of the viewport within which the video will bedisplayed. If the viewport size may change, this should be set to the maximum possible width.
 * @param viewportHeight The height in pixels of the viewport within which the video will bedisplayed. If the viewport size may change, this should be set to the maximum possible height.
 * @return An array holding the indices of the selected formats.
 * @throws DecoderQueryException
 */
public static int[] selectVideoFormats(List<? extends FormatWrapper> formatWrappers,String[] allowedContainerMimeTypes,boolean filterHdFormats,boolean orientationMayChange,int viewportWidth,int viewportHeight) throws DecoderQueryException {
  int maxVideoPixelsToRetain=Integer.MAX_VALUE;
  ArrayList<Integer> selectedIndexList=new ArrayList<>();
  int maxDecodableFrameSize=MediaCodecUtil.maxH264DecodableFrameSize();
  int formatWrapperCount=formatWrappers.size();
  for (int i=0; i < formatWrapperCount; i++) {
    Format format=formatWrappers.get(i).getFormat();
    if (isFormatPlayable(format,allowedContainerMimeTypes,filterHdFormats,maxDecodableFrameSize)) {
      selectedIndexList.add(i);
      if (format.width > 0 && format.height > 0) {
        Point maxVideoSizeInViewport=getMaxVideoSizeInViewport(orientationMayChange,viewportWidth,viewportHeight,format.width,format.height);
        int videoPixels=format.width * format.height;
        if (format.width >= (int)(maxVideoSizeInViewport.x * FRACTION_TO_CONSIDER_FULLSCREEN) && format.height >= (int)(maxVideoSizeInViewport.y * FRACTION_TO_CONSIDER_FULLSCREEN) && videoPixels < maxVideoPixelsToRetain) {
          maxVideoPixelsToRetain=videoPixels;
        }
      }
    }
  }
  for (int i=selectedIndexList.size() - 1; i >= 0; i--) {
    Format format=formatWrappers.get(i).getFormat();
    if (format.width > 0 && format.height > 0 && format.width * format.height > maxVideoPixelsToRetain) {
      selectedIndexList.remove(i);
    }
  }
  return Util.toArray(selectedIndexList);
}","/** 
 * Chooses a suitable subset from a number of video formats. <p> A format is filtered (i.e. not selected) if: <ul> <li>  {@code allowedContainerMimeTypes} is non-null and the format does not have one of thepermitted mime types. <li> {@code filterHdFormats} is true and the format is HD.<li>It's determined that the video decoder isn't powerful enough to decode the format. <li>There exists another format of lower resolution whose resolution exceeds the maximum size in pixels that the video can be rendered within the viewport. </ul>
 * @param formatWrappers Wrapped formats from which to select.
 * @param allowedContainerMimeTypes An array of allowed container mime types. Null allows allmime types.
 * @param filterHdFormats True to filter HD formats. False otherwise.
 * @param orientationMayChange True if the video's orientation may change with respect to theviewport during playback.
 * @param viewportWidth The width in pixels of the viewport within which the video will bedisplayed. If the viewport size may change, this should be set to the maximum possible width.
 * @param viewportHeight The height in pixels of the viewport within which the video will bedisplayed. If the viewport size may change, this should be set to the maximum possible height.
 * @return An array holding the indices of the selected formats.
 * @throws DecoderQueryException
 */
public static int[] selectVideoFormats(List<? extends FormatWrapper> formatWrappers,String[] allowedContainerMimeTypes,boolean filterHdFormats,boolean orientationMayChange,int viewportWidth,int viewportHeight) throws DecoderQueryException {
  int maxVideoPixelsToRetain=Integer.MAX_VALUE;
  ArrayList<Integer> selectedIndexList=new ArrayList<>();
  int maxDecodableFrameSize=MediaCodecUtil.maxH264DecodableFrameSize();
  int formatWrapperCount=formatWrappers.size();
  for (int i=0; i < formatWrapperCount; i++) {
    Format format=formatWrappers.get(i).getFormat();
    if (isFormatPlayable(format,allowedContainerMimeTypes,filterHdFormats,maxDecodableFrameSize)) {
      selectedIndexList.add(i);
      if (format.width > 0 && format.height > 0) {
        Point maxVideoSizeInViewport=getMaxVideoSizeInViewport(orientationMayChange,viewportWidth,viewportHeight,format.width,format.height);
        int videoPixels=format.width * format.height;
        if (format.width >= (int)(maxVideoSizeInViewport.x * FRACTION_TO_CONSIDER_FULLSCREEN) && format.height >= (int)(maxVideoSizeInViewport.y * FRACTION_TO_CONSIDER_FULLSCREEN) && videoPixels < maxVideoPixelsToRetain) {
          maxVideoPixelsToRetain=videoPixels;
        }
      }
    }
  }
  for (int i=selectedIndexList.size() - 1; i >= 0; i--) {
    Format format=formatWrappers.get(selectedIndexList.get(i)).getFormat();
    if (format.width > 0 && format.height > 0 && format.width * format.height > maxVideoPixelsToRetain) {
      selectedIndexList.remove(i);
    }
  }
  return Util.toArray(selectedIndexList);
}",0.9957330602491892
110415,"@Override public void enable(int track){
  enabledTrack=tracks.get(track);
  processManifest(currentManifest);
  if (enabledTrack.isAdaptive()) {
    adaptiveFormatEvaluator.enable();
  }
  if (manifestFetcher != null) {
    manifestFetcher.enable();
  }
}","@Override public void enable(int track){
  enabledTrack=tracks.get(track);
  if (enabledTrack.isAdaptive()) {
    adaptiveFormatEvaluator.enable();
  }
  if (manifestFetcher != null) {
    manifestFetcher.enable();
    processManifest(manifestFetcher.getManifest());
  }
 else {
    processManifest(currentManifest);
  }
}",0.7612456747404844
110416,"@Override public void onLoadCompleted(int sourceId,long bytesLoaded,int type,int trigger,Format format,int mediaStartTimeMs,int mediaEndTimeMs,long elapsedRealtimeMs,long loadDurationMs){
  if (VerboseLogUtil.isTagEnabled(TAG)) {
    long downloadTime=SystemClock.elapsedRealtime() - loadStartTimeMs[sourceId];
    Log.v(TAG,""String_Node_Str"" + getSessionTimeString() + ""String_Node_Str""+ sourceId+ ""String_Node_Str""+ downloadTime+ ""String_Node_Str"");
  }
}","@Override public void onLoadCompleted(int sourceId,long bytesLoaded,int type,int trigger,Format format,long mediaStartTimeMs,long mediaEndTimeMs,long elapsedRealtimeMs,long loadDurationMs){
  if (VerboseLogUtil.isTagEnabled(TAG)) {
    long downloadTime=SystemClock.elapsedRealtime() - loadStartTimeMs[sourceId];
    Log.v(TAG,""String_Node_Str"" + getSessionTimeString() + ""String_Node_Str""+ sourceId+ ""String_Node_Str""+ downloadTime+ ""String_Node_Str"");
  }
}",0.9847161572052402
110417,"@Override public void onLoadStarted(int sourceId,long length,int type,int trigger,Format format,int mediaStartTimeMs,int mediaEndTimeMs){
  loadStartTimeMs[sourceId]=SystemClock.elapsedRealtime();
  if (VerboseLogUtil.isTagEnabled(TAG)) {
    Log.v(TAG,""String_Node_Str"" + getSessionTimeString() + ""String_Node_Str""+ sourceId+ ""String_Node_Str""+ type+ ""String_Node_Str""+ mediaStartTimeMs+ ""String_Node_Str""+ mediaEndTimeMs+ ""String_Node_Str"");
  }
}","@Override public void onLoadStarted(int sourceId,long length,int type,int trigger,Format format,long mediaStartTimeMs,long mediaEndTimeMs){
  loadStartTimeMs[sourceId]=SystemClock.elapsedRealtime();
  if (VerboseLogUtil.isTagEnabled(TAG)) {
    Log.v(TAG,""String_Node_Str"" + getSessionTimeString() + ""String_Node_Str""+ sourceId+ ""String_Node_Str""+ type+ ""String_Node_Str""+ mediaStartTimeMs+ ""String_Node_Str""+ mediaEndTimeMs+ ""String_Node_Str"");
  }
}",0.9844444444444445
110418,"@Override public void onVideoFormatEnabled(Format format,int trigger,int mediaTimeMs){
  Log.d(TAG,""String_Node_Str"" + getSessionTimeString() + ""String_Node_Str""+ format.id+ ""String_Node_Str""+ Integer.toString(trigger)+ ""String_Node_Str"");
}","@Override public void onVideoFormatEnabled(Format format,int trigger,long mediaTimeMs){
  Log.d(TAG,""String_Node_Str"" + getSessionTimeString() + ""String_Node_Str""+ format.id+ ""String_Node_Str""+ Integer.toString(trigger)+ ""String_Node_Str"");
}",0.9855072463768116
110419,"@Override public void onAudioFormatEnabled(Format format,int trigger,int mediaTimeMs){
  Log.d(TAG,""String_Node_Str"" + getSessionTimeString() + ""String_Node_Str""+ format.id+ ""String_Node_Str""+ Integer.toString(trigger)+ ""String_Node_Str"");
}","@Override public void onAudioFormatEnabled(Format format,int trigger,long mediaTimeMs){
  Log.d(TAG,""String_Node_Str"" + getSessionTimeString() + ""String_Node_Str""+ format.id+ ""String_Node_Str""+ Integer.toString(trigger)+ ""String_Node_Str"");
}",0.9855072463768116
110420,"@Override public void onUpstreamDiscarded(int sourceId,int mediaStartTimeMs,int mediaEndTimeMs){
}","@Override public void onUpstreamDiscarded(int sourceId,long mediaStartTimeMs,long mediaEndTimeMs){
}",0.9494949494949496
110421,"void onVideoFormatEnabled(Format format,int trigger,int mediaTimeMs);","void onVideoFormatEnabled(Format format,int trigger,long mediaTimeMs);",0.9640287769784172
110422,"@Override public void onLoadStarted(int sourceId,long length,int type,int trigger,Format format,int mediaStartTimeMs,int mediaEndTimeMs){
  if (infoListener != null) {
    infoListener.onLoadStarted(sourceId,length,type,trigger,format,mediaStartTimeMs,mediaEndTimeMs);
  }
}","@Override public void onLoadStarted(int sourceId,long length,int type,int trigger,Format format,long mediaStartTimeMs,long mediaEndTimeMs){
  if (infoListener != null) {
    infoListener.onLoadStarted(sourceId,length,type,trigger,format,mediaStartTimeMs,mediaEndTimeMs);
  }
}",0.9090909090909092
110423,"void onAudioFormatEnabled(Format format,int trigger,int mediaTimeMs);","void onAudioFormatEnabled(Format format,int trigger,long mediaTimeMs);",0.9640287769784172
110424,"@Override public void onDownstreamFormatChanged(int sourceId,Format format,int trigger,int mediaTimeMs){
  if (infoListener == null) {
    return;
  }
  if (sourceId == TYPE_VIDEO) {
    videoFormat=format;
    infoListener.onVideoFormatEnabled(format,trigger,mediaTimeMs);
  }
 else   if (sourceId == TYPE_AUDIO) {
    infoListener.onAudioFormatEnabled(format,trigger,mediaTimeMs);
  }
}","@Override public void onDownstreamFormatChanged(int sourceId,Format format,int trigger,long mediaTimeMs){
  if (infoListener == null) {
    return;
  }
  if (sourceId == TYPE_VIDEO) {
    videoFormat=format;
    infoListener.onVideoFormatEnabled(format,trigger,mediaTimeMs);
  }
 else   if (sourceId == TYPE_AUDIO) {
    infoListener.onAudioFormatEnabled(format,trigger,mediaTimeMs);
  }
}",0.990990990990991
110425,"@Override public void onLoadCompleted(int sourceId,long bytesLoaded,int type,int trigger,Format format,int mediaStartTimeMs,int mediaEndTimeMs,long elapsedRealtimeMs,long loadDurationMs){
  if (infoListener != null) {
    infoListener.onLoadCompleted(sourceId,bytesLoaded,type,trigger,format,mediaStartTimeMs,mediaEndTimeMs,elapsedRealtimeMs,loadDurationMs);
  }
}","@Override public void onLoadCompleted(int sourceId,long bytesLoaded,int type,int trigger,Format format,long mediaStartTimeMs,long mediaEndTimeMs,long elapsedRealtimeMs,long loadDurationMs){
  if (infoListener != null) {
    infoListener.onLoadCompleted(sourceId,bytesLoaded,type,trigger,format,mediaStartTimeMs,mediaEndTimeMs,elapsedRealtimeMs,loadDurationMs);
  }
}",0.9808219178082191
110426,"/** 
 * Invoked when the current load operation completes.
 * @param sourceId The id of the reporting {@link SampleSource}.
 * @param bytesLoaded The number of bytes that were loaded.
 * @param type The type of the loaded data.
 * @param trigger The reason for the data being loaded.
 * @param format The particular format to which this data corresponds, or null if the loaded datadoes not correspond to a format.
 * @param mediaStartTimeMs The media time of the start of the loaded data, or -1 if this load wasfor initialization data.
 * @param mediaEndTimeMs The media time of the end of the loaded data, or -1 if this load was forinitialization data.
 * @param elapsedRealtimeMs {@code elapsedRealtime} timestamp of when the load finished.
 * @param loadDurationMs Amount of time taken to load the data.
 */
void onLoadCompleted(int sourceId,long bytesLoaded,int type,int trigger,Format format,int mediaStartTimeMs,int mediaEndTimeMs,long elapsedRealtimeMs,long loadDurationMs);","/** 
 * Invoked when the current load operation completes.
 * @param sourceId The id of the reporting {@link SampleSource}.
 * @param bytesLoaded The number of bytes that were loaded.
 * @param type The type of the loaded data.
 * @param trigger The reason for the data being loaded.
 * @param format The particular format to which this data corresponds, or null if the loaded datadoes not correspond to a format.
 * @param mediaStartTimeMs The media time of the start of the loaded data, or -1 if this load wasfor initialization data.
 * @param mediaEndTimeMs The media time of the end of the loaded data, or -1 if this load was forinitialization data.
 * @param elapsedRealtimeMs {@code elapsedRealtime} timestamp of when the load finished.
 * @param loadDurationMs Amount of time taken to load the data.
 */
void onLoadCompleted(int sourceId,long bytesLoaded,int type,int trigger,Format format,long mediaStartTimeMs,long mediaEndTimeMs,long elapsedRealtimeMs,long loadDurationMs);",0.9928716904276986
110427,"/** 
 * Invoked when an upstream load is started.
 * @param sourceId The id of the reporting {@link SampleSource}.
 * @param length The length of the data being loaded in bytes, or {@link C#LENGTH_UNBOUNDED} ifthe length of the data is not known in advance.
 * @param type The type of the data being loaded.
 * @param trigger The reason for the data being loaded.
 * @param format The particular format to which this data corresponds, or null if the data beingloaded does not correspond to a format.
 * @param mediaStartTimeMs The media time of the start of the data being loaded, or -1 if thisload is for initialization data.
 * @param mediaEndTimeMs The media time of the end of the data being loaded, or -1 if thisload is for initialization data.
 */
void onLoadStarted(int sourceId,long length,int type,int trigger,Format format,int mediaStartTimeMs,int mediaEndTimeMs);","/** 
 * Invoked when an upstream load is started.
 * @param sourceId The id of the reporting {@link SampleSource}.
 * @param length The length of the data being loaded in bytes, or {@link C#LENGTH_UNBOUNDED} ifthe length of the data is not known in advance.
 * @param type The type of the data being loaded.
 * @param trigger The reason for the data being loaded.
 * @param format The particular format to which this data corresponds, or null if the data beingloaded does not correspond to a format.
 * @param mediaStartTimeMs The media time of the start of the data being loaded, or -1 if thisload is for initialization data.
 * @param mediaEndTimeMs The media time of the end of the data being loaded, or -1 if thisload is for initialization data.
 */
void onLoadStarted(int sourceId,long length,int type,int trigger,Format format,long mediaStartTimeMs,long mediaEndTimeMs);",0.992
110428,"/** 
 * Invoked when data is removed from the back of the buffer, typically so that it can be re-buffered using a different representation.
 * @param sourceId The id of the reporting {@link SampleSource}.
 * @param mediaStartTimeMs The media time of the start of the discarded data.
 * @param mediaEndTimeMs The media time of the end of the discarded data.
 */
void onUpstreamDiscarded(int sourceId,int mediaStartTimeMs,int mediaEndTimeMs);","/** 
 * Invoked when data is removed from the back of the buffer, typically so that it can be re-buffered using a different representation.
 * @param sourceId The id of the reporting {@link SampleSource}.
 * @param mediaStartTimeMs The media time of the start of the discarded data.
 * @param mediaEndTimeMs The media time of the end of the discarded data.
 */
void onUpstreamDiscarded(int sourceId,long mediaStartTimeMs,long mediaEndTimeMs);",0.984126984126984
110429,"/** 
 * Invoked when the downstream format changes (i.e. when the format being supplied to the caller of   {@link SampleSourceReader#readData} changes).
 * @param sourceId The id of the reporting {@link SampleSource}.
 * @param format The format.
 * @param trigger The trigger specified in the corresponding upstream load, as specified by the{@link ChunkSource}.
 * @param mediaTimeMs The media time at which the change occurred.
 */
void onDownstreamFormatChanged(int sourceId,Format format,int trigger,int mediaTimeMs);","/** 
 * Invoked when the downstream format changes (i.e. when the format being supplied to the caller of   {@link SampleSourceReader#readData} changes).
 * @param sourceId The id of the reporting {@link SampleSource}.
 * @param format The format.
 * @param trigger The trigger specified in the corresponding upstream load, as specified by the{@link ChunkSource}.
 * @param mediaTimeMs The media time at which the change occurred.
 */
void onDownstreamFormatChanged(int sourceId,Format format,int trigger,long mediaTimeMs);",0.9932885906040269
110430,"protected final int usToMs(long timeUs){
  return (int)(timeUs / 1000);
}","protected final long usToMs(long timeUs){
  return timeUs / 1000;
}",0.9142857142857144
110431,"int usToMs(long timeUs){
  return (int)(timeUs / 1000);
}","long usToMs(long timeUs){
  return timeUs / 1000;
}",0.8888888888888888
110432,"@Override public void onLoadCompleted(int sourceId,long bytesLoaded,int type,int trigger,Format format,int mediaStartTimeMs,int mediaEndTimeMs,long elapsedRealtimeMs,long loadDurationMs){
}","@Override public void onLoadCompleted(int sourceId,long bytesLoaded,int type,int trigger,Format format,long mediaStartTimeMs,long mediaEndTimeMs,long elapsedRealtimeMs,long loadDurationMs){
}",0.9736842105263158
110433,"@Override public void onUpstreamDiscarded(int sourceId,int mediaStartTimeMs,int mediaEndTimeMs){
}","@Override public void onUpstreamDiscarded(int sourceId,long mediaStartTimeMs,long mediaEndTimeMs){
}",0.9494949494949496
110434,"@Override public void onLoadStarted(int sourceId,long length,int type,int trigger,Format format,int mediaStartTimeMs,int mediaEndTimeMs){
}","@Override public void onLoadStarted(int sourceId,long length,int type,int trigger,Format format,long mediaStartTimeMs,long mediaEndTimeMs){
}",0.9642857142857144
110435,"@Override public void onDownstreamFormatChanged(int sourceId,Format format,int trigger,int mediaTimeMs){
  Log.i(tag,""String_Node_Str"" + sourceId + ""String_Node_Str""+ format.id);
}","@Override public void onDownstreamFormatChanged(int sourceId,Format format,int trigger,long mediaTimeMs){
  Log.i(tag,""String_Node_Str"" + sourceId + ""String_Node_Str""+ format.id);
}",0.9861495844875346
110436,"private static MediaFormat getAdjustedMediaFormat(MediaFormat format,long sampleOffsetUs){
  if (sampleOffsetUs != 0 && format.subsampleOffsetUs != MediaFormat.OFFSET_SAMPLE_RELATIVE) {
    return format.copyWithSubsampleOffsetUs(format.subsampleOffsetUs + sampleOffsetUs);
  }
  return format;
}","private static MediaFormat getAdjustedMediaFormat(MediaFormat format,long sampleOffsetUs){
  if (sampleOffsetUs != 0 && format != null && format.subsampleOffsetUs != MediaFormat.OFFSET_SAMPLE_RELATIVE) {
    return format.copyWithSubsampleOffsetUs(format.subsampleOffsetUs + sampleOffsetUs);
  }
  return format;
}",0.9704918032786886
110437,"private void processManifest(MediaPresentationDescription manifest){
  Period firstPeriod=manifest.periods.get(0);
  while (periodHolders.size() > 0 && periodHolders.valueAt(0).startTimeUs < firstPeriod.startMs * 1000) {
    PeriodHolder periodHolder=periodHolders.valueAt(0);
    periodHolders.remove(periodHolder.manifestIndex);
  }
  int periodIndex=0;
  for (int i=0; i < manifest.periods.size(); i++) {
    Period period=manifest.periods.get(i);
    AdaptationSet adaptationSet=period.adaptationSets.get(adaptationSetIndex);
    List<Representation> representations=adaptationSet.representations;
    Representation newRepresentations[];
    if (representationIndices == null) {
      newRepresentations=new Representation[representations.size()];
      representations.toArray(newRepresentations);
    }
 else {
      newRepresentations=new Representation[representationIndices.length];
      for (int j=0; j < representationIndices.length; j++) {
        newRepresentations[j]=representations.get(representationIndices[j]);
      }
    }
    PeriodHolder periodHolder=periodHolders.valueAt(periodIndex);
    if (periodHolder == null) {
      long periodStartUs=period.startMs * 1000;
      periodHolder=new PeriodHolder(periodHolderNextIndex,periodStartUs,newRepresentations);
      periodHolders.put(periodHolderNextIndex,periodHolder);
      periodHolderNextIndex++;
    }
 else {
      for (int j=0; j < newRepresentations.length; j++) {
        RepresentationHolder representationHolder=periodHolder.representationHolders.get(newRepresentations[j].format.id);
        try {
          representationHolder.updateRepresentation(newRepresentations[j]);
        }
 catch (        BehindLiveWindowException e) {
          fatalError=e;
          return;
        }
      }
    }
    periodIndex++;
  }
  currentManifest=manifest;
}","private void processManifest(MediaPresentationDescription manifest){
  Period firstPeriod=manifest.periods.get(0);
  while (periodHolders.size() > 0 && periodHolders.valueAt(0).startTimeUs < firstPeriod.startMs * 1000) {
    PeriodHolder periodHolder=periodHolders.valueAt(0);
    periodHolders.remove(periodHolder.manifestIndex);
  }
  for (int i=0; i < manifest.periods.size(); i++) {
    Period period=manifest.periods.get(i);
    AdaptationSet adaptationSet=period.adaptationSets.get(adaptationSetIndex);
    List<Representation> representations=adaptationSet.representations;
    Representation newRepresentations[];
    if (representationIndices == null) {
      newRepresentations=new Representation[representations.size()];
      representations.toArray(newRepresentations);
    }
 else {
      newRepresentations=new Representation[representationIndices.length];
      for (int j=0; j < representationIndices.length; j++) {
        newRepresentations[j]=representations.get(representationIndices[j]);
      }
    }
    if (i < periodHolders.size()) {
      PeriodHolder periodHolder=periodHolders.valueAt(i);
      for (int j=0; j < newRepresentations.length; j++) {
        RepresentationHolder representationHolder=periodHolder.representationHolders.get(newRepresentations[j].format.id);
        try {
          representationHolder.updateRepresentation(newRepresentations[j]);
        }
 catch (        BehindLiveWindowException e) {
          fatalError=e;
          return;
        }
      }
    }
 else {
      long periodStartUs=period.startMs * 1000;
      PeriodHolder periodHolder=new PeriodHolder(periodHolderNextIndex,periodStartUs,newRepresentations);
      periodHolders.put(periodHolderNextIndex,periodHolder);
      periodHolderNextIndex++;
    }
  }
  currentManifest=manifest;
}",0.7443010162043394
110438,"private PeriodHolder findPeriodHolder(long positionUs){
  if (positionUs < periodHolders.valueAt(0).getAvailableStartTimeUs()) {
    return periodHolders.valueAt(0);
  }
  for (int i=0; i < periodHolders.size(); i++) {
    PeriodHolder periodHolder=periodHolders.valueAt(i);
    if (positionUs >= periodHolder.getAvailableStartTimeUs() && (periodHolder.isIndexUnbounded() || positionUs < periodHolder.getAvailableEndTimeUs())) {
      return periodHolder;
    }
  }
  return periodHolders.valueAt(periodHolders.size() - 1);
}","private PeriodHolder findPeriodHolder(long positionUs){
  if (positionUs < periodHolders.valueAt(0).getAvailableStartTimeUs()) {
    return periodHolders.valueAt(0);
  }
  for (int i=0; i < periodHolders.size() - 1; i++) {
    PeriodHolder periodHolder=periodHolders.valueAt(i);
    if (positionUs < periodHolder.getAvailableEndTimeUs()) {
      return periodHolder;
    }
  }
  return periodHolders.valueAt(periodHolders.size() - 1);
}",0.890738813735692
110439,"@Override public final void getChunkOperation(List<? extends MediaChunk> queue,long seekPositionUs,long playbackPositionUs,ChunkOperationHolder out){
  if (fatalError != null) {
    out.chunk=null;
    return;
  }
  evaluation.queueSize=queue.size();
  if (evaluation.format == null || !lastChunkWasInitialization) {
    PeriodHolder periodHolder=null;
    if (!queue.isEmpty()) {
      periodHolder=periodHolders.get(queue.get(queue.size() - 1).parentId);
    }
    if (periodHolder == null) {
      periodHolder=periodHolders.valueAt(0);
    }
    formatEvaluator.evaluate(queue,playbackPositionUs,periodHolder.formats,evaluation);
  }
  Format selectedFormat=evaluation.format;
  out.queueSize=evaluation.queueSize;
  if (selectedFormat == null) {
    out.chunk=null;
    return;
  }
 else   if (out.queueSize == queue.size() && out.chunk != null && out.chunk.format.equals(selectedFormat)) {
    return;
  }
  out.chunk=null;
  if (currentManifest.dynamic && periodHolders.valueAt(periodHolders.size() - 1).isIndexUnbounded()) {
    updateAvailableBounds(getNowUs());
  }
  availableRangeValues=availableRange.getCurrentBoundsUs(availableRangeValues);
  long segmentStartTimeUs;
  int segmentNum=-1;
  boolean startingNewPeriod=false;
  PeriodHolder periodHolder;
  if (queue.isEmpty()) {
    if (currentManifest.dynamic) {
      if (startAtLiveEdge) {
        seekPositionUs=Math.max(availableRangeValues[0],availableRangeValues[1] - liveEdgeLatencyUs);
      }
 else {
        seekPositionUs=Math.max(seekPositionUs,availableRangeValues[0]);
        seekPositionUs=Math.min(seekPositionUs,availableRangeValues[1] - 1);
      }
    }
    periodHolder=findPeriodHolder(seekPositionUs);
    segmentStartTimeUs=seekPositionUs;
    startingNewPeriod=true;
  }
 else {
    if (startAtLiveEdge) {
      startAtLiveEdge=false;
    }
    MediaChunk previous=queue.get(out.queueSize - 1);
    if (previous.isLastChunk) {
      return;
    }
    segmentNum=previous.chunkIndex + 1;
    segmentStartTimeUs=previous.endTimeUs;
    if (currentManifest.dynamic) {
      if (segmentStartTimeUs < availableRangeValues[0]) {
        fatalError=new BehindLiveWindowException();
        return;
      }
 else       if (segmentStartTimeUs >= availableRangeValues[1]) {
        return;
      }
    }
    periodHolder=periodHolders.get(previous.parentId);
    if (periodHolder == null) {
      periodHolder=periodHolders.valueAt(0);
      startingNewPeriod=true;
    }
 else     if (!periodHolder.isIndexUnbounded() && segmentStartTimeUs >= periodHolder.getAvailableEndTimeUs()) {
      periodHolder=periodHolders.get(previous.parentId + 1);
      startingNewPeriod=true;
    }
  }
  RepresentationHolder representationHolder=periodHolder.representationHolders.get(selectedFormat.id);
  Representation selectedRepresentation=representationHolder.representation;
  ChunkExtractorWrapper extractorWrapper=representationHolder.extractorWrapper;
  RangedUri pendingInitializationUri=null;
  RangedUri pendingIndexUri=null;
  MediaFormat mediaFormat=representationHolder.mediaFormat;
  if (mediaFormat == null) {
    pendingInitializationUri=selectedRepresentation.getInitializationUri();
  }
  if (representationHolder.segmentIndex == null) {
    pendingIndexUri=selectedRepresentation.getIndexUri();
  }
  if (pendingInitializationUri != null || pendingIndexUri != null) {
    Chunk initializationChunk=newInitializationChunk(pendingInitializationUri,pendingIndexUri,selectedRepresentation,extractorWrapper,dataSource,periodHolder.manifestIndex,evaluation.trigger);
    lastChunkWasInitialization=true;
    out.chunk=initializationChunk;
    return;
  }
  if (startingNewPeriod) {
    if (queue.isEmpty()) {
      segmentNum=representationHolder.getSegmentNum(segmentStartTimeUs);
    }
 else {
      segmentNum=representationHolder.getFirstAvailableSegmentNum();
    }
  }
  Chunk nextMediaChunk=newMediaChunk(periodHolder,representationHolder,dataSource,mediaFormat,segmentNum,evaluation.trigger);
  lastChunkWasInitialization=false;
  out.chunk=nextMediaChunk;
}","@Override public final void getChunkOperation(List<? extends MediaChunk> queue,long seekPositionUs,long playbackPositionUs,ChunkOperationHolder out){
  if (fatalError != null) {
    out.chunk=null;
    return;
  }
  evaluation.queueSize=queue.size();
  if (evaluation.format == null || !lastChunkWasInitialization) {
    PeriodHolder periodHolder=null;
    if (!queue.isEmpty()) {
      periodHolder=periodHolders.get(queue.get(queue.size() - 1).parentId);
    }
    if (periodHolder == null) {
      periodHolder=periodHolders.valueAt(0);
    }
    formatEvaluator.evaluate(queue,playbackPositionUs,periodHolder.formats,evaluation);
  }
  Format selectedFormat=evaluation.format;
  out.queueSize=evaluation.queueSize;
  if (selectedFormat == null) {
    out.chunk=null;
    return;
  }
 else   if (out.queueSize == queue.size() && out.chunk != null && out.chunk.format.equals(selectedFormat)) {
    return;
  }
  out.chunk=null;
  if (currentManifest.dynamic && periodHolders.valueAt(periodHolders.size() - 1).isIndexUnbounded()) {
    updateAvailableBounds(getNowUs());
  }
  availableRangeValues=availableRange.getCurrentBoundsUs(availableRangeValues);
  long segmentStartTimeUs;
  int segmentNum=-1;
  boolean startingNewPeriod=false;
  PeriodHolder periodHolder;
  if (queue.isEmpty()) {
    if (currentManifest.dynamic) {
      if (startAtLiveEdge) {
        seekPositionUs=Math.max(availableRangeValues[0],availableRangeValues[1] - liveEdgeLatencyUs);
      }
 else {
        seekPositionUs=Math.min(seekPositionUs,availableRangeValues[1] - 1);
        seekPositionUs=Math.max(seekPositionUs,availableRangeValues[0]);
      }
    }
    periodHolder=findPeriodHolder(seekPositionUs);
    segmentStartTimeUs=seekPositionUs;
    startingNewPeriod=true;
  }
 else {
    if (startAtLiveEdge) {
      startAtLiveEdge=false;
    }
    MediaChunk previous=queue.get(out.queueSize - 1);
    if (previous.isLastChunk) {
      return;
    }
    segmentNum=previous.chunkIndex + 1;
    segmentStartTimeUs=previous.endTimeUs;
    if (currentManifest.dynamic) {
      if (segmentStartTimeUs < availableRangeValues[0]) {
        fatalError=new BehindLiveWindowException();
        return;
      }
 else       if (segmentStartTimeUs >= availableRangeValues[1]) {
        return;
      }
    }
    periodHolder=periodHolders.get(previous.parentId);
    if (periodHolder == null) {
      periodHolder=periodHolders.valueAt(0);
      startingNewPeriod=true;
    }
 else     if (!periodHolder.isIndexUnbounded() && segmentStartTimeUs >= periodHolder.getAvailableEndTimeUs()) {
      periodHolder=periodHolders.get(previous.parentId + 1);
      startingNewPeriod=true;
    }
  }
  RepresentationHolder representationHolder=periodHolder.representationHolders.get(selectedFormat.id);
  Representation selectedRepresentation=representationHolder.representation;
  ChunkExtractorWrapper extractorWrapper=representationHolder.extractorWrapper;
  RangedUri pendingInitializationUri=null;
  RangedUri pendingIndexUri=null;
  MediaFormat mediaFormat=representationHolder.mediaFormat;
  if (mediaFormat == null) {
    pendingInitializationUri=selectedRepresentation.getInitializationUri();
  }
  if (representationHolder.segmentIndex == null) {
    pendingIndexUri=selectedRepresentation.getIndexUri();
  }
  if (pendingInitializationUri != null || pendingIndexUri != null) {
    Chunk initializationChunk=newInitializationChunk(pendingInitializationUri,pendingIndexUri,selectedRepresentation,extractorWrapper,dataSource,periodHolder.manifestIndex,evaluation.trigger);
    lastChunkWasInitialization=true;
    out.chunk=initializationChunk;
    return;
  }
  if (startingNewPeriod) {
    if (queue.isEmpty()) {
      segmentNum=representationHolder.getSegmentNum(segmentStartTimeUs);
    }
 else {
      segmentNum=representationHolder.getFirstAvailableSegmentNum();
    }
  }
  Chunk nextMediaChunk=newMediaChunk(periodHolder,representationHolder,dataSource,mediaFormat,segmentNum,evaluation.trigger);
  lastChunkWasInitialization=false;
  out.chunk=nextMediaChunk;
}",0.9809641532756488
110440,"/** 
 * @param dataSource A {@link DataSource} suitable for loading the media data.
 * @param playlistUrl The playlist URL.
 * @param playlist The hls playlist.
 * @param bandwidthMeter provides an estimate of the currently available bandwidth.
 * @param variantIndices If {@code playlist} is a {@link HlsMasterPlaylist}, the subset of variant indices to consider, or null to consider all of the variants. For other playlist types this parameter is ignored.
 * @param adaptiveMode The mode for switching from one variant to another. One of{@link #ADAPTIVE_MODE_NONE},   {@link #ADAPTIVE_MODE_ABRUPT} and{@link #ADAPTIVE_MODE_SPLICE}.
 * @param minBufferDurationToSwitchUpMs The minimum duration of media that needs to be bufferedfor a switch to a higher quality variant to be considered.
 * @param maxBufferDurationToSwitchDownMs The maximum duration of media that needs to be bufferedfor a switch to a lower quality variant to be considered.
 * @param audioCapabilities The audio capabilities for playback on this device, or {@code null} ifthe default capabilities should be assumed.
 */
public HlsChunkSource(DataSource dataSource,String playlistUrl,HlsPlaylist playlist,BandwidthMeter bandwidthMeter,int[] variantIndices,int adaptiveMode,long minBufferDurationToSwitchUpMs,long maxBufferDurationToSwitchDownMs,AudioCapabilities audioCapabilities){
  this.dataSource=dataSource;
  this.bandwidthMeter=bandwidthMeter;
  this.adaptiveMode=adaptiveMode;
  this.audioCapabilities=audioCapabilities;
  minBufferDurationToSwitchUpUs=minBufferDurationToSwitchUpMs * 1000;
  maxBufferDurationToSwitchDownUs=maxBufferDurationToSwitchDownMs * 1000;
  baseUri=playlist.baseUri;
  playlistParser=new HlsPlaylistParser();
  if (playlist.type == HlsPlaylist.TYPE_MEDIA) {
    variants=new Variant[]{new Variant(0,playlistUrl,0,null,-1,-1)};
    variantPlaylists=new HlsMediaPlaylist[]{(HlsMediaPlaylist)playlist};
    variantLastPlaylistLoadTimesMs=new long[1];
    variantBlacklistTimes=new long[1];
    maxWidth=-1;
    maxHeight=-1;
  }
 else {
    List<Variant> masterPlaylistVariants=((HlsMasterPlaylist)playlist).variants;
    variants=buildOrderedVariants(masterPlaylistVariants,variantIndices);
    variantPlaylists=new HlsMediaPlaylist[variants.length];
    variantLastPlaylistLoadTimesMs=new long[variants.length];
    variantBlacklistTimes=new long[variants.length];
    int maxWidth=-1;
    int maxHeight=-1;
    int minOriginalVariantIndex=Integer.MAX_VALUE;
    for (int i=0; i < variants.length; i++) {
      int originalVariantIndex=masterPlaylistVariants.indexOf(variants[i]);
      if (originalVariantIndex < minOriginalVariantIndex) {
        minOriginalVariantIndex=originalVariantIndex;
        selectedVariantIndex=i;
      }
      Format variantFormat=variants[i].format;
      maxWidth=Math.max(variantFormat.width,maxWidth);
      maxHeight=Math.max(variantFormat.height,maxHeight);
    }
    if (variants.length <= 1 || adaptiveMode == ADAPTIVE_MODE_NONE) {
      this.maxWidth=-1;
      this.maxHeight=-1;
    }
 else {
      this.maxWidth=maxWidth > 0 ? maxWidth : 1920;
      this.maxHeight=maxHeight > 0 ? maxHeight : 1080;
    }
  }
}","/** 
 * @param dataSource A {@link DataSource} suitable for loading the media data.
 * @param playlistUrl The playlist URL.
 * @param playlist The hls playlist.
 * @param bandwidthMeter provides an estimate of the currently available bandwidth.
 * @param variantIndices If {@code playlist} is a {@link HlsMasterPlaylist}, the subset of variant indices to consider, or null to consider all of the variants. For other playlist types this parameter is ignored.
 * @param adaptiveMode The mode for switching from one variant to another. One of{@link #ADAPTIVE_MODE_NONE},   {@link #ADAPTIVE_MODE_ABRUPT} and{@link #ADAPTIVE_MODE_SPLICE}.
 * @param minBufferDurationToSwitchUpMs The minimum duration of media that needs to be bufferedfor a switch to a higher quality variant to be considered.
 * @param maxBufferDurationToSwitchDownMs The maximum duration of media that needs to be bufferedfor a switch to a lower quality variant to be considered.
 * @param audioCapabilities The audio capabilities for playback on this device, or {@code null} ifthe default capabilities should be assumed.
 */
public HlsChunkSource(DataSource dataSource,String playlistUrl,HlsPlaylist playlist,BandwidthMeter bandwidthMeter,int[] variantIndices,int adaptiveMode,long minBufferDurationToSwitchUpMs,long maxBufferDurationToSwitchDownMs,AudioCapabilities audioCapabilities){
  this.dataSource=dataSource;
  this.bandwidthMeter=bandwidthMeter;
  this.adaptiveMode=adaptiveMode;
  this.audioCapabilities=audioCapabilities;
  minBufferDurationToSwitchUpUs=minBufferDurationToSwitchUpMs * 1000;
  maxBufferDurationToSwitchDownUs=maxBufferDurationToSwitchDownMs * 1000;
  baseUri=playlist.baseUri;
  playlistParser=new HlsPlaylistParser();
  if (playlist.type == HlsPlaylist.TYPE_MEDIA) {
    variants=new Variant[]{new Variant(0,playlistUrl,0,null,-1,-1)};
    variantPlaylists=new HlsMediaPlaylist[1];
    variantLastPlaylistLoadTimesMs=new long[1];
    variantBlacklistTimes=new long[1];
    setMediaPlaylist(0,(HlsMediaPlaylist)playlist);
    maxWidth=-1;
    maxHeight=-1;
  }
 else {
    List<Variant> masterPlaylistVariants=((HlsMasterPlaylist)playlist).variants;
    variants=buildOrderedVariants(masterPlaylistVariants,variantIndices);
    variantPlaylists=new HlsMediaPlaylist[variants.length];
    variantLastPlaylistLoadTimesMs=new long[variants.length];
    variantBlacklistTimes=new long[variants.length];
    int maxWidth=-1;
    int maxHeight=-1;
    int minOriginalVariantIndex=Integer.MAX_VALUE;
    for (int i=0; i < variants.length; i++) {
      int originalVariantIndex=masterPlaylistVariants.indexOf(variants[i]);
      if (originalVariantIndex < minOriginalVariantIndex) {
        minOriginalVariantIndex=originalVariantIndex;
        selectedVariantIndex=i;
      }
      Format variantFormat=variants[i].format;
      maxWidth=Math.max(variantFormat.width,maxWidth);
      maxHeight=Math.max(variantFormat.height,maxHeight);
    }
    if (variants.length <= 1 || adaptiveMode == ADAPTIVE_MODE_NONE) {
      this.maxWidth=-1;
      this.maxHeight=-1;
    }
 else {
      this.maxWidth=maxWidth > 0 ? maxWidth : 1920;
      this.maxHeight=maxHeight > 0 ? maxHeight : 1080;
    }
  }
}",0.987205812667825
110441,"@Override public void enable(int track,long positionUs){
  Assertions.checkState(state == STATE_PREPARED);
  Assertions.checkState(track == 0);
  state=STATE_ENABLED;
  chunkSource.enable();
  loadControl.register(this,bufferSizeContribution);
  downstreamFormat=null;
  downstreamMediaFormat=null;
  downstreamPositionUs=positionUs;
  lastSeekPositionUs=positionUs;
  restartFrom(positionUs);
}","@Override public void enable(int track,long positionUs){
  Assertions.checkState(state == STATE_PREPARED);
  Assertions.checkState(track == 0);
  state=STATE_ENABLED;
  chunkSource.enable();
  loadControl.register(this,bufferSizeContribution);
  downstreamFormat=null;
  downstreamMediaFormat=null;
  downstreamPositionUs=positionUs;
  lastSeekPositionUs=positionUs;
  pendingDiscontinuity=false;
  restartFrom(positionUs);
}",0.9634146341463414
110442,"@Override public void seekToUs(long positionUs){
  Assertions.checkState(state == STATE_ENABLED);
  lastSeekPositionUs=positionUs;
  if ((isPendingReset() ? pendingResetPositionUs : downstreamPositionUs) == positionUs) {
    return;
  }
  downstreamPositionUs=positionUs;
  boolean seekInsideBuffer=!isPendingReset() && sampleQueue.skipToKeyframeBefore(positionUs);
  if (seekInsideBuffer) {
    boolean haveSamples=!sampleQueue.isEmpty();
    while (haveSamples && mediaChunks.size() > 1 && mediaChunks.get(1).getFirstSampleIndex() <= sampleQueue.getReadIndex()) {
      mediaChunks.removeFirst();
    }
  }
 else {
    restartFrom(positionUs);
  }
  pendingDiscontinuity=true;
}","@Override public void seekToUs(long positionUs){
  Assertions.checkState(state == STATE_ENABLED);
  long currentPositionUs=isPendingReset() ? pendingResetPositionUs : downstreamPositionUs;
  downstreamPositionUs=positionUs;
  lastSeekPositionUs=positionUs;
  if (currentPositionUs == positionUs) {
    return;
  }
  boolean seekInsideBuffer=!isPendingReset() && sampleQueue.skipToKeyframeBefore(positionUs);
  if (seekInsideBuffer) {
    boolean haveSamples=!sampleQueue.isEmpty();
    while (haveSamples && mediaChunks.size() > 1 && mediaChunks.get(1).getFirstSampleIndex() <= sampleQueue.getReadIndex()) {
      mediaChunks.removeFirst();
    }
  }
 else {
    restartFrom(positionUs);
  }
  pendingDiscontinuity=true;
}",0.8273894436519258
110443,"@Override public void disable(int track){
  Assertions.checkState(state == STATE_ENABLED);
  Assertions.checkState(track == 0);
  pendingDiscontinuity=false;
  state=STATE_PREPARED;
  try {
    chunkSource.disable(mediaChunks);
  }
  finally {
    loadControl.unregister(this);
    if (loader.isLoading()) {
      loader.cancelLoading();
    }
 else {
      sampleQueue.clear();
      mediaChunks.clear();
      clearCurrentLoadable();
      loadControl.trimAllocator();
    }
  }
}","@Override public void disable(int track){
  Assertions.checkState(state == STATE_ENABLED);
  Assertions.checkState(track == 0);
  state=STATE_PREPARED;
  try {
    chunkSource.disable(mediaChunks);
  }
  finally {
    loadControl.unregister(this);
    if (loader.isLoading()) {
      loader.cancelLoading();
    }
 else {
      sampleQueue.clear();
      mediaChunks.clear();
      clearCurrentLoadable();
      loadControl.trimAllocator();
    }
  }
}",0.9678800856531048
110444,"@Override public void enable(int track,long positionUs){
  Assertions.checkState(prepared);
  Assertions.checkState(!trackEnabledStates[track]);
  enabledTrackCount++;
  trackEnabledStates[track]=true;
  pendingMediaFormat[track]=true;
  if (enabledTrackCount == 1) {
    seekToUs(positionUs);
  }
}","@Override public void enable(int track,long positionUs){
  Assertions.checkState(prepared);
  Assertions.checkState(!trackEnabledStates[track]);
  enabledTrackCount++;
  trackEnabledStates[track]=true;
  pendingMediaFormat[track]=true;
  if (enabledTrackCount == 1) {
    seekToUs(positionUs);
  }
  pendingDiscontinuities[track]=false;
}",0.9387755102040816
110445,"@Override public void seekToUs(long positionUs){
  Assertions.checkState(prepared);
  Assertions.checkState(enabledTrackCount > 0);
  if (!seekMap.isSeekable()) {
    positionUs=0;
  }
  lastSeekPositionUs=positionUs;
  if ((isPendingReset() ? pendingResetPositionUs : downstreamPositionUs) == positionUs) {
    return;
  }
  downstreamPositionUs=positionUs;
  boolean seekInsideBuffer=!isPendingReset();
  for (int i=0; seekInsideBuffer && i < sampleQueues.size(); i++) {
    seekInsideBuffer&=sampleQueues.valueAt(i).skipToKeyframeBefore(positionUs);
  }
  if (!seekInsideBuffer) {
    restartFrom(positionUs);
  }
  for (int i=0; i < pendingDiscontinuities.length; i++) {
    pendingDiscontinuities[i]=true;
  }
}","@Override public void seekToUs(long positionUs){
  Assertions.checkState(prepared);
  Assertions.checkState(enabledTrackCount > 0);
  if (!seekMap.isSeekable()) {
    positionUs=0;
  }
  long currentPositionUs=isPendingReset() ? pendingResetPositionUs : downstreamPositionUs;
  downstreamPositionUs=positionUs;
  lastSeekPositionUs=positionUs;
  if (currentPositionUs == positionUs) {
    return;
  }
  boolean seekInsideBuffer=!isPendingReset();
  for (int i=0; seekInsideBuffer && i < sampleQueues.size(); i++) {
    seekInsideBuffer&=sampleQueues.valueAt(i).skipToKeyframeBefore(positionUs);
  }
  if (!seekInsideBuffer) {
    restartFrom(positionUs);
  }
  for (int i=0; i < pendingDiscontinuities.length; i++) {
    pendingDiscontinuities[i]=true;
  }
}",0.8900949796472184
110446,"@Override public void disable(int track){
  Assertions.checkState(prepared);
  Assertions.checkState(trackEnabledStates[track]);
  enabledTrackCount--;
  trackEnabledStates[track]=false;
  pendingDiscontinuities[track]=false;
  if (enabledTrackCount == 0) {
    if (loader.isLoading()) {
      loader.cancelLoading();
    }
 else {
      clearState();
      allocator.trim(0);
    }
  }
}","@Override public void disable(int track){
  Assertions.checkState(prepared);
  Assertions.checkState(trackEnabledStates[track]);
  enabledTrackCount--;
  trackEnabledStates[track]=false;
  if (enabledTrackCount == 0) {
    downstreamPositionUs=Long.MIN_VALUE;
    if (loader.isLoading()) {
      loader.cancelLoading();
    }
 else {
      clearState();
      allocator.trim(0);
    }
  }
}",0.897172236503856
110447,"@Override public void enable(int track,long positionUs){
  Assertions.checkState(prepared);
  Assertions.checkState(!trackEnabledStates[track]);
  enabledTrackCount++;
  trackEnabledStates[track]=true;
  downstreamMediaFormats[track]=null;
  downstreamFormat=null;
  if (!loadControlRegistered) {
    loadControl.register(this,bufferSizeContribution);
    loadControlRegistered=true;
  }
  if (enabledTrackCount == 1) {
    seekToUs(positionUs);
  }
}","@Override public void enable(int track,long positionUs){
  Assertions.checkState(prepared);
  Assertions.checkState(!trackEnabledStates[track]);
  enabledTrackCount++;
  trackEnabledStates[track]=true;
  downstreamMediaFormats[track]=null;
  downstreamFormat=null;
  if (!loadControlRegistered) {
    loadControl.register(this,bufferSizeContribution);
    loadControlRegistered=true;
  }
  if (enabledTrackCount == 1) {
    seekToUs(positionUs);
  }
  pendingDiscontinuities[track]=false;
}",0.9585547290116896
110448,"@Override public void seekToUs(long positionUs){
  Assertions.checkState(prepared);
  Assertions.checkState(enabledTrackCount > 0);
  lastSeekPositionUs=positionUs;
  if ((isPendingReset() ? pendingResetPositionUs : downstreamPositionUs) == positionUs) {
    return;
  }
  downstreamPositionUs=positionUs;
  for (int i=0; i < pendingDiscontinuities.length; i++) {
    pendingDiscontinuities[i]=true;
  }
  restartFrom(positionUs);
}","@Override public void seekToUs(long positionUs){
  Assertions.checkState(prepared);
  Assertions.checkState(enabledTrackCount > 0);
  long currentPositionUs=isPendingReset() ? pendingResetPositionUs : downstreamPositionUs;
  downstreamPositionUs=positionUs;
  lastSeekPositionUs=positionUs;
  if (currentPositionUs == positionUs) {
    return;
  }
  downstreamPositionUs=positionUs;
  for (int i=0; i < pendingDiscontinuities.length; i++) {
    pendingDiscontinuities[i]=true;
  }
  restartFrom(positionUs);
}",0.7778958554729012
110449,"@Override public void disable(int track){
  Assertions.checkState(prepared);
  Assertions.checkState(trackEnabledStates[track]);
  enabledTrackCount--;
  trackEnabledStates[track]=false;
  pendingDiscontinuities[track]=false;
  if (enabledTrackCount == 0) {
    if (loadControlRegistered) {
      loadControl.unregister(this);
      loadControlRegistered=false;
    }
    if (loader.isLoading()) {
      loader.cancelLoading();
    }
 else {
      clearState();
      loadControl.trimAllocator();
    }
  }
}","@Override public void disable(int track){
  Assertions.checkState(prepared);
  Assertions.checkState(trackEnabledStates[track]);
  enabledTrackCount--;
  trackEnabledStates[track]=false;
  if (enabledTrackCount == 0) {
    downstreamPositionUs=Long.MIN_VALUE;
    if (loadControlRegistered) {
      loadControl.unregister(this);
      loadControlRegistered=false;
    }
    if (loader.isLoading()) {
      loader.cancelLoading();
    }
 else {
      clearState();
      loadControl.trimAllocator();
    }
  }
}",0.6797642436149313
110450,"@Override public void onLoadError(Loadable loadable,IOException e){
  if (chunkSource.onChunkLoadError(currentLoadable,e)) {
    clearCurrentLoadable();
  }
 else {
    currentLoadableException=e;
    currentLoadableExceptionCount++;
    currentLoadableExceptionTimestamp=SystemClock.elapsedRealtime();
  }
  notifyLoadError(e);
  maybeStartLoading();
}","@Override public void onLoadError(Loadable loadable,IOException e){
  if (chunkSource.onChunkLoadError(currentLoadable,e)) {
    if (previousTsLoadable == null && !isPendingReset()) {
      pendingResetPositionUs=currentTsLoadable.startTimeUs;
    }
    clearCurrentLoadable();
  }
 else {
    currentLoadableException=e;
    currentLoadableExceptionCount++;
    currentLoadableExceptionTimestamp=SystemClock.elapsedRealtime();
  }
  notifyLoadError(e);
  maybeStartLoading();
}",0.8495788206979543
110451,"/** 
 * Checks two adaptation set types for consistency, returning the consistent type, or throwing an  {@link IllegalStateException} if the types are inconsistent.<p> Two types are consistent if they are equal, or if one is  {@link AdaptationSet#TYPE_UNKNOWN}. Where one of the types is   {@link AdaptationSet#TYPE_UNKNOWN}, the other is returned.
 * @param firstType The first type.
 * @param secondType The second type.
 * @return The consistent type.
 */
private int checkAdaptationSetTypeConsistency(int firstType,int secondType){
  if (firstType == AdaptationSet.TYPE_UNKNOWN) {
    return secondType;
  }
 else   if (secondType == AdaptationSet.TYPE_UNKNOWN) {
    return firstType;
  }
 else {
    Assertions.checkState(firstType == secondType);
    return firstType;
  }
}","/** 
 * Checks two adaptation set types for consistency, returning the consistent type, or throwing an  {@link IllegalStateException} if the types are inconsistent.<p> Two types are consistent if they are equal, or if one is  {@link AdaptationSet#TYPE_UNKNOWN}. Where one of the types is   {@link AdaptationSet#TYPE_UNKNOWN}, the other is returned.
 * @param firstType The first type.
 * @param secondType The second type.
 * @return The consistent type.
 */
private static int checkAdaptationSetTypeConsistency(int firstType,int secondType){
  if (firstType == AdaptationSet.TYPE_UNKNOWN) {
    return secondType;
  }
 else   if (secondType == AdaptationSet.TYPE_UNKNOWN) {
    return firstType;
  }
 else {
    Assertions.checkState(firstType == secondType);
    return firstType;
  }
}",0.9955385595920968
110452,"protected AdaptationSet parseAdaptationSet(XmlPullParser xpp,String baseUrl,long periodStartMs,long periodDurationMs,SegmentBase segmentBase) throws XmlPullParserException, IOException {
  String mimeType=xpp.getAttributeValue(null,""String_Node_Str"");
  String language=xpp.getAttributeValue(null,""String_Node_Str"");
  int contentType=parseAdaptationSetTypeFromMimeType(mimeType);
  int id=-1;
  ContentProtectionsBuilder contentProtectionsBuilder=new ContentProtectionsBuilder();
  List<Representation> representations=new ArrayList<>();
  do {
    xpp.next();
    if (isStartTag(xpp,""String_Node_Str"")) {
      baseUrl=parseBaseUrl(xpp,baseUrl);
    }
 else     if (isStartTag(xpp,""String_Node_Str"")) {
      contentProtectionsBuilder.addAdaptationSetProtection(parseContentProtection(xpp));
    }
 else     if (isStartTag(xpp,""String_Node_Str"")) {
      id=Integer.parseInt(xpp.getAttributeValue(null,""String_Node_Str""));
      contentType=checkAdaptationSetTypeConsistency(contentType,parseAdaptationSetType(xpp.getAttributeValue(null,""String_Node_Str"")));
    }
 else     if (isStartTag(xpp,""String_Node_Str"")) {
      Representation representation=parseRepresentation(xpp,baseUrl,periodStartMs,periodDurationMs,mimeType,language,segmentBase,contentProtectionsBuilder);
      contentProtectionsBuilder.endRepresentation();
      contentType=checkAdaptationSetTypeConsistency(contentType,parseAdaptationSetTypeFromMimeType(representation.format.mimeType));
      representations.add(representation);
    }
 else     if (isStartTag(xpp,""String_Node_Str"")) {
      segmentBase=parseSegmentBase(xpp,baseUrl,(SingleSegmentBase)segmentBase);
    }
 else     if (isStartTag(xpp,""String_Node_Str"")) {
      segmentBase=parseSegmentList(xpp,baseUrl,(SegmentList)segmentBase,periodDurationMs);
    }
 else     if (isStartTag(xpp,""String_Node_Str"")) {
      segmentBase=parseSegmentTemplate(xpp,baseUrl,(SegmentTemplate)segmentBase,periodDurationMs);
    }
 else     if (isStartTag(xpp)) {
      parseAdaptationSetChild(xpp);
    }
  }
 while (!isEndTag(xpp,""String_Node_Str""));
  return buildAdaptationSet(id,contentType,representations,contentProtectionsBuilder.build());
}","protected AdaptationSet parseAdaptationSet(XmlPullParser xpp,String baseUrl,long periodStartMs,long periodDurationMs,SegmentBase segmentBase) throws XmlPullParserException, IOException {
  int id=parseInt(xpp,""String_Node_Str"",-1);
  String mimeType=xpp.getAttributeValue(null,""String_Node_Str"");
  String language=xpp.getAttributeValue(null,""String_Node_Str"");
  int contentType=parseAdaptationSetType(xpp.getAttributeValue(null,""String_Node_Str""));
  if (contentType == AdaptationSet.TYPE_UNKNOWN) {
    contentType=parseAdaptationSetTypeFromMimeType(xpp.getAttributeValue(null,""String_Node_Str""));
  }
  ContentProtectionsBuilder contentProtectionsBuilder=new ContentProtectionsBuilder();
  List<Representation> representations=new ArrayList<>();
  do {
    xpp.next();
    if (isStartTag(xpp,""String_Node_Str"")) {
      baseUrl=parseBaseUrl(xpp,baseUrl);
    }
 else     if (isStartTag(xpp,""String_Node_Str"")) {
      contentProtectionsBuilder.addAdaptationSetProtection(parseContentProtection(xpp));
    }
 else     if (isStartTag(xpp,""String_Node_Str"")) {
      language=checkLanguageConsistency(language,xpp.getAttributeValue(null,""String_Node_Str""));
      contentType=checkAdaptationSetTypeConsistency(contentType,parseAdaptationSetType(xpp.getAttributeValue(null,""String_Node_Str"")));
    }
 else     if (isStartTag(xpp,""String_Node_Str"")) {
      Representation representation=parseRepresentation(xpp,baseUrl,periodStartMs,periodDurationMs,mimeType,language,segmentBase,contentProtectionsBuilder);
      contentProtectionsBuilder.endRepresentation();
      contentType=checkAdaptationSetTypeConsistency(contentType,parseAdaptationSetTypeFromMimeType(representation.format.mimeType));
      representations.add(representation);
    }
 else     if (isStartTag(xpp,""String_Node_Str"")) {
      segmentBase=parseSegmentBase(xpp,baseUrl,(SingleSegmentBase)segmentBase);
    }
 else     if (isStartTag(xpp,""String_Node_Str"")) {
      segmentBase=parseSegmentList(xpp,baseUrl,(SegmentList)segmentBase,periodDurationMs);
    }
 else     if (isStartTag(xpp,""String_Node_Str"")) {
      segmentBase=parseSegmentTemplate(xpp,baseUrl,(SegmentTemplate)segmentBase,periodDurationMs);
    }
 else     if (isStartTag(xpp)) {
      parseAdaptationSetChild(xpp);
    }
  }
 while (!isEndTag(xpp,""String_Node_Str""));
  return buildAdaptationSet(id,contentType,representations,contentProtectionsBuilder.build());
}",0.8608923884514436
110453,"/** 
 * Parses an AudioSpecificConfig, as defined in ISO 14496-3 1.6.2.1
 * @param audioSpecificConfig The AudioSpecificConfig to parse.
 * @return A pair consisting of the sample rate in Hz and the channel count.
 */
public static Pair<Integer,Integer> parseAudioSpecificConfig(byte[] audioSpecificConfig){
  int audioObjectType=(audioSpecificConfig[0] >> 3) & 0x1F;
  if (audioObjectType < 31) {
    int byteOffset=audioObjectType == 5 || audioObjectType == 29 ? 1 : 0;
    int frequencyIndex=(audioSpecificConfig[byteOffset] & 0x7) << 1 | ((audioSpecificConfig[byteOffset + 1] >> 7) & 0x1);
    Assertions.checkState(frequencyIndex < 13);
    int sampleRate=AUDIO_SPECIFIC_CONFIG_SAMPLING_RATE_TABLE[frequencyIndex];
    int channelCount=(audioSpecificConfig[byteOffset + 1] >> 3) & 0xF;
    return Pair.create(sampleRate,channelCount);
  }
 else {
    int frequencyIndex=(audioSpecificConfig[1] & 0x1E) >> 1;
    Assertions.checkState(frequencyIndex < 13);
    int sampleRate=AUDIO_SPECIFIC_CONFIG_SAMPLING_RATE_TABLE[frequencyIndex];
    int channelCount=(audioSpecificConfig[1] & 0x01) << 2 | ((audioSpecificConfig[2] >> 6) & 0x03);
    return Pair.create(sampleRate,channelCount);
  }
}","/** 
 * Parses an AudioSpecificConfig, as defined in ISO 14496-3 1.6.2.1
 * @param audioSpecificConfig The AudioSpecificConfig to parse.
 * @return A pair consisting of the sample rate in Hz and the channel count.
 */
public static Pair<Integer,Integer> parseAudioSpecificConfig(byte[] audioSpecificConfig){
  int audioObjectType=(audioSpecificConfig[0] >> 3) & 0x1F;
  if (audioObjectType < 31) {
    int byteOffset=audioObjectType == 5 || audioObjectType == 29 ? 1 : 0;
    int frequencyIndex=(audioSpecificConfig[byteOffset] & 0x7) << 1 | ((audioSpecificConfig[byteOffset + 1] >> 7) & 0x1);
    Assertions.checkState(frequencyIndex < 13);
    int sampleRate=AUDIO_SPECIFIC_CONFIG_SAMPLING_RATE_TABLE[frequencyIndex];
    int channelCount=AUDIO_SPECIFIC_CONFIG_CHANNEL_COUNT_TABLE[(audioSpecificConfig[byteOffset + 1] >> 3) & 0xF];
    return Pair.create(sampleRate,channelCount);
  }
 else {
    int frequencyIndex=(audioSpecificConfig[1] & 0x1E) >> 1;
    Assertions.checkState(frequencyIndex < 13);
    int sampleRate=AUDIO_SPECIFIC_CONFIG_SAMPLING_RATE_TABLE[frequencyIndex];
    int channelCount=AUDIO_SPECIFIC_CONFIG_CHANNEL_COUNT_TABLE[(audioSpecificConfig[1] & 0x01) << 3 | ((audioSpecificConfig[2] >> 5) & 0x07)];
    return Pair.create(sampleRate,channelCount);
  }
}",0.7605177993527508
110454,"@Override public void continueBuffering(long playbackPositionUs){
  if (manifestFetcher == null || !currentManifest.dynamic || fatalError != null) {
    return;
  }
  MediaPresentationDescription newManifest=manifestFetcher.getManifest();
  if (currentManifest != newManifest && newManifest != null) {
    Representation[] newRepresentations=DashChunkSource.getFilteredRepresentations(newManifest,adaptationSetIndex,representationIndices);
    for (    Representation representation : newRepresentations) {
      RepresentationHolder representationHolder=representationHolders.get(representation.format.id);
      DashSegmentIndex oldIndex=representationHolder.segmentIndex;
      DashSegmentIndex newIndex=representation.getIndex();
      int newFirstSegmentNum=newIndex.getFirstSegmentNum();
      int segmentNumShift=oldIndex.getSegmentNum(newIndex.getTimeUs(newFirstSegmentNum)) - newFirstSegmentNum;
      representationHolder.segmentNumShift+=segmentNumShift;
      representationHolder.segmentIndex=newIndex;
    }
    currentManifest=newManifest;
    finishedCurrentManifest=false;
    long nowUs=getNowUs();
    updateAvailableSegmentBounds(newRepresentations[0].getIndex(),nowUs);
    updateSeekRange(newRepresentations[0].getIndex(),nowUs);
  }
  long minUpdatePeriod=currentManifest.minUpdatePeriod;
  if (minUpdatePeriod == 0) {
    minUpdatePeriod=5000;
  }
  if (finishedCurrentManifest && (android.os.SystemClock.elapsedRealtime() > manifestFetcher.getManifestLoadTimestamp() + minUpdatePeriod)) {
    manifestFetcher.requestRefresh();
  }
}","@Override public void continueBuffering(long playbackPositionUs){
  if (manifestFetcher == null || !currentManifest.dynamic || fatalError != null) {
    return;
  }
  MediaPresentationDescription newManifest=manifestFetcher.getManifest();
  if (currentManifest != newManifest && newManifest != null) {
    Representation[] newRepresentations=DashChunkSource.getFilteredRepresentations(newManifest,adaptationSetIndex,representationIndices);
    for (    Representation representation : newRepresentations) {
      RepresentationHolder representationHolder=representationHolders.get(representation.format.id);
      DashSegmentIndex oldIndex=representationHolder.segmentIndex;
      int oldIndexLastSegmentNum=oldIndex.getLastSegmentNum();
      long oldIndexEndTimeUs=oldIndex.getTimeUs(oldIndexLastSegmentNum) + oldIndex.getDurationUs(oldIndexLastSegmentNum);
      DashSegmentIndex newIndex=representation.getIndex();
      int newIndexFirstSegmentNum=newIndex.getFirstSegmentNum();
      long newIndexStartTimeUs=newIndex.getTimeUs(newIndexFirstSegmentNum);
      if (oldIndexEndTimeUs < newIndexStartTimeUs) {
        fatalError=new BehindLiveWindowException();
        return;
      }
      int segmentNumShift;
      if (oldIndexEndTimeUs == newIndexStartTimeUs) {
        segmentNumShift=oldIndex.getLastSegmentNum() + 1 - newIndexFirstSegmentNum;
      }
 else {
        segmentNumShift=oldIndex.getSegmentNum(newIndexStartTimeUs) - newIndexFirstSegmentNum;
      }
      representationHolder.segmentNumShift+=segmentNumShift;
      representationHolder.segmentIndex=newIndex;
    }
    currentManifest=newManifest;
    finishedCurrentManifest=false;
    long nowUs=getNowUs();
    updateAvailableSegmentBounds(newRepresentations[0].getIndex(),nowUs);
    updateSeekRange(newRepresentations[0].getIndex(),nowUs);
  }
  long minUpdatePeriod=currentManifest.minUpdatePeriod;
  if (minUpdatePeriod == 0) {
    minUpdatePeriod=5000;
  }
  if (finishedCurrentManifest && (android.os.SystemClock.elapsedRealtime() > manifestFetcher.getManifestLoadTimestamp() + minUpdatePeriod)) {
    manifestFetcher.requestRefresh();
  }
}",0.824008690928843
110455,"@Override public void continueBuffering(long playbackPositionUs){
  if (manifestFetcher == null || !currentManifest.isLive || fatalError != null) {
    return;
  }
  SmoothStreamingManifest newManifest=manifestFetcher.getManifest();
  if (currentManifest != newManifest && newManifest != null) {
    StreamElement currentElement=getElement(currentManifest);
    StreamElement newElement=getElement(newManifest);
    if (newElement.chunkCount == 0) {
      currentManifestChunkOffset+=currentElement.chunkCount;
    }
 else     if (currentElement.chunkCount > 0) {
      currentManifestChunkOffset+=currentElement.getChunkIndex(newElement.getStartTimeUs(0));
    }
    currentManifest=newManifest;
    finishedCurrentManifest=false;
  }
  if (finishedCurrentManifest && (SystemClock.elapsedRealtime() > manifestFetcher.getManifestLoadTimestamp() + MINIMUM_MANIFEST_REFRESH_PERIOD_MS)) {
    manifestFetcher.requestRefresh();
  }
}","@Override public void continueBuffering(long playbackPositionUs){
  if (manifestFetcher == null || !currentManifest.isLive || fatalError != null) {
    return;
  }
  SmoothStreamingManifest newManifest=manifestFetcher.getManifest();
  if (currentManifest != newManifest && newManifest != null) {
    StreamElement currentElement=getElement(currentManifest);
    int currentElementChunkCount=currentElement.chunkCount;
    StreamElement newElement=getElement(newManifest);
    if (currentElementChunkCount == 0 || newElement.chunkCount == 0) {
      currentManifestChunkOffset+=currentElementChunkCount;
    }
 else {
      long currentElementEndTimeUs=currentElement.getStartTimeUs(currentElementChunkCount - 1) + currentElement.getChunkDurationUs(currentElementChunkCount - 1);
      long newElementStartTimeUs=newElement.getStartTimeUs(0);
      if (currentElementEndTimeUs <= newElementStartTimeUs) {
        currentManifestChunkOffset+=currentElementChunkCount;
      }
 else {
        currentManifestChunkOffset+=currentElement.getChunkIndex(newElementStartTimeUs);
      }
    }
    currentManifest=newManifest;
    finishedCurrentManifest=false;
  }
  if (finishedCurrentManifest && (SystemClock.elapsedRealtime() > manifestFetcher.getManifestLoadTimestamp() + MINIMUM_MANIFEST_REFRESH_PERIOD_MS)) {
    manifestFetcher.requestRefresh();
  }
}",0.7424308907415533
110456,"/** 
 * Updates the audio track latency and playback position parameters. 
 */
private void maybeSampleSyncParams(){
  long playbackPositionUs=audioTrackUtil.getPlaybackHeadPositionUs();
  if (playbackPositionUs == 0) {
    return;
  }
  long systemClockUs=System.nanoTime() / 1000;
  if (systemClockUs - lastPlayheadSampleTimeUs >= MIN_PLAYHEAD_OFFSET_SAMPLE_INTERVAL_US) {
    playheadOffsets[nextPlayheadOffsetIndex]=playbackPositionUs - systemClockUs;
    nextPlayheadOffsetIndex=(nextPlayheadOffsetIndex + 1) % MAX_PLAYHEAD_OFFSET_COUNT;
    if (playheadOffsetCount < MAX_PLAYHEAD_OFFSET_COUNT) {
      playheadOffsetCount++;
    }
    lastPlayheadSampleTimeUs=systemClockUs;
    smoothedPlayheadOffsetUs=0;
    for (int i=0; i < playheadOffsetCount; i++) {
      smoothedPlayheadOffsetUs+=playheadOffsets[i] / playheadOffsetCount;
    }
  }
  if (systemClockUs - lastTimestampSampleTimeUs >= MIN_TIMESTAMP_SAMPLE_INTERVAL_US) {
    audioTimestampSet=audioTrackUtil.updateTimestamp();
    if (audioTimestampSet) {
      long audioTimestampUs=audioTrackUtil.getTimestampNanoTime() / 1000;
      long audioTimestampFramePosition=audioTrackUtil.getTimestampFramePosition();
      if (audioTimestampUs < resumeSystemTimeUs) {
        audioTimestampSet=false;
      }
 else       if (Math.abs(audioTimestampUs - systemClockUs) > MAX_AUDIO_TIMESTAMP_OFFSET_US) {
        audioTimestampSet=false;
        Log.w(TAG,""String_Node_Str"" + audioTimestampFramePosition + ""String_Node_Str""+ audioTimestampUs+ ""String_Node_Str""+ systemClockUs+ ""String_Node_Str""+ playbackPositionUs);
      }
 else       if (Math.abs(framesToDurationUs(audioTimestampFramePosition) - playbackPositionUs) > MAX_AUDIO_TIMESTAMP_OFFSET_US) {
        audioTimestampSet=false;
        Log.w(TAG,""String_Node_Str"" + audioTimestampFramePosition + ""String_Node_Str""+ audioTimestampUs+ ""String_Node_Str""+ systemClockUs+ ""String_Node_Str""+ playbackPositionUs);
      }
    }
    if (getLatencyMethod != null) {
      try {
        latencyUs=(Integer)getLatencyMethod.invoke(audioTrack,(Object[])null) * 1000L - framesToDurationUs(bytesToFrames(bufferSize));
        latencyUs=Math.max(latencyUs,0);
        if (latencyUs > MAX_LATENCY_US) {
          Log.w(TAG,""String_Node_Str"" + latencyUs);
          latencyUs=0;
        }
      }
 catch (      Exception e) {
        getLatencyMethod=null;
      }
    }
    lastTimestampSampleTimeUs=systemClockUs;
  }
}","/** 
 * Updates the audio track latency and playback position parameters. 
 */
private void maybeSampleSyncParams(){
  long playbackPositionUs=audioTrackUtil.getPlaybackHeadPositionUs();
  if (playbackPositionUs == 0) {
    return;
  }
  long systemClockUs=System.nanoTime() / 1000;
  if (systemClockUs - lastPlayheadSampleTimeUs >= MIN_PLAYHEAD_OFFSET_SAMPLE_INTERVAL_US) {
    playheadOffsets[nextPlayheadOffsetIndex]=playbackPositionUs - systemClockUs;
    nextPlayheadOffsetIndex=(nextPlayheadOffsetIndex + 1) % MAX_PLAYHEAD_OFFSET_COUNT;
    if (playheadOffsetCount < MAX_PLAYHEAD_OFFSET_COUNT) {
      playheadOffsetCount++;
    }
    lastPlayheadSampleTimeUs=systemClockUs;
    smoothedPlayheadOffsetUs=0;
    for (int i=0; i < playheadOffsetCount; i++) {
      smoothedPlayheadOffsetUs+=playheadOffsets[i] / playheadOffsetCount;
    }
  }
  if (systemClockUs - lastTimestampSampleTimeUs >= MIN_TIMESTAMP_SAMPLE_INTERVAL_US) {
    audioTimestampSet=!isAc3 && audioTrackUtil.updateTimestamp();
    if (audioTimestampSet) {
      long audioTimestampUs=audioTrackUtil.getTimestampNanoTime() / 1000;
      long audioTimestampFramePosition=audioTrackUtil.getTimestampFramePosition();
      if (audioTimestampUs < resumeSystemTimeUs) {
        audioTimestampSet=false;
      }
 else       if (Math.abs(audioTimestampUs - systemClockUs) > MAX_AUDIO_TIMESTAMP_OFFSET_US) {
        audioTimestampSet=false;
        Log.w(TAG,""String_Node_Str"" + audioTimestampFramePosition + ""String_Node_Str""+ audioTimestampUs+ ""String_Node_Str""+ systemClockUs+ ""String_Node_Str""+ playbackPositionUs);
      }
 else       if (Math.abs(framesToDurationUs(audioTimestampFramePosition) - playbackPositionUs) > MAX_AUDIO_TIMESTAMP_OFFSET_US) {
        audioTimestampSet=false;
        Log.w(TAG,""String_Node_Str"" + audioTimestampFramePosition + ""String_Node_Str""+ audioTimestampUs+ ""String_Node_Str""+ systemClockUs+ ""String_Node_Str""+ playbackPositionUs);
      }
    }
    if (getLatencyMethod != null) {
      try {
        latencyUs=(Integer)getLatencyMethod.invoke(audioTrack,(Object[])null) * 1000L - framesToDurationUs(bytesToFrames(bufferSize));
        latencyUs=Math.max(latencyUs,0);
        if (latencyUs > MAX_LATENCY_US) {
          Log.w(TAG,""String_Node_Str"" + latencyUs);
          latencyUs=0;
        }
      }
 catch (      Exception e) {
        getLatencyMethod=null;
      }
    }
    lastTimestampSampleTimeUs=systemClockUs;
  }
}",0.997938994229184
110457,"/** 
 * Attempts to write   {@code size} bytes from {@code buffer} at {@code offset} to the audio track.Returns a bit field containing  {@link #RESULT_BUFFER_CONSUMED} if the buffer can be released(due to having been written), and  {@link #RESULT_POSITION_DISCONTINUITY} if the buffer wasdiscontinuous with previously written data.
 * @param buffer The buffer containing audio data to play back.
 * @param offset The offset in the buffer from which to consume data.
 * @param size The number of bytes to consume from {@code buffer}.
 * @param presentationTimeUs Presentation timestamp of the next buffer in microseconds.
 * @return A bit field with {@link #RESULT_BUFFER_CONSUMED} if the buffer can be released, and{@link #RESULT_POSITION_DISCONTINUITY} if the buffer was not contiguous with previouslywritten data.
 * @throws WriteException If an error occurs writing the audio data.
 */
public int handleBuffer(ByteBuffer buffer,int offset,int size,long presentationTimeUs) throws WriteException {
  if (size == 0) {
    return RESULT_BUFFER_CONSUMED;
  }
  if (Util.SDK_INT <= 22 && isAc3 && audioTrack.getPlayState() == android.media.AudioTrack.PLAYSTATE_PAUSED) {
    return 0;
  }
  int result=0;
  if (temporaryBufferSize == 0) {
    if (isAc3 && ac3Bitrate == UNKNOWN_AC3_BITRATE) {
      ac3Bitrate=Ac3Util.getBitrate(size,sampleRate);
    }
    long bufferStartTime=presentationTimeUs - framesToDurationUs(bytesToFrames(size));
    if (startMediaTimeUs == START_NOT_SET) {
      startMediaTimeUs=Math.max(0,bufferStartTime);
      startMediaTimeState=START_IN_SYNC;
    }
 else {
      long expectedBufferStartTime=startMediaTimeUs + framesToDurationUs(bytesToFrames(submittedBytes));
      if (startMediaTimeState == START_IN_SYNC && Math.abs(expectedBufferStartTime - bufferStartTime) > 200000) {
        Log.e(TAG,""String_Node_Str"" + expectedBufferStartTime + ""String_Node_Str""+ bufferStartTime+ ""String_Node_Str"");
        startMediaTimeState=START_NEED_SYNC;
      }
      if (startMediaTimeState == START_NEED_SYNC) {
        startMediaTimeUs+=(bufferStartTime - expectedBufferStartTime);
        startMediaTimeState=START_IN_SYNC;
        result|=RESULT_POSITION_DISCONTINUITY;
      }
    }
  }
  if (temporaryBufferSize == 0) {
    temporaryBufferSize=size;
    buffer.position(offset);
    if (Util.SDK_INT < 21) {
      if (temporaryBuffer == null || temporaryBuffer.length < size) {
        temporaryBuffer=new byte[size];
      }
      buffer.get(temporaryBuffer,0,size);
      temporaryBufferOffset=0;
    }
  }
  int bytesWritten=0;
  if (Util.SDK_INT < 21) {
    int bytesPending=(int)(submittedBytes - (audioTrackUtil.getPlaybackHeadPosition() * frameSize));
    int bytesToWrite=bufferSize - bytesPending;
    if (bytesToWrite > 0) {
      bytesToWrite=Math.min(temporaryBufferSize,bytesToWrite);
      bytesWritten=audioTrack.write(temporaryBuffer,temporaryBufferOffset,bytesToWrite);
      if (bytesWritten >= 0) {
        temporaryBufferOffset+=bytesWritten;
      }
    }
  }
 else {
    bytesWritten=writeNonBlockingV21(audioTrack,buffer,temporaryBufferSize);
  }
  if (bytesWritten < 0) {
    throw new WriteException(bytesWritten);
  }
  temporaryBufferSize-=bytesWritten;
  submittedBytes+=bytesWritten;
  if (temporaryBufferSize == 0) {
    result|=RESULT_BUFFER_CONSUMED;
  }
  return result;
}","/** 
 * Attempts to write   {@code size} bytes from {@code buffer} at {@code offset} to the audio track.Returns a bit field containing  {@link #RESULT_BUFFER_CONSUMED} if the buffer can be released(due to having been written), and  {@link #RESULT_POSITION_DISCONTINUITY} if the buffer wasdiscontinuous with previously written data.
 * @param buffer The buffer containing audio data to play back.
 * @param offset The offset in the buffer from which to consume data.
 * @param size The number of bytes to consume from {@code buffer}.
 * @param presentationTimeUs Presentation timestamp of the next buffer in microseconds.
 * @return A bit field with {@link #RESULT_BUFFER_CONSUMED} if the buffer can be released, and{@link #RESULT_POSITION_DISCONTINUITY} if the buffer was not contiguous with previouslywritten data.
 * @throws WriteException If an error occurs writing the audio data.
 */
public int handleBuffer(ByteBuffer buffer,int offset,int size,long presentationTimeUs) throws WriteException {
  if (size == 0) {
    return RESULT_BUFFER_CONSUMED;
  }
  if (Util.SDK_INT <= 22 && isAc3) {
    if (audioTrack.getPlayState() == android.media.AudioTrack.PLAYSTATE_PAUSED) {
      return 0;
    }
    if (audioTrack.getPlayState() == android.media.AudioTrack.PLAYSTATE_STOPPED && audioTrackUtil.getPlaybackHeadPosition() != 0) {
      return 0;
    }
  }
  int result=0;
  if (temporaryBufferSize == 0) {
    if (isAc3 && ac3Bitrate == UNKNOWN_AC3_BITRATE) {
      ac3Bitrate=Ac3Util.getBitrate(size,sampleRate);
    }
    long bufferStartTime=presentationTimeUs - framesToDurationUs(bytesToFrames(size));
    if (startMediaTimeUs == START_NOT_SET) {
      startMediaTimeUs=Math.max(0,bufferStartTime);
      startMediaTimeState=START_IN_SYNC;
    }
 else {
      long expectedBufferStartTime=startMediaTimeUs + framesToDurationUs(bytesToFrames(submittedBytes));
      if (startMediaTimeState == START_IN_SYNC && Math.abs(expectedBufferStartTime - bufferStartTime) > 200000) {
        Log.e(TAG,""String_Node_Str"" + expectedBufferStartTime + ""String_Node_Str""+ bufferStartTime+ ""String_Node_Str"");
        startMediaTimeState=START_NEED_SYNC;
      }
      if (startMediaTimeState == START_NEED_SYNC) {
        startMediaTimeUs+=(bufferStartTime - expectedBufferStartTime);
        startMediaTimeState=START_IN_SYNC;
        result|=RESULT_POSITION_DISCONTINUITY;
      }
    }
  }
  if (temporaryBufferSize == 0) {
    temporaryBufferSize=size;
    buffer.position(offset);
    if (Util.SDK_INT < 21) {
      if (temporaryBuffer == null || temporaryBuffer.length < size) {
        temporaryBuffer=new byte[size];
      }
      buffer.get(temporaryBuffer,0,size);
      temporaryBufferOffset=0;
    }
  }
  int bytesWritten=0;
  if (Util.SDK_INT < 21) {
    int bytesPending=(int)(submittedBytes - (audioTrackUtil.getPlaybackHeadPosition() * frameSize));
    int bytesToWrite=bufferSize - bytesPending;
    if (bytesToWrite > 0) {
      bytesToWrite=Math.min(temporaryBufferSize,bytesToWrite);
      bytesWritten=audioTrack.write(temporaryBuffer,temporaryBufferOffset,bytesToWrite);
      if (bytesWritten >= 0) {
        temporaryBufferOffset+=bytesWritten;
      }
    }
  }
 else {
    bytesWritten=writeNonBlockingV21(audioTrack,buffer,temporaryBufferSize);
  }
  if (bytesWritten < 0) {
    throw new WriteException(bytesWritten);
  }
  temporaryBufferSize-=bytesWritten;
  submittedBytes+=bytesWritten;
  if (temporaryBufferSize == 0) {
    result|=RESULT_BUFFER_CONSUMED;
  }
  return result;
}",0.9739537606087212
110458,"@Override public void read(ExtractorInput input) throws IOException, InterruptedException {
  if (!input.readFully(tsPacketBuffer.data,0,TS_PACKET_SIZE)) {
    return;
  }
  tsPacketBuffer.setPosition(0);
  int syncByte=tsPacketBuffer.readUnsignedByte();
  if (syncByte != TS_SYNC_BYTE) {
    return;
  }
  tsPacketBuffer.readBytes(tsScratch,3);
  tsScratch.skipBits(1);
  boolean payloadUnitStartIndicator=tsScratch.readBit();
  tsScratch.skipBits(1);
  int pid=tsScratch.readBits(13);
  tsScratch.skipBits(2);
  boolean adaptationFieldExists=tsScratch.readBit();
  boolean payloadExists=tsScratch.readBit();
  if (adaptationFieldExists) {
    int adaptationFieldLength=tsPacketBuffer.readUnsignedByte();
    tsPacketBuffer.skip(adaptationFieldLength);
  }
  if (payloadExists) {
    TsPayloadReader payloadReader=tsPayloadReaders.get(pid);
    if (payloadReader != null) {
      payloadReader.consume(tsPacketBuffer,payloadUnitStartIndicator,output);
    }
  }
}","@Override public void read(ExtractorInput input) throws IOException, InterruptedException {
  if (!input.readFully(tsPacketBuffer.data,0,TS_PACKET_SIZE)) {
    return;
  }
  tsPacketBuffer.setPosition(0);
  tsPacketBuffer.setLimit(TS_PACKET_SIZE);
  int syncByte=tsPacketBuffer.readUnsignedByte();
  if (syncByte != TS_SYNC_BYTE) {
    return;
  }
  tsPacketBuffer.readBytes(tsScratch,3);
  tsScratch.skipBits(1);
  boolean payloadUnitStartIndicator=tsScratch.readBit();
  tsScratch.skipBits(1);
  int pid=tsScratch.readBits(13);
  tsScratch.skipBits(2);
  boolean adaptationFieldExists=tsScratch.readBit();
  boolean payloadExists=tsScratch.readBit();
  if (adaptationFieldExists) {
    int adaptationFieldLength=tsPacketBuffer.readUnsignedByte();
    tsPacketBuffer.skip(adaptationFieldLength);
  }
  if (payloadExists) {
    TsPayloadReader payloadReader=tsPayloadReaders.get(pid);
    if (payloadReader != null) {
      payloadReader.consume(tsPacketBuffer,payloadUnitStartIndicator,output);
    }
  }
}",0.97818366311517
110459,"@Override public boolean skipFully(int length) throws IOException, InterruptedException {
  int remaining=length;
  while (remaining > 0) {
    if (Thread.interrupted()) {
      throw new InterruptedException();
    }
    int bytesRead=dataSource.read(SCRATCH_SPACE,0,remaining);
    if (bytesRead == -1) {
      isEnded=true;
      return true;
    }
    remaining-=bytesRead;
  }
  position+=length;
  return false;
}","@Override public boolean skipFully(int length) throws IOException, InterruptedException {
  int remaining=length;
  while (remaining > 0) {
    if (Thread.interrupted()) {
      throw new InterruptedException();
    }
    int bytesRead=dataSource.read(SCRATCH_SPACE,0,Math.min(SCRATCH_SPACE.length,remaining));
    if (bytesRead == -1) {
      isEnded=true;
      return false;
    }
    remaining-=bytesRead;
  }
  position+=length;
  return true;
}",0.9298043728423476
110460,"private static int indexOfEOS(byte[] data,int fromIndex,int encodingByte){
  int terminationPos=indexOf(data,fromIndex,(byte)0);
  if (encodingByte == ID3_TEXT_ENCODING_ISO_8859_1 || encodingByte == ID3_TEXT_ENCODING_UTF_8) {
    return terminationPos;
  }
  while (terminationPos < data.length - 1) {
    if (data[terminationPos + 1] == (byte)0) {
      return terminationPos + 1;
    }
    terminationPos=indexOf(data,terminationPos + 1,(byte)0);
  }
  return data.length;
}","private static int indexOfEOS(byte[] data,int fromIndex,int encodingByte){
  int terminationPos=indexOf(data,fromIndex,(byte)0);
  if (encodingByte == ID3_TEXT_ENCODING_ISO_8859_1 || encodingByte == ID3_TEXT_ENCODING_UTF_8) {
    return terminationPos;
  }
  while (terminationPos < data.length - 1) {
    if (data[terminationPos + 1] == (byte)0) {
      return terminationPos;
    }
    terminationPos=indexOf(data,terminationPos + 1,(byte)0);
  }
  return data.length;
}",0.9957805907172996
110461,"@Override public Map<String,Object> parse(byte[] data,int size) throws UnsupportedEncodingException, ParserException {
  Map<String,Object> metadata=new HashMap<String,Object>();
  ParsableByteArray id3Data=new ParsableByteArray(data,size);
  int id3Size=parseId3Header(id3Data);
  while (id3Size > 0) {
    int frameId0=id3Data.readUnsignedByte();
    int frameId1=id3Data.readUnsignedByte();
    int frameId2=id3Data.readUnsignedByte();
    int frameId3=id3Data.readUnsignedByte();
    int frameSize=id3Data.readSynchSafeInt();
    if (frameSize <= 1) {
      break;
    }
    id3Data.skip(2);
    if (frameId0 == 'T' && frameId1 == 'X' && frameId2 == 'X' && frameId3 == 'X') {
      int encoding=id3Data.readUnsignedByte();
      String charset=getCharsetName(encoding);
      byte[] frame=new byte[frameSize - 1];
      id3Data.readBytes(frame,0,frameSize - 1);
      int firstZeroIndex=indexOfEOS(frame,0,encoding);
      String description=new String(frame,0,firstZeroIndex,charset);
      int valueStartIndex=firstZeroIndex + 1;
      int valueEndIndex=indexOfEOS(frame,valueStartIndex,encoding);
      String value=new String(frame,valueStartIndex,valueEndIndex - valueStartIndex,charset);
      metadata.put(TxxxMetadata.TYPE,new TxxxMetadata(description,value));
    }
 else     if (frameId0 == 'P' && frameId1 == 'R' && frameId2 == 'I' && frameId3 == 'V') {
      byte[] frame=new byte[frameSize];
      id3Data.readBytes(frame,0,frameSize);
      int firstZeroIndex=indexOf(frame,0,(byte)0);
      String owner=new String(frame,0,firstZeroIndex,""String_Node_Str"");
      byte[] privateData=new byte[frameSize - firstZeroIndex - 1];
      System.arraycopy(frame,firstZeroIndex + 1,privateData,0,frameSize - firstZeroIndex - 1);
      metadata.put(PrivMetadata.TYPE,new PrivMetadata(owner,privateData));
    }
 else     if (frameId0 == 'G' && frameId1 == 'E' && frameId2 == 'O' && frameId3 == 'B') {
      int encoding=id3Data.readUnsignedByte();
      String charset=getCharsetName(encoding);
      byte[] frame=new byte[frameSize - 1];
      id3Data.readBytes(frame,0,frameSize - 1);
      int firstZeroIndex=indexOf(frame,0,(byte)0);
      String mimeType=new String(frame,0,firstZeroIndex,""String_Node_Str"");
      int filenameStartIndex=firstZeroIndex + 1;
      int filenameEndIndex=indexOfEOS(frame,filenameStartIndex,encoding);
      String filename=new String(frame,filenameStartIndex,filenameEndIndex - filenameStartIndex,charset);
      int descriptionStartIndex=filenameEndIndex + 1;
      int descriptionEndIndex=indexOfEOS(frame,descriptionStartIndex,encoding);
      String description=new String(frame,descriptionStartIndex,descriptionEndIndex - descriptionStartIndex,charset);
      byte[] objectData=new byte[frameSize - descriptionEndIndex - 2];
      System.arraycopy(frame,descriptionEndIndex + 1,objectData,0,frameSize - descriptionEndIndex - 2);
      metadata.put(GeobMetadata.TYPE,new GeobMetadata(mimeType,filename,description,objectData));
    }
 else {
      String type=String.format(""String_Node_Str"",frameId0,frameId1,frameId2,frameId3);
      byte[] frame=new byte[frameSize];
      id3Data.readBytes(frame,0,frameSize);
      metadata.put(type,frame);
    }
    id3Size-=frameSize + 10;
  }
  return Collections.unmodifiableMap(metadata);
}","@Override public Map<String,Object> parse(byte[] data,int size) throws UnsupportedEncodingException, ParserException {
  Map<String,Object> metadata=new HashMap<String,Object>();
  ParsableByteArray id3Data=new ParsableByteArray(data,size);
  int id3Size=parseId3Header(id3Data);
  while (id3Size > 0) {
    int frameId0=id3Data.readUnsignedByte();
    int frameId1=id3Data.readUnsignedByte();
    int frameId2=id3Data.readUnsignedByte();
    int frameId3=id3Data.readUnsignedByte();
    int frameSize=id3Data.readSynchSafeInt();
    if (frameSize <= 1) {
      break;
    }
    id3Data.skip(2);
    if (frameId0 == 'T' && frameId1 == 'X' && frameId2 == 'X' && frameId3 == 'X') {
      int encoding=id3Data.readUnsignedByte();
      String charset=getCharsetName(encoding);
      byte[] frame=new byte[frameSize - 1];
      id3Data.readBytes(frame,0,frameSize - 1);
      int firstZeroIndex=indexOfEOS(frame,0,encoding);
      String description=new String(frame,0,firstZeroIndex,charset);
      int valueStartIndex=firstZeroIndex + delimiterLength(encoding);
      int valueEndIndex=indexOfEOS(frame,valueStartIndex,encoding);
      String value=new String(frame,valueStartIndex,valueEndIndex - valueStartIndex,charset);
      metadata.put(TxxxMetadata.TYPE,new TxxxMetadata(description,value));
    }
 else     if (frameId0 == 'P' && frameId1 == 'R' && frameId2 == 'I' && frameId3 == 'V') {
      byte[] frame=new byte[frameSize];
      id3Data.readBytes(frame,0,frameSize);
      int firstZeroIndex=indexOf(frame,0,(byte)0);
      String owner=new String(frame,0,firstZeroIndex,""String_Node_Str"");
      byte[] privateData=new byte[frameSize - firstZeroIndex - 1];
      System.arraycopy(frame,firstZeroIndex + 1,privateData,0,frameSize - firstZeroIndex - 1);
      metadata.put(PrivMetadata.TYPE,new PrivMetadata(owner,privateData));
    }
 else     if (frameId0 == 'G' && frameId1 == 'E' && frameId2 == 'O' && frameId3 == 'B') {
      int encoding=id3Data.readUnsignedByte();
      String charset=getCharsetName(encoding);
      byte[] frame=new byte[frameSize - 1];
      id3Data.readBytes(frame,0,frameSize - 1);
      int firstZeroIndex=indexOf(frame,0,(byte)0);
      String mimeType=new String(frame,0,firstZeroIndex,""String_Node_Str"");
      int filenameStartIndex=firstZeroIndex + delimiterLength(encoding);
      int filenameEndIndex=indexOfEOS(frame,filenameStartIndex,encoding);
      String filename=new String(frame,filenameStartIndex,filenameEndIndex - filenameStartIndex,charset);
      int descriptionStartIndex=filenameEndIndex + delimiterLength(encoding);
      int descriptionEndIndex=indexOfEOS(frame,descriptionStartIndex,encoding);
      String description=new String(frame,descriptionStartIndex,descriptionEndIndex - descriptionStartIndex,charset);
      byte[] objectData=new byte[frameSize - descriptionEndIndex - 2];
      System.arraycopy(frame,descriptionEndIndex + delimiterLength(encoding),objectData,0,frameSize - descriptionEndIndex - 2);
      metadata.put(GeobMetadata.TYPE,new GeobMetadata(mimeType,filename,description,objectData));
    }
 else {
      String type=String.format(""String_Node_Str"",frameId0,frameId1,frameId2,frameId3);
      byte[] frame=new byte[frameSize];
      id3Data.readBytes(frame,0,frameSize);
      metadata.put(type,frame);
    }
    id3Size-=frameSize + 10;
  }
  return Collections.unmodifiableMap(metadata);
}",0.9843890723506454
110462,"@Override public Map<String,Object> parse(byte[] data,int size) throws UnsupportedEncodingException, ParserException {
  Map<String,Object> metadata=new HashMap<String,Object>();
  ParsableByteArray id3Data=new ParsableByteArray(data,size);
  int id3Size=parseId3Header(id3Data);
  while (id3Size > 0) {
    int frameId0=id3Data.readUnsignedByte();
    int frameId1=id3Data.readUnsignedByte();
    int frameId2=id3Data.readUnsignedByte();
    int frameId3=id3Data.readUnsignedByte();
    int frameSize=id3Data.readSynchSafeInt();
    if (frameSize <= 1) {
      break;
    }
    id3Data.skip(2);
    if (frameId0 == 'T' && frameId1 == 'X' && frameId2 == 'X' && frameId3 == 'X') {
      int encoding=id3Data.readUnsignedByte();
      String charset=getCharsetName(encoding);
      byte[] frame=new byte[frameSize - 1];
      id3Data.readBytes(frame,0,frameSize - 1);
      int firstZeroIndex=indexOfEOS(frame,0,encoding);
      String description=new String(frame,0,firstZeroIndex,charset);
      int valueStartIndex=firstZeroIndex + delimiterLength(encoding);
      int valueEndIndex=indexOfEOS(frame,valueStartIndex,encoding);
      String value=new String(frame,valueStartIndex,valueEndIndex - valueStartIndex,charset);
      metadata.put(TxxxMetadata.TYPE,new TxxxMetadata(description,value));
    }
 else     if (frameId0 == 'P' && frameId1 == 'R' && frameId2 == 'I' && frameId3 == 'V') {
      byte[] frame=new byte[frameSize];
      id3Data.readBytes(frame,0,frameSize);
      int firstZeroIndex=indexOf(frame,0,(byte)0);
      String owner=new String(frame,0,firstZeroIndex,""String_Node_Str"");
      byte[] privateData=new byte[frameSize - firstZeroIndex - 1];
      System.arraycopy(frame,firstZeroIndex + 1,privateData,0,frameSize - firstZeroIndex - 1);
      metadata.put(PrivMetadata.TYPE,new PrivMetadata(owner,privateData));
    }
 else     if (frameId0 == 'G' && frameId1 == 'E' && frameId2 == 'O' && frameId3 == 'B') {
      int encoding=id3Data.readUnsignedByte();
      String charset=getCharsetName(encoding);
      byte[] frame=new byte[frameSize - 1];
      id3Data.readBytes(frame,0,frameSize - 1);
      int firstZeroIndex=indexOf(frame,0,(byte)0);
      String mimeType=new String(frame,0,firstZeroIndex,""String_Node_Str"");
      int filenameStartIndex=firstZeroIndex + delimiterLength(encoding);
      int filenameEndIndex=indexOfEOS(frame,filenameStartIndex,encoding);
      String filename=new String(frame,filenameStartIndex,filenameEndIndex - filenameStartIndex,charset);
      int descriptionStartIndex=filenameEndIndex + delimiterLength(encoding);
      int descriptionEndIndex=indexOfEOS(frame,descriptionStartIndex,encoding);
      String description=new String(frame,descriptionStartIndex,descriptionEndIndex - descriptionStartIndex,charset);
      byte[] objectData=new byte[frameSize - descriptionEndIndex - 2];
      System.arraycopy(frame,descriptionEndIndex + delimiterLength(encoding),objectData,0,frameSize - descriptionEndIndex - 2);
      metadata.put(GeobMetadata.TYPE,new GeobMetadata(mimeType,filename,description,objectData));
    }
 else {
      String type=String.format(""String_Node_Str"",frameId0,frameId1,frameId2,frameId3);
      byte[] frame=new byte[frameSize];
      id3Data.readBytes(frame,0,frameSize);
      metadata.put(type,frame);
    }
    id3Size-=frameSize + 10;
  }
  return Collections.unmodifiableMap(metadata);
}","@Override public Map<String,Object> parse(byte[] data,int size) throws UnsupportedEncodingException, ParserException {
  Map<String,Object> metadata=new HashMap<String,Object>();
  ParsableByteArray id3Data=new ParsableByteArray(data,size);
  int id3Size=parseId3Header(id3Data);
  while (id3Size > 0) {
    int frameId0=id3Data.readUnsignedByte();
    int frameId1=id3Data.readUnsignedByte();
    int frameId2=id3Data.readUnsignedByte();
    int frameId3=id3Data.readUnsignedByte();
    int frameSize=id3Data.readSynchSafeInt();
    if (frameSize <= 1) {
      break;
    }
    id3Data.skip(2);
    if (frameId0 == 'T' && frameId1 == 'X' && frameId2 == 'X' && frameId3 == 'X') {
      int encoding=id3Data.readUnsignedByte();
      String charset=getCharsetName(encoding);
      byte[] frame=new byte[frameSize - 1];
      id3Data.readBytes(frame,0,frameSize - 1);
      int firstZeroIndex=indexOfEOS(frame,0,encoding);
      String description=new String(frame,0,firstZeroIndex,charset);
      int valueStartIndex=firstZeroIndex + delimiterLength(encoding);
      int valueEndIndex=indexOfEOS(frame,valueStartIndex,encoding);
      String value=new String(frame,valueStartIndex,valueEndIndex - valueStartIndex,charset);
      metadata.put(TxxxMetadata.TYPE,new TxxxMetadata(description,value));
    }
 else     if (frameId0 == 'P' && frameId1 == 'R' && frameId2 == 'I' && frameId3 == 'V') {
      byte[] frame=new byte[frameSize];
      id3Data.readBytes(frame,0,frameSize);
      int firstZeroIndex=indexOf(frame,0,(byte)0);
      String owner=new String(frame,0,firstZeroIndex,""String_Node_Str"");
      byte[] privateData=new byte[frameSize - firstZeroIndex - 1];
      System.arraycopy(frame,firstZeroIndex + 1,privateData,0,frameSize - firstZeroIndex - 1);
      metadata.put(PrivMetadata.TYPE,new PrivMetadata(owner,privateData));
    }
 else     if (frameId0 == 'G' && frameId1 == 'E' && frameId2 == 'O' && frameId3 == 'B') {
      int encoding=id3Data.readUnsignedByte();
      String charset=getCharsetName(encoding);
      byte[] frame=new byte[frameSize - 1];
      id3Data.readBytes(frame,0,frameSize - 1);
      int firstZeroIndex=indexOf(frame,0,(byte)0);
      String mimeType=new String(frame,0,firstZeroIndex,""String_Node_Str"");
      int filenameStartIndex=firstZeroIndex + delimiterLength(encoding);
      int filenameEndIndex=indexOfEOS(frame,filenameStartIndex,encoding);
      String filename=new String(frame,filenameStartIndex,filenameEndIndex - filenameStartIndex,charset);
      int descriptionStartIndex=filenameEndIndex + delimiterLength(encoding);
      int descriptionEndIndex=indexOfEOS(frame,descriptionStartIndex,encoding);
      String description=new String(frame,descriptionStartIndex,descriptionEndIndex - descriptionStartIndex,charset);
      int objectDataSize=frameSize - 1 - descriptionEndIndex- delimiterLength(encoding);
      byte[] objectData=new byte[objectDataSize];
      System.arraycopy(frame,descriptionEndIndex + delimiterLength(encoding),objectData,0,objectDataSize);
      metadata.put(GeobMetadata.TYPE,new GeobMetadata(mimeType,filename,description,objectData));
    }
 else {
      String type=String.format(""String_Node_Str"",frameId0,frameId1,frameId2,frameId3);
      byte[] frame=new byte[frameSize];
      id3Data.readBytes(frame,0,frameSize);
      metadata.put(type,frame);
    }
    id3Size-=frameSize + 10;
  }
  return Collections.unmodifiableMap(metadata);
}",0.9501836884643644
110463,"private void feedNalUnitTargetEnd(long pesTimeUs,int discardPadding){
  sps.endNalUnit(discardPadding);
  pps.endNalUnit(discardPadding);
  if (sei.endNalUnit(discardPadding)) {
    seiReader.read(sei.nalData,0,pesTimeUs);
  }
}","private void feedNalUnitTargetEnd(long pesTimeUs,int discardPadding){
  sps.endNalUnit(discardPadding);
  pps.endNalUnit(discardPadding);
  if (sei.endNalUnit(discardPadding)) {
    int unescapedLength=unescapeStream(sei.nalData,sei.nalLength);
    seiReader.read(sei.nalData,0,unescapedLength,pesTimeUs);
  }
}",0.8460111317254174
110464,"private void parseMediaFormat(NalUnitTargetBuffer sps,NalUnitTargetBuffer pps){
  byte[] spsData=new byte[sps.nalLength];
  byte[] ppsData=new byte[pps.nalLength];
  System.arraycopy(sps.nalData,0,spsData,0,sps.nalLength);
  System.arraycopy(pps.nalData,0,ppsData,0,pps.nalLength);
  List<byte[]> initializationData=new ArrayList<byte[]>();
  initializationData.add(spsData);
  initializationData.add(ppsData);
  byte[] unescapedSps=unescapeStream(spsData,0,spsData.length);
  ParsableBitArray bitArray=new ParsableBitArray(unescapedSps);
  bitArray.skipBits(32);
  int profileIdc=bitArray.readBits(8);
  bitArray.skipBits(16);
  bitArray.readUnsignedExpGolombCodedInt();
  int chromaFormatIdc=1;
  if (profileIdc == 100 || profileIdc == 110 || profileIdc == 122 || profileIdc == 244 || profileIdc == 44 || profileIdc == 83 || profileIdc == 86 || profileIdc == 118 || profileIdc == 128 || profileIdc == 138) {
    chromaFormatIdc=bitArray.readUnsignedExpGolombCodedInt();
    if (chromaFormatIdc == 3) {
      bitArray.skipBits(1);
    }
    bitArray.readUnsignedExpGolombCodedInt();
    bitArray.readUnsignedExpGolombCodedInt();
    bitArray.skipBits(1);
    boolean seqScalingMatrixPresentFlag=bitArray.readBit();
    if (seqScalingMatrixPresentFlag) {
      int limit=(chromaFormatIdc != 3) ? 8 : 12;
      for (int i=0; i < limit; i++) {
        boolean seqScalingListPresentFlag=bitArray.readBit();
        if (seqScalingListPresentFlag) {
          skipScalingList(bitArray,i < 6 ? 16 : 64);
        }
      }
    }
  }
  bitArray.readUnsignedExpGolombCodedInt();
  long picOrderCntType=bitArray.readUnsignedExpGolombCodedInt();
  if (picOrderCntType == 0) {
    bitArray.readUnsignedExpGolombCodedInt();
  }
 else   if (picOrderCntType == 1) {
    bitArray.skipBits(1);
    bitArray.readSignedExpGolombCodedInt();
    bitArray.readSignedExpGolombCodedInt();
    long numRefFramesInPicOrderCntCycle=bitArray.readUnsignedExpGolombCodedInt();
    for (int i=0; i < numRefFramesInPicOrderCntCycle; i++) {
      bitArray.readUnsignedExpGolombCodedInt();
    }
  }
  bitArray.readUnsignedExpGolombCodedInt();
  bitArray.skipBits(1);
  int picWidthInMbs=bitArray.readUnsignedExpGolombCodedInt() + 1;
  int picHeightInMapUnits=bitArray.readUnsignedExpGolombCodedInt() + 1;
  boolean frameMbsOnlyFlag=bitArray.readBit();
  int frameHeightInMbs=(2 - (frameMbsOnlyFlag ? 1 : 0)) * picHeightInMapUnits;
  if (!frameMbsOnlyFlag) {
    bitArray.skipBits(1);
  }
  bitArray.skipBits(1);
  int frameWidth=picWidthInMbs * 16;
  int frameHeight=frameHeightInMbs * 16;
  boolean frameCroppingFlag=bitArray.readBit();
  if (frameCroppingFlag) {
    int frameCropLeftOffset=bitArray.readUnsignedExpGolombCodedInt();
    int frameCropRightOffset=bitArray.readUnsignedExpGolombCodedInt();
    int frameCropTopOffset=bitArray.readUnsignedExpGolombCodedInt();
    int frameCropBottomOffset=bitArray.readUnsignedExpGolombCodedInt();
    int cropUnitX, cropUnitY;
    if (chromaFormatIdc == 0) {
      cropUnitX=1;
      cropUnitY=2 - (frameMbsOnlyFlag ? 1 : 0);
    }
 else {
      int subWidthC=(chromaFormatIdc == 3) ? 1 : 2;
      int subHeightC=(chromaFormatIdc == 1) ? 2 : 1;
      cropUnitX=subWidthC;
      cropUnitY=subHeightC * (2 - (frameMbsOnlyFlag ? 1 : 0));
    }
    frameWidth-=(frameCropLeftOffset + frameCropRightOffset) * cropUnitX;
    frameHeight-=(frameCropTopOffset + frameCropBottomOffset) * cropUnitY;
  }
  setMediaFormat(MediaFormat.createVideoFormat(MimeTypes.VIDEO_H264,MediaFormat.NO_VALUE,frameWidth,frameHeight,initializationData));
}","private void parseMediaFormat(NalUnitTargetBuffer sps,NalUnitTargetBuffer pps){
  byte[] spsData=new byte[sps.nalLength];
  byte[] ppsData=new byte[pps.nalLength];
  System.arraycopy(sps.nalData,0,spsData,0,sps.nalLength);
  System.arraycopy(pps.nalData,0,ppsData,0,pps.nalLength);
  List<byte[]> initializationData=new ArrayList<byte[]>();
  initializationData.add(spsData);
  initializationData.add(ppsData);
  unescapeStream(sps.nalData,sps.nalLength);
  ParsableBitArray bitArray=new ParsableBitArray(sps.nalData);
  bitArray.skipBits(32);
  int profileIdc=bitArray.readBits(8);
  bitArray.skipBits(16);
  bitArray.readUnsignedExpGolombCodedInt();
  int chromaFormatIdc=1;
  if (profileIdc == 100 || profileIdc == 110 || profileIdc == 122 || profileIdc == 244 || profileIdc == 44 || profileIdc == 83 || profileIdc == 86 || profileIdc == 118 || profileIdc == 128 || profileIdc == 138) {
    chromaFormatIdc=bitArray.readUnsignedExpGolombCodedInt();
    if (chromaFormatIdc == 3) {
      bitArray.skipBits(1);
    }
    bitArray.readUnsignedExpGolombCodedInt();
    bitArray.readUnsignedExpGolombCodedInt();
    bitArray.skipBits(1);
    boolean seqScalingMatrixPresentFlag=bitArray.readBit();
    if (seqScalingMatrixPresentFlag) {
      int limit=(chromaFormatIdc != 3) ? 8 : 12;
      for (int i=0; i < limit; i++) {
        boolean seqScalingListPresentFlag=bitArray.readBit();
        if (seqScalingListPresentFlag) {
          skipScalingList(bitArray,i < 6 ? 16 : 64);
        }
      }
    }
  }
  bitArray.readUnsignedExpGolombCodedInt();
  long picOrderCntType=bitArray.readUnsignedExpGolombCodedInt();
  if (picOrderCntType == 0) {
    bitArray.readUnsignedExpGolombCodedInt();
  }
 else   if (picOrderCntType == 1) {
    bitArray.skipBits(1);
    bitArray.readSignedExpGolombCodedInt();
    bitArray.readSignedExpGolombCodedInt();
    long numRefFramesInPicOrderCntCycle=bitArray.readUnsignedExpGolombCodedInt();
    for (int i=0; i < numRefFramesInPicOrderCntCycle; i++) {
      bitArray.readUnsignedExpGolombCodedInt();
    }
  }
  bitArray.readUnsignedExpGolombCodedInt();
  bitArray.skipBits(1);
  int picWidthInMbs=bitArray.readUnsignedExpGolombCodedInt() + 1;
  int picHeightInMapUnits=bitArray.readUnsignedExpGolombCodedInt() + 1;
  boolean frameMbsOnlyFlag=bitArray.readBit();
  int frameHeightInMbs=(2 - (frameMbsOnlyFlag ? 1 : 0)) * picHeightInMapUnits;
  if (!frameMbsOnlyFlag) {
    bitArray.skipBits(1);
  }
  bitArray.skipBits(1);
  int frameWidth=picWidthInMbs * 16;
  int frameHeight=frameHeightInMbs * 16;
  boolean frameCroppingFlag=bitArray.readBit();
  if (frameCroppingFlag) {
    int frameCropLeftOffset=bitArray.readUnsignedExpGolombCodedInt();
    int frameCropRightOffset=bitArray.readUnsignedExpGolombCodedInt();
    int frameCropTopOffset=bitArray.readUnsignedExpGolombCodedInt();
    int frameCropBottomOffset=bitArray.readUnsignedExpGolombCodedInt();
    int cropUnitX, cropUnitY;
    if (chromaFormatIdc == 0) {
      cropUnitX=1;
      cropUnitY=2 - (frameMbsOnlyFlag ? 1 : 0);
    }
 else {
      int subWidthC=(chromaFormatIdc == 3) ? 1 : 2;
      int subHeightC=(chromaFormatIdc == 1) ? 2 : 1;
      cropUnitX=subWidthC;
      cropUnitY=subHeightC * (2 - (frameMbsOnlyFlag ? 1 : 0));
    }
    frameWidth-=(frameCropLeftOffset + frameCropRightOffset) * cropUnitX;
    frameHeight-=(frameCropTopOffset + frameCropBottomOffset) * cropUnitY;
  }
  setMediaFormat(MediaFormat.createVideoFormat(MimeTypes.VIDEO_H264,MediaFormat.NO_VALUE,frameWidth,frameHeight,initializationData));
}",0.973133484162896
110465,"public H264Reader(BufferPool bufferPool,SeiReader seiReader){
  super(bufferPool);
  this.seiReader=seiReader;
  prefixFlags=new boolean[3];
  sps=new NalUnitTargetBuffer(NAL_UNIT_TYPE_SPS,128);
  pps=new NalUnitTargetBuffer(NAL_UNIT_TYPE_PPS,128);
  sei=new NalUnitTargetBuffer(NAL_UNIT_TYPE_SEI,128);
}","public H264Reader(BufferPool bufferPool,SeiReader seiReader){
  super(bufferPool);
  this.seiReader=seiReader;
  prefixFlags=new boolean[3];
  sps=new NalUnitTargetBuffer(NAL_UNIT_TYPE_SPS,128);
  pps=new NalUnitTargetBuffer(NAL_UNIT_TYPE_PPS,128);
  sei=new NalUnitTargetBuffer(NAL_UNIT_TYPE_SEI,128);
  scratchEscapePositions=new int[10];
}",0.9411764705882352
110466,"/** 
 * Replaces occurrences of [0, 0, 3] with [0, 0]. <p> See ISO/IEC 14496-10:2005(E) page 36 for more information.
 */
private byte[] unescapeStream(byte[] data,int offset,int limit){
  int position=offset;
  List<Integer> escapePositions=new ArrayList<Integer>();
  while (position < limit) {
    position=findNextUnescapeIndex(data,position,limit);
    if (position < limit) {
      escapePositions.add(position);
      position+=3;
    }
  }
  int escapeCount=escapePositions.size();
  int escapedPosition=offset;
  int unescapedPosition=0;
  byte[] unescapedData=new byte[limit - offset - escapeCount];
  for (int i=0; i < escapeCount; i++) {
    int nextEscapePosition=escapePositions.get(i);
    int copyLength=nextEscapePosition - escapedPosition;
    System.arraycopy(data,escapedPosition,unescapedData,unescapedPosition,copyLength);
    escapedPosition+=copyLength + 3;
    unescapedPosition+=copyLength + 2;
  }
  int remainingLength=unescapedData.length - unescapedPosition;
  System.arraycopy(data,escapedPosition,unescapedData,unescapedPosition,remainingLength);
  return unescapedData;
}","/** 
 * Unescapes   {@code data} up to the specified limit, replacing occurrences of [0, 0, 3] with[0, 0]. The unescaped data is returned in-place, with the return value indicating its length. <p> See ISO/IEC 14496-10:2005(E) page 36 for more information.
 * @param data The data to unescape.
 * @param limit The limit (exclusive) of the data to unescape.
 * @return The length of the unescaped data.
 */
private int unescapeStream(byte[] data,int limit){
  int position=0;
  scratchEscapeCount=0;
  while (position < limit) {
    position=findNextUnescapeIndex(data,position,limit);
    if (position < limit) {
      if (scratchEscapePositions.length <= scratchEscapeCount) {
        scratchEscapePositions=Arrays.copyOf(scratchEscapePositions,scratchEscapePositions.length * 2);
      }
      scratchEscapePositions[scratchEscapeCount++]=position;
      position+=3;
    }
  }
  int unescapedLength=limit - scratchEscapeCount;
  int escapedPosition=0;
  int unescapedPosition=0;
  for (int i=0; i < scratchEscapeCount; i++) {
    int nextEscapePosition=scratchEscapePositions[i];
    int copyLength=nextEscapePosition - escapedPosition;
    System.arraycopy(data,escapedPosition,data,unescapedPosition,copyLength);
    escapedPosition+=copyLength + 3;
    unescapedPosition+=copyLength + 2;
  }
  int remainingLength=unescapedLength - unescapedPosition;
  System.arraycopy(data,escapedPosition,data,unescapedPosition,remainingLength);
  return unescapedLength;
}",0.6105919003115264
110467,"public void read(byte[] data,int position,long pesTimeUs){
  seiBuffer.reset(data,data.length);
  seiBuffer.setPosition(position + 4);
  int ccDataSize=Eia608Parser.parseHeader(seiBuffer);
  if (ccDataSize > 0) {
    startSample(pesTimeUs);
    appendData(seiBuffer,ccDataSize);
    commitSample(true);
  }
}","public void read(byte[] data,int position,int limit,long pesTimeUs){
  seiBuffer.reset(data,limit);
  seiBuffer.setPosition(position + 4);
  int b;
  while (seiBuffer.bytesLeft() > 1) {
    int payloadType=0;
    do {
      b=seiBuffer.readUnsignedByte();
      payloadType+=b;
    }
 while (b == 0xFF);
    int payloadSize=0;
    do {
      b=seiBuffer.readUnsignedByte();
      payloadSize+=b;
    }
 while (b == 0xFF);
    if (Eia608Parser.inspectSeiMessage(payloadType,payloadSize,seiBuffer)) {
      startSample(pesTimeUs);
      appendData(seiBuffer,payloadSize);
      commitSample(true);
    }
 else {
      seiBuffer.skip(payloadSize);
    }
  }
}",0.2489626556016597
110468,"ClosedCaptionList parse(SampleHolder sampleHolder){
  if (sampleHolder.size <= 0) {
    return null;
  }
  captions.clear();
  stringBuilder.setLength(0);
  seiBuffer.reset(sampleHolder.data.array());
  seiBuffer.skipBits(3);
  int ccCount=seiBuffer.readBits(5);
  seiBuffer.skipBits(8);
  for (int i=0; i < ccCount; i++) {
    seiBuffer.skipBits(5);
    boolean ccValid=seiBuffer.readBit();
    if (!ccValid) {
      seiBuffer.skipBits(18);
      continue;
    }
    int ccType=seiBuffer.readBits(2);
    if (ccType != 0) {
      seiBuffer.skipBits(16);
      continue;
    }
    seiBuffer.skipBits(1);
    byte ccData1=(byte)seiBuffer.readBits(7);
    seiBuffer.skipBits(1);
    byte ccData2=(byte)seiBuffer.readBits(7);
    if (ccData1 == 0 && ccData2 == 0) {
      continue;
    }
    if ((ccData1 == 0x11) && ((ccData2 & 0x70) == 0x30)) {
      stringBuilder.append(getSpecialChar(ccData2));
      continue;
    }
    if (ccData1 < 0x20) {
      if (stringBuilder.length() > 0) {
        captions.add(new ClosedCaptionText(stringBuilder.toString()));
        stringBuilder.setLength(0);
      }
      captions.add(new ClosedCaptionCtrl(ccData1,ccData2));
      continue;
    }
    stringBuilder.append(getChar(ccData1));
    if (ccData2 != 0) {
      stringBuilder.append(getChar(ccData2));
    }
  }
  if (stringBuilder.length() > 0) {
    captions.add(new ClosedCaptionText(stringBuilder.toString()));
  }
  if (captions.isEmpty()) {
    return null;
  }
  ClosedCaption[] captionArray=new ClosedCaption[captions.size()];
  captions.toArray(captionArray);
  return new ClosedCaptionList(sampleHolder.timeUs,sampleHolder.decodeOnly,captionArray);
}","ClosedCaptionList parse(SampleHolder sampleHolder){
  if (sampleHolder.size < 10) {
    return null;
  }
  captions.clear();
  stringBuilder.setLength(0);
  seiBuffer.reset(sampleHolder.data.array());
  seiBuffer.skipBits(67);
  int ccCount=seiBuffer.readBits(5);
  seiBuffer.skipBits(8);
  for (int i=0; i < ccCount; i++) {
    seiBuffer.skipBits(5);
    boolean ccValid=seiBuffer.readBit();
    if (!ccValid) {
      seiBuffer.skipBits(18);
      continue;
    }
    int ccType=seiBuffer.readBits(2);
    if (ccType != 0) {
      seiBuffer.skipBits(16);
      continue;
    }
    seiBuffer.skipBits(1);
    byte ccData1=(byte)seiBuffer.readBits(7);
    seiBuffer.skipBits(1);
    byte ccData2=(byte)seiBuffer.readBits(7);
    if (ccData1 == 0 && ccData2 == 0) {
      continue;
    }
    if ((ccData1 == 0x11) && ((ccData2 & 0x70) == 0x30)) {
      stringBuilder.append(getSpecialChar(ccData2));
      continue;
    }
    if (ccData1 < 0x20) {
      if (stringBuilder.length() > 0) {
        captions.add(new ClosedCaptionText(stringBuilder.toString()));
        stringBuilder.setLength(0);
      }
      captions.add(new ClosedCaptionCtrl(ccData1,ccData2));
      continue;
    }
    stringBuilder.append(getChar(ccData1));
    if (ccData2 != 0) {
      stringBuilder.append(getChar(ccData2));
    }
  }
  if (stringBuilder.length() > 0) {
    captions.add(new ClosedCaptionText(stringBuilder.toString()));
  }
  if (captions.isEmpty()) {
    return null;
  }
  ClosedCaption[] captionArray=new ClosedCaption[captions.size()];
  captions.toArray(captionArray);
  return new ClosedCaptionList(sampleHolder.timeUs,sampleHolder.decodeOnly,captionArray);
}",0.9978845572680568
110469,"@Override public int read(byte[] buffer,int offset,int length) throws IOException {
  System.arraycopy(data,readPosition,buffer,offset,length);
  readPosition+=length;
  return length;
}","@Override public int read(byte[] buffer,int offset,int length) throws IOException {
  if (remainingBytes == 0) {
    return -1;
  }
  length=Math.min(length,remainingBytes);
  System.arraycopy(data,readPosition,buffer,offset,length);
  readPosition+=length;
  remainingBytes-=length;
  return length;
}",0.7622950819672131
110470,"/** 
 * @param data The data to be read.
 */
public ByteArrayDataSource(byte[] data){
  this.data=Assertions.checkNotNull(data);
}","/** 
 * @param data The data to be read.
 */
public ByteArrayDataSource(byte[] data){
  Assertions.checkNotNull(data);
  Assertions.checkArgument(data.length > 0);
  this.data=data;
}",0.7667731629392971
110471,"@Override public long open(DataSpec dataSpec) throws IOException {
  if (dataSpec.length == C.LENGTH_UNBOUNDED) {
    Assertions.checkArgument(dataSpec.position < data.length);
  }
 else {
    Assertions.checkArgument(dataSpec.position + dataSpec.length <= data.length);
  }
  readPosition=(int)dataSpec.position;
  return (dataSpec.length == C.LENGTH_UNBOUNDED) ? (data.length - dataSpec.position) : dataSpec.length;
}","@Override public long open(DataSpec dataSpec) throws IOException {
  readPosition=(int)dataSpec.position;
  remainingBytes=(int)((dataSpec.length == C.LENGTH_UNBOUNDED) ? (data.length - dataSpec.position) : dataSpec.length);
  if (remainingBytes <= 0 || readPosition + remainingBytes > data.length) {
    throw new IOException(""String_Node_Str"" + readPosition + ""String_Node_Str""+ dataSpec.length+ ""String_Node_Str""+ data.length);
  }
  return remainingBytes;
}",0.3159090909090909
110472,"/** 
 * Reads a single unsigned byte.
 * @return The value of the parsed byte.
 */
public int readUnsignedByte(){
  byte b;
  if (bitOffset != 0) {
    b=(byte)((data[byteOffset] << bitOffset) | (data[byteOffset + 1] >> (8 - bitOffset)));
  }
 else {
    b=data[byteOffset];
  }
  byteOffset++;
  return b & 0xFF;
}","/** 
 * Reads a single unsigned byte.
 * @return The value of the parsed byte.
 */
public int readUnsignedByte(){
  byte b;
  if (bitOffset != 0) {
    b=(byte)((data[byteOffset] << bitOffset) | ((data[byteOffset + 1] & 0xFF) >> (8 - bitOffset)));
  }
 else {
    b=data[byteOffset];
  }
  byteOffset++;
  return b & 0xFF;
}",0.701095461658842
110473,"/** 
 * @param dataSource A {@link DataSource} suitable for loading the media data.
 * @param evaluator Selects from the available formats.
 * @param representations The representations to be considered by the source.
 */
public DashChunkSource(DataSource dataSource,FormatEvaluator evaluator,Representation... representations){
  this.dataSource=dataSource;
  this.evaluator=evaluator;
  this.formats=new Format[representations.length];
  this.extractors=new HashMap<String,Extractor>();
  this.segmentIndexes=new HashMap<String,DashSegmentIndex>();
  this.representations=new HashMap<String,Representation>();
  this.trackInfo=new TrackInfo(representations[0].format.mimeType,representations[0].periodDurationMs * 1000);
  this.evaluation=new Evaluation();
  int maxWidth=0;
  int maxHeight=0;
  for (int i=0; i < representations.length; i++) {
    formats[i]=representations[i].format;
    maxWidth=Math.max(formats[i].width,maxWidth);
    maxHeight=Math.max(formats[i].height,maxHeight);
    Extractor extractor=mimeTypeIsWebm(formats[i].mimeType) ? new WebmExtractor() : new FragmentedMp4Extractor();
    extractors.put(formats[i].id,extractor);
    this.representations.put(formats[i].id,representations[i]);
    DashSegmentIndex segmentIndex=representations[i].getIndex();
    if (segmentIndex != null) {
      segmentIndexes.put(formats[i].id,segmentIndex);
    }
  }
  this.maxWidth=maxWidth;
  this.maxHeight=maxHeight;
  Arrays.sort(formats,new DecreasingBandwidthComparator());
}","/** 
 * @param dataSource A {@link DataSource} suitable for loading the media data.
 * @param evaluator Selects from the available formats.
 * @param representations The representations to be considered by the source.
 */
public DashChunkSource(DataSource dataSource,FormatEvaluator evaluator,Representation... representations){
  long periodDurationUs=(representations[0].periodDurationMs == -1) ? -1 : representations[0].periodDurationMs * 1000;
  this.dataSource=dataSource;
  this.evaluator=evaluator;
  this.formats=new Format[representations.length];
  this.extractors=new HashMap<String,Extractor>();
  this.segmentIndexes=new HashMap<String,DashSegmentIndex>();
  this.representations=new HashMap<String,Representation>();
  this.trackInfo=new TrackInfo(representations[0].format.mimeType,periodDurationUs);
  this.evaluation=new Evaluation();
  int maxWidth=0;
  int maxHeight=0;
  for (int i=0; i < representations.length; i++) {
    formats[i]=representations[i].format;
    maxWidth=Math.max(formats[i].width,maxWidth);
    maxHeight=Math.max(formats[i].height,maxHeight);
    Extractor extractor=mimeTypeIsWebm(formats[i].mimeType) ? new WebmExtractor() : new FragmentedMp4Extractor();
    extractors.put(formats[i].id,extractor);
    this.representations.put(formats[i].id,representations[i]);
    DashSegmentIndex segmentIndex=representations[i].getIndex();
    if (segmentIndex != null) {
      segmentIndexes.put(formats[i].id,segmentIndex);
    }
  }
  this.maxWidth=maxWidth;
  this.maxHeight=maxHeight;
  Arrays.sort(formats,new DecreasingBandwidthComparator());
}",0.7577235772357723
110474,"public final long getSegmentTimeUs(int sequenceNumber){
  long unscaledSegmentTime;
  if (segmentTimeline != null) {
    unscaledSegmentTime=segmentTimeline.get(sequenceNumber - startNumber).startTime - presentationTimeOffset;
  }
 else {
    unscaledSegmentTime=(sequenceNumber - startNumber) * duration;
  }
  return (unscaledSegmentTime * 1000000) / timescale;
}","public final long getSegmentTimeUs(int sequenceNumber){
  long unscaledSegmentTime;
  if (segmentTimeline != null) {
    unscaledSegmentTime=segmentTimeline.get(sequenceNumber - startNumber).startTime - presentationTimeOffset;
  }
 else {
    unscaledSegmentTime=(sequenceNumber - startNumber) * duration;
  }
  return Util.scaleLargeTimestamp(unscaledSegmentTime,1000000,timescale);
}",0.8773333333333333
110475,"public StreamElement(Uri baseUri,String chunkTemplate,int type,String subType,long timescale,String name,int qualityLevels,int maxWidth,int maxHeight,int displayWidth,int displayHeight,String language,TrackElement[] tracks,List<Long> chunkStartTimes,long lastChunkDuration){
  this.baseUri=baseUri;
  this.chunkTemplate=chunkTemplate;
  this.type=type;
  this.subType=subType;
  this.timescale=timescale;
  this.name=name;
  this.qualityLevels=qualityLevels;
  this.maxWidth=maxWidth;
  this.maxHeight=maxHeight;
  this.displayWidth=displayWidth;
  this.displayHeight=displayHeight;
  this.language=language;
  this.tracks=tracks;
  this.chunkCount=chunkStartTimes.size();
  this.chunkStartTimes=chunkStartTimes;
  chunkStartTimesUs=new long[chunkStartTimes.size()];
  if (timescale >= MICROS_PER_SECOND && (timescale % MICROS_PER_SECOND) == 0) {
    long divisionFactor=timescale / MICROS_PER_SECOND;
    for (int i=0; i < chunkStartTimesUs.length; i++) {
      chunkStartTimesUs[i]=chunkStartTimes.get(i) / divisionFactor;
    }
    lastChunkDurationUs=lastChunkDuration / divisionFactor;
  }
 else   if (timescale < MICROS_PER_SECOND && (MICROS_PER_SECOND % timescale) == 0) {
    long multiplicationFactor=MICROS_PER_SECOND / timescale;
    for (int i=0; i < chunkStartTimesUs.length; i++) {
      chunkStartTimesUs[i]=chunkStartTimes.get(i) * multiplicationFactor;
    }
    lastChunkDurationUs=lastChunkDuration * multiplicationFactor;
  }
 else {
    double multiplicationFactor=(double)MICROS_PER_SECOND / timescale;
    for (int i=0; i < chunkStartTimesUs.length; i++) {
      chunkStartTimesUs[i]=(long)(chunkStartTimes.get(i) * multiplicationFactor);
    }
    lastChunkDurationUs=(long)(lastChunkDuration * multiplicationFactor);
  }
}","public StreamElement(Uri baseUri,String chunkTemplate,int type,String subType,long timescale,String name,int qualityLevels,int maxWidth,int maxHeight,int displayWidth,int displayHeight,String language,TrackElement[] tracks,List<Long> chunkStartTimes,long lastChunkDuration){
  this.baseUri=baseUri;
  this.chunkTemplate=chunkTemplate;
  this.type=type;
  this.subType=subType;
  this.timescale=timescale;
  this.name=name;
  this.qualityLevels=qualityLevels;
  this.maxWidth=maxWidth;
  this.maxHeight=maxHeight;
  this.displayWidth=displayWidth;
  this.displayHeight=displayHeight;
  this.language=language;
  this.tracks=tracks;
  this.chunkCount=chunkStartTimes.size();
  this.chunkStartTimes=chunkStartTimes;
  lastChunkDurationUs=Util.scaleLargeTimestamp(lastChunkDuration,MICROS_PER_SECOND,timescale);
  chunkStartTimesUs=Util.scaleLargeTimestamps(chunkStartTimes,MICROS_PER_SECOND,timescale);
}",0.5717522658610272
110476,"public SmoothStreamingManifest(int majorVersion,int minorVersion,long timescale,long duration,long dvrWindowLength,int lookAheadCount,boolean isLive,ProtectionElement protectionElement,StreamElement[] streamElements){
  this.majorVersion=majorVersion;
  this.minorVersion=minorVersion;
  this.timescale=timescale;
  this.lookAheadCount=lookAheadCount;
  this.isLive=isLive;
  this.protectionElement=protectionElement;
  this.streamElements=streamElements;
  if (timescale >= MICROS_PER_SECOND && (timescale % MICROS_PER_SECOND) == 0) {
    long divisionFactor=timescale / MICROS_PER_SECOND;
    dvrWindowLengthUs=dvrWindowLength / divisionFactor;
    durationUs=duration / divisionFactor;
  }
 else   if (timescale < MICROS_PER_SECOND && (MICROS_PER_SECOND % timescale) == 0) {
    long multiplicationFactor=MICROS_PER_SECOND / timescale;
    dvrWindowLengthUs=dvrWindowLength * multiplicationFactor;
    durationUs=duration * multiplicationFactor;
  }
 else {
    double multiplicationFactor=(double)MICROS_PER_SECOND / timescale;
    dvrWindowLengthUs=(long)(dvrWindowLength * multiplicationFactor);
    durationUs=(long)(duration * multiplicationFactor);
  }
}","public SmoothStreamingManifest(int majorVersion,int minorVersion,long timescale,long duration,long dvrWindowLength,int lookAheadCount,boolean isLive,ProtectionElement protectionElement,StreamElement[] streamElements){
  this.majorVersion=majorVersion;
  this.minorVersion=minorVersion;
  this.timescale=timescale;
  this.lookAheadCount=lookAheadCount;
  this.isLive=isLive;
  this.protectionElement=protectionElement;
  this.streamElements=streamElements;
  dvrWindowLengthUs=Util.scaleLargeTimestamp(dvrWindowLength,MICROS_PER_SECOND,timescale);
  durationUs=Util.scaleLargeTimestamp(duration,MICROS_PER_SECOND,timescale);
}",0.5548098434004475
110477,"private static long parseDateTime(XmlPullParser xpp,String name,long defaultValue) throws ParseException {
  String value=xpp.getAttributeValue(null,name);
  if (value != null) {
    SimpleDateFormat parser=new SimpleDateFormat(""String_Node_Str"",Locale.US);
    return parser.parse(value).getTime();
  }
  return defaultValue;
}","static long parseDateTime(String value) throws ParseException {
  Matcher matcher=DATE_TIME_PATTERN.matcher(value);
  if (!matcher.matches()) {
    throw new ParseException(""String_Node_Str"" + value,0);
  }
  int timezoneShift;
  if (matcher.group(9) == null) {
    timezoneShift=0;
  }
 else   if (matcher.group(9).equalsIgnoreCase(""String_Node_Str"")) {
    timezoneShift=0;
  }
 else {
    timezoneShift=((Integer.valueOf(matcher.group(12)) * 60 + Integer.valueOf(matcher.group(13))));
    if (matcher.group(11).equals(""String_Node_Str"")) {
      timezoneShift*=-1;
    }
  }
  Calendar dateTime=new GregorianCalendar(TimeZone.getTimeZone(""String_Node_Str""));
  dateTime.clear();
  dateTime.set(Integer.valueOf(matcher.group(1)),Integer.valueOf(matcher.group(2)) - 1,Integer.valueOf(matcher.group(3)),Integer.valueOf(matcher.group(4)),Integer.valueOf(matcher.group(5)),Integer.valueOf(matcher.group(6)));
  if (!TextUtils.isEmpty(matcher.group(8))) {
    final BigDecimal bd=new BigDecimal(""String_Node_Str"" + matcher.group(8));
    dateTime.set(Calendar.MILLISECOND,bd.movePointRight(3).intValue());
  }
  long time=dateTime.getTimeInMillis();
  if (timezoneShift != 0) {
    time-=timezoneShift * 60000;
  }
  return time;
}",0.1015424164524421
110478,"@Override protected void onInputFormatChanged(MediaFormatHolder holder) throws ExoPlaybackException {
  super.onInputFormatChanged(holder);
  currentPixelWidthHeightRatio=holder.format.pixelWidthHeightRatio;
}","@Override protected void onInputFormatChanged(MediaFormatHolder holder) throws ExoPlaybackException {
  super.onInputFormatChanged(holder);
  currentPixelWidthHeightRatio=holder.format.pixelWidthHeightRatio == MediaFormat.NO_VALUE ? 1 : holder.format.pixelWidthHeightRatio;
}",0.8636363636363636
110479,"@Override protected final T doInBackground(String... data){
  try {
    contentId=data.length > 1 ? data[1] : null;
    String urlString=data[0];
    String inputEncoding=null;
    InputStream inputStream=null;
    try {
      Uri baseUri=Util.parseBaseUri(urlString);
      HttpURLConnection connection=configureHttpConnection(new URL(urlString));
      inputStream=connection.getInputStream();
      inputEncoding=connection.getContentEncoding();
      if (inputEncoding == null) {
        inputEncoding=C.UTF8_NAME;
      }
      return parser.parse(inputStream,inputEncoding,contentId,baseUri);
    }
  finally {
      if (inputStream != null) {
        inputStream.close();
      }
    }
  }
 catch (  Exception e) {
    exception=e;
    return null;
  }
}","@Override protected final T doInBackground(String... data){
  try {
    contentId=data.length > 1 ? data[1] : null;
    String urlString=data[0];
    String inputEncoding=null;
    InputStream inputStream=null;
    try {
      Uri baseUri=Util.parseBaseUri(urlString);
      HttpURLConnection connection=configureHttpConnection(new URL(urlString));
      inputStream=connection.getInputStream();
      inputEncoding=connection.getContentEncoding();
      return parser.parse(inputStream,inputEncoding,contentId,baseUri);
    }
  finally {
      if (inputStream != null) {
        inputStream.close();
      }
    }
  }
 catch (  Exception e) {
    exception=e;
    return null;
  }
}",0.945983379501385
110480,"@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null || getClass() != obj.getClass()) {
    return false;
  }
  MediaFormat other=(MediaFormat)obj;
  if (maxInputSize != other.maxInputSize || width != other.width || height != other.height || maxWidth != other.maxWidth || maxHeight != other.maxHeight || channelCount != other.channelCount || sampleRate != other.sampleRate || !Util.areEqual(mimeType,other.mimeType) || initializationData.size() != other.initializationData.size()) {
    return false;
  }
  for (int i=0; i < initializationData.size(); i++) {
    if (!Arrays.equals(initializationData.get(i),other.initializationData.get(i))) {
      return false;
    }
  }
  return true;
}","public boolean equals(MediaFormat other,boolean ignoreMaxDimensions){
  if (this == other) {
    return true;
  }
  if (other == null) {
    return false;
  }
  return equalsInternal(other,ignoreMaxDimensions);
}",0.0272536687631027
110481,"@Override public int readData(int track,long playbackPositionUs,FormatHolder formatHolder,SampleHolder sampleHolder,boolean onlyReadDiscontinuity) throws IOException {
  Assertions.checkState(state == STATE_ENABLED);
  Assertions.checkState(track == 0);
  if (pendingDiscontinuity) {
    pendingDiscontinuity=false;
    return DISCONTINUITY_READ;
  }
  if (onlyReadDiscontinuity) {
    return NOTHING_READ;
  }
  downstreamPositionUs=playbackPositionUs;
  if (isPendingReset()) {
    if (currentLoadableException != null) {
      throw currentLoadableException;
    }
    IOException chunkSourceException=chunkSource.getError();
    if (chunkSourceException != null) {
      throw chunkSourceException;
    }
    return NOTHING_READ;
  }
  MediaChunk mediaChunk=mediaChunks.getFirst();
  if (mediaChunk.isReadFinished()) {
    if (mediaChunks.size() > 1) {
      discardDownstreamMediaChunk();
      mediaChunk=mediaChunks.getFirst();
      mediaChunk.seekToStart();
      return readData(track,playbackPositionUs,formatHolder,sampleHolder,false);
    }
 else     if (mediaChunk.isLastChunk()) {
      return END_OF_STREAM;
    }
    IOException chunkSourceException=chunkSource.getError();
    if (chunkSourceException != null) {
      throw chunkSourceException;
    }
    return NOTHING_READ;
  }
  if (downstreamFormat == null || !downstreamFormat.equals(mediaChunk.format)) {
    notifyDownstreamFormatChanged(mediaChunk.format.id,mediaChunk.trigger,mediaChunk.startTimeUs);
    downstreamFormat=mediaChunk.format;
  }
  if (!mediaChunk.prepare()) {
    return NOTHING_READ;
  }
  MediaFormat mediaFormat=mediaChunk.getMediaFormat();
  if (mediaFormat != null && !mediaFormat.equals(downstreamMediaFormat)) {
    chunkSource.getMaxVideoDimensions(mediaFormat);
    formatHolder.format=mediaFormat;
    formatHolder.drmInitData=mediaChunk.getPsshInfo();
    downstreamMediaFormat=mediaFormat;
    return FORMAT_READ;
  }
  if (mediaChunk.read(sampleHolder)) {
    sampleHolder.decodeOnly=frameAccurateSeeking && sampleHolder.timeUs < lastSeekPositionUs;
    onSampleRead(mediaChunk,sampleHolder);
    return SAMPLE_READ;
  }
 else {
    if (currentLoadableException != null) {
      throw currentLoadableException;
    }
    return NOTHING_READ;
  }
}","@Override public int readData(int track,long playbackPositionUs,FormatHolder formatHolder,SampleHolder sampleHolder,boolean onlyReadDiscontinuity) throws IOException {
  Assertions.checkState(state == STATE_ENABLED);
  Assertions.checkState(track == 0);
  if (pendingDiscontinuity) {
    pendingDiscontinuity=false;
    return DISCONTINUITY_READ;
  }
  if (onlyReadDiscontinuity) {
    return NOTHING_READ;
  }
  downstreamPositionUs=playbackPositionUs;
  if (isPendingReset()) {
    if (currentLoadableException != null) {
      throw currentLoadableException;
    }
    IOException chunkSourceException=chunkSource.getError();
    if (chunkSourceException != null) {
      throw chunkSourceException;
    }
    return NOTHING_READ;
  }
  MediaChunk mediaChunk=mediaChunks.getFirst();
  if (mediaChunk.isReadFinished()) {
    if (mediaChunks.size() > 1) {
      discardDownstreamMediaChunk();
      mediaChunk=mediaChunks.getFirst();
      mediaChunk.seekToStart();
      return readData(track,playbackPositionUs,formatHolder,sampleHolder,false);
    }
 else     if (mediaChunk.isLastChunk()) {
      return END_OF_STREAM;
    }
    IOException chunkSourceException=chunkSource.getError();
    if (chunkSourceException != null) {
      throw chunkSourceException;
    }
    return NOTHING_READ;
  }
  if (downstreamFormat == null || !downstreamFormat.equals(mediaChunk.format)) {
    notifyDownstreamFormatChanged(mediaChunk.format.id,mediaChunk.trigger,mediaChunk.startTimeUs);
    downstreamFormat=mediaChunk.format;
  }
  if (!mediaChunk.prepare()) {
    return NOTHING_READ;
  }
  MediaFormat mediaFormat=mediaChunk.getMediaFormat();
  if (mediaFormat != null && !mediaFormat.equals(downstreamMediaFormat,true)) {
    chunkSource.getMaxVideoDimensions(mediaFormat);
    formatHolder.format=mediaFormat;
    formatHolder.drmInitData=mediaChunk.getPsshInfo();
    downstreamMediaFormat=mediaFormat;
    return FORMAT_READ;
  }
  if (mediaChunk.read(sampleHolder)) {
    sampleHolder.decodeOnly=frameAccurateSeeking && sampleHolder.timeUs < lastSeekPositionUs;
    onSampleRead(mediaChunk,sampleHolder);
    return SAMPLE_READ;
  }
 else {
    if (currentLoadableException != null) {
      throw currentLoadableException;
    }
    return NOTHING_READ;
  }
}",0.9988925802879292
110482,"/** 
 * Seeks to the beginning of the chunk.
 */
public final void seekToStart(){
  seekTo(startTimeUs,false);
}","/** 
 * Seeks to the beginning of the chunk.
 */
public abstract void seekToStart();",0.7857142857142857
110483,"@Override public void onManifest(String contentId,SmoothStreamingManifest manifest){
  Handler mainHandler=player.getMainHandler();
  LoadControl loadControl=new DefaultLoadControl(new BufferPool(BUFFER_SEGMENT_SIZE));
  DefaultBandwidthMeter bandwidthMeter=new DefaultBandwidthMeter(mainHandler,player);
  DrmSessionManager drmSessionManager=null;
  if (manifest.protectionElement != null) {
    if (Util.SDK_INT < 18) {
      callback.onRenderersError(new UnsupportedOperationException(""String_Node_Str"" + Util.SDK_INT));
      return;
    }
    try {
      drmSessionManager=V18Compat.getDrmSessionManager(manifest.protectionElement.uuid,player,drmCallback);
    }
 catch (    UnsupportedSchemeException e) {
      callback.onRenderersError(e);
      return;
    }
  }
  int maxDecodableFrameSize=MediaCodecUtil.maxH264DecodableFrameSize();
  int audioStreamElementCount=0;
  int textStreamElementCount=0;
  int videoStreamElementIndex=-1;
  ArrayList<Integer> videoTrackIndexList=new ArrayList<Integer>();
  for (int i=0; i < manifest.streamElements.length; i++) {
    if (manifest.streamElements[i].type == StreamElement.TYPE_AUDIO) {
      audioStreamElementCount++;
    }
 else     if (manifest.streamElements[i].type == StreamElement.TYPE_TEXT) {
      textStreamElementCount++;
    }
 else     if (videoStreamElementIndex == -1 && manifest.streamElements[i].type == StreamElement.TYPE_VIDEO) {
      videoStreamElementIndex=i;
      StreamElement streamElement=manifest.streamElements[i];
      for (int j=0; j < streamElement.tracks.length; j++) {
        TrackElement trackElement=streamElement.tracks[j];
        if (trackElement.maxWidth * trackElement.maxHeight <= maxDecodableFrameSize) {
          videoTrackIndexList.add(j);
        }
 else {
        }
      }
    }
  }
  int[] videoTrackIndices=new int[videoTrackIndexList.size()];
  for (int i=0; i < videoTrackIndexList.size(); i++) {
    videoTrackIndices[i]=videoTrackIndexList.get(i);
  }
  DataSource videoDataSource=new HttpDataSource(userAgent,HttpDataSource.REJECT_PAYWALL_TYPES,bandwidthMeter);
  ChunkSource videoChunkSource=new SmoothStreamingChunkSource(url,manifest,videoStreamElementIndex,videoTrackIndices,videoDataSource,new AdaptiveEvaluator(bandwidthMeter));
  ChunkSampleSource videoSampleSource=new ChunkSampleSource(videoChunkSource,loadControl,VIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE,true,mainHandler,player,DemoPlayer.TYPE_VIDEO);
  MediaCodecVideoTrackRenderer videoRenderer=new MediaCodecVideoTrackRenderer(videoSampleSource,drmSessionManager,true,MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT,5000,mainHandler,player,50);
  final String[] audioTrackNames;
  final MultiTrackChunkSource audioChunkSource;
  final MediaCodecAudioTrackRenderer audioRenderer;
  if (audioStreamElementCount == 0) {
    audioTrackNames=null;
    audioChunkSource=null;
    audioRenderer=null;
  }
 else {
    audioTrackNames=new String[audioStreamElementCount];
    ChunkSource[] audioChunkSources=new ChunkSource[audioStreamElementCount];
    DataSource audioDataSource=new HttpDataSource(userAgent,HttpDataSource.REJECT_PAYWALL_TYPES,bandwidthMeter);
    FormatEvaluator audioFormatEvaluator=new FormatEvaluator.FixedEvaluator();
    audioStreamElementCount=0;
    for (int i=0; i < manifest.streamElements.length; i++) {
      if (manifest.streamElements[i].type == StreamElement.TYPE_AUDIO) {
        audioTrackNames[audioStreamElementCount]=manifest.streamElements[i].name;
        audioChunkSources[audioStreamElementCount]=new SmoothStreamingChunkSource(url,manifest,i,new int[]{0},audioDataSource,audioFormatEvaluator);
        audioStreamElementCount++;
      }
    }
    audioChunkSource=new MultiTrackChunkSource(audioChunkSources);
    ChunkSampleSource audioSampleSource=new ChunkSampleSource(audioChunkSource,loadControl,AUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE,true,mainHandler,player,DemoPlayer.TYPE_AUDIO);
    audioRenderer=new MediaCodecAudioTrackRenderer(audioSampleSource,drmSessionManager,true,mainHandler,player);
  }
  final String[] textTrackNames;
  final MultiTrackChunkSource textChunkSource;
  final TrackRenderer textRenderer;
  if (textStreamElementCount == 0) {
    textTrackNames=null;
    textChunkSource=null;
    textRenderer=null;
  }
 else {
    textTrackNames=new String[textStreamElementCount];
    ChunkSource[] textChunkSources=new ChunkSource[textStreamElementCount];
    DataSource ttmlDataSource=new HttpDataSource(userAgent,HttpDataSource.REJECT_PAYWALL_TYPES,bandwidthMeter);
    FormatEvaluator ttmlFormatEvaluator=new FormatEvaluator.FixedEvaluator();
    textStreamElementCount=0;
    for (int i=0; i < manifest.streamElements.length; i++) {
      if (manifest.streamElements[i].type == StreamElement.TYPE_TEXT) {
        textTrackNames[textStreamElementCount]=manifest.streamElements[i].language;
        textChunkSources[textStreamElementCount]=new SmoothStreamingChunkSource(url,manifest,i,new int[]{0},ttmlDataSource,ttmlFormatEvaluator);
        textStreamElementCount++;
      }
    }
    textChunkSource=new MultiTrackChunkSource(textChunkSources);
    ChunkSampleSource ttmlSampleSource=new ChunkSampleSource(textChunkSource,loadControl,TTML_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE,true,mainHandler,player,DemoPlayer.TYPE_TEXT);
    textRenderer=new TextTrackRenderer(ttmlSampleSource,new TtmlParser(),player,mainHandler.getLooper());
  }
  TrackRenderer debugRenderer=debugTextView != null ? new DebugTrackRenderer(debugTextView,videoRenderer,videoSampleSource) : null;
  String[][] trackNames=new String[DemoPlayer.RENDERER_COUNT][];
  trackNames[DemoPlayer.TYPE_AUDIO]=audioTrackNames;
  trackNames[DemoPlayer.TYPE_TEXT]=textTrackNames;
  MultiTrackChunkSource[] multiTrackChunkSources=new MultiTrackChunkSource[DemoPlayer.RENDERER_COUNT];
  multiTrackChunkSources[DemoPlayer.TYPE_AUDIO]=audioChunkSource;
  multiTrackChunkSources[DemoPlayer.TYPE_TEXT]=textChunkSource;
  TrackRenderer[] renderers=new TrackRenderer[DemoPlayer.RENDERER_COUNT];
  renderers[DemoPlayer.TYPE_VIDEO]=videoRenderer;
  renderers[DemoPlayer.TYPE_AUDIO]=audioRenderer;
  renderers[DemoPlayer.TYPE_TEXT]=textRenderer;
  renderers[DemoPlayer.TYPE_DEBUG]=debugRenderer;
  callback.onRenderers(trackNames,multiTrackChunkSources,renderers);
}","@Override public void onManifest(String contentId,SmoothStreamingManifest manifest){
  Handler mainHandler=player.getMainHandler();
  LoadControl loadControl=new DefaultLoadControl(new BufferPool(BUFFER_SEGMENT_SIZE));
  DefaultBandwidthMeter bandwidthMeter=new DefaultBandwidthMeter(mainHandler,player);
  DrmSessionManager drmSessionManager=null;
  if (manifest.protectionElement != null) {
    if (Util.SDK_INT < 18) {
      callback.onRenderersError(new UnsupportedOperationException(""String_Node_Str"" + Util.SDK_INT));
      return;
    }
    try {
      drmSessionManager=V18Compat.getDrmSessionManager(manifest.protectionElement.uuid,player,drmCallback);
    }
 catch (    Exception e) {
      callback.onRenderersError(e);
      return;
    }
  }
  int maxDecodableFrameSize=MediaCodecUtil.maxH264DecodableFrameSize();
  int audioStreamElementCount=0;
  int textStreamElementCount=0;
  int videoStreamElementIndex=-1;
  ArrayList<Integer> videoTrackIndexList=new ArrayList<Integer>();
  for (int i=0; i < manifest.streamElements.length; i++) {
    if (manifest.streamElements[i].type == StreamElement.TYPE_AUDIO) {
      audioStreamElementCount++;
    }
 else     if (manifest.streamElements[i].type == StreamElement.TYPE_TEXT) {
      textStreamElementCount++;
    }
 else     if (videoStreamElementIndex == -1 && manifest.streamElements[i].type == StreamElement.TYPE_VIDEO) {
      videoStreamElementIndex=i;
      StreamElement streamElement=manifest.streamElements[i];
      for (int j=0; j < streamElement.tracks.length; j++) {
        TrackElement trackElement=streamElement.tracks[j];
        if (trackElement.maxWidth * trackElement.maxHeight <= maxDecodableFrameSize) {
          videoTrackIndexList.add(j);
        }
 else {
        }
      }
    }
  }
  int[] videoTrackIndices=new int[videoTrackIndexList.size()];
  for (int i=0; i < videoTrackIndexList.size(); i++) {
    videoTrackIndices[i]=videoTrackIndexList.get(i);
  }
  DataSource videoDataSource=new HttpDataSource(userAgent,HttpDataSource.REJECT_PAYWALL_TYPES,bandwidthMeter);
  ChunkSource videoChunkSource=new SmoothStreamingChunkSource(url,manifest,videoStreamElementIndex,videoTrackIndices,videoDataSource,new AdaptiveEvaluator(bandwidthMeter));
  ChunkSampleSource videoSampleSource=new ChunkSampleSource(videoChunkSource,loadControl,VIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE,true,mainHandler,player,DemoPlayer.TYPE_VIDEO);
  MediaCodecVideoTrackRenderer videoRenderer=new MediaCodecVideoTrackRenderer(videoSampleSource,drmSessionManager,true,MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT,5000,mainHandler,player,50);
  final String[] audioTrackNames;
  final MultiTrackChunkSource audioChunkSource;
  final MediaCodecAudioTrackRenderer audioRenderer;
  if (audioStreamElementCount == 0) {
    audioTrackNames=null;
    audioChunkSource=null;
    audioRenderer=null;
  }
 else {
    audioTrackNames=new String[audioStreamElementCount];
    ChunkSource[] audioChunkSources=new ChunkSource[audioStreamElementCount];
    DataSource audioDataSource=new HttpDataSource(userAgent,HttpDataSource.REJECT_PAYWALL_TYPES,bandwidthMeter);
    FormatEvaluator audioFormatEvaluator=new FormatEvaluator.FixedEvaluator();
    audioStreamElementCount=0;
    for (int i=0; i < manifest.streamElements.length; i++) {
      if (manifest.streamElements[i].type == StreamElement.TYPE_AUDIO) {
        audioTrackNames[audioStreamElementCount]=manifest.streamElements[i].name;
        audioChunkSources[audioStreamElementCount]=new SmoothStreamingChunkSource(url,manifest,i,new int[]{0},audioDataSource,audioFormatEvaluator);
        audioStreamElementCount++;
      }
    }
    audioChunkSource=new MultiTrackChunkSource(audioChunkSources);
    ChunkSampleSource audioSampleSource=new ChunkSampleSource(audioChunkSource,loadControl,AUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE,true,mainHandler,player,DemoPlayer.TYPE_AUDIO);
    audioRenderer=new MediaCodecAudioTrackRenderer(audioSampleSource,drmSessionManager,true,mainHandler,player);
  }
  final String[] textTrackNames;
  final MultiTrackChunkSource textChunkSource;
  final TrackRenderer textRenderer;
  if (textStreamElementCount == 0) {
    textTrackNames=null;
    textChunkSource=null;
    textRenderer=null;
  }
 else {
    textTrackNames=new String[textStreamElementCount];
    ChunkSource[] textChunkSources=new ChunkSource[textStreamElementCount];
    DataSource ttmlDataSource=new HttpDataSource(userAgent,HttpDataSource.REJECT_PAYWALL_TYPES,bandwidthMeter);
    FormatEvaluator ttmlFormatEvaluator=new FormatEvaluator.FixedEvaluator();
    textStreamElementCount=0;
    for (int i=0; i < manifest.streamElements.length; i++) {
      if (manifest.streamElements[i].type == StreamElement.TYPE_TEXT) {
        textTrackNames[textStreamElementCount]=manifest.streamElements[i].language;
        textChunkSources[textStreamElementCount]=new SmoothStreamingChunkSource(url,manifest,i,new int[]{0},ttmlDataSource,ttmlFormatEvaluator);
        textStreamElementCount++;
      }
    }
    textChunkSource=new MultiTrackChunkSource(textChunkSources);
    ChunkSampleSource ttmlSampleSource=new ChunkSampleSource(textChunkSource,loadControl,TTML_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE,true,mainHandler,player,DemoPlayer.TYPE_TEXT);
    textRenderer=new TextTrackRenderer(ttmlSampleSource,new TtmlParser(),player,mainHandler.getLooper());
  }
  TrackRenderer debugRenderer=debugTextView != null ? new DebugTrackRenderer(debugTextView,videoRenderer,videoSampleSource) : null;
  String[][] trackNames=new String[DemoPlayer.RENDERER_COUNT][];
  trackNames[DemoPlayer.TYPE_AUDIO]=audioTrackNames;
  trackNames[DemoPlayer.TYPE_TEXT]=textTrackNames;
  MultiTrackChunkSource[] multiTrackChunkSources=new MultiTrackChunkSource[DemoPlayer.RENDERER_COUNT];
  multiTrackChunkSources[DemoPlayer.TYPE_AUDIO]=audioChunkSource;
  multiTrackChunkSources[DemoPlayer.TYPE_TEXT]=textChunkSource;
  TrackRenderer[] renderers=new TrackRenderer[DemoPlayer.RENDERER_COUNT];
  renderers[DemoPlayer.TYPE_VIDEO]=videoRenderer;
  renderers[DemoPlayer.TYPE_AUDIO]=audioRenderer;
  renderers[DemoPlayer.TYPE_TEXT]=textRenderer;
  renderers[DemoPlayer.TYPE_DEBUG]=debugRenderer;
  callback.onRenderers(trackNames,multiTrackChunkSources,renderers);
}",0.9986379296530726
110484,"@Override public synchronized void onTransferEnd(){
  Assertions.checkState(streamCount > 0);
  long nowMs=clock.elapsedRealtime();
  int elapsedMs=(int)(nowMs - startTimeMs);
  if (elapsedMs > 0) {
    float bytesPerSecond=accumulator * 1000 / elapsedMs;
    slidingPercentile.addSample(computeWeight(accumulator),bytesPerSecond);
    float bandwidthEstimateFloat=slidingPercentile.getPercentile(0.5f);
    bandwidthEstimate=bandwidthEstimateFloat == Float.NaN ? NO_ESTIMATE : (long)bandwidthEstimateFloat;
    notifyBandwidthSample(elapsedMs,accumulator,bandwidthEstimate);
  }
  streamCount--;
  if (streamCount > 0) {
    startTimeMs=nowMs;
  }
  accumulator=0;
}","@Override public synchronized void onTransferEnd(){
  Assertions.checkState(streamCount > 0);
  long nowMs=clock.elapsedRealtime();
  int elapsedMs=(int)(nowMs - startTimeMs);
  if (elapsedMs > 0) {
    float bytesPerSecond=accumulator * 1000 / elapsedMs;
    slidingPercentile.addSample(computeWeight(accumulator),bytesPerSecond);
    float bandwidthEstimateFloat=slidingPercentile.getPercentile(0.5f);
    bandwidthEstimate=Float.isNaN(bandwidthEstimateFloat) ? NO_ESTIMATE : (long)bandwidthEstimateFloat;
    notifyBandwidthSample(elapsedMs,accumulator,bandwidthEstimate);
  }
  streamCount--;
  if (streamCount > 0) {
    startTimeMs=nowMs;
  }
  accumulator=0;
}",0.9625187406296852
110485,"public long getDuration(){
  return mAnimatorSet.getDuration();
}","public long getDuration(){
}",0.6021505376344086
110486,"@SuppressWarnings(""String_Node_Str"") private Channel acquireUploadChannel() throws InterruptedException {
  Promise<Channel> channelReady=eventLoop.next().newPromise();
  channelPool.acquire().addListener((  Future<Channel> channelAcquired) -> {
    if (!channelAcquired.isSuccess()) {
      channelReady.setFailure(channelAcquired.cause());
      return;
    }
    try {
      Channel ch=channelAcquired.getNow();
      ChannelPipeline p=ch.pipeline();
      p.addLast(new HttpResponseDecoder());
      p.addLast(new HttpObjectAggregator(10 * 1024));
      p.addLast(new HttpRequestEncoder());
      p.addLast(new ChunkedWriteHandler());
      p.addLast(new HttpUploadHandler(creds));
      channelReady.setSuccess(ch);
    }
 catch (    Throwable t) {
      channelReady.setFailure(t);
    }
  }
);
  try {
    return channelReady.get();
  }
 catch (  ExecutionException e) {
    PlatformDependent.throwException(e.getCause());
    return null;
  }
}","@SuppressWarnings(""String_Node_Str"") private Channel acquireUploadChannel() throws InterruptedException {
  Promise<Channel> channelReady=eventLoop.next().newPromise();
  channelPool.acquire().addListener((  Future<Channel> channelAcquired) -> {
    if (!channelAcquired.isSuccess()) {
      channelReady.setFailure(channelAcquired.cause());
      return;
    }
    try {
      Channel ch=channelAcquired.getNow();
      ChannelPipeline p=ch.pipeline();
      p.addLast(new HttpResponseDecoder());
      p.addLast(new HttpObjectAggregator(10 * 1024));
      p.addLast(new HttpRequestEncoder());
      p.addLast(new ChunkedWriteHandler());
synchronized (credentialsLock) {
        p.addLast(new HttpUploadHandler(creds));
      }
      channelReady.setSuccess(ch);
    }
 catch (    Throwable t) {
      channelReady.setFailure(t);
    }
  }
);
  try {
    return channelReady.get();
  }
 catch (  ExecutionException e) {
    PlatformDependent.throwException(e.getCause());
    return null;
  }
}",0.9666153055983564
110487,"@SuppressWarnings(""String_Node_Str"") private Future<Channel> acquireDownloadChannel(){
  Promise<Channel> channelReady=eventLoop.next().newPromise();
  channelPool.acquire().addListener((  Future<Channel> channelAcquired) -> {
    if (!channelAcquired.isSuccess()) {
      channelReady.setFailure(channelAcquired.cause());
      return;
    }
    try {
      Channel ch=channelAcquired.getNow();
      ChannelPipeline p=ch.pipeline();
      ch.pipeline().addFirst(""String_Node_Str"",new ReadTimeoutHandler(timeoutMillis));
      p.addLast(new HttpClientCodec());
      p.addLast(new HttpDownloadHandler(creds));
      channelReady.setSuccess(ch);
    }
 catch (    Throwable t) {
      channelReady.setFailure(t);
    }
  }
);
  return channelReady;
}","@SuppressWarnings(""String_Node_Str"") private Future<Channel> acquireDownloadChannel(){
  Promise<Channel> channelReady=eventLoop.next().newPromise();
  channelPool.acquire().addListener((  Future<Channel> channelAcquired) -> {
    if (!channelAcquired.isSuccess()) {
      channelReady.setFailure(channelAcquired.cause());
      return;
    }
    try {
      Channel ch=channelAcquired.getNow();
      ChannelPipeline p=ch.pipeline();
      ch.pipeline().addFirst(""String_Node_Str"",new ReadTimeoutHandler(timeoutMillis));
      p.addLast(new HttpClientCodec());
synchronized (credentialsLock) {
        p.addLast(new HttpDownloadHandler(creds));
      }
      channelReady.setSuccess(ch);
    }
 catch (    Throwable t) {
      channelReady.setFailure(t);
    }
  }
);
  return channelReady;
}",0.9578742709008424
110488,"@Override public Thread newThread(final Runnable runnable){
  final Thread t=new Thread(null,runnable,""String_Node_Str"" + threadInitNumber.getAndIncrement(),THREAD_STACK_SIZE);
  t.setDaemon(true);
  return t;
}","@Override public Thread newThread(final Runnable runnable){
  final Thread t=new Thread(null,runnable,""String_Node_Str"" + threadInitNumber.getAndIncrement());
  t.setDaemon(true);
  return t;
}",0.9554455445544554
110489,"static QueryTaskFuture<Predicate<SkyKey>> getDTCSkyKeyPredicateFuture(SkyQueryEnvironment env,QueryExpression expression,QueryExpressionContext<Target> context,int processResultsBatchSize,int concurrencyLevel){
  QueryTaskFuture<ThreadSafeMutableSet<Target>> universeValueFuture=QueryUtil.evalAll(env,context,expression);
  Function<ThreadSafeMutableSet<Target>,QueryTaskFuture<Predicate<SkyKey>>> getTransitiveClosureAsyncFunction=universeValue -> {
    ThreadSafeAggregateAllSkyKeysCallback aggregateAllCallback=new ThreadSafeAggregateAllSkyKeysCallback(concurrencyLevel);
    return env.executeAsync(() -> {
      Callback<Target> visitorCallback=ParallelVisitor.createParallelVisitorCallback(new TransitiveTraversalValueDTCVisitor.Factory(env,env.createSkyKeyUniquifier(),processResultsBatchSize,aggregateAllCallback));
      visitorCallback.process(universeValue);
      return Predicates.in(aggregateAllCallback.getResult());
    }
);
  }
;
  return env.transformAsync(universeValueFuture,getTransitiveClosureAsyncFunction);
}","static QueryTaskFuture<Predicate<SkyKey>> getDTCSkyKeyPredicateFuture(SkyQueryEnvironment env,QueryExpression expression,QueryExpressionContext<Target> context,int processResultsBatchSize,int concurrencyLevel){
  QueryTaskFuture<ThreadSafeMutableSet<Target>> universeValueFuture=QueryUtil.evalAll(env,context,expression);
  Function<ThreadSafeMutableSet<Target>,QueryTaskFuture<Predicate<SkyKey>>> getTransitiveClosureAsyncFunction=universeValue -> {
    ThreadSafeAggregateAllSkyKeysCallback aggregateAllCallback=new ThreadSafeAggregateAllSkyKeysCallback(concurrencyLevel);
    return env.executeAsync(() -> {
      Callback<Target> visitorCallback=ParallelVisitor.createParallelVisitorCallback(new UnfilteredTransitiveTraversalValueDTCVisitor.Factory(env,env.createSkyKeyUniquifier(),processResultsBatchSize,aggregateAllCallback));
      visitorCallback.process(universeValue);
      return Predicates.in(aggregateAllCallback.getResult());
    }
);
  }
;
  return env.transformAsync(universeValueFuture,getTransitiveClosureAsyncFunction);
}",0.995178399228544
110490,"static QueryTaskFuture<Void> getRdepsInUniverseUnboundedParallel(SkyQueryEnvironment env,QueryExpression expression,Predicate<SkyKey> universe,QueryExpressionContext<Target> context,Callback<Target> callback,MultisetSemaphore<PackageIdentifier> packageSemaphore){
  return env.eval(expression,context,ParallelVisitor.createParallelVisitorCallback(new RdepsUnboundedVisitor.Factory(env,universe,callback,packageSemaphore)));
}","static QueryTaskFuture<Void> getRdepsInUniverseUnboundedParallel(SkyQueryEnvironment env,QueryExpression expression,Predicate<SkyKey> unfilteredUniverse,QueryExpressionContext<Target> context,Callback<Target> callback,MultisetSemaphore<PackageIdentifier> packageSemaphore){
  return env.eval(expression,context,ParallelVisitor.createParallelVisitorCallback(new RdepsUnboundedVisitor.Factory(env,unfilteredUniverse,callback,packageSemaphore)));
}",0.9770114942528736
110491,"RdepsUnboundedVisitor(SkyQueryEnvironment env,Uniquifier<DepAndRdep> depAndRdepUniquifier,Uniquifier<SkyKey> validRdepUniquifier,Predicate<SkyKey> universe,Callback<Target> callback,MultisetSemaphore<PackageIdentifier> packageSemaphore){
  super(env,callback,packageSemaphore);
  this.depAndRdepUniquifier=depAndRdepUniquifier;
  this.validRdepUniquifier=validRdepUniquifier;
  this.universe=universe;
}","RdepsUnboundedVisitor(SkyQueryEnvironment env,Uniquifier<DepAndRdep> depAndRdepUniquifier,Uniquifier<SkyKey> validRdepUniquifier,Predicate<SkyKey> unfilteredUniverse,Callback<Target> callback,MultisetSemaphore<PackageIdentifier> packageSemaphore){
  super(env,callback,packageSemaphore);
  this.depAndRdepUniquifier=depAndRdepUniquifier;
  this.validRdepUniquifier=validRdepUniquifier;
  this.unfilteredUniverse=unfilteredUniverse;
}",0.9641148325358851
110492,"@Override protected Iterable<DepAndRdep> preprocessInitialVisit(Iterable<SkyKey> keys){
  return Iterables.transform(Iterables.filter(keys,k -> universe.apply(k)),key -> new DepAndRdep(null,key));
}","@Override protected Iterable<DepAndRdep> preprocessInitialVisit(Iterable<SkyKey> keys){
  return Iterables.transform(Iterables.filter(keys,k -> unfilteredUniverse.apply(k)),key -> new DepAndRdep(null,key));
}",0.9753694581280788
110493,"Factory(SkyQueryEnvironment env,Predicate<SkyKey> universe,Callback<Target> callback,MultisetSemaphore<PackageIdentifier> packageSemaphore){
  this.env=env;
  this.universe=universe;
  this.depAndRdepUniquifier=new UniquifierImpl<>(depAndRdep -> depAndRdep);
  this.validRdepUniquifier=env.createSkyKeyUniquifier();
  this.callback=callback;
  this.packageSemaphore=packageSemaphore;
}","Factory(SkyQueryEnvironment env,Predicate<SkyKey> unfilteredUniverse,Callback<Target> callback,MultisetSemaphore<PackageIdentifier> packageSemaphore){
  this.env=env;
  this.unfilteredUniverse=unfilteredUniverse;
  this.depAndRdepUniquifier=new UniquifierImpl<>(depAndRdep -> depAndRdep);
  this.validRdepUniquifier=env.createSkyKeyUniquifier();
  this.callback=callback;
  this.packageSemaphore=packageSemaphore;
}",0.9425
110494,"@Override public ParallelVisitor<DepAndRdep,Target> create(){
  return new RdepsUnboundedVisitor(env,depAndRdepUniquifier,validRdepUniquifier,universe,callback,packageSemaphore);
}","@Override public ParallelVisitor<DepAndRdep,Target> create(){
  return new RdepsUnboundedVisitor(env,depAndRdepUniquifier,validRdepUniquifier,unfilteredUniverse,callback,packageSemaphore);
}",0.972972972972973
110495,"@Override protected Visit getVisitResult(Iterable<DepAndRdep> depAndRdeps) throws QueryException, InterruptedException {
  Collection<SkyKey> validRdeps=new ArrayList<>();
  Multimap<SkyKey,SkyKey> reverseDepMultimap=ArrayListMultimap.create();
  for (  DepAndRdep depAndRdep : depAndRdeps) {
    if (depAndRdep.dep == null) {
      validRdeps.add(depAndRdep.rdep);
    }
 else {
      reverseDepMultimap.put(depAndRdep.dep,depAndRdep.rdep);
    }
  }
  Multimap<SkyKey,SkyKey> packageKeyToTargetKeyMap=env.makePackageKeyToTargetKeyMap(Iterables.concat(reverseDepMultimap.values()));
  Set<PackageIdentifier> pkgIdsNeededForTargetification=packageKeyToTargetKeyMap.keySet().stream().map(SkyQueryEnvironment.PACKAGE_SKYKEY_TO_PACKAGE_IDENTIFIER).collect(toImmutableSet());
  packageSemaphore.acquireAll(pkgIdsNeededForTargetification);
  try {
    if (!reverseDepMultimap.isEmpty()) {
      Collection<Target> filteredTargets=env.filterRawReverseDepsOfTransitiveTraversalKeys(reverseDepMultimap.asMap(),packageKeyToTargetKeyMap);
      filteredTargets.stream().map(SkyQueryEnvironment.TARGET_TO_SKY_KEY).forEachOrdered(validRdeps::add);
    }
  }
  finally {
    packageSemaphore.releaseAll(pkgIdsNeededForTargetification);
  }
  ImmutableList.Builder<SkyKey> uniqueValidRdepsbuilder=ImmutableList.builder();
  for (  SkyKey rdep : validRdeps) {
    if (validRdepUniquifier.unique(rdep)) {
      uniqueValidRdepsbuilder.add(rdep);
    }
  }
  ImmutableList<SkyKey> uniqueValidRdeps=uniqueValidRdepsbuilder.build();
  ImmutableList.Builder<DepAndRdep> depAndRdepsToVisitBuilder=ImmutableList.builder();
  env.graph.getReverseDeps(uniqueValidRdeps).entrySet().forEach(reverseDepsEntry -> depAndRdepsToVisitBuilder.addAll(Iterables.transform(Iterables.filter(reverseDepsEntry.getValue(),Predicates.and(SkyQueryEnvironment.IS_TTV,universe)),rdep -> new DepAndRdep(reverseDepsEntry.getKey(),rdep))));
  return new Visit(uniqueValidRdeps,depAndRdepsToVisitBuilder.build());
}","@Override protected Visit getVisitResult(Iterable<DepAndRdep> depAndRdeps) throws QueryException, InterruptedException {
  Collection<SkyKey> validRdeps=new ArrayList<>();
  Multimap<SkyKey,SkyKey> reverseDepMultimap=ArrayListMultimap.create();
  for (  DepAndRdep depAndRdep : depAndRdeps) {
    if (depAndRdep.dep == null) {
      validRdeps.add(depAndRdep.rdep);
    }
 else {
      reverseDepMultimap.put(depAndRdep.dep,depAndRdep.rdep);
    }
  }
  Multimap<SkyKey,SkyKey> packageKeyToTargetKeyMap=env.makePackageKeyToTargetKeyMap(Iterables.concat(reverseDepMultimap.values()));
  Set<PackageIdentifier> pkgIdsNeededForTargetification=packageKeyToTargetKeyMap.keySet().stream().map(SkyQueryEnvironment.PACKAGE_SKYKEY_TO_PACKAGE_IDENTIFIER).collect(toImmutableSet());
  packageSemaphore.acquireAll(pkgIdsNeededForTargetification);
  try {
    if (!reverseDepMultimap.isEmpty()) {
      Collection<Target> filteredTargets=env.filterRawReverseDepsOfTransitiveTraversalKeys(reverseDepMultimap.asMap(),packageKeyToTargetKeyMap);
      filteredTargets.stream().map(SkyQueryEnvironment.TARGET_TO_SKY_KEY).forEachOrdered(validRdeps::add);
    }
  }
  finally {
    packageSemaphore.releaseAll(pkgIdsNeededForTargetification);
  }
  ImmutableList.Builder<SkyKey> uniqueValidRdepsbuilder=ImmutableList.builder();
  for (  SkyKey rdep : validRdeps) {
    if (validRdepUniquifier.unique(rdep)) {
      uniqueValidRdepsbuilder.add(rdep);
    }
  }
  ImmutableList<SkyKey> uniqueValidRdeps=uniqueValidRdepsbuilder.build();
  ImmutableList.Builder<DepAndRdep> depAndRdepsToVisitBuilder=ImmutableList.builder();
  env.graph.getReverseDeps(uniqueValidRdeps).entrySet().forEach(reverseDepsEntry -> depAndRdepsToVisitBuilder.addAll(Iterables.transform(Iterables.filter(reverseDepsEntry.getValue(),Predicates.and(SkyQueryEnvironment.IS_TTV,unfilteredUniverse)),rdep -> new DepAndRdep(reverseDepsEntry.getKey(),rdep))));
  return new Visit(uniqueValidRdeps,depAndRdepsToVisitBuilder.build());
}",0.9974657881398884
110496,"@ThreadSafe @Override public QueryTaskFuture<Void> getRdepsUnboundedParallel(QueryExpression expression,QueryExpression universe,QueryExpressionContext<Target> context,Callback<Target> callback){
  return transformAsync(getUniverseDTCSkyKeyPredicateFuture(universe,context),universePredicate -> ParallelSkyQueryUtils.getRdepsInUniverseUnboundedParallel(this,expression,universePredicate,context,callback,packageSemaphore));
}","@ThreadSafe @Override public QueryTaskFuture<Void> getRdepsUnboundedParallel(QueryExpression expression,QueryExpression universe,QueryExpressionContext<Target> context,Callback<Target> callback){
  return transformAsync(getUnfilteredUniverseDTCSkyKeyPredicateFuture(universe,context),unfilteredUniversePredicate -> ParallelSkyQueryUtils.getRdepsInUniverseUnboundedParallel(this,expression,unfilteredUniversePredicate,context,callback,packageSemaphore));
}",0.9659090909090908
110497,"@ThreadSafe @Override public QueryTaskFuture<Void> getRdepsBoundedParallel(QueryExpression expression,int depth,QueryExpression universe,QueryExpressionContext<Target> context,Callback<Target> callback){
  return transformAsync(getUniverseDTCSkyKeyPredicateFuture(universe,context),universePredicate -> ParallelSkyQueryUtils.getRdepsInUniverseBoundedParallel(this,expression,depth,universePredicate,context,callback,packageSemaphore));
}","@ThreadSafe @Override public QueryTaskFuture<Void> getRdepsBoundedParallel(QueryExpression expression,int depth,QueryExpression universe,QueryExpressionContext<Target> context,Callback<Target> callback){
  return transformAsync(getUnfilteredUniverseDTCSkyKeyPredicateFuture(universe,context),universePredicate -> ParallelSkyQueryUtils.getRdepsInUniverseBoundedParallel(this,expression,depth,universePredicate,context,callback,packageSemaphore));
}",0.98868778280543
110498,"@Test public void testWhitelist() throws Exception {
  SkylarkCcCommonTestHelper.createFiles(scratch,""String_Node_Str"");
  AssertionError e=assertThrows(AssertionError.class,() -> getConfiguredTarget(""String_Node_Str""));
  assertThat(e).hasMessageThat().contains(""String_Node_Str"");
}","@Test public void testWhitelist() throws Exception {
  SkylarkCcCommonTestHelper.createFiles(scratch,""String_Node_Str"");
  reporter.removeHandler(failFastHandler);
  getConfiguredTarget(""String_Node_Str"");
  assertContainsEvent(""String_Node_Str"");
}",0.551594746716698
110499,"@Test public void testLibraryLinkerInputArtifactCategoryError() throws Exception {
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  AssertionError e=assertThrows(AssertionError.class,() -> getConfiguredTarget(""String_Node_Str""));
  assertThat(e).hasMessageThat().contains(""String_Node_Str"" + ""String_Node_Str"");
}","@Test public void testLibraryLinkerInputArtifactCategoryError() throws Exception {
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  reporter.removeHandler(failFastHandler);
  getConfiguredTarget(""String_Node_Str"");
  assertContainsEvent(""String_Node_Str"" + ""String_Node_Str"");
}",0.7717782577393808
110500,"@Test public void testCcLinkingProviderParamsWithoutFlag() throws Exception {
  useConfiguration(""String_Node_Str"");
  setUpCcLinkingProviderParamsTest();
  AssertionError e=assertThrows(AssertionError.class,() -> getConfiguredTarget(""String_Node_Str""));
  assertThat(e).hasMessageThat().contains(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
}","@Test public void testCcLinkingProviderParamsWithoutFlag() throws Exception {
  useConfiguration(""String_Node_Str"");
  setUpCcLinkingProviderParamsTest();
  reporter.removeHandler(failFastHandler);
  getConfiguredTarget(""String_Node_Str"");
  assertContainsEvent(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
}",0.6461086637298091
110501,"@Test public void testEmptyCcLinkingInfoError() throws Exception {
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  AssertionError e=assertThrows(AssertionError.class,() -> getConfiguredTarget(""String_Node_Str""));
  assertThat(e).hasMessageThat().contains(""String_Node_Str"");
}","@Test public void testEmptyCcLinkingInfoError() throws Exception {
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  reporter.removeHandler(failFastHandler);
  getConfiguredTarget(""String_Node_Str"");
  assertContainsEvent(""String_Node_Str"");
}",0.7388949079089924
110502,"@ThreadCompatible private <T extends SkyValue>EvaluationResult<T> doMutatingEvaluation(ImmutableSet<SkyKey> skyKeys) throws InterruptedException, E {
  NodeEntry errorTransienceEntry=Iterables.getOnlyElement(graph.createIfAbsentBatch(null,Reason.PRE_OR_POST_EVALUATION,ImmutableList.of(ErrorTransienceValue.KEY)).values());
  if (!errorTransienceEntry.isDone()) {
    injectValues(ImmutableMap.of(ErrorTransienceValue.KEY,ErrorTransienceValue.INSTANCE),evaluatorContext.getGraphVersion(),graph,evaluatorContext.getProgressReceiver());
  }
  try {
    for (    Map.Entry<SkyKey,? extends NodeEntry> e : graph.createIfAbsentBatch(null,Reason.PRE_OR_POST_EVALUATION,skyKeys).entrySet()) {
      SkyKey skyKey=e.getKey();
      NodeEntry entry=e.getValue();
switch (entry.addReverseDepAndCheckIfDone(null)) {
case NEEDS_SCHEDULING:
        evaluatorContext.getVisitor().enqueueEvaluation(skyKey);
      break;
case DONE:
    informProgressReceiverThatValueIsDone(skyKey,entry);
  break;
case ALREADY_EVALUATING:
break;
default :
throw new IllegalStateException(entry + ""String_Node_Str"" + skyKey+ ""String_Node_Str"");
}
}
}
 catch (InterruptedException e) {
Thread.currentThread().interrupt();
evaluatorContext.getVisitor().waitForCompletion();
throw e;
}
return waitForCompletionAndConstructResult(skyKeys);
}","@ThreadCompatible private <T extends SkyValue>EvaluationResult<T> doMutatingEvaluation(ImmutableSet<SkyKey> skyKeys) throws InterruptedException, E {
  NodeEntry errorTransienceEntry=Iterables.getOnlyElement(graph.createIfAbsentBatch(null,Reason.PRE_OR_POST_EVALUATION,ImmutableList.of(ErrorTransienceValue.KEY)).values());
  if (!errorTransienceEntry.isDone()) {
    injectValues(ImmutableMap.of(ErrorTransienceValue.KEY,ErrorTransienceValue.INSTANCE),evaluatorContext.getGraphVersion(),graph,evaluatorContext.getProgressReceiver());
  }
  try {
    for (    Map.Entry<SkyKey,? extends NodeEntry> e : graph.createIfAbsentBatch(null,Reason.PRE_OR_POST_EVALUATION,skyKeys).entrySet()) {
      SkyKey skyKey=e.getKey();
      NodeEntry entry=e.getValue();
switch (entry.addReverseDepAndCheckIfDone(null)) {
case NEEDS_SCHEDULING:
        evaluatorContext.getVisitor().enqueueEvaluation(skyKey);
      break;
case DONE:
    informProgressReceiverThatValueIsDone(skyKey,entry);
  break;
case ALREADY_EVALUATING:
break;
default :
throw new IllegalStateException(entry + ""String_Node_Str"" + skyKey+ ""String_Node_Str"");
}
}
}
 catch (InterruptedException ie) {
Thread.currentThread().interrupt();
try {
evaluatorContext.getVisitor().waitForCompletion();
}
 catch (SchedulerException se) {
if (!(se.getCause() instanceof InterruptedException)) {
throw se;
}
}
throw ie;
}
return waitForCompletionAndConstructResult(skyKeys);
}",0.953360264414249
110503,"@Override public Map<SkyKey,InMemoryNodeEntry> createIfAbsentBatch(@Nullable SkyKey requestor,Reason reason,Iterable<SkyKey> keys){
  ImmutableMap.Builder<SkyKey,InMemoryNodeEntry> builder=ImmutableMap.builder();
  for (  SkyKey key : keys) {
    builder.put(key,createIfAbsent(key));
  }
  return builder.build();
}","@Override public Map<SkyKey,NodeEntry> createIfAbsentBatch(@Nullable SkyKey requestor,Reason reason,Iterable<SkyKey> keys){
  ImmutableMap.Builder<SkyKey,NodeEntry> builder=ImmutableMap.builder();
  for (  SkyKey key : keys) {
    builder.put(key,createIfAbsent(key));
  }
  return builder.build();
}",0.974025974025974
110504,"@Override public Map<SkyKey,SkyValue> getValues(){
  return Collections.unmodifiableMap(Maps.transformValues(nodeMap,new Function<InMemoryNodeEntry,SkyValue>(){
    @Override public SkyValue apply(    InMemoryNodeEntry entry){
      return entry.toValue();
    }
  }
));
}","@Override public Map<SkyKey,SkyValue> getValues(){
  return Collections.unmodifiableMap(Maps.transformValues(nodeMap,entry -> {
    try {
      return entry.toValue();
    }
 catch (    InterruptedException e) {
      throw new IllegalStateException(e);
    }
  }
));
}",0.5175600739371534
110505,"@Override public Map<SkyKey,SkyValue> getDoneValues(){
  return Collections.unmodifiableMap(Maps.filterValues(Maps.transformValues(nodeMap,new Function<InMemoryNodeEntry,SkyValue>(){
    @Override public SkyValue apply(    InMemoryNodeEntry entry){
      return entry.isDone() ? entry.getValue() : null;
    }
  }
),Predicates.notNull()));
}","@Override public Map<SkyKey,SkyValue> getDoneValues(){
  return Collections.unmodifiableMap(Maps.filterValues(Maps.transformValues(nodeMap,entry -> {
    if (!entry.isDone()) {
      return null;
    }
    try {
      return entry.getValue();
    }
 catch (    InterruptedException e) {
      throw new IllegalStateException(e);
    }
  }
),Predicates.notNull()));
}",0.5176803394625177
110506,"protected InMemoryNodeEntry createIfAbsent(SkyKey key){
  InMemoryNodeEntry newval=keepEdges ? new InMemoryNodeEntry() : new EdgelessInMemoryNodeEntry();
  InMemoryNodeEntry oldval=nodeMap.putIfAbsent(key,newval);
  return oldval == null ? newval : oldval;
}","protected NodeEntry createIfAbsent(SkyKey key){
  NodeEntry newval=newNodeEntry(key);
  NodeEntry oldval=nodeMap.putIfAbsent(key,newval);
  return oldval == null ? newval : oldval;
}",0.8227272727272728
110507,"@Override public Map<SkyKey,InMemoryNodeEntry> getAllValues(){
  return Collections.unmodifiableMap(nodeMap);
}","@Override public Map<SkyKey,NodeEntry> getAllValues(){
  return Collections.unmodifiableMap(nodeMap);
}",0.9626168224299064
110508,"@Override public Map<SkyKey,NodeEntry> getBatch(SkyKey requestor,Reason reason,Iterable<? extends SkyKey> keys){
  HashMap<SkyKey,NodeEntry> result=new HashMap<>();
  for (  SkyKey key : keys) {
    InMemoryNodeEntry entry=get(null,Reason.OTHER,key);
    if (entry != null) {
      result.put(key,entry);
    }
  }
  return result;
}","@Override public Map<SkyKey,NodeEntry> getBatch(SkyKey requestor,Reason reason,Iterable<? extends SkyKey> keys){
  HashMap<SkyKey,NodeEntry> result=new HashMap<>();
  for (  SkyKey key : keys) {
    NodeEntry entry=get(null,Reason.OTHER,key);
    if (entry != null) {
      result.put(key,entry);
    }
  }
  return result;
}",0.9878419452887538
110509,"@Override public InMemoryNodeEntry get(@Nullable SkyKey requestor,Reason reason,SkyKey skyKey){
  return nodeMap.get(skyKey);
}","@Override public NodeEntry get(@Nullable SkyKey requestor,Reason reason,SkyKey skyKey){
  return nodeMap.get(skyKey);
}",0.967479674796748
110510,"/** 
 * Download the output files and directory trees of a remotely executed action to the local machine, as well stdin / stdout to the given files. <p>In case of failure, this method deletes any output files it might have already created.
 * @throws IOException in case of a cache miss or if the remote cache is unavailable.
 * @throws ExecException in case clean up after a failed download failed.
 */
public void download(ActionResult result,Path execRoot,FileOutErr outErr) throws ExecException, IOException, InterruptedException {
  try {
    Context ctx=Context.current();
    List<FuturePathBooleanTuple> fileDownloads=Collections.synchronizedList(new ArrayList<>(result.getOutputFilesCount() + result.getOutputDirectoriesCount()));
    for (    OutputFile file : result.getOutputFilesList()) {
      Path path=execRoot.getRelative(file.getPath());
      ListenableFuture<Void> download=retrier.executeAsync(() -> ctx.call(() -> downloadFile(path,file.getDigest(),file.getContent())));
      fileDownloads.add(new FuturePathBooleanTuple(download,path,file.getIsExecutable()));
    }
    List<ListenableFuture<Void>> dirDownloads=new ArrayList<>(result.getOutputDirectoriesCount());
    for (    OutputDirectory dir : result.getOutputDirectoriesList()) {
      SettableFuture<Void> dirDownload=SettableFuture.create();
      ListenableFuture<byte[]> protoDownload=retrier.executeAsync(() -> ctx.call(() -> downloadBlob(dir.getTreeDigest())));
      Futures.addCallback(protoDownload,new FutureCallback<byte[]>(){
        @Override public void onSuccess(        byte[] b){
          try {
            Tree tree=Tree.parseFrom(b);
            Map<Digest,Directory> childrenMap=new HashMap<>();
            for (            Directory child : tree.getChildrenList()) {
              childrenMap.put(digestUtil.compute(child),child);
            }
            Path path=execRoot.getRelative(dir.getPath());
            fileDownloads.addAll(downloadDirectory(path,tree.getRoot(),childrenMap,ctx));
            dirDownload.set(null);
          }
 catch (          IOException e) {
            dirDownload.setException(e);
          }
        }
        @Override public void onFailure(        Throwable t){
          dirDownload.setException(t);
        }
      }
,MoreExecutors.directExecutor());
      dirDownloads.add(dirDownload);
    }
    fileDownloads.addAll(downloadOutErr(result,outErr,ctx));
    for (    ListenableFuture<Void> dirDownload : dirDownloads) {
      getFromFuture(dirDownload);
    }
    for (    FuturePathBooleanTuple download : fileDownloads) {
      getFromFuture(download.getFuture());
      if (download.getPath() != null) {
        download.getPath().setExecutable(download.isExecutable());
      }
    }
  }
 catch (  IOException downloadException) {
    try {
      for (      OutputFile file : result.getOutputFilesList()) {
        execRoot.getRelative(file.getPath()).delete();
      }
      for (      OutputDirectory directory : result.getOutputDirectoriesList()) {
        FileSystemUtils.deleteTree(execRoot.getRelative(directory.getPath()));
      }
      if (outErr != null) {
        outErr.getOutputPath().delete();
        outErr.getErrorPath().delete();
      }
    }
 catch (    IOException e) {
      throw new EnvironmentalExecException(""String_Node_Str"" + ""String_Node_Str"",e,true);
    }
    throw downloadException;
  }
}","/** 
 * Download the output files and directory trees of a remotely executed action to the local machine, as well stdin / stdout to the given files. <p>In case of failure, this method deletes any output files it might have already created.
 * @throws IOException in case of a cache miss or if the remote cache is unavailable.
 * @throws ExecException in case clean up after a failed download failed.
 */
public void download(ActionResult result,Path execRoot,FileOutErr outErr) throws ExecException, IOException, InterruptedException {
  Context ctx=Context.current();
  List<FuturePathBooleanTuple> fileDownloads=Collections.synchronizedList(new ArrayList<>(result.getOutputFilesCount() + result.getOutputDirectoriesCount()));
  for (  OutputFile file : result.getOutputFilesList()) {
    Path path=execRoot.getRelative(file.getPath());
    ListenableFuture<Void> download=retrier.executeAsync(() -> ctx.call(() -> downloadFile(path,file.getDigest(),file.getContent())));
    fileDownloads.add(new FuturePathBooleanTuple(download,path,file.getIsExecutable()));
  }
  List<ListenableFuture<Void>> dirDownloads=new ArrayList<>(result.getOutputDirectoriesCount());
  for (  OutputDirectory dir : result.getOutputDirectoriesList()) {
    SettableFuture<Void> dirDownload=SettableFuture.create();
    ListenableFuture<byte[]> protoDownload=retrier.executeAsync(() -> ctx.call(() -> downloadBlob(dir.getTreeDigest())));
    Futures.addCallback(protoDownload,new FutureCallback<byte[]>(){
      @Override public void onSuccess(      byte[] b){
        try {
          Tree tree=Tree.parseFrom(b);
          Map<Digest,Directory> childrenMap=new HashMap<>();
          for (          Directory child : tree.getChildrenList()) {
            childrenMap.put(digestUtil.compute(child),child);
          }
          Path path=execRoot.getRelative(dir.getPath());
          fileDownloads.addAll(downloadDirectory(path,tree.getRoot(),childrenMap,ctx));
          dirDownload.set(null);
        }
 catch (        IOException e) {
          dirDownload.setException(e);
        }
      }
      @Override public void onFailure(      Throwable t){
        dirDownload.setException(t);
      }
    }
,MoreExecutors.directExecutor());
    dirDownloads.add(dirDownload);
  }
  IOException downloadException=null;
  try {
    fileDownloads.addAll(downloadOutErr(result,outErr,ctx));
  }
 catch (  IOException e) {
    downloadException=e;
  }
  for (  ListenableFuture<Void> dirDownload : dirDownloads) {
    try {
      getFromFuture(dirDownload);
    }
 catch (    IOException e) {
      downloadException=downloadException == null ? e : downloadException;
    }
  }
  for (  FuturePathBooleanTuple download : fileDownloads) {
    try {
      getFromFuture(download.getFuture());
      if (download.getPath() != null) {
        download.getPath().setExecutable(download.isExecutable());
      }
    }
 catch (    IOException e) {
      downloadException=downloadException == null ? e : downloadException;
    }
  }
  if (downloadException != null) {
    try {
      for (      OutputFile file : result.getOutputFilesList()) {
        execRoot.getRelative(file.getPath()).delete();
      }
      for (      OutputDirectory directory : result.getOutputDirectoriesList()) {
        FileSystemUtils.deleteTree(execRoot.getRelative(directory.getPath()));
      }
      if (outErr != null) {
        outErr.getOutputPath().delete();
        outErr.getErrorPath().delete();
      }
    }
 catch (    IOException e) {
      throw new EnvironmentalExecException(""String_Node_Str"" + ""String_Node_Str"",e,true);
    }
    throw downloadException;
  }
}",0.9307780320366132
110511,"/** 
 * Method responsible for a single Streaming RPC. 
 */
private void publishEventStream(final ConcurrentLinkedDeque<InternalOrderedBuildEvent> pendingAck,final BlockingDeque<InternalOrderedBuildEvent> pendingSend,final BuildEventServiceClient besClient) throws Exception {
  logger.log(Level.INFO,String.format(""String_Node_Str"",pendingSend.size()));
  ListenableFuture<Status> streamDone=besClient.openStream(ackCallback(pendingAck,besClient));
  logger.log(Level.INFO,String.format(""String_Node_Str"",pendingSend.size()));
  try {
    @Nullable InternalOrderedBuildEvent orderedBuildEvent;
    do {
      orderedBuildEvent=pendingSend.pollFirst(STREAMING_RPC_POLL_IN_SECS,TimeUnit.SECONDS);
      if (orderedBuildEvent != null) {
        PathConverter pathConverter;
        try {
          pathConverter=orderedBuildEvent.localFileUploadProgress().get();
        }
 catch (        ExecutionException e) {
          logger.log(Level.WARNING,String.format(""String_Node_Str"" + ""String_Node_Str"",e.getMessage()),e);
          besClient.abortStream(Status.INTERNAL.augmentDescription(e.getMessage()));
          throw e;
        }
catch (        InterruptedException e) {
          Thread.interrupted();
          String additionalDetails=""String_Node_Str"";
          besClient.abortStream(Status.CANCELLED.augmentDescription(additionalDetails));
          throw e;
        }
        pendingAck.add(orderedBuildEvent);
        besClient.sendOverStream(orderedBuildEvent.serialize(pathConverter));
      }
      checkState(besClient.isStreamActive(),""String_Node_Str"");
    }
 while (orderedBuildEvent == null || !orderedBuildEvent.isLastEvent());
    logger.log(Level.INFO,String.format(""String_Node_Str"",orderedBuildEvent.isLastEvent(),besClient.isStreamActive()));
  }
 catch (  InterruptedException e) {
    Thread.interrupted();
    String additionalDetails=""String_Node_Str"";
    besClient.abortStream(Status.CANCELLED.augmentDescription(additionalDetails));
    throw e;
  }
catch (  Exception e) {
    Status status=streamDone.isDone() ? streamDone.get() : null;
    String additionalDetail=e.getMessage();
    logger.log(Level.WARNING,String.format(""String_Node_Str"",status,additionalDetail),e);
    besClient.abortStream(Status.INTERNAL.augmentDescription(additionalDetail));
    throw e;
  }
  try {
    Status status=streamDone.get(PUBLISH_EVENT_STREAM_FINISHED_TIMEOUT.toMillis(),TimeUnit.MILLISECONDS);
    logger.log(Level.INFO,""String_Node_Str"" + status);
  }
 catch (  InterruptedException e) {
    Thread.interrupted();
    String additionalDetails=""String_Node_Str"";
    besClient.abortStream(Status.CANCELLED.augmentDescription(additionalDetails));
    throw e;
  }
catch (  TimeoutException e) {
    String additionalDetail=""String_Node_Str"";
    logger.log(Level.WARNING,""String_Node_Str"" + additionalDetail);
    besClient.abortStream(Status.CANCELLED.augmentDescription(additionalDetail));
    throw e;
  }
}","/** 
 * Method responsible for a single Streaming RPC. 
 */
private void publishEventStream(final ConcurrentLinkedDeque<InternalOrderedBuildEvent> pendingAck,final BlockingDeque<InternalOrderedBuildEvent> pendingSend,final BuildEventServiceClient besClient) throws Exception {
  logger.log(Level.INFO,String.format(""String_Node_Str"",pendingSend.size()));
  ListenableFuture<Status> streamDone=besClient.openStream(ackCallback(pendingAck,besClient));
  logger.log(Level.INFO,String.format(""String_Node_Str"",pendingSend.size()));
  try {
    @Nullable InternalOrderedBuildEvent orderedBuildEvent;
    do {
      orderedBuildEvent=pendingSend.pollFirst(STREAMING_RPC_POLL_IN_SECS,TimeUnit.SECONDS);
      if (orderedBuildEvent != null) {
        pendingAck.add(orderedBuildEvent);
        PathConverter pathConverter=waitForLocalFileUploads(orderedBuildEvent);
        besClient.sendOverStream(orderedBuildEvent.serialize(pathConverter));
      }
      checkState(besClient.isStreamActive(),""String_Node_Str"");
    }
 while (orderedBuildEvent == null || !orderedBuildEvent.isLastEvent());
    logger.log(Level.INFO,String.format(""String_Node_Str"",orderedBuildEvent.isLastEvent(),besClient.isStreamActive()));
  }
 catch (  InterruptedException e) {
    Thread.interrupted();
    String additionalDetails=""String_Node_Str"";
    besClient.abortStream(Status.CANCELLED.augmentDescription(additionalDetails));
    throw e;
  }
catch (  Exception e) {
    Status status=streamDone.isDone() ? streamDone.get() : null;
    String additionalDetail=e.getMessage();
    logger.log(Level.WARNING,String.format(""String_Node_Str"",status,additionalDetail),e);
    besClient.abortStream(Status.INTERNAL.augmentDescription(additionalDetail));
    throw e;
  }
  try {
    Status status=streamDone.get(PUBLISH_EVENT_STREAM_FINISHED_TIMEOUT.toMillis(),TimeUnit.MILLISECONDS);
    logger.log(Level.INFO,""String_Node_Str"" + status);
  }
 catch (  InterruptedException e) {
    Thread.interrupted();
    String additionalDetails=""String_Node_Str"";
    besClient.abortStream(Status.CANCELLED.augmentDescription(additionalDetails));
    throw e;
  }
catch (  TimeoutException e) {
    String additionalDetail=""String_Node_Str"";
    logger.log(Level.WARNING,""String_Node_Str"" + additionalDetail);
    besClient.abortStream(Status.CANCELLED.augmentDescription(additionalDetail));
    throw e;
  }
}",0.8728781591852132
110512,"/** 
 * Executes a   {@link Callable} retrying on exception thrown. 
 */
private void retryOnException(Callable<?> c) throws Exception {
  final int maxRetries=5;
  final long initialDelayMillis=0;
  final long delayMillis=1000;
  int tries=0;
  while (tries <= maxRetries) {
    try {
      acksReceivedSinceLastRetry.set(0);
      c.call();
      lastKnownError=null;
      return;
    }
 catch (    InterruptedException e) {
      throw e;
    }
catch (    Exception e) {
      if (acksReceivedSinceLastRetry.get() > 0) {
        logger.fine(String.format(""String_Node_Str"",acksReceivedSinceLastRetry.get()));
        tries=0;
      }
      tries++;
      lastKnownError=e;
      long sleepMillis;
      if (tries == 1) {
        sleepMillis=initialDelayMillis;
      }
 else {
        sleepMillis=(long)(delayMillis * Math.pow(1.6,tries));
      }
      String message=String.format(""String_Node_Str"",sleepMillis);
      logger.log(Level.INFO,message,lastKnownError);
      sleeper.sleepMillis(sleepMillis);
    }
  }
  Preconditions.checkNotNull(lastKnownError);
  throw lastKnownError;
}","/** 
 * Executes a   {@link Callable} retrying on exception thrown. 
 */
private void retryOnException(Callable<?> c) throws Exception {
  final int maxRetries=5;
  final long initialDelayMillis=0;
  final long delayMillis=1000;
  int tries=0;
  while (tries <= maxRetries) {
    try {
      acksReceivedSinceLastRetry.set(0);
      c.call();
      lastRetryError=null;
      return;
    }
 catch (    InterruptedException e) {
      throw e;
    }
catch (    LocalFileUploadException e) {
      throw (Exception)e.getCause();
    }
catch (    Exception e) {
      if (acksReceivedSinceLastRetry.get() > 0) {
        logger.fine(String.format(""String_Node_Str"",acksReceivedSinceLastRetry.get()));
        tries=0;
      }
      tries++;
      lastRetryError=e;
      long sleepMillis;
      if (tries == 1) {
        sleepMillis=initialDelayMillis;
      }
 else {
        sleepMillis=(long)(delayMillis * Math.pow(1.6,tries));
      }
      String message=String.format(""String_Node_Str"",sleepMillis);
      logger.log(Level.INFO,message,lastRetryError);
      sleeper.sleepMillis(sleepMillis);
    }
  }
  Preconditions.checkNotNull(lastRetryError);
  throw lastRetryError;
}",0.9251101321585904
110513,"@VisibleForTesting public BuildEventServiceTransport(BuildEventServiceClient besClient,Duration uploadTimeout,boolean publishLifecycleEvents,String buildRequestId,String invocationId,String command,ModuleEnvironment moduleEnvironment,Clock clock,BuildEventProtocolOptions protocolOptions,EventHandler commandLineReporter,@Nullable String projectId,Set<String> keywords,@Nullable String besResultsUrl,BuildEventArtifactUploader artifactUploader,Sleeper sleeper,boolean errorsShouldFailTheBuild){
  this.besClient=besClient;
  this.besProtoUtil=new BuildEventServiceProtoUtil(buildRequestId,invocationId,projectId,command,clock,keywords);
  this.publishLifecycleEvents=publishLifecycleEvents;
  this.moduleEnvironment=moduleEnvironment;
  this.commandLineReporter=commandLineReporter;
  this.pendingAck=new ConcurrentLinkedDeque<>();
  this.pendingSend=new LinkedBlockingDeque<>();
  this.uploaderExecutorService=listeningDecorator(Executors.newFixedThreadPool(2));
  this.protocolOptions=protocolOptions;
  this.invocationResult=UNKNOWN_STATUS;
  this.uploadTimeout=uploadTimeout;
  this.artifactUploader=artifactUploader;
  this.sleeper=sleeper;
  this.besResultsUrl=besResultsUrl;
  this.errorsShouldFailTheBuild=errorsShouldFailTheBuild;
}","@VisibleForTesting public BuildEventServiceTransport(BuildEventServiceClient besClient,Duration uploadTimeout,boolean publishLifecycleEvents,String buildRequestId,String invocationId,String command,ModuleEnvironment moduleEnvironment,Clock clock,BuildEventProtocolOptions protocolOptions,EventHandler commandLineReporter,@Nullable String projectId,Set<String> keywords,@Nullable String besResultsUrl,BuildEventArtifactUploader artifactUploader,Sleeper sleeper,boolean errorsShouldFailTheBuild){
  this.besClient=besClient;
  this.besProtoUtil=new BuildEventServiceProtoUtil(buildRequestId,invocationId,projectId,command,clock,keywords);
  this.publishLifecycleEvents=publishLifecycleEvents;
  this.moduleEnvironment=moduleEnvironment;
  this.commandLineReporter=commandLineReporter;
  this.pendingAck=new ConcurrentLinkedDeque<>();
  this.pendingSend=new LinkedBlockingDeque<>();
  this.uploaderExecutorService=listeningDecorator(Executors.newFixedThreadPool(2,new ThreadFactory(){
    private final AtomicInteger count=new AtomicInteger();
    @Override public Thread newThread(    Runnable r){
      return new Thread(r,""String_Node_Str"" + count.incrementAndGet());
    }
  }
));
  this.protocolOptions=protocolOptions;
  this.invocationResult=UNKNOWN_STATUS;
  this.uploadTimeout=uploadTimeout;
  this.artifactUploader=artifactUploader;
  this.sleeper=sleeper;
  this.besResultsUrl=besResultsUrl;
  this.errorsShouldFailTheBuild=errorsShouldFailTheBuild;
}",0.9192592592592592
110514,"private void reportErrorAndFailBuild(Throwable t){
  String message=errorMessageFromException(t);
  if (errorsShouldFailTheBuild) {
    commandLineReporter.handle(Event.error(message));
    moduleEnvironment.exit(new AbruptExitException(""String_Node_Str"",ExitCode.PUBLISH_ERROR));
  }
 else {
    commandLineReporter.handle(Event.warn(message));
  }
}","protected void reportErrorAndFailBuild(Throwable t){
  String message=errorMessageFromException(t);
  if (errorsShouldFailTheBuild) {
    commandLineReporter.handle(Event.error(message));
    moduleEnvironment.exit(new AbruptExitException(""String_Node_Str"",ExitCode.PUBLISH_ERROR));
  }
 else {
    commandLineReporter.handle(Event.warn(message));
  }
}",0.9829545454545454
110515,"private String errorMessageFromException(Throwable t){
  String message;
  if (t instanceof TimeoutException) {
    message=""String_Node_Str"";
    Exception lastKnownError0=lastKnownError;
    if (lastKnownError0 != null) {
      message+=""String_Node_Str"";
      message+=""String_Node_Str"";
      message+=besClient.userReadableError(lastKnownError0);
      return message;
    }
    return message;
  }
 else   if (t instanceof ExecutionException) {
    message=format(UPLOAD_FAILED_MESSAGE,t.getCause() != null ? besClient.userReadableError(t.getCause()) : t.getMessage());
    return message;
  }
 else {
    message=format(UPLOAD_FAILED_MESSAGE,besClient.userReadableError(t));
    return message;
  }
}","private String errorMessageFromException(Throwable t){
  String message;
  if (t instanceof TimeoutException) {
    message=""String_Node_Str"";
    Exception lastRetryError0=lastRetryError;
    if (lastRetryError0 != null) {
      message+=""String_Node_Str"";
      message+=""String_Node_Str"";
      message+=besClient.userReadableError(lastRetryError0);
      return message;
    }
    return message;
  }
 else   if (t instanceof ExecutionException) {
    message=format(UPLOAD_FAILED_MESSAGE,t.getCause() != null ? besClient.userReadableError(t.getCause()) : t.getMessage());
    return message;
  }
 else {
    message=format(UPLOAD_FAILED_MESSAGE,besClient.userReadableError(t));
    return message;
  }
}",0.9717514124293786
110516,"public Object invoke(Map<String,Object> kwargs,FuncallExpression ast,Environment env) throws EvalException, InterruptedException {
  try {
    Package.Builder builder=PackageFactory.getContext(env,ast.getLocation()).pkgBuilder;
    if (!allowOverride && kwargs.containsKey(""String_Node_Str"") && builder.targets.containsKey(kwargs.get(""String_Node_Str""))) {
      throw new EvalException(ast.getLocation(),""String_Node_Str"" + ""String_Node_Str"" + kwargs.get(""String_Node_Str"") + ""String_Node_Str"");
    }
    if (env.getSemantics().experimentalEnableRepoMapping()) {
      if (kwargs.containsKey(""String_Node_Str"")) {
        if (!(kwargs.get(""String_Node_Str"") instanceof Map)) {
          throw new EvalException(ast.getLocation(),""String_Node_Str"" + kwargs.get(""String_Node_Str"") + ""String_Node_Str"");
        }
        @SuppressWarnings(""String_Node_Str"") Map<String,String> map=(Map<String,String>)kwargs.get(""String_Node_Str"");
        String externalRepoName=(String)kwargs.get(""String_Node_Str"");
        for (        Map.Entry<String,String> e : map.entrySet()) {
          builder.addRepositoryMappingEntry(RepositoryName.createFromValidStrippedName(externalRepoName),RepositoryName.create((String)e.getKey()),RepositoryName.create((String)e.getValue()));
        }
      }
    }
    RuleClass ruleClass=ruleFactory.getRuleClass(ruleClassName);
    RuleClass bindRuleClass=ruleFactory.getRuleClass(""String_Node_Str"");
    Rule rule=WorkspaceFactoryHelper.createAndAddRepositoryRule(builder,ruleClass,bindRuleClass,getFinalKwargs(kwargs,env.getSemantics()),ast);
    if (!isLegalWorkspaceName(rule.getName())) {
      throw new EvalException(ast.getLocation(),rule + ""String_Node_Str"");
    }
  }
 catch (  RuleFactory.InvalidRuleException|Package.NameConflictException|LabelSyntaxException e) {
    throw new EvalException(ast.getLocation(),e.getMessage());
  }
  return NONE;
}","public Object invoke(Map<String,Object> kwargs,FuncallExpression ast,Environment env) throws EvalException, InterruptedException {
  try {
    Package.Builder builder=PackageFactory.getContext(env,ast.getLocation()).pkgBuilder;
    if (!allowOverride && kwargs.containsKey(""String_Node_Str"") && builder.targets.containsKey(kwargs.get(""String_Node_Str""))) {
      throw new EvalException(ast.getLocation(),""String_Node_Str"" + ""String_Node_Str"" + kwargs.get(""String_Node_Str"") + ""String_Node_Str"");
    }
    String externalRepoName=(String)kwargs.get(""String_Node_Str"");
    if (!Strings.isNullOrEmpty(builder.pkg.getWorkspaceName())) {
      builder.addRepositoryMappingEntry(RepositoryName.createFromValidStrippedName(externalRepoName),RepositoryName.createFromValidStrippedName(builder.pkg.getWorkspaceName()),RepositoryName.MAIN);
    }
    if (env.getSemantics().experimentalEnableRepoMapping()) {
      if (kwargs.containsKey(""String_Node_Str"")) {
        if (!(kwargs.get(""String_Node_Str"") instanceof Map)) {
          throw new EvalException(ast.getLocation(),""String_Node_Str"" + kwargs.get(""String_Node_Str"") + ""String_Node_Str"");
        }
        @SuppressWarnings(""String_Node_Str"") Map<String,String> map=(Map<String,String>)kwargs.get(""String_Node_Str"");
        for (        Map.Entry<String,String> e : map.entrySet()) {
          builder.addRepositoryMappingEntry(RepositoryName.createFromValidStrippedName(externalRepoName),RepositoryName.create((String)e.getKey()),RepositoryName.create((String)e.getValue()));
        }
      }
    }
    RuleClass ruleClass=ruleFactory.getRuleClass(ruleClassName);
    RuleClass bindRuleClass=ruleFactory.getRuleClass(""String_Node_Str"");
    Rule rule=WorkspaceFactoryHelper.createAndAddRepositoryRule(builder,ruleClass,bindRuleClass,getFinalKwargs(kwargs,env.getSemantics()),ast);
    if (!isLegalWorkspaceName(rule.getName())) {
      throw new EvalException(ast.getLocation(),rule + ""String_Node_Str"");
    }
  }
 catch (  RuleFactory.InvalidRuleException|Package.NameConflictException|LabelSyntaxException e) {
    throw new EvalException(ast.getLocation(),e.getMessage());
  }
  return NONE;
}",0.8514115898959881
110517,"/** 
 * Returns a function-value implementing the build or workspace rule ""ruleClass"" (e.g. cc_library) in the specified package context.
 */
private static BuiltinFunction newRuleFunction(final RuleFactory ruleFactory,final String ruleClassName,final boolean allowOverride){
  return new BuiltinFunction(ruleClassName,FunctionSignature.KWARGS,BuiltinFunction.USE_AST_ENV){
    public Object invoke(    Map<String,Object> kwargs,    FuncallExpression ast,    Environment env) throws EvalException, InterruptedException {
      try {
        Package.Builder builder=PackageFactory.getContext(env,ast.getLocation()).pkgBuilder;
        if (!allowOverride && kwargs.containsKey(""String_Node_Str"") && builder.targets.containsKey(kwargs.get(""String_Node_Str""))) {
          throw new EvalException(ast.getLocation(),""String_Node_Str"" + ""String_Node_Str"" + kwargs.get(""String_Node_Str"") + ""String_Node_Str"");
        }
        if (env.getSemantics().experimentalEnableRepoMapping()) {
          if (kwargs.containsKey(""String_Node_Str"")) {
            if (!(kwargs.get(""String_Node_Str"") instanceof Map)) {
              throw new EvalException(ast.getLocation(),""String_Node_Str"" + kwargs.get(""String_Node_Str"") + ""String_Node_Str"");
            }
            @SuppressWarnings(""String_Node_Str"") Map<String,String> map=(Map<String,String>)kwargs.get(""String_Node_Str"");
            String externalRepoName=(String)kwargs.get(""String_Node_Str"");
            for (            Map.Entry<String,String> e : map.entrySet()) {
              builder.addRepositoryMappingEntry(RepositoryName.createFromValidStrippedName(externalRepoName),RepositoryName.create((String)e.getKey()),RepositoryName.create((String)e.getValue()));
            }
          }
        }
        RuleClass ruleClass=ruleFactory.getRuleClass(ruleClassName);
        RuleClass bindRuleClass=ruleFactory.getRuleClass(""String_Node_Str"");
        Rule rule=WorkspaceFactoryHelper.createAndAddRepositoryRule(builder,ruleClass,bindRuleClass,getFinalKwargs(kwargs,env.getSemantics()),ast);
        if (!isLegalWorkspaceName(rule.getName())) {
          throw new EvalException(ast.getLocation(),rule + ""String_Node_Str"");
        }
      }
 catch (      RuleFactory.InvalidRuleException|Package.NameConflictException|LabelSyntaxException e) {
        throw new EvalException(ast.getLocation(),e.getMessage());
      }
      return NONE;
    }
  }
;
}","/** 
 * Returns a function-value implementing the build or workspace rule ""ruleClass"" (e.g. cc_library) in the specified package context.
 */
private static BuiltinFunction newRuleFunction(final RuleFactory ruleFactory,final String ruleClassName,final boolean allowOverride){
  return new BuiltinFunction(ruleClassName,FunctionSignature.KWARGS,BuiltinFunction.USE_AST_ENV){
    public Object invoke(    Map<String,Object> kwargs,    FuncallExpression ast,    Environment env) throws EvalException, InterruptedException {
      try {
        Package.Builder builder=PackageFactory.getContext(env,ast.getLocation()).pkgBuilder;
        if (!allowOverride && kwargs.containsKey(""String_Node_Str"") && builder.targets.containsKey(kwargs.get(""String_Node_Str""))) {
          throw new EvalException(ast.getLocation(),""String_Node_Str"" + ""String_Node_Str"" + kwargs.get(""String_Node_Str"") + ""String_Node_Str"");
        }
        String externalRepoName=(String)kwargs.get(""String_Node_Str"");
        if (!Strings.isNullOrEmpty(builder.pkg.getWorkspaceName())) {
          builder.addRepositoryMappingEntry(RepositoryName.createFromValidStrippedName(externalRepoName),RepositoryName.createFromValidStrippedName(builder.pkg.getWorkspaceName()),RepositoryName.MAIN);
        }
        if (env.getSemantics().experimentalEnableRepoMapping()) {
          if (kwargs.containsKey(""String_Node_Str"")) {
            if (!(kwargs.get(""String_Node_Str"") instanceof Map)) {
              throw new EvalException(ast.getLocation(),""String_Node_Str"" + kwargs.get(""String_Node_Str"") + ""String_Node_Str"");
            }
            @SuppressWarnings(""String_Node_Str"") Map<String,String> map=(Map<String,String>)kwargs.get(""String_Node_Str"");
            for (            Map.Entry<String,String> e : map.entrySet()) {
              builder.addRepositoryMappingEntry(RepositoryName.createFromValidStrippedName(externalRepoName),RepositoryName.create((String)e.getKey()),RepositoryName.create((String)e.getValue()));
            }
          }
        }
        RuleClass ruleClass=ruleFactory.getRuleClass(ruleClassName);
        RuleClass bindRuleClass=ruleFactory.getRuleClass(""String_Node_Str"");
        Rule rule=WorkspaceFactoryHelper.createAndAddRepositoryRule(builder,ruleClass,bindRuleClass,getFinalKwargs(kwargs,env.getSemantics()),ast);
        if (!isLegalWorkspaceName(rule.getName())) {
          throw new EvalException(ast.getLocation(),rule + ""String_Node_Str"");
        }
      }
 catch (      RuleFactory.InvalidRuleException|Package.NameConflictException|LabelSyntaxException e) {
        throw new EvalException(ast.getLocation(),e.getMessage());
      }
      return NONE;
    }
  }
;
}",0.8780967361384192
110518,"@Test public void testWorkspaceMappings() throws Exception {
  helper.setSkylarkSemantics(""String_Node_Str"");
  helper.parse(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertMapping(helper,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}","@Test public void testWorkspaceMappings() throws Exception {
  helper.setSkylarkSemantics(""String_Node_Str"");
  helper.parse(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertMapping(helper,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertMapping(helper,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}",0.8596237337192475
110519,"@Test public void testSimpleMapping() throws Exception {
  setSkylarkSemanticsOptions(""String_Node_Str"");
  scratch.overwriteFile(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  RepositoryName name=RepositoryName.create(""String_Node_Str"");
  SkyKey skyKey=RepositoryMappingValue.key(name);
  EvaluationResult<RepositoryMappingValue> result=eval(skyKey);
  assertThat(result.hasError()).isFalse();
  assertThatEvaluationResult(result).hasEntryThat(skyKey).isEqualTo(RepositoryMappingValue.withMapping(ImmutableMap.of(RepositoryName.create(""String_Node_Str""),RepositoryName.create(""String_Node_Str""))));
}","@Test public void testSimpleMapping() throws Exception {
  setSkylarkSemanticsOptions(""String_Node_Str"");
  scratch.overwriteFile(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  RepositoryName name=RepositoryName.create(""String_Node_Str"");
  SkyKey skyKey=RepositoryMappingValue.key(name);
  EvaluationResult<RepositoryMappingValue> result=eval(skyKey);
  assertThat(result.hasError()).isFalse();
  assertThatEvaluationResult(result).hasEntryThat(skyKey).isEqualTo(RepositoryMappingValue.withMapping(ImmutableMap.of(RepositoryName.create(""String_Node_Str""),RepositoryName.MAIN,RepositoryName.create(""String_Node_Str""),RepositoryName.create(""String_Node_Str""))));
}",0.9573724668064292
110520,"@Test public void testRepositoryWithMultipleMappings() throws Exception {
  setSkylarkSemanticsOptions(""String_Node_Str"");
  scratch.overwriteFile(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  RepositoryName name=RepositoryName.create(""String_Node_Str"");
  SkyKey skyKey=RepositoryMappingValue.key(name);
  assertThatEvaluationResult(eval(skyKey)).hasEntryThat(skyKey).isEqualTo(RepositoryMappingValue.withMapping(ImmutableMap.of(RepositoryName.create(""String_Node_Str""),RepositoryName.create(""String_Node_Str""),RepositoryName.create(""String_Node_Str""),RepositoryName.create(""String_Node_Str""))));
}","@Test public void testRepositoryWithMultipleMappings() throws Exception {
  setSkylarkSemanticsOptions(""String_Node_Str"");
  scratch.overwriteFile(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  RepositoryName name=RepositoryName.create(""String_Node_Str"");
  SkyKey skyKey=RepositoryMappingValue.key(name);
  assertThatEvaluationResult(eval(skyKey)).hasEntryThat(skyKey).isEqualTo(RepositoryMappingValue.withMapping(ImmutableMap.of(RepositoryName.create(""String_Node_Str""),RepositoryName.MAIN,RepositoryName.create(""String_Node_Str""),RepositoryName.create(""String_Node_Str""),RepositoryName.create(""String_Node_Str""),RepositoryName.create(""String_Node_Str""))));
}",0.9572529782761036
110521,"@Test public void testMultipleRepositoriesWithMapping() throws Exception {
  setSkylarkSemanticsOptions(""String_Node_Str"");
  scratch.overwriteFile(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  RepositoryName name1=RepositoryName.create(""String_Node_Str"");
  SkyKey skyKey1=RepositoryMappingValue.key(name1);
  RepositoryName name2=RepositoryName.create(""String_Node_Str"");
  SkyKey skyKey2=RepositoryMappingValue.key(name2);
  assertThatEvaluationResult(eval(skyKey1)).hasEntryThat(skyKey1).isEqualTo(RepositoryMappingValue.withMapping(ImmutableMap.of(RepositoryName.create(""String_Node_Str""),RepositoryName.create(""String_Node_Str""))));
  assertThatEvaluationResult(eval(skyKey2)).hasEntryThat(skyKey2).isEqualTo(RepositoryMappingValue.withMapping(ImmutableMap.of(RepositoryName.create(""String_Node_Str""),RepositoryName.create(""String_Node_Str""))));
}","@Test public void testMultipleRepositoriesWithMapping() throws Exception {
  setSkylarkSemanticsOptions(""String_Node_Str"");
  scratch.overwriteFile(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  RepositoryName name1=RepositoryName.create(""String_Node_Str"");
  SkyKey skyKey1=RepositoryMappingValue.key(name1);
  RepositoryName name2=RepositoryName.create(""String_Node_Str"");
  SkyKey skyKey2=RepositoryMappingValue.key(name2);
  assertThatEvaluationResult(eval(skyKey1)).hasEntryThat(skyKey1).isEqualTo(RepositoryMappingValue.withMapping(ImmutableMap.of(RepositoryName.create(""String_Node_Str""),RepositoryName.MAIN,RepositoryName.create(""String_Node_Str""),RepositoryName.create(""String_Node_Str""))));
  assertThatEvaluationResult(eval(skyKey2)).hasEntryThat(skyKey2).isEqualTo(RepositoryMappingValue.withMapping(ImmutableMap.of(RepositoryName.create(""String_Node_Str""),RepositoryName.MAIN,RepositoryName.create(""String_Node_Str""),RepositoryName.create(""String_Node_Str""))));
}",0.9439338235294118
110522,"public PerBuildSyscallCache build(){
  CacheBuilder<Object,Object> statCacheBuilder=CacheBuilder.newBuilder();
  if (maxStats != UNSET) {
    statCacheBuilder=statCacheBuilder.maximumSize(maxStats);
  }
  CacheBuilder<Object,Object> readdirCacheBuilder=CacheBuilder.newBuilder();
  if (maxReaddirs != UNSET) {
    readdirCacheBuilder=readdirCacheBuilder.maximumSize(maxStats);
  }
  if (concurrencyLevel != UNSET) {
    statCacheBuilder=statCacheBuilder.concurrencyLevel(concurrencyLevel);
    readdirCacheBuilder=readdirCacheBuilder.concurrencyLevel(concurrencyLevel);
  }
  return new PerBuildSyscallCache(statCacheBuilder.build(newStatLoader()),readdirCacheBuilder.build(newReaddirLoader()));
}","public PerBuildSyscallCache build(){
  CacheBuilder<Object,Object> statCacheBuilder=CacheBuilder.newBuilder();
  if (maxStats != UNSET) {
    statCacheBuilder=statCacheBuilder.maximumSize(maxStats);
  }
  CacheBuilder<Object,Object> readdirCacheBuilder=CacheBuilder.newBuilder();
  if (maxReaddirs != UNSET) {
    readdirCacheBuilder=readdirCacheBuilder.maximumSize(maxReaddirs);
  }
  if (concurrencyLevel != UNSET) {
    statCacheBuilder=statCacheBuilder.concurrencyLevel(concurrencyLevel);
    readdirCacheBuilder=readdirCacheBuilder.concurrencyLevel(concurrencyLevel);
  }
  return new PerBuildSyscallCache(statCacheBuilder.build(newStatLoader()),readdirCacheBuilder.build(newReaddirLoader()));
}",0.9921259842519684
110523,"/** 
 * Retrieves the fingerprint associated with the given NestedSet contents, or null if the given contents are not known.
 */
@Nullable public FingerprintComputationResult fingerprintForContents(Object[] contents){
  return contentsToFingerprint.getIfPresent(contents);
}","/** 
 * Retrieves the fingerprint associated with the given NestedSet contents, or null if the given contents are not known.
 */
@VisibleForTesting @Nullable FingerprintComputationResult fingerprintForContents(Object[] contents){
  return contentsToFingerprint.getIfPresent(contents);
}",0.9535714285714286
110524,@VisibleForTesting public abstract ListenableFuture<Void> writeStatus();,@VisibleForTesting abstract ListenableFuture<Void> writeStatus();,0.948905109489051
110525,"/** 
 * Computes and returns the fingerprint for the given NestedSet contents using the given   {@link SerializationContext}, while also associating the contents with the computed fingerprint in the store. Recursively does the same for all transitive members (i.e. Object[] members) of the provided contents.
 */
@VisibleForTesting public FingerprintComputationResult computeFingerprintAndStore(Object[] contents,SerializationContext serializationContext) throws SerializationException, IOException {
  FingerprintComputationResult priorFingerprint=nestedSetCache.fingerprintForContents(contents);
  if (priorFingerprint != null) {
    return priorFingerprint;
  }
  SerializationContext newSerializationContext=serializationContext.getNewMemoizingContext();
  ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();
  CodedOutputStream codedOutputStream=CodedOutputStream.newInstance(byteArrayOutputStream);
  ImmutableList.Builder<ListenableFuture<Void>> futureBuilder=ImmutableList.builder();
  try {
    codedOutputStream.writeInt32NoTag(contents.length);
    for (    Object child : contents) {
      if (child instanceof Object[]) {
        FingerprintComputationResult fingerprintComputationResult=computeFingerprintAndStore((Object[])child,serializationContext);
        futureBuilder.add(fingerprintComputationResult.writeStatus());
        newSerializationContext.serialize(fingerprintComputationResult.fingerprint(),codedOutputStream);
      }
 else {
        newSerializationContext.serialize(child,codedOutputStream);
      }
    }
    codedOutputStream.flush();
  }
 catch (  IOException e) {
    throw new SerializationException(""String_Node_Str"",e);
  }
  byte[] serializedBytes=byteArrayOutputStream.toByteArray();
  ByteString fingerprint=ByteString.copyFrom(Hashing.md5().hashBytes(serializedBytes).asBytes());
  futureBuilder.add(nestedSetStorageEndpoint.put(fingerprint,serializedBytes));
  ListenableFuture<Void> innerWriteFutures=newSerializationContext.createFutureToBlockWritingOn();
  if (innerWriteFutures != null) {
    futureBuilder.add(innerWriteFutures);
  }
  ListenableFuture<Void> writeFuture=Futures.whenAllComplete(futureBuilder.build()).call(() -> null,MoreExecutors.directExecutor());
  FingerprintComputationResult fingerprintComputationResult=FingerprintComputationResult.create(fingerprint,writeFuture);
  nestedSetCache.put(fingerprintComputationResult,contents);
  return fingerprintComputationResult;
}","/** 
 * Computes and returns the fingerprint for the given NestedSet contents using the given   {@link SerializationContext}, while also associating the contents with the computed fingerprint in the store. Recursively does the same for all transitive members (i.e. Object[] members) of the provided contents. <p>We wish to serialize each nested set only once. However, this is not currently enforced, due to the check-then-act race below, where we check nestedSetCache and then, significantly later, insert a result into the cache. This is a bug, but since any thread that redoes unnecessary work will return the   {@link FingerprintComputationResult} containing its own futures, theserialization work that must wait on remote storage writes to complete will wait on the correct futures. Thus it is a performance bug, not a correctness bug.
 */
FingerprintComputationResult computeFingerprintAndStore(Object[] contents,SerializationContext serializationContext) throws SerializationException, IOException {
  FingerprintComputationResult priorFingerprint=nestedSetCache.fingerprintForContents(contents);
  if (priorFingerprint != null) {
    return priorFingerprint;
  }
  SerializationContext newSerializationContext=serializationContext.getNewMemoizingContext();
  ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();
  CodedOutputStream codedOutputStream=CodedOutputStream.newInstance(byteArrayOutputStream);
  ImmutableList.Builder<ListenableFuture<Void>> futureBuilder=ImmutableList.builder();
  try {
    codedOutputStream.writeInt32NoTag(contents.length);
    for (    Object child : contents) {
      if (child instanceof Object[]) {
        FingerprintComputationResult fingerprintComputationResult=computeFingerprintAndStore((Object[])child,serializationContext);
        futureBuilder.add(fingerprintComputationResult.writeStatus());
        newSerializationContext.serialize(fingerprintComputationResult.fingerprint(),codedOutputStream);
      }
 else {
        newSerializationContext.serialize(child,codedOutputStream);
      }
    }
    codedOutputStream.flush();
  }
 catch (  IOException e) {
    throw new SerializationException(""String_Node_Str"",e);
  }
  byte[] serializedBytes=byteArrayOutputStream.toByteArray();
  ByteString fingerprint=ByteString.copyFrom(Hashing.md5().hashBytes(serializedBytes).asBytes());
  futureBuilder.add(nestedSetStorageEndpoint.put(fingerprint,serializedBytes));
  ListenableFuture<Void> innerWriteFutures=newSerializationContext.createFutureToBlockWritingOn();
  if (innerWriteFutures != null) {
    futureBuilder.add(innerWriteFutures);
  }
  ListenableFuture<Void> writeFuture=Futures.whenAllComplete(futureBuilder.build()).call(() -> null,MoreExecutors.directExecutor());
  FingerprintComputationResult fingerprintComputationResult=FingerprintComputationResult.create(fingerprint,writeFuture);
  nestedSetCache.put(fingerprintComputationResult,contents);
  return fingerprintComputationResult;
}",0.8972754050073638
110526,"@VisibleForTesting public NestedSetStore(NestedSetStorageEndpoint nestedSetStorageEndpoint,NestedSetCache nestedSetCache,Executor executor){
  this.nestedSetStorageEndpoint=nestedSetStorageEndpoint;
  this.nestedSetCache=nestedSetCache;
  this.executor=executor;
}","@VisibleForTesting NestedSetStore(NestedSetStorageEndpoint nestedSetStorageEndpoint,NestedSetCache nestedSetCache,Executor executor){
  this.nestedSetStorageEndpoint=nestedSetStorageEndpoint;
  this.nestedSetCache=nestedSetCache;
  this.executor=executor;
}",0.9865642994241842
110527,"/** 
 * Retrieves and deserializes the NestedSet contents associated with the given fingerprint. 
 */
public ListenableFuture<Object[]> getContentsAndDeserialize(ByteString fingerprint,DeserializationContext deserializationContext) throws IOException {
  ListenableFuture<Object[]> contents=nestedSetCache.contentsForFingerprint(fingerprint);
  if (contents != null) {
    return contents;
  }
  ListenableFuture<byte[]> retrieved=nestedSetStorageEndpoint.get(fingerprint);
  ListenableFuture<Object[]> result=Futures.transformAsync(retrieved,bytes -> {
    CodedInputStream codedIn=CodedInputStream.newInstance(bytes);
    int numberOfElements=codedIn.readInt32();
    DeserializationContext newDeserializationContext=deserializationContext.getNewMemoizingContext();
    List<ListenableFuture<?>> deserializationFutures=new ArrayList<>();
    for (int i=0; i < numberOfElements; i++) {
      Object deserializedElement=newDeserializationContext.deserialize(codedIn);
      if (deserializedElement instanceof ByteString) {
        deserializationFutures.add(getContentsAndDeserialize((ByteString)deserializedElement,deserializationContext));
      }
 else {
        deserializationFutures.add(Futures.immediateFuture(deserializedElement));
      }
    }
    return Futures.whenAllComplete(deserializationFutures).call(() -> {
      Object[] deserializedContents=new Object[deserializationFutures.size()];
      for (int i=0; i < deserializationFutures.size(); i++) {
        deserializedContents[i]=Futures.getDone(deserializationFutures.get(i));
      }
      return deserializedContents;
    }
,executor);
  }
,executor);
  FingerprintComputationResult fingerprintComputationResult=FingerprintComputationResult.create(fingerprint,Futures.immediateFuture(null));
  nestedSetCache.put(fingerprintComputationResult,result);
  return result;
}","/** 
 * Retrieves and deserializes the NestedSet contents associated with the given fingerprint. <p>We wish to only do one deserialization per fingerprint. This is enforced by the   {@link #nestedSetCache}, which is responsible for returning the canonical future that will contain the results of the deserialization. If that future is not owned by the current call of this method, it doesn't have to do anything further.
 */
ListenableFuture<Object[]> getContentsAndDeserialize(ByteString fingerprint,DeserializationContext deserializationContext) throws IOException {
  SettableFuture<Object[]> future=SettableFuture.create();
  ListenableFuture<Object[]> contents=nestedSetCache.putIfAbsent(fingerprint,future);
  if (contents != null) {
    return contents;
  }
  ListenableFuture<byte[]> retrieved=nestedSetStorageEndpoint.get(fingerprint);
  future.setFuture(Futures.transformAsync(retrieved,bytes -> {
    CodedInputStream codedIn=CodedInputStream.newInstance(bytes);
    int numberOfElements=codedIn.readInt32();
    DeserializationContext newDeserializationContext=deserializationContext.getNewMemoizingContext();
    List<ListenableFuture<?>> deserializationFutures=new ArrayList<>();
    for (int i=0; i < numberOfElements; i++) {
      Object deserializedElement=newDeserializationContext.deserialize(codedIn);
      if (deserializedElement instanceof ByteString) {
        deserializationFutures.add(getContentsAndDeserialize((ByteString)deserializedElement,deserializationContext));
      }
 else {
        deserializationFutures.add(Futures.immediateFuture(deserializedElement));
      }
    }
    return Futures.whenAllComplete(deserializationFutures).call(() -> {
      Object[] deserializedContents=new Object[deserializationFutures.size()];
      for (int i=0; i < deserializationFutures.size(); i++) {
        deserializedContents[i]=Futures.getDone(deserializationFutures.get(i));
      }
      return deserializedContents;
    }
,executor);
  }
,executor));
  return future;
}",0.7503908285565398
110528,"@Test public void testDeserializationInParallel() throws Exception {
  NestedSetStorageEndpoint nestedSetStorageEndpoint=Mockito.spy(new InMemoryNestedSetStorageEndpoint());
  NestedSetCache emptyNestedSetCache=Mockito.mock(NestedSetCache.class);
  NestedSetStore nestedSetStore=new NestedSetStore(nestedSetStorageEndpoint,emptyNestedSetCache,MoreExecutors.directExecutor());
  ObjectCodecs objectCodecs=new ObjectCodecs(AutoRegistry.get().getBuilder().setAllowDefaultCodec(true).add(new NestedSetCodecWithStore<>(nestedSetStore)).build());
  NestedSet<String> subset1=new NestedSetBuilder<String>(Order.STABLE_ORDER).add(""String_Node_Str"").add(""String_Node_Str"").build();
  SettableFuture<byte[]> subset1Future=SettableFuture.create();
  NestedSet<String> subset2=new NestedSetBuilder<String>(Order.STABLE_ORDER).add(""String_Node_Str"").add(""String_Node_Str"").build();
  SettableFuture<byte[]> subset2Future=SettableFuture.create();
  NestedSet<String> set=new NestedSetBuilder<String>(Order.STABLE_ORDER).addTransitive(subset1).addTransitive(subset2).build();
  ArgumentCaptor<ByteString> fingerprintCaptor=ArgumentCaptor.forClass(ByteString.class);
  ByteString fingerprint=nestedSetStore.computeFingerprintAndStore((Object[])set.getChildren(),objectCodecs.getSerializationContext()).fingerprint();
  Mockito.verify(nestedSetStorageEndpoint,Mockito.times(3)).put(fingerprintCaptor.capture(),Mockito.any());
  Mockito.doReturn(subset1Future).when(nestedSetStorageEndpoint).get(fingerprintCaptor.getAllValues().get(0));
  Mockito.doReturn(subset2Future).when(nestedSetStorageEndpoint).get(fingerprintCaptor.getAllValues().get(1));
  ListenableFuture<Object[]> deserializationFuture=nestedSetStore.getContentsAndDeserialize(fingerprint,objectCodecs.getDeserializationContext());
  assertThat(deserializationFuture.isDone()).isFalse();
  Mockito.verify(nestedSetStorageEndpoint,Mockito.times(3)).get(Mockito.any());
  subset1Future.set(ByteString.copyFrom(""String_Node_Str"",Charset.defaultCharset()).toByteArray());
  subset2Future.set(ByteString.copyFrom(""String_Node_Str"",Charset.defaultCharset()).toByteArray());
  assertThat(deserializationFuture.isDone()).isTrue();
}","@Test public void testDeserializationInParallel() throws Exception {
  NestedSetStorageEndpoint nestedSetStorageEndpoint=Mockito.spy(new InMemoryNestedSetStorageEndpoint());
  NestedSetCache emptyNestedSetCache=Mockito.mock(NestedSetCache.class);
  NestedSetStore nestedSetStore=new NestedSetStore(nestedSetStorageEndpoint,emptyNestedSetCache,MoreExecutors.directExecutor());
  ObjectCodecs objectCodecs=new ObjectCodecs(AutoRegistry.get().getBuilder().setAllowDefaultCodec(true).add(new NestedSetCodecWithStore<>(nestedSetStore)).build());
  NestedSet<String> subset1=new NestedSetBuilder<String>(Order.STABLE_ORDER).add(""String_Node_Str"").add(""String_Node_Str"").build();
  SettableFuture<byte[]> subset1Future=SettableFuture.create();
  NestedSet<String> subset2=new NestedSetBuilder<String>(Order.STABLE_ORDER).add(""String_Node_Str"").add(""String_Node_Str"").build();
  SettableFuture<byte[]> subset2Future=SettableFuture.create();
  NestedSet<String> set=new NestedSetBuilder<String>(Order.STABLE_ORDER).addTransitive(subset1).addTransitive(subset2).build();
  ArgumentCaptor<ByteString> fingerprintCaptor=ArgumentCaptor.forClass(ByteString.class);
  ByteString fingerprint=nestedSetStore.computeFingerprintAndStore((Object[])set.getChildren(),objectCodecs.getSerializationContext()).fingerprint();
  Mockito.verify(nestedSetStorageEndpoint,Mockito.times(3)).put(fingerprintCaptor.capture(),Mockito.any());
  Mockito.doReturn(subset1Future).when(nestedSetStorageEndpoint).get(fingerprintCaptor.getAllValues().get(0));
  Mockito.doReturn(subset2Future).when(nestedSetStorageEndpoint).get(fingerprintCaptor.getAllValues().get(1));
  Mockito.when(emptyNestedSetCache.putIfAbsent(Mockito.any(),Mockito.any())).thenAnswer(invocation -> null);
  ListenableFuture<Object[]> deserializationFuture=nestedSetStore.getContentsAndDeserialize(fingerprint,objectCodecs.getDeserializationContext());
  assertThat(deserializationFuture.isDone()).isFalse();
  Mockito.verify(nestedSetStorageEndpoint,Mockito.times(3)).get(Mockito.any());
  subset1Future.set(ByteString.copyFrom(""String_Node_Str"",Charset.defaultCharset()).toByteArray());
  subset2Future.set(ByteString.copyFrom(""String_Node_Str"",Charset.defaultCharset()).toByteArray());
  assertThat(deserializationFuture.isDone()).isTrue();
}",0.9755001123848056
110529,"@Override public ConfiguredTarget create(RuleContext ruleContext) throws InterruptedException, RuleErrorException, ActionConflictException {
  Artifact staticLibrary=ruleContext.getPrerequisiteArtifact(""String_Node_Str"",Mode.TARGET);
  Artifact sharedLibrary=ruleContext.getPrerequisiteArtifact(""String_Node_Str"",Mode.TARGET);
  Artifact interfaceLibrary=ruleContext.getPrerequisiteArtifact(""String_Node_Str"",Mode.TARGET);
  boolean systemProvided=ruleContext.attributes().get(""String_Node_Str"",Type.BOOLEAN);
  if (systemProvided && sharedLibrary != null) {
    ruleContext.ruleError(""String_Node_Str"");
  }
  if (!systemProvided && sharedLibrary == null && interfaceLibrary != null) {
    ruleContext.ruleError(""String_Node_Str"");
  }
  CcToolchainProvider ccToolchain=CppHelper.getToolchainUsingDefaultCcToolchainAttribute(ruleContext);
  FeatureConfiguration featureConfiguration=CcCommon.configureFeaturesOrReportRuleError(ruleContext,ccToolchain);
  FdoSupportProvider fdoSupport=CppHelper.getFdoSupportUsingDefaultCcToolchainAttribute(ruleContext);
  final CcCommon common=new CcCommon(ruleContext);
  CompilationInfo compilationInfo=new CcCompilationHelper(ruleContext,semantics,featureConfiguration,ccToolchain,fdoSupport).addPublicHeaders(common.getHeaders()).setHeadersCheckingMode(HeadersCheckingMode.STRICT).compile();
  boolean alwayslink=ruleContext.attributes().get(""String_Node_Str"",Type.BOOLEAN);
  ArtifactCategory staticLibraryCategory=alwayslink ? ArtifactCategory.ALWAYSLINK_STATIC_LIBRARY : ArtifactCategory.STATIC_LIBRARY;
  PathFragment labelName=PathFragment.create(ruleContext.getLabel().getName());
  String libraryIdentifier=ruleContext.getPackageDirectory().getRelative(labelName.replaceName(""String_Node_Str"" + labelName.getBaseName())).getPathString();
  CcLinkingHelper linkingHelper=new CcLinkingHelper(ruleContext,semantics,featureConfiguration,ccToolchain,fdoSupport,ruleContext.getConfiguration());
  if (staticLibrary != null) {
    if (CppFileTypes.PIC_ARCHIVE.matches(staticLibrary.getPath())) {
      linkingHelper.addPicStaticLibraries(ImmutableList.of(LinkerInputs.opaqueLibraryToLink(staticLibrary,staticLibraryCategory,libraryIdentifier,alwayslink)));
    }
 else {
      linkingHelper.addStaticLibraries(ImmutableList.of(LinkerInputs.opaqueLibraryToLink(staticLibrary,staticLibraryCategory,libraryIdentifier,alwayslink)));
    }
  }
  boolean targetWindows=featureConfiguration.isEnabled(CppRuleClasses.TARGETS_WINDOWS);
  Iterable<LibraryToLink> dynamicLibraryForLinkingList=null;
  Iterable<LibraryToLink> dynamicLibrariesForRuntimeList=null;
  if (sharedLibrary != null) {
    if (targetWindows) {
      dynamicLibrariesForRuntimeList=ImmutableList.of(LinkerInputs.opaqueLibraryToLink(sharedLibrary,ArtifactCategory.DYNAMIC_LIBRARY,libraryIdentifier));
    }
 else {
      dynamicLibrariesForRuntimeList=ImmutableList.of(LinkerInputs.solibLibraryToLink(common.getDynamicLibrarySymlink(sharedLibrary,true),sharedLibrary,libraryIdentifier));
    }
    linkingHelper.addDynamicLibrariesForRuntime(dynamicLibrariesForRuntimeList);
  }
  if (interfaceLibrary != null) {
    if (targetWindows) {
      dynamicLibraryForLinkingList=ImmutableList.of(LinkerInputs.opaqueLibraryToLink(interfaceLibrary,ArtifactCategory.INTERFACE_LIBRARY,libraryIdentifier));
    }
 else {
      dynamicLibraryForLinkingList=ImmutableList.of(LinkerInputs.solibLibraryToLink(common.getDynamicLibrarySymlink(interfaceLibrary,true),interfaceLibrary,libraryIdentifier));
    }
  }
 else {
    if (!targetWindows) {
      dynamicLibraryForLinkingList=dynamicLibrariesForRuntimeList;
    }
 else     if (staticLibrary == null) {
      ruleContext.ruleError(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  if (dynamicLibraryForLinkingList != null) {
    linkingHelper.addDynamicLibrariesForLinking(dynamicLibraryForLinkingList);
  }
  LinkingInfo linkingInfo=linkingHelper.link(compilationInfo.getCcCompilationOutputs(),compilationInfo.getCcCompilationContext());
  return new RuleConfiguredTargetBuilder(ruleContext).addProviders(compilationInfo.getProviders()).addProviders(linkingInfo.getProviders()).addSkylarkTransitiveInfo(CcSkylarkApiProvider.NAME,new CcSkylarkApiProvider()).addOutputGroups(CcCommon.mergeOutputGroups(ImmutableList.of(compilationInfo.getOutputGroups(),linkingInfo.getOutputGroups()))).addProvider(RunfilesProvider.class,RunfilesProvider.simple(Runfiles.EMPTY)).build();
}","@Override public ConfiguredTarget create(RuleContext ruleContext) throws InterruptedException, RuleErrorException, ActionConflictException {
  Artifact staticLibrary=ruleContext.getPrerequisiteArtifact(""String_Node_Str"",Mode.TARGET);
  Artifact sharedLibrary=ruleContext.getPrerequisiteArtifact(""String_Node_Str"",Mode.TARGET);
  Artifact interfaceLibrary=ruleContext.getPrerequisiteArtifact(""String_Node_Str"",Mode.TARGET);
  boolean systemProvided=ruleContext.attributes().get(""String_Node_Str"",Type.BOOLEAN);
  if (systemProvided && sharedLibrary != null) {
    ruleContext.ruleError(""String_Node_Str"");
  }
  if (!systemProvided && sharedLibrary == null && interfaceLibrary != null) {
    ruleContext.ruleError(""String_Node_Str"");
  }
  CcToolchainProvider ccToolchain=CppHelper.getToolchainUsingDefaultCcToolchainAttribute(ruleContext);
  FeatureConfiguration featureConfiguration=CcCommon.configureFeaturesOrReportRuleError(ruleContext,ccToolchain);
  FdoSupportProvider fdoSupport=CppHelper.getFdoSupportUsingDefaultCcToolchainAttribute(ruleContext);
  final CcCommon common=new CcCommon(ruleContext);
  CompilationInfo compilationInfo=new CcCompilationHelper(ruleContext,semantics,featureConfiguration,ccToolchain,fdoSupport).addPublicHeaders(common.getHeaders()).setHeadersCheckingMode(HeadersCheckingMode.STRICT).compile();
  boolean alwayslink=ruleContext.attributes().get(""String_Node_Str"",Type.BOOLEAN);
  ArtifactCategory staticLibraryCategory=alwayslink ? ArtifactCategory.ALWAYSLINK_STATIC_LIBRARY : ArtifactCategory.STATIC_LIBRARY;
  PathFragment labelName=PathFragment.create(ruleContext.getLabel().getName());
  String libraryIdentifier=ruleContext.getPackageDirectory().getRelative(labelName.replaceName(""String_Node_Str"" + labelName.getBaseName())).getPathString();
  CcLinkingHelper linkingHelper=new CcLinkingHelper(ruleContext,semantics,featureConfiguration,ccToolchain,fdoSupport,ruleContext.getConfiguration());
  if (staticLibrary != null) {
    if (CppFileTypes.PIC_ARCHIVE.matches(staticLibrary.getPath())) {
      linkingHelper.addPicStaticLibraries(ImmutableList.of(LinkerInputs.opaqueLibraryToLink(staticLibrary,staticLibraryCategory,libraryIdentifier,alwayslink)));
    }
 else {
      linkingHelper.addStaticLibraries(ImmutableList.of(LinkerInputs.opaqueLibraryToLink(staticLibrary,staticLibraryCategory,libraryIdentifier,alwayslink)));
    }
  }
  boolean targetWindows=featureConfiguration.isEnabled(CppRuleClasses.TARGETS_WINDOWS);
  Iterable<LibraryToLink> dynamicLibraryForLinkingList=null;
  Iterable<LibraryToLink> dynamicLibrariesForRuntimeList=null;
  if (sharedLibrary != null) {
    if (targetWindows) {
      dynamicLibrariesForRuntimeList=ImmutableList.of(LinkerInputs.opaqueLibraryToLink(sharedLibrary,ArtifactCategory.DYNAMIC_LIBRARY,libraryIdentifier));
    }
 else {
      dynamicLibrariesForRuntimeList=ImmutableList.of(LinkerInputs.solibLibraryToLink(common.getDynamicLibrarySymlink(sharedLibrary,true),sharedLibrary,libraryIdentifier));
    }
    linkingHelper.addDynamicLibrariesForRuntime(dynamicLibrariesForRuntimeList);
  }
  if (interfaceLibrary != null) {
    if (targetWindows) {
      dynamicLibraryForLinkingList=ImmutableList.of(LinkerInputs.opaqueLibraryToLink(interfaceLibrary,ArtifactCategory.INTERFACE_LIBRARY,libraryIdentifier));
    }
 else {
      dynamicLibraryForLinkingList=ImmutableList.of(LinkerInputs.solibLibraryToLink(common.getDynamicLibrarySymlink(interfaceLibrary,true),interfaceLibrary,libraryIdentifier));
    }
  }
 else {
    if (!targetWindows) {
      dynamicLibraryForLinkingList=dynamicLibrariesForRuntimeList;
    }
 else     if (sharedLibrary != null) {
      ruleContext.ruleError(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  if (dynamicLibraryForLinkingList != null) {
    linkingHelper.addDynamicLibrariesForLinking(dynamicLibraryForLinkingList);
  }
  LinkingInfo linkingInfo=linkingHelper.link(compilationInfo.getCcCompilationOutputs(),compilationInfo.getCcCompilationContext());
  return new RuleConfiguredTargetBuilder(ruleContext).addProviders(compilationInfo.getProviders()).addProviders(linkingInfo.getProviders()).addSkylarkTransitiveInfo(CcSkylarkApiProvider.NAME,new CcSkylarkApiProvider()).addOutputGroups(CcCommon.mergeOutputGroups(ImmutableList.of(compilationInfo.getOutputGroups(),linkingInfo.getOutputGroups()))).addProvider(RunfilesProvider.class,RunfilesProvider.simple(Runfiles.EMPTY)).build();
}",0.9968282736746716
110530,"@Override public SkyValue compute(SkyKey skyKey,Environment env) throws ActionExecutionFunctionException, InterruptedException {
  ActionLookupData actionLookupData=(ActionLookupData)skyKey.argument();
  ActionLookupValue actionLookupValue=(ActionLookupValue)env.getValue(actionLookupData.getActionLookupKey());
  int actionIndex=actionLookupData.getActionIndex();
  Action action=actionLookupValue.getAction(actionIndex);
  skyframeActionExecutor.noteActionEvaluationStarted(actionLookupData,action);
  if ((action.isVolatile() && !(action instanceof SkyframeAwareAction)) || action instanceof NotifyOnActionCacheHit) {
    PrecomputedValue.BUILD_ID.get(env);
  }
  Map<SkyKey,SkyValue> clientEnvLookup=env.getValues(Iterables.transform(action.getClientEnvironmentVariables(),ClientEnvironmentFunction::key));
  if (env.valuesMissing()) {
    return null;
  }
  Map<String,String> clientEnv=new HashMap<>();
  for (  Map.Entry<SkyKey,SkyValue> entry : clientEnvLookup.entrySet()) {
    ClientEnvironmentValue envValue=(ClientEnvironmentValue)entry.getValue();
    if (envValue.getValue() != null) {
      clientEnv.put((String)entry.getKey().argument(),envValue.getValue());
    }
  }
  boolean sharedActionAlreadyRan=skyframeActionExecutor.probeActionExecution(action);
  ContinuationState state;
  if (action.discoversInputs()) {
    state=getState(action);
  }
 else {
    state=new ContinuationState();
  }
  if (!state.hasCollectedInputs()) {
    state.allInputs=collectInputs(action,env);
    if (state.allInputs == null) {
      return null;
    }
  }
 else   if (state.allInputs.keysRequested != null) {
    env.getValues(state.allInputs.keysRequested);
    Preconditions.checkState(!env.valuesMissing(),""String_Node_Str"",action,state);
  }
  Pair<ActionInputMap,Map<Artifact,Collection<Artifact>>> checkedInputs=null;
  try {
    Map<SkyKey,ValueOrException2<MissingInputFileException,ActionExecutionException>> inputDeps=env.getValuesOrThrow(toKeys(state.allInputs.getAllInputs(),action.discoversInputs() ? action.getMandatoryInputs() : null),MissingInputFileException.class,ActionExecutionException.class);
    if (!sharedActionAlreadyRan && !state.hasArtifactData()) {
      checkedInputs=checkInputs(env,action,inputDeps);
    }
  }
 catch (  ActionExecutionException e) {
    stateMap.remove(action);
    throw new ActionExecutionFunctionException(e);
  }
  if (env.valuesMissing()) {
    return null;
  }
  try {
    establishSkyframeDependencies(env,action);
  }
 catch (  ActionExecutionException e) {
    throw new ActionExecutionFunctionException(e);
  }
  if (env.valuesMissing()) {
    return null;
  }
  if (checkedInputs != null) {
    Preconditions.checkState(!state.hasArtifactData(),""String_Node_Str"",state,action);
    state.inputArtifactData=checkedInputs.first;
    state.expandedArtifacts=checkedInputs.second;
    if (skyframeActionExecutor.usesActionFileSystem()) {
      Iterable<Artifact> optionalInputs;
      if (action.discoversInputs()) {
        if (action instanceof IncludeScannable) {
          optionalInputs=((IncludeScannable)action).getDeclaredIncludeSrcs();
        }
 else {
          optionalInputs=action.getAllowedDerivedInputs();
        }
      }
 else {
        optionalInputs=ImmutableList.of();
      }
      state.actionFileSystem=new ActionFileSystem(skyframeActionExecutor.getExecutorFileSystem(),skyframeActionExecutor.getExecRoot(),directories.getRelativeOutputPath(),skyframeActionExecutor.getSourceRoots(),checkedInputs.first,optionalInputs,action.getOutputs());
    }
  }
  ActionExecutionValue result;
  try {
    result=checkCacheAndExecuteIfNeeded(action,state,env,clientEnv,actionLookupData,sharedActionAlreadyRan);
  }
 catch (  ActionExecutionException e) {
    stateMap.remove(action);
    throw new ActionExecutionFunctionException(new AlreadyReportedActionExecutionException(e));
  }
  if (env.valuesMissing()) {
    Preconditions.checkState(stateMap.containsKey(action),action);
    return null;
  }
  stateMap.remove(action);
  actionLookupValue.actionEvaluated(actionIndex,action);
  return result;
}","@Override public SkyValue compute(SkyKey skyKey,Environment env) throws ActionExecutionFunctionException, InterruptedException {
  ActionLookupData actionLookupData=(ActionLookupData)skyKey.argument();
  ActionLookupValue actionLookupValue=(ActionLookupValue)env.getValue(actionLookupData.getActionLookupKey());
  int actionIndex=actionLookupData.getActionIndex();
  Action action=actionLookupValue.getAction(actionIndex);
  skyframeActionExecutor.noteActionEvaluationStarted(actionLookupData,action);
  if ((action.isVolatile() && !(action instanceof SkyframeAwareAction)) || action instanceof NotifyOnActionCacheHit) {
    PrecomputedValue.BUILD_ID.get(env);
  }
  Map<SkyKey,SkyValue> clientEnvLookup=env.getValues(Iterables.transform(action.getClientEnvironmentVariables(),ClientEnvironmentFunction::key));
  if (env.valuesMissing()) {
    return null;
  }
  Map<String,String> clientEnv=new HashMap<>();
  for (  Map.Entry<SkyKey,SkyValue> entry : clientEnvLookup.entrySet()) {
    ClientEnvironmentValue envValue=(ClientEnvironmentValue)entry.getValue();
    if (envValue.getValue() != null) {
      clientEnv.put((String)entry.getKey().argument(),envValue.getValue());
    }
  }
  boolean sharedActionAlreadyRan=skyframeActionExecutor.probeActionExecution(action);
  ContinuationState state;
  if (action.discoversInputs()) {
    state=getState(action);
  }
 else {
    state=new ContinuationState();
  }
  if (!state.hasCollectedInputs()) {
    state.allInputs=collectInputs(action,env);
    if (state.allInputs == null) {
      return null;
    }
  }
 else   if (state.allInputs.keysRequested != null) {
    env.getValues(state.allInputs.keysRequested);
    Preconditions.checkState(!env.valuesMissing(),""String_Node_Str"",action,state);
  }
  Pair<ActionInputMap,Map<Artifact,Collection<Artifact>>> checkedInputs=null;
  try {
    Map<SkyKey,ValueOrException2<MissingInputFileException,ActionExecutionException>> inputDeps=env.getValuesOrThrow(toKeys(state.allInputs.getAllInputs(),action.discoversInputs() ? action.getMandatoryInputs() : null),MissingInputFileException.class,ActionExecutionException.class);
    if (!sharedActionAlreadyRan && !state.hasArtifactData()) {
      checkedInputs=checkInputs(env,action,inputDeps);
    }
  }
 catch (  ActionExecutionException e) {
    stateMap.remove(action);
    throw new ActionExecutionFunctionException(e);
  }
  if (env.valuesMissing()) {
    return null;
  }
  try {
    establishSkyframeDependencies(env,action);
  }
 catch (  ActionExecutionException e) {
    throw new ActionExecutionFunctionException(e);
  }
  if (env.valuesMissing()) {
    return null;
  }
  if (checkedInputs != null) {
    Preconditions.checkState(!state.hasArtifactData(),""String_Node_Str"",state,action);
    state.inputArtifactData=checkedInputs.first;
    state.expandedArtifacts=checkedInputs.second;
    if (skyframeActionExecutor.usesActionFileSystem()) {
      Iterable<Artifact> optionalInputs;
      if (action.discoversInputs()) {
        if (action instanceof IncludeScannable) {
          optionalInputs=((IncludeScannable)action).getDeclaredIncludeSrcs();
        }
 else {
          optionalInputs=action.getAllowedDerivedInputs();
        }
      }
 else {
        optionalInputs=ImmutableList.of();
      }
      state.actionFileSystem=new ActionFileSystem(skyframeActionExecutor.getExecutorFileSystem(),skyframeActionExecutor.getExecRoot().asFragment(),directories.getRelativeOutputPath(),skyframeActionExecutor.getSourceRoots(),checkedInputs.first,optionalInputs,action.getOutputs());
    }
  }
  ActionExecutionValue result;
  try {
    result=checkCacheAndExecuteIfNeeded(action,state,env,clientEnv,actionLookupData,sharedActionAlreadyRan);
  }
 catch (  ActionExecutionException e) {
    stateMap.remove(action);
    throw new ActionExecutionFunctionException(new AlreadyReportedActionExecutionException(e));
  }
  if (env.valuesMissing()) {
    Preconditions.checkState(stateMap.containsKey(action),action);
    return null;
  }
  stateMap.remove(action);
  actionLookupValue.actionEvaluated(actionIndex,action);
  return result;
}",0.9984082282355822
110531,"ActionFileSystem(FileSystem delegate,Path execRoot,String relativeOutputPath,ImmutableList<Root> sourceRoots,ActionInputMap inputArtifactData,Iterable<Artifact> allowedInputs,Iterable<Artifact> outputArtifacts){
  try (SilentCloseable c=Profiler.instance().profile(ProfilerTask.ACTION_FS_STAGING,""String_Node_Str"")){
    this.delegate=delegate;
    this.execRootFragment=execRoot.asFragment();
    this.outputPathFragment=execRootFragment.getRelative(relativeOutputPath);
    this.sourceRoots=sourceRoots.stream().map(root -> root.asPath().asFragment()).collect(ImmutableList.toImmutableList());
    validateRoots();
    this.inputArtifactData=inputArtifactData;
    this.optionalInputs=new HashMap<>();
    for (    Artifact input : allowedInputs) {
      if (input.isSourceArtifact() || inputArtifactData.getMetadata(input) != null) {
        continue;
      }
      optionalInputs.computeIfAbsent(input.getExecPath(),unused -> new OptionalInputMetadata(input));
    }
    ImmutableMap<PathFragment,Artifact> outputsMapping=Streams.stream(outputArtifacts).collect(ImmutableMap.toImmutableMap(Artifact::getExecPath,a -> a));
    this.outputs=CacheBuilder.newBuilder().build(CacheLoader.from(path -> new OutputMetadata(outputsMapping.get(path))));
  }
 }","ActionFileSystem(FileSystem delegate,PathFragment execRoot,String relativeOutputPath,ImmutableList<Root> sourceRoots,ActionInputMap inputArtifactData,Iterable<Artifact> allowedInputs,Iterable<Artifact> outputArtifacts){
  try (SilentCloseable c=Profiler.instance().profile(ProfilerTask.ACTION_FS_STAGING,""String_Node_Str"")){
    this.delegate=delegate;
    this.execRootFragment=execRoot;
    this.outputPathFragment=execRootFragment.getRelative(relativeOutputPath);
    this.sourceRoots=sourceRoots.stream().map(root -> root.asPath().asFragment()).collect(ImmutableList.toImmutableList());
    validateRoots();
    this.inputArtifactData=inputArtifactData;
    this.optionalInputs=new HashMap<>();
    for (    Artifact input : allowedInputs) {
      if (input.isSourceArtifact() || inputArtifactData.getMetadata(input) != null) {
        continue;
      }
      optionalInputs.computeIfAbsent(input.getExecPath(),unused -> new OptionalInputMetadata(input));
    }
    ImmutableMap<PathFragment,Artifact> outputsMapping=Streams.stream(outputArtifacts).collect(ImmutableMap.toImmutableMap(Artifact::getExecPath,a -> a));
    this.outputs=CacheBuilder.newBuilder().build(CacheLoader.from(path -> new OutputMetadata(outputsMapping.get(path))));
  }
 }",0.9916100679184978
110532,"@Override public void close() throws IOException {
  super.close();
  byte[] data=toByteArray();
  set(new InlineFileArtifactValue(data,Hashing.md5().hashBytes(data).asBytes()),true);
}","@Override public void close() throws IOException {
  flush();
  super.close();
}",0.5207547169811321
110533,"/** 
 * Callers are expected to close the returned stream. 
 */
public ByteArrayOutputStream getOutputStream(){
  Preconditions.checkState(metadata == null,""String_Node_Str"",artifact);
  return new ByteArrayOutputStream(){
    @Override public void close() throws IOException {
      super.close();
      byte[] data=toByteArray();
      set(new InlineFileArtifactValue(data,Hashing.md5().hashBytes(data).asBytes()),true);
    }
  }
;
}","/** 
 * Callers are expected to close the returned stream. 
 */
public ByteArrayOutputStream getOutputStream(){
  Preconditions.checkState(metadata == null,""String_Node_Str"",artifact);
  return new ByteArrayOutputStream(){
    @Override public void close() throws IOException {
      flush();
      super.close();
    }
    @Override public void flush() throws IOException {
      super.flush();
      byte[] data=toByteArray();
      set(new InlineFileArtifactValue(data,Hashing.md5().hashBytes(data).asBytes()),true);
    }
  }
;
}",0.8771929824561403
110534,"/** 
 * Unpauses the given thread if it is currently paused. Also unsets   {@link #pausingAllThreads}.
 */
@GuardedBy(""String_Node_Str"") private void resumeThread(ThreadState thread,SkylarkDebuggingProtos.Stepping stepping){
  PausedThreadState pausedState=thread.pausedState;
  if (pausedState == null) {
    return;
  }
  pausingAllThreads=false;
  thread.readyToPause=thread.debuggable.stepControl(DebugEventHelper.convertSteppingEnum(stepping));
  pausedState.semaphore.release();
  thread.pausedState=null;
}","/** 
 * Unpauses the given thread if it is currently paused. Also unsets   {@link #pausingAllThreads}.
 */
@GuardedBy(""String_Node_Str"") private void resumeThread(ThreadState thread,SkylarkDebuggingProtos.Stepping stepping){
  PausedThreadState pausedState=thread.pausedState;
  if (pausedState == null) {
    return;
  }
  pausingAllThreads=false;
  thread.readyToPause=thread.debuggable.stepControl(DebugEventHelper.convertSteppingEnum(stepping));
  thread.pausedState=null;
  pausedState.semaphore.release();
}",0.9473684210526316
110535,"/** 
 * Pauses the current thread's execution, blocking until it's resumed via a ContinueExecutionRequest.
 */
private void pauseCurrentThread(Environment env,Location location,DebugServerTransport transport){
  long threadId=Thread.currentThread().getId();
  SkylarkDebuggingProtos.Thread threadProto;
  PausedThreadState pausedState;
synchronized (threads) {
    ThreadState thread=threads.get(threadId);
    if (thread == null) {
      String fallbackThreadName=""String_Node_Str"" + threadId;
      transport.postEvent(DebugEventHelper.threadStartedEvent(threadId,fallbackThreadName));
      thread=doRegisterThread(threadId,fallbackThreadName,env);
    }
    threadProto=getThreadProto(thread);
    pausedState=new PausedThreadState(location);
    thread.pausedState=pausedState;
  }
  transport.postEvent(DebugEventHelper.threadPausedEvent(threadProto));
  pausedState.semaphore.acquireUninterruptibly();
  transport.postEvent(DebugEventHelper.threadContinuedEvent(threadProto));
}","/** 
 * Pauses the current thread's execution, blocking until it's resumed via a ContinueExecutionRequest.
 */
private void pauseCurrentThread(Environment env,Location location,DebugServerTransport transport){
  long threadId=Thread.currentThread().getId();
  SkylarkDebuggingProtos.Thread threadProto;
  PausedThreadState pausedState;
synchronized (threads) {
    ThreadState thread=threads.get(threadId);
    if (thread == null) {
      String fallbackThreadName=""String_Node_Str"" + threadId;
      transport.postEvent(DebugEventHelper.threadStartedEvent(threadId,fallbackThreadName));
      thread=doRegisterThread(threadId,fallbackThreadName,env);
    }
    pausedState=new PausedThreadState(location);
    thread.pausedState=pausedState;
    threadProto=getThreadProto(thread);
  }
  transport.postEvent(DebugEventHelper.threadPausedEvent(threadProto));
  pausedState.semaphore.acquireUninterruptibly();
  transport.postEvent(DebugEventHelper.threadContinuedEvent(threadProto.toBuilder().clearLocation().setIsPaused(false).build()));
}",0.8691358024691358
110536,"/** 
 * Returns whether a test with the specified tags matches a filter (as specified by the set of its positive and its negative filters).
 */
public static boolean testMatchesFilters(Collection<String> testTags,Collection<String> requiredTags,Collection<String> excludedTags,boolean mustMatchAllPositive){
  for (  String tag : excludedTags) {
    if (testTags.contains(tag)) {
      return false;
    }
  }
  if (!requiredTags.isEmpty()) {
    if (mustMatchAllPositive) {
      for (      String tag : requiredTags) {
        if (!testTags.contains(tag)) {
          return false;
        }
      }
      return true;
    }
 else {
      for (      String tag : requiredTags) {
        if (testTags.contains(tag)) {
          return true;
        }
      }
    }
    return false;
  }
  return true;
}","/** 
 * Decides whether to include a test in a test_suite or not.
 * @param testTarget A given test target.
 * @param requiredTags Tags declared by the suite. A Test must match ALL of these.
 * @param excludedTags Tags declared by the suite. A Test must match NONE of these.
 * @return false is the test is to be removed.
 */
private static boolean testMatchesFilters(Rule testTarget,Collection<String> requiredTags,Collection<String> excludedTags){
  AttributeMap nonConfigurableAttrs=NonconfigurableAttributeMapper.of(testTarget);
  Set<String> testTags=new HashSet<>(nonConfigurableAttrs.get(""String_Node_Str"",Type.STRING_LIST));
  testTags.add(nonConfigurableAttrs.get(""String_Node_Str"",Type.STRING));
  return testMatchesFilters(testTags,requiredTags,excludedTags);
}",0.1928934010152284
110537,"/** 
 * Populates 'result' with all the tests associated with the specified 'testSuite'.  Throws an exception if any target is missing. CAUTION!  Keep this logic consistent with   {@code TestsSuiteConfiguredTarget}!
 */
private void computeTestsInSuite(Rule testSuite,Set<Target> result) throws TargetParsingException {
  List<Target> testsAndSuites=new ArrayList<>();
  testsAndSuites.addAll(getPrerequisites(testSuite,""String_Node_Str""));
  for (  Target test : testsAndSuites) {
    if (TargetUtils.isTestRule(test)) {
      result.add(test);
    }
 else     if (strict && !TargetUtils.isTestSuiteRule(test)) {
      eventHandler.handle(Event.error(testSuite.getLocation(),""String_Node_Str"" + testSuite.getLabel() + ""String_Node_Str""+ test.getLabel()+ ""String_Node_Str""));
      hasError=true;
      if (!keepGoing) {
        throw new TargetParsingException(""String_Node_Str"");
      }
    }
  }
  for (  Target target : getPrerequisites(testSuite,""String_Node_Str"")) {
    if (TargetUtils.isTestRule(target)) {
      result.add(target);
    }
  }
  filterTests(testSuite,result);
  for (  Target suite : testsAndSuites) {
    if (TargetUtils.isTestSuiteRule(suite)) {
      result.addAll(getTestsInSuite((Rule)suite));
    }
  }
}","/** 
 * Populates 'result' with all the tests associated with the specified 'testSuite'.  Throws an exception if any target is missing. CAUTION!  Keep this logic consistent with   {@code TestSuite} and {@code TestsInSuiteFunction}!
 */
private void computeTestsInSuite(Rule testSuite,Set<Target> result) throws TargetParsingException {
  List<Target> testsAndSuites=new ArrayList<>();
  testsAndSuites.addAll(getPrerequisites(testSuite,""String_Node_Str""));
  for (  Target test : testsAndSuites) {
    if (TargetUtils.isTestRule(test)) {
      result.add(test);
    }
 else     if (strict && !TargetUtils.isTestSuiteRule(test)) {
      eventHandler.handle(Event.error(testSuite.getLocation(),""String_Node_Str"" + testSuite.getLabel() + ""String_Node_Str""+ test.getLabel()+ ""String_Node_Str""));
      hasError=true;
      if (!keepGoing) {
        throw new TargetParsingException(""String_Node_Str"");
      }
    }
  }
  for (  Target target : getPrerequisites(testSuite,""String_Node_Str"")) {
    if (TargetUtils.isTestRule(target)) {
      result.add(target);
    }
  }
  filterTests(testSuite,result);
  for (  Target suite : testsAndSuites) {
    if (TargetUtils.isTestSuiteRule(suite)) {
      result.addAll(getTestsInSuite((Rule)suite));
    }
  }
}",0.9758648431214804
110538,"/** 
 * Filters 'tests' (by mutation) according to the 'tags' attribute, specifically those that match ALL of the tags in tagsAttribute.
 * @precondition {@code env.getAccessor().isTestSuite(testSuite)}
 * @precondition {@code env.getAccessor().isTestRule(test)} for all test in tests
 */
private void filterTests(Rule testSuite,Set<Target> tests){
  List<String> tagsAttribute=NonconfigurableAttributeMapper.of(testSuite).get(""String_Node_Str"",Type.STRING_LIST);
  Pair<Collection<String>,Collection<String>> tagLists=sortTagsBySense(tagsAttribute);
  Collection<String> positiveTags=tagLists.first;
  Collection<String> negativeTags=tagLists.second;
  Iterator<Target> it=tests.iterator();
  while (it.hasNext()) {
    Rule test=(Rule)it.next();
    AttributeMap nonConfigurableAttributes=NonconfigurableAttributeMapper.of(test);
    List<String> testTags=new ArrayList<>(nonConfigurableAttributes.get(""String_Node_Str"",Type.STRING_LIST));
    testTags.add(nonConfigurableAttributes.get(""String_Node_Str"",Type.STRING));
    if (!includeTest(testTags,positiveTags,negativeTags)) {
      it.remove();
    }
  }
}","/** 
 * Filters 'tests' (by mutation) according to the 'tags' attribute, specifically those that match ALL of the tags in tagsAttribute.
 * @precondition {@code env.getAccessor().isTestSuite(testSuite)}
 * @precondition {@code env.getAccessor().isTestRule(test)} for all test in tests
 */
public static void filterTests(Rule testSuite,Set<Target> tests){
  List<String> tagsAttribute=NonconfigurableAttributeMapper.of(testSuite).get(""String_Node_Str"",Type.STRING_LIST);
  Pair<Collection<String>,Collection<String>> tagLists=sortTagsBySense(tagsAttribute);
  Collection<String> positiveTags=tagLists.first;
  Collection<String> negativeTags=tagLists.second;
  tests.removeIf((  Target t) -> !testMatchesFilters((Rule)t,positiveTags,negativeTags));
}",0.7039226222461042
110539,"/** 
 * Computes and returns the set of test rules in a particular suite.  Uses dynamic programming---a memoized version of   {@link #computeTestsInSuite}.
 */
private Set<Target> getTestsInSuite(Rule testSuite) throws TargetParsingException {
  Set<Target> tests=testsInSuite.get(testSuite);
  if (tests == null) {
    tests=Sets.newHashSet();
    testsInSuite.put(testSuite,tests);
    computeTestsInSuite(testSuite,tests);
  }
  return tests;
}","/** 
 * Computes and returns the set of test rules in a particular suite.  Uses dynamic programming---a memoized version of   {@link #computeTestsInSuite}.
 */
private Set<Target> getTestsInSuite(Rule testSuite) throws TargetParsingException {
  Set<Target> tests=testsInSuite.get(testSuite);
  if (tests == null) {
    tests=new HashSet<>();
    testsInSuite.put(testSuite,tests);
    computeTestsInSuite(testSuite,tests);
  }
  return tests;
}",0.827354260089686
110540,"@Override public ConfiguredTarget create(RuleContext ruleContext) throws InterruptedException, RuleErrorException, ActionConflictException {
  checkTestsAndSuites(ruleContext,""String_Node_Str"");
  if (ruleContext.hasErrors()) {
    return null;
  }
  List<String> tagsAttribute=new ArrayList<>(ruleContext.attributes().get(""String_Node_Str"",Type.STRING_LIST));
  tagsAttribute.remove(""String_Node_Str"");
  Pair<Collection<String>,Collection<String>> requiredExcluded=TestTargetUtils.sortTagsBySense(tagsAttribute);
  List<TransitiveInfoCollection> directTestsAndSuitesBuilder=new ArrayList<>();
  for (  TransitiveInfoCollection dep : Iterables.concat(getPrerequisites(ruleContext,""String_Node_Str""),getPrerequisites(ruleContext,""String_Node_Str""))) {
    if (dep.getProvider(TestProvider.class) != null) {
      List<String> tags=dep.getProvider(TestProvider.class).getTestTags();
      if (!TestTargetUtils.testMatchesFilters(tags,requiredExcluded.first,requiredExcluded.second,true)) {
        continue;
      }
    }
    directTestsAndSuitesBuilder.add(dep);
  }
  Runfiles runfiles=new Runfiles.Builder(ruleContext.getWorkspaceName(),ruleContext.getConfiguration().legacyExternalRunfiles()).addTargets(directTestsAndSuitesBuilder,RunfilesProvider.DATA_RUNFILES).build();
  return new RuleConfiguredTargetBuilder(ruleContext).add(RunfilesProvider.class,RunfilesProvider.withData(Runfiles.EMPTY,runfiles)).add(TransitiveTestsProvider.class,new TransitiveTestsProvider()).build();
}","@Override public ConfiguredTarget create(RuleContext ruleContext) throws InterruptedException, RuleErrorException, ActionConflictException {
  checkTestsAndSuites(ruleContext,""String_Node_Str"");
  if (ruleContext.hasErrors()) {
    return null;
  }
  List<String> tagsAttribute=new ArrayList<>(ruleContext.attributes().get(""String_Node_Str"",Type.STRING_LIST));
  tagsAttribute.remove(""String_Node_Str"");
  Pair<Collection<String>,Collection<String>> requiredExcluded=TestTargetUtils.sortTagsBySense(tagsAttribute);
  List<TransitiveInfoCollection> directTestsAndSuitesBuilder=new ArrayList<>();
  for (  TransitiveInfoCollection dep : Iterables.concat(getPrerequisites(ruleContext,""String_Node_Str""),getPrerequisites(ruleContext,""String_Node_Str""))) {
    if (dep.getProvider(TestProvider.class) != null) {
      List<String> tags=dep.getProvider(TestProvider.class).getTestTags();
      if (!TestTargetUtils.testMatchesFilters(tags,requiredExcluded.first,requiredExcluded.second)) {
        continue;
      }
    }
    directTestsAndSuitesBuilder.add(dep);
  }
  Runfiles runfiles=new Runfiles.Builder(ruleContext.getWorkspaceName(),ruleContext.getConfiguration().legacyExternalRunfiles()).addTargets(directTestsAndSuitesBuilder,RunfilesProvider.DATA_RUNFILES).build();
  return new RuleConfiguredTargetBuilder(ruleContext).add(RunfilesProvider.class,RunfilesProvider.withData(Runfiles.EMPTY,runfiles)).add(TransitiveTestsProvider.class,new TransitiveTestsProvider()).build();
}",0.9983125210934864
110541,"@SkylarkCallable(name=""String_Node_Str"",doc=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",parameters={@Param(name=""String_Node_Str"",type=String.class,doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=String.class,legacyNamed=true,doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=Integer.class,legacyNamed=true,defaultValue=""String_Node_Str"",doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=Integer.class,legacyNamed=true,noneable=true,defaultValue=""String_Node_Str"",doc=""String_Node_Str"")}) public Integer invoke(String self,String sub,Integer start,Object end) throws ConversionException {
  return stringFind(true,self,sub,start,end,""String_Node_Str"");
}","@SkylarkCallable(name=""String_Node_Str"",doc=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",parameters={@Param(name=""String_Node_Str"",type=String.class,doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=String.class,legacyNamed=true,doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=Integer.class,legacyNamed=true,defaultValue=""String_Node_Str"",doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=Integer.class,legacyNamed=true,noneable=true,defaultValue=""String_Node_Str"",doc=""String_Node_Str"")}) public Integer invoke(String self,String sub,Integer start,Object end) throws ConversionException {
  return stringFind(true,self,sub,start,end,""String_Node_Str"");
}",0.9864960909737028
110542,"@SkylarkCallable(name=""String_Node_Str"",doc=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",parameters={@Param(name=""String_Node_Str"",type=String.class,doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=String.class,legacyNamed=true,doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=Integer.class,legacyNamed=true,defaultValue=""String_Node_Str"",doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=Integer.class,legacyNamed=true,noneable=true,defaultValue=""String_Node_Str"",doc=""String_Node_Str"")}) public Integer rfind(String self,String sub,Integer start,Object end) throws ConversionException {
  return stringFind(false,self,sub,start,end,""String_Node_Str"");
}","@SkylarkCallable(name=""String_Node_Str"",doc=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",parameters={@Param(name=""String_Node_Str"",type=String.class,doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=String.class,legacyNamed=true,doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=Integer.class,legacyNamed=true,defaultValue=""String_Node_Str"",doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=Integer.class,legacyNamed=true,noneable=true,defaultValue=""String_Node_Str"",doc=""String_Node_Str"")}) public Integer rfind(String self,String sub,Integer start,Object end) throws ConversionException {
  return stringFind(false,self,sub,start,end,""String_Node_Str"");
}",0.9864960909737028
110543,"@SkylarkCallable(name=""String_Node_Str"",doc=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",parameters={@Param(name=""String_Node_Str"",type=String.class,doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=String.class,legacyNamed=true,doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=Integer.class,legacyNamed=true,defaultValue=""String_Node_Str"",doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=Integer.class,legacyNamed=true,noneable=true,defaultValue=""String_Node_Str"",doc=""String_Node_Str"")},useLocation=true) public Integer rindex(String self,String sub,Integer start,Object end,Location loc) throws EvalException {
  int res=stringFind(false,self,sub,start,end,""String_Node_Str"");
  if (res < 0) {
    throw new EvalException(loc,Printer.format(""String_Node_Str"",sub,self));
  }
  return res;
}","@SkylarkCallable(name=""String_Node_Str"",doc=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",parameters={@Param(name=""String_Node_Str"",type=String.class,doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=String.class,legacyNamed=true,doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=Integer.class,legacyNamed=true,defaultValue=""String_Node_Str"",doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=Integer.class,legacyNamed=true,noneable=true,defaultValue=""String_Node_Str"",doc=""String_Node_Str"")},useLocation=true) public Integer rindex(String self,String sub,Integer start,Object end,Location loc) throws EvalException {
  int res=stringFind(false,self,sub,start,end,""String_Node_Str"");
  if (res < 0) {
    throw new EvalException(loc,Printer.format(""String_Node_Str"",sub,self));
  }
  return res;
}",0.9887106357694592
110544,"@SkylarkCallable(name=""String_Node_Str"",doc=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",parameters={@Param(name=""String_Node_Str"",type=String.class,doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=String.class,legacyNamed=true,doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=Integer.class,legacyNamed=true,defaultValue=""String_Node_Str"",doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=Integer.class,legacyNamed=true,noneable=true,defaultValue=""String_Node_Str"",doc=""String_Node_Str"")},useLocation=true) public Integer index(String self,String sub,Integer start,Object end,Location loc) throws EvalException {
  int res=stringFind(true,self,sub,start,end,""String_Node_Str"");
  if (res < 0) {
    throw new EvalException(loc,Printer.format(""String_Node_Str"",sub,self));
  }
  return res;
}","@SkylarkCallable(name=""String_Node_Str"",doc=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",parameters={@Param(name=""String_Node_Str"",type=String.class,doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=String.class,legacyNamed=true,doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=Integer.class,legacyNamed=true,defaultValue=""String_Node_Str"",doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=Integer.class,legacyNamed=true,noneable=true,defaultValue=""String_Node_Str"",doc=""String_Node_Str"")},useLocation=true) public Integer index(String self,String sub,Integer start,Object end,Location loc) throws EvalException {
  int res=stringFind(true,self,sub,start,end,""String_Node_Str"");
  if (res < 0) {
    throw new EvalException(loc,Printer.format(""String_Node_Str"",sub,self));
  }
  return res;
}",0.98868374032162
110545,"@SkylarkCallable(name=""String_Node_Str"",doc=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",parameters={@Param(name=""String_Node_Str"",type=String.class,doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=String.class,legacyNamed=true,doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=Integer.class,legacyNamed=true,defaultValue=""String_Node_Str"",doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=Integer.class,legacyNamed=true,noneable=true,defaultValue=""String_Node_Str"",doc=""String_Node_Str"")}) public Boolean endsWith(String self,String sub,Integer start,Object end) throws ConversionException {
  return pythonSubstring(self,start,end,""String_Node_Str"").endsWith(sub);
}","@SkylarkCallable(name=""String_Node_Str"",doc=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",parameters={@Param(name=""String_Node_Str"",type=String.class,doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=String.class,legacyNamed=true,doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=Integer.class,legacyNamed=true,defaultValue=""String_Node_Str"",doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=Integer.class,legacyNamed=true,noneable=true,defaultValue=""String_Node_Str"",doc=""String_Node_Str"")}) public Boolean endsWith(String self,String sub,Integer start,Object end) throws ConversionException {
  return pythonSubstring(self,start,end,""String_Node_Str"").endsWith(sub);
}",0.986722571628232
110546,"@SkylarkCallable(name=""String_Node_Str"",doc=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",parameters={@Param(name=""String_Node_Str"",type=String.class,doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=String.class,legacyNamed=true,doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=Integer.class,legacyNamed=true,defaultValue=""String_Node_Str"",doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=Integer.class,legacyNamed=true,noneable=true,defaultValue=""String_Node_Str"",doc=""String_Node_Str"")}) public Boolean startsWith(String self,String sub,Integer start,Object end) throws ConversionException {
  return pythonSubstring(self,start,end,""String_Node_Str"").startsWith(sub);
}","@SkylarkCallable(name=""String_Node_Str"",doc=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",parameters={@Param(name=""String_Node_Str"",type=String.class,doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=String.class,legacyNamed=true,doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=Integer.class,legacyNamed=true,defaultValue=""String_Node_Str"",doc=""String_Node_Str""),@Param(name=""String_Node_Str"",type=Integer.class,legacyNamed=true,noneable=true,defaultValue=""String_Node_Str"",doc=""String_Node_Str"")}) public Boolean startsWith(String self,String sub,Integer start,Object end) throws ConversionException {
  return pythonSubstring(self,start,end,""String_Node_Str"").startsWith(sub);
}",0.98679638637943
110547,"/** 
 * Skylark API for shrinking a resource APK <p>TODO(b/79159379): Stop passing SkylarkRuleContext here
 * @param ctx the SkylarkRuleContext. We will soon change to using an ActionConstructionContextinstead. See b/79159379
 */
@SkylarkCallable(name=""String_Node_Str"",mandatoryPositionals=4,parameters={@Param(name=""String_Node_Str"",type=BinaryDataSettings.class,noneable=true,defaultValue=""String_Node_Str"",positional=false,named=true,doc=""String_Node_Str"" + ""String_Node_Str""),@Param(name=""String_Node_Str"",positional=false,defaultValue=""String_Node_Str"",type=SkylarkList.class,generic1=ConfiguredTarget.class,named=true,doc=""String_Node_Str"" + ""String_Node_Str""),@Param(name=""String_Node_Str"",type=SkylarkList.class,generic1=ConfiguredTarget.class,defaultValue=""String_Node_Str"",positional=false,named=true,doc=""String_Node_Str"" + ""String_Node_Str""),@Param(name=""String_Node_Str"",type=SkylarkList.class,generic1=ConfiguredTarget.class,defaultValue=""String_Node_Str"",positional=false,named=true,doc=""String_Node_Str"" + ""String_Node_Str"")},doc=""String_Node_Str"" + ""String_Node_Str"") public AndroidBinaryDataInfo shrinkDataApk(SkylarkRuleContext ctx,AndroidBinaryDataInfo binaryDataInfo,Artifact proguardOutputJar,Artifact proguardMapping,Object maybeSettings,SkylarkList<ConfiguredTarget> deps,SkylarkList<ConfiguredTarget> localProguardSpecs,SkylarkList<ConfiguredTarget> extraProguardSpecs) throws EvalException, InterruptedException {
  BinaryDataSettings settings=fromNoneableOrDefault(maybeSettings,BinaryDataSettings.class,defaultBinaryDataSettings(ctx));
  if (!settings.shrinkResources) {
    return binaryDataInfo;
  }
  ImmutableList<Artifact> proguardSpecs=AndroidBinary.getProguardSpecs(ctx.getRuleContext(),getAndroidSemantics(),binaryDataInfo.getResourceProguardConfig(),binaryDataInfo.getManifestInfo().getManifest(),filesFromConfiguredTargets(localProguardSpecs),filesFromConfiguredTargets(extraProguardSpecs),getProviders(deps,ProguardSpecProvider.class));
  if (!binaryDataInfo.getResourcesInfo().getDirectAndroidResources().isSingleton()) {
    throw new EvalException(Location.BUILTIN,""String_Node_Str"");
  }
  Optional<Artifact> maybeShrunkApk=AndroidBinary.maybeShrinkResources(ctx.getRuleContext(),binaryDataInfo.getResourcesInfo().getDirectAndroidResources().toList().get(0),ResourceDependencies.fromProviders(getProviders(deps,AndroidResourcesInfo.PROVIDER),false),proguardSpecs,proguardOutputJar,proguardMapping,settings.aaptVersion,settings.resourceFilterFactory,settings.noCompressExtensions);
  return maybeShrunkApk.map(binaryDataInfo::withShrunkApk).orElse(binaryDataInfo);
}","/** 
 * Skylark API for shrinking a resource APK <p>TODO(b/79159379): Stop passing SkylarkRuleContext here
 * @param ctx the SkylarkRuleContext. We will soon change to using an ActionConstructionContextinstead. See b/79159379
 */
@SkylarkCallable(name=""String_Node_Str"",mandatoryPositionals=4,parameters={@Param(name=""String_Node_Str"",type=BinaryDataSettings.class,noneable=true,defaultValue=""String_Node_Str"",positional=false,named=true,doc=""String_Node_Str"" + ""String_Node_Str""),@Param(name=""String_Node_Str"",positional=false,defaultValue=""String_Node_Str"",type=SkylarkList.class,generic1=ConfiguredTarget.class,named=true,doc=""String_Node_Str"" + ""String_Node_Str""),@Param(name=""String_Node_Str"",type=SkylarkList.class,generic1=ConfiguredTarget.class,defaultValue=""String_Node_Str"",positional=false,named=true,doc=""String_Node_Str"" + ""String_Node_Str""),@Param(name=""String_Node_Str"",type=SkylarkList.class,generic1=ConfiguredTarget.class,defaultValue=""String_Node_Str"",positional=false,named=true,doc=""String_Node_Str"" + ""String_Node_Str"")},doc=""String_Node_Str"" + ""String_Node_Str"") public AndroidBinaryDataInfo shrinkDataApk(SkylarkRuleContext ctx,AndroidBinaryDataInfo binaryDataInfo,Artifact proguardOutputJar,Artifact proguardMapping,Object maybeSettings,SkylarkList<ConfiguredTarget> deps,SkylarkList<ConfiguredTarget> localProguardSpecs,SkylarkList<ConfiguredTarget> extraProguardSpecs) throws EvalException, InterruptedException {
  BinaryDataSettings settings=fromNoneableOrDefault(maybeSettings,BinaryDataSettings.class,defaultBinaryDataSettings(ctx));
  if (!settings.shrinkResources) {
    return binaryDataInfo;
  }
  ImmutableList<Artifact> proguardSpecs=AndroidBinary.getProguardSpecs(ctx.getRuleContext(),getAndroidSemantics(),binaryDataInfo.getResourceProguardConfig(),binaryDataInfo.getManifestInfo().getManifest(),filesFromConfiguredTargets(localProguardSpecs),filesFromConfiguredTargets(extraProguardSpecs),getProviders(deps,ProguardSpecProvider.class));
  if (!binaryDataInfo.getResourcesInfo().getDirectAndroidResources().isSingleton()) {
    throw new EvalException(Location.BUILTIN,""String_Node_Str"" + binaryDataInfo.getResourcesInfo().getDirectAndroidResources());
  }
  Optional<Artifact> maybeShrunkApk=AndroidBinary.maybeShrinkResources(ctx.getRuleContext(),binaryDataInfo.getResourcesInfo().getDirectAndroidResources().toList().get(0),ResourceDependencies.fromProviders(getProviders(deps,AndroidResourcesInfo.PROVIDER),false),proguardSpecs,proguardOutputJar,proguardMapping,settings.aaptVersion,settings.resourceFilterFactory,settings.noCompressExtensions);
  return maybeShrunkApk.map(binaryDataInfo::withShrunkApk).orElse(binaryDataInfo);
}",0.9878833775085196
110548,"@Override public ConfiguredTarget create(RuleContext ruleContext) throws InterruptedException, RuleErrorException, ActionConflictException {
  androidMigrationSemantics.validateRuleContext(ruleContext);
  AndroidSdkProvider.verifyPresence(ruleContext);
  RuleConfiguredTargetBuilder ruleBuilder=new RuleConfiguredTargetBuilder(ruleContext);
  Artifact aar=ruleContext.getPrerequisiteArtifact(""String_Node_Str"",Mode.TARGET);
  Artifact allAarJars=createAarTreeArtifact(ruleContext,""String_Node_Str"");
  Artifact jarMergingParams=createAarArtifact(ruleContext,""String_Node_Str"");
  ruleContext.registerAction(createAarEmbeddedJarsExtractorActions(ruleContext,aar,allAarJars,jarMergingParams));
  Artifact mergedJar=createAarArtifact(ruleContext,MERGED_JAR);
  ruleContext.registerAction(createAarJarsMergingActions(ruleContext,allAarJars,mergedJar,jarMergingParams));
  Artifact androidManifestArtifact=createAarArtifact(ruleContext,ANDROID_MANIFEST);
  SpecialArtifact resources=createAarTreeArtifact(ruleContext,""String_Node_Str"");
  SpecialArtifact assets=createAarTreeArtifact(ruleContext,""String_Node_Str"");
  ruleContext.registerAction(createAarResourcesExtractorActions(ruleContext,aar,resources,assets));
  final ResourceApk resourceApk;
  if (AndroidResources.decoupleDataProcessing(ruleContext)) {
    StampedAndroidManifest manifest=AndroidManifest.forAarImport(ruleContext,androidManifestArtifact);
    boolean neverlink=JavaCommon.isNeverLink(ruleContext);
    ValidatedAndroidResources validatedResources=AndroidResources.forAarImport(resources).process(ruleContext,manifest,neverlink);
    MergedAndroidAssets mergedAssets=AndroidAssets.forAarImport(assets).process(ruleContext,neverlink);
    resourceApk=ResourceApk.of(validatedResources,mergedAssets);
  }
 else {
    ApplicationManifest androidManifest=ApplicationManifest.fromExplicitManifest(ruleContext,androidManifestArtifact);
    Artifact resourcesZip=ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_ZIP);
    resourceApk=androidManifest.packAarWithDataAndResources(ruleContext,AndroidAssets.forAarImport(assets),AndroidResources.forAarImport(resources),ResourceDependencies.fromRuleDeps(ruleContext,JavaCommon.isNeverLink(ruleContext)),ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_R_TXT),ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_LOCAL_SYMBOLS),ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_PROCESSED_MANIFEST),resourcesZip);
  }
  NestedSet<Artifact> filesToBuild=NestedSetBuilder.<Artifact>stableOrder().add(resourceApk.getValidatedResources().getMergedResources()).add(mergedJar).build();
  Artifact nativeLibs=createAarArtifact(ruleContext,""String_Node_Str"");
  ruleContext.registerAction(createAarNativeLibsFilterActions(ruleContext,aar,nativeLibs));
  JavaRuleOutputJarsProvider.Builder jarProviderBuilder=new JavaRuleOutputJarsProvider.Builder().addOutputJar(mergedJar,null,ImmutableList.of());
  ImmutableList<TransitiveInfoCollection> targets=ImmutableList.<TransitiveInfoCollection>builder().addAll(ruleContext.getPrerequisites(""String_Node_Str"",Mode.TARGET)).addAll(ruleContext.getPrerequisites(""String_Node_Str"",Mode.TARGET)).build();
  JavaCommon common=new JavaCommon(ruleContext,javaSemantics,ImmutableList.of(),targets,targets,targets);
  javaSemantics.checkRule(ruleContext,common);
  common.setJavaCompilationArtifacts(new JavaCompilationArtifacts.Builder().addRuntimeJar(mergedJar).addCompileTimeJarAsFullJar(mergedJar).build());
  JavaCompilationArgsProvider javaCompilationArgsProvider=JavaCompilationArgsProvider.create(common.collectJavaCompilationArgs(false,JavaCommon.isNeverLink(ruleContext),false),common.collectJavaCompilationArgs(true,JavaCommon.isNeverLink(ruleContext),false));
  Artifact depsCheckerResult=null;
  JavaConfiguration javaConfig=ruleContext.getFragment(JavaConfiguration.class);
  if (javaConfig.getImportDepsCheckingLevel() != ImportDepsCheckingLevel.OFF) {
    NestedSet<Artifact> deps=getCompileTimeJarsFromCollection(targets,javaConfig.getImportDepsCheckingLevel() == ImportDepsCheckingLevel.STRICT_ERROR);
    NestedSet<Artifact> bootclasspath=getBootclasspath(ruleContext);
    depsCheckerResult=createAarArtifact(ruleContext,""String_Node_Str"");
    ImportDepsCheckActionBuilder.newBuilder().bootcalsspath(bootclasspath).declareDeps(deps).checkJars(NestedSetBuilder.<Artifact>stableOrder().add(mergedJar).build()).outputArtifiact(depsCheckerResult).importDepsCheckingLevel(javaConfig.getImportDepsCheckingLevel()).buildAndRegister(ruleContext);
  }
  ruleContext.registerAction(createSingleFileExtractorActions(ruleContext,aar,ANDROID_MANIFEST,depsCheckerResult,androidManifestArtifact));
  JavaInfo.Builder javaInfoBuilder=JavaInfo.Builder.create().setRuntimeJars(ImmutableList.of(mergedJar)).setJavaConstraints(ImmutableList.of(""String_Node_Str"")).setNeverlink(JavaCommon.isNeverLink(ruleContext)).addProvider(JavaCompilationArgsProvider.class,javaCompilationArgsProvider).addProvider(JavaRuleOutputJarsProvider.class,jarProviderBuilder.build());
  common.addTransitiveInfoProviders(ruleBuilder,javaInfoBuilder,filesToBuild,null);
  resourceApk.addToConfiguredTargetBuilder(ruleBuilder,ruleContext.getLabel(),false);
  ruleBuilder.setFilesToBuild(filesToBuild).addSkylarkTransitiveInfo(JavaSkylarkApiProvider.NAME,JavaSkylarkApiProvider.fromRuleContext()).addProvider(RunfilesProvider.class,RunfilesProvider.EMPTY).addNativeDeclaredProvider(new AndroidNativeLibsInfo(AndroidCommon.collectTransitiveNativeLibs(ruleContext).add(nativeLibs).build())).addNativeDeclaredProvider(javaInfoBuilder.build());
  if (depsCheckerResult != null) {
    ruleBuilder.addOutputGroup(OutputGroupInfo.HIDDEN_TOP_LEVEL,depsCheckerResult);
  }
  return ruleBuilder.build();
}","@Override public ConfiguredTarget create(RuleContext ruleContext) throws InterruptedException, RuleErrorException, ActionConflictException {
  androidMigrationSemantics.validateRuleContext(ruleContext);
  AndroidSdkProvider.verifyPresence(ruleContext);
  RuleConfiguredTargetBuilder ruleBuilder=new RuleConfiguredTargetBuilder(ruleContext);
  Artifact aar=ruleContext.getPrerequisiteArtifact(""String_Node_Str"",Mode.TARGET);
  Artifact allAarJars=createAarTreeArtifact(ruleContext,""String_Node_Str"");
  Artifact jarMergingParams=createAarArtifact(ruleContext,""String_Node_Str"");
  ruleContext.registerAction(createAarEmbeddedJarsExtractorActions(ruleContext,aar,allAarJars,jarMergingParams));
  Artifact mergedJar=createAarArtifact(ruleContext,MERGED_JAR);
  ruleContext.registerAction(createAarJarsMergingActions(ruleContext,allAarJars,mergedJar,jarMergingParams));
  Artifact androidManifestArtifact=createAarArtifact(ruleContext,ANDROID_MANIFEST);
  SpecialArtifact resources=createAarTreeArtifact(ruleContext,""String_Node_Str"");
  SpecialArtifact assets=createAarTreeArtifact(ruleContext,""String_Node_Str"");
  ruleContext.registerAction(createAarResourcesExtractorActions(ruleContext,aar,resources,assets));
  final ResourceApk resourceApk;
  if (AndroidResources.decoupleDataProcessing(ruleContext)) {
    StampedAndroidManifest manifest=AndroidManifest.forAarImport(ruleContext,androidManifestArtifact);
    boolean neverlink=JavaCommon.isNeverLink(ruleContext);
    ValidatedAndroidResources validatedResources=AndroidResources.forAarImport(resources).process(ruleContext,manifest,neverlink);
    MergedAndroidAssets mergedAssets=AndroidAssets.forAarImport(assets).process(ruleContext,neverlink);
    resourceApk=ResourceApk.of(validatedResources,mergedAssets,null,null);
  }
 else {
    ApplicationManifest androidManifest=ApplicationManifest.fromExplicitManifest(ruleContext,androidManifestArtifact);
    Artifact resourcesZip=ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_ZIP);
    resourceApk=androidManifest.packAarWithDataAndResources(ruleContext,AndroidAssets.forAarImport(assets),AndroidResources.forAarImport(resources),ResourceDependencies.fromRuleDeps(ruleContext,JavaCommon.isNeverLink(ruleContext)),ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_R_TXT),ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_LOCAL_SYMBOLS),ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_PROCESSED_MANIFEST),resourcesZip);
  }
  NestedSet<Artifact> filesToBuild=NestedSetBuilder.<Artifact>stableOrder().add(resourceApk.getValidatedResources().getMergedResources()).add(mergedJar).build();
  Artifact nativeLibs=createAarArtifact(ruleContext,""String_Node_Str"");
  ruleContext.registerAction(createAarNativeLibsFilterActions(ruleContext,aar,nativeLibs));
  JavaRuleOutputJarsProvider.Builder jarProviderBuilder=new JavaRuleOutputJarsProvider.Builder().addOutputJar(mergedJar,null,ImmutableList.of());
  ImmutableList<TransitiveInfoCollection> targets=ImmutableList.<TransitiveInfoCollection>builder().addAll(ruleContext.getPrerequisites(""String_Node_Str"",Mode.TARGET)).addAll(ruleContext.getPrerequisites(""String_Node_Str"",Mode.TARGET)).build();
  JavaCommon common=new JavaCommon(ruleContext,javaSemantics,ImmutableList.of(),targets,targets,targets);
  javaSemantics.checkRule(ruleContext,common);
  common.setJavaCompilationArtifacts(new JavaCompilationArtifacts.Builder().addRuntimeJar(mergedJar).addCompileTimeJarAsFullJar(mergedJar).build());
  JavaCompilationArgsProvider javaCompilationArgsProvider=JavaCompilationArgsProvider.create(common.collectJavaCompilationArgs(false,JavaCommon.isNeverLink(ruleContext),false),common.collectJavaCompilationArgs(true,JavaCommon.isNeverLink(ruleContext),false));
  Artifact depsCheckerResult=null;
  JavaConfiguration javaConfig=ruleContext.getFragment(JavaConfiguration.class);
  if (javaConfig.getImportDepsCheckingLevel() != ImportDepsCheckingLevel.OFF) {
    NestedSet<Artifact> deps=getCompileTimeJarsFromCollection(targets,javaConfig.getImportDepsCheckingLevel() == ImportDepsCheckingLevel.STRICT_ERROR);
    NestedSet<Artifact> bootclasspath=getBootclasspath(ruleContext);
    depsCheckerResult=createAarArtifact(ruleContext,""String_Node_Str"");
    ImportDepsCheckActionBuilder.newBuilder().bootcalsspath(bootclasspath).declareDeps(deps).checkJars(NestedSetBuilder.<Artifact>stableOrder().add(mergedJar).build()).outputArtifiact(depsCheckerResult).importDepsCheckingLevel(javaConfig.getImportDepsCheckingLevel()).buildAndRegister(ruleContext);
  }
  ruleContext.registerAction(createSingleFileExtractorActions(ruleContext,aar,ANDROID_MANIFEST,depsCheckerResult,androidManifestArtifact));
  JavaInfo.Builder javaInfoBuilder=JavaInfo.Builder.create().setRuntimeJars(ImmutableList.of(mergedJar)).setJavaConstraints(ImmutableList.of(""String_Node_Str"")).setNeverlink(JavaCommon.isNeverLink(ruleContext)).addProvider(JavaCompilationArgsProvider.class,javaCompilationArgsProvider).addProvider(JavaRuleOutputJarsProvider.class,jarProviderBuilder.build());
  common.addTransitiveInfoProviders(ruleBuilder,javaInfoBuilder,filesToBuild,null);
  resourceApk.addToConfiguredTargetBuilder(ruleBuilder,ruleContext.getLabel(),false);
  ruleBuilder.setFilesToBuild(filesToBuild).addSkylarkTransitiveInfo(JavaSkylarkApiProvider.NAME,JavaSkylarkApiProvider.fromRuleContext()).addProvider(RunfilesProvider.class,RunfilesProvider.EMPTY).addNativeDeclaredProvider(new AndroidNativeLibsInfo(AndroidCommon.collectTransitiveNativeLibs(ruleContext).add(nativeLibs).build())).addNativeDeclaredProvider(javaInfoBuilder.build());
  if (depsCheckerResult != null) {
    ruleBuilder.addOutputGroup(OutputGroupInfo.HIDDEN_TOP_LEVEL,depsCheckerResult);
  }
  return ruleBuilder.build();
}",0.9991343490304708
110549,"static AndroidAssets empty(){
  return new AndroidAssets(ImmutableList.of(),ImmutableList.of());
}","public static AndroidAssets empty(){
  return new AndroidAssets(ImmutableList.of(),ImmutableList.of());
}",0.9655172413793104
110550,"@Override public ConfiguredTarget create(RuleContext ruleContext) throws InterruptedException, RuleErrorException, ActionConflictException {
  validateRuleContext(ruleContext);
  JavaSemantics javaSemantics=createJavaSemantics();
  AndroidSemantics androidSemantics=createAndroidSemantics();
  androidSemantics.validateAndroidLibraryRuleContext(ruleContext);
  createAndroidMigrationSemantics().validateRuleContext(ruleContext);
  AndroidSdkProvider.verifyPresence(ruleContext);
  NestedSetBuilder<Aar> transitiveAars=NestedSetBuilder.naiveLinkOrder();
  NestedSetBuilder<Artifact> transitiveAarArtifacts=NestedSetBuilder.stableOrder();
  collectTransitiveAars(ruleContext,transitiveAars,transitiveAarArtifacts);
  NestedSetBuilder<Artifact> proguardConfigsbuilder=NestedSetBuilder.stableOrder();
  ProguardLibrary proguardLibrary=new ProguardLibrary(ruleContext);
  proguardConfigsbuilder.addTransitive(proguardLibrary.collectProguardSpecs());
  AndroidIdlHelper.maybeAddSupportLibProguardConfigs(ruleContext,proguardConfigsbuilder);
  NestedSet<Artifact> transitiveProguardConfigs=proguardConfigsbuilder.build();
  JavaCommon javaCommon=AndroidCommon.createJavaCommonWithAndroidDataBinding(ruleContext,javaSemantics,true);
  javaSemantics.checkRule(ruleContext,javaCommon);
  AndroidCommon androidCommon=new AndroidCommon(javaCommon);
  AndroidConfiguration androidConfig=AndroidCommon.getAndroidConfig(ruleContext);
  boolean definesLocalResources=AndroidResources.definesAndroidResources(ruleContext.attributes());
  if (definesLocalResources) {
    AndroidResources.validateRuleContext(ruleContext);
  }
  boolean isNeverLink=JavaCommon.isNeverLink(ruleContext) && (definesLocalResources || androidConfig.fixedResourceNeverlinking());
  ResourceDependencies resourceDeps=ResourceDependencies.fromRuleDeps(ruleContext,isNeverLink);
  AssetDependencies assetDeps=AssetDependencies.fromRuleDeps(ruleContext,isNeverLink);
  final ResourceApk resourceApk;
  if (definesLocalResources) {
    if (androidConfig.decoupleDataProcessing()) {
      StampedAndroidManifest manifest=AndroidManifest.from(ruleContext,androidSemantics).stamp(ruleContext);
      ValidatedAndroidResources resources=AndroidResources.from(ruleContext,""String_Node_Str"").process(ruleContext,manifest,isNeverLink);
      MergedAndroidAssets assets=AndroidAssets.from(ruleContext).process(ruleContext,isNeverLink);
      resourceApk=ResourceApk.of(resources,assets);
    }
 else {
      ApplicationManifest applicationManifest=androidSemantics.getManifestForRule(ruleContext).renamePackage(ruleContext,AndroidCommon.getJavaPackage(ruleContext));
      resourceApk=applicationManifest.packLibraryWithDataAndResources(ruleContext,resourceDeps,ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_R_TXT),ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_MERGED_SYMBOLS),ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_PROCESSED_MANIFEST),ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_ZIP),DataBinding.isEnabled(ruleContext) ? DataBinding.getLayoutInfoFile(ruleContext) : null);
    }
    if (ruleContext.hasErrors()) {
      return null;
    }
  }
 else {
    resourceApk=ResourceApk.processFromTransitiveLibraryData(ruleContext,resourceDeps,assetDeps,StampedAndroidManifest.createEmpty(ruleContext,false));
  }
  JavaTargetAttributes javaTargetAttributes=androidCommon.init(javaSemantics,androidSemantics,resourceApk,false,true,false,null,false);
  if (javaTargetAttributes == null) {
    return null;
  }
  Artifact classesJar=ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_LIBRARY_CLASS_JAR);
  Artifact aarOut=ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_LIBRARY_AAR);
  final Aar aar;
  if (definesLocalResources) {
    aar=Aar.create(aarOut,resourceApk.getManifest());
    addAarToProvider(aar,transitiveAars,transitiveAarArtifacts);
  }
 else {
    aar=null;
  }
  new AarGeneratorBuilder(ruleContext).withPrimaryResources(resourceApk.getPrimaryResources()).withPrimaryAssets(resourceApk.getPrimaryAssets()).withManifest(resourceApk.getManifest()).withRtxt(resourceApk.getRTxt()).withClasses(classesJar).setAAROut(aarOut).setProguardSpecs(proguardLibrary.collectLocalProguardSpecs()).setThrowOnResourceConflict(androidConfig.throwOnResourceConflict()).build(ruleContext);
  RuleConfiguredTargetBuilder builder=new RuleConfiguredTargetBuilder(ruleContext);
  androidCommon.addTransitiveInfoProviders(builder,aarOut,resourceApk,null,ImmutableList.<Artifact>of(),NativeLibs.EMPTY,androidCommon.isNeverLink());
  NestedSetBuilder<Artifact> transitiveResourcesJars=collectTransitiveResourceJars(ruleContext);
  if (resourceApk.getResourceJavaClassJar() != null) {
    transitiveResourcesJars.add(resourceApk.getResourceJavaClassJar());
  }
  builder.addNativeDeclaredProvider(new AndroidNativeLibsInfo(AndroidCommon.collectTransitiveNativeLibs(ruleContext).build())).add(JavaSourceInfoProvider.class,JavaSourceInfoProvider.fromJavaTargetAttributes(javaTargetAttributes,javaSemantics)).add(AndroidCcLinkParamsProvider.class,AndroidCcLinkParamsProvider.create(androidCommon.getCcLinkParamsStore())).add(ProguardSpecProvider.class,new ProguardSpecProvider(transitiveProguardConfigs)).addOutputGroup(OutputGroupInfo.HIDDEN_TOP_LEVEL,transitiveProguardConfigs).add(AndroidLibraryResourceClassJarProvider.class,AndroidLibraryResourceClassJarProvider.create(transitiveResourcesJars.build()));
  if (!JavaCommon.isNeverLink(ruleContext)) {
    builder.add(AndroidLibraryAarProvider.class,AndroidLibraryAarProvider.create(aar,transitiveAars.build(),transitiveAarArtifacts.build()));
  }
  return builder.build();
}","@Override public ConfiguredTarget create(RuleContext ruleContext) throws InterruptedException, RuleErrorException, ActionConflictException {
  validateRuleContext(ruleContext);
  JavaSemantics javaSemantics=createJavaSemantics();
  AndroidSemantics androidSemantics=createAndroidSemantics();
  androidSemantics.validateAndroidLibraryRuleContext(ruleContext);
  createAndroidMigrationSemantics().validateRuleContext(ruleContext);
  AndroidSdkProvider.verifyPresence(ruleContext);
  NestedSetBuilder<Aar> transitiveAars=NestedSetBuilder.naiveLinkOrder();
  NestedSetBuilder<Artifact> transitiveAarArtifacts=NestedSetBuilder.stableOrder();
  collectTransitiveAars(ruleContext,transitiveAars,transitiveAarArtifacts);
  NestedSetBuilder<Artifact> proguardConfigsbuilder=NestedSetBuilder.stableOrder();
  ProguardLibrary proguardLibrary=new ProguardLibrary(ruleContext);
  proguardConfigsbuilder.addTransitive(proguardLibrary.collectProguardSpecs());
  AndroidIdlHelper.maybeAddSupportLibProguardConfigs(ruleContext,proguardConfigsbuilder);
  NestedSet<Artifact> transitiveProguardConfigs=proguardConfigsbuilder.build();
  JavaCommon javaCommon=AndroidCommon.createJavaCommonWithAndroidDataBinding(ruleContext,javaSemantics,true);
  javaSemantics.checkRule(ruleContext,javaCommon);
  AndroidCommon androidCommon=new AndroidCommon(javaCommon);
  AndroidConfiguration androidConfig=AndroidCommon.getAndroidConfig(ruleContext);
  boolean definesLocalResources=AndroidResources.definesAndroidResources(ruleContext.attributes());
  if (definesLocalResources) {
    AndroidResources.validateRuleContext(ruleContext);
  }
  boolean isNeverLink=JavaCommon.isNeverLink(ruleContext) && (definesLocalResources || androidConfig.fixedResourceNeverlinking());
  ResourceDependencies resourceDeps=ResourceDependencies.fromRuleDeps(ruleContext,isNeverLink);
  AssetDependencies assetDeps=AssetDependencies.fromRuleDeps(ruleContext,isNeverLink);
  final ResourceApk resourceApk;
  if (definesLocalResources) {
    if (androidConfig.decoupleDataProcessing()) {
      StampedAndroidManifest manifest=AndroidManifest.from(ruleContext,androidSemantics).stamp(ruleContext);
      ValidatedAndroidResources resources=AndroidResources.from(ruleContext,""String_Node_Str"").process(ruleContext,manifest,isNeverLink);
      MergedAndroidAssets assets=AndroidAssets.from(ruleContext).process(ruleContext,isNeverLink);
      resourceApk=ResourceApk.of(resources,assets,null,null);
    }
 else {
      ApplicationManifest applicationManifest=androidSemantics.getManifestForRule(ruleContext).renamePackage(ruleContext,AndroidCommon.getJavaPackage(ruleContext));
      resourceApk=applicationManifest.packLibraryWithDataAndResources(ruleContext,resourceDeps,ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_R_TXT),ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_MERGED_SYMBOLS),ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_PROCESSED_MANIFEST),ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_ZIP),DataBinding.isEnabled(ruleContext) ? DataBinding.getLayoutInfoFile(ruleContext) : null);
    }
    if (ruleContext.hasErrors()) {
      return null;
    }
  }
 else {
    resourceApk=ResourceApk.processFromTransitiveLibraryData(ruleContext,resourceDeps,assetDeps,StampedAndroidManifest.createEmpty(ruleContext,false));
  }
  JavaTargetAttributes javaTargetAttributes=androidCommon.init(javaSemantics,androidSemantics,resourceApk,false,true,false,null,false);
  if (javaTargetAttributes == null) {
    return null;
  }
  Artifact classesJar=ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_LIBRARY_CLASS_JAR);
  Artifact aarOut=ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_LIBRARY_AAR);
  final Aar aar;
  if (definesLocalResources) {
    aar=Aar.create(aarOut,resourceApk.getManifest());
    addAarToProvider(aar,transitiveAars,transitiveAarArtifacts);
  }
 else {
    aar=null;
  }
  new AarGeneratorBuilder(ruleContext).withPrimaryResources(resourceApk.getPrimaryResources()).withPrimaryAssets(resourceApk.getPrimaryAssets()).withManifest(resourceApk.getManifest()).withRtxt(resourceApk.getRTxt()).withClasses(classesJar).setAAROut(aarOut).setProguardSpecs(proguardLibrary.collectLocalProguardSpecs()).setThrowOnResourceConflict(androidConfig.throwOnResourceConflict()).build(ruleContext);
  RuleConfiguredTargetBuilder builder=new RuleConfiguredTargetBuilder(ruleContext);
  androidCommon.addTransitiveInfoProviders(builder,aarOut,resourceApk,null,ImmutableList.<Artifact>of(),NativeLibs.EMPTY,androidCommon.isNeverLink());
  NestedSetBuilder<Artifact> transitiveResourcesJars=collectTransitiveResourceJars(ruleContext);
  if (resourceApk.getResourceJavaClassJar() != null) {
    transitiveResourcesJars.add(resourceApk.getResourceJavaClassJar());
  }
  builder.addNativeDeclaredProvider(new AndroidNativeLibsInfo(AndroidCommon.collectTransitiveNativeLibs(ruleContext).build())).add(JavaSourceInfoProvider.class,JavaSourceInfoProvider.fromJavaTargetAttributes(javaTargetAttributes,javaSemantics)).add(AndroidCcLinkParamsProvider.class,AndroidCcLinkParamsProvider.create(androidCommon.getCcLinkParamsStore())).add(ProguardSpecProvider.class,new ProguardSpecProvider(transitiveProguardConfigs)).addOutputGroup(OutputGroupInfo.HIDDEN_TOP_LEVEL,transitiveProguardConfigs).add(AndroidLibraryResourceClassJarProvider.class,AndroidLibraryResourceClassJarProvider.create(transitiveResourcesJars.build()));
  if (!JavaCommon.isNeverLink(ruleContext)) {
    builder.add(AndroidLibraryAarProvider.class,AndroidLibraryAarProvider.create(aar,transitiveAars.build(),transitiveAarArtifacts.build()));
  }
  return builder.build();
}",0.9991209563994374
110551,"@Override public ConfiguredTarget create(RuleContext ruleContext) throws InterruptedException, RuleErrorException, ActionConflictException {
  ruleContext.checkSrcsSamePackage(true);
  JavaSemantics javaSemantics=createJavaSemantics();
  AndroidSemantics androidSemantics=createAndroidSemantics();
  createAndroidMigrationSemantics().validateRuleContext(ruleContext);
  AndroidLocalTestConfiguration androidLocalTestConfiguration=ruleContext.getFragment(AndroidLocalTestConfiguration.class);
  final JavaCommon javaCommon=new JavaCommon(ruleContext,javaSemantics);
  JavaTargetAttributes.Builder attributesBuilder=javaCommon.initCommon();
  final ResourceApk resourceApk;
  if (AndroidResources.decoupleDataProcessing(ruleContext)) {
    StampedAndroidManifest manifest=StampedAndroidManifest.from(ruleContext,androidSemantics).mergeWithDeps(ruleContext);
    resourceApk=ProcessedAndroidData.processLocalTestDataFrom(ruleContext,manifest).generateRClass(ruleContext);
  }
 else {
    ResourceDependencies resourceDependencies=ResourceDependencies.fromRuleDeps(ruleContext,false);
    ApplicationManifest applicationManifest=getApplicationManifest(ruleContext,androidSemantics,resourceDependencies);
    resourceApk=applicationManifest.packBinaryWithDataAndResources(ruleContext,ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_APK),resourceDependencies,ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_R_TXT),ResourceFilterFactory.fromRuleContext(ruleContext),ImmutableList.of(),false,ProguardHelper.getProguardConfigArtifact(ruleContext,""String_Node_Str""),null,false,ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_PROCESSED_MANIFEST),ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_ZIP),DataBinding.isEnabled(ruleContext) ? DataBinding.getLayoutInfoFile(ruleContext) : null,null,null);
    attributesBuilder.addRuntimeClassPathEntry(resourceApk.getResourceJavaClassJar());
  }
  NestedSet<Artifact> excludedRuntimeArtifacts=getLibraryResourceJars(ruleContext);
  attributesBuilder.addExcludedArtifacts(excludedRuntimeArtifacts);
  String name=""String_Node_Str"" + ruleContext.getRule().getName() + ""String_Node_Str"";
  Artifact propertiesFile=ruleContext.getGenfilesArtifact(name);
  String resourcesLocation=resourceApk.getValidatedResources().getMergedResources().getRunfilesPathString();
  Template template=Template.forResource(AndroidLocalTestBase.class,""String_Node_Str"");
  List<Substitution> substitutions=new ArrayList<>();
  substitutions.add(Substitution.of(""String_Node_Str"",resourceApk.getManifest().getRunfilesPathString()));
  substitutions.add(Substitution.of(""String_Node_Str"",""String_Node_Str"" + resourcesLocation + ""String_Node_Str""));
  substitutions.add(Substitution.of(""String_Node_Str"",""String_Node_Str"" + resourcesLocation + ""String_Node_Str""));
  substitutions.add(Substitution.of(""String_Node_Str"",resourceApk.getValidatedResources().getJavaPackage()));
  boolean generateBinaryResources=androidLocalTestConfiguration.useAndroidLocalTestBinaryResources();
  if (generateBinaryResources) {
    substitutions.add(Substitution.of(""String_Node_Str"",resourceApk.getArtifact().getRunfilesPathString()));
  }
  ruleContext.registerAction(new TemplateExpansionAction(ruleContext.getActionOwner(),propertiesFile,template,substitutions,false));
  attributesBuilder.addResource(PathFragment.create(""String_Node_Str""),propertiesFile);
  String testClass=getAndCheckTestClass(ruleContext,ImmutableList.copyOf(attributesBuilder.getSourceFiles()));
  getAndCheckTestSupport(ruleContext);
  javaSemantics.checkForProtoLibraryAndJavaProtoLibraryOnSameProto(ruleContext,javaCommon);
  if (ruleContext.hasErrors()) {
    return null;
  }
  Artifact srcJar=ruleContext.getImplicitOutputArtifact(JavaSemantics.JAVA_BINARY_SOURCE_JAR);
  JavaSourceJarsProvider.Builder javaSourceJarsProviderBuilder=JavaSourceJarsProvider.builder().addSourceJar(srcJar).addAllTransitiveSourceJars(javaCommon.collectTransitiveSourceJars(srcJar));
  Artifact classJar=ruleContext.getImplicitOutputArtifact(JavaSemantics.JAVA_BINARY_CLASS_JAR);
  JavaRuleOutputJarsProvider.Builder javaRuleOutputJarsProviderBuilder=JavaRuleOutputJarsProvider.builder().addOutputJar(classJar,classJar,srcJar == null ? ImmutableList.<Artifact>of() : ImmutableList.of(srcJar));
  JavaCompilationArtifacts.Builder javaArtifactsBuilder=new JavaCompilationArtifacts.Builder();
  JavaCompilationHelper helper=getJavaCompilationHelperWithDependencies(ruleContext,javaSemantics,javaCommon,attributesBuilder);
  Artifact instrumentationMetadata=helper.createInstrumentationMetadata(classJar,javaArtifactsBuilder);
  Artifact executable;
  if (OS.getCurrent() == OS.WINDOWS && ruleContext.getConfiguration().enableWindowsExeLauncher()) {
    executable=ruleContext.getImplicitOutputArtifact(ruleContext.getTarget().getName() + ""String_Node_Str"");
  }
 else {
    executable=ruleContext.createOutputArtifact();
  }
  NestedSetBuilder<Artifact> filesToBuildBuilder=NestedSetBuilder.<Artifact>stableOrder().add(classJar).add(executable);
  GeneratedExtensionRegistryProvider generatedExtensionRegistryProvider=javaSemantics.createGeneratedExtensionRegistry(ruleContext,javaCommon,filesToBuildBuilder,javaArtifactsBuilder,javaRuleOutputJarsProviderBuilder,javaSourceJarsProviderBuilder);
  String mainClass=getMainClass(ruleContext,javaSemantics,helper,executable,instrumentationMetadata,javaArtifactsBuilder,attributesBuilder);
  addJavaClassJarToArtifactsBuilder(javaArtifactsBuilder,helper.getAttributes(),classJar);
  Artifact manifestProtoOutput=helper.createManifestProtoOutput(classJar);
  Artifact genClassJar=null;
  Artifact genSourceJar=null;
  if (helper.usesAnnotationProcessing()) {
    genClassJar=helper.createGenJar(classJar);
    genSourceJar=helper.createGensrcJar(classJar);
    helper.createGenJarAction(classJar,manifestProtoOutput,genClassJar);
  }
  Artifact outputDepsProtoArtifact=helper.createOutputDepsProtoArtifact(classJar,javaArtifactsBuilder);
  javaRuleOutputJarsProviderBuilder.setJdeps(outputDepsProtoArtifact);
  helper.createCompileAction(classJar,manifestProtoOutput,genSourceJar,outputDepsProtoArtifact,instrumentationMetadata,null);
  helper.createSourceJarAction(srcJar,genSourceJar);
  setUpJavaCommon(javaCommon,helper,javaArtifactsBuilder.build());
  Artifact launcher=JavaHelper.launcherArtifactForTarget(javaSemantics,ruleContext);
  String javaExecutable;
  if (javaSemantics.isJavaExecutableSubstitution()) {
    javaExecutable=JavaCommon.getJavaBinSubstitution(ruleContext,launcher);
  }
 else {
    javaExecutable=JavaCommon.getJavaExecutableForStub(ruleContext,launcher);
  }
  javaSemantics.createStubAction(ruleContext,javaCommon,getJvmFlags(ruleContext,testClass),executable,mainClass,javaExecutable);
  Artifact oneVersionOutputArtifact=null;
  JavaConfiguration javaConfig=ruleContext.getFragment(JavaConfiguration.class);
  OneVersionEnforcementLevel oneVersionEnforcementLevel=javaConfig.oneVersionEnforcementLevel();
  boolean doOneVersionEnforcement=oneVersionEnforcementLevel != OneVersionEnforcementLevel.OFF && javaConfig.enforceOneVersionOnJavaTests();
  JavaToolchainProvider javaToolchain=JavaToolchainProvider.from(ruleContext);
  if (doOneVersionEnforcement) {
    oneVersionOutputArtifact=OneVersionCheckActionBuilder.newBuilder().withEnforcementLevel(oneVersionEnforcementLevel).outputArtifact(ruleContext.getImplicitOutputArtifact(JavaSemantics.JAVA_ONE_VERSION_ARTIFACT)).useToolchain(javaToolchain).checkJars(NestedSetBuilder.fromNestedSet(helper.getAttributes().getRuntimeClassPath()).add(classJar).build()).build(ruleContext);
  }
  NestedSet<Artifact> filesToBuild=filesToBuildBuilder.build();
  Runfiles defaultRunfiles=collectDefaultRunfiles(ruleContext,javaCommon,filesToBuild,resourceApk.getManifest(),resourceApk.getResourceJavaClassJar(),resourceApk.getValidatedResources().getMergedResources(),generateBinaryResources ? resourceApk : null);
  RunfilesSupport runfilesSupport=RunfilesSupport.withExecutable(ruleContext,defaultRunfiles,executable);
  Artifact deployJar=ruleContext.getImplicitOutputArtifact(JavaSemantics.JAVA_BINARY_DEPLOY_JAR);
  new DeployArchiveBuilder(javaSemantics,ruleContext).setOutputJar(deployJar).setJavaStartClass(mainClass).setDeployManifestLines(ImmutableList.<String>of()).setAttributes(helper.getAttributes()).addRuntimeJars(javaCommon.getJavaCompilationArtifacts().getRuntimeJars()).setIncludeBuildData(true).setRunfilesMiddleman(runfilesSupport.getRunfilesMiddleman()).setCompression(COMPRESSED).setLauncher(launcher).setOneVersionEnforcementLevel(doOneVersionEnforcement ? oneVersionEnforcementLevel : OneVersionEnforcementLevel.OFF,javaToolchain.getOneVersionWhitelist()).build();
  JavaSourceJarsProvider sourceJarsProvider=javaSourceJarsProviderBuilder.build();
  NestedSet<Artifact> transitiveSourceJars=sourceJarsProvider.getTransitiveSourceJars();
  RuleConfiguredTargetBuilder builder=new RuleConfiguredTargetBuilder(ruleContext);
  if (generatedExtensionRegistryProvider != null) {
    builder.addProvider(GeneratedExtensionRegistryProvider.class,generatedExtensionRegistryProvider);
  }
  JavaRuleOutputJarsProvider ruleOutputJarsProvider=javaRuleOutputJarsProviderBuilder.build();
  JavaInfo.Builder javaInfoBuilder=JavaInfo.Builder.create();
  javaCommon.addTransitiveInfoProviders(builder,javaInfoBuilder,filesToBuild,classJar);
  javaCommon.addGenJarsProvider(builder,javaInfoBuilder,genClassJar,genSourceJar);
  AndroidFeatureFlagSetProvider.getAndValidateFlagMapFromRuleContext(ruleContext);
  if (oneVersionOutputArtifact != null) {
    builder.addOutputGroup(OutputGroupInfo.HIDDEN_TOP_LEVEL,oneVersionOutputArtifact);
  }
  NestedSet<Artifact> extraFilesToRun=NestedSetBuilder.create(Order.STABLE_ORDER,runfilesSupport.getRunfilesMiddleman());
  JavaInfo javaInfo=javaInfoBuilder.addProvider(JavaSourceJarsProvider.class,sourceJarsProvider).addProvider(JavaRuleOutputJarsProvider.class,ruleOutputJarsProvider).build();
  return builder.setFilesToBuild(filesToBuild).addSkylarkTransitiveInfo(JavaSkylarkApiProvider.NAME,JavaSkylarkApiProvider.fromRuleContext()).addNativeDeclaredProvider(javaInfo).addProvider(RunfilesProvider.class,RunfilesProvider.withData(defaultRunfiles,new Runfiles.Builder(ruleContext.getWorkspaceName()).merge(runfilesSupport).build())).addFilesToRun(extraFilesToRun).setRunfilesSupport(runfilesSupport,executable).addProvider(JavaRuntimeClasspathProvider.class,new JavaRuntimeClasspathProvider(javaCommon.getRuntimeClasspath())).addProvider(JavaPrimaryClassProvider.class,new JavaPrimaryClassProvider(testClass)).addProvider(JavaSourceInfoProvider.class,JavaSourceInfoProvider.fromJavaTargetAttributes(helper.getAttributes(),javaSemantics)).addOutputGroup(JavaSemantics.SOURCE_JARS_OUTPUT_GROUP,transitiveSourceJars).build();
}","@Override public ConfiguredTarget create(RuleContext ruleContext) throws InterruptedException, RuleErrorException, ActionConflictException {
  ruleContext.checkSrcsSamePackage(true);
  JavaSemantics javaSemantics=createJavaSemantics();
  AndroidSemantics androidSemantics=createAndroidSemantics();
  createAndroidMigrationSemantics().validateRuleContext(ruleContext);
  AndroidLocalTestConfiguration androidLocalTestConfiguration=ruleContext.getFragment(AndroidLocalTestConfiguration.class);
  final JavaCommon javaCommon=new JavaCommon(ruleContext,javaSemantics);
  JavaTargetAttributes.Builder attributesBuilder=javaCommon.initCommon();
  final ResourceApk resourceApk;
  if (AndroidResources.decoupleDataProcessing(ruleContext)) {
    StampedAndroidManifest manifest=StampedAndroidManifest.from(ruleContext,androidSemantics).mergeWithDeps(ruleContext);
    resourceApk=ProcessedAndroidData.processLocalTestDataFrom(ruleContext,manifest).generateRClass(ruleContext);
  }
 else {
    ResourceDependencies resourceDependencies=ResourceDependencies.fromRuleDeps(ruleContext,false);
    ApplicationManifest applicationManifest=getApplicationManifest(ruleContext,androidSemantics,resourceDependencies);
    resourceApk=applicationManifest.packBinaryWithDataAndResources(ruleContext,ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_APK),resourceDependencies,ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_R_TXT),ResourceFilterFactory.fromRuleContext(ruleContext),ImmutableList.of(),false,ProguardHelper.getProguardConfigArtifact(ruleContext,""String_Node_Str""),null,false,ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_PROCESSED_MANIFEST),ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_ZIP),DataBinding.isEnabled(ruleContext) ? DataBinding.getLayoutInfoFile(ruleContext) : null,null,null);
  }
  attributesBuilder.addRuntimeClassPathEntry(resourceApk.getResourceJavaClassJar());
  NestedSet<Artifact> excludedRuntimeArtifacts=getLibraryResourceJars(ruleContext);
  attributesBuilder.addExcludedArtifacts(excludedRuntimeArtifacts);
  String name=""String_Node_Str"" + ruleContext.getRule().getName() + ""String_Node_Str"";
  Artifact propertiesFile=ruleContext.getGenfilesArtifact(name);
  String resourcesLocation=resourceApk.getValidatedResources().getMergedResources().getRunfilesPathString();
  Template template=Template.forResource(AndroidLocalTestBase.class,""String_Node_Str"");
  List<Substitution> substitutions=new ArrayList<>();
  substitutions.add(Substitution.of(""String_Node_Str"",resourceApk.getManifest().getRunfilesPathString()));
  substitutions.add(Substitution.of(""String_Node_Str"",""String_Node_Str"" + resourcesLocation + ""String_Node_Str""));
  substitutions.add(Substitution.of(""String_Node_Str"",""String_Node_Str"" + resourcesLocation + ""String_Node_Str""));
  substitutions.add(Substitution.of(""String_Node_Str"",resourceApk.getValidatedResources().getJavaPackage()));
  boolean generateBinaryResources=androidLocalTestConfiguration.useAndroidLocalTestBinaryResources();
  if (generateBinaryResources) {
    substitutions.add(Substitution.of(""String_Node_Str"",resourceApk.getArtifact().getRunfilesPathString()));
  }
  ruleContext.registerAction(new TemplateExpansionAction(ruleContext.getActionOwner(),propertiesFile,template,substitutions,false));
  attributesBuilder.addResource(PathFragment.create(""String_Node_Str""),propertiesFile);
  String testClass=getAndCheckTestClass(ruleContext,ImmutableList.copyOf(attributesBuilder.getSourceFiles()));
  getAndCheckTestSupport(ruleContext);
  javaSemantics.checkForProtoLibraryAndJavaProtoLibraryOnSameProto(ruleContext,javaCommon);
  if (ruleContext.hasErrors()) {
    return null;
  }
  Artifact srcJar=ruleContext.getImplicitOutputArtifact(JavaSemantics.JAVA_BINARY_SOURCE_JAR);
  JavaSourceJarsProvider.Builder javaSourceJarsProviderBuilder=JavaSourceJarsProvider.builder().addSourceJar(srcJar).addAllTransitiveSourceJars(javaCommon.collectTransitiveSourceJars(srcJar));
  Artifact classJar=ruleContext.getImplicitOutputArtifact(JavaSemantics.JAVA_BINARY_CLASS_JAR);
  JavaRuleOutputJarsProvider.Builder javaRuleOutputJarsProviderBuilder=JavaRuleOutputJarsProvider.builder().addOutputJar(classJar,classJar,srcJar == null ? ImmutableList.<Artifact>of() : ImmutableList.of(srcJar));
  JavaCompilationArtifacts.Builder javaArtifactsBuilder=new JavaCompilationArtifacts.Builder();
  JavaCompilationHelper helper=getJavaCompilationHelperWithDependencies(ruleContext,javaSemantics,javaCommon,attributesBuilder);
  Artifact instrumentationMetadata=helper.createInstrumentationMetadata(classJar,javaArtifactsBuilder);
  Artifact executable;
  if (OS.getCurrent() == OS.WINDOWS && ruleContext.getConfiguration().enableWindowsExeLauncher()) {
    executable=ruleContext.getImplicitOutputArtifact(ruleContext.getTarget().getName() + ""String_Node_Str"");
  }
 else {
    executable=ruleContext.createOutputArtifact();
  }
  NestedSetBuilder<Artifact> filesToBuildBuilder=NestedSetBuilder.<Artifact>stableOrder().add(classJar).add(executable);
  GeneratedExtensionRegistryProvider generatedExtensionRegistryProvider=javaSemantics.createGeneratedExtensionRegistry(ruleContext,javaCommon,filesToBuildBuilder,javaArtifactsBuilder,javaRuleOutputJarsProviderBuilder,javaSourceJarsProviderBuilder);
  String mainClass=getMainClass(ruleContext,javaSemantics,helper,executable,instrumentationMetadata,javaArtifactsBuilder,attributesBuilder);
  addJavaClassJarToArtifactsBuilder(javaArtifactsBuilder,helper.getAttributes(),classJar);
  Artifact manifestProtoOutput=helper.createManifestProtoOutput(classJar);
  Artifact genClassJar=null;
  Artifact genSourceJar=null;
  if (helper.usesAnnotationProcessing()) {
    genClassJar=helper.createGenJar(classJar);
    genSourceJar=helper.createGensrcJar(classJar);
    helper.createGenJarAction(classJar,manifestProtoOutput,genClassJar);
  }
  Artifact outputDepsProtoArtifact=helper.createOutputDepsProtoArtifact(classJar,javaArtifactsBuilder);
  javaRuleOutputJarsProviderBuilder.setJdeps(outputDepsProtoArtifact);
  helper.createCompileAction(classJar,manifestProtoOutput,genSourceJar,outputDepsProtoArtifact,instrumentationMetadata,null);
  helper.createSourceJarAction(srcJar,genSourceJar);
  setUpJavaCommon(javaCommon,helper,javaArtifactsBuilder.build());
  Artifact launcher=JavaHelper.launcherArtifactForTarget(javaSemantics,ruleContext);
  String javaExecutable;
  if (javaSemantics.isJavaExecutableSubstitution()) {
    javaExecutable=JavaCommon.getJavaBinSubstitution(ruleContext,launcher);
  }
 else {
    javaExecutable=JavaCommon.getJavaExecutableForStub(ruleContext,launcher);
  }
  javaSemantics.createStubAction(ruleContext,javaCommon,getJvmFlags(ruleContext,testClass),executable,mainClass,javaExecutable);
  Artifact oneVersionOutputArtifact=null;
  JavaConfiguration javaConfig=ruleContext.getFragment(JavaConfiguration.class);
  OneVersionEnforcementLevel oneVersionEnforcementLevel=javaConfig.oneVersionEnforcementLevel();
  boolean doOneVersionEnforcement=oneVersionEnforcementLevel != OneVersionEnforcementLevel.OFF && javaConfig.enforceOneVersionOnJavaTests();
  JavaToolchainProvider javaToolchain=JavaToolchainProvider.from(ruleContext);
  if (doOneVersionEnforcement) {
    oneVersionOutputArtifact=OneVersionCheckActionBuilder.newBuilder().withEnforcementLevel(oneVersionEnforcementLevel).outputArtifact(ruleContext.getImplicitOutputArtifact(JavaSemantics.JAVA_ONE_VERSION_ARTIFACT)).useToolchain(javaToolchain).checkJars(NestedSetBuilder.fromNestedSet(helper.getAttributes().getRuntimeClassPath()).add(classJar).build()).build(ruleContext);
  }
  NestedSet<Artifact> filesToBuild=filesToBuildBuilder.build();
  Runfiles defaultRunfiles=collectDefaultRunfiles(ruleContext,javaCommon,filesToBuild,resourceApk.getManifest(),resourceApk.getResourceJavaClassJar(),resourceApk.getValidatedResources().getMergedResources(),generateBinaryResources ? resourceApk : null);
  RunfilesSupport runfilesSupport=RunfilesSupport.withExecutable(ruleContext,defaultRunfiles,executable);
  Artifact deployJar=ruleContext.getImplicitOutputArtifact(JavaSemantics.JAVA_BINARY_DEPLOY_JAR);
  new DeployArchiveBuilder(javaSemantics,ruleContext).setOutputJar(deployJar).setJavaStartClass(mainClass).setDeployManifestLines(ImmutableList.<String>of()).setAttributes(helper.getAttributes()).addRuntimeJars(javaCommon.getJavaCompilationArtifacts().getRuntimeJars()).setIncludeBuildData(true).setRunfilesMiddleman(runfilesSupport.getRunfilesMiddleman()).setCompression(COMPRESSED).setLauncher(launcher).setOneVersionEnforcementLevel(doOneVersionEnforcement ? oneVersionEnforcementLevel : OneVersionEnforcementLevel.OFF,javaToolchain.getOneVersionWhitelist()).build();
  JavaSourceJarsProvider sourceJarsProvider=javaSourceJarsProviderBuilder.build();
  NestedSet<Artifact> transitiveSourceJars=sourceJarsProvider.getTransitiveSourceJars();
  RuleConfiguredTargetBuilder builder=new RuleConfiguredTargetBuilder(ruleContext);
  if (generatedExtensionRegistryProvider != null) {
    builder.addProvider(GeneratedExtensionRegistryProvider.class,generatedExtensionRegistryProvider);
  }
  JavaRuleOutputJarsProvider ruleOutputJarsProvider=javaRuleOutputJarsProviderBuilder.build();
  JavaInfo.Builder javaInfoBuilder=JavaInfo.Builder.create();
  javaCommon.addTransitiveInfoProviders(builder,javaInfoBuilder,filesToBuild,classJar);
  javaCommon.addGenJarsProvider(builder,javaInfoBuilder,genClassJar,genSourceJar);
  AndroidFeatureFlagSetProvider.getAndValidateFlagMapFromRuleContext(ruleContext);
  if (oneVersionOutputArtifact != null) {
    builder.addOutputGroup(OutputGroupInfo.HIDDEN_TOP_LEVEL,oneVersionOutputArtifact);
  }
  NestedSet<Artifact> extraFilesToRun=NestedSetBuilder.create(Order.STABLE_ORDER,runfilesSupport.getRunfilesMiddleman());
  JavaInfo javaInfo=javaInfoBuilder.addProvider(JavaSourceJarsProvider.class,sourceJarsProvider).addProvider(JavaRuleOutputJarsProvider.class,ruleOutputJarsProvider).build();
  return builder.setFilesToBuild(filesToBuild).addSkylarkTransitiveInfo(JavaSkylarkApiProvider.NAME,JavaSkylarkApiProvider.fromRuleContext()).addNativeDeclaredProvider(javaInfo).addProvider(RunfilesProvider.class,RunfilesProvider.withData(defaultRunfiles,new Runfiles.Builder(ruleContext.getWorkspaceName()).merge(runfilesSupport).build())).addFilesToRun(extraFilesToRun).setRunfilesSupport(runfilesSupport,executable).addProvider(JavaRuntimeClasspathProvider.class,new JavaRuntimeClasspathProvider(javaCommon.getRuntimeClasspath())).addProvider(JavaPrimaryClassProvider.class,new JavaPrimaryClassProvider(testClass)).addProvider(JavaSourceInfoProvider.class,JavaSourceInfoProvider.fromJavaTargetAttributes(helper.getAttributes(),javaSemantics)).addOutputGroup(JavaSemantics.SOURCE_JARS_OUTPUT_GROUP,transitiveSourceJars).build();
}",0.9997228893404766
110552,"/** 
 * Merges the manifest with any dependent manifests. <p>The resulting manifest will be stamped, even if no merging was done.
 */
public StampedAndroidManifest mergeWithDeps(RuleContext ruleContext){
  return ApplicationManifest.maybeMergeWith(ruleContext,manifest,ResourceDependencies.fromRuleDeps(ruleContext,false),ApplicationManifest.getManifestValues(ruleContext)).map(merged -> new StampedAndroidManifest(merged,pkg,exported)).orElseGet(() -> stamp(ruleContext));
}","private StampedAndroidManifest mergeWithDeps(RuleContext ruleContext,ResourceDependencies resourceDeps){
  Artifact newManifest=ApplicationManifest.maybeMergeWith(ruleContext,manifest,resourceDeps,ApplicationManifest.getManifestValues(ruleContext)).orElse(manifest);
  return new StampedAndroidManifest(newManifest,pkg,exported);
}",0.5732009925558312
110553,"public ProcessedAndroidData build(AndroidResources primaryResources,AndroidAssets primaryAssets,StampedAndroidManifest primaryManifest){
  if (aaptVersion == AndroidAaptVersion.AAPT2) {
    createAapt2ApkAction(primaryResources,primaryAssets,primaryManifest);
  }
 else {
    createAaptAction(primaryResources,primaryAssets,primaryManifest);
  }
  ProcessedAndroidManifest processedManifest=new ProcessedAndroidManifest(manifestOut == null ? primaryManifest.getManifest() : manifestOut,primaryManifest.getPackage(),primaryManifest.isExported());
  ParsedAndroidResources parsedResources=ParsedAndroidResources.of(primaryResources,symbols,null,ruleContext.getLabel(),processedManifest);
  ParsedAndroidAssets parsedAssets=ParsedAndroidAssets.of(primaryAssets,symbols,ruleContext.getLabel());
  MergedAndroidAssets mergedAssets=MergedAndroidAssets.of(parsedAssets,mergedResourcesOut,assetDependencies);
  return ProcessedAndroidData.of(parsedResources,mergedAssets,processedManifest,rTxtOut,sourceJarOut,apkOut,dataBindingInfoZip,resourceDependencies);
}","public ProcessedAndroidData build(AndroidResources primaryResources,AndroidAssets primaryAssets,StampedAndroidManifest primaryManifest){
  if (aaptVersion == AndroidAaptVersion.AAPT2) {
    createAapt2ApkAction(primaryResources,primaryAssets,primaryManifest);
  }
 else {
    createAaptAction(primaryResources,primaryAssets,primaryManifest);
  }
  ProcessedAndroidManifest processedManifest=new ProcessedAndroidManifest(manifestOut == null ? primaryManifest.getManifest() : manifestOut,primaryManifest.getPackage(),primaryManifest.isExported());
  ParsedAndroidResources parsedResources=ParsedAndroidResources.of(primaryResources,symbols,null,ruleContext.getLabel(),processedManifest);
  ParsedAndroidAssets parsedAssets=ParsedAndroidAssets.of(primaryAssets,symbols,ruleContext.getLabel());
  MergedAndroidAssets mergedAssets=MergedAndroidAssets.of(parsedAssets,mergedResourcesOut,assetDependencies);
  return ProcessedAndroidData.of(parsedResources,mergedAssets,processedManifest,rTxtOut,sourceJarOut,apkOut,dataBindingInfoZip,resourceDependencies,proguardOut,mainDexProguardOut);
}",0.985480093676815
110554,"@VisibleForTesting static MergedAndroidAssets mergeFrom(RuleContext ruleContext,ParsedAndroidAssets parsed,AssetDependencies deps) throws InterruptedException {
  Artifact mergedAssets=ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_ASSETS_ZIP);
  BusyBoxActionBuilder builder=BusyBoxActionBuilder.create(ruleContext,""String_Node_Str"");
  if (AndroidCommon.getAndroidConfig(ruleContext).throwOnResourceConflict()) {
    builder.addFlag(""String_Node_Str"");
  }
  builder.addOutput(""String_Node_Str"",mergedAssets).addInput(""String_Node_Str"",AndroidSdkProvider.fromRuleContext(ruleContext).getAndroidJar()).addInput(""String_Node_Str"",AndroidDataConverter.MERGABLE_DATA_CONVERTER.map(parsed),Iterables.concat(parsed.getAssets(),ImmutableList.of(parsed.getSymbols()))).addTransitiveFlag(""String_Node_Str"",deps.getDirectParsedAssets(),AndroidDataConverter.MERGABLE_DATA_CONVERTER).addTransitiveFlag(""String_Node_Str"",deps.getTransitiveParsedAssets(),AndroidDataConverter.MERGABLE_DATA_CONVERTER).addTransitiveInputValues(deps.getTransitiveAssets()).addTransitiveInputValues(deps.getTransitiveSymbols()).buildAndRegister(""String_Node_Str"",""String_Node_Str"");
  return of(parsed,mergedAssets,deps);
}","@VisibleForTesting static MergedAndroidAssets mergeFrom(RuleContext ruleContext,ParsedAndroidAssets parsed,AssetDependencies deps) throws InterruptedException {
  Artifact mergedAssets=ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_ASSETS_ZIP);
  BusyBoxActionBuilder builder=BusyBoxActionBuilder.create(ruleContext,""String_Node_Str"");
  if (AndroidCommon.getAndroidConfig(ruleContext).throwOnResourceConflict()) {
    builder.addFlag(""String_Node_Str"");
  }
  builder.addOutput(""String_Node_Str"",mergedAssets).addInput(""String_Node_Str"",AndroidDataConverter.MERGABLE_DATA_CONVERTER.map(parsed),Iterables.concat(parsed.getAssets(),ImmutableList.of(parsed.getSymbols()))).addTransitiveFlag(""String_Node_Str"",deps.getDirectParsedAssets(),AndroidDataConverter.MERGABLE_DATA_CONVERTER).addTransitiveFlag(""String_Node_Str"",deps.getTransitiveParsedAssets(),AndroidDataConverter.MERGABLE_DATA_CONVERTER).addTransitiveInputValues(deps.getTransitiveAssets()).addTransitiveInputValues(deps.getTransitiveSymbols()).buildAndRegister(""String_Node_Str"",""String_Node_Str"");
  return of(parsed,mergedAssets,deps);
}",0.9604471195184868
110555,"public static MergedAndroidResources mergeFrom(RuleContext ruleContext,ParsedAndroidResources parsed,boolean neverlink) throws InterruptedException {
  AndroidConfiguration androidConfiguration=AndroidCommon.getAndroidConfig(ruleContext);
  boolean useCompiledMerge=androidConfiguration.getAndroidAaptVersion().equals(AndroidAaptVersion.AAPT2) && androidConfiguration.skipParsingAction();
  Preconditions.checkState(!useCompiledMerge || parsed.getCompiledSymbols() != null,""String_Node_Str"");
  AndroidResourceMergingActionBuilder builder=new AndroidResourceMergingActionBuilder(ruleContext).setJavaPackage(parsed.getJavaPackage()).withDependencies(ResourceDependencies.fromRuleDeps(ruleContext,neverlink)).setThrowOnResourceConflict(androidConfiguration.throwOnResourceConflict()).setUseCompiledMerge(useCompiledMerge);
  if (DataBinding.isEnabled(ruleContext)) {
    builder.setDataBindingInfoZip(DataBinding.getLayoutInfoFile(ruleContext));
  }
  return builder.setManifestOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_PROCESSED_MANIFEST)).setMergedResourcesOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_ZIP)).setClassJarOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_CLASS_JAR)).build(ruleContext,parsed);
}","public static MergedAndroidResources mergeFrom(RuleContext ruleContext,ParsedAndroidResources parsed,boolean neverlink) throws InterruptedException, RuleErrorException {
  AndroidConfiguration androidConfiguration=AndroidCommon.getAndroidConfig(ruleContext);
  boolean useCompiledMerge=AndroidAaptVersion.chooseTargetAaptVersion(ruleContext) == AndroidAaptVersion.AAPT2 && androidConfiguration.skipParsingAction();
  Preconditions.checkState(!useCompiledMerge || parsed.getCompiledSymbols() != null,""String_Node_Str"");
  AndroidResourceMergingActionBuilder builder=new AndroidResourceMergingActionBuilder(ruleContext).setJavaPackage(parsed.getJavaPackage()).withDependencies(ResourceDependencies.fromRuleDeps(ruleContext,neverlink)).setThrowOnResourceConflict(androidConfiguration.throwOnResourceConflict()).setUseCompiledMerge(useCompiledMerge);
  if (DataBinding.isEnabled(ruleContext)) {
    builder.setDataBindingInfoZip(DataBinding.getLayoutInfoFile(ruleContext));
  }
  return builder.setManifestOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_PROCESSED_MANIFEST)).setMergedResourcesOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_ZIP)).setClassJarOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_CLASS_JAR)).build(ruleContext,parsed);
}",0.9634146341463414
110556,"/** 
 * Validates and packages this rule's resources. <p>See   {@link ValidatedAndroidResources#validateFrom(RuleContext,MergedAndroidResources)}. This method is a convenience method for calling that one.
 */
public ValidatedAndroidResources validate(RuleContext ruleContext) throws InterruptedException {
  return ValidatedAndroidResources.validateFrom(ruleContext,this);
}","/** 
 * Validates and packages this rule's resources. <p>See   {@link ValidatedAndroidResources#validateFrom(RuleContext,MergedAndroidResources)}. This method is a convenience method for calling that one.
 */
public ValidatedAndroidResources validate(RuleContext ruleContext) throws InterruptedException, RuleErrorException {
  return ValidatedAndroidResources.validateFrom(ruleContext,this);
}",0.9739583333333334
110557,"public static ParsedAndroidResources parseFrom(RuleContext ruleContext,AndroidResources resources,StampedAndroidManifest manifest) throws RuleErrorException, InterruptedException {
  boolean isAapt2=AndroidAaptVersion.chooseTargetAaptVersion(ruleContext).equals(AndroidAaptVersion.AAPT2);
  AndroidResourceParsingActionBuilder builder=new AndroidResourceParsingActionBuilder(ruleContext);
  if (DataBinding.isEnabled(ruleContext) && isAapt2) {
    builder.setDataBindingInfoZip(DataBinding.getSuffixedInfoFile(ruleContext,""String_Node_Str""));
  }
  return builder.setOutput(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_MERGED_SYMBOLS)).setCompiledSymbolsOutput(isAapt2 ? ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_COMPILED_SYMBOLS) : null).build(resources,manifest);
}","public static ParsedAndroidResources parseFrom(RuleContext ruleContext,AndroidResources resources,StampedAndroidManifest manifest) throws RuleErrorException, InterruptedException {
  boolean isAapt2=AndroidAaptVersion.chooseTargetAaptVersion(ruleContext) == AndroidAaptVersion.AAPT2;
  AndroidResourceParsingActionBuilder builder=new AndroidResourceParsingActionBuilder(ruleContext);
  if (DataBinding.isEnabled(ruleContext) && isAapt2) {
    builder.setDataBindingInfoZip(DataBinding.getSuffixedInfoFile(ruleContext,""String_Node_Str""));
  }
  return builder.setOutput(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_MERGED_SYMBOLS)).setCompiledSymbolsOutput(isAapt2 ? ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_COMPILED_SYMBOLS) : null).build(resources,manifest);
}",0.9919504643962848
110558,"/** 
 * Merges this target's resources with resources from dependencies. 
 */
public MergedAndroidResources merge(RuleContext ruleContext,boolean neverlink) throws InterruptedException {
  return MergedAndroidResources.mergeFrom(ruleContext,this,neverlink);
}","/** 
 * Merges this target's resources with resources from dependencies. 
 */
public MergedAndroidResources merge(RuleContext ruleContext,boolean neverlink) throws InterruptedException, RuleErrorException {
  return MergedAndroidResources.mergeFrom(ruleContext,this,neverlink);
}",0.9628252788104088
110559,"/** 
 * Common   {@link AndroidResourcesProcessorBuilder} builder for non-incremental top-level targets.<p>The builder will be populated with commonly-used settings and outputs.
 */
private static AndroidResourcesProcessorBuilder builderForNonIncrementalTopLevelTarget(RuleContext ruleContext,StampedAndroidManifest manifest) throws InterruptedException, RuleErrorException {
  return builderForTopLevelTarget(ruleContext,manifest,""String_Node_Str"").targetAaptVersion(AndroidAaptVersion.chooseTargetAaptVersion(ruleContext)).setApkOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_APK)).setRTxtOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_R_TXT)).setSourceJarOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_JAVA_SOURCE_JAR));
}","/** 
 * Common   {@link AndroidResourcesProcessorBuilder} builder for non-incremental top-level targets.<p>The builder will be populated with commonly-used settings and outputs.
 */
private static AndroidResourcesProcessorBuilder builderForNonIncrementalTopLevelTarget(RuleContext ruleContext,StampedAndroidManifest manifest) throws InterruptedException, RuleErrorException {
  return builderForTopLevelTarget(ruleContext,manifest,""String_Node_Str"").targetAaptVersion(AndroidAaptVersion.chooseTargetAaptVersion(ruleContext)).setApkOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_APK)).setRTxtOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_R_TXT)).setSourceJarOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_JAVA_SOURCE_JAR)).setSymbols(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_MERGED_SYMBOLS));
}",0.9451327433628318
110560,"/** 
 * Processes Android data (assets, resources, and manifest) for android_binary targets. 
 */
public static ProcessedAndroidData processBinaryDataFrom(RuleContext ruleContext,StampedAndroidManifest manifest,boolean conditionalKeepRules) throws RuleErrorException, InterruptedException {
  if (conditionalKeepRules && AndroidAaptVersion.chooseTargetAaptVersion(ruleContext) != AndroidAaptVersion.AAPT2) {
    throw ruleContext.throwWithRuleError(""String_Node_Str"");
  }
  AndroidResourcesProcessorBuilder builder=builderForNonIncrementalTopLevelTarget(ruleContext,manifest).setUseCompiledResourcesForMerge(AndroidAaptVersion.chooseTargetAaptVersion(ruleContext) == AndroidAaptVersion.AAPT2 && AndroidCommon.getAndroidConfig(ruleContext).skipParsingAction()).setManifestOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_PROCESSED_MANIFEST)).setMergedResourcesOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_ZIP)).setMainDexProguardOut(AndroidBinary.createMainDexProguardSpec(ruleContext)).conditionalKeepRules(conditionalKeepRules).setDataBindingInfoZip(DataBinding.isEnabled(ruleContext) ? DataBinding.getLayoutInfoFile(ruleContext) : null);
  return buildActionForBinary(ruleContext,builder,manifest);
}","/** 
 * Processes Android data (assets, resources, and manifest) for android_binary targets. 
 */
public static ProcessedAndroidData processBinaryDataFrom(RuleContext ruleContext,StampedAndroidManifest manifest,boolean conditionalKeepRules) throws RuleErrorException, InterruptedException {
  if (conditionalKeepRules && AndroidAaptVersion.chooseTargetAaptVersion(ruleContext) != AndroidAaptVersion.AAPT2) {
    throw ruleContext.throwWithRuleError(""String_Node_Str"");
  }
  AndroidResourcesProcessorBuilder builder=builderForNonIncrementalTopLevelTarget(ruleContext,manifest).setUseCompiledResourcesForMerge(AndroidAaptVersion.chooseTargetAaptVersion(ruleContext) == AndroidAaptVersion.AAPT2 && AndroidCommon.getAndroidConfig(ruleContext).skipParsingAction()).setManifestOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_PROCESSED_MANIFEST)).setMergedResourcesOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_ZIP)).setMainDexProguardOut(AndroidBinary.createMainDexProguardSpec(ruleContext)).conditionalKeepRules(conditionalKeepRules).setDataBindingInfoZip(DataBinding.isEnabled(ruleContext) ? DataBinding.getLayoutInfoFile(ruleContext) : null).setFeatureOf(ruleContext.attributes().isAttributeValueExplicitlySpecified(""String_Node_Str"") ? ruleContext.getPrerequisite(""String_Node_Str"",Mode.TARGET,ApkInfo.PROVIDER).getApk() : null).setFeatureAfter(ruleContext.attributes().isAttributeValueExplicitlySpecified(""String_Node_Str"") ? ruleContext.getPrerequisite(""String_Node_Str"",Mode.TARGET,ApkInfo.PROVIDER).getApk() : null);
  return buildActionForBinary(ruleContext,builder,manifest);
}",0.8689941237469755
110561,"/** 
 * Returns fully processed resources. The R class generator action will not be registered.
 * @param rClassJar an artifact containing the resource class jar for these resources. An actionto generate it must be registered elsewhere.
 */
ResourceApk withValidatedResources(Artifact rClassJar){
  Artifact mergedResources=assets.getMergedAssets();
  MergedAndroidResources merged=MergedAndroidResources.of(resources,mergedResources,rClassJar,dataBindingInfoZip,resourceDeps,manifest);
  ValidatedAndroidResources validated=ValidatedAndroidResources.of(merged,rTxt,sourceJar,apk,null,null,null);
  return ResourceApk.of(validated,assets);
}","/** 
 * Returns fully processed resources. The R class generator action will not be registered.
 * @param rClassJar an artifact containing the resource class jar for these resources. An actionto generate it must be registered elsewhere.
 */
ResourceApk withValidatedResources(Artifact rClassJar){
  Artifact mergedResources=assets.getMergedAssets();
  MergedAndroidResources merged=MergedAndroidResources.of(resources,mergedResources,rClassJar,dataBindingInfoZip,resourceDeps,manifest);
  ValidatedAndroidResources validated=ValidatedAndroidResources.of(merged,rTxt,sourceJar,apk,null,null,null);
  return ResourceApk.of(validated,assets,resourceProguardConfig,mainDexProguardConfig);
}",0.9660889223813112
110562,"static ProcessedAndroidData of(ParsedAndroidResources resources,MergedAndroidAssets assets,ProcessedAndroidManifest manifest,Artifact rTxt,Artifact sourceJar,Artifact apk,@Nullable Artifact dataBindingInfoZip,ResourceDependencies resourceDeps){
  return new ProcessedAndroidData(resources,assets,manifest,rTxt,sourceJar,apk,dataBindingInfoZip,resourceDeps);
}","static ProcessedAndroidData of(ParsedAndroidResources resources,MergedAndroidAssets assets,ProcessedAndroidManifest manifest,Artifact rTxt,Artifact sourceJar,Artifact apk,@Nullable Artifact dataBindingInfoZip,ResourceDependencies resourceDeps,@Nullable Artifact resourceProguardConfig,@Nullable Artifact mainDexProguardConfig){
  return new ProcessedAndroidData(resources,assets,manifest,rTxt,sourceJar,apk,dataBindingInfoZip,resourceDeps,resourceProguardConfig,mainDexProguardConfig);
}",0.8486997635933806
110563,"private ProcessedAndroidData(ParsedAndroidResources resources,MergedAndroidAssets assets,ProcessedAndroidManifest manifest,Artifact rTxt,Artifact sourceJar,Artifact apk,@Nullable Artifact dataBindingInfoZip,ResourceDependencies resourceDeps){
  this.resources=resources;
  this.assets=assets;
  this.manifest=manifest;
  this.rTxt=rTxt;
  this.sourceJar=sourceJar;
  this.apk=apk;
  this.dataBindingInfoZip=dataBindingInfoZip;
  this.resourceDeps=resourceDeps;
}","private ProcessedAndroidData(ParsedAndroidResources resources,MergedAndroidAssets assets,ProcessedAndroidManifest manifest,Artifact rTxt,Artifact sourceJar,Artifact apk,@Nullable Artifact dataBindingInfoZip,ResourceDependencies resourceDeps,@Nullable Artifact resourceProguardConfig,@Nullable Artifact mainDexProguardConfig){
  this.resources=resources;
  this.assets=assets;
  this.manifest=manifest;
  this.rTxt=rTxt;
  this.sourceJar=sourceJar;
  this.apk=apk;
  this.dataBindingInfoZip=dataBindingInfoZip;
  this.resourceDeps=resourceDeps;
  this.resourceProguardConfig=resourceProguardConfig;
  this.mainDexProguardConfig=mainDexProguardConfig;
}",0.8301886792452831
110564,"public static ResourceApk of(ValidatedAndroidResources resources,MergedAndroidAssets assets){
  return new ResourceApk(resources.getApk(),resources.getJavaSourceJar(),resources.getJavaClassJar(),resources.getResourceDependencies(),assets.getAssetDependencies(),resources,resources,assets,resources.getManifest(),resources.getRTxt(),null,null);
}","public static ResourceApk of(ValidatedAndroidResources resources,MergedAndroidAssets assets,@Nullable Artifact resourceProguardConfig,@Nullable Artifact mainDexProguardConfig){
  return new ResourceApk(resources.getApk(),resources.getJavaSourceJar(),resources.getJavaClassJar(),resources.getResourceDependencies(),assets.getAssetDependencies(),resources,resources,assets,resources.getManifest(),resources.getRTxt(),resourceProguardConfig,mainDexProguardConfig);
}",0.8316831683168316
110565,"public void addToConfiguredTargetBuilder(RuleConfiguredTargetBuilder builder,Label label,boolean includeSkylarkApiProvider){
  AndroidResourcesInfo resourceInfo=toResourceInfo(label);
  builder.addNativeDeclaredProvider(resourceInfo);
  if (validatedResources instanceof ValidatedAndroidResources) {
    ValidatedAndroidResources validated=(ValidatedAndroidResources)validatedResources;
    builder.addNativeDeclaredProvider(validated.getStampedManifest().toProvider());
  }
  if (primaryAssets instanceof MergedAndroidAssets) {
    MergedAndroidAssets merged=(MergedAndroidAssets)primaryAssets;
    AndroidAssetsInfo assetsInfo=merged.toProvider();
    builder.addNativeDeclaredProvider(assetsInfo);
    builder.addOutputGroup(OutputGroupInfo.HIDDEN_TOP_LEVEL,assetsInfo.getValidationResult());
  }
 else   if (primaryAssets == null) {
    builder.addNativeDeclaredProvider(assetDeps.toInfo(label));
  }
  if (includeSkylarkApiProvider) {
    builder.addSkylarkTransitiveInfo(AndroidSkylarkApiProvider.NAME,new AndroidSkylarkApiProvider(resourceInfo));
  }
}","public void addToConfiguredTargetBuilder(RuleConfiguredTargetBuilder builder,Label label,boolean includeSkylarkApiProvider){
  AndroidResourcesInfo resourceInfo=toResourceInfo(label);
  builder.addNativeDeclaredProvider(resourceInfo);
  if (validatedResources instanceof ValidatedAndroidResources) {
    ValidatedAndroidResources validated=(ValidatedAndroidResources)validatedResources;
    builder.addNativeDeclaredProvider(validated.getStampedManifest().toProvider());
  }
  if (primaryAssets instanceof MergedAndroidAssets) {
    MergedAndroidAssets merged=(MergedAndroidAssets)primaryAssets;
    AndroidAssetsInfo assetsInfo=merged.toProvider();
    builder.addNativeDeclaredProvider(assetsInfo);
    if (assetsInfo.getValidationResult() != null) {
      builder.addOutputGroup(OutputGroupInfo.HIDDEN_TOP_LEVEL,assetsInfo.getValidationResult());
    }
  }
 else   if (primaryAssets == null) {
    builder.addNativeDeclaredProvider(assetDeps.toInfo(label));
  }
  if (includeSkylarkApiProvider) {
    builder.addSkylarkTransitiveInfo(AndroidSkylarkApiProvider.NAME,new AndroidSkylarkApiProvider(resourceInfo));
  }
}",0.9724517906336088
110566,abstract AndroidAssets getAndroidAssets();,public abstract AndroidAssets getAndroidAssets();,0.9230769230769232
110567,"/** 
 * Validates and packages merged resources. <p>Specifically, validates that: <ul> <li>there are no conflicts between resources (though currently we just warn) <li>each reference to a resource in resources and manifest are satisfied </ul> <p>And packs resources into: <ul> <li>R.java and R.txt files <li>A resource-only APK (deprecated) <li>When building with aapt2, aapt2 equivalents of the above <li>When building with aapt2, a compiled symbols zip </ul>
 */
public static ValidatedAndroidResources validateFrom(RuleContext ruleContext,MergedAndroidResources merged) throws InterruptedException {
  AndroidConfiguration config=AndroidCommon.getAndroidConfig(ruleContext);
  AndroidResourceValidatorActionBuilder builder=new AndroidResourceValidatorActionBuilder(ruleContext).setJavaPackage(merged.getJavaPackage()).setDebug(ruleContext.getConfiguration().getCompilationMode() != CompilationMode.OPT).setMergedResources(merged.getMergedResources()).setRTxtOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_R_TXT)).setSourceJarOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_JAVA_SOURCE_JAR)).setApkOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_LIBRARY_APK)).withDependencies(merged.getResourceDependencies());
  if (config.getAndroidAaptVersion() == AndroidAaptVersion.AAPT2) {
    builder.setCompiledSymbols(merged.getCompiledSymbols()).setAapt2RTxtOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_AAPT2_R_TXT)).setAapt2SourceJarOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_AAPT2_SOURCE_JAR)).setStaticLibraryOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_AAPT2_LIBRARY_APK));
  }
  return builder.build(ruleContext,merged);
}","/** 
 * Validates and packages merged resources. <p>Specifically, validates that: <ul> <li>there are no conflicts between resources (though currently we just warn) <li>each reference to a resource in resources and manifest are satisfied </ul> <p>And packs resources into: <ul> <li>R.java and R.txt files <li>A resource-only APK (deprecated) <li>When building with aapt2, aapt2 equivalents of the above <li>When building with aapt2, a compiled symbols zip </ul>
 */
public static ValidatedAndroidResources validateFrom(RuleContext ruleContext,MergedAndroidResources merged) throws InterruptedException, RuleErrorException {
  AndroidResourceValidatorActionBuilder builder=new AndroidResourceValidatorActionBuilder(ruleContext).setJavaPackage(merged.getJavaPackage()).setDebug(ruleContext.getConfiguration().getCompilationMode() != CompilationMode.OPT).setMergedResources(merged.getMergedResources()).setRTxtOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_R_TXT)).setSourceJarOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_JAVA_SOURCE_JAR)).setApkOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_LIBRARY_APK)).withDependencies(merged.getResourceDependencies());
  if (AndroidAaptVersion.chooseTargetAaptVersion(ruleContext) == AndroidAaptVersion.AAPT2) {
    builder.setCompiledSymbols(merged.getCompiledSymbols()).setAapt2RTxtOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_AAPT2_R_TXT)).setAapt2SourceJarOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_AAPT2_SOURCE_JAR)).setStaticLibraryOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_AAPT2_LIBRARY_APK));
  }
  return builder.build(ruleContext,merged);
}",0.9600225225225224
110568,"private void configureCommonFlags(AndroidResources primaryResources,AndroidAssets primaryAssets,StampedAndroidManifest primaryManifest,List<Artifact> outs,NestedSetBuilder<Artifact> inputs,Builder builder){
  builder.add(""String_Node_Str"",String.format(""String_Node_Str"",AndroidDataConverter.rootsToString(primaryResources.getResourceRoots()),AndroidDataConverter.rootsToString(primaryAssets.getAssetRoots()),primaryManifest.getManifest().getExecPathString()));
  inputs.addAll(primaryResources.getResources());
  inputs.add(primaryManifest.getManifest());
  if (!Strings.isNullOrEmpty(sdk.getBuildToolsVersion())) {
    builder.add(""String_Node_Str"",sdk.getBuildToolsVersion());
  }
  builder.addExecPath(""String_Node_Str"",sdk.getAndroidJar());
  inputs.add(sdk.getAndroidJar());
  if (isLibrary) {
    builder.add(""String_Node_Str"").add(""String_Node_Str"");
  }
  if (rTxtOut != null) {
    builder.addExecPath(""String_Node_Str"",rTxtOut);
    outs.add(rTxtOut);
  }
  if (symbols != null) {
    builder.addExecPath(""String_Node_Str"",symbols);
    outs.add(symbols);
  }
  if (sourceJarOut != null) {
    builder.addExecPath(""String_Node_Str"",sourceJarOut);
    outs.add(sourceJarOut);
  }
  if (proguardOut != null) {
    builder.addExecPath(""String_Node_Str"",proguardOut);
    outs.add(proguardOut);
  }
  if (mainDexProguardOut != null) {
    builder.addExecPath(""String_Node_Str"",mainDexProguardOut);
    outs.add(mainDexProguardOut);
  }
  if (manifestOut != null) {
    builder.addExecPath(""String_Node_Str"",manifestOut);
    outs.add(manifestOut);
  }
  if (mergedResourcesOut != null) {
    builder.addExecPath(""String_Node_Str"",mergedResourcesOut);
    outs.add(mergedResourcesOut);
  }
  if (apkOut != null) {
    builder.addExecPath(""String_Node_Str"",apkOut);
    outs.add(apkOut);
  }
  if (resourceFilterFactory.hasConfigurationFilters()) {
    builder.add(""String_Node_Str"",resourceFilterFactory.getConfigurationFilterString());
  }
  if (resourceFilterFactory.hasDensities()) {
    builder.add(""String_Node_Str"",resourceFilterFactory.getDensityString());
  }
  if (!uncompressedExtensions.isEmpty()) {
    builder.addAll(""String_Node_Str"",VectorArg.join(""String_Node_Str"").each(uncompressedExtensions));
  }
  if (!crunchPng) {
    builder.add(""String_Node_Str"");
  }
  if (debug) {
    builder.add(""String_Node_Str"");
  }
  if (versionCode != null) {
    builder.add(""String_Node_Str"",versionCode);
  }
  if (versionName != null) {
    builder.add(""String_Node_Str"",versionName);
  }
  if (applicationId != null) {
    builder.add(""String_Node_Str"",applicationId);
  }
  if (dataBindingInfoZip != null) {
    builder.addExecPath(""String_Node_Str"",dataBindingInfoZip);
    outs.add(dataBindingInfoZip);
  }
  if (!Strings.isNullOrEmpty(customJavaPackage)) {
    builder.add(""String_Node_Str"",customJavaPackage);
  }
  if (featureOf != null) {
    builder.addExecPath(""String_Node_Str"",featureOf);
    inputs.add(featureOf);
  }
  if (featureAfter != null) {
    builder.addExecPath(""String_Node_Str"",featureAfter);
    inputs.add(featureAfter);
  }
  if (throwOnResourceConflict) {
    builder.add(""String_Node_Str"");
  }
  if (packageUnderTest != null) {
    builder.add(""String_Node_Str"",packageUnderTest);
  }
  if (isTestWithResources) {
    builder.add(""String_Node_Str"");
  }
}","private void configureCommonFlags(AndroidResources primaryResources,AndroidAssets primaryAssets,StampedAndroidManifest primaryManifest,List<Artifact> outs,NestedSetBuilder<Artifact> inputs,Builder builder){
  builder.add(""String_Node_Str"",String.format(""String_Node_Str"",AndroidDataConverter.rootsToString(primaryResources.getResourceRoots()),AndroidDataConverter.rootsToString(primaryAssets.getAssetRoots()),primaryManifest.getManifest().getExecPathString()));
  inputs.addAll(primaryResources.getResources());
  inputs.addAll(primaryAssets.getAssets());
  inputs.add(primaryManifest.getManifest());
  if (!Strings.isNullOrEmpty(sdk.getBuildToolsVersion())) {
    builder.add(""String_Node_Str"",sdk.getBuildToolsVersion());
  }
  builder.addExecPath(""String_Node_Str"",sdk.getAndroidJar());
  inputs.add(sdk.getAndroidJar());
  if (isLibrary) {
    builder.add(""String_Node_Str"").add(""String_Node_Str"");
  }
  if (rTxtOut != null) {
    builder.addExecPath(""String_Node_Str"",rTxtOut);
    outs.add(rTxtOut);
  }
  if (symbols != null) {
    builder.addExecPath(""String_Node_Str"",symbols);
    outs.add(symbols);
  }
  if (sourceJarOut != null) {
    builder.addExecPath(""String_Node_Str"",sourceJarOut);
    outs.add(sourceJarOut);
  }
  if (proguardOut != null) {
    builder.addExecPath(""String_Node_Str"",proguardOut);
    outs.add(proguardOut);
  }
  if (mainDexProguardOut != null) {
    builder.addExecPath(""String_Node_Str"",mainDexProguardOut);
    outs.add(mainDexProguardOut);
  }
  if (manifestOut != null) {
    builder.addExecPath(""String_Node_Str"",manifestOut);
    outs.add(manifestOut);
  }
  if (mergedResourcesOut != null) {
    builder.addExecPath(""String_Node_Str"",mergedResourcesOut);
    outs.add(mergedResourcesOut);
  }
  if (apkOut != null) {
    builder.addExecPath(""String_Node_Str"",apkOut);
    outs.add(apkOut);
  }
  if (resourceFilterFactory.hasConfigurationFilters()) {
    builder.add(""String_Node_Str"",resourceFilterFactory.getConfigurationFilterString());
  }
  if (resourceFilterFactory.hasDensities()) {
    builder.add(""String_Node_Str"",resourceFilterFactory.getDensityString());
  }
  if (!uncompressedExtensions.isEmpty()) {
    builder.addAll(""String_Node_Str"",VectorArg.join(""String_Node_Str"").each(uncompressedExtensions));
  }
  if (!crunchPng) {
    builder.add(""String_Node_Str"");
  }
  if (debug) {
    builder.add(""String_Node_Str"");
  }
  if (versionCode != null) {
    builder.add(""String_Node_Str"",versionCode);
  }
  if (versionName != null) {
    builder.add(""String_Node_Str"",versionName);
  }
  if (applicationId != null) {
    builder.add(""String_Node_Str"",applicationId);
  }
  if (dataBindingInfoZip != null) {
    builder.addExecPath(""String_Node_Str"",dataBindingInfoZip);
    outs.add(dataBindingInfoZip);
  }
  if (!Strings.isNullOrEmpty(customJavaPackage)) {
    builder.add(""String_Node_Str"",customJavaPackage);
  }
  if (featureOf != null) {
    builder.addExecPath(""String_Node_Str"",featureOf);
    inputs.add(featureOf);
  }
  if (featureAfter != null) {
    builder.addExecPath(""String_Node_Str"",featureAfter);
    inputs.add(featureAfter);
  }
  if (throwOnResourceConflict) {
    builder.add(""String_Node_Str"");
  }
  if (packageUnderTest != null) {
    builder.add(""String_Node_Str"",packageUnderTest);
  }
  if (isTestWithResources) {
    builder.add(""String_Node_Str"");
  }
}",0.9933734939759036
110569,"@Nullable static ImmutableList<Label> expandTargetPatterns(Environment env,List<String> targetPatterns,FilteringPolicy filteringPolicy) throws InvalidTargetPatternException, InterruptedException {
  List<TargetPatternValue.TargetPatternKey> patternKeys=new ArrayList<>();
  for (  TargetPatternValue.TargetPatternSkyKeyOrException keyOrException : TargetPatternValue.keys(targetPatterns,filteringPolicy,""String_Node_Str"")) {
    try {
      patternKeys.add(keyOrException.getSkyKey());
    }
 catch (    TargetParsingException e) {
      throw new InvalidTargetPatternException(keyOrException.getOriginalPattern(),e);
    }
  }
  ImmutableList.Builder<Label> labels=new ImmutableList.Builder<>();
  Map<SkyKey,ValueOrException<TargetParsingException>> resolvedPatterns=env.getValuesOrThrow(patternKeys,TargetParsingException.class);
  if (env.valuesMissing()) {
    return null;
  }
  for (  TargetPatternValue.TargetPatternKey pattern : patternKeys) {
    TargetPatternValue value;
    try {
      value=(TargetPatternValue)resolvedPatterns.get(pattern).get();
      labels.addAll(value.getTargets().getTargets());
    }
 catch (    TargetParsingException e) {
      throw new InvalidTargetPatternException(pattern.getPattern(),e);
    }
  }
  return labels.build();
}","@Nullable static ImmutableList<Label> expandTargetPatterns(Environment env,List<String> targetPatterns,FilteringPolicy filteringPolicy) throws InvalidTargetPatternException, InterruptedException {
  List<TargetPatternValue.TargetPatternKey> patternKeys=new ArrayList<>();
  for (  TargetPatternValue.TargetPatternSkyKeyOrException keyOrException : TargetPatternValue.keys(targetPatterns,filteringPolicy,""String_Node_Str"")) {
    try {
      patternKeys.add(keyOrException.getSkyKey());
    }
 catch (    TargetParsingException e) {
      throw new InvalidTargetPatternException(keyOrException.getOriginalPattern(),e);
    }
  }
  Map<SkyKey,ValueOrException<TargetParsingException>> resolvedPatterns=env.getValuesOrThrow(patternKeys,TargetParsingException.class);
  boolean valuesMissing=env.valuesMissing();
  ImmutableList.Builder<Label> labels=valuesMissing ? null : new ImmutableList.Builder<>();
  for (  TargetPatternValue.TargetPatternKey pattern : patternKeys) {
    TargetPatternValue value;
    try {
      value=(TargetPatternValue)resolvedPatterns.get(pattern).get();
      if (!valuesMissing && value != null) {
        labels.addAll(value.getTargets().getTargets());
      }
    }
 catch (    TargetParsingException e) {
      throw new InvalidTargetPatternException(pattern.getPattern(),e);
    }
  }
  if (valuesMissing) {
    return null;
  }
  return labels.build();
}",0.5807909604519774
110570,"@Override protected Iterable<Pair<SkyKey,SkyKey>> preprocessInitialVisit(Iterable<SkyKey> keys){
  return Iterables.transform(keys,key -> Pair.of(null,key));
}","@Override protected Iterable<DepAndRdep> preprocessInitialVisit(Iterable<SkyKey> keys){
  return Iterables.transform(keys,key -> new DepAndRdep(null,key));
}",0.8544303797468354
110571,"@Override protected Iterable<Task> getVisitTasks(Collection<Pair<SkyKey,SkyKey>> pendingKeysToVisit){
  ListMultimap<PackageIdentifier,Pair<SkyKey,SkyKey>> visitsByPackage=ArrayListMultimap.create();
  for (  Pair<SkyKey,SkyKey> visit : pendingKeysToVisit) {
    Label label=SkyQueryEnvironment.SKYKEY_TO_LABEL.apply(visit.second);
    if (label != null) {
      visitsByPackage.put(label.getPackageIdentifier(),visit);
    }
  }
  ImmutableList.Builder<Task> builder=ImmutableList.builder();
  for (  Iterable<Pair<SkyKey,SkyKey>> keysToVisitBatch : Iterables.partition(ImmutableList.copyOf(visitsByPackage.values()),VISIT_BATCH_SIZE)) {
    builder.add(new VisitTask(keysToVisitBatch));
  }
  return builder.build();
}","@Override protected Iterable<Task> getVisitTasks(Collection<DepAndRdep> pendingKeysToVisit){
  ListMultimap<PackageIdentifier,DepAndRdep> visitsByPackage=ArrayListMultimap.create();
  for (  DepAndRdep depAndRdep : pendingKeysToVisit) {
    Label label=SkyQueryEnvironment.SKYKEY_TO_LABEL.apply(depAndRdep.rdep);
    if (label != null) {
      visitsByPackage.put(label.getPackageIdentifier(),depAndRdep);
    }
  }
  ImmutableList.Builder<Task> builder=ImmutableList.builder();
  for (  Iterable<DepAndRdep> depAndRdepBatch : Iterables.partition(ImmutableList.copyOf(visitsByPackage.values()),VISIT_BATCH_SIZE)) {
    builder.add(new VisitTask(depAndRdepBatch));
  }
  return builder.build();
}",0.831095406360424
110572,"private Factory(SkyQueryEnvironment env,Callback<Target> callback,MultisetSemaphore<PackageIdentifier> packageSemaphore){
  this.env=env;
  this.uniquifier=env.createReverseDepSkyKeyUniquifier();
  this.callback=callback;
  this.packageSemaphore=packageSemaphore;
}","private Factory(SkyQueryEnvironment env,Callback<Target> callback,MultisetSemaphore<PackageIdentifier> packageSemaphore){
  this.env=env;
  this.depAndRdepUniquifier=new UniquifierImpl<>(depAndRdep -> depAndRdep);
  this.validRdepUniquifier=env.createSkyKeyUniquifier();
  this.callback=callback;
  this.packageSemaphore=packageSemaphore;
}",0.8099173553719008
110573,"@Override public ParallelVisitor<Pair<SkyKey,SkyKey>,Target> create(){
  return new AllRdepsUnboundedVisitor(env,uniquifier,callback,packageSemaphore);
}","@Override public ParallelVisitor<DepAndRdep,Target> create(){
  return new AllRdepsUnboundedVisitor(env,depAndRdepUniquifier,validRdepUniquifier,callback,packageSemaphore);
}",0.8318042813455657
110574,"@Override protected Visit getVisitResult(Iterable<Pair<SkyKey,SkyKey>> keys) throws InterruptedException {
  Collection<SkyKey> filteredKeys=new ArrayList<>();
  Map<SkyKey,Collection<SkyKey>> reverseDepsMap=Maps.newHashMap();
  for (  Pair<SkyKey,SkyKey> reverseDepPair : keys) {
    if (reverseDepPair.first == null) {
      filteredKeys.add(Preconditions.checkNotNull(reverseDepPair.second));
      continue;
    }
    reverseDepsMap.computeIfAbsent(reverseDepPair.first,k -> new LinkedList<SkyKey>());
    reverseDepsMap.get(reverseDepPair.first).add(reverseDepPair.second);
  }
  Multimap<SkyKey,SkyKey> packageKeyToTargetKeyMap=env.makePackageKeyToTargetKeyMap(Iterables.concat(reverseDepsMap.values()));
  Set<PackageIdentifier> pkgIdsNeededForTargetification=packageKeyToTargetKeyMap.keySet().stream().map(SkyQueryEnvironment.PACKAGE_SKYKEY_TO_PACKAGE_IDENTIFIER).collect(toImmutableSet());
  packageSemaphore.acquireAll(pkgIdsNeededForTargetification);
  try {
    if (!reverseDepsMap.isEmpty()) {
      Collection<Target> filteredTargets=env.filterRawReverseDepsOfTransitiveTraversalKeys(reverseDepsMap,packageKeyToTargetKeyMap);
      filteredTargets.stream().map(SkyQueryEnvironment.TARGET_TO_SKY_KEY).forEachOrdered(filteredKeys::add);
    }
  }
  finally {
    packageSemaphore.releaseAll(pkgIdsNeededForTargetification);
  }
  Map<SkyKey,Iterable<SkyKey>> unfilteredReverseDeps=env.graph.getReverseDeps(filteredKeys);
  ImmutableList.Builder<Pair<SkyKey,SkyKey>> builder=ImmutableList.builder();
  for (  Map.Entry<SkyKey,Iterable<SkyKey>> rdeps : unfilteredReverseDeps.entrySet()) {
    for (    SkyKey rdep : rdeps.getValue()) {
      Label label=SkyQueryEnvironment.SKYKEY_TO_LABEL.apply(rdep);
      if (label != null) {
        builder.add(Pair.of(rdeps.getKey(),rdep));
      }
    }
  }
  return new Visit(filteredKeys,builder.build());
}","@Override protected Visit getVisitResult(Iterable<DepAndRdep> depAndRdeps) throws InterruptedException {
  Collection<SkyKey> filteredUniqueKeys=new ArrayList<>();
  Map<SkyKey,Collection<SkyKey>> reverseDepsMap=Maps.newHashMap();
  for (  DepAndRdep depAndRdep : depAndRdeps) {
    if (depAndRdep.dep == null && validRdepUniquifier.unique(depAndRdep.rdep)) {
      filteredUniqueKeys.add(depAndRdep.rdep);
      continue;
    }
    reverseDepsMap.computeIfAbsent(depAndRdep.dep,k -> new LinkedList<SkyKey>());
    reverseDepsMap.get(depAndRdep.dep).add(depAndRdep.rdep);
  }
  Multimap<SkyKey,SkyKey> packageKeyToTargetKeyMap=env.makePackageKeyToTargetKeyMap(Iterables.concat(reverseDepsMap.values()));
  Set<PackageIdentifier> pkgIdsNeededForTargetification=packageKeyToTargetKeyMap.keySet().stream().map(SkyQueryEnvironment.PACKAGE_SKYKEY_TO_PACKAGE_IDENTIFIER).collect(toImmutableSet());
  packageSemaphore.acquireAll(pkgIdsNeededForTargetification);
  try {
    if (!reverseDepsMap.isEmpty()) {
      Collection<Target> filteredTargets=env.filterRawReverseDepsOfTransitiveTraversalKeys(reverseDepsMap,packageKeyToTargetKeyMap);
      filteredTargets.stream().map(SkyQueryEnvironment.TARGET_TO_SKY_KEY).forEachOrdered(rdep -> {
        if (validRdepUniquifier.unique(rdep)) {
          filteredUniqueKeys.add(rdep);
        }
      }
);
    }
  }
  finally {
    packageSemaphore.releaseAll(pkgIdsNeededForTargetification);
  }
  Map<SkyKey,Iterable<SkyKey>> unfilteredReverseDeps=env.graph.getReverseDeps(filteredUniqueKeys);
  ImmutableList.Builder<DepAndRdep> builder=ImmutableList.builder();
  for (  Map.Entry<SkyKey,Iterable<SkyKey>> rdeps : unfilteredReverseDeps.entrySet()) {
    for (    SkyKey rdep : rdeps.getValue()) {
      Label label=SkyQueryEnvironment.SKYKEY_TO_LABEL.apply(rdep);
      if (label != null) {
        builder.add(new DepAndRdep(rdeps.getKey(),rdep));
      }
    }
  }
  return new Visit(filteredUniqueKeys,builder.build());
}",0.7760334903192047
110575,"private AllRdepsUnboundedVisitor(SkyQueryEnvironment env,Uniquifier<Pair<SkyKey,SkyKey>> uniquifier,Callback<Target> callback,MultisetSemaphore<PackageIdentifier> packageSemaphore){
  super(uniquifier,callback,VISIT_BATCH_SIZE,PROCESS_RESULTS_BATCH_SIZE);
  this.env=env;
  this.packageSemaphore=packageSemaphore;
}","private AllRdepsUnboundedVisitor(SkyQueryEnvironment env,Uniquifier<DepAndRdep> depAndRdepUniquifier,Uniquifier<SkyKey> validRdepUniquifier,Callback<Target> callback,MultisetSemaphore<PackageIdentifier> packageSemaphore){
  super(callback,VISIT_BATCH_SIZE,PROCESS_RESULTS_BATCH_SIZE);
  this.env=env;
  this.depAndRdepUniquifier=depAndRdepUniquifier;
  this.validRdepUniquifier=validRdepUniquifier;
  this.packageSemaphore=packageSemaphore;
}",0.7688243064729194
110576,"/** 
 * Filters this object.
 * @return an optional wrapping a = new {@link AndroidResources} with resources filtered by thepassed  {@link ResourceFilter}, or   {@link Optional#empty()} if no resources should befiltered.
 */
public Optional<AndroidResources> maybeFilter(ResourceFilter resourceFilter,boolean isDependency){
  Optional<ImmutableList<Artifact>> filtered=resourceFilter.maybeFilter(resources,isDependency);
  if (!filtered.isPresent()) {
    return Optional.empty();
  }
  ImmutableList.Builder<PathFragment> filteredResourcesRootsBuilder=ImmutableList.builder();
  for (  PathFragment resourceRoot : resourceRoots) {
    for (    Artifact resource : filtered.get()) {
      if (resource.getRootRelativePath().startsWith(resourceRoot)) {
        filteredResourcesRootsBuilder.add(resourceRoot);
        break;
      }
    }
  }
  return Optional.of(new AndroidResources(filtered.get(),filteredResourcesRootsBuilder.build()));
}","/** 
 * Filters this object.
 * @return an optional wrapping a = new {@link AndroidResources} with resources filtered by thepassed  {@link ResourceFilter}, or   {@link Optional#empty()} if no resources should befiltered.
 */
public Optional<AndroidResources> maybeFilter(RuleErrorConsumer errorConsumer,ResourceFilter resourceFilter,boolean isDependency) throws RuleErrorException {
  Optional<ImmutableList<Artifact>> filtered=resourceFilter.maybeFilter(resources,isDependency);
  if (!filtered.isPresent()) {
    return Optional.empty();
  }
  return Optional.of(new AndroidResources(filtered.get(),getResourceRoots(errorConsumer,filtered.get(),DEFAULT_RESOURCES_ATTR)));
}",0.5767326732673267
110577,"/** 
 * Filters this object, assuming it contains the resources of the current target. <p>If this object contains the resources from a dependency of this target, use   {@link #maybeFilter(ResourceFilter,boolean)} instead.
 * @return a filtered {@link AndroidResources} object. If no filtering was done, this object willbe returned.
 */
public AndroidResources filterLocalResources(ResourceFilter resourceFilter){
  return maybeFilter(resourceFilter,false).orElse(this);
}","/** 
 * Filters this object, assuming it contains the resources of the current target. <p>If this object contains the resources from a dependency of this target, use   {@link #maybeFilter(RuleErrorConsumer,ResourceFilter,boolean)} instead.
 * @return a filtered {@link AndroidResources} object. If no filtering was done, this object willbe returned.
 */
public AndroidResources filterLocalResources(RuleErrorConsumer errorConsumer,ResourceFilter resourceFilter) throws RuleErrorException {
  return maybeFilter(errorConsumer,resourceFilter,false).orElse(this);
}",0.9119070667957404
110578,"public ResourceApk packIncrementalBinaryWithDataAndResources(RuleContext ruleContext,Artifact resourceApk,ResourceDependencies resourceDeps,List<String> uncompressedExtensions,boolean crunchPng,Artifact proguardCfg) throws InterruptedException, RuleErrorException {
  AndroidResources resources=AndroidResources.from(ruleContext,""String_Node_Str"");
  ResourceFilterFactory resourceFilterFactory=ResourceFilterFactory.fromRuleContext(ruleContext);
  ResourceFilter resourceFilter=resourceFilterFactory.getResourceFilter(ruleContext,resourceDeps,resources);
  resources=resources.filterLocalResources(resourceFilter);
  resourceDeps=resourceDeps.filter(resourceFilter);
  ResourceContainer resourceContainer=ResourceContainer.builderFromRule(ruleContext).setApk(resourceApk).setManifest(getManifest()).setAssets(AndroidAssets.from(ruleContext)).setResources(resources).build();
  ResourceContainer processed=new AndroidResourcesProcessorBuilder(ruleContext).setLibrary(false).setApkOut(resourceContainer.getApk()).setResourceFilterFactory(resourceFilterFactory).setUncompressedExtensions(uncompressedExtensions).setCrunchPng(crunchPng).setJavaPackage(resourceContainer.getJavaPackage()).setDebug(ruleContext.getConfiguration().getCompilationMode() != CompilationMode.OPT).withPrimary(resourceContainer).withDependencies(resourceDeps).setProguardOut(proguardCfg).setApplicationId(manifestValues.get(""String_Node_Str"")).setVersionCode(manifestValues.get(""String_Node_Str"")).setVersionName(manifestValues.get(""String_Node_Str"")).setThrowOnResourceConflict(ruleContext.getConfiguration().getFragment(AndroidConfiguration.class).throwOnResourceConflict()).setPackageUnderTest(null).build(ruleContext);
  return new ResourceApk(resourceContainer.getApk(),processed.getJavaSourceJar(),processed.getJavaClassJar(),resourceDeps,processed,processed.getManifest(),proguardCfg,null);
}","public ResourceApk packIncrementalBinaryWithDataAndResources(RuleContext ruleContext,Artifact resourceApk,ResourceDependencies resourceDeps,List<String> uncompressedExtensions,boolean crunchPng,Artifact proguardCfg) throws InterruptedException, RuleErrorException {
  AndroidResources resources=AndroidResources.from(ruleContext,""String_Node_Str"");
  ResourceFilterFactory resourceFilterFactory=ResourceFilterFactory.fromRuleContext(ruleContext);
  ResourceFilter resourceFilter=resourceFilterFactory.getResourceFilter(ruleContext,resourceDeps,resources);
  resources=resources.filterLocalResources(ruleContext,resourceFilter);
  resourceDeps=resourceDeps.filter(ruleContext,resourceFilter);
  ResourceContainer resourceContainer=ResourceContainer.builderFromRule(ruleContext).setApk(resourceApk).setManifest(getManifest()).setAssets(AndroidAssets.from(ruleContext)).setResources(resources).build();
  ResourceContainer processed=new AndroidResourcesProcessorBuilder(ruleContext).setLibrary(false).setApkOut(resourceContainer.getApk()).setResourceFilterFactory(resourceFilterFactory).setUncompressedExtensions(uncompressedExtensions).setCrunchPng(crunchPng).setJavaPackage(resourceContainer.getJavaPackage()).setDebug(ruleContext.getConfiguration().getCompilationMode() != CompilationMode.OPT).withPrimary(resourceContainer).withDependencies(resourceDeps).setProguardOut(proguardCfg).setApplicationId(manifestValues.get(""String_Node_Str"")).setVersionCode(manifestValues.get(""String_Node_Str"")).setVersionName(manifestValues.get(""String_Node_Str"")).setThrowOnResourceConflict(ruleContext.getConfiguration().getFragment(AndroidConfiguration.class).throwOnResourceConflict()).setPackageUnderTest(null).build(ruleContext);
  return new ResourceApk(resourceContainer.getApk(),processed.getJavaSourceJar(),processed.getJavaClassJar(),resourceDeps,processed,processed.getManifest(),proguardCfg,null);
}",0.9936271906532128
110579,"/** 
 * Packages up the manifest with resource and assets from the rule and dependent resources. 
 */
public ResourceApk packBinaryWithDataAndResources(RuleContext ruleContext,Artifact resourceApk,ResourceDependencies resourceDeps,@Nullable Artifact rTxt,ResourceFilterFactory resourceFilterFactory,List<String> uncompressedExtensions,boolean crunchPng,Artifact proguardCfg,@Nullable Artifact mainDexProguardCfg,boolean conditionalKeepRules,Artifact manifestOut,Artifact mergedResources,@Nullable Artifact dataBindingInfoZip,@Nullable Artifact featureOf,@Nullable Artifact featureAfter) throws InterruptedException, RuleErrorException {
  AndroidResources resources=AndroidResources.from(ruleContext,""String_Node_Str"");
  ResourceFilter resourceFilter=resourceFilterFactory.getResourceFilter(ruleContext,resourceDeps,resources);
  resources=resources.filterLocalResources(resourceFilter);
  resourceDeps=resourceDeps.filter(resourceFilter);
  ResourceContainer resourceContainer=ResourceContainer.builderFromRule(ruleContext).setAssets(AndroidAssets.from(ruleContext)).setResources(resources).setManifest(getManifest()).setRTxt(rTxt).setApk(resourceApk).build();
  AndroidConfiguration androidConfiguration=ruleContext.getConfiguration().getFragment(AndroidConfiguration.class);
  boolean skipParsingAction=targetAaptVersion == AndroidAaptVersion.AAPT2 && androidConfiguration.skipParsingAction();
  if (conditionalKeepRules && targetAaptVersion != AndroidAaptVersion.AAPT2) {
    throw ruleContext.throwWithRuleError(""String_Node_Str"");
  }
  ResourceContainer processed=new AndroidResourcesProcessorBuilder(ruleContext).setLibrary(false).setApkOut(resourceContainer.getApk()).setResourceFilterFactory(resourceFilterFactory).setUncompressedExtensions(uncompressedExtensions).setCrunchPng(crunchPng).setJavaPackage(resourceContainer.getJavaPackage()).setDebug(ruleContext.getConfiguration().getCompilationMode() != CompilationMode.OPT).setManifestOut(manifestOut).setMergedResourcesOut(mergedResources).withPrimary(resourceContainer).withDependencies(resourceDeps).setProguardOut(proguardCfg).setMainDexProguardOut(mainDexProguardCfg).conditionalKeepRules(conditionalKeepRules).setDataBindingInfoZip(dataBindingInfoZip).setApplicationId(manifestValues.get(""String_Node_Str"")).setVersionCode(manifestValues.get(""String_Node_Str"")).setVersionName(manifestValues.get(""String_Node_Str"")).setFeatureOf(featureOf).setFeatureAfter(featureAfter).setThrowOnResourceConflict(androidConfiguration.throwOnResourceConflict()).setUseCompiledResourcesForMerge(skipParsingAction).targetAaptVersion(targetAaptVersion).setRTxtOut(resourceContainer.getRTxt()).setSymbols(resourceContainer.getSymbols()).setSourceJarOut(resourceContainer.getJavaSourceJar()).build(ruleContext);
  return new ResourceApk(resourceContainer.getApk(),processed.getJavaSourceJar(),processed.getJavaClassJar(),resourceDeps,processed,processed.getManifest(),proguardCfg,mainDexProguardCfg);
}","/** 
 * Packages up the manifest with resource and assets from the rule and dependent resources. 
 */
public ResourceApk packBinaryWithDataAndResources(RuleContext ruleContext,Artifact resourceApk,ResourceDependencies resourceDeps,@Nullable Artifact rTxt,ResourceFilterFactory resourceFilterFactory,List<String> uncompressedExtensions,boolean crunchPng,Artifact proguardCfg,@Nullable Artifact mainDexProguardCfg,boolean conditionalKeepRules,Artifact manifestOut,Artifact mergedResources,@Nullable Artifact dataBindingInfoZip,@Nullable Artifact featureOf,@Nullable Artifact featureAfter) throws InterruptedException, RuleErrorException {
  AndroidResources resources=AndroidResources.from(ruleContext,""String_Node_Str"");
  ResourceFilter resourceFilter=resourceFilterFactory.getResourceFilter(ruleContext,resourceDeps,resources);
  resources=resources.filterLocalResources(ruleContext,resourceFilter);
  resourceDeps=resourceDeps.filter(ruleContext,resourceFilter);
  ResourceContainer resourceContainer=ResourceContainer.builderFromRule(ruleContext).setAssets(AndroidAssets.from(ruleContext)).setResources(resources).setManifest(getManifest()).setRTxt(rTxt).setApk(resourceApk).build();
  AndroidConfiguration androidConfiguration=ruleContext.getConfiguration().getFragment(AndroidConfiguration.class);
  boolean skipParsingAction=targetAaptVersion == AndroidAaptVersion.AAPT2 && androidConfiguration.skipParsingAction();
  if (conditionalKeepRules && targetAaptVersion != AndroidAaptVersion.AAPT2) {
    throw ruleContext.throwWithRuleError(""String_Node_Str"");
  }
  ResourceContainer processed=new AndroidResourcesProcessorBuilder(ruleContext).setLibrary(false).setApkOut(resourceContainer.getApk()).setResourceFilterFactory(resourceFilterFactory).setUncompressedExtensions(uncompressedExtensions).setCrunchPng(crunchPng).setJavaPackage(resourceContainer.getJavaPackage()).setDebug(ruleContext.getConfiguration().getCompilationMode() != CompilationMode.OPT).setManifestOut(manifestOut).setMergedResourcesOut(mergedResources).withPrimary(resourceContainer).withDependencies(resourceDeps).setProguardOut(proguardCfg).setMainDexProguardOut(mainDexProguardCfg).conditionalKeepRules(conditionalKeepRules).setDataBindingInfoZip(dataBindingInfoZip).setApplicationId(manifestValues.get(""String_Node_Str"")).setVersionCode(manifestValues.get(""String_Node_Str"")).setVersionName(manifestValues.get(""String_Node_Str"")).setFeatureOf(featureOf).setFeatureAfter(featureAfter).setThrowOnResourceConflict(androidConfiguration.throwOnResourceConflict()).setUseCompiledResourcesForMerge(skipParsingAction).targetAaptVersion(targetAaptVersion).setRTxtOut(resourceContainer.getRTxt()).setSymbols(resourceContainer.getSymbols()).setSourceJarOut(resourceContainer.getJavaSourceJar()).build(ruleContext);
  return new ResourceApk(resourceContainer.getApk(),processed.getJavaSourceJar(),processed.getJavaClassJar(),resourceDeps,processed,processed.getManifest(),proguardCfg,mainDexProguardCfg);
}",0.995945945945946
110580,"/** 
 * Returns a copy of this container with filtered resources, or the original if no resources should be filtered. The original container is unchanged.
 */
public ResourceContainer filter(ResourceFilter filter,boolean isDependency){
  Optional<AndroidResources> filteredResources=getResources().maybeFilter(filter,isDependency);
  if (!filteredResources.isPresent()) {
    return this;
  }
  return toBuilder().setResources(filteredResources.get()).build();
}","/** 
 * Returns a copy of this container with filtered resources, or the original if no resources should be filtered. The original container is unchanged.
 */
public ResourceContainer filter(RuleErrorConsumer errorConsumer,ResourceFilter filter,boolean isDependency) throws RuleErrorException {
  Optional<AndroidResources> filteredResources=getResources().maybeFilter(errorConsumer,filter,isDependency);
  if (!filteredResources.isPresent()) {
    return this;
  }
  return toBuilder().setResources(filteredResources.get()).build();
}",0.9187562688064193
110581,"/** 
 * Returns a copy of this instance with filtered resources. The original object is unchanged. 
 */
public ResourceDependencies filter(ResourceFilter resourceFilter){
  Optional<NestedSet<Artifact>> filteredResources=resourceFilter.maybeFilterDependencies(transitiveResources);
  if (!filteredResources.isPresent()) {
    return this;
  }
  return withResources(resourceFilter.filterDependencyContainers(transitiveResourceContainers),resourceFilter.filterDependencyContainers(directResourceContainers),filteredResources.get());
}","/** 
 * Returns a copy of this instance with filtered resources. The original object is unchanged. 
 */
public ResourceDependencies filter(RuleErrorConsumer errorConsumer,ResourceFilter resourceFilter) throws RuleErrorException {
  Optional<NestedSet<Artifact>> filteredResources=resourceFilter.maybeFilterDependencies(transitiveResources);
  if (!filteredResources.isPresent()) {
    return this;
  }
  return withResources(resourceFilter.filterDependencyContainers(errorConsumer,transitiveResourceContainers),resourceFilter.filterDependencyContainers(errorConsumer,directResourceContainers),filteredResources.get());
}",0.9245446660884648
110582,"public NestedSet<ResourceContainer> filterDependencyContainers(NestedSet<ResourceContainer> resourceContainers){
  if (isEmpty) {
    return resourceContainers;
  }
  NestedSetBuilder<ResourceContainer> builder=new NestedSetBuilder<>(resourceContainers.getOrder());
  for (  ResourceContainer container : resourceContainers) {
    builder.add(container.filter(this,true));
  }
  return builder.build();
}","public NestedSet<ResourceContainer> filterDependencyContainers(RuleErrorConsumer errorConsumer,NestedSet<ResourceContainer> resourceContainers) throws RuleErrorException {
  if (isEmpty) {
    return resourceContainers;
  }
  NestedSetBuilder<ResourceContainer> builder=new NestedSetBuilder<>(resourceContainers.getOrder());
  for (  ResourceContainer container : resourceContainers) {
    builder.add(container.filter(errorConsumer,this,true));
  }
  return builder.build();
}",0.9171396140749148
110583,"private void assertFilter(ImmutableList<Artifact> unfilteredResources,ImmutableList<Artifact> filteredResources,boolean isDependency) throws Exception {
  ImmutableList<PathFragment> unfilteredResourcesRoots=getResourceRoots(unfilteredResources);
  AndroidResources unfiltered=new AndroidResources(unfilteredResources,unfilteredResourcesRoots);
  ImmutableList.Builder<Artifact> filteredDepsBuilder=ImmutableList.builder();
  ResourceFilter fakeFilter=ResourceFilter.of(ImmutableSet.copyOf(filteredResources),filteredDepsBuilder::add);
  Optional<AndroidResources> filtered=unfiltered.maybeFilter(fakeFilter,isDependency);
  if (filteredResources.equals(unfilteredResources)) {
    assertThat(filtered.isPresent()).isFalse();
  }
 else {
    assertThat(filtered.get().getResources()).containsExactlyElementsIn(filteredResources).inOrder();
    assertThat(filtered.get().getResourceRoots()).containsExactlyElementsIn(getResourceRoots(filteredResources)).inOrder();
  }
  if (!isDependency) {
    assertThat(filteredDepsBuilder.build()).isEmpty();
  }
 else {
    assertThat(unfilteredResources).containsExactlyElementsIn(Iterables.concat(filteredDepsBuilder.build(),filteredResources));
  }
}","private void assertFilter(ImmutableList<Artifact> unfilteredResources,ImmutableList<Artifact> filteredResources,boolean isDependency) throws Exception {
  ImmutableList<PathFragment> unfilteredResourcesRoots=getResourceRoots(unfilteredResources);
  AndroidResources unfiltered=new AndroidResources(unfilteredResources,unfilteredResourcesRoots);
  ImmutableList.Builder<Artifact> filteredDepsBuilder=ImmutableList.builder();
  ResourceFilter fakeFilter=ResourceFilter.of(ImmutableSet.copyOf(filteredResources),filteredDepsBuilder::add);
  Optional<AndroidResources> filtered=unfiltered.maybeFilter(errorConsumer,fakeFilter,isDependency);
  if (filteredResources.equals(unfilteredResources)) {
    assertThat(filtered.isPresent()).isFalse();
  }
 else {
    assertThat(filtered.get().getResources()).containsExactlyElementsIn(filteredResources).inOrder();
    assertThat(filtered.get().getResourceRoots()).containsExactlyElementsIn(getResourceRoots(filteredResources)).inOrder();
  }
  if (!isDependency) {
    assertThat(filteredDepsBuilder.build()).isEmpty();
  }
 else {
    assertThat(unfilteredResources).containsExactlyElementsIn(Iterables.concat(filteredDepsBuilder.build(),filteredResources));
  }
}",0.9941569282136896
110584,"@Test public void testFilterLocalAndTransitive() throws Exception {
  Artifact localResourceToKeep=getResource(""String_Node_Str"");
  Artifact localResourceToDiscard=getResource(""String_Node_Str"");
  Artifact directResourceToKeep=getResource(""String_Node_Str"");
  Artifact directResourceToDiscard=getResource(""String_Node_Str"");
  Artifact transitiveResourceToKeep=getResource(""String_Node_Str"");
  Artifact transitiveResourceToDiscard=getResource(""String_Node_Str"");
  AndroidResources localResources=AndroidResources.forResources(errorConsumer,ImmutableList.of(localResourceToKeep,localResourceToDiscard),""String_Node_Str"");
  ResourceDependencies resourceDependencies=ResourceDependencies.empty().withResources(getResourceContainers(ImmutableList.of(transitiveResourceToDiscard),ImmutableList.of(transitiveResourceToKeep)),getResourceContainers(ImmutableList.of(directResourceToDiscard),ImmutableList.of(directResourceToKeep)),new NestedSetBuilder<Artifact>(Order.NAIVE_LINK_ORDER).add(directResourceToDiscard).add(directResourceToKeep).addTransitive(NestedSetBuilder.create(Order.NAIVE_LINK_ORDER,transitiveResourceToDiscard,transitiveResourceToKeep)).build());
  ResourceFilterFactory resourceFilterFactory=makeResourceFilter(""String_Node_Str"",""String_Node_Str"",true);
  ResourceFilter filter=resourceFilterFactory.getResourceFilter(errorConsumer,resourceDependencies,localResources);
  assertThat(localResources.filterLocalResources(filter).getResources()).containsExactly(localResourceToKeep);
  ResourceDependencies filteredResourceDeps=resourceDependencies.filter(filter);
  assertThat(resourceDependencies.getTransitiveResources()).containsAllOf(directResourceToKeep,transitiveResourceToKeep).inOrder();
  assertThat(filteredResourceDeps.getTransitiveResources()).containsExactly(directResourceToKeep,transitiveResourceToKeep).inOrder();
  List<ResourceContainer> directContainers=filteredResourceDeps.getDirectResourceContainers().toList();
  assertThat(directContainers).hasSize(2);
  AndroidResources directToDiscard=directContainers.get(0).getResources();
  assertThat(directToDiscard.getResources()).isEmpty();
  assertThat(directToDiscard.getResourceRoots()).isEmpty();
  AndroidResources directToKeep=directContainers.get(1).getResources();
  assertThat(directToKeep.getResources()).containsExactly(directResourceToKeep);
  assertThat(directToKeep.getResourceRoots()).containsExactly(directResourceToKeep.getExecPath().getParentDirectory().getParentDirectory());
  List<ResourceContainer> transitiveContainers=filteredResourceDeps.getTransitiveResourceContainers().toList();
  assertThat(transitiveContainers).hasSize(2);
  AndroidResources transitiveToDiscard=transitiveContainers.get(0).getResources();
  assertThat(transitiveToDiscard.getResources()).isEmpty();
  assertThat(transitiveToDiscard.getResourceRoots()).isEmpty();
  AndroidResources transitiveToKeep=transitiveContainers.get(1).getResources();
  assertThat(transitiveToKeep.getResources()).containsExactly(transitiveResourceToKeep);
  assertThat(transitiveToKeep.getResourceRoots()).containsExactly(transitiveResourceToKeep.getExecPath().getParentDirectory().getParentDirectory());
  assertThat(resourceFilterFactory.getResourcesToIgnoreInExecution()).containsExactly(""String_Node_Str"",""String_Node_Str"");
}","@Test public void testFilterLocalAndTransitive() throws Exception {
  Artifact localResourceToKeep=getResource(""String_Node_Str"");
  Artifact localResourceToDiscard=getResource(""String_Node_Str"");
  Artifact directResourceToKeep=getResource(""String_Node_Str"");
  Artifact directResourceToDiscard=getResource(""String_Node_Str"");
  Artifact transitiveResourceToKeep=getResource(""String_Node_Str"");
  Artifact transitiveResourceToDiscard=getResource(""String_Node_Str"");
  AndroidResources localResources=AndroidResources.forResources(errorConsumer,ImmutableList.of(localResourceToKeep,localResourceToDiscard),""String_Node_Str"");
  ResourceDependencies resourceDependencies=ResourceDependencies.empty().withResources(getResourceContainers(ImmutableList.of(transitiveResourceToDiscard),ImmutableList.of(transitiveResourceToKeep)),getResourceContainers(ImmutableList.of(directResourceToDiscard),ImmutableList.of(directResourceToKeep)),new NestedSetBuilder<Artifact>(Order.NAIVE_LINK_ORDER).add(directResourceToDiscard).add(directResourceToKeep).addTransitive(NestedSetBuilder.create(Order.NAIVE_LINK_ORDER,transitiveResourceToDiscard,transitiveResourceToKeep)).build());
  ResourceFilterFactory resourceFilterFactory=makeResourceFilter(""String_Node_Str"",""String_Node_Str"",true);
  ResourceFilter filter=resourceFilterFactory.getResourceFilter(errorConsumer,resourceDependencies,localResources);
  assertThat(localResources.filterLocalResources(errorConsumer,filter).getResources()).containsExactly(localResourceToKeep);
  ResourceDependencies filteredResourceDeps=resourceDependencies.filter(errorConsumer,filter);
  assertThat(resourceDependencies.getTransitiveResources()).containsAllOf(directResourceToKeep,transitiveResourceToKeep).inOrder();
  assertThat(filteredResourceDeps.getTransitiveResources()).containsExactly(directResourceToKeep,transitiveResourceToKeep).inOrder();
  List<ResourceContainer> directContainers=filteredResourceDeps.getDirectResourceContainers().toList();
  assertThat(directContainers).hasSize(2);
  AndroidResources directToDiscard=directContainers.get(0).getResources();
  assertThat(directToDiscard.getResources()).isEmpty();
  assertThat(directToDiscard.getResourceRoots()).isEmpty();
  AndroidResources directToKeep=directContainers.get(1).getResources();
  assertThat(directToKeep.getResources()).containsExactly(directResourceToKeep);
  assertThat(directToKeep.getResourceRoots()).containsExactly(directResourceToKeep.getExecPath().getParentDirectory().getParentDirectory());
  List<ResourceContainer> transitiveContainers=filteredResourceDeps.getTransitiveResourceContainers().toList();
  assertThat(transitiveContainers).hasSize(2);
  AndroidResources transitiveToDiscard=transitiveContainers.get(0).getResources();
  assertThat(transitiveToDiscard.getResources()).isEmpty();
  assertThat(transitiveToDiscard.getResourceRoots()).isEmpty();
  AndroidResources transitiveToKeep=transitiveContainers.get(1).getResources();
  assertThat(transitiveToKeep.getResources()).containsExactly(transitiveResourceToKeep);
  assertThat(transitiveToKeep.getResourceRoots()).containsExactly(transitiveResourceToKeep.getExecPath().getParentDirectory().getParentDirectory());
  assertThat(resourceFilterFactory.getResourcesToIgnoreInExecution()).containsExactly(""String_Node_Str"",""String_Node_Str"");
}",0.9957601453664444
110585,"private ImmutableList<Artifact> doFilter(ResourceFilterFactory resourceFilterFactory,ImmutableList<Artifact> artifacts) throws RuleErrorException {
  AndroidResources localResources=AndroidResources.forResources(errorConsumer,artifacts,""String_Node_Str"");
  ResourceDependencies resourceDeps=ResourceDependencies.empty();
  ResourceFilter filter=resourceFilterFactory.getResourceFilter(errorConsumer,resourceDeps,localResources);
  assertThat(resourceDeps.filter(filter)).isSameAs(resourceDeps);
  return localResources.filterLocalResources(filter).getResources();
}","private ImmutableList<Artifact> doFilter(ResourceFilterFactory resourceFilterFactory,ImmutableList<Artifact> artifacts) throws RuleErrorException {
  AndroidResources localResources=AndroidResources.forResources(errorConsumer,artifacts,""String_Node_Str"");
  ResourceDependencies resourceDeps=ResourceDependencies.empty();
  ResourceFilter filter=resourceFilterFactory.getResourceFilter(errorConsumer,resourceDeps,localResources);
  assertThat(resourceDeps.filter(errorConsumer,filter)).isSameAs(resourceDeps);
  return localResources.filterLocalResources(errorConsumer,filter).getResources();
}",0.9758620689655172
110586,"private J2ObjcMappingFileProvider createJ2ObjcProtoCompileActions(ConfiguredTarget base,RuleContext ruleContext,Iterable<Artifact> filteredProtoSources,J2ObjcSource j2ObjcSource){
  Iterable<Artifact> outputHeaderMappingFiles=ProtoCommon.getGeneratedOutputs(ruleContext,ImmutableList.copyOf(filteredProtoSources),""String_Node_Str"");
  Iterable<Artifact> outputClassMappingFiles=ProtoCommon.getGeneratedOutputs(ruleContext,ImmutableList.copyOf(filteredProtoSources),""String_Node_Str"");
  ImmutableList<Artifact> outputs=ImmutableList.<Artifact>builder().addAll(j2ObjcSource.getObjcSrcs()).addAll(j2ObjcSource.getObjcHdrs()).addAll(outputHeaderMappingFiles).addAll(outputClassMappingFiles).build();
  String langPluginParameter=String.format(""String_Node_Str"",Joiner.on(',').join(J2OBJC_PLUGIN_PARAMS),ruleContext.getConfiguration().getGenfilesFragment().getPathString());
  SupportData supportData=base.getProvider(ProtoSupportDataProvider.class).getSupportData();
  ProtoCompileActionBuilder actionBuilder=new ProtoCompileActionBuilder(ruleContext,supportData,""String_Node_Str"",""String_Node_Str"",outputs).setLangPluginName(""String_Node_Str"").setLangPluginParameter(langPluginParameter).allowServices(shouldAllowProtoServices(ruleContext));
  ruleContext.registerAction(actionBuilder.build());
  return new J2ObjcMappingFileProvider(NestedSetBuilder.<Artifact>stableOrder().addAll(outputHeaderMappingFiles).build(),NestedSetBuilder.<Artifact>stableOrder().addAll(outputClassMappingFiles).build(),NestedSetBuilder.<Artifact>stableOrder().build(),NestedSetBuilder.<Artifact>stableOrder().build());
}","private J2ObjcMappingFileProvider createJ2ObjcProtoCompileActions(ConfiguredTarget base,RuleContext ruleContext,Iterable<Artifact> filteredProtoSources,J2ObjcSource j2ObjcSource){
  Iterable<Artifact> outputHeaderMappingFiles=ProtoCommon.getGeneratedOutputs(ruleContext,ImmutableList.copyOf(filteredProtoSources),""String_Node_Str"");
  Iterable<Artifact> outputClassMappingFiles=ProtoCommon.getGeneratedOutputs(ruleContext,ImmutableList.copyOf(filteredProtoSources),""String_Node_Str"");
  ImmutableList<Artifact> outputs=ImmutableList.<Artifact>builder().addAll(j2ObjcSource.getObjcSrcs()).addAll(j2ObjcSource.getObjcHdrs()).addAll(outputHeaderMappingFiles).addAll(outputClassMappingFiles).build();
  String genfilesPath=getProtoOutputRoot(ruleContext).getPathString();
  String langPluginParameter=String.format(""String_Node_Str"",Joiner.on(',').join(J2OBJC_PLUGIN_PARAMS),genfilesPath);
  SupportData supportData=base.getProvider(ProtoSupportDataProvider.class).getSupportData();
  ProtoCompileActionBuilder actionBuilder=new ProtoCompileActionBuilder(ruleContext,supportData,""String_Node_Str"",""String_Node_Str"",outputs).setLangPluginName(""String_Node_Str"").setLangPluginParameter(langPluginParameter).allowServices(shouldAllowProtoServices(ruleContext));
  ruleContext.registerAction(actionBuilder.build());
  return new J2ObjcMappingFileProvider(NestedSetBuilder.<Artifact>stableOrder().addAll(outputHeaderMappingFiles).build(),NestedSetBuilder.<Artifact>stableOrder().addAll(outputClassMappingFiles).build(),NestedSetBuilder.<Artifact>stableOrder().build(),NestedSetBuilder.<Artifact>stableOrder().build());
}",0.9554100405363268
110587,"private static J2ObjcSource protoJ2ObjcSource(RuleContext ruleContext,ImmutableList<Artifact> protoSources){
  PathFragment objcFileRootExecPath=ruleContext.getConfiguration().getGenfilesDirectory(ruleContext.getRule().getRepository()).getExecPath();
  Iterable<PathFragment> headerSearchPaths=J2ObjcLibrary.j2objcSourceHeaderSearchPaths(ruleContext,objcFileRootExecPath,protoSources);
  return new J2ObjcSource(ruleContext.getTarget().getLabel(),ProtoCommon.getGeneratedOutputs(ruleContext,protoSources,""String_Node_Str""),ProtoCommon.getGeneratedOutputs(ruleContext,protoSources,""String_Node_Str""),objcFileRootExecPath,SourceType.PROTO,headerSearchPaths);
}","private static J2ObjcSource protoJ2ObjcSource(RuleContext ruleContext,ImmutableList<Artifact> protoSources){
  PathFragment objcFileRootExecPath=getProtoOutputRoot(ruleContext);
  Iterable<PathFragment> headerSearchPaths=J2ObjcLibrary.j2objcSourceHeaderSearchPaths(ruleContext,objcFileRootExecPath,protoSources);
  return new J2ObjcSource(ruleContext.getTarget().getLabel(),ProtoCommon.getGeneratedOutputs(ruleContext,protoSources,""String_Node_Str""),ProtoCommon.getGeneratedOutputs(ruleContext,protoSources,""String_Node_Str""),objcFileRootExecPath,SourceType.PROTO,headerSearchPaths);
}",0.8962188254223652
110588,"@Test public void outputDirectoryForProtoCompileAction_externalRepos() throws Exception {
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  String existingWorkspace=new String(FileSystemUtils.readContentAsLatin1(rootDirectory.getRelative(""String_Node_Str"")));
  scratch.overwriteFile(""String_Node_Str"",""String_Node_Str"",existingWorkspace);
  invalidatePackages();
  Artifact hFile=getFirstArtifactEndingWith(getFilesToBuild(getConfiguredTarget(""String_Node_Str"")),""String_Node_Str"");
  SpawnAction protoCompileAction=getGeneratingSpawnAction(hFile);
  assertThat(protoCompileAction.getArguments()).contains(String.format(""String_Node_Str"",getTargetConfiguration().getGenfilesFragment().toString()));
}","@Test public void outputDirectoryForProtoCompileAction_externalRepos() throws Exception {
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  String existingWorkspace=new String(FileSystemUtils.readContentAsLatin1(rootDirectory.getRelative(""String_Node_Str"")));
  scratch.overwriteFile(""String_Node_Str"",""String_Node_Str"",existingWorkspace);
  invalidatePackages();
  ConfiguredTarget target=getConfiguredTarget(""String_Node_Str"");
  Artifact hFile=getFirstArtifactEndingWith(getFilesToBuild(target),""String_Node_Str"");
  SpawnAction protoCompileAction=getGeneratingSpawnAction(hFile);
  assertThat(protoCompileAction.getArguments()).contains(String.format(""String_Node_Str"",getTargetConfiguration().getGenfilesFragment().toString()));
  Artifact headerFile=getGenfilesArtifactWithNoOwner(""String_Node_Str"");
  CcCompilationInfo ccCompilationInfo=target.get(CcCompilationInfo.PROVIDER);
  assertThat(ccCompilationInfo.getDeclaredIncludeSrcs()).containsExactly(headerFile);
}",0.8168865435356201
110589,"private int fromString(String string,Location loc,int base) throws EvalException {
  String prefix=getIntegerPrefix(string);
  String digits;
  if (prefix == null) {
    digits=string;
    if (base == 0) {
      if (string.length() > 1 && string.startsWith(""String_Node_Str"")) {
        throw new EvalException(loc,Printer.format(""String_Node_Str"",string));
      }
      base=10;
    }
  }
 else {
    digits=string.substring(prefix.length());
    int expectedBase=intPrefixes.get(prefix);
    if (base == 0) {
      base=expectedBase;
    }
 else     if (base != expectedBase) {
      throw new EvalException(loc,Printer.format(""String_Node_Str"",base,string));
    }
  }
  if (base < 2 || base > 36) {
    throw new EvalException(loc,""String_Node_Str"");
  }
  try {
    return Integer.parseInt(digits,base);
  }
 catch (  NumberFormatException e) {
    throw new EvalException(loc,Printer.format(""String_Node_Str"",base,string));
  }
}","private int fromString(String string,Location loc,int base) throws EvalException {
  String stringForErrors=string;
  boolean isNegative=false;
  if (string.isEmpty()) {
    throw new EvalException(loc,Printer.format(""String_Node_Str""));
  }
  char c=string.charAt(0);
  if (c == '+') {
    string=string.substring(1);
  }
 else   if (c == '-') {
    string=string.substring(1);
    isNegative=true;
  }
  String prefix=getIntegerPrefix(string);
  String digits;
  if (prefix == null) {
    digits=string;
    if (base == 0) {
      if (string.length() > 1 && string.startsWith(""String_Node_Str"")) {
        throw new EvalException(loc,Printer.format(""String_Node_Str"",stringForErrors));
      }
      base=10;
    }
  }
 else {
    digits=string.substring(prefix.length());
    int expectedBase=intPrefixes.get(prefix);
    if (base == 0) {
      base=expectedBase;
    }
 else     if (base != expectedBase) {
      throw new EvalException(loc,Printer.format(""String_Node_Str"",base,stringForErrors));
    }
  }
  if (base < 2 || base > 36) {
    throw new EvalException(loc,""String_Node_Str"");
  }
  try {
    String parseable=isNegative ? ""String_Node_Str"" + digits : digits;
    return Integer.parseInt(parseable,base);
  }
 catch (  NumberFormatException|ArithmeticException e) {
    throw new EvalException(loc,Printer.format(""String_Node_Str"",base,stringForErrors));
  }
}",0.8038029386343993
110590,"@Override public String getDetailMessage(String messagePrefix,String message,boolean catastrophe,boolean forciblyRunRemotely){
  TerminationStatus status=new TerminationStatus(exitCode(),status() == Status.TIMEOUT);
  String reason=""String_Node_Str"" + status.toShortString() + ""String_Node_Str"";
  String explanation=status.exited() ? ""String_Node_Str"" : ""String_Node_Str"" + message;
  if (!status().isConsideredUserError()) {
    String errorDetail=status().name().toLowerCase(Locale.US).replace('_',' ');
    explanation+=""String_Node_Str"" + errorDetail;
  }
  if (status() == Status.TIMEOUT) {
    Preconditions.checkState(getWallTime().isPresent(),""String_Node_Str"");
    explanation+=String.format(""String_Node_Str"",getWallTime().get().toMillis() / 1000.0);
  }
 else   if (status() == Status.OUT_OF_MEMORY) {
    explanation+=""String_Node_Str"";
  }
  if (status() != Status.TIMEOUT && forciblyRunRemotely) {
    explanation+=""String_Node_Str"" + ""String_Node_Str"";
  }
  return messagePrefix + ""String_Node_Str"" + reason+ explanation;
}","@Override public String getDetailMessage(String messagePrefix,String message,boolean catastrophe,boolean forciblyRunRemotely){
  TerminationStatus status=new TerminationStatus(exitCode(),status() == Status.TIMEOUT);
  String reason=""String_Node_Str"" + status.toShortString() + ""String_Node_Str"";
  String explanation=status.exited() ? ""String_Node_Str"" : ""String_Node_Str"" + message;
  if (!status().isConsideredUserError()) {
    String errorDetail=status().name().toLowerCase(Locale.US).replace('_',' ');
    explanation+=""String_Node_Str"" + errorDetail;
  }
  if (status() == Status.TIMEOUT) {
    if (getWallTime().isPresent()) {
      explanation+=String.format(""String_Node_Str"",getWallTime().get().toMillis() / 1000.0);
    }
 else {
      explanation+=""String_Node_Str"";
    }
  }
 else   if (status() == Status.OUT_OF_MEMORY) {
    explanation+=""String_Node_Str"";
  }
  if (status() != Status.TIMEOUT && forciblyRunRemotely) {
    explanation+=""String_Node_Str"" + ""String_Node_Str"";
  }
  return messagePrefix + ""String_Node_Str"" + reason+ explanation;
}",0.9249049429657796
110591,"@Override public MethodVisitor visitMethod(int access,String name,String desc,String signature,String[] exceptions){
  members.add(MemberInfo.create(internalName,name,desc));
  return null;
}","@Override public MethodVisitor visitMethod(int access,String name,String desc,String signature,String[] exceptions){
  members.add(MemberInfo.create(name,desc));
  return null;
}",0.964769647696477
110592,"@Override public FieldVisitor visitField(int access,String name,String desc,String signature,Object value){
  members.add(MemberInfo.create(internalName,name,desc));
  return null;
}","@Override public FieldVisitor visitField(int access,String name,String desc,String signature,Object value){
  members.add(MemberInfo.create(name,desc));
  return null;
}",0.9629629629629628
110593,"public static MemberInfo create(String owner,String memberName,String descriptor){
  checkArgument(!Strings.isNullOrEmpty(owner),""String_Node_Str"",owner);
  checkArgument(!Strings.isNullOrEmpty(memberName),""String_Node_Str"",memberName);
  checkArgument(!Strings.isNullOrEmpty(descriptor),""String_Node_Str"",descriptor);
  return new AutoValue_ClassInfo_MemberInfo(owner,memberName,descriptor);
}","public static MemberInfo create(String memberName,String descriptor){
  checkArgument(!Strings.isNullOrEmpty(memberName),""String_Node_Str"",memberName);
  checkArgument(!Strings.isNullOrEmpty(descriptor),""String_Node_Str"",descriptor);
  return new AutoValue_ClassInfo_MemberInfo(memberName,descriptor);
}",0.7230989956958394
110594,"private AbstractClassEntryState checkInternalName(String internalName){
  AbstractClassEntryState state=classCache.getClassState(internalName);
  if (state.isMissingState()) {
    resultCollector.addMissingOrIncompleteClass(internalName,state);
  }
 else   if (state.isIncompleteState()) {
    String missingAncestor=state.asIncompleteState().getMissingAncestor();
    AbstractClassEntryState ancestorState=classCache.getClassState(missingAncestor);
    checkState(ancestorState.isMissingState(),""String_Node_Str"",ancestorState);
    resultCollector.addMissingOrIncompleteClass(missingAncestor,ancestorState);
    resultCollector.addMissingOrIncompleteClass(internalName,state);
  }
  return state;
}","private AbstractClassEntryState checkInternalName(String internalName){
  checkArgument(internalName.length() > 0 && Character.isJavaIdentifierStart(internalName.charAt(0)),""String_Node_Str"",internalName);
  AbstractClassEntryState state=classCache.getClassState(internalName);
  if (state.isMissingState()) {
    resultCollector.addMissingOrIncompleteClass(internalName,state);
  }
 else   if (state.isIncompleteState()) {
    String missingAncestor=state.asIncompleteState().getMissingAncestor();
    AbstractClassEntryState ancestorState=classCache.getClassState(missingAncestor);
    checkState(ancestorState.isMissingState(),""String_Node_Str"",ancestorState);
    resultCollector.addMissingOrIncompleteClass(missingAncestor,ancestorState);
    resultCollector.addMissingOrIncompleteClass(internalName,state);
  }
  return state;
}",0.9126466753585396
110595,"@Override public void visitTypeInsn(int opcode,String type){
  checkInternalName(type);
  super.visitTypeInsn(opcode,type);
}","@Override public void visitTypeInsn(int opcode,String type){
  checkInternalNameOrArrayDescriptor(type);
  super.visitTypeInsn(opcode,type);
}",0.9363295880149812
110596,"private void checkMember(String owner,String name,String desc){
  checkDescriptor(desc);
  AbstractClassEntryState state=checkInternalName(owner);
  Optional<ClassInfo> classInfo=state.classInfo();
  if (!classInfo.isPresent()) {
    checkState(state.isMissingState(),""String_Node_Str"",state);
    return;
  }
  MemberInfo member=MemberInfo.create(owner,name,desc);
  if (!classInfo.get().containsMember(member)) {
    resultCollector.addMissingMember(member);
  }
}","private void checkMember(String owner,String name,String desc){
  try {
    if (checkInternalNameOrArrayDescriptor(owner)) {
      return;
    }
    checkDescriptor(desc);
    AbstractClassEntryState state=checkInternalName(owner);
    Optional<ClassInfo> classInfo=state.classInfo();
    if (!classInfo.isPresent()) {
      checkState(state.isMissingState(),""String_Node_Str"",state);
      return;
    }
    MemberInfo member=MemberInfo.create(name,desc);
    if (!classInfo.get().containsMember(member)) {
      resultCollector.addMissingMember(owner,member);
    }
  }
 catch (  RuntimeException e) {
    System.err.printf(""String_Node_Str"",owner,name,desc);
    throw e;
  }
}",0.643979057591623
110597,"public String computeResultOutput() throws IOException {
  StringBuilder builder=new StringBuilder();
  ImmutableList<String> missingClasses=resultCollector.getSortedMissingClassInternalNames();
  for (  String missing : missingClasses) {
    builder.append(""String_Node_Str"").append(missing.replace('/','.')).append('\n');
  }
  ImmutableList<IncompleteState> incompleteClasses=resultCollector.getSortedIncompleteClasses();
  for (  IncompleteState incomplete : incompleteClasses) {
    builder.append(""String_Node_Str"").append(incomplete.classInfo().get().internalName().replace('/','.')).append('\n');
    ImmutableList<String> failurePath=incomplete.getResolutionFailurePath();
    checkState(!failurePath.isEmpty(),""String_Node_Str"",failurePath);
    builder.append(INDENT).append(""String_Node_Str"").append(failurePath.get(failurePath.size() - 1).replace('/','.')).append('\n');
    builder.append(INDENT).append(""String_Node_Str"").append(failurePath.stream().map(internalName -> internalName.replace('/','.')).collect(Collectors.joining(""String_Node_Str""))).append('\n');
  }
  ImmutableList<MemberInfo> missingMembers=resultCollector.getSortedMissingMembers();
  for (  MemberInfo missing : missingMembers) {
    builder.append(""String_Node_Str"").append(missing.memberName()).append(""String_Node_Str"").append(missing.owner().replace('/','.')).append(""String_Node_Str"").append(missing.memberName()).append(""String_Node_Str"").append(missing.descriptor()).append('\n');
  }
  if (missingClasses.size() + incompleteClasses.size() + missingMembers.size() != 0) {
    builder.append(""String_Node_Str"").append(""String_Node_Str"").append(missingClasses.size()).append('\n').append(""String_Node_Str"").append(incompleteClasses.size()).append('\n').append(""String_Node_Str"").append(missingMembers.size());
  }
  return builder.toString();
}","public String computeResultOutput() throws IOException {
  StringBuilder builder=new StringBuilder();
  ImmutableList<String> missingClasses=resultCollector.getSortedMissingClassInternalNames();
  for (  String missing : missingClasses) {
    builder.append(""String_Node_Str"").append(missing.replace('/','.')).append('\n');
  }
  ImmutableList<IncompleteState> incompleteClasses=resultCollector.getSortedIncompleteClasses();
  for (  IncompleteState incomplete : incompleteClasses) {
    builder.append(""String_Node_Str"").append(incomplete.classInfo().get().internalName().replace('/','.')).append('\n');
    ImmutableList<String> failurePath=incomplete.getResolutionFailurePath();
    checkState(!failurePath.isEmpty(),""String_Node_Str"",failurePath);
    builder.append(INDENT).append(""String_Node_Str"").append(failurePath.get(failurePath.size() - 1).replace('/','.')).append('\n');
    builder.append(INDENT).append(""String_Node_Str"").append(failurePath.stream().map(internalName -> internalName.replace('/','.')).collect(Collectors.joining(""String_Node_Str""))).append('\n');
  }
  ImmutableList<MissingMember> missingMembers=resultCollector.getSortedMissingMembers();
  for (  MissingMember missing : missingMembers) {
    builder.append(""String_Node_Str"").append(missing.memberName()).append(""String_Node_Str"").append(missing.owner().replace('/','.')).append(""String_Node_Str"").append(missing.memberName()).append(""String_Node_Str"").append(missing.descriptor()).append('\n');
  }
  if (missingClasses.size() + incompleteClasses.size() + missingMembers.size() != 0) {
    builder.append(""String_Node_Str"").append(""String_Node_Str"").append(missingClasses.size()).append('\n').append(""String_Node_Str"").append(incompleteClasses.size()).append('\n').append(""String_Node_Str"").append(missingMembers.size());
  }
  return builder.toString();
}",0.9526659412404788
110598,"/** 
 * Checks for dependency problems in the given input jars agains the classpath.
 * @return {@literal true} for no problems, {@literal false} otherwise.
 */
public boolean check() throws IOException {
  for (  Path path : inputJars) {
    try (ZipFile jarFile=new ZipFile(path.toFile())){
      jarFile.stream().forEach(entry -> {
        String name=entry.getName();
        if (!name.endsWith(""String_Node_Str"")) {
          return;
        }
        try (InputStream inputStream=jarFile.getInputStream(entry)){
          ClassReader reader=new ClassReader(inputStream);
          DepsCheckerClassVisitor checker=new DepsCheckerClassVisitor(classCache,resultCollector);
          reader.accept(checker,ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);
        }
 catch (        IOException e) {
          throw new IOError(e);
        }
      }
);
    }
   }
  return resultCollector.isEmpty();
}","/** 
 * Checks for dependency problems in the given input jars agains the classpath.
 * @return {@literal true} for no problems, {@literal false} otherwise.
 */
public boolean check() throws IOException {
  for (  Path path : inputJars) {
    try (ZipFile jarFile=new ZipFile(path.toFile())){
      jarFile.stream().forEach(entry -> {
        String name=entry.getName();
        if (!name.endsWith(""String_Node_Str"")) {
          return;
        }
        try (InputStream inputStream=jarFile.getInputStream(entry)){
          ClassReader reader=new ClassReader(inputStream);
          DepsCheckerClassVisitor checker=new DepsCheckerClassVisitor(classCache,resultCollector);
          reader.accept(checker,ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);
        }
 catch (        IOException e) {
          throw new IOError(e);
        }
catch (        RuntimeException e) {
          System.err.printf(""String_Node_Str"" + ""String_Node_Str"",name,path);
          throw e;
        }
      }
);
    }
   }
  return resultCollector.isEmpty();
}",0.926153846153846
110599,"public ImmutableList<MemberInfo> getSortedMissingMembers(){
  return ImmutableList.sortedCopyOf(missingMembers);
}","public ImmutableList<MissingMember> getSortedMissingMembers(){
  return ImmutableList.sortedCopyOf(missingMembers);
}",0.9523809523809524
110600,"public void addMissingMember(MemberInfo member){
  missingMembers.add(member);
}","public void addMissingMember(String owner,MemberInfo member){
  missingMembers.add(MissingMember.create(owner,member));
}",0.7960199004975125
110601,"@Test public void testMemberInfo(){
  MemberInfo memberInfo=MemberInfo.create(JAVA_LANG_OBJECT,""String_Node_Str"",""String_Node_Str"");
  assertThat(memberInfo.memberName()).isEqualTo(""String_Node_Str"");
  assertThat(memberInfo.descriptor()).isEqualTo(""String_Node_Str"");
  assertThat(memberInfo).isEqualTo(MemberInfo.create(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  assertThat(hashCodeMethod).isEqualTo(MemberInfo.create(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  assertThat(sizeMethod).isEqualTo(MemberInfo.create(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","@Test public void testMemberInfo(){
  MemberInfo memberInfo=MemberInfo.create(""String_Node_Str"",""String_Node_Str"");
  assertThat(memberInfo.memberName()).isEqualTo(""String_Node_Str"");
  assertThat(memberInfo.descriptor()).isEqualTo(""String_Node_Str"");
  assertThat(memberInfo).isEqualTo(MemberInfo.create(""String_Node_Str"",""String_Node_Str""));
  assertThat(hashCodeMethod).isEqualTo(MemberInfo.create(""String_Node_Str"",""String_Node_Str""));
  assertThat(sizeMethod).isEqualTo(MemberInfo.create(""String_Node_Str"",""String_Node_Str""));
}",0.9375549692172384
110602,"@Test public void testContainsMember(){
  ClassInfo parent=objectClass;
  ClassInfo child=listClass;
  assertThat(child.superClasses()).contains(parent);
  assertThat(parent.containsMember(MemberInfo.create(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""))).isTrue();
  assertThat(parent.containsMember(MemberInfo.create(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""))).isFalse();
  assertThat(parent.containsMember(MemberInfo.create(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""))).isFalse();
  assertThat(child.containsMember(MemberInfo.create(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""))).isTrue();
  assertThat(child.containsMember(MemberInfo.create(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""))).isTrue();
}","@Test public void testContainsMember(){
  ClassInfo parent=objectClass;
  ClassInfo child=listClass;
  assertThat(child.superClasses()).contains(parent);
  assertThat(parent.containsMember(MemberInfo.create(""String_Node_Str"",""String_Node_Str""))).isTrue();
  assertThat(parent.containsMember(MemberInfo.create(""String_Node_Str"",""String_Node_Str""))).isFalse();
  assertThat(parent.containsMember(MemberInfo.create(""String_Node_Str"",""String_Node_Str""))).isFalse();
  assertThat(child.containsMember(MemberInfo.create(""String_Node_Str"",""String_Node_Str""))).isTrue();
  assertThat(child.containsMember(MemberInfo.create(""String_Node_Str"",""String_Node_Str""))).isTrue();
}",0.5225352112676056
110603,"@Test public void testClassInfoCorrectlySet(){
  assertThat(objectClass.internalName()).isEqualTo(""String_Node_Str"");
  assertThat(objectClass.declaredMembers()).containsExactly(MemberInfo.create(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")).inOrder();
  assertThat(objectClass.containsMember(MemberInfo.create(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""))).isTrue();
  assertThat(listClass.internalName()).isEqualTo(""String_Node_Str"");
  assertThat(listClass.declaredMembers()).containsExactly(sizeMethod);
  assertThat(listClass.containsMember(hashCodeMethod)).isTrue();
}","@Test public void testClassInfoCorrectlySet(){
  assertThat(objectClass.internalName()).isEqualTo(""String_Node_Str"");
  assertThat(objectClass.declaredMembers()).containsExactly(MemberInfo.create(""String_Node_Str"",""String_Node_Str"")).inOrder();
  assertThat(objectClass.containsMember(MemberInfo.create(""String_Node_Str"",""String_Node_Str""))).isTrue();
  assertThat(listClass.internalName()).isEqualTo(""String_Node_Str"");
  assertThat(listClass.declaredMembers()).containsExactly(sizeMethod);
  assertThat(listClass.containsMember(hashCodeMethod)).isTrue();
}",0.96875
110604,"private ResultCollector getResultCollector(Path... classpath) throws IOException {
  ImmutableList<String> clientClasses=ImmutableList.of(PACKAGE_NAME + ""String_Node_Str"",PACKAGE_NAME + ""String_Node_Str"");
  ResultCollector resultCollector=new ResultCollector();
  try (ClassCache cache=new ClassCache(ImmutableList.copyOf(classpath));ZipFile zipFile=new ZipFile(clientJar.toFile())){
    AbstractClassEntryState state=cache.getClassState(""String_Node_Str"");
    System.out.println(state);
    for (    String clientClass : clientClasses) {
      ZipEntry entry=zipFile.getEntry(clientClass + ""String_Node_Str"");
      try (InputStream classStream=zipFile.getInputStream(entry)){
        ClassReader reader=new ClassReader(classStream);
        DepsCheckerClassVisitor checker=new DepsCheckerClassVisitor(cache,resultCollector);
        reader.accept(checker,ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);
      }
     }
  }
   return resultCollector;
}","private ResultCollector getResultCollector(Path... classpath) throws IOException {
  ImmutableList<String> clientClasses=ImmutableList.of(PACKAGE_NAME + ""String_Node_Str"",PACKAGE_NAME + ""String_Node_Str"");
  ResultCollector resultCollector=new ResultCollector();
  try (ClassCache cache=new ClassCache(ImmutableList.copyOf(classpath));ZipFile zipFile=new ZipFile(clientJar.toFile())){
    assertThat(cache.getClassState(""String_Node_Str"").isExistingState()).isTrue();
    AbstractClassEntryState state=cache.getClassState(""String_Node_Str"");
    assertThat(state.isExistingState()).isTrue();
    for (    String clientClass : clientClasses) {
      ZipEntry entry=zipFile.getEntry(clientClass + ""String_Node_Str"");
      try (InputStream classStream=zipFile.getInputStream(entry)){
        ClassReader reader=new ClassReader(classStream);
        DepsCheckerClassVisitor checker=new DepsCheckerClassVisitor(cache,resultCollector);
        reader.accept(checker,ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);
      }
     }
  }
   return resultCollector;
}",0.925595238095238
110605,"@Test public void testMissingMembersInClient() throws IOException {
  ResultCollector collector=getResultCollector(bootclasspath,libraryAnnotationsJar,libraryInterfaceJar,libraryWoMembersJar,libraryExceptionJar,clientJar);
  assertThat(collector.getSortedMissingClassInternalNames()).isEmpty();
  assertThat(collector.getSortedMissingMembers()).containsExactly(MemberInfo.create(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),MemberInfo.create(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),MemberInfo.create(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),MemberInfo.create(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"")).inOrder();
}","@Test public void testMissingMembersInClient() throws IOException {
  ResultCollector collector=getResultCollector(bootclasspath,libraryAnnotationsJar,libraryInterfaceJar,libraryWoMembersJar,libraryExceptionJar,clientJar);
  assertThat(collector.getSortedMissingClassInternalNames()).isEmpty();
  assertThat(collector.getSortedMissingMembers()).containsExactly(MissingMember.create(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),MissingMember.create(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),MissingMember.create(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),MissingMember.create(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"")).inOrder();
}",0.661849710982659
110606,"@Test public void testIncompleteState(){
  assertThrows(IllegalArgumentException.class,() -> IncompleteState.create(LIST_CLASS_INFO,ImmutableList.of()));
  IncompleteState state=IncompleteState.create(LIST_CLASS_INFO,ImmutableList.of(""String_Node_Str""));
  assertThat(state.isExistingState()).isFalse();
  assertThat(state.isIncompleteState()).isTrue();
  assertThat(state.isMissingState()).isFalse();
  assertThat(state.asIncompleteState()).isSameAs(state);
  assertThrows(IllegalStateException.class,() -> state.asExistingState());
  assertThrows(IllegalStateException.class,() -> state.asMissingState());
  ClassInfo classInfo=state.classInfo().get();
  assertThat(classInfo.internalName()).isEqualTo(""String_Node_Str"");
  assertThat(classInfo.declaredMembers()).hasSize(1);
  assertThat(classInfo.declaredMembers()).containsExactly(MemberInfo.create(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  ImmutableList<String> failurePath=state.getResolutionFailurePath();
  assertThat(failurePath).hasSize(1);
  assertThat(failurePath).containsExactly(""String_Node_Str"");
}","@Test public void testIncompleteState(){
  assertThrows(IllegalArgumentException.class,() -> IncompleteState.create(LIST_CLASS_INFO,ImmutableList.of()));
  IncompleteState state=IncompleteState.create(LIST_CLASS_INFO,ImmutableList.of(""String_Node_Str""));
  assertThat(state.isExistingState()).isFalse();
  assertThat(state.isIncompleteState()).isTrue();
  assertThat(state.isMissingState()).isFalse();
  assertThat(state.asIncompleteState()).isSameAs(state);
  assertThrows(IllegalStateException.class,() -> state.asExistingState());
  assertThrows(IllegalStateException.class,() -> state.asMissingState());
  ClassInfo classInfo=state.classInfo().get();
  assertThat(classInfo.internalName()).isEqualTo(""String_Node_Str"");
  assertThat(classInfo.declaredMembers()).hasSize(1);
  assertThat(classInfo.declaredMembers()).containsExactly(MemberInfo.create(""String_Node_Str"",""String_Node_Str""));
  ImmutableList<String> failurePath=state.getResolutionFailurePath();
  assertThat(failurePath).hasSize(1);
  assertThat(failurePath).containsExactly(""String_Node_Str"");
}",0.9916123019571296
110607,"@Test public void testExistingState(){
  ExistingState state=ExistingState.create(LIST_CLASS_INFO);
  assertThat(state.isExistingState()).isTrue();
  assertThat(state.isIncompleteState()).isFalse();
  assertThat(state.isMissingState()).isFalse();
  assertThat(state.asExistingState()).isSameAs(state);
  assertThrows(IllegalStateException.class,() -> state.asIncompleteState());
  assertThrows(IllegalStateException.class,() -> state.asMissingState());
  ClassInfo classInfo=state.classInfo().get();
  assertThat(classInfo.internalName()).isEqualTo(""String_Node_Str"");
  assertThat(classInfo.declaredMembers()).hasSize(1);
  assertThat(classInfo.declaredMembers()).containsExactly(MemberInfo.create(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","@Test public void testExistingState(){
  ExistingState state=ExistingState.create(LIST_CLASS_INFO);
  assertThat(state.isExistingState()).isTrue();
  assertThat(state.isIncompleteState()).isFalse();
  assertThat(state.isMissingState()).isFalse();
  assertThat(state.asExistingState()).isSameAs(state);
  assertThrows(IllegalStateException.class,() -> state.asIncompleteState());
  assertThrows(IllegalStateException.class,() -> state.asMissingState());
  ClassInfo classInfo=state.classInfo().get();
  assertThat(classInfo.internalName()).isEqualTo(""String_Node_Str"");
  assertThat(classInfo.declaredMembers()).hasSize(1);
  assertThat(classInfo.declaredMembers()).containsExactly(MemberInfo.create(""String_Node_Str"",""String_Node_Str""));
}",0.9879679144385026
110608,"private static void expandToPathIgnoringRepository(Artifact artifact,Consumer<String> args){
  args.accept(getPathIgnoringRepository(artifact));
}","private static void expandToPathIgnoringRepository(Artifact artifact,Consumer<String> args){
  args.accept(ProtoCommon.getPathIgnoringRepository(artifact).toString());
}",0.926984126984127
110609,"private static void expandTransitiveImportArg(Artifact artifact,Consumer<String> args){
  args.accept(""String_Node_Str"" + getPathIgnoringRepository(artifact) + ""String_Node_Str""+ artifact.getExecPathString());
}","private static void expandTransitiveImportArg(Artifact artifact,Consumer<String> args){
  args.accept(""String_Node_Str"" + ProtoCommon.getPathIgnoringRepository(artifact).toString() + ""String_Node_Str""+ artifact.getExecPathString());
}",0.9483146067415732
110610,"static Action buildAction(Path execRoot,Collection<? extends ActionInput> outputs,Digest command,Digest inputRoot,@Nullable PlatformInfo executionPlatform,Duration timeout,boolean cacheable){
  Action.Builder action=Action.newBuilder();
  action.setCommandDigest(command);
  action.setInputRootDigest(inputRoot);
  ArrayList<String> outputPaths=new ArrayList<>();
  ArrayList<String> outputDirectoryPaths=new ArrayList<>();
  for (  ActionInput output : outputs) {
    String pathString=output.getExecPathString();
    if (execRoot.getRelative(pathString).isDirectory()) {
      outputDirectoryPaths.add(pathString);
    }
 else {
      outputPaths.add(pathString);
    }
  }
  Collections.sort(outputPaths);
  Collections.sort(outputDirectoryPaths);
  action.addAllOutputFiles(outputPaths);
  if (executionPlatform != null) {
    Platform platform=parsePlatform(executionPlatform.label(),executionPlatform.remoteExecutionProperties());
    action.setPlatform(platform);
  }
  if (!timeout.isZero()) {
    action.setTimeout(com.google.protobuf.Duration.newBuilder().setSeconds(timeout.getSeconds()));
  }
  if (!cacheable) {
    action.setDoNotCache(true);
  }
  return action.build();
}","static Action buildAction(Path execRoot,Collection<? extends ActionInput> outputs,Digest command,Digest inputRoot,@Nullable PlatformInfo executionPlatform,Duration timeout,boolean cacheable){
  Action.Builder action=Action.newBuilder();
  action.setCommandDigest(command);
  action.setInputRootDigest(inputRoot);
  ArrayList<String> outputPaths=new ArrayList<>();
  ArrayList<String> outputDirectoryPaths=new ArrayList<>();
  for (  ActionInput output : outputs) {
    String pathString=output.getExecPathString();
    if (execRoot.getRelative(pathString).isDirectory()) {
      outputDirectoryPaths.add(pathString);
    }
 else {
      outputPaths.add(pathString);
    }
  }
  Collections.sort(outputPaths);
  Collections.sort(outputDirectoryPaths);
  action.addAllOutputFiles(outputPaths);
  action.addAllOutputDirectories(outputDirectoryPaths);
  if (executionPlatform != null) {
    Platform platform=parsePlatform(executionPlatform.label(),executionPlatform.remoteExecutionProperties());
    action.setPlatform(platform);
  }
  if (!timeout.isZero()) {
    action.setTimeout(com.google.protobuf.Duration.newBuilder().setSeconds(timeout.getSeconds()));
  }
  if (!cacheable) {
    action.setDoNotCache(true);
  }
  return action.build();
}",0.976954732510288
110611,"/** 
 * Returns a new   {@link Runfiles} instance.<p>The returned object is either: <ul> <li>manifest-based, meaning it looks up runfile paths from a manifest file, or <li>directory-based, meaning it looks up runfile paths under a given directory path </ul> <p>If  {@code env} contains ""RUNFILES_MANIFEST_ONLY"" with value ""1"", this method returns amanifest-based implementation. The manifest's path is defined by the ""RUNFILES_MANIFEST_FILE"" key's value in  {@code env}. <p>Otherwise this method returns a directory-based implementation. The directory's path is defined by the ""RUNFILES_DIR"" or ""TEST_SRCDIR"" key's value in   {@code env}, in this priority order. <p>Note about performance: the manifest-based implementation eagerly reads and caches the whole manifest file upon instantiation.
 * @throws IOException if RUNFILES_MANIFEST_ONLY=1 is in {@code env} but there's no""RUNFILES_MANIFEST_FILE"", or if neither ""RUNFILES_DIR"" nor ""TEST_SRCDIR"" is in  {@code env}, or if some IO error occurs
 */
public static Runfiles create(Map<String,String> env) throws IOException {
  if (isManifestOnly(env)) {
    return new ManifestBased(getManifestPath(env));
  }
 else {
    return new DirectoryBased(getRunfilesDir(env));
  }
}","/** 
 * Returns a new   {@link Runfiles} instance.<p>The returned object is either: <ul> <li>manifest-based, meaning it looks up runfile paths from a manifest file, or <li>directory-based, meaning it looks up runfile paths under a given directory path </ul> <p>If  {@code env} contains ""RUNFILES_MANIFEST_ONLY"" with value ""1"", this method returns amanifest-based implementation. The manifest's path is defined by the ""RUNFILES_MANIFEST_FILE"" key's value in  {@code env}. <p>Otherwise this method returns a directory-based implementation. The directory's path is defined by the value in   {@code env} under the ""RUNFILES_DIR"" key, or if absent, then under the""JAVA_RUNFILES"" key. <p>Note about performance: the manifest-based implementation eagerly reads and caches the whole manifest file upon instantiation.
 * @throws IOException if RUNFILES_MANIFEST_ONLY=1 is in {@code env} but there's no""RUNFILES_MANIFEST_FILE"", ""RUNFILES_DIR"", or ""JAVA_RUNFILES"" key in  {@code env} or theirvalues are empty, or some IO error occurs
 */
public static Runfiles create(Map<String,String> env) throws IOException {
  if (isManifestOnly(env)) {
    return new ManifestBased(getManifestPath(env));
  }
 else {
    return new DirectoryBased(getRunfilesDir(env));
  }
}",0.9083568833266048
110612,"/** 
 * Returns the runtime path of a runfile (a Bazel-built binary's/test's data-dependency). <p>The returned path may not be valid. The caller should check the path's validity and that the path exists. <p>The function may return null. In that case the caller can be sure that the rule does not know about this data-dependency.
 * @param path runfiles-root-relative path of the runfile
 * @throws IllegalArgumentException if {@code path} fails validation, for example if it's null orempty, it's absolute or contains uplevel references
 */
public final String rlocation(String path){
  Util.checkArgument(path != null);
  Util.checkArgument(!path.isEmpty());
  Util.checkArgument(!path.contains(""String_Node_Str""),""String_Node_Str"",path);
  Util.checkArgument(!new File(path).isAbsolute() && path.charAt(0) != File.separatorChar,""String_Node_Str"",path);
  return rlocationChecked(path);
}","/** 
 * Returns the runtime path of a runfile (a Bazel-built binary's/test's data-dependency). <p>The returned path may not be valid. The caller should check the path's validity and that the path exists. <p>The function may return null. In that case the caller can be sure that the rule does not know about this data-dependency.
 * @param path runfiles-root-relative path of the runfile
 * @throws IllegalArgumentException if {@code path} fails validation, for example if it's null orempty, or contains uplevel references
 */
public final String rlocation(String path){
  Util.checkArgument(path != null);
  Util.checkArgument(!path.isEmpty());
  Util.checkArgument(!path.contains(""String_Node_Str""),""String_Node_Str"",path);
  if (new File(path).isAbsolute() || path.charAt(0) == File.separatorChar) {
    return path;
  }
  return rlocationChecked(path);
}",0.9478510028653296
110613,"@Test public void testCreatesManifestBasedRunfiles() throws Exception {
  try (MockFile mf=new MockFile(ImmutableList.of(""String_Node_Str""))){
    Runfiles r=Runfiles.create(ImmutableMap.of(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",mf.path.toString(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    assertThat(r.rlocation(""String_Node_Str"")).isEqualTo(""String_Node_Str"");
    assertThat(r.rlocation(""String_Node_Str"")).isNull();
  }
 }","@Test public void testCreatesManifestBasedRunfiles() throws Exception {
  try (MockFile mf=new MockFile(ImmutableList.of(""String_Node_Str""))){
    Runfiles r=Runfiles.create(ImmutableMap.of(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",mf.path.toString(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    assertThat(r.rlocation(""String_Node_Str"")).isEqualTo(""String_Node_Str"");
    assertThat(r.rlocation(""String_Node_Str"")).isNull();
    if (isWindows()) {
      assertThat(r.rlocation(""String_Node_Str"")).isEqualTo(""String_Node_Str"");
      assertThat(r.rlocation(""String_Node_Str"")).isEqualTo(""String_Node_Str"");
      assertThat(r.rlocation(""String_Node_Str"")).isEqualTo(""String_Node_Str"");
    }
 else {
      assertThat(r.rlocation(""String_Node_Str"")).isEqualTo(""String_Node_Str"");
    }
  }
 }",0.7076239822353811
110614,"@Test public void testCreatesDirectoryBasedRunfiles() throws Exception {
  Runfiles r=Runfiles.create(ImmutableMap.of(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  assertThat(r.rlocation(""String_Node_Str"")).isEqualTo(""String_Node_Str"");
  assertThat(r.rlocation(""String_Node_Str"")).isEqualTo(""String_Node_Str"");
  r=Runfiles.create(ImmutableMap.of(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  assertThat(r.rlocation(""String_Node_Str"")).isEqualTo(""String_Node_Str"");
  assertThat(r.rlocation(""String_Node_Str"")).isEqualTo(""String_Node_Str"");
}","@Test public void testCreatesDirectoryBasedRunfiles() throws Exception {
  Runfiles r=Runfiles.create(ImmutableMap.of(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  assertThat(r.rlocation(""String_Node_Str"")).isEqualTo(""String_Node_Str"");
  assertThat(r.rlocation(""String_Node_Str"")).isEqualTo(""String_Node_Str"");
  r=Runfiles.create(ImmutableMap.of(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  assertThat(r.rlocation(""String_Node_Str"")).isEqualTo(""String_Node_Str"");
  assertThat(r.rlocation(""String_Node_Str"")).isEqualTo(""String_Node_Str"");
}",0.9223021582733812
110615,"@Test public void testRlocationArgumentValidation() throws Exception {
  Runfiles r=Runfiles.create(ImmutableMap.of(""String_Node_Str"",""String_Node_Str""));
  assertRlocationArg(r,null,null);
  assertRlocationArg(r,""String_Node_Str"",null);
  assertRlocationArg(r,""String_Node_Str"",""String_Node_Str"");
  if (File.separatorChar == '/') {
    assertRlocationArg(r,""String_Node_Str"",""String_Node_Str"");
  }
 else {
    assertRlocationArg(r,""String_Node_Str"",""String_Node_Str"");
    assertRlocationArg(r,""String_Node_Str"",""String_Node_Str"");
    assertRlocationArg(r,""String_Node_Str"",""String_Node_Str"");
  }
}","@Test public void testRlocationArgumentValidation() throws Exception {
  Runfiles r=Runfiles.create(ImmutableMap.of(""String_Node_Str"",""String_Node_Str""));
  assertRlocationArg(r,null,null);
  assertRlocationArg(r,""String_Node_Str"",null);
  assertRlocationArg(r,""String_Node_Str"",""String_Node_Str"");
}",0.6644518272425249
110616,"static DirectTraversalRoot forFileOrDirectory(Artifact fileOrDirectory){
  return new AutoValue_FilesetTraversalParams_DirectTraversalRoot(fileOrDirectory.getRoot().getRoot(),fileOrDirectory.getRootRelativePath());
}","public static DirectTraversalRoot forFileOrDirectory(Artifact fileOrDirectory){
  return new AutoValue_FilesetTraversalParams_DirectTraversalRoot(fileOrDirectory.isSourceArtifact() ? null : fileOrDirectory,fileOrDirectory.getRoot().getRoot(),fileOrDirectory.getRootRelativePath());
}",0.8657314629258517
110617,"static DirectTraversalRoot forPackage(Artifact buildFile){
  return new AutoValue_FilesetTraversalParams_DirectTraversalRoot(buildFile.getRoot().getRoot(),buildFile.getRootRelativePath().getParentDirectory());
}","public static DirectTraversalRoot forPackage(Artifact buildFile){
  return new AutoValue_FilesetTraversalParams_DirectTraversalRoot(null,buildFile.getRoot().getRoot(),buildFile.getRootRelativePath().getParentDirectory());
}",0.9723502304147466
110618,"private static RecursiveFilesystemTraversalValue traverse(Environment env,String errorInfo,DirectTraversal traversal) throws MissingDepException, InterruptedException {
  SkyKey depKey=RecursiveFilesystemTraversalValue.key(new RecursiveFilesystemTraversalValue.TraversalRequest(traversal.getRoot().asRootedPath(),traversal.isGenerated(),traversal.getPackageBoundaryMode(),traversal.isPackage(),errorInfo));
  RecursiveFilesystemTraversalValue v=(RecursiveFilesystemTraversalValue)env.getValue(depKey);
  if (env.valuesMissing()) {
    throw new MissingDepException();
  }
  return v;
}","private static RecursiveFilesystemTraversalValue traverse(Environment env,String errorInfo,DirectTraversal traversal) throws MissingDepException, InterruptedException {
  SkyKey depKey=RecursiveFilesystemTraversalValue.key(new RecursiveFilesystemTraversalValue.TraversalRequest(traversal.getRoot(),traversal.isGenerated(),traversal.getPackageBoundaryMode(),traversal.isPackage(),errorInfo));
  RecursiveFilesystemTraversalValue v=(RecursiveFilesystemTraversalValue)env.getValue(depKey);
  if (env.valuesMissing()) {
    throw new MissingDepException();
  }
  return v;
}",0.987012987012987
110619,"private static FileInfo lookUpFileInfo(Environment env,TraversalRequest traversal) throws MissingDepException, IOException, InterruptedException {
  FileValue fileValue=(FileValue)env.getValueOrThrow(FileValue.key(traversal.path),IOException.class);
  if (env.valuesMissing()) {
    throw new MissingDepException();
  }
  if (fileValue.exists()) {
    PathFragment unresolvedLinkTarget=null;
    FileType type=null;
    if (fileValue.isSymlink()) {
      unresolvedLinkTarget=fileValue.getUnresolvedLinkTarget();
      type=fileValue.isDirectory() ? FileType.SYMLINK_TO_DIRECTORY : FileType.SYMLINK_TO_FILE;
    }
 else {
      type=fileValue.isDirectory() ? FileType.DIRECTORY : FileType.FILE;
    }
    return new FileInfo(type,fileValue.realFileStateValue(),fileValue.realRootedPath(),unresolvedLinkTarget);
  }
 else {
    return new FileInfo(fileValue.isSymlink() ? FileType.DANGLING_SYMLINK : FileType.NONEXISTENT,fileValue.realFileStateValue(),null,fileValue.isSymlink() ? fileValue.getUnresolvedLinkTarget() : null);
  }
}","private static FileInfo lookUpFileInfo(Environment env,TraversalRequest traversal) throws MissingDepException, IOException, InterruptedException {
  if (traversal.isGenerated) {
    byte[] digest=null;
    if (traversal.root.getOutputArtifact() != null) {
      Artifact artifact=traversal.root.getOutputArtifact();
      SkyKey artifactKey=ArtifactSkyKey.key(artifact,true);
      SkyValue value=env.getValue(artifactKey);
      if (env.valuesMissing()) {
        throw new MissingDepException();
      }
      if (value instanceof FileArtifactValue) {
        FileArtifactValue fsVal=(FileArtifactValue)value;
        digest=fsVal.getDigest();
      }
 else {
        return new FileInfo(FileType.NONEXISTENT,null,null,null);
      }
    }
    Path path=traversal.root.asRootedPath().asPath();
    FileStatus noFollowStat=path.stat(Symlinks.NOFOLLOW);
    FileStatus followStat=path.statIfFound(Symlinks.FOLLOW);
    FileType type;
    PathFragment unresolvedLinkTarget=null;
    RootedPath realPath=traversal.root.asRootedPath();
    if (followStat == null) {
      type=FileType.DANGLING_SYMLINK;
      if (!noFollowStat.isSymbolicLink()) {
        throw new IOException(""String_Node_Str"" + path + ""String_Node_Str""+ noFollowStat);
      }
      unresolvedLinkTarget=path.readSymbolicLink();
    }
 else     if (noFollowStat.isFile()) {
      type=FileType.FILE;
    }
 else     if (noFollowStat.isDirectory()) {
      type=FileType.DIRECTORY;
    }
 else {
      unresolvedLinkTarget=path.readSymbolicLink();
      realPath=RootedPath.toRootedPath(Root.absoluteRoot(path.getFileSystem()),path.resolveSymbolicLinks());
      type=followStat.isFile() ? FileType.SYMLINK_TO_FILE : FileType.SYMLINK_TO_DIRECTORY;
    }
    return new FileInfo(type,FileStateValue.createWithStatNoFollow(traversal.root.asRootedPath(),new StatWithDigest(noFollowStat,digest),null),realPath,unresolvedLinkTarget);
  }
 else {
    FileValue fileValue=(FileValue)env.getValueOrThrow(FileValue.key(traversal.root.asRootedPath()),IOException.class);
    if (env.valuesMissing()) {
      throw new MissingDepException();
    }
    if (fileValue.exists()) {
      PathFragment unresolvedLinkTarget=null;
      FileType type;
      if (fileValue.isSymlink()) {
        unresolvedLinkTarget=fileValue.getUnresolvedLinkTarget();
        type=fileValue.isDirectory() ? FileType.SYMLINK_TO_DIRECTORY : FileType.SYMLINK_TO_FILE;
      }
 else {
        type=fileValue.isDirectory() ? FileType.DIRECTORY : FileType.FILE;
      }
      return new FileInfo(type,fileValue.realFileStateValue(),fileValue.realRootedPath(),unresolvedLinkTarget);
    }
 else {
      return new FileInfo(fileValue.isSymlink() ? FileType.DANGLING_SYMLINK : FileType.NONEXISTENT,fileValue.realFileStateValue(),null,fileValue.isSymlink() ? fileValue.getUnresolvedLinkTarget() : null);
    }
  }
}",0.2130299896587383
110620,"@Override public SkyValue compute(SkyKey skyKey,Environment env) throws RecursiveFilesystemTraversalFunctionException, InterruptedException {
  TraversalRequest traversal=(TraversalRequest)skyKey.argument();
  try {
    FileInfo rootInfo=lookUpFileInfo(env,traversal);
    if (!rootInfo.type.exists()) {
      if (rootInfo.type.isSymlink()) {
        return resultForDanglingSymlink(traversal.path,rootInfo);
      }
 else {
        return RecursiveFilesystemTraversalValue.EMPTY;
      }
    }
    if (rootInfo.type.isFile()) {
      return resultForFileRoot(traversal.path,rootInfo);
    }
    PkgLookupResult pkgLookupResult=checkIfPackage(env,traversal,rootInfo);
    traversal=pkgLookupResult.traversal;
    if (pkgLookupResult.isConflicting()) {
      throw new RecursiveFilesystemTraversalFunctionException(new GeneratedPathConflictException(traversal));
    }
 else     if (pkgLookupResult.isPackage() && !traversal.skipTestingForSubpackage) {
      String msg=traversal.errorInfo + ""String_Node_Str"" + traversal.path.getRootRelativePath().getPathString();
switch (traversal.crossPkgBoundaries) {
case CROSS:
        env.getListener().handle(Event.warn(null,msg));
      break;
case DONT_CROSS:
    return RecursiveFilesystemTraversalValue.EMPTY;
case REPORT_ERROR:
  throw new RecursiveFilesystemTraversalFunctionException(new CannotCrossPackageBoundaryException(msg));
default :
throw new IllegalStateException(traversal.toString());
}
}
Collection<SkyKey> dependentKeys=createRecursiveTraversalKeys(env,traversal);
return resultForDirectory(traversal,rootInfo,traverseChildren(env,dependentKeys));
}
 catch (IOException e) {
throw new RecursiveFilesystemTraversalFunctionException(new FileOperationException(""String_Node_Str"" + e.getMessage()));
}
catch (MissingDepException e) {
return null;
}
}","@Override public SkyValue compute(SkyKey skyKey,Environment env) throws RecursiveFilesystemTraversalFunctionException, InterruptedException {
  TraversalRequest traversal=(TraversalRequest)skyKey.argument();
  try {
    FileInfo rootInfo=lookUpFileInfo(env,traversal);
    if (!rootInfo.type.exists()) {
      if (rootInfo.type.isSymlink()) {
        return resultForDanglingSymlink(traversal.root.asRootedPath(),rootInfo);
      }
 else {
        return RecursiveFilesystemTraversalValue.EMPTY;
      }
    }
    if (rootInfo.type.isFile()) {
      return resultForFileRoot(traversal.root.asRootedPath(),rootInfo);
    }
    PkgLookupResult pkgLookupResult=checkIfPackage(env,traversal,rootInfo);
    traversal=pkgLookupResult.traversal;
    if (pkgLookupResult.isConflicting()) {
      throw new RecursiveFilesystemTraversalFunctionException(new GeneratedPathConflictException(traversal));
    }
 else     if (pkgLookupResult.isPackage() && !traversal.skipTestingForSubpackage) {
      String msg=traversal.errorInfo + ""String_Node_Str"" + traversal.root.asRootedPath().getRootRelativePath().getPathString();
switch (traversal.crossPkgBoundaries) {
case CROSS:
        env.getListener().handle(Event.warn(null,msg));
      break;
case DONT_CROSS:
    return RecursiveFilesystemTraversalValue.EMPTY;
case REPORT_ERROR:
  throw new RecursiveFilesystemTraversalFunctionException(new CannotCrossPackageBoundaryException(msg));
default :
throw new IllegalStateException(traversal.toString());
}
}
Collection<SkyKey> dependentKeys=createRecursiveTraversalKeys(env,traversal);
return resultForDirectory(traversal,rootInfo,traverseChildren(env,dependentKeys,traversal.isGenerated));
}
 catch (IOException e) {
throw new RecursiveFilesystemTraversalFunctionException(new FileOperationException(""String_Node_Str"" + e.getMessage()));
}
catch (MissingDepException e) {
return null;
}
}",0.9801684324911708
110621,"/** 
 * Checks whether the   {@code traversal}'s path refers to a package directory.
 * @return the result of the lookup; it contains potentially new {@link TraversalRequest} and{@link FileInfo} so the caller should use these instead of the old ones (this happens whena package is found, but under a different root than expected)
 */
private static PkgLookupResult checkIfPackage(Environment env,TraversalRequest traversal,FileInfo rootInfo) throws MissingDepException, IOException, InterruptedException {
  Preconditions.checkArgument(rootInfo.type.exists() && !rootInfo.type.isFile(),""String_Node_Str"",traversal,rootInfo);
  PackageLookupValue pkgLookup=(PackageLookupValue)getDependentSkyValue(env,PackageLookupValue.key(traversal.path.getRootRelativePath()));
  if (pkgLookup.packageExists()) {
    if (traversal.isGenerated) {
      return PkgLookupResult.conflict(traversal,rootInfo);
    }
 else {
      Root pkgRoot=pkgLookup.getRoot();
      if (!pkgRoot.equals(traversal.path.getRoot())) {
        traversal=traversal.forChangedRootPath(pkgRoot);
        rootInfo=lookUpFileInfo(env,traversal);
        Verify.verify(rootInfo.type.exists(),""String_Node_Str"",traversal,rootInfo);
      }
      return PkgLookupResult.pkg(traversal,rootInfo);
    }
  }
 else {
    return PkgLookupResult.directory(traversal,rootInfo);
  }
}","/** 
 * Checks whether the   {@code traversal}'s path refers to a package directory.
 * @return the result of the lookup; it contains potentially new {@link TraversalRequest} and{@link FileInfo} so the caller should use these instead of the old ones (this happens whena package is found, but under a different root than expected)
 */
private static PkgLookupResult checkIfPackage(Environment env,TraversalRequest traversal,FileInfo rootInfo) throws MissingDepException, IOException, InterruptedException {
  Preconditions.checkArgument(rootInfo.type.exists() && !rootInfo.type.isFile(),""String_Node_Str"",traversal,rootInfo);
  PackageLookupValue pkgLookup=(PackageLookupValue)getDependentSkyValue(env,PackageLookupValue.key(traversal.root.asRootedPath().getRootRelativePath()));
  if (pkgLookup.packageExists()) {
    if (traversal.isGenerated) {
      return PkgLookupResult.conflict(traversal,rootInfo);
    }
 else {
      Root pkgRoot=pkgLookup.getRoot();
      if (!pkgRoot.equals(traversal.root.asRootedPath().getRoot())) {
        traversal=traversal.forChangedRootPath(pkgRoot);
        rootInfo=lookUpFileInfo(env,traversal);
        Verify.verify(rootInfo.type.exists(),""String_Node_Str"",traversal,rootInfo);
      }
      return PkgLookupResult.pkg(traversal,rootInfo);
    }
  }
 else {
    return PkgLookupResult.directory(traversal,rootInfo);
  }
}",0.9829250185597624
110622,"GeneratedPathConflictException(TraversalRequest traversal){
  super(String.format(""String_Node_Str"" + ""String_Node_Str"",traversal.path.getRootRelativePath().getPathString(),traversal.errorInfo != null ? traversal.errorInfo : traversal.toString()));
}","GeneratedPathConflictException(TraversalRequest traversal){
  super(String.format(""String_Node_Str"" + ""String_Node_Str"",traversal.root.asRootedPath().getRootRelativePath().getPathString(),traversal.errorInfo != null ? traversal.errorInfo : traversal.toString()));
}",0.9553398058252428
110623,"/** 
 * List the directory and create   {@code SkyKey}s to request contents of its children recursively. <p>The returned keys are of type   {@link SkyFunctions#RECURSIVE_FILESYSTEM_TRAVERSAL}.
 */
private static Collection<SkyKey> createRecursiveTraversalKeys(Environment env,TraversalRequest traversal) throws MissingDepException, InterruptedException {
  DirectoryListingValue dirListing=(DirectoryListingValue)getDependentSkyValue(env,DirectoryListingValue.key(traversal.path));
  List<SkyKey> result=new ArrayList<>();
  for (  Dirent dirent : dirListing.getDirents()) {
    RootedPath childPath=RootedPath.toRootedPath(traversal.path.getRoot(),traversal.path.getRootRelativePath().getRelative(dirent.getName()));
    TraversalRequest childTraversal=traversal.forChildEntry(childPath);
    result.add(RecursiveFilesystemTraversalValue.key(childTraversal));
  }
  return result;
}","/** 
 * List the directory and create   {@code SkyKey}s to request contents of its children recursively. <p>The returned keys are of type   {@link SkyFunctions#RECURSIVE_FILESYSTEM_TRAVERSAL}.
 */
private static Collection<SkyKey> createRecursiveTraversalKeys(Environment env,TraversalRequest traversal) throws MissingDepException, InterruptedException, IOException {
  Iterable<Dirent> dirents;
  if (traversal.isGenerated) {
    List<Dirent> direntsCollection=new ArrayList<>(traversal.root.asRootedPath().asPath().readdir(Symlinks.FOLLOW));
    Collections.sort(direntsCollection);
    dirents=direntsCollection;
  }
 else {
    dirents=((DirectoryListingValue)getDependentSkyValue(env,DirectoryListingValue.key(traversal.root.asRootedPath()))).getDirents();
  }
  List<SkyKey> result=new ArrayList<>();
  for (  Dirent dirent : dirents) {
    RootedPath childPath=RootedPath.toRootedPath(traversal.root.asRootedPath().getRoot(),traversal.root.asRootedPath().getRootRelativePath().getRelative(dirent.getName()));
    TraversalRequest childTraversal=traversal.forChildEntry(childPath);
    result.add(RecursiveFilesystemTraversalValue.key(childTraversal));
  }
  return result;
}",0.685077519379845
110624,"private static RecursiveFilesystemTraversalValue resultForDirectory(TraversalRequest traversal,FileInfo rootInfo,Collection<RecursiveFilesystemTraversalValue> subdirTraversals){
  NestedSetBuilder<ResolvedFile> paths=NestedSetBuilder.stableOrder();
  for (  RecursiveFilesystemTraversalValue child : subdirTraversals) {
    paths.addTransitive(child.getTransitiveFiles());
  }
  ResolvedFile root;
  if (rootInfo.type.isSymlink()) {
    NestedSet<ResolvedFile> children=paths.build();
    root=ResolvedFileFactory.symlinkToDirectory(rootInfo.realPath,traversal.path,rootInfo.unresolvedSymlinkTarget,hashDirectorySymlink(children,rootInfo.metadata.hashCode()));
    paths=NestedSetBuilder.<ResolvedFile>stableOrder().addTransitive(children).add(root);
  }
 else {
    root=ResolvedFileFactory.directory(rootInfo.realPath);
  }
  return RecursiveFilesystemTraversalValue.of(root,paths.build());
}","private static RecursiveFilesystemTraversalValue resultForDirectory(TraversalRequest traversal,FileInfo rootInfo,Collection<RecursiveFilesystemTraversalValue> subdirTraversals){
  NestedSetBuilder<ResolvedFile> paths=NestedSetBuilder.stableOrder();
  for (  RecursiveFilesystemTraversalValue child : subdirTraversals) {
    paths.addTransitive(child.getTransitiveFiles());
  }
  ResolvedFile root;
  if (rootInfo.type.isSymlink()) {
    NestedSet<ResolvedFile> children=paths.build();
    root=ResolvedFileFactory.symlinkToDirectory(rootInfo.realPath,traversal.root.asRootedPath(),rootInfo.unresolvedSymlinkTarget,hashDirectorySymlink(children,rootInfo.metadata.hashCode()));
    paths=NestedSetBuilder.<ResolvedFile>stableOrder().addTransitive(children).add(root);
  }
 else {
    root=ResolvedFileFactory.directory(rootInfo.realPath);
  }
  return RecursiveFilesystemTraversalValue.of(root,paths.build());
}",0.9872434830837492
110625,"boolean isFile(){
  return false;
}","@Override public boolean isFile(){
  return noFollowStat.isFile();
}",0.6407766990291263
110626,"/** 
 * Requests Skyframe to compute the dependent values and returns them. <p>The keys must all be   {@link SkyFunctions#RECURSIVE_FILESYSTEM_TRAVERSAL} keys.
 */
private static Collection<RecursiveFilesystemTraversalValue> traverseChildren(Environment env,Iterable<SkyKey> keys) throws MissingDepException, InterruptedException {
  Map<SkyKey,SkyValue> values=env.getValues(keys);
  if (env.valuesMissing()) {
    throw new MissingDepException();
  }
  return Collections2.transform(values.values(),new Function<SkyValue,RecursiveFilesystemTraversalValue>(){
    @Override public RecursiveFilesystemTraversalValue apply(    SkyValue input){
      return (RecursiveFilesystemTraversalValue)input;
    }
  }
);
}","/** 
 * Requests Skyframe to compute the dependent values and returns them. <p>The keys must all be   {@link SkyFunctions#RECURSIVE_FILESYSTEM_TRAVERSAL} keys.
 */
private Collection<RecursiveFilesystemTraversalValue> traverseChildren(Environment env,Iterable<SkyKey> keys,boolean inline) throws MissingDepException, InterruptedException, RecursiveFilesystemTraversalFunctionException {
  Map<SkyKey,SkyValue> values;
  if (inline) {
    values=new HashMap<>();
    for (    SkyKey depKey : keys) {
      values.put(depKey,compute(depKey,env));
    }
  }
 else {
    values=env.getValues(keys);
  }
  if (env.valuesMissing()) {
    throw new MissingDepException();
  }
  return Collections2.transform(values.values(),new Function<SkyValue,RecursiveFilesystemTraversalValue>(){
    @Override public RecursiveFilesystemTraversalValue apply(    SkyValue input){
      return (RecursiveFilesystemTraversalValue)input;
    }
  }
);
}",0.8597560975609756
110627,"boolean isDirectory(){
  return false;
}","@Override public boolean isDirectory(){
  return noFollowStat.isDirectory();
}",0.6440677966101694
110628,"private ImmutableMap<SkyFunctionName,SkyFunction> skyFunctions(PackageFactory pkgFactory){
  ConfiguredRuleClassProvider ruleClassProvider=(ConfiguredRuleClassProvider)pkgFactory.getRuleClassProvider();
  Semaphore cpuBoundSemaphore=new Semaphore(ResourceUsage.getAvailableProcessors());
  ImmutableMap.Builder<SkyFunctionName,SkyFunction> map=ImmutableMap.builder();
  map.put(SkyFunctions.PRECOMPUTED,new PrecomputedFunction());
  map.put(SkyFunctions.CLIENT_ENVIRONMENT_VARIABLE,new ClientEnvironmentFunction(clientEnv));
  map.put(SkyFunctions.ACTION_ENVIRONMENT_VARIABLE,new ActionEnvironmentFunction());
  map.put(SkyFunctions.FILE_STATE,new FileStateFunction(tsgm,externalFilesHelper));
  map.put(SkyFunctions.DIRECTORY_LISTING_STATE,new DirectoryListingStateFunction(externalFilesHelper));
  map.put(SkyFunctions.FILE_SYMLINK_CYCLE_UNIQUENESS,new FileSymlinkCycleUniquenessFunction());
  map.put(SkyFunctions.FILE_SYMLINK_INFINITE_EXPANSION_UNIQUENESS,new FileSymlinkInfiniteExpansionUniquenessFunction());
  map.put(SkyFunctions.FILE,new FileFunction(pkgLocator));
  map.put(SkyFunctions.DIRECTORY_LISTING,new DirectoryListingFunction());
  map.put(SkyFunctions.PACKAGE_LOOKUP,new PackageLookupFunction(deletedPackages,crossRepositoryLabelViolationStrategy,buildFilesByPriority));
  map.put(SkyFunctions.CONTAINING_PACKAGE_LOOKUP,new ContainingPackageLookupFunction());
  map.put(SkyFunctions.AST_FILE_LOOKUP,new ASTFileLookupFunction(ruleClassProvider));
  map.put(SkyFunctions.SKYLARK_IMPORTS_LOOKUP,newSkylarkImportLookupFunction(ruleClassProvider,pkgFactory));
  map.put(SkyFunctions.GLOB,newGlobFunction());
  map.put(SkyFunctions.TARGET_PATTERN,new TargetPatternFunction(pkgLocator));
  map.put(SkyFunctions.PREPARE_DEPS_OF_PATTERNS,new PrepareDepsOfPatternsFunction());
  map.put(SkyFunctions.PREPARE_DEPS_OF_PATTERN,new PrepareDepsOfPatternFunction(pkgLocator));
  map.put(SkyFunctions.PREPARE_DEPS_OF_TARGETS_UNDER_DIRECTORY,new PrepareDepsOfTargetsUnderDirectoryFunction(directories));
  map.put(SkyFunctions.COLLECT_TARGETS_IN_PACKAGE,new CollectTargetsInPackageFunction());
  map.put(SkyFunctions.COLLECT_PACKAGES_UNDER_DIRECTORY,new CollectPackagesUnderDirectoryFunction(directories));
  map.put(SkyFunctions.BLACKLISTED_PACKAGE_PREFIXES,new BlacklistedPackagePrefixesFunction(hardcodedBlacklistedPackagePrefixes,additionalBlacklistedPackagePrefixesFile));
  map.put(SkyFunctions.TESTS_IN_SUITE,new TestsInSuiteFunction());
  map.put(SkyFunctions.TEST_SUITE_EXPANSION,new TestSuiteExpansionFunction());
  map.put(SkyFunctions.TARGET_PATTERN_PHASE,new TargetPatternPhaseFunction(pkgLocator));
  map.put(SkyFunctions.RECURSIVE_PKG,new RecursivePkgFunction(directories));
  map.put(SkyFunctions.PACKAGE,newPackageFunction(pkgFactory,packageManager,showLoadingProgress,packageFunctionCache,astCache,numPackagesLoaded,ruleClassProvider,packageProgress));
  map.put(SkyFunctions.PACKAGE_ERROR,new PackageErrorFunction());
  map.put(SkyFunctions.TARGET_MARKER,new TargetMarkerFunction());
  map.put(SkyFunctions.TRANSITIVE_TARGET,new TransitiveTargetFunction(ruleClassProvider));
  map.put(Label.TRANSITIVE_TRAVERSAL,new TransitiveTraversalFunction());
  map.put(SkyFunctions.CONFIGURED_TARGET,new ConfiguredTargetFunction(new BuildViewProvider(),ruleClassProvider,cpuBoundSemaphore,removeActionsAfterEvaluation,shouldStoreTransitivePackagesInLoadingAndAnalysis()));
  map.put(SkyFunctions.ASPECT,new AspectFunction(new BuildViewProvider(),ruleClassProvider,removeActionsAfterEvaluation,shouldStoreTransitivePackagesInLoadingAndAnalysis()));
  map.put(SkyFunctions.LOAD_SKYLARK_ASPECT,new ToplevelSkylarkAspectFunction());
  map.put(SkyFunctions.POST_CONFIGURED_TARGET,new PostConfiguredTargetFunction(new BuildViewProvider(),ruleClassProvider));
  map.put(SkyFunctions.BUILD_CONFIGURATION,new BuildConfigurationFunction(directories,ruleClassProvider));
  map.put(SkyFunctions.CONFIGURATION_FRAGMENT,new ConfigurationFragmentFunction(configurationFragments,ruleClassProvider,directories));
  map.put(SkyFunctions.WORKSPACE_NAME,new WorkspaceNameFunction());
  map.put(SkyFunctions.WORKSPACE_AST,new WorkspaceASTFunction(ruleClassProvider));
  map.put(SkyFunctions.WORKSPACE_FILE,new WorkspaceFileFunction(ruleClassProvider,pkgFactory,directories));
  map.put(SkyFunctions.EXTERNAL_PACKAGE,new ExternalPackageFunction());
  map.put(SkyFunctions.TARGET_COMPLETION,CompletionFunction.targetCompletionFunction());
  map.put(SkyFunctions.ASPECT_COMPLETION,CompletionFunction.aspectCompletionFunction());
  map.put(SkyFunctions.TEST_COMPLETION,new TestCompletionFunction());
  map.put(SkyFunctions.ARTIFACT,new ArtifactFunction());
  map.put(SkyFunctions.BUILD_INFO_COLLECTION,new BuildInfoCollectionFunction(actionKeyContext,artifactFactory,buildInfoFactories,removeActionsAfterEvaluation));
  map.put(SkyFunctions.BUILD_INFO,new WorkspaceStatusFunction(actionKeyContext,removeActionsAfterEvaluation,this::makeWorkspaceStatusAction));
  map.put(SkyFunctions.COVERAGE_REPORT,new CoverageReportFunction(actionKeyContext,removeActionsAfterEvaluation));
  ActionExecutionFunction actionExecutionFunction=new ActionExecutionFunction(skyframeActionExecutor,tsgm);
  map.put(SkyFunctions.ACTION_EXECUTION,actionExecutionFunction);
  this.actionExecutionFunction=actionExecutionFunction;
  map.put(SkyFunctions.RECURSIVE_FILESYSTEM_TRAVERSAL,new RecursiveFilesystemTraversalFunction());
  map.put(SkyFunctions.FILESET_ENTRY,new FilesetEntryFunction());
  map.put(SkyFunctions.ACTION_TEMPLATE_EXPANSION,new ActionTemplateExpansionFunction(actionKeyContext,removeActionsAfterEvaluation));
  map.put(SkyFunctions.LOCAL_REPOSITORY_LOOKUP,new LocalRepositoryLookupFunction());
  map.put(SkyFunctions.REGISTERED_EXECUTION_PLATFORMS,new RegisteredExecutionPlatformsFunction());
  map.put(SkyFunctions.REGISTERED_TOOLCHAINS,new RegisteredToolchainsFunction());
  map.put(SkyFunctions.TOOLCHAIN_RESOLUTION,new ToolchainResolutionFunction());
  map.putAll(extraSkyFunctions);
  return map.build();
}","private ImmutableMap<SkyFunctionName,SkyFunction> skyFunctions(PackageFactory pkgFactory){
  ConfiguredRuleClassProvider ruleClassProvider=(ConfiguredRuleClassProvider)pkgFactory.getRuleClassProvider();
  Semaphore cpuBoundSemaphore=new Semaphore(ResourceUsage.getAvailableProcessors());
  ImmutableMap.Builder<SkyFunctionName,SkyFunction> map=ImmutableMap.builder();
  map.put(SkyFunctions.PRECOMPUTED,new PrecomputedFunction());
  map.put(SkyFunctions.CLIENT_ENVIRONMENT_VARIABLE,new ClientEnvironmentFunction(clientEnv));
  map.put(SkyFunctions.ACTION_ENVIRONMENT_VARIABLE,new ActionEnvironmentFunction());
  map.put(SkyFunctions.FILE_STATE,new FileStateFunction(tsgm,externalFilesHelper));
  map.put(SkyFunctions.DIRECTORY_LISTING_STATE,new DirectoryListingStateFunction(externalFilesHelper));
  map.put(SkyFunctions.FILE_SYMLINK_CYCLE_UNIQUENESS,new FileSymlinkCycleUniquenessFunction());
  map.put(SkyFunctions.FILE_SYMLINK_INFINITE_EXPANSION_UNIQUENESS,new FileSymlinkInfiniteExpansionUniquenessFunction());
  map.put(SkyFunctions.FILE,new FileFunction(pkgLocator));
  map.put(SkyFunctions.DIRECTORY_LISTING,new DirectoryListingFunction());
  map.put(SkyFunctions.PACKAGE_LOOKUP,new PackageLookupFunction(deletedPackages,crossRepositoryLabelViolationStrategy,buildFilesByPriority));
  map.put(SkyFunctions.CONTAINING_PACKAGE_LOOKUP,new ContainingPackageLookupFunction());
  map.put(SkyFunctions.AST_FILE_LOOKUP,new ASTFileLookupFunction(ruleClassProvider));
  map.put(SkyFunctions.SKYLARK_IMPORTS_LOOKUP,newSkylarkImportLookupFunction(ruleClassProvider,pkgFactory));
  map.put(SkyFunctions.GLOB,newGlobFunction());
  map.put(SkyFunctions.TARGET_PATTERN,new TargetPatternFunction(pkgLocator));
  map.put(SkyFunctions.PREPARE_DEPS_OF_PATTERNS,new PrepareDepsOfPatternsFunction());
  map.put(SkyFunctions.PREPARE_DEPS_OF_PATTERN,new PrepareDepsOfPatternFunction(pkgLocator));
  map.put(SkyFunctions.PREPARE_DEPS_OF_TARGETS_UNDER_DIRECTORY,new PrepareDepsOfTargetsUnderDirectoryFunction(directories));
  map.put(SkyFunctions.COLLECT_TARGETS_IN_PACKAGE,new CollectTargetsInPackageFunction());
  map.put(SkyFunctions.COLLECT_PACKAGES_UNDER_DIRECTORY,new CollectPackagesUnderDirectoryFunction(directories));
  map.put(SkyFunctions.BLACKLISTED_PACKAGE_PREFIXES,new BlacklistedPackagePrefixesFunction(hardcodedBlacklistedPackagePrefixes,additionalBlacklistedPackagePrefixesFile));
  map.put(SkyFunctions.TESTS_IN_SUITE,new TestsInSuiteFunction());
  map.put(SkyFunctions.TEST_SUITE_EXPANSION,new TestSuiteExpansionFunction());
  map.put(SkyFunctions.TARGET_PATTERN_PHASE,new TargetPatternPhaseFunction(pkgLocator));
  map.put(SkyFunctions.RECURSIVE_PKG,new RecursivePkgFunction(directories));
  map.put(SkyFunctions.PACKAGE,newPackageFunction(pkgFactory,packageManager,showLoadingProgress,packageFunctionCache,astCache,numPackagesLoaded,ruleClassProvider,packageProgress));
  map.put(SkyFunctions.PACKAGE_ERROR,new PackageErrorFunction());
  map.put(SkyFunctions.TARGET_MARKER,new TargetMarkerFunction());
  map.put(SkyFunctions.TARGET_PATTERN_ERROR,new TargetPatternErrorFunction());
  map.put(SkyFunctions.TRANSITIVE_TARGET,new TransitiveTargetFunction(ruleClassProvider));
  map.put(Label.TRANSITIVE_TRAVERSAL,new TransitiveTraversalFunction());
  map.put(SkyFunctions.CONFIGURED_TARGET,new ConfiguredTargetFunction(new BuildViewProvider(),ruleClassProvider,cpuBoundSemaphore,removeActionsAfterEvaluation,shouldStoreTransitivePackagesInLoadingAndAnalysis()));
  map.put(SkyFunctions.ASPECT,new AspectFunction(new BuildViewProvider(),ruleClassProvider,removeActionsAfterEvaluation,shouldStoreTransitivePackagesInLoadingAndAnalysis()));
  map.put(SkyFunctions.LOAD_SKYLARK_ASPECT,new ToplevelSkylarkAspectFunction());
  map.put(SkyFunctions.POST_CONFIGURED_TARGET,new PostConfiguredTargetFunction(new BuildViewProvider(),ruleClassProvider));
  map.put(SkyFunctions.BUILD_CONFIGURATION,new BuildConfigurationFunction(directories,ruleClassProvider));
  map.put(SkyFunctions.CONFIGURATION_FRAGMENT,new ConfigurationFragmentFunction(configurationFragments,ruleClassProvider,directories));
  map.put(SkyFunctions.WORKSPACE_NAME,new WorkspaceNameFunction());
  map.put(SkyFunctions.WORKSPACE_AST,new WorkspaceASTFunction(ruleClassProvider));
  map.put(SkyFunctions.WORKSPACE_FILE,new WorkspaceFileFunction(ruleClassProvider,pkgFactory,directories));
  map.put(SkyFunctions.EXTERNAL_PACKAGE,new ExternalPackageFunction());
  map.put(SkyFunctions.TARGET_COMPLETION,CompletionFunction.targetCompletionFunction());
  map.put(SkyFunctions.ASPECT_COMPLETION,CompletionFunction.aspectCompletionFunction());
  map.put(SkyFunctions.TEST_COMPLETION,new TestCompletionFunction());
  map.put(SkyFunctions.ARTIFACT,new ArtifactFunction());
  map.put(SkyFunctions.BUILD_INFO_COLLECTION,new BuildInfoCollectionFunction(actionKeyContext,artifactFactory,buildInfoFactories,removeActionsAfterEvaluation));
  map.put(SkyFunctions.BUILD_INFO,new WorkspaceStatusFunction(actionKeyContext,removeActionsAfterEvaluation,this::makeWorkspaceStatusAction));
  map.put(SkyFunctions.COVERAGE_REPORT,new CoverageReportFunction(actionKeyContext,removeActionsAfterEvaluation));
  ActionExecutionFunction actionExecutionFunction=new ActionExecutionFunction(skyframeActionExecutor,tsgm);
  map.put(SkyFunctions.ACTION_EXECUTION,actionExecutionFunction);
  this.actionExecutionFunction=actionExecutionFunction;
  map.put(SkyFunctions.RECURSIVE_FILESYSTEM_TRAVERSAL,new RecursiveFilesystemTraversalFunction());
  map.put(SkyFunctions.FILESET_ENTRY,new FilesetEntryFunction());
  map.put(SkyFunctions.ACTION_TEMPLATE_EXPANSION,new ActionTemplateExpansionFunction(actionKeyContext,removeActionsAfterEvaluation));
  map.put(SkyFunctions.LOCAL_REPOSITORY_LOOKUP,new LocalRepositoryLookupFunction());
  map.put(SkyFunctions.REGISTERED_EXECUTION_PLATFORMS,new RegisteredExecutionPlatformsFunction());
  map.put(SkyFunctions.REGISTERED_TOOLCHAINS,new RegisteredToolchainsFunction());
  map.put(SkyFunctions.TOOLCHAIN_RESOLUTION,new ToolchainResolutionFunction());
  map.putAll(extraSkyFunctions);
  return map.build();
}",0.9934499626896608
110629,"/** 
 * Interpret the command-line arguments.
 * @param options the command-line arguments in structured form
 */
private static ResolvedTargets<Target> getTargetsToBuild(Environment env,TargetPatternPhaseKey options,PathPackageLocator pkgPath) throws InterruptedException {
  List<TargetPatternKey> patternSkyKeys=new ArrayList<>();
  for (  TargetPatternSkyKeyOrException keyOrException : TargetPatternValue.keys(options.getTargetPatterns(),options.getBuildManualTests() ? FilteringPolicies.NO_FILTER : FilteringPolicies.FILTER_MANUAL,options.getOffset())) {
    try {
      patternSkyKeys.add(keyOrException.getSkyKey());
    }
 catch (    TargetParsingException e) {
      env.getListener().post(new ParsingFailedEvent(keyOrException.getOriginalPattern(),e.getMessage()));
    }
  }
  Map<SkyKey,ValueOrException<TargetParsingException>> resolvedPatterns=env.getValuesOrThrow(patternSkyKeys,TargetParsingException.class);
  if (env.valuesMissing()) {
    return null;
  }
  ResolvedTargets.Builder<Target> builder=ResolvedTargets.builder();
  for (  TargetPatternKey pattern : patternSkyKeys) {
    TargetPatternValue value;
    try {
      value=(TargetPatternValue)resolvedPatterns.get(pattern).get();
    }
 catch (    TargetParsingException e) {
      String rawPattern=pattern.getPattern();
      String errorMessage=e.getMessage();
      env.getListener().handle(Event.error(""String_Node_Str"" + rawPattern + ""String_Node_Str""+ errorMessage));
      builder.setError();
      continue;
    }
    ResolvedTargets<Target> asTargets=TestSuiteExpansionFunction.labelsToTargets(env,value.getTargets().getTargets(),value.getTargets().hasError());
    if (pattern.isNegative()) {
      builder.filter(Predicates.not(Predicates.in(asTargets.getTargets())));
    }
 else {
      builder.merge(asTargets);
    }
  }
  ResolvedTargets<Target> result=builder.filter(TargetUtils.tagFilter(options.getBuildTargetFilter())).build();
  if (options.getCompileOneDependency()) {
    TargetProvider targetProvider=new EnvironmentBackedRecursivePackageProvider(env,pkgPath);
    try {
      return new CompileOneDependencyTransformer(targetProvider).transformCompileOneDependency(env.getListener(),result);
    }
 catch (    MissingDepException e) {
      return null;
    }
catch (    TargetParsingException e) {
      env.getListener().handle(Event.error(e.getMessage()));
      return ResolvedTargets.failed();
    }
  }
  return result;
}","/** 
 * Interpret the command-line arguments.
 * @param options the command-line arguments in structured form
 */
private static ResolvedTargets<Target> getTargetsToBuild(Environment env,TargetPatternPhaseKey options,PathPackageLocator pkgPath) throws InterruptedException {
  List<TargetPatternKey> patternSkyKeys=new ArrayList<>();
  ResolvedTargets.Builder<Target> builder=ResolvedTargets.builder();
  for (  TargetPatternSkyKeyOrException keyOrException : TargetPatternValue.keys(options.getTargetPatterns(),options.getBuildManualTests() ? FilteringPolicies.NO_FILTER : FilteringPolicies.FILTER_MANUAL,options.getOffset())) {
    try {
      patternSkyKeys.add(keyOrException.getSkyKey());
    }
 catch (    TargetParsingException e) {
      env.getListener().post(new ParsingFailedEvent(keyOrException.getOriginalPattern(),e.getMessage()));
      try {
        env.getValueOrThrow(TargetPatternErrorFunction.key(e.getMessage()),TargetParsingException.class);
      }
 catch (      TargetParsingException ignore) {
      }
      env.getListener().handle(Event.error(""String_Node_Str"" + keyOrException.getOriginalPattern() + ""String_Node_Str""+ e.getMessage()));
      builder.setError();
    }
  }
  Map<SkyKey,ValueOrException<TargetParsingException>> resolvedPatterns=env.getValuesOrThrow(patternSkyKeys,TargetParsingException.class);
  if (env.valuesMissing()) {
    return null;
  }
  for (  TargetPatternKey pattern : patternSkyKeys) {
    TargetPatternValue value;
    try {
      value=(TargetPatternValue)resolvedPatterns.get(pattern).get();
    }
 catch (    TargetParsingException e) {
      String rawPattern=pattern.getPattern();
      String errorMessage=e.getMessage();
      env.getListener().handle(Event.error(""String_Node_Str"" + rawPattern + ""String_Node_Str""+ errorMessage));
      builder.setError();
      continue;
    }
    ResolvedTargets<Target> asTargets=TestSuiteExpansionFunction.labelsToTargets(env,value.getTargets().getTargets(),value.getTargets().hasError());
    if (pattern.isNegative()) {
      builder.filter(Predicates.not(Predicates.in(asTargets.getTargets())));
    }
 else {
      builder.merge(asTargets);
    }
  }
  ResolvedTargets<Target> result=builder.filter(TargetUtils.tagFilter(options.getBuildTargetFilter())).build();
  if (options.getCompileOneDependency()) {
    TargetProvider targetProvider=new EnvironmentBackedRecursivePackageProvider(env,pkgPath);
    try {
      return new CompileOneDependencyTransformer(targetProvider).transformCompileOneDependency(env.getListener(),result);
    }
 catch (    MissingDepException e) {
      return null;
    }
catch (    TargetParsingException e) {
      try {
        env.getValueOrThrow(TargetPatternErrorFunction.key(e.getMessage()),TargetParsingException.class);
      }
 catch (      TargetParsingException ignore) {
      }
      env.getListener().handle(Event.error(e.getMessage()));
      return ResolvedTargets.failed();
    }
  }
  return result;
}",0.8767631774313289
110630,"/** 
 * Creates a new   {@link ImmutableListSerializer} and registers its serializer for the severalImmutableList related classes.
 * @param kryo the {@link Kryo} instance to set the serializer on
 */
static void registerSerializers(Kryo kryo){
  ImmutableListSerializer serializer=new ImmutableListSerializer();
  kryo.register(ImmutableList.class,serializer);
  kryo.register(ImmutableList.of().getClass(),serializer);
  kryo.register(ImmutableList.of(1).getClass(),serializer);
  kryo.register(ImmutableList.of(1,2,3,4).subList(1,3).getClass(),serializer);
  kryo.register(ImmutableList.of(1,2).reverse().getClass(),serializer);
  kryo.register(Lists.charactersOf(""String_Node_Str"").getClass(),serializer);
  Table<Integer,Integer,Integer> baseTable=HashBasedTable.create();
  baseTable.put(1,2,3);
  baseTable.put(4,5,6);
  Table<Integer,Integer,Integer> table=ImmutableTable.copyOf(baseTable);
  kryo.register(table.values().getClass(),serializer);
}","/** 
 * Creates a new   {@link ImmutableListSerializer} and registers its serializer for the severalImmutableList related classes.
 * @param kryo the {@link Kryo} instance to set the serializer on
 */
static void registerSerializers(Kryo kryo){
  ImmutableListSerializer serializer=new ImmutableListSerializer();
  kryo.register(ImmutableList.class,serializer);
  kryo.register(ImmutableList.of().getClass(),serializer);
  kryo.register(ImmutableList.of(1).getClass(),serializer);
  kryo.register(ImmutableList.of(1,2).getClass(),serializer);
  kryo.register(ImmutableList.of(1,2,3,4).subList(1,3).getClass(),serializer);
  kryo.register(ImmutableList.of(1,2).reverse().getClass(),serializer);
  kryo.register(Lists.charactersOf(""String_Node_Str"").getClass(),serializer);
  Table<Integer,Integer,Integer> baseTable=HashBasedTable.create();
  baseTable.put(1,2,3);
  baseTable.put(4,5,6);
  Table<Integer,Integer,Integer> table=ImmutableTable.copyOf(baseTable);
  kryo.register(table.values().getClass(),serializer);
}",0.9685598377281948
110631,"@Override public ImmutableMultimap<Object,Object> read(Kryo kryo,Input input,Class<ImmutableMultimap<Object,Object>> type){
  ImmutableMultimap.Builder<Object,Object> builder;
  if (type.equals(ImmutableListMultimap.class)) {
    builder=ImmutableMultimap.builder();
  }
 else   if (type.equals(ImmutableSetMultimap.class)) {
    builder=ImmutableSetMultimap.builder();
  }
 else {
    builder=ImmutableMultimap.builder();
  }
  @SuppressWarnings(""String_Node_Str"") Map<Object,Collection<Object>> map=kryo.readObject(input,ImmutableMap.class);
  for (  Map.Entry<Object,Collection<Object>> entry : map.entrySet()) {
    builder.putAll(entry.getKey(),entry.getValue());
  }
  return builder.build();
}","@Override public ImmutableMultimap<Object,Object> read(Kryo kryo,Input input,Class<ImmutableMultimap<Object,Object>> type){
  ImmutableMultimap.Builder<Object,Object> builder;
  if (type.equals(ImmutableListMultimap.class)) {
    builder=ImmutableListMultimap.builder();
  }
 else   if (type.equals(ImmutableSetMultimap.class)) {
    builder=ImmutableSetMultimap.builder();
  }
 else {
    builder=ImmutableMultimap.builder();
  }
  @SuppressWarnings(""String_Node_Str"") Map<Object,Collection<Object>> map=kryo.readObject(input,ImmutableMap.class);
  for (  Map.Entry<Object,Collection<Object>> entry : map.entrySet()) {
    builder.putAll(entry.getKey(),entry.getValue());
  }
  return builder.build();
}",0.9971509971509972
110632,"/** 
 * Registers Serializers defined in this package. 
 */
private static void registerSerializers(Kryo kryo){
  kryo.register(Ordering.natural().getClass());
  kryo.register(Collections.reverseOrder().getClass());
  HashCodeSerializer.registerSerializers(kryo);
  ImmutableListSerializer.registerSerializers(kryo);
  ImmutableMapSerializer.registerSerializers(kryo);
  ImmutableMultimapSerializer.registerSerializers(kryo);
  ImmutableSetSerializer.registerSerializers(kryo);
  ImmutableSortedSetSerializer.registerSerializers(kryo);
  MapEntrySerializer.registerSerializers(kryo);
  MultimapSerializer.registerSerializers(kryo);
  PatternSerializer.registerSerializers(kryo);
  ReverseListSerializer.registerSerializers(kryo);
  OptionalSerializer.registerSerializers(kryo);
  UnmodifiableNavigableSetSerializer.registerSerializers(kryo);
}","/** 
 * Registers Serializers defined in this package. 
 */
private static void registerSerializers(Kryo kryo){
  kryo.register(Ordering.natural().getClass());
  kryo.register(Collections.reverseOrder().getClass());
  ClassSerializer.registerSerializers(kryo);
  HashCodeSerializer.registerSerializers(kryo);
  ImmutableListSerializer.registerSerializers(kryo);
  ImmutableMapSerializer.registerSerializers(kryo);
  ImmutableMultimapSerializer.registerSerializers(kryo);
  ImmutableSetSerializer.registerSerializers(kryo);
  ImmutableSortedMapSerializer.registerSerializers(kryo);
  ImmutableSortedSetSerializer.registerSerializers(kryo);
  MapEntrySerializer.registerSerializers(kryo);
  MultimapSerializer.registerSerializers(kryo);
  PatternSerializer.registerSerializers(kryo);
  ReverseListSerializer.registerSerializers(kryo);
  OptionalSerializer.registerSerializers(kryo);
  UnmodifiableListSerializer.registerSerializers(kryo);
  UnmodifiableMapSerializer.registerSerializers(kryo);
  UnmodifiableNavigableSetSerializer.registerSerializers(kryo);
}",0.8873684210526316
110633,"@SuppressWarnings(""String_Node_Str"") @Override public T read(Kryo kryo,Input input,Class<T> unusedType){
  T multimap=create.get();
  int size=input.readInt(true);
  for (int i=0; i < size; ++i) {
    multimap.put((E)kryo.readClassAndObject(input),(E)kryo.readClassAndObject(input));
  }
  return multimap;
}","@SuppressWarnings(""String_Node_Str"") @Override public T read(Kryo kryo,Input input,Class<T> unusedType){
  T multimap=create.get();
  kryo.reference(multimap);
  int size=input.readInt(true);
  for (int i=0; i < size; ++i) {
    multimap.put((E)kryo.readClassAndObject(input),(E)kryo.readClassAndObject(input));
  }
  return multimap;
}",0.9565217391304348
110634,"@Override protected void addBuildVariables(RuleContext ruleContext,Variables.Builder variables) throws RuleErrorException {
  AppleConfiguration appleConfiguration=ruleContext.getFragment(AppleConfiguration.class);
  if (XcodeConfig.getXcodeVersion(ruleContext) == null) {
    ruleContext.throwWithRuleError(""String_Node_Str"");
  }
  ApplePlatform platform=appleConfiguration.getSingleArchPlatform();
  Map<String,String> appleEnv=getEnvironmentBuildVariables(ruleContext);
  variables.addStringVariable(XCODE_VERSION_KEY,XcodeConfig.getXcodeVersion(ruleContext).toStringWithMinimumComponents(2)).addStringVariable(IOS_SDK_VERSION_KEY,XcodeConfig.getSdkVersionForPlatform(ruleContext,ApplePlatform.IOS_SIMULATOR).toStringWithMinimumComponents(2)).addStringVariable(MACOS_SDK_VERSION_KEY,XcodeConfig.getSdkVersionForPlatform(ruleContext,ApplePlatform.MACOS).toStringWithMinimumComponents(2)).addStringVariable(TVOS_SDK_VERSION_KEY,XcodeConfig.getSdkVersionForPlatform(ruleContext,ApplePlatform.TVOS_SIMULATOR).toStringWithMinimumComponents(2)).addStringVariable(WATCHOS_SDK_VERSION_KEY,XcodeConfig.getSdkVersionForPlatform(ruleContext,ApplePlatform.WATCHOS_SIMULATOR).toStringWithMinimumComponents(2)).addStringVariable(SDK_DIR_KEY,AppleToolchain.sdkDir()).addStringVariable(SDK_FRAMEWORK_DIR_KEY,AppleToolchain.sdkFrameworkDir(platform,ruleContext)).addStringVariable(PLATFORM_DEVELOPER_FRAMEWORK_DIR,AppleToolchain.platformDeveloperFrameworkDir(appleConfiguration)).addStringVariable(XCODE_VERISON_OVERRIDE_VALUE_KEY,appleEnv.getOrDefault(AppleConfiguration.XCODE_VERSION_ENV_NAME,""String_Node_Str"")).addStringVariable(APPLE_SDK_VERSION_OVERRIDE_VALUE_KEY,appleEnv.getOrDefault(AppleConfiguration.APPLE_SDK_VERSION_ENV_NAME,""String_Node_Str"")).addStringVariable(APPLE_SDK_PLATFORM_VALUE_KEY,appleEnv.getOrDefault(AppleConfiguration.APPLE_SDK_PLATFORM_ENV_NAME,""String_Node_Str"")).addStringVariable(VERSION_MIN_KEY,XcodeConfig.getMinimumOsForPlatformType(ruleContext,platform.getType()).toString());
}","@Override protected void addBuildVariables(RuleContext ruleContext,Variables.Builder variables) throws RuleErrorException {
  AppleConfiguration appleConfiguration=ruleContext.getFragment(AppleConfiguration.class);
  if (XcodeConfig.getXcodeVersion(ruleContext) == null) {
    ruleContext.throwWithRuleError(""String_Node_Str"" + ""String_Node_Str"");
  }
  ApplePlatform platform=appleConfiguration.getSingleArchPlatform();
  Map<String,String> appleEnv=getEnvironmentBuildVariables(ruleContext);
  variables.addStringVariable(XCODE_VERSION_KEY,XcodeConfig.getXcodeVersion(ruleContext).toStringWithMinimumComponents(2)).addStringVariable(IOS_SDK_VERSION_KEY,XcodeConfig.getSdkVersionForPlatform(ruleContext,ApplePlatform.IOS_SIMULATOR).toStringWithMinimumComponents(2)).addStringVariable(MACOS_SDK_VERSION_KEY,XcodeConfig.getSdkVersionForPlatform(ruleContext,ApplePlatform.MACOS).toStringWithMinimumComponents(2)).addStringVariable(TVOS_SDK_VERSION_KEY,XcodeConfig.getSdkVersionForPlatform(ruleContext,ApplePlatform.TVOS_SIMULATOR).toStringWithMinimumComponents(2)).addStringVariable(WATCHOS_SDK_VERSION_KEY,XcodeConfig.getSdkVersionForPlatform(ruleContext,ApplePlatform.WATCHOS_SIMULATOR).toStringWithMinimumComponents(2)).addStringVariable(SDK_DIR_KEY,AppleToolchain.sdkDir()).addStringVariable(SDK_FRAMEWORK_DIR_KEY,AppleToolchain.sdkFrameworkDir(platform,ruleContext)).addStringVariable(PLATFORM_DEVELOPER_FRAMEWORK_DIR,AppleToolchain.platformDeveloperFrameworkDir(appleConfiguration)).addStringVariable(XCODE_VERISON_OVERRIDE_VALUE_KEY,appleEnv.getOrDefault(AppleConfiguration.XCODE_VERSION_ENV_NAME,""String_Node_Str"")).addStringVariable(APPLE_SDK_VERSION_OVERRIDE_VALUE_KEY,appleEnv.getOrDefault(AppleConfiguration.APPLE_SDK_VERSION_ENV_NAME,""String_Node_Str"")).addStringVariable(APPLE_SDK_PLATFORM_VALUE_KEY,appleEnv.getOrDefault(AppleConfiguration.APPLE_SDK_PLATFORM_ENV_NAME,""String_Node_Str"")).addStringVariable(VERSION_MIN_KEY,XcodeConfig.getMinimumOsForPlatformType(ruleContext,platform.getType()).toString());
}",0.9950273495773247
110635,"@Test public void errorTransienceBug() throws Exception {
  tester.getOrCreate(""String_Node_Str"").setHasTransientError(true);
  assertThat(tester.evalAndGetError(""String_Node_Str"").getException()).isNotNull();
  StringValue value=new StringValue(""String_Node_Str"");
  tester.getOrCreate(""String_Node_Str"").setHasTransientError(false).setConstantValue(value);
  tester.invalidateTransientErrors();
  assertThat(tester.evalAndGet(""String_Node_Str"")).isEqualTo(value);
}","@Test public void errorTransienceBug() throws Exception {
  tester.getOrCreate(""String_Node_Str"").setHasTransientError(true);
  assertThat(tester.evalAndGetError(true,""String_Node_Str"").getException()).isNotNull();
  StringValue value=new StringValue(""String_Node_Str"");
  tester.getOrCreate(""String_Node_Str"").setHasTransientError(false).setConstantValue(value);
  tester.invalidateTransientErrors();
  assertThat(tester.evalAndGet(""String_Node_Str"")).isEqualTo(value);
}",0.9946751863684772
110636,"protected void runTestPersistentErrorsNotRerun(boolean includeTransientError) throws Exception {
  SkyKey topKey=GraphTester.toSkyKey(""String_Node_Str"");
  SkyKey transientErrorKey=GraphTester.toSkyKey(""String_Node_Str"");
  SkyKey persistentErrorKey1=GraphTester.toSkyKey(""String_Node_Str"");
  SkyKey persistentErrorKey2=GraphTester.toSkyKey(""String_Node_Str"");
  TestFunction topFunction=tester.getOrCreate(topKey).addErrorDependency(persistentErrorKey1,new StringValue(""String_Node_Str"")).setHasError(true);
  tester.getOrCreate(persistentErrorKey1).setHasError(true);
  if (includeTransientError) {
    topFunction.addErrorDependency(transientErrorKey,new StringValue(""String_Node_Str""));
    tester.getOrCreate(transientErrorKey).addErrorDependency(persistentErrorKey2,new StringValue(""String_Node_Str"")).setHasTransientError(true);
  }
  tester.getOrCreate(persistentErrorKey2).setHasError(true);
  tester.evalAndGetError(topKey);
  if (includeTransientError) {
    assertThat(tester.getEnqueuedValues()).containsExactly(topKey,transientErrorKey,persistentErrorKey1,persistentErrorKey2);
  }
 else {
    assertThat(tester.getEnqueuedValues()).containsExactly(topKey,persistentErrorKey1);
  }
  tester.invalidate();
  tester.invalidateTransientErrors();
  tester.evalAndGetError(topKey);
  if (includeTransientError) {
    assertThat(tester.getEnqueuedValues()).containsExactly(topKey,transientErrorKey);
  }
 else {
    assertThat(tester.getEnqueuedValues()).isEmpty();
  }
}","protected void runTestPersistentErrorsNotRerun(boolean includeTransientError) throws Exception {
  SkyKey topKey=GraphTester.toSkyKey(""String_Node_Str"");
  SkyKey transientErrorKey=GraphTester.toSkyKey(""String_Node_Str"");
  SkyKey persistentErrorKey1=GraphTester.toSkyKey(""String_Node_Str"");
  SkyKey persistentErrorKey2=GraphTester.toSkyKey(""String_Node_Str"");
  TestFunction topFunction=tester.getOrCreate(topKey).addErrorDependency(persistentErrorKey1,new StringValue(""String_Node_Str"")).setHasError(true);
  tester.getOrCreate(persistentErrorKey1).setHasError(true);
  if (includeTransientError) {
    topFunction.addErrorDependency(transientErrorKey,new StringValue(""String_Node_Str""));
    tester.getOrCreate(transientErrorKey).addErrorDependency(persistentErrorKey2,new StringValue(""String_Node_Str"")).setHasTransientError(true);
  }
  tester.getOrCreate(persistentErrorKey2).setHasError(true);
  tester.evalAndGetError(true,topKey);
  if (includeTransientError) {
    assertThat(tester.getEnqueuedValues()).containsExactly(topKey,transientErrorKey,persistentErrorKey1,persistentErrorKey2);
  }
 else {
    assertThat(tester.getEnqueuedValues()).containsExactly(topKey,persistentErrorKey1);
  }
  tester.invalidate();
  tester.invalidateTransientErrors();
  tester.evalAndGetError(true,topKey);
  if (includeTransientError) {
    assertThat(tester.getEnqueuedValues()).containsExactly(topKey,transientErrorKey);
  }
 else {
    assertThat(tester.getEnqueuedValues()).isEmpty();
  }
}",0.9966329966329966
110637,"/** 
 * Regression test for 2014 bug: error transience value is registered before newly requested deps. A value requests a child, gets it back immediately, and then throws, causing the error transience value to be registered as a dep. The following build, the error is invalidated via that child.
 */
@Test public void doubleDepOnErrorTransienceValue() throws Exception {
  initializeTester();
  SkyKey leafKey=GraphTester.toSkyKey(""String_Node_Str"");
  tester.set(leafKey,new StringValue(""String_Node_Str""));
  assertThat(tester.evalAndGet(false,leafKey)).isEqualTo(new StringValue(""String_Node_Str""));
  SkyKey topKey=GraphTester.toSkyKey(""String_Node_Str"");
  tester.getOrCreate(topKey).addDependency(leafKey).setHasError(true);
  assertThat(tester.evalAndGetError(topKey).getRootCauses()).containsExactly(topKey).inOrder();
  tester.set(leafKey,new StringValue(""String_Node_Str""));
  tester.invalidate();
  assertThat(tester.evalAndGetError(topKey).getRootCauses()).containsExactly(topKey).inOrder();
}","/** 
 * Regression test for 2014 bug: error transience value is registered before newly requested deps. A value requests a child, gets it back immediately, and then throws, causing the error transience value to be registered as a dep. The following build, the error is invalidated via that child.
 */
@Test public void doubleDepOnErrorTransienceValue() throws Exception {
  initializeTester();
  SkyKey leafKey=GraphTester.toSkyKey(""String_Node_Str"");
  tester.set(leafKey,new StringValue(""String_Node_Str""));
  assertThat(tester.evalAndGet(false,leafKey)).isEqualTo(new StringValue(""String_Node_Str""));
  SkyKey topKey=GraphTester.toSkyKey(""String_Node_Str"");
  tester.getOrCreate(topKey).addDependency(leafKey).setHasError(true);
  assertThat(tester.evalAndGetError(true,topKey).getRootCauses()).containsExactly(topKey).inOrder();
  tester.set(leafKey,new StringValue(""String_Node_Str""));
  tester.invalidate();
  assertThat(tester.evalAndGetError(true,topKey).getRootCauses()).containsExactly(topKey).inOrder();
}",0.9950544015825916
110638,"@Test public void errorValueDepOnWarningValue() throws Exception {
  tester.getOrCreate(""String_Node_Str"").setHasError(true).addDependency(""String_Node_Str"");
  tester.set(""String_Node_Str"",new StringValue(""String_Node_Str"")).setWarning(""String_Node_Str"");
  for (int i=0; i < 2; i++) {
    initializeReporter();
    tester.evalAndGetError(""String_Node_Str"");
    if (i == 0 || eventsStored()) {
      assertThatEvents(eventCollector).containsExactly(""String_Node_Str"");
    }
  }
  initializeReporter();
  tester.evalAndGet(""String_Node_Str"");
  if (eventsStored()) {
    assertThatEvents(eventCollector).containsExactly(""String_Node_Str"");
  }
}","@Test public void errorValueDepOnWarningValue() throws Exception {
  tester.getOrCreate(""String_Node_Str"").setHasError(true).addDependency(""String_Node_Str"");
  tester.set(""String_Node_Str"",new StringValue(""String_Node_Str"")).setWarning(""String_Node_Str"");
  for (int i=0; i < 2; i++) {
    initializeReporter();
    tester.evalAndGetError(true,""String_Node_Str"");
    if (i == 0 || eventsStored()) {
      assertThatEvents(eventCollector).containsExactly(""String_Node_Str"");
    }
  }
  initializeReporter();
  tester.evalAndGet(""String_Node_Str"");
  if (eventsStored()) {
    assertThatEvents(eventCollector).containsExactly(""String_Node_Str"");
  }
}",0.9961508852963818
110639,"@Test public void errorChanged() throws Exception {
  SkyKey error=GraphTester.skyKey(""String_Node_Str"");
  tester.getOrCreate(error).setHasError(true);
  assertThatErrorInfo(tester.evalAndGetError(error)).hasExceptionThat().isNotNull();
  tester.getOrCreate(error,true);
  tester.invalidate();
  assertThatErrorInfo(tester.evalAndGetError(error)).hasExceptionThat().isNotNull();
}","@Test public void errorChanged() throws Exception {
  SkyKey error=GraphTester.skyKey(""String_Node_Str"");
  tester.getOrCreate(error).setHasError(true);
  assertThatErrorInfo(tester.evalAndGetError(true,error)).hasExceptionThat().isNotNull();
  tester.getOrCreate(error,true);
  tester.invalidate();
  assertThatErrorInfo(tester.evalAndGetError(true,error)).hasExceptionThat().isNotNull();
}",0.9870466321243524
110640,"@Test public void errorDepAlreadyThereThenTurnedGood() throws Exception {
  initializeTester();
  SkyKey errorKey=GraphTester.toSkyKey(""String_Node_Str"");
  tester.getOrCreate(errorKey).setHasError(true);
  SkyKey parentKey=GraphTester.toSkyKey(""String_Node_Str"");
  tester.getOrCreate(parentKey).addErrorDependency(errorKey,new StringValue(""String_Node_Str"")).setHasError(true);
  assertThat(tester.evalAndGetError(errorKey).getRootCauses()).containsExactly(errorKey);
  EvaluationResult<StringValue> result=tester.eval(false,parentKey);
  assertThat(result.getError(parentKey).getRootCauses()).containsExactly(parentKey).inOrder();
  tester.set(errorKey,new StringValue(""String_Node_Str"")).setHasError(false);
  tester.getOrCreate(parentKey,false).setHasError(false).setComputedValue(COPY);
  tester.differencer.invalidate(ImmutableList.of(errorKey));
  tester.invalidate();
  result=tester.eval(false,parentKey);
  assertThat(result.errorMap()).isEmpty();
  assertThat(result.get(parentKey).getValue()).isEqualTo(""String_Node_Str"");
  tester.getOrCreate(parentKey,false).setHasError(true);
  tester.invalidateTransientErrors();
  result=tester.eval(false,parentKey);
  assertThat(result.errorMap()).isEmpty();
  assertThat(result.get(parentKey).getValue()).isEqualTo(""String_Node_Str"");
}","@Test public void errorDepAlreadyThereThenTurnedGood() throws Exception {
  initializeTester();
  SkyKey errorKey=GraphTester.toSkyKey(""String_Node_Str"");
  tester.getOrCreate(errorKey).setHasError(true);
  SkyKey parentKey=GraphTester.toSkyKey(""String_Node_Str"");
  tester.getOrCreate(parentKey).addErrorDependency(errorKey,new StringValue(""String_Node_Str"")).setHasError(true);
  assertThat(tester.evalAndGetError(true,errorKey).getRootCauses()).containsExactly(errorKey);
  EvaluationResult<StringValue> result=tester.eval(false,parentKey);
  assertThat(result.getError(parentKey).getRootCauses()).containsExactly(parentKey).inOrder();
  tester.set(errorKey,new StringValue(""String_Node_Str"")).setHasError(false);
  tester.getOrCreate(parentKey,false).setHasError(false).setComputedValue(COPY);
  tester.differencer.invalidate(ImmutableList.of(errorKey));
  tester.invalidate();
  result=tester.eval(false,parentKey);
  assertThat(result.errorMap()).isEmpty();
  assertThat(result.get(parentKey).getValue()).isEqualTo(""String_Node_Str"");
  tester.getOrCreate(parentKey,false).setHasError(true);
  tester.invalidateTransientErrors();
  result=tester.eval(false,parentKey);
  assertThat(result.errorMap()).isEmpty();
  assertThat(result.get(parentKey).getValue()).isEqualTo(""String_Node_Str"");
}",0.998067259373792
110641,"@Test public void transientErrorTurningGoodHasNoError() throws Exception {
  initializeTester();
  SkyKey errorKey=GraphTester.toSkyKey(""String_Node_Str"");
  tester.getOrCreate(errorKey).setHasTransientError(true);
  ErrorInfo errorInfo=tester.evalAndGetError(errorKey);
  assertThat(errorInfo).isNotNull();
  assertThat(errorInfo.getRootCauses()).containsExactly(errorKey);
  tester.invalidateTransientErrors();
  errorInfo=tester.evalAndGetError(errorKey);
  assertThat(errorInfo).isNotNull();
  StringValue value=new StringValue(""String_Node_Str"");
  assertThat(errorInfo.getRootCauses()).containsExactly(errorKey);
  tester.getOrCreate(errorKey,false).setHasTransientError(false).setConstantValue(value);
  tester.invalidateTransientErrors();
  StringValue stringValue=(StringValue)tester.evalAndGet(true,errorKey);
  assertThat(value).isSameAs(stringValue);
  tester.getOrCreate(errorKey,false).setHasTransientError(true);
  tester.invalidateTransientErrors();
  stringValue=(StringValue)tester.evalAndGet(true,errorKey);
  assertThat(stringValue).isEqualTo(value);
}","@Test public void transientErrorTurningGoodHasNoError() throws Exception {
  initializeTester();
  SkyKey errorKey=GraphTester.toSkyKey(""String_Node_Str"");
  tester.getOrCreate(errorKey).setHasTransientError(true);
  ErrorInfo errorInfo=tester.evalAndGetError(true,errorKey);
  assertThat(errorInfo).isNotNull();
  assertThat(errorInfo.getRootCauses()).containsExactly(errorKey);
  tester.invalidateTransientErrors();
  errorInfo=tester.evalAndGetError(true,errorKey);
  assertThat(errorInfo).isNotNull();
  StringValue value=new StringValue(""String_Node_Str"");
  assertThat(errorInfo.getRootCauses()).containsExactly(errorKey);
  tester.getOrCreate(errorKey,false).setHasTransientError(false).setConstantValue(value);
  tester.invalidateTransientErrors();
  StringValue stringValue=(StringValue)tester.evalAndGet(true,errorKey);
  assertThat(value).isSameAs(stringValue);
  tester.getOrCreate(errorKey,false).setHasTransientError(true);
  tester.invalidateTransientErrors();
  stringValue=(StringValue)tester.evalAndGet(true,errorKey);
  assertThat(stringValue).isEqualTo(value);
}",0.9953574744661096
110642,"@Override public SkyValue compute(Map<SkyKey,SkyValue> deps,SkyFunction.Environment env){
  return Preconditions.checkNotNull(deps.get(key));
}","@Nullable @Override public SkyValue compute(SkyKey skyKey,Environment env) throws SkyFunctionException, InterruptedException {
  numParentComputeCalls.incrementAndGet();
  if (!keepGoing || numParentComputeCalls.get() == 1) {
    Preconditions.checkState(env.getValue(childKey) == null);
    Preconditions.checkState(env.getValue(childKey) == null);
  }
 else {
    Preconditions.checkState(env.getValue(childKey).equals(childValue));
    Preconditions.checkState(env.getValue(childKey).equals(childValue));
  }
  throw new GenericFunctionException(parentExn,Transience.PERSISTENT);
}",0.1513067400275103
110643,"@Override public String extractTag(SkyKey skyKey){
  return null;
}","@Nullable @Override public String extractTag(SkyKey skyKey){
  return null;
}",0.9305555555555556
110644,"@Test public void transientPruning() throws Exception {
  SkyKey leaf=GraphTester.toSkyKey(""String_Node_Str"");
  tester.getOrCreate(""String_Node_Str"").setHasTransientError(true).addDependency(leaf);
  tester.set(leaf,new StringValue(""String_Node_Str""));
  tester.evalAndGetError(""String_Node_Str"");
  tester.getOrCreate(leaf,true);
  tester.invalidate();
  tester.evalAndGetError(""String_Node_Str"");
}","@Test public void transientPruning() throws Exception {
  SkyKey leaf=GraphTester.toSkyKey(""String_Node_Str"");
  tester.getOrCreate(""String_Node_Str"").setHasTransientError(true).addDependency(leaf);
  tester.set(leaf,new StringValue(""String_Node_Str""));
  tester.evalAndGetError(true,""String_Node_Str"");
  tester.getOrCreate(leaf,true);
  tester.invalidate();
  tester.evalAndGetError(true,""String_Node_Str"");
}",0.9876847290640394
110645,"@Test public void dirtyErrorTransienceValue() throws Exception {
  initializeTester();
  SkyKey error=GraphTester.toSkyKey(""String_Node_Str"");
  tester.getOrCreate(error).setHasError(true);
  assertThat(tester.evalAndGetError(error)).isNotNull();
  tester.invalidateTransientErrors();
  SkyKey secondError=GraphTester.toSkyKey(""String_Node_Str"");
  tester.getOrCreate(secondError).setHasError(true);
  assertThat(tester.evalAndGetError(secondError)).isNotNull();
}","@Test public void dirtyErrorTransienceValue() throws Exception {
  initializeTester();
  SkyKey error=GraphTester.toSkyKey(""String_Node_Str"");
  tester.getOrCreate(error).setHasError(true);
  assertThat(tester.evalAndGetError(true,error)).isNotNull();
  tester.invalidateTransientErrors();
  SkyKey secondError=GraphTester.toSkyKey(""String_Node_Str"");
  tester.getOrCreate(secondError).setHasError(true);
  assertThat(tester.evalAndGetError(true,secondError)).isNotNull();
}",0.9893390191897654
110646,"@Test public void valueInjectionOverValueWithErrors() throws Exception {
  SkyKey key=GraphTester.toSkyKey(""String_Node_Str"");
  SkyValue val=new StringValue(""String_Node_Str"");
  tester.getOrCreate(key).setHasError(true);
  tester.evalAndGetError(key);
  tester.differencer.inject(ImmutableMap.of(key,val));
  assertThat(tester.evalAndGet(false,key)).isEqualTo(val);
}","@Test public void valueInjectionOverValueWithErrors() throws Exception {
  SkyKey key=GraphTester.toSkyKey(""String_Node_Str"");
  SkyValue val=new StringValue(""String_Node_Str"");
  tester.getOrCreate(key).setHasError(true);
  tester.evalAndGetError(true,key);
  tester.differencer.inject(ImmutableMap.of(key,val));
  assertThat(tester.evalAndGet(false,key)).isEqualTo(val);
}",0.993270524899058
110647,"@Test public void cachedErrorShutsDownThreadpool() throws Exception {
  SkyKey cachedErrorKey=GraphTester.skyKey(""String_Node_Str"");
  tester.getOrCreate(cachedErrorKey).setHasError(true);
  assertThat(tester.evalAndGetError(cachedErrorKey)).isNotNull();
  SkyKey topKey=GraphTester.skyKey(""String_Node_Str"");
  tester.getOrCreate(topKey).addDependency(cachedErrorKey).setComputedValue(CONCATENATE);
  SkyKey newErrorKey=GraphTester.skyKey(""String_Node_Str"");
  tester.getOrCreate(newErrorKey).setBuilder(new ChainedFunction.Builder().setWaitForException(true).setWaitToFinish(new CountDownLatch(0)).setValue(null).build());
  EvaluationResult<StringValue> result=tester.eval(false,newErrorKey,topKey);
  assertThatEvaluationResult(result).hasError();
  assertThatEvaluationResult(result).hasErrorEntryForKeyThat(newErrorKey).isNull();
}","@Test public void cachedErrorShutsDownThreadpool() throws Exception {
  SkyKey cachedErrorKey=GraphTester.skyKey(""String_Node_Str"");
  tester.getOrCreate(cachedErrorKey).setHasError(true);
  assertThat(tester.evalAndGetError(true,cachedErrorKey)).isNotNull();
  SkyKey topKey=GraphTester.skyKey(""String_Node_Str"");
  tester.getOrCreate(topKey).addDependency(cachedErrorKey).setComputedValue(CONCATENATE);
  SkyKey newErrorKey=GraphTester.skyKey(""String_Node_Str"");
  tester.getOrCreate(newErrorKey).setBuilder(new ChainedFunction.Builder().setWaitForException(true).setWaitToFinish(new CountDownLatch(0)).setValue(null).build());
  EvaluationResult<StringValue> result=tester.eval(false,newErrorKey,topKey);
  assertThatEvaluationResult(result).hasError();
  assertThatEvaluationResult(result).hasErrorEntryForKeyThat(newErrorKey).isNull();
}",0.997022036926742
110648,"@Test public void transientErrorValueInvalidation() throws Exception {
  tester.getOrCreate(""String_Node_Str"").setHasTransientError(true).setProgress(""String_Node_Str"");
  tester.evalAndGetError(""String_Node_Str"");
  assertThatEvents(eventCollector).containsExactly(""String_Node_Str"");
  tester.getOrCreate(""String_Node_Str"").setHasTransientError(true).setProgress(""String_Node_Str"");
  for (int i=0; i < 2; i++) {
    initializeReporter();
    tester.evalAndGetError(""String_Node_Str"");
    assertThatEvents(eventCollector).isEmpty();
  }
  initializeReporter();
  tester.invalidateTransientErrors();
  tester.evalAndGetError(""String_Node_Str"");
  assertThatEvents(eventCollector).containsExactly(""String_Node_Str"");
}","@Test public void transientErrorValueInvalidation() throws Exception {
  tester.getOrCreate(""String_Node_Str"").setHasTransientError(true).setProgress(""String_Node_Str"");
  tester.evalAndGetError(true,""String_Node_Str"");
  assertThatEvents(eventCollector).containsExactly(""String_Node_Str"");
  tester.getOrCreate(""String_Node_Str"").setHasTransientError(true).setProgress(""String_Node_Str"");
  for (int i=0; i < 2; i++) {
    initializeReporter();
    tester.evalAndGetError(true,""String_Node_Str"");
    assertThatEvents(eventCollector).isEmpty();
  }
  initializeReporter();
  tester.invalidateTransientErrors();
  tester.evalAndGetError(true,""String_Node_Str"");
  assertThatEvents(eventCollector).containsExactly(""String_Node_Str"");
}",0.9896765313145216
110649,"public ErrorInfo evalAndGetError(String key) throws InterruptedException {
  return evalAndGetError(toSkyKey(key));
}","public ErrorInfo evalAndGetError(boolean keepGoing,String key) throws InterruptedException {
  return evalAndGetError(keepGoing,toSkyKey(key));
}",0.8931297709923665
110650,"private ImmutableList<Path> findUnprocessed(String pathPrefix) throws IOException {
  Path rootPathPrefix=rootDirectory.resolve(pathPrefix);
  final String rootPathPrefixStr=rootPathPrefix.toString();
  if (!Files.exists(rootPathPrefix.getParent())) {
    return ImmutableList.of();
  }
  try (Stream<Path> paths=Files.list(rootPathPrefix.getParent()).filter(path -> path.toString().startsWith(rootPathPrefixStr) && !existingPaths.contains(path))){
    return paths.collect(ImmutableList.toImmutableList());
  }
 }","private ImmutableList<Path> findUnprocessed(String pathPrefix) throws IOException {
  Path rootPathPrefix=rootDirectory.resolve(pathPrefix);
  final String rootPathPrefixStr=rootPathPrefix.toString();
  if (!Files.exists(rootPathPrefix.getParent())) {
    return ImmutableList.of();
  }
  try (Stream<Path> paths=Files.list(rootPathPrefix.getParent())){
    return paths.filter(path -> path.toString().startsWith(rootPathPrefixStr) && !existingPaths.contains(path)).collect(ImmutableList.toImmutableList());
  }
 }",0.9163424124513618
110651,"private static Artifact createShuffleJarActions(RuleContext ruleContext,boolean makeDexArchives,@Nullable Artifact proguardedJar,ImmutableList<Artifact> shards,AndroidCommon common,@Nullable Artifact inclusionFilterJar,List<String> dexopts,AndroidSemantics semantics,JavaTargetAttributes attributes,Function<Artifact,Artifact> derivedJarFunction,@Nullable Artifact mainDexList) throws InterruptedException, RuleErrorException {
  checkArgument(!shards.isEmpty());
  checkArgument(mainDexList == null || shards.size() > 1);
  checkArgument(proguardedJar == null || inclusionFilterJar == null);
  Artifact javaResourceJar=ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.JAVA_RESOURCES_JAR);
  ImmutableList<Artifact> shuffleOutputs;
  if (makeDexArchives && proguardedJar != null) {
    checkArgument(shards.size() > 1);
    shuffleOutputs=makeShardArtifacts(ruleContext,shards.size(),""String_Node_Str"");
  }
 else {
    shuffleOutputs=shards;
  }
  SpawnAction.Builder shardAction=new SpawnAction.Builder().useDefaultShellEnvironment().setMnemonic(""String_Node_Str"").setProgressMessage(""String_Node_Str"",ruleContext.getLabel()).setExecutable(ruleContext.getExecutablePrerequisite(""String_Node_Str"",Mode.HOST)).addOutputs(shuffleOutputs).addOutput(javaResourceJar);
  CustomCommandLine.Builder shardCommandLine=CustomCommandLine.builder().addExecPaths(VectorArg.addBefore(""String_Node_Str"").each(shuffleOutputs)).addExecPath(""String_Node_Str"",javaResourceJar);
  if (mainDexList != null) {
    shardCommandLine.addExecPath(""String_Node_Str"",mainDexList);
    shardAction.addInput(mainDexList);
  }
  if (proguardedJar != null) {
    shardCommandLine.addExecPath(""String_Node_Str"",proguardedJar);
    shardAction.addInput(proguardedJar);
  }
 else {
    ImmutableList<Artifact> classpath=collectRuntimeJars(common,attributes);
    if (makeDexArchives) {
      Map<Artifact,Artifact> dexArchives=collectDexArchives(ruleContext,common,dexopts,semantics,derivedJarFunction);
      classpath=toDexedClasspath(ruleContext,classpath,dexArchives);
      shardCommandLine.add(""String_Node_Str"");
    }
 else {
      classpath=classpath.stream().map(derivedJarFunction).collect(toImmutableList());
    }
    shardCommandLine.addExecPaths(VectorArg.addBefore(""String_Node_Str"").each(classpath));
    shardAction.addInputs(classpath);
    if (inclusionFilterJar != null) {
      shardCommandLine.addExecPath(""String_Node_Str"",inclusionFilterJar);
      shardAction.addInput(inclusionFilterJar);
    }
  }
  shardAction.addCommandLine(shardCommandLine.build());
  ruleContext.registerAction(shardAction.build(ruleContext));
  if (makeDexArchives && proguardedJar != null) {
    for (int i=0; i < shards.size(); ++i) {
      checkState(shuffleOutputs.get(i) != shards.get(i));
      DexArchiveAspect.createDexArchiveAction(ruleContext,shuffleOutputs.get(i),DexArchiveAspect.topLevelDexbuilderDexopts(ruleContext,dexopts),shards.get(i));
    }
  }
  return javaResourceJar;
}","private static Artifact createShuffleJarActions(RuleContext ruleContext,boolean makeDexArchives,@Nullable Artifact proguardedJar,ImmutableList<Artifact> shards,AndroidCommon common,@Nullable Artifact inclusionFilterJar,List<String> dexopts,AndroidSemantics semantics,JavaTargetAttributes attributes,Function<Artifact,Artifact> derivedJarFunction,@Nullable Artifact mainDexList) throws InterruptedException, RuleErrorException {
  checkArgument(!shards.isEmpty());
  checkArgument(mainDexList == null || shards.size() > 1);
  checkArgument(proguardedJar == null || inclusionFilterJar == null);
  Artifact javaResourceJar=ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.JAVA_RESOURCES_JAR);
  ImmutableList<Artifact> shuffleOutputs;
  if (makeDexArchives && proguardedJar != null) {
    checkArgument(shards.size() > 1);
    shuffleOutputs=makeShardArtifacts(ruleContext,shards.size(),""String_Node_Str"");
  }
 else {
    shuffleOutputs=shards;
  }
  SpawnAction.Builder shardAction=new SpawnAction.Builder().useDefaultShellEnvironment().setMnemonic(""String_Node_Str"").setProgressMessage(""String_Node_Str"",ruleContext.getLabel()).setExecutable(ruleContext.getExecutablePrerequisite(""String_Node_Str"",Mode.HOST)).addOutputs(shuffleOutputs).addOutput(javaResourceJar);
  CustomCommandLine.Builder shardCommandLine=CustomCommandLine.builder().addExecPaths(VectorArg.addBefore(""String_Node_Str"").each(shuffleOutputs)).addExecPath(""String_Node_Str"",javaResourceJar);
  if (mainDexList != null) {
    shardCommandLine.addExecPath(""String_Node_Str"",mainDexList);
    shardAction.addInput(mainDexList);
  }
  if (proguardedJar != null) {
    shardCommandLine.addExecPath(""String_Node_Str"",proguardedJar);
    shardAction.addInput(proguardedJar);
  }
 else {
    ImmutableList<Artifact> classpath=collectRuntimeJars(common,attributes);
    if (makeDexArchives) {
      Map<Artifact,Artifact> dexArchives=collectDexArchives(ruleContext,common,dexopts,semantics,derivedJarFunction);
      classpath=toDexedClasspath(ruleContext,classpath,dexArchives);
      shardCommandLine.add(""String_Node_Str"");
    }
 else {
      classpath=classpath.stream().map(derivedJarFunction).collect(toImmutableList());
    }
    shardCommandLine.addExecPaths(VectorArg.addBefore(""String_Node_Str"").each(classpath));
    shardAction.addInputs(classpath);
    if (inclusionFilterJar != null) {
      shardCommandLine.addExecPath(""String_Node_Str"",inclusionFilterJar);
      shardAction.addInput(inclusionFilterJar);
    }
  }
  shardAction.addCommandLine(shardCommandLine.build());
  ruleContext.registerAction(shardAction.build(ruleContext));
  if (makeDexArchives && proguardedJar != null) {
    for (int i=0; i < shards.size(); ++i) {
      checkState(!shuffleOutputs.get(i).equals(shards.get(i)));
      DexArchiveAspect.createDexArchiveAction(ruleContext,shuffleOutputs.get(i),DexArchiveAspect.topLevelDexbuilderDexopts(ruleContext,dexopts),shards.get(i));
    }
  }
  return javaResourceJar;
}",0.9936026936026936
110652,"/** 
 * Specialized parallel variant of   {@link SkyQueryEnvironment#getRBuildFiles}. 
 */
static void getRBuildFilesParallel(SkyQueryEnvironment env,Collection<PathFragment> fileIdentifiers,Callback<Target> callback) throws QueryException, InterruptedException {
  Uniquifier<SkyKey> keyUniquifier=env.createSkyKeyUniquifier();
  RBuildFilesVisitor visitor=new RBuildFilesVisitor(env,keyUniquifier,callback);
  visitor.visitAndWaitForCompletion(env.getSkyKeysForFileFragments(fileIdentifiers));
}","/** 
 * Specialized parallel variant of   {@link SkyQueryEnvironment#getRBuildFiles}. 
 */
static void getRBuildFilesParallel(SkyQueryEnvironment env,Collection<PathFragment> fileIdentifiers,Callback<Target> callback) throws QueryException, InterruptedException {
  Uniquifier<SkyKey> keyUniquifier=env.createSkyKeyUniquifier();
  RBuildFilesVisitor visitor=new RBuildFilesVisitor(env,keyUniquifier,callback);
  visitor.visitAndWaitForCompletion(env.getFileStateKeysForFileFragments(fileIdentifiers));
}",0.99
110653,"/** 
 * Calculates the set of   {@link Package} objects, represented as source file targets, that dependon the given list of BUILD files and subincludes (other files are filtered out).
 */
@ThreadSafe QueryTaskFuture<Void> getRBuildFiles(Collection<PathFragment> fileIdentifiers,Callback<Target> callback){
  try {
    Collection<SkyKey> files=getSkyKeysForFileFragments(fileIdentifiers);
    Uniquifier<SkyKey> keyUniquifier=new UniquifierImpl<>(SkyKeyKeyExtractor.INSTANCE,1);
    Collection<SkyKey> current=keyUniquifier.unique(graph.getSuccessfulValues(files).keySet());
    Set<SkyKey> resultKeys=CompactHashSet.create();
    while (!current.isEmpty()) {
      Collection<Iterable<SkyKey>> reverseDeps=graph.getReverseDeps(current).values();
      current=new HashSet<>();
      for (      SkyKey rdep : Iterables.concat(reverseDeps)) {
        if (rdep.functionName().equals(SkyFunctions.PACKAGE)) {
          resultKeys.add(rdep);
          if (rdep.equals(PackageValue.key(Label.EXTERNAL_PACKAGE_IDENTIFIER))) {
            if (keyUniquifier.unique(rdep)) {
              current.add(rdep);
            }
          }
        }
 else         if (!rdep.functionName().equals(SkyFunctions.PACKAGE_LOOKUP)) {
          if (keyUniquifier.unique(rdep)) {
            current.add(rdep);
          }
        }
      }
      if (resultKeys.size() >= BATCH_CALLBACK_SIZE) {
        for (        Iterable<SkyKey> batch : Iterables.partition(resultKeys,BATCH_CALLBACK_SIZE)) {
          getBuildFileTargetsForPackageKeysAndProcessViaCallback(batch,callback);
        }
        resultKeys.clear();
      }
    }
    getBuildFileTargetsForPackageKeysAndProcessViaCallback(resultKeys,callback);
    return immediateSuccessfulFuture(null);
  }
 catch (  QueryException e) {
    return immediateFailedFuture(e);
  }
catch (  InterruptedException e) {
    return immediateCancelledFuture();
  }
}","/** 
 * Calculates the set of   {@link Package} objects, represented as source file targets, that dependon the given list of BUILD files and subincludes (other files are filtered out).
 */
@ThreadSafe QueryTaskFuture<Void> getRBuildFiles(Collection<PathFragment> fileIdentifiers,Callback<Target> callback){
  try {
    Collection<SkyKey> files=getFileStateKeysForFileFragments(fileIdentifiers);
    Uniquifier<SkyKey> keyUniquifier=new UniquifierImpl<>(SkyKeyKeyExtractor.INSTANCE,1);
    Collection<SkyKey> current=keyUniquifier.unique(graph.getSuccessfulValues(files).keySet());
    Set<SkyKey> resultKeys=CompactHashSet.create();
    while (!current.isEmpty()) {
      Collection<Iterable<SkyKey>> reverseDeps=graph.getReverseDeps(current).values();
      current=new HashSet<>();
      for (      SkyKey rdep : Iterables.concat(reverseDeps)) {
        if (rdep.functionName().equals(SkyFunctions.PACKAGE)) {
          resultKeys.add(rdep);
          if (rdep.equals(PackageValue.key(Label.EXTERNAL_PACKAGE_IDENTIFIER))) {
            if (keyUniquifier.unique(rdep)) {
              current.add(rdep);
            }
          }
        }
 else         if (!rdep.functionName().equals(SkyFunctions.PACKAGE_LOOKUP)) {
          if (keyUniquifier.unique(rdep)) {
            current.add(rdep);
          }
        }
      }
      if (resultKeys.size() >= BATCH_CALLBACK_SIZE) {
        for (        Iterable<SkyKey> batch : Iterables.partition(resultKeys,BATCH_CALLBACK_SIZE)) {
          getBuildFileTargetsForPackageKeysAndProcessViaCallback(batch,callback);
        }
        resultKeys.clear();
      }
    }
    getBuildFileTargetsForPackageKeysAndProcessViaCallback(resultKeys,callback);
    return immediateSuccessfulFuture(null);
  }
 catch (  QueryException e) {
    return immediateFailedFuture(e);
  }
catch (  InterruptedException e) {
    return immediateCancelledFuture();
  }
}",0.9968237162519852
110654,"/** 
 * Returns package lookup keys for looking up the package root for which there may be a relevant (from the perspective of   {@link #getRBuildFiles})   {@link FileValue} node in the graph for{@code originalFileFragment}, which is assumed to be a file path. <p>This is a helper function for   {@link #getSkyKeysForFileFragments}.
 */
private static Iterable<SkyKey> getPkgLookupKeysForFile(PathFragment originalFileFragment,PathFragment currentPathFragment){
  if (originalFileFragment.equals(currentPathFragment) && originalFileFragment.equals(Label.WORKSPACE_FILE_NAME)) {
    Preconditions.checkState(Label.WORKSPACE_FILE_NAME.getParentDirectory().equals(PathFragment.EMPTY_FRAGMENT),Label.WORKSPACE_FILE_NAME);
    return ImmutableList.of(PackageLookupValue.key(Label.EXTERNAL_PACKAGE_IDENTIFIER),PackageLookupValue.key(PackageIdentifier.createInMainRepo(PathFragment.EMPTY_FRAGMENT)));
  }
  PathFragment parentPathFragment=currentPathFragment.getParentDirectory();
  return parentPathFragment == null ? ImmutableList.<SkyKey>of() : ImmutableList.of(PackageLookupValue.key(PackageIdentifier.createInMainRepo(parentPathFragment)));
}","/** 
 * Returns package lookup keys for looking up the package root for which there may be a relevant (from the perspective of   {@link #getRBuildFiles})   {@link FileStateValue} node in the graph for{@code originalFileFragment}, which is assumed to be a file path. <p>This is a helper function for   {@link #getFileStateKeysForFileFragments}.
 */
private static Iterable<SkyKey> getPkgLookupKeysForFile(PathFragment originalFileFragment,PathFragment currentPathFragment){
  if (originalFileFragment.equals(currentPathFragment) && originalFileFragment.equals(Label.WORKSPACE_FILE_NAME)) {
    Preconditions.checkState(Label.WORKSPACE_FILE_NAME.getParentDirectory().equals(PathFragment.EMPTY_FRAGMENT),Label.WORKSPACE_FILE_NAME);
    return ImmutableList.of(PackageLookupValue.key(Label.EXTERNAL_PACKAGE_IDENTIFIER),PackageLookupValue.key(PackageIdentifier.createInMainRepo(PathFragment.EMPTY_FRAGMENT)));
  }
  PathFragment parentPathFragment=currentPathFragment.getParentDirectory();
  return parentPathFragment == null ? ImmutableList.<SkyKey>of() : ImmutableList.of(PackageLookupValue.key(PackageIdentifier.createInMainRepo(parentPathFragment)));
}",0.9934526407682236
110655,"/** 
 * The crux of the build system. Builds the targets specified in the request using the specified Executor. <p>Performs loading, analysis and execution for the specified set of targets, honoring the configuration options in the BuildRequest. Returns normally iff successful, throws an exception otherwise. <p>Callers must ensure that   {@link #stopRequest} is called after this method, even if itthrows. <p>The caller is responsible for setting up and syncing the package cache. <p>During this function's execution, the actualTargets and successfulTargets fields of the request object are set.
 * @param request the build request that this build tool is servicing, which specifies variousoptions; during this method's execution, the actualTargets and successfulTargets fields of the request object are populated
 * @param result the build result that is the mutable result of this build
 * @param validator target validator
 */
public void buildTargets(BuildRequest request,BuildResult result,TargetValidator validator) throws BuildFailedException, InterruptedException, ViewCreationFailedException, TargetParsingException, LoadingFailedException, AbruptExitException, InvalidConfigurationException, TestExecException {
  validateOptions(request);
  BuildOptions buildOptions=runtime.createBuildOptions(request);
  env.setupPackageCache(request,DefaultsPackage.getDefaultsPackageContent(buildOptions));
  ExecutionTool executionTool=null;
  boolean catastrophe=false;
  try {
    env.getEventBus().post(new BuildStartingEvent(env,request));
    logger.info(""String_Node_Str"" + request.getId());
    if (!request.getMultiCpus().isEmpty()) {
      getReporter().handle(Event.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""));
      if (!""String_Node_Str"".equals(request.getCommandName()) && !""String_Node_Str"".equals(request.getCommandName())) {
        throw new InvalidConfigurationException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    env.throwPendingException();
    LoadingResult loadingResult=evaluateTargetPatterns(request,validator);
    env.setWorkspaceName(loadingResult.getWorkspaceName());
    executionTool=new ExecutionTool(env,request);
    if (needsExecutionPhase(request.getBuildOptions())) {
      executionTool.init();
    }
    if (request.needsInstrumentationFilter()) {
      String instrumentationFilter=InstrumentationFilterSupport.computeInstrumentationFilter(env.getReporter(),loadingResult.getTestsToRun());
      try {
        buildOptions.get(BuildConfiguration.Options.class).instrumentationFilter=new RegexFilter.RegexFilterConverter().convert(instrumentationFilter);
      }
 catch (      OptionsParsingException e) {
        throw new InvalidConfigurationException(e);
      }
    }
    env.throwPendingException();
    BuildConfigurationCollection configurations=env.getSkyframeExecutor().createConfigurations(env.getReporter(),runtime.getConfigurationFragmentFactories(),buildOptions,request.getMultiCpus(),request.getViewOptions().keepGoing);
    env.throwPendingException();
    if (configurations.getTargetConfigurations().size() == 1) {
      env.getEventBus().post(new MakeEnvironmentEvent(configurations.getTargetConfigurations().get(0).getMakeEnvironment()));
    }
    logger.info(""String_Node_Str"");
    if (request.getBuildOptions().performAnalysisPhase) {
      AnalysisResult analysisResult=runAnalysisPhase(request,loadingResult,configurations);
      result.setBuildConfigurationCollection(configurations);
      result.setActualTargets(analysisResult.getTargetsToBuild());
      result.setTestTargets(analysisResult.getTargetsToTest());
      reportTargets(analysisResult);
      for (      ConfiguredTarget target : analysisResult.getTargetsToSkip()) {
        BuildConfiguration config=target.getConfiguration();
        Label label=target.getLabel();
        env.getEventBus().post(new AbortedEvent(BuildEventId.targetCompleted(label,config.getEventId()),AbortReason.SKIPPED,String.format(""String_Node_Str"",label),label));
      }
      if (request.getBuildOptions().queryExpression != null) {
        try {
          doConfiguredTargetQuery(request,configurations,loadingResult);
        }
 catch (        QueryException|IOException e) {
          if (!request.getViewOptions().keepGoing) {
            throw new ViewCreationFailedException(""String_Node_Str"",e);
          }
          env.getReporter().error(null,""String_Node_Str"",e);
        }
      }
      if (needsExecutionPhase(request.getBuildOptions())) {
        executionTool.executeBuild(request.getId(),analysisResult,result,configurations,analysisResult.getPackageRoots(),request.getTopLevelArtifactContext());
      }
 else {
        getReporter().post(new NoExecutionEvent());
      }
      String delayedErrorMsg=analysisResult.getError();
      if (delayedErrorMsg != null) {
        throw new BuildFailedException(delayedErrorMsg);
      }
    }
 else {
      getReporter().handle(Event.progress(""String_Node_Str""));
      getReporter().post(new NoAnalyzeEvent());
      logger.info(""String_Node_Str"");
      String errorMessage=BuildView.createErrorMessage(loadingResult,null);
      if (errorMessage != null) {
        throw new BuildFailedException(errorMessage);
      }
    }
  }
 catch (  RuntimeException e) {
    request.getOutErr().printErrLn(""String_Node_Str"" + e.getMessage());
    catastrophe=true;
    throw e;
  }
catch (  Error e) {
    catastrophe=true;
    throw e;
  }
catch (  InvalidConfigurationException e) {
    catastrophe=true;
    throw e;
  }
 finally {
    if (executionTool != null) {
      executionTool.shutdown();
    }
    if (!catastrophe) {
      long versionWindow=request.getViewOptions().versionWindowForDirtyNodeGc;
      if (versionWindow != -1) {
        env.getSkyframeExecutor().deleteOldNodes(versionWindow);
      }
      env.getEventBus().post(new BuildInfoEvent(env.getBlazeWorkspace().getWorkspaceStatusActionFactory().createDummyWorkspaceStatus()));
    }
  }
}","/** 
 * The crux of the build system. Builds the targets specified in the request using the specified Executor. <p>Performs loading, analysis and execution for the specified set of targets, honoring the configuration options in the BuildRequest. Returns normally iff successful, throws an exception otherwise. <p>Callers must ensure that   {@link #stopRequest} is called after this method, even if itthrows. <p>The caller is responsible for setting up and syncing the package cache. <p>During this function's execution, the actualTargets and successfulTargets fields of the request object are set.
 * @param request the build request that this build tool is servicing, which specifies variousoptions; during this method's execution, the actualTargets and successfulTargets fields of the request object are populated
 * @param result the build result that is the mutable result of this build
 * @param validator target validator
 */
public void buildTargets(BuildRequest request,BuildResult result,TargetValidator validator) throws BuildFailedException, InterruptedException, ViewCreationFailedException, TargetParsingException, LoadingFailedException, AbruptExitException, InvalidConfigurationException, TestExecException, ConfiguredTargetQueryCommandLineException {
  validateOptions(request);
  BuildOptions buildOptions=runtime.createBuildOptions(request);
  env.setupPackageCache(request,DefaultsPackage.getDefaultsPackageContent(buildOptions));
  ExecutionTool executionTool=null;
  boolean catastrophe=false;
  try {
    env.getEventBus().post(new BuildStartingEvent(env,request));
    logger.info(""String_Node_Str"" + request.getId());
    if (!request.getMultiCpus().isEmpty()) {
      getReporter().handle(Event.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""));
      if (!""String_Node_Str"".equals(request.getCommandName()) && !""String_Node_Str"".equals(request.getCommandName())) {
        throw new InvalidConfigurationException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    env.throwPendingException();
    LoadingResult loadingResult=evaluateTargetPatterns(request,validator);
    env.setWorkspaceName(loadingResult.getWorkspaceName());
    executionTool=new ExecutionTool(env,request);
    if (needsExecutionPhase(request.getBuildOptions())) {
      executionTool.init();
    }
    if (request.needsInstrumentationFilter()) {
      String instrumentationFilter=InstrumentationFilterSupport.computeInstrumentationFilter(env.getReporter(),loadingResult.getTestsToRun());
      try {
        buildOptions.get(BuildConfiguration.Options.class).instrumentationFilter=new RegexFilter.RegexFilterConverter().convert(instrumentationFilter);
      }
 catch (      OptionsParsingException e) {
        throw new InvalidConfigurationException(e);
      }
    }
    env.throwPendingException();
    BuildConfigurationCollection configurations=env.getSkyframeExecutor().createConfigurations(env.getReporter(),runtime.getConfigurationFragmentFactories(),buildOptions,request.getMultiCpus(),request.getViewOptions().keepGoing);
    env.throwPendingException();
    if (configurations.getTargetConfigurations().size() == 1) {
      env.getEventBus().post(new MakeEnvironmentEvent(configurations.getTargetConfigurations().get(0).getMakeEnvironment()));
    }
    logger.info(""String_Node_Str"");
    if (request.getBuildOptions().performAnalysisPhase) {
      AnalysisResult analysisResult=runAnalysisPhase(request,loadingResult,configurations);
      result.setBuildConfigurationCollection(configurations);
      result.setActualTargets(analysisResult.getTargetsToBuild());
      result.setTestTargets(analysisResult.getTargetsToTest());
      reportTargets(analysisResult);
      for (      ConfiguredTarget target : analysisResult.getTargetsToSkip()) {
        BuildConfiguration config=target.getConfiguration();
        Label label=target.getLabel();
        env.getEventBus().post(new AbortedEvent(BuildEventId.targetCompleted(label,config.getEventId()),AbortReason.SKIPPED,String.format(""String_Node_Str"",label),label));
      }
      if (request.getBuildOptions().queryExpression != null) {
        if (!env.getSkyframeExecutor().hasIncrementalState()) {
          throw new ConfiguredTargetQueryCommandLineException(""String_Node_Str"");
        }
        try {
          doConfiguredTargetQuery(request,configurations,loadingResult);
        }
 catch (        QueryException|IOException e) {
          if (!request.getViewOptions().keepGoing) {
            throw new ViewCreationFailedException(""String_Node_Str"",e);
          }
          env.getReporter().error(null,""String_Node_Str"",e);
        }
      }
      if (needsExecutionPhase(request.getBuildOptions())) {
        executionTool.executeBuild(request.getId(),analysisResult,result,configurations,analysisResult.getPackageRoots(),request.getTopLevelArtifactContext());
      }
 else {
        getReporter().post(new NoExecutionEvent());
      }
      String delayedErrorMsg=analysisResult.getError();
      if (delayedErrorMsg != null) {
        throw new BuildFailedException(delayedErrorMsg);
      }
    }
 else {
      getReporter().handle(Event.progress(""String_Node_Str""));
      getReporter().post(new NoAnalyzeEvent());
      logger.info(""String_Node_Str"");
      String errorMessage=BuildView.createErrorMessage(loadingResult,null);
      if (errorMessage != null) {
        throw new BuildFailedException(errorMessage);
      }
    }
  }
 catch (  RuntimeException e) {
    request.getOutErr().printErrLn(""String_Node_Str"" + e.getMessage());
    catastrophe=true;
    throw e;
  }
catch (  Error e) {
    catastrophe=true;
    throw e;
  }
catch (  InvalidConfigurationException e) {
    catastrophe=true;
    throw e;
  }
 finally {
    if (executionTool != null) {
      executionTool.shutdown();
    }
    if (!catastrophe) {
      long versionWindow=request.getViewOptions().versionWindowForDirtyNodeGc;
      if (versionWindow != -1) {
        env.getSkyframeExecutor().deleteOldNodes(versionWindow);
      }
      env.getEventBus().post(new BuildInfoEvent(env.getBlazeWorkspace().getWorkspaceStatusActionFactory().createDummyWorkspaceStatus()));
    }
  }
}",0.9835876288659794
110656,"/** 
 * The crux of the build system. Builds the targets specified in the request using the specified Executor. <p>Performs loading, analysis and execution for the specified set of targets, honoring the configuration options in the BuildRequest. Returns normally iff successful, throws an exception otherwise. <p>The caller is responsible for setting up and syncing the package cache. <p>During this function's execution, the actualTargets and successfulTargets fields of the request object are set.
 * @param request the build request that this build tool is servicing, which specifies variousoptions; during this method's execution, the actualTargets and successfulTargets fields of the request object are populated
 * @param validator target validator
 * @return the result as a {@link BuildResult} object
 */
public BuildResult processRequest(BuildRequest request,TargetValidator validator){
  BuildResult result=new BuildResult(request.getStartTime());
  env.getEventBus().register(result);
  maybeSetStopOnFirstFailure(request,result);
  Throwable catastrophe=null;
  ExitCode exitCode=ExitCode.BLAZE_INTERNAL_ERROR;
  try {
    buildTargets(request,result,validator);
    exitCode=ExitCode.SUCCESS;
  }
 catch (  BuildFailedException e) {
    if (e.isErrorAlreadyShown()) {
    }
 else {
      reportExceptionError(e);
    }
    if (e.isCatastrophic()) {
      result.setCatastrophe();
    }
    exitCode=e.getExitCode() != null ? e.getExitCode() : ExitCode.BUILD_FAILURE;
  }
catch (  InterruptedException e) {
    exitCode=env.getPendingExitCode();
    if (exitCode == null) {
      exitCode=ExitCode.INTERRUPTED;
      env.getReporter().handle(Event.error(""String_Node_Str""));
      env.getEventBus().post(new BuildInterruptedEvent());
    }
 else {
      reportExceptionError(env.getPendingException());
      result.setCatastrophe();
    }
  }
catch (  TargetParsingException|LoadingFailedException|ViewCreationFailedException e) {
    exitCode=ExitCode.PARSING_FAILURE;
    reportExceptionError(e);
  }
catch (  TestExecException e) {
    exitCode=ExitCode.SUCCESS;
    reportExceptionError(e);
  }
catch (  InvalidConfigurationException e) {
    exitCode=ExitCode.COMMAND_LINE_ERROR;
    reportExceptionError(e);
    result.setCatastrophe();
  }
catch (  AbruptExitException e) {
    exitCode=e.getExitCode();
    reportExceptionError(e);
    result.setCatastrophe();
  }
catch (  Throwable throwable) {
    catastrophe=throwable;
    Throwables.propagate(throwable);
  }
 finally {
    stopRequest(result,catastrophe,exitCode);
  }
  return result;
}","/** 
 * The crux of the build system. Builds the targets specified in the request using the specified Executor. <p>Performs loading, analysis and execution for the specified set of targets, honoring the configuration options in the BuildRequest. Returns normally iff successful, throws an exception otherwise. <p>The caller is responsible for setting up and syncing the package cache. <p>During this function's execution, the actualTargets and successfulTargets fields of the request object are set.
 * @param request the build request that this build tool is servicing, which specifies variousoptions; during this method's execution, the actualTargets and successfulTargets fields of the request object are populated
 * @param validator target validator
 * @return the result as a {@link BuildResult} object
 */
public BuildResult processRequest(BuildRequest request,TargetValidator validator){
  BuildResult result=new BuildResult(request.getStartTime());
  env.getEventBus().register(result);
  maybeSetStopOnFirstFailure(request,result);
  Throwable catastrophe=null;
  ExitCode exitCode=ExitCode.BLAZE_INTERNAL_ERROR;
  try {
    buildTargets(request,result,validator);
    exitCode=ExitCode.SUCCESS;
  }
 catch (  BuildFailedException e) {
    if (e.isErrorAlreadyShown()) {
    }
 else {
      reportExceptionError(e);
    }
    if (e.isCatastrophic()) {
      result.setCatastrophe();
    }
    exitCode=e.getExitCode() != null ? e.getExitCode() : ExitCode.BUILD_FAILURE;
  }
catch (  InterruptedException e) {
    exitCode=env.getPendingExitCode();
    if (exitCode == null) {
      exitCode=ExitCode.INTERRUPTED;
      env.getReporter().handle(Event.error(""String_Node_Str""));
      env.getEventBus().post(new BuildInterruptedEvent());
    }
 else {
      reportExceptionError(env.getPendingException());
      result.setCatastrophe();
    }
  }
catch (  TargetParsingException|LoadingFailedException|ViewCreationFailedException e) {
    exitCode=ExitCode.PARSING_FAILURE;
    reportExceptionError(e);
  }
catch (  ConfiguredTargetQueryCommandLineException e) {
    exitCode=ExitCode.COMMAND_LINE_ERROR;
    reportExceptionError(e);
  }
catch (  TestExecException e) {
    exitCode=ExitCode.SUCCESS;
    reportExceptionError(e);
  }
catch (  InvalidConfigurationException e) {
    exitCode=ExitCode.COMMAND_LINE_ERROR;
    reportExceptionError(e);
    result.setCatastrophe();
  }
catch (  AbruptExitException e) {
    exitCode=e.getExitCode();
    reportExceptionError(e);
    result.setCatastrophe();
  }
catch (  Throwable throwable) {
    catastrophe=throwable;
    Throwables.propagate(throwable);
  }
 finally {
    stopRequest(result,catastrophe,exitCode);
  }
  return result;
}",0.9313818665652918
110657,"/** 
 * Returns the names of all the packages under a given directory. <p>Packages returned by this method and passed into   {@link #bulkGetPackages(Iterable)} areexpected to return successful  {@link Package} values.
 * @param eventHandler any errors emitted during package lookup and loading for {@code directory}and non-excluded directories beneath it will be reported here
 * @param directory a {@link RootedPath} specifying the directory to search
 * @param blacklistedSubdirectories a set of {@link PathFragment}s, all of which are beneath  {@code directory}, specifying transitive subdirectories to that have been blacklisted
 * @param excludedSubdirectories a set of {@link PathFragment}s, all of which are beneath   {@code directory}, specifying transitive subdirectories to exclude
 */
Iterable<PathFragment> getPackagesUnderDirectory(ExtendedEventHandler eventHandler,RepositoryName repository,PathFragment directory,ImmutableSet<PathFragment> blacklistedSubdirectories,ImmutableSet<PathFragment> excludedSubdirectories) throws InterruptedException ;","/** 
 * Returns the names of all the packages under a given directory. <p>Packages returned by this method and passed into   {@link #bulkGetPackages(Iterable)} areexpected to return successful  {@link Package} values.
 * @param eventHandler any errors emitted during package lookup and loading for {@code directory}and non-excluded directories beneath it will be reported here
 * @param directory a {@link RootedPath} specifying the directory to search
 * @param blacklistedSubdirectories a set of {@link PathFragment}s, all of which are beneath  {@code directory} (not necessarily strictly), specifying transitive subdirectories thathave been blacklisted
 * @param excludedSubdirectories a set of {@link PathFragment}s, all of which are beneath   {@code directory} (not necessarily strictly), specifying transitive subdirectories to exclude
 */
Iterable<PathFragment> getPackagesUnderDirectory(ExtendedEventHandler eventHandler,RepositoryName repository,PathFragment directory,ImmutableSet<PathFragment> blacklistedSubdirectories,ImmutableSet<PathFragment> excludedSubdirectories) throws InterruptedException ;",0.9705340699815838
110658,"@Override public Iterable<PathFragment> getPackagesUnderDirectory(ExtendedEventHandler eventHandler,RepositoryName repository,PathFragment directory,ImmutableSet<PathFragment> blacklistedSubdirectories,ImmutableSet<PathFragment> excludedSubdirectories) throws MissingDepException, InterruptedException {
  PathPackageLocator packageLocator=PrecomputedValue.PATH_PACKAGE_LOCATOR.get(env);
  if (packageLocator == null) {
    throw new MissingDepException();
  }
  List<Path> roots=new ArrayList<>();
  if (repository.isMain()) {
    roots.addAll(packageLocator.getPathEntries());
  }
 else {
    RepositoryDirectoryValue repositoryValue=(RepositoryDirectoryValue)env.getValue(RepositoryDirectoryValue.key(repository));
    if (repositoryValue == null) {
      throw new MissingDepException();
    }
    if (!repositoryValue.repositoryExists()) {
      throw new IllegalStateException(String.format(""String_Node_Str"",repository));
    }
    roots.add(repositoryValue.getPath());
  }
  LinkedHashSet<PathFragment> packageNames=new LinkedHashSet<>();
  for (  Path root : roots) {
    PathFragment.checkAllPathsAreUnder(blacklistedSubdirectories,directory);
    RecursivePkgValue lookup=(RecursivePkgValue)env.getValue(RecursivePkgValue.key(repository,RootedPath.toRootedPath(root,directory),blacklistedSubdirectories));
    if (lookup == null) {
      throw new MissingDepException();
    }
    for (    String packageName : lookup.getPackages()) {
      PathFragment packageNamePathFragment=PathFragment.create(packageName);
      if (!Iterables.any(excludedSubdirectories,excludedSubdirectory -> packageNamePathFragment.startsWith(excludedSubdirectory))) {
        packageNames.add(packageNamePathFragment);
      }
    }
  }
  return packageNames;
}","@Override public Iterable<PathFragment> getPackagesUnderDirectory(ExtendedEventHandler eventHandler,RepositoryName repository,PathFragment directory,ImmutableSet<PathFragment> blacklistedSubdirectories,ImmutableSet<PathFragment> excludedSubdirectories) throws MissingDepException, InterruptedException {
  PathPackageLocator packageLocator=PrecomputedValue.PATH_PACKAGE_LOCATOR.get(env);
  if (packageLocator == null) {
    throw new MissingDepException();
  }
  List<Path> roots=new ArrayList<>();
  if (repository.isMain()) {
    roots.addAll(packageLocator.getPathEntries());
  }
 else {
    RepositoryDirectoryValue repositoryValue=(RepositoryDirectoryValue)env.getValue(RepositoryDirectoryValue.key(repository));
    if (repositoryValue == null) {
      throw new MissingDepException();
    }
    if (!repositoryValue.repositoryExists()) {
      throw new IllegalStateException(String.format(""String_Node_Str"",repository));
    }
    roots.add(repositoryValue.getPath());
  }
  if (blacklistedSubdirectories.contains(directory)) {
    return ImmutableList.of();
  }
  PathFragment.checkAllPathsAreUnder(blacklistedSubdirectories,directory);
  LinkedHashSet<PathFragment> packageNames=new LinkedHashSet<>();
  for (  Path root : roots) {
    RecursivePkgValue lookup=(RecursivePkgValue)env.getValue(RecursivePkgValue.key(repository,RootedPath.toRootedPath(root,directory),blacklistedSubdirectories));
    if (lookup == null) {
      throw new MissingDepException();
    }
    for (    String packageName : lookup.getPackages()) {
      PathFragment packageNamePathFragment=PathFragment.create(packageName);
      if (!Iterables.any(excludedSubdirectories,excludedSubdirectory -> packageNamePathFragment.startsWith(excludedSubdirectory))) {
        packageNames.add(packageNamePathFragment);
      }
    }
  }
  return packageNames;
}",0.9325153374233128
110659,"@Override public Iterable<PathFragment> getPackagesUnderDirectory(ExtendedEventHandler eventHandler,RepositoryName repository,PathFragment directory,ImmutableSet<PathFragment> blacklistedSubdirectories,ImmutableSet<PathFragment> excludedSubdirectories) throws InterruptedException {
  PathFragment.checkAllPathsAreUnder(blacklistedSubdirectories,directory);
  PathFragment.checkAllPathsAreUnder(excludedSubdirectories,directory);
  if (excludedSubdirectories.contains(directory)) {
    return ImmutableList.of();
  }
  boolean inUniverse=false;
  for (  TargetPatternKey patternKey : universeTargetPatternKeys) {
    TargetPattern pattern=patternKey.getParsedPattern();
    boolean isTBD=pattern.getType().equals(Type.TARGETS_BELOW_DIRECTORY);
    PackageIdentifier packageIdentifier=PackageIdentifier.create(repository,directory);
    if (isTBD && pattern.containsAllTransitiveSubdirectoriesForTBD(packageIdentifier)) {
      inUniverse=true;
      break;
    }
  }
  if (!inUniverse) {
    return ImmutableList.of();
  }
  List<Path> roots=new ArrayList<>();
  if (repository.isMain()) {
    roots.addAll(pkgPath.getPathEntries());
  }
 else {
    RepositoryDirectoryValue repositoryValue=(RepositoryDirectoryValue)graph.getValue(RepositoryDirectoryValue.key(repository));
    if (repositoryValue == null || !repositoryValue.repositoryExists()) {
      return ImmutableList.of();
    }
    roots.add(repositoryValue.getPath());
  }
  ImmutableList.Builder<PathFragment> builder=ImmutableList.builder();
  for (  Path root : roots) {
    RootedPath rootedDir=RootedPath.toRootedPath(root,directory);
    TraversalInfo info=new TraversalInfo(rootedDir,blacklistedSubdirectories,excludedSubdirectories);
    collectPackagesUnder(eventHandler,repository,ImmutableSet.of(info),builder);
  }
  return builder.build();
}","@Override public Iterable<PathFragment> getPackagesUnderDirectory(ExtendedEventHandler eventHandler,RepositoryName repository,PathFragment directory,ImmutableSet<PathFragment> blacklistedSubdirectories,ImmutableSet<PathFragment> excludedSubdirectories) throws InterruptedException {
  if (blacklistedSubdirectories.contains(directory) || excludedSubdirectories.contains(directory)) {
    return ImmutableList.of();
  }
  PathFragment.checkAllPathsAreUnder(blacklistedSubdirectories,directory);
  PathFragment.checkAllPathsAreUnder(excludedSubdirectories,directory);
  boolean inUniverse=false;
  for (  TargetPatternKey patternKey : universeTargetPatternKeys) {
    TargetPattern pattern=patternKey.getParsedPattern();
    boolean isTBD=pattern.getType().equals(Type.TARGETS_BELOW_DIRECTORY);
    PackageIdentifier packageIdentifier=PackageIdentifier.create(repository,directory);
    if (isTBD && pattern.containsAllTransitiveSubdirectoriesForTBD(packageIdentifier)) {
      inUniverse=true;
      break;
    }
  }
  if (!inUniverse) {
    return ImmutableList.of();
  }
  List<Path> roots=new ArrayList<>();
  if (repository.isMain()) {
    roots.addAll(pkgPath.getPathEntries());
  }
 else {
    RepositoryDirectoryValue repositoryValue=(RepositoryDirectoryValue)graph.getValue(RepositoryDirectoryValue.key(repository));
    if (repositoryValue == null || !repositoryValue.repositoryExists()) {
      return ImmutableList.of();
    }
    roots.add(repositoryValue.getPath());
  }
  ImmutableList.Builder<PathFragment> builder=ImmutableList.builder();
  for (  Path root : roots) {
    RootedPath rootedDir=RootedPath.toRootedPath(root,directory);
    TraversalInfo info=new TraversalInfo(rootedDir,blacklistedSubdirectories,excludedSubdirectories);
    collectPackagesUnder(eventHandler,repository,ImmutableSet.of(info),builder);
  }
  return builder.build();
}",0.939385702636586
110660,"@Override public <E extends Exception>void findTargetsBeneathDirectory(RepositoryName repository,String originalPattern,String directory,boolean rulesOnly,ImmutableSet<PathFragment> blacklistedSubdirectories,ImmutableSet<PathFragment> excludedSubdirectories,BatchCallback<Void,E> callback,Class<E> exceptionClass) throws TargetParsingException, E, InterruptedException {
  Preconditions.checkArgument(excludedSubdirectories.isEmpty(),excludedSubdirectories);
  FilteringPolicy policy=rulesOnly ? FilteringPolicies.RULES_ONLY : FilteringPolicies.NO_FILTER;
  PathFragment pathFragment=TargetPatternResolverUtil.getPathFragment(directory);
  List<Path> roots=new ArrayList<>();
  if (repository.isMain()) {
    roots.addAll(pkgPath.getPathEntries());
  }
 else {
    RepositoryDirectoryValue repositoryValue=(RepositoryDirectoryValue)env.getValue(RepositoryDirectoryValue.key(repository));
    if (repositoryValue == null) {
      throw new MissingDepException();
    }
    if (!repositoryValue.repositoryExists()) {
      throw new IllegalStateException(String.format(""String_Node_Str"",repository));
    }
    roots.add(repositoryValue.getPath());
  }
  for (  Path root : roots) {
    RootedPath rootedPath=RootedPath.toRootedPath(root,pathFragment);
    env.getValues(ImmutableList.of(PrepareDepsOfTargetsUnderDirectoryValue.key(repository,rootedPath,blacklistedSubdirectories,policy),CollectPackagesUnderDirectoryValue.key(repository,rootedPath,blacklistedSubdirectories)));
    if (env.valuesMissing()) {
      throw new MissingDepException();
    }
  }
}","@Override public <E extends Exception>void findTargetsBeneathDirectory(RepositoryName repository,String originalPattern,String directory,boolean rulesOnly,ImmutableSet<PathFragment> blacklistedSubdirectories,ImmutableSet<PathFragment> excludedSubdirectories,BatchCallback<Void,E> callback,Class<E> exceptionClass) throws TargetParsingException, E, InterruptedException {
  PathFragment directoryPathFragment=TargetPatternResolverUtil.getPathFragment(directory);
  if (blacklistedSubdirectories.contains(directoryPathFragment)) {
    return;
  }
  Preconditions.checkArgument(excludedSubdirectories.isEmpty(),excludedSubdirectories);
  FilteringPolicy policy=rulesOnly ? FilteringPolicies.RULES_ONLY : FilteringPolicies.NO_FILTER;
  List<Path> roots=new ArrayList<>();
  if (repository.isMain()) {
    roots.addAll(pkgPath.getPathEntries());
  }
 else {
    RepositoryDirectoryValue repositoryValue=(RepositoryDirectoryValue)env.getValue(RepositoryDirectoryValue.key(repository));
    if (repositoryValue == null) {
      throw new MissingDepException();
    }
    if (!repositoryValue.repositoryExists()) {
      throw new IllegalStateException(String.format(""String_Node_Str"",repository));
    }
    roots.add(repositoryValue.getPath());
  }
  for (  Path root : roots) {
    RootedPath rootedPath=RootedPath.toRootedPath(root,directoryPathFragment);
    env.getValues(ImmutableList.of(PrepareDepsOfTargetsUnderDirectoryValue.key(repository,rootedPath,blacklistedSubdirectories,policy),CollectPackagesUnderDirectoryValue.key(repository,rootedPath,blacklistedSubdirectories)));
    if (env.valuesMissing()) {
      throw new MissingDepException();
    }
  }
}",0.917003419334784
110661,"@Nullable private static ImmutableBiMap<Label,Label> resolveToolchainLabels(Environment env,Set<Label> requiredToolchains,BuildConfiguration configuration) throws InterruptedException, ToolchainContextException {
  if (requiredToolchains.isEmpty()) {
    return ImmutableBiMap.of();
  }
  PlatformDescriptors platforms=loadPlatformDescriptors(env,configuration);
  if (platforms == null) {
    return null;
  }
  List<SkyKey> registeredToolchainKeys=new ArrayList<>();
  for (  Label toolchainType : requiredToolchains) {
    registeredToolchainKeys.add(ToolchainResolutionValue.key(configuration,toolchainType,platforms.targetPlatform(),platforms.execPlatform()));
  }
  Map<SkyKey,ValueOrException4<NoToolchainFoundException,ConfiguredValueCreationException,InvalidToolchainLabelException,EvalException>> results=env.getValuesOrThrow(registeredToolchainKeys,NoToolchainFoundException.class,ConfiguredValueCreationException.class,InvalidToolchainLabelException.class,EvalException.class);
  boolean valuesMissing=false;
  ImmutableBiMap.Builder<Label,Label> builder=new ImmutableBiMap.Builder<>();
  List<Label> missingToolchains=new ArrayList<>();
  for (  Map.Entry<SkyKey,ValueOrException4<NoToolchainFoundException,ConfiguredValueCreationException,InvalidToolchainLabelException,EvalException>> entry : results.entrySet()) {
    try {
      Label requiredToolchainType=((ToolchainResolutionKey)entry.getKey().argument()).toolchainType();
      ValueOrException4<NoToolchainFoundException,ConfiguredValueCreationException,InvalidToolchainLabelException,EvalException> valueOrException=entry.getValue();
      if (valueOrException.get() == null) {
        valuesMissing=true;
      }
 else {
        Label toolchainLabel=((ToolchainResolutionValue)valueOrException.get()).toolchainLabel();
        builder.put(requiredToolchainType,toolchainLabel);
      }
    }
 catch (    NoToolchainFoundException e) {
      missingToolchains.add(e.missingToolchainType());
    }
catch (    ConfiguredValueCreationException e) {
      throw new ToolchainContextException(e);
    }
catch (    InvalidToolchainLabelException e) {
      throw new ToolchainContextException(e);
    }
catch (    EvalException e) {
      throw new ToolchainContextException(e);
    }
  }
  if (valuesMissing) {
    return null;
  }
  if (!missingToolchains.isEmpty()) {
    throw new ToolchainContextException(new UnresolvedToolchainsException(missingToolchains));
  }
  return builder.build();
}","@Nullable private static ImmutableBiMap<Label,Label> resolveToolchainLabels(Environment env,Set<Label> requiredToolchains,BuildConfiguration configuration) throws InterruptedException, ToolchainContextException {
  if (requiredToolchains.isEmpty()) {
    return ImmutableBiMap.of();
  }
  PlatformDescriptors platforms=loadPlatformDescriptors(env,configuration);
  if (platforms == null) {
    return null;
  }
  List<SkyKey> registeredToolchainKeys=new ArrayList<>();
  for (  Label toolchainType : requiredToolchains) {
    registeredToolchainKeys.add(ToolchainResolutionValue.key(configuration,toolchainType,platforms.targetPlatform(),platforms.execPlatform()));
  }
  Map<SkyKey,ValueOrException4<NoToolchainFoundException,ConfiguredValueCreationException,InvalidToolchainLabelException,EvalException>> results=env.getValuesOrThrow(registeredToolchainKeys,NoToolchainFoundException.class,ConfiguredValueCreationException.class,InvalidToolchainLabelException.class,EvalException.class);
  boolean valuesMissing=false;
  ImmutableBiMap.Builder<Label,Label> builder=new ImmutableBiMap.Builder<>();
  List<Label> missingToolchains=new ArrayList<>();
  for (  Map.Entry<SkyKey,ValueOrException4<NoToolchainFoundException,ConfiguredValueCreationException,InvalidToolchainLabelException,EvalException>> entry : results.entrySet()) {
    try {
      Label requiredToolchainType=((ToolchainResolutionKey)entry.getKey().argument()).toolchainType();
      ValueOrException4<NoToolchainFoundException,ConfiguredValueCreationException,InvalidToolchainLabelException,EvalException> valueOrException=entry.getValue();
      if (valueOrException.get() == null) {
        valuesMissing=true;
      }
 else {
        Label toolchainLabel=((ToolchainResolutionValue)valueOrException.get()).toolchainLabel();
        builder.put(requiredToolchainType,toolchainLabel);
      }
    }
 catch (    NoToolchainFoundException e) {
      missingToolchains.add(e.missingToolchainType());
    }
catch (    ConfiguredValueCreationException e) {
      throw new ToolchainContextException(e);
    }
catch (    InvalidToolchainLabelException e) {
      throw new ToolchainContextException(e);
    }
catch (    EvalException e) {
      throw new ToolchainContextException(e);
    }
  }
  if (!missingToolchains.isEmpty()) {
    throw new ToolchainContextException(new UnresolvedToolchainsException(missingToolchains));
  }
  if (valuesMissing) {
    return null;
  }
  return builder.build();
}",0.9732142857142856
110662,"@Before public void createConstraints() throws Exception {
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  setting=ConstraintSettingInfo.create(makeLabel(""String_Node_Str""));
  linuxConstraint=ConstraintValueInfo.create(setting,makeLabel(""String_Node_Str""));
  macConstraint=ConstraintValueInfo.create(setting,makeLabel(""String_Node_Str""));
  linuxPlatform=PlatformInfo.builder().setLabel(makeLabel(""String_Node_Str"")).addConstraint(linuxConstraint).build();
  macPlatform=PlatformInfo.builder().setLabel(makeLabel(""String_Node_Str"")).addConstraint(macConstraint).build();
}","@Before public void createConstraints() throws Exception {
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  setting=ConstraintSettingInfo.create(makeLabel(""String_Node_Str""));
  linuxConstraint=ConstraintValueInfo.create(setting,makeLabel(""String_Node_Str""));
  macConstraint=ConstraintValueInfo.create(setting,makeLabel(""String_Node_Str""));
  linuxPlatform=PlatformInfo.builder().setLabel(makeLabel(""String_Node_Str"")).addConstraint(linuxConstraint).build();
  macPlatform=PlatformInfo.builder().setLabel(makeLabel(""String_Node_Str"")).addConstraint(macConstraint).build();
}",0.9764309764309764
110663,"@SuppressWarnings(""String_Node_Str"") public Tuple<Object> invoke(SkylarkRuleContext ctx,String command,Object attributeUnchecked,Boolean expandLocations,Object makeVariablesUnchecked,SkylarkList tools,SkylarkDict<?,?> labelDictUnchecked,SkylarkDict<?,?> executionRequirementsUnchecked,Location loc,Environment env) throws ConversionException, EvalException {
  ctx.checkMutable(""String_Node_Str"");
  Label ruleLabel=ctx.getLabel();
  Map<Label,Iterable<Artifact>> labelDict=checkLabelDict(labelDictUnchecked,loc,env);
  CommandHelper helper=new CommandHelper(ctx.getRuleContext(),tools.getContents(TransitiveInfoCollection.class,""String_Node_Str""),ImmutableMap.copyOf(labelDict));
  String attribute=Type.STRING.convertOptional(attributeUnchecked,""String_Node_Str"",ruleLabel);
  if (expandLocations) {
    command=helper.resolveCommandAndExpandLabels(command,attribute,false);
  }
  if (!EvalUtils.isNullOrNone(makeVariablesUnchecked)) {
    Map<String,String> makeVariables=Type.STRING_DICT.convert(makeVariablesUnchecked,""String_Node_Str"",ruleLabel);
    command=ctx.expandMakeVariables(attribute,command,makeVariables);
  }
  List<Artifact> inputs=new ArrayList<>();
  inputs.addAll(helper.getResolvedTools());
  ImmutableMap<String,String> executionRequirements=ImmutableMap.copyOf(SkylarkDict.castSkylarkDictOrNoneToDict(executionRequirementsUnchecked,String.class,String.class,""String_Node_Str""));
  List<String> argv=helper.buildCommandLine(command,inputs,SCRIPT_SUFFIX,executionRequirements);
  return Tuple.<Object>of(new MutableList(inputs,env),new MutableList(argv,env),helper.getToolsRunfilesSuppliers());
}","@SuppressWarnings(""String_Node_Str"") public Tuple<Object> invoke(SkylarkRuleContext ctx,String command,Object attributeUnchecked,Boolean expandLocations,Object makeVariablesUnchecked,SkylarkList tools,SkylarkDict<?,?> labelDictUnchecked,SkylarkDict<?,?> executionRequirementsUnchecked,Location loc,Environment env) throws ConversionException, EvalException {
  ctx.checkMutable(""String_Node_Str"");
  Label ruleLabel=ctx.getLabel();
  Map<Label,Iterable<Artifact>> labelDict=checkLabelDict(labelDictUnchecked,loc,env);
  CommandHelper helper=new CommandHelper(ctx.getRuleContext(),tools.getContents(TransitiveInfoCollection.class,""String_Node_Str""),ImmutableMap.copyOf(labelDict));
  String attribute=Type.STRING.convertOptional(attributeUnchecked,""String_Node_Str"",ruleLabel);
  if (expandLocations) {
    command=helper.resolveCommandAndExpandLabels(command,attribute,false);
  }
  if (!EvalUtils.isNullOrNone(makeVariablesUnchecked)) {
    Map<String,String> makeVariables=Type.STRING_DICT.convert(makeVariablesUnchecked,""String_Node_Str"",ruleLabel);
    command=ctx.expandMakeVariables(attribute,command,makeVariables);
  }
  List<Artifact> inputs=new ArrayList<>();
  inputs.addAll(helper.getResolvedTools());
  ImmutableMap<String,String> executionRequirements=ImmutableMap.copyOf(SkylarkDict.castSkylarkDictOrNoneToDict(executionRequirementsUnchecked,String.class,String.class,""String_Node_Str""));
  List<String> argv=helper.buildCommandLine(command,inputs,SCRIPT_SUFFIX,executionRequirements);
  return Tuple.<Object>of(MutableList.copyOf(env,inputs),MutableList.copyOf(env,argv),helper.getToolsRunfilesSuppliers());
}",0.9833538840937116
110664,"static SkylarkList<Object> callGlob(@Nullable PackageContext originalContext,Object include,Object exclude,boolean excludeDirs,FuncallExpression ast,Environment env) throws EvalException, ConversionException, InterruptedException {
  PackageContext context;
  if (originalContext == null) {
    context=getContext(env,ast);
  }
 else {
    context=originalContext;
  }
  List<String> includes=Type.STRING_LIST.convert(include,""String_Node_Str"");
  List<String> excludes=Type.STRING_LIST.convert(exclude,""String_Node_Str"");
  List<String> matches;
  try {
    Globber.Token globToken=context.globber.runAsync(includes,excludes,excludeDirs);
    matches=context.globber.fetch(globToken);
  }
 catch (  IOException e) {
    String errorMessage=""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(includes) + ""String_Node_Str""+ e.getMessage();
    context.eventHandler.handle(Event.error(ast.getLocation(),errorMessage));
    context.pkgBuilder.setIOExceptionAndMessage(e,errorMessage);
    matches=ImmutableList.of();
  }
catch (  BadGlobException e) {
    throw new EvalException(ast.getLocation(),e.getMessage());
  }
  GlobList<String> globList=GlobList.captureResults(includes,excludes,matches);
  return new MutableList<>(globList,env);
}","static SkylarkList<Object> callGlob(@Nullable PackageContext originalContext,Object include,Object exclude,boolean excludeDirs,FuncallExpression ast,Environment env) throws EvalException, ConversionException, InterruptedException {
  PackageContext context;
  if (originalContext == null) {
    context=getContext(env,ast);
  }
 else {
    context=originalContext;
  }
  List<String> includes=Type.STRING_LIST.convert(include,""String_Node_Str"");
  List<String> excludes=Type.STRING_LIST.convert(exclude,""String_Node_Str"");
  List<String> matches;
  try {
    Globber.Token globToken=context.globber.runAsync(includes,excludes,excludeDirs);
    matches=context.globber.fetch(globToken);
  }
 catch (  IOException e) {
    String errorMessage=""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(includes) + ""String_Node_Str""+ e.getMessage();
    context.eventHandler.handle(Event.error(ast.getLocation(),errorMessage));
    context.pkgBuilder.setIOExceptionAndMessage(e,errorMessage);
    matches=ImmutableList.of();
  }
catch (  BadGlobException e) {
    throw new EvalException(ast.getLocation(),e.getMessage());
  }
  GlobList<String> globList=GlobList.captureResults(includes,excludes,matches);
  return MutableList.copyOf(env,globList);
}",0.9867203219315897
110665,"@Override public Object getResult(Environment env) throws EvalException {
  return new MutableList<>(result,env);
}","@Override public Object getResult(Environment env) throws EvalException {
  return MutableList.copyOf(env,result);
}",0.9090909090909092
110666,"public MutableList<?> invoke(SkylarkList<?> args,Location loc,Environment env) throws EvalException {
  Iterator<?>[] iterators=new Iterator<?>[args.size()];
  for (int i=0; i < args.size(); i++) {
    iterators[i]=EvalUtils.toIterable(args.get(i),loc,env).iterator();
  }
  List<Tuple<?>> result=new ArrayList<>();
  boolean allHasNext;
  do {
    allHasNext=!args.isEmpty();
    List<Object> elem=Lists.newArrayListWithExpectedSize(args.size());
    for (    Iterator<?> iterator : iterators) {
      if (iterator.hasNext()) {
        elem.add(iterator.next());
      }
 else {
        allHasNext=false;
      }
    }
    if (allHasNext) {
      result.add(Tuple.copyOf(elem));
    }
  }
 while (allHasNext);
  return new MutableList<>(result,env);
}","public MutableList<?> invoke(SkylarkList<?> args,Location loc,Environment env) throws EvalException {
  Iterator<?>[] iterators=new Iterator<?>[args.size()];
  for (int i=0; i < args.size(); i++) {
    iterators[i]=EvalUtils.toIterable(args.get(i),loc,env).iterator();
  }
  List<Tuple<?>> result=new ArrayList<>();
  boolean allHasNext;
  do {
    allHasNext=!args.isEmpty();
    List<Object> elem=Lists.newArrayListWithExpectedSize(args.size());
    for (    Iterator<?> iterator : iterators) {
      if (iterator.hasNext()) {
        elem.add(iterator.next());
      }
 else {
        allHasNext=false;
      }
    }
    if (allHasNext) {
      result.add(Tuple.copyOf(elem));
    }
  }
 while (allHasNext);
  return MutableList.copyOf(env,result);
}",0.9780730897009968
110667,"/** 
 * Splits the given string into a list of words, using   {@code separator} as a delimiter.<p>At most  {@code maxSplits} will be performed, going from right to left.
 * @param input The input string.
 * @param separator The separator string.
 * @param maxSplits The maximum number of splits. Negative values mean unlimited splits.
 * @return A list of words
 * @throws IllegalArgumentException
 */
private static MutableList<String> stringRSplit(String input,String separator,int maxSplits,Environment env){
  if (separator.isEmpty()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (maxSplits <= 0) {
    maxSplits=Integer.MAX_VALUE;
  }
  LinkedList<String> result=new LinkedList<>();
  String[] parts=input.split(Pattern.quote(separator),-1);
  int sepLen=separator.length();
  int remainingLength=input.length();
  int splitsSoFar=0;
  for (int pos=parts.length - 1; (pos >= 0) && (splitsSoFar < maxSplits); --pos) {
    String current=parts[pos];
    result.addFirst(current);
    ++splitsSoFar;
    remainingLength-=sepLen + current.length();
  }
  if (splitsSoFar == maxSplits && remainingLength >= 0) {
    result.addFirst(input.substring(0,remainingLength));
  }
  return new MutableList<>(result,env);
}","/** 
 * Splits the given string into a list of words, using   {@code separator} as a delimiter.<p>At most  {@code maxSplits} will be performed, going from right to left.
 * @param input The input string.
 * @param separator The separator string.
 * @param maxSplits The maximum number of splits. Negative values mean unlimited splits.
 * @return A list of words
 * @throws IllegalArgumentException
 */
private static MutableList<String> stringRSplit(String input,String separator,int maxSplits,Environment env){
  if (separator.isEmpty()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (maxSplits <= 0) {
    maxSplits=Integer.MAX_VALUE;
  }
  LinkedList<String> result=new LinkedList<>();
  String[] parts=input.split(Pattern.quote(separator),-1);
  int sepLen=separator.length();
  int remainingLength=input.length();
  int splitsSoFar=0;
  for (int pos=parts.length - 1; (pos >= 0) && (splitsSoFar < maxSplits); --pos) {
    String current=parts[pos];
    result.addFirst(current);
    ++splitsSoFar;
    remainingLength-=sepLen + current.length();
  }
  if (splitsSoFar == maxSplits && remainingLength >= 0) {
    result.addFirst(input.substring(0,remainingLength));
  }
  return MutableList.copyOf(env,result);
}",0.9866881807180314
110668,"/** 
 * Constructs from the given items and the   {@link Mutability} belonging to the given {@link Environment}. If   {@code env} is null, the list is immutable.
 * @deprecated prefer using {@link #copyOf}
 */
@Deprecated public MutableList(Iterable<? extends E> contents,@Nullable Environment env){
  this(contents,0,env == null ? null : env.mutability());
}","private MutableList(Iterable<? extends E> contents,@Nullable Mutability mutability){
  this(contents,0,mutability);
}",0.4117647058823529
110669,"/** 
 * Converts an object to a Skylark-compatible type if possible.
 */
public static Object convertToSkylark(Object object,@Nullable Environment env){
  if (object instanceof List && !(object instanceof SkylarkList)) {
    return new MutableList<>((List<?>)object,env);
  }
  if (object instanceof SkylarkValue) {
    return object;
  }
  if (object instanceof Map) {
    return SkylarkDict.<Object,Object>copyOf(env,(Map<?,?>)object);
  }
  return object;
}","/** 
 * Converts an object to a Skylark-compatible type if possible.
 */
public static Object convertToSkylark(Object object,@Nullable Environment env){
  if (object instanceof List && !(object instanceof SkylarkList)) {
    return MutableList.copyOf(env,(List<?>)object);
  }
  if (object instanceof SkylarkValue) {
    return object;
  }
  if (object instanceof Map) {
    return SkylarkDict.<Object,Object>copyOf(env,(Map<?,?>)object);
  }
  return object;
}",0.975027144408252
110670,"@Test public void testSkylarkTypeEquivalence() throws Exception {
  Class<?> emptyTupleClass=Tuple.empty().getClass();
  Class<?> tupleClass=Tuple.of(1,""String_Node_Str"",""String_Node_Str"").getClass();
  Class<?> mutableListClass=new MutableList<>(Tuple.of(1,2,3),env).getClass();
  assertThat(SkylarkType.of(mutableListClass)).isEqualTo(SkylarkType.LIST);
  assertThat(SkylarkType.of(emptyTupleClass)).isEqualTo(SkylarkType.TUPLE);
  assertThat(SkylarkType.of(tupleClass)).isEqualTo(SkylarkType.TUPLE);
  assertThat(SkylarkType.TUPLE).isNotEqualTo(SkylarkType.LIST);
  try {
    SkylarkType.of(ClassObject.class);
    throw new Exception(""String_Node_Str"");
  }
 catch (  Exception e) {
    assertThat(e).hasMessageThat().contains(""String_Node_Str"" + ""String_Node_Str"");
  }
  assertThat(SkylarkType.of(Artifact.SpecialArtifact.class)).isEqualTo(SkylarkType.of(Artifact.class));
  assertThat(SkylarkType.of(RuleConfiguredTarget.class)).isNotEqualTo(SkylarkType.of(Info.class));
}","@Test public void testSkylarkTypeEquivalence() throws Exception {
  Class<?> emptyTupleClass=Tuple.empty().getClass();
  Class<?> tupleClass=Tuple.of(1,""String_Node_Str"",""String_Node_Str"").getClass();
  Class<?> mutableListClass=MutableList.copyOf(env,Tuple.of(1,2,3)).getClass();
  assertThat(SkylarkType.of(mutableListClass)).isEqualTo(SkylarkType.LIST);
  assertThat(SkylarkType.of(emptyTupleClass)).isEqualTo(SkylarkType.TUPLE);
  assertThat(SkylarkType.of(tupleClass)).isEqualTo(SkylarkType.TUPLE);
  assertThat(SkylarkType.TUPLE).isNotEqualTo(SkylarkType.LIST);
  try {
    SkylarkType.of(ClassObject.class);
    throw new Exception(""String_Node_Str"");
  }
 catch (  Exception e) {
    assertThat(e).hasMessageThat().contains(""String_Node_Str"" + ""String_Node_Str"");
  }
  assertThat(SkylarkType.of(Artifact.SpecialArtifact.class)).isEqualTo(SkylarkType.of(Artifact.class));
  assertThat(SkylarkType.of(RuleConfiguredTarget.class)).isNotEqualTo(SkylarkType.of(Info.class));
}",0.9882593159775396
110671,"@Test public void testGetSkylarkType() throws Exception {
  Class<?> emptyTupleClass=Tuple.empty().getClass();
  Class<?> tupleClass=Tuple.of(1,""String_Node_Str"",""String_Node_Str"").getClass();
  Class<?> mutableListClass=new MutableList<>(Tuple.of(1,2,3),env).getClass();
  assertThat(EvalUtils.getSkylarkType(mutableListClass)).isEqualTo(MutableList.class);
  assertThat(MutableList.class.isAnnotationPresent(SkylarkModule.class)).isTrue();
  assertThat(EvalUtils.getSkylarkType(emptyTupleClass)).isEqualTo(Tuple.class);
  assertThat(EvalUtils.getSkylarkType(tupleClass)).isEqualTo(Tuple.class);
  assertThat(EvalUtils.getSkylarkType(Info.class)).isEqualTo(Info.class);
  try {
    EvalUtils.getSkylarkType(ClassObject.class);
    throw new Exception(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
    assertThat(e).hasMessageThat().contains(""String_Node_Str"" + ""String_Node_Str"");
  }
}","@Test public void testGetSkylarkType() throws Exception {
  Class<?> emptyTupleClass=Tuple.empty().getClass();
  Class<?> tupleClass=Tuple.of(1,""String_Node_Str"",""String_Node_Str"").getClass();
  Class<?> mutableListClass=MutableList.copyOf(env,Tuple.of(1,2,3)).getClass();
  assertThat(EvalUtils.getSkylarkType(mutableListClass)).isEqualTo(MutableList.class);
  assertThat(MutableList.class.isAnnotationPresent(SkylarkModule.class)).isTrue();
  assertThat(EvalUtils.getSkylarkType(emptyTupleClass)).isEqualTo(Tuple.class);
  assertThat(EvalUtils.getSkylarkType(tupleClass)).isEqualTo(Tuple.class);
  assertThat(EvalUtils.getSkylarkType(Info.class)).isEqualTo(Info.class);
  try {
    EvalUtils.getSkylarkType(ClassObject.class);
    throw new Exception(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
    assertThat(e).hasMessageThat().contains(""String_Node_Str"" + ""String_Node_Str"");
  }
}",0.9872998343456654
110672,"private void updateClientEnv(List<Map.Entry<String,String>> clientEnvList){
  Preconditions.checkState(clientEnv.isEmpty());
  Collection<Map.Entry<String,String>> env=clientEnvList;
  for (  Map.Entry<String,String> entry : env) {
    clientEnv.put(entry.getKey(),entry.getValue());
  }
  if (commandId == null) {
    commandId=getFromEnvOrGenerate(""String_Node_Str"");
  }
  if (buildRequestId == null) {
    buildRequestId=getFromEnvOrGenerate(""String_Node_Str"");
  }
  setCommandIdInCrashData();
}","private void updateClientEnv(List<Map.Entry<String,String>> clientEnvList){
  Preconditions.checkState(clientEnv.isEmpty());
  Collection<Map.Entry<String,String>> env=clientEnvList;
  for (  Map.Entry<String,String> entry : env) {
    clientEnv.put(entry.getKey(),entry.getValue());
  }
  if (commandId == null) {
    commandId=getUuidFromEnvOrGenerate(""String_Node_Str"");
  }
  if (buildRequestId == null) {
    buildRequestId=getFromEnvOrGenerate(""String_Node_Str"");
  }
  setCommandIdInCrashData();
}",0.99601593625498
110673,"/** 
 * Returns the UUID that Blaze uses to identify everything logged from the current build request.
 */
public UUID getBuildRequestId(){
  return Preconditions.checkNotNull(buildRequestId);
}","/** 
 * Returns the ID that Blaze uses to identify everything logged from the current build request. TODO(olaola): this should be a UUID, but some existing clients still use arbitrary strings.
 */
public String getBuildRequestId(){
  return Preconditions.checkNotNull(buildRequestId);
}",0.4791666666666667
110674,"private UUID getFromEnvOrGenerate(String varName){
  String uuidString=clientEnv.getOrDefault(varName,""String_Node_Str"");
  if (!uuidString.isEmpty()) {
    try {
      return UUID.fromString(uuidString);
    }
 catch (    IllegalArgumentException e) {
    }
  }
  return UUID.randomUUID();
}","private String getFromEnvOrGenerate(String varName){
  String id=clientEnv.getOrDefault(varName,""String_Node_Str"");
  if (id.isEmpty()) {
    id=UUID.randomUUID().toString();
  }
  return id;
}",0.6515463917525773
110675,"/** 
 * Executes the given callable in a loop, retrying on retryable errors, as defined by the current backoff/retry policy. Will raise the last encountered retriable error, or the first non-retriable error. <p>This method never throws   {@link StatusRuntimeException} even if the passed-in Callable does.
 * @param c The callable to execute.
 */
public <T>T execute(Callable<T> c) throws InterruptedException, IOException {
  Backoff backoff=backoffSupplier.get();
  while (true) {
    try {
      return c.call();
    }
 catch (    PassThroughException e) {
      throw (StatusRuntimeException)e.getCause();
    }
catch (    RetryException e) {
      throw e;
    }
catch (    StatusException|StatusRuntimeException e) {
      Status st=Status.fromThrowable(e);
      long delay=backoff.nextDelayMillis();
      if (st.getCode() == Status.Code.CANCELLED && Thread.currentThread().isInterrupted()) {
        Thread.currentThread().interrupt();
        throw new InterruptedException();
      }
      if (delay < 0 || !isRetriable.apply(st)) {
        throw new RetryException(st.asRuntimeException(),backoff.getRetryAttempts());
      }
      sleep(delay);
    }
catch (    Exception e) {
      Throwables.throwIfUnchecked(e);
      Throwables.throwIfInstanceOf(e,IOException.class);
      Throwables.throwIfInstanceOf(e,InterruptedException.class);
      throw new RetryException(e,backoff.getRetryAttempts());
    }
  }
}","/** 
 * Executes the given callable in a loop, retrying on retryable errors, as defined by the current backoff/retry policy. Will raise the last encountered retriable error, or the first non-retriable error. <p>This method never throws   {@link StatusRuntimeException} even if the passed-in Callable does.
 * @param c The callable to execute.
 */
public <T>T execute(Callable<T> c) throws InterruptedException, IOException {
  Backoff backoff=backoffSupplier.get();
  while (true) {
    try {
      return c.call();
    }
 catch (    PassThroughException e) {
      throw (StatusRuntimeException)e.getCause();
    }
catch (    RetryException e) {
      throw e;
    }
catch (    StatusException|StatusRuntimeException e) {
      Status st=Status.fromThrowable(e);
      int attempts=backoff.getRetryAttempts();
      long delay=backoff.nextDelayMillis();
      if (st.getCode() == Status.Code.CANCELLED && Thread.currentThread().isInterrupted()) {
        Thread.currentThread().interrupt();
        throw new InterruptedException();
      }
      if (delay < 0 || !isRetriable.apply(st)) {
        throw new RetryException(st.asRuntimeException(),attempts);
      }
      sleep(delay);
    }
catch (    Exception e) {
      Throwables.throwIfUnchecked(e);
      Throwables.throwIfInstanceOf(e,IOException.class);
      Throwables.throwIfInstanceOf(e,InterruptedException.class);
      throw new RetryException(e,backoff.getRetryAttempts());
    }
  }
}",0.9767118526242614
110676,"/** 
 * Execute a   {@link Callable}, retrying execution in case of failure and returning the result in case of success. <p>  {@link InterruptedException} is not retried.
 * @param call  the {@link Callable} to execute.
 * @throws RetryException2 if the {@code call} didn't succeed within the framework specified by{@code backoffSupplier} and {@code shouldRetry}.
 * @throws CircuitBreakerException  in case a call was rejected because the circuit breakertripped.
 * @throws InterruptedException if the {@code call} throws an {@link InterruptedException} or thecurrent thread's interrupted flag is set.
 */
public <T>T execute(Callable<T> call) throws RetryException2, InterruptedException {
  final Backoff backoff=newBackoff();
  while (true) {
    final State circuitState;
    circuitState=circuitBreaker.state();
    if (State.REJECT_CALLS.equals(circuitState)) {
      throw new CircuitBreakerException();
    }
    try {
      if (Thread.interrupted()) {
        throw new InterruptedException();
      }
      T r=call.call();
      circuitBreaker.recordSuccess();
      return r;
    }
 catch (    InterruptedException e) {
      circuitBreaker.recordFailure();
      throw e;
    }
catch (    Exception e) {
      circuitBreaker.recordFailure();
      if (e instanceof RetryException2) {
        e=(Exception)e.getCause();
      }
      if (State.TRIAL_CALL.equals(circuitState)) {
        throw new CircuitBreakerException(""String_Node_Str"",0,e);
      }
      if (!shouldRetry.test(e)) {
        throw new RetryException2(""String_Node_Str"",backoff.getRetryAttempts(),e);
      }
      final long delayMillis=backoff.nextDelayMillis();
      if (delayMillis < 0) {
        throw new RetryException2(""String_Node_Str"" + backoff.getRetryAttempts(),backoff.getRetryAttempts(),e);
      }
      sleeper.sleep(delayMillis);
    }
  }
}","/** 
 * Execute a   {@link Callable}, retrying execution in case of failure and returning the result in case of success. <p>  {@link InterruptedException} is not retried.
 * @param call  the {@link Callable} to execute.
 * @throws RetryException2 if the {@code call} didn't succeed within the framework specified by{@code backoffSupplier} and {@code shouldRetry}.
 * @throws CircuitBreakerException  in case a call was rejected because the circuit breakertripped.
 * @throws InterruptedException if the {@code call} throws an {@link InterruptedException} or thecurrent thread's interrupted flag is set.
 */
public <T>T execute(Callable<T> call) throws RetryException2, InterruptedException {
  final Backoff backoff=newBackoff();
  while (true) {
    final State circuitState;
    circuitState=circuitBreaker.state();
    if (State.REJECT_CALLS.equals(circuitState)) {
      throw new CircuitBreakerException();
    }
    try {
      if (Thread.interrupted()) {
        throw new InterruptedException();
      }
      T r=call.call();
      circuitBreaker.recordSuccess();
      return r;
    }
 catch (    InterruptedException e) {
      circuitBreaker.recordFailure();
      throw e;
    }
catch (    Exception e) {
      circuitBreaker.recordFailure();
      if (e instanceof RetryException2) {
        e=(Exception)e.getCause();
      }
      if (State.TRIAL_CALL.equals(circuitState)) {
        throw new CircuitBreakerException(""String_Node_Str"",0,e);
      }
      int attempts=backoff.getRetryAttempts();
      if (!shouldRetry.test(e)) {
        throw new RetryException2(""String_Node_Str"",attempts,e);
      }
      final long delayMillis=backoff.nextDelayMillis();
      if (delayMillis < 0) {
        throw new RetryException2(""String_Node_Str"" + attempts,attempts,e);
      }
      sleeper.sleep(delayMillis);
    }
  }
}",0.9708843537414966
110677,"/** 
 * Creates SymlinkTreeAction instance.
 * @param owner action owner
 * @param inputManifest the input runfiles manifest
 * @param artifactMiddleman the middleman artifact representing all the files the symlinkspoint to (on Windows we need to know if the target of a ""symlink"" is a directory or a file so we need to build it before)
 * @param outputManifest the generated symlink tree manifest(must have ""MANIFEST"" base name). Symlink tree root will be set to the artifact's parent directory.
 * @param filesetTree true if this is fileset symlink tree,
 * @param enableRunfiles true is the actual symlink tree needs to be created.
 */
public SymlinkTreeAction(ActionOwner owner,Artifact inputManifest,@Nullable Artifact artifactMiddleman,Artifact outputManifest,boolean filesetTree,ImmutableMap<String,String> shellEnvironment,boolean enableRunfiles){
  super(owner,computeInputs(inputManifest,artifactMiddleman),ImmutableList.of(outputManifest));
  Preconditions.checkArgument(outputManifest.getPath().getBaseName().equals(""String_Node_Str""));
  this.inputManifest=inputManifest;
  this.outputManifest=outputManifest;
  this.filesetTree=filesetTree;
  this.shellEnviroment=shellEnvironment;
  this.enableRunfiles=enableRunfiles;
}","/** 
 * Creates SymlinkTreeAction instance.
 * @param owner action owner
 * @param inputManifest the input runfiles manifest
 * @param artifactMiddleman the middleman artifact representing all the files the symlinkspoint to (on Windows we need to know if the target of a ""symlink"" is a directory or a file so we need to build it before)
 * @param outputManifest the generated symlink tree manifest(must have ""MANIFEST"" base name). Symlink tree root will be set to the artifact's parent directory.
 * @param filesetTree true if this is fileset symlink tree,
 * @param enableRunfiles true is the actual symlink tree needs to be created.
 */
public SymlinkTreeAction(ActionOwner owner,Artifact inputManifest,@Nullable Artifact artifactMiddleman,Artifact outputManifest,boolean filesetTree,ImmutableMap<String,String> shellEnvironment,boolean enableRunfiles){
  super(owner,computeInputs(inputManifest,artifactMiddleman),ImmutableList.of(outputManifest));
  Preconditions.checkArgument(outputManifest.getPath().getBaseName().equals(""String_Node_Str""));
  this.inputManifest=inputManifest;
  this.outputManifest=outputManifest;
  this.filesetTree=filesetTree;
  this.shellEnvironment=shellEnvironment;
  this.enableRunfiles=enableRunfiles;
}",0.999595305544314
110678,"@Override public void execute(ActionExecutionContext actionExecutionContext) throws ActionExecutionException, InterruptedException {
  actionExecutionContext.getContext(SymlinkTreeActionContext.class).createSymlinks(this,actionExecutionContext,shellEnviroment,enableRunfiles);
}","@Override public void execute(ActionExecutionContext actionExecutionContext) throws ActionExecutionException, InterruptedException {
  actionExecutionContext.getContext(SymlinkTreeActionContext.class).createSymlinks(this,actionExecutionContext,shellEnvironment,enableRunfiles);
}",0.9982046678635548
110679,"/** 
 * Returns true if the linking of this target is used for a native dependecy library.
 */
public boolean isNativeDeps(){
  return this.isNativeDeps;
}","/** 
 * Returns true if the linking of this target is used for a native dependency library.
 */
public boolean isNativeDeps(){
  return this.isNativeDeps;
}",0.9967845659163987
110680,"@Test public void testAndroidSplitTransitionWithInvalidCpu() throws Exception {
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  BazelMockAndroidSupport.setupNdk(mockToolsConfig);
  useConfiguration(""String_Node_Str"",""String_Node_Str"");
  try {
    getConfiguredTarget(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  AssertionError e) {
    assertThat(e.getMessage()).contains(""String_Node_Str"");
  }
}","@Test public void testAndroidSplitTransitionWithInvalidCpu() throws Exception {
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  BazelMockAndroidSupport.setupNdk(mockToolsConfig);
  useConfiguration(""String_Node_Str"",""String_Node_Str"");
  AssertionError noToolchainError=expectThrows(AssertionError.class,() -> getConfiguredTarget(""String_Node_Str""));
  assertThat(noToolchainError).hasMessageThat().contains(""String_Node_Str"");
}",0.8373042886317222
110681,"/** 
 * Returns the *cached* short hostname (computed at most once per the lifetime of a server). Can take seconds to complete when the cache is cold.
 */
public static String getCachedShortHostName(){
  if (hostname == null) {
synchronized (NetUtil.class) {
      if (hostname == null) {
        hostname=computeShortHostName();
      }
    }
  }
  return computeShortHostName();
}","/** 
 * Returns the *cached* short hostname (computed at most once per the lifetime of a server). Can take seconds to complete when the cache is cold.
 */
public static String getCachedShortHostName(){
  if (hostname == null) {
synchronized (NetUtil.class) {
      if (hostname == null) {
        hostname=computeShortHostName();
      }
    }
  }
  return hostname;
}",0.96
110682,"@Nullable public ActionAnalysisMetadata getGeneratingAction(Artifact artifact){
  return generatingActions.get(artifact);
}","@Nullable @Override public ActionAnalysisMetadata getGeneratingAction(Artifact artifact){
  return generatingActions.get(artifact);
}",0.9609375
110683,"/** 
 * Returns true iff this is a source Artifact as determined by its path and root relationships. Note that this will report all Artifacts in the output tree, including in the include symlink tree, as non-source.
 */
@SkylarkCallable(name=""String_Node_Str"",structField=true,doc=""String_Node_Str"") public final boolean isSourceArtifact(){
  return execPath == rootRelativePath;
}","/** 
 * Returns true iff this is a source Artifact as determined by its path and root relationships. Note that this will report all Artifacts in the output tree, including in the include symlink tree, as non-source.
 */
@SkylarkCallable(name=""String_Node_Str"",structField=true,doc=""String_Node_Str"") @SuppressWarnings(""String_Node_Str"") public final boolean isSourceArtifact(){
  return execPath == rootRelativePath;
}",0.95369211514393
110684,"private static String suffix(ActionAnalysisMetadata a,ActionAnalysisMetadata b){
  StringBuilder sb=new StringBuilder();
  ActionOwner aOwner=a.getOwner();
  ActionOwner bOwner=b.getOwner();
  boolean aNull=aOwner == null;
  boolean bNull=bOwner == null;
  addStringDetail(sb,""String_Node_Str"",aNull ? null : Label.print(aOwner.getLabel()),bNull ? null : Label.print(bOwner.getLabel()));
  addStringDetail(sb,""String_Node_Str"",aNull ? null : aOwner.getTargetKind(),bNull ? null : bOwner.getTargetKind());
  addStringDetail(sb,""String_Node_Str"",aNull ? null : aOwner.getConfigurationChecksum(),bNull ? null : bOwner.getConfigurationChecksum());
  addStringDetail(sb,""String_Node_Str"",a.getMnemonic(),b.getMnemonic());
  addStringDetail(sb,""String_Node_Str"",getKey(a),getKey(b));
  if ((a instanceof ActionExecutionMetadata) && (b instanceof ActionExecutionMetadata)) {
    addStringDetail(sb,""String_Node_Str"",((ActionExecutionMetadata)a).getProgressMessage(),((ActionExecutionMetadata)b).getProgressMessage());
  }
  Artifact aPrimaryInput=a.getPrimaryInput();
  Artifact bPrimaryInput=b.getPrimaryInput();
  addStringDetail(sb,""String_Node_Str"",aPrimaryInput == null ? null : aPrimaryInput.toString(),bPrimaryInput == null ? null : bPrimaryInput.toString());
  addStringDetail(sb,""String_Node_Str"",a.getPrimaryOutput().toString(),b.getPrimaryOutput().toString());
  if ((aPrimaryInput == null && bPrimaryInput == null) || (aPrimaryInput != null && bPrimaryInput != null && aPrimaryInput.toString().equals(bPrimaryInput.toString()))) {
    Artifact aPrimaryOutput=a.getPrimaryOutput();
    Artifact bPrimaryOutput=b.getPrimaryOutput();
    if (aPrimaryOutput != bPrimaryOutput) {
      sb.append(""String_Node_Str"").append(System.identityHashCode(aPrimaryOutput)).append(""String_Node_Str"").append(System.identityHashCode(bPrimaryOutput)).append('\n');
    }
    ArtifactOwner aArtifactOwner=aPrimaryOutput.getArtifactOwner();
    ArtifactOwner bArtifactOwner=bPrimaryOutput.getArtifactOwner();
    addStringDetail(sb,""String_Node_Str"",aArtifactOwner.toString(),bArtifactOwner.toString());
    addListDetail(sb,""String_Node_Str"",a.getMandatoryInputs(),b.getMandatoryInputs());
    addListDetail(sb,""String_Node_Str"",a.getOutputs(),b.getOutputs());
  }
  return sb.toString();
}","private static String suffix(ActionAnalysisMetadata a,ActionAnalysisMetadata b){
  StringBuilder sb=new StringBuilder();
  ActionOwner aOwner=a.getOwner();
  ActionOwner bOwner=b.getOwner();
  boolean aNull=aOwner == null;
  boolean bNull=bOwner == null;
  addStringDetail(sb,""String_Node_Str"",aNull ? null : Label.print(aOwner.getLabel()),bNull ? null : Label.print(bOwner.getLabel()));
  addStringDetail(sb,""String_Node_Str"",aNull ? null : aOwner.getTargetKind(),bNull ? null : bOwner.getTargetKind());
  addStringDetail(sb,""String_Node_Str"",aNull ? null : aOwner.getConfigurationChecksum(),bNull ? null : bOwner.getConfigurationChecksum());
  addStringDetail(sb,""String_Node_Str"",a.getMnemonic(),b.getMnemonic());
  addStringDetail(sb,""String_Node_Str"",getKey(a),getKey(b));
  if ((a instanceof ActionExecutionMetadata) && (b instanceof ActionExecutionMetadata)) {
    addStringDetail(sb,""String_Node_Str"",((ActionExecutionMetadata)a).getProgressMessage(),((ActionExecutionMetadata)b).getProgressMessage());
  }
  Artifact aPrimaryInput=a.getPrimaryInput();
  Artifact bPrimaryInput=b.getPrimaryInput();
  addStringDetail(sb,""String_Node_Str"",aPrimaryInput == null ? null : aPrimaryInput.toString(),bPrimaryInput == null ? null : bPrimaryInput.toString());
  addStringDetail(sb,""String_Node_Str"",a.getPrimaryOutput().toString(),b.getPrimaryOutput().toString());
  if ((aPrimaryInput == null && bPrimaryInput == null) || (aPrimaryInput != null && bPrimaryInput != null && aPrimaryInput.toString().equals(bPrimaryInput.toString()))) {
    Artifact aPrimaryOutput=a.getPrimaryOutput();
    Artifact bPrimaryOutput=b.getPrimaryOutput();
    if (!aPrimaryOutput.equals(bPrimaryOutput)) {
      sb.append(""String_Node_Str"").append(System.identityHashCode(aPrimaryOutput)).append(""String_Node_Str"").append(System.identityHashCode(bPrimaryOutput)).append('\n');
    }
    ArtifactOwner aArtifactOwner=aPrimaryOutput.getArtifactOwner();
    ArtifactOwner bArtifactOwner=bPrimaryOutput.getArtifactOwner();
    addStringDetail(sb,""String_Node_Str"",aArtifactOwner.toString(),bArtifactOwner.toString());
    addListDetail(sb,""String_Node_Str"",a.getMandatoryInputs(),b.getMandatoryInputs());
    addListDetail(sb,""String_Node_Str"",a.getOutputs(),b.getOutputs());
  }
  return sb.toString();
}",0.9850746268656716
110685,"@Override public void initializeRuleClasses(ConfiguredRuleClassProvider.Builder builder){
  for (  Entry<String,RepositoryFunction> handler : repositoryHandlers.entrySet()) {
    RuleDefinition ruleDefinition;
    try {
      ruleDefinition=handler.getValue().getRuleDefinition().newInstance();
    }
 catch (    IllegalAccessException|InstantiationException e) {
      throw new IllegalStateException(e);
    }
    builder.addRuleDefinition(ruleDefinition);
  }
  builder.addSkylarkModule(SkylarkRepositoryModule.class);
}","@Override public void initializeRuleClasses(ConfiguredRuleClassProvider.Builder builder){
  for (  Entry<String,RepositoryFunction> handler : repositoryHandlers.entrySet()) {
    RuleDefinition ruleDefinition;
    try {
      ruleDefinition=handler.getValue().getRuleDefinition().getDeclaredConstructor().newInstance();
    }
 catch (    IllegalAccessException|InstantiationException|NoSuchMethodException|InvocationTargetException e) {
      throw new IllegalStateException(e);
    }
    builder.addRuleDefinition(ruleDefinition);
  }
  builder.addSkylarkModule(SkylarkRepositoryModule.class);
}",0.8757819481680071
110686,"@Override public boolean equals(Object other){
  return this == other || other instanceof DecompressorValue && directory.equals(((DecompressorValue)other).directory);
}","@Override public boolean equals(Object other){
  return this == other || (other instanceof DecompressorValue && directory.equals(((DecompressorValue)other).directory));
}",0.9940828402366864
110687,"private static NdkRelease getNdkRelease(Path directory,Environment env) throws RepositoryFunctionException, InterruptedException {
  Path releaseFilePath=directory.getRelative(""String_Node_Str"");
  if (!releaseFilePath.exists()) {
    releaseFilePath=directory.getRelative(""String_Node_Str"");
  }
  SkyKey releaseFileKey=FileValue.key(RootedPath.toRootedPath(directory,releaseFilePath));
  String releaseFileContent;
  try {
    env.getValueOrThrow(releaseFileKey,IOException.class,FileSymlinkException.class,InconsistentFilesystemException.class);
    releaseFileContent=new String(FileSystemUtils.readContent(releaseFilePath));
  }
 catch (  IOException|FileSymlinkException|InconsistentFilesystemException e) {
    throw new RepositoryFunctionException(new IOException(""String_Node_Str"" + releaseFilePath.getBaseName() + ""String_Node_Str""+ e.getMessage()),Transience.PERSISTENT);
  }
  return NdkRelease.create(releaseFileContent.trim());
}","private static NdkRelease getNdkRelease(Path directory,Environment env) throws RepositoryFunctionException, InterruptedException {
  Path releaseFilePath=directory.getRelative(""String_Node_Str"");
  if (!releaseFilePath.exists()) {
    releaseFilePath=directory.getRelative(""String_Node_Str"");
  }
  SkyKey releaseFileKey=FileValue.key(RootedPath.toRootedPath(directory,releaseFilePath));
  String releaseFileContent;
  try {
    env.getValueOrThrow(releaseFileKey,IOException.class,FileSymlinkException.class,InconsistentFilesystemException.class);
    releaseFileContent=new String(FileSystemUtils.readContent(releaseFilePath),StandardCharsets.UTF_8);
  }
 catch (  IOException|FileSymlinkException|InconsistentFilesystemException e) {
    throw new RepositoryFunctionException(new IOException(""String_Node_Str"" + releaseFilePath.getBaseName() + ""String_Node_Str""+ e.getMessage()),Transience.PERSISTENT);
  }
  return NdkRelease.create(releaseFileContent.trim());
}",0.9879518072289156
110688,"@Override public ConfiguredTarget create(RuleContext ruleContext) throws RuleErrorException {
  ImmutableList<Artifact> srcs=ruleContext.getPrerequisiteArtifacts(""String_Node_Str"",Mode.TARGET).list();
  if (srcs.size() != 1) {
    ruleContext.attributeError(""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  Artifact symlink=ruleContext.createOutputArtifact();
  Artifact src=srcs.get(0);
  ruleContext.registerAction(new ExecutableSymlinkAction(ruleContext.getActionOwner(),src,symlink));
  NestedSetBuilder<Artifact> filesToBuildBuilder=NestedSetBuilder.<Artifact>stableOrder().add(src).add(symlink);
  Runfiles.Builder runfilesBuilder=new Runfiles.Builder(ruleContext.getWorkspaceName(),ruleContext.getConfiguration().legacyExternalRunfiles());
  Artifact mainExecutable=(OS.getCurrent() == OS.WINDOWS) ? launcherForWindows(ruleContext,symlink,src) : symlink;
  if (symlink != mainExecutable) {
    filesToBuildBuilder.add(mainExecutable);
    runfilesBuilder.addArtifact(symlink);
  }
  NestedSet<Artifact> filesToBuild=filesToBuildBuilder.build();
  Runfiles runfiles=runfilesBuilder.addTransitiveArtifacts(filesToBuild).addRunfiles(ruleContext,RunfilesProvider.DEFAULT_RUNFILES).build();
  RunfilesSupport runfilesSupport=RunfilesSupport.withExecutable(ruleContext,runfiles,mainExecutable);
  return new RuleConfiguredTargetBuilder(ruleContext).setFilesToBuild(filesToBuild).setRunfilesSupport(runfilesSupport,mainExecutable).addProvider(RunfilesProvider.class,RunfilesProvider.simple(runfiles)).build();
}","@Override public ConfiguredTarget create(RuleContext ruleContext) throws RuleErrorException {
  ImmutableList<Artifact> srcs=ruleContext.getPrerequisiteArtifacts(""String_Node_Str"",Mode.TARGET).list();
  if (srcs.size() != 1) {
    ruleContext.attributeError(""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  Artifact symlink=ruleContext.createOutputArtifact();
  Artifact src=srcs.get(0);
  ruleContext.registerAction(new ExecutableSymlinkAction(ruleContext.getActionOwner(),src,symlink));
  NestedSetBuilder<Artifact> filesToBuildBuilder=NestedSetBuilder.<Artifact>stableOrder().add(src).add(symlink);
  Runfiles.Builder runfilesBuilder=new Runfiles.Builder(ruleContext.getWorkspaceName(),ruleContext.getConfiguration().legacyExternalRunfiles());
  Artifact mainExecutable=(OS.getCurrent() == OS.WINDOWS) ? launcherForWindows(ruleContext,symlink,src) : symlink;
  if (!symlink.equals(mainExecutable)) {
    filesToBuildBuilder.add(mainExecutable);
    runfilesBuilder.addArtifact(symlink);
  }
  NestedSet<Artifact> filesToBuild=filesToBuildBuilder.build();
  Runfiles runfiles=runfilesBuilder.addTransitiveArtifacts(filesToBuild).addRunfiles(ruleContext,RunfilesProvider.DEFAULT_RUNFILES).build();
  RunfilesSupport runfilesSupport=RunfilesSupport.withExecutable(ruleContext,runfiles,mainExecutable);
  return new RuleConfiguredTargetBuilder(ruleContext).setFilesToBuild(filesToBuild).setRunfilesSupport(runfilesSupport,mainExecutable).addProvider(RunfilesProvider.class,RunfilesProvider.simple(runfiles)).build();
}",0.9954128440366972
110689,"public Collection<BuildEventId> getChildrenEvents(){
  return event.getChildrenEvents();
}","@Override public Collection<BuildEventId> getChildrenEvents(){
  return event.getChildrenEvents();
}",0.9473684210526316
110690,"public BuildEventId getEventId(){
  return event.getEventId();
}","@Override public BuildEventId getEventId(){
  return event.getEventId();
}",0.927536231884058
110691,"public BuildEventStreamProtos.BuildEvent asStreamProto(BuildEventConverters converters){
  return BuildEventStreamProtos.BuildEvent.newBuilder(event.asStreamProto(converters)).setLastMessage(true).build();
}","@Override public BuildEventStreamProtos.BuildEvent asStreamProto(BuildEventConverters converters){
  return BuildEventStreamProtos.BuildEvent.newBuilder(event.asStreamProto(converters)).setLastMessage(true).build();
}",0.9764150943396226
110692,"@Override public synchronized void sendBuildEvent(BuildEvent event,final ArtifactGroupNamer namer){
  BuildEventConverters converters=new BuildEventConverters(){
    @Override public PathConverter pathConverter(){
      return pathConverter;
    }
    @Override public ArtifactGroupNamer artifactGroupNamer(){
      return namer;
    }
  }
;
  String protoJsonRepresentation;
  try {
    protoJsonRepresentation=JsonFormat.printer().omittingInsignificantWhitespace().print(event.asStreamProto(converters)) + ""String_Node_Str"";
  }
 catch (  InvalidProtocolBufferException e) {
    protoJsonRepresentation=""String_Node_Str"";
  }
  writeData(protoJsonRepresentation.getBytes());
}","@Override public synchronized void sendBuildEvent(BuildEvent event,final ArtifactGroupNamer namer){
  BuildEventConverters converters=new BuildEventConverters(){
    @Override public PathConverter pathConverter(){
      return pathConverter;
    }
    @Override public ArtifactGroupNamer artifactGroupNamer(){
      return namer;
    }
  }
;
  String protoJsonRepresentation;
  try {
    protoJsonRepresentation=JsonFormat.printer().omittingInsignificantWhitespace().print(event.asStreamProto(converters)) + ""String_Node_Str"";
  }
 catch (  InvalidProtocolBufferException e) {
    protoJsonRepresentation=""String_Node_Str"";
  }
  writeData(protoJsonRepresentation.getBytes(StandardCharsets.UTF_8));
}",0.9840348330914368
110693,"@Override public synchronized void sendBuildEvent(BuildEvent event,final ArtifactGroupNamer namer){
  BuildEventConverters converters=new BuildEventConverters(){
    @Override public PathConverter pathConverter(){
      return pathConverter;
    }
    @Override public ArtifactGroupNamer artifactGroupNamer(){
      return namer;
    }
  }
;
  String protoTextRepresentation=TextFormat.printToString(event.asStreamProto(converters));
  String line=""String_Node_Str"" + protoTextRepresentation + ""String_Node_Str"";
  writeData(line.getBytes());
}","@Override public synchronized void sendBuildEvent(BuildEvent event,final ArtifactGroupNamer namer){
  BuildEventConverters converters=new BuildEventConverters(){
    @Override public PathConverter pathConverter(){
      return pathConverter;
    }
    @Override public ArtifactGroupNamer artifactGroupNamer(){
      return namer;
    }
  }
;
  String protoTextRepresentation=TextFormat.printToString(event.asStreamProto(converters));
  String line=""String_Node_Str"" + protoTextRepresentation + ""String_Node_Str"";
  writeData(line.getBytes(StandardCharsets.UTF_8));
}",0.9801801801801802
110694,"ActionExecutionInactivityWatchdog.InactivityMonitor createInactivityMonitor(final ActionExecutionStatusReporter statusReporter){
  return new ActionExecutionInactivityWatchdog.InactivityMonitor(){
    @Override public boolean hasStarted(){
      return !enqueuedActions.isEmpty();
    }
    @Override public int getPending(){
      return statusReporter.getCount();
    }
    @Override public int waitForNextCompletion(    int timeoutMilliseconds) throws InterruptedException {
synchronized (activityIndicator) {
        int before=completedActions.size();
        long startTime=BlazeClock.instance().currentTimeMillis();
        while (true) {
          activityIndicator.wait(timeoutMilliseconds);
          int completed=completedActions.size() - before;
          long now=0;
          if (completed > 0 || (startTime + timeoutMilliseconds) <= (now=BlazeClock.instance().currentTimeMillis())) {
            return completed;
          }
 else {
            timeoutMilliseconds-=now - startTime;
            startTime=now;
          }
        }
      }
    }
  }
;
}","ActionExecutionInactivityWatchdog.InactivityMonitor createInactivityMonitor(final ActionExecutionStatusReporter statusReporter){
  return new ActionExecutionInactivityWatchdog.InactivityMonitor(){
    @Override public boolean hasStarted(){
      return !enqueuedActions.isEmpty();
    }
    @Override public int getPending(){
      return statusReporter.getCount();
    }
    @Override public int waitForNextCompletion(    int timeoutMilliseconds) throws InterruptedException {
      long rest=timeoutMilliseconds;
synchronized (activityIndicator) {
        int before=completedActions.size();
        long startTime=BlazeClock.instance().currentTimeMillis();
        while (true) {
          activityIndicator.wait(rest);
          int completed=completedActions.size() - before;
          long now=0;
          if (completed > 0 || (startTime + rest) <= (now=BlazeClock.instance().currentTimeMillis())) {
            return completed;
          }
 else {
            rest-=now - startTime;
            startTime=now;
          }
        }
      }
    }
  }
;
}",0.950281425891182
110695,"@Override public int waitForNextCompletion(int timeoutMilliseconds) throws InterruptedException {
synchronized (activityIndicator) {
    int before=completedActions.size();
    long startTime=BlazeClock.instance().currentTimeMillis();
    while (true) {
      activityIndicator.wait(timeoutMilliseconds);
      int completed=completedActions.size() - before;
      long now=0;
      if (completed > 0 || (startTime + timeoutMilliseconds) <= (now=BlazeClock.instance().currentTimeMillis())) {
        return completed;
      }
 else {
        timeoutMilliseconds-=now - startTime;
        startTime=now;
      }
    }
  }
}","@Override public int waitForNextCompletion(int timeoutMilliseconds) throws InterruptedException {
  long rest=timeoutMilliseconds;
synchronized (activityIndicator) {
    int before=completedActions.size();
    long startTime=BlazeClock.instance().currentTimeMillis();
    while (true) {
      activityIndicator.wait(rest);
      int completed=completedActions.size() - before;
      long now=0;
      if (completed > 0 || (startTime + rest) <= (now=BlazeClock.instance().currentTimeMillis())) {
        return completed;
      }
 else {
        rest-=now - startTime;
        startTime=now;
      }
    }
  }
}",0.9172077922077922
110696,"private ExplanationHandler(OutputStream log,String optionsDescription){
  this.log=new PrintWriter(log);
  this.log.println(""String_Node_Str"" + optionsDescription);
}","private ExplanationHandler(OutputStream log,String optionsDescription){
  this.log=new PrintWriter(new OutputStreamWriter(log,StandardCharsets.UTF_8));
  this.log.println(""String_Node_Str"" + optionsDescription);
}",0.8601583113456465
110697,"/** 
 * See partition(Collection, Comparator).
 */
public static <T>Collection<Set<T>> partition(Collection<T> elements,final EquivalenceRelation<T> equivalenceRelation){
  return partition(elements,(Comparator<T>)equivalenceRelation::compare);
}","/** 
 * See partition(Collection, Comparator).
 */
public static <T>Collection<Set<T>> partition(Collection<T> elements,final EquivalenceRelation<T> equivalenceRelation){
  return partitionWithComparator(elements,(Comparator<T>)equivalenceRelation::compare);
}",0.9723320158102768
110698,"@Override public boolean equals(Object o){
  if (this == o) {
    return true;
  }
  if (o == null || getClass() != o.getClass()) {
    return false;
  }
  ImmutableSharedKeyMap<?,?> that=(ImmutableSharedKeyMap<?,?>)o;
  return offsetTable == that.offsetTable && Arrays.equals(values,that.values);
}","@Override @SuppressWarnings(""String_Node_Str"") public boolean equals(Object o){
  if (this == o) {
    return true;
  }
  if (o == null || getClass() != o.getClass()) {
    return false;
  }
  ImmutableSharedKeyMap<?,?> that=(ImmutableSharedKeyMap<?,?>)o;
  return offsetTable == that.offsetTable && Arrays.equals(values,that.values);
}",0.9417322834645668
110699,"/** 
 * Perform a depth-first traversal of   {@code children}, tracking visited arrays in   {@code sets} and visited leaves in {@code members}.  We also record which edges were taken in   {@code this.memo} starting at {@code pos}. Returns the final value of   {@code pos}.
 */
private int walk(CompactHashSet<Object> sets,CompactHashSet<E> members,Object[] children,int pos){
  for (  Object child : children) {
    if ((pos >> 3) >= memo.length) {
      memo=Arrays.copyOf(memo,memo.length * 2);
    }
    if (child instanceof Object[]) {
      if (sets.add(child)) {
        int prepos=pos;
        int presize=members.size();
        pos=walk(sets,members,(Object[])child,pos + 1);
        if (presize < members.size()) {
          memo[prepos >> 3]|=1 << (prepos & 7);
        }
 else {
          pos=prepos + 1;
        }
      }
 else {
        ++pos;
      }
    }
 else {
      if (members.add((E)child)) {
        memo[pos >> 3]|=1 << (pos & 7);
      }
      ++pos;
    }
  }
  return pos;
}","/** 
 * Perform a depth-first traversal of   {@code children}, tracking visited arrays in   {@code sets} and visited leaves in {@code members}.  We also record which edges were taken in   {@code this.memo} starting at {@code pos}. Returns the final value of   {@code pos}.
 */
private int walk(CompactHashSet<Object> sets,CompactHashSet<E> members,Object[] children,int pos){
  for (  Object child : children) {
    if ((pos >> 3) >= memo.length) {
      memo=Arrays.copyOf(memo,memo.length * 2);
    }
    if (child instanceof Object[]) {
      if (sets.add(child)) {
        int prepos=pos;
        int presize=members.size();
        pos=walk(sets,members,(Object[])child,pos + 1);
        if (presize < members.size()) {
          memo[prepos >> 3]|=(byte)(1 << (prepos & 7));
        }
 else {
          pos=prepos + 1;
        }
      }
 else {
        ++pos;
      }
    }
 else {
      if (members.add((E)child)) {
        memo[pos >> 3]|=(byte)(1 << (pos & 7));
      }
      ++pos;
    }
  }
  return pos;
}",0.99207135777998
110700,"public boolean isLicenseSpecified(){
  return license != null && license != License.NO_LICENSE;
}","public boolean isLicenseSpecified(){
  return license != null && license.isSpecified();
}",0.8387096774193549
110701,"/** 
 * A simple equals implementation leveraging the support built into Set that delegates to its contents.
 */
@Override public boolean equals(Object o){
  return o == this || o instanceof License && ((License)o).licenseTypes.equals(this.licenseTypes) && ((License)o).exceptions.equals(this.exceptions);
}","/** 
 * A simple equals implementation leveraging the support built into Set that delegates to its contents.
 */
@Override public boolean equals(Object o){
  return o == this || (o instanceof License && ((License)o).licenseTypes.equals(this.licenseTypes) && ((License)o).exceptions.equals(this.exceptions));
}",0.9967532467532468
110702,"/** 
 * Sets the visibility and license for an input file. The input file must already exist as a member of this package.
 * @throws IllegalArgumentException if the input file doesn't exist in thispackage's target map.
 */
void setVisibilityAndLicense(InputFile inputFile,RuleVisibility visibility,License license){
  String filename=inputFile.getName();
  Target cacheInstance=targets.get(filename);
  if (!(cacheInstance instanceof InputFile)) {
    throw new IllegalArgumentException(""String_Node_Str"" + filename + ""String_Node_Str""+ pkg.getName()+ ""String_Node_Str"");
  }
  if (!((InputFile)cacheInstance).isVisibilitySpecified() || cacheInstance.getVisibility() != visibility || cacheInstance.getLicense() != license) {
    targets.put(filename,new InputFile(pkg,cacheInstance.getLabel(),cacheInstance.getLocation(),visibility,license));
  }
}","/** 
 * Sets the visibility and license for an input file. The input file must already exist as a member of this package.
 * @throws IllegalArgumentException if the input file doesn't exist in thispackage's target map.
 */
void setVisibilityAndLicense(InputFile inputFile,RuleVisibility visibility,License license){
  String filename=inputFile.getName();
  Target cacheInstance=targets.get(filename);
  if (!(cacheInstance instanceof InputFile)) {
    throw new IllegalArgumentException(""String_Node_Str"" + filename + ""String_Node_Str""+ pkg.getName()+ ""String_Node_Str"");
  }
  if (!((InputFile)cacheInstance).isVisibilitySpecified() || cacheInstance.getVisibility() != visibility || !Objects.equals(cacheInstance.getLicense(),license)) {
    targets.put(filename,new InputFile(pkg,cacheInstance.getLabel(),cacheInstance.getLocation(),visibility,license));
  }
}",0.9789473684210528
110703,"static Runtime.NoneType callExportsFiles(Object srcs,Object visibilityO,Object licensesO,FuncallExpression ast,Environment env) throws EvalException, ConversionException {
  Package.Builder pkgBuilder=getContext(env,ast).pkgBuilder;
  List<String> files=Type.STRING_LIST.convert(srcs,""String_Node_Str"");
  RuleVisibility visibility;
  try {
    visibility=EvalUtils.isNullOrNone(visibilityO) ? ConstantRuleVisibility.PUBLIC : getVisibility(pkgBuilder.getBuildFileLabel(),BuildType.LABEL_LIST.convert(visibilityO,""String_Node_Str"",pkgBuilder.getBuildFileLabel()));
  }
 catch (  EvalException e) {
    throw new EvalException(ast.getLocation(),e.getMessage());
  }
  License license=BuildType.LICENSE.convertOptional(licensesO,""String_Node_Str"");
  for (  String file : files) {
    String errorMessage=LabelValidator.validateTargetName(file);
    if (errorMessage != null) {
      throw new EvalException(ast.getLocation(),errorMessage);
    }
    try {
      InputFile inputFile=pkgBuilder.createInputFile(file,ast.getLocation());
      if (inputFile.isVisibilitySpecified() && inputFile.getVisibility() != visibility) {
        throw new EvalException(ast.getLocation(),String.format(""String_Node_Str"",inputFile.getName()));
      }
      if (license != null && inputFile.isLicenseSpecified()) {
        throw new EvalException(ast.getLocation(),String.format(""String_Node_Str"",inputFile.getName()));
      }
      if (license == null && pkgBuilder.getDefaultLicense() == License.NO_LICENSE && RuleClass.isThirdPartyPackage(pkgBuilder.getPackageIdentifier())) {
        throw new EvalException(ast.getLocation(),""String_Node_Str"" + inputFile.getName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      pkgBuilder.setVisibilityAndLicense(inputFile,visibility,license);
    }
 catch (    Package.Builder.GeneratedLabelConflict e) {
      throw new EvalException(ast.getLocation(),e.getMessage());
    }
  }
  return Runtime.NONE;
}","static Runtime.NoneType callExportsFiles(Object srcs,Object visibilityO,Object licensesO,FuncallExpression ast,Environment env) throws EvalException, ConversionException {
  Package.Builder pkgBuilder=getContext(env,ast).pkgBuilder;
  List<String> files=Type.STRING_LIST.convert(srcs,""String_Node_Str"");
  RuleVisibility visibility;
  try {
    visibility=EvalUtils.isNullOrNone(visibilityO) ? ConstantRuleVisibility.PUBLIC : getVisibility(pkgBuilder.getBuildFileLabel(),BuildType.LABEL_LIST.convert(visibilityO,""String_Node_Str"",pkgBuilder.getBuildFileLabel()));
  }
 catch (  EvalException e) {
    throw new EvalException(ast.getLocation(),e.getMessage());
  }
  License license=BuildType.LICENSE.convertOptional(licensesO,""String_Node_Str"");
  for (  String file : files) {
    String errorMessage=LabelValidator.validateTargetName(file);
    if (errorMessage != null) {
      throw new EvalException(ast.getLocation(),errorMessage);
    }
    try {
      InputFile inputFile=pkgBuilder.createInputFile(file,ast.getLocation());
      if (inputFile.isVisibilitySpecified() && inputFile.getVisibility() != visibility) {
        throw new EvalException(ast.getLocation(),String.format(""String_Node_Str"",inputFile.getName()));
      }
      if (license != null && inputFile.isLicenseSpecified()) {
        throw new EvalException(ast.getLocation(),String.format(""String_Node_Str"",inputFile.getName()));
      }
      if (license == null && !pkgBuilder.getDefaultLicense().isSpecified() && RuleClass.isThirdPartyPackage(pkgBuilder.getPackageIdentifier())) {
        throw new EvalException(ast.getLocation(),""String_Node_Str"" + inputFile.getName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      pkgBuilder.setVisibilityAndLicense(inputFile,visibility,license);
    }
 catch (    Package.Builder.GeneratedLabelConflict e) {
      throw new EvalException(ast.getLocation(),e.getMessage());
    }
  }
  return Runtime.NONE;
}",0.9905201127337944
110704,"/** 
 * Reports an error against the specified rule if it's beneath third_party but does not have a declared license.
 */
private static void checkThirdPartyRuleHasLicense(Rule rule,Package.Builder pkgBuilder,EventHandler eventHandler){
  if (isThirdPartyPackage(rule.getLabel().getPackageIdentifier())) {
    License license=rule.getLicense();
    if (license == null) {
      license=pkgBuilder.getDefaultLicense();
    }
    if (license == License.NO_LICENSE) {
      rule.reportError(""String_Node_Str"" + rule.getLabel() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",eventHandler);
    }
  }
}","/** 
 * Reports an error against the specified rule if it's beneath third_party but does not have a declared license.
 */
private static void checkThirdPartyRuleHasLicense(Rule rule,Package.Builder pkgBuilder,EventHandler eventHandler){
  if (isThirdPartyPackage(rule.getLabel().getPackageIdentifier())) {
    License license=rule.getLicense();
    if (license == null) {
      license=pkgBuilder.getDefaultLicense();
    }
    if (!license.isSpecified()) {
      rule.reportError(""String_Node_Str"" + rule.getLabel() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",eventHandler);
    }
  }
}",0.7923904052936311
110705,"/** 
 * Uses the given label to retrieve the workspace-relative path of the given location (including the line number). <p>For example, the location /usr/local/workspace/my/cool/package/BUILD:3:1 and the label //my/cool/package:BUILD would lead to ""my/cool/package:BUILD:3"".
 * @return The workspace-relative path of the given location, or null if it could not be computed.
 */
@Nullable private static String maybeGetRelativeLocation(@Nullable Location location,Label label){
  if (location == null) {
    return null;
  }
  String absolutePath=Location.printPathAndLine(location);
  int pos=absolutePath.indexOf(label.getPackageName());
  return (pos < 0) ? null : absolutePath.substring(pos);
}","/** 
 * Uses the given label to retrieve the workspace-relative path of the given location (including the line number). <p>For example, the location /usr/local/workspace/my/cool/package/BUILD:3:1 and the label //my/cool/package:BUILD would lead to ""my/cool/package:BUILD:3"".
 * @return The workspace-relative path of the given location, or null if it could not be computed.
 */
@Nullable private static String maybeGetRelativeLocation(@Nullable Location location,Label label){
  if (location == null) {
    return null;
  }
  String absolutePath=Location.printLocation(location);
  int pos=absolutePath.indexOf(label.getPackageName());
  return (pos < 0) ? null : absolutePath.substring(pos);
}",0.9863407620416966
110706,"private void enqueueTarget(final Target from,final Attribute attr,final Label label,final int depth,final int count){
  if (depth >= maxDepth) {
    return;
  }
  if (from != null && from.getLabel().getPackageFragment() == label.getPackageFragment() && !blockNewActions() && count < RECURSION_LIMIT) {
    newVisitRunnable(from,attr,label,depth,count + 1).run();
  }
 else {
    execute(newVisitRunnable(from,attr,label,depth,0));
  }
}","private void enqueueTarget(final Target from,final Attribute attr,final Label label,final int depth,final int count){
  if (depth >= maxDepth) {
    return;
  }
  if (from != null && from.getLabel().getPackageFragment().equals(label.getPackageFragment()) && !blockNewActions() && count < RECURSION_LIMIT) {
    newVisitRunnable(from,attr,label,depth,count + 1).run();
  }
 else {
    execute(newVisitRunnable(from,attr,label,depth,0));
  }
}",0.9737742303306728
110707,"@Override public void output(QueryOptions options,Digraph<Target> result,OutputStream out,AspectResolver aspectProvider){
  this.graphNodeStringLimit=options.graphNodeStringLimit;
  boolean sortLabels=options.orderOutput == OrderOutput.FULL;
  if (options.graphFactored) {
    outputFactored(result,new PrintWriter(out),sortLabels);
  }
 else {
    outputUnfactored(result,new PrintWriter(out),sortLabels,options);
  }
}","@Override public void output(QueryOptions options,Digraph<Target> result,OutputStream out,AspectResolver aspectProvider){
  this.graphNodeStringLimit=options.graphNodeStringLimit;
  boolean sortLabels=options.orderOutput == OrderOutput.FULL;
  if (options.graphFactored) {
    outputFactored(result,new PrintWriter(new OutputStreamWriter(out,StandardCharsets.UTF_8)),sortLabels);
  }
 else {
    outputUnfactored(result,new PrintWriter(new OutputStreamWriter(out,StandardCharsets.UTF_8)),sortLabels,options);
  }
}",0.8865096359743041
110708,"/** 
 * Returns an equivalence relation for nodes in the specified graph. <p>Two nodes are considered equal iff they have equal topology (predecessors and successors). TODO(bazel-team): Make this a method of Digraph.
 */
private static <LABEL>EquivalenceRelation<Node<LABEL>> createEquivalenceRelation(){
  return new EquivalenceRelation<Node<LABEL>>(){
    @Override public int compare(    Node<LABEL> x,    Node<LABEL> y){
      if (x == y) {
        return 0;
      }
      if (x.numPredecessors() != y.numPredecessors() || x.numSuccessors() != y.numSuccessors()) {
        return -1;
      }
      Set<Node<LABEL>> xpred=new HashSet<>(x.getPredecessors());
      Set<Node<LABEL>> ypred=new HashSet<>(y.getPredecessors());
      if (!xpred.equals(ypred)) {
        return -1;
      }
      Set<Node<LABEL>> xsucc=new HashSet<>(x.getSuccessors());
      Set<Node<LABEL>> ysucc=new HashSet<>(y.getSuccessors());
      if (!xsucc.equals(ysucc)) {
        return -1;
      }
      return 0;
    }
  }
;
}","/** 
 * Returns an equivalence relation for nodes in the specified graph. <p>Two nodes are considered equal iff they have equal topology (predecessors and successors). TODO(bazel-team): Make this a method of Digraph.
 */
@SuppressWarnings(""String_Node_Str"") private static <LABEL>EquivalenceRelation<Node<LABEL>> createEquivalenceRelation(){
  return new EquivalenceRelation<Node<LABEL>>(){
    @Override public int compare(    Node<LABEL> x,    Node<LABEL> y){
      if (x == y) {
        return 0;
      }
      if (x.numPredecessors() != y.numPredecessors() || x.numSuccessors() != y.numSuccessors()) {
        return -1;
      }
      Set<Node<LABEL>> xpred=new HashSet<>(x.getPredecessors());
      Set<Node<LABEL>> ypred=new HashSet<>(y.getPredecessors());
      if (!xpred.equals(ypred)) {
        return -1;
      }
      Set<Node<LABEL>> xsucc=new HashSet<>(x.getSuccessors());
      Set<Node<LABEL>> ysucc=new HashSet<>(y.getSuccessors());
      if (!xsucc.equals(ysucc)) {
        return -1;
      }
      return 0;
    }
  }
;
}",0.9818893783651492
110709,"/** 
 * Creates and returns a new Blaze RPCServer. Call   {@link RPCServer#serve()} to start the server.
 */
private static RPCServer createBlazeRPCServer(Iterable<BlazeModule> modules,List<String> args) throws IOException, OptionsParsingException, AbruptExitException {
  final RPCServer[] rpcServer=new RPCServer[1];
  Runnable prepareForAbruptShutdown=() -> rpcServer[0].prepareForAbruptShutdown();
  BlazeRuntime runtime=newRuntime(modules,args,prepareForAbruptShutdown);
  BlazeCommandDispatcher dispatcher=new BlazeCommandDispatcher(runtime);
  CommandExecutor commandExecutor=new CommandExecutor(runtime,dispatcher);
  BlazeServerStartupOptions startupOptions=runtime.getStartupOptionsProvider().getOptions(BlazeServerStartupOptions.class);
  try {
    Class<?> factoryClass=Class.forName(""String_Node_Str"");
    RPCServer.Factory factory=(RPCServer.Factory)factoryClass.getConstructor().newInstance();
    rpcServer[0]=factory.create(commandExecutor,runtime.getClock(),startupOptions.commandPort,runtime.getWorkspace().getWorkspace(),runtime.getServerDirectory(),startupOptions.maxIdleSeconds);
    return rpcServer[0];
  }
 catch (  ReflectiveOperationException|IllegalArgumentException e) {
    throw new AbruptExitException(""String_Node_Str"",ExitCode.BLAZE_INTERNAL_ERROR);
  }
}","/** 
 * Creates and returns a new Blaze RPCServer. Call   {@link RPCServer#serve()} to start the server.
 */
@SuppressWarnings(""String_Node_Str"") private static RPCServer createBlazeRPCServer(Iterable<BlazeModule> modules,List<String> args) throws IOException, OptionsParsingException, AbruptExitException {
  final RPCServer[] rpcServer=new RPCServer[1];
  Runnable prepareForAbruptShutdown=() -> rpcServer[0].prepareForAbruptShutdown();
  BlazeRuntime runtime=newRuntime(modules,args,prepareForAbruptShutdown);
  BlazeCommandDispatcher dispatcher=new BlazeCommandDispatcher(runtime);
  CommandExecutor commandExecutor=new CommandExecutor(runtime,dispatcher);
  BlazeServerStartupOptions startupOptions=runtime.getStartupOptionsProvider().getOptions(BlazeServerStartupOptions.class);
  try {
    Class<?> factoryClass=Class.forName(""String_Node_Str"");
    RPCServer.Factory factory=(RPCServer.Factory)factoryClass.getConstructor().newInstance();
    rpcServer[0]=factory.create(commandExecutor,runtime.getClock(),startupOptions.commandPort,runtime.getWorkspace().getWorkspace(),runtime.getServerDirectory(),startupOptions.maxIdleSeconds);
    return rpcServer[0];
  }
 catch (  ReflectiveOperationException|IllegalArgumentException e) {
    throw new AbruptExitException(""String_Node_Str"",ExitCode.BLAZE_INTERNAL_ERROR);
  }
}",0.9858616736721436
110710,"UnprefixingClassWriter(int flags){
  super(Opcodes.ASM5);
  this.writer=new ClassWriter(flags);
  this.cv=this.writer;
  if (!prefix.isEmpty()) {
    this.cv=new ClassRemapperWithBugFix(this.cv,new Remapper(){
      @Override public String map(      String typeName){
        return unprefix(typeName);
      }
    }
);
  }
}","UnprefixingClassWriter(int flags){
  super(Opcodes.ASM5);
  this.writer=new ClassWriter(flags);
  this.cv=this.writer;
  if (!prefix.isEmpty()) {
    this.cv=new ClassRemapper(this.cv,new Remapper(){
      @Override public String map(      String typeName){
        return unprefix(typeName);
      }
    }
);
  }
}",0.984375
110711,"@Override public void accept(ClassVisitor cv,Attribute[] attrs,int flags){
  cv=new ClassRemapperWithBugFix(cv,new Remapper(){
    @Override public String map(    String typeName){
      return prefix(typeName);
    }
  }
);
  super.accept(cv,attrs,flags);
}","@Override public void accept(ClassVisitor cv,Attribute[] attrs,int flags){
  cv=new ClassRemapper(cv,new Remapper(){
    @Override public String map(    String typeName){
      return prefix(typeName);
    }
  }
);
  super.accept(cv,attrs,flags);
}",0.9802371541501976
110712,"/** 
 * Performs tokenization of the character buffer of file contents provided to the constructor.
 */
private void tokenize(){
  while (pos < buffer.length) {
    if (tokenizeTwoChars()) {
      pos+=2;
      continue;
    }
    char c=buffer[pos];
    pos++;
switch (c) {
case '{':
{
        addToken(new Token(TokenKind.LBRACE,pos - 1,pos));
        openParenStackDepth++;
        break;
      }
case '}':
{
      addToken(new Token(TokenKind.RBRACE,pos - 1,pos));
      popParen();
      break;
    }
case '(':
{
    addToken(new Token(TokenKind.LPAREN,pos - 1,pos));
    openParenStackDepth++;
    break;
  }
case ')':
{
  addToken(new Token(TokenKind.RPAREN,pos - 1,pos));
  popParen();
  break;
}
case '[':
{
addToken(new Token(TokenKind.LBRACKET,pos - 1,pos));
openParenStackDepth++;
break;
}
case ']':
{
addToken(new Token(TokenKind.RBRACKET,pos - 1,pos));
popParen();
break;
}
case '>':
{
addToken(new Token(TokenKind.GREATER,pos - 1,pos));
break;
}
case '<':
{
addToken(new Token(TokenKind.LESS,pos - 1,pos));
break;
}
case ':':
{
addToken(new Token(TokenKind.COLON,pos - 1,pos));
break;
}
case ',':
{
addToken(new Token(TokenKind.COMMA,pos - 1,pos));
break;
}
case '+':
{
addToken(new Token(TokenKind.PLUS,pos - 1,pos));
break;
}
case '-':
{
addToken(new Token(TokenKind.MINUS,pos - 1,pos));
break;
}
case '|':
{
addToken(new Token(TokenKind.PIPE,pos - 1,pos));
break;
}
case '=':
{
addToken(new Token(TokenKind.EQUALS,pos - 1,pos));
break;
}
case '%':
{
addToken(new Token(TokenKind.PERCENT,pos - 1,pos));
break;
}
case '/':
{
if (lookaheadIs(0,'/') && lookaheadIs(1,'=')) {
addToken(new Token(TokenKind.SLASH_SLASH_EQUALS,pos - 1,pos + 2));
pos+=2;
}
 else if (lookaheadIs(0,'/')) {
addToken(new Token(TokenKind.SLASH_SLASH,pos - 1,pos + 1));
pos+=1;
}
 else {
addToken(new Token(TokenKind.SLASH,pos - 1,pos));
}
break;
}
case ';':
{
addToken(new Token(TokenKind.SEMI,pos - 1,pos));
break;
}
case '.':
{
addToken(new Token(TokenKind.DOT,pos - 1,pos));
break;
}
case '*':
{
addToken(new Token(TokenKind.STAR,pos - 1,pos));
break;
}
case ' ':
case '\t':
case '\r':
{
break;
}
case '\\':
{
if (lookaheadIs(0,'\n')) {
pos+=1;
}
 else if (lookaheadIs(0,'\r') && lookaheadIs(1,'\n')) {
pos+=2;
}
 else {
addToken(new Token(TokenKind.ILLEGAL,pos - 1,pos,Character.toString(c)));
}
break;
}
case '\n':
{
newline();
break;
}
case '#':
{
int oldPos=pos - 1;
while (pos < buffer.length) {
c=buffer[pos];
if (c == '\n') {
break;
}
 else {
pos++;
}
}
addToken(new Token(TokenKind.COMMENT,oldPos,pos,bufferSlice(oldPos,pos)));
break;
}
case '\'':
case '\""':
{
addToken(stringLiteral(c,false));
break;
}
default :
{
if (c == 'r' && pos < buffer.length && (buffer[pos] == '\'' || buffer[pos] == '\""')) {
c=buffer[pos];
pos++;
addToken(stringLiteral(c,true));
break;
}
if (Character.isDigit(c)) {
addToken(integer());
}
 else if (Character.isJavaIdentifierStart(c) && c != '$') {
addToken(identifierOrKeyword());
}
 else {
error(""String_Node_Str"" + c + ""String_Node_Str"");
}
break;
}
}
}
if (indentStack.size() > 1) {
addToken(new Token(TokenKind.NEWLINE,pos - 1,pos));
while (indentStack.size() > 1) {
indentStack.pop();
addToken(new Token(TokenKind.OUTDENT,pos - 1,pos));
}
}
if (tokens.isEmpty() || Iterables.getLast(tokens).kind != TokenKind.NEWLINE) {
addToken(new Token(TokenKind.NEWLINE,pos - 1,pos));
}
addToken(new Token(TokenKind.EOF,pos,pos));
}","/** 
 * Performs tokenization of the character buffer of file contents provided to the constructor.
 */
private void tokenize(){
  while (pos < buffer.length) {
    if (tokenizeTwoChars()) {
      pos+=2;
      continue;
    }
    char c=buffer[pos];
    pos++;
switch (c) {
case '{':
{
        addToken(new Token(TokenKind.LBRACE,pos - 1,pos));
        openParenStackDepth++;
        break;
      }
case '}':
{
      addToken(new Token(TokenKind.RBRACE,pos - 1,pos));
      popParen();
      break;
    }
case '(':
{
    addToken(new Token(TokenKind.LPAREN,pos - 1,pos));
    openParenStackDepth++;
    break;
  }
case ')':
{
  addToken(new Token(TokenKind.RPAREN,pos - 1,pos));
  popParen();
  break;
}
case '[':
{
addToken(new Token(TokenKind.LBRACKET,pos - 1,pos));
openParenStackDepth++;
break;
}
case ']':
{
addToken(new Token(TokenKind.RBRACKET,pos - 1,pos));
popParen();
break;
}
case '>':
{
addToken(new Token(TokenKind.GREATER,pos - 1,pos));
break;
}
case '<':
{
addToken(new Token(TokenKind.LESS,pos - 1,pos));
break;
}
case ':':
{
addToken(new Token(TokenKind.COLON,pos - 1,pos));
break;
}
case ',':
{
addToken(new Token(TokenKind.COMMA,pos - 1,pos));
break;
}
case '+':
{
addToken(new Token(TokenKind.PLUS,pos - 1,pos));
break;
}
case '-':
{
addToken(new Token(TokenKind.MINUS,pos - 1,pos));
break;
}
case '|':
{
addToken(new Token(TokenKind.PIPE,pos - 1,pos));
break;
}
case '=':
{
addToken(new Token(TokenKind.EQUALS,pos - 1,pos));
break;
}
case '%':
{
addToken(new Token(TokenKind.PERCENT,pos - 1,pos));
break;
}
case '/':
{
if (lookaheadIs(0,'/') && lookaheadIs(1,'=')) {
addToken(new Token(TokenKind.SLASH_SLASH_EQUALS,pos - 1,pos + 2));
pos+=2;
}
 else if (lookaheadIs(0,'/')) {
addToken(new Token(TokenKind.SLASH_SLASH,pos - 1,pos + 1));
pos+=1;
}
 else {
addToken(new Token(TokenKind.SLASH,pos - 1,pos));
}
break;
}
case ';':
{
addToken(new Token(TokenKind.SEMI,pos - 1,pos));
break;
}
case '.':
{
addToken(new Token(TokenKind.DOT,pos - 1,pos));
break;
}
case '*':
{
addToken(new Token(TokenKind.STAR,pos - 1,pos));
break;
}
case ' ':
case '\t':
case '\r':
{
break;
}
case '\\':
{
if (lookaheadIs(0,'\n')) {
pos+=1;
}
 else if (lookaheadIs(0,'\r') && lookaheadIs(1,'\n')) {
pos+=2;
}
 else {
addToken(new Token(TokenKind.ILLEGAL,pos - 1,pos,Character.toString(c)));
}
break;
}
case '\n':
{
newline();
break;
}
case '#':
{
int oldPos=pos - 1;
while (pos < buffer.length) {
c=buffer[pos];
if (c == '\n') {
break;
}
 else {
pos++;
}
}
addToken(new Token(TokenKind.COMMENT,oldPos,pos,bufferSlice(oldPos,pos)));
break;
}
case '\'':
case '\""':
{
addToken(stringLiteral(c,false));
break;
}
default :
{
if (c == 'r' && pos < buffer.length && (buffer[pos] == '\'' || buffer[pos] == '\""')) {
c=buffer[pos];
pos++;
addToken(stringLiteral(c,true));
break;
}
if (c >= '0' && c <= '9') {
addToken(integer());
}
 else if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_') {
addToken(identifierOrKeyword());
}
 else {
error(""String_Node_Str"" + c + ""String_Node_Str"");
}
break;
}
}
}
if (indentStack.size() > 1) {
addToken(new Token(TokenKind.NEWLINE,pos - 1,pos));
while (indentStack.size() > 1) {
indentStack.pop();
addToken(new Token(TokenKind.OUTDENT,pos - 1,pos));
}
}
if (tokens.isEmpty() || Iterables.getLast(tokens).kind != TokenKind.NEWLINE) {
addToken(new Token(TokenKind.NEWLINE,pos - 1,pos));
}
addToken(new Token(TokenKind.EOF,pos,pos));
}",0.970246950312407
110713,"private SkylarkDict(@Nullable Environment env){
  mutability=env == null ? Mutability.IMMUTABLE : env.mutability();
}","private SkylarkDict(@Nullable Environment env){
  this.mutability=env == null ? Mutability.IMMUTABLE : env.mutability();
}",0.9790794979079498
110714,"@Override public List<E> getContents(){
  return contents;
}","/** 
 * Casts this list as a List of   {@code T}, checking that each element has type   {@code T}.
 * @param type the expected class of elements
 * @param description a description of the argument being converted, or null, for debugging
 */
public <T>List<T> getContents(Class<T> type,@Nullable String description) throws EvalException {
  return castList(getContentsUnsafe(),type,description);
}",0.1140350877192982
110715,"@Override public Collection<V> values(){
  return getContentsUnsafe().values();
}","@Override public Collection<V> values(){
  return Collections.unmodifiableMap(getContentsUnsafe()).values();
}",0.8481675392670157
110716,"@Override public Iterator<E> iterator(){
  return getContentsUnsafe().iterator();
}","@Override public Iterator<E> iterator(){
  return Collections.unmodifiableCollection(getContentsUnsafe()).iterator();
}",0.8217821782178217
110717,"@Override public Set<K> keySet(){
  return getContentsUnsafe().keySet();
}","@Override public Set<K> keySet(){
  return Collections.unmodifiableMap(getContentsUnsafe()).keySet();
}",0.8361581920903954
110718,"@Override public List<E> subList(int fromIndex,int toIndex){
  return getContentsUnsafe().subList(fromIndex,toIndex);
}","@Override public List<E> subList(int fromIndex,int toIndex){
  return Collections.unmodifiableList(getContentsUnsafe()).subList(fromIndex,toIndex);
}",0.8880597014925373
110719,"@Override public Set<Map.Entry<K,V>> entrySet(){
  return getContentsUnsafe().entrySet();
}","@Override public Set<Map.Entry<K,V>> entrySet(){
  return Collections.unmodifiableMap(getContentsUnsafe()).entrySet();
}",0.8625592417061612
110720,"@Override public ListIterator<E> listIterator(int index){
  return getContentsUnsafe().listIterator(index);
}","@Override public ListIterator<E> listIterator(int index){
  return Collections.unmodifiableList(getContentsUnsafe()).listIterator(index);
}",0.8790322580645161
110721,"URLConnection connect(URL originalUrl,ImmutableMap<String,String> requestHeaders) throws IOException {
  if (Thread.interrupted()) {
    throw new InterruptedIOException();
  }
  URL url=originalUrl;
  if (HttpUtils.isProtocol(url,""String_Node_Str"")) {
    return url.openConnection();
  }
  List<Throwable> suppressions=new ArrayList<>();
  int retries=0;
  int redirects=0;
  int connectTimeout=MIN_CONNECT_TIMEOUT_MS;
  while (true) {
    HttpURLConnection connection=null;
    try {
      connection=(HttpURLConnection)url.openConnection(proxyHelper.createProxyIfNeeded(url));
      boolean isAlreadyCompressed=COMPRESSED_EXTENSIONS.contains(HttpUtils.getExtension(url.getPath())) || COMPRESSED_EXTENSIONS.contains(HttpUtils.getExtension(originalUrl.getPath()));
      for (      Map.Entry<String,String> entry : requestHeaders.entrySet()) {
        if (isAlreadyCompressed && Ascii.equalsIgnoreCase(entry.getKey(),""String_Node_Str"")) {
          continue;
        }
        connection.setRequestProperty(entry.getKey(),entry.getValue());
      }
      connection.setConnectTimeout(connectTimeout);
      connection.setReadTimeout(READ_TIMEOUT_MS);
      int code;
      try {
        connection.connect();
        code=connection.getResponseCode();
      }
 catch (      FileNotFoundException ignored) {
        code=connection.getResponseCode();
      }
catch (      UnknownHostException e) {
        String message=""String_Node_Str"" + e.getMessage();
        eventHandler.handle(Event.progress(message));
        throw new UnrecoverableHttpException(message);
      }
catch (      IllegalArgumentException e) {
        throw new UnrecoverableHttpException(e.getMessage());
      }
catch (      IOException e) {
        if (e.getMessage() == null || !e.getMessage().startsWith(""String_Node_Str"")) {
          throw e;
        }
        code=connection.getResponseCode();
      }
      if (code == 200 || code == 206) {
        return connection;
      }
 else       if (code == 301 || code == 302 || code == 307) {
        readAllBytesAndClose(connection.getInputStream());
        if (++redirects == MAX_REDIRECTS) {
          eventHandler.handle(Event.progress(""String_Node_Str"" + originalUrl));
          throw new UnrecoverableHttpException(""String_Node_Str"");
        }
        url=HttpUtils.getLocation(connection);
        if (code == 301) {
          originalUrl=url;
        }
      }
 else       if (code == 403) {
        throw new IOException(describeHttpResponse(connection));
      }
 else       if (code == 408) {
        throw new IOException(describeHttpResponse(connection));
      }
 else       if (code < 500 || code == 501 || code == 502 || code == 505) {
        readAllBytesAndClose(connection.getErrorStream());
        throw new UnrecoverableHttpException(describeHttpResponse(connection));
      }
 else {
        throw new IOException(describeHttpResponse(connection));
      }
    }
 catch (    UnrecoverableHttpException e) {
      throw e;
    }
catch (    IOException e) {
      if (connection != null) {
        connection.disconnect();
      }
      int timeout=IntMath.pow(2,retries) * MIN_RETRY_DELAY_MS;
      if (e instanceof SocketTimeoutException) {
        eventHandler.handle(Event.progress(""String_Node_Str"" + url));
        connectTimeout=Math.min(connectTimeout * 2,MAX_CONNECT_TIMEOUT_MS);
        timeout=1;
      }
 else       if (e instanceof InterruptedIOException) {
        throw e;
      }
      if (++retries == MAX_RETRIES) {
        if (!(e instanceof SocketTimeoutException)) {
          eventHandler.handle(Event.progress(format(""String_Node_Str"",url,e.getMessage())));
        }
        for (        Throwable suppressed : suppressions) {
          e.addSuppressed(suppressed);
        }
        throw e;
      }
      suppressions.add(e);
      eventHandler.handle(Event.progress(format(""String_Node_Str"",url,timeout)));
      url=originalUrl;
      try {
        sleeper.sleepMillis(timeout);
      }
 catch (      InterruptedException translated) {
        throw new InterruptedIOException();
      }
    }
catch (    RuntimeException e) {
      if (connection != null) {
        connection.disconnect();
      }
      eventHandler.handle(Event.progress(format(""String_Node_Str"",url,e)));
      throw e;
    }
  }
}","URLConnection connect(URL originalUrl,ImmutableMap<String,String> requestHeaders) throws IOException {
  if (Thread.interrupted()) {
    throw new InterruptedIOException();
  }
  URL url=originalUrl;
  if (HttpUtils.isProtocol(url,""String_Node_Str"")) {
    return url.openConnection();
  }
  List<Throwable> suppressions=new ArrayList<>();
  int retries=0;
  int redirects=0;
  int connectTimeout=MIN_CONNECT_TIMEOUT_MS;
  while (true) {
    HttpURLConnection connection=null;
    try {
      connection=(HttpURLConnection)url.openConnection(proxyHelper.createProxyIfNeeded(url));
      boolean isAlreadyCompressed=COMPRESSED_EXTENSIONS.contains(HttpUtils.getExtension(url.getPath())) || COMPRESSED_EXTENSIONS.contains(HttpUtils.getExtension(originalUrl.getPath()));
      connection.setInstanceFollowRedirects(false);
      for (      Map.Entry<String,String> entry : requestHeaders.entrySet()) {
        if (isAlreadyCompressed && Ascii.equalsIgnoreCase(entry.getKey(),""String_Node_Str"")) {
          continue;
        }
        connection.setRequestProperty(entry.getKey(),entry.getValue());
      }
      connection.setConnectTimeout(connectTimeout);
      connection.setReadTimeout(READ_TIMEOUT_MS);
      int code;
      try {
        connection.connect();
        code=connection.getResponseCode();
      }
 catch (      FileNotFoundException ignored) {
        code=connection.getResponseCode();
      }
catch (      UnknownHostException e) {
        String message=""String_Node_Str"" + e.getMessage();
        eventHandler.handle(Event.progress(message));
        throw new UnrecoverableHttpException(message);
      }
catch (      IllegalArgumentException e) {
        throw new UnrecoverableHttpException(e.getMessage());
      }
catch (      IOException e) {
        if (e.getMessage() == null || !e.getMessage().startsWith(""String_Node_Str"")) {
          throw e;
        }
        code=connection.getResponseCode();
      }
      if (code == 200 || code == 206) {
        return connection;
      }
 else       if (code == 301 || code == 302 || code == 303 || code == 307) {
        readAllBytesAndClose(connection.getInputStream());
        if (++redirects == MAX_REDIRECTS) {
          eventHandler.handle(Event.progress(""String_Node_Str"" + originalUrl));
          throw new UnrecoverableHttpException(""String_Node_Str"");
        }
        url=HttpUtils.getLocation(connection);
        if (code == 301) {
          originalUrl=url;
        }
      }
 else       if (code == 403) {
        throw new IOException(describeHttpResponse(connection));
      }
 else       if (code == 408) {
        throw new IOException(describeHttpResponse(connection));
      }
 else       if (code < 500 || code == 501 || code == 502 || code == 505) {
        readAllBytesAndClose(connection.getErrorStream());
        throw new UnrecoverableHttpException(describeHttpResponse(connection));
      }
 else {
        throw new IOException(describeHttpResponse(connection));
      }
    }
 catch (    UnrecoverableHttpException e) {
      throw e;
    }
catch (    IOException e) {
      if (connection != null) {
        connection.disconnect();
      }
      int timeout=IntMath.pow(2,retries) * MIN_RETRY_DELAY_MS;
      if (e instanceof SocketTimeoutException) {
        eventHandler.handle(Event.progress(""String_Node_Str"" + url));
        connectTimeout=Math.min(connectTimeout * 2,MAX_CONNECT_TIMEOUT_MS);
        timeout=1;
      }
 else       if (e instanceof InterruptedIOException) {
        throw e;
      }
      if (++retries == MAX_RETRIES) {
        if (!(e instanceof SocketTimeoutException)) {
          eventHandler.handle(Event.progress(format(""String_Node_Str"",url,e.getMessage())));
        }
        for (        Throwable suppressed : suppressions) {
          e.addSuppressed(suppressed);
        }
        throw e;
      }
      suppressions.add(e);
      eventHandler.handle(Event.progress(format(""String_Node_Str"",url,timeout)));
      url=originalUrl;
      try {
        sleeper.sleepMillis(timeout);
      }
 catch (      InterruptedException translated) {
        throw new InterruptedIOException();
      }
    }
catch (    RuntimeException e) {
      if (connection != null) {
        connection.disconnect();
      }
      eventHandler.handle(Event.progress(format(""String_Node_Str"",url,e)));
      throw e;
    }
  }
}",0.9922372842080872
110722,"@Test public void redirectToDifferentPath_works() throws Exception {
  final Map<String,String> headers1=new ConcurrentHashMap<>();
  final Map<String,String> headers2=new ConcurrentHashMap<>();
  try (ServerSocket server=new ServerSocket(0,1,InetAddress.getByName(null))){
    @SuppressWarnings(""String_Node_Str"") Future<?> possiblyIgnoredError=executor.submit(new Callable<Object>(){
      @Override public Object call() throws Exception {
        try (Socket socket=server.accept()){
          readHttpRequest(socket.getInputStream(),headers1);
          sendLines(socket,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        }
         try (Socket socket=server.accept()){
          readHttpRequest(socket.getInputStream(),headers2);
          sendLines(socket,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        }
         return null;
      }
    }
);
    URLConnection connection=connector.connect(new URL(String.format(""String_Node_Str"",server.getLocalPort())),ImmutableMap.<String,String>of());
    assertThat(connection.getURL()).isEqualTo(new URL(String.format(""String_Node_Str"",server.getLocalPort())));
    try (InputStream input=connection.getInputStream()){
      assertThat(ByteStreams.toByteArray(input)).isEmpty();
    }
   }
   assertThat(headers1).containsEntry(""String_Node_Str"",""String_Node_Str"");
  assertThat(headers2).containsEntry(""String_Node_Str"",""String_Node_Str"");
}","public void redirectToDifferentPath_works(String code) throws Exception {
  String redirectCode=""String_Node_Str"" + code + ""String_Node_Str"";
  final Map<String,String> headers1=new ConcurrentHashMap<>();
  final Map<String,String> headers2=new ConcurrentHashMap<>();
  try (ServerSocket server=new ServerSocket(0,1,InetAddress.getByName(null))){
    @SuppressWarnings(""String_Node_Str"") Future<?> possiblyIgnoredError=executor.submit(new Callable<Object>(){
      @Override public Object call() throws Exception {
        try (Socket socket=server.accept()){
          readHttpRequest(socket.getInputStream(),headers1);
          sendLines(socket,redirectCode,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        }
         try (Socket socket=server.accept()){
          readHttpRequest(socket.getInputStream(),headers2);
          sendLines(socket,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        }
         return null;
      }
    }
);
    URLConnection connection=connector.connect(new URL(String.format(""String_Node_Str"",server.getLocalPort())),ImmutableMap.<String,String>of());
    assertThat(connection.getURL()).isEqualTo(new URL(String.format(""String_Node_Str"",server.getLocalPort())));
    try (InputStream input=connection.getInputStream()){
      assertThat(ByteStreams.toByteArray(input)).isEmpty();
    }
   }
   assertThat(headers1).containsEntry(""String_Node_Str"",""String_Node_Str"");
  assertThat(headers2).containsEntry(""String_Node_Str"",""String_Node_Str"");
}",0.9642857142857144
110723,"@Test public void redirectToDifferentServer_works() throws Exception {
  try (ServerSocket server1=new ServerSocket(0,1,InetAddress.getByName(null));ServerSocket server2=new ServerSocket(0,1,InetAddress.getByName(null))){
    @SuppressWarnings(""String_Node_Str"") Future<?> possiblyIgnoredError=executor.submit(new Callable<Object>(){
      @Override public Object call() throws Exception {
        try (Socket socket=server1.accept()){
          readHttpRequest(socket.getInputStream());
          sendLines(socket,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",String.format(""String_Node_Str"",server2.getLocalPort()),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        }
         return null;
      }
    }
);
    @SuppressWarnings(""String_Node_Str"") Future<?> possiblyIgnoredError1=executor.submit(new Callable<Object>(){
      @Override public Object call() throws Exception {
        try (Socket socket=server2.accept()){
          readHttpRequest(socket.getInputStream());
          sendLines(socket,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        }
         return null;
      }
    }
);
    URLConnection connection=connector.connect(new URL(String.format(""String_Node_Str"",server1.getLocalPort())),ImmutableMap.<String,String>of());
    assertThat(connection.getURL()).isEqualTo(new URL(String.format(""String_Node_Str"",server2.getLocalPort())));
    try (InputStream input=connection.getInputStream()){
      assertThat(ByteStreams.toByteArray(input)).isEqualTo(""String_Node_Str"".getBytes(US_ASCII));
    }
   }
 }","public void redirectToDifferentServer_works(String code) throws Exception {
  String redirectCode=""String_Node_Str"" + code + ""String_Node_Str"";
  try (ServerSocket server1=new ServerSocket(0,1,InetAddress.getByName(null));ServerSocket server2=new ServerSocket(0,1,InetAddress.getByName(null))){
    @SuppressWarnings(""String_Node_Str"") Future<?> possiblyIgnoredError=executor.submit(new Callable<Object>(){
      @Override public Object call() throws Exception {
        try (Socket socket=server1.accept()){
          readHttpRequest(socket.getInputStream());
          sendLines(socket,redirectCode,""String_Node_Str"",""String_Node_Str"",String.format(""String_Node_Str"",server2.getLocalPort()),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        }
         return null;
      }
    }
);
    @SuppressWarnings(""String_Node_Str"") Future<?> possiblyIgnoredError1=executor.submit(new Callable<Object>(){
      @Override public Object call() throws Exception {
        try (Socket socket=server2.accept()){
          readHttpRequest(socket.getInputStream());
          sendLines(socket,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        }
         return null;
      }
    }
);
    URLConnection connection=connector.connect(new URL(String.format(""String_Node_Str"",server1.getLocalPort())),ImmutableMap.<String,String>of());
    assertThat(connection.getURL()).isEqualTo(new URL(String.format(""String_Node_Str"",server2.getLocalPort())));
    try (InputStream input=connection.getInputStream()){
      assertThat(ByteStreams.toByteArray(input)).isEqualTo(""String_Node_Str"".getBytes(US_ASCII));
    }
   }
 }",0.9657245941070356
110724,"private Iterable<SkyKey> getSubdirDeps(DirectoryListingValue dirListingValue,RootedPath rootedPath,RepositoryName repositoryName,Set<PathFragment> excludedPaths){
  Path root=rootedPath.getRoot();
  PathFragment rootRelativePath=rootedPath.getRelativePath();
  boolean followSymlinks=shouldFollowSymlinksWhenTraversing(dirListingValue.getDirents());
  List<SkyKey> childDeps=new ArrayList<>();
  for (  Dirent dirent : dirListingValue.getDirents()) {
    Type type=dirent.getType();
    if (type != Type.DIRECTORY && (type != Type.SYMLINK || !followSymlinks)) {
      continue;
    }
    String basename=dirent.getName();
    if (rootRelativePath.equals(PathFragment.EMPTY_FRAGMENT) && PathPackageLocator.DEFAULT_TOP_LEVEL_EXCLUDES.contains(basename)) {
      continue;
    }
    if (basename.equals(Label.EXTERNAL_PACKAGE_NAME.getPathString())) {
      continue;
    }
    PathFragment subdirectory=rootRelativePath.getRelative(basename);
    if (excludedPaths.contains(subdirectory)) {
      continue;
    }
    ImmutableSet<PathFragment> excludedSubdirectoriesBeneathThisSubdirectory=PathFragment.filterPathsStartingWith(excludedPaths,subdirectory);
    RootedPath subdirectoryRootedPath=RootedPath.toRootedPath(root,subdirectory);
    childDeps.add(skyKeyTransformer.makeSkyKey(repositoryName,subdirectoryRootedPath,excludedSubdirectoriesBeneathThisSubdirectory));
  }
  return childDeps;
}","private Iterable<SkyKey> getSubdirDeps(DirectoryListingValue dirListingValue,RootedPath rootedPath,RepositoryName repositoryName,Set<PathFragment> excludedPaths){
  Path root=rootedPath.getRoot();
  PathFragment rootRelativePath=rootedPath.getRelativePath();
  boolean followSymlinks=shouldFollowSymlinksWhenTraversing(dirListingValue.getDirents());
  List<SkyKey> childDeps=new ArrayList<>();
  for (  Dirent dirent : dirListingValue.getDirents()) {
    Type type=dirent.getType();
    if (type != Type.DIRECTORY && (type != Type.SYMLINK || !followSymlinks)) {
      continue;
    }
    String basename=dirent.getName();
    if (rootRelativePath.equals(PathFragment.EMPTY_FRAGMENT) && PathPackageLocator.DEFAULT_TOP_LEVEL_EXCLUDES.contains(basename)) {
      continue;
    }
    PathFragment subdirectory=rootRelativePath.getRelative(basename);
    if (subdirectory.equals(Label.EXTERNAL_PACKAGE_NAME)) {
      continue;
    }
    if (excludedPaths.contains(subdirectory)) {
      continue;
    }
    ImmutableSet<PathFragment> excludedSubdirectoriesBeneathThisSubdirectory=PathFragment.filterPathsStartingWith(excludedPaths,subdirectory);
    RootedPath subdirectoryRootedPath=RootedPath.toRootedPath(root,subdirectory);
    childDeps.add(skyKeyTransformer.makeSkyKey(repositoryName,subdirectoryRootedPath,excludedSubdirectoriesBeneathThisSubdirectory));
  }
  return childDeps;
}",0.6527377521613833
110725,"void upload(Path execRoot,Collection<Path> files,FileOutErr outErr,ActionResult.Builder result) throws IOException, InterruptedException {
  ArrayList<Digest> digests=new ArrayList<>();
  ImmutableSet<Digest> digestsToUpload=getMissingDigests(digests);
  List<Chunker> filesToUpload=new ArrayList<>(digestsToUpload.size());
  for (  Path file : files) {
    if (!file.exists()) {
      continue;
    }
    if (file.isDirectory()) {
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
    Digest digest=Digests.computeDigest(file);
    digests.add(digest);
    if (digestsToUpload.contains(digest)) {
      Chunker chunker=new Chunker(file);
      filesToUpload.add(chunker);
    }
  }
  if (!filesToUpload.isEmpty()) {
    uploader.uploadBlobs(filesToUpload);
  }
  int index=0;
  for (  Path file : files) {
    result.addOutputFilesBuilder().setPath(file.relativeTo(execRoot).getPathString()).setDigest(digests.get(index++)).setIsExecutable(file.isExecutable());
  }
  if (outErr.getErrorPath().exists()) {
    Digest stderr=uploadFileContents(outErr.getErrorPath());
    result.setStderrDigest(stderr);
  }
  if (outErr.getOutputPath().exists()) {
    Digest stdout=uploadFileContents(outErr.getOutputPath());
    result.setStdoutDigest(stdout);
  }
}","void upload(Path execRoot,Collection<Path> files,FileOutErr outErr,ActionResult.Builder result) throws IOException, InterruptedException {
  Map<Digest,Path> digestToFile=new HashMap<>();
  for (  Path file : files) {
    if (!file.exists()) {
      continue;
    }
    if (file.isDirectory()) {
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
    Digest digest=Digests.computeDigest(file);
    result.addOutputFilesBuilder().setPath(file.relativeTo(execRoot).getPathString()).setDigest(digest).setIsExecutable(file.isExecutable());
    digestToFile.put(digest,file);
  }
  ImmutableSet<Digest> digestsToUpload=getMissingDigests(digestToFile.keySet());
  List<Chunker> filesToUpload=new ArrayList<>();
  for (  Digest digest : digestsToUpload) {
    Path file=digestToFile.get(digest);
    if (file == null) {
      String message=""String_Node_Str"" + digest;
      throw new IOException(message);
    }
    filesToUpload.add(new Chunker(file));
  }
  if (!filesToUpload.isEmpty()) {
    uploader.uploadBlobs(filesToUpload);
  }
  if (outErr.getErrorPath().exists()) {
    Digest stderr=uploadFileContents(outErr.getErrorPath());
    result.setStderrDigest(stderr);
  }
  if (outErr.getOutputPath().exists()) {
    Digest stdout=uploadFileContents(outErr.getOutputPath());
    result.setStdoutDigest(stdout);
  }
}",0.2680965147453083
110726,"@Test public void testUploadBlobMultipleChunks() throws Exception {
  final Digest digest=Digests.computeDigestUtf8(""String_Node_Str"");
  serviceRegistry.addService(new ContentAddressableStorageImplBase(){
    @Override public void findMissingBlobs(    FindMissingBlobsRequest request,    StreamObserver<FindMissingBlobsResponse> responseObserver){
      responseObserver.onNext(FindMissingBlobsResponse.newBuilder().addMissingBlobDigests(digest).build());
      responseObserver.onCompleted();
    }
  }
);
  ByteStreamImplBase mockByteStreamImpl=Mockito.mock(ByteStreamImplBase.class);
  serviceRegistry.addService(mockByteStreamImpl);
  for (int chunkSize=1; chunkSize <= 6; ++chunkSize) {
    GrpcRemoteCache client=newClient();
    Chunker.setDefaultChunkSizeForTesting(chunkSize);
    when(mockByteStreamImpl.write(Mockito.<StreamObserver<WriteResponse>>anyObject())).thenAnswer(blobChunkedWriteAnswer(""String_Node_Str"",chunkSize));
    assertThat(client.uploadBlob(""String_Node_Str"".getBytes(UTF_8))).isEqualTo(digest);
  }
}","@Test public void testUploadBlobMultipleChunks() throws Exception {
  final Digest digest=Digests.computeDigestUtf8(""String_Node_Str"");
  serviceRegistry.addService(new ContentAddressableStorageImplBase(){
    @Override public void findMissingBlobs(    FindMissingBlobsRequest request,    StreamObserver<FindMissingBlobsResponse> responseObserver){
      responseObserver.onNext(FindMissingBlobsResponse.newBuilder().addMissingBlobDigests(digest).build());
      responseObserver.onCompleted();
    }
  }
);
  ByteStreamImplBase mockByteStreamImpl=Mockito.mock(ByteStreamImplBase.class);
  serviceRegistry.addService(mockByteStreamImpl);
  for (int chunkSize=1; chunkSize <= 6; ++chunkSize) {
    GrpcRemoteCache client=newClient();
    Chunker.setDefaultChunkSizeForTesting(chunkSize);
    when(mockByteStreamImpl.write(Mockito.<StreamObserver<WriteResponse>>anyObject())).thenAnswer(blobChunkedWriteAnswer(""String_Node_Str"",chunkSize));
    assertThat(client.uploadBlob(""String_Node_Str"".getBytes(UTF_8))).isEqualTo(digest);
  }
  Mockito.verify(mockByteStreamImpl,Mockito.times(6)).write(Mockito.<StreamObserver<WriteResponse>>anyObject());
}",0.9480937069361508
110727,"@Test public void testUploadCacheMissesWithRetries() throws Exception {
  final GrpcRemoteCache client=newClient();
  final Digest fooDigest=fakeFileCache.createScratchInput(ActionInputHelper.fromPath(""String_Node_Str""),""String_Node_Str"");
  final Digest barDigest=fakeFileCache.createScratchInput(ActionInputHelper.fromPath(""String_Node_Str""),""String_Node_Str"");
  final Digest bazDigest=fakeFileCache.createScratchInput(ActionInputHelper.fromPath(""String_Node_Str""),""String_Node_Str"");
  final Path fooFile=execRoot.getRelative(""String_Node_Str"");
  final Path barFile=execRoot.getRelative(""String_Node_Str"");
  final Path bazFile=execRoot.getRelative(""String_Node_Str"");
  ActionKey actionKey=Digests.unsafeActionKeyFromDigest(fooDigest);
  barFile.setExecutable(true);
  serviceRegistry.addService(new ContentAddressableStorageImplBase(){
    private int numErrors=4;
    @Override public void findMissingBlobs(    FindMissingBlobsRequest request,    StreamObserver<FindMissingBlobsResponse> responseObserver){
      if (numErrors-- <= 0) {
        responseObserver.onNext(FindMissingBlobsResponse.getDefaultInstance());
        responseObserver.onCompleted();
      }
 else {
        responseObserver.onError(Status.UNAVAILABLE.asRuntimeException());
      }
    }
  }
);
  ActionResult.Builder rb=ActionResult.newBuilder();
  rb.addOutputFilesBuilder().setPath(""String_Node_Str"").setDigest(fooDigest);
  rb.addOutputFilesBuilder().setPath(""String_Node_Str"").setDigest(barDigest).setIsExecutable(true);
  rb.addOutputFilesBuilder().setPath(""String_Node_Str"").setDigest(bazDigest);
  ActionResult result=rb.build();
  serviceRegistry.addService(new ActionCacheImplBase(){
    private int numErrors=4;
    @Override public void updateActionResult(    UpdateActionResultRequest request,    StreamObserver<ActionResult> responseObserver){
      assertThat(request).isEqualTo(UpdateActionResultRequest.newBuilder().setActionDigest(fooDigest).setActionResult(result).build());
      if (numErrors-- <= 0) {
        responseObserver.onNext(result);
        responseObserver.onCompleted();
      }
 else {
        responseObserver.onError(Status.UNAVAILABLE.asRuntimeException());
      }
    }
  }
);
  ByteStreamImplBase mockByteStreamImpl=Mockito.mock(ByteStreamImplBase.class);
  serviceRegistry.addService(mockByteStreamImpl);
  when(mockByteStreamImpl.write(Mockito.<StreamObserver<WriteResponse>>anyObject())).thenAnswer(blobChunkedWriteAnswerError()).thenAnswer(blobChunkedWriteAnswer(""String_Node_Str"",1)).thenAnswer(blobChunkedWriteAnswerError()).thenAnswer(blobChunkedWriteAnswer(""String_Node_Str"",3)).thenAnswer(blobChunkedWriteAnswerError()).thenAnswer(blobChunkedWriteAnswer(""String_Node_Str"",1));
  client.upload(actionKey,execRoot,ImmutableList.<Path>of(fooFile,barFile,bazFile),outErr);
}","@Test public void testUploadCacheMissesWithRetries() throws Exception {
  final GrpcRemoteCache client=newClient();
  final Digest fooDigest=fakeFileCache.createScratchInput(ActionInputHelper.fromPath(""String_Node_Str""),""String_Node_Str"");
  final Digest barDigest=fakeFileCache.createScratchInput(ActionInputHelper.fromPath(""String_Node_Str""),""String_Node_Str"");
  final Digest bazDigest=fakeFileCache.createScratchInput(ActionInputHelper.fromPath(""String_Node_Str""),""String_Node_Str"");
  final Path fooFile=execRoot.getRelative(""String_Node_Str"");
  final Path barFile=execRoot.getRelative(""String_Node_Str"");
  final Path bazFile=execRoot.getRelative(""String_Node_Str"");
  ActionKey actionKey=Digests.unsafeActionKeyFromDigest(fooDigest);
  barFile.setExecutable(true);
  serviceRegistry.addService(new ContentAddressableStorageImplBase(){
    private int numErrors=4;
    @Override public void findMissingBlobs(    FindMissingBlobsRequest request,    StreamObserver<FindMissingBlobsResponse> responseObserver){
      if (numErrors-- <= 0) {
        responseObserver.onNext(FindMissingBlobsResponse.newBuilder().addMissingBlobDigests(fooDigest).addMissingBlobDigests(barDigest).addMissingBlobDigests(bazDigest).build());
        responseObserver.onCompleted();
      }
 else {
        responseObserver.onError(Status.UNAVAILABLE.asRuntimeException());
      }
    }
  }
);
  ActionResult.Builder rb=ActionResult.newBuilder();
  rb.addOutputFilesBuilder().setPath(""String_Node_Str"").setDigest(fooDigest);
  rb.addOutputFilesBuilder().setPath(""String_Node_Str"").setDigest(barDigest).setIsExecutable(true);
  rb.addOutputFilesBuilder().setPath(""String_Node_Str"").setDigest(bazDigest);
  ActionResult result=rb.build();
  serviceRegistry.addService(new ActionCacheImplBase(){
    private int numErrors=4;
    @Override public void updateActionResult(    UpdateActionResultRequest request,    StreamObserver<ActionResult> responseObserver){
      assertThat(request).isEqualTo(UpdateActionResultRequest.newBuilder().setActionDigest(fooDigest).setActionResult(result).build());
      if (numErrors-- <= 0) {
        responseObserver.onNext(result);
        responseObserver.onCompleted();
      }
 else {
        responseObserver.onError(Status.UNAVAILABLE.asRuntimeException());
      }
    }
  }
);
  ByteStreamImplBase mockByteStreamImpl=Mockito.mock(ByteStreamImplBase.class);
  serviceRegistry.addService(mockByteStreamImpl);
  when(mockByteStreamImpl.write(Mockito.<StreamObserver<WriteResponse>>anyObject())).thenAnswer(new Answer<StreamObserver<WriteRequest>>(){
    private int numErrors=4;
    @Override @SuppressWarnings(""String_Node_Str"") public StreamObserver<WriteRequest> answer(    InvocationOnMock invocation){
      StreamObserver<WriteResponse> responseObserver=(StreamObserver<WriteResponse>)invocation.getArguments()[0];
      return new StreamObserver<WriteRequest>(){
        @Override public void onNext(        WriteRequest request){
          numErrors--;
          if (numErrors >= 0) {
            responseObserver.onError(Status.UNAVAILABLE.asRuntimeException());
            return;
          }
          assertThat(request.getFinishWrite()).isTrue();
          String resourceName=request.getResourceName();
          String dataStr=request.getData().toStringUtf8();
          int size=0;
          if (resourceName.contains(fooDigest.getHash())) {
            assertThat(dataStr).isEqualTo(""String_Node_Str"");
            size=3;
          }
 else           if (resourceName.contains(barDigest.getHash())) {
            assertThat(dataStr).isEqualTo(""String_Node_Str"");
            size=1;
          }
 else           if (resourceName.contains(bazDigest.getHash())) {
            assertThat(dataStr).isEqualTo(""String_Node_Str"");
            size=1;
          }
 else {
            fail(""String_Node_Str"" + resourceName);
          }
          responseObserver.onNext(WriteResponse.newBuilder().setCommittedSize(size).build());
        }
        @Override public void onCompleted(){
          responseObserver.onCompleted();
        }
        @Override public void onError(        Throwable t){
          fail(""String_Node_Str"" + t);
        }
      }
;
    }
  }
);
  client.upload(actionKey,execRoot,ImmutableList.<Path>of(fooFile,barFile,bazFile),outErr);
  Mockito.verify(mockByteStreamImpl,Mockito.times(7)).write(Mockito.<StreamObserver<WriteResponse>>anyObject());
}",0.7171016102165464
110728,"@Override public void onCompleted(){
}","@Override public void onCompleted(){
  responseObserver.onCompleted();
}",0.6909090909090909
110729,"@Override public void onNext(WriteRequest request){
  ((StreamObserver<WriteResponse>)invocation.getArguments()[0]).onError(Status.UNAVAILABLE.asRuntimeException());
}","@Override public void onNext(WriteRequest request){
  numErrors--;
  if (numErrors >= 0) {
    responseObserver.onError(Status.UNAVAILABLE.asRuntimeException());
    return;
  }
  assertThat(request.getFinishWrite()).isTrue();
  String resourceName=request.getResourceName();
  String dataStr=request.getData().toStringUtf8();
  int size=0;
  if (resourceName.contains(fooDigest.getHash())) {
    assertThat(dataStr).isEqualTo(""String_Node_Str"");
    size=3;
  }
 else   if (resourceName.contains(barDigest.getHash())) {
    assertThat(dataStr).isEqualTo(""String_Node_Str"");
    size=1;
  }
 else   if (resourceName.contains(bazDigest.getHash())) {
    assertThat(dataStr).isEqualTo(""String_Node_Str"");
    size=1;
  }
 else {
    fail(""String_Node_Str"" + resourceName);
  }
  responseObserver.onNext(WriteResponse.newBuilder().setCommittedSize(size).build());
}",0.2215743440233236
110730,"@Test public void testUploadCacheHits() throws Exception {
  final GrpcRemoteCache client=newClient();
  final Digest fooDigest=fakeFileCache.createScratchInput(ActionInputHelper.fromPath(""String_Node_Str""),""String_Node_Str"");
  final Digest barDigest=fakeFileCache.createScratchInput(ActionInputHelper.fromPath(""String_Node_Str""),""String_Node_Str"");
  final Path fooFile=execRoot.getRelative(""String_Node_Str"");
  final Path barFile=execRoot.getRelative(""String_Node_Str"");
  barFile.setExecutable(true);
  serviceRegistry.addService(new ContentAddressableStorageImplBase(){
    @Override public void findMissingBlobs(    FindMissingBlobsRequest request,    StreamObserver<FindMissingBlobsResponse> responseObserver){
      assertThat(request).isEqualTo(FindMissingBlobsRequest.newBuilder().addBlobDigests(fooDigest).addBlobDigests(barDigest).build());
      responseObserver.onNext(FindMissingBlobsResponse.getDefaultInstance());
      responseObserver.onCompleted();
    }
  }
);
  ActionResult.Builder result=ActionResult.newBuilder();
  client.upload(execRoot,ImmutableList.<Path>of(fooFile,barFile),outErr,result);
  ActionResult.Builder expectedResult=ActionResult.newBuilder();
  expectedResult.addOutputFilesBuilder().setPath(""String_Node_Str"").setDigest(fooDigest);
  expectedResult.addOutputFilesBuilder().setPath(""String_Node_Str"").setDigest(barDigest).setIsExecutable(true);
  assertThat(result.build()).isEqualTo(expectedResult.build());
}","@Test public void testUploadCacheHits() throws Exception {
  final GrpcRemoteCache client=newClient();
  final Digest fooDigest=fakeFileCache.createScratchInput(ActionInputHelper.fromPath(""String_Node_Str""),""String_Node_Str"");
  final Digest barDigest=fakeFileCache.createScratchInput(ActionInputHelper.fromPath(""String_Node_Str""),""String_Node_Str"");
  final Path fooFile=execRoot.getRelative(""String_Node_Str"");
  final Path barFile=execRoot.getRelative(""String_Node_Str"");
  barFile.setExecutable(true);
  serviceRegistry.addService(new ContentAddressableStorageImplBase(){
    @Override public void findMissingBlobs(    FindMissingBlobsRequest request,    StreamObserver<FindMissingBlobsResponse> responseObserver){
      assertThat(request.getBlobDigestsList()).containsExactly(fooDigest,barDigest);
      responseObserver.onNext(FindMissingBlobsResponse.getDefaultInstance());
      responseObserver.onCompleted();
    }
  }
);
  ActionResult.Builder result=ActionResult.newBuilder();
  client.upload(execRoot,ImmutableList.<Path>of(fooFile,barFile),outErr,result);
  ActionResult.Builder expectedResult=ActionResult.newBuilder();
  expectedResult.addOutputFilesBuilder().setPath(""String_Node_Str"").setDigest(fooDigest);
  expectedResult.addOutputFilesBuilder().setPath(""String_Node_Str"").setDigest(barDigest).setIsExecutable(true);
  assertThat(result.build()).isEqualTo(expectedResult.build());
}",0.9516806722689076
110731,"@Override @SuppressWarnings(""String_Node_Str"") public StreamObserver<WriteRequest> answer(final InvocationOnMock invocation){
  return new StreamObserver<WriteRequest>(){
    @Override public void onNext(    WriteRequest request){
      ((StreamObserver<WriteResponse>)invocation.getArguments()[0]).onError(Status.UNAVAILABLE.asRuntimeException());
    }
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable t){
      fail(""String_Node_Str"" + t);
    }
  }
;
}","@Override @SuppressWarnings(""String_Node_Str"") public StreamObserver<WriteRequest> answer(InvocationOnMock invocation){
  StreamObserver<WriteResponse> responseObserver=(StreamObserver<WriteResponse>)invocation.getArguments()[0];
  return new StreamObserver<WriteRequest>(){
    @Override public void onNext(    WriteRequest request){
      numErrors--;
      if (numErrors >= 0) {
        responseObserver.onError(Status.UNAVAILABLE.asRuntimeException());
        return;
      }
      assertThat(request.getFinishWrite()).isTrue();
      String resourceName=request.getResourceName();
      String dataStr=request.getData().toStringUtf8();
      int size=0;
      if (resourceName.contains(fooDigest.getHash())) {
        assertThat(dataStr).isEqualTo(""String_Node_Str"");
        size=3;
      }
 else       if (resourceName.contains(barDigest.getHash())) {
        assertThat(dataStr).isEqualTo(""String_Node_Str"");
        size=1;
      }
 else       if (resourceName.contains(bazDigest.getHash())) {
        assertThat(dataStr).isEqualTo(""String_Node_Str"");
        size=1;
      }
 else {
        fail(""String_Node_Str"" + resourceName);
      }
      responseObserver.onNext(WriteResponse.newBuilder().setCommittedSize(size).build());
    }
    @Override public void onCompleted(){
      responseObserver.onCompleted();
    }
    @Override public void onError(    Throwable t){
      fail(""String_Node_Str"" + t);
    }
  }
;
}",0.4231764097258148
110732,"@Override public void findMissingBlobs(FindMissingBlobsRequest request,StreamObserver<FindMissingBlobsResponse> responseObserver){
  if (numErrors-- <= 0) {
    responseObserver.onNext(FindMissingBlobsResponse.getDefaultInstance());
    responseObserver.onCompleted();
  }
 else {
    responseObserver.onError(Status.UNAVAILABLE.asRuntimeException());
  }
}","@Override public void findMissingBlobs(FindMissingBlobsRequest request,StreamObserver<FindMissingBlobsResponse> responseObserver){
  if (numErrors-- <= 0) {
    responseObserver.onNext(FindMissingBlobsResponse.newBuilder().addMissingBlobDigests(fooDigest).addMissingBlobDigests(barDigest).addMissingBlobDigests(bazDigest).build());
    responseObserver.onCompleted();
  }
 else {
    responseObserver.onError(Status.UNAVAILABLE.asRuntimeException());
  }
}",0.8364083640836408
110733,"boolean isValidWith(SourceChecker checker) throws IOException {
  return !primary.equals(overwritten) && !checker.checkEquality(primary.source(),overwritten.source());
}","boolean isValidWith(SourceChecker checker) throws IOException {
  return !primary.valueEquals(overwritten) && !checker.checkEquality(primary.source(),overwritten.source());
}",0.9854227405247812
110734,"@Test public void writeResourceXmlWithAttributes() throws Exception {
  Path target=fs.getPath(""String_Node_Str"");
  Path source=fs.getPath(""String_Node_Str"");
  AndroidDataWriter mergedDataWriter=AndroidDataWriter.createWithDefaults(target);
  ParsedAndroidData direct=AndroidDataBuilder.of(source).addValuesWithAttributes(""String_Node_Str"",ImmutableMap.of(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str"").addValuesWithAttributes(""String_Node_Str"",ImmutableMap.of(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").createManifest(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").buildParsed();
  MergedAndroidData actual=UnwrittenMergedAndroidData.of(source.resolve(""String_Node_Str""),direct,ParsedAndroidDataBuilder.empty()).write(mergedDataWriter);
  assertAbout(paths).that(actual.getManifest()).exists();
  assertAbout(paths).that(actual.getResourceDir().resolve(""String_Node_Str"")).exists();
  assertAbout(paths).that(actual.getResourceDir().resolve(""String_Node_Str"")).xmlContentsIsEqualTo(START_RESOURCES + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",END_RESOURCES);
}","@Test public void writeResourceXmlWithAttributes() throws Exception {
  Path target=fs.getPath(""String_Node_Str"");
  Path source=fs.getPath(""String_Node_Str"");
  AndroidDataWriter mergedDataWriter=AndroidDataWriter.createWithDefaults(target);
  ParsedAndroidData direct=AndroidDataBuilder.of(source).addValuesWithAttributes(""String_Node_Str"",ImmutableMap.of(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str"").addValuesWithAttributes(""String_Node_Str"",ImmutableMap.of(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").createManifest(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").buildParsed();
  MergedAndroidData actual=UnwrittenMergedAndroidData.of(source.resolve(""String_Node_Str""),direct,ParsedAndroidDataBuilder.empty()).write(mergedDataWriter);
  assertAbout(paths).that(actual.getManifest()).exists();
  assertAbout(paths).that(actual.getResourceDir().resolve(""String_Node_Str"")).exists();
  assertAbout(paths).that(actual.getResourceDir().resolve(""String_Node_Str"")).xmlContentsIsEqualTo(START_RESOURCES + ""String_Node_Str"",""String_Node_Str"" + fs.getPath(""String_Node_Str"") + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + fs.getPath(""String_Node_Str"") + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",END_RESOURCES);
}",0.9438291139240508
110735,"@Test public void writeResourceXmlWithQualfiers() throws Exception {
  Path target=fs.getPath(""String_Node_Str"");
  Path source=fs.getPath(""String_Node_Str"");
  AndroidDataWriter mergedDataWriter=AndroidDataWriter.createWithDefaults(target);
  ParsedAndroidData direct=AndroidDataBuilder.of(source).addResource(""String_Node_Str"",AndroidDataBuilder.ResourceType.VALUE,""String_Node_Str"").addResource(""String_Node_Str"",AndroidDataBuilder.ResourceType.VALUE,""String_Node_Str"").createManifest(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").buildParsed();
  MergedAndroidData actual=UnwrittenMergedAndroidData.of(source.resolve(""String_Node_Str""),direct,ParsedAndroidDataBuilder.empty()).write(mergedDataWriter);
  assertAbout(paths).that(actual.getManifest()).exists();
  assertAbout(paths).that(actual.getResourceDir().resolve(""String_Node_Str"")).exists();
  assertAbout(paths).that(actual.getResourceDir().resolve(""String_Node_Str"")).xmlContentsIsEqualTo(START_RESOURCES + ""String_Node_Str"",""String_Node_Str"",END_RESOURCES);
  assertAbout(paths).that(actual.getResourceDir().resolve(""String_Node_Str"")).exists();
  assertAbout(paths).that(actual.getResourceDir().resolve(""String_Node_Str"")).xmlContentsIsEqualTo(START_RESOURCES + ""String_Node_Str"",""String_Node_Str"",END_RESOURCES);
}","@Test public void writeResourceXmlWithQualfiers() throws Exception {
  Path target=fs.getPath(""String_Node_Str"");
  Path source=fs.getPath(""String_Node_Str"");
  AndroidDataWriter mergedDataWriter=AndroidDataWriter.createWithDefaults(target);
  ParsedAndroidData direct=AndroidDataBuilder.of(source).addResource(""String_Node_Str"",AndroidDataBuilder.ResourceType.VALUE,""String_Node_Str"").addResource(""String_Node_Str"",AndroidDataBuilder.ResourceType.VALUE,""String_Node_Str"").createManifest(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").buildParsed();
  MergedAndroidData actual=UnwrittenMergedAndroidData.of(source.resolve(""String_Node_Str""),direct,ParsedAndroidDataBuilder.empty()).write(mergedDataWriter);
  assertAbout(paths).that(actual.getManifest()).exists();
  assertAbout(paths).that(actual.getResourceDir().resolve(""String_Node_Str"")).exists();
  assertAbout(paths).that(actual.getResourceDir().resolve(""String_Node_Str"")).xmlContentsIsEqualTo(START_RESOURCES + ""String_Node_Str"",""String_Node_Str"" + fs.getPath(""String_Node_Str"") + ""String_Node_Str"",END_RESOURCES);
  assertAbout(paths).that(actual.getResourceDir().resolve(""String_Node_Str"")).exists();
  assertAbout(paths).that(actual.getResourceDir().resolve(""String_Node_Str"")).xmlContentsIsEqualTo(START_RESOURCES + ""String_Node_Str"",""String_Node_Str"" + fs.getPath(""String_Node_Str"") + ""String_Node_Str"",END_RESOURCES);
}",0.9611940298507464
110736,"@Test public void writeResourceXml() throws Exception {
  Path target=fs.getPath(""String_Node_Str"");
  Path source=fs.getPath(""String_Node_Str"");
  AndroidDataWriter mergedDataWriter=AndroidDataWriter.createWithDefaults(target);
  ParsedAndroidData direct=AndroidDataBuilder.of(source).addResource(""String_Node_Str"",AndroidDataBuilder.ResourceType.VALUE,""String_Node_Str"",""String_Node_Str"").addResource(""String_Node_Str"",AndroidDataBuilder.ResourceType.VALUE,""String_Node_Str"").createManifest(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").buildParsed();
  MergedAndroidData actual=UnwrittenMergedAndroidData.of(source.resolve(""String_Node_Str""),direct,ParsedAndroidDataBuilder.empty()).write(mergedDataWriter);
  assertAbout(paths).that(actual.getManifest()).exists();
  assertAbout(paths).that(actual.getResourceDir().resolve(""String_Node_Str"")).exists();
  assertAbout(paths).that(actual.getResourceDir().resolve(""String_Node_Str"")).xmlContentsIsEqualTo(START_RESOURCES + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",END_RESOURCES);
}","@Test public void writeResourceXml() throws Exception {
  Path target=fs.getPath(""String_Node_Str"");
  Path source=fs.getPath(""String_Node_Str"");
  AndroidDataWriter mergedDataWriter=AndroidDataWriter.createWithDefaults(target);
  ParsedAndroidData direct=AndroidDataBuilder.of(source).addResource(""String_Node_Str"",AndroidDataBuilder.ResourceType.VALUE,""String_Node_Str"",""String_Node_Str"").addResource(""String_Node_Str"",AndroidDataBuilder.ResourceType.VALUE,""String_Node_Str"").createManifest(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").buildParsed();
  MergedAndroidData actual=UnwrittenMergedAndroidData.of(source.resolve(""String_Node_Str""),direct,ParsedAndroidDataBuilder.empty()).write(mergedDataWriter);
  assertAbout(paths).that(actual.getManifest()).exists();
  assertAbout(paths).that(actual.getResourceDir().resolve(""String_Node_Str"")).exists();
  assertAbout(paths).that(actual.getResourceDir().resolve(""String_Node_Str"")).xmlContentsIsEqualTo(START_RESOURCES + ""String_Node_Str"",""String_Node_Str"" + fs.getPath(""String_Node_Str"") + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + fs.getPath(""String_Node_Str"") + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",END_RESOURCES);
}",0.9387931034482758
110737,"@Test public void writeWithIDDuplicates() throws Exception {
  Path target=fs.getPath(""String_Node_Str"");
  Path source=fs.getPath(""String_Node_Str"");
  AndroidDataWriter mergedDataWriter=AndroidDataWriter.createWithDefaults(target);
  ParsedAndroidData direct=AndroidDataBuilder.of(source).addResource(""String_Node_Str"",AndroidDataBuilder.ResourceType.LAYOUT,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").addResource(""String_Node_Str"",AndroidDataBuilder.ResourceType.LAYOUT,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").addResource(""String_Node_Str"",AndroidDataBuilder.ResourceType.VALUE,""String_Node_Str"",""String_Node_Str"").addResource(""String_Node_Str"",AndroidDataBuilder.ResourceType.VALUE,""String_Node_Str"").createManifest(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").buildParsed();
  MergedAndroidData actual=UnwrittenMergedAndroidData.of(source.resolve(""String_Node_Str""),direct,ParsedAndroidDataBuilder.empty()).write(mergedDataWriter);
  assertAbout(paths).that(actual.getManifest()).exists();
  assertAbout(paths).that(actual.getResourceDir().resolve(""String_Node_Str"")).exists();
  assertAbout(paths).that(actual.getResourceDir().resolve(""String_Node_Str"")).exists();
  assertAbout(paths).that(actual.getResourceDir().resolve(""String_Node_Str"")).xmlContentsIsEqualTo(START_RESOURCES + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",END_RESOURCES);
}","@Test public void writeWithIDDuplicates() throws Exception {
  Path target=fs.getPath(""String_Node_Str"");
  Path source=fs.getPath(""String_Node_Str"");
  AndroidDataWriter mergedDataWriter=AndroidDataWriter.createWithDefaults(target);
  ParsedAndroidData direct=AndroidDataBuilder.of(source).addResource(""String_Node_Str"",AndroidDataBuilder.ResourceType.LAYOUT,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").addResource(""String_Node_Str"",AndroidDataBuilder.ResourceType.LAYOUT,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").addResource(""String_Node_Str"",AndroidDataBuilder.ResourceType.VALUE,""String_Node_Str"",""String_Node_Str"").addResource(""String_Node_Str"",AndroidDataBuilder.ResourceType.VALUE,""String_Node_Str"").createManifest(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").buildParsed();
  MergedAndroidData actual=UnwrittenMergedAndroidData.of(source.resolve(""String_Node_Str""),direct,ParsedAndroidDataBuilder.empty()).write(mergedDataWriter);
  assertAbout(paths).that(actual.getManifest()).exists();
  assertAbout(paths).that(actual.getResourceDir().resolve(""String_Node_Str"")).exists();
  assertAbout(paths).that(actual.getResourceDir().resolve(""String_Node_Str"")).exists();
  assertAbout(paths).that(actual.getResourceDir().resolve(""String_Node_Str"")).xmlContentsIsEqualTo(START_RESOURCES + ""String_Node_Str"",""String_Node_Str"" + fs.getPath(""String_Node_Str"") + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + fs.getPath(""String_Node_Str"") + ""String_Node_Str"",""String_Node_Str"",END_RESOURCES);
}",0.9458966565349544
110738,"@Test public void writePublicResourceSameNameDifferentType() throws Exception {
  Path target=fs.getPath(""String_Node_Str"");
  Path source=fs.getPath(""String_Node_Str"");
  AndroidDataWriter mergedDataWriter=AndroidDataWriter.createWithDefaults(target);
  ParsedAndroidData direct=AndroidDataBuilder.of(source).addResource(""String_Node_Str"",AndroidDataBuilder.ResourceType.VALUE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").addResource(""String_Node_Str"",AndroidDataBuilder.ResourceType.VALUE,""String_Node_Str"",""String_Node_Str"").createManifest(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").buildParsed();
  MergedAndroidData actual=UnwrittenMergedAndroidData.of(source.resolve(""String_Node_Str""),direct,ParsedAndroidDataBuilder.empty()).write(mergedDataWriter);
  assertAbout(paths).that(actual.getManifest()).exists();
  assertAbout(paths).that(actual.getResourceDir().resolve(""String_Node_Str"")).exists();
  assertAbout(paths).that(actual.getResourceDir().resolve(""String_Node_Str"")).xmlContentsIsEqualTo(START_RESOURCES + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",END_RESOURCES);
}","@Test public void writePublicResourceSameNameDifferentType() throws Exception {
  Path target=fs.getPath(""String_Node_Str"");
  Path source=fs.getPath(""String_Node_Str"");
  AndroidDataWriter mergedDataWriter=AndroidDataWriter.createWithDefaults(target);
  ParsedAndroidData direct=AndroidDataBuilder.of(source).addResource(""String_Node_Str"",AndroidDataBuilder.ResourceType.VALUE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").addResource(""String_Node_Str"",AndroidDataBuilder.ResourceType.VALUE,""String_Node_Str"",""String_Node_Str"").createManifest(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").buildParsed();
  MergedAndroidData actual=UnwrittenMergedAndroidData.of(source.resolve(""String_Node_Str""),direct,ParsedAndroidDataBuilder.empty()).write(mergedDataWriter);
  assertAbout(paths).that(actual.getManifest()).exists();
  assertAbout(paths).that(actual.getResourceDir().resolve(""String_Node_Str"")).exists();
  assertAbout(paths).that(actual.getResourceDir().resolve(""String_Node_Str"")).xmlContentsIsEqualTo(START_RESOURCES + ""String_Node_Str"",""String_Node_Str"" + fs.getPath(""String_Node_Str"") + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + fs.getPath(""String_Node_Str"") + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + fs.getPath(""String_Node_Str"") + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",END_RESOURCES);
}",0.8869760479041916
110739,"@Override public FileVisitResult visitFile(Path file,BasicFileAttributes attrs) throws IOException {
  Files.delete(file);
  return FileVisitResult.CONTINUE;
}","@Override public FileVisitResult visitFile(Path file,BasicFileAttributes attrs) throws IOException {
  DosFileAttributeView dosAttribs=Files.getFileAttributeView(path,DosFileAttributeView.class);
  if (dosAttribs != null) {
    dosAttribs.setReadOnly(false);
  }
  Files.delete(file);
  return FileVisitResult.CONTINUE;
}",0.6625
110740,"Digest uploadBlob(byte[] blob) throws IOException, InterruptedException {
  Digest digest=Digests.computeDigest(blob);
  ImmutableSet<Digest> missing=getMissingDigests(ImmutableList.of(digest));
  try {
    if (!missing.isEmpty()) {
      uploadChunks(1,new Chunker.Builder().addInput(blob));
    }
    return digest;
  }
 catch (  IOException e) {
    throw new RuntimeException();
  }
}","Digest uploadBlob(byte[] blob) throws IOException, InterruptedException {
  Digest digest=Digests.computeDigest(blob);
  ImmutableSet<Digest> missing=getMissingDigests(ImmutableList.of(digest));
  if (!missing.isEmpty()) {
    uploadChunks(1,new Chunker.Builder().addInput(blob));
  }
  return digest;
}",0.8133140376266281
110741,"/** 
 * Called when the server becomes idle. Should not block, but may invoke new threads.
 */
public void idle(){
  Preconditions.checkState(!executor.isShutdown());
  @SuppressWarnings(""String_Node_Str"") Future<?> possiblyIgnoredError=executor.schedule(() -> {
    try (AutoProfiler p=AutoProfiler.logged(""String_Node_Str"",LOG)){
      System.gc();
    }
   }
,10,TimeUnit.SECONDS);
}","/** 
 * Called when the server becomes idle. Should not block, but may invoke new threads.
 */
public void idle(){
  Preconditions.checkState(!executor.isShutdown());
  @SuppressWarnings(""String_Node_Str"") Future<?> possiblyIgnoredError=executor.schedule(() -> {
    try (AutoProfiler p=AutoProfiler.logged(""String_Node_Str"",log)){
      System.gc();
    }
   }
,10,TimeUnit.SECONDS);
}",0.9922279792746114
110742,"private boolean memoryHeuristic(long idleMillis){
  if (idleMillis < FIVE_MIN_MILLIS) {
    return true;
  }
  ProcMeminfoParser memInfo=null;
  try {
    memInfo=new ProcMeminfoParser();
  }
 catch (  IOException e) {
    LOG.info(""String_Node_Str"" + e);
    return true;
  }
  long totalPhysical, totalFree;
  try {
    totalPhysical=memInfo.getTotalKb();
    totalFree=memInfo.getFreeRamKb();
  }
 catch (  IllegalArgumentException e) {
    LoggingUtil.logToRemote(Level.WARNING,""String_Node_Str"",e);
    return true;
  }
  double fractionFree=(double)totalFree / totalPhysical;
  if (fractionFree < .1) {
    LOG.info(""String_Node_Str"");
    LOG.info(String.format(""String_Node_Str"",totalPhysical,totalFree));
    return false;
  }
  return true;
}","private boolean memoryHeuristic(long idleMillis){
  if (idleMillis < FIVE_MIN_MILLIS) {
    return true;
  }
  ProcMeminfoParser memInfo=null;
  try {
    memInfo=new ProcMeminfoParser();
  }
 catch (  IOException e) {
    log.info(""String_Node_Str"" + e);
    return true;
  }
  long totalPhysical;
  long totalFree;
  try {
    totalPhysical=memInfo.getTotalKb();
    totalFree=memInfo.getFreeRamKb();
  }
 catch (  IllegalArgumentException e) {
    LoggingUtil.logToRemote(Level.WARNING,""String_Node_Str"",e);
    return true;
  }
  double fractionFree=(double)totalFree / totalPhysical;
  if (fractionFree < .1) {
    log.info(""String_Node_Str"");
    log.info(String.format(""String_Node_Str"",totalPhysical,totalFree));
    return false;
  }
  return true;
}",0.9821310390469888
110743,"@Override void doExec(Environment env) throws EvalException, InterruptedException {
  if (env.getSemantics().incompatibleLoadArgumentIsLabel) {
    String s=imp.getValue();
    if (!s.startsWith(""String_Node_Str"") && !s.startsWith(""String_Node_Str"")) {
      throw new EvalException(getLocation(),""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  for (  Map.Entry<Identifier,String> entry : symbolMap.entrySet()) {
    try {
      Identifier name=entry.getKey();
      Identifier declared=new Identifier(entry.getValue());
      if (declared.isPrivate()) {
        throw new EvalException(getLocation(),""String_Node_Str"" + declared.getName() + ""String_Node_Str"");
      }
      env.importSymbol(imp.getValue(),name,declared.getName());
    }
 catch (    Environment.LoadFailedException e) {
      throw new EvalException(getLocation(),e.getMessage());
    }
  }
}","@Override void doExec(Environment env) throws EvalException, InterruptedException {
  if (env.getSemantics().incompatibleLoadArgumentIsLabel) {
    String s=imp.getValue();
    if (!s.startsWith(""String_Node_Str"") && !s.startsWith(""String_Node_Str"")) {
      throw new EvalException(getLocation(),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  for (  Map.Entry<Identifier,String> entry : symbolMap.entrySet()) {
    try {
      Identifier name=entry.getKey();
      Identifier declared=new Identifier(entry.getValue());
      if (declared.isPrivate()) {
        throw new EvalException(getLocation(),""String_Node_Str"" + declared.getName() + ""String_Node_Str"");
      }
      env.importSymbol(imp.getValue(),name,declared.getName());
    }
 catch (    Environment.LoadFailedException e) {
      throw new EvalException(getLocation(),e.getMessage());
    }
  }
}",0.9885714285714284
110744,"/** 
 * Uses a rule name to fetch the corresponding Rule from the external package. 
 */
@Nullable public static List<Rule> getRuleByRuleClass(final String ruleClassName,Environment env) throws ExternalPackageException, InterruptedException {
  Set<Rule> rules=getRules(env,false,new Function<Package,Iterable<Rule>>(){
    @Nullable @Override public Iterable<Rule> apply(    Package externalPackage){
      return externalPackage.getRulesMatchingRuleClass(ruleClassName);
    }
  }
);
  if (env.valuesMissing()) {
    return null;
  }
  return ImmutableList.copyOf(rules);
}","/** 
 * Uses a rule name to fetch the corresponding Rule from the external package. 
 */
@Nullable public static List<Rule> getRuleByRuleClass(final String ruleClassName,Environment env) throws ExternalPackageException, InterruptedException {
  List<Rule> rules=getRules(env,false,new Function<Package,Iterable<Rule>>(){
    @Nullable @Override public Iterable<Rule> apply(    Package externalPackage){
      return externalPackage.getRulesMatchingRuleClass(ruleClassName);
    }
  }
);
  if (env.valuesMissing()) {
    return null;
  }
  return ImmutableList.copyOf(rules);
}",0.9956559513466552
110745,"/** 
 * Uses a rule name to fetch the corresponding Rule from the external package. 
 */
@Nullable public static Rule getRuleByName(final String ruleName,Environment env) throws ExternalPackageException, InterruptedException {
  Set<Rule> rules=getRules(env,true,new Function<Package,Iterable<Rule>>(){
    @Nullable @Override public Iterable<Rule> apply(    Package externalPackage){
      Rule rule=externalPackage.getRule(ruleName);
      if (rule == null) {
        return null;
      }
      return ImmutableList.of(rule);
    }
  }
);
  if (env.valuesMissing()) {
    return null;
  }
  if (rules == null || rules.isEmpty()) {
    throw new ExternalRuleNotFoundException(ruleName);
  }
  return Iterables.getFirst(rules,null);
}","/** 
 * Uses a rule name to fetch the corresponding Rule from the external package. 
 */
@Nullable public static Rule getRuleByName(final String ruleName,Environment env) throws ExternalPackageException, InterruptedException {
  List<Rule> rules=getRules(env,true,new Function<Package,Iterable<Rule>>(){
    @Nullable @Override public Iterable<Rule> apply(    Package externalPackage){
      Rule rule=externalPackage.getRule(ruleName);
      if (rule == null) {
        return null;
      }
      return ImmutableList.of(rule);
    }
  }
);
  if (env.valuesMissing()) {
    return null;
  }
  if (rules == null || rules.isEmpty()) {
    throw new ExternalRuleNotFoundException(ruleName);
  }
  return Iterables.getFirst(rules,null);
}",0.9965963240299524
110746,"/** 
 * Loads the external package and then calls the selector to find matching rules.
 * @param env the environment to use for lookups
 * @param returnFirst whether to return only the first rule found
 * @param selector the function to call to load rules
 */
@Nullable private static Set<Rule> getRules(Environment env,boolean returnFirst,Function<Package,Iterable<Rule>> selector) throws ExternalPackageException, InterruptedException {
  SkyKey packageLookupKey=PackageLookupValue.key(Label.EXTERNAL_PACKAGE_IDENTIFIER);
  PackageLookupValue packageLookupValue=(PackageLookupValue)env.getValue(packageLookupKey);
  if (packageLookupValue == null) {
    return null;
  }
  RootedPath workspacePath=packageLookupValue.getRootedPath(Label.EXTERNAL_PACKAGE_IDENTIFIER);
  Set<Rule> rules=new HashSet<>();
  SkyKey workspaceKey=WorkspaceFileValue.key(workspacePath);
  do {
    WorkspaceFileValue value=(WorkspaceFileValue)env.getValue(workspaceKey);
    if (value == null) {
      return null;
    }
    Package externalPackage=value.getPackage();
    if (externalPackage.containsErrors()) {
      Event.replayEventsOn(env.getListener(),externalPackage.getEvents());
      throw new ExternalPackageException(new BuildFileContainsErrorsException(Label.EXTERNAL_PACKAGE_IDENTIFIER,""String_Node_Str""),Transience.PERSISTENT);
    }
    Iterable<Rule> results=selector.apply(externalPackage);
    if (results != null) {
      Iterables.addAll(rules,results);
      if (returnFirst && !rules.isEmpty()) {
        return ImmutableSet.of(Iterables.getFirst(results,null));
      }
    }
    workspaceKey=value.next();
  }
 while (workspaceKey != null);
  return rules;
}","/** 
 * Loads the external package and then calls the selector to find matching rules.
 * @param env the environment to use for lookups
 * @param returnFirst whether to return only the first rule found
 * @param selector the function to call to load rules
 */
@Nullable private static List<Rule> getRules(Environment env,boolean returnFirst,Function<Package,Iterable<Rule>> selector) throws ExternalPackageException, InterruptedException {
  SkyKey packageLookupKey=PackageLookupValue.key(Label.EXTERNAL_PACKAGE_IDENTIFIER);
  PackageLookupValue packageLookupValue=(PackageLookupValue)env.getValue(packageLookupKey);
  if (packageLookupValue == null) {
    return null;
  }
  RootedPath workspacePath=packageLookupValue.getRootedPath(Label.EXTERNAL_PACKAGE_IDENTIFIER);
  List<Rule> rules=ImmutableList.of();
  SkyKey workspaceKey=WorkspaceFileValue.key(workspacePath);
  do {
    WorkspaceFileValue value=(WorkspaceFileValue)env.getValue(workspaceKey);
    if (value == null) {
      return null;
    }
    Package externalPackage=value.getPackage();
    if (externalPackage.containsErrors()) {
      Event.replayEventsOn(env.getListener(),externalPackage.getEvents());
      throw new ExternalPackageException(new BuildFileContainsErrorsException(Label.EXTERNAL_PACKAGE_IDENTIFIER,""String_Node_Str""),Transience.PERSISTENT);
    }
    Iterable<Rule> results=selector.apply(externalPackage);
    if (results != null) {
      rules=ImmutableList.copyOf(results);
      if (returnFirst && !rules.isEmpty()) {
        return ImmutableList.of(Iterables.getFirst(results,null));
      }
    }
    workspaceKey=value.next();
  }
 while (workspaceKey != null);
  return rules;
}",0.9297719087635054
110747,"/** 
 * Returns a copy of this container with filtered resources, or the original if no resources should be filtered. The original container is unchanged.
 */
public ResourceContainer filter(RuleContext ruleContext,ResourceFilter filter){
  ImmutableList<Artifact> filteredResources=filter.filter(ruleContext,getResources());
  if (filteredResources.size() == getResources().size()) {
    return this;
  }
  ImmutableList.Builder<PathFragment> filteredResourcesRootsBuilder=ImmutableList.builder();
  for (  PathFragment resourceRoot : getResourcesRoots()) {
    for (    Artifact resource : filteredResources) {
      if (resource.getRootRelativePath().startsWith(resourceRoot)) {
        filteredResourcesRootsBuilder.add(resourceRoot);
        break;
      }
    }
  }
  return toBuilder().setResources(filteredResources).setResourcesRoots(filteredResourcesRootsBuilder.build()).build();
}","/** 
 * Returns a copy of this container with filtered resources, or the original if no resources should be filtered. The original container is unchanged.
 */
public ResourceContainer filter(RuleErrorConsumer ruleErrorConsumer,ResourceFilter filter){
  ImmutableList<Artifact> filteredResources=filter.filter(ruleErrorConsumer,getResources());
  if (filteredResources.size() == getResources().size()) {
    return this;
  }
  ImmutableList.Builder<PathFragment> filteredResourcesRootsBuilder=ImmutableList.builder();
  for (  PathFragment resourceRoot : getResourcesRoots()) {
    for (    Artifact resource : filteredResources) {
      if (resource.getRootRelativePath().startsWith(resourceRoot)) {
        filteredResourcesRootsBuilder.add(resourceRoot);
        break;
      }
    }
  }
  return toBuilder().setResources(filteredResources).setResourcesRoots(filteredResourcesRootsBuilder.build()).build();
}",0.9711431742508324
110748,"/** 
 * Constructor.
 * @param configFilters the resource configuration filters, as a list of strings.
 * @param densities the density filters, as a list of strings.
 * @param filterBehavior the behavior of this filter.
 */
private ResourceFilter(ImmutableList<String> configFilters,ImmutableList<String> densities,FilterBehavior filterBehavior){
  this.configFilters=configFilters;
  this.densities=densities;
  this.filterBehavior=filterBehavior;
}","/** 
 * Constructor.
 * @param configFilters the resource configuration filters, as a list of strings.
 * @param densities the density filters, as a list of strings.
 * @param filterBehavior the behavior of this filter.
 */
@VisibleForTesting ResourceFilter(ImmutableList<String> configFilters,ImmutableList<String> densities,FilterBehavior filterBehavior){
  this.configFilters=configFilters;
  this.densities=densities;
  this.filterBehavior=filterBehavior;
}",0.9725576289791438
110749,"/** 
 * Reports an attribute error if the given item is null, and otherwise adds it to the builder. 
 */
private static <T>void addIfNotNull(T item,String itemString,ImmutableList.Builder<T> builder,RuleContext ruleContext,String attrName){
  if (item == null) {
    ruleContext.attributeError(attrName,""String_Node_Str"" + itemString + ""String_Node_Str""+ attrName);
  }
 else {
    builder.add(item);
  }
}","/** 
 * Reports an attribute error if the given item is null, and otherwise adds it to the builder. 
 */
private static <T>void addIfNotNull(T item,String itemString,ImmutableList.Builder<T> builder,RuleErrorConsumer ruleErrorConsumer,String attrName){
  if (item == null) {
    ruleErrorConsumer.attributeError(attrName,""String_Node_Str"" + itemString + ""String_Node_Str""+ attrName);
  }
 else {
    builder.add(item);
  }
}",0.9373493975903614
110750,"private static FolderConfiguration getConfigForArtifact(RuleContext ruleContext,Artifact artifact){
  String containingFolder=getContainingFolder(artifact);
  FolderConfiguration config=FolderConfiguration.getConfigForFolder(containingFolder);
  if (config == null) {
    ruleContext.ruleError(""String_Node_Str"" + containingFolder + ""String_Node_Str"");
    return FolderConfiguration.getConfigForQualifierString(""String_Node_Str"");
  }
  config.setVersionQualifier(VersionQualifier.getQualifier(""String_Node_Str""));
  return config;
}","private static FolderConfiguration getConfigForArtifact(RuleErrorConsumer ruleErrorConsumer,Artifact artifact){
  String containingFolder=getContainingFolder(artifact);
  FolderConfiguration config=FolderConfiguration.getConfigForFolder(containingFolder);
  if (config == null) {
    ruleErrorConsumer.ruleError(""String_Node_Str"" + containingFolder + ""String_Node_Str"");
    return FolderConfiguration.getConfigForQualifierString(""String_Node_Str"");
  }
  return config;
}",0.8250497017892644
110751,"/** 
 * @param artifact if this artifact is a better match for this object's desired density than anyother artifacts with the same name and non-density configuration, adds it to this object.
 */
public void maybeAddArtifact(Artifact artifact){
  FolderConfiguration config=getConfigForArtifact(ruleContext,artifact);
  config.setDensityQualifier(null);
  String nameAndConfiguration=config.getUniqueKey() + ""String_Node_Str"" + artifact.getFilename();
  Artifact currentBest=nameAndConfigurationToBestArtifact.get(nameAndConfiguration);
  if (currentBest == null || computeAffinity(artifact) < computeAffinity(currentBest)) {
    nameAndConfigurationToBestArtifact.put(nameAndConfiguration,artifact);
  }
}","/** 
 * @param artifact if this artifact is a better match for this object's desired density than anyother artifacts with the same name and non-density configuration, adds it to this object.
 */
public void maybeAddArtifact(Artifact artifact){
  FolderConfiguration config=getConfigForArtifact(ruleErrorConsumer,artifact);
  config.setDensityQualifier(null);
  String nameAndConfiguration=config.getUniqueKey() + ""String_Node_Str"" + artifact.getFilename();
  Artifact currentBest=nameAndConfigurationToBestArtifact.get(nameAndConfiguration);
  if (currentBest == null || computeAffinity(artifact) < computeAffinity(currentBest)) {
    nameAndConfigurationToBestArtifact.put(nameAndConfiguration,artifact);
  }
}",0.9901129943502824
110752,"private ImmutableList<FolderConfiguration> getConfigurationFilters(RuleContext ruleContext){
  ImmutableList.Builder<FolderConfiguration> filterBuilder=ImmutableList.builder();
  for (  String filter : configFilters) {
    addIfNotNull(getFolderConfiguration(filter),filter,filterBuilder,ruleContext,RESOURCE_CONFIGURATION_FILTERS_NAME);
  }
  return filterBuilder.build();
}","private ImmutableList<FolderConfiguration> getConfigurationFilters(RuleErrorConsumer ruleErrorConsumer){
  ImmutableList.Builder<FolderConfiguration> filterBuilder=ImmutableList.builder();
  for (  String filter : configFilters) {
    addIfNotNull(getFolderConfiguration(filter),filter,filterBuilder,ruleErrorConsumer,RESOURCE_CONFIGURATION_FILTERS_NAME);
  }
  return filterBuilder.build();
}",0.9088541666666666
110753,"/** 
 * Extracts filters from the current RuleContext, as a list of strings. <p>In BUILD files, string lists can be represented as a list of strings, a single comma-separated string, or a combination of both. This method outputs a single list of individual string values, which can then be passed directly to resource processing actions.
 * @return the values of this attribute contained in the {@link RuleContext}, as a list.
 */
private static ImmutableList<String> extractFilters(AttributeMap attrs,String attrName){
  if (!hasAttr(attrs,attrName)) {
    return ImmutableList.<String>of();
  }
  List<String> rawValues=attrs.get(attrName,Type.STRING_LIST);
  ImmutableList.Builder<String> builder=ImmutableList.builder();
  for (  String rawValue : rawValues) {
    if (rawValue.contains(""String_Node_Str"")) {
      for (      String token : rawValue.split(""String_Node_Str"")) {
        if (!token.trim().isEmpty()) {
          builder.add(token.trim());
        }
      }
    }
 else     if (!rawValue.isEmpty()) {
      builder.add(rawValue);
    }
  }
  return builder.build();
}","/** 
 * Extracts filters from an AttributeMap, as a list of strings. <p>In BUILD files, string lists can be represented as a list of strings, a single comma-separated string, or a combination of both. This method outputs a single list of individual string values, which can then be passed directly to resource processing actions.
 * @return the values of this attribute contained in the {@link AttributeMap}, as a list.
 */
private static ImmutableList<String> extractFilters(AttributeMap attrs,String attrName){
  if (!hasAttr(attrs,attrName)) {
    return ImmutableList.<String>of();
  }
  List<String> rawValues=attrs.get(attrName,Type.STRING_LIST);
  ImmutableList.Builder<String> builder=ImmutableList.builder();
  for (  String rawValue : rawValues) {
    if (rawValue.contains(""String_Node_Str"")) {
      for (      String token : rawValue.split(""String_Node_Str"")) {
        if (!token.trim().isEmpty()) {
          builder.add(token.trim());
        }
      }
    }
 else     if (!rawValue.isEmpty()) {
      builder.add(rawValue);
    }
  }
  return builder.build();
}",0.9717984281091078
110754,"/** 
 * Filters a NestedSet of resource containers that contain dependencies of the current rule. This may be a no-op if this filter is empty or if resource prefiltering is disabled.
 */
NestedSet<ResourceContainer> filterDependencies(RuleContext ruleContext,NestedSet<ResourceContainer> resources){
  if (!isPrefiltering()) {
    return resources;
  }
  NestedSetBuilder<ResourceContainer> builder=new NestedSetBuilder<>(resources.getOrder());
  for (  ResourceContainer resource : resources) {
    builder.add(resource.filter(ruleContext,this));
  }
  return builder.build();
}","/** 
 * Filters a NestedSet of resource containers that contain dependencies of the current rule. This may be a no-op if this filter is empty or if resource prefiltering is disabled.
 */
NestedSet<ResourceContainer> filterDependencies(RuleErrorConsumer ruleErrorConsumer,NestedSet<ResourceContainer> resources){
  if (!isPrefiltering()) {
    return resources;
  }
  NestedSetBuilder<ResourceContainer> builder=new NestedSetBuilder<>(resources.getOrder());
  for (  ResourceContainer resource : resources) {
    builder.add(resource.filter(ruleErrorConsumer,this));
  }
  return builder.build();
}",0.9404761904761904
110755,"ImmutableList<Artifact> filter(RuleContext ruleContext,ImmutableList<Artifact> artifacts){
  if (!isPrefiltering()) {
    return artifacts;
  }
  ImmutableSet.Builder<Artifact> builder=ImmutableSet.builder();
  List<BestArtifactsForDensity> bestArtifactsForAllDensities=new ArrayList<>();
  for (  Density density : getDensities(ruleContext)) {
    bestArtifactsForAllDensities.add(new BestArtifactsForDensity(ruleContext,density));
  }
  ImmutableList<FolderConfiguration> folderConfigs=getConfigurationFilters(ruleContext);
  for (  Artifact artifact : artifacts) {
    if (!matchesConfigurationFilters(folderConfigs,getConfigForArtifact(ruleContext,artifact))) {
      continue;
    }
    if (!shouldFilterByDensity(artifact)) {
      builder.add(artifact);
      continue;
    }
    for (    BestArtifactsForDensity bestArtifactsForDensity : bestArtifactsForAllDensities) {
      bestArtifactsForDensity.maybeAddArtifact(artifact);
    }
  }
  for (  BestArtifactsForDensity bestArtifactsForDensity : bestArtifactsForAllDensities) {
    builder.addAll(bestArtifactsForDensity.get());
  }
  ImmutableSet<Artifact> keptArtifacts=builder.build();
  for (  Artifact artifact : artifacts) {
    if (keptArtifacts.contains(artifact)) {
      continue;
    }
    String parentDir=artifact.getPath().getParentDirectory().getBaseName();
    filteredResources.add(parentDir + ""String_Node_Str"" + artifact.getFilename());
  }
  return keptArtifacts.asList();
}","ImmutableList<Artifact> filter(RuleErrorConsumer ruleErrorConsumer,ImmutableList<Artifact> artifacts){
  if (!isPrefiltering()) {
    return artifacts;
  }
  ImmutableSet.Builder<Artifact> builder=ImmutableSet.builder();
  List<BestArtifactsForDensity> bestArtifactsForAllDensities=new ArrayList<>();
  for (  Density density : getDensities(ruleErrorConsumer)) {
    bestArtifactsForAllDensities.add(new BestArtifactsForDensity(ruleErrorConsumer,density));
  }
  ImmutableList<FolderConfiguration> folderConfigs=getConfigurationFilters(ruleErrorConsumer);
  for (  Artifact artifact : artifacts) {
    FolderConfiguration config=getConfigForArtifact(ruleErrorConsumer,artifact);
    config.setVersionQualifier(VersionQualifier.getQualifier(""String_Node_Str""));
    if (!matchesConfigurationFilters(folderConfigs,config)) {
      continue;
    }
    if (!shouldFilterByDensity(artifact)) {
      builder.add(artifact);
      continue;
    }
    for (    BestArtifactsForDensity bestArtifactsForDensity : bestArtifactsForAllDensities) {
      bestArtifactsForDensity.maybeAddArtifact(artifact);
    }
  }
  for (  BestArtifactsForDensity bestArtifactsForDensity : bestArtifactsForAllDensities) {
    builder.addAll(bestArtifactsForDensity.get());
  }
  ImmutableSet<Artifact> keptArtifacts=builder.build();
  for (  Artifact artifact : artifacts) {
    if (keptArtifacts.contains(artifact)) {
      continue;
    }
    String parentDir=artifact.getPath().getParentDirectory().getBaseName();
    filteredResources.add(parentDir + ""String_Node_Str"" + artifact.getFilename());
  }
  return keptArtifacts.asList();
}",0.9049951028403526
110756,"public BestArtifactsForDensity(RuleContext ruleContext,Density density){
  this.ruleContext=ruleContext;
  desiredDensity=density;
}","public BestArtifactsForDensity(RuleErrorConsumer ruleErrorConsumer,Density density){
  this.ruleErrorConsumer=ruleErrorConsumer;
  desiredDensity=density;
}",0.8333333333333334
110757,"/** 
 * Compute how well this artifact matches the   {@link #desiredDensity}. <p>Various different codebases have different and sometimes contradictory methods for which resources are better in different situations. All of them agree that an exact match is best, but: <p>The android common code (see   {@link FolderConfiguration#getDensityQualifier()} treatslarger densities as better than non-matching smaller densities. <p>aapt code to filter assets by density prefers the smallest density that is larger than or the same as the desired density, or, lacking that, the largest available density. <p>Other implementations of density filtering include Gradle (to filter which resources actually get built into apps) and Android code itself (for the device to decide which resource to use). <p>This particular implementation is based on  {@link com.google.devtools.build.android.DensitySpecificResourceFilter}, which filters resources by density during execution. It prefers to use exact matches when possible, then tries to find resources with exactly double the desired density for particularly easy downsizing, and otherwise prefers resources that are closest to the desired density, relative to the smaller of the available and desired densities. <p>Once we always filter resources during analysis, we should be able to completely remove that code.
 * @return a score for how well the artifact matches. Lower scores indicate better matches.
 */
private double computeAffinity(Artifact artifact){
  DensityQualifier resourceQualifier=getConfigForArtifact(ruleContext,artifact).getDensityQualifier();
  if (resourceQualifier == null) {
    return Double.MAX_VALUE;
  }
  int resourceDensity=resourceQualifier.getValue().getDpiValue();
  int density=desiredDensity.getDpiValue();
  if (resourceDensity == density) {
    return -2;
  }
  if (resourceDensity == 2 * density) {
    return -1;
  }
  double densityRatio=Math.max(density,resourceDensity) / (double)Math.min(density,resourceDensity);
  if (density < resourceDensity) {
    return densityRatio;
  }
  return densityRatio + 0.01;
}","/** 
 * Compute how well this artifact matches the   {@link #desiredDensity}. <p>Various different codebases have different and sometimes contradictory methods for which resources are better in different situations. All of them agree that an exact match is best, but: <p>The android common code (see   {@link FolderConfiguration#getDensityQualifier()} treatslarger densities as better than non-matching smaller densities. <p>aapt code to filter assets by density prefers the smallest density that is larger than or the same as the desired density, or, lacking that, the largest available density. <p>Other implementations of density filtering include Gradle (to filter which resources actually get built into apps) and Android code itself (for the device to decide which resource to use). <p>This particular implementation is based on  {@link com.google.devtools.build.android.DensitySpecificResourceFilter}, which filters resources by density during execution. It prefers to use exact matches when possible, then tries to find resources with exactly double the desired density for particularly easy downsizing, and otherwise prefers resources that are closest to the desired density, relative to the smaller of the available and desired densities. <p>Once we always filter resources during analysis, we should be able to completely remove that code.
 * @return a score for how well the artifact matches. Lower scores indicate better matches.
 */
private double computeAffinity(Artifact artifact){
  DensityQualifier resourceQualifier=getConfigForArtifact(ruleErrorConsumer,artifact).getDensityQualifier();
  if (resourceQualifier == null) {
    return Double.MAX_VALUE;
  }
  int resourceDensity=resourceQualifier.getValue().getDpiValue();
  int density=desiredDensity.getDpiValue();
  if (resourceDensity == density) {
    return -2;
  }
  if (resourceDensity == 2 * density) {
    return -1;
  }
  double densityRatio=Math.max(density,resourceDensity) / (double)Math.min(density,resourceDensity);
  if (density < resourceDensity) {
    return densityRatio;
  }
  return densityRatio + 0.01;
}",0.9966539196940728
110758,"@Override public void handle(Event e){
  hasErrors|=e.getKind() == EventKind.ERROR;
  super.handle(e);
}","@Override public void handle(Event e){
  if (e.getKind() == EventKind.ERROR) {
    hasErrors=true;
  }
  super.handle(e);
}",0.8193832599118943
110759,"@Override public void handleOptions(OptionsProvider optionsProvider){
  this.options=optionsProvider.getOptions(RemoteOptions.class);
}","@Override public void handleOptions(OptionsProvider optionsProvider){
  converter.options=optionsProvider.getOptions(RemoteOptions.class);
}",0.96
110760,"@Override public void serverInit(OptionsProvider startupOptions,ServerBuilder builder) throws AbruptExitException {
  builder.addPathToUriConverter(new CasPathConverter());
}","@Override public void serverInit(OptionsProvider startupOptions,ServerBuilder builder) throws AbruptExitException {
  builder.addPathToUriConverter(converter);
}",0.9552238805970148
110761,"@Override public void flush() throws IOException {
  String line=buffer.toString(StandardCharsets.UTF_8.name());
  if (!line.startsWith(SHOW_INCLUDES_PREFIX) && !line.startsWith(sourceFileName)) {
    buffer.writeTo(out);
  }
  out.flush();
}","@Override public void flush() throws IOException {
  String line=buffer.toString(StandardCharsets.UTF_8.name());
  if (!line.startsWith(SHOW_INCLUDES_PREFIX) && !line.startsWith(sourceFileName) && !SHOW_INCLUDES_PREFIX.startsWith(line)&& !sourceFileName.startsWith(line)) {
    buffer.writeTo(out);
    buffer.reset();
  }
  out.flush();
}",0.8330464716006885
110762,"public Collection<Path> getDependencies(Path root){
  Collection<Path> dependenciesInPath=new ArrayList<>();
  if (filterShowIncludesOutputStream != null) {
    for (    String dep : filterShowIncludesOutputStream.getDependencies()) {
      dependenciesInPath.add(root.getRelative(dep));
    }
  }
  return Collections.unmodifiableCollection(dependenciesInPath);
}","@VisibleForTesting Collection<String> getDependencies(){
  return filterShowIncludesOutputStream.getDependencies();
}",0.3908523908523909
110763,"/** 
 * Waits for the task queue to drain. Then if   {@code ownExecutorService} is true, shuts down the{@link ExecutorService} and waits for it to terminate. Throws (the same) unchecked exception ifany worker thread failed unexpectedly.
 */
protected final void awaitTermination(boolean interruptWorkers) throws InterruptedException {
  Throwables.propagateIfPossible(catastrophe);
  try {
synchronized (zeroRemainingTasks) {
      while (remainingTasks.get() != 0 && !jobsMustBeStopped) {
        zeroRemainingTasks.wait();
      }
    }
  }
 catch (  InterruptedException e) {
    setInterrupted();
  }
  reallyAwaitTermination(interruptWorkers);
  if (isInterrupted()) {
    Thread.currentThread().interrupt();
  }
  Throwables.propagateIfPossible(unhandled);
  if (Thread.interrupted()) {
    throw new InterruptedException();
  }
}","/** 
 * Waits for the task queue to drain. Then if   {@code ownExecutorService} is true, shuts down the{@link ExecutorService} and waits for it to terminate. Throws (the same) unchecked exception ifany worker thread failed unexpectedly.
 */
protected final void awaitTermination(boolean interruptWorkers) throws InterruptedException {
  reallyAwaitTermination(interruptWorkers);
  if (isInterrupted()) {
    Thread.currentThread().interrupt();
  }
  Throwables.propagateIfPossible(unhandled);
  if (Thread.interrupted()) {
    throw new InterruptedException();
  }
}",0.579172610556348
110764,"@Override public final void awaitQuiescence(boolean interruptWorkers) throws InterruptedException {
  awaitTermination(interruptWorkers);
}","@Override public final void awaitQuiescence(boolean interruptWorkers) throws InterruptedException {
  Throwables.propagateIfPossible(catastrophe);
  try {
synchronized (zeroRemainingTasks) {
      while (remainingTasks.get() != 0 && !jobsMustBeStopped) {
        zeroRemainingTasks.wait();
      }
    }
  }
 catch (  InterruptedException e) {
    setInterrupted();
  }
  awaitTermination(interruptWorkers);
}",0.4817518248175182
110765,"private void visitAndWaitForCompletion() throws QueryException, InterruptedException {
  while (!mustJobsBeStopped() && (!processingQueue.isEmpty() || getTaskCount() > 0)) {
    if (getTaskCount() < MIN_PENDING_TASKS || processingQueue.size() >= SkyQueryEnvironment.BATCH_CALLBACK_SIZE) {
      Collection<T> pendingKeysToVisit=new ArrayList<>(processingQueue.size());
      processingQueue.drainTo(pendingKeysToVisit);
      for (      Task task : getVisitTasks(pendingKeysToVisit)) {
        execute(task);
      }
    }
    try {
      Thread.sleep(SCHEDULING_INTERVAL_MILLISECONDS);
    }
 catch (    InterruptedException e) {
      setInterrupted();
      awaitTerminationAndPropagateErrorsIfAny();
      throw e;
    }
  }
  awaitTerminationAndPropagateErrorsIfAny();
}","private void visitAndWaitForCompletion() throws QueryException, InterruptedException {
  while (!mustJobsBeStopped() && (!processingQueue.isEmpty() || getTaskCount() > 0)) {
    if (getTaskCount() < MIN_PENDING_TASKS || processingQueue.size() >= SkyQueryEnvironment.BATCH_CALLBACK_SIZE) {
      Collection<T> pendingKeysToVisit=new ArrayList<>(processingQueue.size());
      processingQueue.drainTo(pendingKeysToVisit);
      for (      Task task : getVisitTasks(pendingKeysToVisit)) {
        execute(task);
      }
    }
    try {
      Thread.sleep(SCHEDULING_INTERVAL_MILLISECONDS);
    }
 catch (    InterruptedException e) {
      setInterrupted();
      awaitTerminationAndPropagateErrorsIfAny();
    }
  }
  awaitTerminationAndPropagateErrorsIfAny();
}",0.927687296416938
110766,"public boolean isOverwritable(){
  return type.isOverwritable();
}","public boolean isOverwritable(){
  return type.isOverwritable(this);
}",0.9705882352941176
110767,"public boolean isCombining(){
  return type != AttributeType.UNCOMBINABLE;
}","public boolean isCombining(){
  return type.isCombining();
}",0.7058823529411765
110768,"/** 
 * Converts the given flag values into a string hash for use as an output directory fragment. 
 */
private static String hashFlags(SortedMap<Label,String> flagValues){
  Hasher hasher=Hashing.murmur3_128().newHasher();
  for (  Map.Entry<Label,String> flag : flagValues.entrySet()) {
    hasher.putUnencodedChars(flag.getKey().toString());
    hasher.putUnencodedChars(flag.getValue());
  }
  return hasher.hash().toString();
}","/** 
 * Converts the given flag values into a string hash for use as an output directory fragment. 
 */
private static String hashFlags(SortedMap<Label,String> flagValues){
  Hasher hasher=Hashing.murmur3_128().newHasher();
  for (  Map.Entry<Label,String> flag : flagValues.entrySet()) {
    hasher.putUnencodedChars(flag.getKey().toString());
    hasher.putByte((byte)0);
    hasher.putUnencodedChars(flag.getValue());
    hasher.putByte((byte)0);
  }
  return hasher.hash().toString();
}",0.9370932754880694
110769,"private void stubMissingDefaultMethods(ImmutableList<String> interfaces){
  for (  String implemented : interfaces) {
    if (!seenInterfaces.add(implemented)) {
      continue;
    }
    ClassReader bytecode=classpath.readIfKnown(implemented);
    if (bytecode != null && !bootclasspath.isKnown(implemented)) {
      bytecode.accept(new DefaultMethodStubber(),ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG);
    }
  }
}","private void stubMissingDefaultMethods(String implemented){
  if (bootclasspath.isKnown(implemented)) {
    return;
  }
  ClassReader bytecode=checkNotNull(classpath.readIfKnown(implemented),""String_Node_Str"",implemented,internalName);
  bytecode.accept(new DefaultMethodStubber(),ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG);
}",0.5585106382978723
110770,"public DefaultMethodClassFixer(ClassVisitor dest,ClassReaderFactory classpath,ClassReaderFactory bootclasspath){
  super(Opcodes.ASM5,dest);
  this.classpath=classpath;
  this.bootclasspath=bootclasspath;
}","public DefaultMethodClassFixer(ClassVisitor dest,ClassReaderFactory classpath,ClassReaderFactory bootclasspath,ClassLoader targetLoader){
  super(Opcodes.ASM5,dest);
  this.classpath=classpath;
  this.bootclasspath=bootclasspath;
  this.targetLoader=targetLoader;
}",0.8747346072186837
110771,"@Override public void visit(int version,int access,String name,String signature,String superName,String[] interfaces){
  checkArgument(BitFlags.noneSet(access,Opcodes.ACC_INTERFACE));
  for (  String inheritedInterface : interfaces) {
    seenInterfaces.add(inheritedInterface);
  }
  super.visit(version,access,name,signature,superName,interfaces);
}","@Override public void visit(int version,int access,String name,String signature,String superName,String[] interfaces){
  checkArgument(BitFlags.noneSet(access,Opcodes.ACC_INTERFACE));
  super.visit(version,access,name,signature,superName,interfaces);
}",0.835820895522388
110772,"/** 
 * Create the class visitors for the lambda classes that are generated on the fly. If no new class visitors are not generated, then the passed-in   {@code writer} will be returned.
 */
private ClassVisitor createClassVisitorsForDumpedLambdaClasses(ClassLoader loader,@Nullable ClassReaderFactory classpathReader,ClassReaderFactory bootclasspathReader,ImmutableSet<String> interfaceLambdaMethods,@Nullable ClassReaderFactory bridgeMethodReader,LambdaInfo lambdaClass,UnprefixingClassWriter writer){
  ClassVisitor visitor=checkNotNull(writer);
  if (outputJava7) {
    visitor=new Java7Compatibility(visitor,(ClassReaderFactory)null);
    if (options.desugarTryWithResourcesIfNeeded) {
      visitor=new TryWithResourcesRewriter(visitor,loader,visitedExceptionTypes,numOfTryWithResourcesInvoked);
    }
    if (options.desugarInterfaceMethodBodiesIfNeeded) {
      visitor=new DefaultMethodClassFixer(visitor,classpathReader,bootclasspathReader);
      visitor=new InterfaceDesugaring(visitor,bootclasspathReader,store);
    }
  }
  visitor=new LambdaClassFixer(visitor,lambdaClass,bridgeMethodReader,interfaceLambdaMethods,allowDefaultMethods,outputJava7);
  visitor=new LambdaDesugaring(visitor,loader,lambdas,null,allowDefaultMethods);
  if (!allowCallsToObjectsNonNull) {
    visitor=new ObjectsRequireNonNullMethodRewriter(visitor);
  }
  if (options.enableRewritingOfLongCompare) {
    visitor=new LongCompareMethodRewriter(visitor);
  }
  return visitor;
}","/** 
 * Create the class visitors for the lambda classes that are generated on the fly. If no new class visitors are not generated, then the passed-in   {@code writer} will be returned.
 */
private ClassVisitor createClassVisitorsForDumpedLambdaClasses(ClassLoader loader,@Nullable ClassReaderFactory classpathReader,ClassReaderFactory bootclasspathReader,ImmutableSet<String> interfaceLambdaMethods,@Nullable ClassReaderFactory bridgeMethodReader,LambdaInfo lambdaClass,UnprefixingClassWriter writer){
  ClassVisitor visitor=checkNotNull(writer);
  if (outputJava7) {
    visitor=new Java7Compatibility(visitor,(ClassReaderFactory)null);
    if (options.desugarTryWithResourcesIfNeeded) {
      visitor=new TryWithResourcesRewriter(visitor,loader,visitedExceptionTypes,numOfTryWithResourcesInvoked);
    }
    if (options.desugarInterfaceMethodBodiesIfNeeded) {
      visitor=new DefaultMethodClassFixer(visitor,classpathReader,bootclasspathReader,loader);
      visitor=new InterfaceDesugaring(visitor,bootclasspathReader,store);
    }
  }
  visitor=new LambdaClassFixer(visitor,lambdaClass,bridgeMethodReader,interfaceLambdaMethods,allowDefaultMethods,outputJava7);
  visitor=new LambdaDesugaring(visitor,loader,lambdas,null,allowDefaultMethods);
  if (!allowCallsToObjectsNonNull) {
    visitor=new ObjectsRequireNonNullMethodRewriter(visitor);
  }
  if (options.enableRewritingOfLongCompare) {
    visitor=new LongCompareMethodRewriter(visitor);
  }
  return visitor;
}",0.9976198571914316
110773,"/** 
 * Create the class visitors for the classes which are in the inputs. If new visitors are created, then all these visitors and the passed-in writer will be chained together. If no new visitor is created, then the passed-in   {@code writer} will be returned.
 */
private ClassVisitor createClassVisitorsForClassesInInputs(ClassLoader loader,@Nullable ClassReaderFactory classpathReader,ClassReaderFactory bootclasspathReader,Builder<String> interfaceLambdaMethodCollector,UnprefixingClassWriter writer){
  ClassVisitor visitor=checkNotNull(writer);
  if (!options.onlyDesugarJavac9ForLint) {
    if (outputJava7) {
      visitor=new Java7Compatibility(visitor,classpathReader);
      if (options.desugarTryWithResourcesIfNeeded) {
        visitor=new TryWithResourcesRewriter(visitor,loader,visitedExceptionTypes,numOfTryWithResourcesInvoked);
      }
      if (options.desugarInterfaceMethodBodiesIfNeeded) {
        visitor=new DefaultMethodClassFixer(visitor,classpathReader,bootclasspathReader);
        visitor=new InterfaceDesugaring(visitor,bootclasspathReader,store);
      }
    }
    visitor=new LambdaDesugaring(visitor,loader,lambdas,interfaceLambdaMethodCollector,allowDefaultMethods);
  }
  if (!allowCallsToObjectsNonNull) {
    visitor=new ObjectsRequireNonNullMethodRewriter(visitor);
  }
  if (options.enableRewritingOfLongCompare) {
    visitor=new LongCompareMethodRewriter(visitor);
  }
  return visitor;
}","/** 
 * Create the class visitors for the classes which are in the inputs. If new visitors are created, then all these visitors and the passed-in writer will be chained together. If no new visitor is created, then the passed-in   {@code writer} will be returned.
 */
private ClassVisitor createClassVisitorsForClassesInInputs(ClassLoader loader,@Nullable ClassReaderFactory classpathReader,ClassReaderFactory bootclasspathReader,Builder<String> interfaceLambdaMethodCollector,UnprefixingClassWriter writer){
  ClassVisitor visitor=checkNotNull(writer);
  if (!options.onlyDesugarJavac9ForLint) {
    if (outputJava7) {
      visitor=new Java7Compatibility(visitor,classpathReader);
      if (options.desugarTryWithResourcesIfNeeded) {
        visitor=new TryWithResourcesRewriter(visitor,loader,visitedExceptionTypes,numOfTryWithResourcesInvoked);
      }
      if (options.desugarInterfaceMethodBodiesIfNeeded) {
        visitor=new DefaultMethodClassFixer(visitor,classpathReader,bootclasspathReader,loader);
        visitor=new InterfaceDesugaring(visitor,bootclasspathReader,store);
      }
    }
    visitor=new LambdaDesugaring(visitor,loader,lambdas,interfaceLambdaMethodCollector,allowDefaultMethods);
  }
  if (!allowCallsToObjectsNonNull) {
    visitor=new ObjectsRequireNonNullMethodRewriter(visitor);
  }
  if (options.enableRewritingOfLongCompare) {
    visitor=new LongCompareMethodRewriter(visitor);
  }
  return visitor;
}",0.9975601254792612
110774,"@Override public MethodVisitor visitMethod(int access,String name,String desc,String signature,String[] exceptions){
  MethodVisitor visitor=super.cv.visitMethod(access,name,desc,signature,exceptions);
  return visitor == null || THROWABLE_EXT_CLASS_INTERNAL_NAMES.contains(name) ? visitor : new TryWithResourceVisitor(visitor,classLoader);
}","@Override public MethodVisitor visitMethod(int access,String name,String desc,String signature,String[] exceptions){
  MethodVisitor visitor=super.cv.visitMethod(access,name,desc,signature,exceptions);
  return visitor == null || shouldCurrentClassBeIgnored ? visitor : new TryWithResourceVisitor(visitor,classLoader);
}",0.8912386706948641
110775,"/** 
 * Expand a single policy. If the policy is not about an expansion flag, this will simply return a list with a single element, oneself. If the policy is for an expansion flag, the policy will get split into multiple policies applying to each flag the original flag expands to. <p>None of the flagPolicies returned should be on expansion flags.
 */
private static List<FlagPolicy> expandPolicy(FlagPolicy originalPolicy,OptionsParser parser) throws OptionsParsingException {
  List<FlagPolicy> expandedPolicy=new ArrayList<>();
  OptionDescription desc=parser.getOptionDescription(originalPolicy.getFlagName());
  if (desc == null) {
    return expandedPolicy;
  }
  ImmutableList.Builder<OptionValueDescription> subflagBuilder=new ImmutableList.Builder<>();
  ImmutableList<OptionValueDescription> subflags=subflagBuilder.addAll(desc.getImplicitRequirements()).addAll(desc.getExpansions()).build();
  boolean isExpansion=!desc.getExpansions().isEmpty();
  if (!subflags.isEmpty() && log.isLoggable(Level.FINE)) {
    List<String> subflagNames=new ArrayList<>(subflags.size());
    for (    OptionValueDescription subflag : subflags) {
      subflagNames.add(""String_Node_Str"" + subflag.getName());
    }
    log.logp(Level.FINE,""String_Node_Str"",""String_Node_Str"",String.format(""String_Node_Str"",originalPolicy.getOperationCase(),originalPolicy.getFlagName(),isExpansion ? ""String_Node_Str"" : ""String_Node_Str"",Joiner.on(""String_Node_Str"").join(subflagNames)));
  }
  for (  OptionValueDescription currentSubflag : subflags) {
    FlagPolicy subflagAsPolicy=null;
switch (originalPolicy.getOperationCase()) {
case SET_VALUE:
      SetValue setValueExpansion=SetValue.newBuilder().addFlagValue(currentSubflag.getOriginalValueString()).setOverridable(originalPolicy.getSetValue().getOverridable()).build();
    subflagAsPolicy=FlagPolicy.newBuilder().addAllCommands(originalPolicy.getCommandsList()).setFlagName(currentSubflag.getName()).setSetValue(setValueExpansion).build();
  break;
case USE_DEFAULT:
subflagAsPolicy=FlagPolicy.newBuilder().addAllCommands(originalPolicy.getCommandsList()).setFlagName(currentSubflag.getName()).setUseDefault(UseDefault.getDefaultInstance()).build();
break;
case ALLOW_VALUES:
if (isExpansion) {
throw new OptionsParsingException(String.format(""String_Node_Str"",originalPolicy.getFlagName()));
}
break;
case DISALLOW_VALUES:
if (isExpansion) {
throw new OptionsParsingException(String.format(""String_Node_Str"",originalPolicy.getFlagName()));
}
break;
case OPERATION_NOT_SET:
throw new PolicyOperationNotSetException(originalPolicy.getFlagName());
default :
expandedPolicy.add(originalPolicy);
return expandedPolicy;
}
expandedPolicy.addAll(expandPolicy(subflagAsPolicy,parser));
}
if (!isExpansion) {
expandedPolicy.add(originalPolicy);
}
return expandedPolicy;
}","/** 
 * Expand a single policy. If the policy is not about an expansion flag, this will simply return a list with a single element, oneself. If the policy is for an expansion flag, the policy will get split into multiple policies applying to each flag the original flag expands to. <p>None of the flagPolicies returned should be on expansion flags.
 */
private static List<FlagPolicy> expandPolicy(FlagPolicy originalPolicy,OptionsParser parser) throws OptionsParsingException {
  List<FlagPolicy> expandedPolicy=new ArrayList<>();
  OptionDescription originalDesc=parser.getOptionDescription(originalPolicy.getFlagName());
  if (originalDesc == null) {
    return expandedPolicy;
  }
  ImmutableList.Builder<OptionValueDescription> subflagBuilder=new ImmutableList.Builder<>();
  ImmutableList<OptionValueDescription> subflags=subflagBuilder.addAll(originalDesc.getImplicitRequirements()).addAll(originalDesc.getExpansions()).build();
  boolean isExpansion=!originalDesc.getExpansions().isEmpty();
  if (!subflags.isEmpty() && log.isLoggable(Level.FINE)) {
    List<String> subflagNames=new ArrayList<>(subflags.size());
    for (    OptionValueDescription subflag : subflags) {
      subflagNames.add(""String_Node_Str"" + subflag.getName());
    }
    log.logp(Level.FINE,""String_Node_Str"",""String_Node_Str"",String.format(""String_Node_Str"",originalPolicy.getOperationCase(),originalPolicy.getFlagName(),isExpansion ? ""String_Node_Str"" : ""String_Node_Str"",Joiner.on(""String_Node_Str"").join(subflagNames)));
  }
  Multimap<String,OptionValueDescription> repeatableSubflagsInSetValues=ArrayListMultimap.create();
  for (  OptionValueDescription currentSubflag : subflags) {
    if (currentSubflag.getAllowMultiple() && originalPolicy.getOperationCase().equals(OperationCase.SET_VALUE)) {
      repeatableSubflagsInSetValues.put(currentSubflag.getName(),currentSubflag);
    }
 else {
      FlagPolicy subflagAsPolicy=getSubflagAsPolicy(currentSubflag,originalPolicy,originalDesc);
      expandedPolicy.addAll(expandPolicy(subflagAsPolicy,parser));
    }
  }
  for (  String repeatableFlag : repeatableSubflagsInSetValues.keySet()) {
    int numValues=repeatableSubflagsInSetValues.get(repeatableFlag).size();
    ArrayList<String> newValues=new ArrayList<>(numValues);
    for (    OptionValueDescription setValue : repeatableSubflagsInSetValues.get(repeatableFlag)) {
      newValues.add(setValue.getOriginalValueString());
    }
    expandedPolicy.add(getSetValueSubflagAsPolicy(repeatableFlag,newValues,true,originalPolicy));
  }
  if (!isExpansion) {
    expandedPolicy.add(originalPolicy);
  }
  return expandedPolicy;
}",0.5904902322152599
110776,"@Override public void visitFrame(int type,int nLocal,Object[] local,int nStack,Object[] stack){
  if (isArrayNullOrEmpty(local)) {
    nLocal=0;
  }
  if (isArrayNullOrEmpty(stack)) {
    nStack=0;
  }
  super.visitFrame(type,nLocal,local,nStack,stack);
}","@Override public void visitFrame(int type,int nLocal,Object[] local,int nStack,Object[] stack){
  if (this.mv != null) {
    mv.visitFrame(type,nLocal,remapEntriesWithBugfix(nLocal,local),nStack,remapEntriesWithBugfix(nStack,stack));
  }
}",0.4736842105263157
110777,"@Override protected MethodVisitor createMethodRemapper(MethodVisitor mv){
  return new MethodRemapper(mv,this.remapper){
    private final boolean isArrayNullOrEmpty(    Object[] array){
      return array == null || array.length == 0;
    }
    @Override public void visitFrame(    int type,    int nLocal,    Object[] local,    int nStack,    Object[] stack){
      if (isArrayNullOrEmpty(local)) {
        nLocal=0;
      }
      if (isArrayNullOrEmpty(stack)) {
        nStack=0;
      }
      super.visitFrame(type,nLocal,local,nStack,stack);
    }
  }
;
}","@Override protected MethodVisitor createMethodRemapper(MethodVisitor mv){
  return new MethodRemapper(mv,this.remapper){
    @Override public void visitFrame(    int type,    int nLocal,    Object[] local,    int nStack,    Object[] stack){
      if (this.mv != null) {
        mv.visitFrame(type,nLocal,remapEntriesWithBugfix(nLocal,local),nStack,remapEntriesWithBugfix(nStack,stack));
      }
    }
    /** 
 * In   {@code FrameNode.accept(MethodVisitor)}, when the frame is Opcodes.F_CHOP, it is possible that nLocal is greater than 0, and local is null, which causes MethodRemapper to throw a NPE. So the patch is to make sure that the   {@code nLocal<=local.length} and{@code nStack<=stack.length}
 */
    private Object[] remapEntriesWithBugfix(    int n,    Object[] entries){
      if (entries == null || entries.length == 0) {
        return entries;
      }
      for (int i=0; i < n; i++) {
        if (entries[i] instanceof String) {
          Object[] newEntries=new Object[n];
          if (i > 0) {
            System.arraycopy(entries,0,newEntries,0,i);
          }
          do {
            Object t=entries[i];
            newEntries[i++]=t instanceof String ? remapper.mapType((String)t) : t;
          }
 while (i < n);
          return newEntries;
        }
      }
      return entries;
    }
  }
;
}",0.2696390658174097
110778,"static boolean isSupported(){
  String osxVersion=OS.getVersion();
  String[] parts=osxVersion.split(""String_Node_Str"");
  if (parts.length != 3) {
    return false;
  }
  try {
    int v0=Integer.parseInt(parts[0]);
    int v1=Integer.parseInt(parts[1]);
    if (v0 != 10 || v1 < 11) {
      return false;
    }
  }
 catch (  NumberFormatException e) {
    return false;
  }
  List<String> args=new ArrayList<>();
  args.add(SANDBOX_EXEC);
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  ImmutableMap<String,String> env=ImmutableMap.of();
  File cwd=new File(""String_Node_Str"");
  Command cmd=new Command(args.toArray(new String[0]),env,cwd);
  try {
    cmd.execute(new byte[]{},Command.NO_OBSERVER,ByteStreams.nullOutputStream(),ByteStreams.nullOutputStream(),true);
  }
 catch (  CommandException e) {
    return false;
  }
  return true;
}","static boolean isSupported(){
  String osxVersion=OS.getVersion();
  String[] parts=osxVersion.split(""String_Node_Str"");
  if (parts.length < 2 || parts.length > 3) {
    return false;
  }
  try {
    int v0=Integer.parseInt(parts[0]);
    int v1=Integer.parseInt(parts[1]);
    if (v0 != 10 || v1 < 11) {
      return false;
    }
  }
 catch (  NumberFormatException e) {
    return false;
  }
  List<String> args=new ArrayList<>();
  args.add(SANDBOX_EXEC);
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  ImmutableMap<String,String> env=ImmutableMap.of();
  File cwd=new File(""String_Node_Str"");
  Command cmd=new Command(args.toArray(new String[0]),env,cwd);
  try {
    cmd.execute(new byte[]{},Command.NO_OBSERVER,ByteStreams.nullOutputStream(),ByteStreams.nullOutputStream(),true);
  }
 catch (  CommandException e) {
    return false;
  }
  return true;
}",0.9872293170460856
110779,"private static ResourceApk shrinkResources(RuleContext ruleContext,ResourceApk resourceApk,ImmutableList<Artifact> proguardSpecs,ProguardOutput proguardOutput,NestedSetBuilder<Artifact> filesBuilder) throws InterruptedException {
  if (LocalResourceContainer.definesAndroidResources(ruleContext.attributes()) && !proguardSpecs.isEmpty()) {
    Artifact apk=new ResourceShrinkerActionBuilder(ruleContext).setResourceApkOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_SHRUNK_APK)).setShrunkResourcesOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_SHRUNK_ZIP)).setLogOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCE_SHRINKER_LOG)).withResourceFiles(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_ZIP)).withShrunkJar(proguardOutput.getOutputJar()).withProguardMapping(proguardOutput.getMapping()).withPrimary(resourceApk.getPrimaryResource()).withDependencies(resourceApk.getResourceDependencies()).setConfigurationFilters(ResourceConfigurationFilter.fromRuleContext(ruleContext)).setUncompressedExtensions(ruleContext.getTokenizedStringListAttr(""String_Node_Str"")).build();
    filesBuilder.add(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCE_SHRINKER_LOG));
    return new ResourceApk(apk,resourceApk.getResourceJavaSrcJar(),resourceApk.getResourceJavaClassJar(),resourceApk.getResourceDependencies(),resourceApk.getPrimaryResource(),resourceApk.getManifest(),resourceApk.getResourceProguardConfig(),resourceApk.getMainDexProguardConfig(),resourceApk.isLegacy());
  }
  return resourceApk;
}","private static ResourceApk shrinkResources(RuleContext ruleContext,ResourceApk resourceApk,ImmutableList<Artifact> proguardSpecs,ProguardOutput proguardOutput,NestedSetBuilder<Artifact> filesBuilder) throws InterruptedException {
  if (LocalResourceContainer.definesAndroidResources(ruleContext.attributes()) && !proguardSpecs.isEmpty()) {
    Artifact apk=new ResourceShrinkerActionBuilder(ruleContext).setResourceApkOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_SHRUNK_APK)).setShrunkResourcesOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_SHRUNK_ZIP)).setLogOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCE_SHRINKER_LOG)).withResourceFiles(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_ZIP)).withShrunkJar(proguardOutput.getOutputJar()).withProguardMapping(proguardOutput.getMapping()).withPrimary(resourceApk.getPrimaryResource()).withDependencies(resourceApk.getResourceDependencies()).setResourceFilter(ResourceFilter.fromRuleContext(ruleContext)).setUncompressedExtensions(ruleContext.getTokenizedStringListAttr(""String_Node_Str"")).build();
    filesBuilder.add(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCE_SHRINKER_LOG));
    return new ResourceApk(apk,resourceApk.getResourceJavaSrcJar(),resourceApk.getResourceJavaClassJar(),resourceApk.getResourceDependencies(),resourceApk.getPrimaryResource(),resourceApk.getManifest(),resourceApk.getResourceProguardConfig(),resourceApk.getMainDexProguardConfig(),resourceApk.isLegacy());
  }
  return resourceApk;
}",0.9836872883964296
110780,"/** 
 * Tests if the resources need to be regenerated. <p>The resources should be regenerated (using aapt) if any of the following are true: <ul> <li>There is more than one resource container <li>There are densities to filter by. <li>There are resource configuration filters. <li>There are extensions that should be compressed. </ul>
 */
public static boolean shouldRegenerate(RuleContext ruleContext,ResourceDependencies resourceDeps){
  return Iterables.size(resourceDeps.getResources()) > 1 || ruleContext.attributes().isAttributeValueExplicitlySpecified(""String_Node_Str"") || ResourceConfigurationFilter.hasFilters(ruleContext) || ruleContext.attributes().isAttributeValueExplicitlySpecified(""String_Node_Str"");
}","/** 
 * Tests if the resources need to be regenerated. <p>The resources should be regenerated (using aapt) if any of the following are true: <ul> <li>There is more than one resource container <li>There are resource filters. <li>There are extensions that should be compressed. </ul>
 */
public static boolean shouldRegenerate(RuleContext ruleContext,ResourceDependencies resourceDeps){
  return Iterables.size(resourceDeps.getResources()) > 1 || ResourceFilter.hasFilters(ruleContext) || ruleContext.attributes().isAttributeValueExplicitlySpecified(""String_Node_Str"");
}",0.8724727838258165
110781,"private static RuleConfiguredTargetBuilder init(RuleContext ruleContext,NestedSetBuilder<Artifact> filesBuilder,ResourceDependencies resourceDeps,JavaCommon javaCommon,AndroidCommon androidCommon,JavaSemantics javaSemantics,AndroidSemantics androidSemantics) throws InterruptedException, RuleErrorException {
  validateRuleContext(ruleContext);
  Multimap<String,TransitiveInfoCollection> depsByArchitecture=MultimapBuilder.treeKeys().arrayListValues().build();
  AndroidConfiguration androidConfig=ruleContext.getFragment(AndroidConfiguration.class);
  for (  Map.Entry<Optional<String>,? extends List<? extends TransitiveInfoCollection>> entry : ruleContext.getSplitPrerequisites(""String_Node_Str"").entrySet()) {
    String cpu=entry.getKey().or(androidConfig.getCpu());
    depsByArchitecture.putAll(cpu,entry.getValue());
  }
  Map<String,BuildConfiguration> configurationMap=new LinkedHashMap<>();
  Map<String,CcToolchainProvider> toolchainMap=new LinkedHashMap<>();
  for (  Map.Entry<Optional<String>,? extends List<? extends TransitiveInfoCollection>> entry : ruleContext.getSplitPrerequisites(""String_Node_Str"").entrySet()) {
    String cpu=entry.getKey().or(androidConfig.getCpu());
    TransitiveInfoCollection dep=Iterables.getOnlyElement(entry.getValue());
    CcToolchainProvider toolchain=CppHelper.getToolchain(ruleContext,dep);
    configurationMap.put(cpu,dep.getConfiguration());
    toolchainMap.put(cpu,toolchain);
  }
  NativeLibs nativeLibs=NativeLibs.fromLinkedNativeDeps(ruleContext,androidSemantics.getNativeDepsFileName(),depsByArchitecture,toolchainMap,configurationMap);
  ApplicationManifest applicationManifest;
  ResourceApk resourceApk;
  ResourceApk incrementalResourceApk;
  ResourceApk instantRunResourceApk;
  ResourceApk splitResourceApk;
  if (LocalResourceContainer.definesAndroidResources(ruleContext.attributes())) {
    LocalResourceContainer.validateRuleContext(ruleContext);
    ApplicationManifest ruleManifest=androidSemantics.getManifestForRule(ruleContext);
    applicationManifest=ruleManifest.mergeWith(ruleContext,resourceDeps);
    Artifact featureOfArtifact=ruleContext.attributes().isAttributeValueExplicitlySpecified(""String_Node_Str"") ? Iterables.getOnlyElement(ruleContext.getPrerequisite(""String_Node_Str"",Mode.TARGET,ApkProvider.class).getTransitiveApks()) : null;
    Artifact featureAfterArtifact=ruleContext.attributes().isAttributeValueExplicitlySpecified(""String_Node_Str"") ? Iterables.getOnlyElement(ruleContext.getPrerequisite(""String_Node_Str"",Mode.TARGET,ApkProvider.class).getTransitiveApks()) : null;
    resourceApk=applicationManifest.packWithDataAndResources(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_APK),ruleContext,false,resourceDeps,ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_R_TXT),null,ResourceConfigurationFilter.fromRuleContext(ruleContext),ruleContext.getTokenizedStringListAttr(""String_Node_Str""),ruleContext.attributes().get(""String_Node_Str"",Type.BOOLEAN),ruleContext.getTokenizedStringListAttr(""String_Node_Str""),false,ProguardHelper.getProguardConfigArtifact(ruleContext,""String_Node_Str""),createMainDexProguardSpec(ruleContext),ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_PROCESSED_MANIFEST),ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_ZIP),DataBinding.isEnabled(ruleContext) ? DataBinding.getLayoutInfoFile(ruleContext) : null,featureOfArtifact,featureAfterArtifact);
    ruleContext.assertNoErrors();
    incrementalResourceApk=applicationManifest.addMobileInstallStubApplication(ruleContext).packWithDataAndResources(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_INCREMENTAL_RESOURCES_APK),ruleContext,false,resourceDeps,null,null,ResourceConfigurationFilter.fromRuleContext(ruleContext),ruleContext.getTokenizedStringListAttr(""String_Node_Str""),ruleContext.attributes().get(""String_Node_Str"",Type.BOOLEAN),ruleContext.getTokenizedStringListAttr(""String_Node_Str""),true,ProguardHelper.getProguardConfigArtifact(ruleContext,""String_Node_Str""),null,null,null,null,null,null);
    ruleContext.assertNoErrors();
    instantRunResourceApk=applicationManifest.addInstantRunStubApplication(ruleContext).packWithDataAndResources(getDxArtifact(ruleContext,""String_Node_Str""),ruleContext,false,resourceDeps,null,null,ResourceConfigurationFilter.fromRuleContext(ruleContext),ruleContext.getTokenizedStringListAttr(""String_Node_Str""),ruleContext.attributes().get(""String_Node_Str"",Type.BOOLEAN),ruleContext.getTokenizedStringListAttr(""String_Node_Str""),true,ProguardHelper.getProguardConfigArtifact(ruleContext,""String_Node_Str""),null,null,null,null,null,null);
    ruleContext.assertNoErrors();
    splitResourceApk=applicationManifest.createSplitManifest(ruleContext,""String_Node_Str"",false).packWithDataAndResources(getDxArtifact(ruleContext,""String_Node_Str""),ruleContext,false,resourceDeps,null,null,ResourceConfigurationFilter.fromRuleContext(ruleContext),ruleContext.getTokenizedStringListAttr(""String_Node_Str""),ruleContext.attributes().get(""String_Node_Str"",Type.BOOLEAN),ruleContext.getTokenizedStringListAttr(""String_Node_Str""),true,ProguardHelper.getProguardConfigArtifact(ruleContext,""String_Node_Str""),null,null,null,null,null,null);
    ruleContext.assertNoErrors();
  }
 else {
    if (!ruleContext.attributes().get(""String_Node_Str"",Type.BOOLEAN)) {
      ruleContext.throwWithRuleError(""String_Node_Str"" + ""String_Node_Str"");
    }
    ApplicationManifest resourcesManifest=ApplicationManifest.fromResourcesRule(ruleContext);
    if (resourcesManifest == null) {
      throw new RuleErrorException();
    }
    applicationManifest=resourcesManifest.mergeWith(ruleContext,resourceDeps);
    if (shouldRegenerate(ruleContext,resourceDeps)) {
      resourceApk=applicationManifest.packWithResources(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_APK),ruleContext,resourceDeps,true,ProguardHelper.getProguardConfigArtifact(ruleContext,""String_Node_Str""),createMainDexProguardSpec(ruleContext));
      ruleContext.assertNoErrors();
    }
 else {
      resourceApk=applicationManifest.useCurrentResources(ruleContext,ProguardHelper.getProguardConfigArtifact(ruleContext,""String_Node_Str""),createMainDexProguardSpec(ruleContext));
      ruleContext.assertNoErrors();
    }
    incrementalResourceApk=applicationManifest.addMobileInstallStubApplication(ruleContext).packWithResources(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_INCREMENTAL_RESOURCES_APK),ruleContext,resourceDeps,false,ProguardHelper.getProguardConfigArtifact(ruleContext,""String_Node_Str""),null);
    ruleContext.assertNoErrors();
    instantRunResourceApk=applicationManifest.addInstantRunStubApplication(ruleContext).packWithResources(getDxArtifact(ruleContext,""String_Node_Str""),ruleContext,resourceDeps,false,ProguardHelper.getProguardConfigArtifact(ruleContext,""String_Node_Str""),null);
    ruleContext.assertNoErrors();
    splitResourceApk=applicationManifest.createSplitManifest(ruleContext,""String_Node_Str"",false).packWithResources(getDxArtifact(ruleContext,""String_Node_Str""),ruleContext,resourceDeps,false,ProguardHelper.getProguardConfigArtifact(ruleContext,""String_Node_Str""),null);
    ruleContext.assertNoErrors();
  }
  boolean shrinkResources=shouldShrinkResources(ruleContext);
  JavaTargetAttributes resourceClasses=androidCommon.init(javaSemantics,androidSemantics,resourceApk,ruleContext.getConfiguration().isCodeCoverageEnabled(),true,true);
  ruleContext.assertNoErrors();
  Function<Artifact,Artifact> derivedJarFunction=collectDesugaredJars(ruleContext,androidCommon,androidSemantics,resourceClasses);
  Artifact deployJar=createDeployJar(ruleContext,javaSemantics,androidCommon,resourceClasses,derivedJarFunction);
  Artifact proguardMapping=ruleContext.getPrerequisiteArtifact(""String_Node_Str"",Mode.TARGET);
  return createAndroidBinary(ruleContext,filesBuilder,deployJar,derivedJarFunction,false,javaCommon,androidCommon,javaSemantics,androidSemantics,nativeLibs,applicationManifest,resourceApk,incrementalResourceApk,instantRunResourceApk,splitResourceApk,shrinkResources,resourceClasses,ImmutableList.<Artifact>of(),ImmutableList.<Artifact>of(),proguardMapping);
}","private static RuleConfiguredTargetBuilder init(RuleContext ruleContext,NestedSetBuilder<Artifact> filesBuilder,ResourceDependencies resourceDeps,JavaCommon javaCommon,AndroidCommon androidCommon,JavaSemantics javaSemantics,AndroidSemantics androidSemantics) throws InterruptedException, RuleErrorException {
  validateRuleContext(ruleContext);
  Multimap<String,TransitiveInfoCollection> depsByArchitecture=MultimapBuilder.treeKeys().arrayListValues().build();
  AndroidConfiguration androidConfig=ruleContext.getFragment(AndroidConfiguration.class);
  for (  Map.Entry<Optional<String>,? extends List<? extends TransitiveInfoCollection>> entry : ruleContext.getSplitPrerequisites(""String_Node_Str"").entrySet()) {
    String cpu=entry.getKey().or(androidConfig.getCpu());
    depsByArchitecture.putAll(cpu,entry.getValue());
  }
  Map<String,BuildConfiguration> configurationMap=new LinkedHashMap<>();
  Map<String,CcToolchainProvider> toolchainMap=new LinkedHashMap<>();
  for (  Map.Entry<Optional<String>,? extends List<? extends TransitiveInfoCollection>> entry : ruleContext.getSplitPrerequisites(""String_Node_Str"").entrySet()) {
    String cpu=entry.getKey().or(androidConfig.getCpu());
    TransitiveInfoCollection dep=Iterables.getOnlyElement(entry.getValue());
    CcToolchainProvider toolchain=CppHelper.getToolchain(ruleContext,dep);
    configurationMap.put(cpu,dep.getConfiguration());
    toolchainMap.put(cpu,toolchain);
  }
  NativeLibs nativeLibs=NativeLibs.fromLinkedNativeDeps(ruleContext,androidSemantics.getNativeDepsFileName(),depsByArchitecture,toolchainMap,configurationMap);
  ApplicationManifest applicationManifest;
  ResourceApk resourceApk;
  ResourceApk incrementalResourceApk;
  ResourceApk instantRunResourceApk;
  ResourceApk splitResourceApk;
  if (LocalResourceContainer.definesAndroidResources(ruleContext.attributes())) {
    LocalResourceContainer.validateRuleContext(ruleContext);
    ApplicationManifest ruleManifest=androidSemantics.getManifestForRule(ruleContext);
    applicationManifest=ruleManifest.mergeWith(ruleContext,resourceDeps);
    Artifact featureOfArtifact=ruleContext.attributes().isAttributeValueExplicitlySpecified(""String_Node_Str"") ? Iterables.getOnlyElement(ruleContext.getPrerequisite(""String_Node_Str"",Mode.TARGET,ApkProvider.class).getTransitiveApks()) : null;
    Artifact featureAfterArtifact=ruleContext.attributes().isAttributeValueExplicitlySpecified(""String_Node_Str"") ? Iterables.getOnlyElement(ruleContext.getPrerequisite(""String_Node_Str"",Mode.TARGET,ApkProvider.class).getTransitiveApks()) : null;
    resourceApk=applicationManifest.packWithDataAndResources(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_APK),ruleContext,false,resourceDeps,ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_R_TXT),null,ResourceFilter.fromRuleContext(ruleContext),ruleContext.getTokenizedStringListAttr(""String_Node_Str""),ruleContext.attributes().get(""String_Node_Str"",Type.BOOLEAN),false,ProguardHelper.getProguardConfigArtifact(ruleContext,""String_Node_Str""),createMainDexProguardSpec(ruleContext),ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_PROCESSED_MANIFEST),ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_ZIP),DataBinding.isEnabled(ruleContext) ? DataBinding.getLayoutInfoFile(ruleContext) : null,featureOfArtifact,featureAfterArtifact);
    ruleContext.assertNoErrors();
    incrementalResourceApk=applicationManifest.addMobileInstallStubApplication(ruleContext).packWithDataAndResources(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_INCREMENTAL_RESOURCES_APK),ruleContext,false,resourceDeps,null,null,ResourceFilter.fromRuleContext(ruleContext),ruleContext.getTokenizedStringListAttr(""String_Node_Str""),ruleContext.attributes().get(""String_Node_Str"",Type.BOOLEAN),true,ProguardHelper.getProguardConfigArtifact(ruleContext,""String_Node_Str""),null,null,null,null,null,null);
    ruleContext.assertNoErrors();
    instantRunResourceApk=applicationManifest.addInstantRunStubApplication(ruleContext).packWithDataAndResources(getDxArtifact(ruleContext,""String_Node_Str""),ruleContext,false,resourceDeps,null,null,ResourceFilter.fromRuleContext(ruleContext),ruleContext.getTokenizedStringListAttr(""String_Node_Str""),ruleContext.attributes().get(""String_Node_Str"",Type.BOOLEAN),true,ProguardHelper.getProguardConfigArtifact(ruleContext,""String_Node_Str""),null,null,null,null,null,null);
    ruleContext.assertNoErrors();
    splitResourceApk=applicationManifest.createSplitManifest(ruleContext,""String_Node_Str"",false).packWithDataAndResources(getDxArtifact(ruleContext,""String_Node_Str""),ruleContext,false,resourceDeps,null,null,ResourceFilter.fromRuleContext(ruleContext),ruleContext.getTokenizedStringListAttr(""String_Node_Str""),ruleContext.attributes().get(""String_Node_Str"",Type.BOOLEAN),true,ProguardHelper.getProguardConfigArtifact(ruleContext,""String_Node_Str""),null,null,null,null,null,null);
    ruleContext.assertNoErrors();
  }
 else {
    if (!ruleContext.attributes().get(""String_Node_Str"",Type.BOOLEAN)) {
      ruleContext.throwWithRuleError(""String_Node_Str"" + ""String_Node_Str"");
    }
    ApplicationManifest resourcesManifest=ApplicationManifest.fromResourcesRule(ruleContext);
    if (resourcesManifest == null) {
      throw new RuleErrorException();
    }
    applicationManifest=resourcesManifest.mergeWith(ruleContext,resourceDeps);
    if (shouldRegenerate(ruleContext,resourceDeps)) {
      resourceApk=applicationManifest.packWithResources(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_APK),ruleContext,resourceDeps,true,ProguardHelper.getProguardConfigArtifact(ruleContext,""String_Node_Str""),createMainDexProguardSpec(ruleContext));
      ruleContext.assertNoErrors();
    }
 else {
      resourceApk=applicationManifest.useCurrentResources(ruleContext,ProguardHelper.getProguardConfigArtifact(ruleContext,""String_Node_Str""),createMainDexProguardSpec(ruleContext));
      ruleContext.assertNoErrors();
    }
    incrementalResourceApk=applicationManifest.addMobileInstallStubApplication(ruleContext).packWithResources(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_INCREMENTAL_RESOURCES_APK),ruleContext,resourceDeps,false,ProguardHelper.getProguardConfigArtifact(ruleContext,""String_Node_Str""),null);
    ruleContext.assertNoErrors();
    instantRunResourceApk=applicationManifest.addInstantRunStubApplication(ruleContext).packWithResources(getDxArtifact(ruleContext,""String_Node_Str""),ruleContext,resourceDeps,false,ProguardHelper.getProguardConfigArtifact(ruleContext,""String_Node_Str""),null);
    ruleContext.assertNoErrors();
    splitResourceApk=applicationManifest.createSplitManifest(ruleContext,""String_Node_Str"",false).packWithResources(getDxArtifact(ruleContext,""String_Node_Str""),ruleContext,resourceDeps,false,ProguardHelper.getProguardConfigArtifact(ruleContext,""String_Node_Str""),null);
    ruleContext.assertNoErrors();
  }
  boolean shrinkResources=shouldShrinkResources(ruleContext);
  JavaTargetAttributes resourceClasses=androidCommon.init(javaSemantics,androidSemantics,resourceApk,ruleContext.getConfiguration().isCodeCoverageEnabled(),true,true);
  ruleContext.assertNoErrors();
  Function<Artifact,Artifact> derivedJarFunction=collectDesugaredJars(ruleContext,androidCommon,androidSemantics,resourceClasses);
  Artifact deployJar=createDeployJar(ruleContext,javaSemantics,androidCommon,resourceClasses,derivedJarFunction);
  Artifact proguardMapping=ruleContext.getPrerequisiteArtifact(""String_Node_Str"",Mode.TARGET);
  return createAndroidBinary(ruleContext,filesBuilder,deployJar,derivedJarFunction,false,javaCommon,androidCommon,javaSemantics,androidSemantics,nativeLibs,applicationManifest,resourceApk,incrementalResourceApk,instantRunResourceApk,splitResourceApk,shrinkResources,resourceClasses,ImmutableList.<Artifact>of(),ImmutableList.<Artifact>of(),proguardMapping);
}",0.9824431256181998
110782,"@Override public RuleClass build(RuleClass.Builder builder,final RuleDefinitionEnvironment env){
  return builder.add(attr(""String_Node_Str"",STRING).allowedValues(new AllowedValueSet(AndroidManifestMerger.getAttributeValues())).value(AndroidManifestMerger.getRuleAttributeDefault())).add(attr(""String_Node_Str"",STRING_DICT)).add(attr(""String_Node_Str"",STRING_LIST)).add(attr(""String_Node_Str"",BOOLEAN).value(true)).add(attr(ResourceConfigurationFilter.ATTR_NAME,STRING_LIST)).add(attr(""String_Node_Str"",TRISTATE).value(TriState.AUTO)).add(attr(""String_Node_Str"",STRING_LIST)).add(attr(""String_Node_Str"",LABEL).cfg(HOST).exec().value(env.getToolsLabel(AndroidRuleClasses.MANIFEST_MERGE_TOOL_LABEL))).removeAttribute(""String_Node_Str"").build();
}","@Override public RuleClass build(RuleClass.Builder builder,final RuleDefinitionEnvironment env){
  return builder.add(attr(""String_Node_Str"",STRING).allowedValues(new AllowedValueSet(AndroidManifestMerger.getAttributeValues())).value(AndroidManifestMerger.getRuleAttributeDefault())).add(attr(""String_Node_Str"",STRING_DICT)).add(attr(""String_Node_Str"",STRING_LIST)).add(attr(""String_Node_Str"",BOOLEAN).value(true)).add(attr(ResourceFilter.RESOURCE_CONFIGURATION_FILTERS_NAME,STRING_LIST)).add(attr(""String_Node_Str"",TRISTATE).value(TriState.AUTO)).add(attr(ResourceFilter.DENSITIES_NAME,STRING_LIST)).add(attr(""String_Node_Str"",LABEL).cfg(HOST).exec().value(env.getToolsLabel(AndroidRuleClasses.MANIFEST_MERGE_TOOL_LABEL))).removeAttribute(""String_Node_Str"").build();
}",0.9319233311302048
110783,"@Override public ConfiguredTarget create(RuleContext ruleContext) throws InterruptedException, RuleErrorException {
  validateRuleContext(ruleContext);
  JavaSemantics javaSemantics=createJavaSemantics();
  AndroidSemantics androidSemantics=createAndroidSemantics();
  if (!AndroidSdkProvider.verifyPresence(ruleContext)) {
    return null;
  }
  checkResourceInlining(ruleContext);
  NestedSetBuilder<Aar> transitiveAars=collectTransitiveAars(ruleContext);
  NestedSetBuilder<Artifact> proguardConfigsbuilder=NestedSetBuilder.stableOrder();
  proguardConfigsbuilder.addTransitive(new ProguardLibrary(ruleContext).collectProguardSpecs());
  AndroidIdlHelper.maybeAddSupportLibProguardConfigs(ruleContext,proguardConfigsbuilder);
  NestedSet<Artifact> transitiveProguardConfigs=proguardConfigsbuilder.build();
  JavaCommon javaCommon=AndroidCommon.createJavaCommonWithAndroidDataBinding(ruleContext,javaSemantics,true);
  javaSemantics.checkRule(ruleContext,javaCommon);
  AndroidCommon androidCommon=new AndroidCommon(javaCommon);
  boolean definesLocalResources=LocalResourceContainer.definesAndroidResources(ruleContext.attributes());
  if (definesLocalResources) {
    LocalResourceContainer.validateRuleContext(ruleContext);
  }
  final ResourceApk resourceApk;
  if (definesLocalResources) {
    ApplicationManifest applicationManifest=androidSemantics.getManifestForRule(ruleContext).renamePackage(ruleContext,AndroidCommon.getJavaPackage(ruleContext));
    resourceApk=applicationManifest.packWithDataAndResources(null,ruleContext,true,ResourceDependencies.fromRuleDeps(ruleContext,JavaCommon.isNeverLink(ruleContext)),ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_R_TXT),ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_MERGED_SYMBOLS),ResourceConfigurationFilter.empty(ruleContext),ImmutableList.<String>of(),false,ImmutableList.<String>of(),false,null,null,ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_PROCESSED_MANIFEST),ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_ZIP),DataBinding.isEnabled(ruleContext) ? DataBinding.getLayoutInfoFile(ruleContext) : null,null,null);
    if (ruleContext.hasErrors()) {
      return null;
    }
  }
 else {
    resourceApk=ResourceApk.fromTransitiveResources(ResourceDependencies.fromRuleResourceAndDeps(ruleContext,false));
  }
  if (!ruleContext.getFragment(AndroidConfiguration.class).allowSrcsLessAndroidLibraryDeps() && !definesLocalResources && ruleContext.attributes().get(""String_Node_Str"",BuildType.LABEL_LIST).isEmpty()&& ruleContext.attributes().get(""String_Node_Str"",BuildType.LABEL_LIST).isEmpty()&& !ruleContext.attributes().get(""String_Node_Str"",BuildType.LABEL_LIST).isEmpty()) {
    ruleContext.attributeError(""String_Node_Str"",""String_Node_Str"");
  }
  JavaTargetAttributes javaTargetAttributes=androidCommon.init(javaSemantics,androidSemantics,resourceApk,false,true,false);
  if (javaTargetAttributes == null) {
    return null;
  }
  Artifact classesJar=ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_LIBRARY_CLASS_JAR);
  Artifact aarOut=ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_LIBRARY_AAR);
  final ResourceContainer primaryResources;
  final Aar aar;
  if (definesLocalResources) {
    primaryResources=resourceApk.getPrimaryResource();
    ApplicationManifest applicationManifest=androidSemantics.getManifestForRule(ruleContext);
    aar=Aar.create(aarOut,applicationManifest.getManifest());
    transitiveAars.add(aar);
  }
 else   if (AndroidCommon.getAndroidResources(ruleContext) != null) {
    primaryResources=Iterables.getOnlyElement(AndroidCommon.getAndroidResources(ruleContext).getDirectAndroidResources());
    aar=Aar.create(aarOut,primaryResources.getManifest());
    transitiveAars.add(aar);
  }
 else {
    aar=null;
    ApplicationManifest applicationManifest=ApplicationManifest.generatedManifest(ruleContext).renamePackage(ruleContext,AndroidCommon.getJavaPackage(ruleContext));
    String javaPackage=AndroidCommon.getJavaPackage(ruleContext);
    ResourceContainer resourceContainer=ResourceContainer.builder().setLabel(ruleContext.getLabel()).setJavaPackageFromString(javaPackage).setManifest(applicationManifest.getManifest()).setJavaSourceJar(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_JAVA_SOURCE_JAR)).setManifestExported(ruleContext.attributes().get(""String_Node_Str"",Type.BOOLEAN)).setRTxt(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_R_TXT)).build();
    primaryResources=new AndroidResourcesProcessorBuilder(ruleContext).setLibrary(true).setRTxtOut(resourceContainer.getRTxt()).setManifestOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_PROCESSED_MANIFEST)).setSourceJarOut(resourceContainer.getJavaSourceJar()).setJavaPackage(resourceContainer.getJavaPackage()).withPrimary(resourceContainer).withDependencies(resourceApk.getResourceDependencies()).setDebug(ruleContext.getConfiguration().getCompilationMode() != CompilationMode.OPT).build(ruleContext);
  }
  new AarGeneratorBuilder(ruleContext).withPrimary(primaryResources).withManifest(aar != null ? aar.getManifest() : primaryResources.getManifest()).withRtxt(primaryResources.getRTxt()).withClasses(classesJar).setAAROut(aarOut).build(ruleContext);
  RuleConfiguredTargetBuilder builder=new RuleConfiguredTargetBuilder(ruleContext);
  androidCommon.addTransitiveInfoProviders(builder,androidSemantics,aarOut,resourceApk,null,ImmutableList.<Artifact>of());
  androidSemantics.addTransitiveInfoProviders(builder,ruleContext,javaCommon,androidCommon,null);
  NestedSetBuilder<Artifact> transitiveResourcesJars=collectTransitiveResourceJars(ruleContext);
  if (androidCommon.getResourceClassJar() != null) {
    transitiveResourcesJars.add(androidCommon.getResourceClassJar());
  }
  builder.addProvider(NativeLibsZipsProvider.class,new NativeLibsZipsProvider(AndroidCommon.collectTransitiveNativeLibsZips(ruleContext).build())).add(JavaNeverlinkInfoProvider.class,new JavaNeverlinkInfoProvider(androidCommon.isNeverLink())).add(JavaSourceInfoProvider.class,JavaSourceInfoProvider.fromJavaTargetAttributes(javaTargetAttributes,javaSemantics)).add(AndroidCcLinkParamsProvider.class,AndroidCcLinkParamsProvider.create(androidCommon.getCcLinkParamsStore())).add(JavaPluginInfoProvider.class,JavaCommon.getTransitivePlugins(ruleContext)).add(ProguardSpecProvider.class,new ProguardSpecProvider(transitiveProguardConfigs)).addOutputGroup(OutputGroupProvider.HIDDEN_TOP_LEVEL,transitiveProguardConfigs).add(AndroidLibraryResourceClassJarProvider.class,AndroidLibraryResourceClassJarProvider.create(transitiveResourcesJars.build()));
  if (!JavaCommon.isNeverLink(ruleContext)) {
    builder.add(AndroidLibraryAarProvider.class,AndroidLibraryAarProvider.create(aar,transitiveAars.build()));
  }
  return builder.build();
}","@Override public ConfiguredTarget create(RuleContext ruleContext) throws InterruptedException, RuleErrorException {
  validateRuleContext(ruleContext);
  JavaSemantics javaSemantics=createJavaSemantics();
  AndroidSemantics androidSemantics=createAndroidSemantics();
  if (!AndroidSdkProvider.verifyPresence(ruleContext)) {
    return null;
  }
  checkResourceInlining(ruleContext);
  NestedSetBuilder<Aar> transitiveAars=collectTransitiveAars(ruleContext);
  NestedSetBuilder<Artifact> proguardConfigsbuilder=NestedSetBuilder.stableOrder();
  proguardConfigsbuilder.addTransitive(new ProguardLibrary(ruleContext).collectProguardSpecs());
  AndroidIdlHelper.maybeAddSupportLibProguardConfigs(ruleContext,proguardConfigsbuilder);
  NestedSet<Artifact> transitiveProguardConfigs=proguardConfigsbuilder.build();
  JavaCommon javaCommon=AndroidCommon.createJavaCommonWithAndroidDataBinding(ruleContext,javaSemantics,true);
  javaSemantics.checkRule(ruleContext,javaCommon);
  AndroidCommon androidCommon=new AndroidCommon(javaCommon);
  boolean definesLocalResources=LocalResourceContainer.definesAndroidResources(ruleContext.attributes());
  if (definesLocalResources) {
    LocalResourceContainer.validateRuleContext(ruleContext);
  }
  final ResourceApk resourceApk;
  if (definesLocalResources) {
    ApplicationManifest applicationManifest=androidSemantics.getManifestForRule(ruleContext).renamePackage(ruleContext,AndroidCommon.getJavaPackage(ruleContext));
    resourceApk=applicationManifest.packWithDataAndResources(null,ruleContext,true,ResourceDependencies.fromRuleDeps(ruleContext,JavaCommon.isNeverLink(ruleContext)),ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_R_TXT),ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_MERGED_SYMBOLS),ResourceFilter.empty(ruleContext),ImmutableList.<String>of(),false,false,null,null,ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_PROCESSED_MANIFEST),ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_ZIP),DataBinding.isEnabled(ruleContext) ? DataBinding.getLayoutInfoFile(ruleContext) : null,null,null);
    if (ruleContext.hasErrors()) {
      return null;
    }
  }
 else {
    resourceApk=ResourceApk.fromTransitiveResources(ResourceDependencies.fromRuleResourceAndDeps(ruleContext,false));
  }
  if (!ruleContext.getFragment(AndroidConfiguration.class).allowSrcsLessAndroidLibraryDeps() && !definesLocalResources && ruleContext.attributes().get(""String_Node_Str"",BuildType.LABEL_LIST).isEmpty()&& ruleContext.attributes().get(""String_Node_Str"",BuildType.LABEL_LIST).isEmpty()&& !ruleContext.attributes().get(""String_Node_Str"",BuildType.LABEL_LIST).isEmpty()) {
    ruleContext.attributeError(""String_Node_Str"",""String_Node_Str"");
  }
  JavaTargetAttributes javaTargetAttributes=androidCommon.init(javaSemantics,androidSemantics,resourceApk,false,true,false);
  if (javaTargetAttributes == null) {
    return null;
  }
  Artifact classesJar=ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_LIBRARY_CLASS_JAR);
  Artifact aarOut=ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_LIBRARY_AAR);
  final ResourceContainer primaryResources;
  final Aar aar;
  if (definesLocalResources) {
    primaryResources=resourceApk.getPrimaryResource();
    ApplicationManifest applicationManifest=androidSemantics.getManifestForRule(ruleContext);
    aar=Aar.create(aarOut,applicationManifest.getManifest());
    transitiveAars.add(aar);
  }
 else   if (AndroidCommon.getAndroidResources(ruleContext) != null) {
    primaryResources=Iterables.getOnlyElement(AndroidCommon.getAndroidResources(ruleContext).getDirectAndroidResources());
    aar=Aar.create(aarOut,primaryResources.getManifest());
    transitiveAars.add(aar);
  }
 else {
    aar=null;
    ApplicationManifest applicationManifest=ApplicationManifest.generatedManifest(ruleContext).renamePackage(ruleContext,AndroidCommon.getJavaPackage(ruleContext));
    String javaPackage=AndroidCommon.getJavaPackage(ruleContext);
    ResourceContainer resourceContainer=ResourceContainer.builder().setLabel(ruleContext.getLabel()).setJavaPackageFromString(javaPackage).setManifest(applicationManifest.getManifest()).setJavaSourceJar(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_JAVA_SOURCE_JAR)).setManifestExported(ruleContext.attributes().get(""String_Node_Str"",Type.BOOLEAN)).setRTxt(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_R_TXT)).build();
    primaryResources=new AndroidResourcesProcessorBuilder(ruleContext).setLibrary(true).setRTxtOut(resourceContainer.getRTxt()).setManifestOut(ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_PROCESSED_MANIFEST)).setSourceJarOut(resourceContainer.getJavaSourceJar()).setJavaPackage(resourceContainer.getJavaPackage()).withPrimary(resourceContainer).withDependencies(resourceApk.getResourceDependencies()).setDebug(ruleContext.getConfiguration().getCompilationMode() != CompilationMode.OPT).build(ruleContext);
  }
  new AarGeneratorBuilder(ruleContext).withPrimary(primaryResources).withManifest(aar != null ? aar.getManifest() : primaryResources.getManifest()).withRtxt(primaryResources.getRTxt()).withClasses(classesJar).setAAROut(aarOut).build(ruleContext);
  RuleConfiguredTargetBuilder builder=new RuleConfiguredTargetBuilder(ruleContext);
  androidCommon.addTransitiveInfoProviders(builder,androidSemantics,aarOut,resourceApk,null,ImmutableList.<Artifact>of());
  androidSemantics.addTransitiveInfoProviders(builder,ruleContext,javaCommon,androidCommon,null);
  NestedSetBuilder<Artifact> transitiveResourcesJars=collectTransitiveResourceJars(ruleContext);
  if (androidCommon.getResourceClassJar() != null) {
    transitiveResourcesJars.add(androidCommon.getResourceClassJar());
  }
  builder.addProvider(NativeLibsZipsProvider.class,new NativeLibsZipsProvider(AndroidCommon.collectTransitiveNativeLibsZips(ruleContext).build())).add(JavaNeverlinkInfoProvider.class,new JavaNeverlinkInfoProvider(androidCommon.isNeverLink())).add(JavaSourceInfoProvider.class,JavaSourceInfoProvider.fromJavaTargetAttributes(javaTargetAttributes,javaSemantics)).add(AndroidCcLinkParamsProvider.class,AndroidCcLinkParamsProvider.create(androidCommon.getCcLinkParamsStore())).add(JavaPluginInfoProvider.class,JavaCommon.getTransitivePlugins(ruleContext)).add(ProguardSpecProvider.class,new ProguardSpecProvider(transitiveProguardConfigs)).addOutputGroup(OutputGroupProvider.HIDDEN_TOP_LEVEL,transitiveProguardConfigs).add(AndroidLibraryResourceClassJarProvider.class,AndroidLibraryResourceClassJarProvider.create(transitiveResourcesJars.build()));
  if (!JavaCommon.isNeverLink(ruleContext)) {
    builder.add(AndroidLibraryAarProvider.class,AndroidLibraryAarProvider.create(aar,transitiveAars.build()));
  }
  return builder.build();
}",0.997075595847346
110784,"/** 
 * @param ruleContext The RuleContext that was used to create the SpawnAction.Builder.
 */
public AndroidResourcesProcessorBuilder(RuleContext ruleContext){
  this.sdk=AndroidSdkProvider.fromRuleContext(ruleContext);
  this.ruleContext=ruleContext;
  this.spawnActionBuilder=new SpawnAction.Builder();
  this.resourceConfigs=ResourceConfigurationFilter.empty(ruleContext);
}","/** 
 * @param ruleContext The RuleContext that was used to create the SpawnAction.Builder.
 */
public AndroidResourcesProcessorBuilder(RuleContext ruleContext){
  this.sdk=AndroidSdkProvider.fromRuleContext(ruleContext);
  this.ruleContext=ruleContext;
  this.spawnActionBuilder=new SpawnAction.Builder();
  this.resourceFilter=ResourceFilter.empty(ruleContext);
}",0.9650537634408602
110785,"public ResourceContainer build(ActionConstructionContext context){
  List<Artifact> outs=new ArrayList<>();
  CustomCommandLine.Builder builder=new CustomCommandLine.Builder();
  builder.add(""String_Node_Str"").add(""String_Node_Str"").add(""String_Node_Str"");
  if (!Strings.isNullOrEmpty(sdk.getBuildToolsVersion())) {
    builder.add(""String_Node_Str"").add(sdk.getBuildToolsVersion());
  }
  builder.addExecPath(""String_Node_Str"",sdk.getAapt().getExecutable());
  NestedSetBuilder<Artifact> inputs=NestedSetBuilder.naiveLinkOrder();
  inputs.addAll(ruleContext.getExecutablePrerequisite(""String_Node_Str"",Mode.HOST).getRunfilesSupport().getRunfilesArtifactsWithoutMiddlemen());
  builder.addExecPath(""String_Node_Str"",sdk.getAnnotationsJar());
  inputs.add(sdk.getAnnotationsJar());
  builder.addExecPath(""String_Node_Str"",sdk.getAndroidJar());
  inputs.add(sdk.getAndroidJar());
  builder.add(""String_Node_Str"").add(RESOURCE_CONTAINER_TO_ARG.apply(primary));
  inputs.addTransitive(RESOURCE_CONTAINER_TO_ARTIFACTS.apply(primary));
  ResourceContainerConverter.convertDependencies(dependencies,builder,inputs,RESOURCE_DEP_TO_ARG,RESOURCE_DEP_TO_ARTIFACTS);
  if (isLibrary) {
    builder.add(""String_Node_Str"").add(""String_Node_Str"");
  }
  if (rTxtOut != null) {
    builder.addExecPath(""String_Node_Str"",rTxtOut);
    outs.add(rTxtOut);
  }
  if (symbols != null) {
    builder.addExecPath(""String_Node_Str"",symbols);
    outs.add(symbols);
  }
  if (sourceJarOut != null) {
    builder.addExecPath(""String_Node_Str"",sourceJarOut);
    outs.add(sourceJarOut);
  }
  if (proguardOut != null) {
    builder.addExecPath(""String_Node_Str"",proguardOut);
    outs.add(proguardOut);
  }
  if (mainDexProguardOut != null) {
    builder.addExecPath(""String_Node_Str"",mainDexProguardOut);
    outs.add(mainDexProguardOut);
  }
  if (manifestOut != null) {
    builder.addExecPath(""String_Node_Str"",manifestOut);
    outs.add(manifestOut);
  }
  if (mergedResourcesOut != null) {
    builder.addExecPath(""String_Node_Str"",mergedResourcesOut);
    outs.add(mergedResourcesOut);
  }
  if (apkOut != null) {
    builder.addExecPath(""String_Node_Str"",apkOut);
    outs.add(apkOut);
  }
  if (!resourceConfigs.isEmpty()) {
    builder.add(""String_Node_Str"").add(resourceConfigs.getFilterString());
  }
  if (!densities.isEmpty()) {
    builder.addJoinStrings(""String_Node_Str"",""String_Node_Str"",densities);
  }
  if (!uncompressedExtensions.isEmpty()) {
    builder.addJoinStrings(""String_Node_Str"",""String_Node_Str"",uncompressedExtensions);
  }
  if (!crunchPng) {
    builder.add(""String_Node_Str"");
  }
  if (!assetsToIgnore.isEmpty()) {
    builder.addJoinStrings(""String_Node_Str"",""String_Node_Str"",assetsToIgnore);
  }
  if (debug) {
    builder.add(""String_Node_Str"");
  }
  if (versionCode != null) {
    builder.add(""String_Node_Str"").add(versionCode);
  }
  if (versionName != null) {
    builder.add(""String_Node_Str"").add(versionName);
  }
  if (applicationId != null) {
    builder.add(""String_Node_Str"").add(applicationId);
  }
  if (dataBindingInfoZip != null) {
    builder.addExecPath(""String_Node_Str"",dataBindingInfoZip);
    outs.add(dataBindingInfoZip);
  }
  if (!Strings.isNullOrEmpty(customJavaPackage)) {
    builder.add(""String_Node_Str"").add(customJavaPackage);
  }
  if (featureOf != null) {
    builder.addExecPath(""String_Node_Str"",featureOf);
    inputs.add(featureOf);
  }
  if (featureAfter != null) {
    builder.addExecPath(""String_Node_Str"",featureAfter);
    inputs.add(featureAfter);
  }
  ruleContext.registerAction(this.spawnActionBuilder.useParameterFile(ParameterFileType.UNQUOTED).addTool(sdk.getAapt()).addTransitiveInputs(inputs.build()).addOutputs(ImmutableList.<Artifact>copyOf(outs)).setCommandLine(builder.build()).setExecutable(ruleContext.getExecutablePrerequisite(""String_Node_Str"",Mode.HOST)).setProgressMessage(""String_Node_Str"" + ruleContext.getLabel()).setMnemonic(""String_Node_Str"").build(context));
  ResourceContainer.Builder result=primary.toBuilder().setJavaSourceJar(sourceJarOut).setRTxt(rTxtOut).setSymbols(symbols);
  if (apkOut != null) {
    result.setApk(apkOut);
  }
  if (manifestOut != null) {
    result.setManifest(manifestOut);
  }
  return result.build();
}","public ResourceContainer build(ActionConstructionContext context){
  List<Artifact> outs=new ArrayList<>();
  CustomCommandLine.Builder builder=new CustomCommandLine.Builder();
  builder.add(""String_Node_Str"").add(""String_Node_Str"").add(""String_Node_Str"");
  if (!Strings.isNullOrEmpty(sdk.getBuildToolsVersion())) {
    builder.add(""String_Node_Str"").add(sdk.getBuildToolsVersion());
  }
  builder.addExecPath(""String_Node_Str"",sdk.getAapt().getExecutable());
  NestedSetBuilder<Artifact> inputs=NestedSetBuilder.naiveLinkOrder();
  inputs.addAll(ruleContext.getExecutablePrerequisite(""String_Node_Str"",Mode.HOST).getRunfilesSupport().getRunfilesArtifactsWithoutMiddlemen());
  builder.addExecPath(""String_Node_Str"",sdk.getAnnotationsJar());
  inputs.add(sdk.getAnnotationsJar());
  builder.addExecPath(""String_Node_Str"",sdk.getAndroidJar());
  inputs.add(sdk.getAndroidJar());
  builder.add(""String_Node_Str"").add(RESOURCE_CONTAINER_TO_ARG.apply(primary));
  inputs.addTransitive(RESOURCE_CONTAINER_TO_ARTIFACTS.apply(primary));
  ResourceContainerConverter.convertDependencies(dependencies,builder,inputs,RESOURCE_DEP_TO_ARG,RESOURCE_DEP_TO_ARTIFACTS);
  if (isLibrary) {
    builder.add(""String_Node_Str"").add(""String_Node_Str"");
  }
  if (rTxtOut != null) {
    builder.addExecPath(""String_Node_Str"",rTxtOut);
    outs.add(rTxtOut);
  }
  if (symbols != null) {
    builder.addExecPath(""String_Node_Str"",symbols);
    outs.add(symbols);
  }
  if (sourceJarOut != null) {
    builder.addExecPath(""String_Node_Str"",sourceJarOut);
    outs.add(sourceJarOut);
  }
  if (proguardOut != null) {
    builder.addExecPath(""String_Node_Str"",proguardOut);
    outs.add(proguardOut);
  }
  if (mainDexProguardOut != null) {
    builder.addExecPath(""String_Node_Str"",mainDexProguardOut);
    outs.add(mainDexProguardOut);
  }
  if (manifestOut != null) {
    builder.addExecPath(""String_Node_Str"",manifestOut);
    outs.add(manifestOut);
  }
  if (mergedResourcesOut != null) {
    builder.addExecPath(""String_Node_Str"",mergedResourcesOut);
    outs.add(mergedResourcesOut);
  }
  if (apkOut != null) {
    builder.addExecPath(""String_Node_Str"",apkOut);
    outs.add(apkOut);
  }
  if (resourceFilter.hasConfigurationFilters() && !resourceFilter.isPrefiltering()) {
    builder.add(""String_Node_Str"").add(resourceFilter.getConfigurationFilterString());
  }
  if (resourceFilter.hasDensities() && !resourceFilter.isPrefiltering()) {
    builder.add(""String_Node_Str"").add(resourceFilter.getDensityString());
  }
  ImmutableList<String> filteredResources=resourceFilter.getFilteredResources();
  if (!filteredResources.isEmpty()) {
    builder.addJoinStrings(""String_Node_Str"",""String_Node_Str"",filteredResources);
  }
  if (!uncompressedExtensions.isEmpty()) {
    builder.addJoinStrings(""String_Node_Str"",""String_Node_Str"",uncompressedExtensions);
  }
  if (!crunchPng) {
    builder.add(""String_Node_Str"");
  }
  if (!assetsToIgnore.isEmpty()) {
    builder.addJoinStrings(""String_Node_Str"",""String_Node_Str"",assetsToIgnore);
  }
  if (debug) {
    builder.add(""String_Node_Str"");
  }
  if (versionCode != null) {
    builder.add(""String_Node_Str"").add(versionCode);
  }
  if (versionName != null) {
    builder.add(""String_Node_Str"").add(versionName);
  }
  if (applicationId != null) {
    builder.add(""String_Node_Str"").add(applicationId);
  }
  if (dataBindingInfoZip != null) {
    builder.addExecPath(""String_Node_Str"",dataBindingInfoZip);
    outs.add(dataBindingInfoZip);
  }
  if (!Strings.isNullOrEmpty(customJavaPackage)) {
    builder.add(""String_Node_Str"").add(customJavaPackage);
  }
  if (featureOf != null) {
    builder.addExecPath(""String_Node_Str"",featureOf);
    inputs.add(featureOf);
  }
  if (featureAfter != null) {
    builder.addExecPath(""String_Node_Str"",featureAfter);
    inputs.add(featureAfter);
  }
  ruleContext.registerAction(this.spawnActionBuilder.useParameterFile(ParameterFileType.UNQUOTED).addTool(sdk.getAapt()).addTransitiveInputs(inputs.build()).addOutputs(ImmutableList.<Artifact>copyOf(outs)).setCommandLine(builder.build()).setExecutable(ruleContext.getExecutablePrerequisite(""String_Node_Str"",Mode.HOST)).setProgressMessage(""String_Node_Str"" + ruleContext.getLabel()).setMnemonic(""String_Node_Str"").build(context));
  ResourceContainer.Builder result=primary.toBuilder().setJavaSourceJar(sourceJarOut).setRTxt(rTxtOut).setSymbols(symbols);
  if (apkOut != null) {
    result.setApk(apkOut);
  }
  if (manifestOut != null) {
    result.setManifest(manifestOut);
  }
  return result.build();
}",0.9376929232879844
110786,"/** 
 * Packages up the manifest with resource and assets from the rule and dependent resources. 
 */
public ResourceApk packWithDataAndResources(@Nullable Artifact resourceApk,RuleContext ruleContext,boolean isLibrary,ResourceDependencies resourceDeps,Artifact rTxt,Artifact symbols,ResourceConfigurationFilter configurationFilters,List<String> uncompressedExtensions,boolean crunchPng,List<String> densities,boolean incremental,Artifact proguardCfg,@Nullable Artifact mainDexProguardCfg,Artifact manifestOut,Artifact mergedResources,Artifact dataBindingInfoZip,@Nullable Artifact featureOf,@Nullable Artifact featureAfter) throws InterruptedException {
  LocalResourceContainer data=new LocalResourceContainer.Builder(ruleContext).withAssets(AndroidCommon.getAssetDir(ruleContext),ruleContext.getPrerequisitesIf(ResourceType.ASSETS.getAttribute(),Mode.TARGET,FileProvider.class)).withResources(ruleContext.getPrerequisites(""String_Node_Str"",Mode.TARGET,FileProvider.class)).build();
  if (ruleContext.hasErrors()) {
    return null;
  }
  return createApk(ruleContext,isLibrary,resourceDeps,configurationFilters,uncompressedExtensions,crunchPng,densities,incremental,ResourceContainer.builderFromRule(ruleContext).setAssetsAndResourcesFrom(data).setManifest(getManifest()).setRTxt(rTxt).setSymbols(symbols).setApk(resourceApk).build(),data,proguardCfg,mainDexProguardCfg,manifestOut,mergedResources,dataBindingInfoZip,featureOf,featureAfter);
}","/** 
 * Packages up the manifest with resource and assets from the rule and dependent resources. 
 */
public ResourceApk packWithDataAndResources(@Nullable Artifact resourceApk,RuleContext ruleContext,boolean isLibrary,ResourceDependencies resourceDeps,Artifact rTxt,Artifact symbols,ResourceFilter resourceFilter,List<String> uncompressedExtensions,boolean crunchPng,boolean incremental,Artifact proguardCfg,@Nullable Artifact mainDexProguardCfg,Artifact manifestOut,Artifact mergedResources,Artifact dataBindingInfoZip,@Nullable Artifact featureOf,@Nullable Artifact featureAfter) throws InterruptedException {
  LocalResourceContainer data=new LocalResourceContainer.Builder(ruleContext).withAssets(AndroidCommon.getAssetDir(ruleContext),ruleContext.getPrerequisitesIf(ResourceType.ASSETS.getAttribute(),Mode.TARGET,FileProvider.class)).withResources(ruleContext.getPrerequisites(""String_Node_Str"",Mode.TARGET,FileProvider.class)).build();
  if (ruleContext.hasErrors()) {
    return null;
  }
  return createApk(ruleContext,isLibrary,resourceDeps,resourceFilter,uncompressedExtensions,crunchPng,incremental,ResourceContainer.builderFromRule(ruleContext).setAssetsAndResourcesFrom(data).setManifest(getManifest()).setRTxt(rTxt).setSymbols(symbols).setApk(resourceApk).build(),data,proguardCfg,mainDexProguardCfg,manifestOut,mergedResources,dataBindingInfoZip,featureOf,featureAfter);
}",0.968242766407904
110787,"/** 
 * Packages up the manifest with assets from the rule and dependent resources.
 * @throws InterruptedException 
 */
public ResourceApk packWithAssets(Artifact resourceApk,RuleContext ruleContext,ResourceDependencies resourceDeps,Artifact rTxt,boolean incremental,Artifact proguardCfg) throws InterruptedException {
  LocalResourceContainer data=new LocalResourceContainer.Builder(ruleContext).withAssets(AndroidCommon.getAssetDir(ruleContext),ruleContext.getPrerequisitesIf(ResourceType.ASSETS.getAttribute(),Mode.TARGET,FileProvider.class)).build();
  return createApk(ruleContext,false,resourceDeps,ResourceConfigurationFilter.empty(ruleContext),ImmutableList.<String>of(),true,ImmutableList.<String>of(),incremental,ResourceContainer.builderFromRule(ruleContext).setAssetsAndResourcesFrom(data).setManifest(getManifest()).setRTxt(rTxt).setApk(resourceApk).build(),data,proguardCfg,null,null,null,null,null,null);
}","/** 
 * Packages up the manifest with assets from the rule and dependent resources.
 * @throws InterruptedException 
 */
public ResourceApk packWithAssets(Artifact resourceApk,RuleContext ruleContext,ResourceDependencies resourceDeps,Artifact rTxt,boolean incremental,Artifact proguardCfg) throws InterruptedException {
  LocalResourceContainer data=new LocalResourceContainer.Builder(ruleContext).withAssets(AndroidCommon.getAssetDir(ruleContext),ruleContext.getPrerequisitesIf(ResourceType.ASSETS.getAttribute(),Mode.TARGET,FileProvider.class)).build();
  return createApk(ruleContext,false,resourceDeps,ResourceFilter.empty(ruleContext),ImmutableList.<String>of(),true,incremental,ResourceContainer.builderFromRule(ruleContext).setAssetsAndResourcesFrom(data).setManifest(getManifest()).setRTxt(rTxt).setApk(resourceApk).build(),data,proguardCfg,null,null,null,null,null,null);
}",0.9778270509977828
110788,"private ResourceApk createApk(RuleContext ruleContext,boolean isLibrary,ResourceDependencies resourceDeps,ResourceConfigurationFilter configurationFilters,List<String> uncompressedExtensions,boolean crunchPng,List<String> densities,boolean incremental,ResourceContainer maybeInlinedResourceContainer,LocalResourceContainer data,Artifact proguardCfg,@Nullable Artifact mainDexProguardCfg,Artifact manifestOut,Artifact mergedResources,Artifact dataBindingInfoZip,@Nullable Artifact featureOf,@Nullable Artifact featureAfter) throws InterruptedException {
  ResourceContainer resourceContainer=checkForInlinedResources(maybeInlinedResourceContainer,resourceDeps.getResources(),ruleContext);
  if (ruleContext.hasErrors()) {
    return null;
  }
  resourceContainer=resourceContainer.filter(configurationFilters);
  resourceDeps=resourceDeps.filter(configurationFilters);
  ResourceContainer processed;
  if (isLibrary && AndroidCommon.getAndroidConfig(ruleContext).useParallelResourceProcessing()) {
    Preconditions.checkArgument(!incremental);
    Artifact rJavaClassJar=ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_CLASS_JAR);
    ResourceContainer parsed=new AndroidResourceParsingActionBuilder(ruleContext).setParse(data).withPrimary(resourceContainer).setOutput(resourceContainer.getSymbols()).build(ruleContext);
    ResourceContainer generated=new LibraryRGeneratorActionBuilder().setJavaPackage(resourceContainer.getJavaPackage()).withPrimary(parsed).withDependencies(resourceDeps).setClassJarOut(rJavaClassJar).build(ruleContext);
    ResourceContainer merged=new AndroidResourceMergingActionBuilder(ruleContext).setJavaPackage(generated.getJavaPackage()).withPrimary(generated).withDependencies(resourceDeps).setMergedResourcesOut(mergedResources).setManifestOut(manifestOut).setDataBindingInfoZip(dataBindingInfoZip).build(ruleContext);
    processed=new AndroidResourceValidatorActionBuilder(ruleContext).setJavaPackage(merged.getJavaPackage()).setDebug(ruleContext.getConfiguration().getCompilationMode() != CompilationMode.OPT).setMergedResources(mergedResources).withPrimary(merged).setSourceJarOut(merged.getJavaSourceJar()).setRTxtOut(merged.getRTxt()).build(ruleContext);
  }
 else {
    AndroidResourcesProcessorBuilder builder=new AndroidResourcesProcessorBuilder(ruleContext).setLibrary(isLibrary).setApkOut(resourceContainer.getApk()).setConfigurationFilters(configurationFilters).setUncompressedExtensions(uncompressedExtensions).setCrunchPng(crunchPng).setJavaPackage(resourceContainer.getJavaPackage()).setDebug(ruleContext.getConfiguration().getCompilationMode() != CompilationMode.OPT).setManifestOut(manifestOut).setMergedResourcesOut(mergedResources).withPrimary(resourceContainer).withDependencies(resourceDeps).setDensities(densities).setProguardOut(proguardCfg).setMainDexProguardOut(mainDexProguardCfg).setDataBindingInfoZip(dataBindingInfoZip).setApplicationId(manifestValues.get(""String_Node_Str"")).setVersionCode(manifestValues.get(""String_Node_Str"")).setVersionName(manifestValues.get(""String_Node_Str""));
    builder.setFeatureOf(featureOf);
    builder.setFeatureAfter(featureAfter);
    if (!incremental) {
      builder.setRTxtOut(resourceContainer.getRTxt()).setSymbols(resourceContainer.getSymbols()).setSourceJarOut(resourceContainer.getJavaSourceJar());
    }
    processed=builder.build(ruleContext);
  }
  return new ResourceApk(resourceContainer.getApk(),processed.getJavaSourceJar(),processed.getJavaClassJar(),resourceDeps,processed,processed.getManifest(),proguardCfg,mainDexProguardCfg,false);
}","private ResourceApk createApk(RuleContext ruleContext,boolean isLibrary,ResourceDependencies resourceDeps,ResourceFilter resourceFilter,List<String> uncompressedExtensions,boolean crunchPng,boolean incremental,ResourceContainer maybeInlinedResourceContainer,LocalResourceContainer data,Artifact proguardCfg,@Nullable Artifact mainDexProguardCfg,Artifact manifestOut,Artifact mergedResources,Artifact dataBindingInfoZip,@Nullable Artifact featureOf,@Nullable Artifact featureAfter) throws InterruptedException {
  ResourceContainer resourceContainer=checkForInlinedResources(maybeInlinedResourceContainer,resourceDeps.getResources(),ruleContext);
  if (ruleContext.hasErrors()) {
    return null;
  }
  resourceContainer=resourceContainer.filter(resourceFilter);
  resourceDeps=resourceDeps.filter(resourceFilter);
  ResourceContainer processed;
  if (isLibrary && AndroidCommon.getAndroidConfig(ruleContext).useParallelResourceProcessing()) {
    Preconditions.checkArgument(!incremental);
    Artifact rJavaClassJar=ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_RESOURCES_CLASS_JAR);
    ResourceContainer parsed=new AndroidResourceParsingActionBuilder(ruleContext).setParse(data).withPrimary(resourceContainer).setOutput(resourceContainer.getSymbols()).build(ruleContext);
    ResourceContainer generated=new LibraryRGeneratorActionBuilder().setJavaPackage(resourceContainer.getJavaPackage()).withPrimary(parsed).withDependencies(resourceDeps).setClassJarOut(rJavaClassJar).build(ruleContext);
    ResourceContainer merged=new AndroidResourceMergingActionBuilder(ruleContext).setJavaPackage(generated.getJavaPackage()).withPrimary(generated).withDependencies(resourceDeps).setMergedResourcesOut(mergedResources).setManifestOut(manifestOut).setDataBindingInfoZip(dataBindingInfoZip).build(ruleContext);
    processed=new AndroidResourceValidatorActionBuilder(ruleContext).setJavaPackage(merged.getJavaPackage()).setDebug(ruleContext.getConfiguration().getCompilationMode() != CompilationMode.OPT).setMergedResources(mergedResources).withPrimary(merged).setSourceJarOut(merged.getJavaSourceJar()).setRTxtOut(merged.getRTxt()).build(ruleContext);
  }
 else {
    AndroidResourcesProcessorBuilder builder=new AndroidResourcesProcessorBuilder(ruleContext).setLibrary(isLibrary).setApkOut(resourceContainer.getApk()).setResourceFilter(resourceFilter).setUncompressedExtensions(uncompressedExtensions).setCrunchPng(crunchPng).setJavaPackage(resourceContainer.getJavaPackage()).setDebug(ruleContext.getConfiguration().getCompilationMode() != CompilationMode.OPT).setManifestOut(manifestOut).setMergedResourcesOut(mergedResources).withPrimary(resourceContainer).withDependencies(resourceDeps).setProguardOut(proguardCfg).setMainDexProguardOut(mainDexProguardCfg).setDataBindingInfoZip(dataBindingInfoZip).setApplicationId(manifestValues.get(""String_Node_Str"")).setVersionCode(manifestValues.get(""String_Node_Str"")).setVersionName(manifestValues.get(""String_Node_Str""));
    builder.setFeatureOf(featureOf);
    builder.setFeatureAfter(featureAfter);
    if (!incremental) {
      builder.setRTxtOut(resourceContainer.getRTxt()).setSymbols(resourceContainer.getSymbols()).setSourceJarOut(resourceContainer.getJavaSourceJar());
    }
    processed=builder.build(ruleContext);
  }
  return new ResourceApk(resourceContainer.getApk(),processed.getJavaSourceJar(),processed.getJavaClassJar(),resourceDeps,processed,processed.getManifest(),proguardCfg,mainDexProguardCfg,false);
}",0.9756442934013028
110789,"/** 
 * Packages up the manifest with resources, and generates the R.java.
 * @throws InterruptedException
 * @deprecated in favor of {@link ApplicationManifest#packWithDataAndResources}.
 */
@Deprecated public ResourceApk packWithResources(Artifact resourceApk,RuleContext ruleContext,ResourceDependencies resourceDeps,boolean createSource,Artifact proguardCfg,@Nullable Artifact mainDexProguardCfg) throws InterruptedException {
  TransitiveInfoCollection resourcesPrerequisite=ruleContext.getPrerequisite(""String_Node_Str"",Mode.TARGET);
  ResourceContainer resourceContainer=Iterables.getOnlyElement(resourcesPrerequisite.getProvider(AndroidResourcesProvider.class).getDirectAndroidResources());
  List<ResourceContainer> resourceContainers=ImmutableList.<ResourceContainer>builder().addAll(resourceDeps.getResources()).build();
  if (Iterables.size(resourceDeps.getResources()) > 1) {
    if (resourceContainer.getConstantsInlined() && !resourceContainer.getArtifacts(ResourceType.RESOURCES).isEmpty()) {
      ruleContext.ruleError(""String_Node_Str"" + ""String_Node_Str"" + AndroidCommon.getAndroidResources(ruleContext).getLabel() + ""String_Node_Str"");
      return null;
    }
  }
  AndroidAaptActionHelper aaptActionHelper=new AndroidAaptActionHelper(ruleContext,getManifest(),Lists.newArrayList(resourceContainers));
  String resourceConfigurationFilters=ResourceConfigurationFilter.extractFilters(ruleContext);
  List<String> uncompressedExtensions=ruleContext.getTokenizedStringListAttr(""String_Node_Str"");
  ImmutableList.Builder<String> additionalAaptOpts=ImmutableList.<String>builder();
  for (  String extension : uncompressedExtensions) {
    additionalAaptOpts.add(""String_Node_Str"").add(extension);
  }
  if (!resourceConfigurationFilters.isEmpty()) {
    additionalAaptOpts.add(""String_Node_Str"").add(resourceConfigurationFilters);
  }
  Artifact javaSourcesJar=null;
  if (createSource) {
    javaSourcesJar=ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_JAVA_SOURCE_JAR);
    aaptActionHelper.createGenerateResourceSymbolsAction(javaSourcesJar,null,resourceContainer.getJavaPackage(),true);
  }
  List<String> densities=ruleContext.getTokenizedStringListAttr(""String_Node_Str"");
  aaptActionHelper.createGenerateApkAction(resourceApk,resourceContainer.getRenameManifestPackage(),additionalAaptOpts.build(),densities);
  ResourceContainer updatedResources=resourceContainer.toBuilder().setLabel(ruleContext.getLabel()).setApk(resourceApk).setManifest(getManifest()).setJavaSourceJar(javaSourcesJar).setJavaClassJar(null).setSymbols(null).build();
  aaptActionHelper.createGenerateProguardAction(proguardCfg,mainDexProguardCfg);
  return new ResourceApk(resourceApk,updatedResources.getJavaSourceJar(),updatedResources.getJavaClassJar(),resourceDeps,updatedResources,manifest,proguardCfg,mainDexProguardCfg,true);
}","/** 
 * Packages up the manifest with resources, and generates the R.java.
 * @throws InterruptedException
 * @deprecated in favor of {@link ApplicationManifest#packWithDataAndResources}.
 */
@Deprecated public ResourceApk packWithResources(Artifact resourceApk,RuleContext ruleContext,ResourceDependencies resourceDeps,boolean createSource,Artifact proguardCfg,@Nullable Artifact mainDexProguardCfg) throws InterruptedException {
  TransitiveInfoCollection resourcesPrerequisite=ruleContext.getPrerequisite(""String_Node_Str"",Mode.TARGET);
  ResourceContainer resourceContainer=Iterables.getOnlyElement(resourcesPrerequisite.getProvider(AndroidResourcesProvider.class).getDirectAndroidResources());
  List<ResourceContainer> resourceContainers=ImmutableList.<ResourceContainer>builder().addAll(resourceDeps.getResources()).build();
  if (Iterables.size(resourceDeps.getResources()) > 1) {
    if (resourceContainer.getConstantsInlined() && !resourceContainer.getArtifacts(ResourceType.RESOURCES).isEmpty()) {
      ruleContext.ruleError(""String_Node_Str"" + ""String_Node_Str"" + AndroidCommon.getAndroidResources(ruleContext).getLabel() + ""String_Node_Str"");
      return null;
    }
  }
  AndroidAaptActionHelper aaptActionHelper=new AndroidAaptActionHelper(ruleContext,getManifest(),Lists.newArrayList(resourceContainers));
  ResourceFilter resourceFilter=ResourceFilter.fromRuleContext(ruleContext);
  List<String> uncompressedExtensions=ruleContext.getTokenizedStringListAttr(""String_Node_Str"");
  ImmutableList.Builder<String> additionalAaptOpts=ImmutableList.<String>builder();
  for (  String extension : uncompressedExtensions) {
    additionalAaptOpts.add(""String_Node_Str"").add(extension);
  }
  if (resourceFilter.hasConfigurationFilters() && !resourceFilter.isPrefiltering()) {
    additionalAaptOpts.add(""String_Node_Str"").add(resourceFilter.getConfigurationFilterString());
  }
  Artifact javaSourcesJar=null;
  if (createSource) {
    javaSourcesJar=ruleContext.getImplicitOutputArtifact(AndroidRuleClasses.ANDROID_JAVA_SOURCE_JAR);
    aaptActionHelper.createGenerateResourceSymbolsAction(javaSourcesJar,null,resourceContainer.getJavaPackage(),true);
  }
  aaptActionHelper.createGenerateApkAction(resourceApk,resourceContainer.getRenameManifestPackage(),additionalAaptOpts.build(),resourceFilter.getDensities());
  ResourceContainer updatedResources=resourceContainer.toBuilder().setLabel(ruleContext.getLabel()).setApk(resourceApk).setManifest(getManifest()).setJavaSourceJar(javaSourcesJar).setJavaClassJar(null).setSymbols(null).build();
  aaptActionHelper.createGenerateProguardAction(proguardCfg,mainDexProguardCfg);
  return new ResourceApk(resourceApk,updatedResources.getJavaSourceJar(),updatedResources.getJavaClassJar(),resourceDeps,updatedResources,manifest,proguardCfg,mainDexProguardCfg,true);
}",0.9407825167430384
110790,"private PathFragment checkForWorkspace(PathFragment path){
  sawWorkspaceName=sawWorkspaceName || path.getSegment(0).equals(workspaceName);
  return path;
}","private PathFragment checkForWorkspace(PathFragment path){
  sawWorkspaceName=sawWorkspaceName || path.getSegment(0).equals(workspaceName.getPathString());
  return path;
}",0.951219512195122
110791,"@Override public BuildOptions apply(BuildOptions buildOptions){
  BuildOptions result=buildOptions.clone();
  if (!appleCrosstoolTransitionIsAppliedForAllObjc(buildOptions)) {
    return buildOptions;
  }
  String cpu=String.format(""String_Node_Str"",buildOptions.get(AppleCommandLineOptions.class).applePlatformType,buildOptions.get(AppleCommandLineOptions.class).getSingleArchitecture());
  setAppleCrosstoolTransitionConfiguration(buildOptions,result,cpu);
  return result;
}","@Override public BuildOptions apply(BuildOptions buildOptions){
  BuildOptions result=buildOptions.clone();
  if (!appleCrosstoolTransitionIsAppliedForAllObjc(buildOptions)) {
    return buildOptions;
  }
  String cpu=Platform.cpuStringForTarget(buildOptions.get(AppleCommandLineOptions.class).applePlatformType,buildOptions.get(AppleCommandLineOptions.class).getSingleArchitecture());
  setAppleCrosstoolTransitionConfiguration(buildOptions,result,cpu);
  return result;
}",0.9494736842105264
110792,"private boolean runForConfigAndReturnLastIsIncremental(BuildGroupResult.Builder buildGroupResultBuilder,BuildCase buildCase,Path buildBinary,BuildEnvConfig envConfig,ImmutableList<BuildTargetConfig> buildTargetConfigs,int versionIndex,int envIndex,int targetIndex,boolean lastIsIncremental,boolean removeFirstResult) throws IOException, CommandException {
  BuildTargetConfig targetConfig=buildTargetConfigs.get(targetIndex);
  System.out.println(targetConfig.getDescription());
  if (lastIsIncremental && !envConfig.getIncremental()) {
    buildCase.prepareGeneratedCode(workspace.resolve(GENERATED_CODE_FOR_COPY_DIR),workspace.resolve(GENERATED_CODE_DIR));
  }
  if (!lastIsIncremental && envConfig.getIncremental()) {
    JavaCodeGenerator.modifyExistingProject(workspace.resolve(GENERATED_CODE_DIR).toString(),true,true,true,true);
  }
  lastIsIncremental=envConfig.getIncremental();
  if (removeFirstResult) {
    buildTargetAndGetElapsedTime(buildBinary,envConfig,targetConfig);
  }
  double elapsedTime=buildTargetAndGetElapsedTime(buildBinary,envConfig,targetConfig);
  buildGroupResultBuilder.getBuildTargetResultsBuilder(targetIndex).getBuildEnvResultsBuilder(envIndex).getResultsBuilder(versionIndex).addResults(elapsedTime);
  return lastIsIncremental;
}","private boolean runForConfigAndReturnLastIsIncremental(BuildGroupResult.Builder buildGroupResultBuilder,BuildCase buildCase,Path buildBinary,BuildEnvConfig envConfig,ImmutableList<BuildTargetConfig> buildTargetConfigs,int versionIndex,int envIndex,int targetIndex,boolean lastIsIncremental,boolean removeFirstResult) throws IOException, CommandException {
  BuildTargetConfig targetConfig=buildTargetConfigs.get(targetIndex);
  System.out.println(targetConfig.getDescription());
  if (lastIsIncremental && !envConfig.getIncremental()) {
    buildCase.prepareGeneratedCode(workspace.resolve(GENERATED_CODE_FOR_COPY_DIR),workspace.resolve(GENERATED_CODE_DIR));
  }
  if (!lastIsIncremental && envConfig.getIncremental()) {
    JavaCodeGenerator.modifyExistingProject(workspace.resolve(GENERATED_CODE_DIR).toString(),true,true,true,true);
  }
  lastIsIncremental=envConfig.getIncremental();
  if (targetIndex == 0 && envConfig.getCleanBeforeBuild()) {
    builder.clean();
  }
  if (removeFirstResult) {
    buildTargetAndGetElapsedTime(buildBinary,envConfig,targetConfig);
  }
  double elapsedTime=buildTargetAndGetElapsedTime(buildBinary,envConfig,targetConfig);
  buildGroupResultBuilder.getBuildTargetResultsBuilder(targetIndex).getBuildEnvResultsBuilder(envIndex).getResultsBuilder(versionIndex).addResults(elapsedTime);
  return lastIsIncremental;
}",0.9671504965622612
110793,"private double buildTargetAndGetElapsedTime(Path buildBinary,BuildEnvConfig envConfig,BuildTargetConfig targetConfig) throws CommandException {
  if (envConfig.getCleanBeforeBuild()) {
    builder.clean();
  }
  double elapsedTime=builder.buildAndGetElapsedTime(buildBinary,builder.getCommandFromConfig(targetConfig,envConfig));
  System.out.println(elapsedTime);
  return elapsedTime;
}","private double buildTargetAndGetElapsedTime(Path buildBinary,BuildEnvConfig envConfig,BuildTargetConfig targetConfig) throws CommandException {
  double elapsedTime=builder.buildAndGetElapsedTime(buildBinary,builder.getCommandFromConfig(targetConfig,envConfig));
  System.out.println(elapsedTime);
  return elapsedTime;
}",0.9067796610169492
110794,"@Override public Uniquifier<Target> createUniquifier(){
  return new AbstractUniquifier<Target,Label>(){
    @Override protected Label extractKey(    Target target){
      return target.getLabel();
    }
  }
;
}","@Override public Uniquifier<Target> createUniquifier(){
  return new UniquifierImpl<>(TargetKeyExtractor.INSTANCE);
}",0.5975609756097561
110795,"/** 
 * Calculates the set of   {@link Package} objects, represented as source file targets, that dependon the given list of BUILD files and subincludes (other files are filtered out).
 */
@ThreadSafe void getRBuildFiles(Collection<PathFragment> fileIdentifiers,Callback<Target> callback) throws QueryException, InterruptedException {
  Collection<SkyKey> files=getSkyKeysForFileFragments(fileIdentifiers);
  Uniquifier<SkyKey> keyUniquifier=new ThreadSafeSkyKeyUniquifier(1);
  Collection<SkyKey> current=keyUniquifier.unique(graph.getSuccessfulValues(files).keySet());
  Set<SkyKey> resultKeys=CompactHashSet.create();
  while (!current.isEmpty()) {
    Collection<Iterable<SkyKey>> reverseDeps=graph.getReverseDeps(current).values();
    current=new HashSet<>();
    for (    SkyKey rdep : Iterables.concat(reverseDeps)) {
      if (rdep.functionName().equals(SkyFunctions.PACKAGE)) {
        resultKeys.add(rdep);
        if (rdep.equals(PackageValue.key(Label.EXTERNAL_PACKAGE_IDENTIFIER))) {
          if (keyUniquifier.unique(rdep)) {
            current.add(rdep);
          }
        }
      }
 else       if (!rdep.functionName().equals(SkyFunctions.PACKAGE_LOOKUP)) {
        if (keyUniquifier.unique(rdep)) {
          current.add(rdep);
        }
      }
    }
    if (resultKeys.size() >= BATCH_CALLBACK_SIZE) {
      for (      Iterable<SkyKey> batch : Iterables.partition(resultKeys,BATCH_CALLBACK_SIZE)) {
        callback.process(getBuildFilesForPackageValues(graph.getSuccessfulValues(batch).values()));
      }
      resultKeys.clear();
    }
  }
  callback.process(getBuildFilesForPackageValues(graph.getSuccessfulValues(resultKeys).values()));
}","/** 
 * Calculates the set of   {@link Package} objects, represented as source file targets, that dependon the given list of BUILD files and subincludes (other files are filtered out).
 */
@ThreadSafe void getRBuildFiles(Collection<PathFragment> fileIdentifiers,Callback<Target> callback) throws QueryException, InterruptedException {
  Collection<SkyKey> files=getSkyKeysForFileFragments(fileIdentifiers);
  Uniquifier<SkyKey> keyUniquifier=new ThreadSafeUniquifierImpl<>(SkyKeyKeyExtractor.INSTANCE,1);
  Collection<SkyKey> current=keyUniquifier.unique(graph.getSuccessfulValues(files).keySet());
  Set<SkyKey> resultKeys=CompactHashSet.create();
  while (!current.isEmpty()) {
    Collection<Iterable<SkyKey>> reverseDeps=graph.getReverseDeps(current).values();
    current=new HashSet<>();
    for (    SkyKey rdep : Iterables.concat(reverseDeps)) {
      if (rdep.functionName().equals(SkyFunctions.PACKAGE)) {
        resultKeys.add(rdep);
        if (rdep.equals(PackageValue.key(Label.EXTERNAL_PACKAGE_IDENTIFIER))) {
          if (keyUniquifier.unique(rdep)) {
            current.add(rdep);
          }
        }
      }
 else       if (!rdep.functionName().equals(SkyFunctions.PACKAGE_LOOKUP)) {
        if (keyUniquifier.unique(rdep)) {
          current.add(rdep);
        }
      }
    }
    if (resultKeys.size() >= BATCH_CALLBACK_SIZE) {
      for (      Iterable<SkyKey> batch : Iterables.partition(resultKeys,BATCH_CALLBACK_SIZE)) {
        callback.process(getBuildFilesForPackageValues(graph.getSuccessfulValues(batch).values()));
      }
      resultKeys.clear();
    }
  }
  callback.process(getBuildFilesForPackageValues(graph.getSuccessfulValues(resultKeys).values()));
}",0.9875074360499704
110796,"@ThreadSafe ThreadSafeUniquifier<SkyKey> createSkyKeyUniquifier(){
  return new ThreadSafeSkyKeyUniquifier(DEFAULT_THREAD_COUNT);
}","@ThreadSafe ThreadSafeUniquifier<SkyKey> createSkyKeyUniquifier(){
  return new ThreadSafeUniquifierImpl<>(SkyKeyKeyExtractor.INSTANCE,DEFAULT_THREAD_COUNT);
}",0.8620689655172413
110797,"private BatchAllRdepsCallback(Uniquifier<Target> uniquifier,Predicate<Target> universe,Callback<Target> callback,int depth,int batchSize){
  this.uniquifier=uniquifier;
  this.universe=universe;
  this.callback=callback;
  this.depth=depth;
  this.batchSize=batchSize;
}","private BatchAllRdepsCallback(MinDepthUniquifier<Target> minDepthUniquifier,Predicate<Target> universe,Callback<Target> callback,int depth,int batchSize){
  this.minDepthUniquifier=minDepthUniquifier;
  this.universe=universe;
  this.callback=callback;
  this.depth=depth;
  this.batchSize=batchSize;
}",0.9335664335664337
110798,"/** 
 * Computes and applies the callback to the reverse dependencies of the expression. <p>Batch size is used to only populate at most N targets at one time, because some individual nodes are directly depended on by a large number of other nodes.
 */
@VisibleForTesting protected void getAllRdeps(QueryExpression expression,Predicate<Target> universe,VariableContext<Target> context,Callback<Target> callback,int depth,int batchSize) throws QueryException, InterruptedException {
  Uniquifier<Target> uniquifier=createUniquifier();
  eval(expression,context,new BatchAllRdepsCallback(uniquifier,universe,callback,depth,batchSize));
}","/** 
 * Computes and applies the callback to the reverse dependencies of the expression. <p>Batch size is used to only populate at most N targets at one time, because some individual nodes are directly depended on by a large number of other nodes.
 */
@VisibleForTesting protected void getAllRdeps(QueryExpression expression,Predicate<Target> universe,VariableContext<Target> context,Callback<Target> callback,int depth,int batchSize) throws QueryException, InterruptedException {
  MinDepthUniquifier<Target> minDepthUniquifier=createMinDepthUniquifier();
  eval(expression,context,new BatchAllRdepsCallback(minDepthUniquifier,universe,callback,depth,batchSize));
}",0.9723076923076924
110799,"@ThreadSafe ThreadSafeUniquifier<Pair<SkyKey,SkyKey>> createReverseDepSkyKeyUniquifier(){
  return new ThreadSafeReverseDepSkyKeyUniquifier(DEFAULT_THREAD_COUNT);
}","@ThreadSafe ThreadSafeUniquifier<Pair<SkyKey,SkyKey>> createReverseDepSkyKeyUniquifier(){
  return new ThreadSafeUniquifierImpl<>(ReverseDepSkyKeyKeyExtractor.INSTANCE,DEFAULT_THREAD_COUNT);
}",0.8707865168539326
110800,"@Override protected SkyKey extractKey(Pair<SkyKey,SkyKey> element){
  return element.second;
}","@Override public SkyKey extractKey(Pair<SkyKey,SkyKey> element){
  return element.second;
}",0.9405405405405406
110801,"@ThreadSafe ThreadSafeUniquifier<Target> createTargetUniquifier(){
  return new ThreadSafeTargetUniquifier(DEFAULT_THREAD_COUNT);
}","@ThreadSafe ThreadSafeUniquifier<Target> createTargetUniquifier(){
  return new ThreadSafeUniquifierImpl<>(TargetKeyExtractor.INSTANCE,DEFAULT_THREAD_COUNT);
}",0.8620689655172413
110802,"@Override public void process(Iterable<Target> targets) throws QueryException, InterruptedException {
  Iterable<Target> currentInUniverse=Iterables.filter(targets,universe);
  ImmutableList<Target> uniqueTargets=uniquifier.unique(currentInUniverse);
  callback.process(uniqueTargets);
  Queue<Map.Entry<SkyKey,Iterable<SkyKey>>> reverseDepsQueue=new LinkedList<>();
  reverseDepsQueue.addAll(graph.getReverseDeps(makeTransitiveTraversalKeys(uniqueTargets)).entrySet());
  for (int i=0; i < depth; i++) {
    Map<SkyKey,Iterable<SkyKey>> reverseDepsMap=Maps.newHashMap();
    int batch=0;
    int processed=0;
    int size=reverseDepsQueue.size();
    while (processed < size) {
      Map.Entry<SkyKey,Iterable<SkyKey>> entry=reverseDepsQueue.peek();
      int rdepsSize=Iterables.size(entry.getValue());
      if (rdepsSize == 0) {
        reverseDepsQueue.poll();
        processed++;
        continue;
      }
      if ((rdepsSize + batch <= batchSize)) {
        reverseDepsMap.put(entry.getKey(),entry.getValue());
        batch+=rdepsSize;
        reverseDepsQueue.poll();
        processed++;
      }
 else {
        if (batch == 0) {
          for (          Iterable<SkyKey> subList : Iterables.partition(entry.getValue(),batchSize)) {
            reverseDepsMap.put(entry.getKey(),subList);
            processReverseDepsMap(uniquifier,reverseDepsMap,callback,reverseDepsQueue);
          }
          reverseDepsQueue.poll();
          processed++;
        }
 else {
          processReverseDepsMap(uniquifier,reverseDepsMap,callback,reverseDepsQueue);
          batch=0;
        }
      }
    }
    if (!reverseDepsMap.isEmpty()) {
      processReverseDepsMap(uniquifier,reverseDepsMap,callback,reverseDepsQueue);
    }
    if (reverseDepsQueue.isEmpty()) {
      break;
    }
  }
}","@Override public void process(Iterable<Target> targets) throws QueryException, InterruptedException {
  Iterable<Target> currentInUniverse=Iterables.filter(targets,universe);
  ImmutableList<Target> uniqueTargets=minDepthUniquifier.uniqueAtDepthLessThanOrEqualTo(currentInUniverse,0);
  callback.process(uniqueTargets);
  Queue<Map.Entry<SkyKey,Iterable<SkyKey>>> reverseDepsQueue=new LinkedList<>();
  reverseDepsQueue.addAll(graph.getReverseDeps(makeTransitiveTraversalKeys(uniqueTargets)).entrySet());
  for (int curDepth=1; curDepth <= depth; curDepth++) {
    Map<SkyKey,Iterable<SkyKey>> reverseDepsMap=Maps.newHashMap();
    int batch=0;
    int processed=0;
    int size=reverseDepsQueue.size();
    while (processed < size) {
      Map.Entry<SkyKey,Iterable<SkyKey>> entry=reverseDepsQueue.peek();
      int rdepsSize=Iterables.size(entry.getValue());
      if (rdepsSize == 0) {
        reverseDepsQueue.poll();
        processed++;
        continue;
      }
      if ((rdepsSize + batch <= batchSize)) {
        reverseDepsMap.put(entry.getKey(),entry.getValue());
        batch+=rdepsSize;
        reverseDepsQueue.poll();
        processed++;
      }
 else {
        if (batch == 0) {
          for (          Iterable<SkyKey> subList : Iterables.partition(entry.getValue(),batchSize)) {
            reverseDepsMap.put(entry.getKey(),subList);
            processReverseDepsMap(minDepthUniquifier,reverseDepsMap,callback,reverseDepsQueue,curDepth);
          }
          reverseDepsQueue.poll();
          processed++;
        }
 else {
          processReverseDepsMap(minDepthUniquifier,reverseDepsMap,callback,reverseDepsQueue,curDepth);
          batch=0;
        }
      }
    }
    if (!reverseDepsMap.isEmpty()) {
      processReverseDepsMap(minDepthUniquifier,reverseDepsMap,callback,reverseDepsQueue,curDepth);
    }
    if (reverseDepsQueue.isEmpty()) {
      break;
    }
  }
}",0.9656106146764148
110803,"/** 
 * Populates   {@link Target}s from reverse dep mappings of   {@link SkyKey}s, empties the pending list and add next level reverse dep mappings of   {@link SkyKey}s to the queue.
 */
private void processReverseDepsMap(Uniquifier<Target> uniquifier,Map<SkyKey,Iterable<SkyKey>> reverseDepsMap,Callback<Target> callback,Queue<Map.Entry<SkyKey,Iterable<SkyKey>>> reverseDepsQueue) throws QueryException, InterruptedException {
  Collection<Target> children=processRawReverseDeps(targetifyValues(reverseDepsMap));
  Iterable<Target> currentInUniverse=Iterables.filter(children,universe);
  ImmutableList<Target> uniqueChildren=uniquifier.unique(currentInUniverse);
  reverseDepsMap.clear();
  if (!uniqueChildren.isEmpty()) {
    callback.process(uniqueChildren);
    reverseDepsQueue.addAll(graph.getReverseDeps(makeTransitiveTraversalKeys(uniqueChildren)).entrySet());
  }
}","/** 
 * Populates   {@link Target}s from reverse dep mappings of   {@link SkyKey}s, empties the pending list and add next level reverse dep mappings of   {@link SkyKey}s to the queue.
 */
private void processReverseDepsMap(MinDepthUniquifier<Target> minDepthUniquifier,Map<SkyKey,Iterable<SkyKey>> reverseDepsMap,Callback<Target> callback,Queue<Map.Entry<SkyKey,Iterable<SkyKey>>> reverseDepsQueue,int depth) throws QueryException, InterruptedException {
  Collection<Target> children=processRawReverseDeps(targetifyValues(reverseDepsMap));
  Iterable<Target> currentInUniverse=Iterables.filter(children,universe);
  ImmutableList<Target> uniqueChildren=minDepthUniquifier.uniqueAtDepthLessThanOrEqualTo(currentInUniverse,depth);
  reverseDepsMap.clear();
  if (!uniqueChildren.isEmpty()) {
    callback.process(uniqueChildren);
    reverseDepsQueue.addAll(graph.getReverseDeps(makeTransitiveTraversalKeys(uniqueChildren)).entrySet());
  }
}",0.9625962596259626
110804,"@Override public void process(Iterable<T> partialResult) throws QueryException, InterruptedException {
  Iterable<T> current=partialResult;
  for (int i=0; i <= depth; i++) {
    List<T> next=new ArrayList<>();
    Iterable<T> currentInUniverse=Iterables.filter(current,universe);
    next.addAll(env.getReverseDeps(uniquifier.unique(currentInUniverse)));
    callback.process(currentInUniverse);
    if (next.isEmpty()) {
      break;
    }
    current=next;
  }
}","@Override public void process(Iterable<T> partialResult) throws QueryException, InterruptedException {
  Iterable<T> current=partialResult;
  for (int i=0; i <= depth; i++) {
    List<T> next=new ArrayList<>();
    Iterable<T> currentInUniverse=Iterables.filter(current,universe);
    next.addAll(env.getReverseDeps(minDepthUniquifier.uniqueAtDepthLessThanOrEqualTo(currentInUniverse,i)));
    callback.process(currentInUniverse);
    if (next.isEmpty()) {
      break;
    }
    current=next;
  }
}",0.9626556016597512
110805,"protected <T>void eval(final QueryEnvironment<T> env,VariableContext<T> context,final List<Argument> args,final Callback<T> callback,final Predicate<T> universe) throws QueryException, InterruptedException {
  final int depth=args.size() > 1 ? args.get(1).getInteger() : Integer.MAX_VALUE;
  if (env instanceof StreamableQueryEnvironment<?>) {
    ((StreamableQueryEnvironment<T>)env).getAllRdeps(args.get(0).getExpression(),universe,context,callback,depth);
  }
 else {
    final Uniquifier<T> uniquifier=env.createUniquifier();
    env.eval(args.get(0).getExpression(),context,new Callback<T>(){
      @Override public void process(      Iterable<T> partialResult) throws QueryException, InterruptedException {
        Iterable<T> current=partialResult;
        for (int i=0; i <= depth; i++) {
          List<T> next=new ArrayList<>();
          Iterable<T> currentInUniverse=Iterables.filter(current,universe);
          next.addAll(env.getReverseDeps(uniquifier.unique(currentInUniverse)));
          callback.process(currentInUniverse);
          if (next.isEmpty()) {
            break;
          }
          current=next;
        }
      }
    }
);
  }
}","protected <T>void eval(final QueryEnvironment<T> env,VariableContext<T> context,final List<Argument> args,final Callback<T> callback,final Predicate<T> universe) throws QueryException, InterruptedException {
  final int depth=args.size() > 1 ? args.get(1).getInteger() : Integer.MAX_VALUE;
  if (env instanceof StreamableQueryEnvironment<?>) {
    ((StreamableQueryEnvironment<T>)env).getAllRdeps(args.get(0).getExpression(),universe,context,callback,depth);
  }
 else {
    final MinDepthUniquifier<T> minDepthUniquifier=env.createMinDepthUniquifier();
    env.eval(args.get(0).getExpression(),context,new Callback<T>(){
      @Override public void process(      Iterable<T> partialResult) throws QueryException, InterruptedException {
        Iterable<T> current=partialResult;
        for (int i=0; i <= depth; i++) {
          List<T> next=new ArrayList<>();
          Iterable<T> currentInUniverse=Iterables.filter(current,universe);
          next.addAll(env.getReverseDeps(minDepthUniquifier.uniqueAtDepthLessThanOrEqualTo(currentInUniverse,i)));
          callback.process(currentInUniverse);
          if (next.isEmpty()) {
            break;
          }
          current=next;
        }
      }
    }
);
  }
}",0.9739714525608733
110806,"@Override public void process(Iterable<T> partialResult) throws QueryException, InterruptedException {
  Collection<T> current=Sets.newHashSet(partialResult);
  env.buildTransitiveClosure(expression,(Set<T>)current,depthBound);
  for (int i=0; i <= depthBound; i++) {
    ImmutableList<T> toProcess=uniquifier.unique(current);
    callback.process(toProcess);
    current=ImmutableList.copyOf(env.getFwdDeps(toProcess));
    if (current.isEmpty()) {
      break;
    }
  }
}","@Override public void process(Iterable<T> partialResult) throws QueryException, InterruptedException {
  Collection<T> current=Sets.newHashSet(partialResult);
  env.buildTransitiveClosure(expression,(Set<T>)current,depthBound);
  for (int i=0; i <= depthBound; i++) {
    ImmutableList<T> toProcess=minDepthUniquifier.uniqueAtDepthLessThanOrEqualTo(current,i);
    callback.process(toProcess);
    current=ImmutableList.copyOf(env.getFwdDeps(toProcess));
    if (current.isEmpty()) {
      break;
    }
  }
}",0.9470468431771896
110807,"/** 
 * Breadth-first search from the arguments.
 */
@Override public <T>void eval(final QueryEnvironment<T> env,VariableContext<T> context,final QueryExpression expression,List<Argument> args,final Callback<T> callback) throws QueryException, InterruptedException {
  final int depthBound=args.size() > 1 ? args.get(1).getInteger() : Integer.MAX_VALUE;
  final Uniquifier<T> uniquifier=env.createUniquifier();
  env.eval(args.get(0).getExpression(),context,new Callback<T>(){
    @Override public void process(    Iterable<T> partialResult) throws QueryException, InterruptedException {
      Collection<T> current=Sets.newHashSet(partialResult);
      env.buildTransitiveClosure(expression,(Set<T>)current,depthBound);
      for (int i=0; i <= depthBound; i++) {
        ImmutableList<T> toProcess=uniquifier.unique(current);
        callback.process(toProcess);
        current=ImmutableList.copyOf(env.getFwdDeps(toProcess));
        if (current.isEmpty()) {
          break;
        }
      }
    }
  }
);
}","/** 
 * Breadth-first search from the arguments.
 */
@Override public <T>void eval(final QueryEnvironment<T> env,VariableContext<T> context,final QueryExpression expression,List<Argument> args,final Callback<T> callback) throws QueryException, InterruptedException {
  final int depthBound=args.size() > 1 ? args.get(1).getInteger() : Integer.MAX_VALUE;
  final MinDepthUniquifier<T> minDepthUniquifier=env.createMinDepthUniquifier();
  env.eval(args.get(0).getExpression(),context,new Callback<T>(){
    @Override public void process(    Iterable<T> partialResult) throws QueryException, InterruptedException {
      Collection<T> current=Sets.newHashSet(partialResult);
      env.buildTransitiveClosure(expression,(Set<T>)current,depthBound);
      for (int i=0; i <= depthBound; i++) {
        ImmutableList<T> toProcess=minDepthUniquifier.uniqueAtDepthLessThanOrEqualTo(current,i);
        callback.process(toProcess);
        current=ImmutableList.copyOf(env.getFwdDeps(toProcess));
        if (current.isEmpty()) {
          break;
        }
      }
    }
  }
);
}",0.962536023054755
110808,"private static SpawnInfo getExtraActionInfo(Spawn spawn){
  SpawnInfo.Builder info=SpawnInfo.newBuilder();
  info.addAllArgument(spawn.getArguments());
  for (  Map.Entry<String,String> variable : spawn.getEnvironment().entrySet()) {
    info.addVariable(EnvironmentVariable.newBuilder().setName(variable.getKey()).setValue(variable.getValue()).build());
  }
  for (  ActionInput input : spawn.getInputFiles()) {
    if (!(input instanceof Artifact) || !((Artifact)input).isMiddlemanArtifact()) {
      info.addInputFile(input.getExecPathString());
    }
  }
  info.addAllOutputFile(ActionInputHelper.toExecPaths(spawn.getOutputFiles()));
  return info.build();
}","@Override public ExtraActionInfo.Builder getExtraActionInfo(){
  ExtraActionInfo.Builder builder=super.getExtraActionInfo();
  if (extraActionInfoSupplier == null) {
    SpawnInfo spawnInfo=getExtraActionSpawnInfo();
    return builder.setExtension(SpawnInfo.spawnInfo,spawnInfo);
  }
 else {
    extraActionInfoSupplier.extend(builder);
    return builder;
  }
}",0.1169590643274853
110809,"@Override public void process(Iterable<T> partialResult) throws QueryException, InterruptedException {
  Set<T> result=CompactHashSet.create();
  Iterables.addAll(result,partialResult);
  callback.process(env.getBuildFiles(expression,result,true,true,true));
}","@Override public void process(Iterable<T> partialResult) throws QueryException, InterruptedException {
  Set<T> result=CompactHashSet.create();
  Iterables.addAll(result,partialResult);
  callback.process(uniquifier.unique(env.getBuildFiles(expression,result,true,true,true)));
}",0.9647495361781075
110810,"@Override public <T>void eval(final QueryEnvironment<T> env,VariableContext<T> context,final QueryExpression expression,List<Argument> args,final Callback<T> callback) throws QueryException, InterruptedException {
  env.eval(args.get(0).getExpression(),context,new ThreadSafeCallback<T>(){
    @Override public void process(    Iterable<T> partialResult) throws QueryException, InterruptedException {
      Set<T> result=CompactHashSet.create();
      Iterables.addAll(result,partialResult);
      callback.process(env.getBuildFiles(expression,result,true,true,true));
    }
  }
);
}","@Override public <T>void eval(final QueryEnvironment<T> env,VariableContext<T> context,final QueryExpression expression,List<Argument> args,final Callback<T> callback) throws QueryException, InterruptedException {
  final Uniquifier<T> uniquifier=env.createUniquifier();
  env.eval(args.get(0).getExpression(),context,new ThreadSafeCallback<T>(){
    @Override public void process(    Iterable<T> partialResult) throws QueryException, InterruptedException {
      Set<T> result=CompactHashSet.create();
      Iterables.addAll(result,partialResult);
      callback.process(uniquifier.unique(env.getBuildFiles(expression,result,true,true,true)));
    }
  }
);
}",0.9388083735909822
110811,"@Override public void process(Iterable<T> partialResult) throws QueryException, InterruptedException {
  Set<T> result=CompactHashSet.create();
  Iterables.addAll(result,partialResult);
  callback.process(env.getBuildFiles(expression,result,false,false,true));
}","@Override public void process(Iterable<T> partialResult) throws QueryException, InterruptedException {
  Set<T> result=CompactHashSet.create();
  Iterables.addAll(result,partialResult);
  callback.process(uniquifier.unique(env.getBuildFiles(expression,result,false,false,true)));
}",0.9650092081031308
110812,"@Override public <T>void eval(final QueryEnvironment<T> env,VariableContext<T> context,final QueryExpression expression,List<QueryEnvironment.Argument> args,final Callback<T> callback) throws QueryException, InterruptedException {
  env.eval(args.get(0).getExpression(),context,new Callback<T>(){
    @Override public void process(    Iterable<T> partialResult) throws QueryException, InterruptedException {
      Set<T> result=CompactHashSet.create();
      Iterables.addAll(result,partialResult);
      callback.process(env.getBuildFiles(expression,result,false,false,true));
    }
  }
);
}","@Override public <T>void eval(final QueryEnvironment<T> env,VariableContext<T> context,final QueryExpression expression,List<QueryEnvironment.Argument> args,final Callback<T> callback) throws QueryException, InterruptedException {
  final Uniquifier<T> uniquifier=env.createUniquifier();
  env.eval(args.get(0).getExpression(),context,new Callback<T>(){
    @Override public void process(    Iterable<T> partialResult) throws QueryException, InterruptedException {
      Set<T> result=CompactHashSet.create();
      Iterables.addAll(result,partialResult);
      callback.process(uniquifier.unique(env.getBuildFiles(expression,result,false,false,true)));
    }
  }
);
}",0.9396825396825396
110813,"@VisibleForTesting public static SequencedSkyframeExecutor create(PackageFactory pkgFactory,BlazeDirectories directories,BinTools binTools,WorkspaceStatusAction.Factory workspaceStatusActionFactory,ImmutableList<BuildInfoFactory> buildInfoFactories,Iterable<? extends DiffAwareness.Factory> diffAwarenessFactories,PathFragment blacklistedPackagePrefixesFile,String productName){
  return create(pkgFactory,directories,binTools,workspaceStatusActionFactory,buildInfoFactories,diffAwarenessFactories,Predicates.<PathFragment>alwaysFalse(),Preprocessor.Factory.Supplier.NullSupplier.INSTANCE,ImmutableMap.<SkyFunctionName,SkyFunction>of(),ImmutableList.<PrecomputedValue.Injected>of(),ImmutableList.<SkyValueDirtinessChecker>of(),blacklistedPackagePrefixesFile,productName,CrossRepositoryLabelViolationStrategy.ERROR,ImmutableList.of(BuildFileName.BUILD_DOT_BAZEL,BuildFileName.BUILD));
}","@VisibleForTesting public static SequencedSkyframeExecutor create(PackageFactory pkgFactory,BlazeDirectories directories,BinTools binTools,WorkspaceStatusAction.Factory workspaceStatusActionFactory,ImmutableList<BuildInfoFactory> buildInfoFactories,Iterable<? extends DiffAwareness.Factory> diffAwarenessFactories,PathFragment blacklistedPackagePrefixesFile,String productName,Preprocessor.Factory.Supplier preprocessorFactorySupplier){
  return create(pkgFactory,directories,binTools,workspaceStatusActionFactory,buildInfoFactories,diffAwarenessFactories,Predicates.<PathFragment>alwaysFalse(),preprocessorFactorySupplier,ImmutableMap.<SkyFunctionName,SkyFunction>of(),ImmutableList.<PrecomputedValue.Injected>of(),ImmutableList.<SkyValueDirtinessChecker>of(),blacklistedPackagePrefixesFile,productName,CrossRepositoryLabelViolationStrategy.ERROR,ImmutableList.of(BuildFileName.BUILD_DOT_BAZEL,BuildFileName.BUILD));
}",0.9246119733924612
110814,"/** 
 * Reads a .afdo.imports file and stores the imports information.
 */
private static ImmutableMultimap<PathFragment,PathFragment> readAutoFdoImports(Path importsFile) throws IOException, FdoException {
  ImmutableMultimap.Builder<PathFragment,PathFragment> importBuilder=ImmutableMultimap.builder();
  for (  String line : FileSystemUtils.iterateLinesAsLatin1(importsFile)) {
    if (!line.isEmpty()) {
      PathFragment key=new PathFragment(line.substring(0,line.indexOf(':')));
      if (key.isAbsolute()) {
        throw new FdoException(""String_Node_Str"" + importsFile + ""String_Node_Str""+ key);
      }
      for (      String auxFile : line.substring(line.indexOf(':') + 1).split(""String_Node_Str"")) {
        if (auxFile.length() == 0) {
          continue;
        }
        importBuilder.put(key,new PathFragment(auxFile));
      }
    }
  }
  return importBuilder.build();
}","/** 
 * Reads a .afdo.imports file and stores the imports information.
 */
private static ImmutableMultimap<PathFragment,PathFragment> readAutoFdoImports(Path importsFile) throws IOException, FdoException {
  ImmutableMultimap.Builder<PathFragment,PathFragment> importBuilder=ImmutableMultimap.builder();
  for (  String line : FileSystemUtils.iterateLinesAsLatin1(importsFile)) {
    line=line.trim();
    if (line.isEmpty()) {
      continue;
    }
    int colonIndex=line.indexOf(':');
    if (colonIndex < 0) {
      continue;
    }
    PathFragment key=new PathFragment(line.substring(0,colonIndex));
    if (key.isAbsolute()) {
      throw new FdoException(""String_Node_Str"" + importsFile + ""String_Node_Str""+ key);
    }
    for (    String auxFile : line.substring(colonIndex + 1).split(""String_Node_Str"")) {
      if (auxFile.length() == 0) {
        continue;
      }
      importBuilder.put(key,new PathFragment(auxFile));
    }
  }
  return importBuilder.build();
}",0.8205677557579004
110815,"/** 
 * Constructs a   {@link Package} object for the given package using legacy package loading.Note that the returned package may be in error. <p>May return null if the computation has to be restarted. <p>Exactly one of  {@code replacementContents} and {@code buildFileValue} will benon- {@code null}. The former indicates that we have a faux BUILD file with the given contents and the latter indicates that we have a legitimate BUILD file and should actually do preprocessing.
 */
@Nullable private CacheEntryWithGlobDeps<Package.Builder> loadPackage(Package externalPkg,@Nullable String replacementContents,PackageIdentifier packageId,Path buildFilePath,@Nullable FileValue buildFileValue,RuleVisibility defaultVisibility,List<Statement> preludeStatements,Path packageRoot,Environment env) throws InterruptedException, PackageFunctionException {
  CacheEntryWithGlobDeps<Package.Builder> packageFunctionCacheEntry=packageFunctionCache.getIfPresent(packageId);
  if (packageFunctionCacheEntry == null) {
    profiler.startTask(ProfilerTask.CREATE_PACKAGE,packageId.toString());
    if (packageProgress != null) {
      packageProgress.startReadPackage(packageId);
    }
    try {
      CacheEntryWithGlobDeps<AstAfterPreprocessing> astCacheEntry=astCache.getIfPresent(packageId);
      if (astCacheEntry == null) {
        if (showLoadingProgress.get()) {
          env.getListener().handle(Event.progress(""String_Node_Str"" + packageId));
        }
        LegacyGlobber legacyGlobber=packageFactory.createLegacyGlobberThatDoesntSort(buildFilePath.getParentDirectory(),packageId,packageLocator);
        SkyframeHybridGlobber skyframeGlobber=new SkyframeHybridGlobber(packageId,packageRoot,env,legacyGlobber);
        Preprocessor.Result preprocessingResult;
        if (replacementContents == null) {
          Preconditions.checkNotNull(buildFileValue,packageId);
          byte[] buildFileBytes;
          try {
            buildFileBytes=buildFileValue.isSpecialFile() ? FileSystemUtils.readContent(buildFilePath) : FileSystemUtils.readWithKnownFileSize(buildFilePath,buildFileValue.getSize());
          }
 catch (          IOException e) {
            throw new PackageFunctionException(new BuildFileContainsErrorsException(packageId,e.getMessage()),Transience.TRANSIENT);
          }
          try {
            preprocessingResult=packageFactory.preprocess(buildFilePath,packageId,buildFileBytes,skyframeGlobber);
          }
 catch (          IOException e) {
            throw new PackageFunctionException(new BuildFileContainsErrorsException(packageId,""String_Node_Str"" + e.getMessage(),e),Transience.TRANSIENT);
          }
        }
 else {
          ParserInputSource replacementSource=ParserInputSource.create(replacementContents,buildFilePath.asFragment());
          preprocessingResult=Preprocessor.Result.noPreprocessing(replacementSource);
        }
        StoredEventHandler astParsingEventHandler=new StoredEventHandler();
        BuildFileAST ast=PackageFactory.parseBuildFile(packageId,preprocessingResult.result,preludeStatements,astParsingEventHandler);
        Set<SkyKey> globDepsRequested=skyframeGlobber.getGlobDepsRequested();
        LegacyGlobber legacyGlobberToStore=globDepsRequested.isEmpty() ? null : legacyGlobber;
        astCacheEntry=new CacheEntryWithGlobDeps<>(new AstAfterPreprocessing(preprocessingResult,ast,astParsingEventHandler),globDepsRequested,legacyGlobberToStore);
        astCache.put(packageId,astCacheEntry);
      }
      AstAfterPreprocessing astAfterPreprocessing=astCacheEntry.value;
      Set<SkyKey> globDepsRequestedDuringPreprocessing=astCacheEntry.globDepKeys;
      SkylarkImportResult importResult;
      try {
        importResult=fetchImportsFromBuildFile(buildFilePath,packageId,astAfterPreprocessing.ast,env,skylarkImportLookupFunctionForInlining);
      }
 catch (      PackageFunctionException|InterruptedException e) {
        astCache.invalidate(packageId);
        throw e;
      }
      if (importResult == null) {
        return null;
      }
      astCache.invalidate(packageId);
      LegacyGlobber legacyGlobber=astCacheEntry.legacyGlobber != null ? astCacheEntry.legacyGlobber : packageFactory.createLegacyGlobber(buildFilePath.getParentDirectory(),packageId,packageLocator);
      SkyframeHybridGlobber skyframeGlobber=new SkyframeHybridGlobber(packageId,packageRoot,env,legacyGlobber);
      Package.Builder pkgBuilder=packageFactory.createPackageFromPreprocessingAst(externalPkg,packageId,buildFilePath,astAfterPreprocessing,importResult.importMap,importResult.fileDependencies,defaultVisibility,skyframeGlobber);
      Set<SkyKey> globDepsRequested=ImmutableSet.<SkyKey>builder().addAll(globDepsRequestedDuringPreprocessing).addAll(skyframeGlobber.getGlobDepsRequested()).build();
      packageFunctionCacheEntry=new CacheEntryWithGlobDeps<>(pkgBuilder,globDepsRequested,null);
      numPackagesLoaded.incrementAndGet();
      if (packageProgress != null) {
        packageProgress.doneReadPackage(packageId);
      }
      packageFunctionCache.put(packageId,packageFunctionCacheEntry);
    }
  finally {
      profiler.completeTask(ProfilerTask.CREATE_PACKAGE);
    }
  }
  return packageFunctionCacheEntry;
}","/** 
 * Constructs a   {@link Package} object for the given package using legacy package loading.Note that the returned package may be in error. <p>May return null if the computation has to be restarted. <p>Exactly one of  {@code replacementContents} and {@code buildFileValue} will benon- {@code null}. The former indicates that we have a faux BUILD file with the given contents and the latter indicates that we have a legitimate BUILD file and should actually do preprocessing.
 */
@Nullable private CacheEntryWithGlobDeps<Package.Builder> loadPackage(Package externalPkg,@Nullable String replacementContents,PackageIdentifier packageId,Path buildFilePath,@Nullable FileValue buildFileValue,RuleVisibility defaultVisibility,List<Statement> preludeStatements,Path packageRoot,Environment env) throws InterruptedException, PackageFunctionException {
  CacheEntryWithGlobDeps<Package.Builder> packageFunctionCacheEntry=packageFunctionCache.getIfPresent(packageId);
  if (packageFunctionCacheEntry == null) {
    profiler.startTask(ProfilerTask.CREATE_PACKAGE,packageId.toString());
    if (packageProgress != null) {
      packageProgress.startReadPackage(packageId);
    }
    try {
      CacheEntryWithGlobDeps<AstAfterPreprocessing> astCacheEntry=astCache.getIfPresent(packageId);
      if (astCacheEntry == null) {
        if (showLoadingProgress.get()) {
          env.getListener().handle(Event.progress(""String_Node_Str"" + packageId));
        }
        LegacyGlobber legacyGlobber=packageFactory.createLegacyGlobberThatDoesntSort(buildFilePath.getParentDirectory(),packageId,packageLocator);
        SkyframeHybridGlobber skyframeGlobber=new SkyframeHybridGlobber(packageId,packageRoot,env,legacyGlobber);
        Preprocessor.Result preprocessingResult;
        if (replacementContents == null) {
          Preconditions.checkNotNull(buildFileValue,packageId);
          byte[] buildFileBytes;
          try {
            buildFileBytes=buildFileValue.isSpecialFile() ? FileSystemUtils.readContent(buildFilePath) : FileSystemUtils.readWithKnownFileSize(buildFilePath,buildFileValue.getSize());
          }
 catch (          IOException e) {
            throw new PackageFunctionException(new BuildFileContainsErrorsException(packageId,e.getMessage()),Transience.TRANSIENT);
          }
          try {
            preprocessingResult=packageFactory.preprocess(buildFilePath,packageId,buildFileBytes,skyframeGlobber);
          }
 catch (          IOException e) {
            throw new PackageFunctionException(new BuildFileContainsErrorsException(packageId,""String_Node_Str"" + e.getMessage(),e),Transience.TRANSIENT);
          }
        }
 else {
          ParserInputSource replacementSource=ParserInputSource.create(replacementContents,buildFilePath.asFragment());
          preprocessingResult=Preprocessor.Result.noPreprocessing(replacementSource);
        }
        StoredEventHandler astParsingEventHandler=new StoredEventHandler();
        BuildFileAST ast=PackageFactory.parseBuildFile(packageId,preprocessingResult.result,preludeStatements,astParsingEventHandler);
        Set<SkyKey> globDepsRequested=skyframeGlobber.getGlobDepsRequested();
        LegacyGlobber legacyGlobberToStore=globDepsRequested.isEmpty() ? null : legacyGlobber;
        astCacheEntry=new CacheEntryWithGlobDeps<>(new AstAfterPreprocessing(preprocessingResult,ast,astParsingEventHandler),globDepsRequested,legacyGlobberToStore);
        astCache.put(packageId,astCacheEntry);
      }
      AstAfterPreprocessing astAfterPreprocessing=astCacheEntry.value;
      Set<SkyKey> globDepsRequestedDuringPreprocessing=astCacheEntry.globDepKeys;
      SkylarkImportResult importResult;
      try {
        importResult=fetchImportsFromBuildFile(buildFilePath,packageId,astAfterPreprocessing.ast,env,skylarkImportLookupFunctionForInlining);
      }
 catch (      NoSuchPackageException e) {
        throw new PackageFunctionException(e,Transience.PERSISTENT);
      }
catch (      InterruptedException e) {
        astCache.invalidate(packageId);
        throw e;
      }
      if (importResult == null) {
        return null;
      }
      astCache.invalidate(packageId);
      LegacyGlobber legacyGlobber=astCacheEntry.legacyGlobber != null ? astCacheEntry.legacyGlobber : packageFactory.createLegacyGlobber(buildFilePath.getParentDirectory(),packageId,packageLocator);
      SkyframeHybridGlobber skyframeGlobber=new SkyframeHybridGlobber(packageId,packageRoot,env,legacyGlobber);
      Package.Builder pkgBuilder=packageFactory.createPackageFromPreprocessingAst(externalPkg,packageId,buildFilePath,astAfterPreprocessing,importResult.importMap,importResult.fileDependencies,defaultVisibility,skyframeGlobber);
      Set<SkyKey> globDepsRequested=ImmutableSet.<SkyKey>builder().addAll(globDepsRequestedDuringPreprocessing).addAll(skyframeGlobber.getGlobDepsRequested()).build();
      packageFunctionCacheEntry=new CacheEntryWithGlobDeps<>(pkgBuilder,globDepsRequested,null);
      numPackagesLoaded.incrementAndGet();
      if (packageProgress != null) {
        packageProgress.doneReadPackage(packageId);
      }
      packageFunctionCache.put(packageId,packageFunctionCacheEntry);
    }
  finally {
      profiler.completeTask(ProfilerTask.CREATE_PACKAGE);
    }
  }
  return packageFunctionCacheEntry;
}",0.9880895664602192
110816,"/** 
 * Fetch the skylark loads for this BUILD file. If any of them haven't been computed yet, returns null.
 */
@Nullable static SkylarkImportResult fetchImportsFromBuildFile(Path buildFilePath,PackageIdentifier packageId,BuildFileAST buildFileAST,Environment env,SkylarkImportLookupFunction skylarkImportLookupFunctionForInlining) throws PackageFunctionException, InterruptedException {
  Preconditions.checkArgument(!packageId.getRepository().isDefault());
  ImmutableList<SkylarkImport> imports=buildFileAST.getImports();
  Map<String,Extension> importMap=Maps.newHashMapWithExpectedSize(imports.size());
  ImmutableList.Builder<SkylarkFileDependency> fileDependencies=ImmutableList.builder();
  ImmutableMap<String,Label> importPathMap;
  Label labelForCurrBuildFile;
  try {
    labelForCurrBuildFile=Label.create(packageId,""String_Node_Str"");
  }
 catch (  LabelSyntaxException e) {
    throw new IllegalStateException(e);
  }
  try {
    importPathMap=SkylarkImportLookupFunction.findLabelsForLoadStatements(imports,labelForCurrBuildFile,env);
    if (importPathMap == null) {
      return null;
    }
  }
 catch (  SkylarkImportFailedException e) {
    throw new PackageFunctionException(new BuildFileContainsErrorsException(packageId,e.getMessage()),Transience.PERSISTENT);
  }
  ImmutableCollection<Label> importLabels=importPathMap.values();
  List<SkyKey> importLookupKeys=Lists.newArrayListWithExpectedSize(importLabels.size());
  boolean inWorkspace=buildFilePath.getBaseName().endsWith(""String_Node_Str"");
  for (  Label importLabel : importLabels) {
    importLookupKeys.add(SkylarkImportLookupValue.key(importLabel,inWorkspace));
  }
  Map<SkyKey,SkyValue> skylarkImportMap=Maps.newHashMapWithExpectedSize(importPathMap.size());
  boolean valuesMissing=false;
  try {
    if (skylarkImportLookupFunctionForInlining == null) {
      Map<SkyKey,ValueOrException2<SkylarkImportFailedException,InconsistentFilesystemException>> skylarkLookupResults=env.getValuesOrThrow(importLookupKeys,SkylarkImportFailedException.class,InconsistentFilesystemException.class);
      valuesMissing=env.valuesMissing();
      for (      Map.Entry<SkyKey,ValueOrException2<SkylarkImportFailedException,InconsistentFilesystemException>> entry : skylarkLookupResults.entrySet()) {
        skylarkImportMap.put(entry.getKey(),entry.getValue().get());
      }
    }
 else {
      LinkedHashMap<Label,SkylarkImportLookupValue> alreadyVisitedImports=Maps.newLinkedHashMapWithExpectedSize(importLookupKeys.size());
      for (      SkyKey importLookupKey : importLookupKeys) {
        SkyValue skyValue=skylarkImportLookupFunctionForInlining.computeWithInlineCalls(importLookupKey,env,alreadyVisitedImports);
        if (skyValue == null) {
          Preconditions.checkState(env.valuesMissing(),""String_Node_Str"",importLookupKey);
          valuesMissing=true;
        }
 else {
          skylarkImportMap.put(importLookupKey,skyValue);
        }
      }
    }
  }
 catch (  SkylarkImportFailedException e) {
    throw new PackageFunctionException(new BuildFileContainsErrorsException(packageId,e.getMessage()),Transience.PERSISTENT);
  }
catch (  InconsistentFilesystemException e) {
    throw new PackageFunctionException(new NoSuchPackageException(packageId,e.getMessage(),e),Transience.PERSISTENT);
  }
  if (valuesMissing) {
    return null;
  }
  for (  Entry<String,Label> importEntry : importPathMap.entrySet()) {
    String importString=importEntry.getKey();
    Label importLabel=importEntry.getValue();
    SkyKey keyForLabel=SkylarkImportLookupValue.key(importLabel,inWorkspace);
    SkylarkImportLookupValue importLookupValue=(SkylarkImportLookupValue)skylarkImportMap.get(keyForLabel);
    importMap.put(importString,importLookupValue.getEnvironmentExtension());
    fileDependencies.add(importLookupValue.getDependency());
  }
  return new SkylarkImportResult(importMap,transitiveClosureOfLabels(fileDependencies.build()));
}","/** 
 * Fetch the skylark loads for this BUILD file. If any of them haven't been computed yet, returns null.
 */
@Nullable static SkylarkImportResult fetchImportsFromBuildFile(Path buildFilePath,PackageIdentifier packageId,BuildFileAST buildFileAST,Environment env,SkylarkImportLookupFunction skylarkImportLookupFunctionForInlining) throws NoSuchPackageException, InterruptedException {
  Preconditions.checkArgument(!packageId.getRepository().isDefault());
  ImmutableList<SkylarkImport> imports=buildFileAST.getImports();
  Map<String,Extension> importMap=Maps.newHashMapWithExpectedSize(imports.size());
  ImmutableList.Builder<SkylarkFileDependency> fileDependencies=ImmutableList.builder();
  ImmutableMap<String,Label> importPathMap;
  Label labelForCurrBuildFile;
  try {
    labelForCurrBuildFile=Label.create(packageId,""String_Node_Str"");
  }
 catch (  LabelSyntaxException e) {
    throw new IllegalStateException(e);
  }
  try {
    importPathMap=SkylarkImportLookupFunction.findLabelsForLoadStatements(imports,labelForCurrBuildFile,env);
    if (importPathMap == null) {
      return null;
    }
  }
 catch (  SkylarkImportFailedException e) {
    throw new BuildFileContainsErrorsException(packageId,e.getMessage());
  }
  ImmutableCollection<Label> importLabels=importPathMap.values();
  List<SkyKey> importLookupKeys=Lists.newArrayListWithExpectedSize(importLabels.size());
  boolean inWorkspace=buildFilePath.getBaseName().endsWith(""String_Node_Str"");
  for (  Label importLabel : importLabels) {
    importLookupKeys.add(SkylarkImportLookupValue.key(importLabel,inWorkspace));
  }
  Map<SkyKey,SkyValue> skylarkImportMap=Maps.newHashMapWithExpectedSize(importPathMap.size());
  boolean valuesMissing=false;
  try {
    if (skylarkImportLookupFunctionForInlining == null) {
      Map<SkyKey,ValueOrException2<SkylarkImportFailedException,InconsistentFilesystemException>> skylarkLookupResults=env.getValuesOrThrow(importLookupKeys,SkylarkImportFailedException.class,InconsistentFilesystemException.class);
      valuesMissing=env.valuesMissing();
      for (      Map.Entry<SkyKey,ValueOrException2<SkylarkImportFailedException,InconsistentFilesystemException>> entry : skylarkLookupResults.entrySet()) {
        skylarkImportMap.put(entry.getKey(),entry.getValue().get());
      }
    }
 else {
      LinkedHashMap<Label,SkylarkImportLookupValue> alreadyVisitedImports=Maps.newLinkedHashMapWithExpectedSize(importLookupKeys.size());
      for (      SkyKey importLookupKey : importLookupKeys) {
        SkyValue skyValue=skylarkImportLookupFunctionForInlining.computeWithInlineCalls(importLookupKey,env,alreadyVisitedImports);
        if (skyValue == null) {
          Preconditions.checkState(env.valuesMissing(),""String_Node_Str"",importLookupKey);
          valuesMissing=true;
        }
 else {
          skylarkImportMap.put(importLookupKey,skyValue);
        }
      }
    }
  }
 catch (  SkylarkImportFailedException e) {
    throw new BuildFileContainsErrorsException(packageId,e.getMessage());
  }
catch (  InconsistentFilesystemException e) {
    throw new NoSuchPackageException(packageId,e.getMessage(),e);
  }
  if (valuesMissing) {
    return null;
  }
  for (  Entry<String,Label> importEntry : importPathMap.entrySet()) {
    String importString=importEntry.getKey();
    Label importLabel=importEntry.getValue();
    SkyKey keyForLabel=SkylarkImportLookupValue.key(importLabel,inWorkspace);
    SkylarkImportLookupValue importLookupValue=(SkylarkImportLookupValue)skylarkImportMap.get(keyForLabel);
    importMap.put(importString,importLookupValue.getEnvironmentExtension());
    fileDependencies.add(importLookupValue.getDependency());
  }
  return new SkylarkImportResult(importMap,transitiveClosureOfLabels(fileDependencies.build()));
}",0.3918462736951441
110817,"public WorkspaceASTFunctionException(Exception e,Transience transience){
  super(e,transience);
}","WorkspaceASTFunctionException(IOException e,Transience transience){
  super(e,transience);
}",0.9523809523809524
110818,"@Override public SkyValue compute(SkyKey skyKey,Environment env) throws WorkspaceFileFunctionException, InterruptedException {
  WorkspaceFileKey key=(WorkspaceFileKey)skyKey.argument();
  RootedPath workspaceRoot=key.getPath();
  WorkspaceASTValue workspaceASTValue=(WorkspaceASTValue)env.getValue(WorkspaceASTValue.key(workspaceRoot));
  if (workspaceASTValue == null) {
    return null;
  }
  Path repoWorkspace=workspaceRoot.getRoot().getRelative(workspaceRoot.getRelativePath());
  Package.Builder builder=packageFactory.newExternalPackageBuilder(repoWorkspace,ruleClassProvider.getRunfilesPrefix());
  if (workspaceASTValue.getASTs().isEmpty()) {
    return new WorkspaceFileValue(builder.build(),ImmutableMap.<String,Extension>of(),ImmutableMap.<String,Object>of(),workspaceRoot,0,false);
  }
  WorkspaceFactory parser;
  try (Mutability mutability=Mutability.create(""String_Node_Str"",repoWorkspace)){
    parser=new WorkspaceFactory(builder,ruleClassProvider,packageFactory.getEnvironmentExtensions(),mutability,key.getIndex() == 0,directories.getEmbeddedBinariesRoot(),directories.getWorkspace());
    if (key.getIndex() > 0) {
      WorkspaceFileValue prevValue=(WorkspaceFileValue)env.getValue(WorkspaceFileValue.key(key.getPath(),key.getIndex() - 1));
      if (prevValue == null) {
        return null;
      }
      if (prevValue.next() == null) {
        return prevValue;
      }
      parser.setParent(prevValue.getPackage(),prevValue.getImportMap(),prevValue.getBindings());
    }
    BuildFileAST ast=workspaceASTValue.getASTs().get(key.getIndex());
    PackageFunction.SkylarkImportResult importResult=PackageFunction.fetchImportsFromBuildFile(repoWorkspace,rootPackage,ast,env,null);
    if (importResult == null) {
      return null;
    }
    parser.execute(ast,importResult.importMap);
  }
 catch (  PackageFunctionException e) {
    throw new WorkspaceFileFunctionException(e,Transience.PERSISTENT);
  }
catch (  NameConflictException e) {
    throw new WorkspaceFileFunctionException(e,Transience.PERSISTENT);
  }
  return new WorkspaceFileValue(builder.build(),parser.getImportMap(),parser.getVariableBindings(),workspaceRoot,key.getIndex(),key.getIndex() < workspaceASTValue.getASTs().size() - 1);
}","@Override public SkyValue compute(SkyKey skyKey,Environment env) throws WorkspaceFileFunctionException, InterruptedException {
  WorkspaceFileKey key=(WorkspaceFileKey)skyKey.argument();
  RootedPath workspaceRoot=key.getPath();
  WorkspaceASTValue workspaceASTValue=(WorkspaceASTValue)env.getValue(WorkspaceASTValue.key(workspaceRoot));
  if (workspaceASTValue == null) {
    return null;
  }
  Path repoWorkspace=workspaceRoot.getRoot().getRelative(workspaceRoot.getRelativePath());
  Package.Builder builder=packageFactory.newExternalPackageBuilder(repoWorkspace,ruleClassProvider.getRunfilesPrefix());
  if (workspaceASTValue.getASTs().isEmpty()) {
    return new WorkspaceFileValue(builder.build(),ImmutableMap.<String,Extension>of(),ImmutableMap.<String,Object>of(),workspaceRoot,0,false);
  }
  WorkspaceFactory parser;
  try (Mutability mutability=Mutability.create(""String_Node_Str"",repoWorkspace)){
    parser=new WorkspaceFactory(builder,ruleClassProvider,packageFactory.getEnvironmentExtensions(),mutability,key.getIndex() == 0,directories.getEmbeddedBinariesRoot(),directories.getWorkspace());
    if (key.getIndex() > 0) {
      WorkspaceFileValue prevValue=(WorkspaceFileValue)env.getValue(WorkspaceFileValue.key(key.getPath(),key.getIndex() - 1));
      if (prevValue == null) {
        return null;
      }
      if (prevValue.next() == null) {
        return prevValue;
      }
      parser.setParent(prevValue.getPackage(),prevValue.getImportMap(),prevValue.getBindings());
    }
    BuildFileAST ast=workspaceASTValue.getASTs().get(key.getIndex());
    PackageFunction.SkylarkImportResult importResult=PackageFunction.fetchImportsFromBuildFile(repoWorkspace,rootPackage,ast,env,null);
    if (importResult == null) {
      return null;
    }
    parser.execute(ast,importResult.importMap);
  }
 catch (  NoSuchPackageException e) {
    throw new WorkspaceFileFunctionException(e,Transience.PERSISTENT);
  }
catch (  NameConflictException e) {
    throw new WorkspaceFileFunctionException(e,Transience.PERSISTENT);
  }
  return new WorkspaceFileValue(builder.build(),parser.getImportMap(),parser.getVariableBindings(),workspaceRoot,key.getIndex(),key.getIndex() < workspaceASTValue.getASTs().size() - 1);
}",0.9968553459119496
110819,"public WorkspaceFileFunctionException(NameConflictException e,Transience transience){
  super(e,transience);
}","WorkspaceFileFunctionException(IOException e,Transience transience){
  super(e,transience);
}",0.896551724137931
110820,"/** 
 * Marks the provided dependency as a direct/explicit dependency. Additionally, if strict_java_deps is enabled, it emits a [strict] compiler warning/error (behavior to be soon replaced by the more complete Blaze implementation).
 */
private void collectExplicitDependency(String jarName,JCTree node,Symbol.TypeSymbol sym){
  if (strictJavaDepsMode.isEnabled() && !isStrictDepsExempt) {
    JarOwner owner=indirectJarsToTargets.get(jarName);
    if (owner != null && seenTargets.add(owner)) {
      String canonicalTargetName=canonicalizeTarget(owner.label());
      missingTargets.add(owner);
      String toolInfo=owner.aspect() == null ? canonicalTargetName : String.format(""String_Node_Str"",canonicalTargetName,owner.aspect());
      if (strictJavaDepsMode == ERROR) {
        log.error(node.pos,""String_Node_Str"",MessageFormat.format(TRANSITIVE_DEP_MESSAGE,sym,toolInfo));
      }
 else {
        log.warning(node.pos,""String_Node_Str"",MessageFormat.format(TRANSITIVE_DEP_MESSAGE,sym,toolInfo));
      }
    }
  }
  if (!directDependenciesMap.containsKey(jarName)) {
    Dependency dep=Dependency.newBuilder().setPath(jarName).setKind(Dependency.Kind.EXPLICIT).build();
    directDependenciesMap.put(jarName,dep);
  }
}","/** 
 * Marks the provided dependency as a direct/explicit dependency. Additionally, if strict_java_deps is enabled, it emits a [strict] compiler warning/error (behavior to be soon replaced by the more complete Blaze implementation).
 */
private void collectExplicitDependency(String jarName,JCTree node,Symbol.TypeSymbol sym){
  if (strictJavaDepsMode.isEnabled() && !isStrictDepsExempt) {
    JarOwner owner=indirectJarsToTargets.get(jarName);
    if (owner != null && seenTargets.add(owner)) {
      String canonicalTargetName=canonicalizeTarget(remapTarget(owner.label()));
      missingTargets.add(owner);
      String toolInfo=owner.aspect() == null ? canonicalTargetName : String.format(""String_Node_Str"",canonicalTargetName,owner.aspect());
      if (strictJavaDepsMode == ERROR) {
        log.error(node.pos,""String_Node_Str"",MessageFormat.format(TRANSITIVE_DEP_MESSAGE,sym,toolInfo));
      }
 else {
        log.warning(node.pos,""String_Node_Str"",MessageFormat.format(TRANSITIVE_DEP_MESSAGE,sym,toolInfo));
      }
    }
  }
  if (!directDependenciesMap.containsKey(jarName)) {
    Dependency dep=Dependency.newBuilder().setPath(jarName).setKind(Dependency.Kind.EXPLICIT).build();
    directDependenciesMap.put(jarName,dep);
  }
}",0.9947347104090724
110821,"/** 
 * Returns the canonical version of the target name. Package private for testing. 
 */
static String canonicalizeTarget(String target){
  String replacement=targetMap.getProperty(target);
  if (replacement != null) {
    return replacement;
  }
  int atIndex=target.indexOf('@');
  if (atIndex != -1) {
    target=target.substring(1);
  }
  int colonIndex=target.indexOf(':');
  if (colonIndex == -1) {
    return target;
  }
  int lastSlash=target.lastIndexOf('/',colonIndex);
  if (lastSlash == -1) {
    return target;
  }
  String packageName=target.substring(lastSlash + 1,colonIndex);
  String suffix=target.substring(colonIndex + 1);
  if (packageName.equals(suffix)) {
    return target.substring(0,colonIndex);
  }
  return target;
}","/** 
 * Returns the canonical version of the target name. Package private for testing. 
 */
static String canonicalizeTarget(String target){
  int atIndex=target.indexOf('@');
  if (atIndex != -1) {
    target=target.substring(1);
  }
  int colonIndex=target.indexOf(':');
  if (colonIndex == -1) {
    return target;
  }
  int lastSlash=target.lastIndexOf('/',colonIndex);
  if (lastSlash == -1) {
    return target;
  }
  String packageName=target.substring(lastSlash + 1,colonIndex);
  String suffix=target.substring(colonIndex + 1);
  if (packageName.equals(suffix)) {
    return target.substring(0,colonIndex);
  }
  return target;
}",0.9212996389891696
110822,"@Override public void finish(){
  implicitDependencyExtractor.accumulate(context,checkingTreeScanner.getSeenClasses());
  if (!missingTargets.isEmpty()) {
    String canonicalizedLabel=dependencyModule.getTargetLabel() == null ? null : canonicalizeTarget(dependencyModule.getTargetLabel());
    List<JarOwner> canonicalizedMissing=new ArrayList<>();
    for (    JarOwner owner : Ordering.natural().onResultOf(JarOwner.LABEL).immutableSortedCopy(missingTargets)) {
      canonicalizedMissing.add(JarOwner.create(canonicalizeTarget(owner.label()),owner.aspect()));
    }
    errWriter.print(dependencyModule.getFixMessage().get(canonicalizedMissing,canonicalizedLabel,USE_COLOR));
  }
}","@Override public void finish(){
  implicitDependencyExtractor.accumulate(context,checkingTreeScanner.getSeenClasses());
  if (!missingTargets.isEmpty()) {
    String canonicalizedLabel=dependencyModule.getTargetLabel() == null ? null : canonicalizeTarget(dependencyModule.getTargetLabel());
    List<JarOwner> canonicalizedMissing=new ArrayList<>();
    for (    JarOwner owner : Ordering.natural().onResultOf(JarOwner.LABEL).immutableSortedCopy(missingTargets)) {
      String actualTarget=canonicalizeTarget(remapTarget(owner.label()));
      canonicalizedMissing.add(JarOwner.create(actualTarget,owner.aspect()));
    }
    errWriter.print(dependencyModule.getFixMessage().get(canonicalizedMissing,canonicalizedLabel,USE_COLOR));
  }
}",0.9163738580463808
110823,"/** 
 * Validates the proto attributes for this target. <ul> <li>Validates that there are protos specified to be compiled. <li>Validates that, when enabling the open source protobuf library, the options for the PB2 are not specified also. <li>Validates that, when enabling the open source protobuf library, the rule specifies at least one portable proto filter file. </ul>
 */
public void validate() throws RuleErrorException {
  PrerequisiteArtifacts prerequisiteArtifacts=ruleContext.getPrerequisiteArtifacts(""String_Node_Str"",Mode.TARGET);
  ImmutableList<Artifact> protos=prerequisiteArtifacts.filter(FileType.of(""String_Node_Str"")).list();
  if (!protos.isEmpty()) {
    ruleContext.attributeWarning(""String_Node_Str"",FILES_DEPRECATED_WARNING);
  }
  if (ruleContext.attributes().isAttributeValueExplicitlySpecified(ObjcProtoLibraryRule.PORTABLE_PROTO_FILTERS_ATTR)) {
    if (getProtoFiles().isEmpty() && !hasObjcProtoLibraryDependencies()) {
      ruleContext.throwWithRuleError(NO_PROTOS_ERROR);
    }
    if (getPortableProtoFilters().isEmpty()) {
      ruleContext.throwWithRuleError(PORTABLE_PROTO_FILTERS_EMPTY_ERROR);
    }
    if (usesObjcHeaderNames() || needsPerProtoIncludes() || getOptionsFile().isPresent()) {
      ruleContext.throwWithRuleError(PORTABLE_PROTO_FILTERS_NOT_EXCLUSIVE_ERROR);
    }
    if (hasPB2Dependencies()) {
      ruleContext.throwWithRuleError(PROTOCOL_BUFFERS2_IN_PROTOBUF_DEPS_ERROR);
    }
  }
 else {
    if (getProtoFiles().isEmpty()) {
      ruleContext.throwWithRuleError(NO_PROTOS_ERROR);
    }
    if (!usesObjcHeaderNames()) {
      ruleContext.ruleWarning(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (hasObjcProtoLibraryDependencies()) {
      ruleContext.throwWithRuleError(OBJC_PROTO_LIB_DEP_IN_PROTOCOL_BUFFERS2_DEPS_ERROR);
    }
  }
}","/** 
 * Validates the proto attributes for this target. <ul> <li>Validates that there are protos specified to be compiled. <li>Validates that, when enabling the open source protobuf library, the options for the PB2 are not specified also. <li>Validates that, when enabling the open source protobuf library, the rule specifies at least one portable proto filter file. </ul>
 */
public void validate() throws RuleErrorException {
  PrerequisiteArtifacts prerequisiteArtifacts=ruleContext.getPrerequisiteArtifacts(""String_Node_Str"",Mode.TARGET);
  ImmutableList<Artifact> protos=prerequisiteArtifacts.filter(FileType.of(""String_Node_Str"")).list();
  if (ruleContext.attributes().isAttributeValueExplicitlySpecified(ObjcProtoLibraryRule.PORTABLE_PROTO_FILTERS_ATTR)) {
    if (!protos.isEmpty()) {
      ruleContext.throwWithAttributeError(""String_Node_Str"",FILES_NOT_ALLOWED_ERROR);
    }
    if (getProtoFiles().isEmpty() && !hasObjcProtoLibraryDependencies()) {
      ruleContext.throwWithRuleError(NO_PROTOS_ERROR);
    }
    if (getPortableProtoFilters().isEmpty()) {
      ruleContext.throwWithRuleError(PORTABLE_PROTO_FILTERS_EMPTY_ERROR);
    }
    if (usesObjcHeaderNames() || needsPerProtoIncludes() || getOptionsFile().isPresent()) {
      ruleContext.throwWithRuleError(PORTABLE_PROTO_FILTERS_NOT_EXCLUSIVE_ERROR);
    }
    if (hasPB2Dependencies()) {
      ruleContext.throwWithRuleError(PROTOCOL_BUFFERS2_IN_PROTOBUF_DEPS_ERROR);
    }
  }
 else {
    if (!protos.isEmpty()) {
      ruleContext.attributeWarning(""String_Node_Str"",FILES_DEPRECATED_WARNING);
    }
    if (getProtoFiles().isEmpty()) {
      ruleContext.throwWithRuleError(NO_PROTOS_ERROR);
    }
    if (!usesObjcHeaderNames()) {
      ruleContext.ruleWarning(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (hasObjcProtoLibraryDependencies()) {
      ruleContext.throwWithRuleError(OBJC_PROTO_LIB_DEP_IN_PROTOCOL_BUFFERS2_DEPS_ERROR);
    }
  }
}",0.4676857066237597
110824,"private void beforeEvaluateQuery() throws InterruptedException {
  boolean resolverNeedsRecreation=false;
  if (graph == null || !graphFactory.isUpToDate(universeKey)) {
    EvaluationResult<SkyValue> result;
    try (AutoProfiler p=AutoProfiler.logged(""String_Node_Str"",LOG)){
      result=graphFactory.prepareAndGet(universeKey,loadingPhaseThreads,eventHandler);
    }
     checkEvaluationResult(result);
    packageSemaphore=makeFreshPackageMultisetSemaphore();
    graph=result.getWalkableGraph();
    blacklistPatternsSupplier=InterruptibleSupplier.Memoize.of(new BlacklistSupplier(graph));
    graphBackedRecursivePackageProvider=new GraphBackedRecursivePackageProvider(graph,universeTargetPatternKeys,pkgPath);
    resolverNeedsRecreation=true;
  }
  if (forkJoinPool == null) {
    forkJoinPool=NamedForkJoinPool.newNamedPool(""String_Node_Str"",queryEvaluationParallelismLevel);
    resolverNeedsRecreation=true;
  }
  if (resolverNeedsRecreation) {
    resolver=new RecursivePackageProviderBackedTargetPatternResolver(graphBackedRecursivePackageProvider,eventHandler,TargetPatternEvaluator.DEFAULT_FILTERING_POLICY,packageSemaphore);
  }
}","private void beforeEvaluateQuery() throws InterruptedException {
  if (graph == null || !graphFactory.isUpToDate(universeKey)) {
    EvaluationResult<SkyValue> result;
    try (AutoProfiler p=AutoProfiler.logged(""String_Node_Str"",LOG)){
      result=graphFactory.prepareAndGet(universeKey,loadingPhaseThreads,eventHandler);
    }
     checkEvaluationResult(result);
    packageSemaphore=makeFreshPackageMultisetSemaphore();
    graph=result.getWalkableGraph();
    blacklistPatternsSupplier=InterruptibleSupplier.Memoize.of(new BlacklistSupplier(graph));
    graphBackedRecursivePackageProvider=new GraphBackedRecursivePackageProvider(graph,universeTargetPatternKeys,pkgPath);
  }
  if (forkJoinPool == null) {
    forkJoinPool=NamedForkJoinPool.newNamedPool(""String_Node_Str"",queryEvaluationParallelismLevel);
  }
  resolver=new RecursivePackageProviderBackedTargetPatternResolver(graphBackedRecursivePackageProvider,eventHandler,TargetPatternEvaluator.DEFAULT_FILTERING_POLICY,packageSemaphore);
}",0.9310344827586208
110825,"@Override public boolean isCycle(SkyKey key) throws InterruptedException {
  NodeEntry entry=getEntryForValue(key);
  if (entry == null) {
    return false;
  }
  ErrorInfo errorInfo=entry.getErrorInfo();
  return errorInfo != null && errorInfo.getCycleInfo() != null;
}","@Override public boolean isCycle(SkyKey key) throws InterruptedException {
  NodeEntry entry=getEntryForValue(key);
  if (entry == null) {
    return false;
  }
  ErrorInfo errorInfo=entry.getErrorInfo();
  return errorInfo != null && !Iterables.isEmpty(errorInfo.getCycleInfo());
}",0.9492753623188406
110826,"@Override public void recordResourceReferences(ResourceFolderType folderType,Node node,Resource from){
  super.recordResourceReferences(folderType,node,from);
  if (from != null && node.getNodeType() == Node.ELEMENT_NODE) {
    NamedNodeMap attributes=((Element)node).getAttributes();
    for (int i=0; i < attributes.getLength(); i++) {
      Attr attr=(Attr)attributes.item(i);
      if (attr.getValue().startsWith(SdkConstants.PREFIX_RESOURCE_REF) && SdkConstants.ATTR_ID.equals(attr.getLocalName()) && SdkConstants.ANDROID_URI.equals(attr.getNamespaceURI())) {
        ResourceUrl url=ResourceUrl.parse(attr.getValue());
        if (url != null) {
          Resource resource=getResource(url.type,url.name);
          if (resource != null) {
            from.addReference(resource);
          }
        }
      }
    }
  }
}","/** 
 * Records resource declarations and usages within an XML resource file
 * @param folderType the type of resource file
 * @param node the root node to start the recursive search from
 * @param from a referencing context, if any.
 */
@Override public void recordResourceReferences(@NonNull ResourceFolderType folderType,@NonNull Node node,@Nullable Resource from){
  short nodeType=node.getNodeType();
  if (nodeType == Node.ELEMENT_NODE) {
    Element element=(Element)node;
    if (from != null) {
      NamedNodeMap attributes=element.getAttributes();
      for (int i=0, n=attributes.getLength(); i < n; i++) {
        Attr attr=(Attr)attributes.item(i);
        if (TOOLS_URI.equals(attr.getNamespaceURI())) {
          recordToolsAttributes(attr);
          continue;
        }
        String value=attr.getValue();
        if (!(value.startsWith(PREFIX_RESOURCE_REF) || value.startsWith(PREFIX_THEME_REF))) {
          continue;
        }
        ResourceUrl url=ResourceUrl.parse(value);
        if (url != null && !url.framework) {
          Resource resource;
          if (url.create) {
            resource=declareResource(url.type,url.name,attr);
            from.addReference(resource);
          }
 else {
            resource=addResource(url.type,url.name,null);
            from.addReference(resource);
          }
        }
 else         if (value.startsWith(""String_Node_Str"")) {
          int length=value.length();
          int index=2;
          while (true) {
            index=value.indexOf('@',index);
            if (index == -1) {
              break;
            }
            int end=index + 1;
            while (end < length) {
              char c=value.charAt(end);
              if (!(Character.isJavaIdentifierPart(c) || c == '_' || c == '.' || c == '/' || c == '+')) {
                break;
              }
              end++;
            }
            url=ResourceUrl.parse(value.substring(index,end));
            if (url != null && !url.framework) {
              Resource resource;
              if (url.create) {
                resource=declareResource(url.type,url.name,attr);
              }
 else {
                resource=addResource(url.type,url.name,null);
              }
              from.addReference(resource);
            }
            index=end;
          }
        }
      }
      if (""String_Node_Str"".equals(element.getTagName())) {
        StringBuilder sb=new StringBuilder();
        NodeList children=node.getChildNodes();
        for (int i=0, n=children.getLength(); i < n; i++) {
          Node child=children.item(i);
          if (child.getNodeType() == Element.TEXT_NODE || child.getNodeType() == Element.CDATA_SECTION_NODE) {
            sb.append(child.getNodeValue());
          }
        }
        if (sb.length() > 0) {
          Resource resource=getResource(ResourceType.RAW,sb.toString().trim());
          from.addReference(resource);
        }
      }
    }
 else {
      recordToolsAttributes(element.getAttributeNodeNS(TOOLS_URI,ATTR_KEEP));
      recordToolsAttributes(element.getAttributeNodeNS(TOOLS_URI,ATTR_DISCARD));
      recordToolsAttributes(element.getAttributeNodeNS(TOOLS_URI,ATTR_SHRINK_MODE));
    }
    if (folderType == ResourceFolderType.VALUES) {
      Resource definition=null;
      ResourceType type=getResourceType(element);
      if (type != null) {
        String name=getFieldName(element);
        if (type == ResourceType.PUBLIC) {
          String typeName=element.getAttribute(ATTR_TYPE);
          if (!typeName.isEmpty()) {
            type=ResourceType.getEnum(typeName);
            if (type != null) {
              definition=declareResource(type,name,element);
              definition.setPublic(true);
            }
          }
        }
 else {
          definition=declareResource(type,name,element);
        }
      }
      if (definition != null) {
        from=definition;
      }
      String tagName=element.getTagName();
      if (TAG_STYLE.equals(tagName)) {
        if (element.hasAttribute(ATTR_PARENT)) {
          String parent=element.getAttribute(ATTR_PARENT);
          if (parent.startsWith(ANDROID_STYLE_RESOURCE_PREFIX) || parent.startsWith(PREFIX_ANDROID)) {
            if (definition != null) {
              markReachable(definition);
            }
          }
 else           if (!parent.isEmpty()) {
            String parentStyle=parent;
            if (!parentStyle.startsWith(STYLE_RESOURCE_PREFIX)) {
              parentStyle=STYLE_RESOURCE_PREFIX + parentStyle;
            }
            Resource ps=getResourceFromUrl(LintUtils.getFieldName(parentStyle));
            if (ps != null && definition != null) {
              definition.addReference(ps);
            }
          }
        }
 else {
          String name=getFieldName(element);
          while (true) {
            int index=name.lastIndexOf('_');
            if (index != -1) {
              name=name.substring(0,index);
              Resource ps=getResourceFromUrl(STYLE_RESOURCE_PREFIX + LintUtils.getFieldName(name));
              if (ps != null && definition != null) {
                definition.addReference(ps);
              }
            }
 else {
              break;
            }
          }
        }
      }
      if (TAG_ITEM.equals(tagName)) {
        if (element.getParentNode() != null && element.getParentNode().getNodeName().equals(TAG_STYLE)) {
          String name=element.getAttributeNS(ANDROID_URI,ATTR_NAME);
          if (!name.isEmpty() && !name.startsWith(""String_Node_Str"")) {
            Resource resource=getResource(ResourceType.ATTR,name);
            if (definition == null) {
              Element style=(Element)element.getParentNode();
              definition=getResource(style);
              if (definition != null) {
                from=definition;
                definition.addReference(resource);
              }
            }
          }
        }
      }
    }
  }
 else   if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) {
    String text=node.getNodeValue().trim();
    Resource textResource=getResourceFromUrl(LintUtils.getFieldName(text));
    if (textResource != null && from != null) {
      from.addReference(textResource);
    }
  }
  NodeList children=node.getChildNodes();
  for (int i=0, n=children.getLength(); i < n; i++) {
    Node child=children.item(i);
    recordResourceReferences(folderType,child,from);
  }
}",0.1222406181015452
110827,"public static ConfiguredTarget init(CppSemantics semantics,RuleContext ruleContext,boolean fake) throws InterruptedException, RuleErrorException {
  ruleContext.checkSrcsSamePackage(true);
  FeatureConfiguration featureConfiguration=CcCommon.configureFeatures(ruleContext);
  CcCommon common=new CcCommon(ruleContext);
  CppConfiguration cppConfiguration=ruleContext.getFragment(CppConfiguration.class);
  PrecompiledFiles precompiledFiles=new PrecompiledFiles(ruleContext);
  LinkTargetType linkType=isLinkShared(ruleContext) ? LinkTargetType.DYNAMIC_LIBRARY : LinkTargetType.EXECUTABLE;
  semantics.validateAttributes(ruleContext);
  if (ruleContext.hasErrors()) {
    return null;
  }
  CcLibraryHelper helper=new CcLibraryHelper(ruleContext,semantics,featureConfiguration).fromCommon(common).addSources(common.getSources()).addDeps(ImmutableList.of(CppHelper.mallocForTarget(ruleContext))).setFake(fake).addPrecompiledFiles(precompiledFiles).enableInterfaceSharedObjects();
  helper.setLinkType(ruleContext.isTestTarget() ? LinkTargetType.STATIC_LIBRARY : linkType);
  CcLibraryHelper.Info info=helper.build();
  CppCompilationContext cppCompilationContext=info.getCppCompilationContext();
  CcCompilationOutputs ccCompilationOutputs=info.getCcCompilationOutputs();
  PathFragment binaryPath=new PathFragment(ruleContext.getTarget().getName());
  if (!isLinkShared(ruleContext)) {
    binaryPath=new PathFragment(binaryPath.getPathString() + OsUtils.executableExtension());
  }
  Artifact binary=ruleContext.getBinArtifact(binaryPath);
  if (isLinkShared(ruleContext) && !CppFileTypes.SHARED_LIBRARY.matches(binary.getFilename()) && !CppFileTypes.VERSIONED_SHARED_LIBRARY.matches(binary.getFilename())) {
    ruleContext.attributeError(""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  List<String> linkopts=common.getLinkopts();
  LinkStaticness linkStaticness=getLinkStaticness(ruleContext,linkopts,cppConfiguration);
  CppLinkActionBuilder linkActionBuilder=determineLinkerArguments(ruleContext,common,precompiledFiles,info,cppCompilationContext.getTransitiveCompilationPrerequisites(),fake,binary,linkStaticness,linkopts);
  linkActionBuilder.setUseTestOnlyFlags(ruleContext.isTestTarget());
  CcToolchainProvider ccToolchain=CppHelper.getToolchain(ruleContext);
  if (linkStaticness == LinkStaticness.DYNAMIC) {
    linkActionBuilder.setRuntimeInputs(ArtifactCategory.DYNAMIC_LIBRARY,ccToolchain.getDynamicRuntimeLinkMiddleman(),ccToolchain.getDynamicRuntimeLinkInputs());
  }
 else {
    linkActionBuilder.setRuntimeInputs(ArtifactCategory.STATIC_LIBRARY,ccToolchain.getStaticRuntimeLinkMiddleman(),ccToolchain.getStaticRuntimeLinkInputs());
    if (!ccToolchain.getStaticRuntimeLinkInputs().isEmpty()) {
      linkActionBuilder.addLinkopt(""String_Node_Str"");
    }
  }
  linkActionBuilder.setLinkType(linkType);
  linkActionBuilder.setLinkStaticness(linkStaticness);
  linkActionBuilder.setFake(fake);
  linkActionBuilder.setFeatureConfiguration(featureConfiguration);
  if (CppLinkAction.enableSymbolsCounts(cppConfiguration,fake,linkType)) {
    linkActionBuilder.setSymbolCountsOutput(ruleContext.getBinArtifact(CppLinkAction.symbolCountsFileName(binaryPath)));
  }
  if (isLinkShared(ruleContext)) {
    linkActionBuilder.setLibraryIdentifier(CcLinkingOutputs.libraryIdentifierOf(binary));
  }
  CppLinkAction.Context linkContext=new CppLinkAction.Context(linkActionBuilder);
  if (featureConfiguration.isEnabled(CppRuleClasses.THIN_LTO)) {
    linkActionBuilder.setLTOIndexing(true);
    CppLinkAction indexAction=linkActionBuilder.build();
    ruleContext.registerAction(indexAction);
    for (    LTOBackendArtifacts ltoArtifacts : indexAction.getAllLTOBackendArtifacts()) {
      boolean usePic=CppHelper.usePic(ruleContext,!isLinkShared(ruleContext));
      ltoArtifacts.scheduleLTOBackendAction(ruleContext,featureConfiguration,usePic);
    }
    linkActionBuilder.setLTOIndexing(false);
  }
  CppLinkAction linkAction=linkActionBuilder.build();
  ruleContext.registerAction(linkAction);
  LibraryToLink outputLibrary=linkAction.getOutputLibrary();
  Iterable<Artifact> fakeLinkerInputs=fake ? linkAction.getInputs() : ImmutableList.<Artifact>of();
  Artifact executable=linkAction.getLinkOutput();
  CcLinkingOutputs.Builder linkingOutputsBuilder=new CcLinkingOutputs.Builder();
  if (isLinkShared(ruleContext)) {
    linkingOutputsBuilder.addDynamicLibrary(outputLibrary);
    linkingOutputsBuilder.addExecutionDynamicLibrary(outputLibrary);
  }
  for (  Artifact library : precompiledFiles.getSharedLibraries()) {
    Artifact symlink=common.getDynamicLibrarySymlink(library,true);
    LibraryToLink symlinkLibrary=LinkerInputs.solibLibraryToLink(symlink,library,CcLinkingOutputs.libraryIdentifierOf(library));
    linkingOutputsBuilder.addDynamicLibrary(symlinkLibrary);
    linkingOutputsBuilder.addExecutionDynamicLibrary(symlinkLibrary);
  }
  CcLinkingOutputs linkingOutputs=linkingOutputsBuilder.build();
  NestedSet<Artifact> filesToBuild=NestedSetBuilder.create(Order.STABLE_ORDER,executable);
  Artifact strippedFile=ruleContext.getImplicitOutputArtifact(CppRuleClasses.CC_BINARY_STRIPPED);
  CppHelper.createStripAction(ruleContext,cppConfiguration,executable,strippedFile);
  DwoArtifactsCollector dwoArtifacts=collectTransitiveDwoArtifacts(ruleContext,ccCompilationOutputs,linkStaticness);
  Artifact dwpFile=ruleContext.getImplicitOutputArtifact(CppRuleClasses.CC_BINARY_DEBUG_PACKAGE);
  createDebugPackagerActions(ruleContext,cppConfiguration,dwpFile,dwoArtifacts);
  Artifact explicitDwpFile=dwpFile;
  if (!cppConfiguration.useFission()) {
    explicitDwpFile=null;
  }
 else {
    if (TargetUtils.isTestRule(ruleContext.getRule()) && linkStaticness != LinkStaticness.DYNAMIC && cppConfiguration.shouldBuildTestDwp()) {
      filesToBuild=NestedSetBuilder.fromNestedSet(filesToBuild).add(dwpFile).build();
    }
  }
  Runfiles runfiles=collectRunfiles(ruleContext,linkingOutputs,info,linkStaticness,filesToBuild,fakeLinkerInputs,fake,helper.getCompilationUnitSources());
  RunfilesSupport runfilesSupport=RunfilesSupport.withExecutable(ruleContext,runfiles,executable,ruleContext.getConfiguration().buildRunfiles());
  TransitiveLipoInfoProvider transitiveLipoInfo;
  if (cppConfiguration.isLipoContextCollector()) {
    transitiveLipoInfo=common.collectTransitiveLipoLabels(ccCompilationOutputs);
  }
 else {
    transitiveLipoInfo=TransitiveLipoInfoProvider.EMPTY;
  }
  RuleConfiguredTargetBuilder ruleBuilder=new RuleConfiguredTargetBuilder(ruleContext);
  addTransitiveInfoProviders(ruleContext,cppConfiguration,common,ruleBuilder,filesToBuild,ccCompilationOutputs,cppCompilationContext,linkingOutputs,dwoArtifacts,transitiveLipoInfo,fake);
  Map<Artifact,IncludeScannable> scannableMap=new LinkedHashMap<>();
  Map<PathFragment,Artifact> sourceFileMap=new LinkedHashMap<>();
  if (cppConfiguration.isLipoContextCollector()) {
    for (    IncludeScannable scannable : transitiveLipoInfo.getTransitiveIncludeScannables()) {
      Artifact source=Iterables.getOnlyElement(scannable.getIncludeScannerSources());
      scannableMap.put(source,scannable);
      sourceFileMap.put(source.getExecPath(),source);
    }
  }
  if (Platform.isApplePlatform(cppConfiguration.getTargetCpu()) && TargetUtils.isTestRule(ruleContext.getRule())) {
    ruleBuilder.addNativeDeclaredProvider(new ExecutionInfoProvider(ImmutableMap.of(ExecutionRequirements.REQUIRES_DARWIN,""String_Node_Str"")));
  }
  return ruleBuilder.addProvider(RunfilesProvider.class,RunfilesProvider.simple(runfiles)).addProvider(CppDebugPackageProvider.class,new CppDebugPackageProvider(ruleContext.getLabel(),strippedFile,executable,explicitDwpFile)).setRunfilesSupport(runfilesSupport,executable).addProvider(LipoContextProvider.class,new LipoContextProvider(cppCompilationContext,ImmutableMap.copyOf(scannableMap),ImmutableMap.copyOf(sourceFileMap))).addProvider(CppLinkAction.Context.class,linkContext).addSkylarkTransitiveInfo(CcSkylarkApiProvider.NAME,new CcSkylarkApiProvider()).build();
}","public static ConfiguredTarget init(CppSemantics semantics,RuleContext ruleContext,boolean fake) throws InterruptedException, RuleErrorException {
  ruleContext.checkSrcsSamePackage(true);
  FeatureConfiguration featureConfiguration=CcCommon.configureFeatures(ruleContext);
  CcCommon common=new CcCommon(ruleContext);
  CppConfiguration cppConfiguration=ruleContext.getFragment(CppConfiguration.class);
  PrecompiledFiles precompiledFiles=new PrecompiledFiles(ruleContext);
  LinkTargetType linkType=isLinkShared(ruleContext) ? LinkTargetType.DYNAMIC_LIBRARY : LinkTargetType.EXECUTABLE;
  semantics.validateAttributes(ruleContext);
  if (ruleContext.hasErrors()) {
    return null;
  }
  List<String> linkopts=common.getLinkopts();
  LinkStaticness linkStaticness=getLinkStaticness(ruleContext,linkopts,cppConfiguration);
  boolean linkCompileOutputSeparately=ruleContext.isTestTarget() && cppConfiguration.getLinkCompileOutputSeparately() && linkStaticness == LinkStaticness.DYNAMIC;
  CcLibraryHelper helper=new CcLibraryHelper(ruleContext,semantics,featureConfiguration).fromCommon(common).addSources(common.getSources()).addDeps(ImmutableList.of(CppHelper.mallocForTarget(ruleContext))).setFake(fake).addPrecompiledFiles(precompiledFiles).enableInterfaceSharedObjects();
  helper.setLinkType(linkCompileOutputSeparately ? LinkTargetType.STATIC_LIBRARY : linkType);
  CcLibraryHelper.Info info=helper.build();
  CppCompilationContext cppCompilationContext=info.getCppCompilationContext();
  CcCompilationOutputs ccCompilationOutputs=info.getCcCompilationOutputs();
  PathFragment binaryPath=new PathFragment(ruleContext.getTarget().getName());
  if (!isLinkShared(ruleContext)) {
    binaryPath=new PathFragment(binaryPath.getPathString() + OsUtils.executableExtension());
  }
  Artifact binary=ruleContext.getBinArtifact(binaryPath);
  if (isLinkShared(ruleContext) && !CppFileTypes.SHARED_LIBRARY.matches(binary.getFilename()) && !CppFileTypes.VERSIONED_SHARED_LIBRARY.matches(binary.getFilename())) {
    ruleContext.attributeError(""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  CppLinkActionBuilder linkActionBuilder=determineLinkerArguments(ruleContext,common,precompiledFiles,info,cppCompilationContext.getTransitiveCompilationPrerequisites(),fake,binary,linkStaticness,linkopts,linkCompileOutputSeparately);
  linkActionBuilder.setUseTestOnlyFlags(ruleContext.isTestTarget());
  CcToolchainProvider ccToolchain=CppHelper.getToolchain(ruleContext);
  if (linkStaticness == LinkStaticness.DYNAMIC) {
    linkActionBuilder.setRuntimeInputs(ArtifactCategory.DYNAMIC_LIBRARY,ccToolchain.getDynamicRuntimeLinkMiddleman(),ccToolchain.getDynamicRuntimeLinkInputs());
  }
 else {
    linkActionBuilder.setRuntimeInputs(ArtifactCategory.STATIC_LIBRARY,ccToolchain.getStaticRuntimeLinkMiddleman(),ccToolchain.getStaticRuntimeLinkInputs());
    if (!ccToolchain.getStaticRuntimeLinkInputs().isEmpty()) {
      linkActionBuilder.addLinkopt(""String_Node_Str"");
    }
  }
  linkActionBuilder.setLinkType(linkType);
  linkActionBuilder.setLinkStaticness(linkStaticness);
  linkActionBuilder.setFake(fake);
  linkActionBuilder.setFeatureConfiguration(featureConfiguration);
  if (CppLinkAction.enableSymbolsCounts(cppConfiguration,fake,linkType)) {
    linkActionBuilder.setSymbolCountsOutput(ruleContext.getBinArtifact(CppLinkAction.symbolCountsFileName(binaryPath)));
  }
  if (isLinkShared(ruleContext)) {
    linkActionBuilder.setLibraryIdentifier(CcLinkingOutputs.libraryIdentifierOf(binary));
  }
  CppLinkAction.Context linkContext=new CppLinkAction.Context(linkActionBuilder);
  if (featureConfiguration.isEnabled(CppRuleClasses.THIN_LTO)) {
    linkActionBuilder.setLTOIndexing(true);
    CppLinkAction indexAction=linkActionBuilder.build();
    ruleContext.registerAction(indexAction);
    for (    LTOBackendArtifacts ltoArtifacts : indexAction.getAllLTOBackendArtifacts()) {
      boolean usePic=CppHelper.usePic(ruleContext,!isLinkShared(ruleContext));
      ltoArtifacts.scheduleLTOBackendAction(ruleContext,featureConfiguration,usePic);
    }
    linkActionBuilder.setLTOIndexing(false);
  }
  CppLinkAction linkAction=linkActionBuilder.build();
  ruleContext.registerAction(linkAction);
  LibraryToLink outputLibrary=linkAction.getOutputLibrary();
  Iterable<Artifact> fakeLinkerInputs=fake ? linkAction.getInputs() : ImmutableList.<Artifact>of();
  Artifact executable=linkAction.getLinkOutput();
  CcLinkingOutputs.Builder linkingOutputsBuilder=new CcLinkingOutputs.Builder();
  if (isLinkShared(ruleContext)) {
    linkingOutputsBuilder.addDynamicLibrary(outputLibrary);
    linkingOutputsBuilder.addExecutionDynamicLibrary(outputLibrary);
  }
  for (  Artifact library : precompiledFiles.getSharedLibraries()) {
    Artifact symlink=common.getDynamicLibrarySymlink(library,true);
    LibraryToLink symlinkLibrary=LinkerInputs.solibLibraryToLink(symlink,library,CcLinkingOutputs.libraryIdentifierOf(library));
    linkingOutputsBuilder.addDynamicLibrary(symlinkLibrary);
    linkingOutputsBuilder.addExecutionDynamicLibrary(symlinkLibrary);
  }
  CcLinkingOutputs linkingOutputs=linkingOutputsBuilder.build();
  NestedSet<Artifact> filesToBuild=NestedSetBuilder.create(Order.STABLE_ORDER,executable);
  Artifact strippedFile=ruleContext.getImplicitOutputArtifact(CppRuleClasses.CC_BINARY_STRIPPED);
  CppHelper.createStripAction(ruleContext,cppConfiguration,executable,strippedFile);
  DwoArtifactsCollector dwoArtifacts=collectTransitiveDwoArtifacts(ruleContext,ccCompilationOutputs,linkStaticness);
  Artifact dwpFile=ruleContext.getImplicitOutputArtifact(CppRuleClasses.CC_BINARY_DEBUG_PACKAGE);
  createDebugPackagerActions(ruleContext,cppConfiguration,dwpFile,dwoArtifacts);
  Artifact explicitDwpFile=dwpFile;
  if (!cppConfiguration.useFission()) {
    explicitDwpFile=null;
  }
 else {
    if (TargetUtils.isTestRule(ruleContext.getRule()) && linkStaticness != LinkStaticness.DYNAMIC && cppConfiguration.shouldBuildTestDwp()) {
      filesToBuild=NestedSetBuilder.fromNestedSet(filesToBuild).add(dwpFile).build();
    }
  }
  Runfiles runfiles=collectRunfiles(ruleContext,linkingOutputs,info,linkStaticness,filesToBuild,fakeLinkerInputs,fake,helper.getCompilationUnitSources(),linkCompileOutputSeparately);
  RunfilesSupport runfilesSupport=RunfilesSupport.withExecutable(ruleContext,runfiles,executable,ruleContext.getConfiguration().buildRunfiles());
  TransitiveLipoInfoProvider transitiveLipoInfo;
  if (cppConfiguration.isLipoContextCollector()) {
    transitiveLipoInfo=common.collectTransitiveLipoLabels(ccCompilationOutputs);
  }
 else {
    transitiveLipoInfo=TransitiveLipoInfoProvider.EMPTY;
  }
  RuleConfiguredTargetBuilder ruleBuilder=new RuleConfiguredTargetBuilder(ruleContext);
  addTransitiveInfoProviders(ruleContext,cppConfiguration,common,ruleBuilder,filesToBuild,ccCompilationOutputs,cppCompilationContext,linkingOutputs,dwoArtifacts,transitiveLipoInfo,fake);
  Map<Artifact,IncludeScannable> scannableMap=new LinkedHashMap<>();
  Map<PathFragment,Artifact> sourceFileMap=new LinkedHashMap<>();
  if (cppConfiguration.isLipoContextCollector()) {
    for (    IncludeScannable scannable : transitiveLipoInfo.getTransitiveIncludeScannables()) {
      Artifact source=Iterables.getOnlyElement(scannable.getIncludeScannerSources());
      scannableMap.put(source,scannable);
      sourceFileMap.put(source.getExecPath(),source);
    }
  }
  if (Platform.isApplePlatform(cppConfiguration.getTargetCpu()) && TargetUtils.isTestRule(ruleContext.getRule())) {
    ruleBuilder.addNativeDeclaredProvider(new ExecutionInfoProvider(ImmutableMap.of(ExecutionRequirements.REQUIRES_DARWIN,""String_Node_Str"")));
  }
  return ruleBuilder.addProvider(RunfilesProvider.class,RunfilesProvider.simple(runfiles)).addProvider(CppDebugPackageProvider.class,new CppDebugPackageProvider(ruleContext.getLabel(),strippedFile,executable,explicitDwpFile)).setRunfilesSupport(runfilesSupport,executable).addProvider(LipoContextProvider.class,new LipoContextProvider(cppCompilationContext,ImmutableMap.copyOf(scannableMap),ImmutableMap.copyOf(sourceFileMap))).addProvider(CppLinkAction.Context.class,linkContext).addSkylarkTransitiveInfo(CcSkylarkApiProvider.NAME,new CcSkylarkApiProvider()).build();
}",0.9664900825428114
110828,"private static Runfiles collectRunfiles(RuleContext context,CcLinkingOutputs linkingOutputs,CcLibraryHelper.Info info,LinkStaticness linkStaticness,NestedSet<Artifact> filesToBuild,Iterable<Artifact> fakeLinkerInputs,boolean fake,ImmutableSet<CppSource> cAndCppSources){
  Runfiles.Builder builder=new Runfiles.Builder(context.getWorkspaceName(),context.getConfiguration().legacyExternalRunfiles());
  Function<TransitiveInfoCollection,Runfiles> runfilesMapping=CppRunfilesProvider.runfilesFunction(linkStaticness != LinkStaticness.DYNAMIC);
  builder.addTransitiveArtifacts(filesToBuild);
  builder.addArtifacts(linkingOutputs.getLibrariesForRunfiles(true));
  builder.addRunfiles(context,RunfilesProvider.DEFAULT_RUNFILES);
  builder.add(context,runfilesMapping);
  CcToolchainProvider toolchain=CppHelper.getToolchain(context);
  if (linkStaticness == LinkStaticness.DYNAMIC) {
    builder.addTransitiveArtifacts(toolchain.getDynamicRuntimeLinkInputs());
    CppConfiguration cppConfiguration=context.getFragment(CppConfiguration.class);
    if (cppConfiguration.getLinkDynamicBinariesSeparately()) {
      builder.addArtifacts(LinkerInputs.toLibraryArtifacts(info.getCcLinkingOutputs().getExecutionDynamicLibraries()));
    }
  }
  boolean linkshared=isLinkShared(context);
  if (!linkshared) {
    TransitiveInfoCollection malloc=CppHelper.mallocForTarget(context);
    builder.addTarget(malloc,RunfilesProvider.DEFAULT_RUNFILES);
    builder.addTarget(malloc,runfilesMapping);
  }
  if (fake) {
    builder.addSymlinksToArtifacts(Iterables.filter(fakeLinkerInputs,Artifact.MIDDLEMAN_FILTER));
    builder.addTransitiveArtifacts(toolchain.getCrosstool());
    builder.addTransitiveArtifacts(toolchain.getLibcLink());
    ImmutableSet.Builder<Artifact> sourcesBuilder=ImmutableSet.<Artifact>builder();
    for (    CppSource cppSource : cAndCppSources) {
      sourcesBuilder.add(cppSource.getSource());
    }
    builder.addSymlinksToArtifacts(sourcesBuilder.build());
    CppCompilationContext cppCompilationContext=info.getCppCompilationContext();
    builder.addSymlinksToArtifacts(cppCompilationContext.getDeclaredIncludeSrcs());
    builder.addSymlinksToArtifacts(cppCompilationContext.getAdditionalInputs());
    builder.addSymlinksToArtifacts(cppCompilationContext.getTransitiveModules(CppHelper.usePic(context,!isLinkShared(context))));
  }
  return builder.build();
}","private static Runfiles collectRunfiles(RuleContext context,CcLinkingOutputs linkingOutputs,CcLibraryHelper.Info info,LinkStaticness linkStaticness,NestedSet<Artifact> filesToBuild,Iterable<Artifact> fakeLinkerInputs,boolean fake,ImmutableSet<CppSource> cAndCppSources,boolean linkCompileOutputSeparately){
  Runfiles.Builder builder=new Runfiles.Builder(context.getWorkspaceName(),context.getConfiguration().legacyExternalRunfiles());
  Function<TransitiveInfoCollection,Runfiles> runfilesMapping=CppRunfilesProvider.runfilesFunction(linkStaticness != LinkStaticness.DYNAMIC);
  builder.addTransitiveArtifacts(filesToBuild);
  builder.addArtifacts(linkingOutputs.getLibrariesForRunfiles(true));
  builder.addRunfiles(context,RunfilesProvider.DEFAULT_RUNFILES);
  builder.add(context,runfilesMapping);
  CcToolchainProvider toolchain=CppHelper.getToolchain(context);
  if (linkStaticness == LinkStaticness.DYNAMIC) {
    builder.addTransitiveArtifacts(toolchain.getDynamicRuntimeLinkInputs());
  }
  if (linkCompileOutputSeparately) {
    builder.addArtifacts(LinkerInputs.toLibraryArtifacts(info.getCcLinkingOutputs().getExecutionDynamicLibraries()));
  }
  boolean linkshared=isLinkShared(context);
  if (!linkshared) {
    TransitiveInfoCollection malloc=CppHelper.mallocForTarget(context);
    builder.addTarget(malloc,RunfilesProvider.DEFAULT_RUNFILES);
    builder.addTarget(malloc,runfilesMapping);
  }
  if (fake) {
    builder.addSymlinksToArtifacts(Iterables.filter(fakeLinkerInputs,Artifact.MIDDLEMAN_FILTER));
    builder.addTransitiveArtifacts(toolchain.getCrosstool());
    builder.addTransitiveArtifacts(toolchain.getLibcLink());
    ImmutableSet.Builder<Artifact> sourcesBuilder=ImmutableSet.<Artifact>builder();
    for (    CppSource cppSource : cAndCppSources) {
      sourcesBuilder.add(cppSource.getSource());
    }
    builder.addSymlinksToArtifacts(sourcesBuilder.build());
    CppCompilationContext cppCompilationContext=info.getCppCompilationContext();
    builder.addSymlinksToArtifacts(cppCompilationContext.getDeclaredIncludeSrcs());
    builder.addSymlinksToArtifacts(cppCompilationContext.getAdditionalInputs());
    builder.addSymlinksToArtifacts(cppCompilationContext.getTransitiveModules(CppHelper.usePic(context,!isLinkShared(context))));
  }
  return builder.build();
}",0.910992529348986
110829,"/** 
 * Given 'temps', traverse this target and its dependencies and collect up all the object files, libraries, linker options, linkstamps attributes and linker scripts.
 */
private static CppLinkActionBuilder determineLinkerArguments(RuleContext context,CcCommon common,PrecompiledFiles precompiledFiles,CcLibraryHelper.Info info,ImmutableSet<Artifact> compilationPrerequisites,boolean fake,Artifact binary,LinkStaticness linkStaticness,List<String> linkopts) throws InterruptedException {
  CppLinkActionBuilder builder=new CppLinkActionBuilder(context,binary).setCrosstoolInputs(CppHelper.getToolchain(context).getLink()).addNonCodeInputs(compilationPrerequisites);
  CppConfiguration cppConfiguration=context.getFragment(CppConfiguration.class);
  if (cppConfiguration.getLinkDynamicBinariesSeparately() && linkStaticness == LinkStaticness.DYNAMIC) {
    for (    LibraryToLink library : info.getCcLinkingOutputs().getDynamicLibraries()) {
      builder.addLibrary(library);
    }
  }
 else {
    boolean usePic=CppHelper.usePic(context,!isLinkShared(context));
    Iterable<Artifact> objectFiles=info.getCcCompilationOutputs().getObjectFiles(usePic);
    if (fake) {
      builder.addFakeObjectFiles(objectFiles);
    }
 else {
      builder.addObjectFiles(objectFiles);
    }
  }
  builder.addLTOBitcodeFiles(info.getCcCompilationOutputs().getLtoBitcodeFiles());
  builder.addNonCodeInputs(common.getLinkerScripts());
  for (  Artifact library : precompiledFiles.getLibraries()) {
    if (Link.SHARED_LIBRARY_FILETYPES.matches(library.getFilename())) {
      builder.addLibrary(LinkerInputs.solibLibraryToLink(common.getDynamicLibrarySymlink(library,true),library,CcLinkingOutputs.libraryIdentifierOf(library)));
    }
 else     if (Link.LINK_LIBRARY_FILETYPES.matches(library.getFilename())) {
      builder.addLibrary(LinkerInputs.precompiledLibraryToLink(library,ArtifactCategory.ALWAYSLINK_STATIC_LIBRARY));
    }
 else     if (Link.ARCHIVE_FILETYPES.matches(library.getFilename())) {
      builder.addLibrary(LinkerInputs.precompiledLibraryToLink(library,ArtifactCategory.STATIC_LIBRARY));
    }
 else {
      throw new IllegalStateException();
    }
  }
  CcLinkParams linkParams=collectCcLinkParams(context,linkStaticness != LinkStaticness.DYNAMIC,isLinkShared(context),linkopts);
  builder.addLinkParams(linkParams,context);
  return builder;
}","/** 
 * Given 'temps', traverse this target and its dependencies and collect up all the object files, libraries, linker options, linkstamps attributes and linker scripts.
 */
private static CppLinkActionBuilder determineLinkerArguments(RuleContext context,CcCommon common,PrecompiledFiles precompiledFiles,CcLibraryHelper.Info info,ImmutableSet<Artifact> compilationPrerequisites,boolean fake,Artifact binary,LinkStaticness linkStaticness,List<String> linkopts,boolean linkCompileOutputSeparately) throws InterruptedException {
  CppLinkActionBuilder builder=new CppLinkActionBuilder(context,binary).setCrosstoolInputs(CppHelper.getToolchain(context).getLink()).addNonCodeInputs(compilationPrerequisites);
  if (linkCompileOutputSeparately) {
    for (    LibraryToLink library : info.getCcLinkingOutputs().getDynamicLibraries()) {
      builder.addLibrary(library);
    }
  }
 else {
    boolean usePic=CppHelper.usePic(context,!isLinkShared(context));
    Iterable<Artifact> objectFiles=info.getCcCompilationOutputs().getObjectFiles(usePic);
    if (fake) {
      builder.addFakeObjectFiles(objectFiles);
    }
 else {
      builder.addObjectFiles(objectFiles);
    }
  }
  builder.addLTOBitcodeFiles(info.getCcCompilationOutputs().getLtoBitcodeFiles());
  builder.addNonCodeInputs(common.getLinkerScripts());
  for (  Artifact library : precompiledFiles.getLibraries()) {
    if (Link.SHARED_LIBRARY_FILETYPES.matches(library.getFilename())) {
      builder.addLibrary(LinkerInputs.solibLibraryToLink(common.getDynamicLibrarySymlink(library,true),library,CcLinkingOutputs.libraryIdentifierOf(library)));
    }
 else     if (Link.LINK_LIBRARY_FILETYPES.matches(library.getFilename())) {
      builder.addLibrary(LinkerInputs.precompiledLibraryToLink(library,ArtifactCategory.ALWAYSLINK_STATIC_LIBRARY));
    }
 else     if (Link.ARCHIVE_FILETYPES.matches(library.getFilename())) {
      builder.addLibrary(LinkerInputs.precompiledLibraryToLink(library,ArtifactCategory.STATIC_LIBRARY));
    }
 else {
      throw new IllegalStateException();
    }
  }
  CcLinkParams linkParams=collectCcLinkParams(context,linkStaticness != LinkStaticness.DYNAMIC,isLinkShared(context),linkopts);
  builder.addLinkParams(linkParams,context);
  return builder;
}",0.9511400651465798
110830,"@Test public void testCompilesTestSourcesIntoDynamicLibrary() throws Exception {
  if (OS.getCurrent() == OS.WINDOWS) {
    return;
  }
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  useConfiguration(""String_Node_Str"");
  ConfiguredTarget configuredTarget=getConfiguredTarget(""String_Node_Str"");
  CppLinkAction linkAction=(CppLinkAction)getGeneratingAction(configuredTarget,""String_Node_Str"" + OsUtils.executableExtension());
  assertThat(artifactsToStrings(linkAction.getInputs())).contains(""String_Node_Str"" + CrosstoolConfigurationHelper.defaultCpu() + ""String_Node_Str"");
  assertThat(linkAction.getArguments()).contains(getBinArtifactWithNoOwner(""String_Node_Str"" + CrosstoolConfigurationHelper.defaultCpu() + ""String_Node_Str"").getExecPathString());
  RunfilesProvider runfilesProvider=configuredTarget.getProvider(RunfilesProvider.class);
  assertThat(artifactsToStrings(runfilesProvider.getDefaultRunfiles().getArtifacts())).contains(""String_Node_Str"" + CrosstoolConfigurationHelper.defaultCpu() + ""String_Node_Str"");
}","@Test public void testCompilesTestSourcesIntoDynamicLibrary() throws Exception {
  if (OS.getCurrent() == OS.WINDOWS) {
    return;
  }
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  useConfiguration(""String_Node_Str"",""String_Node_Str"");
  ConfiguredTarget configuredTarget=getConfiguredTarget(""String_Node_Str"");
  String cpu=CrosstoolConfigurationHelper.defaultCpu();
  String extension=OsUtils.executableExtension();
  CppLinkAction linkAction=(CppLinkAction)getGeneratingAction(configuredTarget,""String_Node_Str"" + extension);
  assertThat(artifactsToStrings(linkAction.getInputs())).contains(""String_Node_Str"" + cpu + ""String_Node_Str"");
  assertThat(linkAction.getArguments()).contains(getBinArtifactWithNoOwner(""String_Node_Str"" + cpu + ""String_Node_Str"").getExecPathString());
  RunfilesProvider runfilesProvider=configuredTarget.getProvider(RunfilesProvider.class);
  assertThat(artifactsToStrings(runfilesProvider.getDefaultRunfiles().getArtifacts())).contains(""String_Node_Str"" + cpu + ""String_Node_Str"");
  configuredTarget=getConfiguredTarget(""String_Node_Str"");
  linkAction=(CppLinkAction)getGeneratingAction(configuredTarget,""String_Node_Str"" + extension);
  assertThat(artifactsToStrings(linkAction.getInputs())).contains(""String_Node_Str"");
  runfilesProvider=configuredTarget.getProvider(RunfilesProvider.class);
  assertThat(artifactsToStrings(runfilesProvider.getDefaultRunfiles().getArtifacts())).containsExactly(""String_Node_Str"");
}",0.3856707317073171
110831,"public static ConfiguredTarget init(CppSemantics semantics,RuleContext ruleContext,boolean fake) throws InterruptedException, RuleErrorException {
  ruleContext.checkSrcsSamePackage(true);
  FeatureConfiguration featureConfiguration=CcCommon.configureFeatures(ruleContext);
  CcCommon common=new CcCommon(ruleContext);
  CppConfiguration cppConfiguration=ruleContext.getFragment(CppConfiguration.class);
  PrecompiledFiles precompiledFiles=new PrecompiledFiles(ruleContext);
  semantics.validateAttributes(ruleContext);
  if (ruleContext.hasErrors()) {
    return null;
  }
  CcLibraryHelper helper=new CcLibraryHelper(ruleContext,semantics,featureConfiguration).fromCommon(common).addSources(common.getSources()).addDeps(ImmutableList.of(CppHelper.mallocForTarget(ruleContext))).setFake(fake).setLinkType(LinkTargetType.STATIC_LIBRARY).addPrecompiledFiles(precompiledFiles).enableInterfaceSharedObjects();
  CcLibraryHelper.Info info=helper.build();
  CppCompilationContext cppCompilationContext=info.getCppCompilationContext();
  CcCompilationOutputs ccCompilationOutputs=info.getCcCompilationOutputs();
  PathFragment binaryPath=new PathFragment(ruleContext.getTarget().getName());
  if (!isLinkShared(ruleContext)) {
    binaryPath=new PathFragment(binaryPath.getPathString() + OsUtils.executableExtension());
  }
  Artifact binary=ruleContext.getBinArtifact(binaryPath);
  if (isLinkShared(ruleContext) && !CppFileTypes.SHARED_LIBRARY.matches(binary.getFilename()) && !CppFileTypes.VERSIONED_SHARED_LIBRARY.matches(binary.getFilename())) {
    ruleContext.attributeError(""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  LinkTargetType linkType=isLinkShared(ruleContext) ? LinkTargetType.DYNAMIC_LIBRARY : LinkTargetType.EXECUTABLE;
  List<String> linkopts=common.getLinkopts();
  LinkStaticness linkStaticness=getLinkStaticness(ruleContext,linkopts,cppConfiguration);
  CppLinkActionBuilder linkActionBuilder=determineLinkerArguments(ruleContext,common,precompiledFiles,info,cppCompilationContext.getTransitiveCompilationPrerequisites(),fake,binary,linkStaticness,linkopts);
  linkActionBuilder.setUseTestOnlyFlags(ruleContext.isTestTarget());
  CcToolchainProvider ccToolchain=CppHelper.getToolchain(ruleContext);
  if (linkStaticness == LinkStaticness.DYNAMIC) {
    linkActionBuilder.setRuntimeInputs(ArtifactCategory.DYNAMIC_LIBRARY,ccToolchain.getDynamicRuntimeLinkMiddleman(),ccToolchain.getDynamicRuntimeLinkInputs());
  }
 else {
    linkActionBuilder.setRuntimeInputs(ArtifactCategory.STATIC_LIBRARY,ccToolchain.getStaticRuntimeLinkMiddleman(),ccToolchain.getStaticRuntimeLinkInputs());
    if (!ccToolchain.getStaticRuntimeLinkInputs().isEmpty()) {
      linkActionBuilder.addLinkopt(""String_Node_Str"");
    }
  }
  linkActionBuilder.setLinkType(linkType);
  linkActionBuilder.setLinkStaticness(linkStaticness);
  linkActionBuilder.setFake(fake);
  linkActionBuilder.setFeatureConfiguration(featureConfiguration);
  if (CppLinkAction.enableSymbolsCounts(cppConfiguration,fake,linkType)) {
    linkActionBuilder.setSymbolCountsOutput(ruleContext.getBinArtifact(CppLinkAction.symbolCountsFileName(binaryPath)));
  }
  if (isLinkShared(ruleContext)) {
    linkActionBuilder.setLibraryIdentifier(CcLinkingOutputs.libraryIdentifierOf(binary));
  }
  CppLinkAction.Context linkContext=new CppLinkAction.Context(linkActionBuilder);
  if (featureConfiguration.isEnabled(CppRuleClasses.THIN_LTO)) {
    linkActionBuilder.setLTOIndexing(true);
    CppLinkAction indexAction=linkActionBuilder.build();
    ruleContext.registerAction(indexAction);
    for (    LTOBackendArtifacts ltoArtifacts : indexAction.getAllLTOBackendArtifacts()) {
      boolean usePic=CppHelper.usePic(ruleContext,!isLinkShared(ruleContext));
      ltoArtifacts.scheduleLTOBackendAction(ruleContext,featureConfiguration,usePic);
    }
    linkActionBuilder.setLTOIndexing(false);
  }
  CppLinkAction linkAction=linkActionBuilder.build();
  ruleContext.registerAction(linkAction);
  LibraryToLink outputLibrary=linkAction.getOutputLibrary();
  Iterable<Artifact> fakeLinkerInputs=fake ? linkAction.getInputs() : ImmutableList.<Artifact>of();
  Artifact executable=linkAction.getLinkOutput();
  CcLinkingOutputs.Builder linkingOutputsBuilder=new CcLinkingOutputs.Builder();
  if (isLinkShared(ruleContext)) {
    linkingOutputsBuilder.addDynamicLibrary(outputLibrary);
    linkingOutputsBuilder.addExecutionDynamicLibrary(outputLibrary);
  }
  for (  Artifact library : precompiledFiles.getSharedLibraries()) {
    Artifact symlink=common.getDynamicLibrarySymlink(library,true);
    LibraryToLink symlinkLibrary=LinkerInputs.solibLibraryToLink(symlink,library,CcLinkingOutputs.libraryIdentifierOf(library));
    linkingOutputsBuilder.addDynamicLibrary(symlinkLibrary);
    linkingOutputsBuilder.addExecutionDynamicLibrary(symlinkLibrary);
  }
  CcLinkingOutputs linkingOutputs=linkingOutputsBuilder.build();
  NestedSet<Artifact> filesToBuild=NestedSetBuilder.create(Order.STABLE_ORDER,executable);
  Artifact strippedFile=ruleContext.getImplicitOutputArtifact(CppRuleClasses.CC_BINARY_STRIPPED);
  CppHelper.createStripAction(ruleContext,cppConfiguration,executable,strippedFile);
  DwoArtifactsCollector dwoArtifacts=collectTransitiveDwoArtifacts(ruleContext,ccCompilationOutputs,linkStaticness);
  Artifact dwpFile=ruleContext.getImplicitOutputArtifact(CppRuleClasses.CC_BINARY_DEBUG_PACKAGE);
  createDebugPackagerActions(ruleContext,cppConfiguration,dwpFile,dwoArtifacts);
  Artifact explicitDwpFile=dwpFile;
  if (!cppConfiguration.useFission()) {
    explicitDwpFile=null;
  }
 else {
    if (TargetUtils.isTestRule(ruleContext.getRule()) && linkStaticness != LinkStaticness.DYNAMIC && cppConfiguration.shouldBuildTestDwp()) {
      filesToBuild=NestedSetBuilder.fromNestedSet(filesToBuild).add(dwpFile).build();
    }
  }
  Runfiles runfiles=collectRunfiles(ruleContext,linkingOutputs,info,linkStaticness,filesToBuild,fakeLinkerInputs,fake,helper.getCompilationUnitSources());
  RunfilesSupport runfilesSupport=RunfilesSupport.withExecutable(ruleContext,runfiles,executable,ruleContext.getConfiguration().buildRunfiles());
  TransitiveLipoInfoProvider transitiveLipoInfo;
  if (cppConfiguration.isLipoContextCollector()) {
    transitiveLipoInfo=common.collectTransitiveLipoLabels(ccCompilationOutputs);
  }
 else {
    transitiveLipoInfo=TransitiveLipoInfoProvider.EMPTY;
  }
  RuleConfiguredTargetBuilder ruleBuilder=new RuleConfiguredTargetBuilder(ruleContext);
  addTransitiveInfoProviders(ruleContext,cppConfiguration,common,ruleBuilder,filesToBuild,ccCompilationOutputs,cppCompilationContext,linkingOutputs,dwoArtifacts,transitiveLipoInfo,fake);
  Map<Artifact,IncludeScannable> scannableMap=new LinkedHashMap<>();
  Map<PathFragment,Artifact> sourceFileMap=new LinkedHashMap<>();
  if (cppConfiguration.isLipoContextCollector()) {
    for (    IncludeScannable scannable : transitiveLipoInfo.getTransitiveIncludeScannables()) {
      Artifact source=Iterables.getOnlyElement(scannable.getIncludeScannerSources());
      scannableMap.put(source,scannable);
      sourceFileMap.put(source.getExecPath(),source);
    }
  }
  if (Platform.isApplePlatform(cppConfiguration.getTargetCpu()) && TargetUtils.isTestRule(ruleContext.getRule())) {
    ruleBuilder.addNativeDeclaredProvider(new ExecutionInfoProvider(ImmutableMap.of(""String_Node_Str"",""String_Node_Str"")));
  }
  return ruleBuilder.addProvider(RunfilesProvider.class,RunfilesProvider.simple(runfiles)).addProvider(CppDebugPackageProvider.class,new CppDebugPackageProvider(ruleContext.getLabel(),strippedFile,executable,explicitDwpFile)).setRunfilesSupport(runfilesSupport,executable).addProvider(LipoContextProvider.class,new LipoContextProvider(cppCompilationContext,ImmutableMap.copyOf(scannableMap),ImmutableMap.copyOf(sourceFileMap))).addProvider(CppLinkAction.Context.class,linkContext).addSkylarkTransitiveInfo(CcSkylarkApiProvider.NAME,new CcSkylarkApiProvider()).build();
}","public static ConfiguredTarget init(CppSemantics semantics,RuleContext ruleContext,boolean fake) throws InterruptedException, RuleErrorException {
  ruleContext.checkSrcsSamePackage(true);
  FeatureConfiguration featureConfiguration=CcCommon.configureFeatures(ruleContext);
  CcCommon common=new CcCommon(ruleContext);
  CppConfiguration cppConfiguration=ruleContext.getFragment(CppConfiguration.class);
  PrecompiledFiles precompiledFiles=new PrecompiledFiles(ruleContext);
  LinkTargetType linkType=isLinkShared(ruleContext) ? LinkTargetType.DYNAMIC_LIBRARY : LinkTargetType.EXECUTABLE;
  semantics.validateAttributes(ruleContext);
  if (ruleContext.hasErrors()) {
    return null;
  }
  CcLibraryHelper helper=new CcLibraryHelper(ruleContext,semantics,featureConfiguration).fromCommon(common).addSources(common.getSources()).addDeps(ImmutableList.of(CppHelper.mallocForTarget(ruleContext))).setFake(fake).addPrecompiledFiles(precompiledFiles).enableInterfaceSharedObjects();
  helper.setLinkType(ruleContext.isTestTarget() ? LinkTargetType.STATIC_LIBRARY : linkType);
  CcLibraryHelper.Info info=helper.build();
  CppCompilationContext cppCompilationContext=info.getCppCompilationContext();
  CcCompilationOutputs ccCompilationOutputs=info.getCcCompilationOutputs();
  PathFragment binaryPath=new PathFragment(ruleContext.getTarget().getName());
  if (!isLinkShared(ruleContext)) {
    binaryPath=new PathFragment(binaryPath.getPathString() + OsUtils.executableExtension());
  }
  Artifact binary=ruleContext.getBinArtifact(binaryPath);
  if (isLinkShared(ruleContext) && !CppFileTypes.SHARED_LIBRARY.matches(binary.getFilename()) && !CppFileTypes.VERSIONED_SHARED_LIBRARY.matches(binary.getFilename())) {
    ruleContext.attributeError(""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  List<String> linkopts=common.getLinkopts();
  LinkStaticness linkStaticness=getLinkStaticness(ruleContext,linkopts,cppConfiguration);
  CppLinkActionBuilder linkActionBuilder=determineLinkerArguments(ruleContext,common,precompiledFiles,info,cppCompilationContext.getTransitiveCompilationPrerequisites(),fake,binary,linkStaticness,linkopts);
  linkActionBuilder.setUseTestOnlyFlags(ruleContext.isTestTarget());
  CcToolchainProvider ccToolchain=CppHelper.getToolchain(ruleContext);
  if (linkStaticness == LinkStaticness.DYNAMIC) {
    linkActionBuilder.setRuntimeInputs(ArtifactCategory.DYNAMIC_LIBRARY,ccToolchain.getDynamicRuntimeLinkMiddleman(),ccToolchain.getDynamicRuntimeLinkInputs());
  }
 else {
    linkActionBuilder.setRuntimeInputs(ArtifactCategory.STATIC_LIBRARY,ccToolchain.getStaticRuntimeLinkMiddleman(),ccToolchain.getStaticRuntimeLinkInputs());
    if (!ccToolchain.getStaticRuntimeLinkInputs().isEmpty()) {
      linkActionBuilder.addLinkopt(""String_Node_Str"");
    }
  }
  linkActionBuilder.setLinkType(linkType);
  linkActionBuilder.setLinkStaticness(linkStaticness);
  linkActionBuilder.setFake(fake);
  linkActionBuilder.setFeatureConfiguration(featureConfiguration);
  if (CppLinkAction.enableSymbolsCounts(cppConfiguration,fake,linkType)) {
    linkActionBuilder.setSymbolCountsOutput(ruleContext.getBinArtifact(CppLinkAction.symbolCountsFileName(binaryPath)));
  }
  if (isLinkShared(ruleContext)) {
    linkActionBuilder.setLibraryIdentifier(CcLinkingOutputs.libraryIdentifierOf(binary));
  }
  CppLinkAction.Context linkContext=new CppLinkAction.Context(linkActionBuilder);
  if (featureConfiguration.isEnabled(CppRuleClasses.THIN_LTO)) {
    linkActionBuilder.setLTOIndexing(true);
    CppLinkAction indexAction=linkActionBuilder.build();
    ruleContext.registerAction(indexAction);
    for (    LTOBackendArtifacts ltoArtifacts : indexAction.getAllLTOBackendArtifacts()) {
      boolean usePic=CppHelper.usePic(ruleContext,!isLinkShared(ruleContext));
      ltoArtifacts.scheduleLTOBackendAction(ruleContext,featureConfiguration,usePic);
    }
    linkActionBuilder.setLTOIndexing(false);
  }
  CppLinkAction linkAction=linkActionBuilder.build();
  ruleContext.registerAction(linkAction);
  LibraryToLink outputLibrary=linkAction.getOutputLibrary();
  Iterable<Artifact> fakeLinkerInputs=fake ? linkAction.getInputs() : ImmutableList.<Artifact>of();
  Artifact executable=linkAction.getLinkOutput();
  CcLinkingOutputs.Builder linkingOutputsBuilder=new CcLinkingOutputs.Builder();
  if (isLinkShared(ruleContext)) {
    linkingOutputsBuilder.addDynamicLibrary(outputLibrary);
    linkingOutputsBuilder.addExecutionDynamicLibrary(outputLibrary);
  }
  for (  Artifact library : precompiledFiles.getSharedLibraries()) {
    Artifact symlink=common.getDynamicLibrarySymlink(library,true);
    LibraryToLink symlinkLibrary=LinkerInputs.solibLibraryToLink(symlink,library,CcLinkingOutputs.libraryIdentifierOf(library));
    linkingOutputsBuilder.addDynamicLibrary(symlinkLibrary);
    linkingOutputsBuilder.addExecutionDynamicLibrary(symlinkLibrary);
  }
  CcLinkingOutputs linkingOutputs=linkingOutputsBuilder.build();
  NestedSet<Artifact> filesToBuild=NestedSetBuilder.create(Order.STABLE_ORDER,executable);
  Artifact strippedFile=ruleContext.getImplicitOutputArtifact(CppRuleClasses.CC_BINARY_STRIPPED);
  CppHelper.createStripAction(ruleContext,cppConfiguration,executable,strippedFile);
  DwoArtifactsCollector dwoArtifacts=collectTransitiveDwoArtifacts(ruleContext,ccCompilationOutputs,linkStaticness);
  Artifact dwpFile=ruleContext.getImplicitOutputArtifact(CppRuleClasses.CC_BINARY_DEBUG_PACKAGE);
  createDebugPackagerActions(ruleContext,cppConfiguration,dwpFile,dwoArtifacts);
  Artifact explicitDwpFile=dwpFile;
  if (!cppConfiguration.useFission()) {
    explicitDwpFile=null;
  }
 else {
    if (TargetUtils.isTestRule(ruleContext.getRule()) && linkStaticness != LinkStaticness.DYNAMIC && cppConfiguration.shouldBuildTestDwp()) {
      filesToBuild=NestedSetBuilder.fromNestedSet(filesToBuild).add(dwpFile).build();
    }
  }
  Runfiles runfiles=collectRunfiles(ruleContext,linkingOutputs,info,linkStaticness,filesToBuild,fakeLinkerInputs,fake,helper.getCompilationUnitSources());
  RunfilesSupport runfilesSupport=RunfilesSupport.withExecutable(ruleContext,runfiles,executable,ruleContext.getConfiguration().buildRunfiles());
  TransitiveLipoInfoProvider transitiveLipoInfo;
  if (cppConfiguration.isLipoContextCollector()) {
    transitiveLipoInfo=common.collectTransitiveLipoLabels(ccCompilationOutputs);
  }
 else {
    transitiveLipoInfo=TransitiveLipoInfoProvider.EMPTY;
  }
  RuleConfiguredTargetBuilder ruleBuilder=new RuleConfiguredTargetBuilder(ruleContext);
  addTransitiveInfoProviders(ruleContext,cppConfiguration,common,ruleBuilder,filesToBuild,ccCompilationOutputs,cppCompilationContext,linkingOutputs,dwoArtifacts,transitiveLipoInfo,fake);
  Map<Artifact,IncludeScannable> scannableMap=new LinkedHashMap<>();
  Map<PathFragment,Artifact> sourceFileMap=new LinkedHashMap<>();
  if (cppConfiguration.isLipoContextCollector()) {
    for (    IncludeScannable scannable : transitiveLipoInfo.getTransitiveIncludeScannables()) {
      Artifact source=Iterables.getOnlyElement(scannable.getIncludeScannerSources());
      scannableMap.put(source,scannable);
      sourceFileMap.put(source.getExecPath(),source);
    }
  }
  if (Platform.isApplePlatform(cppConfiguration.getTargetCpu()) && TargetUtils.isTestRule(ruleContext.getRule())) {
    ruleBuilder.addNativeDeclaredProvider(new ExecutionInfoProvider(ImmutableMap.of(""String_Node_Str"",""String_Node_Str"")));
  }
  return ruleBuilder.addProvider(RunfilesProvider.class,RunfilesProvider.simple(runfiles)).addProvider(CppDebugPackageProvider.class,new CppDebugPackageProvider(ruleContext.getLabel(),strippedFile,executable,explicitDwpFile)).setRunfilesSupport(runfilesSupport,executable).addProvider(LipoContextProvider.class,new LipoContextProvider(cppCompilationContext,ImmutableMap.copyOf(scannableMap),ImmutableMap.copyOf(sourceFileMap))).addProvider(CppLinkAction.Context.class,linkContext).addSkylarkTransitiveInfo(CcSkylarkApiProvider.NAME,new CcSkylarkApiProvider()).build();
}",0.9409696056267268
110832,"private static void checkCompositeSkylarkObjectSafe(Object object){
  if (object instanceof SkylarkApiProvider) {
    return;
  }
 else   if (object instanceof SkylarkList) {
    SkylarkList list=(SkylarkList)object;
    if (list.isEmpty()) {
      return;
    }
    for (    Object listItem : list) {
      checkSkylarkObjectSafe(listItem);
    }
    return;
  }
 else   if (object instanceof SkylarkNestedSet) {
    Class<?> contentType=((SkylarkNestedSet)object).getContentType().getType();
    if (!contentType.equals(Object.class) && !isSimpleSkylarkObjectSafe(contentType)) {
      throw new IllegalArgumentException(EvalUtils.getDataTypeName(contentType));
    }
    return;
  }
 else   if (object instanceof Map<?,?>) {
    for (    Map.Entry<?,?> entry : ((Map<?,?>)object).entrySet()) {
      checkSkylarkObjectSafe(entry.getKey());
      checkSkylarkObjectSafe(entry.getValue());
    }
    return;
  }
 else   if (object instanceof ClassObject) {
    ClassObject struct=(ClassObject)object;
    for (    String key : struct.getKeys()) {
      checkSkylarkObjectSafe(struct.getValue(key));
    }
    return;
  }
  throw new IllegalArgumentException(EvalUtils.getDataTypeName(object));
}","private static void checkCompositeSkylarkObjectSafe(Object object){
  if (object instanceof SkylarkApiProvider) {
    return;
  }
 else   if (object instanceof SkylarkList) {
    SkylarkList list=(SkylarkList)object;
    if (list.isEmpty()) {
      return;
    }
    for (    Object listItem : list) {
      checkSkylarkObjectSafe(listItem);
    }
    return;
  }
 else   if (object instanceof SkylarkNestedSet) {
    Class<?> contentType=((SkylarkNestedSet)object).getContentType().getType();
    if (!contentType.equals(Object.class) && !isSimpleSkylarkObjectSafe(contentType)) {
      throw new IllegalArgumentException(EvalUtils.getDataTypeNameFromClass(contentType));
    }
    return;
  }
 else   if (object instanceof Map<?,?>) {
    for (    Map.Entry<?,?> entry : ((Map<?,?>)object).entrySet()) {
      checkSkylarkObjectSafe(entry.getKey());
      checkSkylarkObjectSafe(entry.getValue());
    }
    return;
  }
 else   if (object instanceof ClassObject) {
    ClassObject struct=(ClassObject)object;
    for (    String key : struct.getKeys()) {
      checkSkylarkObjectSafe(struct.getValue(key));
    }
    return;
  }
  throw new IllegalArgumentException(EvalUtils.getDataTypeName(object));
}",0.9962515618492296
110833,"/** 
 * Evaluates an expression of the form ""e1 + e2 + ... + eK"" by evaluating all the subexpressions in parallel.
 */
private static <T>void parEvalPlus(ImmutableList<QueryExpression> operands,final QueryEnvironment<T> env,final VariableContext<T> context,final ThreadSafeCallback<T> callback,ForkJoinPool forkJoinPool) throws QueryException, InterruptedException {
  ArrayList<ForkJoinTask<Void>> tasks=new ArrayList<>(operands.size());
  for (  final QueryExpression operand : operands) {
    tasks.add(ForkJoinTask.adapt(new Callable<Void>(){
      @Override public Void call() throws QueryException, InterruptedException {
        env.eval(operand,context,callback);
        return null;
      }
    }
));
  }
  for (  ForkJoinTask<?> task : tasks) {
    forkJoinPool.submit(task);
  }
  try {
    MoreFutures.waitForAllInterruptiblyFailFast(tasks);
  }
 catch (  ExecutionException e) {
    Throwables.propagateIfPossible(e.getCause(),QueryException.class,InterruptedException.class);
    throw new IllegalStateException(e);
  }
}","/** 
 * Evaluates an expression of the form ""e1 + e2 + ... + eK"" by evaluating all the subexpressions in parallel.
 */
private static <T>void parEvalPlus(ImmutableList<QueryExpression> operands,final QueryEnvironment<T> env,final VariableContext<T> context,final ThreadSafeCallback<T> callback,ForkJoinPool forkJoinPool) throws QueryException, InterruptedException {
  ArrayList<QueryTask> queryTasks=new ArrayList<>(operands.size());
  for (  final QueryExpression operand : operands) {
    queryTasks.add(new QueryTask(){
      @Override public void execute() throws QueryException, InterruptedException {
        env.eval(operand,context,callback);
      }
    }
);
  }
  ParallelQueryUtils.executeQueryTasksAndWaitInterruptibly(queryTasks,forkJoinPool);
}",0.6952646239554318
110834,"/** 
 * Returns whether dynamic configurations should trim their fragments to only those needed by targets and their transitive dependencies.
 */
private static boolean useUntrimmedDynamicConfigs(BuildOptions options){
  return options.get(BuildConfiguration.Options.class).useDynamicConfigurations == BuildConfiguration.Options.DynamicConfigsMode.NOTRIM;
}","/** 
 * Returns whether dynamic configurations should trim their fragments to only those needed by targets and their transitive dependencies.
 */
private static boolean useUntrimmedDynamicConfigs(BuildOptions options){
  BuildConfiguration.Options.DynamicConfigsMode mode=options.get(BuildConfiguration.Options.class).useDynamicConfigurations;
  return mode == BuildConfiguration.Options.DynamicConfigsMode.NOTRIM || mode == BuildConfiguration.Options.DynamicConfigsMode.NOTRIM_PARTIAL;
}",0.8284023668639053
110835,"/** 
 * Runs Jars in   {@link JavaRuntimeJarProvider} through desugaring action if flag is set and addsthe result to  {@code result}. Note that this cannot happen in a separate aspect because aspects don't see providers added by other aspects executed on the same target.
 */
private Function<Artifact,Artifact> desugarJarsIfRequested(ConfiguredTarget base,RuleContext ruleContext,ConfiguredAspect.Builder result){
  if (!getAndroidConfig(ruleContext).desugarJava8()) {
    return Functions.identity();
  }
  Map<Artifact,Artifact> newlyDesugared=new HashMap<>();
  if (JavaCommon.isNeverLink(ruleContext)) {
    result.addProvider(AndroidRuntimeJarProvider.NEVERLINK);
    return Functions.forMap(newlyDesugared);
  }
  AndroidRuntimeJarProvider.Builder desugaredJars=new AndroidRuntimeJarProvider.Builder().addTransitiveProviders(collectPrerequisites(ruleContext,AndroidRuntimeJarProvider.class));
  JavaRuntimeJarProvider jarProvider=base.getProvider(JavaRuntimeJarProvider.class);
  if (jarProvider != null) {
    NestedSet<Artifact> compileTimeClasspath=base.getProvider(JavaCompilationArgsProvider.class).getRecursiveJavaCompilationArgs().getCompileTimeJars();
    ImmutableList<Artifact> bootclasspath=getBootclasspath(base,ruleContext);
    for (    Artifact jar : jarProvider.getRuntimeJars()) {
      Artifact desugared=createDesugarAction(ruleContext,jar,bootclasspath,compileTimeClasspath);
      newlyDesugared.put(jar,desugared);
      desugaredJars.addDesugaredJar(jar,desugared);
    }
  }
  result.addProvider(desugaredJars.build());
  return Functions.forMap(newlyDesugared);
}","/** 
 * Runs Jars in   {@link JavaRuntimeJarProvider} through desugaring action if flag is set and addsthe result to  {@code result}. Note that this cannot happen in a separate aspect because aspects don't see providers added by other aspects executed on the same target.
 */
private Function<Artifact,Artifact> desugarJarsIfRequested(ConfiguredTarget base,RuleContext ruleContext,ConfiguredAspect.Builder result){
  if (!getAndroidConfig(ruleContext).desugarJava8()) {
    return Functions.identity();
  }
  Map<Artifact,Artifact> newlyDesugared=new HashMap<>();
  if (JavaCommon.isNeverLink(ruleContext)) {
    result.addProvider(AndroidRuntimeJarProvider.NEVERLINK);
    return Functions.forMap(newlyDesugared);
  }
  AndroidRuntimeJarProvider.Builder desugaredJars=new AndroidRuntimeJarProvider.Builder().addTransitiveProviders(collectPrerequisites(ruleContext,AndroidRuntimeJarProvider.class));
  JavaRuntimeJarProvider jarProvider=base.getProvider(JavaRuntimeJarProvider.class);
  if (jarProvider != null) {
    NestedSet<Artifact> compileTimeClasspath=base.getProvider(JavaCompilationArgsProvider.class).getRecursiveJavaCompilationArgs().getCompileTimeJars();
    ImmutableList<Artifact> bootclasspath=getBootclasspath(base,ruleContext);
    boolean basenameClash=checkBasenameClash(jarProvider.getRuntimeJars());
    for (    Artifact jar : jarProvider.getRuntimeJars()) {
      Artifact desugared=createDesugarAction(ruleContext,basenameClash,jar,bootclasspath,compileTimeClasspath);
      newlyDesugared.put(jar,desugared);
      desugaredJars.addDesugaredJar(jar,desugared);
    }
  }
  result.addProvider(desugaredJars.build());
  return Functions.forMap(newlyDesugared);
}",0.972560975609756
110836,"@Override public ConfiguredAspect create(ConfiguredTarget base,RuleContext ruleContext,AspectParameters params) throws InterruptedException {
  ConfiguredAspect.Builder result=new ConfiguredAspect.Builder(this,params,ruleContext);
  Function<Artifact,Artifact> desugaredJars=desugarJarsIfRequested(base,ruleContext,result);
  TriState incrementalAttr=TriState.valueOf(params.getOnlyValueOfAttribute(""String_Node_Str""));
  if (incrementalAttr == TriState.NO || (getAndroidConfig(ruleContext).getIncrementalDexingBinaries().isEmpty() && incrementalAttr != TriState.YES)) {
    return result.build();
  }
  if (JavaCommon.isNeverLink(ruleContext)) {
    return result.addProvider(DexArchiveProvider.NEVERLINK).build();
  }
  DexArchiveProvider.Builder dexArchives=new DexArchiveProvider.Builder().addTransitiveProviders(collectPrerequisites(ruleContext,DexArchiveProvider.class));
  JavaRuntimeJarProvider jarProvider=base.getProvider(JavaRuntimeJarProvider.class);
  if (jarProvider != null) {
    Set<Set<String>> aspectDexopts=aspectDexopts(ruleContext);
    for (    Artifact jar : jarProvider.getRuntimeJars()) {
      for (      Set<String> incrementalDexopts : aspectDexopts) {
        String filename=jar.getFilename() + Joiner.on(""String_Node_Str"").join(incrementalDexopts) + ""String_Node_Str"";
        Artifact dexArchive=createDexArchiveAction(ruleContext,ASPECT_DEXBUILDER_PREREQ,desugaredJars.apply(jar),incrementalDexopts,AndroidBinary.getDxArtifact(ruleContext,filename));
        dexArchives.addDexArchive(incrementalDexopts,dexArchive,jar);
      }
    }
  }
  return result.addProvider(dexArchives.build()).build();
}","@Override public ConfiguredAspect create(ConfiguredTarget base,RuleContext ruleContext,AspectParameters params) throws InterruptedException {
  ConfiguredAspect.Builder result=new ConfiguredAspect.Builder(this,params,ruleContext);
  Function<Artifact,Artifact> desugaredJars=desugarJarsIfRequested(base,ruleContext,result);
  TriState incrementalAttr=TriState.valueOf(params.getOnlyValueOfAttribute(""String_Node_Str""));
  if (incrementalAttr == TriState.NO || (getAndroidConfig(ruleContext).getIncrementalDexingBinaries().isEmpty() && incrementalAttr != TriState.YES)) {
    return result.build();
  }
  if (JavaCommon.isNeverLink(ruleContext)) {
    return result.addProvider(DexArchiveProvider.NEVERLINK).build();
  }
  DexArchiveProvider.Builder dexArchives=new DexArchiveProvider.Builder().addTransitiveProviders(collectPrerequisites(ruleContext,DexArchiveProvider.class));
  JavaRuntimeJarProvider jarProvider=base.getProvider(JavaRuntimeJarProvider.class);
  if (jarProvider != null) {
    boolean basenameClash=checkBasenameClash(jarProvider.getRuntimeJars());
    Set<Set<String>> aspectDexopts=aspectDexopts(ruleContext);
    for (    Artifact jar : jarProvider.getRuntimeJars()) {
      for (      Set<String> incrementalDexopts : aspectDexopts) {
        String uniqueFilename=(basenameClash ? jar.getRootRelativePathString() : jar.getFilename()) + Joiner.on(""String_Node_Str"").join(incrementalDexopts) + ""String_Node_Str"";
        Artifact dexArchive=createDexArchiveAction(ruleContext,ASPECT_DEXBUILDER_PREREQ,desugaredJars.apply(jar),incrementalDexopts,AndroidBinary.getDxArtifact(ruleContext,uniqueFilename));
        dexArchives.addDexArchive(incrementalDexopts,dexArchive,jar);
      }
    }
  }
  return result.addProvider(dexArchives.build()).build();
}",0.9576968272620446
110837,"@Test public void bigDataWithInvalidChecksum_throwsIOExceptionAfterCreateOnEof() throws Exception {
  byte[] bigData=new byte[HttpStream.PRECHECK_BYTES + 70001];
  randoCalrissian.nextBytes(bigData);
  when(connection.getInputStream()).thenReturn(new ByteArrayInputStream(bigData));
  try (HttpStream stream=streamFactory.create(connection,AURL,BAD_CHECKSUM,reconnector)){
    thrown.expect(IOException.class);
    thrown.expectMessage(""String_Node_Str"");
    toByteArray(stream);
    fail(""String_Node_Str"");
  }
 }","@Test public void bigDataWithInvalidChecksum_throwsIOExceptionAfterCreateOnEof() throws Exception {
  byte[] bigData=new byte[HttpStream.PRECHECK_BYTES + 70001];
  randoCalrissian.nextBytes(bigData);
  when(connection.getInputStream()).thenReturn(new ByteArrayInputStream(bigData));
  try (HttpStream stream=streamFactory.create(connection,AURL,BAD_CHECKSUM,reconnector)){
    thrown.expect(IOException.class);
    thrown.expectMessage(""String_Node_Str"");
    ByteStreams.exhaust(stream);
    fail(""String_Node_Str"");
  }
 }",0.9788461538461538
110838,"/** 
 * Strips the C++-contributed prefix out of an output path when tests are run with dynamic configurations. e.g. turns ""bazel-out/gcc-X-glibc-Y-k8-fastbuild/ to ""bazel-out/fastbuild/"". <p>This should be used for targets use configurations with C++ fragments.
 */
protected String stripCppPrefixForDynamicConfigs(String outputPath){
  return targetConfig.useDynamicConfigurations() ? AnalysisTestUtil.OUTPUT_PATH_CPP_PREFIX_PATTERN.matcher(outputPath).replaceFirst(""String_Node_Str"") : outputPath;
}","/** 
 * Strips the C++-contributed prefix out of an output path when tests are run with dynamic configurations. e.g. turns ""bazel-out/gcc-X-glibc-Y-k8-fastbuild/ to ""bazel-out/fastbuild/"". <p>This should be used for targets use configurations with C++ fragments.
 */
protected String stripCppPrefixForDynamicConfigs(String outputPath){
  return targetConfig.trimConfigurations() ? AnalysisTestUtil.OUTPUT_PATH_CPP_PREFIX_PATTERN.matcher(outputPath).replaceFirst(""String_Node_Str"") : outputPath;
}",0.9879759519038076
110839,"@Override public void visitBlock(JCBlock tree){
  JCIdent ident=make.at(tree).Ident(names.fromString(""String_Node_Str""));
  JCThrow throwsTree=make.Throw(make.NewClass(null,List.nil(),ident,List.nil(),null));
  tree.stats=List.of(throwsTree);
}","@Override public void visitBlock(JCBlock tree){
  tree.stats=List.nil();
}",0.4465408805031446
110840,"PruningVisitor(Context context){
  this.make=TreeMaker.instance(context);
  this.names=Names.instance(context);
}","PruningVisitor(Context context){
  this.make=TreeMaker.instance(context);
  this.symtab=Symtab.instance(context);
}",0.9210526315789472
110841,"@Test public void initalizerBlocks(){
  String[] lines={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  JCCompilationUnit tree=parseLines(lines);
  TreePruner.prune(context,tree);
  String[] expected={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  assertThat(prettyPrint(tree)).isEqualTo(Joiner.on('\n').join(expected));
}","@Test public void initalizerBlocks(){
  String[] lines={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  JCCompilationUnit tree=parseLines(lines);
  TreePruner.prune(context,tree);
  String[] expected={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  assertThat(prettyPrint(tree)).isEqualTo(Joiner.on('\n').join(expected));
}",0.9643564356435644
110842,"@Override Object doEval(Environment env) throws EvalException, InterruptedException {
  Object objValue=obj.eval(env);
  Object keyValue=key.eval(env);
  Location loc=getLocation();
  if (objValue instanceof SkylarkIndexable) {
    Object result=((SkylarkIndexable)objValue).getIndex(keyValue,loc);
    return SkylarkType.convertToSkylark(result,env);
  }
 else   if (objValue instanceof String) {
    String string=(String)objValue;
    int index=MethodLibrary.getListIndex(keyValue,string.length(),loc);
    return string.substring(index,index + 1);
  }
  throw new EvalException(loc,Printer.format(""String_Node_Str"",EvalUtils.getDataTypeName(objValue),EvalUtils.getDataTypeName(keyValue)));
}","@Override Object doEval(Environment env) throws EvalException, InterruptedException {
  Object objValue=obj.eval(env);
  Object keyValue=key.eval(env);
  Location loc=getLocation();
  if (objValue instanceof SkylarkIndexable) {
    Object result=((SkylarkIndexable)objValue).getIndex(keyValue,loc);
    return SkylarkType.convertToSkylark(result,env);
  }
 else   if (objValue instanceof String) {
    String string=(String)objValue;
    int index=EvalUtils.getSequenceIndex(keyValue,string.length(),loc);
    return string.substring(index,index + 1);
  }
  throw new EvalException(loc,Printer.format(""String_Node_Str"",EvalUtils.getDataTypeName(objValue),EvalUtils.getDataTypeName(keyValue)));
}",0.9697841726618706
110843,"/** 
 * Common implementation for find, rfind, index, rindex.
 * @param forward true if we want to return the last matching index.
 */
private static int stringFind(boolean forward,String self,String sub,int start,Object end,String msg) throws ConversionException {
  String substr=pythonSubstring(self,start,end,msg);
  int subpos=forward ? substr.indexOf(sub) : substr.lastIndexOf(sub);
  start=clampIndex(start,self.length());
  return subpos < 0 ? subpos : subpos + start;
}","/** 
 * Common implementation for find, rfind, index, rindex.
 * @param forward true if we want to return the last matching index.
 */
private static int stringFind(boolean forward,String self,String sub,int start,Object end,String msg) throws ConversionException {
  String substr=pythonSubstring(self,start,end,msg);
  int subpos=forward ? substr.indexOf(sub) : substr.lastIndexOf(sub);
  start=EvalUtils.clampRangeEndpoint(start,self.length());
  return subpos < 0 ? subpos : subpos + start;
}",0.971252566735113
110844,"private static String pythonSubstring(String str,int start,Object end,String msg) throws ConversionException {
  if (start == 0 && EvalUtils.isNullOrNone(end)) {
    return str;
  }
  start=clampIndex(start,str.length());
  int stop;
  if (EvalUtils.isNullOrNone(end)) {
    stop=str.length();
  }
 else {
    stop=clampIndex(Type.INTEGER.convert(end,msg),str.length());
  }
  if (start >= stop) {
    return ""String_Node_Str"";
  }
  return str.substring(start,stop);
}","private static String pythonSubstring(String str,int start,Object end,String msg) throws ConversionException {
  if (start == 0 && EvalUtils.isNullOrNone(end)) {
    return str;
  }
  start=EvalUtils.clampRangeEndpoint(start,str.length());
  int stop;
  if (EvalUtils.isNullOrNone(end)) {
    stop=str.length();
  }
 else {
    stop=EvalUtils.clampRangeEndpoint(Type.INTEGER.convert(end,msg),str.length());
  }
  if (start >= stop) {
    return ""String_Node_Str"";
  }
  return str.substring(start,stop);
}",0.942505133470226
110845,"/** 
 * Retrieve an entry from a SkylarkList.
 * @param key the index
 * @param loc a {@link Location} in case of error
 * @throws EvalException if the key is invalid
 */
@Override public final E getIndex(Object key,Location loc) throws EvalException {
  List<E> list=getContentsUnsafe();
  int index=MethodLibrary.getListIndex(key,list.size(),loc);
  return list.get(index);
}","/** 
 * Retrieve an entry from a SkylarkList.
 * @param key the index
 * @param loc a {@link Location} in case of error
 * @throws EvalException if the key is invalid
 */
@Override public final E getIndex(Object key,Location loc) throws EvalException {
  List<E> list=getContentsUnsafe();
  int index=EvalUtils.getSequenceIndex(key,list.size(),loc);
  return list.get(index);
}",0.9549071618037136
110846,"/** 
 * Put an entry into a SkylarkList.
 * @param key the index
 * @param value the associated value
 * @param loc a {@link Location} in case of error
 * @param env an {@link Environment}, to check Mutability
 * @throws EvalException if the key is invalid
 */
public void set(Object key,E value,Location loc,Environment env) throws EvalException {
  checkMutable(loc,env);
  List list=getContentsUnsafe();
  int index=MethodLibrary.getListIndex(key,list.size(),loc);
  list.set(index,value);
}","/** 
 * Put an entry into a SkylarkList.
 * @param key the index
 * @param value the associated value
 * @param loc a {@link Location} in case of error
 * @param env an {@link Environment}, to check Mutability
 * @throws EvalException if the key is invalid
 */
public void set(Object key,E value,Location loc,Environment env) throws EvalException {
  checkMutable(loc,env);
  List list=getContentsUnsafe();
  int index=EvalUtils.getSequenceIndex(key,list.size(),loc);
  list.set(index,value);
}",0.9655870445344128
110847,"@Override Object doEval(Environment env) throws EvalException, InterruptedException {
  Object objValue=obj.eval(env);
  Object startValue=start.eval(env);
  Object endValue=end.eval(env);
  Object stepValue=step.eval(env);
  Location loc=getLocation();
  if (objValue instanceof SkylarkList) {
    SkylarkList<Object> list=(SkylarkList<Object>)objValue;
    Object slice=list.getSlice(startValue,endValue,stepValue,loc);
    return SkylarkType.convertToSkylark(slice,env);
  }
 else   if (objValue instanceof String) {
    String string=(String)objValue;
    List<Integer> indices=MethodLibrary.getSliceIndices(startValue,endValue,stepValue,string.length(),loc);
    char[] result=new char[indices.size()];
    char[] original=((String)objValue).toCharArray();
    int resultIndex=0;
    for (    int originalIndex : indices) {
      result[resultIndex]=original[originalIndex];
      ++resultIndex;
    }
    return new String(result);
  }
  throw new EvalException(loc,Printer.format(""String_Node_Str"",EvalUtils.getDataTypeName(objValue),EvalUtils.getDataTypeName(startValue),EvalUtils.getDataTypeName(endValue),EvalUtils.getDataTypeName(stepValue)));
}","@Override Object doEval(Environment env) throws EvalException, InterruptedException {
  Object objValue=obj.eval(env);
  Object startValue=start.eval(env);
  Object endValue=end.eval(env);
  Object stepValue=step.eval(env);
  Location loc=getLocation();
  if (objValue instanceof SkylarkList) {
    SkylarkList<Object> list=(SkylarkList<Object>)objValue;
    Object slice=list.getSlice(startValue,endValue,stepValue,loc);
    return SkylarkType.convertToSkylark(slice,env);
  }
 else   if (objValue instanceof String) {
    String string=(String)objValue;
    List<Integer> indices=EvalUtils.getSliceIndices(startValue,endValue,stepValue,string.length(),loc);
    char[] result=new char[indices.size()];
    char[] original=((String)objValue).toCharArray();
    int resultIndex=0;
    for (    int originalIndex : indices) {
      result[resultIndex]=original[originalIndex];
      ++resultIndex;
    }
    return new String(result);
  }
  throw new EvalException(loc,Printer.format(""String_Node_Str"",EvalUtils.getDataTypeName(objValue),EvalUtils.getDataTypeName(startValue),EvalUtils.getDataTypeName(endValue),EvalUtils.getDataTypeName(stepValue)));
}",0.9904679376083187
110848,"public String toConflictMessage(){
  return String.format(CONFLICT_MESSAGE,dataKey.toPrettyString(),first.source(),second.source());
}","public String toConflictMessage(){
  return String.format(CONFLICT_MESSAGE,dataKey.toPrettyString(),first.source().getPath(),second.source().getPath());
}",0.9305555555555556
110849,"@Override public ConfiguredTarget create(final RuleContext ruleContext) throws InterruptedException, RuleErrorException {
  JavaCompilationArgsProvider dependencyArgsProviders=JavaCompilationArgsProvider.merge(Iterables.<JavaCompilationArgsAspectProvider,JavaCompilationArgsProvider>transform(getDeps(ruleContext,JavaCompilationArgsAspectProvider.class),JavaCompilationArgsAspectProvider.GET_PROVIDER));
  if (!StrictDepsUtils.isStrictDepsJavaProtoLibrary(ruleContext)) {
    dependencyArgsProviders=StrictDepsUtils.makeNonStrict(dependencyArgsProviders);
  }
  Runfiles runfiles=new Runfiles.Builder(ruleContext.getWorkspaceName()).addArtifacts(dependencyArgsProviders.getRecursiveJavaCompilationArgs().getRuntimeJars()).build();
  JavaSourceJarsProvider sourceJarsProvider=JavaSourceJarsProvider.merge(transform(getDeps(ruleContext,JavaSourceJarsAspectProvider.class),JavaSourceJarsAspectProvider.GET_PROVIDER));
  NestedSetBuilder<Artifact> filesToBuild=NestedSetBuilder.stableOrder();
  filesToBuild.addAll(sourceJarsProvider.getSourceJars());
  for (  JavaProtoLibraryTransitiveFilesToBuildProvider provider : ruleContext.getPrerequisites(""String_Node_Str"",Mode.TARGET,JavaProtoLibraryTransitiveFilesToBuildProvider.class)) {
    filesToBuild.addTransitive(provider.getJars());
  }
  return new RuleConfiguredTargetBuilder(ruleContext).setFilesToBuild(filesToBuild.build()).addProvider(RunfilesProvider.class,RunfilesProvider.withData(Runfiles.EMPTY,runfiles)).addOutputGroup(OutputGroupProvider.DEFAULT,NestedSetBuilder.<Artifact>emptySet(STABLE_ORDER)).add(JavaCompilationArgsProvider.class,dependencyArgsProviders).add(JavaSourceJarsProvider.class,sourceJarsProvider).add(JavaRunfilesProvider.class,new JavaRunfilesProvider(runfiles)).add(ProguardSpecProvider.class,new ProguardSpecProvider(new ProguardLibrary(ruleContext).collectProguardSpecs(ImmutableMultimap.of(Mode.TARGET,LITE_PROTO_RUNTIME_ATTR)))).add(JavaRuleOutputJarsProvider.class,JavaRuleOutputJarsProvider.builder().build()).addSkylarkTransitiveInfo(JavaSkylarkApiProvider.NAME,new JavaSkylarkApiProvider()).build();
}","@Override public ConfiguredTarget create(final RuleContext ruleContext) throws InterruptedException, RuleErrorException {
  JavaCompilationArgsProvider dependencyArgsProviders=JavaCompilationArgsProvider.merge(Iterables.<JavaCompilationArgsAspectProvider,JavaCompilationArgsProvider>transform(getDeps(ruleContext,JavaCompilationArgsAspectProvider.class),JavaCompilationArgsAspectProvider.GET_PROVIDER));
  if (!StrictDepsUtils.isStrictDepsJavaProtoLibrary(ruleContext)) {
    dependencyArgsProviders=StrictDepsUtils.makeNonStrict(dependencyArgsProviders);
  }
  Runfiles runfiles=new Runfiles.Builder(ruleContext.getWorkspaceName()).addArtifacts(dependencyArgsProviders.getRecursiveJavaCompilationArgs().getRuntimeJars()).build();
  JavaSourceJarsProvider sourceJarsProvider=JavaSourceJarsProvider.merge(Iterables.<JavaSourceJarsAspectProvider,JavaSourceJarsProvider>transform(getDeps(ruleContext,JavaSourceJarsAspectProvider.class),JavaSourceJarsAspectProvider.GET_PROVIDER));
  NestedSetBuilder<Artifact> filesToBuild=NestedSetBuilder.stableOrder();
  filesToBuild.addAll(sourceJarsProvider.getSourceJars());
  for (  JavaProtoLibraryTransitiveFilesToBuildProvider provider : ruleContext.getPrerequisites(""String_Node_Str"",Mode.TARGET,JavaProtoLibraryTransitiveFilesToBuildProvider.class)) {
    filesToBuild.addTransitive(provider.getJars());
  }
  return new RuleConfiguredTargetBuilder(ruleContext).setFilesToBuild(filesToBuild.build()).addProvider(RunfilesProvider.class,RunfilesProvider.withData(Runfiles.EMPTY,runfiles)).addOutputGroup(OutputGroupProvider.DEFAULT,NestedSetBuilder.<Artifact>emptySet(STABLE_ORDER)).add(JavaCompilationArgsProvider.class,dependencyArgsProviders).add(JavaSourceJarsProvider.class,sourceJarsProvider).add(JavaRunfilesProvider.class,new JavaRunfilesProvider(runfiles)).add(ProguardSpecProvider.class,new ProguardSpecProvider(new ProguardLibrary(ruleContext).collectProguardSpecs(ImmutableMultimap.of(Mode.TARGET,LITE_PROTO_RUNTIME_ATTR)))).add(JavaRuleOutputJarsProvider.class,JavaRuleOutputJarsProvider.builder().build()).addSkylarkTransitiveInfo(JavaSkylarkApiProvider.NAME,new JavaSkylarkApiProvider()).build();
}",0.9851520150836672
110850,"/** 
 * Finds Artifact prefix conflicts between generated artifacts. An artifact prefix conflict happens if one action generates an artifact whose path is a prefix of another artifact's path. Those two artifacts cannot exist simultaneously in the output tree.
 * @param actionGraph the {@link ActionGraph} to query for artifact conflicts
 * @param artifactPathMap a map mapping generated artifacts to their exec paths
 * @return A map between actions that generated the conflicting artifacts and their associated{@link ArtifactPrefixConflictException}.
 */
public static Map<ActionAnalysisMetadata,ArtifactPrefixConflictException> findArtifactPrefixConflicts(ActionGraph actionGraph,SortedMap<PathFragment,Artifact> artifactPathMap){
  if (artifactPathMap.isEmpty()) {
    return ImmutableMap.<ActionAnalysisMetadata,ArtifactPrefixConflictException>of();
  }
  Map<ActionAnalysisMetadata,ArtifactPrefixConflictException> badActions=new LinkedHashMap();
  Iterator<PathFragment> iter=artifactPathMap.keySet().iterator();
  for (PathFragment pathJ=iter.next(); iter.hasNext(); ) {
    PathFragment pathI=pathJ;
    while (iter.hasNext()) {
      pathJ=iter.next();
      if (pathJ.startsWith(pathI)) {
        Artifact artifactI=Preconditions.checkNotNull(artifactPathMap.get(pathI),pathI);
        Artifact artifactJ=Preconditions.checkNotNull(artifactPathMap.get(pathJ),pathJ);
        ActionAnalysisMetadata actionI=Preconditions.checkNotNull(actionGraph.getGeneratingAction(artifactI),artifactI);
        ActionAnalysisMetadata actionJ=Preconditions.checkNotNull(actionGraph.getGeneratingAction(artifactJ),artifactJ);
        if (actionI.shouldReportPathPrefixConflict(actionJ)) {
          ArtifactPrefixConflictException exception=new ArtifactPrefixConflictException(pathI,pathJ,actionI.getOwner().getLabel(),actionJ.getOwner().getLabel());
          badActions.put(actionI,exception);
          badActions.put(actionJ,exception);
        }
      }
 else {
        break;
      }
    }
  }
  return ImmutableMap.copyOf(badActions);
}","/** 
 * Finds Artifact prefix conflicts between generated artifacts. An artifact prefix conflict happens if one action generates an artifact whose path is a prefix of another artifact's path. Those two artifacts cannot exist simultaneously in the output tree.
 * @param actionGraph the {@link ActionGraph} to query for artifact conflicts
 * @param artifactPathMap a map mapping generated artifacts to their exec paths
 * @return A map between actions that generated the conflicting artifacts and their associated{@link ArtifactPrefixConflictException}.
 */
public static Map<ActionAnalysisMetadata,ArtifactPrefixConflictException> findArtifactPrefixConflicts(ActionGraph actionGraph,SortedMap<PathFragment,Artifact> artifactPathMap){
  if (artifactPathMap.isEmpty()) {
    return ImmutableMap.<ActionAnalysisMetadata,ArtifactPrefixConflictException>of();
  }
  Map<ActionAnalysisMetadata,ArtifactPrefixConflictException> badActions=new LinkedHashMap();
  Iterator<PathFragment> iter=artifactPathMap.keySet().iterator();
  for (PathFragment pathJ=iter.next(); iter.hasNext(); ) {
    PathFragment pathI=pathJ;
    while (iter.hasNext()) {
      pathJ=iter.next();
      if (pathJ.startsWith(pathI)) {
        Artifact artifactI=Preconditions.checkNotNull(artifactPathMap.get(pathI),pathI);
        Artifact artifactJ=Preconditions.checkNotNull(artifactPathMap.get(pathJ),pathJ);
        if (artifactJ.hasParent() && artifactJ.getParent().equals(artifactI)) {
          continue;
        }
        ActionAnalysisMetadata actionI=Preconditions.checkNotNull(actionGraph.getGeneratingAction(artifactI),artifactI);
        ActionAnalysisMetadata actionJ=Preconditions.checkNotNull(actionGraph.getGeneratingAction(artifactJ),artifactJ);
        if (actionI.shouldReportPathPrefixConflict(actionJ)) {
          ArtifactPrefixConflictException exception=new ArtifactPrefixConflictException(pathI,pathJ,actionI.getOwner().getLabel(),actionJ.getOwner().getLabel());
          badActions.put(actionI,exception);
          badActions.put(actionJ,exception);
        }
      }
 else {
        break;
      }
    }
  }
  return ImmutableMap.copyOf(badActions);
}",0.9737093690248566
110851,"@Override public Package getPackage(EventHandler eventHandler,PackageIdentifier packageName) throws NoSuchPackageException, InterruptedException {
  SkyKey pkgKey=PackageValue.key(packageName);
  PackageValue pkgValue;
  if (graph.exists(pkgKey)) {
    pkgValue=(PackageValue)graph.getValue(pkgKey);
    if (pkgValue == null) {
      throw (NoSuchPackageException)Preconditions.checkNotNull(graph.getException(pkgKey),pkgKey);
    }
  }
 else {
    throw new BuildFileNotFoundException(packageName,""String_Node_Str"");
  }
  return pkgValue.getPackage();
}","@Override public Package getPackage(EventHandler eventHandler,PackageIdentifier packageName) throws NoSuchPackageException, InterruptedException {
  SkyKey pkgKey=PackageValue.key(packageName);
  PackageValue pkgValue;
  if (graph.exists(pkgKey)) {
    pkgValue=(PackageValue)graph.getValue(pkgKey);
    if (pkgValue == null) {
      NoSuchPackageException nspe=(NoSuchPackageException)graph.getException(pkgKey);
      if (nspe != null) {
        throw nspe;
      }
      throw new NoSuchPackageException(packageName,""String_Node_Str"");
    }
  }
 else {
    throw new BuildFileNotFoundException(packageName,""String_Node_Str"");
  }
  return pkgValue.getPackage();
}",0.7250409165302782
110852,"/** 
 * Remove the lock for a given   {@link Freezable} that is associated with the given
 * @{link Location}. It is an error if {@code object} does not belong to this mutability,or has no lock corresponding to  {@code loc}.
 */
public void unlock(Freezable object,Location loc){
  if (!object.mutability().equals(this)) {
    throw new AssertionError(""String_Node_Str"");
  }
  if (!isMutable) {
    return;
  }
  Integer hash=System.identityHashCode(object);
  if (!lockedItems.containsKey(hash)) {
    throw new AssertionError(""String_Node_Str"");
  }
  boolean changed=lockedItems.remove(hash,loc);
  if (!changed) {
    throw new AssertionError(Printer.format(""String_Node_Str"" + ""String_Node_Str"",loc));
  }
}","/** 
 * Remove the lock for a given   {@link Freezable} that is associated with the given
 * @{link Location}. It is an error if {@code object} does not belong to this mutability,or has no lock corresponding to  {@code loc}.
 */
public void unlock(Freezable object,Location loc){
  if (!object.mutability().equals(this)) {
    throw new AssertionError(""String_Node_Str"");
  }
  if (!isMutable) {
    return;
  }
  if (!lockedItems.containsKey(object)) {
    throw new AssertionError(""String_Node_Str"");
  }
  List<Location> locList=lockedItems.get(object);
  boolean changed=locList.remove(loc);
  if (!changed) {
    throw new AssertionError(Printer.format(""String_Node_Str"" + ""String_Node_Str"",loc));
  }
  if (locList.isEmpty()) {
    lockedItems.remove(object);
  }
}",0.8355795148247979
110853,"/** 
 * Creates a Mutability.
 * @param annotation an Object used for error reporting,describing to the user the context in which this Mutability was active.
 */
private Mutability(String annotation){
  this.isMutable=true;
  this.lockedItems=ArrayListMultimap.create();
  this.annotation=Preconditions.checkNotNull(annotation);
}","/** 
 * Creates a Mutability.
 * @param annotation an Object used for error reporting,describing to the user the context in which this Mutability was active.
 */
private Mutability(String annotation){
  this.isMutable=true;
  this.lockedItems=new IdentityHashMap<>(10);
  this.annotation=Preconditions.checkNotNull(annotation);
}",0.9377845220030347
110854,"/** 
 * Return whether a   {@link Freezable} belonging to this Mutability is currently locked.Frozen objects are not considered locked, though they are of course immutable nonetheless.
 */
public boolean isLocked(Freezable object){
  if (!object.mutability().equals(this)) {
    throw new AssertionError(""String_Node_Str"");
  }
  if (!isMutable) {
    return false;
  }
  Integer hash=System.identityHashCode(object);
  return lockedItems.containsKey(hash);
}","/** 
 * Return whether a   {@link Freezable} belonging to this Mutability is currently locked.Frozen objects are not considered locked, though they are of course immutable nonetheless.
 */
public boolean isLocked(Freezable object){
  if (!object.mutability().equals(this)) {
    throw new AssertionError(""String_Node_Str"");
  }
  if (!isMutable) {
    return false;
  }
  return lockedItems.containsKey(object);
}",0.8830275229357798
110855,"/** 
 * Add a lock on a   {@link Freezable} belonging to this Mutability. The object cannot bemutated until all locks on it are gone. For error reporting purposes each lock is associated with its originating  {@link Location}.
 */
public void lock(Freezable object,Location loc){
  if (!object.mutability().equals(this)) {
    throw new AssertionError(""String_Node_Str"");
  }
  if (!isMutable) {
    return;
  }
  Integer hash=System.identityHashCode(object);
  lockedItems.put(hash,loc);
}","/** 
 * Add a lock on a   {@link Freezable} belonging to this Mutability. The object cannot bemutated until all locks on it are gone. For error reporting purposes each lock is associated with its originating  {@link Location}.
 */
public void lock(Freezable object,Location loc){
  if (!object.mutability().equals(this)) {
    throw new AssertionError(""String_Node_Str"");
  }
  if (!isMutable) {
    return;
  }
  List<Location> locList;
  if (!lockedItems.containsKey(object)) {
    locList=new ArrayList<>();
    lockedItems.put(object,locList);
  }
 else {
    locList=lockedItems.get(object);
  }
  locList.add(loc);
}",0.8057553956834532
110856,"/** 
 * For a locked   {@link Freezable} that belongs to this Mutability, return a List of the{@link Locations} corresponding to its current locks.
 */
public List<Location> getLockLocations(Freezable object){
  if (!isLocked(object)) {
    throw new AssertionError(""String_Node_Str"");
  }
  Integer hash=System.identityHashCode(object);
  return lockedItems.get(hash);
}","/** 
 * For a locked   {@link Freezable} that belongs to this Mutability, return a List of the{@link Locations} corresponding to its current locks.
 */
public List<Location> getLockLocations(Freezable object){
  if (!isLocked(object)) {
    throw new AssertionError(""String_Node_Str"");
  }
  return lockedItems.get(object);
}",0.8850574712643678
110857,"static void lazyCleanup(ExecutorService backgroundWorkers,final SandboxRunner runner){
  backgroundWorkers.execute(new Runnable(){
    @Override public void run(){
      try {
        while (!Thread.currentThread().isInterrupted()) {
          try {
            runner.cleanup();
            return;
          }
 catch (          IOException e2) {
            Thread.sleep(250);
          }
        }
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
      }
    }
  }
);
}","static void lazyCleanup(ExecutorService backgroundWorkers,final EventHandler eventHandler,final SandboxRunner runner){
  backgroundWorkers.execute(new Runnable(){
    @Override public void run(){
      try {
        runner.cleanup();
      }
 catch (      IOException e) {
        eventHandler.handle(Event.warn(String.format(""String_Node_Str"",runner.getSandboxPath(),e)));
      }
    }
  }
);
}",0.4763995609220636
110858,"@Override public void run(){
  try {
    while (!Thread.currentThread().isInterrupted()) {
      try {
        runner.cleanup();
        return;
      }
 catch (      IOException e2) {
        Thread.sleep(250);
      }
    }
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
}","@Override public void run(){
  try {
    runner.cleanup();
  }
 catch (  IOException e) {
    eventHandler.handle(Event.warn(String.format(""String_Node_Str"",runner.getSandboxPath(),e)));
  }
}",0.4493041749502982
110859,"@Override public void afterCommand(){
  env=null;
  buildRequest=null;
  ExecutorUtil.interruptibleShutdown(backgroundWorkers);
}","@Override public void afterCommand(){
  backgroundWorkers.shutdownNow();
  if (sandboxOptions != null && !sandboxOptions.sandboxDebug) {
    Path sandboxRoot=env.getDirectories().getOutputBase().getRelative(env.getRuntime().getProductName() + ""String_Node_Str"");
    if (sandboxRoot.exists()) {
      try {
        for (        Path child : sandboxRoot.getDirectoryEntries()) {
          try {
            FileSystemUtils.deleteTree(child);
          }
 catch (          IOException e) {
            env.getReporter().handle(Event.warn(String.format(""String_Node_Str"",child.getPathString(),e)));
          }
        }
        sandboxRoot.delete();
      }
 catch (      IOException e) {
        env.getReporter().handle(Event.warn(String.format(""String_Node_Str"",sandboxRoot.getBaseName(),e)));
      }
    }
  }
  env=null;
  buildRequest=null;
  backgroundWorkers=null;
  sandboxOptions=null;
}",0.1482926829268292
110860,"@Override public Iterable<ActionContextProvider> getActionContextProviders(){
  Preconditions.checkNotNull(env);
  Preconditions.checkNotNull(buildRequest);
  Preconditions.checkNotNull(backgroundWorkers);
  try {
    return ImmutableList.<ActionContextProvider>of(SandboxActionContextProvider.create(env,buildRequest,backgroundWorkers));
  }
 catch (  IOException e) {
    throw new IllegalStateException(e);
  }
}","@Override public Iterable<ActionContextProvider> getActionContextProviders(){
  Preconditions.checkNotNull(env);
  Preconditions.checkNotNull(buildRequest);
  Preconditions.checkNotNull(backgroundWorkers);
  sandboxOptions=buildRequest.getOptions(SandboxOptions.class);
  try {
    return ImmutableList.<ActionContextProvider>of(SandboxActionContextProvider.create(env,buildRequest,backgroundWorkers));
  }
 catch (  IOException e) {
    throw new IllegalStateException(e);
  }
}",0.9284116331096196
110861,"protected void runSpawn(Spawn spawn,ActionExecutionContext actionExecutionContext,Map<String,String> spawnEnvironment,SandboxExecRoot sandboxExecRoot,Set<PathFragment> outputs,SandboxRunner runner,AtomicReference<Class<? extends SpawnActionContext>> writeOutputFiles) throws ExecException, InterruptedException {
  try {
    runner.run(spawn.getArguments(),spawnEnvironment,actionExecutionContext.getFileOutErr(),Spawns.getTimeoutSeconds(spawn),SandboxHelpers.shouldAllowNetwork(buildRequest,spawn));
  }
  finally {
    if (writeOutputFiles != null && !writeOutputFiles.compareAndSet(null,SandboxStrategy.class)) {
      Thread.currentThread().interrupt();
    }
 else {
      try {
        sandboxExecRoot.copyOutputs(execRoot,outputs);
      }
 catch (      IOException e) {
        actionExecutionContext.getExecutor().getEventHandler().handle(Event.error(""String_Node_Str"" + e));
      }
    }
    if (!sandboxOptions.sandboxDebug) {
      SandboxHelpers.lazyCleanup(backgroundWorkers,runner);
    }
  }
  if (Thread.interrupted()) {
    throw new InterruptedException();
  }
}","protected void runSpawn(Spawn spawn,ActionExecutionContext actionExecutionContext,Map<String,String> spawnEnvironment,SandboxExecRoot sandboxExecRoot,Set<PathFragment> outputs,SandboxRunner runner,AtomicReference<Class<? extends SpawnActionContext>> writeOutputFiles) throws ExecException, InterruptedException {
  EventHandler eventHandler=actionExecutionContext.getExecutor().getEventHandler();
  try {
    runner.run(spawn.getArguments(),spawnEnvironment,actionExecutionContext.getFileOutErr(),Spawns.getTimeoutSeconds(spawn),SandboxHelpers.shouldAllowNetwork(buildRequest,spawn));
  }
  finally {
    if (writeOutputFiles != null && !writeOutputFiles.compareAndSet(null,SandboxStrategy.class)) {
      Thread.currentThread().interrupt();
    }
 else {
      try {
        sandboxExecRoot.copyOutputs(execRoot,outputs);
      }
 catch (      IOException e) {
        eventHandler.handle(Event.error(""String_Node_Str"" + e));
      }
    }
    if (!sandboxOptions.sandboxDebug) {
      SandboxHelpers.lazyCleanup(backgroundWorkers,eventHandler,runner);
    }
  }
  if (Thread.interrupted()) {
    throw new InterruptedException();
  }
}",0.9364578639026588
110862,"private DarwinSandboxedStrategy(BuildRequest buildRequest,Map<String,String> clientEnv,BlazeDirectories blazeDirs,ExecutorService backgroundWorkers,boolean verboseFailures,String productName,ImmutableList<Path> confPaths,SpawnHelpers spawnHelpers){
  super(blazeDirs,verboseFailures,buildRequest.getOptions(SandboxOptions.class));
  this.buildRequest=buildRequest;
  this.clientEnv=ImmutableMap.copyOf(clientEnv);
  this.blazeDirs=blazeDirs;
  this.execRoot=blazeDirs.getExecRoot();
  this.backgroundWorkers=Preconditions.checkNotNull(backgroundWorkers);
  this.sandboxDebug=buildRequest.getOptions(SandboxOptions.class).sandboxDebug;
  this.verboseFailures=verboseFailures;
  this.productName=productName;
  this.confPaths=confPaths;
  this.spawnHelpers=spawnHelpers;
}","private DarwinSandboxedStrategy(BuildRequest buildRequest,Map<String,String> clientEnv,BlazeDirectories blazeDirs,ExecutorService backgroundWorkers,boolean verboseFailures,String productName,ImmutableList<Path> confPaths,SpawnHelpers spawnHelpers){
  super(buildRequest,blazeDirs,backgroundWorkers,verboseFailures,buildRequest.getOptions(SandboxOptions.class));
  this.clientEnv=ImmutableMap.copyOf(clientEnv);
  this.blazeDirs=blazeDirs;
  this.execRoot=blazeDirs.getExecRoot();
  this.sandboxDebug=buildRequest.getOptions(SandboxOptions.class).sandboxDebug;
  this.verboseFailures=verboseFailures;
  this.productName=productName;
  this.confPaths=confPaths;
  this.spawnHelpers=spawnHelpers;
}",0.9064846416382252
110863,"@Override public void exec(Spawn spawn,ActionExecutionContext actionExecutionContext,AtomicReference<Class<? extends SpawnActionContext>> writeOutputFiles) throws ExecException, InterruptedException {
  Executor executor=actionExecutionContext.getExecutor();
  if (!spawn.isRemotable() || spawn.hasNoSandbox()) {
    SandboxHelpers.fallbackToNonSandboxedExecution(spawn,actionExecutionContext,executor);
    return;
  }
  SandboxHelpers.reportSubcommand(executor,spawn);
  SandboxHelpers.postActionStatusMessage(executor,spawn);
  PrintWriter errWriter=sandboxDebug ? new PrintWriter(actionExecutionContext.getFileOutErr().getErrorStream()) : null;
  Path sandboxPath=SandboxHelpers.getSandboxRoot(blazeDirs,productName,uuid,execCounter);
  Path sandboxExecRoot=sandboxPath.getRelative(""String_Node_Str"").getRelative(execRoot.getBaseName());
  if (errWriter != null) {
    errWriter.printf(""String_Node_Str"",sandboxPath.toString());
    errWriter.printf(""String_Node_Str"",sandboxExecRoot.toString());
  }
  ImmutableMap<String,String> spawnEnvironment=StandaloneSpawnStrategy.locallyDeterminedEnv(execRoot,productName,spawn.getEnvironment());
  Set<Path> writableDirs=getWritableDirs(sandboxExecRoot,spawn.getEnvironment());
  Path runUnderPath=getRunUnderPath(spawn);
  try {
    HardlinkedExecRoot hardlinkedExecRoot=new HardlinkedExecRoot(execRoot,sandboxPath,sandboxExecRoot,errWriter);
    ImmutableSet<PathFragment> outputs=SandboxHelpers.getOutputFiles(spawn);
    hardlinkedExecRoot.createFileSystem(getMounts(spawn,actionExecutionContext),outputs,writableDirs);
    if (errWriter != null) {
      errWriter.flush();
    }
    DarwinSandboxRunner runner;
    runner=new DarwinSandboxRunner(sandboxPath,sandboxExecRoot,getWritableDirs(sandboxExecRoot,spawnEnvironment),getInaccessiblePaths(),runUnderPath,verboseFailures);
    try {
      runner.run(spawn.getArguments(),spawnEnvironment,actionExecutionContext.getFileOutErr(),Spawns.getTimeoutSeconds(spawn),SandboxHelpers.shouldAllowNetwork(buildRequest,spawn));
    }
  finally {
      if (writeOutputFiles != null && !writeOutputFiles.compareAndSet(null,DarwinSandboxedStrategy.class)) {
        Thread.currentThread().interrupt();
      }
 else {
        hardlinkedExecRoot.copyOutputs(execRoot,outputs);
      }
      if (!sandboxDebug) {
        SandboxHelpers.lazyCleanup(backgroundWorkers,runner);
      }
    }
  }
 catch (  IOException e) {
    throw new UserExecException(""String_Node_Str"",e);
  }
  if (Thread.interrupted()) {
    throw new InterruptedException();
  }
}","@Override public void exec(Spawn spawn,ActionExecutionContext actionExecutionContext,AtomicReference<Class<? extends SpawnActionContext>> writeOutputFiles) throws ExecException, InterruptedException {
  Executor executor=actionExecutionContext.getExecutor();
  if (!spawn.isRemotable() || spawn.hasNoSandbox()) {
    SandboxHelpers.fallbackToNonSandboxedExecution(spawn,actionExecutionContext,executor);
    return;
  }
  SandboxHelpers.reportSubcommand(executor,spawn);
  SandboxHelpers.postActionStatusMessage(executor,spawn);
  PrintWriter errWriter=sandboxDebug ? new PrintWriter(actionExecutionContext.getFileOutErr().getErrorStream()) : null;
  Path sandboxPath=SandboxHelpers.getSandboxRoot(blazeDirs,productName,uuid,execCounter);
  Path sandboxExecRoot=sandboxPath.getRelative(""String_Node_Str"").getRelative(execRoot.getBaseName());
  if (errWriter != null) {
    errWriter.printf(""String_Node_Str"",sandboxPath.toString());
    errWriter.printf(""String_Node_Str"",sandboxExecRoot.toString());
  }
  ImmutableMap<String,String> spawnEnvironment=StandaloneSpawnStrategy.locallyDeterminedEnv(execRoot,productName,spawn.getEnvironment());
  Set<Path> writableDirs=getWritableDirs(sandboxExecRoot,spawn.getEnvironment());
  Path runUnderPath=getRunUnderPath(spawn);
  HardlinkedExecRoot hardlinkedExecRoot=new HardlinkedExecRoot(execRoot,sandboxPath,sandboxExecRoot,errWriter);
  ImmutableSet<PathFragment> outputs=SandboxHelpers.getOutputFiles(spawn);
  try {
    hardlinkedExecRoot.createFileSystem(getMounts(spawn,actionExecutionContext),outputs,writableDirs);
  }
 catch (  IOException e) {
    throw new UserExecException(""String_Node_Str"",e);
  }
  if (errWriter != null) {
    errWriter.flush();
  }
  DarwinSandboxRunner runner=new DarwinSandboxRunner(sandboxPath,sandboxExecRoot,getWritableDirs(sandboxExecRoot,spawnEnvironment),getInaccessiblePaths(),runUnderPath,verboseFailures);
  runSpawn(spawn,actionExecutionContext,spawnEnvironment,hardlinkedExecRoot,outputs,runner,writeOutputFiles);
}",0.7355917289925209
110864,"LinuxSandboxedStrategy(BuildRequest buildRequest,BlazeDirectories blazeDirs,ExecutorService backgroundWorkers,boolean verboseFailures,String productName,boolean fullySupported){
  super(blazeDirs,verboseFailures,buildRequest.getOptions(SandboxOptions.class));
  this.buildRequest=buildRequest;
  this.sandboxOptions=buildRequest.getOptions(SandboxOptions.class);
  this.blazeDirs=blazeDirs;
  this.execRoot=blazeDirs.getExecRoot();
  this.backgroundWorkers=Preconditions.checkNotNull(backgroundWorkers);
  this.verboseFailures=verboseFailures;
  this.productName=productName;
  this.fullySupported=fullySupported;
}","LinuxSandboxedStrategy(BuildRequest buildRequest,BlazeDirectories blazeDirs,ExecutorService backgroundWorkers,boolean verboseFailures,String productName,boolean fullySupported){
  super(buildRequest,blazeDirs,backgroundWorkers,verboseFailures,buildRequest.getOptions(SandboxOptions.class));
  this.sandboxOptions=buildRequest.getOptions(SandboxOptions.class);
  this.blazeDirs=blazeDirs;
  this.execRoot=blazeDirs.getExecRoot();
  this.verboseFailures=verboseFailures;
  this.productName=productName;
  this.fullySupported=fullySupported;
}",0.8813852813852814
110865,"@Override public void exec(Spawn spawn,ActionExecutionContext actionExecutionContext,AtomicReference<Class<? extends SpawnActionContext>> writeOutputFiles) throws ExecException, InterruptedException {
  Executor executor=actionExecutionContext.getExecutor();
  if (!spawn.isRemotable() || spawn.hasNoSandbox()) {
    SandboxHelpers.fallbackToNonSandboxedExecution(spawn,actionExecutionContext,executor);
    return;
  }
  SandboxHelpers.reportSubcommand(executor,spawn);
  SandboxHelpers.postActionStatusMessage(executor,spawn);
  Path sandboxPath=SandboxHelpers.getSandboxRoot(blazeDirs,productName,uuid,execCounter);
  Path sandboxExecRoot=sandboxPath.getRelative(""String_Node_Str"").getRelative(execRoot.getBaseName());
  Path sandboxTempDir=sandboxPath.getRelative(""String_Node_Str"");
  Set<Path> writableDirs=getWritableDirs(sandboxExecRoot,spawn.getEnvironment());
  try {
    SymlinkedExecRoot symlinkedExecRoot=new SymlinkedExecRoot(sandboxExecRoot);
    ImmutableSet<PathFragment> outputs=SandboxHelpers.getOutputFiles(spawn);
    symlinkedExecRoot.createFileSystem(getMounts(spawn,actionExecutionContext),outputs,writableDirs);
    sandboxTempDir.createDirectory();
    final SandboxRunner runner;
    if (fullySupported) {
      runner=new LinuxSandboxRunner(execRoot,sandboxPath,sandboxExecRoot,sandboxTempDir,getWritableDirs(sandboxExecRoot,spawn.getEnvironment()),getInaccessiblePaths(),getBindMounts(blazeDirs),verboseFailures,sandboxOptions.sandboxDebug);
    }
 else {
      runner=new ProcessWrapperRunner(execRoot,sandboxPath,sandboxExecRoot,verboseFailures);
    }
    try {
      runner.run(spawn.getArguments(),spawn.getEnvironment(),actionExecutionContext.getFileOutErr(),Spawns.getTimeoutSeconds(spawn),SandboxHelpers.shouldAllowNetwork(buildRequest,spawn));
    }
  finally {
      if (writeOutputFiles != null && !writeOutputFiles.compareAndSet(null,LinuxSandboxedStrategy.class)) {
        Thread.currentThread().interrupt();
      }
 else {
        symlinkedExecRoot.copyOutputs(execRoot,outputs);
      }
      if (!sandboxOptions.sandboxDebug) {
        SandboxHelpers.lazyCleanup(backgroundWorkers,runner);
      }
    }
  }
 catch (  IOException e) {
    throw new UserExecException(""String_Node_Str"",e);
  }
  if (Thread.interrupted()) {
    throw new InterruptedException();
  }
}","@Override public void exec(Spawn spawn,ActionExecutionContext actionExecutionContext,AtomicReference<Class<? extends SpawnActionContext>> writeOutputFiles) throws ExecException, InterruptedException {
  Executor executor=actionExecutionContext.getExecutor();
  if (!spawn.isRemotable() || spawn.hasNoSandbox()) {
    SandboxHelpers.fallbackToNonSandboxedExecution(spawn,actionExecutionContext,executor);
    return;
  }
  SandboxHelpers.reportSubcommand(executor,spawn);
  SandboxHelpers.postActionStatusMessage(executor,spawn);
  Path sandboxPath=SandboxHelpers.getSandboxRoot(blazeDirs,productName,uuid,execCounter);
  Path sandboxExecRoot=sandboxPath.getRelative(""String_Node_Str"").getRelative(execRoot.getBaseName());
  Path sandboxTempDir=sandboxPath.getRelative(""String_Node_Str"");
  Set<Path> writableDirs=getWritableDirs(sandboxExecRoot,spawn.getEnvironment());
  SymlinkedExecRoot symlinkedExecRoot=new SymlinkedExecRoot(sandboxExecRoot);
  ImmutableSet<PathFragment> outputs=SandboxHelpers.getOutputFiles(spawn);
  try {
    symlinkedExecRoot.createFileSystem(getMounts(spawn,actionExecutionContext),outputs,writableDirs);
    sandboxTempDir.createDirectory();
  }
 catch (  IOException e) {
    throw new UserExecException(""String_Node_Str"",e);
  }
  SandboxRunner runner=getSandboxRunner(spawn,sandboxPath,sandboxExecRoot,sandboxTempDir);
  runSpawn(spawn,actionExecutionContext,spawn.getEnvironment(),symlinkedExecRoot,outputs,runner,writeOutputFiles);
}",0.6402116402116402
110866,"/** 
 * Runs the command specified via   {@code arguments} and {@code env} inside the sandbox.
 * @param arguments - arguments of spawn to run inside the sandbox.
 * @param environment - environment variables to pass to the spawn.
 * @param outErr - error output to capture sandbox's and command's stderr
 * @param timeout - after how many seconds should the process be killed
 * @param allowNetwork - whether networking should be allowed for the process
 */
void run(List<String> arguments,Map<String,String> environment,OutErr outErr,int timeout,boolean allowNetwork) throws IOException, ExecException {
  Command cmd=getCommand(arguments,environment,timeout,allowNetwork);
  try {
    cmd.execute(new byte[]{},getCommandObserver(timeout),outErr.getOutputStream(),outErr.getErrorStream(),true);
  }
 catch (  CommandException e) {
    boolean timedOut=false;
    if (e instanceof AbnormalTerminationException) {
      TerminationStatus status=((AbnormalTerminationException)e).getResult().getTerminationStatus();
      timedOut=!status.exited() && (status.getTerminatingSignal() == getSignalOnTimeout());
    }
    String message=CommandFailureUtils.describeCommandFailure(verboseFailures,Arrays.asList(cmd.getCommandLineElements()),environment,sandboxExecRoot.getPathString());
    throw new UserExecException(message,e,timedOut);
  }
}","/** 
 * Runs the command specified via   {@code arguments} and {@code env} inside the sandbox.
 * @param arguments - arguments of spawn to run inside the sandbox.
 * @param environment - environment variables to pass to the spawn.
 * @param outErr - error output to capture sandbox's and command's stderr
 * @param timeout - after how many seconds should the process be killed
 * @param allowNetwork - whether networking should be allowed for the process
 */
void run(List<String> arguments,Map<String,String> environment,OutErr outErr,int timeout,boolean allowNetwork) throws ExecException {
  Command cmd;
  try {
    cmd=getCommand(arguments,environment,timeout,allowNetwork);
  }
 catch (  IOException e) {
    throw new UserExecException(""String_Node_Str"",e);
  }
  try {
    cmd.execute(new byte[]{},getCommandObserver(timeout),outErr.getOutputStream(),outErr.getErrorStream(),true);
  }
 catch (  CommandException e) {
    boolean timedOut=false;
    if (e instanceof AbnormalTerminationException) {
      TerminationStatus status=((AbnormalTerminationException)e).getResult().getTerminationStatus();
      timedOut=!status.exited() && (status.getTerminatingSignal() == getSignalOnTimeout());
    }
    String message=CommandFailureUtils.describeCommandFailure(verboseFailures,Arrays.asList(cmd.getCommandLineElements()),environment,sandboxExecRoot.getPathString());
    throw new UserExecException(message,e,timedOut);
  }
}",0.9094189823168533
110867,"public SandboxStrategy(BlazeDirectories blazeDirs,boolean verboseFailures,SandboxOptions sandboxOptions){
  this.blazeDirs=blazeDirs;
  this.verboseFailures=verboseFailures;
  this.sandboxOptions=sandboxOptions;
  this.spawnHelpers=new SpawnHelpers(blazeDirs.getExecRoot());
}","public SandboxStrategy(BuildRequest buildRequest,BlazeDirectories blazeDirs,ExecutorService backgroundWorkers,boolean verboseFailures,SandboxOptions sandboxOptions){
  this.buildRequest=buildRequest;
  this.blazeDirs=blazeDirs;
  this.execRoot=blazeDirs.getExecRoot();
  this.backgroundWorkers=Preconditions.checkNotNull(backgroundWorkers);
  this.verboseFailures=verboseFailures;
  this.sandboxOptions=sandboxOptions;
  this.spawnHelpers=new SpawnHelpers(blazeDirs.getExecRoot());
}",0.619235836627141
110868,"public static ConfiguredTarget init(CppSemantics semantics,RuleContext ruleContext,boolean fake,boolean isTest) throws InterruptedException, RuleErrorException {
  ruleContext.checkSrcsSamePackage(true);
  FeatureConfiguration featureConfiguration=CcCommon.configureFeatures(ruleContext);
  CcCommon common=new CcCommon(ruleContext);
  CppConfiguration cppConfiguration=ruleContext.getFragment(CppConfiguration.class);
  PrecompiledFiles precompiledFiles=new PrecompiledFiles(ruleContext);
  LinkTargetType linkType=isLinkShared(ruleContext) ? LinkTargetType.DYNAMIC_LIBRARY : LinkTargetType.EXECUTABLE;
  List<String> linkopts=common.getLinkopts();
  LinkStaticness linkStaticness=getLinkStaticness(ruleContext,linkopts,cppConfiguration);
  semantics.validateAttributes(ruleContext);
  if (ruleContext.hasErrors()) {
    return null;
  }
  CcLibraryHelper helper=new CcLibraryHelper(ruleContext,semantics,featureConfiguration).fromCommon(common).addSources(common.getSources()).addDeps(ImmutableList.of(CppHelper.mallocForTarget(ruleContext))).setFake(fake).setLinkType(linkType).addPrecompiledFiles(precompiledFiles);
  CcLibraryHelper.Info info=helper.build();
  CppCompilationContext cppCompilationContext=info.getCppCompilationContext();
  CcCompilationOutputs ccCompilationOutputs=info.getCcCompilationOutputs();
  PathFragment binaryPath=new PathFragment(ruleContext.getTarget().getName());
  if (!isLinkShared(ruleContext)) {
    binaryPath=new PathFragment(binaryPath.getPathString() + OsUtils.executableExtension());
  }
  Artifact binary=ruleContext.getBinArtifact(binaryPath);
  if (isLinkShared(ruleContext) && !CppFileTypes.SHARED_LIBRARY.matches(binary.getFilename())) {
    ruleContext.attributeError(""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  CppLinkActionBuilder linkActionBuilder=determineLinkerArguments(ruleContext,common,precompiledFiles,ccCompilationOutputs,cppCompilationContext.getTransitiveCompilationPrerequisites(),fake,binary,linkStaticness,linkopts);
  linkActionBuilder.setUseTestOnlyFlags(isTest);
  linkActionBuilder.addNonCodeInputs(ccCompilationOutputs.getHeaderTokenFiles());
  CcToolchainProvider ccToolchain=CppHelper.getToolchain(ruleContext);
  if (linkStaticness == LinkStaticness.DYNAMIC) {
    linkActionBuilder.setRuntimeInputs(ArtifactCategory.DYNAMIC_LIBRARY,ccToolchain.getDynamicRuntimeLinkMiddleman(),ccToolchain.getDynamicRuntimeLinkInputs());
  }
 else {
    linkActionBuilder.setRuntimeInputs(ArtifactCategory.STATIC_LIBRARY,ccToolchain.getStaticRuntimeLinkMiddleman(),ccToolchain.getStaticRuntimeLinkInputs());
    if (!ccToolchain.getStaticRuntimeLinkInputs().isEmpty()) {
      linkActionBuilder.addLinkopt(""String_Node_Str"");
    }
  }
  linkActionBuilder.setLinkType(linkType);
  linkActionBuilder.setLinkStaticness(linkStaticness);
  linkActionBuilder.setFake(fake);
  linkActionBuilder.setFeatureConfiguration(featureConfiguration);
  if (CppLinkAction.enableSymbolsCounts(cppConfiguration,fake,linkType)) {
    linkActionBuilder.setSymbolCountsOutput(ruleContext.getBinArtifact(CppLinkAction.symbolCountsFileName(binaryPath)));
  }
  if (isLinkShared(ruleContext)) {
    linkActionBuilder.setLibraryIdentifier(CcLinkingOutputs.libraryIdentifierOf(binary));
  }
  CppLinkAction.Context linkContext=new CppLinkAction.Context(linkActionBuilder);
  if (featureConfiguration.isEnabled(CppRuleClasses.THIN_LTO)) {
    linkActionBuilder.setLTOIndexing(true);
    CppLinkAction indexAction=linkActionBuilder.build();
    ruleContext.registerAction(indexAction);
    for (    LTOBackendArtifacts ltoArtifacts : indexAction.getAllLTOBackendArtifacts()) {
      boolean usePic=CppHelper.usePic(ruleContext,!isLinkShared(ruleContext));
      ltoArtifacts.scheduleLTOBackendAction(ruleContext,usePic);
    }
    linkActionBuilder.setLTOIndexing(false);
  }
  CppLinkAction linkAction=linkActionBuilder.build();
  ruleContext.registerAction(linkAction);
  LibraryToLink outputLibrary=linkAction.getOutputLibrary();
  Iterable<Artifact> fakeLinkerInputs=fake ? linkAction.getInputs() : ImmutableList.<Artifact>of();
  Artifact executable=linkAction.getLinkOutput();
  CcLinkingOutputs.Builder linkingOutputsBuilder=new CcLinkingOutputs.Builder();
  if (isLinkShared(ruleContext)) {
    linkingOutputsBuilder.addDynamicLibrary(outputLibrary);
    linkingOutputsBuilder.addExecutionDynamicLibrary(outputLibrary);
  }
  for (  Artifact library : precompiledFiles.getSharedLibraries()) {
    Artifact symlink=common.getDynamicLibrarySymlink(library,true);
    LibraryToLink symlinkLibrary=LinkerInputs.solibLibraryToLink(symlink,library,CcLinkingOutputs.libraryIdentifierOf(library));
    linkingOutputsBuilder.addDynamicLibrary(symlinkLibrary);
    linkingOutputsBuilder.addExecutionDynamicLibrary(symlinkLibrary);
  }
  CcLinkingOutputs linkingOutputs=linkingOutputsBuilder.build();
  NestedSet<Artifact> filesToBuild=NestedSetBuilder.create(Order.STABLE_ORDER,executable);
  Artifact strippedFile=ruleContext.getImplicitOutputArtifact(CppRuleClasses.CC_BINARY_STRIPPED);
  CppHelper.createStripAction(ruleContext,cppConfiguration,executable,strippedFile);
  DwoArtifactsCollector dwoArtifacts=collectTransitiveDwoArtifacts(ruleContext,ccCompilationOutputs,linkStaticness);
  Artifact dwpFile=ruleContext.getImplicitOutputArtifact(CppRuleClasses.CC_BINARY_DEBUG_PACKAGE);
  createDebugPackagerActions(ruleContext,cppConfiguration,dwpFile,dwoArtifacts);
  Artifact explicitDwpFile=dwpFile;
  if (!cppConfiguration.useFission()) {
    explicitDwpFile=null;
  }
 else {
    if (TargetUtils.isTestRule(ruleContext.getRule()) && linkStaticness != LinkStaticness.DYNAMIC && cppConfiguration.shouldBuildTestDwp()) {
      filesToBuild=NestedSetBuilder.fromNestedSet(filesToBuild).add(dwpFile).build();
    }
  }
  Runfiles runfiles=collectRunfiles(ruleContext,linkingOutputs,cppCompilationContext,linkStaticness,filesToBuild,fakeLinkerInputs,fake,helper.getCompilationUnitSources());
  RunfilesSupport runfilesSupport=RunfilesSupport.withExecutable(ruleContext,runfiles,executable,ruleContext.getConfiguration().buildRunfiles());
  TransitiveLipoInfoProvider transitiveLipoInfo;
  if (cppConfiguration.isLipoContextCollector()) {
    transitiveLipoInfo=common.collectTransitiveLipoLabels(ccCompilationOutputs);
  }
 else {
    transitiveLipoInfo=TransitiveLipoInfoProvider.EMPTY;
  }
  RuleConfiguredTargetBuilder ruleBuilder=new RuleConfiguredTargetBuilder(ruleContext);
  addTransitiveInfoProviders(ruleContext,cppConfiguration,common,ruleBuilder,filesToBuild,ccCompilationOutputs,cppCompilationContext,linkingOutputs,dwoArtifacts,transitiveLipoInfo,fake);
  Map<Artifact,IncludeScannable> scannableMap=new LinkedHashMap<>();
  Map<PathFragment,Artifact> sourceFileMap=new LinkedHashMap<>();
  if (cppConfiguration.isLipoContextCollector()) {
    for (    IncludeScannable scannable : transitiveLipoInfo.getTransitiveIncludeScannables()) {
      Artifact source=Iterables.getOnlyElement(scannable.getIncludeScannerSources());
      scannableMap.put(source,scannable);
      sourceFileMap.put(source.getExecPath(),source);
    }
  }
  if (Platform.isApplePlatform(cppConfiguration.getTargetCpu()) && TargetUtils.isTestRule(ruleContext.getRule())) {
    ruleBuilder.add(ExecutionInfoProvider.class,new ExecutionInfoProvider(ImmutableMap.of(""String_Node_Str"",""String_Node_Str"")));
  }
  return ruleBuilder.add(RunfilesProvider.class,RunfilesProvider.simple(runfiles)).add(CppDebugPackageProvider.class,new CppDebugPackageProvider(ruleContext.getLabel(),strippedFile,executable,explicitDwpFile)).setRunfilesSupport(runfilesSupport,executable).addProvider(LipoContextProvider.class,new LipoContextProvider(cppCompilationContext,ImmutableMap.copyOf(scannableMap),ImmutableMap.copyOf(sourceFileMap))).addProvider(CppLinkAction.Context.class,linkContext).addSkylarkTransitiveInfo(CcSkylarkApiProvider.NAME,new CcSkylarkApiProvider()).build();
}","public static ConfiguredTarget init(CppSemantics semantics,RuleContext ruleContext,boolean fake,boolean isTest) throws InterruptedException, RuleErrorException {
  ruleContext.checkSrcsSamePackage(true);
  FeatureConfiguration featureConfiguration=CcCommon.configureFeatures(ruleContext);
  CcCommon common=new CcCommon(ruleContext);
  CppConfiguration cppConfiguration=ruleContext.getFragment(CppConfiguration.class);
  PrecompiledFiles precompiledFiles=new PrecompiledFiles(ruleContext);
  LinkTargetType linkType=isLinkShared(ruleContext) ? LinkTargetType.DYNAMIC_LIBRARY : LinkTargetType.EXECUTABLE;
  List<String> linkopts=common.getLinkopts();
  LinkStaticness linkStaticness=getLinkStaticness(ruleContext,linkopts,cppConfiguration);
  semantics.validateAttributes(ruleContext);
  if (ruleContext.hasErrors()) {
    return null;
  }
  CcLibraryHelper helper=new CcLibraryHelper(ruleContext,semantics,featureConfiguration).fromCommon(common).addSources(common.getSources()).addDeps(ImmutableList.of(CppHelper.mallocForTarget(ruleContext))).setFake(fake).setLinkType(linkType).addPrecompiledFiles(precompiledFiles);
  CcLibraryHelper.Info info=helper.build();
  CppCompilationContext cppCompilationContext=info.getCppCompilationContext();
  CcCompilationOutputs ccCompilationOutputs=info.getCcCompilationOutputs();
  PathFragment binaryPath=new PathFragment(ruleContext.getTarget().getName());
  if (!isLinkShared(ruleContext)) {
    binaryPath=new PathFragment(binaryPath.getPathString() + OsUtils.executableExtension());
  }
  Artifact binary=ruleContext.getBinArtifact(binaryPath);
  if (isLinkShared(ruleContext) && !CppFileTypes.SHARED_LIBRARY.matches(binary.getFilename())) {
    ruleContext.attributeError(""String_Node_Str"",""String_Node_Str"");
    return null;
  }
  CppLinkActionBuilder linkActionBuilder=determineLinkerArguments(ruleContext,common,precompiledFiles,ccCompilationOutputs,cppCompilationContext.getTransitiveCompilationPrerequisites(),fake,binary,linkStaticness,linkopts);
  linkActionBuilder.setUseTestOnlyFlags(isTest);
  CcToolchainProvider ccToolchain=CppHelper.getToolchain(ruleContext);
  if (linkStaticness == LinkStaticness.DYNAMIC) {
    linkActionBuilder.setRuntimeInputs(ArtifactCategory.DYNAMIC_LIBRARY,ccToolchain.getDynamicRuntimeLinkMiddleman(),ccToolchain.getDynamicRuntimeLinkInputs());
  }
 else {
    linkActionBuilder.setRuntimeInputs(ArtifactCategory.STATIC_LIBRARY,ccToolchain.getStaticRuntimeLinkMiddleman(),ccToolchain.getStaticRuntimeLinkInputs());
    if (!ccToolchain.getStaticRuntimeLinkInputs().isEmpty()) {
      linkActionBuilder.addLinkopt(""String_Node_Str"");
    }
  }
  linkActionBuilder.setLinkType(linkType);
  linkActionBuilder.setLinkStaticness(linkStaticness);
  linkActionBuilder.setFake(fake);
  linkActionBuilder.setFeatureConfiguration(featureConfiguration);
  if (CppLinkAction.enableSymbolsCounts(cppConfiguration,fake,linkType)) {
    linkActionBuilder.setSymbolCountsOutput(ruleContext.getBinArtifact(CppLinkAction.symbolCountsFileName(binaryPath)));
  }
  if (isLinkShared(ruleContext)) {
    linkActionBuilder.setLibraryIdentifier(CcLinkingOutputs.libraryIdentifierOf(binary));
  }
  CppLinkAction.Context linkContext=new CppLinkAction.Context(linkActionBuilder);
  if (featureConfiguration.isEnabled(CppRuleClasses.THIN_LTO)) {
    linkActionBuilder.setLTOIndexing(true);
    CppLinkAction indexAction=linkActionBuilder.build();
    ruleContext.registerAction(indexAction);
    for (    LTOBackendArtifacts ltoArtifacts : indexAction.getAllLTOBackendArtifacts()) {
      boolean usePic=CppHelper.usePic(ruleContext,!isLinkShared(ruleContext));
      ltoArtifacts.scheduleLTOBackendAction(ruleContext,usePic);
    }
    linkActionBuilder.setLTOIndexing(false);
  }
  CppLinkAction linkAction=linkActionBuilder.build();
  ruleContext.registerAction(linkAction);
  LibraryToLink outputLibrary=linkAction.getOutputLibrary();
  Iterable<Artifact> fakeLinkerInputs=fake ? linkAction.getInputs() : ImmutableList.<Artifact>of();
  Artifact executable=linkAction.getLinkOutput();
  CcLinkingOutputs.Builder linkingOutputsBuilder=new CcLinkingOutputs.Builder();
  if (isLinkShared(ruleContext)) {
    linkingOutputsBuilder.addDynamicLibrary(outputLibrary);
    linkingOutputsBuilder.addExecutionDynamicLibrary(outputLibrary);
  }
  for (  Artifact library : precompiledFiles.getSharedLibraries()) {
    Artifact symlink=common.getDynamicLibrarySymlink(library,true);
    LibraryToLink symlinkLibrary=LinkerInputs.solibLibraryToLink(symlink,library,CcLinkingOutputs.libraryIdentifierOf(library));
    linkingOutputsBuilder.addDynamicLibrary(symlinkLibrary);
    linkingOutputsBuilder.addExecutionDynamicLibrary(symlinkLibrary);
  }
  CcLinkingOutputs linkingOutputs=linkingOutputsBuilder.build();
  NestedSet<Artifact> filesToBuild=NestedSetBuilder.create(Order.STABLE_ORDER,executable);
  Artifact strippedFile=ruleContext.getImplicitOutputArtifact(CppRuleClasses.CC_BINARY_STRIPPED);
  CppHelper.createStripAction(ruleContext,cppConfiguration,executable,strippedFile);
  DwoArtifactsCollector dwoArtifacts=collectTransitiveDwoArtifacts(ruleContext,ccCompilationOutputs,linkStaticness);
  Artifact dwpFile=ruleContext.getImplicitOutputArtifact(CppRuleClasses.CC_BINARY_DEBUG_PACKAGE);
  createDebugPackagerActions(ruleContext,cppConfiguration,dwpFile,dwoArtifacts);
  Artifact explicitDwpFile=dwpFile;
  if (!cppConfiguration.useFission()) {
    explicitDwpFile=null;
  }
 else {
    if (TargetUtils.isTestRule(ruleContext.getRule()) && linkStaticness != LinkStaticness.DYNAMIC && cppConfiguration.shouldBuildTestDwp()) {
      filesToBuild=NestedSetBuilder.fromNestedSet(filesToBuild).add(dwpFile).build();
    }
  }
  Runfiles runfiles=collectRunfiles(ruleContext,linkingOutputs,cppCompilationContext,linkStaticness,filesToBuild,fakeLinkerInputs,fake,helper.getCompilationUnitSources());
  RunfilesSupport runfilesSupport=RunfilesSupport.withExecutable(ruleContext,runfiles,executable,ruleContext.getConfiguration().buildRunfiles());
  TransitiveLipoInfoProvider transitiveLipoInfo;
  if (cppConfiguration.isLipoContextCollector()) {
    transitiveLipoInfo=common.collectTransitiveLipoLabels(ccCompilationOutputs);
  }
 else {
    transitiveLipoInfo=TransitiveLipoInfoProvider.EMPTY;
  }
  RuleConfiguredTargetBuilder ruleBuilder=new RuleConfiguredTargetBuilder(ruleContext);
  addTransitiveInfoProviders(ruleContext,cppConfiguration,common,ruleBuilder,filesToBuild,ccCompilationOutputs,cppCompilationContext,linkingOutputs,dwoArtifacts,transitiveLipoInfo,fake);
  Map<Artifact,IncludeScannable> scannableMap=new LinkedHashMap<>();
  Map<PathFragment,Artifact> sourceFileMap=new LinkedHashMap<>();
  if (cppConfiguration.isLipoContextCollector()) {
    for (    IncludeScannable scannable : transitiveLipoInfo.getTransitiveIncludeScannables()) {
      Artifact source=Iterables.getOnlyElement(scannable.getIncludeScannerSources());
      scannableMap.put(source,scannable);
      sourceFileMap.put(source.getExecPath(),source);
    }
  }
  if (Platform.isApplePlatform(cppConfiguration.getTargetCpu()) && TargetUtils.isTestRule(ruleContext.getRule())) {
    ruleBuilder.add(ExecutionInfoProvider.class,new ExecutionInfoProvider(ImmutableMap.of(""String_Node_Str"",""String_Node_Str"")));
  }
  return ruleBuilder.add(RunfilesProvider.class,RunfilesProvider.simple(runfiles)).add(CppDebugPackageProvider.class,new CppDebugPackageProvider(ruleContext.getLabel(),strippedFile,executable,explicitDwpFile)).setRunfilesSupport(runfilesSupport,executable).addProvider(LipoContextProvider.class,new LipoContextProvider(cppCompilationContext,ImmutableMap.copyOf(scannableMap),ImmutableMap.copyOf(sourceFileMap))).addProvider(CppLinkAction.Context.class,linkContext).addSkylarkTransitiveInfo(CcSkylarkApiProvider.NAME,new CcSkylarkApiProvider()).build();
}",0.9947777353203412
110869,"private static void addTransitiveInfoProviders(RuleContext ruleContext,CppConfiguration cppConfiguration,CcCommon common,RuleConfiguredTargetBuilder builder,NestedSet<Artifact> filesToBuild,CcCompilationOutputs ccCompilationOutputs,CppCompilationContext cppCompilationContext,CcLinkingOutputs linkingOutputs,DwoArtifactsCollector dwoArtifacts,TransitiveLipoInfoProvider transitiveLipoInfo,boolean fake){
  List<Artifact> instrumentedObjectFiles=new ArrayList<>();
  instrumentedObjectFiles.addAll(ccCompilationOutputs.getObjectFiles(false));
  instrumentedObjectFiles.addAll(ccCompilationOutputs.getObjectFiles(true));
  InstrumentedFilesProvider instrumentedFilesProvider=common.getInstrumentedFilesProvider(instrumentedObjectFiles,!TargetUtils.isTestRule(ruleContext.getRule()) && !fake);
  NestedSet<Artifact> filesToCompile=ccCompilationOutputs.getFilesToCompile(cppConfiguration.isLipoContextCollector(),cppConfiguration.processHeadersInDependencies(),CppHelper.usePic(ruleContext,false));
  NestedSet<Artifact> artifactsToForce=collectHiddenTopLevelArtifacts(ruleContext);
  builder.setFilesToBuild(filesToBuild).add(CppCompilationContext.class,cppCompilationContext).add(TransitiveLipoInfoProvider.class,transitiveLipoInfo).add(CcExecutionDynamicLibrariesProvider.class,new CcExecutionDynamicLibrariesProvider(collectExecutionDynamicLibraryArtifacts(ruleContext,linkingOutputs.getExecutionDynamicLibraries()))).add(CcNativeLibraryProvider.class,new CcNativeLibraryProvider(collectTransitiveCcNativeLibraries(ruleContext,linkingOutputs.getDynamicLibraries()))).add(InstrumentedFilesProvider.class,instrumentedFilesProvider).add(CppDebugFileProvider.class,new CppDebugFileProvider(dwoArtifacts.getDwoArtifacts(),dwoArtifacts.getPicDwoArtifacts())).addOutputGroup(OutputGroupProvider.TEMP_FILES,getTemps(cppConfiguration,ccCompilationOutputs)).addOutputGroup(OutputGroupProvider.FILES_TO_COMPILE,filesToCompile).addOutputGroup(OutputGroupProvider.HIDDEN_TOP_LEVEL,artifactsToForce).addOutputGroup(OutputGroupProvider.COMPILATION_PREREQUISITES,CcCommon.collectCompilationPrerequisites(ruleContext,cppCompilationContext));
  CppHelper.maybeAddStaticLinkMarkerProvider(builder,ruleContext);
}","private static void addTransitiveInfoProviders(RuleContext ruleContext,CppConfiguration cppConfiguration,CcCommon common,RuleConfiguredTargetBuilder builder,NestedSet<Artifact> filesToBuild,CcCompilationOutputs ccCompilationOutputs,CppCompilationContext cppCompilationContext,CcLinkingOutputs linkingOutputs,DwoArtifactsCollector dwoArtifacts,TransitiveLipoInfoProvider transitiveLipoInfo,boolean fake){
  List<Artifact> instrumentedObjectFiles=new ArrayList<>();
  instrumentedObjectFiles.addAll(ccCompilationOutputs.getObjectFiles(false));
  instrumentedObjectFiles.addAll(ccCompilationOutputs.getObjectFiles(true));
  InstrumentedFilesProvider instrumentedFilesProvider=common.getInstrumentedFilesProvider(instrumentedObjectFiles,!TargetUtils.isTestRule(ruleContext.getRule()) && !fake);
  NestedSet<Artifact> headerTokens=CcLibraryHelper.collectHeaderTokens(ruleContext,ccCompilationOutputs);
  NestedSet<Artifact> filesToCompile=ccCompilationOutputs.getFilesToCompile(cppConfiguration.isLipoContextCollector(),cppConfiguration.processHeadersInDependencies(),CppHelper.usePic(ruleContext,false));
  builder.setFilesToBuild(filesToBuild).add(CppCompilationContext.class,cppCompilationContext).add(TransitiveLipoInfoProvider.class,transitiveLipoInfo).add(CcExecutionDynamicLibrariesProvider.class,new CcExecutionDynamicLibrariesProvider(collectExecutionDynamicLibraryArtifacts(ruleContext,linkingOutputs.getExecutionDynamicLibraries()))).add(CcNativeLibraryProvider.class,new CcNativeLibraryProvider(collectTransitiveCcNativeLibraries(ruleContext,linkingOutputs.getDynamicLibraries()))).add(InstrumentedFilesProvider.class,instrumentedFilesProvider).add(CppDebugFileProvider.class,new CppDebugFileProvider(dwoArtifacts.getDwoArtifacts(),dwoArtifacts.getPicDwoArtifacts())).addOutputGroup(OutputGroupProvider.TEMP_FILES,getTemps(cppConfiguration,ccCompilationOutputs)).addOutputGroup(OutputGroupProvider.FILES_TO_COMPILE,filesToCompile).addOutputGroup(OutputGroupProvider.HIDDEN_TOP_LEVEL,headerTokens).addOutputGroup(OutputGroupProvider.COMPILATION_PREREQUISITES,CcCommon.collectCompilationPrerequisites(ruleContext,cppCompilationContext));
  CppHelper.maybeAddStaticLinkMarkerProvider(builder,ruleContext);
}",0.8946412352406903
110870,"public static void init(CppSemantics semantics,RuleContext ruleContext,RuleConfiguredTargetBuilder targetBuilder,LinkTargetType linkType,boolean neverLink,boolean linkStatic,boolean collectLinkstamp,boolean addDynamicRuntimeInputArtifactsToRunfiles) throws RuleErrorException, InterruptedException {
  FeatureConfiguration featureConfiguration=CcCommon.configureFeatures(ruleContext);
  final CcCommon common=new CcCommon(ruleContext);
  PrecompiledFiles precompiledFiles=new PrecompiledFiles(ruleContext);
  semantics.validateAttributes(ruleContext);
  if (ruleContext.hasErrors()) {
    return;
  }
  CcLibraryHelper helper=new CcLibraryHelper(ruleContext,semantics,featureConfiguration).fromCommon(common).addLinkopts(common.getLinkopts()).addSources(common.getSources()).addPublicHeaders(common.getHeaders()).enableCcNativeLibrariesProvider().enableCompileProviders().enableInterfaceSharedObjects().setGenerateLinkActionsIfEmpty(ruleContext.getRule().getImplicitOutputsFunction() != ImplicitOutputsFunction.NONE).setLinkType(linkType).setNeverLink(neverLink).addPrecompiledFiles(precompiledFiles);
  if (collectLinkstamp) {
    helper.addLinkstamps(ruleContext.getPrerequisites(""String_Node_Str"",Mode.TARGET));
  }
  Artifact soImplArtifact=null;
  boolean supportsDynamicLinker=ruleContext.getFragment(CppConfiguration.class).supportsDynamicLinker();
  boolean createDynamicLibrary=!linkStatic && appearsToHaveObjectFiles(ruleContext.attributes()) && supportsDynamicLinker;
  if (ruleContext.getRule().isAttrDefined(""String_Node_Str"",Type.STRING_LIST)) {
    List<String> outs=ruleContext.attributes().get(""String_Node_Str"",Type.STRING_LIST);
    if (outs.size() > 1) {
      ruleContext.attributeError(""String_Node_Str"",""String_Node_Str"");
    }
 else     if (outs.size() == 1) {
      PathFragment soImplFilename=new PathFragment(ruleContext.getLabel().getName());
      if (LinkTargetType.DYNAMIC_LIBRARY != LinkTargetType.EXECUTABLE) {
        soImplFilename=soImplFilename.replaceName(""String_Node_Str"" + soImplFilename.getBaseName() + LinkTargetType.DYNAMIC_LIBRARY.getExtension());
      }
      soImplFilename=soImplFilename.replaceName(outs.get(0));
      if (!soImplFilename.getPathString().endsWith(""String_Node_Str"")) {
        ruleContext.attributeError(""String_Node_Str"",""String_Node_Str"");
      }
      if (createDynamicLibrary) {
        soImplArtifact=ruleContext.getBinArtifact(soImplFilename);
      }
    }
  }
  if (ruleContext.getRule().isAttrDefined(""String_Node_Str"",BuildType.LABEL_LIST)) {
    ruleContext.checkSrcsSamePackage(true);
  }
  if (ruleContext.getRule().isAttrDefined(""String_Node_Str"",BuildType.LABEL_LIST)) {
    helper.addPublicTextualHeaders(ruleContext.getPrerequisiteArtifacts(""String_Node_Str"",Mode.TARGET).list());
  }
  if (common.getLinkopts().contains(""String_Node_Str"")) {
    ruleContext.attributeWarning(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  }
  helper.setCreateDynamicLibrary(createDynamicLibrary);
  helper.setDynamicLibrary(soImplArtifact);
  if (!createDynamicLibrary && !supportsDynamicLinker) {
    Artifact solibArtifact=CppHelper.getLinuxLinkedArtifact(ruleContext,LinkTargetType.DYNAMIC_LIBRARY);
    ruleContext.registerAction(new FailAction(ruleContext.getActionOwner(),ImmutableList.of(solibArtifact),""String_Node_Str""));
  }
 else   if (!createDynamicLibrary && ruleContext.attributes().isConfigurable(""String_Node_Str"",BuildType.LABEL_LIST)) {
    Artifact solibArtifact=CppHelper.getLinuxLinkedArtifact(ruleContext,LinkTargetType.DYNAMIC_LIBRARY);
    ruleContext.registerAction(new FailAction(ruleContext.getActionOwner(),ImmutableList.of(solibArtifact),""String_Node_Str"" + ""String_Node_Str""));
  }
  Iterable<LibraryToLink> staticLibrariesFromSrcs=LinkerInputs.opaqueLibrariesToLink(ArtifactCategory.STATIC_LIBRARY,precompiledFiles.getStaticLibraries());
  Iterable<LibraryToLink> alwayslinkLibrariesFromSrcs=LinkerInputs.opaqueLibrariesToLink(ArtifactCategory.ALWAYSLINK_STATIC_LIBRARY,precompiledFiles.getAlwayslinkStaticLibraries());
  Iterable<LibraryToLink> picStaticLibrariesFromSrcs=LinkerInputs.opaqueLibrariesToLink(ArtifactCategory.STATIC_LIBRARY,precompiledFiles.getPicStaticLibraries());
  Iterable<LibraryToLink> picAlwayslinkLibrariesFromSrcs=LinkerInputs.opaqueLibrariesToLink(ArtifactCategory.ALWAYSLINK_STATIC_LIBRARY,precompiledFiles.getPicAlwayslinkLibraries());
  helper.addStaticLibraries(staticLibrariesFromSrcs);
  helper.addStaticLibraries(alwayslinkLibrariesFromSrcs);
  helper.addPicStaticLibraries(picStaticLibrariesFromSrcs);
  helper.addPicStaticLibraries(picAlwayslinkLibrariesFromSrcs);
  helper.addDynamicLibraries(Iterables.transform(precompiledFiles.getSharedLibraries(),new Function<Artifact,LibraryToLink>(){
    @Override public LibraryToLink apply(    Artifact library){
      return LinkerInputs.solibLibraryToLink(common.getDynamicLibrarySymlink(library,true),library,CcLinkingOutputs.libraryIdentifierOf(library));
    }
  }
));
  CcLibraryHelper.Info info=helper.build();
  CcLinkingOutputs linkedLibraries=info.getCcLinkingOutputsExcludingPrecompiledLibraries();
  NestedSet<Artifact> artifactsToForce=collectHiddenTopLevelArtifacts(ruleContext,info.getCcCompilationOutputs());
  NestedSetBuilder<Artifact> filesBuilder=NestedSetBuilder.stableOrder();
  filesBuilder.addAll(LinkerInputs.toLibraryArtifacts(linkedLibraries.getStaticLibraries()));
  filesBuilder.addAll(LinkerInputs.toLibraryArtifacts(linkedLibraries.getPicStaticLibraries()));
  filesBuilder.addAll(LinkerInputs.toNonSolibArtifacts(linkedLibraries.getDynamicLibraries()));
  filesBuilder.addAll(LinkerInputs.toNonSolibArtifacts(linkedLibraries.getExecutionDynamicLibraries()));
  CcLinkingOutputs linkingOutputs=info.getCcLinkingOutputs();
  warnAboutEmptyLibraries(ruleContext,info.getCcCompilationOutputs(),linkStatic);
  NestedSet<Artifact> filesToBuild=filesBuilder.build();
  Runfiles staticRunfiles=collectRunfiles(ruleContext,linkingOutputs,neverLink,addDynamicRuntimeInputArtifactsToRunfiles,true);
  Runfiles sharedRunfiles=collectRunfiles(ruleContext,linkingOutputs,neverLink,addDynamicRuntimeInputArtifactsToRunfiles,false);
  List<Artifact> instrumentedObjectFiles=new ArrayList<>();
  instrumentedObjectFiles.addAll(info.getCcCompilationOutputs().getObjectFiles(false));
  instrumentedObjectFiles.addAll(info.getCcCompilationOutputs().getObjectFiles(true));
  InstrumentedFilesProvider instrumentedFilesProvider=common.getInstrumentedFilesProvider(instrumentedObjectFiles,true);
  CppHelper.maybeAddStaticLinkMarkerProvider(targetBuilder,ruleContext);
  targetBuilder.setFilesToBuild(filesToBuild).addProviders(info.getProviders()).addSkylarkTransitiveInfo(CcSkylarkApiProvider.NAME,new CcSkylarkApiProvider()).addOutputGroups(info.getOutputGroups()).add(InstrumentedFilesProvider.class,instrumentedFilesProvider).add(RunfilesProvider.class,RunfilesProvider.withData(staticRunfiles,sharedRunfiles)).add(CppRunfilesProvider.class,new CppRunfilesProvider(staticRunfiles,sharedRunfiles)).addOutputGroup(OutputGroupProvider.HIDDEN_TOP_LEVEL,artifactsToForce);
}","public static void init(CppSemantics semantics,RuleContext ruleContext,RuleConfiguredTargetBuilder targetBuilder,LinkTargetType linkType,boolean neverLink,boolean linkStatic,boolean collectLinkstamp,boolean addDynamicRuntimeInputArtifactsToRunfiles) throws RuleErrorException, InterruptedException {
  FeatureConfiguration featureConfiguration=CcCommon.configureFeatures(ruleContext);
  final CcCommon common=new CcCommon(ruleContext);
  PrecompiledFiles precompiledFiles=new PrecompiledFiles(ruleContext);
  semantics.validateAttributes(ruleContext);
  if (ruleContext.hasErrors()) {
    return;
  }
  CcLibraryHelper helper=new CcLibraryHelper(ruleContext,semantics,featureConfiguration).fromCommon(common).addLinkopts(common.getLinkopts()).addSources(common.getSources()).addPublicHeaders(common.getHeaders()).enableCcNativeLibrariesProvider().enableCompileProviders().enableInterfaceSharedObjects().setGenerateLinkActionsIfEmpty(ruleContext.getRule().getImplicitOutputsFunction() != ImplicitOutputsFunction.NONE).setLinkType(linkType).setNeverLink(neverLink).addPrecompiledFiles(precompiledFiles);
  if (collectLinkstamp) {
    helper.addLinkstamps(ruleContext.getPrerequisites(""String_Node_Str"",Mode.TARGET));
  }
  Artifact soImplArtifact=null;
  boolean supportsDynamicLinker=ruleContext.getFragment(CppConfiguration.class).supportsDynamicLinker();
  boolean createDynamicLibrary=!linkStatic && appearsToHaveObjectFiles(ruleContext.attributes()) && supportsDynamicLinker;
  if (ruleContext.getRule().isAttrDefined(""String_Node_Str"",Type.STRING_LIST)) {
    List<String> outs=ruleContext.attributes().get(""String_Node_Str"",Type.STRING_LIST);
    if (outs.size() > 1) {
      ruleContext.attributeError(""String_Node_Str"",""String_Node_Str"");
    }
 else     if (outs.size() == 1) {
      PathFragment soImplFilename=new PathFragment(ruleContext.getLabel().getName());
      if (LinkTargetType.DYNAMIC_LIBRARY != LinkTargetType.EXECUTABLE) {
        soImplFilename=soImplFilename.replaceName(""String_Node_Str"" + soImplFilename.getBaseName() + LinkTargetType.DYNAMIC_LIBRARY.getExtension());
      }
      soImplFilename=soImplFilename.replaceName(outs.get(0));
      if (!soImplFilename.getPathString().endsWith(""String_Node_Str"")) {
        ruleContext.attributeError(""String_Node_Str"",""String_Node_Str"");
      }
      if (createDynamicLibrary) {
        soImplArtifact=ruleContext.getBinArtifact(soImplFilename);
      }
    }
  }
  if (ruleContext.getRule().isAttrDefined(""String_Node_Str"",BuildType.LABEL_LIST)) {
    ruleContext.checkSrcsSamePackage(true);
  }
  if (ruleContext.getRule().isAttrDefined(""String_Node_Str"",BuildType.LABEL_LIST)) {
    helper.addPublicTextualHeaders(ruleContext.getPrerequisiteArtifacts(""String_Node_Str"",Mode.TARGET).list());
  }
  if (common.getLinkopts().contains(""String_Node_Str"")) {
    ruleContext.attributeWarning(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  }
  helper.setCreateDynamicLibrary(createDynamicLibrary);
  helper.setDynamicLibrary(soImplArtifact);
  if (!createDynamicLibrary && !supportsDynamicLinker) {
    Artifact solibArtifact=CppHelper.getLinuxLinkedArtifact(ruleContext,LinkTargetType.DYNAMIC_LIBRARY);
    ruleContext.registerAction(new FailAction(ruleContext.getActionOwner(),ImmutableList.of(solibArtifact),""String_Node_Str""));
  }
 else   if (!createDynamicLibrary && ruleContext.attributes().isConfigurable(""String_Node_Str"",BuildType.LABEL_LIST)) {
    Artifact solibArtifact=CppHelper.getLinuxLinkedArtifact(ruleContext,LinkTargetType.DYNAMIC_LIBRARY);
    ruleContext.registerAction(new FailAction(ruleContext.getActionOwner(),ImmutableList.of(solibArtifact),""String_Node_Str"" + ""String_Node_Str""));
  }
  Iterable<LibraryToLink> staticLibrariesFromSrcs=LinkerInputs.opaqueLibrariesToLink(ArtifactCategory.STATIC_LIBRARY,precompiledFiles.getStaticLibraries());
  Iterable<LibraryToLink> alwayslinkLibrariesFromSrcs=LinkerInputs.opaqueLibrariesToLink(ArtifactCategory.ALWAYSLINK_STATIC_LIBRARY,precompiledFiles.getAlwayslinkStaticLibraries());
  Iterable<LibraryToLink> picStaticLibrariesFromSrcs=LinkerInputs.opaqueLibrariesToLink(ArtifactCategory.STATIC_LIBRARY,precompiledFiles.getPicStaticLibraries());
  Iterable<LibraryToLink> picAlwayslinkLibrariesFromSrcs=LinkerInputs.opaqueLibrariesToLink(ArtifactCategory.ALWAYSLINK_STATIC_LIBRARY,precompiledFiles.getPicAlwayslinkLibraries());
  helper.addStaticLibraries(staticLibrariesFromSrcs);
  helper.addStaticLibraries(alwayslinkLibrariesFromSrcs);
  helper.addPicStaticLibraries(picStaticLibrariesFromSrcs);
  helper.addPicStaticLibraries(picAlwayslinkLibrariesFromSrcs);
  helper.addDynamicLibraries(Iterables.transform(precompiledFiles.getSharedLibraries(),new Function<Artifact,LibraryToLink>(){
    @Override public LibraryToLink apply(    Artifact library){
      return LinkerInputs.solibLibraryToLink(common.getDynamicLibrarySymlink(library,true),library,CcLinkingOutputs.libraryIdentifierOf(library));
    }
  }
));
  CcLibraryHelper.Info info=helper.build();
  CcLinkingOutputs linkedLibraries=info.getCcLinkingOutputsExcludingPrecompiledLibraries();
  NestedSetBuilder<Artifact> filesBuilder=NestedSetBuilder.stableOrder();
  filesBuilder.addAll(LinkerInputs.toLibraryArtifacts(linkedLibraries.getStaticLibraries()));
  filesBuilder.addAll(LinkerInputs.toLibraryArtifacts(linkedLibraries.getPicStaticLibraries()));
  filesBuilder.addAll(LinkerInputs.toNonSolibArtifacts(linkedLibraries.getDynamicLibraries()));
  filesBuilder.addAll(LinkerInputs.toNonSolibArtifacts(linkedLibraries.getExecutionDynamicLibraries()));
  CcLinkingOutputs linkingOutputs=info.getCcLinkingOutputs();
  warnAboutEmptyLibraries(ruleContext,info.getCcCompilationOutputs(),linkStatic);
  NestedSet<Artifact> filesToBuild=filesBuilder.build();
  Runfiles staticRunfiles=collectRunfiles(ruleContext,linkingOutputs,neverLink,addDynamicRuntimeInputArtifactsToRunfiles,true);
  Runfiles sharedRunfiles=collectRunfiles(ruleContext,linkingOutputs,neverLink,addDynamicRuntimeInputArtifactsToRunfiles,false);
  List<Artifact> instrumentedObjectFiles=new ArrayList<>();
  instrumentedObjectFiles.addAll(info.getCcCompilationOutputs().getObjectFiles(false));
  instrumentedObjectFiles.addAll(info.getCcCompilationOutputs().getObjectFiles(true));
  InstrumentedFilesProvider instrumentedFilesProvider=common.getInstrumentedFilesProvider(instrumentedObjectFiles,true);
  CppHelper.maybeAddStaticLinkMarkerProvider(targetBuilder,ruleContext);
  targetBuilder.setFilesToBuild(filesToBuild).addProviders(info.getProviders()).addSkylarkTransitiveInfo(CcSkylarkApiProvider.NAME,new CcSkylarkApiProvider()).addOutputGroups(info.getOutputGroups()).add(InstrumentedFilesProvider.class,instrumentedFilesProvider).add(RunfilesProvider.class,RunfilesProvider.withData(staticRunfiles,sharedRunfiles)).add(CppRunfilesProvider.class,new CppRunfilesProvider(staticRunfiles,sharedRunfiles)).addOutputGroup(OutputGroupProvider.HIDDEN_TOP_LEVEL,collectHiddenTopLevelArtifacts(ruleContext,info.getCcCompilationOutputs())).addOutputGroup(CcLibraryHelper.HIDDEN_HEADER_TOKENS,CcLibraryHelper.collectHeaderTokens(ruleContext,info.getCcCompilationOutputs()));
}",0.9765251616530785
110871,"private static NestedSet<Artifact> collectHiddenTopLevelArtifacts(RuleContext ruleContext,CcCompilationOutputs ccCompilationOutputs){
  NestedSetBuilder<Artifact> artifactsToForceBuilder=NestedSetBuilder.stableOrder();
  boolean isLipoCollector=ruleContext.getFragment(CppConfiguration.class).isLipoContextCollector();
  boolean processHeadersInDependencies=ruleContext.getFragment(CppConfiguration.class).processHeadersInDependencies();
  boolean usePic=CppHelper.usePic(ruleContext,false);
  artifactsToForceBuilder.addTransitive(ccCompilationOutputs.getFilesToCompile(isLipoCollector,processHeadersInDependencies,usePic));
  for (  OutputGroupProvider dep : ruleContext.getPrerequisites(""String_Node_Str"",Mode.TARGET,OutputGroupProvider.class)) {
    artifactsToForceBuilder.addTransitive(dep.getOutputGroup(OutputGroupProvider.HIDDEN_TOP_LEVEL));
  }
  return artifactsToForceBuilder.build();
}","private static NestedSet<Artifact> collectHiddenTopLevelArtifacts(RuleContext ruleContext,CcCompilationOutputs ccCompilationOutputs){
  NestedSetBuilder<Artifact> artifactsToForceBuilder=NestedSetBuilder.stableOrder();
  CppConfiguration cppConfiguration=ruleContext.getFragment(CppConfiguration.class);
  boolean isLipoCollector=cppConfiguration.isLipoContextCollector();
  boolean processHeadersInDependencies=cppConfiguration.processHeadersInDependencies();
  boolean usePic=CppHelper.usePic(ruleContext,false);
  artifactsToForceBuilder.addTransitive(ccCompilationOutputs.getFilesToCompile(isLipoCollector,processHeadersInDependencies,usePic));
  for (  OutputGroupProvider dep : ruleContext.getPrerequisites(""String_Node_Str"",Mode.TARGET,OutputGroupProvider.class)) {
    artifactsToForceBuilder.addTransitive(dep.getOutputGroup(OutputGroupProvider.HIDDEN_TOP_LEVEL));
  }
  return artifactsToForceBuilder.build();
}",0.8763056624518967
110872,"/** 
 * Create the C++ compile and link actions, and the corresponding C++-related providers.
 * @throws RuleErrorException
 */
public Info build() throws RuleErrorException, InterruptedException {
  Preconditions.checkState(ruleContext.getRule().getRuleClass().equals(""String_Node_Str"") || ruleContext.getRule().isAttrDefined(""String_Node_Str"",BuildType.LABEL));
  if (checkDepsGenerateCpp) {
    for (    LanguageDependentFragment dep : AnalysisUtils.getProviders(implementationDeps,LanguageDependentFragment.class)) {
      LanguageDependentFragment.Checker.depSupportsLanguage(ruleContext,dep,CppRuleClasses.LANGUAGE);
    }
  }
  CppModel model=initializeCppModel();
  CppCompilationContext cppCompilationContext=initializeCppCompilationContext(model,false);
  model.setContext(cppCompilationContext);
  CppCompilationContext interfaceCompilationContext=cppCompilationContext;
  if (implementationDeps.size() != interfaceDeps.size()) {
    interfaceCompilationContext=initializeCppCompilationContext(model,true);
  }
  model.setInterfaceContext(interfaceCompilationContext);
  boolean compileHeaderModules=featureConfiguration.isEnabled(CppRuleClasses.HEADER_MODULES);
  Preconditions.checkState(!compileHeaderModules || cppCompilationContext.getCppModuleMap() != null,""String_Node_Str"");
  CcCompilationOutputs ccOutputs=model.createCcCompileActions();
  if (!objectFiles.isEmpty() || !picObjectFiles.isEmpty()) {
    ccOutputs=new CcCompilationOutputs.Builder().merge(ccOutputs).addLTOBitcodeFile(ccOutputs.getLtoBitcodeFiles()).addObjectFiles(objectFiles).addPicObjectFiles(picObjectFiles).build();
  }
  CcLinkingOutputs ccLinkingOutputs=CcLinkingOutputs.EMPTY;
  if (emitLinkActionsIfEmpty || !ccOutputs.isEmpty()) {
    if (linkType.staticness() == Staticness.STATIC) {
      ccLinkingOutputs=model.createCcLinkActions(ccOutputs,nonCodeLinkerInputs);
    }
  }
  CcLinkingOutputs originalLinkingOutputs=ccLinkingOutputs;
  if (!(staticLibraries.isEmpty() && picStaticLibraries.isEmpty() && dynamicLibraries.isEmpty())) {
    CcLinkingOutputs.Builder newOutputsBuilder=new CcLinkingOutputs.Builder();
    if (!ccOutputs.isEmpty()) {
      newOutputsBuilder.merge(originalLinkingOutputs);
      ImmutableSetMultimap<String,LibraryToLink> precompiledLibraryMap=CcLinkingOutputs.getLibrariesByIdentifier(Iterables.concat(staticLibraries,picStaticLibraries,dynamicLibraries));
      ImmutableSetMultimap<String,LibraryToLink> linkedLibraryMap=originalLinkingOutputs.getLibrariesByIdentifier();
      for (      String matchingIdentifier : Sets.intersection(precompiledLibraryMap.keySet(),linkedLibraryMap.keySet())) {
        Iterable<Artifact> matchingInputLibs=LinkerInputs.toNonSolibArtifacts(precompiledLibraryMap.get(matchingIdentifier));
        Iterable<Artifact> matchingOutputLibs=LinkerInputs.toNonSolibArtifacts(linkedLibraryMap.get(matchingIdentifier));
        ruleContext.ruleError(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(Iterables.transform(matchingInputLibs,FileType.TO_FILENAME)) + ""String_Node_Str""+ ruleContext.getRuleClassNameForLogging()+ ""String_Node_Str""+ ruleContext.getRule().getName()+ ""String_Node_Str""+ Joiner.on(""String_Node_Str"").join(Iterables.transform(matchingOutputLibs,FileType.TO_FILENAME))+ ""String_Node_Str""+ ""String_Node_Str"");
      }
    }
    ccLinkingOutputs=newOutputsBuilder.addStaticLibraries(staticLibraries).addPicStaticLibraries(picStaticLibraries).addDynamicLibraries(dynamicLibraries).addExecutionDynamicLibraries(dynamicLibraries).build();
  }
  DwoArtifactsCollector dwoArtifacts=DwoArtifactsCollector.transitiveCollector(ccOutputs,implementationDeps);
  Runfiles cppStaticRunfiles=collectCppRunfiles(ccLinkingOutputs,true);
  Runfiles cppSharedRunfiles=collectCppRunfiles(ccLinkingOutputs,false);
  Map<Class<? extends TransitiveInfoProvider>,TransitiveInfoProvider> providers=new LinkedHashMap<>();
  providers.put(CppRunfilesProvider.class,new CppRunfilesProvider(cppStaticRunfiles,cppSharedRunfiles));
  providers.put(CppCompilationContext.class,interfaceCompilationContext);
  providers.put(CppDebugFileProvider.class,new CppDebugFileProvider(dwoArtifacts.getDwoArtifacts(),dwoArtifacts.getPicDwoArtifacts()));
  providers.put(TransitiveLipoInfoProvider.class,collectTransitiveLipoInfo(ccOutputs));
  Map<String,NestedSet<Artifact>> outputGroups=new TreeMap<>();
  if (shouldAddLinkerOutputArtifacts(ruleContext,ccOutputs)) {
    addLinkerOutputArtifacts(outputGroups);
  }
  outputGroups.put(OutputGroupProvider.TEMP_FILES,getTemps(ccOutputs));
  if (emitCompileProviders) {
    boolean isLipoCollector=ruleContext.getFragment(CppConfiguration.class).isLipoContextCollector();
    boolean processHeadersInDependencies=ruleContext.getFragment(CppConfiguration.class).processHeadersInDependencies();
    boolean usePic=CppHelper.usePic(ruleContext,false);
    outputGroups.put(OutputGroupProvider.FILES_TO_COMPILE,ccOutputs.getFilesToCompile(isLipoCollector,processHeadersInDependencies,usePic));
    outputGroups.put(OutputGroupProvider.COMPILATION_PREREQUISITES,CcCommon.collectCompilationPrerequisites(ruleContext,cppCompilationContext));
  }
  if (emitCcNativeLibrariesProvider) {
    providers.put(CcNativeLibraryProvider.class,new CcNativeLibraryProvider(collectNativeCcLibraries(ccLinkingOutputs)));
  }
  providers.put(CcExecutionDynamicLibrariesProvider.class,collectExecutionDynamicLibraryArtifacts(ccLinkingOutputs.getExecutionDynamicLibraries()));
  boolean forcePic=ruleContext.getFragment(CppConfiguration.class).forcePic();
  if (emitCcSpecificLinkParamsProvider) {
    providers.put(CcSpecificLinkParamsProvider.class,new CcSpecificLinkParamsProvider(createCcLinkParamsStore(ccLinkingOutputs,cppCompilationContext,forcePic)));
  }
 else {
    providers.put(CcLinkParamsProvider.class,new CcLinkParamsProvider(createCcLinkParamsStore(ccLinkingOutputs,cppCompilationContext,forcePic)));
  }
  return new Info(providers,outputGroups,ccOutputs,ccLinkingOutputs,originalLinkingOutputs,cppCompilationContext);
}","/** 
 * Create the C++ compile and link actions, and the corresponding C++-related providers.
 * @throws RuleErrorException
 */
public Info build() throws RuleErrorException, InterruptedException {
  Preconditions.checkState(ruleContext.getRule().getRuleClass().equals(""String_Node_Str"") || ruleContext.getRule().isAttrDefined(""String_Node_Str"",BuildType.LABEL));
  if (checkDepsGenerateCpp) {
    for (    LanguageDependentFragment dep : AnalysisUtils.getProviders(implementationDeps,LanguageDependentFragment.class)) {
      LanguageDependentFragment.Checker.depSupportsLanguage(ruleContext,dep,CppRuleClasses.LANGUAGE);
    }
  }
  CppModel model=initializeCppModel();
  CppCompilationContext cppCompilationContext=initializeCppCompilationContext(model,false);
  model.setContext(cppCompilationContext);
  CppCompilationContext interfaceCompilationContext=cppCompilationContext;
  if (implementationDeps.size() != interfaceDeps.size()) {
    interfaceCompilationContext=initializeCppCompilationContext(model,true);
  }
  model.setInterfaceContext(interfaceCompilationContext);
  boolean compileHeaderModules=featureConfiguration.isEnabled(CppRuleClasses.HEADER_MODULES);
  Preconditions.checkState(!compileHeaderModules || cppCompilationContext.getCppModuleMap() != null,""String_Node_Str"");
  CcCompilationOutputs ccOutputs=model.createCcCompileActions();
  if (!objectFiles.isEmpty() || !picObjectFiles.isEmpty()) {
    ccOutputs=new CcCompilationOutputs.Builder().merge(ccOutputs).addLTOBitcodeFile(ccOutputs.getLtoBitcodeFiles()).addObjectFiles(objectFiles).addPicObjectFiles(picObjectFiles).build();
  }
  CcLinkingOutputs ccLinkingOutputs=CcLinkingOutputs.EMPTY;
  if (emitLinkActionsIfEmpty || !ccOutputs.isEmpty()) {
    if (linkType.staticness() == Staticness.STATIC) {
      ccLinkingOutputs=model.createCcLinkActions(ccOutputs,nonCodeLinkerInputs);
    }
  }
  CcLinkingOutputs originalLinkingOutputs=ccLinkingOutputs;
  if (!(staticLibraries.isEmpty() && picStaticLibraries.isEmpty() && dynamicLibraries.isEmpty())) {
    CcLinkingOutputs.Builder newOutputsBuilder=new CcLinkingOutputs.Builder();
    if (!ccOutputs.isEmpty()) {
      newOutputsBuilder.merge(originalLinkingOutputs);
      ImmutableSetMultimap<String,LibraryToLink> precompiledLibraryMap=CcLinkingOutputs.getLibrariesByIdentifier(Iterables.concat(staticLibraries,picStaticLibraries,dynamicLibraries));
      ImmutableSetMultimap<String,LibraryToLink> linkedLibraryMap=originalLinkingOutputs.getLibrariesByIdentifier();
      for (      String matchingIdentifier : Sets.intersection(precompiledLibraryMap.keySet(),linkedLibraryMap.keySet())) {
        Iterable<Artifact> matchingInputLibs=LinkerInputs.toNonSolibArtifacts(precompiledLibraryMap.get(matchingIdentifier));
        Iterable<Artifact> matchingOutputLibs=LinkerInputs.toNonSolibArtifacts(linkedLibraryMap.get(matchingIdentifier));
        ruleContext.ruleError(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(Iterables.transform(matchingInputLibs,FileType.TO_FILENAME)) + ""String_Node_Str""+ ruleContext.getRuleClassNameForLogging()+ ""String_Node_Str""+ ruleContext.getRule().getName()+ ""String_Node_Str""+ Joiner.on(""String_Node_Str"").join(Iterables.transform(matchingOutputLibs,FileType.TO_FILENAME))+ ""String_Node_Str""+ ""String_Node_Str"");
      }
    }
    ccLinkingOutputs=newOutputsBuilder.addStaticLibraries(staticLibraries).addPicStaticLibraries(picStaticLibraries).addDynamicLibraries(dynamicLibraries).addExecutionDynamicLibraries(dynamicLibraries).build();
  }
  DwoArtifactsCollector dwoArtifacts=DwoArtifactsCollector.transitiveCollector(ccOutputs,implementationDeps);
  Runfiles cppStaticRunfiles=collectCppRunfiles(ccLinkingOutputs,true);
  Runfiles cppSharedRunfiles=collectCppRunfiles(ccLinkingOutputs,false);
  Map<Class<? extends TransitiveInfoProvider>,TransitiveInfoProvider> providers=new LinkedHashMap<>();
  providers.put(CppRunfilesProvider.class,new CppRunfilesProvider(cppStaticRunfiles,cppSharedRunfiles));
  providers.put(CppCompilationContext.class,interfaceCompilationContext);
  providers.put(CppDebugFileProvider.class,new CppDebugFileProvider(dwoArtifacts.getDwoArtifacts(),dwoArtifacts.getPicDwoArtifacts()));
  providers.put(TransitiveLipoInfoProvider.class,collectTransitiveLipoInfo(ccOutputs));
  Map<String,NestedSet<Artifact>> outputGroups=new TreeMap<>();
  if (shouldAddLinkerOutputArtifacts(ruleContext,ccOutputs)) {
    addLinkerOutputArtifacts(outputGroups);
  }
  outputGroups.put(OutputGroupProvider.TEMP_FILES,getTemps(ccOutputs));
  CppConfiguration cppConfiguration=ruleContext.getFragment(CppConfiguration.class);
  if (emitCompileProviders) {
    boolean isLipoCollector=cppConfiguration.isLipoContextCollector();
    boolean processHeadersInDependencies=cppConfiguration.processHeadersInDependencies();
    boolean usePic=CppHelper.usePic(ruleContext,false);
    outputGroups.put(OutputGroupProvider.FILES_TO_COMPILE,ccOutputs.getFilesToCompile(isLipoCollector,processHeadersInDependencies,usePic));
    outputGroups.put(OutputGroupProvider.COMPILATION_PREREQUISITES,CcCommon.collectCompilationPrerequisites(ruleContext,cppCompilationContext));
  }
  if (emitCcNativeLibrariesProvider) {
    providers.put(CcNativeLibraryProvider.class,new CcNativeLibraryProvider(collectNativeCcLibraries(ccLinkingOutputs)));
  }
  providers.put(CcExecutionDynamicLibrariesProvider.class,collectExecutionDynamicLibraryArtifacts(ccLinkingOutputs.getExecutionDynamicLibraries()));
  boolean forcePic=cppConfiguration.forcePic();
  if (emitCcSpecificLinkParamsProvider) {
    providers.put(CcSpecificLinkParamsProvider.class,new CcSpecificLinkParamsProvider(createCcLinkParamsStore(ccLinkingOutputs,cppCompilationContext,forcePic)));
  }
 else {
    providers.put(CcLinkParamsProvider.class,new CcLinkParamsProvider(createCcLinkParamsStore(ccLinkingOutputs,cppCompilationContext,forcePic)));
  }
  return new Info(providers,outputGroups,ccOutputs,ccLinkingOutputs,originalLinkingOutputs,cppCompilationContext);
}",0.975975975975976
110873,"/** 
 * Constructs the C++ linker actions. It generally generates two actions, one for a static library and one for a dynamic library. If PIC is required for shared libraries, but not for binaries, it additionally creates a third action to generate a PIC static library. <p>For dynamic libraries, this method can additionally create an interface shared library that can be used for linking, but doesn't contain any executable code. This increases the number of cache hits for link actions. Call   {@link #setAllowInterfaceSharedObjects(boolean)} to enablethis behavior.
 * @throws RuleErrorException
 */
public CcLinkingOutputs createCcLinkActions(CcCompilationOutputs ccOutputs,Iterable<Artifact> nonCodeLinkerInputs) throws RuleErrorException, InterruptedException {
  Preconditions.checkState(linkType.staticness() == Staticness.STATIC,""String_Node_Str"");
  CcLinkingOutputs.Builder result=new CcLinkingOutputs.Builder();
  if (cppConfiguration.isLipoContextCollector()) {
    return result.build();
  }
  AnalysisEnvironment env=ruleContext.getAnalysisEnvironment();
  boolean usePicForBinaries=CppHelper.usePic(ruleContext,true);
  boolean usePicForSharedLibs=CppHelper.usePic(ruleContext,false);
  Artifact linkedArtifact=getLinkedArtifact(linkType);
  PathFragment labelName=new PathFragment(ruleContext.getLabel().getName());
  String libraryIdentifier=ruleContext.getPackageDirectory().getRelative(labelName.replaceName(""String_Node_Str"" + labelName.getBaseName())).getPathString();
  CppLinkAction maybePicAction=newLinkActionBuilder(linkedArtifact).addObjectFiles(ccOutputs.getObjectFiles(usePicForBinaries)).addNonCodeInputs(ccOutputs.getHeaderTokenFiles()).addNonCodeInputs(nonCodeLinkerInputs).addLTOBitcodeFiles(ccOutputs.getLtoBitcodeFiles()).setLinkType(linkType).setLinkStaticness(LinkStaticness.FULLY_STATIC).addActionInputs(linkActionInputs).setLibraryIdentifier(libraryIdentifier).addVariablesExtensions(variablesExtensions).setFeatureConfiguration(featureConfiguration).build();
  env.registerAction(maybePicAction);
  if (linkType != LinkTargetType.EXECUTABLE) {
    result.addStaticLibrary(maybePicAction.getOutputLibrary());
  }
  if (!usePicForBinaries && usePicForSharedLibs) {
    LinkTargetType picLinkType=(linkType == LinkTargetType.ALWAYS_LINK_STATIC_LIBRARY) ? LinkTargetType.ALWAYS_LINK_PIC_STATIC_LIBRARY : LinkTargetType.PIC_STATIC_LIBRARY;
    Artifact picArtifact=getLinkedArtifact(picLinkType);
    CppLinkAction picAction=newLinkActionBuilder(picArtifact).addObjectFiles(ccOutputs.getObjectFiles(true)).addNonCodeInputs(ccOutputs.getHeaderTokenFiles()).addLTOBitcodeFiles(ccOutputs.getLtoBitcodeFiles()).setLinkType(picLinkType).setLinkStaticness(LinkStaticness.FULLY_STATIC).addActionInputs(linkActionInputs).setLibraryIdentifier(libraryIdentifier).addVariablesExtensions(variablesExtensions).setFeatureConfiguration(featureConfiguration).build();
    env.registerAction(picAction);
    if (linkType != LinkTargetType.EXECUTABLE) {
      result.addPicStaticLibrary(picAction.getOutputLibrary());
    }
  }
  if (!createDynamicLibrary) {
    return result.build();
  }
  Artifact soImpl;
  String mainLibraryIdentifier;
  if (soImplArtifact == null) {
    soImpl=getLinkedArtifact(LinkTargetType.DYNAMIC_LIBRARY);
    mainLibraryIdentifier=libraryIdentifier;
  }
 else {
    soImpl=soImplArtifact;
    mainLibraryIdentifier=FileSystemUtils.removeExtension(soImpl.getRootRelativePath().getPathString());
  }
  List<String> sonameLinkopts=ImmutableList.of();
  Artifact soInterface=null;
  if (cppConfiguration.useInterfaceSharedObjects() && allowInterfaceSharedObjects) {
    soInterface=CppHelper.getLinuxLinkedArtifact(ruleContext,LinkTargetType.INTERFACE_DYNAMIC_LIBRARY);
    sonameLinkopts=ImmutableList.of(""String_Node_Str"" + SolibSymlinkAction.getDynamicLibrarySoname(soImpl.getRootRelativePath(),false));
  }
  CppLinkActionBuilder linkActionBuilder=newLinkActionBuilder(soImpl).setInterfaceOutput(soInterface).addObjectFiles(ccOutputs.getObjectFiles(usePicForSharedLibs)).addNonCodeInputs(ccOutputs.getHeaderTokenFiles()).addLTOBitcodeFiles(ccOutputs.getLtoBitcodeFiles()).setLinkType(LinkTargetType.DYNAMIC_LIBRARY).setLinkStaticness(LinkStaticness.DYNAMIC).addActionInputs(linkActionInputs).setLibraryIdentifier(mainLibraryIdentifier).addLinkopts(linkopts).addLinkopts(sonameLinkopts).setRuntimeInputs(ArtifactCategory.DYNAMIC_LIBRARY,CppHelper.getToolchain(ruleContext).getDynamicRuntimeLinkMiddleman(),CppHelper.getToolchain(ruleContext).getDynamicRuntimeLinkInputs()).setFeatureConfiguration(featureConfiguration).addVariablesExtensions(variablesExtensions);
  if (!ccOutputs.getLtoBitcodeFiles().isEmpty() && featureConfiguration.isEnabled(CppRuleClasses.THIN_LTO)) {
    linkActionBuilder.setLTOIndexing(true);
    CppLinkAction indexAction=linkActionBuilder.build();
    env.registerAction(indexAction);
    for (    LTOBackendArtifacts ltoArtifacts : indexAction.getAllLTOBackendArtifacts()) {
      ltoArtifacts.scheduleLTOBackendAction(ruleContext,usePicForSharedLibs);
    }
    linkActionBuilder.setLTOIndexing(false);
  }
  CppLinkAction action=linkActionBuilder.build();
  env.registerAction(action);
  if (linkType == LinkTargetType.EXECUTABLE) {
    return result.build();
  }
  LibraryToLink dynamicLibrary=action.getOutputLibrary();
  LibraryToLink interfaceLibrary=action.getInterfaceOutputLibrary();
  if (interfaceLibrary == null) {
    interfaceLibrary=dynamicLibrary;
  }
  if (neverLink) {
    result.addDynamicLibrary(interfaceLibrary);
    result.addExecutionDynamicLibrary(dynamicLibrary);
  }
 else {
    Artifact libraryLink=SolibSymlinkAction.getDynamicLibrarySymlink(ruleContext,interfaceLibrary.getArtifact(),false,false,ruleContext.getConfiguration());
    result.addDynamicLibrary(LinkerInputs.solibLibraryToLink(libraryLink,interfaceLibrary.getArtifact(),libraryIdentifier));
    Artifact implLibraryLink=SolibSymlinkAction.getDynamicLibrarySymlink(ruleContext,dynamicLibrary.getArtifact(),false,false,ruleContext.getConfiguration());
    result.addExecutionDynamicLibrary(LinkerInputs.solibLibraryToLink(implLibraryLink,dynamicLibrary.getArtifact(),libraryIdentifier));
  }
  return result.build();
}","/** 
 * Constructs the C++ linker actions. It generally generates two actions, one for a static library and one for a dynamic library. If PIC is required for shared libraries, but not for binaries, it additionally creates a third action to generate a PIC static library. <p>For dynamic libraries, this method can additionally create an interface shared library that can be used for linking, but doesn't contain any executable code. This increases the number of cache hits for link actions. Call   {@link #setAllowInterfaceSharedObjects(boolean)} to enablethis behavior.
 * @throws RuleErrorException
 */
public CcLinkingOutputs createCcLinkActions(CcCompilationOutputs ccOutputs,Iterable<Artifact> nonCodeLinkerInputs) throws RuleErrorException, InterruptedException {
  Preconditions.checkState(linkType.staticness() == Staticness.STATIC,""String_Node_Str"");
  CcLinkingOutputs.Builder result=new CcLinkingOutputs.Builder();
  if (cppConfiguration.isLipoContextCollector()) {
    return result.build();
  }
  AnalysisEnvironment env=ruleContext.getAnalysisEnvironment();
  boolean usePicForBinaries=CppHelper.usePic(ruleContext,true);
  boolean usePicForSharedLibs=CppHelper.usePic(ruleContext,false);
  Artifact linkedArtifact=getLinkedArtifact(linkType);
  PathFragment labelName=new PathFragment(ruleContext.getLabel().getName());
  String libraryIdentifier=ruleContext.getPackageDirectory().getRelative(labelName.replaceName(""String_Node_Str"" + labelName.getBaseName())).getPathString();
  CppLinkAction maybePicAction=newLinkActionBuilder(linkedArtifact).addObjectFiles(ccOutputs.getObjectFiles(usePicForBinaries)).addNonCodeInputs(nonCodeLinkerInputs).addLTOBitcodeFiles(ccOutputs.getLtoBitcodeFiles()).setLinkType(linkType).setLinkStaticness(LinkStaticness.FULLY_STATIC).addActionInputs(linkActionInputs).setLibraryIdentifier(libraryIdentifier).addVariablesExtensions(variablesExtensions).setFeatureConfiguration(featureConfiguration).build();
  env.registerAction(maybePicAction);
  if (linkType != LinkTargetType.EXECUTABLE) {
    result.addStaticLibrary(maybePicAction.getOutputLibrary());
  }
  if (!usePicForBinaries && usePicForSharedLibs) {
    LinkTargetType picLinkType=(linkType == LinkTargetType.ALWAYS_LINK_STATIC_LIBRARY) ? LinkTargetType.ALWAYS_LINK_PIC_STATIC_LIBRARY : LinkTargetType.PIC_STATIC_LIBRARY;
    Artifact picArtifact=getLinkedArtifact(picLinkType);
    CppLinkAction picAction=newLinkActionBuilder(picArtifact).addObjectFiles(ccOutputs.getObjectFiles(true)).addLTOBitcodeFiles(ccOutputs.getLtoBitcodeFiles()).setLinkType(picLinkType).setLinkStaticness(LinkStaticness.FULLY_STATIC).addActionInputs(linkActionInputs).setLibraryIdentifier(libraryIdentifier).addVariablesExtensions(variablesExtensions).setFeatureConfiguration(featureConfiguration).build();
    env.registerAction(picAction);
    if (linkType != LinkTargetType.EXECUTABLE) {
      result.addPicStaticLibrary(picAction.getOutputLibrary());
    }
  }
  if (!createDynamicLibrary) {
    return result.build();
  }
  Artifact soImpl;
  String mainLibraryIdentifier;
  if (soImplArtifact == null) {
    soImpl=getLinkedArtifact(LinkTargetType.DYNAMIC_LIBRARY);
    mainLibraryIdentifier=libraryIdentifier;
  }
 else {
    soImpl=soImplArtifact;
    mainLibraryIdentifier=FileSystemUtils.removeExtension(soImpl.getRootRelativePath().getPathString());
  }
  List<String> sonameLinkopts=ImmutableList.of();
  Artifact soInterface=null;
  if (cppConfiguration.useInterfaceSharedObjects() && allowInterfaceSharedObjects) {
    soInterface=CppHelper.getLinuxLinkedArtifact(ruleContext,LinkTargetType.INTERFACE_DYNAMIC_LIBRARY);
    sonameLinkopts=ImmutableList.of(""String_Node_Str"" + SolibSymlinkAction.getDynamicLibrarySoname(soImpl.getRootRelativePath(),false));
  }
  CppLinkActionBuilder linkActionBuilder=newLinkActionBuilder(soImpl).setInterfaceOutput(soInterface).addObjectFiles(ccOutputs.getObjectFiles(usePicForSharedLibs)).addNonCodeInputs(ccOutputs.getHeaderTokenFiles()).addLTOBitcodeFiles(ccOutputs.getLtoBitcodeFiles()).setLinkType(LinkTargetType.DYNAMIC_LIBRARY).setLinkStaticness(LinkStaticness.DYNAMIC).addActionInputs(linkActionInputs).setLibraryIdentifier(mainLibraryIdentifier).addLinkopts(linkopts).addLinkopts(sonameLinkopts).setRuntimeInputs(ArtifactCategory.DYNAMIC_LIBRARY,CppHelper.getToolchain(ruleContext).getDynamicRuntimeLinkMiddleman(),CppHelper.getToolchain(ruleContext).getDynamicRuntimeLinkInputs()).setFeatureConfiguration(featureConfiguration).addVariablesExtensions(variablesExtensions);
  if (!ccOutputs.getLtoBitcodeFiles().isEmpty() && featureConfiguration.isEnabled(CppRuleClasses.THIN_LTO)) {
    linkActionBuilder.setLTOIndexing(true);
    CppLinkAction indexAction=linkActionBuilder.build();
    env.registerAction(indexAction);
    for (    LTOBackendArtifacts ltoArtifacts : indexAction.getAllLTOBackendArtifacts()) {
      ltoArtifacts.scheduleLTOBackendAction(ruleContext,usePicForSharedLibs);
    }
    linkActionBuilder.setLTOIndexing(false);
  }
  CppLinkAction action=linkActionBuilder.build();
  env.registerAction(action);
  if (linkType == LinkTargetType.EXECUTABLE) {
    return result.build();
  }
  LibraryToLink dynamicLibrary=action.getOutputLibrary();
  LibraryToLink interfaceLibrary=action.getInterfaceOutputLibrary();
  if (interfaceLibrary == null) {
    interfaceLibrary=dynamicLibrary;
  }
  if (neverLink) {
    result.addDynamicLibrary(interfaceLibrary);
    result.addExecutionDynamicLibrary(dynamicLibrary);
  }
 else {
    Artifact libraryLink=SolibSymlinkAction.getDynamicLibrarySymlink(ruleContext,interfaceLibrary.getArtifact(),false,false,ruleContext.getConfiguration());
    result.addDynamicLibrary(LinkerInputs.solibLibraryToLink(libraryLink,interfaceLibrary.getArtifact(),libraryIdentifier));
    Artifact implLibraryLink=SolibSymlinkAction.getDynamicLibrarySymlink(ruleContext,dynamicLibrary.getArtifact(),false,false,ruleContext.getConfiguration());
    result.addExecutionDynamicLibrary(LinkerInputs.solibLibraryToLink(implLibraryLink,dynamicLibrary.getArtifact(),libraryIdentifier));
  }
  return result.build();
}",0.9918500407497962
110874,"@Test public void testProcessHeadersInDependenciesOfBinaries() throws Exception {
  AnalysisMock.get().ccSupport().setupCrosstool(mockToolsConfig,MockCcSupport.HEADER_PROCESSING_FEATURE_CONFIGURATION);
  useConfiguration(""String_Node_Str"",""String_Node_Str"");
  ConfiguredTarget x=scratchConfiguredTarget(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertThat(ActionsTestUtil.baseArtifactNames(getOutputGroup(x,OutputGroupProvider.HIDDEN_TOP_LEVEL))).contains(""String_Node_Str"");
}","@Test public void testProcessHeadersInDependenciesOfBinaries() throws Exception {
  AnalysisMock.get().ccSupport().setupCrosstool(mockToolsConfig,MockCcSupport.HEADER_PROCESSING_FEATURE_CONFIGURATION);
  useConfiguration(""String_Node_Str"",""String_Node_Str"");
  ConfiguredTarget x=scratchConfiguredTarget(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  String hiddenTopLevel=ActionsTestUtil.baseNamesOf(getOutputGroup(x,OutputGroupProvider.HIDDEN_TOP_LEVEL));
  assertThat(hiddenTopLevel).contains(""String_Node_Str"");
  assertThat(hiddenTopLevel).doesNotContain(""String_Node_Str"");
}",0.8421052631578947
110875,"/** 
 * Converts an environment map to the format expected in lpEnvironment by CreateProcess().
 */
private byte[] convertEnvToNative(Map<String,String> env) throws IOException {
  Map<String,String> realEnv=new TreeMap<>();
  realEnv.putAll(env == null ? System.getenv() : env);
  if (getSystemRoot(realEnv) == null) {
    String systemRoot=getSystemRoot(System.getenv());
    if (systemRoot != null) {
      realEnv.put(""String_Node_Str"",systemRoot);
    }
  }
  if (realEnv.isEmpty()) {
    return new byte[]{0,0};
  }
  StringBuilder result=new StringBuilder();
  for (  Map.Entry<String,String> entry : realEnv.entrySet()) {
    if (entry.getKey().contains(""String_Node_Str"")) {
      throw new IOException(""String_Node_Str"");
    }
    result.append(entry.getKey() + ""String_Node_Str"" + entry.getValue()+ ""String_Node_Str"");
  }
  result.append(""String_Node_Str"");
  return result.toString().getBytes(Charsets.UTF_8);
}","/** 
 * Converts an environment map to the format expected in lpEnvironment by CreateProcess().
 */
private byte[] convertEnvToNative(Map<String,String> env) throws IOException {
  Map<String,String> realEnv=new TreeMap<>();
  realEnv.putAll(env == null ? System.getenv() : env);
  if (getSystemRoot(realEnv) == null) {
    String systemRoot=getSystemRoot(System.getenv());
    if (systemRoot != null) {
      realEnv.put(""String_Node_Str"",systemRoot);
    }
  }
  if (realEnv.isEmpty()) {
    return new byte[]{0,0};
  }
  StringBuilder result=new StringBuilder();
  for (  Map.Entry<String,String> entry : realEnv.entrySet()) {
    if (entry.getKey().contains(""String_Node_Str"")) {
      continue;
    }
    result.append(entry.getKey() + ""String_Node_Str"" + entry.getValue()+ ""String_Node_Str"");
  }
  result.append(""String_Node_Str"");
  return result.toString().getBytes(Charsets.UTF_8);
}",0.9746974697469748
110876,"@Override public Path decompress(DecompressorDescriptor descriptor) throws RepositoryFunctionException {
  Optional<String> prefix=descriptor.prefix();
  boolean foundPrefix=false;
  try (InputStream decompressorStream=getDecompressorStream(descriptor)){
    TarArchiveInputStream tarStream=new TarArchiveInputStream(decompressorStream);
    TarArchiveEntry entry;
    while ((entry=tarStream.getNextTarEntry()) != null) {
      StripPrefixedPath entryPath=StripPrefixedPath.maybeDeprefix(entry.getName(),prefix);
      foundPrefix=foundPrefix || entryPath.foundPrefix();
      if (entryPath.skip()) {
        continue;
      }
      Path filename=descriptor.repositoryPath().getRelative(entryPath.getPathFragment());
      FileSystemUtils.createDirectoryAndParents(filename.getParentDirectory());
      if (entry.isDirectory()) {
        FileSystemUtils.createDirectoryAndParents(filename);
      }
 else {
        if (entry.isSymbolicLink()) {
          PathFragment linkName=new PathFragment(entry.getLinkName());
          if (linkName.isAbsolute()) {
            linkName=linkName.relativeTo(PathFragment.ROOT_DIR);
            linkName=descriptor.repositoryPath().getRelative(linkName).asFragment();
          }
          FileSystemUtils.ensureSymbolicLink(filename,linkName);
        }
 else {
          Files.copy(tarStream,filename.getPathFile().toPath(),StandardCopyOption.REPLACE_EXISTING);
          filename.chmod(entry.getMode());
        }
      }
    }
  }
 catch (  IOException e) {
    throw new RepositoryFunctionException(e,Transience.TRANSIENT);
  }
  if (prefix.isPresent() && !foundPrefix) {
    throw new RepositoryFunctionException(new IOException(""String_Node_Str"" + prefix.get() + ""String_Node_Str""),Transience.PERSISTENT);
  }
  return descriptor.repositoryPath();
}","@Override public Path decompress(DecompressorDescriptor descriptor) throws RepositoryFunctionException {
  Optional<String> prefix=descriptor.prefix();
  boolean foundPrefix=false;
  try (InputStream decompressorStream=getDecompressorStream(descriptor)){
    TarArchiveInputStream tarStream=new TarArchiveInputStream(decompressorStream);
    TarArchiveEntry entry;
    while ((entry=tarStream.getNextTarEntry()) != null) {
      StripPrefixedPath entryPath=StripPrefixedPath.maybeDeprefix(entry.getName(),prefix);
      foundPrefix=foundPrefix || entryPath.foundPrefix();
      if (entryPath.skip()) {
        continue;
      }
      Path filename=descriptor.repositoryPath().getRelative(entryPath.getPathFragment());
      FileSystemUtils.createDirectoryAndParents(filename.getParentDirectory());
      if (entry.isDirectory()) {
        FileSystemUtils.createDirectoryAndParents(filename);
      }
 else {
        if (entry.isSymbolicLink() || entry.isLink()) {
          PathFragment linkName=new PathFragment(entry.getLinkName());
          if (linkName.isAbsolute()) {
            linkName=linkName.relativeTo(PathFragment.ROOT_DIR);
            linkName=descriptor.repositoryPath().getRelative(linkName).asFragment();
          }
          if (entry.isSymbolicLink()) {
            FileSystemUtils.ensureSymbolicLink(filename,linkName);
          }
 else {
            FileSystemUtils.createHardLink(filename,descriptor.repositoryPath().getRelative(linkName));
          }
        }
 else {
          Files.copy(tarStream,filename.getPathFile().toPath(),StandardCopyOption.REPLACE_EXISTING);
          filename.chmod(entry.getMode());
        }
      }
    }
  }
 catch (  IOException e) {
    throw new RepositoryFunctionException(e,Transience.TRANSIENT);
  }
  if (prefix.isPresent() && !foundPrefix) {
    throw new RepositoryFunctionException(new IOException(""String_Node_Str"" + prefix.get() + ""String_Node_Str""),Transience.PERSISTENT);
  }
  return descriptor.repositoryPath();
}",0.9482029598308668
110877,"/** 
 * Compare Paths of the same file system using their PathFragments. <p>Paths from different filesystems will be compared using the identity hash code of their respective filesystems.
 */
@Override public int compareTo(Path o){
  if (equals(o)) {
    return 0;
  }
  FileSystem otherFs=o.getFileSystem();
  if (!fileSystem.equals(otherFs)) {
    int thisFileSystemHash=System.identityHashCode(fileSystem);
    int otherFileSystemHash=System.identityHashCode(otherFs);
    if (thisFileSystemHash < otherFileSystemHash) {
      return -1;
    }
 else     if (thisFileSystemHash > otherFileSystemHash) {
      return 1;
    }
 else {
      return 0;
    }
  }
  Path a=this, b=o;
  int maxDepth=Math.min(a.depth,b.depth);
  while (a.depth > maxDepth) {
    a=a.getParentDirectory();
  }
  while (b.depth > maxDepth) {
    b=b.getParentDirectory();
  }
  if (a.equals(b)) {
    return equals(a) ? -1 : 1;
  }
  Path previousa, previousb;
  do {
    previousa=a;
    previousb=b;
    a=a.getParentDirectory();
    b=b.getParentDirectory();
  }
 while (!a.equals(b));
  return previousa.name.compareTo(previousb.name);
}","/** 
 * Compare Paths of the same file system using their PathFragments. <p>Paths from different filesystems will be compared using the identity hash code of their respective filesystems.
 */
@Override public int compareTo(Path o){
  if (equals(o)) {
    return 0;
  }
  FileSystem otherFs=o.getFileSystem();
  if (!fileSystem.equals(otherFs)) {
    int thisFileSystemHash=System.identityHashCode(fileSystem);
    int otherFileSystemHash=System.identityHashCode(otherFs);
    if (thisFileSystemHash < otherFileSystemHash) {
      return -1;
    }
 else     if (thisFileSystemHash > otherFileSystemHash) {
      return 1;
    }
 else {
      return 0;
    }
  }
  Path a=this;
  Path b=o;
  int maxDepth=Math.min(a.depth,b.depth);
  while (a.depth > maxDepth) {
    a=a.getParentDirectory();
  }
  while (b.depth > maxDepth) {
    b=b.getParentDirectory();
  }
  if (a.equals(b)) {
    return equals(a) ? -1 : 1;
  }
  Path previousa;
  Path previousb;
  do {
    previousa=a;
    previousb=b;
    a=a.getParentDirectory();
    b=b.getParentDirectory();
  }
 while (!a.equals(b));
  return previousa.name.compareTo(previousb.name);
}",0.992
110878,"@Override public void exec(Spawn spawn,ActionExecutionContext actionExecutionContext) throws ExecException {
  Executor executor=actionExecutionContext.getExecutor();
  if (!spawn.isRemotable()) {
    SandboxHelpers.fallbackToNonSandboxedExecution(spawn,actionExecutionContext,executor);
    return;
  }
  SandboxHelpers.reportSubcommand(executor,spawn);
  SandboxHelpers.postActionStatusMessage(executor,spawn);
  PrintWriter errWriter=sandboxDebug ? new PrintWriter(actionExecutionContext.getFileOutErr().getErrorStream()) : null;
  Path sandboxPath=SandboxHelpers.getSandboxRoot(blazeDirs,productName,uuid,execCounter);
  Path sandboxExecRoot=sandboxPath.getRelative(""String_Node_Str"");
  if (errWriter != null) {
    errWriter.printf(""String_Node_Str"",sandboxPath.toString());
    errWriter.printf(""String_Node_Str"",sandboxExecRoot.toString());
  }
  ImmutableMap<String,String> spawnEnvironment=StandaloneSpawnStrategy.locallyDeterminedEnv(execRoot,productName,spawn.getEnvironment());
  Set<Path> writableDirs=getWritableDirs(sandboxExecRoot,spawn.getEnvironment());
  Path runUnderPath=getRunUnderPath(spawn);
  try {
    HardlinkedExecRoot hardlinkedExecRoot=new HardlinkedExecRoot(execRoot,sandboxPath,sandboxExecRoot,errWriter);
    if (errWriter != null) {
      errWriter.flush();
    }
    ImmutableSet<PathFragment> outputs=SandboxHelpers.getOutputFiles(spawn);
    hardlinkedExecRoot.createFileSystem(getMounts(spawn,actionExecutionContext),outputs,writableDirs);
    DarwinSandboxRunner runner;
    runner=new DarwinSandboxRunner(sandboxPath,sandboxExecRoot,getWritableDirs(sandboxExecRoot,spawnEnvironment),getInaccessiblePaths(),runUnderPath,verboseFailures);
    try {
      runner.run(spawn.getArguments(),spawnEnvironment,actionExecutionContext.getFileOutErr(),SandboxHelpers.getTimeout(spawn),SandboxHelpers.shouldAllowNetwork(buildRequest,spawn));
    }
  finally {
      hardlinkedExecRoot.copyOutputs(execRoot,outputs);
      if (!sandboxDebug) {
        SandboxHelpers.lazyCleanup(backgroundWorkers,runner);
      }
    }
  }
 catch (  IOException e) {
    throw new UserExecException(""String_Node_Str"",e);
  }
}","@Override public void exec(Spawn spawn,ActionExecutionContext actionExecutionContext) throws ExecException {
  Executor executor=actionExecutionContext.getExecutor();
  if (!spawn.isRemotable()) {
    SandboxHelpers.fallbackToNonSandboxedExecution(spawn,actionExecutionContext,executor);
    return;
  }
  SandboxHelpers.reportSubcommand(executor,spawn);
  SandboxHelpers.postActionStatusMessage(executor,spawn);
  PrintWriter errWriter=sandboxDebug ? new PrintWriter(actionExecutionContext.getFileOutErr().getErrorStream()) : null;
  Path sandboxPath=SandboxHelpers.getSandboxRoot(blazeDirs,productName,uuid,execCounter);
  Path sandboxExecRoot=sandboxPath.getRelative(""String_Node_Str"");
  if (errWriter != null) {
    errWriter.printf(""String_Node_Str"",sandboxPath.toString());
    errWriter.printf(""String_Node_Str"",sandboxExecRoot.toString());
  }
  ImmutableMap<String,String> spawnEnvironment=StandaloneSpawnStrategy.locallyDeterminedEnv(execRoot,productName,spawn.getEnvironment());
  Set<Path> writableDirs=getWritableDirs(sandboxExecRoot,spawn.getEnvironment());
  Path runUnderPath=getRunUnderPath(spawn);
  try {
    HardlinkedExecRoot hardlinkedExecRoot=new HardlinkedExecRoot(execRoot,sandboxPath,sandboxExecRoot,errWriter);
    ImmutableSet<PathFragment> outputs=SandboxHelpers.getOutputFiles(spawn);
    hardlinkedExecRoot.createFileSystem(getMounts(spawn,actionExecutionContext),outputs,writableDirs);
    if (errWriter != null) {
      errWriter.flush();
    }
    DarwinSandboxRunner runner;
    runner=new DarwinSandboxRunner(sandboxPath,sandboxExecRoot,getWritableDirs(sandboxExecRoot,spawnEnvironment),getInaccessiblePaths(),runUnderPath,verboseFailures);
    try {
      runner.run(spawn.getArguments(),spawnEnvironment,actionExecutionContext.getFileOutErr(),SandboxHelpers.getTimeout(spawn),SandboxHelpers.shouldAllowNetwork(buildRequest,spawn));
    }
  finally {
      hardlinkedExecRoot.copyOutputs(execRoot,outputs);
      if (!sandboxDebug) {
        SandboxHelpers.lazyCleanup(backgroundWorkers,runner);
      }
    }
  }
 catch (  IOException e) {
    throw new UserExecException(""String_Node_Str"",e);
  }
}",0.9719363891487371
110879,"/** 
 * The new capacity when growing the array to contain at least newSize many elements. Uses a growth factor of 1.5.
 */
private int growCapacity(int newSize){
  return newSize + newSize >> 1;
}","/** 
 * The new capacity when growing the array to contain at least newSize many elements. Uses a growth factor of 1.5.
 */
private int growCapacity(int newSize){
  return newSize + (newSize >> 1);
}",0.9949494949494948
110880,"/** 
 * Determines and returns a map from attribute name to list of configured fileset entries, based on a PrerequisiteMap instance.
 */
private ListMultimap<String,ConfiguredFilesetEntry> createFilesetEntryMap(final Rule rule,ImmutableMap<Label,ConfigMatchingProvider> configConditions){
  final ImmutableSortedKeyListMultimap.Builder<String,ConfiguredFilesetEntry> mapBuilder=ImmutableSortedKeyListMultimap.builder();
  for (  Attribute attr : rule.getAttributes()) {
    if (attr.getType() != BuildType.FILESET_ENTRY_LIST) {
      continue;
    }
    String attributeName=attr.getName();
    Map<Label,ConfiguredTarget> ctMap=new HashMap<>();
    for (    ConfiguredTarget prerequisite : prerequisiteMap.get(attr)) {
      ctMap.put(prerequisite.getLabel(),prerequisite);
    }
    List<FilesetEntry> entries=ConfiguredAttributeMapper.of(rule,configConditions).get(attributeName,BuildType.FILESET_ENTRY_LIST);
    for (    FilesetEntry entry : entries) {
      if (entry.getFiles() == null) {
        Label label=entry.getSrcLabel();
        ConfiguredTarget src=ctMap.get(label);
        if (!validateFilesetEntry(entry,src)) {
          continue;
        }
        mapBuilder.put(attributeName,new ConfiguredFilesetEntry(entry,src));
      }
 else {
        ImmutableList.Builder<TransitiveInfoCollection> files=ImmutableList.builder();
        for (        Label file : entry.getFiles()) {
          files.add(ctMap.get(file));
        }
        mapBuilder.put(attributeName,new ConfiguredFilesetEntry(entry,files.build()));
      }
    }
  }
  return mapBuilder.build();
}","/** 
 * Determines and returns a map from attribute name to list of configured fileset entries, based on a PrerequisiteMap instance.
 */
private ListMultimap<String,ConfiguredFilesetEntry> createFilesetEntryMap(final Rule rule,ImmutableMap<Label,ConfigMatchingProvider> configConditions){
  final ImmutableSortedKeyListMultimap.Builder<String,ConfiguredFilesetEntry> mapBuilder=ImmutableSortedKeyListMultimap.builder();
  for (  Attribute attr : rule.getAttributes()) {
    if (attr.getType() != BuildType.FILESET_ENTRY_LIST) {
      continue;
    }
    String attributeName=attr.getName();
    Map<Label,ConfiguredTarget> ctMap=new HashMap<>();
    for (    ConfiguredTarget prerequisite : prerequisiteMap.get(attr)) {
      ctMap.put(AliasProvider.getDependencyLabel(prerequisite),prerequisite);
    }
    List<FilesetEntry> entries=ConfiguredAttributeMapper.of(rule,configConditions).get(attributeName,BuildType.FILESET_ENTRY_LIST);
    for (    FilesetEntry entry : entries) {
      if (entry.getFiles() == null) {
        Label label=entry.getSrcLabel();
        ConfiguredTarget src=ctMap.get(label);
        if (!validateFilesetEntry(entry,src)) {
          continue;
        }
        mapBuilder.put(attributeName,new ConfiguredFilesetEntry(entry,src));
      }
 else {
        ImmutableList.Builder<TransitiveInfoCollection> files=ImmutableList.builder();
        for (        Label file : entry.getFiles()) {
          files.add(ctMap.get(file));
        }
        mapBuilder.put(attributeName,new ConfiguredFilesetEntry(entry,files.build()));
      }
    }
  }
  return mapBuilder.build();
}",0.986482238289846
110881,"/** 
 * Invokes obj.func() and returns the result.
 */
private Object invokeObjectMethod(Environment env) throws EvalException, InterruptedException {
  Object objValue=obj.eval(env);
  ImmutableList.Builder<Object> posargs=new ImmutableList.Builder<>();
  posargs.add(objValue);
  Map<String,Object> kwargs=new HashMap<>();
  evalArguments(posargs,kwargs,env);
  return invokeObjectMethod(func.getName(),posargs.build(),ImmutableMap.<String,Object>copyOf(kwargs),this,env);
}","/** 
 * Invokes obj.func() and returns the result.
 */
private Object invokeObjectMethod(Environment env) throws EvalException, InterruptedException {
  Object objValue=obj.eval(env);
  ImmutableList.Builder<Object> posargs=new ImmutableList.Builder<>();
  posargs.add(objValue);
  Map<String,Object> kwargs=new LinkedHashMap<>();
  evalArguments(posargs,kwargs,env);
  return invokeObjectMethod(func.getName(),posargs.build(),ImmutableMap.<String,Object>copyOf(kwargs),this,env);
}",0.9937369519832986
110882,"@Test public void testJavaCallWithPositionalAndKwargs() throws Exception {
  new SkylarkTest().update(""String_Node_Str"",new Mock()).setUp(""String_Node_Str"").testLookup(""String_Node_Str"",""String_Node_Str"");
  new SkylarkTest().update(""String_Node_Str"",new Mock()).setUp(""String_Node_Str"").testIfExactError(""String_Node_Str"",""String_Node_Str"");
  new SkylarkTest().update(""String_Node_Str"",new Mock()).setUp(""String_Node_Str"").testIfExactError(""String_Node_Str"",""String_Node_Str"");
  new SkylarkTest().update(""String_Node_Str"",new Mock()).setUp(""String_Node_Str"").testLookup(""String_Node_Str"",""String_Node_Str"");
  new SkylarkTest().update(""String_Node_Str"",new Mock()).setUp(""String_Node_Str"").testLookup(""String_Node_Str"",""String_Node_Str"");
  new SkylarkTest().update(""String_Node_Str"",new Mock()).setUp(""String_Node_Str"").testLookup(""String_Node_Str"",""String_Node_Str"");
}","@Test public void testJavaCallWithPositionalAndKwargs() throws Exception {
  new SkylarkTest().update(""String_Node_Str"",new Mock()).setUp(""String_Node_Str"").testLookup(""String_Node_Str"",""String_Node_Str"");
  new SkylarkTest().update(""String_Node_Str"",new Mock()).setUp(""String_Node_Str"").testIfExactError(""String_Node_Str"",""String_Node_Str"");
  new SkylarkTest().update(""String_Node_Str"",new Mock()).setUp(""String_Node_Str"").testIfExactError(""String_Node_Str"",""String_Node_Str"");
  new SkylarkTest().update(""String_Node_Str"",new Mock()).setUp(""String_Node_Str"").testLookup(""String_Node_Str"",""String_Node_Str"");
  new SkylarkTest().update(""String_Node_Str"",new Mock()).setUp(""String_Node_Str"").testLookup(""String_Node_Str"",""String_Node_Str"");
  new SkylarkTest().update(""String_Node_Str"",new Mock()).setUp(""String_Node_Str"").testLookup(""String_Node_Str"",""String_Node_Str"");
  new SkylarkTest().update(""String_Node_Str"",new Mock()).setUp(""String_Node_Str"").testIfExactError(""String_Node_Str"",""String_Node_Str"");
}",0.9273209549071618
110883,"@Override public void run(){
  NodeEntry state=Preconditions.checkNotNull(graph.get(null,Reason.EVALUATION,skyKey),skyKey);
  Preconditions.checkState(state.isReady(),""String_Node_Str"",skyKey,state);
  if (maybeHandleDirtyNode(state) == DirtyOutcome.ALREADY_PROCESSED) {
    return;
  }
  Set<SkyKey> oldDeps=state.getAllRemainingDirtyDirectDeps();
  SkyFunctionEnvironment env=new SkyFunctionEnvironment(skyKey,state.getTemporaryDirectDeps(),oldDeps,visitor);
  SkyFunctionName functionName=skyKey.functionName();
  SkyFunction factory=skyFunctions.get(functionName);
  Preconditions.checkState(factory != null,""String_Node_Str"",functionName,skyKey,state);
  SkyValue value=null;
  long startTime=BlazeClock.instance().nanoTime();
  try {
    value=factory.compute(skyKey,env);
  }
 catch (  final SkyFunctionException builderException) {
    ReifiedSkyFunctionException reifiedBuilderException=new ReifiedSkyFunctionException(builderException,skyKey);
    if ((!keepGoing || !env.valuesMissing()) && reifiedBuilderException.getRootCauseSkyKey().equals(skyKey)) {
      boolean shouldFailFast=!keepGoing || builderException.isCatastrophic();
      if (shouldFailFast) {
        if (!visitor.preventNewEvaluations()) {
          return;
        }
      }
      Map<SkyKey,NodeEntry> newlyRequestedDeps=getBatchValues(skyKey,Reason.RDEP_ADDITION,env.newlyRequestedDeps);
      boolean isTransitivelyTransient=reifiedBuilderException.isTransient();
      for (      NodeEntry depEntry : Iterables.concat(env.directDeps.values(),newlyRequestedDeps.values())) {
        if (!isDoneForBuild(depEntry)) {
          continue;
        }
        ErrorInfo depError=depEntry.getErrorInfo();
        if (depError != null) {
          isTransitivelyTransient|=depError.isTransient();
        }
      }
      ErrorInfo errorInfo=ErrorInfo.fromException(reifiedBuilderException,isTransitivelyTransient);
      registerNewlyDiscoveredDepsForDoneEntry(skyKey,state,newlyRequestedDeps,oldDeps,env);
      env.setError(state,errorInfo,reifiedBuilderException.isTransient());
      env.commit(state,keepGoing);
      if (!shouldFailFast) {
        return;
      }
      throw SchedulerException.ofError(errorInfo,skyKey);
    }
  }
catch (  InterruptedException ie) {
    throw SchedulerException.ofInterruption(ie,skyKey);
  }
catch (  RuntimeException re) {
    String msg=prepareCrashMessage(skyKey,state.getInProgressReverseDeps());
    RuntimeException ex=new RuntimeException(msg,re);
    visitor.noteCrash(ex);
    throw ex;
  }
 finally {
    env.doneBuilding();
    long elapsedTimeNanos=BlazeClock.instance().nanoTime() - startTime;
    if (elapsedTimeNanos > 0) {
      if (progressReceiver != null) {
        progressReceiver.computed(skyKey,elapsedTimeNanos);
      }
      Profiler.instance().logSimpleTaskDuration(startTime,elapsedTimeNanos,ProfilerTask.SKYFUNCTION,skyKey);
    }
  }
  GroupedListHelper<SkyKey> newDirectDeps=env.newlyRequestedDeps;
  if (value != null) {
    Preconditions.checkState(!env.valuesMissing(),""String_Node_Str"" + ""String_Node_Str"",skyKey,newDirectDeps,state);
    env.setValue(value);
    registerNewlyDiscoveredDepsForDoneEntry(skyKey,state,graph.getBatch(skyKey,Reason.RDEP_ADDITION,env.newlyRequestedDeps),oldDeps,env);
    env.commit(state,true);
    return;
  }
  if (env.getDepErrorKey() != null) {
    Preconditions.checkState(!keepGoing,""String_Node_Str"",skyKey,state,env.getDepErrorKey());
    SkyKey childErrorKey=env.getDepErrorKey();
    NodeEntry childErrorEntry=Preconditions.checkNotNull(graph.get(skyKey,Reason.OTHER,childErrorKey),""String_Node_Str"",skyKey,state,childErrorKey);
    Preconditions.checkState(!state.getTemporaryDirectDeps().expensiveContains(childErrorKey),""String_Node_Str"",skyKey,state,childErrorKey,childErrorEntry);
    Preconditions.checkState(newDirectDeps.contains(childErrorKey),""String_Node_Str"",state,childErrorKey,newDirectDeps);
    state.addTemporaryDirectDeps(GroupedListHelper.create(ImmutableList.of(childErrorKey)));
    DependencyState childErrorState;
    if (oldDeps.contains(childErrorKey)) {
      childErrorState=childErrorEntry.checkIfDoneForDirtyReverseDep(skyKey);
    }
 else {
      childErrorState=childErrorEntry.addReverseDepAndCheckIfDone(skyKey);
    }
    Preconditions.checkState(childErrorState == DependencyState.DONE,""String_Node_Str"",skyKey,state,childErrorKey,childErrorEntry);
    ErrorInfo childErrorInfo=Preconditions.checkNotNull(childErrorEntry.getErrorInfo());
    visitor.preventNewEvaluations();
    throw SchedulerException.ofError(childErrorInfo,childErrorKey);
  }
  state.addTemporaryDirectDeps(newDirectDeps);
  if (newDirectDeps.isEmpty()) {
    Preconditions.checkState(!env.childErrorInfos.isEmpty(),""String_Node_Str"",skyKey,state);
    Preconditions.checkState(keepGoing,""String_Node_Str"",skyKey,state,env.childErrorInfos);
    env.commit(state,true);
    return;
  }
  for (  Map.Entry<SkyKey,NodeEntry> e : graph.createIfAbsentBatch(skyKey,Reason.ENQUEUING_CHILD,newDirectDeps).entrySet()) {
    SkyKey newDirectDep=e.getKey();
    NodeEntry newDirectDepEntry=e.getValue();
    enqueueChild(skyKey,state,newDirectDep,newDirectDepEntry,oldDeps.contains(newDirectDep));
  }
}","@Override public void run(){
  NodeEntry state=Preconditions.checkNotNull(graph.get(null,Reason.EVALUATION,skyKey),skyKey);
  Preconditions.checkState(state.isReady(),""String_Node_Str"",skyKey,state);
  if (maybeHandleDirtyNode(state) == DirtyOutcome.ALREADY_PROCESSED) {
    return;
  }
  Set<SkyKey> oldDeps=state.getAllRemainingDirtyDirectDeps();
  SkyFunctionEnvironment env=new SkyFunctionEnvironment(skyKey,state.getTemporaryDirectDeps(),oldDeps,visitor);
  SkyFunctionName functionName=skyKey.functionName();
  SkyFunction factory=skyFunctions.get(functionName);
  Preconditions.checkState(factory != null,""String_Node_Str"",functionName,skyKey,state);
  SkyValue value=null;
  long startTime=BlazeClock.instance().nanoTime();
  try {
    value=factory.compute(skyKey,env);
  }
 catch (  final SkyFunctionException builderException) {
    ReifiedSkyFunctionException reifiedBuilderException=new ReifiedSkyFunctionException(builderException,skyKey);
    if ((!keepGoing || !env.valuesMissing()) && reifiedBuilderException.getRootCauseSkyKey().equals(skyKey)) {
      boolean shouldFailFast=!keepGoing || builderException.isCatastrophic();
      if (shouldFailFast) {
        if (!visitor.preventNewEvaluations()) {
          return;
        }
      }
      Map<SkyKey,NodeEntry> newlyRequestedDeps=getBatchValues(skyKey,Reason.RDEP_ADDITION,env.newlyRequestedDeps);
      boolean isTransitivelyTransient=reifiedBuilderException.isTransient();
      for (      NodeEntry depEntry : Iterables.concat(env.directDeps.values(),newlyRequestedDeps.values())) {
        if (!isDoneForBuild(depEntry)) {
          continue;
        }
        ErrorInfo depError=depEntry.getErrorInfo();
        if (depError != null) {
          isTransitivelyTransient|=depError.isTransient();
        }
      }
      ErrorInfo errorInfo=ErrorInfo.fromException(reifiedBuilderException,isTransitivelyTransient);
      registerNewlyDiscoveredDepsForDoneEntry(skyKey,state,newlyRequestedDeps,oldDeps,env);
      env.setError(state,errorInfo,reifiedBuilderException.isTransient());
      env.commit(state,keepGoing);
      if (!shouldFailFast) {
        return;
      }
      throw SchedulerException.ofError(errorInfo,skyKey);
    }
  }
catch (  InterruptedException ie) {
    throw SchedulerException.ofInterruption(ie,skyKey);
  }
catch (  RuntimeException re) {
    String msg=prepareCrashMessage(skyKey,state.getInProgressReverseDeps());
    RuntimeException ex=new RuntimeException(msg,re);
    visitor.noteCrash(ex);
    throw ex;
  }
 finally {
    env.doneBuilding();
    long elapsedTimeNanos=BlazeClock.instance().nanoTime() - startTime;
    if (elapsedTimeNanos > 0) {
      if (progressReceiver != null) {
        progressReceiver.computed(skyKey,elapsedTimeNanos);
      }
      Profiler.instance().logSimpleTaskDuration(startTime,elapsedTimeNanos,ProfilerTask.SKYFUNCTION,skyKey);
    }
  }
  GroupedListHelper<SkyKey> newDirectDeps=env.newlyRequestedDeps;
  if (value != null) {
    Preconditions.checkState(!env.valuesMissing(),""String_Node_Str"" + ""String_Node_Str"",skyKey,newDirectDeps,state);
    env.setValue(value);
    registerNewlyDiscoveredDepsForDoneEntry(skyKey,state,graph.getBatch(skyKey,Reason.RDEP_ADDITION,env.newlyRequestedDeps),oldDeps,env);
    env.commit(state,true);
    return;
  }
  if (env.getDepErrorKey() != null) {
    Preconditions.checkState(!keepGoing,""String_Node_Str"",skyKey,state,env.getDepErrorKey());
    SkyKey childErrorKey=env.getDepErrorKey();
    NodeEntry childErrorEntry=Preconditions.checkNotNull(graph.get(skyKey,Reason.OTHER,childErrorKey),""String_Node_Str"",skyKey,state,childErrorKey);
    if (newDirectDeps.contains(childErrorKey)) {
      state.addTemporaryDirectDeps(GroupedListHelper.create(ImmutableList.of(childErrorKey)));
      DependencyState childErrorState;
      if (oldDeps.contains(childErrorKey)) {
        childErrorState=childErrorEntry.checkIfDoneForDirtyReverseDep(skyKey);
      }
 else {
        childErrorState=childErrorEntry.addReverseDepAndCheckIfDone(skyKey);
      }
      Preconditions.checkState(childErrorState == DependencyState.DONE,""String_Node_Str"",skyKey,state,childErrorKey,childErrorEntry);
    }
    ErrorInfo childErrorInfo=Preconditions.checkNotNull(childErrorEntry.getErrorInfo());
    visitor.preventNewEvaluations();
    throw SchedulerException.ofError(childErrorInfo,childErrorKey);
  }
  state.addTemporaryDirectDeps(newDirectDeps);
  if (newDirectDeps.isEmpty()) {
    Preconditions.checkState(!env.childErrorInfos.isEmpty(),""String_Node_Str"",skyKey,state);
    Preconditions.checkState(keepGoing,""String_Node_Str"",skyKey,state,env.childErrorInfos);
    env.commit(state,true);
    return;
  }
  for (  Map.Entry<SkyKey,NodeEntry> e : graph.createIfAbsentBatch(skyKey,Reason.ENQUEUING_CHILD,newDirectDeps).entrySet()) {
    SkyKey newDirectDep=e.getKey();
    NodeEntry newDirectDepEntry=e.getValue();
    enqueueChild(skyKey,state,newDirectDep,newDirectDepEntry,oldDeps.contains(newDirectDep));
  }
}",0.8914004914004914
110884,"@Override public FragmentOptions getHost(boolean fallback){
  Options host=(Options)getDefault();
  host.outputDirectoryName=""String_Node_Str"";
  host.compilationMode=CompilationMode.OPT;
  host.isHost=true;
  host.useDynamicConfigurations=useDynamicConfigurations;
  if (fallback) {
    host.cpu=host.hostCpu;
  }
 else {
    host.cpu=hostCpu;
  }
  host.buildRunfiles=true;
  host.stampBinaries=false;
  host.checkVisibility=checkVisibility;
  host.checkLicenses=checkLicenses;
  host.skyframeNativeFileset=skyframeNativeFileset;
  host.allowRuntimeDepsOnNeverLink=allowRuntimeDepsOnNeverLink;
  host.defaultFeatures=ImmutableList.copyOf(defaultFeatures);
  return host;
}","@Override public FragmentOptions getHost(boolean fallback){
  Options host=(Options)getDefault();
  host.outputDirectoryName=""String_Node_Str"";
  host.compilationMode=CompilationMode.OPT;
  host.isHost=true;
  host.useDynamicConfigurations=useDynamicConfigurations;
  host.enforceConstraints=enforceConstraints;
  if (fallback) {
    host.cpu=host.hostCpu;
  }
 else {
    host.cpu=hostCpu;
  }
  host.buildRunfiles=true;
  host.stampBinaries=false;
  host.checkVisibility=checkVisibility;
  host.checkLicenses=checkLicenses;
  host.skyframeNativeFileset=skyframeNativeFileset;
  host.allowRuntimeDepsOnNeverLink=allowRuntimeDepsOnNeverLink;
  host.defaultFeatures=ImmutableList.copyOf(defaultFeatures);
  return host;
}",0.9670014347202296
110885,"private Label(PackageIdentifier packageIdentifier,String name) throws LabelSyntaxException {
  Preconditions.checkNotNull(packageIdentifier);
  Preconditions.checkNotNull(name);
  this.packageIdentifier=packageIdentifier;
  try {
    this.name=canonicalizeTargetName(name);
  }
 catch (  LabelSyntaxException e) {
    if (packageIdentifier.getPackageFragment().getPathString().endsWith(""String_Node_Str"" + name)) {
      throw new LabelSyntaxException(e.getMessage() + ""String_Node_Str"" + name+ ""String_Node_Str"");
    }
    throw e;
  }
  this.hashCode=Objects.hash(this.name,this.packageIdentifier);
}","private Label(PackageIdentifier packageIdentifier,String name) throws LabelSyntaxException {
  Preconditions.checkNotNull(packageIdentifier);
  Preconditions.checkNotNull(name);
  this.packageIdentifier=packageIdentifier;
  try {
    this.name=canonicalizeTargetName(name);
  }
 catch (  LabelSyntaxException e) {
    if (packageIdentifier.getPackageFragment().getPathString().endsWith(""String_Node_Str"" + name)) {
      throw new LabelSyntaxException(e.getMessage() + ""String_Node_Str"" + name+ ""String_Node_Str"");
    }
    throw e;
  }
  this.hashCode=hashCode(this.name,this.packageIdentifier);
}",0.9833610648918468
110886,"/** 
 * Performs validity checking of the specified target name. Returns null on success or an error message otherwise.
 */
@Nullable public static String validateTargetName(String targetName){
  int len=targetName.length();
  if (len == 0) {
    return ""String_Node_Str"";
  }
  char c=targetName.charAt(0);
  if (c == '/') {
    return ""String_Node_Str"";
  }
 else   if (c == '.') {
    if (targetName.startsWith(""String_Node_Str"") || targetName.equals(""String_Node_Str"")) {
      return ""String_Node_Str"";
    }
 else     if (targetName.equals(""String_Node_Str"")) {
      return null;
    }
 else     if (targetName.startsWith(""String_Node_Str"")) {
      return ""String_Node_Str"";
    }
  }
  if (targetName.endsWith(""String_Node_Str"")) {
    return ""String_Node_Str"" + ""String_Node_Str"";
  }
  for (int ii=0; ii < len; ++ii) {
    c=targetName.charAt(ii);
    if (ALWAYS_ALLOWED_TARGET_CHARACTERS.matches(c)) {
      continue;
    }
    if (c == '.') {
      continue;
    }
    if (c == '/') {
      if (targetName.substring(ii).startsWith(""String_Node_Str"")) {
        return ""String_Node_Str"";
      }
 else       if (targetName.substring(ii).startsWith(""String_Node_Str"")) {
        return ""String_Node_Str"";
      }
 else       if (targetName.substring(ii).startsWith(""String_Node_Str"")) {
        return ""String_Node_Str"";
      }
      continue;
    }
    if (CharMatcher.javaIsoControl().matches(c)) {
      return ""String_Node_Str"" + String.format(""String_Node_Str"",(int)c) + ""String_Node_Str"";
    }
    return ""String_Node_Str"" + c + ""String_Node_Str"";
  }
  if (c == '.') {
    if (targetName.endsWith(""String_Node_Str"")) {
      return ""String_Node_Str"";
    }
 else     if (targetName.endsWith(""String_Node_Str"")) {
      return null;
    }
  }
  if (c == '/') {
    return ""String_Node_Str"";
  }
  return null;
}","/** 
 * Performs validity checking of the specified target name. Returns null on success or an error message otherwise.
 */
@Nullable public static String validateTargetName(String targetName){
  int len=targetName.length();
  if (len == 0) {
    return ""String_Node_Str"";
  }
  char c=targetName.charAt(0);
  if (c == '/') {
    return ""String_Node_Str"";
  }
 else   if (c == '.') {
    if (targetName.startsWith(""String_Node_Str"") || targetName.equals(""String_Node_Str"")) {
      return ""String_Node_Str"";
    }
 else     if (targetName.equals(""String_Node_Str"")) {
      return null;
    }
 else     if (targetName.startsWith(""String_Node_Str"")) {
      return ""String_Node_Str"";
    }
  }
  if (targetName.endsWith(""String_Node_Str"")) {
    return ""String_Node_Str"" + ""String_Node_Str"";
  }
  for (int ii=0; ii < len; ++ii) {
    c=targetName.charAt(ii);
    if (ALWAYS_ALLOWED_TARGET_CHARACTERS.matches(c)) {
      continue;
    }
    if (c == '.') {
      continue;
    }
    if (c == '/') {
      if (stringRegionMatch(targetName,""String_Node_Str"",ii)) {
        return ""String_Node_Str"";
      }
 else       if (stringRegionMatch(targetName,""String_Node_Str"",ii)) {
        return ""String_Node_Str"";
      }
 else       if (stringRegionMatch(targetName,""String_Node_Str"",ii)) {
        return ""String_Node_Str"";
      }
      continue;
    }
    if (CharMatcher.javaIsoControl().matches(c)) {
      return ""String_Node_Str"" + String.format(""String_Node_Str"",(int)c) + ""String_Node_Str"";
    }
    return ""String_Node_Str"" + c + ""String_Node_Str"";
  }
  if (c == '.') {
    if (targetName.endsWith(""String_Node_Str"")) {
      return ""String_Node_Str"";
    }
 else     if (targetName.endsWith(""String_Node_Str"")) {
      return null;
    }
  }
  if (c == '/') {
    return ""String_Node_Str"";
  }
  return null;
}",0.850328947368421
110887,"private void setupCompileBuildVariables(CppCompileActionBuilder builder,boolean usePic,PathFragment ccRelativeName,PathFragment autoFdoImportPath,Artifact gcnoFile,Artifact dwoFile){
  CcToolchainFeatures.Variables.Builder buildVariables=new CcToolchainFeatures.Variables.Builder();
  CppCompilationContext builderContext=builder.getContext();
  CppModuleMap cppModuleMap=builderContext.getCppModuleMap();
  Artifact sourceFile=builder.getSourceFile();
  Artifact outputFile=builder.getOutputFile();
  String realOutputFilePath;
  buildVariables.addVariable(""String_Node_Str"",sourceFile.getExecPathString());
  buildVariables.addVariable(""String_Node_Str"",outputFile.getExecPathString());
  if (fake) {
    realOutputFilePath=builder.getTempOutputFile().getPathString();
  }
 else {
    realOutputFilePath=builder.getOutputFile().getExecPathString();
  }
  if (FileType.contains(outputFile,CppFileTypes.ASSEMBLER,CppFileTypes.PIC_ASSEMBLER)) {
    buildVariables.addVariable(""String_Node_Str"",realOutputFilePath);
  }
 else   if (FileType.contains(outputFile,CppFileTypes.PREPROCESSED_C,CppFileTypes.PREPROCESSED_CPP,CppFileTypes.PIC_PREPROCESSED_C,CppFileTypes.PIC_PREPROCESSED_CPP)) {
    buildVariables.addVariable(""String_Node_Str"",realOutputFilePath);
  }
 else {
    buildVariables.addVariable(""String_Node_Str"",realOutputFilePath);
  }
  DotdFile dotdFile=CppFileTypes.mustProduceDotdFile(sourceFile.getPath().toString()) ? Preconditions.checkNotNull(builder.getDotdFile()) : null;
  if (dotdFile != null) {
    buildVariables.addVariable(""String_Node_Str"",dotdFile.getSafeExecPath().getPathString());
  }
  if (featureConfiguration.isEnabled(CppRuleClasses.MODULE_MAPS) && cppModuleMap != null) {
    buildVariables.addVariable(""String_Node_Str"",cppModuleMap.getName());
    buildVariables.addVariable(""String_Node_Str"",cppModuleMap.getArtifact().getExecPathString());
    CcToolchainFeatures.Variables.ValueSequence.Builder sequence=new CcToolchainFeatures.Variables.ValueSequence.Builder();
    for (    Artifact artifact : builderContext.getDirectModuleMaps()) {
      sequence.addValue(artifact.getExecPathString());
    }
    buildVariables.addSequence(""String_Node_Str"",sequence.build());
  }
  if (featureConfiguration.isEnabled(CppRuleClasses.USE_HEADER_MODULES)) {
    buildVariables.addSequenceVariable(""String_Node_Str"",getHeaderModulePaths(builder,usePic));
  }
  if (featureConfiguration.isEnabled(CppRuleClasses.INCLUDE_PATHS)) {
    buildVariables.addSequenceVariable(""String_Node_Str"",getSafePathStrings(builderContext.getIncludeDirs()));
    buildVariables.addSequenceVariable(""String_Node_Str"",getSafePathStrings(builderContext.getQuoteIncludeDirs()));
    buildVariables.addSequenceVariable(""String_Node_Str"",getSafePathStrings(builderContext.getSystemIncludeDirs()));
  }
  if (featureConfiguration.isEnabled(CppRuleClasses.PREPROCESSOR_DEFINES)) {
    String fdoBuildStamp=CppHelper.getFdoBuildStamp(ruleContext);
    ImmutableList<String> defines;
    if (fdoBuildStamp != null) {
      defines=ImmutableList.<String>builder().addAll(builderContext.getDefines()).add(CppConfiguration.FDO_STAMP_MACRO + ""String_Node_Str"" + CppHelper.getFdoBuildStamp(ruleContext)+ ""String_Node_Str"").build();
    }
 else {
      defines=builderContext.getDefines();
    }
    buildVariables.addSequenceVariable(""String_Node_Str"",defines);
  }
  if (usePic) {
    if (!featureConfiguration.isEnabled(CppRuleClasses.PIC)) {
      ruleContext.ruleError(""String_Node_Str"");
    }
    buildVariables.addVariable(""String_Node_Str"",""String_Node_Str"");
  }
  if (ccRelativeName != null) {
    CppHelper.getFdoSupport(ruleContext).configureCompilation(builder,buildVariables,ruleContext,ccRelativeName,autoFdoImportPath,usePic,featureConfiguration);
  }
  if (gcnoFile != null) {
    buildVariables.addVariable(""String_Node_Str"",gcnoFile.getExecPathString());
  }
  if (dwoFile != null) {
    buildVariables.addVariable(""String_Node_Str"",dwoFile.getExecPathString());
  }
  buildVariables.addAllVariables(CppHelper.getToolchain(ruleContext).getBuildVariables());
  for (  VariablesExtension extension : variablesExtensions) {
    extension.addVariables(buildVariables);
  }
  CcToolchainFeatures.Variables variables=buildVariables.build();
  builder.setVariables(variables);
}","private void setupCompileBuildVariables(CppCompileActionBuilder builder,boolean usePic,PathFragment ccRelativeName,PathFragment autoFdoImportPath,Artifact gcnoFile,Artifact dwoFile){
  CcToolchainFeatures.Variables.Builder buildVariables=new CcToolchainFeatures.Variables.Builder();
  CppCompilationContext builderContext=builder.getContext();
  CppModuleMap cppModuleMap=builderContext.getCppModuleMap();
  Artifact sourceFile=builder.getSourceFile();
  Artifact outputFile=builder.getOutputFile();
  String realOutputFilePath;
  buildVariables.addVariable(""String_Node_Str"",sourceFile.getExecPathString());
  buildVariables.addVariable(""String_Node_Str"",outputFile.getExecPathString());
  if (builder.getTempOutputFile() != null) {
    realOutputFilePath=builder.getTempOutputFile().getPathString();
  }
 else {
    realOutputFilePath=builder.getOutputFile().getExecPathString();
  }
  if (FileType.contains(outputFile,CppFileTypes.ASSEMBLER,CppFileTypes.PIC_ASSEMBLER)) {
    buildVariables.addVariable(""String_Node_Str"",realOutputFilePath);
  }
 else   if (FileType.contains(outputFile,CppFileTypes.PREPROCESSED_C,CppFileTypes.PREPROCESSED_CPP,CppFileTypes.PIC_PREPROCESSED_C,CppFileTypes.PIC_PREPROCESSED_CPP)) {
    buildVariables.addVariable(""String_Node_Str"",realOutputFilePath);
  }
 else {
    buildVariables.addVariable(""String_Node_Str"",realOutputFilePath);
  }
  DotdFile dotdFile=CppFileTypes.mustProduceDotdFile(sourceFile.getPath().toString()) ? Preconditions.checkNotNull(builder.getDotdFile()) : null;
  if (dotdFile != null) {
    buildVariables.addVariable(""String_Node_Str"",dotdFile.getSafeExecPath().getPathString());
  }
  if (featureConfiguration.isEnabled(CppRuleClasses.MODULE_MAPS) && cppModuleMap != null) {
    buildVariables.addVariable(""String_Node_Str"",cppModuleMap.getName());
    buildVariables.addVariable(""String_Node_Str"",cppModuleMap.getArtifact().getExecPathString());
    CcToolchainFeatures.Variables.ValueSequence.Builder sequence=new CcToolchainFeatures.Variables.ValueSequence.Builder();
    for (    Artifact artifact : builderContext.getDirectModuleMaps()) {
      sequence.addValue(artifact.getExecPathString());
    }
    buildVariables.addSequence(""String_Node_Str"",sequence.build());
  }
  if (featureConfiguration.isEnabled(CppRuleClasses.USE_HEADER_MODULES)) {
    buildVariables.addSequenceVariable(""String_Node_Str"",getHeaderModulePaths(builder,usePic));
  }
  if (featureConfiguration.isEnabled(CppRuleClasses.INCLUDE_PATHS)) {
    buildVariables.addSequenceVariable(""String_Node_Str"",getSafePathStrings(builderContext.getIncludeDirs()));
    buildVariables.addSequenceVariable(""String_Node_Str"",getSafePathStrings(builderContext.getQuoteIncludeDirs()));
    buildVariables.addSequenceVariable(""String_Node_Str"",getSafePathStrings(builderContext.getSystemIncludeDirs()));
  }
  if (featureConfiguration.isEnabled(CppRuleClasses.PREPROCESSOR_DEFINES)) {
    String fdoBuildStamp=CppHelper.getFdoBuildStamp(ruleContext);
    ImmutableList<String> defines;
    if (fdoBuildStamp != null) {
      defines=ImmutableList.<String>builder().addAll(builderContext.getDefines()).add(CppConfiguration.FDO_STAMP_MACRO + ""String_Node_Str"" + CppHelper.getFdoBuildStamp(ruleContext)+ ""String_Node_Str"").build();
    }
 else {
      defines=builderContext.getDefines();
    }
    buildVariables.addSequenceVariable(""String_Node_Str"",defines);
  }
  if (usePic) {
    if (!featureConfiguration.isEnabled(CppRuleClasses.PIC)) {
      ruleContext.ruleError(""String_Node_Str"");
    }
    buildVariables.addVariable(""String_Node_Str"",""String_Node_Str"");
  }
  if (ccRelativeName != null) {
    CppHelper.getFdoSupport(ruleContext).configureCompilation(builder,buildVariables,ruleContext,ccRelativeName,autoFdoImportPath,usePic,featureConfiguration);
  }
  if (gcnoFile != null) {
    buildVariables.addVariable(""String_Node_Str"",gcnoFile.getExecPathString());
  }
  if (dwoFile != null) {
    buildVariables.addVariable(""String_Node_Str"",dwoFile.getExecPathString());
  }
  buildVariables.addAllVariables(CppHelper.getToolchain(ruleContext).getBuildVariables());
  for (  VariablesExtension extension : variablesExtensions) {
    extension.addVariables(buildVariables);
  }
  CcToolchainFeatures.Variables variables=buildVariables.build();
  builder.setVariables(variables);
}",0.9954593084177435
110888,"/** 
 * Collects all attribute labels from the specified aspectDefinition.
 */
public static void addAllAttributesOfAspect(Rule from,Multimap<Attribute,Label> labelBuilder,Aspect aspect,DependencyFilter dependencyFilter){
  ImmutableMap<String,Attribute> attributes=aspect.getDefinition().getAttributes();
  for (  Attribute aspectAttribute : attributes.values()) {
    if (!dependencyFilter.apply(aspect,aspectAttribute)) {
      continue;
    }
    if (aspectAttribute.getType() == BuildType.LABEL) {
      Label label=from.getLabel().resolveRepositoryRelative(BuildType.LABEL.cast(aspectAttribute.getDefaultValue(from)));
      if (label != null) {
        labelBuilder.put(aspectAttribute,label);
      }
    }
 else     if (aspectAttribute.getType() == BuildType.LABEL_LIST) {
      for (      Label label : BuildType.LABEL_LIST.cast(aspectAttribute.getDefaultValue(from))) {
        labelBuilder.put(aspectAttribute,from.getLabel().resolveRepositoryRelative(label));
      }
    }
  }
}","/** 
 * Collects all attribute labels from the specified aspectDefinition.
 */
public static void addAllAttributesOfAspect(Rule from,Multimap<Attribute,Label> labelBuilder,Aspect aspect,DependencyFilter dependencyFilter){
  ImmutableMap<String,Attribute> attributes=aspect.getDefinition().getAttributes();
  for (  Attribute aspectAttribute : attributes.values()) {
    if (!dependencyFilter.apply(aspect,aspectAttribute)) {
      continue;
    }
    if (aspectAttribute.getType() == BuildType.LABEL) {
      Label label=maybeGetRepositoryRelativeLabel(from,BuildType.LABEL.cast(aspectAttribute.getDefaultValue(from)));
      if (label != null) {
        labelBuilder.put(aspectAttribute,label);
      }
    }
 else     if (aspectAttribute.getType() == BuildType.LABEL_LIST) {
      List<Label> defaultLabels=BuildType.LABEL_LIST.cast(aspectAttribute.getDefaultValue(from));
      if (defaultLabels != null) {
        for (        Label defaultLabel : defaultLabels) {
          Label label=maybeGetRepositoryRelativeLabel(from,defaultLabel);
          if (label != null) {
            labelBuilder.put(aspectAttribute,label);
          }
        }
      }
    }
  }
}",0.8148148148148148
110889,"@Override public synchronized void handle(Event event){
  try {
    if (debugAllEvents) {
      clearProgressBar();
      terminal.flush();
      outErr.getOutputStream().write((event + ""String_Node_Str"").getBytes(StandardCharsets.UTF_8));
      outErr.getOutputStream().flush();
      addProgressBar();
      terminal.flush();
    }
 else {
switch (event.getKind()) {
case STDOUT:
case STDERR:
        OutputStream stream=event.getKind() == EventKind.STDOUT ? outErr.getOutputStream() : outErr.getErrorStream();
      if (buildComplete) {
        stream.write(event.getMessageBytes());
        stream.flush();
      }
 else {
        byte[] message=event.getMessageBytes();
        int eolIndex=Bytes.lastIndexOf(message,(byte)'\n');
        if (eolIndex >= 0) {
          clearProgressBar();
          terminal.flush();
          stream.write(event.getKind() == EventKind.STDOUT ? stdoutBuffer : stderrBuffer);
          stream.write(Arrays.copyOf(message,eolIndex + 1));
          byte[] restMessage=Arrays.copyOfRange(message,eolIndex + 1,message.length + 1);
          if (event.getKind() == EventKind.STDOUT) {
            stdoutBuffer=restMessage;
          }
 else {
            stderrBuffer=restMessage;
          }
          stream.flush();
          if (cursorControl) {
            addProgressBar();
          }
          terminal.flush();
        }
 else {
          if (event.getKind() == EventKind.STDOUT) {
            stdoutBuffer=Bytes.concat(stdoutBuffer,message);
          }
 else {
            stderrBuffer=Bytes.concat(stderrBuffer,message);
          }
        }
      }
    break;
case ERROR:
case WARNING:
case INFO:
case SUBCOMMAND:
  if (!buildComplete) {
    clearProgressBar();
  }
outErr.getOutputStream().write(stdoutBuffer);
outErr.getOutputStream().flush();
stdoutBuffer=new byte[]{};
outErr.getErrorStream().write(stderrBuffer);
outErr.getErrorStream().flush();
stderrBuffer=new byte[]{};
crlf();
setEventKindColor(event.getKind());
terminal.writeString(event.getKind() + ""String_Node_Str"");
terminal.resetTerminal();
if (event.getLocation() != null) {
terminal.writeString(event.getLocation() + ""String_Node_Str"");
}
if (event.getMessage() != null) {
terminal.writeString(event.getMessage());
}
crlf();
if (!buildComplete) {
addProgressBar();
}
terminal.flush();
break;
case PROGRESS:
if (stateTracker.progressBarTimeDependent()) {
refresh();
}
}
}
}
 catch (IOException e) {
LOG.warning(""String_Node_Str"" + e);
}
}","@Override public synchronized void handle(Event event){
  try {
    if (debugAllEvents) {
      clearProgressBar();
      terminal.flush();
      outErr.getOutputStream().write((event + ""String_Node_Str"").getBytes(StandardCharsets.UTF_8));
      outErr.getOutputStream().flush();
      addProgressBar();
      terminal.flush();
    }
 else {
switch (event.getKind()) {
case STDOUT:
case STDERR:
        OutputStream stream=event.getKind() == EventKind.STDOUT ? outErr.getOutputStream() : outErr.getErrorStream();
      if (buildComplete) {
        stream.write(event.getMessageBytes());
        stream.flush();
      }
 else {
        byte[] message=event.getMessageBytes();
        int eolIndex=Bytes.lastIndexOf(message,(byte)'\n');
        if (eolIndex >= 0) {
          clearProgressBar();
          terminal.flush();
          stream.write(event.getKind() == EventKind.STDOUT ? stdoutBuffer : stderrBuffer);
          stream.write(Arrays.copyOf(message,eolIndex + 1));
          byte[] restMessage=Arrays.copyOfRange(message,eolIndex + 1,message.length);
          if (event.getKind() == EventKind.STDOUT) {
            stdoutBuffer=restMessage;
          }
 else {
            stderrBuffer=restMessage;
          }
          stream.flush();
          if (cursorControl) {
            addProgressBar();
          }
          terminal.flush();
        }
 else {
          if (event.getKind() == EventKind.STDOUT) {
            stdoutBuffer=Bytes.concat(stdoutBuffer,message);
          }
 else {
            stderrBuffer=Bytes.concat(stderrBuffer,message);
          }
        }
      }
    break;
case ERROR:
case WARNING:
case INFO:
case SUBCOMMAND:
  if (!buildComplete) {
    clearProgressBar();
  }
outErr.getOutputStream().write(stdoutBuffer);
outErr.getOutputStream().flush();
stdoutBuffer=new byte[]{};
outErr.getErrorStream().write(stderrBuffer);
outErr.getErrorStream().flush();
stderrBuffer=new byte[]{};
crlf();
setEventKindColor(event.getKind());
terminal.writeString(event.getKind() + ""String_Node_Str"");
terminal.resetTerminal();
if (event.getLocation() != null) {
terminal.writeString(event.getLocation() + ""String_Node_Str"");
}
if (event.getMessage() != null) {
terminal.writeString(event.getMessage());
}
crlf();
if (!buildComplete) {
addProgressBar();
}
terminal.flush();
break;
case PROGRESS:
if (stateTracker.progressBarTimeDependent()) {
refresh();
}
}
}
}
 catch (IOException e) {
LOG.warning(""String_Node_Str"" + e);
}
}",0.999183340138832
110890,"protected SkyframeExecutor(EvaluatorSupplier evaluatorSupplier,PackageFactory pkgFactory,BlazeDirectories directories,BinTools binTools,Factory workspaceStatusActionFactory,ImmutableList<BuildInfoFactory> buildInfoFactories,Predicate<PathFragment> allowedMissingInputs,Preprocessor.Factory.Supplier preprocessorFactorySupplier,ImmutableMap<SkyFunctionName,SkyFunction> extraSkyFunctions,ImmutableList<PrecomputedValue.Injected> extraPrecomputedValues,boolean errorOnExternalFiles,PathFragment blacklistedPackagePrefixesFile,String productName){
  this.evaluatorSupplier=evaluatorSupplier;
  this.pkgFactory=pkgFactory;
  this.pkgFactory.setSyscalls(syscalls);
  this.workspaceStatusActionFactory=workspaceStatusActionFactory;
  this.packageManager=new SkyframePackageManager(new SkyframePackageLoader(),new SkyframeTransitivePackageLoader(),syscalls,cyclesReporter,pkgLocator,numPackagesLoaded,this);
  this.resourceManager=ResourceManager.instance();
  this.skyframeActionExecutor=new SkyframeActionExecutor(resourceManager,eventBus,statusReporterRef);
  this.directories=Preconditions.checkNotNull(directories);
  this.buildInfoFactories=buildInfoFactories;
  this.allowedMissingInputs=allowedMissingInputs;
  this.preprocessorFactorySupplier=preprocessorFactorySupplier;
  this.extraSkyFunctions=extraSkyFunctions;
  this.extraPrecomputedValues=extraPrecomputedValues;
  this.errorOnExternalFiles=errorOnExternalFiles;
  this.blacklistedPackagePrefixesFile=blacklistedPackagePrefixesFile;
  this.binTools=binTools;
  this.skyframeBuildView=new SkyframeBuildView(directories,this,binTools,(ConfiguredRuleClassProvider)pkgFactory.getRuleClassProvider());
  this.artifactFactory.set(skyframeBuildView.getArtifactFactory());
  this.externalFilesHelper=new ExternalFilesHelper(pkgLocator,this.errorOnExternalFiles,directories);
  this.productName=productName;
}","protected SkyframeExecutor(EvaluatorSupplier evaluatorSupplier,PackageFactory pkgFactory,BlazeDirectories directories,BinTools binTools,Factory workspaceStatusActionFactory,ImmutableList<BuildInfoFactory> buildInfoFactories,Predicate<PathFragment> allowedMissingInputs,Preprocessor.Factory.Supplier preprocessorFactorySupplier,ImmutableMap<SkyFunctionName,SkyFunction> extraSkyFunctions,ImmutableList<PrecomputedValue.Injected> extraPrecomputedValues,boolean errorOnExternalFiles,PathFragment blacklistedPackagePrefixesFile,String productName){
  this.evaluatorSupplier=evaluatorSupplier;
  this.pkgFactory=pkgFactory;
  this.pkgFactory.setSyscalls(syscalls);
  this.workspaceStatusActionFactory=workspaceStatusActionFactory;
  this.packageManager=new SkyframePackageManager(new SkyframePackageLoader(),new SkyframeTransitivePackageLoader(),syscalls,cyclesReporter,pkgLocator,numPackagesLoaded,this);
  this.resourceManager=ResourceManager.instance();
  this.skyframeActionExecutor=new SkyframeActionExecutor(resourceManager,eventBus,statusReporterRef);
  this.directories=Preconditions.checkNotNull(directories);
  this.buildInfoFactories=buildInfoFactories;
  this.allowedMissingInputs=allowedMissingInputs;
  this.preprocessorFactorySupplier=preprocessorFactorySupplier;
  this.extraSkyFunctions=extraSkyFunctions;
  this.extraPrecomputedValues=extraPrecomputedValues;
  this.errorOnExternalFiles=errorOnExternalFiles;
  this.blacklistedPackagePrefixesFile=blacklistedPackagePrefixesFile;
  this.binTools=binTools;
  this.ruleClassProvider=pkgFactory.getRuleClassProvider();
  this.skyframeBuildView=new SkyframeBuildView(directories,this,binTools,(ConfiguredRuleClassProvider)ruleClassProvider);
  this.artifactFactory.set(skyframeBuildView.getArtifactFactory());
  this.externalFilesHelper=new ExternalFilesHelper(pkgLocator,this.errorOnExternalFiles,directories);
  this.productName=productName;
}",0.9441786283891548
110891,"/** 
 * Computes the build options needed for the given key, accounting for transitions possibly specified in the key.
 */
private BuildOptions getDynamicConfigOptions(Dependency key,BuildOptions fromOptions){
  if (key.hasStaticConfiguration()) {
    return key.getConfiguration().getOptions();
  }
 else   if (key.getTransition() == Attribute.ConfigurationTransition.NONE) {
    return fromOptions;
  }
 else {
    return ((PatchTransition)key.getTransition()).apply(fromOptions);
  }
}","/** 
 * Computes the build options needed for the given key, accounting for transitions possibly specified in the key.
 */
private BuildOptions getDynamicConfigOptions(Dependency key,BuildOptions fromOptions,Iterable<Class<? extends BuildConfiguration.Fragment>> requiredFragments){
  if (key.hasStaticConfiguration()) {
    return key.getConfiguration().getOptions();
  }
  BuildOptions toOptions;
  if (key.getTransition() == Attribute.ConfigurationTransition.NONE) {
    toOptions=fromOptions;
  }
 else {
    toOptions=((PatchTransition)key.getTransition()).apply(fromOptions);
  }
  return toOptions.trim(BuildConfiguration.getOptionsClasses(requiredFragments,ruleClassProvider));
}",0.7982978723404255
110892,"/** 
 * Retrieves the configurations needed for the given deps, trimming down their fragments to those only needed by their transitive closures.
 */
private Map<Dependency,BuildConfiguration> getConfigurations(EventHandler eventHandler,BuildOptions fromOptions,Iterable<Dependency> keys){
  Map<Dependency,BuildConfiguration> builder=new HashMap<>();
  Set<Dependency> depsToEvaluate=new HashSet<>();
  final List<SkyKey> transitiveFragmentSkyKeys=new ArrayList<>();
  Map<Label,Set<Class<? extends BuildConfiguration.Fragment>>> fragmentsMap=new HashMap<>();
  Set<Label> labelsWithErrors=new HashSet<>();
  for (  Dependency key : keys) {
    if (key.hasStaticConfiguration()) {
      builder.put(key,key.getConfiguration());
    }
 else     if (key.getTransition() == Attribute.ConfigurationTransition.NULL) {
      builder.put(key,null);
    }
 else {
      depsToEvaluate.add(key);
      transitiveFragmentSkyKeys.add(TransitiveTargetValue.key(key.getLabel()));
    }
  }
  EvaluationResult<SkyValue> fragmentsResult=evaluateSkyKeys(eventHandler,transitiveFragmentSkyKeys);
  for (  Dependency key : keys) {
    if (!depsToEvaluate.contains(key)) {
    }
 else     if (fragmentsResult.getError(TransitiveTargetValue.key(key.getLabel())) != null) {
      labelsWithErrors.add(key.getLabel());
    }
 else {
      TransitiveTargetValue ttv=(TransitiveTargetValue)fragmentsResult.get(TransitiveTargetValue.key(key.getLabel()));
      fragmentsMap.put(key.getLabel(),ttv.getTransitiveConfigFragments().toSet());
    }
  }
  final List<SkyKey> configSkyKeys=new ArrayList<>();
  for (  Dependency key : keys) {
    if (!depsToEvaluate.contains(key) || labelsWithErrors.contains(key.getLabel())) {
      continue;
    }
    configSkyKeys.add(BuildConfigurationValue.key(fragmentsMap.get(key.getLabel()),getDynamicConfigOptions(key,fromOptions)));
  }
  EvaluationResult<SkyValue> configsResult=evaluateSkyKeys(eventHandler,configSkyKeys);
  for (  Dependency key : keys) {
    if (!depsToEvaluate.contains(key) || labelsWithErrors.contains(key.getLabel())) {
      continue;
    }
    SkyKey configKey=BuildConfigurationValue.key(fragmentsMap.get(key.getLabel()),getDynamicConfigOptions(key,fromOptions));
    builder.put(key,((BuildConfigurationValue)configsResult.get(configKey)).getConfiguration());
  }
  return builder;
}","/** 
 * Retrieves the configurations needed for the given deps, trimming down their fragments to those only needed by their transitive closures.
 */
private Map<Dependency,BuildConfiguration> getConfigurations(EventHandler eventHandler,BuildOptions fromOptions,Iterable<Dependency> keys){
  Map<Dependency,BuildConfiguration> builder=new HashMap<>();
  Set<Dependency> depsToEvaluate=new HashSet<>();
  final List<SkyKey> transitiveFragmentSkyKeys=new ArrayList<>();
  Map<Label,Set<Class<? extends BuildConfiguration.Fragment>>> fragmentsMap=new HashMap<>();
  Set<Label> labelsWithErrors=new HashSet<>();
  for (  Dependency key : keys) {
    if (key.hasStaticConfiguration()) {
      builder.put(key,key.getConfiguration());
    }
 else     if (key.getTransition() == Attribute.ConfigurationTransition.NULL) {
      builder.put(key,null);
    }
 else {
      depsToEvaluate.add(key);
      transitiveFragmentSkyKeys.add(TransitiveTargetValue.key(key.getLabel()));
    }
  }
  EvaluationResult<SkyValue> fragmentsResult=evaluateSkyKeys(eventHandler,transitiveFragmentSkyKeys);
  for (  Dependency key : keys) {
    if (!depsToEvaluate.contains(key)) {
    }
 else     if (fragmentsResult.getError(TransitiveTargetValue.key(key.getLabel())) != null) {
      labelsWithErrors.add(key.getLabel());
    }
 else {
      TransitiveTargetValue ttv=(TransitiveTargetValue)fragmentsResult.get(TransitiveTargetValue.key(key.getLabel()));
      fragmentsMap.put(key.getLabel(),ttv.getTransitiveConfigFragments().toSet());
    }
  }
  final List<SkyKey> configSkyKeys=new ArrayList<>();
  for (  Dependency key : keys) {
    if (!depsToEvaluate.contains(key) || labelsWithErrors.contains(key.getLabel())) {
      continue;
    }
    Set<Class<? extends BuildConfiguration.Fragment>> depFragments=fragmentsMap.get(key.getLabel());
    configSkyKeys.add(BuildConfigurationValue.key(depFragments,getDynamicConfigOptions(key,fromOptions,depFragments)));
  }
  EvaluationResult<SkyValue> configsResult=evaluateSkyKeys(eventHandler,configSkyKeys);
  for (  Dependency key : keys) {
    if (!depsToEvaluate.contains(key) || labelsWithErrors.contains(key.getLabel())) {
      continue;
    }
    Set<Class<? extends BuildConfiguration.Fragment>> depFragments=fragmentsMap.get(key.getLabel());
    SkyKey configKey=BuildConfigurationValue.key(depFragments,getDynamicConfigOptions(key,fromOptions,depFragments));
    builder.put(key,((BuildConfigurationValue)configsResult.get(configKey)).getConfiguration());
  }
  return builder;
}",0.87474162877222
110893,"/** 
 * Registers actions required for compiling the proto files.
 * @return this proto support
 */
public ProtoSupport registerActions(){
  if (!Iterables.isEmpty(getProtoSources())) {
    registerProtoInputListFileAction();
    registerGenerateProtoFilesAction();
  }
  return this;
}","/** 
 * Registers actions required for compiling the proto files.
 * @return this proto support
 */
public ProtoSupport registerActions(){
  if (!Iterables.isEmpty(getFilteredProtoSources())) {
    registerProtoInputListFileAction();
    registerGenerateProtoFilesAction();
  }
  return this;
}",0.986206896551724
110894,"private NestedSet<Artifact> getGenerateActionInputs(){
  NestedSetBuilder<Artifact> inputsBuilder=NestedSetBuilder.<Artifact>stableOrder().add(attributes.getProtoCompiler()).addAll(getProtoSources()).add(getProtoInputListFile()).addAll(attributes.getProtoCompilerSupport()).addAll(getPortableProtoFilters());
  Artifact optionsFile=attributes.getOptionsFile();
  if (optionsFile != null) {
    inputsBuilder.add(optionsFile);
  }
  return inputsBuilder.build();
}","private NestedSet<Artifact> getGenerateActionInputs(){
  NestedSetBuilder<Artifact> inputsBuilder=NestedSetBuilder.<Artifact>stableOrder().add(attributes.getProtoCompiler()).addAll(getAllProtoSources()).add(getProtoInputListFile()).addAll(attributes.getProtoCompilerSupport()).addAll(getPortableProtoFilters());
  Artifact optionsFile=attributes.getOptionsFile();
  if (optionsFile != null) {
    inputsBuilder.add(optionsFile);
  }
  return inputsBuilder.build();
}",0.9967707212055974
110895,"private ImmutableList<Artifact> generatedOutputArtifacts(FileType newFileType){
  ImmutableList.Builder<Artifact> builder=new ImmutableList.Builder<>();
  for (  Artifact protoFile : getProtoSources()) {
    String protoFileName=FileSystemUtils.removeExtension(protoFile.getFilename());
    String generatedOutputName;
    if (attributes.outputsCpp()) {
      generatedOutputName=protoFileName;
    }
 else     if (usesProtobufLibrary()) {
      generatedOutputName=generateProtobufFilename(protoFileName);
    }
 else {
      String lowerUnderscoreBaseName=protoFileName.replace('-','_').toLowerCase();
      generatedOutputName=LOWER_UNDERSCORE.to(UPPER_CAMEL,lowerUnderscoreBaseName);
    }
    PathFragment generatedFilePath=new PathFragment(protoFile.getRootRelativePath().getParentDirectory(),new PathFragment(generatedOutputName));
    PathFragment outputFile=FileSystemUtils.appendExtension(generatedFilePath,newFileType.getExtensions().get(0));
    if (outputFile != null) {
      builder.add(ruleContext.getUniqueDirectoryArtifact(UNIQUE_DIRECTORY_NAME,outputFile,ruleContext.getBinOrGenfilesDirectory()));
    }
  }
  return builder.build();
}","private ImmutableList<Artifact> generatedOutputArtifacts(FileType newFileType){
  ImmutableList.Builder<Artifact> builder=new ImmutableList.Builder<>();
  for (  Artifact protoFile : getFilteredProtoSources()) {
    String protoFileName=FileSystemUtils.removeExtension(protoFile.getFilename());
    String generatedOutputName;
    if (attributes.outputsCpp()) {
      generatedOutputName=protoFileName;
    }
 else     if (usesProtobufLibrary()) {
      generatedOutputName=generateProtobufFilename(protoFileName);
    }
 else {
      String lowerUnderscoreBaseName=protoFileName.replace('-','_').toLowerCase();
      generatedOutputName=LOWER_UNDERSCORE.to(UPPER_CAMEL,lowerUnderscoreBaseName);
    }
    PathFragment generatedFilePath=new PathFragment(protoFile.getRootRelativePath().getParentDirectory(),new PathFragment(generatedOutputName));
    PathFragment outputFile=FileSystemUtils.appendExtension(generatedFilePath,newFileType.getExtensions().get(0));
    if (outputFile != null) {
      builder.add(ruleContext.getUniqueDirectoryArtifact(UNIQUE_DIRECTORY_NAME,outputFile,ruleContext.getBinOrGenfilesDirectory()));
    }
  }
  return builder.build();
}",0.996545768566494
110896,"private String getProtoInputListFileContents(){
  return Artifact.joinExecPaths(""String_Node_Str"",getProtoSources());
}","private String getProtoInputListFileContents(){
  return Artifact.joinExecPaths(""String_Node_Str"",getFilteredProtoSources());
}",0.967479674796748
110897,"@Override public ConfiguredAspect create(ConfiguredTarget base,RuleContext ruleContext,AspectParameters parameters) throws InterruptedException {
  ConfiguredAspect.Builder aspectBuilder=new ConfiguredAspect.Builder(NAME,ruleContext);
  ObjcConfiguration objcConfiguration=ruleContext.getFragment(ObjcConfiguration.class);
  if (!objcConfiguration.experimentalAutoTopLevelUnionObjCProtos()) {
    return aspectBuilder.build();
  }
  ObjcProtoProvider.Builder aspectObjcProtoProvider=new ObjcProtoProvider.Builder();
  Iterable<ObjcProtoProvider> depObjcProtoProviders=ruleContext.getPrerequisites(""String_Node_Str"",Mode.TARGET,ObjcProtoProvider.class);
  aspectObjcProtoProvider.addTransitive(depObjcProtoProviders);
  if (ruleContext.attributes().has(ObjcProtoLibraryRule.PORTABLE_PROTO_FILTERS_ATTR,LABEL_LIST)) {
    aspectObjcProtoProvider.addPortableProtoFilters(PrerequisiteArtifacts.nestedSet(ruleContext,ObjcProtoLibraryRule.PORTABLE_PROTO_FILTERS_ATTR,Mode.HOST));
    Iterable<ProtoSourcesProvider> protoProviders=ruleContext.getPrerequisites(""String_Node_Str"",Mode.TARGET,ProtoSourcesProvider.class);
    for (    ProtoSourcesProvider protoProvider : protoProviders) {
      aspectObjcProtoProvider.addProtoSources(protoProvider.getTransitiveProtoSources());
    }
  }
  if (!aspectObjcProtoProvider.isEmpty()) {
    aspectBuilder.addProvider(ObjcProtoProvider.class,aspectObjcProtoProvider.build());
  }
  return aspectBuilder.build();
}","@Override public ConfiguredAspect create(ConfiguredTarget base,RuleContext ruleContext,AspectParameters parameters) throws InterruptedException {
  ConfiguredAspect.Builder aspectBuilder=new ConfiguredAspect.Builder(NAME,ruleContext);
  ObjcConfiguration objcConfiguration=ruleContext.getFragment(ObjcConfiguration.class);
  if (!objcConfiguration.experimentalAutoTopLevelUnionObjCProtos()) {
    return aspectBuilder.build();
  }
  ObjcProtoProvider.Builder aspectObjcProtoProvider=new ObjcProtoProvider.Builder();
  if (ruleContext.attributes().has(""String_Node_Str"",BuildType.LABEL_LIST)) {
    Iterable<ObjcProtoProvider> depObjcProtoProviders=ruleContext.getPrerequisites(""String_Node_Str"",Mode.TARGET,ObjcProtoProvider.class);
    aspectObjcProtoProvider.addTransitive(depObjcProtoProviders);
  }
  if (ruleContext.attributes().isAttributeValueExplicitlySpecified(ObjcProtoLibraryRule.PORTABLE_PROTO_FILTERS_ATTR)) {
    aspectObjcProtoProvider.addPortableProtoFilters(PrerequisiteArtifacts.nestedSet(ruleContext,ObjcProtoLibraryRule.PORTABLE_PROTO_FILTERS_ATTR,Mode.HOST));
    Iterable<ProtoSourcesProvider> protoProviders=ruleContext.getPrerequisites(""String_Node_Str"",Mode.TARGET,ProtoSourcesProvider.class);
    for (    ProtoSourcesProvider protoProvider : protoProviders) {
      aspectObjcProtoProvider.addProtoSources(protoProvider.getTransitiveProtoSources());
    }
  }
  if (!aspectObjcProtoProvider.isEmpty()) {
    aspectBuilder.addProvider(ObjcProtoProvider.class,aspectObjcProtoProvider.build());
  }
  return aspectBuilder.build();
}",0.7547420965058236
110898,"/** 
 * Queries if the node is done and adds the given key as a reverse dependency. The return code indicates whether a) the node is done, b) the reverse dependency is the first one, so the node needs to be scheduled, or c) the reverse dependency was added, and the node does not need to be scheduled. <p>This method <b>must</b> be called before any processing of the entry. This encourages callers to check that the entry is ready to be processed. <p>Adding the dependency and checking if the node needs to be scheduled is an atomic operation to avoid a race where two threads work on two nodes, where one depends on the other (b depends on a). In that case, we need to ensure that b is re-scheduled exactly once when a is done. However, a may complete first, in which case b has to re-schedule itself. Also see   {@link #setValue}. <p>If the parameter is   {@code null}, then no reverse dependency is added, but we still check if the node needs to be scheduled.
 */
@ThreadSafe DependencyState addReverseDepAndCheckIfDone(@Nullable SkyKey reverseDep);","/** 
 * Queries if the node is done and adds the given key as a reverse dependency. The return code indicates whether a) the node is done, b) the reverse dependency is the first one, so the node needs to be scheduled, or c) the reverse dependency was added, and the node does not need to be scheduled. <p>This method <b>must</b> be called before any processing of the entry. This encourages callers to check that the entry is ready to be processed. <p>Adding the dependency and checking if the node needs to be scheduled is an atomic operation to avoid a race where two threads work on two nodes, where one depends on the other (b depends on a). In that case, we need to ensure that b is re-scheduled exactly once when a is done. However, a may complete first, in which case b has to re-schedule itself. Also see   {@link #setValue}. <p>If the parameter is   {@code null}, then no reverse dependency is added, but we still check if the node needs to be scheduled. <p>If   {@code reverseDep} is a rebuilding dirty entry that was already a reverse dep of thisentry, then  {@link #checkIfDoneForDirtyReverseDep} must be called instead.
 */
@ThreadSafe DependencyState addReverseDepAndCheckIfDone(@Nullable SkyKey reverseDep);",0.9257142857142856
110899,"@Override public void run(){
  NodeEntry state=Preconditions.checkNotNull(graph.get(skyKey),skyKey);
  Preconditions.checkState(state.isReady(),""String_Node_Str"",skyKey,state);
  if (maybeHandleDirtyNode(state) == DirtyOutcome.ALREADY_PROCESSED) {
    return;
  }
  Set<SkyKey> oldDeps=state.getAllRemainingDirtyDirectDeps();
  SkyFunctionEnvironment env=new SkyFunctionEnvironment(skyKey,state.getTemporaryDirectDeps(),oldDeps,visitor);
  SkyFunctionName functionName=skyKey.functionName();
  SkyFunction factory=skyFunctions.get(functionName);
  Preconditions.checkState(factory != null,""String_Node_Str"",functionName,skyKey,state);
  SkyValue value=null;
  long startTime=BlazeClock.instance().nanoTime();
  try {
    value=factory.compute(skyKey,env);
  }
 catch (  final SkyFunctionException builderException) {
    ReifiedSkyFunctionException reifiedBuilderException=new ReifiedSkyFunctionException(builderException,skyKey);
    if (reifiedBuilderException.getRootCauseSkyKey().equals(skyKey)) {
      boolean shouldFailFast=!keepGoing || builderException.isCatastrophic();
      if (shouldFailFast) {
        if (!visitor.preventNewEvaluations()) {
          return;
        }
      }
      Map<SkyKey,NodeEntry> newlyRequestedDeps=graph.getBatch(env.newlyRequestedDeps);
      boolean isTransitivelyTransient=reifiedBuilderException.isTransient();
      for (      NodeEntry depEntry : Iterables.concat(env.directDeps.values(),newlyRequestedDeps.values())) {
        if (!isDoneForBuild(depEntry)) {
          continue;
        }
        ErrorInfo depError=depEntry.getErrorInfo();
        if (depError != null) {
          isTransitivelyTransient|=depError.isTransient();
        }
      }
      ErrorInfo errorInfo=ErrorInfo.fromException(reifiedBuilderException,isTransitivelyTransient);
      registerNewlyDiscoveredDepsForDoneEntry(skyKey,state,newlyRequestedDeps,oldDeps,env);
      env.setError(errorInfo,reifiedBuilderException.isTransient());
      env.commit(keepGoing);
      if (!shouldFailFast) {
        return;
      }
      throw SchedulerException.ofError(errorInfo,skyKey);
    }
  }
catch (  InterruptedException ie) {
    throw SchedulerException.ofInterruption(ie,skyKey);
  }
catch (  RuntimeException re) {
    String msg=prepareCrashMessage(skyKey,state.getInProgressReverseDeps());
    RuntimeException ex=new RuntimeException(msg,re);
    visitor.noteCrash(ex);
    throw ex;
  }
 finally {
    env.doneBuilding();
    long elapsedTimeNanos=BlazeClock.instance().nanoTime() - startTime;
    if (elapsedTimeNanos > 0) {
      if (progressReceiver != null) {
        progressReceiver.computed(skyKey,elapsedTimeNanos);
      }
      Profiler.instance().logSimpleTaskDuration(startTime,elapsedTimeNanos,ProfilerTask.SKYFUNCTION,skyKey);
    }
  }
  GroupedListHelper<SkyKey> newDirectDeps=env.newlyRequestedDeps;
  if (value != null) {
    Preconditions.checkState(!env.valuesMissing(),""String_Node_Str"" + ""String_Node_Str"",skyKey,newDirectDeps,state);
    env.setValue(value);
    registerNewlyDiscoveredDepsForDoneEntry(skyKey,state,graph.getBatch(env.newlyRequestedDeps),oldDeps,env);
    env.commit(true);
    return;
  }
  if (env.getDepErrorKey() != null) {
    Preconditions.checkState(!keepGoing,""String_Node_Str"",skyKey,state,env.getDepErrorKey());
    SkyKey childErrorKey=env.getDepErrorKey();
    NodeEntry childErrorEntry=Preconditions.checkNotNull(graph.get(childErrorKey),""String_Node_Str"",skyKey,state,childErrorKey);
    Preconditions.checkState(!state.getTemporaryDirectDeps().expensiveContains(childErrorKey),""String_Node_Str"",skyKey,state,childErrorKey,childErrorEntry);
    Preconditions.checkState(newDirectDeps.contains(childErrorKey),""String_Node_Str"",state,childErrorKey,newDirectDeps);
    state.addTemporaryDirectDeps(GroupedListHelper.create(ImmutableList.of(childErrorKey)));
    DependencyState childErrorState=childErrorEntry.addReverseDepAndCheckIfDone(skyKey);
    Preconditions.checkState(childErrorState == DependencyState.DONE,""String_Node_Str"",skyKey,state,childErrorKey,childErrorEntry);
    ErrorInfo childErrorInfo=Preconditions.checkNotNull(childErrorEntry.getErrorInfo());
    visitor.preventNewEvaluations();
    throw SchedulerException.ofError(childErrorInfo,childErrorKey);
  }
  state.addTemporaryDirectDeps(newDirectDeps);
  if (newDirectDeps.isEmpty()) {
    Preconditions.checkState(!env.childErrorInfos.isEmpty(),""String_Node_Str"",skyKey,state);
    Preconditions.checkState(keepGoing,""String_Node_Str"",skyKey,state,env.childErrorInfos);
    env.commit(true);
    return;
  }
  for (  Map.Entry<SkyKey,NodeEntry> e : graph.createIfAbsentBatch(newDirectDeps).entrySet()) {
    SkyKey newDirectDep=e.getKey();
    NodeEntry newDirectDepEntry=e.getValue();
    enqueueChild(skyKey,state,newDirectDep,newDirectDepEntry,oldDeps.contains(newDirectDep));
  }
}","@Override public void run(){
  NodeEntry state=Preconditions.checkNotNull(graph.get(skyKey),skyKey);
  Preconditions.checkState(state.isReady(),""String_Node_Str"",skyKey,state);
  if (maybeHandleDirtyNode(state) == DirtyOutcome.ALREADY_PROCESSED) {
    return;
  }
  Set<SkyKey> oldDeps=state.getAllRemainingDirtyDirectDeps();
  SkyFunctionEnvironment env=new SkyFunctionEnvironment(skyKey,state.getTemporaryDirectDeps(),oldDeps,visitor);
  SkyFunctionName functionName=skyKey.functionName();
  SkyFunction factory=skyFunctions.get(functionName);
  Preconditions.checkState(factory != null,""String_Node_Str"",functionName,skyKey,state);
  SkyValue value=null;
  long startTime=BlazeClock.instance().nanoTime();
  try {
    value=factory.compute(skyKey,env);
  }
 catch (  final SkyFunctionException builderException) {
    ReifiedSkyFunctionException reifiedBuilderException=new ReifiedSkyFunctionException(builderException,skyKey);
    if (reifiedBuilderException.getRootCauseSkyKey().equals(skyKey)) {
      boolean shouldFailFast=!keepGoing || builderException.isCatastrophic();
      if (shouldFailFast) {
        if (!visitor.preventNewEvaluations()) {
          return;
        }
      }
      Map<SkyKey,NodeEntry> newlyRequestedDeps=graph.getBatch(env.newlyRequestedDeps);
      boolean isTransitivelyTransient=reifiedBuilderException.isTransient();
      for (      NodeEntry depEntry : Iterables.concat(env.directDeps.values(),newlyRequestedDeps.values())) {
        if (!isDoneForBuild(depEntry)) {
          continue;
        }
        ErrorInfo depError=depEntry.getErrorInfo();
        if (depError != null) {
          isTransitivelyTransient|=depError.isTransient();
        }
      }
      ErrorInfo errorInfo=ErrorInfo.fromException(reifiedBuilderException,isTransitivelyTransient);
      registerNewlyDiscoveredDepsForDoneEntry(skyKey,state,newlyRequestedDeps,oldDeps,env);
      env.setError(errorInfo,reifiedBuilderException.isTransient());
      env.commit(keepGoing);
      if (!shouldFailFast) {
        return;
      }
      throw SchedulerException.ofError(errorInfo,skyKey);
    }
  }
catch (  InterruptedException ie) {
    throw SchedulerException.ofInterruption(ie,skyKey);
  }
catch (  RuntimeException re) {
    String msg=prepareCrashMessage(skyKey,state.getInProgressReverseDeps());
    RuntimeException ex=new RuntimeException(msg,re);
    visitor.noteCrash(ex);
    throw ex;
  }
 finally {
    env.doneBuilding();
    long elapsedTimeNanos=BlazeClock.instance().nanoTime() - startTime;
    if (elapsedTimeNanos > 0) {
      if (progressReceiver != null) {
        progressReceiver.computed(skyKey,elapsedTimeNanos);
      }
      Profiler.instance().logSimpleTaskDuration(startTime,elapsedTimeNanos,ProfilerTask.SKYFUNCTION,skyKey);
    }
  }
  GroupedListHelper<SkyKey> newDirectDeps=env.newlyRequestedDeps;
  if (value != null) {
    Preconditions.checkState(!env.valuesMissing(),""String_Node_Str"" + ""String_Node_Str"",skyKey,newDirectDeps,state);
    env.setValue(value);
    registerNewlyDiscoveredDepsForDoneEntry(skyKey,state,graph.getBatch(env.newlyRequestedDeps),oldDeps,env);
    env.commit(true);
    return;
  }
  if (env.getDepErrorKey() != null) {
    Preconditions.checkState(!keepGoing,""String_Node_Str"",skyKey,state,env.getDepErrorKey());
    SkyKey childErrorKey=env.getDepErrorKey();
    NodeEntry childErrorEntry=Preconditions.checkNotNull(graph.get(childErrorKey),""String_Node_Str"",skyKey,state,childErrorKey);
    Preconditions.checkState(!state.getTemporaryDirectDeps().expensiveContains(childErrorKey),""String_Node_Str"",skyKey,state,childErrorKey,childErrorEntry);
    Preconditions.checkState(newDirectDeps.contains(childErrorKey),""String_Node_Str"",state,childErrorKey,newDirectDeps);
    state.addTemporaryDirectDeps(GroupedListHelper.create(ImmutableList.of(childErrorKey)));
    DependencyState childErrorState;
    if (oldDeps.contains(childErrorKey)) {
      childErrorState=childErrorEntry.checkIfDoneForDirtyReverseDep(skyKey);
    }
 else {
      childErrorState=childErrorEntry.addReverseDepAndCheckIfDone(skyKey);
    }
    Preconditions.checkState(childErrorState == DependencyState.DONE,""String_Node_Str"",skyKey,state,childErrorKey,childErrorEntry);
    ErrorInfo childErrorInfo=Preconditions.checkNotNull(childErrorEntry.getErrorInfo());
    visitor.preventNewEvaluations();
    throw SchedulerException.ofError(childErrorInfo,childErrorKey);
  }
  state.addTemporaryDirectDeps(newDirectDeps);
  if (newDirectDeps.isEmpty()) {
    Preconditions.checkState(!env.childErrorInfos.isEmpty(),""String_Node_Str"",skyKey,state);
    Preconditions.checkState(keepGoing,""String_Node_Str"",skyKey,state,env.childErrorInfos);
    env.commit(true);
    return;
  }
  for (  Map.Entry<SkyKey,NodeEntry> e : graph.createIfAbsentBatch(newDirectDeps).entrySet()) {
    SkyKey newDirectDep=e.getKey();
    NodeEntry newDirectDepEntry=e.getValue();
    enqueueChild(skyKey,state,newDirectDep,newDirectDepEntry,oldDeps.contains(newDirectDep));
  }
}",0.9828129767110748
110900,"/** 
 * Returns the path formed by appending the relative or absolute string  {@code path} to this path.<p>If the given path string is absolute, the current path will be ignored; otherwise, they will be combined. Up-level references ("".."") cause the preceding path segment to be elided. <p>This is a purely syntactic operation, i.e. it does no I/O, it does not validate the existence of any path, nor resolve symbolic links.
 */
public Path getRelative(String path){
  if ((path.length() == 0) || (path.equals(""String_Node_Str""))) {
    return this;
  }
 else   if (path.equals(""String_Node_Str"")) {
    return parent == null ? this : parent;
  }
 else   if ((path.indexOf('/') != -1)) {
    return getRelative(new PathFragment(path));
  }
 else {
    return getCachedChildPath(path);
  }
}","/** 
 * Returns the path formed by appending the relative or absolute string  {@code path} to this path.<p>If the given path string is absolute, the current path will be ignored; otherwise, they will be combined. Up-level references ("".."") cause the preceding path segment to be elided. <p>This is a purely syntactic operation, i.e. it does no I/O, it does not validate the existence of any path, nor resolve symbolic links.
 */
public Path getRelative(String path){
  if ((path.length() == 0) || (path.equals(""String_Node_Str""))) {
    return this;
  }
 else   if (path.equals(""String_Node_Str"")) {
    return parent == null ? this : parent;
  }
 else   if (path.indexOf('/') != -1) {
    return getRelative(new PathFragment(path));
  }
 else   if (path.indexOf(PathFragment.EXTRA_SEPARATOR_CHAR) != -1) {
    return getRelative(new PathFragment(path));
  }
 else {
    return getCachedChildPath(path);
  }
}",0.9276044732195408
110901,"@Override protected String computeKey(){
  Fingerprint f=new Fingerprint();
  f.addString(GUID);
  f.addInt(privateHeaders.size());
  for (  Artifact artifact : privateHeaders) {
    f.addPath(artifact.getRootRelativePath());
  }
  f.addInt(publicHeaders.size());
  for (  Artifact artifact : publicHeaders) {
    f.addPath(artifact.getRootRelativePath());
  }
  f.addInt(dependencies.size());
  for (  CppModuleMap dep : dependencies) {
    f.addPath(dep.getArtifact().getExecPath());
  }
  f.addInt(additionalExportedHeaders.size());
  for (  PathFragment path : additionalExportedHeaders) {
    f.addPath(path);
  }
  f.addPath(cppModuleMap.getArtifact().getExecPath());
  f.addString(cppModuleMap.getName());
  f.addBoolean(moduleMapHomeIsCwd);
  f.addBoolean(compiledModule);
  f.addBoolean(generateSubmodules);
  f.addBoolean(externDependencies);
  return f.hexDigestAndReset();
}","@Override protected String computeKey(){
  Fingerprint f=new Fingerprint();
  f.addString(GUID);
  f.addInt(privateHeaders.size());
  for (  Artifact artifact : privateHeaders) {
    f.addPath(artifact.getExecPath());
  }
  f.addInt(publicHeaders.size());
  for (  Artifact artifact : publicHeaders) {
    f.addPath(artifact.getExecPath());
  }
  f.addInt(dependencies.size());
  for (  CppModuleMap dep : dependencies) {
    f.addPath(dep.getArtifact().getExecPath());
  }
  f.addInt(additionalExportedHeaders.size());
  for (  PathFragment path : additionalExportedHeaders) {
    f.addPath(path);
  }
  f.addPath(cppModuleMap.getArtifact().getExecPath());
  f.addString(cppModuleMap.getName());
  f.addBoolean(moduleMapHomeIsCwd);
  f.addBoolean(compiledModule);
  f.addBoolean(generateSubmodules);
  f.addBoolean(externDependencies);
  return f.hexDigestAndReset();
}",0.5683371298405467
110902,"private void runFindAllRules(String pattern) throws Exception {
  assertThat(parseList(pattern)).containsExactlyElementsIn(Sets.union(rulesBeneathFoo,rulesBeneathOtherrules));
  assertNoEvents();
  eventCollector.clear();
}","private void runFindAllRules(String pattern) throws Exception {
  assertThat(parseList(pattern)).containsExactlyElementsIn(ImmutableSet.builder().addAll(rulesBeneathFoo).addAll(rulesBeneathOtherrules).addAll(rulesInTopLevelPackage).build());
  assertNoEvents();
  eventCollector.clear();
}",0.83984375
110903,"private void runFindAllTargets(String pattern) throws Exception {
  assertThat(parseList(pattern)).containsExactlyElementsIn(Sets.union(targetsBeneathFoo,targetsInOtherrules));
  assertNoEvents();
  eventCollector.clear();
}","private void runFindAllTargets(String pattern) throws Exception {
  assertThat(parseList(pattern)).containsExactlyElementsIn(ImmutableSet.builder().addAll(targetsBeneathFoo).addAll(targetsInOtherrules).addAll(targetsInTopLevelPackage).build());
  assertNoEvents();
  eventCollector.clear();
}",0.8372093023255814
110904,"@Test public void testFindAllRulesRecursivelyWithExperimental() throws Exception {
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  assertThat(parseList(""String_Node_Str"")).containsExactlyElementsIn(Sets.union(rulesBeneathFoo,rulesBeneathOtherrules));
  assertNoEvents();
}","@Test public void testFindAllRulesRecursivelyWithExperimental() throws Exception {
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  assertThat(parseList(""String_Node_Str"")).containsExactlyElementsIn(ImmutableSet.builder().addAll(rulesBeneathFoo).addAll(rulesBeneathOtherrules).addAll(rulesInTopLevelPackage).build());
  assertNoEvents();
}",0.8589743589743589
110905,"@Before public final void createFiles() throws Exception {
  boolean hasImplicitCcOutputs=ruleClassProvider.getRuleClassMap().get(""String_Node_Str"").getImplicitOutputsFunction() != ImplicitOutputsFunction.NONE;
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  Path foo=scratch.dir(""String_Node_Str"");
  fooOffset=foo.relativeTo(rootDirectory);
  rulesBeneathFoo=labels(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  rulesBeneathFooBar=labels(""String_Node_Str"",""String_Node_Str"");
  rulesBeneathOtherrules=labels(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  rulesInFoo=labels(""String_Node_Str"");
  rulesInFooBar=labels(""String_Node_Str"",""String_Node_Str"");
  rulesInOtherrules=rulesBeneathOtherrules;
  targetsInFoo=labels(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  if (hasImplicitCcOutputs) {
    targetsInFoo.addAll(labels(""String_Node_Str"",""String_Node_Str""));
  }
  targetsInFooBar=labels(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  if (hasImplicitCcOutputs) {
    targetsInFooBar.addAll(labels(""String_Node_Str"",""String_Node_Str""));
  }
  targetsBeneathFoo=Sets.newHashSet();
  targetsBeneathFoo.addAll(targetsInFoo);
  targetsBeneathFoo.addAll(targetsInFooBar);
  targetsInOtherrules=labels(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  if (hasImplicitCcOutputs) {
    targetsInOtherrules.addAll(labels(""String_Node_Str""));
  }
}","@Before public final void createFiles() throws Exception {
  boolean hasImplicitCcOutputs=ruleClassProvider.getRuleClassMap().get(""String_Node_Str"").getImplicitOutputsFunction() != ImplicitOutputsFunction.NONE;
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  Path foo=scratch.dir(""String_Node_Str"");
  fooOffset=foo.relativeTo(rootDirectory);
  rulesBeneathFoo=labels(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  rulesBeneathFooBar=labels(""String_Node_Str"",""String_Node_Str"");
  rulesBeneathOtherrules=labels(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  rulesInTopLevelPackage=labels(""String_Node_Str"");
  rulesInFoo=labels(""String_Node_Str"");
  rulesInFooBar=labels(""String_Node_Str"",""String_Node_Str"");
  rulesInOtherrules=rulesBeneathOtherrules;
  targetsInTopLevelPackage=labels(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  targetsInFoo=labels(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  if (hasImplicitCcOutputs) {
    targetsInFoo.addAll(labels(""String_Node_Str"",""String_Node_Str""));
  }
  targetsInFooBar=labels(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  if (hasImplicitCcOutputs) {
    targetsInFooBar.addAll(labels(""String_Node_Str"",""String_Node_Str""));
  }
  targetsBeneathFoo=Sets.newHashSet();
  targetsBeneathFoo.addAll(targetsInFoo);
  targetsBeneathFoo.addAll(targetsInFooBar);
  targetsInOtherrules=labels(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  if (hasImplicitCcOutputs) {
    targetsInOtherrules.addAll(labels(""String_Node_Str""));
  }
}",0.9425861208187718
110906,"@Override public void getTargetsMatchingPattern(QueryExpression owner,String pattern,Callback<Target> callback) throws QueryException {
  if (precomputedPatterns.containsKey(pattern)) {
    Set<Label> labels=precomputedPatterns.get(pattern);
    if (labels != null) {
      try {
        makeTargetsFromLabels(labels,callback);
      }
 catch (      InterruptedException e) {
        throw new QueryException(owner,e.getMessage());
      }
    }
 else {
      TargetParsingException exception;
      try {
        exception=(TargetParsingException)Preconditions.checkNotNull(graph.getException(TargetPatternValue.key(pattern,TargetPatternEvaluator.DEFAULT_FILTERING_POLICY,parserPrefix)),pattern);
      }
 catch (      TargetParsingException e) {
        exception=e;
      }
      reportBuildFileError(owner,exception.getMessage());
    }
  }
 else {
    try {
      TargetPatternKey targetPatternKey=((TargetPatternKey)TargetPatternValue.key(pattern,TargetPatternEvaluator.DEFAULT_FILTERING_POLICY,parserPrefix).argument());
      GraphBackedRecursivePackageProvider provider=new GraphBackedRecursivePackageProvider(graph,universeTargetPatternKeys,pkgPath);
      ExecutorService threadPool=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(),new ThreadFactoryBuilder().setNameFormat(""String_Node_Str"").build());
      RecursivePackageProviderBackedTargetPatternResolver resolver=new RecursivePackageProviderBackedTargetPatternResolver(provider,eventHandler,targetPatternKey.getPolicy(),threadPool);
      TargetPattern parsedPattern=targetPatternKey.getParsedPattern();
      FilteringBatchingUniquifyingCallback wrapper=new FilteringBatchingUniquifyingCallback(callback);
      parsedPattern.eval(resolver,wrapper,QueryException.class);
      wrapper.processLastPending();
    }
 catch (    TargetParsingException e) {
      reportBuildFileError(owner,e.getMessage());
    }
catch (    InterruptedException e) {
      throw new QueryException(owner,e.getMessage());
    }
  }
}","@Override public void getTargetsMatchingPattern(QueryExpression owner,String pattern,Callback<Target> callback) throws QueryException {
  if (precomputedPatterns.containsKey(pattern)) {
    Set<Label> labels=precomputedPatterns.get(pattern);
    if (labels != null) {
      try {
        makeTargetsFromLabels(labels,callback);
      }
 catch (      InterruptedException e) {
        throw new QueryException(owner,e.getMessage());
      }
    }
 else {
      TargetParsingException exception;
      try {
        exception=(TargetParsingException)Preconditions.checkNotNull(graph.getException(TargetPatternValue.key(pattern,TargetPatternEvaluator.DEFAULT_FILTERING_POLICY,parserPrefix)),pattern);
      }
 catch (      TargetParsingException e) {
        exception=e;
      }
      reportBuildFileError(owner,exception.getMessage());
    }
  }
 else {
    try {
      TargetPatternKey targetPatternKey=((TargetPatternKey)TargetPatternValue.key(pattern,TargetPatternEvaluator.DEFAULT_FILTERING_POLICY,parserPrefix).argument());
      GraphBackedRecursivePackageProvider provider=new GraphBackedRecursivePackageProvider(graph,universeTargetPatternKeys,pkgPath);
      ExecutorService threadPool=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(),new ThreadFactoryBuilder().setNameFormat(""String_Node_Str"").build());
      RecursivePackageProviderBackedTargetPatternResolver resolver=new RecursivePackageProviderBackedTargetPatternResolver(provider,eventHandler,targetPatternKey.getPolicy(),threadPool);
      TargetPattern parsedPattern=targetPatternKey.getParsedPattern();
      ImmutableSet<PathFragment> subdirectoriesToExclude=targetPatternKey.getAllSubdirectoriesToExclude(blacklistPatterns);
      FilteringBatchingUniquifyingCallback wrapper=new FilteringBatchingUniquifyingCallback(callback);
      parsedPattern.eval(resolver,subdirectoriesToExclude,wrapper,QueryException.class);
      wrapper.processLastPending();
    }
 catch (    TargetParsingException e) {
      reportBuildFileError(owner,e.getMessage());
    }
catch (    InterruptedException e) {
      throw new QueryException(owner,e.getMessage());
    }
  }
}",0.964354527938343
110907,"private void init() throws InterruptedException {
  EvaluationResult<SkyValue> result;
  try (AutoProfiler p=AutoProfiler.logged(""String_Node_Str"",LOG)){
    result=graphFactory.prepareAndGet(universeScope,parserPrefix,loadingPhaseThreads,eventHandler);
  }
   graph=result.getWalkableGraph();
  SkyKey universeKey=graphFactory.getUniverseKey(universeScope,parserPrefix);
  universeTargetPatternKeys=PrepareDepsOfPatternsFunction.getTargetPatternKeys(PrepareDepsOfPatternsFunction.getSkyKeys(universeKey,eventHandler));
  Collection<SkyValue> values=result.values();
  if (!values.isEmpty()) {
    Preconditions.checkState(values.size() == 1,""String_Node_Str"" + ""String_Node_Str"",universeScope,values.size());
    Preconditions.checkNotNull(result.get(universeKey),result);
  }
 else {
    boolean foundCycle=!Iterables.isEmpty(result.getError().getCycleInfo());
    Preconditions.checkState(foundCycle,""String_Node_Str"",universeScope,result.getError());
  }
}","private void init() throws InterruptedException {
  EvaluationResult<SkyValue> result;
  try (AutoProfiler p=AutoProfiler.logged(""String_Node_Str"",LOG)){
    result=graphFactory.prepareAndGet(universeScope,parserPrefix,loadingPhaseThreads,eventHandler);
  }
   graph=result.getWalkableGraph();
  blacklistPatterns=Preconditions.checkNotNull((BlacklistedPackagePrefixesValue)graph.getValue(BlacklistedPackagePrefixesValue.key())).getPatterns();
  SkyKey universeKey=graphFactory.getUniverseKey(universeScope,parserPrefix);
  universeTargetPatternKeys=PrepareDepsOfPatternsFunction.getTargetPatternKeys(PrepareDepsOfPatternsFunction.getSkyKeys(universeKey,eventHandler));
  Collection<SkyValue> values=result.values();
  if (!values.isEmpty()) {
    Preconditions.checkState(values.size() == 1,""String_Node_Str"" + ""String_Node_Str"",universeScope,values.size());
    Preconditions.checkNotNull(result.get(universeKey),result);
  }
 else {
    boolean foundCycle=!Iterables.isEmpty(result.getError().getCycleInfo());
    Preconditions.checkState(foundCycle,""String_Node_Str"",universeScope,result.getError());
  }
}",0.927536231884058
110908,"@Nullable @Override public SkyValue compute(SkyKey key,Environment env) throws SkyFunctionException, InterruptedException {
  TargetPatternValue.TargetPatternKey patternKey=((TargetPatternValue.TargetPatternKey)key.argument());
  Preconditions.checkState(patternKey.getPolicy().equals(FilteringPolicies.NO_FILTER),patternKey.getPolicy());
  try {
    TargetPattern parsedPattern=patternKey.getParsedPattern();
    DepsOfPatternPreparer preparer=new DepsOfPatternPreparer(env,pkgPath.get());
    ImmutableSet<PathFragment> excludedSubdirectories=patternKey.getExcludedSubdirectories();
    parsedPattern.eval(preparer,excludedSubdirectories,NullCallback.<Void>instance(),RuntimeException.class);
  }
 catch (  TargetParsingException e) {
    throw new PrepareDepsOfPatternFunctionException(e);
  }
catch (  MissingDepException e) {
    return null;
  }
  return PrepareDepsOfPatternValue.INSTANCE;
}","@Nullable @Override public SkyValue compute(SkyKey key,Environment env) throws SkyFunctionException, InterruptedException {
  TargetPatternValue.TargetPatternKey patternKey=((TargetPatternValue.TargetPatternKey)key.argument());
  Preconditions.checkState(patternKey.getPolicy().equals(FilteringPolicies.NO_FILTER),patternKey.getPolicy());
  TargetPattern parsedPattern=patternKey.getParsedPattern();
  BlacklistedPackagePrefixesValue blacklist=(BlacklistedPackagePrefixesValue)env.getValue(BlacklistedPackagePrefixesValue.key());
  if (blacklist == null) {
    return null;
  }
  ImmutableSet<PathFragment> subdirectoriesToExclude=patternKey.getAllSubdirectoriesToExclude(blacklist.getPatterns());
  DepsOfPatternPreparer preparer=new DepsOfPatternPreparer(env,pkgPath.get());
  try {
    parsedPattern.eval(preparer,subdirectoriesToExclude,NullCallback.<Void>instance(),RuntimeException.class);
  }
 catch (  TargetParsingException e) {
    throw new PrepareDepsOfPatternFunctionException(e);
  }
catch (  MissingDepException e) {
    return null;
  }
  return PrepareDepsOfPatternValue.INSTANCE;
}",0.6690035052578869
110909,"/** 
 * Looks in the directory specified by   {@code recursivePkgKey} for a package, does some workas specified by  {@link Visitor} if such a package exists, then recursively does work in eachnon-excluded subdirectory as specified by  {@link #getSkyKeyForSubdirectory}, and finally aggregates the   {@link Visitor} value along with values from each subdirectory as specifiedby  {@link #aggregateWithSubdirectorySkyValues}, and returns that aggregation. <p>Returns null if   {@code env.valuesMissing()} is true, checked after each call to one of{@link RecursiveDirectoryTraversalFunction}'s abstract methods that were given   {@code env}. (And after each of   {@code visitDirectory}'s own uses of   {@code env}, of course.)
 */
TReturn visitDirectory(RecursivePkgKey recursivePkgKey,Environment env){
  RootedPath rootedPath=recursivePkgKey.getRootedPath();
  BlacklistedPackagePrefixesValue blacklist=(BlacklistedPackagePrefixesValue)env.getValue(BlacklistedPackagePrefixesValue.key());
  if (blacklist == null) {
    return null;
  }
  Set<PathFragment> excludedPaths=Sets.union(recursivePkgKey.getExcludedPaths(),blacklist.getPatterns());
  Path root=rootedPath.getRoot();
  PathFragment rootRelativePath=rootedPath.getRelativePath();
  SkyKey fileKey=FileValue.key(rootedPath);
  FileValue fileValue;
  try {
    fileValue=(FileValue)env.getValueOrThrow(fileKey,InconsistentFilesystemException.class,FileSymlinkException.class,IOException.class);
  }
 catch (  InconsistentFilesystemException|FileSymlinkException|IOException e) {
    return reportErrorAndReturn(""String_Node_Str"",e,rootRelativePath,env.getListener());
  }
  if (fileValue == null) {
    return null;
  }
  if (!fileValue.isDirectory()) {
    return getEmptyReturn();
  }
  PackageIdentifier packageId=PackageIdentifier.create(recursivePkgKey.getRepository(),rootRelativePath);
  if ((packageId.getRepository().isDefault() || packageId.getRepository().isMain()) && fileValue.isSymlink() && fileValue.getUnresolvedLinkTarget().startsWith(directories.getOutputBase().asFragment())) {
    return getEmptyReturn();
  }
  SkyKey pkgLookupKey=PackageLookupValue.key(packageId);
  SkyKey dirListingKey=DirectoryListingValue.key(rootedPath);
  Map<SkyKey,ValueOrException4<NoSuchPackageException,InconsistentFilesystemException,FileSymlinkException,IOException>> pkgLookupAndDirectoryListingDeps=env.getValuesOrThrow(ImmutableList.of(pkgLookupKey,dirListingKey),NoSuchPackageException.class,InconsistentFilesystemException.class,FileSymlinkException.class,IOException.class);
  if (env.valuesMissing()) {
    return null;
  }
  PackageLookupValue pkgLookupValue;
  try {
    pkgLookupValue=(PackageLookupValue)Preconditions.checkNotNull(pkgLookupAndDirectoryListingDeps.get(pkgLookupKey).get(),""String_Node_Str"",recursivePkgKey,pkgLookupKey);
  }
 catch (  NoSuchPackageException|InconsistentFilesystemException e) {
    return reportErrorAndReturn(""String_Node_Str"",e,rootRelativePath,env.getListener());
  }
catch (  IOException|FileSymlinkException e) {
    throw new IllegalStateException(e);
  }
  TVisitor visitor=getInitialVisitor();
  DirectoryListingValue dirListingValue;
  try {
    dirListingValue=(DirectoryListingValue)Preconditions.checkNotNull(pkgLookupAndDirectoryListingDeps.get(dirListingKey).get(),""String_Node_Str"",recursivePkgKey,dirListingKey);
  }
 catch (  InconsistentFilesystemException|IOException e) {
    return reportErrorAndReturn(""String_Node_Str"",e,rootRelativePath,env.getListener());
  }
catch (  FileSymlinkException e) {
    throw new IllegalStateException(""String_Node_Str"" + rootedPath + ""String_Node_Str"");
  }
catch (  NoSuchPackageException e) {
    throw new IllegalStateException(e);
  }
  boolean followSymlinks=shouldFollowSymlinksWhenTraversing(dirListingValue.getDirents());
  List<SkyKey> childDeps=new ArrayList<>();
  for (  Dirent dirent : dirListingValue.getDirents()) {
    Type type=dirent.getType();
    if (type != Type.DIRECTORY && (type != Type.SYMLINK || (type == Type.SYMLINK && !followSymlinks))) {
      continue;
    }
    String basename=dirent.getName();
    if (rootRelativePath.equals(PathFragment.EMPTY_FRAGMENT) && PathPackageLocator.DEFAULT_TOP_LEVEL_EXCLUDES.contains(basename)) {
      continue;
    }
    PathFragment subdirectory=rootRelativePath.getRelative(basename);
    if (excludedPaths.contains(subdirectory)) {
      continue;
    }
    ImmutableSet<PathFragment> excludedSubdirectoriesBeneathThisSubdirectory=PathFragment.filterPathsStartingWith(excludedPaths,subdirectory);
    RootedPath subdirectoryRootedPath=RootedPath.toRootedPath(root,subdirectory);
    childDeps.add(getSkyKeyForSubdirectory(recursivePkgKey.getRepository(),subdirectoryRootedPath,excludedSubdirectoriesBeneathThisSubdirectory));
  }
  Map<SkyKey,SkyValue> subdirectorySkyValues;
  if (pkgLookupValue.packageExists() && pkgLookupValue.getRoot().equals(root)) {
    SkyKey packageKey=PackageValue.key(packageId);
    Map<SkyKey,ValueOrException<NoSuchPackageException>> dependentSkyValues=env.getValuesOrThrow(Iterables.concat(childDeps,ImmutableList.of(packageKey)),NoSuchPackageException.class);
    if (env.valuesMissing()) {
      return null;
    }
    Package pkg=null;
    try {
      PackageValue pkgValue=(PackageValue)dependentSkyValues.get(packageKey).get();
      if (pkgValue == null) {
        return null;
      }
      pkg=pkgValue.getPackage();
      if (pkg.containsErrors()) {
        env.getListener().handle(Event.error(""String_Node_Str"" + rootRelativePath.getPathString()));
      }
    }
 catch (    NoSuchPackageException e) {
      env.getListener().handle(Event.error(""String_Node_Str"" + rootRelativePath.getPathString()));
    }
    if (pkg != null) {
      visitor.visitPackageValue(pkg,env);
      if (env.valuesMissing()) {
        return null;
      }
    }
    subdirectorySkyValues=Maps.transformValues(Maps.filterKeys(dependentSkyValues,Predicates.not(Predicates.equalTo(packageKey))),GET_SKYVALUE);
  }
 else {
    subdirectorySkyValues=env.getValues(childDeps);
  }
  if (env.valuesMissing()) {
    return null;
  }
  return aggregateWithSubdirectorySkyValues(visitor,subdirectorySkyValues);
}","/** 
 * Looks in the directory specified by   {@code recursivePkgKey} for a package, does some workas specified by  {@link Visitor} if such a package exists, then recursively does work in eachnon-excluded subdirectory as specified by  {@link #getSkyKeyForSubdirectory}, and finally aggregates the   {@link Visitor} value along with values from each subdirectory as specifiedby  {@link #aggregateWithSubdirectorySkyValues}, and returns that aggregation. <p>Returns null if   {@code env.valuesMissing()} is true, checked after each call to one of{@link RecursiveDirectoryTraversalFunction}'s abstract methods that were given   {@code env}. (And after each of   {@code visitDirectory}'s own uses of   {@code env}, of course.)
 */
TReturn visitDirectory(RecursivePkgKey recursivePkgKey,Environment env){
  RootedPath rootedPath=recursivePkgKey.getRootedPath();
  ImmutableSet<PathFragment> excludedPaths=recursivePkgKey.getExcludedPaths();
  Path root=rootedPath.getRoot();
  PathFragment rootRelativePath=rootedPath.getRelativePath();
  SkyKey fileKey=FileValue.key(rootedPath);
  FileValue fileValue;
  try {
    fileValue=(FileValue)env.getValueOrThrow(fileKey,InconsistentFilesystemException.class,FileSymlinkException.class,IOException.class);
  }
 catch (  InconsistentFilesystemException|FileSymlinkException|IOException e) {
    return reportErrorAndReturn(""String_Node_Str"",e,rootRelativePath,env.getListener());
  }
  if (fileValue == null) {
    return null;
  }
  if (!fileValue.isDirectory()) {
    return getEmptyReturn();
  }
  PackageIdentifier packageId=PackageIdentifier.create(recursivePkgKey.getRepository(),rootRelativePath);
  if ((packageId.getRepository().isDefault() || packageId.getRepository().isMain()) && fileValue.isSymlink() && fileValue.getUnresolvedLinkTarget().startsWith(directories.getOutputBase().asFragment())) {
    return getEmptyReturn();
  }
  SkyKey pkgLookupKey=PackageLookupValue.key(packageId);
  SkyKey dirListingKey=DirectoryListingValue.key(rootedPath);
  Map<SkyKey,ValueOrException4<NoSuchPackageException,InconsistentFilesystemException,FileSymlinkException,IOException>> pkgLookupAndDirectoryListingDeps=env.getValuesOrThrow(ImmutableList.of(pkgLookupKey,dirListingKey),NoSuchPackageException.class,InconsistentFilesystemException.class,FileSymlinkException.class,IOException.class);
  if (env.valuesMissing()) {
    return null;
  }
  PackageLookupValue pkgLookupValue;
  try {
    pkgLookupValue=(PackageLookupValue)Preconditions.checkNotNull(pkgLookupAndDirectoryListingDeps.get(pkgLookupKey).get(),""String_Node_Str"",recursivePkgKey,pkgLookupKey);
  }
 catch (  NoSuchPackageException|InconsistentFilesystemException e) {
    return reportErrorAndReturn(""String_Node_Str"",e,rootRelativePath,env.getListener());
  }
catch (  IOException|FileSymlinkException e) {
    throw new IllegalStateException(e);
  }
  TVisitor visitor=getInitialVisitor();
  DirectoryListingValue dirListingValue;
  try {
    dirListingValue=(DirectoryListingValue)Preconditions.checkNotNull(pkgLookupAndDirectoryListingDeps.get(dirListingKey).get(),""String_Node_Str"",recursivePkgKey,dirListingKey);
  }
 catch (  InconsistentFilesystemException|IOException e) {
    return reportErrorAndReturn(""String_Node_Str"",e,rootRelativePath,env.getListener());
  }
catch (  FileSymlinkException e) {
    throw new IllegalStateException(""String_Node_Str"" + rootedPath + ""String_Node_Str"");
  }
catch (  NoSuchPackageException e) {
    throw new IllegalStateException(e);
  }
  boolean followSymlinks=shouldFollowSymlinksWhenTraversing(dirListingValue.getDirents());
  List<SkyKey> childDeps=new ArrayList<>();
  for (  Dirent dirent : dirListingValue.getDirents()) {
    Type type=dirent.getType();
    if (type != Type.DIRECTORY && (type != Type.SYMLINK || (type == Type.SYMLINK && !followSymlinks))) {
      continue;
    }
    String basename=dirent.getName();
    if (rootRelativePath.equals(PathFragment.EMPTY_FRAGMENT) && PathPackageLocator.DEFAULT_TOP_LEVEL_EXCLUDES.contains(basename)) {
      continue;
    }
    PathFragment subdirectory=rootRelativePath.getRelative(basename);
    if (excludedPaths.contains(subdirectory)) {
      continue;
    }
    ImmutableSet<PathFragment> excludedSubdirectoriesBeneathThisSubdirectory=PathFragment.filterPathsStartingWith(excludedPaths,subdirectory);
    RootedPath subdirectoryRootedPath=RootedPath.toRootedPath(root,subdirectory);
    childDeps.add(getSkyKeyForSubdirectory(recursivePkgKey.getRepository(),subdirectoryRootedPath,excludedSubdirectoriesBeneathThisSubdirectory));
  }
  Map<SkyKey,SkyValue> subdirectorySkyValues;
  if (pkgLookupValue.packageExists() && pkgLookupValue.getRoot().equals(root)) {
    SkyKey packageKey=PackageValue.key(packageId);
    Map<SkyKey,ValueOrException<NoSuchPackageException>> dependentSkyValues=env.getValuesOrThrow(Iterables.concat(childDeps,ImmutableList.of(packageKey)),NoSuchPackageException.class);
    if (env.valuesMissing()) {
      return null;
    }
    Package pkg=null;
    try {
      PackageValue pkgValue=(PackageValue)dependentSkyValues.get(packageKey).get();
      if (pkgValue == null) {
        return null;
      }
      pkg=pkgValue.getPackage();
      if (pkg.containsErrors()) {
        env.getListener().handle(Event.error(""String_Node_Str"" + rootRelativePath.getPathString()));
      }
    }
 catch (    NoSuchPackageException e) {
      env.getListener().handle(Event.error(""String_Node_Str"" + rootRelativePath.getPathString()));
    }
    if (pkg != null) {
      visitor.visitPackageValue(pkg,env);
      if (env.valuesMissing()) {
        return null;
      }
    }
    subdirectorySkyValues=Maps.transformValues(Maps.filterKeys(dependentSkyValues,Predicates.not(Predicates.equalTo(packageKey))),GET_SKYVALUE);
  }
 else {
    subdirectorySkyValues=env.getValues(childDeps);
  }
  if (env.valuesMissing()) {
    return null;
  }
  return aggregateWithSubdirectorySkyValues(visitor,subdirectorySkyValues);
}",0.9765941609461584
110910,"private SequencedSkyframeExecutor(EvaluatorSupplier evaluatorSupplier,PackageFactory pkgFactory,BlazeDirectories directories,BinTools binTools,Factory workspaceStatusActionFactory,ImmutableList<BuildInfoFactory> buildInfoFactories,Iterable<? extends DiffAwareness.Factory> diffAwarenessFactories,Predicate<PathFragment> allowedMissingInputs,Preprocessor.Factory.Supplier preprocessorFactorySupplier,ImmutableMap<SkyFunctionName,SkyFunction> extraSkyFunctions,ImmutableList<PrecomputedValue.Injected> extraPrecomputedValues,Iterable<SkyValueDirtinessChecker> customDirtinessCheckers){
  super(evaluatorSupplier,pkgFactory,directories,binTools,workspaceStatusActionFactory,buildInfoFactories,allowedMissingInputs,preprocessorFactorySupplier,extraSkyFunctions,extraPrecomputedValues,false);
  this.diffAwarenessManager=new DiffAwarenessManager(diffAwarenessFactories);
  this.customDirtinessCheckers=customDirtinessCheckers;
}","private SequencedSkyframeExecutor(EvaluatorSupplier evaluatorSupplier,PackageFactory pkgFactory,BlazeDirectories directories,BinTools binTools,Factory workspaceStatusActionFactory,ImmutableList<BuildInfoFactory> buildInfoFactories,Iterable<? extends DiffAwareness.Factory> diffAwarenessFactories,Predicate<PathFragment> allowedMissingInputs,Preprocessor.Factory.Supplier preprocessorFactorySupplier,ImmutableMap<SkyFunctionName,SkyFunction> extraSkyFunctions,ImmutableList<PrecomputedValue.Injected> extraPrecomputedValues,Iterable<SkyValueDirtinessChecker> customDirtinessCheckers,PathFragment blacklistedPackagePrefixesFile){
  super(evaluatorSupplier,pkgFactory,directories,binTools,workspaceStatusActionFactory,buildInfoFactories,allowedMissingInputs,preprocessorFactorySupplier,extraSkyFunctions,extraPrecomputedValues,false,blacklistedPackagePrefixesFile);
  this.diffAwarenessManager=new DiffAwarenessManager(diffAwarenessFactories);
  this.customDirtinessCheckers=customDirtinessCheckers;
}",0.960957834461218
110911,"@VisibleForTesting public static SequencedSkyframeExecutor create(PackageFactory pkgFactory,BlazeDirectories directories,BinTools binTools,WorkspaceStatusAction.Factory workspaceStatusActionFactory,ImmutableList<BuildInfoFactory> buildInfoFactories,Iterable<? extends DiffAwareness.Factory> diffAwarenessFactories){
  return create(pkgFactory,directories,binTools,workspaceStatusActionFactory,buildInfoFactories,diffAwarenessFactories,Predicates.<PathFragment>alwaysFalse(),Preprocessor.Factory.Supplier.NullSupplier.INSTANCE,ImmutableMap.<SkyFunctionName,SkyFunction>of(),ImmutableList.<PrecomputedValue.Injected>of(),ImmutableList.<SkyValueDirtinessChecker>of());
}","@VisibleForTesting public static SequencedSkyframeExecutor create(PackageFactory pkgFactory,BlazeDirectories directories,BinTools binTools,WorkspaceStatusAction.Factory workspaceStatusActionFactory,ImmutableList<BuildInfoFactory> buildInfoFactories,Iterable<? extends DiffAwareness.Factory> diffAwarenessFactories,PathFragment blacklistedPackagePrefixesFile){
  return create(pkgFactory,directories,binTools,workspaceStatusActionFactory,buildInfoFactories,diffAwarenessFactories,Predicates.<PathFragment>alwaysFalse(),Preprocessor.Factory.Supplier.NullSupplier.INSTANCE,ImmutableMap.<SkyFunctionName,SkyFunction>of(),ImmutableList.<PrecomputedValue.Injected>of(),ImmutableList.<SkyValueDirtinessChecker>of(),blacklistedPackagePrefixesFile);
}",0.9467707594038324
110912,"protected SkyframeExecutor(EvaluatorSupplier evaluatorSupplier,PackageFactory pkgFactory,BlazeDirectories directories,BinTools binTools,Factory workspaceStatusActionFactory,ImmutableList<BuildInfoFactory> buildInfoFactories,Predicate<PathFragment> allowedMissingInputs,Preprocessor.Factory.Supplier preprocessorFactorySupplier,ImmutableMap<SkyFunctionName,SkyFunction> extraSkyFunctions,ImmutableList<PrecomputedValue.Injected> extraPrecomputedValues,boolean errorOnExternalFiles){
  this.evaluatorSupplier=evaluatorSupplier;
  this.pkgFactory=pkgFactory;
  this.pkgFactory.setSyscalls(syscalls);
  this.workspaceStatusActionFactory=workspaceStatusActionFactory;
  this.packageManager=new SkyframePackageManager(new SkyframePackageLoader(),new SkyframeTransitivePackageLoader(),syscalls,cyclesReporter,pkgLocator,numPackagesLoaded,this);
  this.resourceManager=ResourceManager.instance();
  this.skyframeActionExecutor=new SkyframeActionExecutor(resourceManager,eventBus,statusReporterRef);
  this.directories=Preconditions.checkNotNull(directories);
  this.buildInfoFactories=buildInfoFactories;
  this.allowedMissingInputs=allowedMissingInputs;
  this.preprocessorFactorySupplier=preprocessorFactorySupplier;
  this.extraSkyFunctions=extraSkyFunctions;
  this.extraPrecomputedValues=extraPrecomputedValues;
  this.errorOnExternalFiles=errorOnExternalFiles;
  this.binTools=binTools;
  this.skyframeBuildView=new SkyframeBuildView(directories,this,binTools,(ConfiguredRuleClassProvider)pkgFactory.getRuleClassProvider());
  this.artifactFactory.set(skyframeBuildView.getArtifactFactory());
  this.externalFilesHelper=new ExternalFilesHelper(pkgLocator,this.errorOnExternalFiles);
}","protected SkyframeExecutor(EvaluatorSupplier evaluatorSupplier,PackageFactory pkgFactory,BlazeDirectories directories,BinTools binTools,Factory workspaceStatusActionFactory,ImmutableList<BuildInfoFactory> buildInfoFactories,Predicate<PathFragment> allowedMissingInputs,Preprocessor.Factory.Supplier preprocessorFactorySupplier,ImmutableMap<SkyFunctionName,SkyFunction> extraSkyFunctions,ImmutableList<PrecomputedValue.Injected> extraPrecomputedValues,boolean errorOnExternalFiles,PathFragment blacklistedPackagePrefixesFile){
  this.evaluatorSupplier=evaluatorSupplier;
  this.pkgFactory=pkgFactory;
  this.pkgFactory.setSyscalls(syscalls);
  this.workspaceStatusActionFactory=workspaceStatusActionFactory;
  this.packageManager=new SkyframePackageManager(new SkyframePackageLoader(),new SkyframeTransitivePackageLoader(),syscalls,cyclesReporter,pkgLocator,numPackagesLoaded,this);
  this.resourceManager=ResourceManager.instance();
  this.skyframeActionExecutor=new SkyframeActionExecutor(resourceManager,eventBus,statusReporterRef);
  this.directories=Preconditions.checkNotNull(directories);
  this.buildInfoFactories=buildInfoFactories;
  this.allowedMissingInputs=allowedMissingInputs;
  this.preprocessorFactorySupplier=preprocessorFactorySupplier;
  this.extraSkyFunctions=extraSkyFunctions;
  this.extraPrecomputedValues=extraPrecomputedValues;
  this.errorOnExternalFiles=errorOnExternalFiles;
  this.blacklistedPackagePrefixesFile=blacklistedPackagePrefixesFile;
  this.binTools=binTools;
  this.skyframeBuildView=new SkyframeBuildView(directories,this,binTools,(ConfiguredRuleClassProvider)pkgFactory.getRuleClassProvider());
  this.artifactFactory.set(skyframeBuildView.getArtifactFactory());
  this.externalFilesHelper=new ExternalFilesHelper(pkgLocator,this.errorOnExternalFiles);
}",0.9672225416906268
110913,"protected PathFragment getBlacklistedPackagePrefixesFile(){
  return PathFragment.EMPTY_FRAGMENT;
}","@VisibleForTesting public PathFragment getBlacklistedPackagePrefixesFile(){
  return blacklistedPackagePrefixesFile;
}",0.663594470046083
110914,"private void skipBlock(){
  int start=token.left;
  Token blockToken=token;
  syncTo(EnumSet.of(TokenKind.COLON,TokenKind.EOF));
  if (parsingMode != PYTHON) {
    String msg=ILLEGAL_BLOCK_KEYWORDS.containsKey(blockToken.kind) ? String.format(""String_Node_Str"",ILLEGAL_BLOCK_KEYWORDS.get(blockToken.kind)) : ""String_Node_Str"";
    reportError(lexer.createLocation(start,token.right),String.format(""String_Node_Str"",blockToken,msg));
  }
  expect(TokenKind.COLON);
  skipSuite();
}","private void skipBlock(){
  int start=token.left;
  Token blockToken=token;
  syncTo(EnumSet.of(TokenKind.COLON,TokenKind.EOF));
  if (blockToken.kind == TokenKind.ELSE && parsingMode == SKYLARK) {
    reportError(lexer.createLocation(blockToken.left,blockToken.right),""String_Node_Str"");
  }
 else   if (parsingMode != PYTHON) {
    String msg=ILLEGAL_BLOCK_KEYWORDS.containsKey(blockToken.kind) ? String.format(""String_Node_Str"",ILLEGAL_BLOCK_KEYWORDS.get(blockToken.kind)) : ""String_Node_Str"";
    reportError(lexer.createLocation(start,token.right),String.format(""String_Node_Str"",blockToken,msg));
  }
  expect(TokenKind.COLON);
  skipSuite();
}",0.8495575221238938
110915,"@Override protected Map<SkyKey,ValueOrUntypedException> getValueOrUntypedExceptions(Set<SkyKey> depKeys){
  checkActive();
  Preconditions.checkState(!depKeys.contains(ErrorTransienceValue.KEY),""String_Node_Str"",skyKey);
  Map<SkyKey,SkyValue> values=getValuesMaybeFromError(depKeys,bubbleErrorInfo);
  for (  Map.Entry<SkyKey,SkyValue> depEntry : values.entrySet()) {
    SkyKey depKey=depEntry.getKey();
    SkyValue depValue=depEntry.getValue();
    if (depValue == NULL_MARKER) {
      if (directDeps.containsKey(depKey)) {
        throw new IllegalStateException(""String_Node_Str"" + depKey + ""String_Node_Str""+ skyKey+ ""String_Node_Str""+ graph.get(depKey)+ ""String_Node_Str""+ graph.get(skyKey));
      }
      valuesMissing=true;
      addDep(depKey);
      continue;
    }
    ErrorInfo errorInfo=ValueWithMetadata.getMaybeErrorInfo(depEntry.getValue());
    if (errorInfo != null) {
      childErrorInfos.add(errorInfo);
      if (bubbleErrorInfo != null) {
        Thread.currentThread().interrupt();
      }
      if ((!keepGoing && bubbleErrorInfo == null) || errorInfo.getException() == null) {
        valuesMissing=true;
        if (depErrorKey == null) {
          depErrorKey=depKey;
        }
      }
    }
    if (!directDeps.containsKey(depKey)) {
      if (bubbleErrorInfo == null) {
        addDep(depKey);
      }
      replayingNestedSetEventVisitor.visit(ValueWithMetadata.getEvents(depValue));
    }
  }
  return Maps.transformValues(values,new Function<SkyValue,ValueOrUntypedException>(){
    @Override public ValueOrUntypedException apply(    SkyValue maybeWrappedValue){
      if (maybeWrappedValue == NULL_MARKER) {
        return ValueOrExceptionUtils.ofNull();
      }
      SkyValue justValue=ValueWithMetadata.justValue(maybeWrappedValue);
      ErrorInfo errorInfo=ValueWithMetadata.getMaybeErrorInfo(maybeWrappedValue);
      if (justValue != null && (keepGoing || errorInfo == null)) {
        return ValueOrExceptionUtils.ofValueUntyped(justValue);
      }
      Preconditions.checkNotNull(errorInfo,""String_Node_Str"",skyKey,maybeWrappedValue);
      Exception exception=errorInfo.getException();
      if (!keepGoing && exception != null && bubbleErrorInfo == null) {
        return ValueOrExceptionUtils.ofNull();
      }
      if (exception != null) {
        return ValueOrExceptionUtils.ofExn(exception);
      }
      Preconditions.checkState(!Iterables.isEmpty(errorInfo.getCycleInfo()),""String_Node_Str"",skyKey,errorInfo,maybeWrappedValue);
      return ValueOrExceptionUtils.ofNull();
    }
  }
);
}","@Override protected Map<SkyKey,ValueOrUntypedException> getValueOrUntypedExceptions(Set<SkyKey> depKeys){
  checkActive();
  Preconditions.checkState(!depKeys.contains(ErrorTransienceValue.KEY),""String_Node_Str"",skyKey);
  Map<SkyKey,SkyValue> values=getValuesMaybeFromError(depKeys,bubbleErrorInfo);
  for (  Map.Entry<SkyKey,SkyValue> depEntry : values.entrySet()) {
    SkyKey depKey=depEntry.getKey();
    SkyValue depValue=depEntry.getValue();
    if (depValue == NULL_MARKER) {
      if (directDeps.containsKey(depKey)) {
        throw new IllegalStateException(""String_Node_Str"" + depKey + ""String_Node_Str""+ skyKey+ ""String_Node_Str""+ graph.get(depKey)+ ""String_Node_Str""+ graph.get(skyKey));
      }
      valuesMissing=true;
      addDep(depKey);
      continue;
    }
    ErrorInfo errorInfo=ValueWithMetadata.getMaybeErrorInfo(depEntry.getValue());
    if (errorInfo != null) {
      childErrorInfos.add(errorInfo);
      if (bubbleErrorInfo != null) {
        Thread.currentThread().interrupt();
      }
      if ((!keepGoing && bubbleErrorInfo == null) || errorInfo.getException() == null) {
        valuesMissing=true;
        if (!keepGoing && depErrorKey == null) {
          depErrorKey=depKey;
        }
      }
    }
    if (!directDeps.containsKey(depKey)) {
      if (bubbleErrorInfo == null) {
        addDep(depKey);
      }
      replayingNestedSetEventVisitor.visit(ValueWithMetadata.getEvents(depValue));
    }
  }
  return Maps.transformValues(values,new Function<SkyValue,ValueOrUntypedException>(){
    @Override public ValueOrUntypedException apply(    SkyValue maybeWrappedValue){
      if (maybeWrappedValue == NULL_MARKER) {
        return ValueOrExceptionUtils.ofNull();
      }
      SkyValue justValue=ValueWithMetadata.justValue(maybeWrappedValue);
      ErrorInfo errorInfo=ValueWithMetadata.getMaybeErrorInfo(maybeWrappedValue);
      if (justValue != null && (keepGoing || errorInfo == null)) {
        return ValueOrExceptionUtils.ofValueUntyped(justValue);
      }
      Preconditions.checkNotNull(errorInfo,""String_Node_Str"",skyKey,maybeWrappedValue);
      Exception exception=errorInfo.getException();
      if (!keepGoing && exception != null && bubbleErrorInfo == null) {
        return ValueOrExceptionUtils.ofNull();
      }
      if (exception != null) {
        return ValueOrExceptionUtils.ofExn(exception);
      }
      Preconditions.checkState(!Iterables.isEmpty(errorInfo.getCycleInfo()),""String_Node_Str"",skyKey,errorInfo,maybeWrappedValue);
      return ValueOrExceptionUtils.ofNull();
    }
  }
);
}",0.997257053291536
110916,"private static void logException(Throwable exception,List<String> args,String... values){
  String preamble=exception instanceof OutOfMemoryError ? ""String_Node_Str"" : ""String_Node_Str"";
  LoggingUtil.logToRemote(Level.SEVERE,preamble + Joiner.on(' ').join(args),exception,values);
}","private static void logException(Throwable exception,List<String> args,String... values){
  String preamble=Constants.PRODUCT_NAME + (exception instanceof OutOfMemoryError ? ""String_Node_Str"" : ""String_Node_Str"");
  LoggingUtil.logToRemote(Level.SEVERE,preamble + Joiner.on(' ').join(args),exception,values);
}",0.954468802698145
110917,"private static void printThrowableTo(OutErr outErr,Throwable e){
  PrintStream err=new PrintStream(outErr.getErrorStream());
  e.printStackTrace(err);
  err.flush();
  LOG.log(Level.SEVERE,""String_Node_Str"",e);
}","private static void printThrowableTo(OutErr outErr,Throwable e){
  PrintStream err=new PrintStream(outErr.getErrorStream());
  e.printStackTrace(err);
  err.flush();
  LOG.log(Level.SEVERE,Constants.PRODUCT_NAME + ""String_Node_Str"",e);
}",0.9443207126948776
110918,"private static void logCrash(Throwable throwable,String... args){
  BugReport.sendBugReport(throwable,Arrays.asList(args));
  BugReport.printBug(OutErr.SYSTEM_OUT_ERR,throwable);
  System.err.println(""String_Node_Str"");
  throwable.printStackTrace();
}","private static void logCrash(Throwable throwable,String... args){
  BugReport.sendBugReport(throwable,Arrays.asList(args));
  BugReport.printBug(OutErr.SYSTEM_OUT_ERR,throwable);
  System.err.println(Constants.PRODUCT_NAME + ""String_Node_Str"");
  throwable.printStackTrace();
}",0.9527410207939508
110919,"/** 
 * Print user-helpful information about the bug/crash to the output.
 * @param outErr where to write the output
 * @param e the exception thrown
 */
public static void printBug(OutErr outErr,Throwable e){
  if (e instanceof OutOfMemoryError) {
    outErr.printErr(e.getMessage() + ""String_Node_Str"" + ""String_Node_Str"");
  }
 else {
    printThrowableTo(outErr,e);
  }
}","/** 
 * Print user-helpful information about the bug/crash to the output.
 * @param outErr where to write the output
 * @param e the exception thrown
 */
public static void printBug(OutErr outErr,Throwable e){
  if (e instanceof OutOfMemoryError) {
    outErr.printErr(e.getMessage() + ""String_Node_Str"" + Constants.PRODUCT_NAME+ ""String_Node_Str"");
  }
 else {
    printThrowableTo(outErr,e);
  }
}",0.9689922480620154
110920,"@Override public void run(){
  NodeEntry state=Preconditions.checkNotNull(graph.get(skyKey),skyKey);
  Preconditions.checkState(state.isReady(),""String_Node_Str"",skyKey,state);
  if (maybeHandleDirtyNode(state) == DirtyOutcome.ALREADY_PROCESSED) {
    return;
  }
  Set<SkyKey> directDeps=state.getTemporaryDirectDeps();
  Preconditions.checkState(!directDeps.contains(ErrorTransienceValue.KEY),""String_Node_Str"",skyKey,state);
  SkyFunctionEnvironment env=new SkyFunctionEnvironment(skyKey,directDeps,visitor);
  SkyFunctionName functionName=skyKey.functionName();
  SkyFunction factory=skyFunctions.get(functionName);
  Preconditions.checkState(factory != null,""String_Node_Str"",functionName,state);
  SkyValue value=null;
  long startTime=BlazeClock.instance().nanoTime();
  try {
    value=factory.compute(skyKey,env);
  }
 catch (  final SkyFunctionException builderException) {
    ReifiedSkyFunctionException reifiedBuilderException=new ReifiedSkyFunctionException(builderException,skyKey);
    if (reifiedBuilderException.getRootCauseSkyKey().equals(skyKey)) {
      boolean shouldFailFast=!keepGoing || builderException.isCatastrophic();
      if (shouldFailFast) {
        if (!visitor.preventNewEvaluations()) {
          return;
        }
      }
      Map<SkyKey,NodeEntry> newlyRequestedDeps=graph.getBatch(env.newlyRequestedDeps);
      boolean isTransitivelyTransient=reifiedBuilderException.isTransient();
      for (      NodeEntry depEntry : Iterables.concat(env.directDeps.values(),newlyRequestedDeps.values())) {
        if (!isDoneForBuild(depEntry)) {
          continue;
        }
        ErrorInfo depError=depEntry.getErrorInfo();
        if (depError != null) {
          isTransitivelyTransient|=depError.isTransient();
        }
      }
      ErrorInfo errorInfo=ErrorInfo.fromException(reifiedBuilderException,isTransitivelyTransient);
      registerNewlyDiscoveredDepsForDoneEntry(skyKey,state,newlyRequestedDeps,env);
      env.setError(errorInfo,reifiedBuilderException.isTransient());
      env.commit(keepGoing);
      if (!shouldFailFast) {
        return;
      }
      throw SchedulerException.ofError(errorInfo,skyKey);
    }
  }
catch (  InterruptedException ie) {
    throw SchedulerException.ofInterruption(ie,skyKey);
  }
catch (  RuntimeException re) {
    String msg=prepareCrashMessage(skyKey,state.getInProgressReverseDeps());
    RuntimeException ex=new RuntimeException(msg,re);
    visitor.noteCrash(ex);
    throw ex;
  }
 finally {
    env.doneBuilding();
    long elapsedTimeNanos=BlazeClock.instance().nanoTime() - startTime;
    if (elapsedTimeNanos > 0) {
      if (progressReceiver != null) {
        progressReceiver.computed(skyKey,elapsedTimeNanos);
      }
      Profiler.instance().logSimpleTaskDuration(startTime,elapsedTimeNanos,ProfilerTask.SKYFUNCTION,skyKey);
    }
  }
  GroupedListHelper<SkyKey> newDirectDeps=env.newlyRequestedDeps;
  if (value != null) {
    Preconditions.checkState(!env.valuesMissing(),""String_Node_Str"" + ""String_Node_Str"",skyKey,newDirectDeps,state);
    env.setValue(value);
    registerNewlyDiscoveredDepsForDoneEntry(skyKey,state,graph.getBatch(env.newlyRequestedDeps),env);
    env.commit(true);
    return;
  }
  if (env.getDepErrorKey() != null) {
    Preconditions.checkState(!keepGoing,""String_Node_Str"",skyKey,state,env.getDepErrorKey());
    SkyKey childErrorKey=env.getDepErrorKey();
    NodeEntry childErrorEntry=Preconditions.checkNotNull(graph.get(childErrorKey),""String_Node_Str"",skyKey,state,childErrorKey);
    Preconditions.checkState(!state.getTemporaryDirectDeps().contains(childErrorKey),""String_Node_Str"",skyKey,state,childErrorKey,childErrorEntry);
    Preconditions.checkState(newDirectDeps.contains(childErrorKey),""String_Node_Str"",state,childErrorKey,newDirectDeps);
    state.addTemporaryDirectDeps(GroupedListHelper.create(ImmutableList.of(childErrorKey)));
    DependencyState childErrorState=childErrorEntry.addReverseDepAndCheckIfDone(skyKey);
    Preconditions.checkState(childErrorState == DependencyState.DONE,""String_Node_Str"",skyKey,state,childErrorKey,childErrorEntry);
    ErrorInfo childErrorInfo=Preconditions.checkNotNull(childErrorEntry.getErrorInfo());
    visitor.preventNewEvaluations();
    throw SchedulerException.ofError(childErrorInfo,childErrorKey);
  }
  state.addTemporaryDirectDeps(newDirectDeps);
  if (newDirectDeps.isEmpty()) {
    Preconditions.checkState(!env.childErrorInfos.isEmpty(),""String_Node_Str"",skyKey,state);
    Preconditions.checkState(keepGoing,""String_Node_Str"",skyKey,state,env.childErrorInfos);
    env.commit(true);
    return;
  }
  for (  Map.Entry<SkyKey,NodeEntry> e : graph.createIfAbsentBatch(newDirectDeps).entrySet()) {
    SkyKey newDirectDep=e.getKey();
    NodeEntry newDirectDepEntry=e.getValue();
    enqueueChild(skyKey,state,newDirectDep,newDirectDepEntry,false);
  }
}","@Override public void run(){
  NodeEntry state=Preconditions.checkNotNull(graph.get(skyKey),skyKey);
  Preconditions.checkState(state.isReady(),""String_Node_Str"",skyKey,state);
  if (maybeHandleDirtyNode(state) == DirtyOutcome.ALREADY_PROCESSED) {
    return;
  }
  Set<SkyKey> directDeps=state.getTemporaryDirectDeps();
  Preconditions.checkState(!directDeps.contains(ErrorTransienceValue.KEY),""String_Node_Str"",skyKey,state);
  SkyFunctionEnvironment env=new SkyFunctionEnvironment(skyKey,directDeps,visitor);
  SkyFunctionName functionName=skyKey.functionName();
  SkyFunction factory=skyFunctions.get(functionName);
  Preconditions.checkState(factory != null,""String_Node_Str"",functionName,skyKey,state);
  SkyValue value=null;
  long startTime=BlazeClock.instance().nanoTime();
  try {
    value=factory.compute(skyKey,env);
  }
 catch (  final SkyFunctionException builderException) {
    ReifiedSkyFunctionException reifiedBuilderException=new ReifiedSkyFunctionException(builderException,skyKey);
    if (reifiedBuilderException.getRootCauseSkyKey().equals(skyKey)) {
      boolean shouldFailFast=!keepGoing || builderException.isCatastrophic();
      if (shouldFailFast) {
        if (!visitor.preventNewEvaluations()) {
          return;
        }
      }
      Map<SkyKey,NodeEntry> newlyRequestedDeps=graph.getBatch(env.newlyRequestedDeps);
      boolean isTransitivelyTransient=reifiedBuilderException.isTransient();
      for (      NodeEntry depEntry : Iterables.concat(env.directDeps.values(),newlyRequestedDeps.values())) {
        if (!isDoneForBuild(depEntry)) {
          continue;
        }
        ErrorInfo depError=depEntry.getErrorInfo();
        if (depError != null) {
          isTransitivelyTransient|=depError.isTransient();
        }
      }
      ErrorInfo errorInfo=ErrorInfo.fromException(reifiedBuilderException,isTransitivelyTransient);
      registerNewlyDiscoveredDepsForDoneEntry(skyKey,state,newlyRequestedDeps,env);
      env.setError(errorInfo,reifiedBuilderException.isTransient());
      env.commit(keepGoing);
      if (!shouldFailFast) {
        return;
      }
      throw SchedulerException.ofError(errorInfo,skyKey);
    }
  }
catch (  InterruptedException ie) {
    throw SchedulerException.ofInterruption(ie,skyKey);
  }
catch (  RuntimeException re) {
    String msg=prepareCrashMessage(skyKey,state.getInProgressReverseDeps());
    RuntimeException ex=new RuntimeException(msg,re);
    visitor.noteCrash(ex);
    throw ex;
  }
 finally {
    env.doneBuilding();
    long elapsedTimeNanos=BlazeClock.instance().nanoTime() - startTime;
    if (elapsedTimeNanos > 0) {
      if (progressReceiver != null) {
        progressReceiver.computed(skyKey,elapsedTimeNanos);
      }
      Profiler.instance().logSimpleTaskDuration(startTime,elapsedTimeNanos,ProfilerTask.SKYFUNCTION,skyKey);
    }
  }
  GroupedListHelper<SkyKey> newDirectDeps=env.newlyRequestedDeps;
  if (value != null) {
    Preconditions.checkState(!env.valuesMissing(),""String_Node_Str"" + ""String_Node_Str"",skyKey,newDirectDeps,state);
    env.setValue(value);
    registerNewlyDiscoveredDepsForDoneEntry(skyKey,state,graph.getBatch(env.newlyRequestedDeps),env);
    env.commit(true);
    return;
  }
  if (env.getDepErrorKey() != null) {
    Preconditions.checkState(!keepGoing,""String_Node_Str"",skyKey,state,env.getDepErrorKey());
    SkyKey childErrorKey=env.getDepErrorKey();
    NodeEntry childErrorEntry=Preconditions.checkNotNull(graph.get(childErrorKey),""String_Node_Str"",skyKey,state,childErrorKey);
    Preconditions.checkState(!state.getTemporaryDirectDeps().contains(childErrorKey),""String_Node_Str"",skyKey,state,childErrorKey,childErrorEntry);
    Preconditions.checkState(newDirectDeps.contains(childErrorKey),""String_Node_Str"",state,childErrorKey,newDirectDeps);
    state.addTemporaryDirectDeps(GroupedListHelper.create(ImmutableList.of(childErrorKey)));
    DependencyState childErrorState=childErrorEntry.addReverseDepAndCheckIfDone(skyKey);
    Preconditions.checkState(childErrorState == DependencyState.DONE,""String_Node_Str"",skyKey,state,childErrorKey,childErrorEntry);
    ErrorInfo childErrorInfo=Preconditions.checkNotNull(childErrorEntry.getErrorInfo());
    visitor.preventNewEvaluations();
    throw SchedulerException.ofError(childErrorInfo,childErrorKey);
  }
  state.addTemporaryDirectDeps(newDirectDeps);
  if (newDirectDeps.isEmpty()) {
    Preconditions.checkState(!env.childErrorInfos.isEmpty(),""String_Node_Str"",skyKey,state);
    Preconditions.checkState(keepGoing,""String_Node_Str"",skyKey,state,env.childErrorInfos);
    env.commit(true);
    return;
  }
  for (  Map.Entry<SkyKey,NodeEntry> e : graph.createIfAbsentBatch(newDirectDeps).entrySet()) {
    SkyKey newDirectDep=e.getKey();
    NodeEntry newDirectDepEntry=e.getValue();
    enqueueChild(skyKey,state,newDirectDep,newDirectDepEntry,false);
  }
}",0.9992791679538668
110921,"@Subscribe public void buildCompleteEvent(BuildCompleteEvent event){
  BuildResult result=event.getResult();
  if (result.wasCatastrophe()) {
    blazeHalted=true;
  }
 else   if (result.skippedTargetsBecauseOfEarlierFailure()) {
    skippedTestsBecauseOfEarlierFailure=true;
  }
  buildComplete(result.getActualTargets(),result.getSuccessfulTargets());
}","@Subscribe public void buildCompleteEvent(BuildCompleteEvent event){
  BuildResult result=event.getResult();
  if (result.wasCatastrophe()) {
    blazeHalted=true;
  }
  buildComplete(result.getActualTargets(),result.getSuccessfulTargets());
}",0.6020066889632107
110922,"private void targetFailure(LabelAndConfiguration label){
  TestSummary finalSummary;
synchronized (summaryLock) {
    if (!remainingRuns.containsKey(label)) {
      return;
    }
    TestSummary.Builder summary=summaries.get(label);
    if (summary == null) {
      return;
    }
    finalSummary=analyzer.markUnbuilt(summary,blazeHalted,skippedTestsBecauseOfEarlierFailure).build();
    remainingRuns.removeAll(label);
  }
  eventBus.post(finalSummary);
}","private void targetFailure(LabelAndConfiguration label){
  TestSummary finalSummary;
synchronized (summaryLock) {
    if (!remainingRuns.containsKey(label)) {
      return;
    }
    TestSummary.Builder summary=summaries.get(label);
    if (summary == null) {
      return;
    }
    finalSummary=analyzer.markUnbuilt(summary,blazeHalted).build();
    remainingRuns.removeAll(label);
  }
  eventBus.post(finalSummary);
}",0.958904109589041
110923,"TestSummary.Builder markUnbuilt(TestSummary.Builder summary,boolean blazeHalted,boolean stopOnFirstFailure){
  BlazeTestStatus runStatus=blazeHalted ? BlazeTestStatus.BLAZE_HALTED_BEFORE_TESTING : (executionOptions.testCheckUpToDate || stopOnFirstFailure ? BlazeTestStatus.NO_STATUS : BlazeTestStatus.FAILED_TO_BUILD);
  return summary.setStatus(runStatus);
}","TestSummary.Builder markUnbuilt(TestSummary.Builder summary,boolean blazeHalted){
  BlazeTestStatus runStatus=blazeHalted ? BlazeTestStatus.BLAZE_HALTED_BEFORE_TESTING : (executionOptions.testCheckUpToDate || skipTargetsOnFailure ? BlazeTestStatus.NO_STATUS : BlazeTestStatus.FAILED_TO_BUILD);
  return summary.setStatus(runStatus);
}",0.9321789321789322
110924,"/** 
 * @param summaryOptions Parsed test summarization options.
 * @param executionOptions Parsed build/test execution options.
 * @param eventBus For reporting failed to build and cached tests.
 */
public TestResultAnalyzer(Path execRoot,TestSummaryOptions summaryOptions,ExecutionOptions executionOptions,EventBus eventBus){
  this.execRoot=execRoot;
  this.summaryOptions=summaryOptions;
  this.executionOptions=executionOptions;
  this.eventBus=eventBus;
}","/** 
 * @param summaryOptions Parsed test summarization options.
 * @param executionOptions Parsed build/test execution options.
 * @param eventBus For reporting failed to build and cached tests.
 */
public TestResultAnalyzer(Path execRoot,TestSummaryOptions summaryOptions,ExecutionOptions executionOptions,EventBus eventBus){
  this.execRoot=execRoot;
  this.summaryOptions=summaryOptions;
  this.executionOptions=executionOptions;
  this.eventBus=eventBus;
  eventBus.register(this);
}",0.9715489989462592
110925,"private TestSummary.Builder markIncomplete(TestSummary.Builder summaryBuilder){
  TestSummary summary=summaryBuilder.peek();
  BlazeTestStatus status=summary.getStatus();
  if (status != BlazeTestStatus.NO_STATUS) {
    status=aggregateStatus(status,BlazeTestStatus.INCOMPLETE);
  }
  return summaryBuilder.setStatus(status);
}","private TestSummary.Builder markIncomplete(TestSummary.Builder summaryBuilder){
  TestSummary summary=summaryBuilder.peek();
  BlazeTestStatus status=summary.getStatus();
  if (skipTargetsOnFailure) {
    status=BlazeTestStatus.NO_STATUS;
  }
 else   if (status != BlazeTestStatus.NO_STATUS) {
    status=aggregateStatus(status,BlazeTestStatus.INCOMPLETE);
  }
  return summaryBuilder.setStatus(status);
}",0.8934426229508197
110926,"/** 
 * Returns the names of all the packages under a given directory.
 * @param directory a {@link RootedPath} specifying the directory to search
 * @param excludedSubdirectories a set of {@link PathFragment}s, all of which are beneath  {@code directory}, specifying transitive subdirectories to exclude
 */
Iterable<PathFragment> getPackagesUnderDirectory(RepositoryName repository,PathFragment directory,ImmutableSet<PathFragment> excludedSubdirectories);","/** 
 * Returns the names of all the packages under a given directory. <p>Packages returned by this method and passed into  {@link #bulkGetPackages(EventHandler,Iterable)} are expected to return successful{@link Package} values.
 * @param directory a {@link RootedPath} specifying the directory to search
 * @param excludedSubdirectories a set of {@link PathFragment}s, all of which are beneath  {@code directory}, specifying transitive subdirectories to exclude
 */
Iterable<PathFragment> getPackagesUnderDirectory(RepositoryName repository,PathFragment directory,ImmutableSet<PathFragment> excludedSubdirectories);",0.8528864059590316
110927,"@Override public Map<PackageIdentifier,Package> bulkGetPackages(EventHandler eventHandler,Iterable<PackageIdentifier> pkgIds) throws NoSuchPackageException {
  Set<SkyKey> pkgKeys=ImmutableSet.copyOf(PackageValue.keys(pkgIds));
  ImmutableMap.Builder<PackageIdentifier,Package> pkgResults=ImmutableMap.builder();
  Map<SkyKey,SkyValue> packages=graph.getSuccessfulValues(pkgKeys);
  for (  PackageIdentifier pkgId : pkgIds) {
    PackageValue pkgValue=(PackageValue)packages.get(PackageValue.key(pkgId));
    pkgResults.put(pkgId,Preconditions.checkNotNull(pkgValue.getPackage(),pkgId));
  }
  SetView<SkyKey> unknownKeys=Sets.difference(pkgKeys,packages.keySet());
  for (  Map.Entry<SkyKey,Exception> missingOrExceptionEntry : graph.getMissingAndExceptions(unknownKeys).entrySet()) {
    PackageIdentifier pkgIdentifier=(PackageIdentifier)missingOrExceptionEntry.getKey().argument();
    Exception exception=missingOrExceptionEntry.getValue();
    if (exception == null) {
      throw new BuildFileNotFoundException(pkgIdentifier,""String_Node_Str"");
    }
    Throwables.propagateIfInstanceOf(exception,NoSuchPackageException.class);
    Throwables.propagate(exception);
  }
  return pkgResults.build();
}","@Override public Map<PackageIdentifier,Package> bulkGetPackages(EventHandler eventHandler,Iterable<PackageIdentifier> pkgIds) throws NoSuchPackageException {
  Set<SkyKey> pkgKeys=ImmutableSet.copyOf(PackageValue.keys(pkgIds));
  ImmutableMap.Builder<PackageIdentifier,Package> pkgResults=ImmutableMap.builder();
  Map<SkyKey,SkyValue> packages=graph.getSuccessfulValues(pkgKeys);
  for (  Map.Entry<SkyKey,SkyValue> pkgEntry : packages.entrySet()) {
    PackageIdentifier pkgId=(PackageIdentifier)pkgEntry.getKey().argument();
    PackageValue pkgValue=(PackageValue)pkgEntry.getValue();
    pkgResults.put(pkgId,Preconditions.checkNotNull(pkgValue.getPackage(),pkgId));
  }
  SetView<SkyKey> unknownKeys=Sets.difference(pkgKeys,packages.keySet());
  for (  Map.Entry<SkyKey,Exception> missingOrExceptionEntry : graph.getMissingAndExceptions(unknownKeys).entrySet()) {
    PackageIdentifier pkgIdentifier=(PackageIdentifier)missingOrExceptionEntry.getKey().argument();
    Exception exception=missingOrExceptionEntry.getValue();
    if (exception == null) {
      throw new BuildFileNotFoundException(pkgIdentifier,""String_Node_Str"");
    }
    Throwables.propagateIfInstanceOf(exception,NoSuchPackageException.class);
    Throwables.propagate(exception);
  }
  return pkgResults.build();
}",0.9199359487590072
110928,"private Map<PackageIdentifier,ResolvedTargets<Target>> bulkGetTargetsInPackage(String originalPattern,Iterable<PackageIdentifier> pkgIds,FilteringPolicy policy) throws TargetParsingException, InterruptedException {
  try {
    Map<PackageIdentifier,Package> pkgs=bulkGetPackages(pkgIds);
    ImmutableMap.Builder<PackageIdentifier,ResolvedTargets<Target>> result=ImmutableMap.builder();
    for (    PackageIdentifier pkgId : pkgIds) {
      Package pkg=pkgs.get(pkgId);
      result.put(pkgId,TargetPatternResolverUtil.resolvePackageTargets(pkg,policy));
    }
    return result.build();
  }
 catch (  NoSuchThingException e) {
    String message=TargetPatternResolverUtil.getParsingErrorMessage(e.getMessage(),originalPattern);
    throw new TargetParsingException(message,e);
  }
}","private Map<PackageIdentifier,ResolvedTargets<Target>> bulkGetTargetsInPackage(String originalPattern,Iterable<PackageIdentifier> pkgIds,FilteringPolicy policy) throws TargetParsingException, InterruptedException {
  try {
    Map<PackageIdentifier,Package> pkgs=bulkGetPackages(pkgIds);
    if (pkgs.size() != Iterables.size(pkgIds)) {
      throw new IllegalStateException(""String_Node_Str"" + Sets.difference(ImmutableSet.copyOf(pkgIds),pkgs.keySet()));
    }
    ImmutableMap.Builder<PackageIdentifier,ResolvedTargets<Target>> result=ImmutableMap.builder();
    for (    PackageIdentifier pkgId : pkgIds) {
      Package pkg=pkgs.get(pkgId);
      result.put(pkgId,TargetPatternResolverUtil.resolvePackageTargets(pkg,policy));
    }
    return result.build();
  }
 catch (  NoSuchThingException e) {
    String message=TargetPatternResolverUtil.getParsingErrorMessage(e.getMessage(),originalPattern);
    throw new IllegalStateException(""String_Node_Str"" + message,e);
  }
}",0.8756388415672913
110929,"@ThreadSafe public static SkyKey key(BuildOptions buildOptions,Class<? extends Fragment> fragmentType,RuleClassProvider ruleClassProvider){
  BuildOptions optionsKey=buildOptions.get(BuildConfiguration.Options.class).useDynamicConfigurations ? buildOptions.trim(BuildConfiguration.getOptionsClasses(ImmutableList.<Class<? extends BuildConfiguration.Fragment>>of(fragmentType),ruleClassProvider)) : buildOptions;
  return new SkyKey(SkyFunctions.CONFIGURATION_FRAGMENT,new ConfigurationFragmentKey(optionsKey,fragmentType));
}","@ThreadSafe public static SkyKey key(BuildOptions buildOptions,Class<? extends Fragment> fragmentType,RuleClassProvider ruleClassProvider){
  BuildOptions optionsKey=buildOptions.trim(BuildConfiguration.getOptionsClasses(ImmutableList.<Class<? extends BuildConfiguration.Fragment>>of(fragmentType),ruleClassProvider));
  return new SkyKey(SkyFunctions.CONFIGURATION_FRAGMENT,new ConfigurationFragmentKey(optionsKey,fragmentType));
}",0.90282131661442
110930,"public static SkyValue clone(Rule rule,Path outputDirectory,EventHandler eventHandler) throws RepositoryFunctionException {
  AggregatingAttributeMapper mapper=AggregatingAttributeMapper.of(rule);
  if ((mapper.has(""String_Node_Str"",Type.STRING) == mapper.has(""String_Node_Str"",Type.STRING)) && (mapper.get(""String_Node_Str"",Type.STRING).isEmpty() == mapper.get(""String_Node_Str"",Type.STRING).isEmpty())) {
    throw new RepositoryFunctionException(new EvalException(rule.getLocation(),""String_Node_Str""),Transience.PERSISTENT);
  }
  String startingPoint;
  if (mapper.has(""String_Node_Str"",Type.STRING) && !mapper.get(""String_Node_Str"",Type.STRING).isEmpty()) {
    startingPoint=mapper.get(""String_Node_Str"",Type.STRING);
  }
 else {
    startingPoint=""String_Node_Str"" + mapper.get(""String_Node_Str"",Type.STRING);
  }
  GitRepositoryDescriptor descriptor=new GitRepositoryDescriptor(mapper.get(""String_Node_Str"",Type.STRING),startingPoint,mapper.get(""String_Node_Str"",Type.BOOLEAN),outputDirectory);
  Git git=null;
  try {
    if (descriptor.directory.exists()) {
      if (isUpToDate(descriptor)) {
        return new HttpDownloadValue(descriptor.directory);
      }
      try {
        FileSystemUtils.deleteTree(descriptor.directory);
      }
 catch (      IOException e) {
        throw new RepositoryFunctionException(e,Transience.TRANSIENT);
      }
    }
    git=Git.cloneRepository().setURI(descriptor.remote).setCredentialsProvider(new NetRCCredentialsProvider()).setDirectory(descriptor.directory.getPathFile()).setCloneSubmodules(false).setNoCheckout(true).setProgressMonitor(new GitProgressMonitor(""String_Node_Str"" + descriptor.remote,eventHandler)).call();
    git.checkout().setCreateBranch(true).setName(""String_Node_Str"").setStartPoint(descriptor.checkout).call();
    if (descriptor.initSubmodules && !git.submoduleInit().call().isEmpty()) {
      git.submoduleUpdate().setProgressMonitor(new GitProgressMonitor(""String_Node_Str"" + descriptor.remote,eventHandler)).call();
    }
  }
 catch (  InvalidRemoteException e) {
    throw new RepositoryFunctionException(new IOException(""String_Node_Str"" + e.getMessage()),Transience.PERSISTENT);
  }
catch (  RefNotFoundException|InvalidRefNameException e) {
    throw new RepositoryFunctionException(new IOException(""String_Node_Str"" + e.getMessage()),Transience.PERSISTENT);
  }
catch (  GitAPIException e) {
    StringBuilder errmsg=new StringBuilder();
    errmsg.append(e.getMessage());
    Throwable throwable=e;
    while (throwable.getCause() != null) {
      throwable=throwable.getCause();
      errmsg.append(""String_Node_Str"" + e.getMessage());
    }
    throw new RepositoryFunctionException(new IOException(""String_Node_Str"" + errmsg),Transience.PERSISTENT);
  }
catch (  JGitInternalException e) {
    throw new RepositoryFunctionException(new IOException(e.getMessage()),Transience.PERSISTENT);
  }
 finally {
    if (git != null) {
      git.close();
    }
  }
  return new HttpDownloadValue(descriptor.directory);
}","public static SkyValue clone(Rule rule,Path outputDirectory,EventHandler eventHandler) throws RepositoryFunctionException {
  AggregatingAttributeMapper mapper=AggregatingAttributeMapper.of(rule);
  if ((mapper.has(""String_Node_Str"",Type.STRING) == mapper.has(""String_Node_Str"",Type.STRING)) && (mapper.get(""String_Node_Str"",Type.STRING).isEmpty() == mapper.get(""String_Node_Str"",Type.STRING).isEmpty())) {
    throw new RepositoryFunctionException(new EvalException(rule.getLocation(),""String_Node_Str""),Transience.PERSISTENT);
  }
  String startingPoint;
  if (mapper.has(""String_Node_Str"",Type.STRING) && !mapper.get(""String_Node_Str"",Type.STRING).isEmpty()) {
    startingPoint=mapper.get(""String_Node_Str"",Type.STRING);
  }
 else {
    startingPoint=""String_Node_Str"" + mapper.get(""String_Node_Str"",Type.STRING);
  }
  GitRepositoryDescriptor descriptor=new GitRepositoryDescriptor(mapper.get(""String_Node_Str"",Type.STRING),startingPoint,mapper.get(""String_Node_Str"",Type.BOOLEAN),outputDirectory);
  if (descriptor.remote != null && descriptor.remote.startsWith(""String_Node_Str"")) {
    try {
      ProxyHelper.createProxyIfNeeded(descriptor.remote);
    }
 catch (    IOException ie) {
      throw new RepositoryFunctionException(ie,Transience.TRANSIENT);
    }
  }
  Git git=null;
  try {
    if (descriptor.directory.exists()) {
      if (isUpToDate(descriptor)) {
        return new HttpDownloadValue(descriptor.directory);
      }
      try {
        FileSystemUtils.deleteTree(descriptor.directory);
      }
 catch (      IOException e) {
        throw new RepositoryFunctionException(e,Transience.TRANSIENT);
      }
    }
    git=Git.cloneRepository().setURI(descriptor.remote).setCredentialsProvider(new NetRCCredentialsProvider()).setDirectory(descriptor.directory.getPathFile()).setCloneSubmodules(false).setNoCheckout(true).setProgressMonitor(new GitProgressMonitor(""String_Node_Str"" + descriptor.remote,eventHandler)).call();
    git.checkout().setCreateBranch(true).setName(""String_Node_Str"").setStartPoint(descriptor.checkout).call();
    if (descriptor.initSubmodules && !git.submoduleInit().call().isEmpty()) {
      git.submoduleUpdate().setProgressMonitor(new GitProgressMonitor(""String_Node_Str"" + descriptor.remote,eventHandler)).call();
    }
  }
 catch (  InvalidRemoteException e) {
    throw new RepositoryFunctionException(new IOException(""String_Node_Str"" + e.getMessage()),Transience.PERSISTENT);
  }
catch (  RefNotFoundException|InvalidRefNameException e) {
    throw new RepositoryFunctionException(new IOException(""String_Node_Str"" + e.getMessage()),Transience.PERSISTENT);
  }
catch (  GitAPIException e) {
    StringBuilder errmsg=new StringBuilder();
    errmsg.append(e.getMessage());
    Throwable throwable=e;
    while (throwable.getCause() != null) {
      throwable=throwable.getCause();
      errmsg.append(""String_Node_Str"" + e.getMessage());
    }
    throw new RepositoryFunctionException(new IOException(""String_Node_Str"" + errmsg),Transience.PERSISTENT);
  }
catch (  JGitInternalException e) {
    throw new RepositoryFunctionException(new IOException(e.getMessage()),Transience.PERSISTENT);
  }
 finally {
    if (git != null) {
      git.close();
    }
  }
  return new HttpDownloadValue(descriptor.directory);
}",0.9569240587109126
110931,"public static HttpConnection createAndConnect(URL url) throws IOException {
  int retries=MAX_REDIRECTS;
  Proxy proxy=createProxyIfNeeded(url.getProtocol());
  do {
    HttpURLConnection connection=(HttpURLConnection)url.openConnection(proxy);
    try {
      connection.connect();
    }
 catch (    IllegalArgumentException e) {
      throw new IOException(""String_Node_Str"" + url + ""String_Node_Str""+ e.getMessage(),e);
    }
    int statusCode=connection.getResponseCode();
switch (statusCode) {
case HttpURLConnection.HTTP_OK:
      return new HttpConnection(connection.getInputStream(),parseContentLength(connection));
case HttpURLConnection.HTTP_MOVED_PERM:
case HttpURLConnection.HTTP_MOVED_TEMP:
    url=tryGetLocation(statusCode,connection);
  connection.disconnect();
break;
case -1:
throw new IOException(""String_Node_Str"");
default :
throw new IOException(String.format(""String_Node_Str"",connection.getResponseCode(),connection.getResponseMessage(),readBody(connection)));
}
}
 while (retries-- > 0);
throw new IOException(""String_Node_Str"" + MAX_REDIRECTS + ""String_Node_Str"");
}","public static HttpConnection createAndConnect(URL url) throws IOException {
  int retries=MAX_REDIRECTS;
  Proxy proxy=ProxyHelper.createProxyIfNeeded(url.toString());
  do {
    HttpURLConnection connection=(HttpURLConnection)url.openConnection(proxy);
    try {
      connection.connect();
    }
 catch (    IllegalArgumentException e) {
      throw new IOException(""String_Node_Str"" + url + ""String_Node_Str""+ e.getMessage(),e);
    }
    int statusCode=connection.getResponseCode();
switch (statusCode) {
case HttpURLConnection.HTTP_OK:
      return new HttpConnection(connection.getInputStream(),parseContentLength(connection));
case HttpURLConnection.HTTP_MOVED_PERM:
case HttpURLConnection.HTTP_MOVED_TEMP:
    url=tryGetLocation(statusCode,connection);
  connection.disconnect();
break;
case -1:
throw new IOException(""String_Node_Str"");
default :
throw new IOException(String.format(""String_Node_Str"",connection.getResponseCode(),connection.getResponseMessage(),readBody(connection)));
}
}
 while (retries-- > 0);
throw new IOException(""String_Node_Str"" + MAX_REDIRECTS + ""String_Node_Str"");
}",0.985876993166287
110932,"@Override public SkyValue compute(SkyKey skyKey,Environment env) throws GlobFunctionException {
  GlobDescriptor glob=(GlobDescriptor)skyKey.argument();
  PathFragment globSubdir=glob.getSubdir();
  if (!globSubdir.equals(PathFragment.EMPTY_FRAGMENT)) {
    PackageLookupValue globSubdirPkgLookupValue=(PackageLookupValue)env.getValue(PackageLookupValue.key(PackageIdentifier.create(glob.getPackageId().getRepository(),glob.getPackageId().getPackageFragment().getRelative(globSubdir))));
    if (globSubdirPkgLookupValue == null) {
      return null;
    }
    if (globSubdirPkgLookupValue.packageExists()) {
      return GlobValue.EMPTY;
    }
  }
  String pattern=glob.getPattern();
  int slashPos=pattern.indexOf('/');
  String patternHead;
  String patternTail;
  if (slashPos == -1) {
    patternHead=pattern;
    patternTail=null;
  }
 else {
    patternHead=pattern.substring(0,slashPos);
    patternTail=pattern.substring(slashPos + 1);
  }
  NestedSetBuilder<PathFragment> matches=NestedSetBuilder.stableOrder();
  if (""String_Node_Str"".equals(patternHead)) {
    if (patternTail == null) {
      if (!glob.excludeDirs()) {
        matches.add(globSubdir);
      }
    }
 else {
      SkyKey globKey=GlobValue.internalKey(glob.getPackageId(),glob.getPackageRoot(),globSubdir,patternTail,glob.excludeDirs());
      GlobValue globValue=(GlobValue)env.getValue(globKey);
      if (globValue == null) {
        return null;
      }
      matches.addTransitive(globValue.getMatches());
    }
  }
  PathFragment dirPathFragment=glob.getPackageId().getPackageFragment().getRelative(globSubdir);
  RootedPath dirRootedPath=RootedPath.toRootedPath(glob.getPackageRoot(),dirPathFragment);
  if (alwaysUseDirListing || containsGlobs(patternHead)) {
    DirectoryListingValue listingValue=(DirectoryListingValue)env.getValue(DirectoryListingValue.key(dirRootedPath));
    if (listingValue == null) {
      return null;
    }
    for (    Dirent dirent : listingValue.getDirents()) {
      Type direntType=dirent.getType();
      String fileName=dirent.getName();
      boolean isDirectory=(direntType == Dirent.Type.DIRECTORY);
      if (!UnixGlob.matches(patternHead,fileName,regexPatternCache)) {
        continue;
      }
      if (direntType == Dirent.Type.SYMLINK) {
        RootedPath symlinkRootedPath=RootedPath.toRootedPath(glob.getPackageRoot(),dirPathFragment.getRelative(fileName));
        FileValue symlinkFileValue=(FileValue)env.getValue(FileValue.key(symlinkRootedPath));
        if (symlinkFileValue == null) {
          continue;
        }
        if (!symlinkFileValue.isSymlink()) {
          throw new GlobFunctionException(new InconsistentFilesystemException(""String_Node_Str"" + symlinkRootedPath.asPath() + ""String_Node_Str""),Transience.TRANSIENT);
        }
        isDirectory=symlinkFileValue.isDirectory();
      }
      String subdirPattern=""String_Node_Str"".equals(patternHead) ? glob.getPattern() : patternTail;
      addFile(fileName,glob,subdirPattern,patternTail == null,isDirectory,matches,env);
    }
  }
 else {
    String fileName=patternHead;
    RootedPath fileRootedPath=RootedPath.toRootedPath(glob.getPackageRoot(),dirPathFragment.getRelative(fileName));
    FileValue fileValue=(FileValue)env.getValue(FileValue.key(fileRootedPath));
    if (fileValue == null) {
      return null;
    }
    if (fileValue.exists()) {
      addFile(fileName,glob,patternTail,patternTail == null,fileValue.isDirectory(),matches,env);
    }
  }
  if (env.valuesMissing()) {
    return null;
  }
  NestedSet<PathFragment> matchesBuilt=matches.build();
  if (matchesBuilt.isEmpty()) {
    return GlobValue.EMPTY;
  }
  return new GlobValue(matchesBuilt);
}","@Override public SkyValue compute(SkyKey skyKey,Environment env) throws GlobFunctionException {
  GlobDescriptor glob=(GlobDescriptor)skyKey.argument();
  PathFragment globSubdir=glob.getSubdir();
  if (!globSubdir.equals(PathFragment.EMPTY_FRAGMENT)) {
    PackageLookupValue globSubdirPkgLookupValue=(PackageLookupValue)env.getValue(PackageLookupValue.key(PackageIdentifier.create(glob.getPackageId().getRepository(),glob.getPackageId().getPackageFragment().getRelative(globSubdir))));
    if (globSubdirPkgLookupValue == null) {
      return null;
    }
    if (globSubdirPkgLookupValue.packageExists()) {
      return GlobValue.EMPTY;
    }
  }
  String pattern=glob.getPattern();
  int slashPos=pattern.indexOf('/');
  String patternHead;
  String patternTail;
  if (slashPos == -1) {
    patternHead=pattern;
    patternTail=null;
  }
 else {
    patternHead=pattern.substring(0,slashPos);
    patternTail=pattern.substring(slashPos + 1);
  }
  NestedSetBuilder<PathFragment> matches=NestedSetBuilder.stableOrder();
  if (""String_Node_Str"".equals(patternHead)) {
    if (patternTail == null) {
      if (!glob.excludeDirs()) {
        matches.add(globSubdir);
      }
    }
 else {
      SkyKey globKey=GlobValue.internalKey(glob.getPackageId(),glob.getPackageRoot(),globSubdir,patternTail,glob.excludeDirs());
      GlobValue globValue=(GlobValue)env.getValue(globKey);
      if (globValue == null) {
        return null;
      }
      matches.addTransitive(globValue.getMatches());
    }
  }
  PathFragment dirPathFragment=glob.getPackageId().getPackageFragment().getRelative(globSubdir);
  RootedPath dirRootedPath=RootedPath.toRootedPath(glob.getPackageRoot(),dirPathFragment);
  if (alwaysUseDirListing || containsGlobs(patternHead)) {
    DirectoryListingValue listingValue=(DirectoryListingValue)env.getValue(DirectoryListingValue.key(dirRootedPath));
    if (listingValue == null) {
      return null;
    }
    for (    Dirent dirent : listingValue.getDirents()) {
      Type direntType=dirent.getType();
      String fileName=dirent.getName();
      boolean isDirectory=(direntType == Dirent.Type.DIRECTORY);
      if (!UnixGlob.matches(patternHead,fileName,regexPatternCache)) {
        continue;
      }
      if (direntType == Dirent.Type.SYMLINK) {
        RootedPath symlinkRootedPath=RootedPath.toRootedPath(glob.getPackageRoot(),dirPathFragment.getRelative(fileName));
        FileValue symlinkFileValue=(FileValue)env.getValue(FileValue.key(symlinkRootedPath));
        if (symlinkFileValue == null) {
          continue;
        }
        if (!symlinkFileValue.isSymlink()) {
          throw new GlobFunctionException(new InconsistentFilesystemException(""String_Node_Str"" + symlinkRootedPath.asPath() + ""String_Node_Str""),Transience.TRANSIENT);
        }
        if (!symlinkFileValue.exists()) {
          continue;
        }
        isDirectory=symlinkFileValue.isDirectory();
      }
      String subdirPattern=""String_Node_Str"".equals(patternHead) ? glob.getPattern() : patternTail;
      addFile(fileName,glob,subdirPattern,patternTail == null,isDirectory,matches,env);
    }
  }
 else {
    String fileName=patternHead;
    RootedPath fileRootedPath=RootedPath.toRootedPath(glob.getPackageRoot(),dirPathFragment.getRelative(fileName));
    FileValue fileValue=(FileValue)env.getValue(FileValue.key(fileRootedPath));
    if (fileValue == null) {
      return null;
    }
    if (fileValue.exists()) {
      addFile(fileName,glob,patternTail,patternTail == null,fileValue.isDirectory(),matches,env);
    }
  }
  if (env.valuesMissing()) {
    return null;
  }
  NestedSet<PathFragment> matchesBuilt=matches.build();
  if (matchesBuilt.isEmpty()) {
    return GlobValue.EMPTY;
  }
  return new GlobValue(matchesBuilt);
}",0.990301724137931
110933,"@Override public void visitMethodDef(JCMethodDecl tree){
  if (tree.body == null) {
    return;
  }
  tree.body.stats=com.sun.tools.javac.util.List.nil();
}","@Override public void visitMethodDef(JCMethodDecl tree){
  if (tree.body == null) {
    return;
  }
  if (tree.getReturnType() == null && delegatingConstructor(tree.body.stats)) {
    tree.body.stats=com.sun.tools.javac.util.List.of(tree.body.stats.get(0));
    return;
  }
  tree.body.stats=com.sun.tools.javac.util.List.nil();
}",0.6255144032921811
110934,"@Override public int hashCode(){
  return Objects.hash(targetPatterns,compileOneDependency,buildTestsOnly,determineTests,testFilter);
}","@Override public int hashCode(){
  return Objects.hash(targetPatterns,offset,compileOneDependency,buildTestsOnly,determineTests,testFilter);
}",0.9747292418772564
110935,"public TargetPatternList(ImmutableList<String> targetPatterns,String offset,boolean compileOneDependency,boolean buildTestsOnly,boolean determineTests,TestFilter testFilter){
  this.targetPatterns=targetPatterns;
  this.offset=offset;
  this.compileOneDependency=compileOneDependency;
  this.buildTestsOnly=buildTestsOnly;
  this.determineTests=determineTests;
  this.testFilter=testFilter;
}","public TargetPatternList(ImmutableList<String> targetPatterns,String offset,boolean compileOneDependency,boolean buildTestsOnly,boolean determineTests,@Nullable TestFilter testFilter){
  this.targetPatterns=Preconditions.checkNotNull(targetPatterns);
  this.offset=Preconditions.checkNotNull(offset);
  this.compileOneDependency=compileOneDependency;
  this.buildTestsOnly=buildTestsOnly;
  this.determineTests=determineTests;
  this.testFilter=testFilter;
  if (buildTestsOnly || determineTests) {
    Preconditions.checkNotNull(testFilter);
  }
}",0.8212765957446808
110936,"@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (!(obj instanceof TargetPatternList)) {
    return false;
  }
  TargetPatternList other=(TargetPatternList)obj;
  return other.targetPatterns.equals(this.targetPatterns) && other.compileOneDependency == compileOneDependency && other.buildTestsOnly == buildTestsOnly && other.determineTests == determineTests && other.testFilter.equals(testFilter);
}","@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (!(obj instanceof TargetPatternList)) {
    return false;
  }
  TargetPatternList other=(TargetPatternList)obj;
  return other.targetPatterns.equals(this.targetPatterns) && other.offset.equals(this.offset) && other.compileOneDependency == compileOneDependency && other.buildTestsOnly == buildTestsOnly && other.determineTests == determineTests && Objects.equals(other.testFilter,testFilter);
}",0.9352051835853132
110937,"@Override public String toString(){
  return targetPatterns.toString();
}","@Override public String toString(){
  StringBuilder result=new StringBuilder();
  result.append(targetPatterns);
  if (!offset.isEmpty()) {
    result.append(""String_Node_Str"").append(offset);
  }
  result.append(compileOneDependency ? ""String_Node_Str"" : ""String_Node_Str"");
  result.append(buildTestsOnly ? ""String_Node_Str"" : ""String_Node_Str"");
  result.append(determineTests ? ""String_Node_Str"" : ""String_Node_Str"");
  result.append(testFilter != null ? testFilter : ""String_Node_Str"");
  return result.toString();
}",0.1784511784511784
110938,"/** 
 * Create a target pattern phase value key. 
 */
@ThreadSafe public static SkyKey key(ImmutableList<String> targetPatterns,String offset,boolean compileOneDependency,boolean buildTestsOnly,boolean determineTests,TestFilter testFilter){
  return new SkyKey(SkyFunctions.TARGET_PATTERN_PHASE,new TargetPatternList(targetPatterns,offset,compileOneDependency,buildTestsOnly,determineTests,testFilter));
}","/** 
 * Create a target pattern phase value key. 
 */
@ThreadSafe public static SkyKey key(ImmutableList<String> targetPatterns,String offset,boolean compileOneDependency,boolean buildTestsOnly,boolean determineTests,@Nullable TestFilter testFilter){
  return new SkyKey(SkyFunctions.TARGET_PATTERN_PHASE,new TargetPatternList(targetPatterns,offset,compileOneDependency,buildTestsOnly,determineTests,testFilter));
}",0.9878048780487804
110939,"@Override @Nullable public BuildConfiguration createConfigurations(ConfigurationFactory configurationFactory,Cache<String,BuildConfiguration> cache,PackageProviderForConfigurations packageProvider,BuildOptions buildOptions,EventHandler errorEventListener,boolean performSanityCheck) throws InvalidConfigurationException {
  BuildConfiguration targetConfiguration=configurationFactory.getConfiguration(packageProvider,buildOptions,false,cache);
  if (targetConfiguration == null) {
    return null;
  }
  BuildConfiguration dataConfiguration=targetConfiguration;
  BuildConfiguration hostConfiguration=getHostConfigurationFromRequest(configurationFactory,packageProvider,dataConfiguration,buildOptions,cache);
  if (hostConfiguration == null) {
    return null;
  }
  ListMultimap<SplitTransition<?>,BuildConfiguration> splitTransitionsTable=ArrayListMultimap.create();
  for (  SplitTransition<BuildOptions> transition : buildOptions.getPotentialSplitTransitions()) {
    List<BuildOptions> splitOptionsList=transition.split(buildOptions);
    if (splitOptionsList.size() > 1 && targetConfiguration.useDynamicConfigurations()) {
      throw new InvalidConfigurationException(""String_Node_Str"");
    }
    for (    BuildOptions splitOptions : splitOptionsList) {
      BuildConfiguration splitConfig=configurationFactory.getConfiguration(packageProvider,splitOptions,false,cache);
      splitTransitionsTable.put(transition,splitConfig);
    }
  }
  if (packageProvider.valuesMissing()) {
    return null;
  }
  Set<Label> reachableLabels=new HashSet<>();
  if (performSanityCheck) {
    for (    Label label : buildOptions.getAllLabels().values()) {
      try {
        collectTransitiveClosure(packageProvider,reachableLabels,label);
      }
 catch (      NoSuchThingException e) {
        throw new IllegalStateException(e);
      }
    }
    sanityCheckImplicitLabels(reachableLabels,targetConfiguration);
    sanityCheckImplicitLabels(reachableLabels,hostConfiguration);
  }
  BuildConfiguration result=setupTransitions(targetConfiguration,dataConfiguration,hostConfiguration,splitTransitionsTable);
  result.reportInvalidOptions(errorEventListener);
  return result;
}","@Override @Nullable public BuildConfiguration createConfigurations(ConfigurationFactory configurationFactory,Cache<String,BuildConfiguration> cache,PackageProviderForConfigurations packageProvider,BuildOptions buildOptions,EventHandler eventHandler,boolean performSanityCheck) throws InvalidConfigurationException {
  BuildConfiguration targetConfiguration=configurationFactory.getConfiguration(packageProvider,buildOptions,false,cache);
  if (targetConfiguration == null) {
    return null;
  }
  BuildConfiguration dataConfiguration=targetConfiguration;
  BuildConfiguration hostConfiguration=getHostConfigurationFromRequest(configurationFactory,packageProvider,dataConfiguration,buildOptions,cache);
  if (hostConfiguration == null) {
    return null;
  }
  ListMultimap<SplitTransition<?>,BuildConfiguration> splitTransitionsTable=ArrayListMultimap.create();
  for (  SplitTransition<BuildOptions> transition : buildOptions.getPotentialSplitTransitions()) {
    List<BuildOptions> splitOptionsList=transition.split(buildOptions);
    if (splitOptionsList.size() > 1 && targetConfiguration.useDynamicConfigurations()) {
      throw new InvalidConfigurationException(""String_Node_Str"");
    }
    for (    BuildOptions splitOptions : splitOptionsList) {
      BuildConfiguration splitConfig=configurationFactory.getConfiguration(packageProvider,splitOptions,false,cache);
      splitTransitionsTable.put(transition,splitConfig);
    }
  }
  if (packageProvider.valuesMissing()) {
    return null;
  }
  Set<Label> reachableLabels=new HashSet<>();
  if (performSanityCheck) {
    for (    Map.Entry<String,Label> entry : buildOptions.getAllLabels().entries()) {
      Label label=entry.getValue();
      try {
        collectTransitiveClosure(packageProvider,reachableLabels,label);
      }
 catch (      NoSuchThingException e) {
        eventHandler.handle(Event.error(e.getMessage()));
        throw new InvalidConfigurationException(String.format(""String_Node_Str"",entry.getKey(),label));
      }
    }
    if (packageProvider.valuesMissing()) {
      return null;
    }
    sanityCheckImplicitLabels(reachableLabels,targetConfiguration);
    sanityCheckImplicitLabels(reachableLabels,hostConfiguration);
  }
  BuildConfiguration result=setupTransitions(targetConfiguration,dataConfiguration,hostConfiguration,splitTransitionsTable);
  result.reportInvalidOptions(eventHandler);
  return result;
}",0.9302732240437158
110940,"private ImmutableSet<Target> filterErrorFreeTargets(EventHandler eventHandler,EventBus eventBus,TransitivePackageLoader pkgLoader,Collection<Target> targetsToLoad,ListMultimap<String,Label> labelsToLoadUnconditionally) throws LoadingFailedException {
  Multimap<Label,Label> rootCauses=pkgLoader.getRootCauses();
  for (  Map.Entry<String,Label> entry : labelsToLoadUnconditionally.entries()) {
    if (rootCauses.containsKey(entry.getValue())) {
      throw new LoadingFailedException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ entry.getValue()+ ""String_Node_Str"");
    }
  }
  for (  Map.Entry<Label,Label> entry : rootCauses.entries()) {
    eventBus.post(new LoadingFailureEvent(entry.getKey(),entry.getValue()));
  }
  LoadedPackageProvider.Bridge bridge=new LoadedPackageProvider.Bridge(packageManager,eventHandler);
  return ImmutableSet.copyOf(Sets.difference(ImmutableSet.copyOf(targetsToLoad),getTargetsForLabels(bridge,rootCauses.keySet())));
}","private ImmutableSet<Target> filterErrorFreeTargets(EventHandler eventHandler,EventBus eventBus,TransitivePackageLoader pkgLoader,Collection<Target> targetsToLoad,ListMultimap<String,Label> labelsToLoadUnconditionally) throws LoadingFailedException {
  Multimap<Label,Label> rootCauses=pkgLoader.getRootCauses();
  for (  Map.Entry<String,Label> entry : labelsToLoadUnconditionally.entries()) {
    Label label=entry.getValue();
    if (rootCauses.containsKey(label)) {
      throw new LoadingFailedException(String.format(""String_Node_Str"",entry.getKey(),label));
    }
  }
  for (  Map.Entry<Label,Label> entry : rootCauses.entries()) {
    eventBus.post(new LoadingFailureEvent(entry.getKey(),entry.getValue()));
  }
  LoadedPackageProvider.Bridge bridge=new LoadedPackageProvider.Bridge(packageManager,eventHandler);
  return ImmutableSet.copyOf(Sets.difference(ImmutableSet.copyOf(targetsToLoad),getTargetsForLabels(bridge,rootCauses.keySet())));
}",0.9286829776158252
110941,"@Nullable private BuildConfiguration createConfiguration(Cache<String,BuildConfiguration> cache,EventHandler originalEventListener,PackageProviderForConfigurations loadedPackageProvider,BuildOptions buildOptions,String cpuOverride) throws InvalidConfigurationException {
  StoredEventHandler errorEventListener=new StoredEventHandler();
  if (cpuOverride != null) {
    buildOptions=buildOptions.clone();
    buildOptions.get(BuildConfiguration.Options.class).cpu=cpuOverride;
  }
  BuildConfiguration targetConfig=configurationFactory.get().createConfigurations(cache,loadedPackageProvider,buildOptions,errorEventListener);
  if (targetConfig == null) {
    return null;
  }
  errorEventListener.replayOn(originalEventListener);
  if (errorEventListener.hasErrors()) {
    throw new InvalidConfigurationException(""String_Node_Str"");
  }
  return targetConfig;
}","@Nullable private BuildConfiguration createConfiguration(Cache<String,BuildConfiguration> cache,EventHandler originalEventListener,PackageProviderForConfigurations loadedPackageProvider,BuildOptions buildOptions,String cpuOverride) throws InvalidConfigurationException {
  ErrorSensingEventHandler eventHandler=new ErrorSensingEventHandler(originalEventListener);
  if (cpuOverride != null) {
    buildOptions=buildOptions.clone();
    buildOptions.get(BuildConfiguration.Options.class).cpu=cpuOverride;
  }
  BuildConfiguration targetConfig=configurationFactory.get().createConfigurations(cache,loadedPackageProvider,buildOptions,eventHandler);
  if (targetConfig == null) {
    return null;
  }
  if (eventHandler.hasErrors()) {
    throw new InvalidConfigurationException(""String_Node_Str"");
  }
  return targetConfig;
}",0.8783382789317508
110942,"@ThreadCompatible public AnalysisResult update(LoadingResult loadingResult,BuildConfigurationCollection configurations,List<String> aspects,Options viewOptions,TopLevelArtifactContext topLevelOptions,EventHandler eventHandler,EventBus eventBus,boolean loadingEnabled) throws ViewCreationFailedException, InterruptedException {
  LOG.info(""String_Node_Str"");
  pollInterruptedStatus();
  skyframeBuildView.resetEvaluatedConfiguredTargetKeysSet();
  Collection<Target> targets=loadingResult.getTargets();
  eventBus.post(new AnalysisPhaseStartedEvent(targets));
  skyframeBuildView.setConfigurations(configurations);
  List<TargetAndConfiguration> nodes=nodesForTargets(configurations,targets);
  List<ConfiguredTargetKey> targetSpecs=Lists.transform(nodes,new Function<TargetAndConfiguration,ConfiguredTargetKey>(){
    @Override public ConfiguredTargetKey apply(    TargetAndConfiguration node){
      return new ConfiguredTargetKey(node.getLabel(),node.getConfiguration());
    }
  }
);
  List<AspectValueKey> aspectKeys=new ArrayList<>();
  for (  String aspect : aspects) {
    int delimiterPosition=aspect.indexOf('%');
    if (delimiterPosition >= 0) {
      PathFragment bzlFile=new PathFragment(""String_Node_Str"" + aspect.substring(0,delimiterPosition));
      String skylarkFunctionName=aspect.substring(delimiterPosition + 1);
      for (      ConfiguredTargetKey targetSpec : targetSpecs) {
        aspectKeys.add(AspectValue.createSkylarkAspectKey(targetSpec.getLabel(),targetSpec.getConfiguration(),bzlFile,skylarkFunctionName));
      }
    }
 else {
      final Class<? extends ConfiguredNativeAspectFactory> aspectFactoryClass=ruleClassProvider.getAspectFactoryMap().get(aspect).asSubclass(ConfiguredNativeAspectFactory.class);
      if (aspectFactoryClass != null) {
        for (        ConfiguredTargetKey targetSpec : targetSpecs) {
          aspectKeys.add(AspectValue.createAspectKey(targetSpec.getLabel(),targetSpec.getConfiguration(),new NativeAspectClass<ConfiguredNativeAspectFactory>(aspectFactoryClass)));
        }
      }
 else {
        throw new ViewCreationFailedException(""String_Node_Str"" + aspect + ""String_Node_Str"");
      }
    }
  }
  if (loadingEnabled) {
    setArtifactRoots(loadingResult.getPackageRoots(),configurations);
  }
  prepareToBuild(configurations,new SkyframePackageRootResolver(skyframeExecutor,eventHandler));
  skyframeExecutor.injectWorkspaceStatusData();
  SkyframeAnalysisResult skyframeAnalysisResult;
  try {
    skyframeAnalysisResult=skyframeBuildView.configureTargets(eventHandler,targetSpecs,aspectKeys,eventBus,viewOptions.keepGoing);
    setArtifactRoots(skyframeAnalysisResult.getPackageRoots(),configurations);
  }
  finally {
    skyframeBuildView.clearInvalidatedConfiguredTargets();
  }
  int numTargetsToAnalyze=nodes.size();
  int numSuccessful=skyframeAnalysisResult.getConfiguredTargets().size();
  boolean analysisSuccessful=(numSuccessful == numTargetsToAnalyze);
  if (0 < numSuccessful && numSuccessful < numTargetsToAnalyze) {
    String msg=String.format(""String_Node_Str"",numSuccessful,numTargetsToAnalyze);
    eventHandler.handle(Event.info(msg));
    LOG.info(msg);
  }
  AnalysisResult result=createResult(eventHandler,loadingResult,topLevelOptions,viewOptions,skyframeAnalysisResult.getConfiguredTargets(),skyframeAnalysisResult.getAspects(),skyframeAnalysisResult.getWalkableGraph(),skyframeAnalysisResult.getPackageRoots(),analysisSuccessful);
  LOG.info(""String_Node_Str"");
  return result;
}","@ThreadCompatible public AnalysisResult update(LoadingResult loadingResult,BuildConfigurationCollection configurations,List<String> aspects,Options viewOptions,TopLevelArtifactContext topLevelOptions,EventHandler eventHandler,EventBus eventBus,boolean loadingEnabled) throws ViewCreationFailedException, InterruptedException {
  LOG.info(""String_Node_Str"");
  pollInterruptedStatus();
  skyframeBuildView.resetEvaluatedConfiguredTargetKeysSet();
  Collection<Target> targets=loadingResult.getTargets();
  eventBus.post(new AnalysisPhaseStartedEvent(targets));
  skyframeBuildView.setConfigurations(configurations);
  List<TargetAndConfiguration> nodes=nodesForTargets(configurations,targets);
  List<ConfiguredTargetKey> targetSpecs=Lists.transform(nodes,new Function<TargetAndConfiguration,ConfiguredTargetKey>(){
    @Override public ConfiguredTargetKey apply(    TargetAndConfiguration node){
      return new ConfiguredTargetKey(node.getLabel(),node.getConfiguration());
    }
  }
);
  List<AspectValueKey> aspectKeys=new ArrayList<>();
  for (  String aspect : aspects) {
    int delimiterPosition=aspect.indexOf('%');
    if (delimiterPosition >= 0) {
      PathFragment bzlFile=new PathFragment(""String_Node_Str"" + aspect.substring(0,delimiterPosition));
      String skylarkFunctionName=aspect.substring(delimiterPosition + 1);
      for (      ConfiguredTargetKey targetSpec : targetSpecs) {
        aspectKeys.add(AspectValue.createSkylarkAspectKey(targetSpec.getLabel(),targetSpec.getConfiguration(),bzlFile,skylarkFunctionName));
      }
    }
 else {
      final Class<? extends ConfiguredNativeAspectFactory> aspectFactoryClass=ruleClassProvider.getAspectFactoryMap().get(aspect).asSubclass(ConfiguredNativeAspectFactory.class);
      if (aspectFactoryClass != null) {
        for (        ConfiguredTargetKey targetSpec : targetSpecs) {
          aspectKeys.add(AspectValue.createAspectKey(targetSpec.getLabel(),targetSpec.getConfiguration(),new NativeAspectClass<ConfiguredNativeAspectFactory>(aspectFactoryClass)));
        }
      }
 else {
        throw new ViewCreationFailedException(""String_Node_Str"" + aspect + ""String_Node_Str"");
      }
    }
  }
  if (loadingEnabled) {
    setArtifactRoots(loadingResult.getPackageRoots(),configurations);
  }
  prepareToBuild(configurations,new SkyframePackageRootResolver(skyframeExecutor,eventHandler));
  skyframeExecutor.injectWorkspaceStatusData();
  SkyframeAnalysisResult skyframeAnalysisResult;
  try {
    skyframeAnalysisResult=skyframeBuildView.configureTargets(eventHandler,targetSpecs,aspectKeys,eventBus,viewOptions.keepGoing);
    setArtifactRoots(skyframeAnalysisResult.getPackageRoots(),configurations);
  }
  finally {
    skyframeBuildView.clearInvalidatedConfiguredTargets();
  }
  int numTargetsToAnalyze=nodes.size();
  int numSuccessful=skyframeAnalysisResult.getConfiguredTargets().size();
  if (0 < numSuccessful && numSuccessful < numTargetsToAnalyze) {
    String msg=String.format(""String_Node_Str"",numSuccessful,numTargetsToAnalyze);
    eventHandler.handle(Event.info(msg));
    LOG.info(msg);
  }
  boolean analysisSuccessful=!skyframeAnalysisResult.hasError();
  AnalysisResult result=createResult(eventHandler,loadingResult,topLevelOptions,viewOptions,skyframeAnalysisResult.getConfiguredTargets(),skyframeAnalysisResult.getAspects(),skyframeAnalysisResult.getWalkableGraph(),skyframeAnalysisResult.getPackageRoots(),analysisSuccessful);
  LOG.info(""String_Node_Str"");
  return result;
}",0.98076370944588
110943,"public SkyframeAnalysisResult(ImmutableList<ConfiguredTarget> configuredTargets,WalkableGraph walkableGraph,ImmutableList<AspectValue> aspects,ImmutableMap<PackageIdentifier,Path> packageRoots){
  this.configuredTargets=configuredTargets;
  this.walkableGraph=walkableGraph;
  this.aspects=aspects;
  this.packageRoots=packageRoots;
}","public SkyframeAnalysisResult(boolean hasError,ImmutableList<ConfiguredTarget> configuredTargets,WalkableGraph walkableGraph,ImmutableList<AspectValue> aspects,ImmutableMap<PackageIdentifier,Path> packageRoots){
  this.hasError=hasError;
  this.configuredTargets=configuredTargets;
  this.walkableGraph=walkableGraph;
  this.aspects=aspects;
  this.packageRoots=packageRoots;
}",0.939521800281294
110944,"@Nullable @Override public SkyValue compute(SkyKey skyKey,Environment env) throws LoadSkylarkAspectFunctionException, InterruptedException {
  SkylarkAspectLoadingKey aspectLoadingKey=(SkylarkAspectLoadingKey)skyKey.argument();
  String skylarkValueName=aspectLoadingKey.getSkylarkValueName();
  PathFragment extensionFile=aspectLoadingKey.getExtensionFile();
  ImmutableMap<PathFragment,Label> labelLookupMap;
  try {
    labelLookupMap=SkylarkImportLookupFunction.labelsForAbsoluteImports(ImmutableSet.of(extensionFile),env);
  }
 catch (  SkylarkImportFailedException e) {
    env.getListener().handle(Event.error(e.getMessage()));
    throw new LoadSkylarkAspectFunctionException(new AspectCreationException(e.getMessage()),skyKey);
  }
  if (labelLookupMap == null) {
    return null;
  }
  SkylarkAspect skylarkAspect=null;
  try {
    skylarkAspect=AspectFunction.loadSkylarkAspect(env,labelLookupMap.get(extensionFile),skylarkValueName);
  }
 catch (  AspectCreationException e) {
    throw new LoadSkylarkAspectFunctionException(e,skyKey);
  }
  if (skylarkAspect == null) {
    return null;
  }
  SkyKey aspectKey=AspectValue.key(aspectLoadingKey.getTargetLabel(),aspectLoadingKey.getTargetConfiguration(),skylarkAspect.getAspectClass(),AspectParameters.EMPTY);
  return env.getValue(aspectKey);
}","@Nullable @Override public SkyValue compute(SkyKey skyKey,Environment env) throws LoadSkylarkAspectFunctionException, InterruptedException {
  SkylarkAspectLoadingKey aspectLoadingKey=(SkylarkAspectLoadingKey)skyKey.argument();
  String skylarkValueName=aspectLoadingKey.getSkylarkValueName();
  PathFragment extensionFile=aspectLoadingKey.getExtensionFile();
  ImmutableMap<PathFragment,Label> labelLookupMap;
  try {
    labelLookupMap=SkylarkImportLookupFunction.labelsForAbsoluteImports(ImmutableSet.of(extensionFile),env);
  }
 catch (  SkylarkImportFailedException e) {
    env.getListener().handle(Event.error(e.getMessage()));
    throw new LoadSkylarkAspectFunctionException(new AspectCreationException(e.getMessage()));
  }
  if (labelLookupMap == null) {
    return null;
  }
  SkylarkAspect skylarkAspect=null;
  try {
    skylarkAspect=AspectFunction.loadSkylarkAspect(env,labelLookupMap.get(extensionFile),skylarkValueName);
  }
 catch (  AspectCreationException e) {
    throw new LoadSkylarkAspectFunctionException(e);
  }
  if (skylarkAspect == null) {
    return null;
  }
  SkyKey aspectKey=AspectValue.key(aspectLoadingKey.getTargetLabel(),aspectLoadingKey.getTargetConfiguration(),skylarkAspect.getAspectClass(),AspectParameters.EMPTY);
  return env.getValue(aspectKey);
}",0.9946153846153846
110945,"public LoadSkylarkAspectFunctionException(AspectCreationException cause,SkyKey childKey){
  super(cause,childKey);
}","public LoadSkylarkAspectFunctionException(AspectCreationException cause){
  super(cause,Transience.PERSISTENT);
}",0.8209606986899564
110946,"/** 
 * Tests that rules with configurable attributes can be accessed through   {@link com.google.devtools.build.lib.skyframe.PostConfiguredTargetFunction}. This is a regression test for a Bazel crash.
 */
@Test public void testPostProcessedConfigurableAttributes() throws Exception {
  reporter.removeHandler(failFastHandler);
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  AnalysisResult result=update(defaultFlags().with(Flag.KEEP_GOING),""String_Node_Str"",""String_Node_Str"");
  assertContainsEvent(""String_Node_Str"");
}","/** 
 * Tests that rules with configurable attributes can be accessed through   {@link com.google.devtools.build.lib.skyframe.PostConfiguredTargetFunction}. This is a regression test for a Bazel crash.
 */
@Test public void testPostProcessedConfigurableAttributes() throws Exception {
  reporter.removeHandler(failFastHandler);
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  AnalysisResult result=update(defaultFlags().with(Flag.KEEP_GOING),""String_Node_Str"",""String_Node_Str"");
  assertThat(result.hasError()).isTrue();
  assertContainsEvent(""String_Node_Str"");
}",0.9642248722316864
110947,"@Test public void topLevelAspectIsNotAnAspect() throws Exception {
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  reporter.removeHandler(failFastHandler);
  try {
    update(ImmutableList.of(""String_Node_Str""),""String_Node_Str"");
    fail();
  }
 catch (  ViewCreationFailedException e) {
  }
  assertContainsEvent(""String_Node_Str"");
}","@Test public void topLevelAspectIsNotAnAspect() throws Exception {
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  reporter.removeHandler(failFastHandler);
  try {
    AnalysisResult result=update(ImmutableList.of(""String_Node_Str""),""String_Node_Str"");
    assertThat(keepGoing()).isTrue();
    assertThat(result.hasError()).isTrue();
  }
 catch (  ViewCreationFailedException e) {
  }
  assertContainsEvent(""String_Node_Str"");
}",0.8871331828442438
110948,"@Test public void topLevelAspectDoesNotExist2() throws Exception {
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  reporter.removeHandler(failFastHandler);
  try {
    update(ImmutableList.of(""String_Node_Str""),""String_Node_Str"");
    fail();
  }
 catch (  ViewCreationFailedException e) {
  }
  assertContainsEvent(""String_Node_Str"" + ""String_Node_Str"");
}","@Test public void topLevelAspectDoesNotExist2() throws Exception {
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  reporter.removeHandler(failFastHandler);
  try {
    AnalysisResult result=update(ImmutableList.of(""String_Node_Str""),""String_Node_Str"");
    assertThat(keepGoing()).isTrue();
    assertThat(result.hasError()).isTrue();
  }
 catch (  ViewCreationFailedException e) {
  }
  assertContainsEvent(""String_Node_Str"" + ""String_Node_Str"");
}",0.8780487804878049
110949,"@Test public void topLevelAspectDoesNotExist() throws Exception {
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  reporter.removeHandler(failFastHandler);
  try {
    update(ImmutableList.of(""String_Node_Str""),""String_Node_Str"");
    fail();
  }
 catch (  ViewCreationFailedException e) {
  }
  assertContainsEvent(""String_Node_Str"");
}","@Test public void topLevelAspectDoesNotExist() throws Exception {
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  reporter.removeHandler(failFastHandler);
  try {
    AnalysisResult result=update(ImmutableList.of(""String_Node_Str""),""String_Node_Str"");
    assertThat(keepGoing()).isTrue();
    assertThat(result.hasError()).isTrue();
  }
 catch (  ViewCreationFailedException e) {
  }
  assertContainsEvent(""String_Node_Str"");
}",0.8868778280542986
110950,"@Test public void testAspectFailingOrphanArtifacts() throws Exception {
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  reporter.removeHandler(failFastHandler);
  try {
    update(ImmutableList.of(""String_Node_Str""),""String_Node_Str"");
    fail();
  }
 catch (  ViewCreationFailedException e) {
  }
  assertContainsEvent(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","@Test public void testAspectFailingOrphanArtifacts() throws Exception {
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  reporter.removeHandler(failFastHandler);
  try {
    AnalysisResult result=update(ImmutableList.of(""String_Node_Str""),""String_Node_Str"");
    assertThat(keepGoing()).isTrue();
    assertThat(result.hasError()).isTrue();
  }
 catch (  ViewCreationFailedException e) {
  }
  assertContainsEvent(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.918962722852512
110951,"@Test public void topLevelAspectDoesNotExistNoBuildFile() throws Exception {
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  reporter.removeHandler(failFastHandler);
  try {
    update(ImmutableList.of(""String_Node_Str""),""String_Node_Str"");
    fail();
  }
 catch (  ViewCreationFailedException e) {
  }
  assertContainsEvent(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
}","@Test public void topLevelAspectDoesNotExistNoBuildFile() throws Exception {
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  reporter.removeHandler(failFastHandler);
  try {
    AnalysisResult result=update(ImmutableList.of(""String_Node_Str""),""String_Node_Str"");
    assertThat(keepGoing()).isTrue();
    assertThat(result.hasError()).isTrue();
  }
 catch (  ViewCreationFailedException e) {
  }
  assertContainsEvent(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
}",0.8863636363636364
110952,"@Test public void testAspectFailingReturnsUnsafeObject() throws Exception {
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  reporter.removeHandler(failFastHandler);
  try {
    update(ImmutableList.of(""String_Node_Str""),""String_Node_Str"");
    fail();
  }
 catch (  ViewCreationFailedException e) {
  }
  assertContainsEvent(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","@Test public void testAspectFailingReturnsUnsafeObject() throws Exception {
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  reporter.removeHandler(failFastHandler);
  try {
    AnalysisResult result=update(ImmutableList.of(""String_Node_Str""),""String_Node_Str"");
    assertThat(keepGoing()).isTrue();
    assertThat(result.hasError()).isTrue();
  }
 catch (  ViewCreationFailedException e) {
  }
  assertContainsEvent(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9193548387096774
110953,"@Test public void testAspectFailingExecution() throws Exception {
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  reporter.removeHandler(failFastHandler);
  try {
    update(ImmutableList.of(""String_Node_Str""),""String_Node_Str"");
    fail();
  }
 catch (  ViewCreationFailedException e) {
  }
  assertContainsEvent(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","@Test public void testAspectFailingExecution() throws Exception {
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  reporter.removeHandler(failFastHandler);
  try {
    AnalysisResult result=update(ImmutableList.of(""String_Node_Str""),""String_Node_Str"");
    assertThat(keepGoing()).isTrue();
    assertThat(result.hasError()).isTrue();
  }
 catch (  ViewCreationFailedException e) {
  }
  assertContainsEvent(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9207606973058636
110954,"private ConfiguredTarget getConfiguredTargetForAspectFragment(String fullFieldName,String fragments,String hostFragments,String ruleFragments,String ruleHostFragments) throws Exception {
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + fullFieldName + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + fragments + ""String_Node_Str"",""String_Node_Str"" + hostFragments + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ruleFragments + ""String_Node_Str"",""String_Node_Str"" + ruleHostFragments + ""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  update(ImmutableList.of(""String_Node_Str""),""String_Node_Str"");
  return getConfiguredTarget(""String_Node_Str"");
}","private ConfiguredTarget getConfiguredTargetForAspectFragment(String fullFieldName,String fragments,String hostFragments,String ruleFragments,String ruleHostFragments) throws Exception {
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + fullFieldName + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + fragments + ""String_Node_Str"",""String_Node_Str"" + hostFragments + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ruleFragments + ""String_Node_Str"",""String_Node_Str"" + ruleHostFragments + ""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  AnalysisResult result=update(ImmutableList.of(""String_Node_Str""),""String_Node_Str"");
  if (result.hasError()) {
    assertThat(keepGoing()).isTrue();
    throw new ViewCreationFailedException(""String_Node_Str"");
  }
  return getConfiguredTarget(""String_Node_Str"");
}",0.9335071707953064
110955,"@Test public void testAspectFailingReturnsNotAStruct() throws Exception {
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  reporter.removeHandler(failFastHandler);
  try {
    update(ImmutableList.of(""String_Node_Str""),""String_Node_Str"");
    fail();
  }
 catch (  ViewCreationFailedException e) {
  }
  assertContainsEvent(""String_Node_Str"");
}","@Test public void testAspectFailingReturnsNotAStruct() throws Exception {
  scratch.file(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  scratch.file(""String_Node_Str"",""String_Node_Str"");
  reporter.removeHandler(failFastHandler);
  try {
    AnalysisResult result=update(ImmutableList.of(""String_Node_Str""),""String_Node_Str"");
    assertThat(keepGoing()).isTrue();
    assertThat(result.hasError()).isTrue();
  }
 catch (  ViewCreationFailedException e) {
  }
  assertContainsEvent(""String_Node_Str"");
}",0.9007936507936508
110956,"/** 
 * Process the Skyframe update, taking into account the keepGoing setting. <p>Returns false if the update() failed, but we should continue. Returns true on success. Throws on fail-fast failures.
 */
private static boolean processResult(EventHandler eventHandler,EvaluationResult<?> result,boolean keepGoing,SkyframeExecutor skyframeExecutor) throws BuildFailedException, TestExecException {
  if (result.hasError()) {
    boolean hasCycles=false;
    for (    Map.Entry<SkyKey,ErrorInfo> entry : result.errorMap().entrySet()) {
      Iterable<CycleInfo> cycles=entry.getValue().getCycleInfo();
      skyframeExecutor.reportCycles(eventHandler,cycles,entry.getKey());
      hasCycles|=!Iterables.isEmpty(cycles);
    }
    boolean hasCatastrophe=resultHasCatastrophicError(result);
    if (keepGoing && !hasCatastrophe) {
      return false;
    }
    if (hasCycles || result.errorMap().isEmpty()) {
      if (result.getCatastrophe() != null) {
        rethrow(result.getCatastrophe());
      }
      throw new BuildFailedException(null,hasCatastrophe);
    }
 else {
      rethrow(Preconditions.checkNotNull(result.getError().getException()));
    }
  }
  return true;
}","/** 
 * Process the Skyframe update, taking into account the keepGoing setting. <p>Returns false if the update() failed, but we should continue. Returns true on success. Throws on fail-fast failures.
 */
private static boolean processResult(EventHandler eventHandler,EvaluationResult<?> result,boolean keepGoing,SkyframeExecutor skyframeExecutor) throws BuildFailedException, TestExecException {
  if (result.hasError()) {
    for (    Map.Entry<SkyKey,ErrorInfo> entry : result.errorMap().entrySet()) {
      Iterable<CycleInfo> cycles=entry.getValue().getCycleInfo();
      skyframeExecutor.reportCycles(eventHandler,cycles,entry.getKey());
    }
    if (result.getCatastrophe() != null) {
      rethrow(result.getCatastrophe());
    }
    if (keepGoing) {
      return false;
    }
    ErrorInfo errorInfo=Preconditions.checkNotNull(result.getError(),result);
    Exception exception=errorInfo.getException();
    if (exception == null) {
      Preconditions.checkState(!Iterables.isEmpty(errorInfo.getCycleInfo()),errorInfo);
      throw new BuildFailedException(null,false);
    }
 else {
      rethrow(exception);
    }
  }
  return true;
}",0.5937096079276174
110957,"/** 
 * Constructor for the ""completed"" case. Used only by   {@link Builder}.
 */
private EvaluationResult(Map<SkyKey,T> result,Map<SkyKey,ErrorInfo> errorMap,boolean hasError,@Nullable Exception catastrophe,@Nullable WalkableGraph walkableGraph){
  Preconditions.checkState(errorMap.isEmpty() || hasError,""String_Node_Str"",result,errorMap);
  this.resultMap=Preconditions.checkNotNull(result);
  this.errorMap=Preconditions.checkNotNull(errorMap);
  this.hasError=hasError;
  this.catastrophe=catastrophe;
  this.walkableGraph=walkableGraph;
}","/** 
 * Constructor for the ""completed"" case. Used only by   {@link Builder}.
 */
private EvaluationResult(Map<SkyKey,T> result,Map<SkyKey,ErrorInfo> errorMap,@Nullable Exception catastrophe,@Nullable WalkableGraph walkableGraph){
  this.resultMap=Preconditions.checkNotNull(result);
  this.errorMap=Preconditions.checkNotNull(errorMap);
  this.catastrophe=catastrophe;
  this.walkableGraph=walkableGraph;
}",0.7066246056782335
110958,"public EvaluationResult<T> build(){
  return new EvaluationResult<>(result,errors,hasError,catastrophe,walkableGraph);
}","public EvaluationResult<T> build(){
  return new EvaluationResult<>(result,errors,catastrophe,walkableGraph);
}",0.961038961038961
110959,"public Builder<T> mergeFrom(EvaluationResult<T> otherResult){
  result.putAll(otherResult.resultMap);
  errors.putAll(otherResult.errorMap);
  hasError|=otherResult.hasError;
  catastrophe=otherResult.catastrophe;
  return this;
}","public Builder<T> mergeFrom(EvaluationResult<T> otherResult){
  result.putAll(otherResult.resultMap);
  errors.putAll(otherResult.errorMap);
  catastrophe=otherResult.catastrophe;
  return this;
}",0.92018779342723
110960,"@Override public String toString(){
  return MoreObjects.toStringHelper(this).add(""String_Node_Str"",hasError).add(""String_Node_Str"",errorMap).add(""String_Node_Str"",resultMap).toString();
}","@Override public String toString(){
  return MoreObjects.toStringHelper(this).add(""String_Node_Str"",catastrophe).add(""String_Node_Str"",errorMap).add(""String_Node_Str"",resultMap).toString();
}",0.9709762532981532
110961,"/** 
 * @return Whether or not the eval successfully evaluated all requested values. Note that thismay return true even if all values returned are available in get(). This happens if a top-level value depends transitively on some value that recovered from a  {@link SkyFunctionException}.
 */
public boolean hasError(){
  return hasError;
}","/** 
 * @return Whether or not the eval successfully evaluated all requested values. True iff{@link #getCatastrophe} or {@link #getError} returns non-null.
 */
public boolean hasError(){
  return catastrophe != null || !errorMap.isEmpty();
}",0.5025817555938038
110962,"/** 
 * Constructs an   {@link EvaluationResult} from the {@link #graph}.  Looks for cycles if there are unfinished nodes but no error was already found through bubbling up (as indicated by   {@code bubbleErrorInfo} being null).<p> {@code visitor} may be null, but only in the case where all graph entries corresponding to{@code skyKeys} are known to be in the DONE state ({@code entry.isDone()} returns true).
 */
private <T extends SkyValue>EvaluationResult<T> constructResult(@Nullable ValueVisitor visitor,Iterable<SkyKey> skyKeys,@Nullable Map<SkyKey,ValueWithMetadata> bubbleErrorInfo,boolean catastrophe){
  Preconditions.checkState(catastrophe == (keepGoing && bubbleErrorInfo != null),""String_Node_Str"",skyKeys,catastrophe,keepGoing,bubbleErrorInfo);
  EvaluationResult.Builder<T> result=EvaluationResult.builder();
  List<SkyKey> cycleRoots=new ArrayList<>();
  boolean hasError=false;
  for (  SkyKey skyKey : skyKeys) {
    ValueWithMetadata valueWithMetadata=getValueMaybeFromError(skyKey,bubbleErrorInfo);
    if (valueWithMetadata == null) {
      if (bubbleErrorInfo == null) {
        cycleRoots.add(skyKey);
      }
      hasError=true;
      continue;
    }
    SkyValue value=valueWithMetadata.getValue();
    replayingNestedSetEventVisitor.visit(valueWithMetadata.getTransitiveEvents());
    ErrorInfo errorInfo=valueWithMetadata.getErrorInfo();
    Preconditions.checkState(value != null || errorInfo != null,skyKey);
    hasError=hasError || (errorInfo != null);
    if (!keepGoing && errorInfo != null) {
      result.addError(skyKey,errorInfo);
      continue;
    }
    if (value == null) {
      result.addError(skyKey,errorInfo);
    }
 else {
      result.addResult(skyKey,value);
    }
  }
  if (!cycleRoots.isEmpty()) {
    Preconditions.checkState(visitor != null,skyKeys);
    checkForCycles(cycleRoots,result,visitor,keepGoing);
  }
  Preconditions.checkState(bubbleErrorInfo == null || hasError,""String_Node_Str"",bubbleErrorInfo,skyKeys);
  result.setHasError(hasError);
  if (catastrophe) {
    ErrorInfo errorInfo=Preconditions.checkNotNull(Iterables.getOnlyElement(bubbleErrorInfo.values()).getErrorInfo(),""String_Node_Str"",bubbleErrorInfo);
    Preconditions.checkState(errorInfo.isCatastrophic(),""String_Node_Str"",bubbleErrorInfo);
    result.setCatastrophe(errorInfo.getException());
  }
  return result.build();
}","/** 
 * Constructs an   {@link EvaluationResult} from the {@link #graph}.  Looks for cycles if there are unfinished nodes but no error was already found through bubbling up (as indicated by   {@code bubbleErrorInfo} being null).<p> {@code visitor} may be null, but only in the case where all graph entries corresponding to{@code skyKeys} are known to be in the DONE state ({@code entry.isDone()} returns true).
 */
private <T extends SkyValue>EvaluationResult<T> constructResult(@Nullable ValueVisitor visitor,Iterable<SkyKey> skyKeys,@Nullable Map<SkyKey,ValueWithMetadata> bubbleErrorInfo,boolean catastrophe){
  Preconditions.checkState(catastrophe == (keepGoing && bubbleErrorInfo != null),""String_Node_Str"",skyKeys,catastrophe,keepGoing,bubbleErrorInfo);
  EvaluationResult.Builder<T> result=EvaluationResult.builder();
  List<SkyKey> cycleRoots=new ArrayList<>();
  for (  SkyKey skyKey : skyKeys) {
    ValueWithMetadata valueWithMetadata=getValueMaybeFromError(skyKey,bubbleErrorInfo);
    if (valueWithMetadata == null) {
      if (bubbleErrorInfo == null) {
        cycleRoots.add(skyKey);
      }
      continue;
    }
    SkyValue value=valueWithMetadata.getValue();
    replayingNestedSetEventVisitor.visit(valueWithMetadata.getTransitiveEvents());
    ErrorInfo errorInfo=valueWithMetadata.getErrorInfo();
    Preconditions.checkState(value != null || errorInfo != null,skyKey);
    if (!keepGoing && errorInfo != null) {
      result.addError(skyKey,errorInfo);
      continue;
    }
    if (value == null) {
      result.addError(skyKey,errorInfo);
    }
 else {
      result.addResult(skyKey,value);
    }
  }
  if (!cycleRoots.isEmpty()) {
    Preconditions.checkState(visitor != null,skyKeys);
    checkForCycles(cycleRoots,result,visitor,keepGoing);
  }
  if (catastrophe) {
    ErrorInfo errorInfo=Preconditions.checkNotNull(Iterables.getOnlyElement(bubbleErrorInfo.values()).getErrorInfo(),""String_Node_Str"",bubbleErrorInfo);
    Preconditions.checkState(errorInfo.isCatastrophic(),""String_Node_Str"",bubbleErrorInfo);
    result.setCatastrophe(errorInfo.getException());
  }
  EvaluationResult<T> builtResult=result.build();
  Preconditions.checkState(bubbleErrorInfo == null || builtResult.hasError(),""String_Node_Str"",bubbleErrorInfo,skyKeys,builtResult);
  return builtResult;
}",0.6878488621726063
110963,"private WalkableGraph getGraphFromPatternsEvaluation(ImmutableList<String> patternSequence,boolean successExpected,boolean keepGoing) throws InterruptedException {
  SkyKey independentTarget=PrepareDepsOfPatternsValue.key(patternSequence,""String_Node_Str"");
  ImmutableList<SkyKey> singletonTargetPattern=ImmutableList.of(independentTarget);
  EvaluationResult<SkyValue> evaluationResult=getSkyframeExecutor().getDriverForTesting().evaluate(singletonTargetPattern,keepGoing,LOADING_PHASE_THREADS,eventCollector);
  if (successExpected) {
    assertFalse(evaluationResult.hasError());
  }
 else {
    assertTrue(evaluationResult.hasError());
  }
  return Preconditions.checkNotNull(evaluationResult.getWalkableGraph());
}","private WalkableGraph getGraphFromPatternsEvaluation(ImmutableList<String> patternSequence,boolean keepGoing) throws InterruptedException {
  SkyKey independentTarget=PrepareDepsOfPatternsValue.key(patternSequence,""String_Node_Str"");
  ImmutableList<SkyKey> singletonTargetPattern=ImmutableList.of(independentTarget);
  EvaluationResult<SkyValue> evaluationResult=getSkyframeExecutor().getDriverForTesting().evaluate(singletonTargetPattern,keepGoing,LOADING_PHASE_THREADS,eventCollector);
  assertThatEvaluationResult(evaluationResult).hasNoError();
  return Preconditions.checkNotNull(evaluationResult.getWalkableGraph());
}",0.8743494423791821
110964,"@Test public void testDependencyTraversalNoSuchPackageException() throws Exception {
  createFooWithDependencyOnMissingBarPackage();
  ImmutableList<String> patternSequence=ImmutableList.of(""String_Node_Str"");
  WalkableGraph walkableGraph=getGraphFromPatternsEvaluation(patternSequence,false);
  assertValidValue(walkableGraph,getKeyForLabel(Label.create(""String_Node_Str"",""String_Node_Str"")),true);
  Exception e=assertException(walkableGraph,getKeyForLabel(Label.create(""String_Node_Str"",""String_Node_Str"")));
  assertThat(e).isInstanceOf(NoSuchPackageException.class);
}","@Test public void testDependencyTraversalNoSuchPackageException() throws Exception {
  createFooWithDependencyOnMissingBarPackage();
  ImmutableList<String> patternSequence=ImmutableList.of(""String_Node_Str"");
  WalkableGraph walkableGraph=getGraphFromPatternsEvaluation(patternSequence);
  assertValidValue(walkableGraph,getKeyForLabel(Label.create(""String_Node_Str"",""String_Node_Str"")),true);
  Exception e=assertException(walkableGraph,getKeyForLabel(Label.create(""String_Node_Str"",""String_Node_Str"")));
  assertThat(e).isInstanceOf(NoSuchPackageException.class);
}",0.9947460595446584
110965,"private void parsingProblem(boolean keepGoing) throws Exception {
  createFooAndFoo2(false);
  String bogusPattern=""String_Node_Str"";
  ImmutableList<String> patternSequence=ImmutableList.of(bogusPattern,""String_Node_Str"");
  WalkableGraph walkableGraph=getGraphFromPatternsEvaluation(patternSequence,true,keepGoing);
  assertContainsEvent(""String_Node_Str"" + bogusPattern + ""String_Node_Str"");
  assertTrue(walkableGraph.exists(getKeyForLabel(Label.create(""String_Node_Str"",""String_Node_Str""))));
}","private void parsingProblem(boolean keepGoing) throws Exception {
  createFooAndFoo2(false);
  String bogusPattern=""String_Node_Str"";
  ImmutableList<String> patternSequence=ImmutableList.of(bogusPattern,""String_Node_Str"");
  WalkableGraph walkableGraph=getGraphFromPatternsEvaluation(patternSequence,keepGoing);
  assertContainsEvent(""String_Node_Str"" + bogusPattern + ""String_Node_Str"");
  assertTrue(walkableGraph.exists(getKeyForLabel(Label.create(""String_Node_Str"",""String_Node_Str""))));
}",0.9949647532729105
110966,"@Test public void testFunctionLoadsTargetAndNotUnspecifiedTargets() throws Exception {
  createFooAndFoo2(false);
  ImmutableList<String> patternSequence=ImmutableList.of(""String_Node_Str"");
  WalkableGraph walkableGraph=getGraphFromPatternsEvaluation(patternSequence,true);
  assertValidValue(walkableGraph,getKeyForLabel(Label.create(""String_Node_Str"",""String_Node_Str"")));
  assertFalse(walkableGraph.exists(getKeyForLabel(Label.create(""String_Node_Str"",""String_Node_Str""))));
}","@Test public void testFunctionLoadsTargetAndNotUnspecifiedTargets() throws Exception {
  createFooAndFoo2(false);
  ImmutableList<String> patternSequence=ImmutableList.of(""String_Node_Str"");
  WalkableGraph walkableGraph=getGraphFromPatternsEvaluation(patternSequence);
  assertValidValue(walkableGraph,getKeyForLabel(Label.create(""String_Node_Str"",""String_Node_Str"")));
  assertFalse(walkableGraph.exists(getKeyForLabel(Label.create(""String_Node_Str"",""String_Node_Str""))));
}",0.6290491118077325
110967,"@Test public void testFunctionLoadsTargetDependencies() throws Exception {
  createFooAndFoo2(true);
  ImmutableList<String> patternSequence=ImmutableList.of(""String_Node_Str"");
  WalkableGraph walkableGraph=getGraphFromPatternsEvaluation(patternSequence,true);
  assertValidValue(walkableGraph,getKeyForLabel(Label.create(""String_Node_Str"",""String_Node_Str"")));
}","@Test public void testFunctionLoadsTargetDependencies() throws Exception {
  createFooAndFoo2(true);
  ImmutableList<String> patternSequence=ImmutableList.of(""String_Node_Str"");
  WalkableGraph walkableGraph=getGraphFromPatternsEvaluation(patternSequence);
  assertValidValue(walkableGraph,getKeyForLabel(Label.create(""String_Node_Str"",""String_Node_Str"")));
}",0.7164591977869986
110968,"@Test public void testFunctionExpandsTargetPatterns() throws Exception {
  createFooAndFoo2(false);
  ImmutableList<String> patternSequence=ImmutableList.of(""String_Node_Str"");
  WalkableGraph walkableGraph=getGraphFromPatternsEvaluation(patternSequence,true);
  assertValidValue(walkableGraph,getKeyForLabel(Label.create(""String_Node_Str"",""String_Node_Str"")));
  assertValidValue(walkableGraph,getKeyForLabel(Label.create(""String_Node_Str"",""String_Node_Str"")));
}","@Test public void testFunctionExpandsTargetPatterns() throws Exception {
  createFooAndFoo2(false);
  ImmutableList<String> patternSequence=ImmutableList.of(""String_Node_Str"");
  WalkableGraph walkableGraph=getGraphFromPatternsEvaluation(patternSequence);
  assertValidValue(walkableGraph,getKeyForLabel(Label.create(""String_Node_Str"",""String_Node_Str"")));
  assertValidValue(walkableGraph,getKeyForLabel(Label.create(""String_Node_Str"",""String_Node_Str"")));
}",0.7778981581798483
110969,"@Test public void testDependencyTraversalNoSuchTargetException() throws Exception {
  createFooWithDependencyOnBarPackageWithMissingTarget();
  ImmutableList<String> patternSequence=ImmutableList.of(""String_Node_Str"");
  WalkableGraph walkableGraph=getGraphFromPatternsEvaluation(patternSequence,false);
  assertValidValue(walkableGraph,getKeyForLabel(Label.create(""String_Node_Str"",""String_Node_Str"")),true);
  Exception e=assertException(walkableGraph,getKeyForLabel(Label.create(""String_Node_Str"",""String_Node_Str"")));
  assertThat(e).isInstanceOf(NoSuchTargetException.class);
}","@Test public void testDependencyTraversalNoSuchTargetException() throws Exception {
  createFooWithDependencyOnBarPackageWithMissingTarget();
  ImmutableList<String> patternSequence=ImmutableList.of(""String_Node_Str"");
  WalkableGraph walkableGraph=getGraphFromPatternsEvaluation(patternSequence);
  assertValidValue(walkableGraph,getKeyForLabel(Label.create(""String_Node_Str"",""String_Node_Str"")),true);
  Exception e=assertException(walkableGraph,getKeyForLabel(Label.create(""String_Node_Str"",""String_Node_Str"")));
  assertThat(e).isInstanceOf(NoSuchTargetException.class);
}",0.9948186528497408
110970,"@Test public void testTargetParsingException() throws Exception {
  String nonexistentTarget=""String_Node_Str"";
  ImmutableList<String> patternSequence=ImmutableList.of(nonexistentTarget);
  WalkableGraph walkableGraph=getGraphFromPatternsEvaluation(patternSequence,false);
  assertFalse(walkableGraph.exists(getKeyForLabel(Label.create(""String_Node_Str"",""String_Node_Str""))));
}","@Test public void testTargetParsingException() throws Exception {
  String nonexistentTarget=""String_Node_Str"";
  ImmutableList<String> patternSequence=ImmutableList.of(nonexistentTarget);
  WalkableGraph walkableGraph=getGraphFromPatternsEvaluation(patternSequence);
  assertFalse(walkableGraph.exists(getKeyForLabel(Label.create(""String_Node_Str"",""String_Node_Str""))));
}",0.9920212765957448
110971,"@Override protected void invalidPackageGroupReferenceHook(TargetAndConfiguration node,Label label){
}","@Override protected void invalidPackageGroupReferenceHook(TargetAndConfiguration node,Label label){
  throw new RuntimeException(""String_Node_Str"" + label + ""String_Node_Str"");
}",0.7240143369175627
110972,"@VisibleForTesting public Iterable<Dependency> getDirectPrerequisiteDependenciesForIdeInfo(final EventHandler eventHandler,ConfiguredTarget ct,@Nullable final LoadingCache<Label,Target> targetCache,BuildConfigurationCollection configurations) throws InterruptedException {
  if (!(ct.getTarget() instanceof Rule)) {
    return ImmutableList.of();
  }
class SilentDependencyResolver extends DependencyResolver {
    @Override protected void invalidVisibilityReferenceHook(    TargetAndConfiguration node,    Label label){
    }
    @Override protected void invalidPackageGroupReferenceHook(    TargetAndConfiguration node,    Label label){
    }
    @Override protected Target getTarget(    Label label){
      if (targetCache == null) {
        try {
          return LoadedPackageProvider.Bridge.getLoadedTarget(skyframeExecutor.getPackageManager(),eventHandler,label);
        }
 catch (        NoSuchThingException e) {
          throw new IllegalStateException(e);
        }
      }
      try {
        return targetCache.get(label);
      }
 catch (      ExecutionException e) {
        throw new IllegalStateException(e);
      }
    }
  }
  DependencyResolver dependencyResolver=new SilentDependencyResolver();
  TargetAndConfiguration ctgNode=new TargetAndConfiguration(ct.getTarget(),ct.getConfiguration());
  try {
    return ImmutableSet.copyOf(dependencyResolver.dependentNodeMap(ctgNode,configurations.getHostConfiguration(),null,getConfigurableAttributeKeysForTesting(eventHandler,ctgNode)).values());
  }
 catch (  EvalException e) {
    throw new IllegalStateException(e);
  }
}","@VisibleForTesting public Iterable<Dependency> getDirectPrerequisiteDependenciesForIdeInfo(final EventHandler eventHandler,ConfiguredTarget ct,@Nullable final LoadingCache<Label,Target> targetCache,BuildConfigurationCollection configurations) throws InterruptedException {
  if (!(ct.getTarget() instanceof Rule)) {
    return ImmutableList.of();
  }
class SilentDependencyResolver extends DependencyResolver {
    @Override protected void invalidVisibilityReferenceHook(    TargetAndConfiguration node,    Label label){
    }
    @Override protected void invalidPackageGroupReferenceHook(    TargetAndConfiguration node,    Label label){
    }
    @Override protected void missingEdgeHook(    Target from,    Label to,    NoSuchThingException e){
    }
    @Override protected Target getTarget(    Label label){
      if (targetCache == null) {
        try {
          return LoadedPackageProvider.Bridge.getLoadedTarget(skyframeExecutor.getPackageManager(),eventHandler,label);
        }
 catch (        NoSuchThingException e) {
          throw new IllegalStateException(e);
        }
      }
      try {
        return targetCache.get(label);
      }
 catch (      ExecutionException e) {
        throw new IllegalStateException(e);
      }
    }
  }
  DependencyResolver dependencyResolver=new SilentDependencyResolver();
  TargetAndConfiguration ctgNode=new TargetAndConfiguration(ct.getTarget(),ct.getConfiguration());
  try {
    return ImmutableSet.copyOf(dependencyResolver.dependentNodeMap(ctgNode,configurations.getHostConfiguration(),null,getConfigurableAttributeKeysForTesting(eventHandler,ctgNode)).values());
  }
 catch (  EvalException e) {
    throw new IllegalStateException(e);
  }
}",0.8419775553533515
110973,"@Override protected void invalidVisibilityReferenceHook(TargetAndConfiguration node,Label label){
}","@Override protected void invalidVisibilityReferenceHook(TargetAndConfiguration node,Label label){
  throw new RuntimeException(""String_Node_Str"" + label + ""String_Node_Str"");
}",0.72
110974,"@VisibleForTesting public ListMultimap<Attribute,Dependency> getDirectPrerequisiteDependenciesForTesting(final EventHandler eventHandler,ConfiguredTarget ct,BuildConfigurationCollection configurations) throws EvalException, InterruptedException {
  if (!(ct.getTarget() instanceof Rule)) {
    return ArrayListMultimap.create();
  }
class SilentDependencyResolver extends DependencyResolver {
    @Override protected void invalidVisibilityReferenceHook(    TargetAndConfiguration node,    Label label){
    }
    @Override protected void invalidPackageGroupReferenceHook(    TargetAndConfiguration node,    Label label){
    }
    @Override protected Target getTarget(    Label label) throws NoSuchThingException {
      return LoadedPackageProvider.Bridge.getLoadedTarget(skyframeExecutor.getPackageManager(),eventHandler,label);
    }
  }
  DependencyResolver dependencyResolver=new SilentDependencyResolver();
  TargetAndConfiguration ctgNode=new TargetAndConfiguration(ct.getTarget(),ct.getConfiguration());
  return dependencyResolver.dependentNodeMap(ctgNode,configurations.getHostConfiguration(),null,getConfigurableAttributeKeysForTesting(eventHandler,ctgNode));
}","@VisibleForTesting public ListMultimap<Attribute,Dependency> getDirectPrerequisiteDependenciesForTesting(final EventHandler eventHandler,ConfiguredTarget ct,BuildConfigurationCollection configurations) throws EvalException, InterruptedException {
  if (!(ct.getTarget() instanceof Rule)) {
    return ArrayListMultimap.create();
  }
class SilentDependencyResolver extends DependencyResolver {
    @Override protected void invalidVisibilityReferenceHook(    TargetAndConfiguration node,    Label label){
      throw new RuntimeException(""String_Node_Str"" + label + ""String_Node_Str"");
    }
    @Override protected void invalidPackageGroupReferenceHook(    TargetAndConfiguration node,    Label label){
      throw new RuntimeException(""String_Node_Str"" + label + ""String_Node_Str"");
    }
    @Override protected void missingEdgeHook(    Target from,    Label to,    NoSuchThingException e){
      throw new RuntimeException(""String_Node_Str"" + from.getLabel() + ""String_Node_Str""+ to+ ""String_Node_Str""+ e.getMessage(),e);
    }
    @Override protected Target getTarget(    Label label) throws NoSuchThingException {
      return LoadedPackageProvider.Bridge.getLoadedTarget(skyframeExecutor.getPackageManager(),eventHandler,label);
    }
  }
  DependencyResolver dependencyResolver=new SilentDependencyResolver();
  TargetAndConfiguration ctgNode=new TargetAndConfiguration(ct.getTarget(),ct.getConfiguration());
  return dependencyResolver.dependentNodeMap(ctgNode,configurations.getHostConfiguration(),null,getConfigurableAttributeKeysForTesting(eventHandler,ctgNode));
}",0.8365489625045505
110975,"/** 
 * Returns ids for dependent nodes of a given node, sorted by attribute. Note that some dependencies do not have a corresponding attribute here, and we use the null attribute to represent those edges. Visibility attributes are only visited if   {@code visitVisibility} is{@code true}. <p>If   {@code aspect} is null, returns the dependent nodes of the configuredtarget node representing the given target and configuration, otherwise that of the aspect node accompanying the aforementioned configured target node for the specified aspect. <p>The values are not simply labels because this also implements the first step of applying configuration transitions, namely, split transitions. This needs to be done before the labels are resolved because late bound attributes depend on the configuration. A good example for this is @{code :cc_toolchain}. <p>The long-term goal is that most configuration transitions be applied here. However, in order to do that, we first have to eliminate transitions that depend on the rule class of the dependency.
 */
public final ListMultimap<Attribute,Dependency> dependentNodeMap(TargetAndConfiguration node,BuildConfiguration hostConfig,Aspect aspect,Set<ConfigMatchingProvider> configConditions) throws EvalException, InterruptedException {
  Target target=node.getTarget();
  BuildConfiguration config=node.getConfiguration();
  ListMultimap<Attribute,Dependency> outgoingEdges=ArrayListMultimap.create();
  if (target instanceof OutputFile) {
    Preconditions.checkNotNull(config);
    visitTargetVisibility(node,outgoingEdges.get(null));
    Rule rule=((OutputFile)target).getGeneratingRule();
    outgoingEdges.put(null,Dependency.withConfiguration(rule.getLabel(),config));
  }
 else   if (target instanceof InputFile) {
    visitTargetVisibility(node,outgoingEdges.get(null));
  }
 else   if (target instanceof EnvironmentGroup) {
    visitTargetVisibility(node,outgoingEdges.get(null));
  }
 else   if (target instanceof Rule) {
    Preconditions.checkNotNull(config);
    visitTargetVisibility(node,outgoingEdges.get(null));
    Rule rule=(Rule)target;
    ListMultimap<Attribute,LabelAndConfiguration> labelMap=resolveAttributes(rule,aspect != null ? aspect.getDefinition() : null,config,hostConfig,configConditions);
    visitRule(rule,aspect,labelMap,outgoingEdges);
  }
 else   if (target instanceof PackageGroup) {
    visitPackageGroup(node,(PackageGroup)target,outgoingEdges.get(null));
  }
 else {
    throw new IllegalStateException(target.getLabel().toString());
  }
  return outgoingEdges;
}","/** 
 * Returns ids for dependent nodes of a given node, sorted by attribute. Note that some dependencies do not have a corresponding attribute here, and we use the null attribute to represent those edges. Visibility attributes are only visited if   {@code visitVisibility} is{@code true}. <p>If   {@code aspect} is null, returns the dependent nodes of the configuredtarget node representing the given target and configuration, otherwise that of the aspect node accompanying the aforementioned configured target node for the specified aspect. <p>The values are not simply labels because this also implements the first step of applying configuration transitions, namely, split transitions. This needs to be done before the labels are resolved because late bound attributes depend on the configuration. A good example for this is @{code :cc_toolchain}. <p>The long-term goal is that most configuration transitions be applied here. However, in order to do that, we first have to eliminate transitions that depend on the rule class of the dependency.
 */
public final ListMultimap<Attribute,Dependency> dependentNodeMap(TargetAndConfiguration node,BuildConfiguration hostConfig,Aspect aspect,Set<ConfigMatchingProvider> configConditions,NestedSetBuilder<Label> rootCauses) throws EvalException, InterruptedException {
  Target target=node.getTarget();
  BuildConfiguration config=node.getConfiguration();
  ListMultimap<Attribute,Dependency> outgoingEdges=ArrayListMultimap.create();
  if (target instanceof OutputFile) {
    Preconditions.checkNotNull(config);
    visitTargetVisibility(node,rootCauses,outgoingEdges.get(null));
    Rule rule=((OutputFile)target).getGeneratingRule();
    outgoingEdges.put(null,Dependency.withConfiguration(rule.getLabel(),config));
  }
 else   if (target instanceof InputFile) {
    visitTargetVisibility(node,rootCauses,outgoingEdges.get(null));
  }
 else   if (target instanceof EnvironmentGroup) {
    visitTargetVisibility(node,rootCauses,outgoingEdges.get(null));
  }
 else   if (target instanceof Rule) {
    Preconditions.checkNotNull(config);
    visitTargetVisibility(node,rootCauses,outgoingEdges.get(null));
    Rule rule=(Rule)target;
    ListMultimap<Attribute,LabelAndConfiguration> labelMap=resolveAttributes(rule,aspect != null ? aspect.getDefinition() : null,config,hostConfig,configConditions);
    visitRule(rule,aspect,labelMap,rootCauses,outgoingEdges);
  }
 else   if (target instanceof PackageGroup) {
    visitPackageGroup(node,(PackageGroup)target,rootCauses,outgoingEdges.get(null));
  }
 else {
    throw new IllegalStateException(target.getLabel().toString());
  }
  return outgoingEdges;
}",0.9805731871513752
110976,"/** 
 * Converts the given multimap of attributes to labels into a multi map of attributes to  {@link Dependency} objects using the proper configuration transition for each attribute.
 * @throws IllegalArgumentException if the {@code node} does not refer to a {@link Rule} instance
 */
public final Collection<Dependency> resolveRuleLabels(TargetAndConfiguration node,ListMultimap<Attribute,LabelAndConfiguration> labelMap){
  Preconditions.checkArgument(node.getTarget() instanceof Rule);
  Rule rule=(Rule)node.getTarget();
  ListMultimap<Attribute,Dependency> outgoingEdges=ArrayListMultimap.create();
  visitRule(rule,labelMap,outgoingEdges);
  return outgoingEdges.values();
}","/** 
 * Converts the given multimap of attributes to labels into a multi map of attributes to  {@link Dependency} objects using the proper configuration transition for each attribute.
 * @throws IllegalArgumentException if the {@code node} does not refer to a {@link Rule} instance
 */
public final Collection<Dependency> resolveRuleLabels(TargetAndConfiguration node,ListMultimap<Attribute,LabelAndConfiguration> labelMap,NestedSetBuilder<Label> rootCauses){
  Preconditions.checkArgument(node.getTarget() instanceof Rule);
  Rule rule=(Rule)node.getTarget();
  ListMultimap<Attribute,Dependency> outgoingEdges=ArrayListMultimap.create();
  visitRule(rule,labelMap,rootCauses,outgoingEdges);
  return outgoingEdges.values();
}",0.9673295454545454
110977,"private void visitRule(Rule rule,Aspect aspect,ListMultimap<Attribute,LabelAndConfiguration> labelMap,ListMultimap<Attribute,Dependency> outgoingEdges){
  Preconditions.checkNotNull(labelMap);
  for (  Map.Entry<Attribute,Collection<LabelAndConfiguration>> entry : labelMap.asMap().entrySet()) {
    Attribute attribute=entry.getKey();
    for (    LabelAndConfiguration dep : entry.getValue()) {
      Label label=dep.getLabel();
      BuildConfiguration config=dep.getConfiguration();
      Target toTarget;
      try {
        toTarget=getTarget(label);
      }
 catch (      NoSuchThingException e) {
        throw new IllegalStateException(""String_Node_Str"" + label + ""String_Node_Str""+ rule+ ""String_Node_Str""+ attribute.getName());
      }
      if (toTarget == null) {
        continue;
      }
      BuildConfiguration.TransitionApplier transitionApplier=config.getTransitionApplier();
      if (config.useDynamicConfigurations() && config.isHostConfiguration() && !BuildConfiguration.usesNullConfiguration(toTarget)) {
        transitionApplier.applyTransition(Attribute.ConfigurationTransition.HOST);
      }
 else {
        config.evaluateTransition(rule,attribute,toTarget,transitionApplier);
      }
      for (      Dependency dependency : transitionApplier.getDependencies(label,requiredAspects(aspect,attribute,toTarget,rule))) {
        outgoingEdges.put(entry.getKey(),dependency);
      }
    }
  }
}","private void visitRule(Rule rule,Aspect aspect,ListMultimap<Attribute,LabelAndConfiguration> labelMap,NestedSetBuilder<Label> rootCauses,ListMultimap<Attribute,Dependency> outgoingEdges){
  Preconditions.checkNotNull(labelMap);
  for (  Map.Entry<Attribute,Collection<LabelAndConfiguration>> entry : labelMap.asMap().entrySet()) {
    Attribute attribute=entry.getKey();
    for (    LabelAndConfiguration dep : entry.getValue()) {
      Label label=dep.getLabel();
      BuildConfiguration config=dep.getConfiguration();
      Target toTarget=getTarget(rule,label,rootCauses);
      if (toTarget == null) {
        continue;
      }
      BuildConfiguration.TransitionApplier transitionApplier=config.getTransitionApplier();
      if (config.useDynamicConfigurations() && config.isHostConfiguration() && !BuildConfiguration.usesNullConfiguration(toTarget)) {
        transitionApplier.applyTransition(Attribute.ConfigurationTransition.HOST);
      }
 else {
        config.evaluateTransition(rule,attribute,toTarget,transitionApplier);
      }
      for (      Dependency dependency : transitionApplier.getDependencies(label,requiredAspects(aspect,attribute,toTarget,rule))) {
        outgoingEdges.put(entry.getKey(),dependency);
      }
    }
  }
}",0.8858105578435043
110978,"private void visitPackageGroup(TargetAndConfiguration node,PackageGroup packageGroup,Collection<Dependency> outgoingEdges){
  for (  Label label : packageGroup.getIncludes()) {
    try {
      Target target=getTarget(label);
      if (target == null) {
        return;
      }
      if (!(target instanceof PackageGroup)) {
        invalidPackageGroupReferenceHook(node,label);
        continue;
      }
      outgoingEdges.add(Dependency.withNullConfiguration(label));
    }
 catch (    NoSuchThingException e) {
    }
  }
}","private void visitPackageGroup(TargetAndConfiguration node,PackageGroup packageGroup,NestedSetBuilder<Label> rootCauses,Collection<Dependency> outgoingEdges){
  for (  Label label : packageGroup.getIncludes()) {
    Target target=getTarget(packageGroup,label,rootCauses);
    if (target == null) {
      continue;
    }
    if (!(target instanceof PackageGroup)) {
      invalidPackageGroupReferenceHook(node,label);
      continue;
    }
    outgoingEdges.add(Dependency.withNullConfiguration(label));
  }
}",0.8538238141335914
110979,"private void visitTargetVisibility(TargetAndConfiguration node,Collection<Dependency> outgoingEdges){
  for (  Label label : node.getTarget().getVisibility().getDependencyLabels()) {
    try {
      Target visibilityTarget=getTarget(label);
      if (visibilityTarget == null) {
        return;
      }
      if (!(visibilityTarget instanceof PackageGroup)) {
        invalidVisibilityReferenceHook(node,label);
        continue;
      }
      outgoingEdges.add(Dependency.withNullConfiguration(label));
    }
 catch (    NoSuchThingException e) {
    }
  }
}","private void visitTargetVisibility(TargetAndConfiguration node,NestedSetBuilder<Label> rootCauses,Collection<Dependency> outgoingEdges){
  Target target=node.getTarget();
  for (  Label label : target.getVisibility().getDependencyLabels()) {
    Target visibilityTarget=getTarget(target,label,rootCauses);
    if (visibilityTarget == null) {
      continue;
    }
    if (!(visibilityTarget instanceof PackageGroup)) {
      invalidVisibilityReferenceHook(node,label);
      continue;
    }
    outgoingEdges.add(Dependency.withNullConfiguration(label));
  }
}",0.7935656836461126
110980,"@Nullable @Override public SkyValue compute(SkyKey skyKey,Environment env) throws AspectFunctionException, InterruptedException {
  SkyframeBuildView view=buildViewProvider.getSkyframeBuildView();
  NestedSetBuilder<Package> transitivePackages=NestedSetBuilder.stableOrder();
  AspectKey key=(AspectKey)skyKey.argument();
  ConfiguredAspectFactory aspectFactory;
  if (key.getAspectClass() instanceof NativeAspectClass<?>) {
    aspectFactory=(ConfiguredAspectFactory)((NativeAspectClass<?>)key.getAspectClass()).newInstance();
  }
 else   if (key.getAspectClass() instanceof SkylarkAspectClass) {
    SkylarkAspectClass skylarkAspectClass=(SkylarkAspectClass)key.getAspectClass();
    SkylarkAspect skylarkAspect;
    try {
      skylarkAspect=loadSkylarkAspect(env,skylarkAspectClass.getExtensionLabel(),skylarkAspectClass.getExportedName());
    }
 catch (    AspectCreationException e) {
      throw new AspectFunctionException(e);
    }
    if (skylarkAspect == null) {
      return null;
    }
    aspectFactory=new SkylarkAspectFactory(skylarkAspect.getName(),skylarkAspect);
  }
 else {
    throw new IllegalStateException();
  }
  PackageValue packageValue=(PackageValue)env.getValue(PackageValue.key(key.getLabel().getPackageIdentifier()));
  if (packageValue == null) {
    return null;
  }
  Package pkg=packageValue.getPackage();
  if (pkg.containsErrors()) {
    throw new AspectFunctionException(new BuildFileContainsErrorsException(key.getLabel().getPackageIdentifier()));
  }
  Target target;
  try {
    target=pkg.getTarget(key.getLabel().getName());
  }
 catch (  NoSuchTargetException e) {
    throw new AspectFunctionException(e);
  }
  if (!(target instanceof Rule)) {
    throw new AspectFunctionException(new AspectCreationException(""String_Node_Str""));
  }
  final ConfiguredTargetValue configuredTargetValue=(ConfiguredTargetValue)env.getValue(ConfiguredTargetValue.key(key.getLabel(),key.getConfiguration()));
  if (configuredTargetValue == null) {
    return null;
  }
  RuleConfiguredTarget associatedTarget=(RuleConfiguredTarget)configuredTargetValue.getConfiguredTarget();
  if (associatedTarget == null) {
    return null;
  }
  SkyframeDependencyResolver resolver=view.createDependencyResolver(env);
  TargetAndConfiguration ctgValue=new TargetAndConfiguration(target,key.getConfiguration());
  try {
    Set<ConfigMatchingProvider> configConditions=ConfiguredTargetFunction.getConfigConditions(target,env,resolver,ctgValue,transitivePackages);
    if (configConditions == null) {
      return null;
    }
    ListMultimap<Attribute,ConfiguredTarget> depValueMap=ConfiguredTargetFunction.computeDependencies(env,resolver,ctgValue,key.getAspect(),configConditions,ruleClassProvider,view.getHostConfiguration(ctgValue.getConfiguration()),transitivePackages);
    return createAspect(env,key,aspectFactory,associatedTarget,configConditions,depValueMap,transitivePackages);
  }
 catch (  DependencyEvaluationException e) {
    if (e.getCause() instanceof ConfiguredValueCreationException) {
      ConfiguredValueCreationException cause=(ConfiguredValueCreationException)e.getCause();
      throw new AspectFunctionException(new AspectCreationException(cause.getMessage(),cause.getAnalysisRootCause()));
    }
 else {
      InvalidConfigurationException cause=(InvalidConfigurationException)e.getCause();
      throw new AspectFunctionException(new AspectCreationException(cause.getMessage()));
    }
  }
catch (  AspectCreationException e) {
    throw new AspectFunctionException(e);
  }
}","@Nullable @Override public SkyValue compute(SkyKey skyKey,Environment env) throws AspectFunctionException, InterruptedException {
  SkyframeBuildView view=buildViewProvider.getSkyframeBuildView();
  NestedSetBuilder<Package> transitivePackages=NestedSetBuilder.stableOrder();
  NestedSetBuilder<Label> transitiveRootCauses=NestedSetBuilder.stableOrder();
  AspectKey key=(AspectKey)skyKey.argument();
  ConfiguredAspectFactory aspectFactory;
  if (key.getAspectClass() instanceof NativeAspectClass<?>) {
    aspectFactory=(ConfiguredAspectFactory)((NativeAspectClass<?>)key.getAspectClass()).newInstance();
  }
 else   if (key.getAspectClass() instanceof SkylarkAspectClass) {
    SkylarkAspectClass skylarkAspectClass=(SkylarkAspectClass)key.getAspectClass();
    SkylarkAspect skylarkAspect;
    try {
      skylarkAspect=loadSkylarkAspect(env,skylarkAspectClass.getExtensionLabel(),skylarkAspectClass.getExportedName());
    }
 catch (    AspectCreationException e) {
      throw new AspectFunctionException(e);
    }
    if (skylarkAspect == null) {
      return null;
    }
    aspectFactory=new SkylarkAspectFactory(skylarkAspect.getName(),skylarkAspect);
  }
 else {
    throw new IllegalStateException();
  }
  PackageValue packageValue=(PackageValue)env.getValue(PackageValue.key(key.getLabel().getPackageIdentifier()));
  if (packageValue == null) {
    return null;
  }
  Package pkg=packageValue.getPackage();
  if (pkg.containsErrors()) {
    throw new AspectFunctionException(new BuildFileContainsErrorsException(key.getLabel().getPackageIdentifier()));
  }
  Target target;
  try {
    target=pkg.getTarget(key.getLabel().getName());
  }
 catch (  NoSuchTargetException e) {
    throw new AspectFunctionException(e);
  }
  if (!(target instanceof Rule)) {
    throw new AspectFunctionException(new AspectCreationException(""String_Node_Str""));
  }
  final ConfiguredTargetValue configuredTargetValue;
  try {
    configuredTargetValue=(ConfiguredTargetValue)env.getValueOrThrow(ConfiguredTargetValue.key(key.getLabel(),key.getConfiguration()),ConfiguredValueCreationException.class);
  }
 catch (  ConfiguredValueCreationException e) {
    throw new AspectFunctionException(new AspectCreationException(e.getRootCauses()));
  }
  if (configuredTargetValue == null) {
    return null;
  }
  RuleConfiguredTarget associatedTarget=(RuleConfiguredTarget)configuredTargetValue.getConfiguredTarget();
  if (associatedTarget == null) {
    return null;
  }
  SkyframeDependencyResolver resolver=view.createDependencyResolver(env);
  TargetAndConfiguration ctgValue=new TargetAndConfiguration(target,key.getConfiguration());
  try {
    Set<ConfigMatchingProvider> configConditions=ConfiguredTargetFunction.getConfigConditions(target,env,resolver,ctgValue,transitivePackages,transitiveRootCauses);
    if (configConditions == null) {
      return null;
    }
    ListMultimap<Attribute,ConfiguredTarget> depValueMap=ConfiguredTargetFunction.computeDependencies(env,resolver,ctgValue,key.getAspect(),configConditions,ruleClassProvider,view.getHostConfiguration(ctgValue.getConfiguration()),transitivePackages,transitiveRootCauses);
    if (depValueMap == null) {
      return null;
    }
    if (!transitiveRootCauses.isEmpty()) {
      throw new AspectFunctionException(new AspectCreationException(""String_Node_Str"",transitiveRootCauses.build()));
    }
    return createAspect(env,key,aspectFactory,associatedTarget,configConditions,depValueMap,transitivePackages);
  }
 catch (  DependencyEvaluationException e) {
    if (e.getCause() instanceof ConfiguredValueCreationException) {
      ConfiguredValueCreationException cause=(ConfiguredValueCreationException)e.getCause();
      throw new AspectFunctionException(new AspectCreationException(cause.getMessage(),cause.getAnalysisRootCause()));
    }
 else {
      InvalidConfigurationException cause=(InvalidConfigurationException)e.getCause();
      throw new AspectFunctionException(new AspectCreationException(cause.getMessage()));
    }
  }
catch (  AspectCreationException e) {
    throw new AspectFunctionException(e);
  }
}",0.92242966079411
110981,"public AspectCreationException(String message){
  this(message,null);
}","public AspectCreationException(String message){
  this(message,(Label)null);
}",0.953020134228188
110982,"/** 
 * Load Skylark aspect from an extension file. Is to be called from a SkyFunction.
 * @return {@code null} if dependencies cannot be satisfied.
 */
@Nullable public static SkylarkAspect loadSkylarkAspect(Environment env,Label extensionLabel,String skylarkValueName) throws ConversionException {
  SkyKey importFileKey=SkylarkImportLookupValue.key(extensionLabel,false);
  SkylarkImportLookupValue skylarkImportLookupValue=(SkylarkImportLookupValue)env.getValue(importFileKey);
  if (skylarkImportLookupValue == null) {
    return null;
  }
  Object skylarkValue=skylarkImportLookupValue.getEnvironmentExtension().get(skylarkValueName);
  if (!(skylarkValue instanceof SkylarkAspect)) {
    throw new ConversionException(skylarkValueName + ""String_Node_Str"" + extensionLabel.toString()+ ""String_Node_Str"");
  }
  return (SkylarkAspect)skylarkValue;
}","/** 
 * Load Skylark aspect from an extension file. Is to be called from a SkyFunction.
 * @return {@code null} if dependencies cannot be satisfied.
 */
@Nullable public static SkylarkAspect loadSkylarkAspect(Environment env,Label extensionLabel,String skylarkValueName) throws ConversionException, SkylarkImportFailedException {
  SkyKey importFileKey=SkylarkImportLookupValue.key(extensionLabel,false);
  SkylarkImportLookupValue skylarkImportLookupValue=(SkylarkImportLookupValue)env.getValueOrThrow(importFileKey,SkylarkImportFailedException.class);
  if (skylarkImportLookupValue == null) {
    return null;
  }
  Object skylarkValue=skylarkImportLookupValue.getEnvironmentExtension().get(skylarkValueName);
  if (!(skylarkValue instanceof SkylarkAspect)) {
    throw new ConversionException(skylarkValueName + ""String_Node_Str"" + extensionLabel.toString()+ ""String_Node_Str"");
  }
  return (SkylarkAspect)skylarkValue;
}",0.9595505617977528
110983,"@Nullable @Override public SkyValue compute(SkyKey skyKey,Environment env) throws AspectFunctionException, InterruptedException {
  SkyframeBuildView view=buildViewProvider.getSkyframeBuildView();
  NestedSetBuilder<Package> transitivePackages=NestedSetBuilder.stableOrder();
  AspectKey key=(AspectKey)skyKey.argument();
  ConfiguredAspectFactory aspectFactory;
  if (key.getAspectClass() instanceof NativeAspectClass<?>) {
    aspectFactory=(ConfiguredAspectFactory)((NativeAspectClass<?>)key.getAspectClass()).newInstance();
  }
 else   if (key.getAspectClass() instanceof SkylarkAspectClass) {
    SkylarkAspectClass skylarkAspectClass=(SkylarkAspectClass)key.getAspectClass();
    SkylarkAspect skylarkAspect;
    try {
      skylarkAspect=loadSkylarkAspect(env,skylarkAspectClass.getExtensionLabel(),skylarkAspectClass.getExportedName());
    }
 catch (    ConversionException e) {
      throw new AspectFunctionException(skyKey,e);
    }
    if (skylarkAspect == null) {
      return null;
    }
    aspectFactory=new SkylarkAspectFactory(skylarkAspect.getName(),skylarkAspect);
  }
 else {
    throw new IllegalStateException();
  }
  PackageValue packageValue=(PackageValue)env.getValue(PackageValue.key(key.getLabel().getPackageIdentifier()));
  if (packageValue == null) {
    return null;
  }
  Package pkg=packageValue.getPackage();
  if (pkg.containsErrors()) {
    throw new AspectFunctionException(skyKey,new BuildFileContainsErrorsException(key.getLabel().getPackageIdentifier()));
  }
  Target target;
  try {
    target=pkg.getTarget(key.getLabel().getName());
  }
 catch (  NoSuchTargetException e) {
    throw new AspectFunctionException(skyKey,e);
  }
  if (!(target instanceof Rule)) {
    throw new AspectFunctionException(new AspectCreationException(""String_Node_Str""));
  }
  final ConfiguredTargetValue configuredTargetValue=(ConfiguredTargetValue)env.getValue(ConfiguredTargetValue.key(key.getLabel(),key.getConfiguration()));
  if (configuredTargetValue == null) {
    return null;
  }
  RuleConfiguredTarget associatedTarget=(RuleConfiguredTarget)configuredTargetValue.getConfiguredTarget();
  if (associatedTarget == null) {
    return null;
  }
  SkyframeDependencyResolver resolver=view.createDependencyResolver(env);
  TargetAndConfiguration ctgValue=new TargetAndConfiguration(target,key.getConfiguration());
  try {
    Set<ConfigMatchingProvider> configConditions=ConfiguredTargetFunction.getConfigConditions(target,env,resolver,ctgValue,transitivePackages);
    if (configConditions == null) {
      return null;
    }
    ListMultimap<Attribute,ConfiguredTarget> depValueMap=ConfiguredTargetFunction.computeDependencies(env,resolver,ctgValue,key.getAspect(),configConditions,ruleClassProvider,view.getHostConfiguration(ctgValue.getConfiguration()),transitivePackages);
    return createAspect(env,key,aspectFactory,associatedTarget,configConditions,depValueMap,transitivePackages);
  }
 catch (  DependencyEvaluationException e) {
    throw new AspectFunctionException(e.getRootCauseSkyKey(),e.getCause());
  }
catch (  AspectCreationException e) {
    throw new AspectFunctionException(e);
  }
}","@Nullable @Override public SkyValue compute(SkyKey skyKey,Environment env) throws AspectFunctionException, InterruptedException {
  SkyframeBuildView view=buildViewProvider.getSkyframeBuildView();
  NestedSetBuilder<Package> transitivePackages=NestedSetBuilder.stableOrder();
  AspectKey key=(AspectKey)skyKey.argument();
  ConfiguredAspectFactory aspectFactory;
  if (key.getAspectClass() instanceof NativeAspectClass<?>) {
    aspectFactory=(ConfiguredAspectFactory)((NativeAspectClass<?>)key.getAspectClass()).newInstance();
  }
 else   if (key.getAspectClass() instanceof SkylarkAspectClass) {
    SkylarkAspectClass skylarkAspectClass=(SkylarkAspectClass)key.getAspectClass();
    SkylarkAspect skylarkAspect;
    try {
      skylarkAspect=loadSkylarkAspect(env,skylarkAspectClass.getExtensionLabel(),skylarkAspectClass.getExportedName());
    }
 catch (    SkylarkImportFailedException e) {
      throw new AspectFunctionException(skyKey,e);
    }
catch (    ConversionException e) {
      throw new AspectFunctionException(skyKey,e);
    }
    if (skylarkAspect == null) {
      return null;
    }
    aspectFactory=new SkylarkAspectFactory(skylarkAspect.getName(),skylarkAspect);
  }
 else {
    throw new IllegalStateException();
  }
  PackageValue packageValue=(PackageValue)env.getValue(PackageValue.key(key.getLabel().getPackageIdentifier()));
  if (packageValue == null) {
    return null;
  }
  Package pkg=packageValue.getPackage();
  if (pkg.containsErrors()) {
    throw new AspectFunctionException(skyKey,new BuildFileContainsErrorsException(key.getLabel().getPackageIdentifier()));
  }
  Target target;
  try {
    target=pkg.getTarget(key.getLabel().getName());
  }
 catch (  NoSuchTargetException e) {
    throw new AspectFunctionException(skyKey,e);
  }
  if (!(target instanceof Rule)) {
    throw new AspectFunctionException(new AspectCreationException(""String_Node_Str""));
  }
  final ConfiguredTargetValue configuredTargetValue=(ConfiguredTargetValue)env.getValue(ConfiguredTargetValue.key(key.getLabel(),key.getConfiguration()));
  if (configuredTargetValue == null) {
    return null;
  }
  RuleConfiguredTarget associatedTarget=(RuleConfiguredTarget)configuredTargetValue.getConfiguredTarget();
  if (associatedTarget == null) {
    return null;
  }
  SkyframeDependencyResolver resolver=view.createDependencyResolver(env);
  TargetAndConfiguration ctgValue=new TargetAndConfiguration(target,key.getConfiguration());
  try {
    Set<ConfigMatchingProvider> configConditions=ConfiguredTargetFunction.getConfigConditions(target,env,resolver,ctgValue,transitivePackages);
    if (configConditions == null) {
      return null;
    }
    ListMultimap<Attribute,ConfiguredTarget> depValueMap=ConfiguredTargetFunction.computeDependencies(env,resolver,ctgValue,key.getAspect(),configConditions,ruleClassProvider,view.getHostConfiguration(ctgValue.getConfiguration()),transitivePackages);
    return createAspect(env,key,aspectFactory,associatedTarget,configConditions,depValueMap,transitivePackages);
  }
 catch (  DependencyEvaluationException e) {
    throw new AspectFunctionException(e.getRootCauseSkyKey(),e.getCause());
  }
catch (  AspectCreationException e) {
    throw new AspectFunctionException(e);
  }
}",0.9808537350910232
110984,"private static void assertSaneAnalysisError(ErrorInfo errorInfo,SkyKey key){
  Throwable cause=errorInfo.getException();
  if (cause != null) {
    Preconditions.checkState(cause instanceof ConfiguredValueCreationException || cause instanceof AspectCreationException || cause instanceof ActionConflictException,""String_Node_Str"",key,errorInfo);
  }
}","private static void assertSaneAnalysisError(ErrorInfo errorInfo,SkyKey key){
  Throwable cause=errorInfo.getException();
  if (cause != null) {
    Preconditions.checkState(cause instanceof ConfiguredValueCreationException || cause instanceof ActionConflictException || cause instanceof AspectCreationException|| cause instanceof SkylarkImportFailedException,""String_Node_Str"",key,errorInfo);
  }
}",0.8716577540106952
110985,"@Nullable @Override public SkyValue compute(SkyKey skyKey,Environment env) throws LoadSkylarkAspectFunctionException, InterruptedException {
  SkylarkAspectLoadingKey aspectLoadingKey=(SkylarkAspectLoadingKey)skyKey.argument();
  String skylarkValueName=aspectLoadingKey.getSkylarkValueName();
  PathFragment extensionFile=aspectLoadingKey.getExtensionFile();
  ImmutableMap<PathFragment,Label> labelLookupMap;
  try {
    labelLookupMap=SkylarkImportLookupFunction.labelsForAbsoluteImports(ImmutableSet.of(extensionFile),env);
  }
 catch (  SkylarkImportFailedException e) {
    throw new LoadSkylarkAspectFunctionException(e,skyKey);
  }
  if (labelLookupMap == null) {
    return null;
  }
  SkylarkAspect skylarkAspect=null;
  try {
    skylarkAspect=AspectFunction.loadSkylarkAspect(env,labelLookupMap.get(extensionFile),skylarkValueName);
  }
 catch (  ConversionException e) {
    throw new LoadSkylarkAspectFunctionException(e,skyKey);
  }
  if (skylarkAspect == null) {
    return null;
  }
  SkyKey aspectKey=AspectValue.key(aspectLoadingKey.getTargetLabel(),aspectLoadingKey.getTargetConfiguration(),skylarkAspect.getAspectClass(),AspectParameters.EMPTY);
  return env.getValue(aspectKey);
}","@Nullable @Override public SkyValue compute(SkyKey skyKey,Environment env) throws LoadSkylarkAspectFunctionException, InterruptedException {
  SkylarkAspectLoadingKey aspectLoadingKey=(SkylarkAspectLoadingKey)skyKey.argument();
  String skylarkValueName=aspectLoadingKey.getSkylarkValueName();
  PathFragment extensionFile=aspectLoadingKey.getExtensionFile();
  ImmutableMap<PathFragment,Label> labelLookupMap;
  try {
    labelLookupMap=SkylarkImportLookupFunction.labelsForAbsoluteImports(ImmutableSet.of(extensionFile),env);
  }
 catch (  SkylarkImportFailedException e) {
    env.getListener().handle(Event.error(e.getMessage()));
    throw new LoadSkylarkAspectFunctionException(e,skyKey);
  }
  if (labelLookupMap == null) {
    return null;
  }
  SkylarkAspect skylarkAspect=null;
  try {
    skylarkAspect=AspectFunction.loadSkylarkAspect(env,labelLookupMap.get(extensionFile),skylarkValueName);
  }
 catch (  SkylarkImportFailedException e) {
    env.getListener().handle(Event.error(e.getMessage()));
    throw new LoadSkylarkAspectFunctionException(new AspectCreationException(e.getMessage()),skyKey);
  }
catch (  ConversionException e) {
    env.getListener().handle(Event.error(e.getMessage()));
    throw new LoadSkylarkAspectFunctionException(new AspectCreationException(e.getMessage()),skyKey);
  }
  if (skylarkAspect == null) {
    return null;
  }
  SkyKey aspectKey=AspectValue.key(aspectLoadingKey.getTargetLabel(),aspectLoadingKey.getTargetConfiguration(),skylarkAspect.getAspectClass(),AspectParameters.EMPTY);
  return env.getValue(aspectKey);
}",0.8593073593073594
110986,"/** 
 * Returns the STL prerequisite of the rule. <p>If rule has an implicit $stl attribute returns STL version set on the command line or if not set, the value of the $stl attribute. Returns  {@code null} otherwise.
 */
private static Label getStl(Rule rule,BuildConfiguration original){
  Label stl=null;
  if (rule.getRuleClassObject().hasAttr(""String_Node_Str"",BuildType.LABEL)) {
    Label stlConfigLabel=original.getFragment(CppConfiguration.class).getStl();
    Label stlRuleLabel=RawAttributeMapper.of(rule).get(""String_Node_Str"",BuildType.LABEL);
    if (stlConfigLabel == null) {
      stl=stlRuleLabel;
    }
 else     if (!stlConfigLabel.equals(rule.getLabel()) && stlRuleLabel != null) {
      stl=stlConfigLabel;
    }
  }
  return stl;
}","/** 
 * Returns the STL prerequisite of the rule. <p>If rule has an implicit $stl_default attribute returns STL version set on the command line or if not set, the value of the $stl_default attribute. Returns  {@code null} otherwise.
 */
private static Label getStl(Rule rule,BuildConfiguration original){
  Label stl=null;
  if (rule.getRuleClassObject().hasAttr(""String_Node_Str"",BuildType.LABEL)) {
    Label stlConfigLabel=original.getFragment(CppConfiguration.class).getStl();
    Label stlRuleLabel=RawAttributeMapper.of(rule).get(""String_Node_Str"",BuildType.LABEL);
    if (stlConfigLabel == null) {
      stl=stlRuleLabel;
    }
 else     if (!stlConfigLabel.equals(rule.getLabel()) && stlRuleLabel != null) {
      stl=stlConfigLabel;
    }
  }
  return stl;
}",0.9894736842105264
110987,"/** 
 * Constructs an instance of RuleClass whose name is 'name', attributes are 'attributes'. The   {@code srcsAllowedFiles} determines which types offiles are allowed as parameters to the ""srcs"" attribute; rules are always allowed. For the ""deps"" attribute, there are four cases: <ul> <li>if the parameter is a file, it is allowed if its file type is given in  {@code depsAllowedFiles}, <li>if the parameter is a rule and the rule class is accepted by  {@code depsAllowedRules}, then it is allowed, <li>if the parameter is a rule and the rule class is not accepted by  {@code depsAllowedRules}, but accepted by  {@code depsAllowedRulesWithWarning}, then it is allowed, but triggers a warning; <li>all other parameters trigger an error. </ul> <p>The   {@code depsAllowedRules} predicate should have a {@code toString}method which returns a plain English enumeration of the allowed rule class names, if it does not allow all rule classes.
 * @param workspaceOnly
 */
@VisibleForTesting void RuleClass(String name,boolean isSkylark,boolean skylarkExecutable,boolean documented,boolean publicByDefault,boolean binaryOutput,boolean workspaceOnly,boolean outputsDefaultExecutable,ImplicitOutputsFunction implicitOutputsFunction,Configurator<?,?> configurator,ConfiguredTargetFactory<?,?> configuredTargetFactory,PredicateWithMessage<Rule> validityPredicate,Predicate<String> preferredDependencyPredicate,ImmutableSet<Class<?>> advertisedProviders,@Nullable BaseFunction configuredTargetFunction,Function<? super Rule,Map<String,Label>> externalBindingsFunction,@Nullable Environment ruleDefinitionEnvironment,ConfigurationFragmentPolicy configurationFragmentPolicy,boolean supportsConstraintChecking,Attribute... attributes){
  this.name=name;
  this.isSkylark=isSkylark;
  this.targetKind=name + ""String_Node_Str"";
  this.skylarkExecutable=skylarkExecutable;
  this.documented=documented;
  this.publicByDefault=publicByDefault;
  this.binaryOutput=binaryOutput;
  this.implicitOutputsFunction=implicitOutputsFunction;
  this.configurator=Preconditions.checkNotNull(configurator);
  this.configuredTargetFactory=configuredTargetFactory;
  this.validityPredicate=validityPredicate;
  this.preferredDependencyPredicate=preferredDependencyPredicate;
  this.advertisedProviders=advertisedProviders;
  this.configuredTargetFunction=configuredTargetFunction;
  this.externalBindingsFunction=externalBindingsFunction;
  this.ruleDefinitionEnvironment=ruleDefinitionEnvironment;
  this.attributes=ImmutableList.copyOf(attributes);
  this.workspaceOnly=workspaceOnly;
  this.outputsDefaultExecutable=outputsDefaultExecutable;
  this.configurationFragmentPolicy=configurationFragmentPolicy;
  this.supportsConstraintChecking=supportsConstraintChecking;
  int index=0;
  attributeIndex=new HashMap<>(attributes.length);
  for (  Attribute attribute : attributes) {
    attributeIndex.put(attribute.getName(),index++);
  }
}","/** 
 * Constructs an instance of RuleClass whose name is 'name', attributes are 'attributes'. The   {@code srcsAllowedFiles} determines which types offiles are allowed as parameters to the ""srcs"" attribute; rules are always allowed. For the ""deps"" attribute, there are four cases: <ul> <li>if the parameter is a file, it is allowed if its file type is given in  {@code depsAllowedFiles}, <li>if the parameter is a rule and the rule class is accepted by  {@code depsAllowedRules}, then it is allowed, <li>if the parameter is a rule and the rule class is not accepted by  {@code depsAllowedRules}, but accepted by  {@code depsAllowedRulesWithWarning}, then it is allowed, but triggers a warning; <li>all other parameters trigger an error. </ul> <p>The   {@code depsAllowedRules} predicate should have a {@code toString}method which returns a plain English enumeration of the allowed rule class names, if it does not allow all rule classes.
 * @param workspaceOnly
 */
@VisibleForTesting void RuleClass(String name,boolean isSkylark,boolean skylarkExecutable,boolean documented,boolean publicByDefault,boolean binaryOutput,boolean workspaceOnly,boolean outputsDefaultExecutable,ImplicitOutputsFunction implicitOutputsFunction,Configurator<?,?> configurator,ConfiguredTargetFactory<?,?> configuredTargetFactory,PredicateWithMessage<Rule> validityPredicate,Predicate<String> preferredDependencyPredicate,ImmutableSet<Class<?>> advertisedProviders,@Nullable BaseFunction configuredTargetFunction,Function<? super Rule,Map<String,Label>> externalBindingsFunction,@Nullable Environment ruleDefinitionEnvironment,ConfigurationFragmentPolicy configurationFragmentPolicy,boolean supportsConstraintChecking,Attribute... attributes){
  this.name=name;
  this.isSkylark=isSkylark;
  this.targetKind=name + ""String_Node_Str"";
  this.skylarkExecutable=skylarkExecutable;
  this.documented=documented;
  this.publicByDefault=publicByDefault;
  this.binaryOutput=binaryOutput;
  this.implicitOutputsFunction=implicitOutputsFunction;
  this.configurator=Preconditions.checkNotNull(configurator);
  this.configuredTargetFactory=configuredTargetFactory;
  this.validityPredicate=validityPredicate;
  this.preferredDependencyPredicate=preferredDependencyPredicate;
  this.advertisedProviders=advertisedProviders;
  this.configuredTargetFunction=configuredTargetFunction;
  this.externalBindingsFunction=externalBindingsFunction;
  this.ruleDefinitionEnvironment=ruleDefinitionEnvironment;
  validateNoClashInPublicNames(attributes);
  this.attributes=ImmutableList.copyOf(attributes);
  this.workspaceOnly=workspaceOnly;
  this.outputsDefaultExecutable=outputsDefaultExecutable;
  this.configurationFragmentPolicy=configurationFragmentPolicy;
  this.supportsConstraintChecking=supportsConstraintChecking;
  int index=0;
  attributeIndex=new HashMap<>(attributes.length);
  for (  Attribute attribute : attributes) {
    attributeIndex.put(attribute.getName(),index++);
  }
}",0.9924940293415216
110988,"/** 
 * Creates a new SkylarkRuleContext using ruleContext.
 * @throws InterruptedException 
 */
public SkylarkRuleContext(RuleContext ruleContext) throws EvalException, InterruptedException {
  this.ruleContext=Preconditions.checkNotNull(ruleContext);
  fragments=new FragmentCollection(ruleContext,ConfigurationTransition.NONE);
  hostFragments=new FragmentCollection(ruleContext,ConfigurationTransition.HOST);
  HashMap<String,Object> outputsBuilder=new HashMap<>();
  if (ruleContext.getRule().getRuleClassObject().outputsDefaultExecutable()) {
    addOutput(outputsBuilder,""String_Node_Str"",ruleContext.createOutputArtifact());
  }
  ImplicitOutputsFunction implicitOutputsFunction=ruleContext.getRule().getRuleClassObject().getImplicitOutputsFunction();
  if (implicitOutputsFunction instanceof SkylarkImplicitOutputsFunction) {
    SkylarkImplicitOutputsFunction func=(SkylarkImplicitOutputsFunction)ruleContext.getRule().getRuleClassObject().getImplicitOutputsFunction();
    for (    Map.Entry<String,String> entry : func.calculateOutputs(RawAttributeMapper.of(ruleContext.getRule())).entrySet()) {
      addOutput(outputsBuilder,entry.getKey(),ruleContext.getImplicitOutputArtifact(entry.getValue()));
    }
  }
  ImmutableMap.Builder<Artifact,Label> artifactLabelMapBuilder=ImmutableMap.builder();
  for (  Attribute a : ruleContext.getRule().getAttributes()) {
    String attrName=a.getName();
    Type<?> type=a.getType();
    if (type != BuildType.OUTPUT && type != BuildType.OUTPUT_LIST) {
      continue;
    }
    ImmutableList.Builder<Artifact> artifactsBuilder=ImmutableList.builder();
    for (    OutputFile outputFile : ruleContext.getRule().getOutputFileMap().get(attrName)) {
      Artifact artifact=ruleContext.createOutputArtifact(outputFile);
      artifactsBuilder.add(artifact);
      artifactLabelMapBuilder.put(artifact,outputFile.getLabel());
    }
    ImmutableList<Artifact> artifacts=artifactsBuilder.build();
    if (type == BuildType.OUTPUT) {
      if (artifacts.size() == 1) {
        addOutput(outputsBuilder,attrName,Iterables.getOnlyElement(artifacts));
      }
 else {
        addOutput(outputsBuilder,attrName,Runtime.NONE);
      }
    }
 else     if (type == BuildType.OUTPUT_LIST) {
      addOutput(outputsBuilder,attrName,new MutableList(artifacts));
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + attrName + ""String_Node_Str""+ type+ ""String_Node_Str"");
    }
  }
  artifactLabelMap=artifactLabelMapBuilder.build();
  outputsObject=new SkylarkClassObject(outputsBuilder,""String_Node_Str"");
  ImmutableMap.Builder<String,Object> attrBuilder=new ImmutableMap.Builder<>();
  ImmutableMap.Builder<String,Object> executableBuilder=new ImmutableMap.Builder<>();
  ImmutableMap.Builder<Artifact,FilesToRunProvider> executableRunfilesbuilder=new ImmutableMap.Builder<>();
  ImmutableMap.Builder<String,Object> fileBuilder=new ImmutableMap.Builder<>();
  ImmutableMap.Builder<String,Object> filesBuilder=new ImmutableMap.Builder<>();
  for (  Attribute a : ruleContext.getRule().getAttributes()) {
    Type<?> type=a.getType();
    Object val=ruleContext.attributes().get(a.getName(),type);
    if (type != BuildType.LABEL && type != BuildType.LABEL_LIST) {
      attrBuilder.put(a.getPublicName(),val == null ? Runtime.NONE : SkylarkType.convertToSkylark(val,null));
      continue;
    }
    String skyname=a.getPublicName();
    Mode mode=getMode(a.getName());
    if (a.isExecutable()) {
      FilesToRunProvider provider=ruleContext.getExecutablePrerequisite(a.getName(),mode);
      if (provider != null && provider.getExecutable() != null) {
        Artifact executable=provider.getExecutable();
        executableBuilder.put(skyname,executable);
        executableRunfilesbuilder.put(executable,provider);
      }
 else {
        executableBuilder.put(skyname,Runtime.NONE);
      }
    }
    if (a.isSingleArtifact()) {
      Artifact artifact=ruleContext.getPrerequisiteArtifact(a.getName(),mode);
      if (artifact != null) {
        fileBuilder.put(skyname,artifact);
      }
 else {
        fileBuilder.put(skyname,Runtime.NONE);
      }
    }
    filesBuilder.put(skyname,ruleContext.getPrerequisiteArtifacts(a.getName(),mode).list());
    List<?> allPrereq=ruleContext.getPrerequisites(a.getName(),mode);
    if (type == BuildType.LABEL) {
      Object prereq=ruleContext.getPrerequisite(a.getName(),mode);
      if (prereq == null) {
        prereq=Runtime.NONE;
      }
      attrBuilder.put(skyname,prereq);
    }
 else {
      attrBuilder.put(skyname,new MutableList(allPrereq));
    }
  }
  attrObject=new SkylarkClassObject(attrBuilder.build(),""String_Node_Str"");
  executableObject=new SkylarkClassObject(executableBuilder.build(),""String_Node_Str"" + ""String_Node_Str"");
  fileObject=new SkylarkClassObject(fileBuilder.build(),""String_Node_Str"" + ""String_Node_Str"");
  filesObject=new SkylarkClassObject(filesBuilder.build(),""String_Node_Str"" + ""String_Node_Str"");
  executableRunfilesMap=executableRunfilesbuilder.build();
  makeVariables=ruleContext.getConfigurationMakeVariableContext().collectMakeVariables();
}","/** 
 * Creates a new SkylarkRuleContext using ruleContext.
 * @throws InterruptedException 
 */
public SkylarkRuleContext(RuleContext ruleContext) throws EvalException, InterruptedException {
  this.ruleContext=Preconditions.checkNotNull(ruleContext);
  fragments=new FragmentCollection(ruleContext,ConfigurationTransition.NONE);
  hostFragments=new FragmentCollection(ruleContext,ConfigurationTransition.HOST);
  HashMap<String,Object> outputsBuilder=new HashMap<>();
  if (ruleContext.getRule().getRuleClassObject().outputsDefaultExecutable()) {
    addOutput(outputsBuilder,""String_Node_Str"",ruleContext.createOutputArtifact());
  }
  ImplicitOutputsFunction implicitOutputsFunction=ruleContext.getRule().getRuleClassObject().getImplicitOutputsFunction();
  if (implicitOutputsFunction instanceof SkylarkImplicitOutputsFunction) {
    SkylarkImplicitOutputsFunction func=(SkylarkImplicitOutputsFunction)ruleContext.getRule().getRuleClassObject().getImplicitOutputsFunction();
    for (    Map.Entry<String,String> entry : func.calculateOutputs(RawAttributeMapper.of(ruleContext.getRule())).entrySet()) {
      addOutput(outputsBuilder,entry.getKey(),ruleContext.getImplicitOutputArtifact(entry.getValue()));
    }
  }
  ImmutableMap.Builder<Artifact,Label> artifactLabelMapBuilder=ImmutableMap.builder();
  for (  Attribute a : ruleContext.getRule().getAttributes()) {
    String attrName=a.getName();
    Type<?> type=a.getType();
    if (type != BuildType.OUTPUT && type != BuildType.OUTPUT_LIST) {
      continue;
    }
    ImmutableList.Builder<Artifact> artifactsBuilder=ImmutableList.builder();
    for (    OutputFile outputFile : ruleContext.getRule().getOutputFileMap().get(attrName)) {
      Artifact artifact=ruleContext.createOutputArtifact(outputFile);
      artifactsBuilder.add(artifact);
      artifactLabelMapBuilder.put(artifact,outputFile.getLabel());
    }
    ImmutableList<Artifact> artifacts=artifactsBuilder.build();
    if (type == BuildType.OUTPUT) {
      if (artifacts.size() == 1) {
        addOutput(outputsBuilder,attrName,Iterables.getOnlyElement(artifacts));
      }
 else {
        addOutput(outputsBuilder,attrName,Runtime.NONE);
      }
    }
 else     if (type == BuildType.OUTPUT_LIST) {
      addOutput(outputsBuilder,attrName,new MutableList(artifacts));
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + attrName + ""String_Node_Str""+ type+ ""String_Node_Str"");
    }
  }
  artifactLabelMap=artifactLabelMapBuilder.build();
  outputsObject=new SkylarkClassObject(outputsBuilder,""String_Node_Str"");
  ImmutableMap.Builder<String,Object> attrBuilder=new ImmutableMap.Builder<>();
  ImmutableMap.Builder<String,Object> executableBuilder=new ImmutableMap.Builder<>();
  ImmutableMap.Builder<Artifact,FilesToRunProvider> executableRunfilesbuilder=new ImmutableMap.Builder<>();
  ImmutableMap.Builder<String,Object> fileBuilder=new ImmutableMap.Builder<>();
  ImmutableMap.Builder<String,Object> filesBuilder=new ImmutableMap.Builder<>();
  for (  Attribute a : ruleContext.getRule().getAttributes()) {
    Type<?> type=a.getType();
    Object val=ruleContext.attributes().get(a.getName(),type);
    if (type != BuildType.LABEL && type != BuildType.LABEL_LIST) {
      attrBuilder.put(a.getPublicName(),val == null ? Runtime.NONE : SkylarkType.convertToSkylark(val,null));
      continue;
    }
    String skyname=a.getPublicName();
    if (a.isExecutable()) {
      FilesToRunProvider provider=ruleContext.getExecutablePrerequisite(a.getName(),Mode.DONT_CHECK);
      if (provider != null && provider.getExecutable() != null) {
        Artifact executable=provider.getExecutable();
        executableBuilder.put(skyname,executable);
        executableRunfilesbuilder.put(executable,provider);
      }
 else {
        executableBuilder.put(skyname,Runtime.NONE);
      }
    }
    if (a.isSingleArtifact()) {
      Artifact artifact=ruleContext.getPrerequisiteArtifact(a.getName(),Mode.DONT_CHECK);
      if (artifact != null) {
        fileBuilder.put(skyname,artifact);
      }
 else {
        fileBuilder.put(skyname,Runtime.NONE);
      }
    }
    filesBuilder.put(skyname,ruleContext.getPrerequisiteArtifacts(a.getName(),Mode.DONT_CHECK).list());
    List<?> allPrereq=ruleContext.getPrerequisites(a.getName(),Mode.DONT_CHECK);
    if (type == BuildType.LABEL) {
      Object prereq=ruleContext.getPrerequisite(a.getName(),Mode.DONT_CHECK);
      if (prereq == null) {
        prereq=Runtime.NONE;
      }
      attrBuilder.put(skyname,prereq);
    }
 else {
      attrBuilder.put(skyname,new MutableList(allPrereq));
    }
  }
  attrObject=new SkylarkClassObject(attrBuilder.build(),""String_Node_Str"");
  executableObject=new SkylarkClassObject(executableBuilder.build(),""String_Node_Str"" + ""String_Node_Str"");
  fileObject=new SkylarkClassObject(fileBuilder.build(),""String_Node_Str"" + ""String_Node_Str"");
  filesObject=new SkylarkClassObject(filesBuilder.build(),""String_Node_Str"" + ""String_Node_Str"");
  executableRunfilesMap=executableRunfilesbuilder.build();
  makeVariables=ruleContext.getConfigurationMakeVariableContext().collectMakeVariables();
}",0.9871932740248314
110989,"@Override public SkyValue compute(SkyKey key,Environment env) throws FilesetEntryFunctionException {
  FilesetTraversalParams t=(FilesetTraversalParams)key.argument();
  Preconditions.checkState(t.getNestedTraversal().isPresent() != t.getDirectTraversal().isPresent(),""String_Node_Str"",t);
  Set<String> exclusions=createExclusionSet(t.getExcludedFiles());
  Map<PathFragment,FilesetOutputSymlink> outputSymlinks=new LinkedHashMap<>();
  if (t.getNestedTraversal().isPresent()) {
    FilesetEntryValue nested=(FilesetEntryValue)env.getValue(FilesetEntryValue.key(t.getNestedTraversal().get()));
    if (env.valuesMissing()) {
      return null;
    }
    for (    FilesetOutputSymlink s : nested.getSymlinks()) {
      maybeStoreSymlink(s,t.getDestPath(),exclusions,outputSymlinks);
    }
  }
 else {
    DirectTraversal direct=t.getDirectTraversal().get();
    RecursiveFilesystemTraversalValue rftv;
    try {
      rftv=traverse(env,createErrorInfo(t),direct);
    }
 catch (    MissingDepException e) {
      return null;
    }
    if (!rftv.getResolvedRoot().isPresent()) {
      return FilesetEntryValue.EMPTY;
    }
    ResolvedFile resolvedRoot=rftv.getResolvedRoot().get();
    if (!resolvedRoot.type.exists()) {
      return FilesetEntryValue.EMPTY;
    }
    PathFragment prefixToRemove=direct.getRoot().getRelativePart();
    Iterable<ResolvedFile> results=null;
    if (direct.isRecursive() || (resolvedRoot.type.isDirectory() && !resolvedRoot.type.isSymlink())) {
      DirectoryTree root=new DirectoryTree();
      for (      ResolvedFile f : rftv.getTransitiveFiles().toCollection()) {
        PathFragment path=f.getNameInSymlinkTree().relativeTo(prefixToRemove);
        if (path.segmentCount() > 0) {
          path=t.getDestPath().getRelative(path);
          DirectoryTree dir=root;
          for (int i=0; i < path.segmentCount() - 1; ++i) {
            dir=dir.addOrGetSubdir(path.getSegment(i));
          }
          dir.maybeAddFile(f);
        }
      }
      results=root.iterateFiles();
    }
 else {
      results=ImmutableList.of(resolvedRoot);
    }
    for (    ResolvedFile f : results) {
      PathFragment targetName;
      try {
        targetName=f.getTargetInSymlinkTree(direct.isFollowingSymlinks());
      }
 catch (      DanglingSymlinkException e) {
        throw new FilesetEntryFunctionException(e);
      }
      String metadata=Integer.toHexString(f.metadata.get().hashCode());
      PathFragment linkName=f.getNameInSymlinkTree().relativeTo(prefixToRemove);
      maybeStoreSymlink(linkName,targetName,metadata,t.getDestPath(),exclusions,outputSymlinks);
    }
  }
  return FilesetEntryValue.of(ImmutableSet.copyOf(outputSymlinks.values()));
}","@Override public SkyValue compute(SkyKey key,Environment env) throws FilesetEntryFunctionException {
  FilesetTraversalParams t=(FilesetTraversalParams)key.argument();
  Preconditions.checkState(t.getNestedTraversal().isPresent() != t.getDirectTraversal().isPresent(),""String_Node_Str"",t);
  Set<String> exclusions=createExclusionSet(t.getExcludedFiles());
  Map<PathFragment,FilesetOutputSymlink> outputSymlinks=new LinkedHashMap<>();
  if (t.getNestedTraversal().isPresent()) {
    FilesetEntryValue nested=(FilesetEntryValue)env.getValue(FilesetEntryValue.key(t.getNestedTraversal().get()));
    if (env.valuesMissing()) {
      return null;
    }
    for (    FilesetOutputSymlink s : nested.getSymlinks()) {
      if (!exclusions.contains(s.name.getPathString())) {
        maybeStoreSymlink(s,t.getDestPath(),outputSymlinks);
      }
    }
  }
 else {
    DirectTraversal direct=t.getDirectTraversal().get();
    RecursiveFilesystemTraversalValue rftv;
    try {
      rftv=traverse(env,createErrorInfo(t),direct);
    }
 catch (    MissingDepException e) {
      return null;
    }
    if (!rftv.getResolvedRoot().isPresent()) {
      return FilesetEntryValue.EMPTY;
    }
    ResolvedFile resolvedRoot=rftv.getResolvedRoot().get();
    if (!resolvedRoot.type.exists()) {
      return FilesetEntryValue.EMPTY;
    }
    PathFragment prefixToRemove=direct.getRoot().getRelativePart();
    Iterable<ResolvedFile> results=null;
    if (direct.isRecursive() || (resolvedRoot.type.isDirectory() && !resolvedRoot.type.isSymlink())) {
      DirectoryTree root=new DirectoryTree();
      for (      ResolvedFile f : rftv.getTransitiveFiles().toCollection()) {
        PathFragment path=f.getNameInSymlinkTree().relativeTo(prefixToRemove);
        if (path.segmentCount() > 0) {
          path=t.getDestPath().getRelative(path);
          DirectoryTree dir=root;
          for (int i=0; i < path.segmentCount() - 1; ++i) {
            dir=dir.addOrGetSubdir(path.getSegment(i));
          }
          dir.maybeAddFile(f);
        }
      }
      results=root.iterateFiles();
    }
 else {
      results=ImmutableList.of(resolvedRoot);
    }
    for (    ResolvedFile f : results) {
      PathFragment linkName=f.getNameInSymlinkTree().relativeTo(prefixToRemove);
      if (exclusions.contains(linkName.getPathString())) {
        continue;
      }
      PathFragment targetName;
      try {
        targetName=f.getTargetInSymlinkTree(direct.isFollowingSymlinks());
      }
 catch (      DanglingSymlinkException e) {
        throw new FilesetEntryFunctionException(e);
      }
      String metadata=Integer.toHexString(f.metadata.get().hashCode());
      maybeStoreSymlink(linkName,targetName,metadata,t.getDestPath(),outputSymlinks);
    }
  }
  return FilesetEntryValue.of(ImmutableSet.copyOf(outputSymlinks.values()));
}",0.886631598040994
110990,"/** 
 * Stores an output symlink unless it's excluded or would overwrite an existing one. 
 */
private static void maybeStoreSymlink(PathFragment linkName,PathFragment linkTarget,String metadata,PathFragment destPath,Set<String> exclusions,Map<PathFragment,FilesetOutputSymlink> result){
  if (!exclusions.contains(linkName.getPathString())) {
    linkName=destPath.getRelative(linkName);
    if (!result.containsKey(linkName)) {
      result.put(linkName,new FilesetOutputSymlink(linkName,linkTarget,metadata));
    }
  }
}","/** 
 * Stores an output symlink unless it's excluded or would overwrite an existing one. 
 */
private static void maybeStoreSymlink(PathFragment linkName,PathFragment linkTarget,String metadata,PathFragment destPath,Map<PathFragment,FilesetOutputSymlink> result){
  linkName=destPath.getRelative(linkName);
  if (!result.containsKey(linkName)) {
    result.put(linkName,new FilesetOutputSymlink(linkName,linkTarget,metadata));
  }
}",0.5308254963427377
110991,"public DanglingSymlinkException(String path,String unresolvedLink){
  super(""String_Node_Str"" + path + ""String_Node_Str"");
  Preconditions.checkArgument(path != null && !path.isEmpty());
  Preconditions.checkArgument(unresolvedLink != null && !unresolvedLink.isEmpty());
  this.path=path;
  this.unresolvedLink=unresolvedLink;
}","public DanglingSymlinkException(String path,String unresolvedLink){
  super(String.format(""String_Node_Str"",path,unresolvedLink));
  Preconditions.checkArgument(path != null && !path.isEmpty());
  Preconditions.checkArgument(unresolvedLink != null && !unresolvedLink.isEmpty());
  this.path=path;
  this.unresolvedLink=unresolvedLink;
}",0.9066265060240964
110992,"/** 
 * Construct the BuildStartingEvent.
 * @param request the build request.
 */
public BuildCompleteEvent(BuildRequest request,BuildResult result){
  this.result=result;
}","/** 
 * Construct the BuildCompleteEvent.
 * @param request the build request.
 */
public BuildCompleteEvent(BuildRequest request,BuildResult result){
  this.result=result;
}",0.9597701149425288
110993,"private void registerConvertStringsActions(ObjcProvider objcProvider){
  IntermediateArtifacts intermediateArtifacts=ObjcRuleClasses.intermediateArtifacts(ruleContext);
  for (  Artifact strings : objcProvider.get(ObjcProvider.STRINGS)) {
    Artifact bundled=intermediateArtifacts.convertedStringsFile(strings);
    ruleContext.registerAction(ObjcRuleClasses.spawnOnDarwinActionBuilder(ruleContext).setMnemonic(""String_Node_Str"").setExecutable(XCRUN).setCommandLine(CustomCommandLine.builder().add(""String_Node_Str"").add(""String_Node_Str"").add(""String_Node_Str"").addExecPath(""String_Node_Str"",bundled).add(""String_Node_Str"").addPath(strings.getExecPath()).build()).addInput(strings).addOutput(bundled).build(ruleContext));
  }
}","private void registerConvertStringsActions(ObjcProvider objcProvider){
  IntermediateArtifacts intermediateArtifacts=ObjcRuleClasses.intermediateArtifacts(ruleContext);
  for (  Artifact strings : objcProvider.get(ObjcProvider.STRINGS)) {
    Artifact bundled=intermediateArtifacts.convertedStringsFile(strings);
    ruleContext.registerAction(ObjcRuleClasses.spawnOnDarwinActionBuilder(ruleContext).setMnemonic(""String_Node_Str"").setExecutable(new PathFragment(""String_Node_Str"")).setCommandLine(CustomCommandLine.builder().add(""String_Node_Str"").add(""String_Node_Str"").addExecPath(""String_Node_Str"",bundled).add(""String_Node_Str"").addPath(strings.getExecPath()).build()).addInput(strings).addOutput(bundled).build(ruleContext));
  }
}",0.9583617747440272
110994,"@Nullable public Fragment getSkylarkFragment(String name,ConfigurationTransition config){
  Class<? extends Fragment> fragmentClass=getConfiguration().getSkylarkFragmentByName(name);
  if (fragmentClass == null) {
    return null;
  }
  return getFragment(fragmentClass,name,String.format(""String_Node_Str"" + ""String_Node_Str"",(config == ConfigurationTransition.HOST) ? ""String_Node_Str"" : ""String_Node_Str"",name),config);
}","@Nullable public Fragment getSkylarkFragment(String name,ConfigurationTransition config){
  Class<? extends Fragment> fragmentClass=getConfiguration(config).getSkylarkFragmentByName(name);
  if (fragmentClass == null) {
    return null;
  }
  return getFragment(fragmentClass,name,String.format(""String_Node_Str"" + ""String_Node_Str"",(config == ConfigurationTransition.HOST) ? ""String_Node_Str"" : ""String_Node_Str"",name),config);
}",0.9929742388758782
110995,"/** 
 * Returns the path and file state of   {@code rootedPath}, accounting for ancestor symlinks, or  {@code null} if there was a missing dep.
 */
@Nullable private Pair<RootedPath,FileStateValue> resolveFromAncestors(RootedPath rootedPath,Environment env) throws FileFunctionException {
  PathFragment relativePath=rootedPath.getRelativePath();
  RootedPath realRootedPath=rootedPath;
  FileValue parentFileValue=null;
  if (!externalFilesHelper.shouldAssumeImmutable(rootedPath) && !relativePath.equals(PathFragment.EMPTY_FRAGMENT)) {
    RootedPath parentRootedPath=RootedPath.toRootedPath(rootedPath.getRoot(),relativePath.getParentDirectory());
    parentFileValue=(FileValue)env.getValue(FileValue.key(parentRootedPath));
    if (parentFileValue == null) {
      return null;
    }
    PathFragment baseName=new PathFragment(relativePath.getBaseName());
    RootedPath parentRealRootedPath=parentFileValue.realRootedPath();
    realRootedPath=RootedPath.toRootedPath(parentRealRootedPath.getRoot(),parentRealRootedPath.getRelativePath().getRelative(baseName));
    if (!parentFileValue.exists()) {
      return Pair.of(realRootedPath,FileStateValue.NONEXISTENT_FILE_STATE_NODE);
    }
  }
  FileStateValue realFileStateValue=(FileStateValue)env.getValue(FileStateValue.key(realRootedPath));
  if (realFileStateValue == null) {
    return null;
  }
  if (realFileStateValue.getType() != FileStateValue.Type.NONEXISTENT && parentFileValue != null && !parentFileValue.isDirectory()) {
    String type=realFileStateValue.getType().toString().toLowerCase();
    String message=type + ""String_Node_Str"" + rootedPath.asPath()+ ""String_Node_Str""+ ""String_Node_Str""+ parentFileValue.realRootedPath().asPath()+ ""String_Node_Str"";
    throw new FileFunctionException(new InconsistentFilesystemException(message),Transience.TRANSIENT);
  }
  return Pair.of(realRootedPath,realFileStateValue);
}","/** 
 * Returns the path and file state of   {@code rootedPath}, accounting for ancestor symlinks, or  {@code null} if there was a missing dep.
 */
@Nullable private Pair<RootedPath,FileStateValue> resolveFromAncestors(RootedPath rootedPath,Environment env) throws FileFunctionException {
  PathFragment relativePath=rootedPath.getRelativePath();
  RootedPath realRootedPath=rootedPath;
  FileValue parentFileValue=null;
  if (!externalFilesHelper.shouldAssumeImmutable(rootedPath) && !relativePath.equals(PathFragment.EMPTY_FRAGMENT)) {
    RootedPath parentRootedPath=RootedPath.toRootedPath(rootedPath.getRoot(),relativePath.getParentDirectory());
    parentFileValue=(FileValue)env.getValue(FileValue.key(parentRootedPath));
    if (parentFileValue == null) {
      return null;
    }
    PathFragment baseName=new PathFragment(relativePath.getBaseName());
    RootedPath parentRealRootedPath=parentFileValue.realRootedPath();
    realRootedPath=RootedPath.toRootedPath(parentRealRootedPath.getRoot(),parentRealRootedPath.getRelativePath().getRelative(baseName));
    if (!parentFileValue.exists()) {
      return Pair.<RootedPath,FileStateValue>of(realRootedPath,FileStateValue.NONEXISTENT_FILE_STATE_NODE);
    }
  }
  FileStateValue realFileStateValue=(FileStateValue)env.getValue(FileStateValue.key(realRootedPath));
  if (realFileStateValue == null) {
    return null;
  }
  if (realFileStateValue.getType() != FileStateValue.Type.NONEXISTENT && parentFileValue != null && !parentFileValue.isDirectory()) {
    String type=realFileStateValue.getType().toString().toLowerCase();
    String message=type + ""String_Node_Str"" + rootedPath.asPath()+ ""String_Node_Str""+ ""String_Node_Str""+ parentFileValue.realRootedPath().asPath()+ ""String_Node_Str"";
    throw new FileFunctionException(new InconsistentFilesystemException(message),Transience.TRANSIENT);
  }
  return Pair.of(realRootedPath,realFileStateValue);
}",0.992904073587385
110996,"Directory(RootedPath path){
  super(FileType.DIRECTORY,Optional.of(path),Optional.of(FileStateValue.DIRECTORY_FILE_STATE_NODE));
}","Directory(RootedPath path){
  super(FileType.DIRECTORY,Optional.of(path),Optional.<FileStateValue>of(FileStateValue.DIRECTORY_FILE_STATE_NODE));
}",0.9420289855072465
110997,"private void skipBlock(){
  int start=token.left;
  Token blockToken=token;
  syncTo(EnumSet.of(TokenKind.COLON,TokenKind.EOF));
  if (parsingMode != PYTHON) {
    reportError(lexer.createLocation(start,token.right),""String_Node_Str"" + blockToken + ""String_Node_Str""+ ""String_Node_Str"");
  }
  expect(TokenKind.COLON);
  skipSuite();
}","private void skipBlock(){
  int start=token.left;
  Token blockToken=token;
  syncTo(EnumSet.of(TokenKind.COLON,TokenKind.EOF));
  if (parsingMode != PYTHON) {
    String msg=ILLEGAL_BLOCK_KEYWORDS.containsKey(blockToken.kind) ? String.format(""String_Node_Str"",ILLEGAL_BLOCK_KEYWORDS.get(blockToken.kind)) : ""String_Node_Str"";
    reportError(lexer.createLocation(start,token.right),String.format(""String_Node_Str"",blockToken,msg));
  }
  expect(TokenKind.COLON);
  skipSuite();
}",0.6773006134969325
110998,"@Override public ActionExecutionException toActionExecutionException(String messagePrefix,boolean verboseFailures,Action action){
  if (verboseFailures) {
    return new ActionExecutionException(messagePrefix + ""String_Node_Str"" + getMessage(),this,action,isCatastrophic());
  }
 else {
    return new ActionExecutionException(messagePrefix + ""String_Node_Str"" + getMessage(),action,isCatastrophic());
  }
}","@Override public ActionExecutionException toActionExecutionException(String messagePrefix,boolean verboseFailures,Action action){
  if (verboseFailures) {
    return new ActionExecutionException(messagePrefix + ""String_Node_Str"" + getMessage()+ ""String_Node_Str"",this,action,isCatastrophic());
  }
 else {
    return new ActionExecutionException(messagePrefix + ""String_Node_Str"" + getMessage()+ ""String_Node_Str"",action,isCatastrophic());
  }
}",0.955399061032864
110999,"/** 
 * Generates an empty manifest for a rule that does not directly specify resources. <p><strong>Note:</strong> This generated manifest can then be used as the primary manifest when merging with dependencies.
 * @return the generated ApplicationManifest
 */
public static ApplicationManifest generatedManifest(RuleContext ruleContext){
  Artifact generatedManifest=ruleContext.getUniqueDirectoryArtifact(ruleContext.getRule().getName() + ""String_Node_Str"",new PathFragment(""String_Node_Str""),ruleContext.getBinOrGenfilesDirectory());
  String manifestPackage;
  if (ruleContext.attributes().isAttributeValueExplicitlySpecified(""String_Node_Str"")) {
    manifestPackage=ruleContext.attributes().get(""String_Node_Str"",Type.STRING);
  }
 else {
    manifestPackage=JavaUtil.getJavaFullClassname(ruleContext.getRule().getPackage().getNameFragment());
  }
  String contents=Joiner.on(""String_Node_Str"").join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + manifestPackage + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  ruleContext.getAnalysisEnvironment().registerAction(new FileWriteAction(ruleContext.getActionOwner(),generatedManifest,contents,false));
  return new ApplicationManifest(generatedManifest);
}","/** 
 * Generates an empty manifest for a rule that does not directly specify resources. <p><strong>Note:</strong> This generated manifest can then be used as the primary manifest when merging with dependencies.
 * @return the generated ApplicationManifest
 */
public static ApplicationManifest generatedManifest(RuleContext ruleContext){
  Artifact generatedManifest=ruleContext.getUniqueDirectoryArtifact(ruleContext.getRule().getName() + ""String_Node_Str"",new PathFragment(""String_Node_Str""),ruleContext.getBinOrGenfilesDirectory());
  String manifestPackage=AndroidCommon.getJavaPackage(ruleContext);
  String contents=Joiner.on(""String_Node_Str"").join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + manifestPackage + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  ruleContext.getAnalysisEnvironment().registerAction(new FileWriteAction(ruleContext.getActionOwner(),generatedManifest,contents,false));
  return new ApplicationManifest(generatedManifest);
}",0.8516703786191536
111000,"@Nullable @Override public SkyValue compute(SkyKey skyKey,Environment env) throws AspectFunctionException {
  SkyframeBuildView view=buildViewProvider.getSkyframeBuildView();
  NestedSetBuilder<Package> transitivePackages=NestedSetBuilder.stableOrder();
  AspectKey key=(AspectKey)skyKey.argument();
  ConfiguredAspectFactory aspectFactory=(ConfiguredAspectFactory)AspectFactory.Util.create(key.getAspect());
  PackageValue packageValue=(PackageValue)env.getValue(PackageValue.key(key.getLabel().getPackageIdentifier()));
  if (packageValue == null) {
    return null;
  }
  Target target;
  try {
    target=packageValue.getPackage().getTarget(key.getLabel().getName());
  }
 catch (  NoSuchTargetException e) {
    throw new AspectFunctionException(skyKey,e);
  }
  if (!(target instanceof Rule)) {
    throw new AspectFunctionException(new AspectCreationException(""String_Node_Str""));
  }
  final ConfiguredTargetValue configuredTargetValue=(ConfiguredTargetValue)env.getValue(ConfiguredTargetValue.key(key.getLabel(),key.getConfiguration()));
  if (configuredTargetValue == null) {
    return null;
  }
  RuleConfiguredTarget associatedTarget=(RuleConfiguredTarget)configuredTargetValue.getConfiguredTarget();
  if (associatedTarget == null) {
    return null;
  }
  SkyframeDependencyResolver resolver=view.createDependencyResolver(env);
  if (resolver == null) {
    return null;
  }
  TargetAndConfiguration ctgValue=new TargetAndConfiguration(target,key.getConfiguration());
  try {
    Set<ConfigMatchingProvider> configConditions=ConfiguredTargetFunction.getConfigConditions(target,env,resolver,ctgValue,transitivePackages);
    if (configConditions == null) {
      return null;
    }
    ListMultimap<Attribute,ConfiguredTarget> depValueMap=ConfiguredTargetFunction.computeDependencies(env,resolver,ctgValue,aspectFactory.getDefinition(),key.getParameters(),configConditions,ruleClassProvider,view.getHostConfiguration(ctgValue.getConfiguration()),transitivePackages);
    return createAspect(env,key,associatedTarget,configConditions,depValueMap,transitivePackages);
  }
 catch (  DependencyEvaluationException e) {
    throw new AspectFunctionException(e.getRootCauseSkyKey(),e.getCause());
  }
}","@Nullable @Override public SkyValue compute(SkyKey skyKey,Environment env) throws AspectFunctionException {
  SkyframeBuildView view=buildViewProvider.getSkyframeBuildView();
  NestedSetBuilder<Package> transitivePackages=NestedSetBuilder.stableOrder();
  AspectKey key=(AspectKey)skyKey.argument();
  ConfiguredAspectFactory aspectFactory=(ConfiguredAspectFactory)AspectFactory.Util.create(key.getAspect());
  PackageValue packageValue=(PackageValue)env.getValue(PackageValue.key(key.getLabel().getPackageIdentifier()));
  if (packageValue == null) {
    return null;
  }
  Target target;
  try {
    target=packageValue.getPackage().getTarget(key.getLabel().getName());
  }
 catch (  NoSuchTargetException e) {
    throw new AspectFunctionException(skyKey,e);
  }
  if (!(target instanceof Rule)) {
    throw new AspectFunctionException(new AspectCreationException(""String_Node_Str""));
  }
  final ConfiguredTargetValue configuredTargetValue=(ConfiguredTargetValue)env.getValue(ConfiguredTargetValue.key(key.getLabel(),key.getConfiguration()));
  if (configuredTargetValue == null) {
    return null;
  }
  RuleConfiguredTarget associatedTarget=(RuleConfiguredTarget)configuredTargetValue.getConfiguredTarget();
  if (associatedTarget == null) {
    return null;
  }
  SkyframeDependencyResolver resolver=view.createDependencyResolver(env);
  if (resolver == null) {
    return null;
  }
  TargetAndConfiguration ctgValue=new TargetAndConfiguration(target,key.getConfiguration());
  try {
    Set<ConfigMatchingProvider> configConditions=ConfiguredTargetFunction.getConfigConditions(target,env,resolver,ctgValue,transitivePackages);
    if (configConditions == null) {
      return null;
    }
    ListMultimap<Attribute,ConfiguredTarget> depValueMap=ConfiguredTargetFunction.computeDependencies(env,resolver,ctgValue,aspectFactory.getDefinition(),key.getParameters(),configConditions,ruleClassProvider,view.getHostConfiguration(ctgValue.getConfiguration()),transitivePackages);
    return createAspect(env,key,associatedTarget,configConditions,depValueMap,transitivePackages);
  }
 catch (  DependencyEvaluationException e) {
    throw new AspectFunctionException(e.getRootCauseSkyKey(),e.getCause());
  }
catch (  AspectCreationException e) {
    throw new AspectFunctionException(e);
  }
}",0.9813499111900532
