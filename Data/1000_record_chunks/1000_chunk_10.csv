record_number,buggy_code,fixed_code,code_similarity
9001,"@Ignore(""String_Node_Str"") @Test public void testAllowChild3() throws Exception {
  Tree rootTree1=testRoot1.getTree(""String_Node_Str"");
  Tree rootTree2=testRoot2.getTree(""String_Node_Str"");
  assertTrue(rootTree1.hasChild(""String_Node_Str""));
  assertTrue(rootTree2.hasChild(""String_Node_Str""));
  assertFalse(rootTree1.hasChild(""String_Node_Str""));
  assertFalse(rootTree2.hasChild(""String_Node_Str""));
  setupPermission(testRoot1,""String_Node_Str"",testPrincipal,false,PrivilegeConstants.JCR_READ);
  assertFalse(rootTree1.hasChild(""String_Node_Str""));
  assertTrue(rootTree2.hasChild(""String_Node_Str""));
  String uid=testPrincipal.getName();
  ContentSession session3=login(new SimpleCredentials(uid,uid.toCharArray()));
  Tree rootTree3=session3.getLatestRoot().getTree(""String_Node_Str"");
  assertFalse(rootTree3.hasChild(""String_Node_Str""));
}","@Test public void testAllowChild3() throws Exception {
  Tree rootTree1=testRoot1.getTree(""String_Node_Str"");
  Tree rootTree2=testRoot2.getTree(""String_Node_Str"");
  assertTrue(rootTree1.hasChild(""String_Node_Str""));
  assertTrue(rootTree2.hasChild(""String_Node_Str""));
  assertFalse(rootTree1.hasChild(""String_Node_Str""));
  assertFalse(rootTree2.hasChild(""String_Node_Str""));
  setupPermission(testRoot1,""String_Node_Str"",testPrincipal,false,PrivilegeConstants.JCR_READ);
  assertFalse(rootTree1.hasChild(""String_Node_Str""));
  assertTrue(rootTree2.hasChild(""String_Node_Str""));
  String uid=testPrincipal.getName();
  ContentSession session3=login(new SimpleCredentials(uid,uid.toCharArray()));
  Tree rootTree3=session3.getLatestRoot().getTree(""String_Node_Str"");
  assertFalse(rootTree3.hasChild(""String_Node_Str""));
}",0.9838805970149254
9002,"private void convertOldestHotToCold(){
  Entry<K,V> last=stack.stackPrev;
  removeFromStack(last);
  addToQueue(queue,last);
  pruneStack();
}","private void convertOldestHotToCold(){
  Entry<K,V> last=stack.stackPrev;
  if (last == stack) {
    throw new IllegalStateException();
  }
  removeFromStack(last);
  addToQueue(queue,last);
  pruneStack();
}",0.8114285714285714
9003,"/** 
 * Evict cold entries (resident and non-resident) until the memory limit is reached. The new entry is added as a cold entry, except if it is the only entry.
 * @param newCold a new cold entry
 */
private void evict(Entry<K,V> newCold){
  while ((queueSize << 5) < mapSize) {
    convertOldestHotToCold();
  }
  if (stackSize > 0) {
    addToQueue(queue,newCold);
  }
  while (usedMemory > maxMemory && queueSize > 1) {
    Entry<K,V> e=queue.queuePrev;
    usedMemory-=e.memory;
    evictionCount++;
    removeFromQueue(e);
    e.value=null;
    e.memory=0;
    addToQueue(queue2,e);
    while (queue2Size + queue2Size > stackSize) {
      e=queue2.queuePrev;
      int hash=getHash(e.key);
      invalidate(e.key,hash);
    }
  }
}","/** 
 * Evict cold entries (resident and non-resident) until the memory limit is reached. The new entry is added as a cold entry, except if it is the only entry.
 * @param newCold a new cold entry
 */
private void evict(Entry<K,V> newCold){
  while (queueSize <= (mapSize >>> 5) && stackSize > 0) {
    convertOldestHotToCold();
  }
  if (stackSize > 0) {
    addToQueue(queue,newCold);
  }
  while (usedMemory > maxMemory && queueSize > 1) {
    Entry<K,V> e=queue.queuePrev;
    usedMemory-=e.memory;
    evictionCount++;
    removeFromQueue(e);
    e.value=null;
    e.memory=0;
    addToQueue(queue2,e);
    while (queue2Size + queue2Size > stackSize) {
      e=queue2.queuePrev;
      int hash=getHash(e.key);
      invalidate(e.key,hash);
    }
  }
}",0.9765572672471534
9004,"/** 
 * Ensure the last entry of the stack is cold.
 */
private void pruneStack(){
  while (true) {
    Entry<K,V> last=stack.stackPrev;
    if (last == stack || last.isHot()) {
      break;
    }
    removeFromStack(last);
  }
}","/** 
 * Ensure the last entry of the stack is cold.
 */
private void pruneStack(){
  while (true) {
    Entry<K,V> last=stack.stackPrev;
    if (last.isHot()) {
      break;
    }
    removeFromStack(last);
  }
}",0.9614512471655328
9005,"/** 
 * Calculate the granted permissions by evaluating the given privileges. Note, that only built-in privileges can be mapped to permissions. Any other privileges will be ignored.
 * @param bits The set of privileges present at given tree.
 * @param parentBits The privileges present on the parent tree. These arerequired in order to determine permissions that include a modification of the parent tree (add_child_nodes, remove_child_nodes).
 * @param isAllow {@code true} if the privileges are granted; {@code false}otherwise.
 * @return the resulting permissions.
 */
public static long calculatePermissions(@Nonnull PrivilegeBits bits,@Nonnull PrivilegeBits parentBits,boolean isAllow){
  long privs=bits.d.longValue();
  long parentPrivs=parentBits.d.longValue();
  long perm=Permissions.NO_PERMISSION;
  if ((privs & READ) == READ) {
    perm|=Permissions.READ;
  }
 else {
    if ((privs & READ_NODES) == READ_NODES) {
      perm|=Permissions.READ_NODE;
    }
 else     if (((privs & READ_PROPERTIES) == READ_PROPERTIES)) {
      perm|=Permissions.READ_PROPERTY;
    }
  }
  if ((privs & MODIFY_PROPERTIES) == MODIFY_PROPERTIES) {
    perm|=Permissions.SET_PROPERTY;
  }
 else {
    if ((privs & ADD_PROPERTIES) == ADD_PROPERTIES) {
      perm|=Permissions.ADD_PROPERTY;
    }
 else     if ((privs & ALTER_PROPERTIES) == ALTER_PROPERTIES) {
      perm|=Permissions.MODIFY_PROPERTY;
    }
 else     if ((privs & REMOVE_PROPERTIES) == REMOVE_PROPERTIES) {
      perm|=Permissions.REMOVE_PROPERTY;
    }
  }
  if ((parentPrivs & ADD_CHILD_NODES) == ADD_CHILD_NODES) {
    perm|=Permissions.ADD_NODE;
  }
  if (isAllow) {
    if ((parentPrivs & REMOVE_CHILD_NODES) == REMOVE_CHILD_NODES && (privs & REMOVE_NODE) == REMOVE_NODE) {
      perm|=Permissions.REMOVE_NODE;
    }
  }
 else {
    if ((parentPrivs & REMOVE_CHILD_NODES) == REMOVE_CHILD_NODES || (privs & REMOVE_NODE) == REMOVE_NODE) {
      perm|=Permissions.REMOVE_NODE;
    }
  }
  if ((parentPrivs & ADD_CHILD_NODES) == ADD_CHILD_NODES && (parentPrivs & REMOVE_CHILD_NODES) == REMOVE_CHILD_NODES) {
    perm|=Permissions.MODIFY_CHILD_NODE_COLLECTION;
  }
  if ((privs & READ_AC) == READ_AC) {
    perm|=Permissions.READ_ACCESS_CONTROL;
  }
  if ((privs & MODIFY_AC) == MODIFY_AC) {
    perm|=Permissions.MODIFY_ACCESS_CONTROL;
  }
  if ((privs & LIFECYCLE_MNGMT) == LIFECYCLE_MNGMT) {
    perm|=Permissions.LIFECYCLE_MANAGEMENT;
  }
  if ((privs & LOCK_MNGMT) == LOCK_MNGMT) {
    perm|=Permissions.LOCK_MANAGEMENT;
  }
  if ((privs & NODE_TYPE_MNGMT) == NODE_TYPE_MNGMT) {
    perm|=Permissions.NODE_TYPE_MANAGEMENT;
  }
  if ((privs & RETENTION_MNGMT) == RETENTION_MNGMT) {
    perm|=Permissions.RETENTION_MANAGEMENT;
  }
  if ((privs & VERSION_MNGMT) == VERSION_MNGMT) {
    perm|=Permissions.VERSION_MANAGEMENT;
  }
  if ((privs & WORKSPACE_MNGMT) == WORKSPACE_MNGMT) {
    perm|=Permissions.WORKSPACE_MANAGEMENT;
  }
  if ((privs & NODE_TYPE_DEF_MNGMT) == NODE_TYPE_DEF_MNGMT) {
    perm|=Permissions.NODE_TYPE_DEFINITION_MANAGEMENT;
  }
  if ((privs & NAMESPACE_MNGMT) == NAMESPACE_MNGMT) {
    perm|=Permissions.NAMESPACE_MANAGEMENT;
  }
  if ((privs & PRIVILEGE_MNGMT) == PRIVILEGE_MNGMT) {
    perm|=Permissions.PRIVILEGE_MANAGEMENT;
  }
  if ((privs & USER_MNGMT) == USER_MNGMT) {
    perm|=Permissions.USER_MANAGEMENT;
  }
  return perm;
}","/** 
 * Calculate the granted permissions by evaluating the given privileges. Note, that only built-in privileges can be mapped to permissions. Any other privileges will be ignored.
 * @param bits The set of privileges present at given tree.
 * @param parentBits The privileges present on the parent tree. These arerequired in order to determine permissions that include a modification of the parent tree (add_child_nodes, remove_child_nodes).
 * @param isAllow {@code true} if the privileges are granted; {@code false}otherwise.
 * @return the resulting permissions.
 */
public static long calculatePermissions(@Nonnull PrivilegeBits bits,@Nonnull PrivilegeBits parentBits,boolean isAllow){
  long privs=bits.d.longValue();
  long parentPrivs=parentBits.d.longValue();
  long perm=Permissions.NO_PERMISSION;
  if ((privs & READ) == READ) {
    perm|=Permissions.READ;
  }
 else {
    if ((privs & READ_NODES) == READ_NODES) {
      perm|=Permissions.READ_NODE;
    }
 else     if (((privs & READ_PROPERTIES) == READ_PROPERTIES)) {
      perm|=Permissions.READ_PROPERTY;
    }
  }
  if ((privs & MODIFY_PROPERTIES) == MODIFY_PROPERTIES) {
    perm|=Permissions.SET_PROPERTY;
  }
 else {
    if ((privs & ADD_PROPERTIES) == ADD_PROPERTIES) {
      perm|=Permissions.ADD_PROPERTY;
    }
    if ((privs & ALTER_PROPERTIES) == ALTER_PROPERTIES) {
      perm|=Permissions.MODIFY_PROPERTY;
    }
    if ((privs & REMOVE_PROPERTIES) == REMOVE_PROPERTIES) {
      perm|=Permissions.REMOVE_PROPERTY;
    }
  }
  if ((parentPrivs & ADD_CHILD_NODES) == ADD_CHILD_NODES) {
    perm|=Permissions.ADD_NODE;
  }
  if (isAllow) {
    if ((parentPrivs & REMOVE_CHILD_NODES) == REMOVE_CHILD_NODES && (privs & REMOVE_NODE) == REMOVE_NODE) {
      perm|=Permissions.REMOVE_NODE;
    }
  }
 else {
    if ((parentPrivs & REMOVE_CHILD_NODES) == REMOVE_CHILD_NODES || (privs & REMOVE_NODE) == REMOVE_NODE) {
      perm|=Permissions.REMOVE_NODE;
    }
  }
  if ((parentPrivs & ADD_CHILD_NODES) == ADD_CHILD_NODES && (parentPrivs & REMOVE_CHILD_NODES) == REMOVE_CHILD_NODES) {
    perm|=Permissions.MODIFY_CHILD_NODE_COLLECTION;
  }
  if ((privs & READ_AC) == READ_AC) {
    perm|=Permissions.READ_ACCESS_CONTROL;
  }
  if ((privs & MODIFY_AC) == MODIFY_AC) {
    perm|=Permissions.MODIFY_ACCESS_CONTROL;
  }
  if ((privs & LIFECYCLE_MNGMT) == LIFECYCLE_MNGMT) {
    perm|=Permissions.LIFECYCLE_MANAGEMENT;
  }
  if ((privs & LOCK_MNGMT) == LOCK_MNGMT) {
    perm|=Permissions.LOCK_MANAGEMENT;
  }
  if ((privs & NODE_TYPE_MNGMT) == NODE_TYPE_MNGMT) {
    perm|=Permissions.NODE_TYPE_MANAGEMENT;
  }
  if ((privs & RETENTION_MNGMT) == RETENTION_MNGMT) {
    perm|=Permissions.RETENTION_MANAGEMENT;
  }
  if ((privs & VERSION_MNGMT) == VERSION_MNGMT) {
    perm|=Permissions.VERSION_MANAGEMENT;
  }
  if ((privs & WORKSPACE_MNGMT) == WORKSPACE_MNGMT) {
    perm|=Permissions.WORKSPACE_MANAGEMENT;
  }
  if ((privs & NODE_TYPE_DEF_MNGMT) == NODE_TYPE_DEF_MNGMT) {
    perm|=Permissions.NODE_TYPE_DEFINITION_MANAGEMENT;
  }
  if ((privs & NAMESPACE_MNGMT) == NAMESPACE_MNGMT) {
    perm|=Permissions.NAMESPACE_MANAGEMENT;
  }
  if ((privs & PRIVILEGE_MNGMT) == PRIVILEGE_MNGMT) {
    perm|=Permissions.PRIVILEGE_MANAGEMENT;
  }
  if ((privs & USER_MNGMT) == USER_MNGMT) {
    perm|=Permissions.USER_MANAGEMENT;
  }
  return perm;
}",0.99818676337262
9006,"@Test public void testCalculatePermissions(){
  PrivilegeBitsProvider provider=new PrivilegeBitsProvider(root);
  Map<PrivilegeBits,Long> simple=new HashMap<PrivilegeBits,Long>();
  simple.put(PrivilegeBits.EMPTY,Permissions.NO_PERMISSION);
  simple.put(provider.getBits(JCR_READ),Permissions.READ);
  simple.put(provider.getBits(JCR_LOCK_MANAGEMENT),Permissions.LOCK_MANAGEMENT);
  simple.put(provider.getBits(JCR_VERSION_MANAGEMENT),Permissions.VERSION_MANAGEMENT);
  simple.put(provider.getBits(JCR_READ_ACCESS_CONTROL),Permissions.READ_ACCESS_CONTROL);
  simple.put(provider.getBits(JCR_MODIFY_ACCESS_CONTROL),Permissions.MODIFY_ACCESS_CONTROL);
  simple.put(provider.getBits(REP_READ_NODES),Permissions.READ_NODE);
  simple.put(provider.getBits(REP_READ_PROPERTIES),Permissions.READ_PROPERTY);
  simple.put(provider.getBits(REP_USER_MANAGEMENT),Permissions.USER_MANAGEMENT);
  for (  PrivilegeBits pb : simple.keySet()) {
    long expected=simple.get(pb).longValue();
    assertTrue(expected == PrivilegeBits.calculatePermissions(pb,PrivilegeBits.EMPTY,true));
  }
  PrivilegeBits all=provider.getBits(JCR_ALL);
  assertFalse(Permissions.ALL == PrivilegeBits.calculatePermissions(all,PrivilegeBits.EMPTY,true));
  assertTrue(Permissions.ALL == PrivilegeBits.calculatePermissions(all,all,true));
  PrivilegeBits addChild=provider.getBits(JCR_ADD_CHILD_NODES);
  assertFalse(Permissions.ADD_NODE == PrivilegeBits.calculatePermissions(addChild,PrivilegeBits.EMPTY,true));
  assertTrue(Permissions.ADD_NODE == PrivilegeBits.calculatePermissions(PrivilegeBits.EMPTY,addChild,true));
  PrivilegeBits removeChild=provider.getBits(JCR_REMOVE_CHILD_NODES);
  assertFalse(Permissions.REMOVE_NODE == PrivilegeBits.calculatePermissions(removeChild,PrivilegeBits.EMPTY,true));
  assertFalse(Permissions.REMOVE_NODE == PrivilegeBits.calculatePermissions(PrivilegeBits.EMPTY,removeChild,true));
  PrivilegeBits removeNode=provider.getBits(JCR_REMOVE_NODE);
  assertFalse(Permissions.REMOVE_NODE == PrivilegeBits.calculatePermissions(removeNode,PrivilegeBits.EMPTY,true));
  assertFalse(Permissions.REMOVE_NODE == PrivilegeBits.calculatePermissions(PrivilegeBits.EMPTY,removeNode,true));
  PrivilegeBits remove=provider.getBits(JCR_REMOVE_CHILD_NODES,JCR_REMOVE_NODE);
  assertFalse(Permissions.REMOVE_NODE == PrivilegeBits.calculatePermissions(remove,PrivilegeBits.EMPTY,true));
  assertFalse(Permissions.REMOVE_NODE == PrivilegeBits.calculatePermissions(PrivilegeBits.EMPTY,remove,true));
  assertTrue(Permissions.REMOVE_NODE == PrivilegeBits.calculatePermissions(remove,remove,true));
}","@Test public void testCalculatePermissions(){
  PrivilegeBitsProvider provider=new PrivilegeBitsProvider(root);
  Map<PrivilegeBits,Long> simple=new HashMap<PrivilegeBits,Long>();
  simple.put(PrivilegeBits.EMPTY,Permissions.NO_PERMISSION);
  simple.put(provider.getBits(JCR_READ),Permissions.READ);
  simple.put(provider.getBits(JCR_LOCK_MANAGEMENT),Permissions.LOCK_MANAGEMENT);
  simple.put(provider.getBits(JCR_VERSION_MANAGEMENT),Permissions.VERSION_MANAGEMENT);
  simple.put(provider.getBits(JCR_READ_ACCESS_CONTROL),Permissions.READ_ACCESS_CONTROL);
  simple.put(provider.getBits(JCR_MODIFY_ACCESS_CONTROL),Permissions.MODIFY_ACCESS_CONTROL);
  simple.put(provider.getBits(REP_READ_NODES),Permissions.READ_NODE);
  simple.put(provider.getBits(REP_READ_PROPERTIES),Permissions.READ_PROPERTY);
  simple.put(provider.getBits(REP_USER_MANAGEMENT),Permissions.USER_MANAGEMENT);
  simple.put(provider.getBits(JCR_MODIFY_PROPERTIES),Permissions.SET_PROPERTY);
  simple.put(provider.getBits(REP_ADD_PROPERTIES),Permissions.ADD_PROPERTY);
  simple.put(provider.getBits(REP_ALTER_PROPERTIES),Permissions.MODIFY_PROPERTY);
  simple.put(provider.getBits(REP_REMOVE_PROPERTIES),Permissions.REMOVE_PROPERTY);
  for (  PrivilegeBits pb : simple.keySet()) {
    long expected=simple.get(pb).longValue();
    assertTrue(expected == PrivilegeBits.calculatePermissions(pb,PrivilegeBits.EMPTY,true));
    assertTrue(expected == PrivilegeBits.calculatePermissions(pb,pb,true));
  }
  PrivilegeBits add_change=provider.getBits(REP_ADD_PROPERTIES,REP_ALTER_PROPERTIES);
  long permissions=(Permissions.ADD_PROPERTY | Permissions.MODIFY_PROPERTY);
  assertTrue(permissions == PrivilegeBits.calculatePermissions(add_change,PrivilegeBits.EMPTY,true));
  assertTrue(permissions == PrivilegeBits.calculatePermissions(add_change,add_change,true));
  PrivilegeBits add_rm=provider.getBits(REP_ADD_PROPERTIES,REP_REMOVE_PROPERTIES);
  permissions=(Permissions.ADD_PROPERTY | Permissions.REMOVE_PROPERTY);
  assertTrue(permissions == PrivilegeBits.calculatePermissions(add_rm,PrivilegeBits.EMPTY,true));
  assertTrue(permissions == PrivilegeBits.calculatePermissions(add_rm,add_rm,true));
  PrivilegeBits ch_rm=provider.getBits(REP_ALTER_PROPERTIES,REP_REMOVE_PROPERTIES);
  permissions=(Permissions.MODIFY_PROPERTY | Permissions.REMOVE_PROPERTY);
  assertTrue(permissions == PrivilegeBits.calculatePermissions(ch_rm,PrivilegeBits.EMPTY,true));
  assertTrue(permissions == PrivilegeBits.calculatePermissions(ch_rm,add_rm,true));
  PrivilegeBits all=provider.getBits(JCR_ALL);
  assertFalse(Permissions.ALL == PrivilegeBits.calculatePermissions(all,PrivilegeBits.EMPTY,true));
  assertTrue(Permissions.ALL == PrivilegeBits.calculatePermissions(all,all,true));
  PrivilegeBits addChild=provider.getBits(JCR_ADD_CHILD_NODES);
  assertFalse(Permissions.ADD_NODE == PrivilegeBits.calculatePermissions(addChild,PrivilegeBits.EMPTY,true));
  assertTrue(Permissions.ADD_NODE == PrivilegeBits.calculatePermissions(PrivilegeBits.EMPTY,addChild,true));
  PrivilegeBits removeChild=provider.getBits(JCR_REMOVE_CHILD_NODES);
  assertFalse(Permissions.REMOVE_NODE == PrivilegeBits.calculatePermissions(removeChild,PrivilegeBits.EMPTY,true));
  assertFalse(Permissions.REMOVE_NODE == PrivilegeBits.calculatePermissions(PrivilegeBits.EMPTY,removeChild,true));
  PrivilegeBits removeNode=provider.getBits(JCR_REMOVE_NODE);
  assertFalse(Permissions.REMOVE_NODE == PrivilegeBits.calculatePermissions(removeNode,PrivilegeBits.EMPTY,true));
  assertFalse(Permissions.REMOVE_NODE == PrivilegeBits.calculatePermissions(PrivilegeBits.EMPTY,removeNode,true));
  PrivilegeBits remove=provider.getBits(JCR_REMOVE_CHILD_NODES,JCR_REMOVE_NODE);
  assertFalse(Permissions.REMOVE_NODE == PrivilegeBits.calculatePermissions(remove,PrivilegeBits.EMPTY,true));
  assertFalse(Permissions.REMOVE_NODE == PrivilegeBits.calculatePermissions(PrivilegeBits.EMPTY,remove,true));
  assertTrue(Permissions.REMOVE_NODE == PrivilegeBits.calculatePermissions(remove,remove,true));
}",0.7823975720789075
9007,"public static void main(String[] args) throws Exception {
  OptionParser parser=new OptionParser();
  OptionSpec<File> base=parser.accepts(""String_Node_Str"",""String_Node_Str"").withRequiredArg().ofType(File.class).defaultsTo(new File(""String_Node_Str""));
  OptionSpec<String> host=parser.accepts(""String_Node_Str"",""String_Node_Str"").withRequiredArg().defaultsTo(""String_Node_Str"");
  OptionSpec<Integer> port=parser.accepts(""String_Node_Str"",""String_Node_Str"").withRequiredArg().ofType(Integer.class).defaultsTo(27017);
  OptionSpec<String> dbName=parser.accepts(""String_Node_Str"",""String_Node_Str"").withRequiredArg();
  OptionSpec<Boolean> dropDBAfterTest=parser.accepts(""String_Node_Str"",""String_Node_Str"").withOptionalArg().ofType(Boolean.class).defaultsTo(true);
  OptionSpec<Boolean> mmap=parser.accepts(""String_Node_Str"",""String_Node_Str"").withOptionalArg().ofType(Boolean.class).defaultsTo(""String_Node_Str"".equals(System.getProperty(""String_Node_Str"")));
  OptionSpec<Integer> cache=parser.accepts(""String_Node_Str"",""String_Node_Str"").withRequiredArg().ofType(Integer.class).defaultsTo(100);
  OptionSpec<File> wikipedia=parser.accepts(""String_Node_Str"",""String_Node_Str"").withRequiredArg().ofType(File.class);
  OptionSpec<Boolean> runAsAdmin=parser.accepts(""String_Node_Str"",""String_Node_Str"").withRequiredArg().ofType(Boolean.class).defaultsTo(Boolean.FALSE);
  OptionSpec<Integer> itemsToRead=parser.accepts(""String_Node_Str"",""String_Node_Str"").withRequiredArg().ofType(Integer.class).defaultsTo(1000);
  OptionSpec<Integer> bgReaders=parser.accepts(""String_Node_Str"",""String_Node_Str"").withRequiredArg().ofType(Integer.class).defaultsTo(20);
  OptionSpec<Boolean> report=parser.accepts(""String_Node_Str"",""String_Node_Str"").withOptionalArg().ofType(Boolean.class).defaultsTo(Boolean.FALSE);
  OptionSet options=parser.parse(args);
  int cacheSize=cache.value(options);
  RepositoryFixture[] allFixtures=new RepositoryFixture[]{new JackrabbitRepositoryFixture(base.value(options),cacheSize),OakRepositoryFixture.getMemory(cacheSize * MB),OakRepositoryFixture.getDefault(base.value(options),cacheSize * MB),OakRepositoryFixture.getMongo(host.value(options),port.value(options),dbName.value(options),dropDBAfterTest.value(options),cacheSize * MB),OakRepositoryFixture.getMongoLog(host.value(options),port.value(options),cacheSize * MB),OakRepositoryFixture.getSegment(host.value(options),port.value(options),cacheSize * MB),OakRepositoryFixture.getTar(base.value(options),256 * 1024 * 1024,mmap.value(options))};
  Benchmark[] allBenchmarks=new Benchmark[]{new LoginTest(),new LoginLogoutTest(),new NamespaceTest(),new ReadPropertyTest(),GetNodeTest.withAdmin(),GetNodeTest.withAnonymous(),new GetDeepNodeTest(),new SetPropertyTest(),new SmallFileReadTest(),new SmallFileWriteTest(),new ConcurrentReadTest(),new ConcurrentReadWriteTest(),new ConcurrentWriteReadTest(),new ConcurrentWriteTest(),new SimpleSearchTest(),new SQL2SearchTest(),new DescendantSearchTest(),new SQL2DescendantSearchTest(),new CreateManyChildNodesTest(),new UpdateManyChildNodesTest(),new TransientManyChildNodesTest(),new WikipediaImport(wikipedia.value(options)),new CreateNodesBenchmark(),new ManyNodes(),new ObservationTest(),new XmlImportTest(),new FlatTreeWithAceForSamePrincipalTest(),new ReadDeepTreeTest(runAsAdmin.value(options),itemsToRead.value(options),report.value(options)),new ConcurrentReadAccessControlledTreeTest(runAsAdmin.value(options),itemsToRead.value(options),bgReaders.value(options),report.value(options)),new ConcurrentReadDeepTreeTest(runAsAdmin.value(options),itemsToRead.value(options),bgReaders.value(options),report.value(options)),ReadManyTest.linear(""String_Node_Str"",1,ReadManyTest.EMPTY),ReadManyTest.linear(""String_Node_Str"",1,ReadManyTest.FILES),ReadManyTest.linear(""String_Node_Str"",1,ReadManyTest.NODES),ReadManyTest.uniform(""String_Node_Str"",1,ReadManyTest.EMPTY),ReadManyTest.uniform(""String_Node_Str"",1,ReadManyTest.FILES),ReadManyTest.uniform(""String_Node_Str"",1,ReadManyTest.NODES)};
  Set<String> argset=Sets.newHashSet(options.nonOptionArguments());
  List<RepositoryFixture> fixtures=Lists.newArrayList();
  for (  RepositoryFixture fixture : allFixtures) {
    if (argset.remove(fixture.toString())) {
      fixtures.add(fixture);
    }
  }
  List<Benchmark> benchmarks=Lists.newArrayList();
  for (  Benchmark benchmark : allBenchmarks) {
    if (argset.remove(benchmark.toString())) {
      benchmarks.add(benchmark);
    }
  }
  if (argset.isEmpty()) {
    for (    Benchmark benchmark : benchmarks) {
      benchmark.run(fixtures);
    }
  }
 else {
    System.err.println(""String_Node_Str"" + argset);
  }
}","public static void main(String[] args) throws Exception {
  OptionParser parser=new OptionParser();
  OptionSpec<File> base=parser.accepts(""String_Node_Str"",""String_Node_Str"").withRequiredArg().ofType(File.class).defaultsTo(new File(""String_Node_Str""));
  OptionSpec<String> host=parser.accepts(""String_Node_Str"",""String_Node_Str"").withRequiredArg().defaultsTo(""String_Node_Str"");
  OptionSpec<Integer> port=parser.accepts(""String_Node_Str"",""String_Node_Str"").withRequiredArg().ofType(Integer.class).defaultsTo(27017);
  OptionSpec<String> dbName=parser.accepts(""String_Node_Str"",""String_Node_Str"").withRequiredArg();
  OptionSpec<Boolean> dropDBAfterTest=parser.accepts(""String_Node_Str"",""String_Node_Str"").withOptionalArg().ofType(Boolean.class).defaultsTo(true);
  OptionSpec<Boolean> mmap=parser.accepts(""String_Node_Str"",""String_Node_Str"").withOptionalArg().ofType(Boolean.class).defaultsTo(""String_Node_Str"".equals(System.getProperty(""String_Node_Str"")));
  OptionSpec<Integer> cache=parser.accepts(""String_Node_Str"",""String_Node_Str"").withRequiredArg().ofType(Integer.class).defaultsTo(100);
  OptionSpec<File> wikipedia=parser.accepts(""String_Node_Str"",""String_Node_Str"").withRequiredArg().ofType(File.class);
  OptionSpec<Boolean> runAsAdmin=parser.accepts(""String_Node_Str"",""String_Node_Str"").withRequiredArg().ofType(Boolean.class).defaultsTo(Boolean.FALSE);
  OptionSpec<Integer> itemsToRead=parser.accepts(""String_Node_Str"",""String_Node_Str"").withRequiredArg().ofType(Integer.class).defaultsTo(1000);
  OptionSpec<Integer> bgReaders=parser.accepts(""String_Node_Str"",""String_Node_Str"").withRequiredArg().ofType(Integer.class).defaultsTo(20);
  OptionSpec<Boolean> report=parser.accepts(""String_Node_Str"",""String_Node_Str"").withOptionalArg().ofType(Boolean.class).defaultsTo(Boolean.FALSE);
  OptionSet options=parser.parse(args);
  int cacheSize=cache.value(options);
  RepositoryFixture[] allFixtures=new RepositoryFixture[]{new JackrabbitRepositoryFixture(base.value(options),cacheSize),OakRepositoryFixture.getMemory(cacheSize * MB),OakRepositoryFixture.getDefault(base.value(options),cacheSize * MB),OakRepositoryFixture.getMongo(host.value(options),port.value(options),dbName.value(options),dropDBAfterTest.value(options),cacheSize * MB),OakRepositoryFixture.getSegment(host.value(options),port.value(options),cacheSize * MB),OakRepositoryFixture.getTar(base.value(options),256 * 1024 * 1024,mmap.value(options))};
  Benchmark[] allBenchmarks=new Benchmark[]{new LoginTest(),new LoginLogoutTest(),new NamespaceTest(),new ReadPropertyTest(),GetNodeTest.withAdmin(),GetNodeTest.withAnonymous(),new GetDeepNodeTest(),new SetPropertyTest(),new SmallFileReadTest(),new SmallFileWriteTest(),new ConcurrentReadTest(),new ConcurrentReadWriteTest(),new ConcurrentWriteReadTest(),new ConcurrentWriteTest(),new SimpleSearchTest(),new SQL2SearchTest(),new DescendantSearchTest(),new SQL2DescendantSearchTest(),new CreateManyChildNodesTest(),new UpdateManyChildNodesTest(),new TransientManyChildNodesTest(),new WikipediaImport(wikipedia.value(options)),new CreateNodesBenchmark(),new ManyNodes(),new ObservationTest(),new XmlImportTest(),new FlatTreeWithAceForSamePrincipalTest(),new ReadDeepTreeTest(runAsAdmin.value(options),itemsToRead.value(options),report.value(options)),new ConcurrentReadAccessControlledTreeTest(runAsAdmin.value(options),itemsToRead.value(options),bgReaders.value(options),report.value(options)),new ConcurrentReadDeepTreeTest(runAsAdmin.value(options),itemsToRead.value(options),bgReaders.value(options),report.value(options)),ReadManyTest.linear(""String_Node_Str"",1,ReadManyTest.EMPTY),ReadManyTest.linear(""String_Node_Str"",1,ReadManyTest.FILES),ReadManyTest.linear(""String_Node_Str"",1,ReadManyTest.NODES),ReadManyTest.uniform(""String_Node_Str"",1,ReadManyTest.EMPTY),ReadManyTest.uniform(""String_Node_Str"",1,ReadManyTest.FILES),ReadManyTest.uniform(""String_Node_Str"",1,ReadManyTest.NODES)};
  Set<String> argset=Sets.newHashSet(options.nonOptionArguments());
  List<RepositoryFixture> fixtures=Lists.newArrayList();
  for (  RepositoryFixture fixture : allFixtures) {
    if (argset.remove(fixture.toString())) {
      fixtures.add(fixture);
    }
  }
  List<Benchmark> benchmarks=Lists.newArrayList();
  for (  Benchmark benchmark : allBenchmarks) {
    if (argset.remove(benchmark.toString())) {
      benchmarks.add(benchmark);
    }
  }
  if (argset.isEmpty()) {
    for (    Benchmark benchmark : benchmarks) {
      benchmark.run(fixtures);
    }
  }
 else {
    System.err.println(""String_Node_Str"" + argset);
  }
}",0.9903208265361608
9008,"private void updateAndLogTimes(String operation,long start,int paramSize,int resultSize){
  long now=now();
  if (startTime == 0) {
    startTime=now;
  }
  Count c=counts.get(operation);
  if (c == null) {
    c=new Count();
    counts.put(operation,c);
  }
  c.update(now - start,paramSize,resultSize);
  long t=now - lastLogTime;
  if (t >= 10000) {
    totalLogTime+=t;
    lastLogTime=now;
    long totalCount=0, totalTime=0;
    for (    Count count : counts.values()) {
      totalCount+=count.count;
      totalTime+=count.total;
    }
    totalCount=Math.max(1,totalCount);
    totalTime=Math.max(1,totalTime);
    for (    Entry<String,Count> e : counts.entrySet()) {
      c=e.getValue();
      long count=c.count;
      long total=c.total;
      long in=c.paramSize / 1024 / 1024;
      long out=c.resultSize / 1024 / 1024;
      if (count > 0) {
        log(e.getKey() + ""String_Node_Str"" + count+ ""String_Node_Str""+ (100 * count / totalCount)+ ""String_Node_Str""+ ""String_Node_Str""+ in+ ""String_Node_Str""+ out+ ""String_Node_Str""+ total+ ""String_Node_Str""+ (100 * total / totalTime)+ ""String_Node_Str"");
      }
    }
    log(""String_Node_Str"" + totalCount + ""String_Node_Str""+ totalTime+ ""String_Node_Str""+ (100 * totalTime / totalLogTime)+ ""String_Node_Str"");
    HashMap<String,Integer> map=commonCalls;
    int top=10;
    int max=Integer.MAX_VALUE;
    for (int i=0; i < top; ) {
      int best=0;
      for (      int x : map.values()) {
        if (x < max && x > best) {
          best=x;
        }
      }
      for (      Entry<String,Integer> e : map.entrySet()) {
        if (e.getValue() >= best && e.getValue() < max) {
          log(""String_Node_Str"" + e.getValue() + ""String_Node_Str""+ e.getKey());
          i++;
          if (i >= top) {
            break;
          }
        }
      }
      max=best;
    }
    commonCalls.clear();
    log(""String_Node_Str"");
  }
}","private void updateAndLogTimes(String operation,long start,int paramSize,int resultSize){
  long now=now();
  if (startTime == 0) {
    startTime=now;
  }
  Count c=counts.get(operation);
  if (c == null) {
    c=new Count();
    counts.put(operation,c);
  }
  c.update(now - start,paramSize,resultSize);
  long t=now - lastLogTime;
  if (t >= 10000) {
    totalLogTime+=t;
    lastLogTime=now;
    long totalCount=0, totalTime=0;
    for (    Count count : counts.values()) {
      totalCount+=count.count;
      totalTime+=count.total;
    }
    totalCount=Math.max(1,totalCount);
    totalTime=Math.max(1,totalTime);
    for (    Entry<String,Count> e : counts.entrySet()) {
      c=e.getValue();
      long count=c.count;
      long total=c.total;
      long in=c.paramSize / 1024 / 1024;
      long out=c.resultSize / 1024 / 1024;
      if (count > 0) {
        log(e.getKey() + ""String_Node_Str"" + count+ ""String_Node_Str""+ (100 * count / totalCount)+ ""String_Node_Str""+ ""String_Node_Str""+ in+ ""String_Node_Str""+ out+ ""String_Node_Str""+ total+ ""String_Node_Str""+ (100 * total / totalTime)+ ""String_Node_Str"");
      }
    }
    log(""String_Node_Str"" + totalCount + ""String_Node_Str""+ totalTime+ ""String_Node_Str""+ (100 * totalTime / totalLogTime)+ ""String_Node_Str"");
    Map<String,Integer> map=slowCalls;
    int top=10;
    int max=Integer.MAX_VALUE;
    for (int i=0; i < top; ) {
      int best=0;
      for (      int x : map.values()) {
        if (x < max && x > best) {
          best=x;
        }
      }
      for (      Entry<String,Integer> e : map.entrySet()) {
        if (e.getValue() >= best && e.getValue() < max) {
          log(""String_Node_Str"" + e.getValue() + ""String_Node_Str""+ e.getKey());
          i++;
          if (i >= top) {
            break;
          }
        }
      }
      if (i >= map.size()) {
        break;
      }
      max=best;
    }
    slowCalls.clear();
    log(""String_Node_Str"");
  }
}",0.9801980198019802
9009,"private synchronized void logCommonCall(long start,String key){
  int time=(int)(System.currentTimeMillis() - start);
  if (time <= 0) {
    return;
  }
  HashMap<String,Integer> map=commonCalls;
  Integer oldCount=map.get(key);
  if (oldCount == null) {
    map.put(key,time);
  }
 else {
    map.put(key,oldCount + time);
  }
  int maxElements=1000;
  int minCount=1;
  while (map.size() > maxElements) {
    for (Iterator<Map.Entry<String,Integer>> ei=map.entrySet().iterator(); ei.hasNext(); ) {
      Map.Entry<String,Integer> e=ei.next();
      if (e.getValue() <= minCount) {
        ei.remove();
      }
    }
    if (map.size() > maxElements) {
      minCount++;
    }
  }
}","private void logCommonCall(long start,String key){
  int time=(int)(System.currentTimeMillis() - start);
  if (time <= 0) {
    return;
  }
  Map<String,Integer> map=slowCalls;
  Integer oldCount=map.get(key);
  if (oldCount == null) {
    map.put(key,time);
  }
 else {
    map.put(key,oldCount + time);
  }
  int maxElements=1000;
  int minCount=1;
  while (map.size() > maxElements) {
    for (Iterator<Map.Entry<String,Integer>> ei=map.entrySet().iterator(); ei.hasNext(); ) {
      Map.Entry<String,Integer> e=ei.next();
      if (e.getValue() <= minCount) {
        ei.remove();
      }
    }
    if (map.size() > maxElements) {
      minCount++;
    }
  }
}",0.979955456570156
9010,"@Override public synchronized String getNodes(String path,String revisionId,int depth,long offset,int maxChildNodes,String filter) throws MicroKernelException {
  if (depth != 0) {
    throw new MicroKernelException(""String_Node_Str"" + depth);
  }
  revisionId=revisionId != null ? revisionId : headRevision.toString();
  revisionId=stripBranchRevMarker(revisionId);
  Revision rev=Revision.fromString(revisionId);
  Node n=getNode(path,rev);
  if (n == null) {
    return null;
  }
  JsopStream json=new JsopStream();
  boolean includeId=filter != null && filter.contains(""String_Node_Str"");
  includeId|=filter != null && filter.contains(""String_Node_Str"");
  json.object();
  n.append(json,includeId);
  int max;
  if (maxChildNodes == -1) {
    max=MANY_CHILDREN_THRESHOLD;
    maxChildNodes=Integer.MAX_VALUE;
  }
 else {
    long m=maxChildNodes + 1L + offset;
    max=(int)Math.min(m,Integer.MAX_VALUE);
  }
  if (offset > 0) {
    max=Integer.MAX_VALUE;
  }
  Children c=getChildren(path,rev,max);
  for (long i=offset; i < c.children.size(); i++) {
    if (maxChildNodes-- <= 0) {
      break;
    }
    String name=PathUtils.getName(c.children.get((int)i));
    json.key(name).object().endObject();
  }
  if (c.hasMore) {
    json.key(""String_Node_Str"").value(Integer.MAX_VALUE);
  }
 else {
    json.key(""String_Node_Str"").value(c.children.size());
  }
  json.endObject();
  return json.toString();
}","@Override public synchronized String getNodes(String path,String revisionId,int depth,long offset,int maxChildNodes,String filter) throws MicroKernelException {
  if (depth != 0) {
    throw new MicroKernelException(""String_Node_Str"" + depth);
  }
  revisionId=revisionId != null ? revisionId : headRevision.toString();
  revisionId=stripBranchRevMarker(revisionId);
  Revision rev=Revision.fromString(revisionId);
  Node n=getNode(path,rev);
  if (n == null) {
    return null;
  }
  JsopStream json=new JsopStream();
  boolean includeId=filter != null && filter.contains(""String_Node_Str"");
  includeId|=filter != null && filter.contains(""String_Node_Str"");
  json.object();
  n.append(json,includeId);
  int max;
  if (maxChildNodes == -1) {
    max=MANY_CHILDREN_THRESHOLD;
    maxChildNodes=Integer.MAX_VALUE;
  }
 else {
    long m=maxChildNodes + 1L + offset;
    max=(int)Math.min(m,Integer.MAX_VALUE);
  }
  if (offset > 0) {
    max=Integer.MAX_VALUE;
  }
  Children c=getChildren(path,rev,max);
  for (long i=offset; i < c.children.size(); i++) {
    if (maxChildNodes-- <= 0) {
      break;
    }
    String name=PathUtils.getName(c.children.get((int)i));
    json.key(name).object().endObject();
  }
  if (c.hasMore) {
    json.key(""String_Node_Str"").value(Long.MAX_VALUE);
  }
 else {
    json.key(""String_Node_Str"").value(c.children.size());
  }
  json.endObject();
  return json.toString();
}",0.9960979070592408
9011,"@Override public synchronized String getNodes(String path,String revisionId,int depth,long offset,int maxChildNodes,String filter) throws MicroKernelException {
  if (depth != 0) {
    throw new MicroKernelException(""String_Node_Str"" + depth);
  }
  revisionId=revisionId != null ? revisionId : headRevision.toString();
  revisionId=stripBranchRevMarker(revisionId);
  Revision rev=Revision.fromString(revisionId);
  Node n=getNode(path,rev);
  if (n == null) {
    return null;
  }
  JsopStream json=new JsopStream();
  boolean includeId=filter != null && filter.contains(""String_Node_Str"");
  includeId|=filter != null && filter.contains(""String_Node_Str"");
  json.object();
  n.append(json,includeId);
  int max;
  if (maxChildNodes == -1) {
    max=MANY_CHILDREN_THRESHOLD;
    maxChildNodes=Integer.MAX_VALUE;
  }
 else {
    max=Math.max(maxChildNodes,maxChildNodes + 1);
  }
  Children c=getChildren(path,rev,max);
  for (long i=offset; i < c.children.size(); i++) {
    if (maxChildNodes-- <= 0) {
      break;
    }
    String name=PathUtils.getName(c.children.get((int)i));
    json.key(name).object().endObject();
  }
  if (c.hasMore) {
    json.key(""String_Node_Str"").value(Integer.MAX_VALUE);
  }
 else {
    json.key(""String_Node_Str"").value(c.children.size());
  }
  json.endObject();
  return json.toString();
}","@Override public synchronized String getNodes(String path,String revisionId,int depth,long offset,int maxChildNodes,String filter) throws MicroKernelException {
  if (depth != 0) {
    throw new MicroKernelException(""String_Node_Str"" + depth);
  }
  revisionId=revisionId != null ? revisionId : headRevision.toString();
  revisionId=stripBranchRevMarker(revisionId);
  Revision rev=Revision.fromString(revisionId);
  Node n=getNode(path,rev);
  if (n == null) {
    return null;
  }
  JsopStream json=new JsopStream();
  boolean includeId=filter != null && filter.contains(""String_Node_Str"");
  includeId|=filter != null && filter.contains(""String_Node_Str"");
  json.object();
  n.append(json,includeId);
  int max;
  if (maxChildNodes == -1) {
    max=MANY_CHILDREN_THRESHOLD;
    maxChildNodes=Integer.MAX_VALUE;
  }
 else {
    long m=maxChildNodes + 1L + offset;
    max=(int)Math.min(m,Integer.MAX_VALUE);
  }
  if (offset > 0) {
    max=Integer.MAX_VALUE;
  }
  Children c=getChildren(path,rev,max);
  for (long i=offset; i < c.children.size(); i++) {
    if (maxChildNodes-- <= 0) {
      break;
    }
    String name=PathUtils.getName(c.children.get((int)i));
    json.key(name).object().endObject();
  }
  if (c.hasMore) {
    json.key(""String_Node_Str"").value(Integer.MAX_VALUE);
  }
 else {
    json.key(""String_Node_Str"").value(c.children.size());
  }
  json.endObject();
  return json.toString();
}",0.6654492330168006
9012,"@Override public boolean init(Session session,Root root,NamePathMapper namePathMapper,boolean isWorkspaceImport,int uuidBehavior,ReferenceChangeTracker referenceTracker){
  if (initialized) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  try {
    this.namePathMapper=namePathMapper;
    AccessControlConfiguration config=securityProvider.getAccessControlConfiguration();
    if (isWorkspaceImport) {
      acMgr=config.getAccessControlManager(root,namePathMapper);
    }
 else {
      acMgr=session.getAccessControlManager();
    }
    principalManager=securityProvider.getPrincipalConfiguration().getPrincipalManager(root,namePathMapper);
    ntMgr=ReadOnlyNodeTypeManager.getInstance(root,namePathMapper);
    initialized=true;
  }
 catch (  RepositoryException e) {
    log.warn(""String_Node_Str"",e);
  }
  return initialized;
}","@Override public boolean init(Session session,Root root,NamePathMapper namePathMapper,boolean isWorkspaceImport,int uuidBehavior,ReferenceChangeTracker referenceTracker){
  if (initialized) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  try {
    AccessControlConfiguration config=securityProvider.getAccessControlConfiguration();
    if (isWorkspaceImport) {
      acMgr=config.getAccessControlManager(root,namePathMapper);
    }
 else {
      acMgr=session.getAccessControlManager();
    }
    principalManager=securityProvider.getPrincipalConfiguration().getPrincipalManager(root,namePathMapper);
    ntMgr=ReadOnlyNodeTypeManager.getInstance(root,namePathMapper);
    initialized=true;
  }
 catch (  RepositoryException e) {
    log.warn(""String_Node_Str"",e);
  }
  return initialized;
}",0.9758454106280192
9013,"public PrincipalProviderImpl(Root root,UserConfiguration userConfiguration,NamePathMapper namePathMapper){
  this.userManager=userConfiguration.getUserManager(root,namePathMapper);
}","public PrincipalProviderImpl(@Nonnull Root root,@Nonnull UserConfiguration userConfiguration,@Nonnull NamePathMapper namePathMapper){
  this.userManager=userConfiguration.getUserManager(root,namePathMapper);
}",0.9309462915601024
9014,"private SolrServer createSolrServer() throws Exception {
  String solrHomePath=oakSolrConfiguration.getSolrHomePath();
  String coreName=oakSolrConfiguration.getCoreName();
  String solrConfigPath=oakSolrConfiguration.getSolrConfigPath();
  checkSolrConfiguration(solrHomePath,solrConfigPath,coreName);
  CoreContainer coreContainer=new CoreContainer(solrHomePath);
  coreContainer.load(solrHomePath,new File(solrConfigPath));
  return new EmbeddedSolrServer(coreContainer,coreName);
}","private SolrServer createSolrServer() throws Exception {
  String solrHomePath=oakSolrConfiguration.getSolrHomePath();
  String coreName=oakSolrConfiguration.getCoreName();
  String solrConfigPath=oakSolrConfiguration.getSolrConfigPath();
  checkSolrConfiguration(solrHomePath,solrConfigPath,coreName);
  ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
  Thread.currentThread().setContextClassLoader(CoreContainer.class.getClassLoader());
  CoreContainer coreContainer=new CoreContainer(solrHomePath);
  try {
    coreContainer.load(solrHomePath,new File(solrConfigPath));
  }
  finally {
    Thread.currentThread().setContextClassLoader(classLoader);
  }
  return new EmbeddedSolrServer(coreContainer,coreName);
}",0.7489779231398201
9015,"/** 
 * Try to create or update the node. If there was a conflict, this method throws an exception, even thought the change is still applied.
 * @param store the store
 * @param op the operation
 */
private void createOrUpdateNode(DocumentStore store,UpdateOp op){
  Map<String,Object> map=store.createOrUpdate(Collection.NODES,op);
  if (baseRevision != null) {
    Revision newestRev=mk.getNewestRevision(map,revision,true);
    if (newestRev != null) {
      if (op.isNew) {
        throw new MicroKernelException(""String_Node_Str"" + op.path + ""String_Node_Str""+ newestRev+ ""String_Node_Str""+ revision+ ""String_Node_Str""+ map);
      }
      if (mk.isRevisionNewer(newestRev,baseRevision)) {
        throw new MicroKernelException(""String_Node_Str"" + op.path + ""String_Node_Str""+ newestRev+ ""String_Node_Str""+ baseRevision+ ""String_Node_Str""+ revision+ ""String_Node_Str""+ map);
      }
    }
  }
  int size=Utils.estimateMemoryUsage(map);
  if (size > MAX_DOCUMENT_SIZE) {
    UpdateOp[] split=splitDocument(map);
    UpdateOp old=split[0];
    if (old != null) {
      store.createOrUpdate(Collection.NODES,old);
    }
    UpdateOp main=split[1];
    if (main != null) {
      store.createOrUpdate(Collection.NODES,main);
    }
  }
}","/** 
 * Try to create or update the node. If there was a conflict, this method throws an exception, even thought the change is still applied.
 * @param store the store
 * @param op the operation
 */
private void createOrUpdateNode(DocumentStore store,UpdateOp op){
  Map<String,Object> map=store.createOrUpdate(Collection.NODES,op);
  if (baseRevision != null) {
    Revision newestRev=mk.getNewestRevision(map,revision,true);
    if (newestRev == null) {
      if (op.isDelete || !op.isNew) {
        throw new MicroKernelException(""String_Node_Str"" + op.path + ""String_Node_Str""+ ""String_Node_Str""+ revision+ ""String_Node_Str""+ map);
      }
    }
 else {
      if (op.isNew) {
        throw new MicroKernelException(""String_Node_Str"" + op.path + ""String_Node_Str""+ newestRev+ ""String_Node_Str""+ revision+ ""String_Node_Str""+ map);
      }
      if (mk.isRevisionNewer(newestRev,baseRevision)) {
        throw new MicroKernelException(""String_Node_Str"" + op.path + ""String_Node_Str""+ newestRev+ ""String_Node_Str""+ baseRevision+ ""String_Node_Str""+ revision+ ""String_Node_Str""+ map);
      }
    }
  }
  int size=Utils.estimateMemoryUsage(map);
  if (size > MAX_DOCUMENT_SIZE) {
    UpdateOp[] split=splitDocument(map);
    UpdateOp old=split[0];
    if (old != null) {
      store.createOrUpdate(Collection.NODES,old);
    }
    UpdateOp main=split[1];
    if (main != null) {
      store.createOrUpdate(Collection.NODES,main);
    }
  }
}",0.9192825112107624
9016,"@Nonnull public Map<String,Object> createOrUpdate(Collection collection,UpdateOp update){
  ConcurrentSkipListMap<String,Map<String,Object>> map=getMap(collection);
  Map<String,Object> n;
  Map<String,Object> oldNode;
  oldNode=n=map.get(update.key);
  if (n == null) {
    n=Utils.newMap();
    oldNode=map.putIfAbsent(update.key,n);
    if (oldNode != null) {
      n=oldNode;
    }
  }
synchronized (n) {
    if (oldNode != null) {
      Map<String,Object> oldNode2=Utils.newMap();
      Utils.deepCopyMap(oldNode,oldNode2);
      oldNode=oldNode2;
    }
    applyChanges(n,update);
  }
  return oldNode;
}","@Nonnull public Map<String,Object> createOrUpdate(Collection collection,UpdateOp update){
  ConcurrentSkipListMap<String,Map<String,Object>> map=getMap(collection);
  Map<String,Object> n;
  Map<String,Object> oldNode;
  oldNode=n=map.get(update.key);
  if (n == null) {
    if (!update.isNew) {
      throw new MicroKernelException(""String_Node_Str"" + update.key);
    }
    n=Utils.newMap();
    oldNode=map.putIfAbsent(update.key,n);
    if (oldNode != null) {
      n=oldNode;
    }
  }
synchronized (n) {
    if (oldNode != null) {
      Map<String,Object> oldNode2=Utils.newMap();
      Utils.deepCopyMap(oldNode,oldNode2);
      oldNode=oldNode2;
    }
    applyChanges(n,update);
  }
  return oldNode;
}",0.923542770628312
9017,"@Override public synchronized String commit(String rootPath,String json,String baseRevId,String message) throws MicroKernelException {
  Revision baseRev;
  if (baseRevId == null) {
    baseRev=headRevision;
    baseRevId=baseRev.toString();
  }
 else {
    baseRev=Revision.fromString(stripBranchRevMarker(baseRevId));
  }
  JsopReader t=new JsopTokenizer(json);
  Revision rev=newRevision();
  Commit commit=new Commit(this,baseRev,rev);
  while (true) {
    int r=t.read();
    if (r == JsopReader.END) {
      break;
    }
    String path=PathUtils.concat(rootPath,t.readString());
switch (r) {
case '+':
      t.read(':');
    t.read('{');
  parseAddNode(commit,t,path);
break;
case '-':
commit.removeNode(path);
markAsDeleted(path,commit,true);
commit.removeNodeDiff(path);
break;
case '^':
t.read(':');
String value;
if (t.matches(JsopReader.NULL)) {
value=null;
commit.getDiff().tag('^').key(path).value(null);
}
 else {
value=t.readRawValue().trim();
commit.getDiff().tag('^').key(path).value(value);
}
String p=PathUtils.getParentPath(path);
String propertyName=PathUtils.getName(path);
commit.updateProperty(p,propertyName,value);
commit.updatePropertyDiff(p,propertyName,value);
break;
case '>':
{
t.read(':');
String sourcePath=path;
String targetPath=t.readString();
if (!PathUtils.isAbsolute(targetPath)) {
targetPath=PathUtils.concat(rootPath,targetPath);
}
commit.moveNode(sourcePath,targetPath);
moveNode(sourcePath,targetPath,baseRev,commit);
break;
}
case '*':
{
t.read(':');
String sourcePath=path;
String targetPath=t.readString();
if (!PathUtils.isAbsolute(targetPath)) {
targetPath=PathUtils.concat(rootPath,targetPath);
}
commit.copyNode(sourcePath,targetPath);
copyNode(sourcePath,targetPath,baseRev,commit);
break;
}
default :
throw new MicroKernelException(""String_Node_Str"" + (char)t.getTokenType());
}
}
if (baseRevId.startsWith(""String_Node_Str"")) {
branchCommits.put(rev,baseRev);
boolean success=false;
try {
commit.prepare(baseRev);
success=true;
}
  finally {
if (!success) {
branchCommits.remove(rev);
}
}
return ""String_Node_Str"" + rev.toString();
}
commit.apply();
headRevision=commit.getRevision();
return rev.toString();
}","@Override public synchronized String commit(String rootPath,String json,String baseRevId,String message) throws MicroKernelException {
  Revision baseRev;
  if (baseRevId == null) {
    baseRev=headRevision;
    baseRevId=baseRev.toString();
  }
 else {
    baseRev=Revision.fromString(stripBranchRevMarker(baseRevId));
  }
  JsopReader t=new JsopTokenizer(json);
  Revision rev=newRevision();
  Commit commit=new Commit(this,baseRev,rev);
  while (true) {
    int r=t.read();
    if (r == JsopReader.END) {
      break;
    }
    String path=PathUtils.concat(rootPath,t.readString());
switch (r) {
case '+':
      t.read(':');
    t.read('{');
  parseAddNode(commit,t,path);
break;
case '-':
commit.removeNode(path);
markAsDeleted(path,commit,true);
commit.removeNodeDiff(path);
break;
case '^':
t.read(':');
String value;
if (t.matches(JsopReader.NULL)) {
value=null;
commit.getDiff().tag('^').key(path).value(null);
}
 else {
value=t.readRawValue().trim();
commit.getDiff().tag('^').key(path).value(value);
}
String p=PathUtils.getParentPath(path);
String propertyName=PathUtils.getName(path);
commit.updateProperty(p,propertyName,value);
commit.updatePropertyDiff(p,propertyName,value);
break;
case '>':
{
t.read(':');
String sourcePath=path;
String targetPath=t.readString();
if (!PathUtils.isAbsolute(targetPath)) {
targetPath=PathUtils.concat(rootPath,targetPath);
}
if (!nodeExists(sourcePath,baseRevId)) {
throw new MicroKernelException(""String_Node_Str"" + sourcePath + ""String_Node_Str""+ baseRevId);
}
if (nodeExists(targetPath,baseRevId)) {
throw new MicroKernelException(""String_Node_Str"" + targetPath + ""String_Node_Str""+ baseRevId);
}
commit.moveNode(sourcePath,targetPath);
moveNode(sourcePath,targetPath,baseRev,commit);
break;
}
case '*':
{
t.read(':');
String sourcePath=path;
String targetPath=t.readString();
if (!PathUtils.isAbsolute(targetPath)) {
targetPath=PathUtils.concat(rootPath,targetPath);
}
if (!nodeExists(sourcePath,baseRevId)) {
throw new MicroKernelException(""String_Node_Str"" + sourcePath + ""String_Node_Str""+ baseRevId);
}
commit.copyNode(sourcePath,targetPath);
copyNode(sourcePath,targetPath,baseRev,commit);
break;
}
default :
throw new MicroKernelException(""String_Node_Str"" + (char)t.getTokenType());
}
}
if (baseRevId.startsWith(""String_Node_Str"")) {
branchCommits.put(rev,baseRev);
boolean success=false;
try {
commit.prepare(baseRev);
success=true;
}
  finally {
if (!success) {
branchCommits.remove(rev);
}
}
return ""String_Node_Str"" + rev.toString();
}
commit.apply();
headRevision=commit.getRevision();
return rev.toString();
}",0.912814017310534
9018,"private void commit(String diff){
  boolean ok=false;
  try {
    mkGold.commit(""String_Node_Str"",diff,null,null);
    ok=true;
  }
 catch (  MicroKernelException e) {
    try {
      mk.commit(""String_Node_Str"",diff,null,null);
      fail(""String_Node_Str"" + diff + ""String_Node_Str""+ e);
    }
 catch (    MicroKernelException e2) {
    }
  }
  if (ok) {
    mk.commit(""String_Node_Str"",diff,null,null);
  }
}","private boolean commit(String diff){
  boolean ok=false;
  try {
    mkGold.commit(""String_Node_Str"",diff,null,null);
    ok=true;
  }
 catch (  MicroKernelException e) {
    try {
      mk.commit(""String_Node_Str"",diff,null,null);
      fail(""String_Node_Str"" + diff + ""String_Node_Str""+ e);
    }
 catch (    MicroKernelException e2) {
    }
  }
  if (ok) {
    mk.commit(""String_Node_Str"",diff,null,null);
  }
  return ok;
}",0.9689737470167064
9019,"/** 
 * Try to create or update the node. If there was a conflict, this method throws an exception, even thought the change is still applied.
 * @param store the store
 * @param op the operation
 */
private void createOrUpdateNode(DocumentStore store,UpdateOp op){
  Map<String,Object> map=store.createOrUpdate(Collection.NODES,op);
  if (baseRevision != null) {
    Revision newestRev=mk.getNewestRevision(map,revision,true);
    if (newestRev != null) {
      if (op.isNew) {
        throw new MicroKernelException(""String_Node_Str"" + op.path + ""String_Node_Str""+ newestRev);
      }
      if (mk.isRevisionNewer(newestRev,baseRevision)) {
        throw new MicroKernelException(""String_Node_Str"" + op.path + ""String_Node_Str""+ newestRev+ ""String_Node_Str""+ baseRevision);
      }
    }
  }
  int size=Utils.estimateMemoryUsage(map);
  if (size > MAX_DOCUMENT_SIZE) {
    UpdateOp[] split=splitDocument(map);
    UpdateOp old=split[0];
    if (old != null) {
      store.createOrUpdate(Collection.NODES,old);
    }
    UpdateOp main=split[1];
    if (main != null) {
      store.createOrUpdate(Collection.NODES,main);
    }
  }
}","/** 
 * Try to create or update the node. If there was a conflict, this method throws an exception, even thought the change is still applied.
 * @param store the store
 * @param op the operation
 */
private void createOrUpdateNode(DocumentStore store,UpdateOp op){
  Map<String,Object> map=store.createOrUpdate(Collection.NODES,op);
  if (baseRevision != null) {
    Revision newestRev=mk.getNewestRevision(map,revision,true);
    if (newestRev != null) {
      if (op.isNew) {
        throw new MicroKernelException(""String_Node_Str"" + op.path + ""String_Node_Str""+ newestRev+ ""String_Node_Str""+ revision+ ""String_Node_Str""+ map);
      }
      if (mk.isRevisionNewer(newestRev,baseRevision)) {
        throw new MicroKernelException(""String_Node_Str"" + op.path + ""String_Node_Str""+ newestRev+ ""String_Node_Str""+ baseRevision+ ""String_Node_Str""+ revision+ ""String_Node_Str""+ map);
      }
    }
  }
  int size=Utils.estimateMemoryUsage(map);
  if (size > MAX_DOCUMENT_SIZE) {
    UpdateOp[] split=splitDocument(map);
    UpdateOp old=split[0];
    if (old != null) {
      store.createOrUpdate(Collection.NODES,old);
    }
    UpdateOp main=split[1];
    if (main != null) {
      store.createOrUpdate(Collection.NODES,main);
    }
  }
}",0.9552364864864864
9020,"/** 
 * Apply the changes to the document store (to update MongoDB).
 * @param baseRevision the base revision of this commit. Currently onlyused for branch commits.
 */
void applyToDocumentStore(Revision baseRevision){
  String commitValue=baseRevision != null ? baseRevision.toString() : ""String_Node_Str"";
  DocumentStore store=mk.getDocumentStore();
  String commitRootPath=null;
  if (baseRevision != null) {
    commitRootPath=""String_Node_Str"";
  }
  ArrayList<UpdateOp> newNodes=new ArrayList<UpdateOp>();
  ArrayList<UpdateOp> changedNodes=new ArrayList<UpdateOp>();
  ArrayList<UpdateOp> done=new ArrayList<UpdateOp>();
  for (  String p : operations.keySet()) {
    markChanged(p);
    if (commitRootPath == null) {
      commitRootPath=p;
    }
 else {
      while (!PathUtils.isAncestor(commitRootPath,p)) {
        commitRootPath=PathUtils.getParentPath(commitRootPath);
        if (PathUtils.denotesRoot(commitRootPath)) {
          break;
        }
      }
    }
  }
  int commitRootDepth=PathUtils.getDepth(commitRootPath);
  UpdateOp commitRoot=getUpdateOperationForNode(commitRootPath);
  for (  String p : operations.keySet()) {
    UpdateOp op=operations.get(p);
    op.setMapEntry(UpdateOp.LAST_REV + ""String_Node_Str"" + revision.getClusterId(),revision.toString());
    if (op.isNew) {
      op.addMapEntry(UpdateOp.DELETED + ""String_Node_Str"" + revision.toString(),""String_Node_Str"");
    }
    if (op == commitRoot) {
    }
 else {
      op.addMapEntry(UpdateOp.COMMIT_ROOT + ""String_Node_Str"" + revision.toString(),commitRootDepth);
      if (op.isNew()) {
        newNodes.add(op);
      }
 else {
        changedNodes.add(op);
      }
    }
  }
  if (changedNodes.size() == 0 && commitRoot.isNew) {
    commitRoot.addMapEntry(UpdateOp.REVISIONS + ""String_Node_Str"" + revision.toString(),commitValue);
    newNodes.add(commitRoot);
  }
  try {
    if (newNodes.size() > 0) {
      if (!store.create(Collection.NODES,newNodes)) {
        for (        UpdateOp op : newNodes) {
          op.unset(UpdateOp.ID);
          if (op == commitRoot) {
            commitRoot.unset(UpdateOp.REVISIONS + ""String_Node_Str"" + revision.toString());
          }
          changedNodes.add(op);
        }
        newNodes.clear();
      }
    }
    for (    UpdateOp op : changedNodes) {
      op.addMapEntry(UpdateOp.COMMIT_ROOT + ""String_Node_Str"" + revision.toString(),commitRootDepth);
      done.add(op);
      createOrUpdateNode(store,op);
    }
    if (changedNodes.size() > 0 || !commitRoot.isNew) {
      commitRoot.addMapEntry(UpdateOp.REVISIONS + ""String_Node_Str"" + revision.toString(),commitValue);
      done.add(commitRoot);
      createOrUpdateNode(store,commitRoot);
      operations.put(commitRootPath,commitRoot);
    }
  }
 catch (  MicroKernelException e) {
    rollback(newNodes,done);
    String msg=""String_Node_Str"" + diff.toString();
    LOG.error(msg,e);
    throw new MicroKernelException(msg,e);
  }
}","/** 
 * Apply the changes to the document store (to update MongoDB).
 * @param baseRevision the base revision of this commit. Currently onlyused for branch commits.
 */
void applyToDocumentStore(Revision baseRevision){
  String commitValue=baseRevision != null ? baseRevision.toString() : ""String_Node_Str"";
  DocumentStore store=mk.getDocumentStore();
  String commitRootPath=null;
  if (baseRevision != null) {
    commitRootPath=""String_Node_Str"";
  }
  ArrayList<UpdateOp> newNodes=new ArrayList<UpdateOp>();
  ArrayList<UpdateOp> changedNodes=new ArrayList<UpdateOp>();
  ArrayList<UpdateOp> done=new ArrayList<UpdateOp>();
  for (  String p : operations.keySet()) {
    markChanged(p);
    if (commitRootPath == null) {
      commitRootPath=p;
    }
 else {
      while (!PathUtils.isAncestor(commitRootPath,p)) {
        commitRootPath=PathUtils.getParentPath(commitRootPath);
        if (PathUtils.denotesRoot(commitRootPath)) {
          break;
        }
      }
    }
  }
  int commitRootDepth=PathUtils.getDepth(commitRootPath);
  UpdateOp commitRoot=getUpdateOperationForNode(commitRootPath);
  for (  String p : operations.keySet()) {
    UpdateOp op=operations.get(p);
    op.setMapEntry(UpdateOp.LAST_REV + ""String_Node_Str"" + revision.getClusterId(),revision.toString());
    if (op.isNew) {
      op.addMapEntry(UpdateOp.DELETED + ""String_Node_Str"" + revision.toString(),""String_Node_Str"");
    }
    if (op == commitRoot) {
    }
 else {
      op.addMapEntry(UpdateOp.COMMIT_ROOT + ""String_Node_Str"" + revision.toString(),commitRootDepth);
      if (op.isNew()) {
        newNodes.add(op);
      }
 else {
        changedNodes.add(op);
      }
    }
  }
  if (changedNodes.size() == 0 && commitRoot.isNew) {
    commitRoot.addMapEntry(UpdateOp.REVISIONS + ""String_Node_Str"" + revision.toString(),commitValue);
    newNodes.add(commitRoot);
  }
  try {
    if (newNodes.size() > 0) {
      if (!store.create(Collection.NODES,newNodes)) {
        for (        UpdateOp op : newNodes) {
          if (op == commitRoot) {
            commitRoot.unset(UpdateOp.REVISIONS + ""String_Node_Str"" + revision.toString());
          }
          changedNodes.add(op);
        }
        newNodes.clear();
      }
    }
    for (    UpdateOp op : changedNodes) {
      op.addMapEntry(UpdateOp.COMMIT_ROOT + ""String_Node_Str"" + revision.toString(),commitRootDepth);
      done.add(op);
      createOrUpdateNode(store,op);
    }
    if (changedNodes.size() > 0 || !commitRoot.isNew) {
      commitRoot.addMapEntry(UpdateOp.REVISIONS + ""String_Node_Str"" + revision.toString(),commitValue);
      done.add(commitRoot);
      createOrUpdateNode(store,commitRoot);
      operations.put(commitRootPath,commitRoot);
    }
  }
 catch (  MicroKernelException e) {
    rollback(newNodes,done);
    String msg=""String_Node_Str"" + diff.toString();
    LOG.error(msg,e);
    throw new MicroKernelException(msg,e);
  }
}",0.9943560800410468
9021,"@Nonnull @Override public Map<String,Object> createOrUpdate(Collection collection,UpdateOp updateOp){
  log(""String_Node_Str"",updateOp);
  DBCollection dbCollection=getDBCollection(collection);
  BasicDBObject setUpdates=new BasicDBObject();
  BasicDBObject incUpdates=new BasicDBObject();
  BasicDBObject unsetUpdates=new BasicDBObject();
  for (  Entry<String,Operation> entry : updateOp.changes.entrySet()) {
    String k=entry.getKey();
    Operation op=entry.getValue();
switch (op.type) {
case SET:
{
        setUpdates.append(k,op.value);
        break;
      }
case INCREMENT:
{
      incUpdates.append(k,op.value);
      break;
    }
case ADD_MAP_ENTRY:
{
    setUpdates.append(k,op.value);
    break;
  }
case REMOVE_MAP_ENTRY:
{
  unsetUpdates.append(k,""String_Node_Str"");
  break;
}
case SET_MAP_ENTRY:
{
String[] kv=k.split(""String_Node_Str"");
BasicDBObject sub=new BasicDBObject();
sub.put(kv[1],op.value);
setUpdates.append(kv[0],sub);
break;
}
}
}
DBObject query=getByPathQuery(updateOp.key);
BasicDBObject update=new BasicDBObject();
if (!setUpdates.isEmpty()) {
update.append(""String_Node_Str"",setUpdates);
}
if (!incUpdates.isEmpty()) {
update.append(""String_Node_Str"",incUpdates);
}
if (!unsetUpdates.isEmpty()) {
update.append(""String_Node_Str"",unsetUpdates);
}
long start=start();
try {
DBObject oldNode=dbCollection.findAndModify(query,null,null,false,update,false,true);
Map<String,Object> map=convertFromDBObject(oldNode);
Map<String,Object> newMap=Utils.newMap();
Utils.deepCopyMap(map,newMap);
String key=updateOp.getKey();
MemoryDocumentStore.applyChanges(newMap,updateOp);
cache.put(key,newMap);
log(""String_Node_Str"",map);
return map;
}
 catch (Exception e) {
throw new MicroKernelException(e);
}
 finally {
end(start);
}
}","@Nonnull @Override public Map<String,Object> createOrUpdate(Collection collection,UpdateOp updateOp){
  log(""String_Node_Str"",updateOp);
  DBCollection dbCollection=getDBCollection(collection);
  BasicDBObject setUpdates=new BasicDBObject();
  BasicDBObject incUpdates=new BasicDBObject();
  BasicDBObject unsetUpdates=new BasicDBObject();
  for (  Entry<String,Operation> entry : updateOp.changes.entrySet()) {
    String k=entry.getKey();
    if (k.equals(UpdateOp.ID)) {
      continue;
    }
    Operation op=entry.getValue();
switch (op.type) {
case SET:
{
        setUpdates.append(k,op.value);
        break;
      }
case INCREMENT:
{
      incUpdates.append(k,op.value);
      break;
    }
case ADD_MAP_ENTRY:
{
    setUpdates.append(k,op.value);
    break;
  }
case REMOVE_MAP_ENTRY:
{
  unsetUpdates.append(k,""String_Node_Str"");
  break;
}
case SET_MAP_ENTRY:
{
String[] kv=k.split(""String_Node_Str"");
BasicDBObject sub=new BasicDBObject();
sub.put(kv[1],op.value);
setUpdates.append(kv[0],sub);
break;
}
}
}
DBObject query=getByPathQuery(updateOp.key);
BasicDBObject update=new BasicDBObject();
if (!setUpdates.isEmpty()) {
update.append(""String_Node_Str"",setUpdates);
}
if (!incUpdates.isEmpty()) {
update.append(""String_Node_Str"",incUpdates);
}
if (!unsetUpdates.isEmpty()) {
update.append(""String_Node_Str"",unsetUpdates);
}
long start=start();
try {
DBObject oldNode=dbCollection.findAndModify(query,null,null,false,update,false,true);
Map<String,Object> map=convertFromDBObject(oldNode);
Map<String,Object> newMap=Utils.newMap();
Utils.deepCopyMap(map,newMap);
String key=updateOp.getKey();
MemoryDocumentStore.applyChanges(newMap,updateOp);
cache.put(key,newMap);
log(""String_Node_Str"",map);
return map;
}
 catch (Exception e) {
throw new MicroKernelException(e);
}
 finally {
end(start);
}
}",0.984554900308902
9022,"/** 
 * Get the revision of the latest change made to this node.
 * @param nodeMap the document
 * @param before the returned value is guaranteed to be older than this revision
 * @param onlyCommitted whether only committed changes should be considered
 * @return the revision, or null if deleted
 */
@Nullable Revision getNewestRevision(Map<String,Object> nodeMap,Revision before,boolean onlyCommitted){
  if (nodeMap == null) {
    return null;
  }
  @SuppressWarnings(""String_Node_Str"") Map<String,String> valueMap=(Map<String,String>)nodeMap.get(UpdateOp.DELETED);
  if (valueMap == null) {
    return null;
  }
  Revision newestRev=null;
  String newestValue=null;
  for (  String r : valueMap.keySet()) {
    Revision propRev=Revision.fromString(r);
    if (newestRev == null || isRevisionNewer(propRev,newestRev)) {
      if (isRevisionNewer(before,propRev)) {
        if (!onlyCommitted || isValidRevision(propRev,before,nodeMap)) {
          newestRev=propRev;
        }
        newestValue=valueMap.get(r);
      }
    }
  }
  if (""String_Node_Str"".equals(newestValue)) {
    return null;
  }
  return newestRev;
}","/** 
 * Get the revision of the latest change made to this node.
 * @param nodeMap the document
 * @param before the returned value is guaranteed to be older than this revision
 * @param onlyCommitted whether only committed changes should be considered
 * @return the revision, or null if deleted
 */
@Nullable Revision getNewestRevision(Map<String,Object> nodeMap,Revision before,boolean onlyCommitted){
  if (nodeMap == null) {
    return null;
  }
  @SuppressWarnings(""String_Node_Str"") Map<String,String> valueMap=(Map<String,String>)nodeMap.get(UpdateOp.DELETED);
  if (valueMap == null) {
    return null;
  }
  Revision newestRev=null;
  String newestValue=null;
  for (  String r : valueMap.keySet()) {
    Revision propRev=Revision.fromString(r);
    if (newestRev == null || isRevisionNewer(propRev,newestRev)) {
      if (isRevisionNewer(before,propRev)) {
        if (!onlyCommitted || isValidRevision(propRev,before,nodeMap)) {
          newestRev=propRev;
          newestValue=valueMap.get(r);
        }
      }
    }
  }
  if (""String_Node_Str"".equals(newestValue)) {
    return null;
  }
  return newestRev;
}",0.9662222222222222
9023,"@Test public void reAddDeleted2(){
  MongoMK mk=createMK();
  String rev=mk.commit(""String_Node_Str"",""String_Node_Str"",null,null);
  rev=mk.commit(""String_Node_Str"",""String_Node_Str"",rev,null);
  rev=mk.commit(""String_Node_Str"",""String_Node_Str"",null,null);
  String test=mk.getNodes(""String_Node_Str"",rev,0,0,Integer.MAX_VALUE,null);
  assertEquals(""String_Node_Str"",test);
  mk.dispose();
}","@Test public void reAddDeleted2(){
  MongoMK mk=createMK();
  String rev=mk.commit(""String_Node_Str"",""String_Node_Str"",null,null);
  rev=mk.commit(""String_Node_Str"",""String_Node_Str"",rev,null);
  rev=mk.commit(""String_Node_Str"",""String_Node_Str"",null,null);
  String test=mk.getNodes(""String_Node_Str"",rev,0,0,Integer.MAX_VALUE,null);
  assertEquals(""String_Node_Str"",test);
  String test2=mk.getNodes(""String_Node_Str"",rev,0,0,Integer.MAX_VALUE,null);
  assertEquals(""String_Node_Str"",test2);
  mk.dispose();
}",0.8682170542635659
9024,"public Node.Children readChildren(String path,String nodeId,Revision rev,int limit){
  Node.Children c;
  c=nodeChildrenCache.get(nodeId);
  if (c != null) {
    return c;
  }
  String from=PathUtils.concat(path,""String_Node_Str"");
  from=Utils.getIdFromPath(from);
  from=from.substring(0,from.length() - 1);
  String to=PathUtils.concat(path,""String_Node_Str"");
  to=Utils.getIdFromPath(to);
  to=to.substring(0,to.length() - 2) + ""String_Node_Str"";
  List<Map<String,Object>> list=store.query(DocumentStore.Collection.NODES,from,to,limit);
  c=new Node.Children(path,nodeId,rev);
  for (  Map<String,Object> e : list) {
    if (isDeleted(e,rev)) {
      continue;
    }
    String id=e.get(UpdateOp.ID).toString();
    String p=Utils.getPathFromId(id);
    c.children.add(p);
  }
  nodeChildrenCache.put(nodeId,c);
  return c;
}","public Node.Children readChildren(String path,String nodeId,Revision rev,int limit){
  Node.Children c;
  c=nodeChildrenCache.get(nodeId);
  if (c != null) {
    return c;
  }
  String from=PathUtils.concat(path,""String_Node_Str"");
  from=Utils.getIdFromPath(from);
  from=from.substring(0,from.length() - 1);
  String to=PathUtils.concat(path,""String_Node_Str"");
  to=Utils.getIdFromPath(to);
  to=to.substring(0,to.length() - 2) + ""String_Node_Str"";
  List<Map<String,Object>> list=store.query(DocumentStore.Collection.NODES,from,to,limit);
  c=new Node.Children(path,nodeId,rev);
  for (  Map<String,Object> e : list) {
    if (getLiveRevision(e,rev) == null) {
      continue;
    }
    String id=e.get(UpdateOp.ID).toString();
    String p=Utils.getPathFromId(id);
    c.children.add(p);
  }
  nodeChildrenCache.put(nodeId,c);
  return c;
}",0.973747016706444
9025,"@Override public String diff(String fromRevisionId,String toRevisionId,String path,int depth) throws MicroKernelException {
  if (fromRevisionId.equals(toRevisionId)) {
    return ""String_Node_Str"";
  }
  return ""String_Node_Str"";
}","@Override public String diff(String fromRevisionId,String toRevisionId,String path,int depth) throws MicroKernelException {
  if (fromRevisionId.equals(toRevisionId)) {
    return ""String_Node_Str"";
  }
  if (true) {
    return ""String_Node_Str"";
  }
  if (depth != 0) {
    throw new MicroKernelException(""String_Node_Str"" + depth);
  }
  fromRevisionId=stripBranchRevMarker(fromRevisionId);
  toRevisionId=stripBranchRevMarker(toRevisionId);
  Node from=getNode(path,Revision.fromString(fromRevisionId));
  Node to=getNode(path,Revision.fromString(toRevisionId));
  if (from == null || to == null) {
    throw new MicroKernelException(""String_Node_Str"");
  }
  JsopWriter w=new JsopStream();
  for (  String p : from.getPropertyNames()) {
    String fromValue=from.getProperty(p);
    String toValue=to.getProperty(p);
    if (!fromValue.equals(toValue)) {
      w.tag('^').key(p).value(toValue).newline();
    }
  }
  for (  String p : to.getPropertyNames()) {
    if (from.getProperty(p) == null) {
      w.tag('^').key(p).value(to.getProperty(p)).newline();
    }
  }
  Revision fromRev=Revision.fromString(fromRevisionId);
  Revision toRev=Revision.fromString(toRevisionId);
  Children fromChildren=readChildren(path,from.getId(),fromRev,Integer.MAX_VALUE);
  Children toChildren=readChildren(path,to.getId(),toRev,Integer.MAX_VALUE);
  Set<String> childrenSet=new HashSet<String>(toChildren.children);
  for (  String n : fromChildren.children) {
    if (!childrenSet.contains(n)) {
      w.tag('-').key(n).object().endObject().newline();
    }
 else {
      w.tag('^').key(n).object().endObject().newline();
    }
  }
  childrenSet=new HashSet<String>(fromChildren.children);
  for (  String n : toChildren.children) {
    if (!childrenSet.contains(n)) {
      w.tag('+').key(n).object().endObject().newline();
    }
  }
  return w.toString();
}",0.2225419664268585
9026,"private String getLatestValue(Map<String,String> valueMap,Revision rev){
  String value=null;
  Revision latestRev=null;
  for (  String r : valueMap.keySet()) {
    Revision propRev=Revision.fromString(r);
    if (includeRevision(propRev,rev)) {
      if (latestRev == null || isRevisionNewer(propRev,latestRev)) {
        latestRev=propRev;
        value=valueMap.get(r);
      }
    }
  }
  return value;
}","/** 
 * Get the latest property value that is larger or equal the min revision, and smaller or equal the max revision.
 * @param valueMap the revision-value map
 * @param min the minimum revision (null meaning unlimited)
 * @param max the maximum revision
 * @return the value, or null if not found
 */
private String getLatestValue(Map<String,String> valueMap,Revision min,Revision max){
  String value=null;
  Revision latestRev=null;
  for (  String r : valueMap.keySet()) {
    Revision propRev=Revision.fromString(r);
    if (min != null) {
      if (isRevisionNewer(min,propRev)) {
        continue;
      }
    }
    if (includeRevision(propRev,max)) {
      if (latestRev == null || isRevisionNewer(propRev,latestRev)) {
        latestRev=propRev;
        value=valueMap.get(r);
      }
    }
  }
  return value;
}",0.6515028432168968
9027,"boolean isRevisionNewer(Revision x,Revision previous){
  return x.compareRevisionTime(previous) >= 0;
}","boolean isRevisionNewer(Revision x,Revision previous){
  return x.compareRevisionTime(previous) > 0;
}",0.9951219512195122
9028,"private Node readNode(String path,Revision rev){
  String id=Utils.getIdFromPath(path);
  Map<String,Object> map=store.find(DocumentStore.Collection.NODES,id);
  if (map == null) {
    return null;
  }
  if (isDeleted(map,rev)) {
    return null;
  }
  Node n=new Node(path,rev);
  Long w=writeCountIncrements.get(path);
  long writeCount=w == null ? 0 : w;
  for (  String key : map.keySet()) {
    if (key.equals(UpdateOp.WRITE_COUNT)) {
      writeCount+=(Long)map.get(key);
    }
    if (!Utils.isPropertyName(key)) {
      continue;
    }
    Object v=map.get(key);
    @SuppressWarnings(""String_Node_Str"") Map<String,String> valueMap=(Map<String,String>)v;
    if (valueMap != null) {
      String value=getLatestValue(valueMap,rev);
      String propertyName=Utils.unescapePropertyName(key);
      n.setProperty(propertyName,value);
    }
  }
  n.setWriteCount(writeCount);
  return n;
}","private Node readNode(String path,Revision rev){
  String id=Utils.getIdFromPath(path);
  Map<String,Object> map=store.find(DocumentStore.Collection.NODES,id);
  if (map == null) {
    return null;
  }
  Revision min=getLiveRevision(map,rev);
  if (min == null) {
    return null;
  }
  Node n=new Node(path,rev);
  Long w=writeCountIncrements.get(path);
  long writeCount=w == null ? 0 : w;
  for (  String key : map.keySet()) {
    if (key.equals(UpdateOp.WRITE_COUNT)) {
      writeCount+=(Long)map.get(key);
    }
    if (!Utils.isPropertyName(key)) {
      continue;
    }
    Object v=map.get(key);
    @SuppressWarnings(""String_Node_Str"") Map<String,String> valueMap=(Map<String,String>)v;
    if (valueMap != null) {
      String value=getLatestValue(valueMap,min,rev);
      String propertyName=Utils.unescapePropertyName(key);
      n.setProperty(propertyName,value);
    }
  }
  n.setWriteCount(writeCount);
  return n;
}",0.95947426067908
9029,"AuthorizableImpl(@Nonnull String id,@Nonnull Tree tree,@Nonnull UserManagerImpl userManager) throws RepositoryException {
  checkValidTree(tree);
  this.id=id;
  this.userManager=userManager;
  PropertyState pNameProp=tree.getProperty(REP_PRINCIPAL_NAME);
  if (pNameProp != null) {
    principalName=pNameProp.getValue(STRING);
  }
 else {
    String msg=""String_Node_Str"" + id;
    log.warn(msg);
    throw new RepositoryException(msg);
  }
}","AuthorizableImpl(@Nonnull String id,@Nonnull Tree tree,@Nonnull UserManagerImpl userManager) throws RepositoryException {
  checkValidTree(tree);
  this.id=id;
  this.userManager=userManager;
  PropertyState pNameProp=tree.getProperty(REP_PRINCIPAL_NAME);
  if (pNameProp != null) {
    principalName=pNameProp.getValue(STRING);
  }
 else {
    String msg=""String_Node_Str"" + id;
    log.warn(msg);
    principalName=id;
  }
}",0.9448275862068966
9030,"private UpdateOp getUpdateOperationForNode(String path){
  UpdateOp op=operations.get(path);
  if (op == null) {
    String id=Node.convertPathToDocumentId(path);
    op=new UpdateOp(path,id,false);
    operations.put(path,op);
  }
  return op;
}","private UpdateOp getUpdateOperationForNode(String path){
  UpdateOp op=operations.get(path);
  if (op == null) {
    String id=Utils.getIdFromPath(path);
    op=new UpdateOp(path,id,false);
    operations.put(path,op);
  }
  return op;
}",0.9233954451345756
9031,"/** 
 * Apply the changes to the MongoMK (to update the cache).
 */
public void applyToCache(){
  HashMap<String,ArrayList<String>> nodesWithChangedChildren=new HashMap<String,ArrayList<String>>();
  ArrayList<String> addOrRemove=new ArrayList<String>();
  addOrRemove.addAll(addedNodes);
  addOrRemove.addAll(removedNodes);
  for (  String p : addOrRemove) {
    String parent=PathUtils.getParentPath(p);
    ArrayList<String> list=nodesWithChangedChildren.get(parent);
    if (list == null) {
      list=new ArrayList<String>();
      nodesWithChangedChildren.put(parent,list);
    }
    list.add(p);
  }
  for (  String path : changedNodes) {
    ArrayList<String> added=new ArrayList<String>();
    ArrayList<String> removed=new ArrayList<String>();
    ArrayList<String> changed=nodesWithChangedChildren.get(path);
    if (changed != null) {
      for (      String s : changed) {
        if (addedNodes.contains(s)) {
          added.add(s);
        }
 else         if (removedNodes.contains(s)) {
          removed.add(s);
        }
      }
    }
    UpdateOp op=operations.get(path);
    boolean isNew=op != null && op.isNew;
    boolean isWritten=op != null;
    boolean isDelete=op != null && op.isDelete;
    long writeCountInc=mk.getWriteCountIncrement(path);
    Long writeCount=writeCounts.get(path);
    if (writeCount == null) {
      if (isNew) {
        writeCount=0L;
        writeCountInc=0;
      }
 else {
        writeCountInc++;
        String id=Node.convertPathToDocumentId(path);
        Map<String,Object> map=mk.getDocumentStore().find(Collection.NODES,id);
        Long oldWriteCount=(Long)map.get(UpdateOp.WRITE_COUNT);
        writeCount=oldWriteCount == null ? 0 : oldWriteCount;
      }
    }
    mk.applyChanges(revision,path,isNew,isDelete,isWritten,writeCount,writeCountInc,added,removed);
  }
}","/** 
 * Apply the changes to the MongoMK (to update the cache).
 */
public void applyToCache(){
  HashMap<String,ArrayList<String>> nodesWithChangedChildren=new HashMap<String,ArrayList<String>>();
  ArrayList<String> addOrRemove=new ArrayList<String>();
  addOrRemove.addAll(addedNodes);
  addOrRemove.addAll(removedNodes);
  for (  String p : addOrRemove) {
    String parent=PathUtils.getParentPath(p);
    ArrayList<String> list=nodesWithChangedChildren.get(parent);
    if (list == null) {
      list=new ArrayList<String>();
      nodesWithChangedChildren.put(parent,list);
    }
    list.add(p);
  }
  for (  String path : changedNodes) {
    ArrayList<String> added=new ArrayList<String>();
    ArrayList<String> removed=new ArrayList<String>();
    ArrayList<String> changed=nodesWithChangedChildren.get(path);
    if (changed != null) {
      for (      String s : changed) {
        if (addedNodes.contains(s)) {
          added.add(s);
        }
 else         if (removedNodes.contains(s)) {
          removed.add(s);
        }
      }
    }
    UpdateOp op=operations.get(path);
    boolean isNew=op != null && op.isNew;
    boolean isWritten=op != null;
    boolean isDelete=op != null && op.isDelete;
    long writeCountInc=mk.getWriteCountIncrement(path);
    Long writeCount=writeCounts.get(path);
    if (writeCount == null) {
      if (isNew) {
        writeCount=0L;
        writeCountInc=0;
      }
 else {
        writeCountInc++;
        String id=Utils.getIdFromPath(path);
        Map<String,Object> map=mk.getDocumentStore().find(Collection.NODES,id);
        Long oldWriteCount=(Long)map.get(UpdateOp.WRITE_COUNT);
        writeCount=oldWriteCount == null ? 0 : oldWriteCount;
      }
    }
    mk.applyChanges(revision,path,isNew,isDelete,isWritten,writeCount,writeCountInc,added,removed);
  }
}",0.9893296853625172
9032,"private void markChanged(String path){
  while (true) {
    changedNodes.add(path);
    if (PathUtils.denotesRoot(path)) {
      break;
    }
    path=PathUtils.getParentPath(path);
  }
}","private void markChanged(String path){
  if (!PathUtils.denotesRoot(path) && !PathUtils.isAbsolute(path)) {
    throw new IllegalArgumentException(""String_Node_Str"" + path);
  }
  while (true) {
    changedNodes.add(path);
    if (PathUtils.denotesRoot(path)) {
      break;
    }
    path=PathUtils.getParentPath(path);
  }
}",0.7290448343079922
9033,"void updateProperty(String path,String propertyName,String value){
  UpdateOp op=getUpdateOperationForNode(path);
  op.addMapEntry(propertyName + ""String_Node_Str"" + revision.toString(),value);
  long increment=mk.getWriteCountIncrement(path);
  op.increment(UpdateOp.WRITE_COUNT,1 + increment);
}","void updateProperty(String path,String propertyName,String value){
  UpdateOp op=getUpdateOperationForNode(path);
  String key=Utils.escapePropertyName(propertyName);
  op.addMapEntry(key + ""String_Node_Str"" + revision.toString(),value);
  long increment=mk.getWriteCountIncrement(path);
  op.increment(UpdateOp.WRITE_COUNT,1 + increment);
}",0.8934169278996865
9034,"private UpdateOp[] splitDocument(Map<String,Object> map){
  String id=(String)map.get(UpdateOp.ID);
  String path=id.substring(1);
  Long previous=(Long)map.get(UpdateOp.PREVIOUS);
  if (previous == null) {
    previous=0L;
  }
 else {
    previous++;
  }
  UpdateOp old=new UpdateOp(path,id + ""String_Node_Str"" + previous,true);
  UpdateOp main=new UpdateOp(path,id,false);
  main.set(UpdateOp.PREVIOUS,previous);
  for (  Entry<String,Object> e : map.entrySet()) {
    String key=e.getKey();
    if (key.equals(UpdateOp.ID)) {
    }
 else     if (key.equals(UpdateOp.PREVIOUS)) {
    }
 else     if (key.equals(UpdateOp.WRITE_COUNT)) {
      main.set(UpdateOp.WRITE_COUNT,e.getValue());
    }
 else {
      @SuppressWarnings(""String_Node_Str"") Map<String,Object> valueMap=(Map<String,Object>)e.getValue();
      Revision latestRev=null;
      for (      String r : valueMap.keySet()) {
        Revision propRev=Revision.fromString(r);
        if (latestRev == null || mk.isRevisionNewer(propRev,latestRev)) {
          latestRev=propRev;
        }
      }
      for (      String r : valueMap.keySet()) {
        Revision propRev=Revision.fromString(r);
        Object v=valueMap.get(r);
        if (propRev.equals(latestRev)) {
          main.setMapEntry(key + ""String_Node_Str"" + propRev.toString(),v);
        }
 else {
          old.addMapEntry(key + ""String_Node_Str"" + propRev.toString(),v);
        }
      }
    }
  }
  if (PURGE_OLD_REVISIONS) {
    old=null;
  }
  return new UpdateOp[]{old,main};
}","private UpdateOp[] splitDocument(Map<String,Object> map){
  String id=(String)map.get(UpdateOp.ID);
  String path=Utils.getPathFromId(id);
  Long previous=(Long)map.get(UpdateOp.PREVIOUS);
  if (previous == null) {
    previous=0L;
  }
 else {
    previous++;
  }
  UpdateOp old=new UpdateOp(path,id + ""String_Node_Str"" + previous,true);
  UpdateOp main=new UpdateOp(path,id,false);
  main.set(UpdateOp.PREVIOUS,previous);
  for (  Entry<String,Object> e : map.entrySet()) {
    String key=e.getKey();
    if (key.equals(UpdateOp.ID)) {
    }
 else     if (key.equals(UpdateOp.PREVIOUS)) {
    }
 else     if (key.equals(UpdateOp.WRITE_COUNT)) {
      main.set(UpdateOp.WRITE_COUNT,e.getValue());
    }
 else {
      @SuppressWarnings(""String_Node_Str"") Map<String,Object> valueMap=(Map<String,Object>)e.getValue();
      Revision latestRev=null;
      for (      String r : valueMap.keySet()) {
        Revision propRev=Revision.fromString(r);
        if (latestRev == null || mk.isRevisionNewer(propRev,latestRev)) {
          latestRev=propRev;
        }
      }
      for (      String r : valueMap.keySet()) {
        Revision propRev=Revision.fromString(r);
        Object v=valueMap.get(r);
        if (propRev.equals(latestRev)) {
          main.setMapEntry(key + ""String_Node_Str"" + propRev.toString(),v);
        }
 else {
          old.addMapEntry(key + ""String_Node_Str"" + propRev.toString(),v);
        }
      }
    }
  }
  if (PURGE_OLD_REVISIONS) {
    old=null;
  }
  return new UpdateOp[]{old,main};
}",0.988118811881188
9035,"@Override public Map<String,Object> find(Collection collection,String path){
  Map<String,Object> result;
synchronized (cache) {
    result=cache.get(path);
  }
  if (result != null) {
    return result;
  }
  log(""String_Node_Str"",path);
  DBCollection dbCollection=getDBCollection(collection);
  long start=start();
  try {
    DBObject doc=dbCollection.findOne(getByPathQuery(path));
    if (doc == null) {
      return null;
    }
    result=convertFromDBObject(doc);
synchronized (cache) {
      cache.put(path,result);
    }
    return result;
  }
  finally {
    end(start);
  }
}","@Override public Map<String,Object> find(Collection collection,String path){
synchronized (cache) {
    if (cache.containsKey(path)) {
      return cache.get(path);
    }
  }
  log(""String_Node_Str"",path);
  DBCollection dbCollection=getDBCollection(collection);
  long start=start();
  try {
    DBObject doc=dbCollection.findOne(getByPathQuery(path));
    Map<String,Object> result;
    if (doc == null) {
      result=null;
    }
 else {
      result=convertFromDBObject(doc);
    }
synchronized (cache) {
      cache.put(path,result);
    }
    return result;
  }
  finally {
    end(start);
  }
}",0.803030303030303
9036,"public Node.Children readChildren(String path,String nodeId,Revision rev,int limit){
  Node.Children c;
  c=nodeChildrenCache.get(nodeId);
  if (c != null) {
    return c;
  }
  String from=PathUtils.concat(path,""String_Node_Str"");
  from=Node.convertPathToDocumentId(from);
  from=from.substring(0,from.length() - 1);
  String to=PathUtils.concat(path,""String_Node_Str"");
  to=Node.convertPathToDocumentId(to);
  to=to.substring(0,to.length() - 2) + ""String_Node_Str"";
  List<Map<String,Object>> list=store.query(DocumentStore.Collection.NODES,from,to,limit);
  c=new Node.Children(path,nodeId,rev);
  for (  Map<String,Object> e : list) {
    if (isDeleted(e,rev)) {
      continue;
    }
    String id=e.get(UpdateOp.ID).toString();
    String p=id.substring(2);
    c.children.add(p);
  }
  nodeChildrenCache.put(nodeId,c);
  return c;
}","public Node.Children readChildren(String path,String nodeId,Revision rev,int limit){
  Node.Children c;
  c=nodeChildrenCache.get(nodeId);
  if (c != null) {
    return c;
  }
  String from=PathUtils.concat(path,""String_Node_Str"");
  from=Utils.getIdFromPath(from);
  from=from.substring(0,from.length() - 1);
  String to=PathUtils.concat(path,""String_Node_Str"");
  to=Utils.getIdFromPath(to);
  to=to.substring(0,to.length() - 2) + ""String_Node_Str"";
  List<Map<String,Object>> list=store.query(DocumentStore.Collection.NODES,from,to,limit);
  c=new Node.Children(path,nodeId,rev);
  for (  Map<String,Object> e : list) {
    if (isDeleted(e,rev)) {
      continue;
    }
    String id=e.get(UpdateOp.ID).toString();
    String p=Utils.getPathFromId(id);
    c.children.add(p);
  }
  nodeChildrenCache.put(nodeId,c);
  return c;
}",0.9318181818181818
9037,"private void markAsDeleted(String path,Commit commit,boolean subTreeAlso){
  Revision rev=commit.getRevision();
  commit.removeNode(path);
  if (subTreeAlso) {
    Node n=getNode(path,rev);
    nodeCache.remove(path + ""String_Node_Str"" + rev);
    Node.Children c=readChildren(path,n.getId(),rev,Integer.MAX_VALUE);
    for (    String childPath : c.children) {
      markAsDeleted(childPath,commit,true);
    }
  }
  nodeCache.remove(path + ""String_Node_Str"" + rev);
}","private void markAsDeleted(String path,Commit commit,boolean subTreeAlso){
  Revision rev=commit.getRevision();
  commit.removeNode(path);
  if (subTreeAlso) {
    Node n=getNode(path,rev);
    nodeCache.remove(path + ""String_Node_Str"" + rev);
    if (n != null) {
      Node.Children c=readChildren(path,n.getId(),rev,Integer.MAX_VALUE);
      for (      String childPath : c.children) {
        markAsDeleted(childPath,commit,true);
      }
    }
  }
  nodeCache.remove(path + ""String_Node_Str"" + rev);
}",0.962051282051282
9038,"private Node readNode(String path,Revision rev){
  String id=Node.convertPathToDocumentId(path);
  Map<String,Object> map=store.find(DocumentStore.Collection.NODES,id);
  if (map == null) {
    return null;
  }
  if (isDeleted(map,rev)) {
    return null;
  }
  Node n=new Node(path,rev);
  Long w=writeCountIncrements.get(path);
  long writeCount=w == null ? 0 : w;
  for (  String key : map.keySet()) {
    if (key.equals(UpdateOp.WRITE_COUNT)) {
      writeCount+=(Long)map.get(key);
    }
    if (!Utils.isPropertyName(key)) {
      continue;
    }
    Object v=map.get(key);
    @SuppressWarnings(""String_Node_Str"") Map<String,String> valueMap=(Map<String,String>)v;
    if (valueMap != null) {
      String value=getLatestValue(valueMap,rev);
      String propertyName=Utils.unescapePropertyName(key);
      n.setProperty(propertyName,value);
    }
  }
  n.setWriteCount(writeCount);
  return n;
}","private Node readNode(String path,Revision rev){
  String id=Utils.getIdFromPath(path);
  Map<String,Object> map=store.find(DocumentStore.Collection.NODES,id);
  if (map == null) {
    return null;
  }
  if (isDeleted(map,rev)) {
    return null;
  }
  Node n=new Node(path,rev);
  Long w=writeCountIncrements.get(path);
  long writeCount=w == null ? 0 : w;
  for (  String key : map.keySet()) {
    if (key.equals(UpdateOp.WRITE_COUNT)) {
      writeCount+=(Long)map.get(key);
    }
    if (!Utils.isPropertyName(key)) {
      continue;
    }
    Object v=map.get(key);
    @SuppressWarnings(""String_Node_Str"") Map<String,String> valueMap=(Map<String,String>)v;
    if (valueMap != null) {
      String value=getLatestValue(valueMap,rev);
      String propertyName=Utils.unescapePropertyName(key);
      n.setProperty(propertyName,value);
    }
  }
  n.setWriteCount(writeCount);
  return n;
}",0.9782971619365608
9039,"/** 
 * Create an add node operation for this node.
 */
UpdateOp asOperation(boolean isNew){
  String id=convertPathToDocumentId(path);
  UpdateOp op=new UpdateOp(path,id,isNew);
  op.set(UpdateOp.ID,id);
  for (  String p : properties.keySet()) {
    String key=Utils.escapePropertyName(p);
    op.addMapEntry(key + ""String_Node_Str"" + rev.toString(),properties.get(p));
  }
  return op;
}","/** 
 * Create an add node operation for this node.
 */
UpdateOp asOperation(boolean isNew){
  String id=Utils.getIdFromPath(path);
  UpdateOp op=new UpdateOp(path,id,isNew);
  op.set(UpdateOp.ID,id);
  for (  String p : properties.keySet()) {
    String key=Utils.escapePropertyName(p);
    op.addMapEntry(key + ""String_Node_Str"" + rev.toString(),properties.get(p));
  }
  return op;
}",0.9561855670103092
9040,"static int pathDepth(String path){
  return path.equals(""String_Node_Str"") ? 0 : path.replaceAll(""String_Node_Str"",""String_Node_Str"").length();
}","static int pathDepth(String path){
  if (path.equals(""String_Node_Str"")) {
    return 0;
  }
  int depth=0;
  for (int i=0; i < path.length(); i++) {
    if (path.charAt(i) == '/') {
      depth++;
    }
  }
  return depth;
}",0.4324324324324324
9041,"/** 
 * Apply the changes to the document store (to update MongoDB).
 * @param store the store
 */
void applyToDocumentStore(){
  DocumentStore store=mk.getDocumentStore();
  String commitRoot=null;
  ArrayList<UpdateOp> newNodes=new ArrayList<UpdateOp>();
  ArrayList<UpdateOp> changedNodes=new ArrayList<UpdateOp>();
  for (  String p : operations.keySet()) {
    markChanged(p);
    if (commitRoot == null) {
      commitRoot=p;
    }
 else {
      while (!PathUtils.isAncestor(commitRoot,p)) {
        commitRoot=PathUtils.getParentPath(commitRoot);
        if (PathUtils.denotesRoot(commitRoot)) {
          break;
        }
      }
    }
  }
  UpdateOp root=getUpdateOperationForNode(commitRoot);
  for (  String p : operations.keySet()) {
    UpdateOp op=operations.get(p);
    if (op == root) {
    }
 else     if (op.isNew()) {
      newNodes.add(op);
    }
 else {
      changedNodes.add(op);
    }
  }
  if (changedNodes.size() == 0 && root.isNew) {
    newNodes.add(root);
    root=null;
  }
  try {
    if (newNodes.size() > 0) {
      if (!store.create(Collection.NODES,newNodes)) {
        for (        UpdateOp op : newNodes) {
          op.unset(UpdateOp.ID);
          op.addMapEntry(UpdateOp.DELETED + ""String_Node_Str"" + revision.toString(),""String_Node_Str"");
          createOrUpdateNode(store,op);
        }
      }
    }
    for (    UpdateOp op : changedNodes) {
      createOrUpdateNode(store,op);
    }
    if (root != null) {
      long increment=mk.getWriteCountIncrement(commitRoot);
      root.increment(UpdateOp.WRITE_COUNT,1 + increment);
      root.addMapEntry(UpdateOp.REVISIONS + ""String_Node_Str"" + revision.toString(),""String_Node_Str"");
      createOrUpdateNode(store,root);
      operations.put(commitRoot,root);
    }
  }
 catch (  MicroKernelException e) {
    String msg=""String_Node_Str"" + diff.toString();
    LOG.error(msg,e);
    throw new MicroKernelException(msg,e);
  }
}","/** 
 * Apply the changes to the document store (to update MongoDB).
 * @param store the store
 */
void applyToDocumentStore(){
  DocumentStore store=mk.getDocumentStore();
  String commitRoot=null;
  ArrayList<UpdateOp> newNodes=new ArrayList<UpdateOp>();
  ArrayList<UpdateOp> changedNodes=new ArrayList<UpdateOp>();
  for (  String p : operations.keySet()) {
    markChanged(p);
    if (commitRoot == null) {
      commitRoot=p;
    }
 else {
      while (!PathUtils.isAncestor(commitRoot,p)) {
        commitRoot=PathUtils.getParentPath(commitRoot);
        if (PathUtils.denotesRoot(commitRoot)) {
          break;
        }
      }
    }
  }
  UpdateOp root=getUpdateOperationForNode(commitRoot);
  for (  String p : operations.keySet()) {
    UpdateOp op=operations.get(p);
    if (op == root) {
    }
 else     if (op.isNew()) {
      newNodes.add(op);
    }
 else {
      changedNodes.add(op);
    }
  }
  if (changedNodes.size() == 0 && root.isNew) {
    newNodes.add(root);
    root=null;
  }
  try {
    if (newNodes.size() > 0) {
      if (!store.create(Collection.NODES,newNodes)) {
        for (        UpdateOp op : newNodes) {
          op.unset(UpdateOp.ID);
          op.addMapEntry(UpdateOp.DELETED + ""String_Node_Str"" + revision.toString(),""String_Node_Str"");
          op.increment(UpdateOp.WRITE_COUNT,1);
          createOrUpdateNode(store,op);
        }
      }
    }
    for (    UpdateOp op : changedNodes) {
      createOrUpdateNode(store,op);
    }
    if (root != null) {
      long increment=mk.getWriteCountIncrement(commitRoot);
      root.increment(UpdateOp.WRITE_COUNT,1 + increment);
      root.addMapEntry(UpdateOp.REVISIONS + ""String_Node_Str"" + revision.toString(),""String_Node_Str"");
      createOrUpdateNode(store,root);
      operations.put(commitRoot,root);
    }
  }
 catch (  MicroKernelException e) {
    String msg=""String_Node_Str"" + diff.toString();
    LOG.error(msg,e);
    throw new MicroKernelException(msg,e);
  }
}",0.867866323907455
9042,"protected boolean removeEldestEntry(Map.Entry<K,V> eldest){
  return size() > size;
}","protected synchronized boolean removeEldestEntry(Map.Entry<K,V> eldest){
  boolean remove=size() > size;
  if (remove) {
    Object k=eldest.getKey();
    if (k != null) {
      keySet.remove(k);
    }
  }
  return remove;
}",0.4142394822006472
9043,"public void applyChanges(Revision rev,String path,boolean isNew,boolean isDelete,boolean isWritten,long oldWriteCount,long writeCountInc,ArrayList<String> added,ArrayList<String> removed){
  if (!isWritten) {
    if (writeCountInc == 0) {
      writeCountIncrements.remove(path);
    }
 else {
      writeCountIncrements.put(path,writeCountInc);
    }
  }
 else {
    writeCountIncrements.remove(path);
  }
  long newWriteCount=oldWriteCount + writeCountInc;
  Children c=nodeChildrenCache.get(path + ""String_Node_Str"" + (newWriteCount - 1));
  if (isNew || (!isDelete && c != null)) {
    String id=path + ""String_Node_Str"" + newWriteCount;
    Children c2=new Children(path,id,rev);
    TreeSet<String> set=new TreeSet<String>();
    if (c != null) {
      set.addAll(c.children);
    }
    set.removeAll(removed);
    set.addAll(added);
    c2.children.addAll(set);
    if (nodeChildrenCache.get(id) != null) {
      throw new AssertionError(""String_Node_Str"");
    }
    nodeChildrenCache.put(id,c2);
  }
}","public void applyChanges(Revision rev,String path,boolean isNew,boolean isDelete,boolean isWritten,long oldWriteCount,long writeCountInc,ArrayList<String> added,ArrayList<String> removed){
  if (!isWritten) {
    if (writeCountInc == 0) {
      writeCountIncrements.remove(path);
    }
 else {
      writeCountIncrements.put(path,writeCountInc);
    }
  }
 else {
    writeCountIncrements.remove(path);
  }
  long newWriteCount=oldWriteCount + writeCountInc;
  Children c=nodeChildrenCache.get(path + ""String_Node_Str"" + (newWriteCount - 1));
  if (isNew || (!isDelete && c != null)) {
    String id=path + ""String_Node_Str"" + newWriteCount;
    Children c2=new Children(path,id,rev);
    TreeSet<String> set=new TreeSet<String>();
    if (c != null) {
      set.addAll(c.children);
    }
    set.removeAll(removed);
    set.addAll(added);
    c2.children.addAll(set);
    if (nodeChildrenCache.get(id) != null) {
      MicroKernelException e=new MicroKernelException(""String_Node_Str"" + id);
      LOG.error(""String_Node_Str"",e);
    }
    nodeChildrenCache.put(id,c2);
  }
}",0.9463087248322148
9044,"void addNode(Node n){
  if (operations.containsKey(n.path)) {
    throw new MicroKernelException(""String_Node_Str"" + n.path);
  }
  operations.put(n.path,n.asOperation(true));
  addedNodes.add(n.path);
}","void addNode(Node n){
  if (operations.containsKey(n.path)) {
    String msg=""String_Node_Str"" + n.path;
    LOG.error(msg);
    throw new MicroKernelException(msg);
  }
  operations.put(n.path,n.asOperation(true));
  addedNodes.add(n.path);
}",0.7937219730941704
9045,"/** 
 * Apply the changes to the MongoMK (to update the cache).
 */
public void applyToCache(){
  HashMap<String,ArrayList<String>> nodesWithChangedChildren=new HashMap<String,ArrayList<String>>();
  ArrayList<String> addOrRemove=new ArrayList<String>();
  addOrRemove.addAll(addedNodes);
  addOrRemove.addAll(removedNodes);
  for (  String p : addOrRemove) {
    String parent=PathUtils.getParentPath(p);
    ArrayList<String> list=nodesWithChangedChildren.get(parent);
    if (list == null) {
      list=new ArrayList<String>();
      nodesWithChangedChildren.put(parent,list);
    }
    list.add(p);
  }
  for (  String path : changedNodes) {
    ArrayList<String> added=new ArrayList<String>();
    ArrayList<String> removed=new ArrayList<String>();
    ArrayList<String> changed=nodesWithChangedChildren.get(path);
    if (changed != null) {
      for (      String s : changed) {
        if (addedNodes.contains(s)) {
          added.add(s);
        }
 else         if (removedNodes.contains(s)) {
          removed.add(s);
        }
      }
    }
    UpdateOp op=operations.get(path);
    boolean isNew=op != null && op.isNew;
    boolean isWritten=op != null;
    long writeCountInc=mk.getWriteCountIncrement(path);
    Long writeCount=writeCounts.get(path);
    if (writeCount == null) {
      if (isNew) {
        writeCount=0L;
        writeCountInc=0;
      }
 else {
        writeCountInc++;
        String id=Node.convertPathToDocumentId(path);
        Map<String,Object> map=mk.getDocumentStore().find(Collection.NODES,id);
        Long oldWriteCount=(Long)map.get(UpdateOp.WRITE_COUNT);
        writeCount=oldWriteCount == null ? 0 : oldWriteCount;
      }
    }
    mk.applyChanges(revision,path,isNew,isWritten,writeCount,writeCountInc,added,removed);
  }
}","/** 
 * Apply the changes to the MongoMK (to update the cache).
 */
public void applyToCache(){
  HashMap<String,ArrayList<String>> nodesWithChangedChildren=new HashMap<String,ArrayList<String>>();
  ArrayList<String> addOrRemove=new ArrayList<String>();
  addOrRemove.addAll(addedNodes);
  addOrRemove.addAll(removedNodes);
  for (  String p : addOrRemove) {
    String parent=PathUtils.getParentPath(p);
    ArrayList<String> list=nodesWithChangedChildren.get(parent);
    if (list == null) {
      list=new ArrayList<String>();
      nodesWithChangedChildren.put(parent,list);
    }
    list.add(p);
  }
  for (  String path : changedNodes) {
    ArrayList<String> added=new ArrayList<String>();
    ArrayList<String> removed=new ArrayList<String>();
    ArrayList<String> changed=nodesWithChangedChildren.get(path);
    if (changed != null) {
      for (      String s : changed) {
        if (addedNodes.contains(s)) {
          added.add(s);
        }
 else         if (removedNodes.contains(s)) {
          removed.add(s);
        }
      }
    }
    UpdateOp op=operations.get(path);
    boolean isNew=op != null && op.isNew;
    boolean isWritten=op != null;
    boolean isDelete=op != null && op.isDelete;
    long writeCountInc=mk.getWriteCountIncrement(path);
    Long writeCount=writeCounts.get(path);
    if (writeCount == null) {
      if (isNew) {
        writeCount=0L;
        writeCountInc=0;
      }
 else {
        writeCountInc++;
        String id=Node.convertPathToDocumentId(path);
        Map<String,Object> map=mk.getDocumentStore().find(Collection.NODES,id);
        Long oldWriteCount=(Long)map.get(UpdateOp.WRITE_COUNT);
        writeCount=oldWriteCount == null ? 0 : oldWriteCount;
      }
    }
    mk.applyChanges(revision,path,isNew,isDelete,isWritten,writeCount,writeCountInc,added,removed);
  }
}",0.9841973939561964
9046,"/** 
 * Apply the changes to the document store (to update MongoDB).
 * @param store the store
 */
void applyToDocumentStore(){
  DocumentStore store=mk.getDocumentStore();
  String commitRoot=null;
  ArrayList<UpdateOp> newNodes=new ArrayList<UpdateOp>();
  ArrayList<UpdateOp> changedNodes=new ArrayList<UpdateOp>();
  for (  String p : operations.keySet()) {
    markChanged(p);
    if (commitRoot == null) {
      commitRoot=p;
    }
 else {
      while (!PathUtils.isAncestor(commitRoot,p)) {
        commitRoot=PathUtils.getParentPath(commitRoot);
        if (PathUtils.denotesRoot(commitRoot)) {
          break;
        }
      }
    }
  }
  UpdateOp root=getUpdateOperationForNode(commitRoot);
  for (  String p : operations.keySet()) {
    UpdateOp op=operations.get(p);
    if (op == root) {
    }
 else     if (op.isNew()) {
      newNodes.add(op);
    }
 else {
      changedNodes.add(op);
    }
  }
  if (changedNodes.size() == 0 && root.isNew) {
    newNodes.add(root);
    root=null;
  }
  try {
    if (newNodes.size() > 0) {
      store.create(Collection.NODES,newNodes);
    }
    for (    UpdateOp op : changedNodes) {
      createOrUpdateNode(store,op);
    }
    if (root != null) {
      long increment=mk.getWriteCountIncrement(commitRoot);
      root.increment(UpdateOp.WRITE_COUNT,1 + increment);
      root.addMapEntry(UpdateOp.REVISIONS + ""String_Node_Str"" + revision.toString(),""String_Node_Str"");
      createOrUpdateNode(store,root);
      operations.put(commitRoot,root);
    }
  }
 catch (  MicroKernelException e) {
    throw new MicroKernelException(""String_Node_Str"" + diff.toString(),e);
  }
}","/** 
 * Apply the changes to the document store (to update MongoDB).
 * @param store the store
 */
void applyToDocumentStore(){
  DocumentStore store=mk.getDocumentStore();
  String commitRoot=null;
  ArrayList<UpdateOp> newNodes=new ArrayList<UpdateOp>();
  ArrayList<UpdateOp> changedNodes=new ArrayList<UpdateOp>();
  for (  String p : operations.keySet()) {
    markChanged(p);
    if (commitRoot == null) {
      commitRoot=p;
    }
 else {
      while (!PathUtils.isAncestor(commitRoot,p)) {
        commitRoot=PathUtils.getParentPath(commitRoot);
        if (PathUtils.denotesRoot(commitRoot)) {
          break;
        }
      }
    }
  }
  UpdateOp root=getUpdateOperationForNode(commitRoot);
  for (  String p : operations.keySet()) {
    UpdateOp op=operations.get(p);
    if (op == root) {
    }
 else     if (op.isNew()) {
      newNodes.add(op);
    }
 else {
      changedNodes.add(op);
    }
  }
  if (changedNodes.size() == 0 && root.isNew) {
    newNodes.add(root);
    root=null;
  }
  try {
    if (newNodes.size() > 0) {
      if (!store.create(Collection.NODES,newNodes)) {
        for (        UpdateOp op : newNodes) {
          op.unset(UpdateOp.ID);
          op.addMapEntry(UpdateOp.DELETED + ""String_Node_Str"" + revision.toString(),""String_Node_Str"");
          createOrUpdateNode(store,op);
        }
      }
    }
    for (    UpdateOp op : changedNodes) {
      createOrUpdateNode(store,op);
    }
    if (root != null) {
      long increment=mk.getWriteCountIncrement(commitRoot);
      root.increment(UpdateOp.WRITE_COUNT,1 + increment);
      root.addMapEntry(UpdateOp.REVISIONS + ""String_Node_Str"" + revision.toString(),""String_Node_Str"");
      createOrUpdateNode(store,root);
      operations.put(commitRoot,root);
    }
  }
 catch (  MicroKernelException e) {
    String msg=""String_Node_Str"" + diff.toString();
    LOG.error(msg,e);
    throw new MicroKernelException(msg,e);
  }
}",0.8977752745705435
9047,"private UpdateOp[] splitDocument(Map<String,Object> map){
  String path=(String)map.get(UpdateOp.PATH);
  String id=(String)map.get(UpdateOp.ID);
  Long previous=(Long)map.get(UpdateOp.PREVIOUS);
  if (previous == null) {
    previous=0L;
  }
 else {
    previous++;
  }
  UpdateOp old=new UpdateOp(path,id + ""String_Node_Str"" + previous,true);
  UpdateOp main=new UpdateOp(path,id,false);
  main.set(UpdateOp.PREVIOUS,previous);
  for (  Entry<String,Object> e : map.entrySet()) {
    String key=e.getKey();
    if (key.equals(UpdateOp.PATH)) {
    }
 else     if (key.equals(UpdateOp.ID)) {
    }
 else     if (key.equals(UpdateOp.PREVIOUS)) {
    }
 else     if (key.equals(UpdateOp.WRITE_COUNT)) {
      main.set(UpdateOp.WRITE_COUNT,e.getValue());
    }
 else {
      @SuppressWarnings(""String_Node_Str"") Map<String,Object> valueMap=(Map<String,Object>)e.getValue();
      Revision latestRev=null;
      for (      String r : valueMap.keySet()) {
        Revision propRev=Revision.fromString(r);
        if (latestRev == null || mk.isRevisionNewer(propRev,latestRev)) {
          latestRev=propRev;
        }
      }
      for (      String r : valueMap.keySet()) {
        Revision propRev=Revision.fromString(r);
        Object v=valueMap.get(r);
        if (propRev.equals(latestRev)) {
          main.setMapEntry(key + ""String_Node_Str"" + propRev.toString(),v);
        }
 else {
          old.addMapEntry(key + ""String_Node_Str"" + propRev.toString(),v);
        }
      }
    }
  }
  if (PURGE_OLD_REVISIONS) {
    old=null;
  }
  return new UpdateOp[]{old,main};
}","private UpdateOp[] splitDocument(Map<String,Object> map){
  String id=(String)map.get(UpdateOp.ID);
  String path=id.substring(1);
  Long previous=(Long)map.get(UpdateOp.PREVIOUS);
  if (previous == null) {
    previous=0L;
  }
 else {
    previous++;
  }
  UpdateOp old=new UpdateOp(path,id + ""String_Node_Str"" + previous,true);
  UpdateOp main=new UpdateOp(path,id,false);
  main.set(UpdateOp.PREVIOUS,previous);
  for (  Entry<String,Object> e : map.entrySet()) {
    String key=e.getKey();
    if (key.equals(UpdateOp.ID)) {
    }
 else     if (key.equals(UpdateOp.PREVIOUS)) {
    }
 else     if (key.equals(UpdateOp.WRITE_COUNT)) {
      main.set(UpdateOp.WRITE_COUNT,e.getValue());
    }
 else {
      @SuppressWarnings(""String_Node_Str"") Map<String,Object> valueMap=(Map<String,Object>)e.getValue();
      Revision latestRev=null;
      for (      String r : valueMap.keySet()) {
        Revision propRev=Revision.fromString(r);
        if (latestRev == null || mk.isRevisionNewer(propRev,latestRev)) {
          latestRev=propRev;
        }
      }
      for (      String r : valueMap.keySet()) {
        Revision propRev=Revision.fromString(r);
        Object v=valueMap.get(r);
        if (propRev.equals(latestRev)) {
          main.setMapEntry(key + ""String_Node_Str"" + propRev.toString(),v);
        }
 else {
          old.addMapEntry(key + ""String_Node_Str"" + propRev.toString(),v);
        }
      }
    }
  }
  if (PURGE_OLD_REVISIONS) {
    old=null;
  }
  return new UpdateOp[]{old,main};
}",0.9591704471808166
9048,"public void removeNode(String path){
  removedNodes.add(path);
  UpdateOp op=getUpdateOperationForNode(path);
  op.addMapEntry(UpdateOp.DELETED + ""String_Node_Str"" + revision.toString(),""String_Node_Str"");
  long increment=mk.getWriteCountIncrement(path);
  op.increment(UpdateOp.WRITE_COUNT,1 + increment);
}","public void removeNode(String path){
  removedNodes.add(path);
  UpdateOp op=getUpdateOperationForNode(path);
  op.setDelete(true);
  op.addMapEntry(UpdateOp.DELETED + ""String_Node_Str"" + revision.toString(),""String_Node_Str"");
  long increment=mk.getWriteCountIncrement(path);
  op.increment(UpdateOp.WRITE_COUNT,1 + increment);
}",0.965625
9049,"void create(Collection collection,List<UpdateOp> updateOps);","/** 
 * Try to create a list of documents.
 * @param collection the collection
 * @param updateOps the list of documents to add
 * @return true if this worked (if none of the documents already existed)
 */
boolean create(Collection collection,List<UpdateOp> updateOps);",0.3404255319148936
9050,"@Override public void create(Collection collection,List<UpdateOp> updateOps){
  for (  UpdateOp op : updateOps) {
    createOrUpdate(collection,op);
  }
}","@Override public boolean create(Collection collection,List<UpdateOp> updateOps){
  ConcurrentSkipListMap<String,Map<String,Object>> map=getMap(collection);
  for (  UpdateOp op : updateOps) {
    if (map.containsKey(op.key)) {
      return false;
    }
  }
  for (  UpdateOp op : updateOps) {
    createOrUpdate(collection,op);
  }
  return true;
}",0.5657370517928287
9051,"private static void log(Object... args){
  if (LOG) {
    String msg=Arrays.toString(args);
    if (msg.length() > 10000) {
      msg=msg.length() + ""String_Node_Str"" + msg;
    }
    System.out.println(msg);
  }
}","private static void log(String message,Object... args){
  if (LOG.isDebugEnabled()) {
    String argList=Arrays.toString(args);
    if (argList.length() > 10000) {
      argList=argList.length() + ""String_Node_Str"" + argList;
    }
    LOG.debug(message + argList);
  }
}",0.6804123711340206
9052,"@Override public void create(Collection collection,List<UpdateOp> updateOps){
  log(""String_Node_Str"",updateOps);
  ArrayList<Map<String,Object>> maps=new ArrayList<Map<String,Object>>();
  DBObject[] inserts=new DBObject[updateOps.size()];
  for (int i=0; i < updateOps.size(); i++) {
    inserts[i]=new BasicDBObject();
    UpdateOp update=updateOps.get(i);
    Map<String,Object> target=Utils.newMap();
    MemoryDocumentStore.applyChanges(target,update);
    maps.add(target);
    for (    Entry<String,Operation> entry : update.changes.entrySet()) {
      String k=entry.getKey();
      Operation op=entry.getValue();
switch (op.type) {
case SET:
{
          inserts[i].put(k,op.value);
          break;
        }
case INCREMENT:
{
        inserts[i].put(k,op.value);
        break;
      }
case SET_MAP_ENTRY:
case ADD_MAP_ENTRY:
{
      String[] kv=k.split(""String_Node_Str"");
      DBObject value=new BasicDBObject(kv[1],op.value.toString());
      inserts[i].put(kv[0],value);
      break;
    }
case REMOVE_MAP_ENTRY:
{
  }
}
}
}
DBCollection dbCollection=getDBCollection(collection);
long start=start();
try {
try {
WriteResult writeResult=dbCollection.insert(inserts,WriteConcern.SAFE);
if (writeResult.getError() != null) {
throw new MicroKernelException(""String_Node_Str"" + writeResult.getError());
}
synchronized (cache) {
for (Map<String,Object> map : maps) {
  String path=(String)map.get(UpdateOp.ID);
synchronized (cache) {
    cache.put(path,map);
  }
}
}
}
 catch (MongoException e) {
throw new MicroKernelException(""String_Node_Str"",e);
}
}
  finally {
end(start);
}
}","@Override public boolean create(Collection collection,List<UpdateOp> updateOps){
  log(""String_Node_Str"",updateOps);
  ArrayList<Map<String,Object>> maps=new ArrayList<Map<String,Object>>();
  DBObject[] inserts=new DBObject[updateOps.size()];
  for (int i=0; i < updateOps.size(); i++) {
    inserts[i]=new BasicDBObject();
    UpdateOp update=updateOps.get(i);
    Map<String,Object> target=Utils.newMap();
    MemoryDocumentStore.applyChanges(target,update);
    maps.add(target);
    for (    Entry<String,Operation> entry : update.changes.entrySet()) {
      String k=entry.getKey();
      Operation op=entry.getValue();
switch (op.type) {
case SET:
{
          inserts[i].put(k,op.value);
          break;
        }
case INCREMENT:
{
        inserts[i].put(k,op.value);
        break;
      }
case SET_MAP_ENTRY:
case ADD_MAP_ENTRY:
{
      String[] kv=k.split(""String_Node_Str"");
      DBObject value=new BasicDBObject(kv[1],op.value.toString());
      inserts[i].put(kv[0],value);
      break;
    }
case REMOVE_MAP_ENTRY:
{
  }
}
}
}
DBCollection dbCollection=getDBCollection(collection);
long start=start();
try {
try {
WriteResult writeResult=dbCollection.insert(inserts,WriteConcern.SAFE);
if (writeResult.getError() != null) {
return false;
}
synchronized (cache) {
for (Map<String,Object> map : maps) {
  String path=(String)map.get(UpdateOp.ID);
synchronized (cache) {
    cache.put(path,map);
  }
}
}
return true;
}
 catch (MongoException e) {
return false;
}
}
  finally {
end(start);
}
}",0.9441033925686592
9053,"@Override public void dispose(){
  if (LOG_TIME) {
    System.out.println(""String_Node_Str"" + time);
  }
  nodesCollection.getDB().getMongo().close();
}","@Override public void dispose(){
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + time);
  }
  nodesCollection.getDB().getMongo().close();
}",0.8599348534201955
9054,"private boolean isDeleted(Map<String,Object> nodeProps,Revision rev){
  @SuppressWarnings(""String_Node_Str"") Map<String,String> valueMap=(Map<String,String>)nodeProps.get(UpdateOp.DELETED);
  if (valueMap != null) {
    for (    Map.Entry<String,String> e : valueMap.entrySet()) {
      Revision propRev=Revision.fromString(e.getKey());
      if (includeRevision(propRev,rev)) {
        if (""String_Node_Str"".equals(e.getValue())) {
          return true;
        }
      }
    }
  }
  return false;
}","private boolean isDeleted(Map<String,Object> nodeProps,Revision rev){
  @SuppressWarnings(""String_Node_Str"") Map<String,String> valueMap=(Map<String,String>)nodeProps.get(UpdateOp.DELETED);
  if (valueMap != null) {
    String value=getLatestValue(valueMap,rev);
    if (""String_Node_Str"".equals(value)) {
      return true;
    }
  }
  return false;
}",0.6893317702227433
9055,"public void applyChanges(Revision rev,String path,boolean isNew,boolean isWritten,long oldWriteCount,long writeCountInc,ArrayList<String> added,ArrayList<String> removed){
  if (!isWritten) {
    if (writeCountInc == 0) {
      writeCountIncrements.remove(path);
    }
 else {
      writeCountIncrements.put(path,writeCountInc);
    }
  }
 else {
    writeCountIncrements.remove(path);
  }
  long newWriteCount=oldWriteCount + writeCountInc;
  Children c=nodeChildrenCache.get(path + ""String_Node_Str"" + (newWriteCount - 1));
  if (isNew || c != null) {
    String id=path + ""String_Node_Str"" + newWriteCount;
    Children c2=new Children(path,id,rev);
    TreeSet<String> set=new TreeSet<String>();
    if (c != null) {
      set.addAll(c.children);
    }
    set.removeAll(removed);
    set.addAll(added);
    c2.children.addAll(set);
    if (nodeChildrenCache.get(id) != null) {
      throw new AssertionError(""String_Node_Str"");
    }
    nodeChildrenCache.put(id,c2);
  }
}","public void applyChanges(Revision rev,String path,boolean isNew,boolean isDelete,boolean isWritten,long oldWriteCount,long writeCountInc,ArrayList<String> added,ArrayList<String> removed){
  if (!isWritten) {
    if (writeCountInc == 0) {
      writeCountIncrements.remove(path);
    }
 else {
      writeCountIncrements.put(path,writeCountInc);
    }
  }
 else {
    writeCountIncrements.remove(path);
  }
  long newWriteCount=oldWriteCount + writeCountInc;
  Children c=nodeChildrenCache.get(path + ""String_Node_Str"" + (newWriteCount - 1));
  if (isNew || (!isDelete && c != null)) {
    String id=path + ""String_Node_Str"" + newWriteCount;
    Children c2=new Children(path,id,rev);
    TreeSet<String> set=new TreeSet<String>();
    if (c != null) {
      set.addAll(c.children);
    }
    set.removeAll(removed);
    set.addAll(added);
    c2.children.addAll(set);
    if (nodeChildrenCache.get(id) != null) {
      throw new AssertionError(""String_Node_Str"");
    }
    nodeChildrenCache.put(id,c2);
  }
}",0.9839034205231388
9056,"private Node readNode(String path,Revision rev){
  String id=Node.convertPathToDocumentId(path);
  Map<String,Object> map=store.find(DocumentStore.Collection.NODES,id);
  if (map == null) {
    return null;
  }
  if (isDeleted(map,rev)) {
    return null;
  }
  Node n=new Node(path,rev);
  Long w=writeCountIncrements.get(path);
  long writeCount=w == null ? 0 : w;
  for (  String key : map.keySet()) {
    if (key.equals(UpdateOp.WRITE_COUNT)) {
      writeCount+=(Long)map.get(key);
    }
    if (key.startsWith(""String_Node_Str"")) {
      continue;
    }
    Object v=map.get(key);
    @SuppressWarnings(""String_Node_Str"") Map<String,String> valueMap=(Map<String,String>)v;
    if (valueMap != null) {
      Revision latestRev=null;
      for (      String r : valueMap.keySet()) {
        Revision propRev=Revision.fromString(r);
        if (includeRevision(propRev,rev)) {
          if (latestRev == null || isRevisionNewer(propRev,latestRev)) {
            latestRev=propRev;
            n.setProperty(key,valueMap.get(r));
          }
        }
      }
    }
  }
  n.setWriteCount(writeCount);
  return n;
}","private Node readNode(String path,Revision rev){
  String id=Node.convertPathToDocumentId(path);
  Map<String,Object> map=store.find(DocumentStore.Collection.NODES,id);
  if (map == null) {
    return null;
  }
  if (isDeleted(map,rev)) {
    return null;
  }
  Node n=new Node(path,rev);
  Long w=writeCountIncrements.get(path);
  long writeCount=w == null ? 0 : w;
  for (  String key : map.keySet()) {
    if (key.equals(UpdateOp.WRITE_COUNT)) {
      writeCount+=(Long)map.get(key);
    }
    if (key.startsWith(""String_Node_Str"")) {
      continue;
    }
    Object v=map.get(key);
    @SuppressWarnings(""String_Node_Str"") Map<String,String> valueMap=(Map<String,String>)v;
    if (valueMap != null) {
      String value=getLatestValue(valueMap,rev);
      n.setProperty(key,value);
    }
  }
  n.setWriteCount(writeCount);
  return n;
}",0.7844739530132788
9057,"/** 
 * Create an update operation for the given document. The commit root is assumed to be the path, unless this is changed later on.
 * @param path the node path (for nodes)
 * @param key the primary key
 * @param isNew whether this is a new document
 * @param rev the revision
 */
UpdateOp(String path,String key,boolean isNew){
  this.path=path;
  this.key=key;
  this.isNew=isNew;
}","/** 
 * Create an update operation for the given document. The commit root is assumed to be the path, unless this is changed later on.
 * @param path the node path (for nodes)
 * @param key the primary key
 * @param isNew whether this is a new document
 * @param isDelete whether the _deleted property is set 
 * @param rev the revision
 */
UpdateOp(String path,String key,boolean isNew){
  this.path=path;
  this.key=key;
  this.isNew=isNew;
}",0.9314079422382672
9058,"@Override public Map<String,Object> createOrUpdate(Collection collection,UpdateOp updateOp){
  log(""String_Node_Str"",updateOp);
  DBCollection dbCollection=getDBCollection(collection);
  BasicDBObject setUpdates=new BasicDBObject();
  BasicDBObject incUpdates=new BasicDBObject();
  for (  Entry<String,Operation> entry : updateOp.changes.entrySet()) {
    String k=entry.getKey();
    Operation op=entry.getValue();
switch (op.type) {
case SET:
{
        setUpdates.append(k,op.value);
        break;
      }
case INCREMENT:
{
      incUpdates.append(k,op.value);
      break;
    }
case ADD_MAP_ENTRY:
{
    setUpdates.append(k,op.value.toString());
    break;
  }
case REMOVE_MAP_ENTRY:
{
  break;
}
case SET_MAP_ENTRY:
{
String[] kv=k.split(""String_Node_Str"");
BasicDBObject sub=new BasicDBObject();
sub.put(kv[1],op.value.toString());
setUpdates.append(kv[0],sub);
break;
}
}
}
DBObject query=getByPathQuery(updateOp.key);
BasicDBObject update=new BasicDBObject();
if (!setUpdates.isEmpty()) {
update.append(""String_Node_Str"",setUpdates);
}
if (!incUpdates.isEmpty()) {
update.append(""String_Node_Str"",incUpdates);
}
long start=start();
try {
DBObject oldNode=dbCollection.findAndModify(query,null,null,false,update,true,true);
Map<String,Object> map=convertFromDBObject(oldNode);
String path=(String)map.get(UpdateOp.ID);
synchronized (cache) {
cache.put(path,map);
}
log(""String_Node_Str"",map);
return map;
}
 catch (Exception e) {
throw new MicroKernelException(e);
}
 finally {
end(start);
}
}","@Override public Map<String,Object> createOrUpdate(Collection collection,UpdateOp updateOp){
  log(""String_Node_Str"",updateOp);
  DBCollection dbCollection=getDBCollection(collection);
  BasicDBObject setUpdates=new BasicDBObject();
  BasicDBObject incUpdates=new BasicDBObject();
  for (  Entry<String,Operation> entry : updateOp.changes.entrySet()) {
    String k=entry.getKey();
    Operation op=entry.getValue();
switch (op.type) {
case SET:
{
        setUpdates.append(k,op.value);
        break;
      }
case INCREMENT:
{
      incUpdates.append(k,op.value);
      break;
    }
case ADD_MAP_ENTRY:
{
    setUpdates.append(k,op.value);
    break;
  }
case REMOVE_MAP_ENTRY:
{
  break;
}
case SET_MAP_ENTRY:
{
String[] kv=k.split(""String_Node_Str"");
BasicDBObject sub=new BasicDBObject();
sub.put(kv[1],op.value);
setUpdates.append(kv[0],sub);
break;
}
}
}
DBObject query=getByPathQuery(updateOp.key);
BasicDBObject update=new BasicDBObject();
if (!setUpdates.isEmpty()) {
update.append(""String_Node_Str"",setUpdates);
}
if (!incUpdates.isEmpty()) {
update.append(""String_Node_Str"",incUpdates);
}
long start=start();
try {
DBObject oldNode=dbCollection.findAndModify(query,null,null,false,update,true,true);
Map<String,Object> map=convertFromDBObject(oldNode);
String path=(String)map.get(UpdateOp.ID);
synchronized (cache) {
cache.put(path,map);
}
log(""String_Node_Str"",map);
return map;
}
 catch (Exception e) {
throw new MicroKernelException(e);
}
 finally {
end(start);
}
}",0.9926224010731052
9059,"@Override public void create(Collection collection,List<UpdateOp> updateOps){
  log(""String_Node_Str"",updateOps);
  ArrayList<Map<String,Object>> maps=new ArrayList<Map<String,Object>>();
  DBObject[] inserts=new DBObject[updateOps.size()];
  for (int i=0; i < updateOps.size(); i++) {
    inserts[i]=new BasicDBObject();
    UpdateOp update=updateOps.get(i);
    Map<String,Object> target=Utils.newMap();
    MemoryDocumentStore.applyChanges(target,update);
    maps.add(target);
    for (    Entry<String,Operation> entry : update.changes.entrySet()) {
      String k=entry.getKey();
      Operation op=entry.getValue();
switch (op.type) {
case SET:
{
          inserts[i].put(k,op.value);
          break;
        }
case INCREMENT:
{
        inserts[i].put(k,op.value);
        break;
      }
case SET_MAP_ENTRY:
case ADD_MAP_ENTRY:
{
      String[] kv=k.split(""String_Node_Str"");
      DBObject value=new BasicDBObject(kv[1],op.value.toString());
      inserts[i].put(kv[0],value);
      break;
    }
case REMOVE_MAP_ENTRY:
{
  }
}
}
}
DBCollection dbCollection=getDBCollection(collection);
long start=start();
try {
WriteResult writeResult=dbCollection.insert(inserts,WriteConcern.SAFE);
if (writeResult.getError() != null) {
throw new MicroKernelException(""String_Node_Str"" + writeResult.getError());
}
synchronized (cache) {
for (Map<String,Object> map : maps) {
String path=(String)map.get(UpdateOp.ID);
synchronized (cache) {
  cache.put(path,map);
}
}
}
}
  finally {
end(start);
}
}","@Override public void create(Collection collection,List<UpdateOp> updateOps){
  log(""String_Node_Str"",updateOps);
  ArrayList<Map<String,Object>> maps=new ArrayList<Map<String,Object>>();
  DBObject[] inserts=new DBObject[updateOps.size()];
  for (int i=0; i < updateOps.size(); i++) {
    inserts[i]=new BasicDBObject();
    UpdateOp update=updateOps.get(i);
    Map<String,Object> target=Utils.newMap();
    MemoryDocumentStore.applyChanges(target,update);
    maps.add(target);
    for (    Entry<String,Operation> entry : update.changes.entrySet()) {
      String k=entry.getKey();
      Operation op=entry.getValue();
switch (op.type) {
case SET:
{
          inserts[i].put(k,op.value);
          break;
        }
case INCREMENT:
{
        inserts[i].put(k,op.value);
        break;
      }
case SET_MAP_ENTRY:
case ADD_MAP_ENTRY:
{
      String[] kv=k.split(""String_Node_Str"");
      DBObject value=new BasicDBObject(kv[1],op.value.toString());
      inserts[i].put(kv[0],value);
      break;
    }
case REMOVE_MAP_ENTRY:
{
  }
}
}
}
DBCollection dbCollection=getDBCollection(collection);
long start=start();
try {
try {
WriteResult writeResult=dbCollection.insert(inserts,WriteConcern.SAFE);
if (writeResult.getError() != null) {
throw new MicroKernelException(""String_Node_Str"" + writeResult.getError());
}
synchronized (cache) {
for (Map<String,Object> map : maps) {
  String path=(String)map.get(UpdateOp.ID);
synchronized (cache) {
    cache.put(path,map);
  }
}
}
}
 catch (MongoException e) {
throw new MicroKernelException(""String_Node_Str"",e);
}
}
  finally {
end(start);
}
}",0.9685371391501784
9060,"void setProperty(String propertyName,String value){
  properties.put(propertyName,value);
}","void setProperty(String propertyName,String value){
  if (value == null) {
    properties.remove(propertyName);
  }
 else {
    properties.put(propertyName,value);
  }
}",0.7
9061,"@Override public String getNodes(String path,String revisionId,int depth,long offset,int maxChildNodes,String filter) throws MicroKernelException {
  NodeFilter nodeFilter=filter == null || filter.isEmpty() ? null : NodeFilter.parse(filter);
  if (offset > 0 && nodeFilter != null && nodeFilter.getChildNodeFilter() != null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    Node rootNode=nodeStore.getNodes(path,revisionId,depth,offset,maxChildNodes,filter);
    if (rootNode == null) {
      return null;
    }
    JsopBuilder builder=new JsopBuilder().object();
    JsonUtil.toJson(builder,new MongoNodeState(rootNode),depth,(int)offset,maxChildNodes,true,nodeFilter);
    return builder.endObject().toString();
  }
 catch (  Exception e) {
    throw new MicroKernelException(e);
  }
}","@Override public String getNodes(String path,String revisionId,int depth,long offset,int maxChildNodes,String filter) throws MicroKernelException {
  NodeFilter nodeFilter=filter == null || filter.isEmpty() ? null : NodeFilter.parse(filter);
  if (offset > 0 && nodeFilter != null && nodeFilter.getChildNodeFilter() != null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    Node rootNode=nodeStore.getNodes(path,revisionId,depth,offset,maxChildNodes,filter);
    if (rootNode == null) {
      return null;
    }
    JsopBuilder builder=new JsopBuilder().object();
    depth=depth == -1 ? Integer.MAX_VALUE : depth;
    JsonUtil.toJson(builder,new MongoNodeState(rootNode),depth,(int)offset,maxChildNodes,true,nodeFilter);
    return builder.endObject().toString();
  }
 catch (  Exception e) {
    throw new MicroKernelException(e);
  }
}",0.9696609161213564
9062,"@Test public void depthLimitless() throws Exception {
  SimpleNodeScenario scenario=new SimpleNodeScenario(mk);
  scenario.create();
  JSONObject root=parseJSONObject(mk.getNodes(""String_Node_Str"",null,3449,0,-1,null));
  assertPropertyValue(root,""String_Node_Str"",1L);
  JSONObject a=resolveObjectValue(root,""String_Node_Str"");
  assertPropertyValue(a,""String_Node_Str"",2L);
  assertPropertyValue(a,""String_Node_Str"",1L);
  JSONObject b=resolveObjectValue(a,""String_Node_Str"");
  assertPropertyValue(b,""String_Node_Str"",""String_Node_Str"");
  JSONObject c=resolveObjectValue(a,""String_Node_Str"");
  assertPropertyValue(c,""String_Node_Str"",true);
}","@Test public void depthLimitless() throws Exception {
  SimpleNodeScenario scenario=new SimpleNodeScenario(mk);
  scenario.create();
  JSONObject root=parseJSONObject(mk.getNodes(""String_Node_Str"",null,-1,0,-1,null));
  assertPropertyValue(root,""String_Node_Str"",1L);
  JSONObject a=resolveObjectValue(root,""String_Node_Str"");
  assertPropertyValue(a,""String_Node_Str"",2L);
  assertPropertyValue(a,""String_Node_Str"",1L);
  JSONObject b=resolveObjectValue(a,""String_Node_Str"");
  assertPropertyValue(b,""String_Node_Str"",""String_Node_Str"");
  JSONObject c=resolveObjectValue(a,""String_Node_Str"");
  assertPropertyValue(c,""String_Node_Str"",true);
}",0.9907120743034056
9063,"private MongoNode getStoredNode(String path){
  MongoNode node=pathNodeMap.get(path);
  if (node != null) {
    return node;
  }
  NodeExistsCommand existCommand=new NodeExistsCommand(nodeStore,path,headRevisionId);
  existCommand.setBranchId(branchId);
  existCommand.setValidCommits(validCommits);
  boolean exists=false;
  try {
    exists=existCommand.execute();
  }
 catch (  Exception ignore) {
  }
  if (!exists) {
    throw new NotFoundException(path + ""String_Node_Str"" + headRevisionId);
  }
  node=existCommand.getNode();
  node.removeField(""String_Node_Str"");
  pathNodeMap.put(path,node);
  return node;
}","private MongoNode getStoredNode(String path,boolean addToMap){
  MongoNode node=pathNodeMap.get(path);
  if (node != null) {
    return node;
  }
  NodeExistsCommand existCommand=new NodeExistsCommand(nodeStore,path,headRevisionId);
  existCommand.setBranchId(branchId);
  boolean exists=false;
  try {
    exists=existCommand.execute();
  }
 catch (  Exception ignore) {
  }
  if (!exists) {
    throw new NotFoundException(path + ""String_Node_Str"" + headRevisionId);
  }
  node=existCommand.getNode();
  node.removeField(""String_Node_Str"");
  if (addToMap) {
    pathNodeMap.put(path,node);
  }
  return node;
}",0.9163281884646628
9064,"@Override public void visit(MoveNodeInstruction instruction){
  String srcPath=instruction.getSourcePath();
  String destPath=instruction.getDestPath();
  if (PathUtils.isAncestor(srcPath,destPath)) {
    throw new RuntimeException(""String_Node_Str"" + destPath);
  }
  String srcParentPath=PathUtils.getParentPath(srcPath);
  String srcNodeName=PathUtils.getName(srcPath);
  String destParentPath=PathUtils.getParentPath(destPath);
  String destNodeName=PathUtils.getName(destPath);
  MongoNode srcParent=getStoredNode(srcParentPath);
  if (!srcParent.childExists(srcNodeName)) {
    throw new NotFoundException(srcPath);
  }
  MongoNode destParent=getStoredNode(destParentPath);
  if (destParent.childExists(destNodeName)) {
    throw new RuntimeException(""String_Node_Str"" + destPath);
  }
  Map<String,MongoNode> nodesToCopy=new FetchNodesActionNew(nodeStore,srcPath,FetchNodesActionNew.LIMITLESS_DEPTH,headRevisionId).execute();
  for (  MongoNode nodeMongo : nodesToCopy.values()) {
    String oldPath=nodeMongo.getPath();
    String oldPathRel=PathUtils.relativize(srcPath,oldPath);
    String newPath=PathUtils.concat(destPath,oldPathRel);
    nodeMongo.setPath(newPath);
    nodeMongo.removeField(""String_Node_Str"");
    pathNodeMap.put(newPath,nodeMongo);
  }
  MongoNode srcNode=getStoredNode(srcPath);
  MongoNode destNode=getStagedNode(destPath);
  copyStagedChanges(srcNode,destNode);
  getStagedNode(destPath);
  destParent.addChild(destNodeName);
  srcParent.removeChild(srcNodeName);
}","@Override public void visit(MoveNodeInstruction instruction){
  String srcPath=instruction.getSourcePath();
  String destPath=instruction.getDestPath();
  if (PathUtils.isAncestor(srcPath,destPath)) {
    throw new RuntimeException(""String_Node_Str"" + destPath);
  }
  String srcParentPath=PathUtils.getParentPath(srcPath);
  String srcNodeName=PathUtils.getName(srcPath);
  String destParentPath=PathUtils.getParentPath(destPath);
  String destNodeName=PathUtils.getName(destPath);
  MongoNode srcParent=getStoredNode(srcParentPath);
  if (!srcParent.childExists(srcNodeName)) {
    throw new NotFoundException(srcPath);
  }
  MongoNode destParent=getStoredNode(destParentPath);
  if (destParent.childExists(destNodeName)) {
    throw new RuntimeException(""String_Node_Str"" + destPath);
  }
  Map<String,MongoNode> nodesToCopy=new FetchNodesActionNew(nodeStore,srcPath,FetchNodesActionNew.LIMITLESS_DEPTH,headRevisionId).execute();
  for (  MongoNode nodeMongo : nodesToCopy.values()) {
    String oldPath=nodeMongo.getPath();
    String oldPathRel=PathUtils.relativize(srcPath,oldPath);
    String newPath=PathUtils.concat(destPath,oldPathRel);
    nodeMongo.setPath(newPath);
    nodeMongo.removeField(""String_Node_Str"");
    pathNodeMap.put(newPath,nodeMongo);
  }
  MongoNode srcNode=getStoredNode(srcPath,false);
  MongoNode destNode=getStagedNode(destPath);
  copyStagedChanges(srcNode,destNode);
  destParent.addChild(destNodeName);
  srcParent.removeChild(srcNodeName);
}",0.988929889298893
9065,"/** 
 * Read a value and return the raw Json representation.
 * @return the Json representation of the value
 */
public String readRawValue(){
  int start=lastPos;
  while (jsop.charAt(start) <= ' ') {
    start++;
  }
  skipRawValue();
  return jsop.substring(start,lastPos);
}","/** 
 * Read a value and return the raw Json representation. This includes arrays and nested arrays.
 * @return the Json representation of the value
 */
public String readRawValue(){
  int start=lastPos;
  while (start < length && jsop.charAt(start) <= ' ') {
    start++;
  }
  skipRawValue();
  return jsop.substring(start,lastPos);
}",0.9055374592833876
9066,"private void skipRawValue(){
switch (currentType) {
case '[':
{
      read();
      int level=0;
      while (true) {
        if (matches(']') && level-- == 0) {
          break;
        }
 else         if (matches('[')) {
          level++;
        }
 else {
          read();
        }
      }
      break;
    }
case '{':
  read();
if (!matches('}')) {
  do {
    skip(STRING);
    read(':');
    skipRawValue();
  }
 while (matches(','));
  read('}');
}
break;
case NULL:
case NUMBER:
case TRUE:
case FALSE:
case COMMENT:
case STRING:
case IDENTIFIER:
read();
break;
default :
throw getFormatException(jsop,pos,""String_Node_Str"");
}
}","private void skipRawValue(){
switch (currentType) {
case '[':
{
      int level=0;
      while (true) {
        if (matches(']')) {
          if (--level == 0) {
            break;
          }
        }
 else         if (matches('[')) {
          level++;
        }
 else         if (matches(JsopReader.END)) {
          throw getFormatException(jsop,pos,""String_Node_Str"");
        }
 else {
          read();
        }
      }
      break;
    }
case '{':
  read();
if (!matches('}')) {
  do {
    skip(STRING);
    read(':');
    skipRawValue();
  }
 while (matches(','));
  read('}');
}
break;
case NULL:
case NUMBER:
case TRUE:
case FALSE:
case COMMENT:
case STRING:
case IDENTIFIER:
read();
break;
default :
throw getFormatException(jsop,pos,""String_Node_Str"");
}
}",0.872959545777147
9067,"/** 
 * Add an asterisk ('[*]') at the given position. This format is used to show where parsing failed in a statement.
 * @param s     the text
 * @param index the position
 * @return the text with asterisk
 */
private static String addAsterisk(String s,int index){
  if (s != null) {
    index=Math.min(index,s.length());
    s=s.substring(0,index) + ""String_Node_Str"" + s.substring(index);
  }
  return s;
}","/** 
 * Add an asterisk ('[*]') at the given position. This format is used to show where parsing failed in a statement.
 * @param s the text
 * @param index the position
 * @return the text with asterisk
 */
private static String addAsterisk(String s,int index){
  if (s != null) {
    index=Math.min(index,s.length());
    s=s.substring(0,index) + ""String_Node_Str"" + s.substring(index);
  }
  return s;
}",0.9950980392156864
9068,"public static void main(String... args){
  for (int k=0; k < 5; k++) {
    String s=""String_Node_Str"";
    StopWatch timer=new StopWatch();
    int t2=0;
    for (int i=0; i < 10000000; i++) {
      t2+=JsopBuilder.encode(s).length();
    }
    System.out.println(timer.seconds() + ""String_Node_Str"" + t2);
  }
}","public static void main(String... args){
  for (int k=0; k < 5; k++) {
    String s=""String_Node_Str"";
    StopWatch timer=new StopWatch();
    int t2=0;
    for (int i=0; i < 1000000; i++) {
      t2+=JsopBuilder.encode(s).length();
    }
    System.out.println(timer.seconds() + ""String_Node_Str"" + t2);
  }
}",0.9983948635634028
9069,"public void testRawValue(){
  JsopTokenizer t=new JsopTokenizer(""String_Node_Str"");
  t.read('{');
  assertEquals(""String_Node_Str"",t.readString());
  t.read(':');
  assertEquals(""String_Node_Str"",t.readRawValue());
  t.read(',');
  assertEquals(""String_Node_Str"",t.readRawValue());
  t.read(',');
  assertEquals(""String_Node_Str"",t.readRawValue());
  t.read(',');
  assertEquals(""String_Node_Str"",t.readRawValue());
  try {
    t.readRawValue();
    fail();
  }
 catch (  IllegalArgumentException e) {
  }
}","public void testRawValue(){
  JsopTokenizer t;
  t=new JsopTokenizer(""String_Node_Str"");
  try {
    t.readRawValue();
    fail();
  }
 catch (  IllegalArgumentException e) {
  }
  t=new JsopTokenizer(""String_Node_Str"");
  try {
    t.readRawValue();
    fail();
  }
 catch (  IllegalArgumentException e) {
  }
  t=new JsopTokenizer(""String_Node_Str"");
  t.read('{');
  assertEquals(""String_Node_Str"",t.readString());
  t.read(':');
  assertEquals(""String_Node_Str"",t.readRawValue());
  t.read(',');
  assertEquals(""String_Node_Str"",t.readRawValue());
  t.read(',');
  assertEquals(""String_Node_Str"",t.readRawValue());
  t.read(',');
  assertEquals(""String_Node_Str"",t.readRawValue());
  t.read(',');
  assertEquals(""String_Node_Str"",t.readRawValue());
  t.read(',');
  assertEquals(""String_Node_Str"",t.readRawValue());
  t.read(',');
  assertEquals(""String_Node_Str"",t.readRawValue());
  t.read(',');
  try {
    t.readRawValue();
    fail();
  }
 catch (  IllegalArgumentException e) {
  }
}",0.2331778814123917
9070,"@Override public NodeTypeIterator getDeclaredSubtypes(){
  try {
    Collection<NodeType> types=new ArrayList<NodeType>();
    NodeTypeIterator iterator=manager.getAllNodeTypes();
    while (iterator.hasNext()) {
      NodeType type=iterator.nextNodeType();
      if (type.isNodeType(getName()) && !isNodeType(type.getName())) {
        List<String> declaredSuperTypeNames=Arrays.asList(type.getDeclaredSupertypeNames());
        if (declaredSuperTypeNames.contains(type)) {
          types.add(type);
        }
      }
    }
    return new NodeTypeIteratorAdapter(types);
  }
 catch (  RepositoryException e) {
    throw new IllegalStateException(""String_Node_Str"" + this,e);
  }
}","@Override public NodeTypeIterator getDeclaredSubtypes(){
  try {
    Collection<NodeType> types=new ArrayList<NodeType>();
    NodeTypeIterator iterator=manager.getAllNodeTypes();
    while (iterator.hasNext()) {
      NodeType type=iterator.nextNodeType();
      String name=type.getName();
      if (type.isNodeType(getName()) && !isNodeType(name)) {
        List<String> declaredSuperTypeNames=Arrays.asList(type.getDeclaredSupertypeNames());
        if (declaredSuperTypeNames.contains(name)) {
          types.add(type);
        }
      }
    }
    return new NodeTypeIteratorAdapter(types);
  }
 catch (  RepositoryException e) {
    throw new IllegalStateException(""String_Node_Str"" + this,e);
  }
}",0.95821325648415
9071,"public NodeTypeImpl(NodeTypeManager manager,NameMapper mapper,String name,String cnd){
  this.manager=manager;
  this.mapper=mapper;
  this.name=name;
  Matcher matcher=CND_PATTERN.matcher(cnd);
  matcher.matches();
  this.isAbstract=matcher.group(5) != null;
  this.mixin=matcher.group(4) != null;
  this.hasOrderableChildNodes=matcher.group(7) != null;
  this.primaryItemName=matcher.group(8);
  String supertypes=matcher.group(2);
  if (supertypes != null) {
    this.declaredSuperTypeNames=supertypes.split(""String_Node_Str"");
  }
 else   if (mixin) {
    this.declaredSuperTypeNames=new String[0];
  }
 else {
    this.declaredSuperTypeNames=new String[]{""String_Node_Str""};
  }
  String defs=matcher.group(9);
  if (defs != null && !defs.isEmpty()) {
    for (    String line : defs.split(""String_Node_Str"")) {
      matcher=DEF_PATTERN.matcher(line);
      if (!matcher.matches()) {
        continue;
      }
      String defName=matcher.group(2);
      String defType=matcher.group(3);
      boolean mandatory=matcher.group(6).contains(""String_Node_Str"");
      boolean autoCreated=matcher.group(6).contains(""String_Node_Str"");
      boolean isProtected=matcher.group(6).contains(""String_Node_Str"");
      boolean multiple=matcher.group(6).contains(""String_Node_Str"");
      int onParentVersionAction=OnParentVersionAction.COPY;
      if (matcher.group(10) != null) {
        onParentVersionAction=OnParentVersionAction.valueFromName(matcher.group(10));
      }
      if (""String_Node_Str"".equals(matcher.group(1))) {
        declaredChildNodeDefinitions.add(new NodeDefinitionImpl(this,mapper,defName,autoCreated,mandatory,onParentVersionAction,isProtected,manager,defType.split(""String_Node_Str""),matcher.group(5),false));
      }
 else       if (""String_Node_Str"".equals(matcher.group(1))) {
        declaredPropertyDefinitions.add(new PropertyDefinitionImpl(this,mapper,defName,autoCreated,mandatory,onParentVersionAction,isProtected,valueFromName(defType),multiple));
      }
    }
  }
}","public NodeTypeImpl(NodeTypeManager manager,NameMapper mapper,String name,String cnd){
  this.manager=manager;
  this.mapper=mapper;
  this.name=name;
  Matcher matcher=CND_PATTERN.matcher(cnd);
  matcher.matches();
  this.isAbstract=matcher.group(5) != null;
  this.mixin=matcher.group(4) != null;
  this.hasOrderableChildNodes=matcher.group(6) != null;
  this.primaryItemName=matcher.group(7);
  String supertypes=matcher.group(2);
  if (supertypes != null) {
    this.declaredSuperTypeNames=supertypes.split(""String_Node_Str"");
  }
 else   if (mixin) {
    this.declaredSuperTypeNames=new String[0];
  }
 else {
    this.declaredSuperTypeNames=new String[]{""String_Node_Str""};
  }
  String defs=matcher.group(9);
  if (defs != null && !defs.isEmpty()) {
    for (    String line : defs.split(""String_Node_Str"")) {
      matcher=DEF_PATTERN.matcher(line);
      if (!matcher.matches()) {
        continue;
      }
      String defName=matcher.group(2);
      String defType=matcher.group(3);
      boolean mandatory=matcher.group(6).contains(""String_Node_Str"");
      boolean autoCreated=matcher.group(6).contains(""String_Node_Str"");
      boolean isProtected=matcher.group(6).contains(""String_Node_Str"");
      boolean multiple=matcher.group(6).contains(""String_Node_Str"");
      boolean allowSNS=matcher.group(6).contains(""String_Node_Str"");
      int onParentVersionAction=OnParentVersionAction.COPY;
      if (matcher.group(10) != null) {
        onParentVersionAction=OnParentVersionAction.valueFromName(matcher.group(10));
      }
      if (""String_Node_Str"".equals(matcher.group(1))) {
        declaredChildNodeDefinitions.add(new NodeDefinitionImpl(this,mapper,defName,autoCreated,mandatory,onParentVersionAction,isProtected,manager,defType.split(""String_Node_Str""),matcher.group(5),allowSNS));
      }
 else       if (""String_Node_Str"".equals(matcher.group(1))) {
        declaredPropertyDefinitions.add(new PropertyDefinitionImpl(this,mapper,defName,autoCreated,mandatory,onParentVersionAction,isProtected,valueFromName(defType),multiple));
      }
    }
  }
}",0.9788801571709234
9072,"/** 
 * Classifies the given set of features.
 * @return The category the set of features is classified as.
 */
@Override public K classify(Collection<T> features){
  SortedSet<Entry<K,Float>> probabilites=this.categoryProbabilities(features);
  if (probabilites.size() > 0)   return probabilites.last().getKey();
  return null;
}","/** 
 * Classifies the given set of features.
 * @return The category the set of features is classified as.
 */
@Override public K classify(Collection<T> features){
  SortedSet<Classification<T,K>> probabilites=this.categoryProbabilities(features);
  System.out.println(""String_Node_Str"");
  for (  Classification<T,K> prob : probabilites)   System.out.println(prob);
  if (probabilites.size() > 0) {
    System.out.println(""String_Node_Str"" + probabilites.last().getCategory());
    return probabilites.last().getCategory();
  }
 else {
    System.out.println(""String_Node_Str"");
  }
  return null;
}",0.5843179377013964
9073,"@Override public int compare(Entry<K,Float> o1,Entry<K,Float> o2){
  int toReturn=o1.getValue().compareTo(o2.getValue());
  if ((toReturn == 0) && (o1.getKey() != o2.getKey())) {
    toReturn=-1;
  }
  return toReturn;
}","@Override public int compare(Classification<T,K> o1,Classification<T,K> o2){
  int toReturn=Float.compare(o1.getProbability(),o2.getProbability());
  if ((toReturn == 0) && !o1.getCategory().equals(o2.getCategory()))   toReturn=-1;
  return toReturn;
}",0.4491525423728814
9074,"/** 
 * Retrieves a sorted <code>Set</code> of probabilities that the given set of features is classified as the available categories.
 * @param features The set of features to use.
 * @return A sorted <code>Set</code> of category-probability-entries.
 */
private SortedSet<Entry<K,Float>> categoryProbabilities(Collection<T> features){
  SortedSet<Entry<K,Float>> probabilities=new TreeSet<Entry<K,Float>>(new Comparator<Entry<K,Float>>(){
    @Override public int compare(    Entry<K,Float> o1,    Entry<K,Float> o2){
      int toReturn=o1.getValue().compareTo(o2.getValue());
      if ((toReturn == 0) && (o1.getKey() != o2.getKey())) {
        toReturn=-1;
      }
      return toReturn;
    }
  }
);
  for (  K category : this.getCategories())   probabilities.add(new SimpleEntry<K,Float>(category,this.categoryProbability(features,category)));
  return probabilities;
}","/** 
 * Retrieves a sorted <code>Set</code> of probabilities that the given set of features is classified as the available categories.
 * @param features The set of features to use.
 * @return A sorted <code>Set</code> of category-probability-entries.
 */
private SortedSet<Classification<T,K>> categoryProbabilities(Collection<T> features){
  SortedSet<Classification<T,K>> probabilities=new TreeSet<Classification<T,K>>(new Comparator<Classification<T,K>>(){
    @Override public int compare(    Classification<T,K> o1,    Classification<T,K> o2){
      int toReturn=Float.compare(o1.getProbability(),o2.getProbability());
      if ((toReturn == 0) && !o1.getCategory().equals(o2.getCategory()))       toReturn=-1;
      return toReturn;
    }
  }
);
  for (  K category : this.getCategories())   probabilities.add(new Classification<T,K>(features,category,this.categoryProbability(features,category)));
  return probabilities;
}",0.5769656699889258
9075,"/** 
 * Train the classifier by telling it that the given features resulted in the given category.
 * @param category The category the features belong to.
 * @param features The features that resulted in the given category.
 */
public void learn(K category,Collection<T> features){
  for (  T feature : features)   this.incrementFeature(feature,category);
  this.incrementCategory(category);
  this.memoryQueue.offer(new Classification<T,K>(features,category));
  if (this.memoryQueue.size() > Classifier.MEMORY_CAPACITY) {
    Classification<T,K> toForget=this.memoryQueue.remove();
    for (    T feature : toForget.getFeatureset())     this.decrementFeature(feature,toForget.getCategory());
    this.decrementCategory(toForget.getCategory());
  }
}","/** 
 * Train the classifier by telling it that the given features resulted in the given category.
 * @param classification The classification to learn.
 */
public void learn(Classification<T,K> classification){
  System.out.println(""String_Node_Str"" + classification);
  for (  T feature : classification.getFeatureset())   this.incrementFeature(feature,classification.getCategory());
  this.incrementCategory(classification.getCategory());
  this.memoryQueue.offer(classification);
  if (this.memoryQueue.size() > Classifier.MEMORY_CAPACITY) {
    Classification<T,K> toForget=this.memoryQueue.remove();
    System.out.println(""String_Node_Str"" + toForget);
    for (    T feature : toForget.getFeatureset())     this.decrementFeature(feature,toForget.getCategory());
    this.decrementCategory(toForget.getCategory());
  }
}",0.5741444866920152
9076,"/** 
 * Increments the count of a given feature in the given category.  This is equal to telling the classifier, that this feature has occurred in this category.
 * @param feature The feature, which count to increase.
 * @param category The category the feature occurred in.
 */
public void incrementFeature(T feature,K category){
  Dictionary<T,Integer> features=this.featureCountPerCategory.get(category);
  if (features == null) {
    this.featureCountPerCategory.put(category,new Hashtable<T,Integer>(Classifier.INITIAL_FEATURE_DICTIONARY_CAPACITY));
    features=this.featureCountPerCategory.get(category);
  }
  Integer count=features.get(feature);
  if (count == null) {
    features.put(feature,1);
    count=features.get(feature);
  }
  count++;
  Integer totalCount=this.totalFeatureCount.get(feature);
  if (totalCount == null) {
    this.totalFeatureCount.put(feature,1);
    totalCount=this.totalFeatureCount.get(feature);
  }
  totalCount++;
}","/** 
 * Increments the count of a given feature in the given category.  This is equal to telling the classifier, that this feature has occurred in this category.
 * @param feature The feature, which count to increase.
 * @param category The category the feature occurred in.
 */
public void incrementFeature(T feature,K category){
  Dictionary<T,Integer> features=this.featureCountPerCategory.get(category);
  if (features == null) {
    this.featureCountPerCategory.put(category,new Hashtable<T,Integer>(Classifier.INITIAL_FEATURE_DICTIONARY_CAPACITY));
    features=this.featureCountPerCategory.get(category);
  }
  Integer count=features.get(feature);
  if (count == null) {
    features.put(feature,0);
    count=features.get(feature);
  }
  features.put(feature,++count);
  Integer totalCount=this.totalFeatureCount.get(feature);
  if (totalCount == null) {
    this.totalFeatureCount.put(feature,1);
    totalCount=this.totalFeatureCount.get(feature);
  }
  this.totalFeatureCount.put(feature,++totalCount);
}",0.9553752535496958
9077,"/** 
 * Increments the count of a given category.  This is equal to telling the classifier, that this category has occurred once more.
 * @param category The category, which count to increase.
 */
public void incrementCategory(K category){
  Integer count=this.totalCategoryCount.get(category);
  if (count == null) {
    this.totalCategoryCount.put(category,1);
    count=this.totalCategoryCount.get(category);
  }
  count++;
}","/** 
 * Increments the count of a given category.  This is equal to telling the classifier, that this category has occurred once more.
 * @param category The category, which count to increase.
 */
public void incrementCategory(K category){
  Integer count=this.totalCategoryCount.get(category);
  if (count == null) {
    this.totalCategoryCount.put(category,1);
    count=this.totalCategoryCount.get(category);
  }
  this.totalCategoryCount.put(category,++count);
}",0.9463087248322148
9078,"/** 
 * @param args
 * @throws IOException 
 */
public static void main(String[] args) throws IOException {
  BayesClassifier<String,String> classifier=new BayesClassifier<String,String>();
  BufferedReader io=new BufferedReader(new InputStreamReader(System.in));
  String line=""String_Node_Str"";
  System.out.print(""String_Node_Str"");
  while ((line=io.readLine()) != null) {
    String[] tokens=line.split(""String_Node_Str"");
    if (tokens.length < 3) {
      System.out.println(""String_Node_Str"");
      continue;
    }
    if (tokens[0].startsWith(""String_Node_Str"")) {
      Collection<String> context=Arrays.asList(Arrays.copyOfRange(tokens,2,tokens.length));
      classifier.learn(tokens[1],context);
      System.out.println(""String_Node_Str"" + classifier.getCategoriesTotal());
    }
 else     if (tokens[0].startsWith(""String_Node_Str"")) {
      Collection<String> context=Arrays.asList(Arrays.copyOfRange(tokens,1,tokens.length));
      System.out.println(classifier.classify(context));
    }
    System.out.print(""String_Node_Str"");
  }
}","/** 
 * @param args
 * @throws IOException 
 */
public static void main(String[] args) throws IOException {
  BayesClassifier<String,String> classifier=new BayesClassifier<String,String>();
  BufferedReader io=new BufferedReader(new InputStreamReader(System.in));
  String line=""String_Node_Str"";
  System.out.print(""String_Node_Str"");
  while ((line=io.readLine()) != null) {
    String[] tokens=line.split(""String_Node_Str"");
    if (tokens.length < 3) {
      System.out.println(""String_Node_Str"");
      continue;
    }
    if (tokens[0].startsWith(""String_Node_Str"")) {
      Collection<String> context=Arrays.asList(Arrays.copyOfRange(tokens,2,tokens.length));
      classifier.learn(tokens[1],context);
    }
 else     if (tokens[0].startsWith(""String_Node_Str"")) {
      Collection<String> context=Arrays.asList(Arrays.copyOfRange(tokens,1,tokens.length));
      classifier.classify(context);
    }
    System.out.print(""String_Node_Str"");
  }
}",0.8897755610972569
9079,"/** 
 * Classifies the given set of features.
 * @return The category the set of features is classified as.
 */
@Override public K classify(Collection<T> features){
  SortedSet<Classification<T,K>> probabilites=this.categoryProbabilities(features);
  System.out.println(""String_Node_Str"");
  for (  Classification<T,K> prob : probabilites)   System.out.println(prob);
  if (probabilites.size() > 0) {
    System.out.println(""String_Node_Str"" + probabilites.last().getCategory());
    return probabilites.last().getCategory();
  }
 else {
    System.out.println(""String_Node_Str"");
  }
  return null;
}","/** 
 * Classifies the given set of features.
 * @return The category the set of features is classified as.
 */
@Override public Classification<T,K> classify(Collection<T> features){
  SortedSet<Classification<T,K>> probabilites=this.categoryProbabilities(features);
  if (probabilites.size() > 0) {
    return probabilites.last();
  }
  return null;
}",0.4197271773347324
9080,"/** 
 * The classify method.  It will retrieve the most likely category for the features given and depends on the concrete classifier implementation.
 * @param features The features to classify.
 * @return The category most likely.
 */
public abstract K classify(Collection<T> features);","/** 
 * The classify method.  It will retrieve the most likely category for the features given and depends on the concrete classifier implementation.
 * @param features The features to classify.
 * @return The category most likely.
 */
public abstract Classification<T,K> classify(Collection<T> features);",0.9695945945945946
9081,"/** 
 * Train the classifier by telling it that the given features resulted in the given category.
 * @param classification The classification to learn.
 */
public void learn(Classification<T,K> classification){
  System.out.println(""String_Node_Str"" + classification);
  for (  T feature : classification.getFeatureset())   this.incrementFeature(feature,classification.getCategory());
  this.incrementCategory(classification.getCategory());
  this.memoryQueue.offer(classification);
  if (this.memoryQueue.size() > Classifier.MEMORY_CAPACITY) {
    Classification<T,K> toForget=this.memoryQueue.remove();
    System.out.println(""String_Node_Str"" + toForget);
    for (    T feature : toForget.getFeatureset())     this.decrementFeature(feature,toForget.getCategory());
    this.decrementCategory(toForget.getCategory());
  }
}","/** 
 * Train the classifier by telling it that the given features resulted in the given category.
 * @param classification The classification to learn.
 */
public void learn(Classification<T,K> classification){
  for (  T feature : classification.getFeatureset())   this.incrementFeature(feature,classification.getCategory());
  this.incrementCategory(classification.getCategory());
  this.memoryQueue.offer(classification);
  if (this.memoryQueue.size() > this.memoryCapacity) {
    Classification<T,K> toForget=this.memoryQueue.remove();
    for (    T feature : toForget.getFeatureset())     this.decrementFeature(feature,toForget.getCategory());
    this.decrementCategory(toForget.getCategory());
  }
}",0.4208469055374593
9082,"/** 
 * Decrements the count of a given feature in the given category.  This is equal to telling the classifier that this feature was classified once in the category.
 * @param feature The feature to decrement the count for.
 * @param category The category.
 */
public void decrementFeature(T feature,K category){
  Dictionary<T,Integer> features=this.featureCountPerCategory.get(category);
  if (features == null) {
    return;
  }
  Integer count=features.get(feature);
  if (count == null) {
    return;
  }
  if (count == 1) {
    features.remove(feature);
  }
 else {
    count--;
  }
  Integer totalCount=this.totalFeatureCount.get(feature);
  if (totalCount == null) {
    return;
  }
  if (totalCount == 1) {
    this.totalFeatureCount.remove(feature);
  }
 else {
    totalCount--;
  }
}","/** 
 * Decrements the count of a given feature in the given category.  This is equal to telling the classifier that this feature was classified once in the category.
 * @param feature The feature to decrement the count for.
 * @param category The category.
 */
public void decrementFeature(T feature,K category){
  Dictionary<T,Integer> features=this.featureCountPerCategory.get(category);
  if (features == null) {
    return;
  }
  Integer count=features.get(feature);
  if (count == null) {
    return;
  }
  if (count.intValue() == 1) {
    features.remove(feature);
    if (features.size() == 0) {
      this.featureCountPerCategory.remove(category);
    }
  }
 else {
    features.put(feature,--count);
  }
  Integer totalCount=this.totalFeatureCount.get(feature);
  if (totalCount == null) {
    return;
  }
  if (totalCount.intValue() == 1) {
    this.totalFeatureCount.remove(feature);
  }
 else {
    this.totalFeatureCount.put(feature,--totalCount);
  }
}",0.88712422007941
9083,"/** 
 * Increments the count of a given feature in the given category.  This is equal to telling the classifier, that this feature has occurred in this category.
 * @param feature The feature, which count to increase.
 * @param category The category the feature occurred in.
 */
public void incrementFeature(T feature,K category){
  Dictionary<T,Integer> features=this.featureCountPerCategory.get(category);
  if (features == null) {
    this.featureCountPerCategory.put(category,new Hashtable<T,Integer>(Classifier.INITIAL_FEATURE_DICTIONARY_CAPACITY));
    features=this.featureCountPerCategory.get(category);
  }
  Integer count=features.get(feature);
  if (count == null) {
    features.put(feature,0);
    count=features.get(feature);
  }
  features.put(feature,++count);
  Integer totalCount=this.totalFeatureCount.get(feature);
  if (totalCount == null) {
    this.totalFeatureCount.put(feature,1);
    totalCount=this.totalFeatureCount.get(feature);
  }
  this.totalFeatureCount.put(feature,++totalCount);
}","/** 
 * Increments the count of a given feature in the given category.  This is equal to telling the classifier, that this feature has occurred in this category.
 * @param feature The feature, which count to increase.
 * @param category The category the feature occurred in.
 */
public void incrementFeature(T feature,K category){
  Dictionary<T,Integer> features=this.featureCountPerCategory.get(category);
  if (features == null) {
    this.featureCountPerCategory.put(category,new Hashtable<T,Integer>(Classifier.INITIAL_FEATURE_DICTIONARY_CAPACITY));
    features=this.featureCountPerCategory.get(category);
  }
  Integer count=features.get(feature);
  if (count == null) {
    features.put(feature,0);
    count=features.get(feature);
  }
  features.put(feature,++count);
  Integer totalCount=this.totalFeatureCount.get(feature);
  if (totalCount == null) {
    this.totalFeatureCount.put(feature,0);
    totalCount=this.totalFeatureCount.get(feature);
  }
  this.totalFeatureCount.put(feature,++totalCount);
}",0.9990147783251232
9084,"/** 
 * Decrements the count of a given category.  This is equal to telling the classifier, that this category has occurred once less.
 * @param category The category, which count to increase.
 */
public void decrementCategory(K category){
  Integer count=this.totalCategoryCount.get(category);
  if (count == null) {
    return;
  }
  if (count == 1) {
    this.totalCategoryCount.remove(category);
  }
 else {
    count--;
  }
}","/** 
 * Decrements the count of a given category.  This is equal to telling the classifier, that this category has occurred once less.
 * @param category The category, which count to increase.
 */
public void decrementCategory(K category){
  Integer count=this.totalCategoryCount.get(category);
  if (count == null) {
    return;
  }
  if (count.intValue() == 1) {
    this.totalCategoryCount.remove(category);
  }
 else {
    this.totalCategoryCount.put(category,--count);
  }
}",0.935093509350935
9085,"/** 
 * Increments the count of a given category.  This is equal to telling the classifier, that this category has occurred once more.
 * @param category The category, which count to increase.
 */
public void incrementCategory(K category){
  Integer count=this.totalCategoryCount.get(category);
  if (count == null) {
    this.totalCategoryCount.put(category,1);
    count=this.totalCategoryCount.get(category);
  }
  this.totalCategoryCount.put(category,++count);
}","/** 
 * Increments the count of a given category.  This is equal to telling the classifier, that this category has occurred once more.
 * @param category The category, which count to increase.
 */
public void incrementCategory(K category){
  Integer count=this.totalCategoryCount.get(category);
  if (count == null) {
    this.totalCategoryCount.put(category,0);
    count=this.totalCategoryCount.get(category);
  }
  this.totalCategoryCount.put(category,++count);
}",0.9978540772532188
9086,"public static boolean isFormattedWritable(Application application) throws IOException {
  try {
    TrailerBlock trailerBlock=application.readTrailer(MfClassicConstants.TRANSPORT_KEY);
    for (int dataArea=0; dataArea < 3; dataArea++) {
      if (!trailerBlock.canWriteDataBlock(MfClassicConstants.TRANSPORT_KEY.getKey(),dataArea))       return false;
    }
    if (NfcUtils.getLeastSignificantNibble(trailerBlock.getGeneralPurposeByte()) != 0)     return false;
    return true;
  }
 catch (  MfLoginException e) {
    return false;
  }
}","public static boolean isFormattedWritable(Application application,KeyValue keyValue) throws IOException {
  try {
    TrailerBlock trailerBlock=application.readTrailer(keyValue);
    for (int dataArea=0; dataArea < 3; dataArea++) {
      if (!trailerBlock.canWriteDataBlock(keyValue.getKey(),dataArea))       return false;
    }
    if (NfcUtils.getLeastSignificantNibble(trailerBlock.getGeneralPurposeByte()) != 0)     return false;
    return true;
  }
 catch (  MfLoginException e) {
    return false;
  }
}",0.9066666666666666
9087,"protected MfClassicNdefOperations createNdefOperations(ApduTag tag,MemoryLayout memoryLayout){
  boolean formatted=false;
  boolean writable=false;
  MfClassicReaderWriter readerWriter=new AcrMfClassicReaderWriter(tag,memoryLayout);
  try {
    if (readerWriter.hasApplicationDirectory()) {
      ApplicationDirectory applicationDirectory=readerWriter.getApplicationDirectory();
      if (applicationDirectory.hasApplication(MfConstants.NDEF_APP_ID)) {
        formatted=true;
        Application application=applicationDirectory.openApplication(MfConstants.NDEF_APP_ID);
        writable=ClassicHandler.isFormattedWritable(application);
      }
 else {
        throw new NfcException(""String_Node_Str"");
      }
    }
 else {
      if (ClassicHandler.isBlank(readerWriter)) {
        writable=true;
      }
 else       throw new NfcException(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  return new MfClassicNdefOperations(readerWriter,formatted,writable);
}","protected MfClassicNdefOperations createNdefOperations(ApduTag tag,MemoryLayout memoryLayout){
  boolean formatted=false;
  boolean writable=false;
  MfClassicReaderWriter readerWriter=new AcrMfClassicReaderWriter(tag,memoryLayout);
  try {
    if (readerWriter.hasApplicationDirectory()) {
      ApplicationDirectory applicationDirectory=readerWriter.getApplicationDirectory();
      if (applicationDirectory.hasApplication(MfConstants.NDEF_APP_ID)) {
        formatted=true;
        Application application=applicationDirectory.openApplication(MfConstants.NDEF_APP_ID);
        writable=ClassicHandler.isFormattedWritable(application,MfClassicConstants.NDEF_KEY);
      }
 else {
        throw new NfcException(""String_Node_Str"");
      }
    }
 else {
      if (ClassicHandler.isBlank(readerWriter)) {
        writable=true;
      }
 else       throw new NfcException(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  return new MfClassicNdefOperations(readerWriter,formatted,writable);
}",0.986206896551724
9088,"@Test public void testIsFormattedWritable() throws Exception {
  ApplicationDirectory applicationDirectory=ReaderWriterCreator.createReadWriter(""String_Node_Str"",MemoryLayout.CLASSIC_1K).getApplicationDirectory();
  assertTrue(ClassicHandler.isFormattedWritable(applicationDirectory.openApplication(MfConstants.NDEF_APP_ID)));
  ApplicationDirectory applicationDirectory2=ReaderWriterCreator.createReadWriter(""String_Node_Str"",MemoryLayout.CLASSIC_4K).getApplicationDirectory();
  assertTrue(ClassicHandler.isFormattedWritable(applicationDirectory2.openApplication(MfConstants.NDEF_APP_ID)));
}","@Test public void testIsFormattedWritable() throws Exception {
  ApplicationDirectory applicationDirectory=ReaderWriterCreator.createReadWriter(""String_Node_Str"",MemoryLayout.CLASSIC_1K).getApplicationDirectory();
  assertTrue(ClassicHandler.isFormattedWritable(applicationDirectory.openApplication(MfConstants.NDEF_APP_ID),MfClassicConstants.TRANSPORT_KEY));
  ApplicationDirectory applicationDirectory2=ReaderWriterCreator.createReadWriter(""String_Node_Str"",MemoryLayout.CLASSIC_4K).getApplicationDirectory();
  assertTrue(ClassicHandler.isFormattedWritable(applicationDirectory2.openApplication(MfConstants.NDEF_APP_ID),MfClassicConstants.NDEF_KEY));
}",0.9511609287429944
9089,"@Override public WellKnownRecord decodePayload(byte[] payload,NdefMessageDecoder messageDecoder){
  CollisionResolutionRecord collisionResolutionRecord=new CollisionResolutionRecord();
  collisionResolutionRecord.setRandomNumber((((payload[0] << 8) | payload[1]) & 0xFFFF));
  return collisionResolutionRecord;
}","@Override public WellKnownRecord decodePayload(byte[] payload,NdefMessageDecoder messageDecoder){
  CollisionResolutionRecord collisionResolutionRecord=new CollisionResolutionRecord();
  collisionResolutionRecord.setRandomNumber(((payload[0] & 0xFF) << 8) | (payload[1] & 0xFF));
  return collisionResolutionRecord;
}",0.9252782193958664
9090,"private byte[] createPayload(NdefMessageEncoder messageEncoder,SmartPosterRecord myRecord){
  try {
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    if (myRecord.getTitle() != null)     baos.write(messageEncoder.encodeSingle(myRecord.getTitle()));
    if (myRecord.getUri() != null)     baos.write(messageEncoder.encodeSingle(myRecord.getUri()));
    if (myRecord.getAction() != null)     baos.write(messageEncoder.encodeSingle(myRecord.getAction()));
    return baos.toByteArray();
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","private byte[] createPayload(NdefMessageEncoder messageEncoder,SmartPosterRecord myRecord){
  List<Record> records=new ArrayList<Record>();
  if (myRecord.getTitle() != null)   records.add(myRecord.getTitle());
  if (myRecord.getUri() != null)   records.add(myRecord.getUri());
  if (myRecord.getAction() != null)   records.add(myRecord.getAction());
  return messageEncoder.encode(records);
}",0.5634095634095634
9091,"@Test public void testEncode() throws Exception {
  SmartPosterRecord smartPosterRecord=new SmartPosterRecord();
  smartPosterRecord.setTitle(new TextRecord(""String_Node_Str"",Charset.forName(""String_Node_Str""),Locale.GERMAN));
  smartPosterRecord.setUri(new UriRecord(""String_Node_Str""));
  byte[] payload=encoder.encodePayload(smartPosterRecord,messageEncoder);
  assertEquals(innerSmartPoster,NfcUtils.convertBinToASCII(payload));
}","@Test public void testEncode() throws Exception {
  SmartPosterRecord smartPosterRecord=new SmartPosterRecord();
  smartPosterRecord.setTitle(new TextRecord(""String_Node_Str"",Charset.forName(""String_Node_Str""),Locale.GERMAN));
  smartPosterRecord.setUri(new UriRecord(""String_Node_Str""));
  byte[] payload=messageEncoder.encodeSingle(smartPosterRecord);
  System.out.println(innerSmartPoster);
  System.out.println(NfcUtils.convertBinToASCII(payload));
  assertEquals(innerSmartPoster,NfcUtils.convertBinToASCII(payload));
}",0.7954070981210856
9092,"public AbstractProtocolDataUnit decode(byte[] pduData){
  int destination=(pduData[0] >> 2) & 0x3f;
  int source=pduData[1] & 0x3f;
  int pduType=((pduData[0] & 0x03) << 2) | ((pduData[1] & 0xc0) >> 6);
switch (pduType) {
case PduConstants.PDU_CONNECT:
    return new Connect(destination,source,decodeParameter(pduData,2));
case PduConstants.PDU_CONNECT_COMPLETE:
  return new ConnectComplete(destination,source,decodeParameter(pduData,2));
case PduConstants.PDU_DISCONNECT:
return new Disconnect(destination,source);
case PduConstants.PDU_DISCONNECTED_MODE:
int reason=pduData[2];
return new DisconnectedMode(destination,source,reason);
case PduConstants.PDU_INFORMATION:
int received=pduData[2] & 0x0f;
int send=pduData[2] >>> 4;
byte[] informationData=new byte[pduData.length - 3];
System.arraycopy(pduData,3,informationData,0,informationData.length);
return new Information(destination,source,received,send,informationData);
case PduConstants.PDU_PARAMETER_EXCHANGE:
return new ParameterExchange(destination,source,decodeParameter(pduData,2));
case PduConstants.PDU_RECEIVE_READY:
int receivedReady=pduData[2] & 0x0f;
return new ReceiveReady(destination,source,receivedReady);
case PduConstants.PDU_SYMMETRY:
return new Symmetry();
case PduConstants.PDU_UNNUMBERED_INFORMATION:
byte[] unnumberedData=new byte[pduData.length - 2];
System.arraycopy(pduData,2,unnumberedData,0,unnumberedData.length);
return new UnnumberedInformation(destination,source,unnumberedData);
case PduConstants.PDU_RECEIVE_NOT_READY:
case PduConstants.PDU_AGGREGATED_FRAME:
case PduConstants.PDU_FRAME_REJECT:
throw new UnsupportedOperationException(""String_Node_Str"" + pduType);
default :
throw new RuntimeException(""String_Node_Str"" + pduType);
}
}","public AbstractProtocolDataUnit decode(byte[] pduData){
  int destination=(pduData[0] >> 2) & 0x3f;
  int source=pduData[1] & 0x3f;
  int pduType=((pduData[0] & 0x03) << 2) | ((pduData[1] & 0xc0) >> 6);
switch (pduType) {
case PduConstants.PDU_CONNECT:
    return new Connect(destination,source,decodeParameter(pduData,2));
case PduConstants.PDU_CONNECT_COMPLETE:
  return new ConnectComplete(destination,source,decodeParameter(pduData,2));
case PduConstants.PDU_DISCONNECT:
return new Disconnect(destination,source);
case PduConstants.PDU_DISCONNECTED_MODE:
int reason=pduData[2];
return new DisconnectedMode(destination,source,reason);
case PduConstants.PDU_INFORMATION:
int received=pduData[2] & 0x0f;
int send=(pduData[2] >>> 4) & 0x0f;
byte[] informationData=new byte[pduData.length - 3];
System.arraycopy(pduData,3,informationData,0,informationData.length);
return new Information(destination,source,received,send,informationData);
case PduConstants.PDU_PARAMETER_EXCHANGE:
return new ParameterExchange(destination,source,decodeParameter(pduData,2));
case PduConstants.PDU_RECEIVE_READY:
int receivedReady=pduData[2] & 0x0f;
return new ReceiveReady(destination,source,receivedReady);
case PduConstants.PDU_SYMMETRY:
return new Symmetry();
case PduConstants.PDU_UNNUMBERED_INFORMATION:
byte[] unnumberedData=new byte[pduData.length - 2];
System.arraycopy(pduData,2,unnumberedData,0,unnumberedData.length);
return new UnnumberedInformation(destination,source,unnumberedData);
case PduConstants.PDU_RECEIVE_NOT_READY:
case PduConstants.PDU_AGGREGATED_FRAME:
case PduConstants.PDU_FRAME_REJECT:
throw new UnsupportedOperationException(""String_Node_Str"" + pduType);
default :
throw new RuntimeException(""String_Node_Str"" + pduType);
}
}",0.9974025974025974
9093,"@Test public void testSequences() throws Exception {
  LlcpSocket llcpSocket=new LlcpSocket(new AddressPair(0,0),null);
  assertEquals(0,llcpSocket.getSendSequence());
  llcpSocket.incSendSequence();
  assertEquals(1,llcpSocket.getSendSequence());
  assertEquals(0,llcpSocket.getReceivedSequence());
  llcpSocket.incReceivedSequence();
  assertEquals(1,llcpSocket.getReceivedSequence());
}","@Test public void testSequences() throws Exception {
  LlcpSocket llcpSocket=new LlcpSocket(new AddressPair(0,0),null);
  assertEquals(0,llcpSocket.getSendSequence());
  llcpSocket.incSendSequence();
  assertEquals(1,llcpSocket.getSendSequence());
  for (int y=0; y < 3; y++) {
    for (int x=0; x < 16; x++) {
      assertEquals(x,llcpSocket.getReceivedSequence());
      llcpSocket.incReceivedSequence();
    }
  }
}",0.8376703841387856
9094,"@Test public void testSnepPut() throws Exception {
  snepClient.setSnepAgentListener(new SnepAgentListener(){
    @Override public void onSnepConnection(    SnepAgent snepAgent){
      List<Record> records=new ArrayList<Record>();
      for (int x=0; x < 50; x++)       records.add(new UriRecord(""String_Node_Str""));
      snepAgent.doPut(records,ndefListener);
    }
    @Override public boolean hasDataToSend(){
      return true;
    }
  }
);
  helper.launch();
synchronized (this) {
    wait(5000);
  }
  assertTrue(ndefListener.isSuccess());
  Collection<Record> receivedRecords=ndefListener.getRecords();
  assertEquals(50,receivedRecords.size());
  UriRecord uriRecord=(UriRecord)receivedRecords.iterator().next();
  assertEquals(""String_Node_Str"",uriRecord.getUri());
}","@Test public void testSnepPut() throws Exception {
  snepClient.setSnepAgentListener(new SnepAgentListener(){
    @Override public void onSnepConnection(    SnepAgent snepAgent){
      List<Record> records=new ArrayList<Record>();
      for (int x=0; x < 50; x++)       records.add(new UriRecord(""String_Node_Str""));
      snepAgent.doPut(records,ndefListener);
    }
    @Override public boolean hasDataToSend(){
      return true;
    }
  }
);
  helper.launch();
synchronized (this) {
    wait(500000);
  }
  assertTrue(ndefListener.isSuccess());
  Collection<Record> receivedRecords=ndefListener.getRecords();
  assertEquals(50,receivedRecords.size());
  UriRecord uriRecord=(UriRecord)receivedRecords.iterator().next();
  assertEquals(""String_Node_Str"",uriRecord.getUri());
}",0.9987146529562982
9095,"@Override protected ErrorRecord createRecord(NdefRecord ndefRecord,NdefMessageDecoder messageDecoder){
  ErrorRecord errorRecord=new ErrorRecord();
  byte[] payload=ndefRecord.getPayload();
  ErrorReason errorReason=ErrorReason.toErrorReason(payload[0]);
  errorRecord.setErrorReason(errorReason);
  Number number;
switch (errorReason) {
case TemporaryMemoryConstraints:
{
      number=new Short((short)(payload[1] & 0xFFFF));
      break;
    }
case PermanenteMemoryConstraints:
{
    number=new Long(((long)(payload[1] << 24 | payload[2] << 16 | payload[3] << 8 | payload[4])) & 0xFFFFFFFFL);
    break;
  }
case CarrierSpecificConstraints:
{
  number=new Short((short)(payload[1] & 0xFFFF));
  break;
}
default :
{
throw new RuntimeException();
}
}
errorRecord.setErrorData(number);
return errorRecord;
}","@Override protected ErrorRecord createRecord(NdefRecord ndefRecord,NdefMessageDecoder messageDecoder){
  ErrorRecord errorRecord=new ErrorRecord();
  byte[] payload=ndefRecord.getPayload();
  ErrorReason errorReason=ErrorReason.toErrorReason(payload[0]);
  errorRecord.setErrorReason(errorReason);
  Number number;
switch (errorReason) {
case TemporaryMemoryConstraints:
{
      number=new Short((short)(payload[1] & 0xFFFF));
      break;
    }
case PermanenteMemoryConstraints:
{
    number=new Long(((long)(payload[1] & 0xFF) << 24) + ((payload[2] & 0xFF) << 16) + ((payload[3] & 0xFF) << 8)+ ((payload[4] & 0xFF) << 0));
    break;
  }
case CarrierSpecificConstraints:
{
  number=new Short((short)(payload[1] & 0xFFFF));
  break;
}
default :
{
throw new RuntimeException();
}
}
errorRecord.setErrorData(number);
return errorRecord;
}",0.95985401459854
9096,"@Override public NdefRecord encodeRecord(Record record,NdefMessageEncoder messageEncoder){
  ActionRecord actionRecord=new ActionRecord();
  if (!actionRecord.hasAction()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  byte[] payload=new byte[]{(byte)actionRecord.getAction().getValue()};
  return new NdefRecord(NdefConstants.TNF_WELL_KNOWN,ActionRecord.TYPE,record.getId(),payload);
}","@Override public NdefRecord encodeRecord(Record record,NdefMessageEncoder messageEncoder){
  ActionRecord actionRecord=(ActionRecord)record;
  if (!actionRecord.hasAction()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  byte[] payload=new byte[]{actionRecord.getAction().getValue()};
  return new NdefRecord(NdefConstants.TNF_WELL_KNOWN,ActionRecord.TYPE,record.getId(),payload);
}",0.9455445544554456
9097,"@Test public void testEncodeDecodeRoundtrip(){
  NdefMessageEncoder ndefMessageEncoder=NdefContext.getNdefMessageEncoder();
  NdefMessageDecoder ndefMessageDecoder=NdefContext.getNdefMessageDecoder();
  for (  Record record : records) {
    System.out.println(record.getClass().getSimpleName());
    byte[] ndef=ndefMessageEncoder.encodeSingle(record);
    Record decodedRecord=ndefMessageDecoder.decodeToRecord(ndef);
    assertEquals(record.getClass().getName(),record,decodedRecord);
  }
}","@Test public void testEncodeDecodeRoundtrip(){
  NdefMessageEncoder ndefMessageEncoder=NdefContext.getNdefMessageEncoder();
  NdefMessageDecoder ndefMessageDecoder=NdefContext.getNdefMessageDecoder();
  for (  Record record : records) {
    byte[] ndef=ndefMessageEncoder.encodeSingle(record);
    Record decodedRecord=ndefMessageDecoder.decodeToRecord(ndef);
    if (!record.equals(decodedRecord)) {
      fail(record.getClass().getName());
    }
  }
}",0.5925925925925926
9098,"public void execute() throws BuildException {
  if (srcdir == null && argfiles == null) {
    throw new BuildException(""String_Node_Str"",location);
  }
  if (destdir != null) {
    cmd.createArgument().setValue(""String_Node_Str"");
    cmd.createArgument().setFile(destdir);
  }
  if (classpath != null) {
    cmd.createArgument().setValue(""String_Node_Str"");
    cmd.createArgument().setPath(classpath);
  }
  if (bootclasspath != null) {
    cmd.createArgument().setValue(""String_Node_Str"");
    cmd.createArgument().setPath(bootclasspath);
  }
  if (extdirs != null) {
    cmd.createArgument().setValue(""String_Node_Str"");
    cmd.createArgument().setPath(extdirs);
  }
  if (null != encoding) {
    cmd.createArgument().setValue(""String_Node_Str"");
    cmd.createArgument().setValue(encoding);
  }
  if (null != source) {
    cmd.createArgument().setValue(""String_Node_Str"");
    cmd.createArgument().setValue(source);
  }
  int numargfiles=0;
  if (argfiles != null) {
    for (Iterator i=argfiles.iterator(); i.hasNext(); ) {
      String name=i.next() + ""String_Node_Str"";
      File argfile=project.resolveFile(name);
      if (check(argfile,name,false,location)) {
        cmd.createArgument().setValue(""String_Node_Str"");
        cmd.createArgument().setFile(argfile);
        numargfiles++;
      }
    }
  }
  int numfiles=0;
  if (srcdir != null) {
    String[] dirs=srcdir.list();
    for (int i=0; i < dirs.length; i++) {
      File dir=project.resolveFile(dirs[i]);
      check(dir,dirs[i],true,location);
      String[] files=getDirectoryScanner(dir).getIncludedFiles();
      for (int j=0; j < files.length; j++) {
        File file=new File(dir,files[j]);
        if (FileUtil.hasSourceSuffix(file)) {
          cmd.createArgument().setFile(file);
          numfiles++;
        }
      }
    }
  }
  if ((null != ignoredOptions) && (ignoredOptions.size() > 0)) {
    log(""String_Node_Str"" + ignoredOptions,Project.MSG_WARN);
    if (ignoredOptions.contains(""String_Node_Str"")) {
      throw new BuildException(""String_Node_Str"");
    }
  }
  log(""String_Node_Str"" + numfiles + ""String_Node_Str""+ +numargfiles+ ""String_Node_Str""+ (null == destdir ? ""String_Node_Str"" : ""String_Node_Str"" + destdir.getPath()),Project.MSG_INFO);
  if (fork || (internalclasspath != null)) {
    log(""String_Node_Str"",Project.MSG_WARN);
  }
  int result=spoon();
  if (result != 0) {
    String msg=""String_Node_Str"" + result;
    if (failonerror) {
      reset();
      throw new BuildException(msg);
    }
 else {
      log(msg,Project.MSG_WARN);
    }
  }
  reset();
}","@Override public void execute() throws BuildException {
  if (srcdir == null && argfiles == null) {
    throw new BuildException(""String_Node_Str"",location);
  }
  if (destdir != null) {
    cmd.createArgument().setValue(""String_Node_Str"");
    cmd.createArgument().setFile(destdir);
  }
  if (classpath != null) {
    cmd.createArgument().setValue(""String_Node_Str"");
    cmd.createArgument().setPath(classpath);
  }
  if (bootclasspath != null) {
    cmd.createArgument().setValue(""String_Node_Str"");
    cmd.createArgument().setPath(bootclasspath);
  }
  if (extdirs != null) {
    cmd.createArgument().setValue(""String_Node_Str"");
    cmd.createArgument().setPath(extdirs);
  }
  if (null != encoding) {
    cmd.createArgument().setValue(""String_Node_Str"");
    cmd.createArgument().setValue(encoding);
  }
  if (null != source) {
    cmd.createArgument().setValue(""String_Node_Str"");
    cmd.createArgument().setValue(source);
  }
  int numargfiles=0;
  if (argfiles != null) {
    for (Iterator i=argfiles.iterator(); i.hasNext(); ) {
      String name=i.next() + ""String_Node_Str"";
      File argfile=project.resolveFile(name);
      if (check(argfile,name,false,location)) {
        cmd.createArgument().setValue(""String_Node_Str"");
        cmd.createArgument().setFile(argfile);
        numargfiles++;
      }
    }
  }
  int numfiles=0;
  if (srcdir != null) {
    String[] dirs=srcdir.list();
    for (int i=0; i < dirs.length; i++) {
      File dir=project.resolveFile(dirs[i]);
      check(dir,dirs[i],true,location);
      String[] files=getDirectoryScanner(dir).getIncludedFiles();
      for (int j=0; j < files.length; j++) {
        File file=new File(dir,files[j]);
        if (FileUtil.hasSourceSuffix(file)) {
          cmd.createArgument().setFile(file);
          numfiles++;
        }
      }
    }
  }
  if ((null != ignoredOptions) && (ignoredOptions.size() > 0)) {
    log(""String_Node_Str"" + ignoredOptions,Project.MSG_WARN);
    if (ignoredOptions.contains(""String_Node_Str"")) {
      throw new BuildException(""String_Node_Str"");
    }
  }
  log(""String_Node_Str"" + numfiles + ""String_Node_Str""+ +numargfiles+ ""String_Node_Str""+ (null == destdir ? ""String_Node_Str"" : ""String_Node_Str"" + destdir.getPath()),Project.MSG_INFO);
  if (fork || (internalclasspath != null)) {
    log(""String_Node_Str"",Project.MSG_WARN);
  }
  int result=spoon();
  if (result != 0) {
    String msg=""String_Node_Str"" + result;
    if (failonerror) {
      reset();
      throw new BuildException(msg);
    }
 else {
      log(msg,Project.MSG_WARN);
    }
  }
  reset();
}",0.998056743101438
9099,"public void dontIgnore(Kind kind){
}","@Override public void dontIgnore(Kind kind){
}",0.8780487804878049
9100,"/** 
 * Compile using ajc per settings.
 * @exception BuildException if the compilation has problems or if there were compiler errors and failonerror is true.
 */
public void execute() throws BuildException {
  this.logger=new TaskLogger(this);
  if (executing) {
    throw new IllegalStateException(""String_Node_Str"");
  }
 else {
    executing=true;
  }
  setupOptions();
  verifyOptions();
  try {
    String[] args=makeCommand();
    if (logCommand) {
      log(""String_Node_Str"" + Arrays.asList(args));
    }
 else {
      logVerbose(""String_Node_Str"" + Arrays.asList(args));
    }
    if (!fork) {
      executeInSameVM(args);
    }
 else {
      executeInOtherVM(args);
    }
  }
 catch (  BuildException e) {
    throw e;
  }
catch (  Throwable x) {
    this.logger.error(Main.renderExceptionForUser(x));
    throw new BuildException(""String_Node_Str"" + LangUtil.unqualifiedClassName(x) + ""String_Node_Str"");
  }
 finally {
    executing=false;
    if (null != tmpOutjar) {
      tmpOutjar.delete();
    }
  }
}","/** 
 * Compile using ajc per settings.
 * @exception BuildException if the compilation has problems or if there were compiler errors and failonerror is true.
 */
@Override public void execute() throws BuildException {
  this.logger=new TaskLogger(this);
  if (executing) {
    throw new IllegalStateException(""String_Node_Str"");
  }
 else {
    executing=true;
  }
  setupOptions();
  verifyOptions();
  try {
    String[] args=makeCommand();
    if (logCommand) {
      log(""String_Node_Str"" + Arrays.asList(args));
    }
 else {
      logVerbose(""String_Node_Str"" + Arrays.asList(args));
    }
    if (!fork) {
      executeInSameVM(args);
    }
 else {
      executeInOtherVM(args);
    }
  }
 catch (  BuildException e) {
    throw e;
  }
catch (  Throwable x) {
    this.logger.error(Main.renderExceptionForUser(x));
    throw new BuildException(""String_Node_Str"" + LangUtil.unqualifiedClassName(x) + ""String_Node_Str"");
  }
 finally {
    executing=false;
    if (null != tmpOutjar) {
      tmpOutjar.delete();
    }
  }
}",0.9951171875
9101,"/** 
 * to use this same Task more than once (testing) 
 */
public void reset(){
  adapterArguments=null;
  adapterFiles=new ArrayList();
  argfiles=null;
  inxmlfiles=null;
  executing=false;
  aspectpath=null;
  bootclasspath=null;
  classpath=null;
  cmd=new GuardedCommand();
  copyInjars=false;
  copyInpath=false;
  destDir=DEFAULT_DESTDIR;
  executing=false;
  executingInOtherVM=false;
  extdirs=null;
  failonerror=true;
  forkclasspath=null;
  inIncrementalMode=false;
  inIncrementalFileMode=false;
  ignored=new ArrayList();
  injars=null;
  inpath=null;
  listFileArgs=false;
  maxMem=null;
  messageHolder=null;
  outjar=null;
  sourceRootCopyFilter=null;
  inpathDirCopyFilter=null;
  sourceRoots=null;
  srcdir=null;
  tmpOutjar=null;
  verbose=false;
  timers=false;
  xweaveDir=null;
  xdoneSignal=null;
  logCommand=false;
  javaCmd=new CommandlineJava();
}","/** 
 * to use this same Task more than once (testing) 
 */
public void reset(){
  adapterArguments=null;
  adapterFiles=new ArrayList();
  compilerArgs=null;
  argfiles=null;
  inxmlfiles=null;
  executing=false;
  aspectpath=null;
  bootclasspath=null;
  classpath=null;
  cmd=new GuardedCommand();
  copyInjars=false;
  copyInpath=false;
  destDir=DEFAULT_DESTDIR;
  executing=false;
  executingInOtherVM=false;
  extdirs=null;
  failonerror=true;
  forkclasspath=null;
  inIncrementalMode=false;
  inIncrementalFileMode=false;
  ignored=new ArrayList();
  injars=null;
  inpath=null;
  listFileArgs=false;
  maxMem=null;
  messageHolder=null;
  outjar=null;
  sourceRootCopyFilter=null;
  inpathDirCopyFilter=null;
  sourceRoots=null;
  srcdir=null;
  tmpOutjar=null;
  verbose=false;
  timers=false;
  xweaveDir=null;
  xdoneSignal=null;
  logCommand=false;
  javaCmd=new CommandlineJava();
}",0.988155668358714
9102,"/** 
 * Add to list any path or plural arguments.
 */
protected void addListArgs(List list) throws BuildException {
  addFlaggedPath(""String_Node_Str"",classpath,list);
  addFlaggedPath(""String_Node_Str"",bootclasspath,list);
  addFlaggedPath(""String_Node_Str"",extdirs,list);
  addFlaggedPath(""String_Node_Str"",aspectpath,list);
  addFlaggedPath(""String_Node_Str"",injars,list);
  addFlaggedPath(""String_Node_Str"",inpath,list);
  addFlaggedPath(""String_Node_Str"",sourceRoots,list);
  if (argfiles != null) {
    String[] files=argfiles.list();
    for (int i=0; i < files.length; i++) {
      File argfile=project.resolveFile(files[i]);
      if (check(argfile,files[i],false,location)) {
        list.add(""String_Node_Str"");
        list.add(argfile.getAbsolutePath());
      }
    }
  }
  if (inxmlfiles != null) {
    String[] files=inxmlfiles.list();
    for (int i=0; i < files.length; i++) {
      File inxmlfile=project.resolveFile(files[i]);
      if (check(inxmlfile,files[i],false,location)) {
        list.add(""String_Node_Str"");
        list.add(inxmlfile.getAbsolutePath());
      }
    }
  }
  if (srcdir != null) {
    String[] dirs=srcdir.list();
    for (int i=0; i < dirs.length; i++) {
      File dir=project.resolveFile(dirs[i]);
      check(dir,dirs[i],true,location);
      String[] files=getDirectoryScanner(dir).getIncludedFiles();
      for (int j=0; j < files.length; j++) {
        File file=new File(dir,files[j]);
        if (FileUtil.hasSourceSuffix(file)) {
          if (!list.contains(file.getAbsolutePath())) {
            list.add(file.getAbsolutePath());
          }
        }
      }
    }
  }
  if (0 < adapterFiles.size()) {
    for (Iterator iter=adapterFiles.iterator(); iter.hasNext(); ) {
      File file=(File)iter.next();
      if (file.canRead() && FileUtil.hasSourceSuffix(file)) {
        list.add(file.getAbsolutePath());
      }
 else {
        this.logger.warning(""String_Node_Str"" + file);
      }
    }
  }
}","/** 
 * Add to list any path or plural arguments.
 */
protected void addListArgs(List<String> list) throws BuildException {
  addFlaggedPath(""String_Node_Str"",classpath,list);
  addFlaggedPath(""String_Node_Str"",bootclasspath,list);
  addFlaggedPath(""String_Node_Str"",extdirs,list);
  addFlaggedPath(""String_Node_Str"",aspectpath,list);
  addFlaggedPath(""String_Node_Str"",injars,list);
  addFlaggedPath(""String_Node_Str"",inpath,list);
  addFlaggedPath(""String_Node_Str"",sourceRoots,list);
  if (this.compilerArgs != null) {
    for (    CompilerArg compilerArg : compilerArgs) {
      list.add(compilerArg.toString());
    }
  }
  if (argfiles != null) {
    String[] files=argfiles.list();
    for (int i=0; i < files.length; i++) {
      File argfile=project.resolveFile(files[i]);
      if (check(argfile,files[i],false,location)) {
        list.add(""String_Node_Str"");
        list.add(argfile.getAbsolutePath());
      }
    }
  }
  if (inxmlfiles != null) {
    String[] files=inxmlfiles.list();
    for (int i=0; i < files.length; i++) {
      File inxmlfile=project.resolveFile(files[i]);
      if (check(inxmlfile,files[i],false,location)) {
        list.add(""String_Node_Str"");
        list.add(inxmlfile.getAbsolutePath());
      }
    }
  }
  if (srcdir != null) {
    String[] dirs=srcdir.list();
    for (int i=0; i < dirs.length; i++) {
      File dir=project.resolveFile(dirs[i]);
      check(dir,dirs[i],true,location);
      String[] files=getDirectoryScanner(dir).getIncludedFiles();
      for (int j=0; j < files.length; j++) {
        File file=new File(dir,files[j]);
        if (FileUtil.hasSourceSuffix(file)) {
          if (!list.contains(file.getAbsolutePath())) {
            list.add(file.getAbsolutePath());
          }
        }
      }
    }
  }
  if (0 < adapterFiles.size()) {
    for (Iterator iter=adapterFiles.iterator(); iter.hasNext(); ) {
      File file=(File)iter.next();
      if (file.canRead() && FileUtil.hasSourceSuffix(file)) {
        list.add(file.getAbsolutePath());
      }
 else {
        this.logger.warning(""String_Node_Str"" + file);
      }
    }
  }
}",0.9635826771653544
9103,"/** 
 * @return null if path null or empty, String rendition otherwise 
 */
protected static void addFlaggedPath(String flag,Path path,List list){
  if (!LangUtil.isEmpty(flag) && ((null != path) && (0 < path.size()))) {
    list.add(flag);
    list.add(path.toString());
  }
}","/** 
 * @return null if path null or empty, String rendition otherwise 
 */
protected static void addFlaggedPath(String flag,Path path,List<String> list){
  if (!LangUtil.isEmpty(flag) && ((null != path) && (0 < path.size()))) {
    list.add(flag);
    list.add(path.toString());
  }
}",0.9857651245551602
9104,"public String toString(){
  return ""String_Node_Str"";
}","@Override public String toString(){
  return value;
}",0.7222222222222222
9105,"public void run(){
  doCompletionTasks();
}","@Override public void run(){
  doCompletionTasks();
}",0.8958333333333334
9106,"/** 
 * Run the compile in the same VM by loading the compiler (Main), setting up any message holders, doing the compile, and converting abort/failure and error messages to BuildException, as appropriate.
 * @throws BuildException if abort or failure messages or if errors and failonerror.
 */
protected void executeInSameVM(String[] args){
  if (null != maxMem) {
    log(""String_Node_Str"" + maxMem,Project.MSG_WARN);
  }
  IMessageHolder holder=messageHolder;
  int numPreviousErrors;
  if (null == holder) {
    MessageHandler mhandler=new MessageHandler(true);
    final IMessageHandler delegate;
    delegate=new AntMessageHandler(this.logger,this.verbose,false);
    mhandler.setInterceptor(delegate);
    holder=mhandler;
    numPreviousErrors=0;
  }
 else {
    numPreviousErrors=holder.numMessages(IMessage.ERROR,true);
  }
{
    Main newmain=new Main();
    newmain.setHolder(holder);
    newmain.setCompletionRunner(new Runnable(){
      public void run(){
        doCompletionTasks();
      }
    }
);
    if (null != main) {
      MessageUtil.fail(holder,""String_Node_Str"");
      return;
    }
    main=newmain;
  }
  main.runMain(args,false);
  if (failonerror) {
    int errs=holder.numMessages(IMessage.ERROR,false);
    errs-=numPreviousErrors;
    if (0 < errs) {
      String m=errs + ""String_Node_Str"";
      MessageUtil.print(System.err,holder,""String_Node_Str"",MessageUtil.MESSAGE_ALL,MessageUtil.PICK_ERROR,true);
      throw new BuildException(m);
    }
  }
{
    IMessage[] fails=holder.getMessages(IMessage.FAIL,true);
    if (!LangUtil.isEmpty(fails)) {
      StringBuffer sb=new StringBuffer();
      String prefix=""String_Node_Str"";
      int numThrown=0;
      for (int i=0; i < fails.length; i++) {
        String message=fails[i].getMessage();
        if (LangUtil.isEmpty(message)) {
          message=""String_Node_Str"";
        }
 else         if (-1 != message.indexOf(USAGE_SUBSTRING)) {
          continue;
        }
        Throwable t=fails[i].getThrown();
        if (null != t) {
          numThrown++;
          sb.append(prefix);
          sb.append(LangUtil.unqualifiedClassName(t.getClass()));
          String thrownMessage=t.getMessage();
          if (!LangUtil.isEmpty(thrownMessage)) {
            sb.append(""String_Node_Str"" + thrownMessage + ""String_Node_Str"");
          }
        }
        sb.append(""String_Node_Str"" + message + ""String_Node_Str"");
        prefix=""String_Node_Str"";
      }
      if (0 < sb.length()) {
        sb.append(""String_Node_Str"" + numThrown + ""String_Node_Str"");
        throw new BuildException(sb.toString());
      }
    }
  }
}","/** 
 * Run the compile in the same VM by loading the compiler (Main), setting up any message holders, doing the compile, and converting abort/failure and error messages to BuildException, as appropriate.
 * @throws BuildException if abort or failure messages or if errors and failonerror.
 */
protected void executeInSameVM(String[] args){
  if (null != maxMem) {
    log(""String_Node_Str"" + maxMem,Project.MSG_WARN);
  }
  IMessageHolder holder=messageHolder;
  int numPreviousErrors;
  if (null == holder) {
    MessageHandler mhandler=new MessageHandler(true);
    final IMessageHandler delegate;
    delegate=new AntMessageHandler(this.logger,this.verbose,false);
    mhandler.setInterceptor(delegate);
    holder=mhandler;
    numPreviousErrors=0;
  }
 else {
    numPreviousErrors=holder.numMessages(IMessage.ERROR,true);
  }
{
    Main newmain=new Main();
    newmain.setHolder(holder);
    newmain.setCompletionRunner(new Runnable(){
      @Override public void run(){
        doCompletionTasks();
      }
    }
);
    if (null != main) {
      MessageUtil.fail(holder,""String_Node_Str"");
      return;
    }
    main=newmain;
  }
  main.runMain(args,false);
  if (failonerror) {
    int errs=holder.numMessages(IMessage.ERROR,false);
    errs-=numPreviousErrors;
    if (0 < errs) {
      String m=errs + ""String_Node_Str"";
      MessageUtil.print(System.err,holder,""String_Node_Str"",MessageUtil.MESSAGE_ALL,MessageUtil.PICK_ERROR,true);
      throw new BuildException(m);
    }
  }
{
    IMessage[] fails=holder.getMessages(IMessage.FAIL,true);
    if (!LangUtil.isEmpty(fails)) {
      StringBuffer sb=new StringBuffer();
      String prefix=""String_Node_Str"";
      int numThrown=0;
      for (int i=0; i < fails.length; i++) {
        String message=fails[i].getMessage();
        if (LangUtil.isEmpty(message)) {
          message=""String_Node_Str"";
        }
 else         if (-1 != message.indexOf(USAGE_SUBSTRING)) {
          continue;
        }
        Throwable t=fails[i].getThrown();
        if (null != t) {
          numThrown++;
          sb.append(prefix);
          sb.append(LangUtil.unqualifiedClassName(t.getClass()));
          String thrownMessage=t.getMessage();
          if (!LangUtil.isEmpty(thrownMessage)) {
            sb.append(""String_Node_Str"" + thrownMessage + ""String_Node_Str"");
          }
        }
        sb.append(""String_Node_Str"" + message + ""String_Node_Str"");
        prefix=""String_Node_Str"";
      }
      if (0 < sb.length()) {
        sb.append(""String_Node_Str"" + numThrown + ""String_Node_Str"");
        throw new BuildException(sb.toString());
      }
    }
  }
}",0.998090874379534
9107,"public void ignore(Kind kind){
}","@Override public void ignore(Kind kind){
}",0.8648648648648649
9108,"public boolean isIgnoring(Kind kind){
  return false;
}","@Override public boolean isIgnoring(Kind kind){
  return false;
}",0.9166666666666666
9109,"public boolean handleMessage(IMessage message) throws AbortException {
  Kind messageKind=message.getKind();
  String messageText=message.toString();
  if (messageKind == IMessage.ABORT) {
    this.logger.error(messageText);
  }
 else   if (messageKind == IMessage.DEBUG) {
    this.logger.debug(messageText);
  }
 else   if (messageKind == IMessage.ERROR) {
    this.logger.error(messageText);
  }
 else   if (messageKind == IMessage.FAIL) {
    this.logger.error(messageText);
  }
 else   if (messageKind == IMessage.INFO) {
    if (this.taskLevelVerbose) {
      this.logger.info(messageText);
    }
 else {
      this.logger.verbose(messageText);
    }
  }
 else   if (messageKind == IMessage.WARNING) {
    this.logger.warning(messageText);
  }
 else   if (messageKind == IMessage.WEAVEINFO) {
    this.logger.info(messageText);
  }
 else   if (messageKind == IMessage.TASKTAG) {
  }
 else {
    throw new BuildException(""String_Node_Str"" + messageKind.toString());
  }
  return handledMessage;
}","@Override public boolean handleMessage(IMessage message) throws AbortException {
  Kind messageKind=message.getKind();
  String messageText=message.toString();
  if (messageKind == IMessage.ABORT) {
    this.logger.error(messageText);
  }
 else   if (messageKind == IMessage.DEBUG) {
    this.logger.debug(messageText);
  }
 else   if (messageKind == IMessage.ERROR) {
    this.logger.error(messageText);
  }
 else   if (messageKind == IMessage.FAIL) {
    this.logger.error(messageText);
  }
 else   if (messageKind == IMessage.INFO) {
    if (this.taskLevelVerbose) {
      this.logger.info(messageText);
    }
 else {
      this.logger.verbose(messageText);
    }
  }
 else   if (messageKind == IMessage.WARNING) {
    this.logger.warning(messageText);
  }
 else   if (messageKind == IMessage.WEAVEINFO) {
    this.logger.info(messageText);
  }
 else   if (messageKind == IMessage.TASKTAG) {
  }
 else {
    throw new BuildException(""String_Node_Str"" + messageKind.toString());
  }
  return handledMessage;
}",0.9950298210735586
9110,"public String[] editCommand(String[] command){
  int len=command.length + prefix.length + suffix.length;
  String[] result=new String[len];
  System.arraycopy(result,0,prefix,0,prefix.length);
  System.arraycopy(result,prefix.length,command,0,command.length);
  System.arraycopy(result,prefix.length + command.length,suffix,0,suffix.length);
  return result;
}","@Override public String[] editCommand(String[] command){
  int len=command.length + prefix.length + suffix.length;
  String[] result=new String[len];
  System.arraycopy(result,0,prefix,0,prefix.length);
  System.arraycopy(result,prefix.length,command,0,command.length);
  System.arraycopy(result,prefix.length + command.length,suffix,0,suffix.length);
  return result;
}",0.9863013698630136
9111,"public void targetStarted(BuildEvent event){
}","@Override public void targetStarted(BuildEvent event){
}",0.9019607843137256
9112,"public void buildFinished(BuildEvent event){
}","@Override public void buildFinished(BuildEvent event){
}",0.9019607843137256
9113,"public void messageLogged(BuildEvent event){
  if (priority == event.getPriority()) {
    results.add(event.getMessage());
  }
}","@Override public void messageLogged(BuildEvent event){
  if (priority == event.getPriority()) {
    results.add(event.getMessage());
  }
}",0.962406015037594
9114,"public void buildStarted(BuildEvent event){
}","@Override public void buildStarted(BuildEvent event){
}",0.9
9115,"public boolean accept(File file){
  return ((null != file) && file.isFile() && file.canWrite()&& file.getPath().endsWith(""String_Node_Str""));
}","@Override public boolean accept(File file){
  return ((null != file) && file.isFile() && file.canWrite()&& file.getPath().endsWith(""String_Node_Str""));
}",0.9662162162162162
9116,"public void taskStarted(BuildEvent event){
}","@Override public void taskStarted(BuildEvent event){
}",0.8979591836734694
9117,"public void targetFinished(BuildEvent event){
}","@Override public void targetFinished(BuildEvent event){
}",0.903846153846154
9118,"public void taskFinished(BuildEvent event){
}","@Override public void taskFinished(BuildEvent event){
}",0.9
9119,"public boolean handleMessage(IMessage message){
  IMessage.Kind kind=message.getKind();
  if (IMessage.ERROR.isSameOrLessThan(kind)) {
    String m=kind.toString();
    AjcTaskTest.collectMessage(m.substring(0,1));
  }
  return true;
}","@Override public boolean handleMessage(IMessage message){
  IMessage.Kind kind=message.getKind();
  if (IMessage.ERROR.isSameOrLessThan(kind)) {
    String m=kind.toString();
    AjcTaskTest.collectMessage(m.substring(0,1));
  }
  return true;
}",0.9791666666666666
9120,"public void tearDown(){
  deleteTempDir();
  MESSAGES.setLength(0);
}","@Override public void tearDown(){
  deleteTempDir();
  MESSAGES.setLength(0);
}",0.9324324324324323
9121,"/** 
 * Resolve to a ReferenceType - simple, raw, parameterized, or generic. Raw, parameterized, and generic versions of a type share a delegate.
 */
private final ResolvedType resolveToReferenceType(UnresolvedType ty,boolean allowMissing){
  if (ty.isParameterizedType()) {
    ResolvedType rt=resolveGenericTypeFor(ty,allowMissing);
    if (rt.isMissing()) {
      return rt;
    }
    ReferenceType genericType=(ReferenceType)rt;
    ReferenceType parameterizedType=TypeFactory.createParameterizedType(genericType,ty.typeParameters,this);
    return parameterizedType;
  }
 else   if (ty.isGenericType()) {
    ResolvedType rt=resolveGenericTypeFor(ty,false);
    ReferenceType genericType=(ReferenceType)rt;
    return genericType;
  }
 else   if (ty.isGenericWildcard()) {
    return resolveGenericWildcardFor((WildcardedUnresolvedType)ty);
  }
 else {
    String erasedSignature=ty.getErasureSignature();
    ReferenceType simpleOrRawType=new ReferenceType(erasedSignature,this);
    if (ty.needsModifiableDelegate()) {
      simpleOrRawType.setNeedsModifiableDelegate(true);
    }
    ReferenceTypeDelegate delegate=resolveDelegate(simpleOrRawType);
    if (delegate == null) {
      return new MissingResolvedTypeWithKnownSignature(ty.getSignature(),erasedSignature,this);
    }
    if (delegate.isGeneric() && behaveInJava5Way) {
      simpleOrRawType.typeKind=TypeKind.RAW;
      if (simpleOrRawType.hasNewInterfaces()) {
        throw new IllegalStateException(""String_Node_Str"" + simpleOrRawType.getName());
      }
      ReferenceType genericType=makeGenericTypeFrom(delegate,simpleOrRawType);
      simpleOrRawType.setDelegate(delegate);
      genericType.setDelegate(delegate);
      simpleOrRawType.setGenericType(genericType);
      return simpleOrRawType;
    }
 else {
      simpleOrRawType.setDelegate(delegate);
      return simpleOrRawType;
    }
  }
}","/** 
 * Resolve to a ReferenceType - simple, raw, parameterized, or generic. Raw, parameterized, and generic versions of a type share a delegate.
 */
private final ResolvedType resolveToReferenceType(UnresolvedType ty,boolean allowMissing){
  if (ty.isParameterizedType()) {
    ResolvedType rt=resolveGenericTypeFor(ty,allowMissing);
    if (rt.isMissing()) {
      return rt;
    }
    ReferenceType genericType=(ReferenceType)rt;
    ReferenceType parameterizedType=TypeFactory.createParameterizedType(genericType,ty.typeParameters,this);
    return parameterizedType;
  }
 else   if (ty.isGenericType()) {
    ResolvedType rt=resolveGenericTypeFor(ty,false);
    ReferenceType genericType=(ReferenceType)rt;
    if (rt.isMissing()) {
      return rt;
    }
    return genericType;
  }
 else   if (ty.isGenericWildcard()) {
    return resolveGenericWildcardFor((WildcardedUnresolvedType)ty);
  }
 else {
    String erasedSignature=ty.getErasureSignature();
    ReferenceType simpleOrRawType=new ReferenceType(erasedSignature,this);
    if (ty.needsModifiableDelegate()) {
      simpleOrRawType.setNeedsModifiableDelegate(true);
    }
    ReferenceTypeDelegate delegate=resolveDelegate(simpleOrRawType);
    if (delegate == null) {
      return new MissingResolvedTypeWithKnownSignature(ty.getSignature(),erasedSignature,this);
    }
    if (delegate.isGeneric() && behaveInJava5Way) {
      simpleOrRawType.typeKind=TypeKind.RAW;
      if (simpleOrRawType.hasNewInterfaces()) {
        throw new IllegalStateException(""String_Node_Str"" + simpleOrRawType.getName());
      }
      ReferenceType genericType=makeGenericTypeFrom(delegate,simpleOrRawType);
      simpleOrRawType.setDelegate(delegate);
      genericType.setDelegate(delegate);
      simpleOrRawType.setGenericType(genericType);
      return simpleOrRawType;
    }
 else {
      simpleOrRawType.setDelegate(delegate);
      return simpleOrRawType;
    }
  }
}",0.9870950750592572
9122,Set getAnnotations(Member onMember);,"ResolvedType[] getAnnotations(Member onMember,boolean runtimeAnnotationsOnly);",0.5964912280701754
9123,"Object getAnnotationFromClass(ResolvedType annotationType,Class aClass);","Object getAnnotationFromClass(ResolvedType annotationType,Class<?> aClass);",0.979591836734694
9124,"@Override public boolean hasAnnotation(UnresolvedType ofType){
  unpackAnnotations();
  return super.hasAnnotation(ofType);
}","@Override public boolean hasAnnotation(UnresolvedType ofType){
  boolean areRuntimeRetentionAnnotationsSufficient=false;
  if (ofType instanceof ResolvedType) {
    areRuntimeRetentionAnnotationsSufficient=((ResolvedType)ofType).isAnnotationWithRuntimeRetention();
  }
  unpackAnnotations(areRuntimeRetentionAnnotationsSufficient);
  return super.hasAnnotation(ofType);
}",0.5040322580645161
9125,"private void unpackAnnotations(){
  if (annotationTypes == null && annotationFinder != null) {
    Set<?> s=annotationFinder.getAnnotations(reflectMember);
    if (s.size() == 0) {
      annotationTypes=ResolvedType.EMPTY_ARRAY;
    }
 else {
      annotationTypes=new ResolvedType[s.size()];
      int i=0;
      for (      Object o : s) {
        annotationTypes[i++]=(ResolvedType)o;
      }
    }
  }
}","private void unpackAnnotations(boolean areRuntimeRetentionAnnotationsSufficient){
  if (annotationFinder != null && (annotationTypes == null || (!areRuntimeRetentionAnnotationsSufficient && onlyRuntimeAnnotationsCached))) {
    annotationTypes=annotationFinder.getAnnotations(reflectMember,areRuntimeRetentionAnnotationsSufficient);
    onlyRuntimeAnnotationsCached=areRuntimeRetentionAnnotationsSufficient;
  }
}",0.336996336996337
9126,"@Override public boolean hasAnnotations(){
  unpackAnnotations();
  return super.hasAnnotations();
}","@Override public boolean hasAnnotations(){
  unpackAnnotations(false);
  return super.hasAnnotations();
}",0.975609756097561
9127,"@Override public ResolvedType[] getAnnotationTypes(){
  unpackAnnotations();
  return super.getAnnotationTypes();
}","@Override public ResolvedType[] getAnnotationTypes(){
  unpackAnnotations(false);
  return super.getAnnotationTypes();
}",0.9787234042553192
9128,"@Override public AnnotationAJ getAnnotationOfType(UnresolvedType ofType){
  unpackAnnotations();
  if (annotationFinder == null || annotationTypes == null) {
    return null;
  }
  for (  ResolvedType type : annotationTypes) {
    if (type.getSignature().equals(ofType.getSignature())) {
      return annotationFinder.getAnnotationOfType(ofType,reflectMember);
    }
  }
  return null;
}","@Override public AnnotationAJ getAnnotationOfType(UnresolvedType ofType){
  unpackAnnotations(false);
  if (annotationFinder == null || annotationTypes == null) {
    return null;
  }
  for (  ResolvedType type : annotationTypes) {
    if (type.getSignature().equals(ofType.getSignature())) {
      return annotationFinder.getAnnotationOfType(ofType,reflectMember);
    }
  }
  return null;
}",0.993581514762516
9129,"/** 
 * @param kind
 * @param declaringType
 * @param modifiers
 * @param name
 * @param signature
 */
public ReflectionBasedResolvedMemberImpl(MemberKind kind,UnresolvedType declaringType,int modifiers,String name,String signature,Member reflectMember){
  super(kind,declaringType,modifiers,name,signature);
  this.reflectMember=reflectMember;
}","public ReflectionBasedResolvedMemberImpl(MemberKind kind,UnresolvedType declaringType,int modifiers,String name,String signature,Member reflectMember){
  super(kind,declaringType,modifiers,name,signature);
  this.reflectMember=reflectMember;
}",0.8251273344651953
9130,"public static ResolvedType resolve(World world,Class aClass){
  String className=aClass.getName();
  if (aClass.isArray()) {
    return world.resolve(UnresolvedType.forSignature(className.replace('.','/')));
  }
 else {
    return world.resolve(className);
  }
}","public static ResolvedType resolve(World world,Class<?> aClass){
  String className=aClass.getName();
  if (aClass.isArray()) {
    return world.resolve(UnresolvedType.forSignature(className.replace('.','/')));
  }
 else {
    return world.resolve(className);
  }
}",0.9943074003795066
9131,"public static AnnotationFinder makeAnnotationFinderIfAny(ClassLoader loader,World world){
  AnnotationFinder annotationFinder=null;
  try {
    if (LangUtil.is15VMOrGreater()) {
      Class java15AnnotationFinder=Class.forName(""String_Node_Str"");
      annotationFinder=(AnnotationFinder)java15AnnotationFinder.newInstance();
      annotationFinder.setClassLoader(loader);
      annotationFinder.setWorld(world);
    }
  }
 catch (  ClassNotFoundException ex) {
  }
catch (  IllegalAccessException ex) {
    throw new BCException(""String_Node_Str"",ex);
  }
catch (  InstantiationException ex) {
    throw new BCException(""String_Node_Str"",ex);
  }
  return annotationFinder;
}","public static AnnotationFinder makeAnnotationFinderIfAny(ClassLoader loader,World world){
  AnnotationFinder annotationFinder=null;
  try {
    if (LangUtil.is15VMOrGreater()) {
      Class<?> java15AnnotationFinder=Class.forName(""String_Node_Str"");
      annotationFinder=(AnnotationFinder)java15AnnotationFinder.newInstance();
      annotationFinder.setClassLoader(loader);
      annotationFinder.setWorld(world);
    }
  }
 catch (  ClassNotFoundException ex) {
  }
catch (  IllegalAccessException ex) {
    throw new BCException(""String_Node_Str"",ex);
  }
catch (  InstantiationException ex) {
    throw new BCException(""String_Node_Str"",ex);
  }
  return annotationFinder;
}",0.9977859778597786
9132,"public MethodBinding[] getMethods(SourceTypeBinding sourceTypeBinding,char[] selector){
  MethodBinding[] orig=sourceTypeBinding.getMethodsBase(selector);
  if (interTypeMethods.isEmpty()) {
    return orig;
  }
  List ret=new ArrayList(Arrays.asList(orig));
  for (int i=0, len=interTypeMethods.size(); i < len; i++) {
    MethodBinding method=(MethodBinding)interTypeMethods.get(i);
    if (CharOperation.equals(selector,method.selector)) {
      ret.add(method);
    }
  }
  if (ret.isEmpty()) {
    return Binding.NO_METHODS;
  }
  return (MethodBinding[])ret.toArray(new MethodBinding[ret.size()]);
}","public MethodBinding[] getMethods(SourceTypeBinding sourceTypeBinding,char[] selector){
  MethodBinding[] orig=sourceTypeBinding.getMethodsBase(selector);
  if (interTypeMethods.isEmpty()) {
    return orig;
  }
  Set<MethodBinding> ret=new HashSet<MethodBinding>(Arrays.asList(orig));
  for (int i=0, len=interTypeMethods.size(); i < len; i++) {
    MethodBinding method=(MethodBinding)interTypeMethods.get(i);
    if (CharOperation.equals(selector,method.selector)) {
      ret.add(method);
    }
  }
  if (ret.isEmpty()) {
    return Binding.NO_METHODS;
  }
  return (MethodBinding[])ret.toArray(new MethodBinding[ret.size()]);
}",0.9571544058205336
9133,"public void weaveCflowEntry(final BcelAdvice munger,final Member cflowField){
  final boolean isPer=munger.getKind() == AdviceKind.PerCflowBelowEntry || munger.getKind() == AdviceKind.PerCflowEntry;
  final Type objectArrayType=new ArrayType(Type.OBJECT,1);
  final InstructionFactory fact=getFactory();
  final BcelVar testResult=genTempVar(UnresolvedType.BOOLEAN);
  InstructionList entryInstructions=new InstructionList();
{
    InstructionList entrySuccessInstructions=new InstructionList();
    if (munger.hasDynamicTests()) {
      entryInstructions.append(Utility.createConstant(fact,0));
      testResult.appendStore(entryInstructions,fact);
      entrySuccessInstructions.append(Utility.createConstant(fact,1));
      testResult.appendStore(entrySuccessInstructions,fact);
    }
    if (isPer) {
      entrySuccessInstructions.append(fact.createInvoke(munger.getConcreteAspect().getName(),NameMangler.PERCFLOW_PUSH_METHOD,Type.VOID,new Type[]{},Constants.INVOKESTATIC));
    }
 else {
      BcelVar[] cflowStateVars=munger.getExposedStateAsBcelVars(false);
      if (cflowStateVars.length == 0) {
        if (!cflowField.getType().getName().endsWith(""String_Node_Str"")) {
          throw new RuntimeException(""String_Node_Str"");
        }
        entrySuccessInstructions.append(Utility.createGet(fact,cflowField));
        entrySuccessInstructions.append(fact.createInvoke(NameMangler.CFLOW_COUNTER_TYPE,""String_Node_Str"",Type.VOID,new Type[]{},Constants.INVOKEVIRTUAL));
      }
 else {
        BcelVar arrayVar=genTempVar(UnresolvedType.OBJECTARRAY);
        int alen=cflowStateVars.length;
        entrySuccessInstructions.append(Utility.createConstant(fact,alen));
        entrySuccessInstructions.append(fact.createNewArray(Type.OBJECT,(short)1));
        arrayVar.appendStore(entrySuccessInstructions,fact);
        for (int i=0; i < alen; i++) {
          arrayVar.appendConvertableArrayStore(entrySuccessInstructions,fact,i,cflowStateVars[i]);
        }
        entrySuccessInstructions.append(Utility.createGet(fact,cflowField));
        arrayVar.appendLoad(entrySuccessInstructions,fact);
        entrySuccessInstructions.append(fact.createInvoke(NameMangler.CFLOW_STACK_TYPE,""String_Node_Str"",Type.VOID,new Type[]{objectArrayType},Constants.INVOKEVIRTUAL));
      }
    }
    InstructionList testInstructions=munger.getTestInstructions(this,entrySuccessInstructions.getStart(),range.getRealStart(),entrySuccessInstructions.getStart());
    entryInstructions.append(testInstructions);
    entryInstructions.append(entrySuccessInstructions);
  }
  weaveAfter(new BcelAdvice(null,null,null,0,0,0,null,munger.getConcreteAspect()){
    @Override public InstructionList getAdviceInstructions(    BcelShadow s,    BcelVar extraArgVar,    InstructionHandle ifNoAdvice){
      InstructionList exitInstructions=new InstructionList();
      if (munger.hasDynamicTests()) {
        testResult.appendLoad(exitInstructions,fact);
        exitInstructions.append(InstructionFactory.createBranchInstruction(Constants.IFEQ,ifNoAdvice));
      }
      exitInstructions.append(Utility.createGet(fact,cflowField));
      if (munger.getKind() != AdviceKind.PerCflowEntry && munger.getKind() != AdviceKind.PerCflowBelowEntry && munger.getExposedStateAsBcelVars(false).length == 0) {
        exitInstructions.append(fact.createInvoke(NameMangler.CFLOW_COUNTER_TYPE,""String_Node_Str"",Type.VOID,new Type[]{},Constants.INVOKEVIRTUAL));
      }
 else {
        exitInstructions.append(fact.createInvoke(NameMangler.CFLOW_STACK_TYPE,""String_Node_Str"",Type.VOID,new Type[]{},Constants.INVOKEVIRTUAL));
      }
      return exitInstructions;
    }
  }
);
  range.insert(entryInstructions,Range.InsideBefore);
}","public void weaveCflowEntry(final BcelAdvice munger,final Member cflowField){
  final boolean isPer=munger.getKind() == AdviceKind.PerCflowBelowEntry || munger.getKind() == AdviceKind.PerCflowEntry;
  if (!isPer && getKind() == PreInitialization) {
    return;
  }
  final Type objectArrayType=new ArrayType(Type.OBJECT,1);
  final InstructionFactory fact=getFactory();
  final BcelVar testResult=genTempVar(UnresolvedType.BOOLEAN);
  InstructionList entryInstructions=new InstructionList();
{
    InstructionList entrySuccessInstructions=new InstructionList();
    if (munger.hasDynamicTests()) {
      entryInstructions.append(Utility.createConstant(fact,0));
      testResult.appendStore(entryInstructions,fact);
      entrySuccessInstructions.append(Utility.createConstant(fact,1));
      testResult.appendStore(entrySuccessInstructions,fact);
    }
    if (isPer) {
      entrySuccessInstructions.append(fact.createInvoke(munger.getConcreteAspect().getName(),NameMangler.PERCFLOW_PUSH_METHOD,Type.VOID,new Type[]{},Constants.INVOKESTATIC));
    }
 else {
      BcelVar[] cflowStateVars=munger.getExposedStateAsBcelVars(false);
      if (cflowStateVars.length == 0) {
        if (!cflowField.getType().getName().endsWith(""String_Node_Str"")) {
          throw new RuntimeException(""String_Node_Str"");
        }
        entrySuccessInstructions.append(Utility.createGet(fact,cflowField));
        entrySuccessInstructions.append(fact.createInvoke(NameMangler.CFLOW_COUNTER_TYPE,""String_Node_Str"",Type.VOID,new Type[]{},Constants.INVOKEVIRTUAL));
      }
 else {
        BcelVar arrayVar=genTempVar(UnresolvedType.OBJECTARRAY);
        int alen=cflowStateVars.length;
        entrySuccessInstructions.append(Utility.createConstant(fact,alen));
        entrySuccessInstructions.append(fact.createNewArray(Type.OBJECT,(short)1));
        arrayVar.appendStore(entrySuccessInstructions,fact);
        for (int i=0; i < alen; i++) {
          arrayVar.appendConvertableArrayStore(entrySuccessInstructions,fact,i,cflowStateVars[i]);
        }
        entrySuccessInstructions.append(Utility.createGet(fact,cflowField));
        arrayVar.appendLoad(entrySuccessInstructions,fact);
        entrySuccessInstructions.append(fact.createInvoke(NameMangler.CFLOW_STACK_TYPE,""String_Node_Str"",Type.VOID,new Type[]{objectArrayType},Constants.INVOKEVIRTUAL));
      }
    }
    InstructionList testInstructions=munger.getTestInstructions(this,entrySuccessInstructions.getStart(),range.getRealStart(),entrySuccessInstructions.getStart());
    entryInstructions.append(testInstructions);
    entryInstructions.append(entrySuccessInstructions);
  }
  BcelAdvice exitAdvice=new BcelAdvice(null,null,null,0,0,0,null,munger.getConcreteAspect()){
    @Override public InstructionList getAdviceInstructions(    BcelShadow s,    BcelVar extraArgVar,    InstructionHandle ifNoAdvice){
      InstructionList exitInstructions=new InstructionList();
      if (munger.hasDynamicTests()) {
        testResult.appendLoad(exitInstructions,fact);
        exitInstructions.append(InstructionFactory.createBranchInstruction(Constants.IFEQ,ifNoAdvice));
      }
      exitInstructions.append(Utility.createGet(fact,cflowField));
      if (munger.getKind() != AdviceKind.PerCflowEntry && munger.getKind() != AdviceKind.PerCflowBelowEntry && munger.getExposedStateAsBcelVars(false).length == 0) {
        exitInstructions.append(fact.createInvoke(NameMangler.CFLOW_COUNTER_TYPE,""String_Node_Str"",Type.VOID,new Type[]{},Constants.INVOKEVIRTUAL));
      }
 else {
        exitInstructions.append(fact.createInvoke(NameMangler.CFLOW_STACK_TYPE,""String_Node_Str"",Type.VOID,new Type[]{},Constants.INVOKEVIRTUAL));
      }
      return exitInstructions;
    }
  }
;
  weaveAfter(exitAdvice);
  range.insert(entryInstructions,Range.InsideBefore);
}",0.9840085287846482
9134,"PerClause.Kind getPerClauseForTypeDeclaration(TypeDeclaration typeDeclaration){
  Annotation[] annotations=typeDeclaration.annotations;
  for (int i=0; i < annotations.length; i++) {
    Annotation annotation=annotations[i];
    if (annotation != null && annotation.resolvedType != null && CharOperation.equals(aspectSig,annotation.resolvedType.signature())) {
      if (annotation.memberValuePairs() == null || annotation.memberValuePairs().length == 0) {
        PerClause.Kind kind=lookupPerClauseKind(typeDeclaration.binding.superclass);
        if (kind == null) {
          return PerClause.SINGLETON;
        }
 else {
          return kind;
        }
      }
 else       if (annotation instanceof SingleMemberAnnotation) {
        SingleMemberAnnotation theAnnotation=(SingleMemberAnnotation)annotation;
        String clause=new String(((StringLiteral)theAnnotation.memberValue).source());
        return determinePerClause(typeDeclaration,clause);
      }
 else       if (annotation instanceof NormalAnnotation) {
        NormalAnnotation theAnnotation=(NormalAnnotation)annotation;
        if (theAnnotation.memberValuePairs == null || theAnnotation.memberValuePairs.length < 1) {
          return PerClause.SINGLETON;
        }
        String clause=new String(((StringLiteral)theAnnotation.memberValuePairs[0].value).source());
        return determinePerClause(typeDeclaration,clause);
      }
 else {
        eclipseWorld().showMessage(IMessage.ABORT,""String_Node_Str"",new EclipseSourceLocation(typeDeclaration.compilationResult,typeDeclaration.sourceStart,typeDeclaration.sourceEnd),null);
        return PerClause.SINGLETON;
      }
    }
  }
  return null;
}","PerClause.Kind getPerClauseForTypeDeclaration(TypeDeclaration typeDeclaration){
  Annotation[] annotations=typeDeclaration.annotations;
  if (annotations == null) {
    return null;
  }
  for (int i=0; i < annotations.length; i++) {
    Annotation annotation=annotations[i];
    if (annotation != null && annotation.resolvedType != null && CharOperation.equals(aspectSig,annotation.resolvedType.signature())) {
      if (annotation.memberValuePairs() == null || annotation.memberValuePairs().length == 0) {
        PerClause.Kind kind=lookupPerClauseKind(typeDeclaration.binding.superclass);
        if (kind == null) {
          return PerClause.SINGLETON;
        }
 else {
          return kind;
        }
      }
 else       if (annotation instanceof SingleMemberAnnotation) {
        SingleMemberAnnotation theAnnotation=(SingleMemberAnnotation)annotation;
        String clause=new String(((StringLiteral)theAnnotation.memberValue).source());
        return determinePerClause(typeDeclaration,clause);
      }
 else       if (annotation instanceof NormalAnnotation) {
        NormalAnnotation theAnnotation=(NormalAnnotation)annotation;
        if (theAnnotation.memberValuePairs == null || theAnnotation.memberValuePairs.length < 1) {
          return PerClause.SINGLETON;
        }
        String clause=new String(((StringLiteral)theAnnotation.memberValuePairs[0].value).source());
        return determinePerClause(typeDeclaration,clause);
      }
 else {
        eclipseWorld().showMessage(IMessage.ABORT,""String_Node_Str"",new EclipseSourceLocation(typeDeclaration.compilationResult,typeDeclaration.sourceStart,typeDeclaration.sourceEnd),null);
        return PerClause.SINGLETON;
      }
    }
  }
  return null;
}",0.9853027630805408
9135,"public static Test suite(){
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTest(AllTestsAspectJ182.suite());
  suite.addTest(AllTestsAspectJ181.suite());
  suite.addTest(AllTestsAspectJ180.suite());
  suite.addTest(AllTests17.suite());
  return suite;
}","public static Test suite(){
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTest(AllTestsAspectJ183.suite());
  suite.addTest(AllTestsAspectJ182.suite());
  suite.addTest(AllTestsAspectJ181.suite());
  suite.addTest(AllTestsAspectJ180.suite());
  suite.addTest(AllTests17.suite());
  return suite;
}",0.9228130360205832
9136,"/** 
 * Build the bytecode for the concrete aspect
 * @return concrete aspect bytecode
 */
public byte[] getBytes(){
  if (!isValid) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (bytes != null) {
    return bytes;
  }
  PerClause parentPerClause=(parent != null ? parent.getPerClause() : null);
  if (parentPerClause == null) {
    parentPerClause=new PerSingleton();
  }
  PerClause.Kind perclauseKind=PerClause.SINGLETON;
  String perclauseString=null;
  if (concreteAspect.perclause != null) {
    perclauseString=concreteAspect.perclause;
    if (perclauseString.startsWith(""String_Node_Str"")) {
      perclauseKind=PerClause.SINGLETON;
    }
 else     if (perclauseString.startsWith(""String_Node_Str"")) {
      perclauseKind=PerClause.PERCFLOW;
    }
 else     if (perclauseString.startsWith(""String_Node_Str"")) {
      perclauseKind=PerClause.PERTYPEWITHIN;
    }
 else     if (perclauseString.startsWith(""String_Node_Str"")) {
      perclauseKind=PerClause.PEROBJECT;
    }
 else     if (perclauseString.startsWith(""String_Node_Str"")) {
      perclauseKind=PerClause.PEROBJECT;
    }
 else     if (perclauseString.startsWith(""String_Node_Str"")) {
      perclauseKind=PerClause.PERCFLOW;
    }
  }
  String parentName=""String_Node_Str"";
  if (parent != null) {
    if (parent.isParameterizedType()) {
      parentName=parent.getGenericType().getName().replace('.','/');
    }
 else {
      parentName=parent.getName().replace('.','/');
    }
  }
  LazyClassGen cg=new LazyClassGen(concreteAspect.name.replace('.','/'),parentName,null,Modifier.PUBLIC + Constants.ACC_SUPER,EMPTY_STRINGS,world);
  if (parent != null && parent.isParameterizedType()) {
    cg.setSuperClass(parent);
  }
  if (perclauseString == null) {
    AnnotationGen ag=new AnnotationGen(new ObjectType(""String_Node_Str""),Collections.<NameValuePair>emptyList(),true,cg.getConstantPool());
    cg.addAnnotation(ag);
  }
 else {
    List<NameValuePair> elems=new ArrayList<NameValuePair>();
    elems.add(new NameValuePair(""String_Node_Str"",new SimpleElementValue(ElementValue.STRING,cg.getConstantPool(),perclauseString),cg.getConstantPool()));
    AnnotationGen ag=new AnnotationGen(new ObjectType(""String_Node_Str""),elems,true,cg.getConstantPool());
    cg.addAnnotation(ag);
  }
  if (concreteAspect.precedence != null) {
    SimpleElementValue svg=new SimpleElementValue(ElementValue.STRING,cg.getConstantPool(),concreteAspect.precedence);
    List<NameValuePair> elems=new ArrayList<NameValuePair>();
    elems.add(new NameValuePair(""String_Node_Str"",svg,cg.getConstantPool()));
    AnnotationGen agprec=new AnnotationGen(new ObjectType(""String_Node_Str""),elems,true,cg.getConstantPool());
    cg.addAnnotation(agprec);
  }
  LazyMethodGen init=new LazyMethodGen(Modifier.PUBLIC,Type.VOID,""String_Node_Str"",EMPTY_TYPES,EMPTY_STRINGS,cg);
  InstructionList cbody=init.getBody();
  cbody.append(InstructionConstants.ALOAD_0);
  cbody.append(cg.getFactory().createInvoke(parentName,""String_Node_Str"",Type.VOID,EMPTY_TYPES,Constants.INVOKESPECIAL));
  cbody.append(InstructionConstants.RETURN);
  cg.addMethodGen(init);
  for (Iterator<Definition.Pointcut> it=concreteAspect.pointcuts.iterator(); it.hasNext(); ) {
    Definition.Pointcut abstractPc=(Definition.Pointcut)it.next();
    LazyMethodGen mg=new LazyMethodGen(Modifier.PUBLIC,Type.VOID,abstractPc.name,EMPTY_TYPES,EMPTY_STRINGS,cg);
    SimpleElementValue svg=new SimpleElementValue(ElementValue.STRING,cg.getConstantPool(),abstractPc.expression);
    List<NameValuePair> elems=new ArrayList<NameValuePair>();
    elems.add(new NameValuePair(""String_Node_Str"",svg,cg.getConstantPool()));
    AnnotationGen mag=new AnnotationGen(new ObjectType(""String_Node_Str""),elems,true,cg.getConstantPool());
    AnnotationAJ max=new BcelAnnotation(mag,world);
    mg.addAnnotation(max);
    InstructionList body=mg.getBody();
    body.append(InstructionConstants.RETURN);
    cg.addMethodGen(mg);
  }
  if (concreteAspect.deows.size() > 0) {
    int counter=1;
    for (    Definition.DeclareErrorOrWarning deow : concreteAspect.deows) {
      FieldGen field=new FieldGen(Modifier.FINAL,ObjectType.STRING,""String_Node_Str"" + (counter++),cg.getConstantPool());
      SimpleElementValue svg=new SimpleElementValue(ElementValue.STRING,cg.getConstantPool(),deow.pointcut);
      List<NameValuePair> elems=new ArrayList<NameValuePair>();
      elems.add(new NameValuePair(""String_Node_Str"",svg,cg.getConstantPool()));
      AnnotationGen mag=new AnnotationGen(new ObjectType(""String_Node_Str"" + (deow.isError ? ""String_Node_Str"" : ""String_Node_Str"")),elems,true,cg.getConstantPool());
      field.addAnnotation(mag);
      field.setValue(deow.message);
      cg.addField(field,null);
    }
  }
  if (concreteAspect.pointcutsAndAdvice.size() > 0) {
    int adviceCounter=1;
    for (    PointcutAndAdvice paa : concreteAspect.pointcutsAndAdvice) {
      generateAdviceMethod(paa,adviceCounter,cg);
      adviceCounter++;
    }
  }
  if (concreteAspect.declareAnnotations.size() > 0) {
    int decCounter=1;
    for (    Definition.DeclareAnnotation da : concreteAspect.declareAnnotations) {
      generateDeclareAnnotation(da,decCounter++,cg);
    }
  }
  ReferenceType rt=new ReferenceType(ResolvedType.forName(concreteAspect.name).getSignature(),world);
  GeneratedReferenceTypeDelegate grtd=new GeneratedReferenceTypeDelegate(rt);
  grtd.setSuperclass(parent);
  rt.setDelegate(grtd);
  BcelPerClauseAspectAdder perClauseMunger=new BcelPerClauseAspectAdder(rt,perclauseKind);
  perClauseMunger.forceMunge(cg,false);
  JavaClass jc=cg.getJavaClass((BcelWorld)world);
  ((BcelWorld)world).addSourceObjectType(jc,true);
  bytes=jc.getBytes();
  return bytes;
}","/** 
 * Build the bytecode for the concrete aspect
 * @return concrete aspect bytecode
 */
public byte[] getBytes(){
  if (!isValid) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (bytes != null) {
    return bytes;
  }
  PerClause.Kind perclauseKind=PerClause.SINGLETON;
  PerClause parentPerClause=(parent != null ? parent.getPerClause() : null);
  if (parentPerClause != null) {
    perclauseKind=parentPerClause.getKind();
  }
  String perclauseString=null;
  if (concreteAspect.perclause != null) {
    perclauseString=concreteAspect.perclause;
    if (perclauseString.startsWith(""String_Node_Str"")) {
      perclauseKind=PerClause.SINGLETON;
    }
 else     if (perclauseString.startsWith(""String_Node_Str"")) {
      perclauseKind=PerClause.PERCFLOW;
    }
 else     if (perclauseString.startsWith(""String_Node_Str"")) {
      perclauseKind=PerClause.PERTYPEWITHIN;
    }
 else     if (perclauseString.startsWith(""String_Node_Str"")) {
      perclauseKind=PerClause.PEROBJECT;
    }
 else     if (perclauseString.startsWith(""String_Node_Str"")) {
      perclauseKind=PerClause.PEROBJECT;
    }
 else     if (perclauseString.startsWith(""String_Node_Str"")) {
      perclauseKind=PerClause.PERCFLOW;
    }
  }
  String parentName=""String_Node_Str"";
  if (parent != null) {
    if (parent.isParameterizedType()) {
      parentName=parent.getGenericType().getName().replace('.','/');
    }
 else {
      parentName=parent.getName().replace('.','/');
    }
  }
  LazyClassGen cg=new LazyClassGen(concreteAspect.name.replace('.','/'),parentName,null,Modifier.PUBLIC + Constants.ACC_SUPER,EMPTY_STRINGS,world);
  if (parent != null && parent.isParameterizedType()) {
    cg.setSuperClass(parent);
  }
  if (perclauseString == null) {
    AnnotationGen ag=new AnnotationGen(new ObjectType(""String_Node_Str""),Collections.<NameValuePair>emptyList(),true,cg.getConstantPool());
    cg.addAnnotation(ag);
  }
 else {
    List<NameValuePair> elems=new ArrayList<NameValuePair>();
    elems.add(new NameValuePair(""String_Node_Str"",new SimpleElementValue(ElementValue.STRING,cg.getConstantPool(),perclauseString),cg.getConstantPool()));
    AnnotationGen ag=new AnnotationGen(new ObjectType(""String_Node_Str""),elems,true,cg.getConstantPool());
    cg.addAnnotation(ag);
  }
  if (concreteAspect.precedence != null) {
    SimpleElementValue svg=new SimpleElementValue(ElementValue.STRING,cg.getConstantPool(),concreteAspect.precedence);
    List<NameValuePair> elems=new ArrayList<NameValuePair>();
    elems.add(new NameValuePair(""String_Node_Str"",svg,cg.getConstantPool()));
    AnnotationGen agprec=new AnnotationGen(new ObjectType(""String_Node_Str""),elems,true,cg.getConstantPool());
    cg.addAnnotation(agprec);
  }
  LazyMethodGen init=new LazyMethodGen(Modifier.PUBLIC,Type.VOID,""String_Node_Str"",EMPTY_TYPES,EMPTY_STRINGS,cg);
  InstructionList cbody=init.getBody();
  cbody.append(InstructionConstants.ALOAD_0);
  cbody.append(cg.getFactory().createInvoke(parentName,""String_Node_Str"",Type.VOID,EMPTY_TYPES,Constants.INVOKESPECIAL));
  cbody.append(InstructionConstants.RETURN);
  cg.addMethodGen(init);
  for (Iterator<Definition.Pointcut> it=concreteAspect.pointcuts.iterator(); it.hasNext(); ) {
    Definition.Pointcut abstractPc=(Definition.Pointcut)it.next();
    LazyMethodGen mg=new LazyMethodGen(Modifier.PUBLIC,Type.VOID,abstractPc.name,EMPTY_TYPES,EMPTY_STRINGS,cg);
    SimpleElementValue svg=new SimpleElementValue(ElementValue.STRING,cg.getConstantPool(),abstractPc.expression);
    List<NameValuePair> elems=new ArrayList<NameValuePair>();
    elems.add(new NameValuePair(""String_Node_Str"",svg,cg.getConstantPool()));
    AnnotationGen mag=new AnnotationGen(new ObjectType(""String_Node_Str""),elems,true,cg.getConstantPool());
    AnnotationAJ max=new BcelAnnotation(mag,world);
    mg.addAnnotation(max);
    InstructionList body=mg.getBody();
    body.append(InstructionConstants.RETURN);
    cg.addMethodGen(mg);
  }
  if (concreteAspect.deows.size() > 0) {
    int counter=1;
    for (    Definition.DeclareErrorOrWarning deow : concreteAspect.deows) {
      FieldGen field=new FieldGen(Modifier.FINAL,ObjectType.STRING,""String_Node_Str"" + (counter++),cg.getConstantPool());
      SimpleElementValue svg=new SimpleElementValue(ElementValue.STRING,cg.getConstantPool(),deow.pointcut);
      List<NameValuePair> elems=new ArrayList<NameValuePair>();
      elems.add(new NameValuePair(""String_Node_Str"",svg,cg.getConstantPool()));
      AnnotationGen mag=new AnnotationGen(new ObjectType(""String_Node_Str"" + (deow.isError ? ""String_Node_Str"" : ""String_Node_Str"")),elems,true,cg.getConstantPool());
      field.addAnnotation(mag);
      field.setValue(deow.message);
      cg.addField(field,null);
    }
  }
  if (concreteAspect.pointcutsAndAdvice.size() > 0) {
    int adviceCounter=1;
    for (    PointcutAndAdvice paa : concreteAspect.pointcutsAndAdvice) {
      generateAdviceMethod(paa,adviceCounter,cg);
      adviceCounter++;
    }
  }
  if (concreteAspect.declareAnnotations.size() > 0) {
    int decCounter=1;
    for (    Definition.DeclareAnnotation da : concreteAspect.declareAnnotations) {
      generateDeclareAnnotation(da,decCounter++,cg);
    }
  }
  ReferenceType rt=new ReferenceType(ResolvedType.forName(concreteAspect.name).getSignature(),world);
  GeneratedReferenceTypeDelegate grtd=new GeneratedReferenceTypeDelegate(rt);
  grtd.setSuperclass(parent);
  rt.setDelegate(grtd);
  BcelPerClauseAspectAdder perClauseMunger=new BcelPerClauseAspectAdder(rt,perclauseKind);
  perClauseMunger.forceMunge(cg,false);
  JavaClass jc=cg.getJavaClass((BcelWorld)world);
  ((BcelWorld)world).addSourceObjectType(jc,true);
  bytes=jc.getBytes();
  return bytes;
}",0.9725221666227724
9137,"public static Test suite(){
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTest(AllTestsAspectJ173.suite());
  suite.addTest(AllTestsAspectJ172.suite());
  suite.addTest(AllTestsAspectJ171.suite());
  suite.addTest(AllTestsAspectJ170.suite());
  suite.addTest(AllTests16.suite());
  suite.addTest(AllTests15.suite());
  return suite;
}","public static Test suite(){
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTest(AllTestsAspectJ174.suite());
  suite.addTest(AllTestsAspectJ173.suite());
  suite.addTest(AllTestsAspectJ172.suite());
  suite.addTest(AllTestsAspectJ171.suite());
  suite.addTest(AllTestsAspectJ170.suite());
  suite.addTest(AllTests16.suite());
  suite.addTest(AllTests15.suite());
  return suite;
}",0.9397590361445785
9138,"private void addPointcutsResolvingConflicts(List acc,List added,boolean isOverriding){
  for (Iterator i=added.iterator(); i.hasNext(); ) {
    ResolvedPointcutDefinition toAdd=(ResolvedPointcutDefinition)i.next();
    for (Iterator j=acc.iterator(); j.hasNext(); ) {
      ResolvedPointcutDefinition existing=(ResolvedPointcutDefinition)j.next();
      if (existing == toAdd) {
        continue;
      }
      if (!isVisible(existing.getModifiers(),existing.getDeclaringType().resolve(getWorld()),this)) {
        if (existing.isAbstract() && conflictingSignature(existing,toAdd)) {
          getWorld().showMessage(IMessage.ERROR,WeaverMessages.format(WeaverMessages.POINTCUT_NOT_VISIBLE,existing.getDeclaringType().getName() + ""String_Node_Str"" + existing.getName()+ ""String_Node_Str"",this.getName()),toAdd.getSourceLocation(),null);
          j.remove();
        }
        continue;
      }
      if (conflictingSignature(existing,toAdd)) {
        if (isOverriding) {
          checkLegalOverride(existing,toAdd);
          j.remove();
        }
 else {
          getWorld().showMessage(IMessage.ERROR,WeaverMessages.format(WeaverMessages.CONFLICTING_INHERITED_POINTCUTS,this.getName() + toAdd.getSignature()),existing.getSourceLocation(),toAdd.getSourceLocation());
          j.remove();
        }
      }
    }
    acc.add(toAdd);
  }
}","private void addPointcutsResolvingConflicts(List acc,List added,boolean isOverriding){
  for (Iterator i=added.iterator(); i.hasNext(); ) {
    ResolvedPointcutDefinition toAdd=(ResolvedPointcutDefinition)i.next();
    for (Iterator j=acc.iterator(); j.hasNext(); ) {
      ResolvedPointcutDefinition existing=(ResolvedPointcutDefinition)j.next();
      if (existing == toAdd) {
        continue;
      }
      ResolvedType pointcutDeclaringType=existing.getDeclaringType().resolve(getWorld());
      if (pointcutDeclaringType == null) {
        throw new BCException(""String_Node_Str"" + existing.toString());
      }
      if (!isVisible(existing.getModifiers(),pointcutDeclaringType,this)) {
        if (existing.isAbstract() && conflictingSignature(existing,toAdd)) {
          getWorld().showMessage(IMessage.ERROR,WeaverMessages.format(WeaverMessages.POINTCUT_NOT_VISIBLE,existing.getDeclaringType().getName() + ""String_Node_Str"" + existing.getName()+ ""String_Node_Str"",this.getName()),toAdd.getSourceLocation(),null);
          j.remove();
        }
        continue;
      }
      if (conflictingSignature(existing,toAdd)) {
        if (isOverriding) {
          checkLegalOverride(existing,toAdd);
          j.remove();
        }
 else {
          getWorld().showMessage(IMessage.ERROR,WeaverMessages.format(WeaverMessages.CONFLICTING_INHERITED_POINTCUTS,this.getName() + toAdd.getSignature()),existing.getSourceLocation(),toAdd.getSourceLocation());
          j.remove();
        }
      }
    }
    acc.add(toAdd);
  }
}",0.8931430560389837
9139,"public void generateDispatchMethod(ClassScope classScope,ClassFile classFile){
  EclipseFactory world=EclipseFactory.fromScopeLookupEnvironment(classScope);
  UnresolvedType aspectType=world.fromBinding(classScope.referenceContext.binding);
  ResolvedMember signature=munger.getSignature();
  ResolvedMember dispatchMember=AjcMemberMaker.interMethodDispatcher(signature,aspectType);
  MethodBinding dispatchBinding=world.makeMethodBinding(dispatchMember,munger.getTypeVariableAliases(),munger.getSignature().getDeclaringType());
  MethodBinding introducedMethod=world.makeMethodBinding(AjcMemberMaker.interMethod(signature,aspectType,onTypeBinding.isInterface()),munger.getTypeVariableAliases());
  classFile.generateMethodInfoHeader(dispatchBinding);
  int methodAttributeOffset=classFile.contentsOffset;
  int attributeNumber=classFile.generateMethodInfoAttribute(binding,false,makeEffectiveSignatureAttribute(signature,Shadow.MethodCall,false));
  int codeAttributeOffset=classFile.contentsOffset;
  classFile.generateCodeAttributeHeader();
  CodeStream codeStream=classFile.codeStream;
  codeStream.reset(this,classFile);
  codeStream.initializeMaxLocals(dispatchBinding);
  Argument[] itdArgs=this.arguments;
  if (itdArgs != null) {
    for (int a=0; a < itdArgs.length; a++) {
      LocalVariableBinding lvb=itdArgs[a].binding;
      LocalVariableBinding lvbCopy=new LocalVariableBinding(lvb.name,lvb.type,lvb.modifiers,true);
      codeStream.record(lvbCopy);
      lvbCopy.recordInitializationStartPC(0);
      lvbCopy.resolvedPosition=lvb.resolvedPosition;
    }
  }
  MethodBinding methodBinding=introducedMethod;
  TypeBinding[] parameters=methodBinding.parameters;
  int length=parameters.length;
  int resolvedPosition;
  if (methodBinding.isStatic())   resolvedPosition=0;
 else {
    codeStream.aload_0();
    resolvedPosition=1;
  }
  for (int i=0; i < length; i++) {
    codeStream.load(parameters[i],resolvedPosition);
    if ((parameters[i] == TypeBinding.DOUBLE) || (parameters[i] == TypeBinding.LONG))     resolvedPosition+=2;
 else     resolvedPosition++;
  }
  if (methodBinding.isStatic())   codeStream.invokestatic(methodBinding);
 else {
    if (methodBinding.declaringClass.isInterface()) {
      codeStream.invokeinterface(methodBinding);
    }
 else {
      codeStream.invokevirtual(methodBinding);
    }
  }
  AstUtil.generateReturn(dispatchBinding.returnType,codeStream);
  if (itdArgs != null) {
    for (int a=0; a < itdArgs.length; a++) {
      codeStream.locals[a].recordInitializationEndPC(codeStream.position);
    }
  }
  classFile.completeCodeAttribute(codeAttributeOffset);
  attributeNumber++;
  classFile.completeMethodInfo(methodAttributeOffset,attributeNumber);
}","public void generateDispatchMethod(ClassScope classScope,ClassFile classFile){
  EclipseFactory world=EclipseFactory.fromScopeLookupEnvironment(classScope);
  UnresolvedType aspectType=world.fromBinding(classScope.referenceContext.binding);
  ResolvedMember signature=munger.getSignature();
  ResolvedMember dispatchMember=AjcMemberMaker.interMethodDispatcher(signature,aspectType);
  MethodBinding dispatchBinding=world.makeMethodBinding(dispatchMember,munger.getTypeVariableAliases(),munger.getSignature().getDeclaringType());
  MethodBinding introducedMethod=world.makeMethodBinding(AjcMemberMaker.interMethod(signature,aspectType,onTypeBinding.isInterface()),munger.getTypeVariableAliases());
  classFile.generateMethodInfoHeader(dispatchBinding);
  int methodAttributeOffset=classFile.contentsOffset;
  int attributeNumber=classFile.generateMethodInfoAttribute(binding,false,makeEffectiveSignatureAttribute(signature,Shadow.MethodCall,false));
  int codeAttributeOffset=classFile.contentsOffset;
  classFile.generateCodeAttributeHeader();
  CodeStream codeStream=classFile.codeStream;
  codeStream.reset(this,classFile);
  codeStream.initializeMaxLocals(dispatchBinding);
  Argument[] itdArgs=this.arguments;
  if (itdArgs != null) {
    for (int a=0; a < itdArgs.length; a++) {
      LocalVariableBinding lvb=itdArgs[a].binding;
      LocalVariableBinding lvbCopy=new LocalVariableBinding(lvb.name,lvb.type,lvb.modifiers,true);
      codeStream.record(lvbCopy);
      lvbCopy.recordInitializationStartPC(0);
      lvbCopy.resolvedPosition=lvb.resolvedPosition;
    }
  }
  MethodBinding methodBinding=introducedMethod;
  TypeBinding[] parameters=methodBinding.parameters;
  int length=parameters.length;
  int resolvedPosition;
  if (methodBinding.isStatic())   resolvedPosition=0;
 else {
    codeStream.aload_0();
    resolvedPosition=1;
  }
  for (int i=0; i < length; i++) {
    codeStream.load(parameters[i],resolvedPosition);
    if ((parameters[i] == TypeBinding.DOUBLE) || (parameters[i] == TypeBinding.LONG))     resolvedPosition+=2;
 else     resolvedPosition++;
  }
  if (methodBinding.isStatic())   codeStream.invokestatic(methodBinding);
 else {
    if (methodBinding.declaringClass.isInterface()) {
      codeStream.invokeinterface(methodBinding);
    }
 else {
      codeStream.invokevirtual(methodBinding);
    }
  }
  AstUtil.generateReturn(dispatchBinding.returnType,codeStream);
  if (itdArgs != null && codeStream.locals != null) {
    for (int a=0; a < itdArgs.length; a++) {
      if (codeStream.locals[a] != null) {
        codeStream.locals[a].recordInitializationEndPC(codeStream.position);
      }
    }
  }
  classFile.completeCodeAttribute(codeAttributeOffset);
  attributeNumber++;
  classFile.completeMethodInfo(methodAttributeOffset,attributeNumber);
}",0.9852646898308168
9140,"/** 
 * Convert String[] paths to File[] as offset of base directory 
 * @param basedir the non-null File base directory for File to create with paths
 * @param paths the String[] of paths to create
 * @param suffixes the String[] of suffixes to limit sources to - ignored if null
 * @return File[] with same length as paths
 */
public static File[] getBaseDirFiles(File basedir,String[] paths,String[] suffixes){
  LangUtil.throwIaxIfNull(basedir,""String_Node_Str"");
  LangUtil.throwIaxIfNull(paths,""String_Node_Str"");
  File[] result=null;
  if (!LangUtil.isEmpty(suffixes)) {
    ArrayList list=new ArrayList();
    for (int i=0; i < paths.length; i++) {
      boolean listed=false;
      String path=paths[i];
      for (int j=0; !listed && (j < suffixes.length); j++) {
        String suffix=suffixes[j];
        if (listed=path.endsWith(suffix)) {
          list.add(new File(basedir,paths[i]));
        }
      }
    }
    result=(File[])list.toArray(new File[0]);
  }
 else {
    result=new File[paths.length];
    for (int i=0; i < result.length; i++) {
      result[i]=newFile(basedir,paths[i]);
    }
  }
  return result;
}","/** 
 * Convert String[] paths to File[] as offset of base directory 
 * @param basedir the non-null File base directory for File to create with paths
 * @param paths the String[] of paths to create
 * @param suffixes the String[] of suffixes to limit sources to - ignored if null
 * @return File[] with same length as paths
 */
public static File[] getBaseDirFiles(File basedir,String[] paths,String[] suffixes){
  LangUtil.throwIaxIfNull(basedir,""String_Node_Str"");
  LangUtil.throwIaxIfNull(paths,""String_Node_Str"");
  File[] result=null;
  if (!LangUtil.isEmpty(suffixes)) {
    ArrayList list=new ArrayList();
    for (int i=0; i < paths.length; i++) {
      String path=paths[i];
      for (int j=0; j < suffixes.length; j++) {
        if (path.endsWith(suffixes[j])) {
          list.add(new File(basedir,paths[i]));
          break;
        }
      }
    }
    result=(File[])list.toArray(new File[0]);
  }
 else {
    result=new File[paths.length];
    for (int i=0; i < result.length; i++) {
      result[i]=newFile(basedir,paths[i]);
    }
  }
  return result;
}",0.9234254644313548
9141,"/** 
 * Add keyword if non-empty and not duplicate 
 */
public void addKeyword(String keyword){
  if (!LangUtil.isEmptyTrimmed(keyword)) {
    keyword=keyword.trim();
    if (!keywords.contains(keyword)) {
      keywords.add(keyword);
    }
  }
}","/** 
 * Add keyword if non-empty and not duplicate 
 */
public void addKeyword(String keyword){
  if (!isEmptyTrimmed(keyword)) {
    keyword=keyword.trim();
    if (!keywords.contains(keyword)) {
      keywords.add(keyword);
    }
  }
}",0.9813664596273292
9142,"/** 
 * @return String[] copy of argfiles array 
 */
public String[] getArgfilesArray(){
  String[] argfiles=this.argfiles;
  if (LangUtil.isEmpty(argfiles)) {
    return new String[0];
  }
  return (String[])LangUtil.copy(argfiles);
}","/** 
 * @return String[] copy of argfiles array 
 */
public String[] getArgfilesArray(){
  String[] argfiles=this.argfiles;
  if (LangUtil.isEmpty(argfiles)) {
    return new String[0];
  }
  return (String[])copy(argfiles);
}",0.980477223427332
9143,"private static String[] copy(String[] input){
  if (null == input) {
    return null;
  }
  String[] result=new String[input.length];
  System.arraycopy(input,0,result,0,input.length);
  return result;
}","/** 
 * Make a copy of the array.
 * @return an array with the same component type as sourcecontaining same elements, even if null.
 * @throws IllegalArgumentException if source is null
 */
public static final Object[] copy(Object[] source){
  LangUtil.throwIaxIfNull(source,""String_Node_Str"");
  final Class c=source.getClass().getComponentType();
  Object[] result=(Object[])Array.newInstance(c,source.length);
  System.arraycopy(source,0,result,0,result.length);
  return result;
}",0.1280931586608442
9144,"/** 
 * This checks that the spec is reasonable and does setup: <ul> <li>calculate and set sandbox testBaseSrcDir as {Sandbox.testBaseDir}/ {Spec.testSrcDirOffset}/<li> <li>get the list of source File to compile as {Sandbox.testBaseSrcDir} / {Spec.getPaths..}</li> <li>get the list of extraClasspath entries to add to default classpath as {Sandbox.testBaseSrcDir} / {Spec.classpath..}</li> <li>get the list of aspectpath entries to use as the aspectpath as {Sandbox. testBaseSrcDir} / {Spec.aspectpath..}</li> </ul> All sources must be readable at this time,  unless spec.badInput is true (for invalid-input tests). If staging, the source files and source roots are copied to a separate staging directory so they can be modified for incremental tests.   Note that (as of this writing) the compiler only handles source roots for incremental tests.
 * @param classesDir the File
 * @see org.aspectj.testing.harness.bridge.AjcTest.IAjcRun#setup(File,File)
 * @throws AbortException containing IOException or IllegalArgumentExceptionif the staging operations fail
 */
public boolean setupAjcRun(Sandbox sandbox,Validator validator){
  if (!validator.nullcheck(spec.getOptionsArray(),""String_Node_Str"") || !validator.nullcheck(sandbox,""String_Node_Str"") || !validator.nullcheck(spec.compiler,""String_Node_Str"")|| !validator.canRead(Globals.F_aspectjrt_jar,""String_Node_Str"")|| !validator.canRead(Globals.F_testingclient_jar,""String_Node_Str"")) {
    return false;
  }
  this.sandbox=sandbox;
  String rdir=spec.testSrcDirOffset;
  File testBaseSrcDir;
  if ((null == rdir) || (0 == rdir.length())) {
    testBaseSrcDir=sandbox.testBaseDir;
  }
 else {
    testBaseSrcDir=new File(sandbox.testBaseDir,rdir);
    if (!validator.canReadDir(testBaseSrcDir,""String_Node_Str"")) {
      return false;
    }
  }
  final String[] inpathPaths;
  final String[] injarPaths;
  final String[] srcPaths;
{
    final String[] paths=spec.getPathsArray();
    srcPaths=LangUtil.endsWith(paths,CompilerRun.SOURCE_SUFFIXES,true);
    injarPaths=LangUtil.endsWith(paths,CompilerRun.JAR_SUFFIXES,true);
    inpathPaths=LangUtil.selectDirectories(paths,testBaseSrcDir);
    if (!spec.badInput) {
      int found=inpathPaths.length + injarPaths.length + srcPaths.length;
      if (paths.length != found) {
        validator.fail(""String_Node_Str"" + found + ""String_Node_Str""+ paths.length+ ""String_Node_Str"");
      }
    }
  }
  if (!spec.badInput) {
    if (!validator.canRead(testBaseSrcDir,srcPaths,""String_Node_Str"") || !validator.canRead(testBaseSrcDir,spec.argfiles,""String_Node_Str"") || !validator.canRead(testBaseSrcDir,spec.classpath,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.aspectpath,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.sourceroots,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.extdirs,""String_Node_Str"")) {
      return false;
    }
  }
  int numSources=srcPaths.length + injarPaths.length + inpathPaths.length+ spec.argfiles.length+ spec.sourceroots.length;
  if (!spec.badInput && (numSources < 1)) {
    validator.fail(""String_Node_Str"");
    return false;
  }
  final File[] argFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.argfiles);
  final File[] injarFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,injarPaths);
  final File[] inpathFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,inpathPaths);
  final File[] aspectFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.aspectpath);
  final File[] extdirFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.extdirs);
  final File[] classFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.classpath);
  final File[] xlintFiles=(null == spec.xlintfile ? new File[0] : FileUtil.getBaseDirFiles(testBaseSrcDir,new String[]{spec.xlintfile}));
  for (int i=0; i < injarFiles.length; i++) {
    if (!injarFiles[i].exists()) {
      injarFiles[i]=new File(sandbox.classesDir,injarPaths[i]);
    }
  }
  for (int i=0; i < inpathFiles.length; i++) {
    if (!inpathFiles[i].exists()) {
      inpathFiles[i]=new File(sandbox.classesDir,inpathPaths[i]);
    }
  }
  if (!validator.canRead(injarFiles,""String_Node_Str"") || !validator.canRead(injarFiles,""String_Node_Str"")) {
    return false;
  }
  if (!spec.badInput) {
    if (!validator.canRead(argFiles,""String_Node_Str"") || !validator.canRead(injarFiles,""String_Node_Str"") || !validator.canRead(inpathFiles,""String_Node_Str"")|| !validator.canRead(aspectFiles,""String_Node_Str"")|| !validator.canRead(classFiles,""String_Node_Str"")|| !validator.canRead(xlintFiles,""String_Node_Str"")) {
      return false;
    }
  }
  final File[] srcFiles;
  File[] sourcerootFiles=new File[0];
  if (!spec.isStaging()) {
    srcFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,srcPaths,CompilerRun.SOURCE_SUFFIXES);
    if (!LangUtil.isEmpty(spec.sourceroots)) {
      sourcerootFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.sourceroots,null);
    }
  }
 else {
    if (spec.badInput) {
      validator.info(""String_Node_Str"");
    }
    try {
      srcFiles=FileUtil.copyFiles(testBaseSrcDir,srcPaths,sandbox.stagingDir);
      if (!LangUtil.isEmpty(spec.sourceroots)) {
        sourcerootFiles=FileUtil.copyFiles(testBaseSrcDir,spec.sourceroots,sandbox.stagingDir);
        FileFilter pickIncFiles=new FileFilter(){
          public boolean accept(          File file){
            if (file.isDirectory()) {
              return true;
            }
            String path=file.getPath();
            if (!FileUtil.hasSourceSuffix(path)) {
              return false;
            }
            int first=path.indexOf(""String_Node_Str"");
            int last=path.lastIndexOf(""String_Node_Str"");
            return (first != last);
          }
        }
;
        for (int i=0; i < sourcerootFiles.length; i++) {
          FileUtil.deleteContents(sourcerootFiles[i],pickIncFiles,false);
        }
        if (0 < sourcerootFiles.length) {
          FileUtil.sleepPastFinalModifiedTime(sourcerootFiles);
        }
      }
      File[] files=FileUtil.getBaseDirFiles(sandbox.stagingDir,srcPaths);
      if (0 < files.length) {
        FileUtil.sleepPastFinalModifiedTime(files);
      }
    }
 catch (    IllegalArgumentException e) {
      validator.fail(""String_Node_Str"",e);
      return false;
    }
catch (    IOException e) {
      validator.fail(""String_Node_Str"",e);
      return false;
    }
  }
  if (!spec.badInput && !validator.canRead(srcFiles,""String_Node_Str"")) {
    return false;
  }
  arguments.clear();
  if (!LangUtil.isEmpty(xlintFiles)) {
    arguments.add(""String_Node_Str"");
    String sr=FileUtil.flatten(xlintFiles,null);
    arguments.add(sr);
  }
  if (spec.outjar != null) {
    arguments.add(""String_Node_Str"");
    arguments.add(new File(sandbox.classesDir,spec.outjar).getPath());
  }
  if (!LangUtil.isEmpty(extdirFiles)) {
    arguments.add(""String_Node_Str"");
    String sr=FileUtil.flatten(extdirFiles,null);
    arguments.add(sr);
  }
  if (!LangUtil.isEmpty(sourcerootFiles)) {
    arguments.add(""String_Node_Str"");
    String sr=FileUtil.flatten(sourcerootFiles,null);
    arguments.add(sr);
  }
  if (!LangUtil.isEmpty(srcFiles)) {
    arguments.addAll(Arrays.asList(FileUtil.getPaths(srcFiles)));
  }
  injars.clear();
  if (!LangUtil.isEmpty(injarFiles)) {
    injars.addAll(Arrays.asList(FileUtil.getPaths(injarFiles)));
  }
  inpaths.clear();
  if (!LangUtil.isEmpty(inpathFiles)) {
    inpaths.addAll(Arrays.asList(FileUtil.getPaths(inpathFiles)));
  }
  if (!LangUtil.isEmpty(argFiles)) {
    String[] ra=FileUtil.getPaths(argFiles);
    for (int j=0; j < ra.length; j++) {
      arguments.add(""String_Node_Str"" + ra[j]);
    }
    if (!spec.badInput && spec.isStaging) {
      validator.fail(""String_Node_Str"");
    }
  }
  final boolean checkReadable=!spec.badInput;
  int size=spec.includeClassesDir ? 3 : 2;
  File[] cp=new File[size + classFiles.length];
  System.arraycopy(classFiles,0,cp,0,classFiles.length);
  int index=classFiles.length;
  if (spec.includeClassesDir) {
    cp[index++]=sandbox.classesDir;
  }
  cp[index++]=Globals.F_aspectjrt_jar;
  cp[index++]=Globals.F_testingclient_jar;
  sandbox.compilerRunInit(this,testBaseSrcDir,aspectFiles,checkReadable,cp,checkReadable,null);
  return true;
}","/** 
 * This checks that the spec is reasonable and does setup: <ul> <li>calculate and set sandbox testBaseSrcDir as {Sandbox.testBaseDir}/ {Spec.testSrcDirOffset}/<li> <li>get the list of source File to compile as {Sandbox.testBaseSrcDir} / {Spec.getPaths..}</li> <li>get the list of extraClasspath entries to add to default classpath as {Sandbox.testBaseSrcDir} / {Spec.classpath..}</li> <li>get the list of aspectpath entries to use as the aspectpath as {Sandbox. testBaseSrcDir} / {Spec.aspectpath..}</li> </ul> All sources must be readable at this time,  unless spec.badInput is true (for invalid-input tests). If staging, the source files and source roots are copied to a separate staging directory so they can be modified for incremental tests.   Note that (as of this writing) the compiler only handles source roots for incremental tests.
 * @param classesDir the File
 * @see org.aspectj.testing.harness.bridge.AjcTest.IAjcRun#setup(File,File)
 * @throws AbortException containing IOException or IllegalArgumentExceptionif the staging operations fail
 */
public boolean setupAjcRun(Sandbox sandbox,Validator validator){
  if (!validator.nullcheck(spec.getOptionsArray(),""String_Node_Str"") || !validator.nullcheck(sandbox,""String_Node_Str"") || !validator.nullcheck(spec.compiler,""String_Node_Str"")|| !validator.canRead(Globals.F_aspectjrt_jar,""String_Node_Str"")|| !validator.canRead(Globals.F_testingclient_jar,""String_Node_Str"")) {
    return false;
  }
  this.sandbox=sandbox;
  String rdir=spec.testSrcDirOffset;
  File testBaseSrcDir;
  if ((null == rdir) || (0 == rdir.length())) {
    testBaseSrcDir=sandbox.testBaseDir;
  }
 else {
    testBaseSrcDir=new File(sandbox.testBaseDir,rdir);
    if (!validator.canReadDir(testBaseSrcDir,""String_Node_Str"")) {
      return false;
    }
  }
  final String[] inpathPaths;
  final String[] injarPaths;
  final String[] srcPaths;
{
    final String[] paths=spec.getPathsArray();
    srcPaths=endsWith(paths,CompilerRun.SOURCE_SUFFIXES,true);
    injarPaths=endsWith(paths,CompilerRun.JAR_SUFFIXES,true);
    inpathPaths=selectDirectories(paths,testBaseSrcDir);
    if (!spec.badInput) {
      int found=inpathPaths.length + injarPaths.length + srcPaths.length;
      if (paths.length != found) {
        validator.fail(""String_Node_Str"" + found + ""String_Node_Str""+ paths.length+ ""String_Node_Str"");
      }
    }
  }
  if (!spec.badInput) {
    if (!validator.canRead(testBaseSrcDir,srcPaths,""String_Node_Str"") || !validator.canRead(testBaseSrcDir,spec.argfiles,""String_Node_Str"") || !validator.canRead(testBaseSrcDir,spec.classpath,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.aspectpath,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.sourceroots,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.extdirs,""String_Node_Str"")) {
      return false;
    }
  }
  int numSources=srcPaths.length + injarPaths.length + inpathPaths.length+ spec.argfiles.length+ spec.sourceroots.length;
  if (!spec.badInput && (numSources < 1)) {
    validator.fail(""String_Node_Str"");
    return false;
  }
  final File[] argFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.argfiles);
  final File[] injarFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,injarPaths);
  final File[] inpathFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,inpathPaths);
  final File[] aspectFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.aspectpath);
  final File[] extdirFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.extdirs);
  final File[] classFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.classpath);
  final File[] xlintFiles=(null == spec.xlintfile ? new File[0] : FileUtil.getBaseDirFiles(testBaseSrcDir,new String[]{spec.xlintfile}));
  for (int i=0; i < injarFiles.length; i++) {
    if (!injarFiles[i].exists()) {
      injarFiles[i]=new File(sandbox.classesDir,injarPaths[i]);
    }
  }
  for (int i=0; i < inpathFiles.length; i++) {
    if (!inpathFiles[i].exists()) {
      inpathFiles[i]=new File(sandbox.classesDir,inpathPaths[i]);
    }
  }
  if (!validator.canRead(injarFiles,""String_Node_Str"") || !validator.canRead(injarFiles,""String_Node_Str"")) {
    return false;
  }
  if (!spec.badInput) {
    if (!validator.canRead(argFiles,""String_Node_Str"") || !validator.canRead(injarFiles,""String_Node_Str"") || !validator.canRead(inpathFiles,""String_Node_Str"")|| !validator.canRead(aspectFiles,""String_Node_Str"")|| !validator.canRead(classFiles,""String_Node_Str"")|| !validator.canRead(xlintFiles,""String_Node_Str"")) {
      return false;
    }
  }
  final File[] srcFiles;
  File[] sourcerootFiles=new File[0];
  if (!spec.isStaging()) {
    srcFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,srcPaths,CompilerRun.SOURCE_SUFFIXES);
    if (!LangUtil.isEmpty(spec.sourceroots)) {
      sourcerootFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.sourceroots,null);
    }
  }
 else {
    if (spec.badInput) {
      validator.info(""String_Node_Str"");
    }
    try {
      srcFiles=FileUtil.copyFiles(testBaseSrcDir,srcPaths,sandbox.stagingDir);
      if (!LangUtil.isEmpty(spec.sourceroots)) {
        sourcerootFiles=FileUtil.copyFiles(testBaseSrcDir,spec.sourceroots,sandbox.stagingDir);
        FileFilter pickIncFiles=new FileFilter(){
          public boolean accept(          File file){
            if (file.isDirectory()) {
              return true;
            }
            String path=file.getPath();
            if (!FileUtil.hasSourceSuffix(path)) {
              return false;
            }
            int first=path.indexOf(""String_Node_Str"");
            int last=path.lastIndexOf(""String_Node_Str"");
            return (first != last);
          }
        }
;
        for (int i=0; i < sourcerootFiles.length; i++) {
          FileUtil.deleteContents(sourcerootFiles[i],pickIncFiles,false);
        }
        if (0 < sourcerootFiles.length) {
          FileUtil.sleepPastFinalModifiedTime(sourcerootFiles);
        }
      }
      File[] files=FileUtil.getBaseDirFiles(sandbox.stagingDir,srcPaths);
      if (0 < files.length) {
        FileUtil.sleepPastFinalModifiedTime(files);
      }
    }
 catch (    IllegalArgumentException e) {
      validator.fail(""String_Node_Str"",e);
      return false;
    }
catch (    IOException e) {
      validator.fail(""String_Node_Str"",e);
      return false;
    }
  }
  if (!spec.badInput && !validator.canRead(srcFiles,""String_Node_Str"")) {
    return false;
  }
  arguments.clear();
  if (!LangUtil.isEmpty(xlintFiles)) {
    arguments.add(""String_Node_Str"");
    String sr=FileUtil.flatten(xlintFiles,null);
    arguments.add(sr);
  }
  if (spec.outjar != null) {
    arguments.add(""String_Node_Str"");
    arguments.add(new File(sandbox.classesDir,spec.outjar).getPath());
  }
  if (!LangUtil.isEmpty(extdirFiles)) {
    arguments.add(""String_Node_Str"");
    String sr=FileUtil.flatten(extdirFiles,null);
    arguments.add(sr);
  }
  if (!LangUtil.isEmpty(sourcerootFiles)) {
    arguments.add(""String_Node_Str"");
    String sr=FileUtil.flatten(sourcerootFiles,null);
    arguments.add(sr);
  }
  if (!LangUtil.isEmpty(srcFiles)) {
    arguments.addAll(Arrays.asList(FileUtil.getPaths(srcFiles)));
  }
  injars.clear();
  if (!LangUtil.isEmpty(injarFiles)) {
    injars.addAll(Arrays.asList(FileUtil.getPaths(injarFiles)));
  }
  inpaths.clear();
  if (!LangUtil.isEmpty(inpathFiles)) {
    inpaths.addAll(Arrays.asList(FileUtil.getPaths(inpathFiles)));
  }
  if (!LangUtil.isEmpty(argFiles)) {
    String[] ra=FileUtil.getPaths(argFiles);
    for (int j=0; j < ra.length; j++) {
      arguments.add(""String_Node_Str"" + ra[j]);
    }
    if (!spec.badInput && spec.isStaging) {
      validator.fail(""String_Node_Str"");
    }
  }
  final boolean checkReadable=!spec.badInput;
  int size=spec.includeClassesDir ? 3 : 2;
  File[] cp=new File[size + classFiles.length];
  System.arraycopy(classFiles,0,cp,0,classFiles.length);
  int index=classFiles.length;
  if (spec.includeClassesDir) {
    cp[index++]=sandbox.classesDir;
  }
  cp[index++]=Globals.F_aspectjrt_jar;
  cp[index++]=Globals.F_testingclient_jar;
  sandbox.compilerRunInit(this,testBaseSrcDir,aspectFiles,checkReadable,cp,checkReadable,null);
  return true;
}",0.9983471074380166
9145,"/** 
 * If the source version warrants, add a -bootclasspath entry to the list of arguments to add.  This will fail and return an error String if the  required library is not found.
 * @param sourceVersion the String (if any) describing the -source option(expecting one of [null, ""1.3"", ""1.4"", ""1.5""].
 * @param compilerName the String name of the target compiler
 * @param toAdd the ArrayList to add -bootclasspath to
 * @return the String describing any errors, or null if no errors
 */
private static String updateBootclasspathForSourceVersion(String sourceVersion,String compilerName,ArrayList toAdd){
  if (null == sourceVersion) {
    return null;
  }
  if (3 != sourceVersion.length()) {
    throw new IllegalArgumentException(""String_Node_Str"" + sourceVersion);
  }
  if (null == toAdd) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int version=sourceVersion.charAt(2) - '0';
switch (version) {
case (3):
    if (LangUtil.supportsJava(""String_Node_Str"")) {
      if (!FileUtil.canReadFile(Globals.J2SE13_RTJAR)) {
        return ""String_Node_Str"";
      }
      toAdd.add(""String_Node_Str"");
      toAdd.add(Globals.J2SE13_RTJAR.getAbsolutePath());
    }
  break;
case (4):
if (!LangUtil.supportsJava(""String_Node_Str"")) {
  if (ReflectionFactory.ECLIPSE.equals(compilerName)) {
    return ""String_Node_Str"";
  }
  if (!FileUtil.canReadFile(Globals.J2SE14_RTJAR)) {
    return ""String_Node_Str"";
  }
  toAdd.add(""String_Node_Str"");
  toAdd.add(Globals.J2SE14_RTJAR.getAbsolutePath());
}
break;
case (5):
return ""String_Node_Str"";
case (0):
break;
default :
throw new Error(""String_Node_Str"" + version);
}
return null;
}","/** 
 * If the source version warrants, add a -bootclasspath entry to the list of arguments to add.  This will fail and return an error String if the  required library is not found.
 * @param sourceVersion the String (if any) describing the -source option(expecting one of [null, ""1.3"", ""1.4"", ""1.5""].
 * @param compilerName the String name of the target compiler
 * @param toAdd the ArrayList to add -bootclasspath to
 * @return the String describing any errors, or null if no errors
 */
private static String updateBootclasspathForSourceVersion(String sourceVersion,String compilerName,ArrayList toAdd){
  if (null == sourceVersion) {
    return null;
  }
  if (3 != sourceVersion.length()) {
    throw new IllegalArgumentException(""String_Node_Str"" + sourceVersion);
  }
  if (null == toAdd) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int version=sourceVersion.charAt(2) - '0';
switch (version) {
case (3):
    if (Globals.supportsJava(""String_Node_Str"")) {
      if (!FileUtil.canReadFile(Globals.J2SE13_RTJAR)) {
        return ""String_Node_Str"";
      }
      toAdd.add(""String_Node_Str"");
      toAdd.add(Globals.J2SE13_RTJAR.getAbsolutePath());
    }
  break;
case (4):
if (!Globals.supportsJava(""String_Node_Str"")) {
  if (ReflectionFactory.ECLIPSE.equals(compilerName)) {
    return ""String_Node_Str"";
  }
  if (!FileUtil.canReadFile(Globals.J2SE14_RTJAR)) {
    return ""String_Node_Str"";
  }
  toAdd.add(""String_Node_Str"");
  toAdd.add(Globals.J2SE14_RTJAR.getAbsolutePath());
}
break;
case (5):
return ""String_Node_Str"";
case (0):
break;
default :
throw new Error(""String_Node_Str"" + version);
}
return null;
}",0.9908925318761383
9146,"/** 
 * post-process result  - use file name as keyword - clip / for dir offsets - extract purejava keyword variants - extract bugID - convert test options to force-options - detect illegal xml characters
 */
private void cleanup(AjcTest.Spec result,LineReader lineReader){
  LangUtil.throwIaxIfNull(result,""String_Node_Str"");
  LangUtil.throwIaxIfNull(lineReader,""String_Node_Str"");
  File suiteFile=lineReader.getFile();
  String name=suiteFile.getName();
  if (!name.endsWith(""String_Node_Str"")) {
    throw new Error(""String_Node_Str"" + name);
  }
  result.addKeyword(""String_Node_Str"" + name.substring(0,name.length() - 4));
  final String dir=result.testDirOffset;
  if (dir.endsWith(""String_Node_Str"")) {
    result.testDirOffset=dir.substring(0,dir.length() - 1);
  }
  StringBuffer description=new StringBuffer(result.description);
  if (strip(description,""String_Node_Str"")) {
    result.addKeyword(""String_Node_Str"");
  }
  if (strip(description,""String_Node_Str"")) {
    result.addKeyword(""String_Node_Str"");
  }
  if (strip(description,""String_Node_Str"")) {
    result.addKeyword(""String_Node_Str"");
  }
  String input=description.toString();
  int loc=input.indexOf(""String_Node_Str"");
  if (-1 != loc) {
    String prefix=input.substring(0,loc).trim();
    String pr=input.substring(loc + 3,loc + 6).trim();
    String suffix=input.substring(loc + 6).trim();
    description.setLength(0);
    description.append((prefix + ""String_Node_Str"" + suffix).trim());
    try {
      result.setBugId(Integer.valueOf(pr).intValue());
    }
 catch (    NumberFormatException e) {
      throw new Error(""String_Node_Str"" + pr + ""String_Node_Str""+ result+ ""String_Node_Str""+ lineReader);
    }
  }
  input=description.toString();
  String error=null;
  if (-1 != input.indexOf(""String_Node_Str"")) {
    error=""String_Node_Str"";
  }
 else   if (-1 != input.indexOf(""String_Node_Str"")) {
    error=""String_Node_Str"";
  }
 else   if (-1 != input.indexOf(""String_Node_Str"")) {
    error=""String_Node_Str"";
  }
 else   if (-1 != input.indexOf(""String_Node_Str"")) {
    error=""String_Node_Str"";
  }
  if (null != error) {
    throw new Error(error + ""String_Node_Str"" + input+ ""String_Node_Str""+ lineReader);
  }
  result.description=input;
  ArrayList newOptions=new ArrayList();
  ArrayList optionsCopy=result.getOptionsList();
  for (Iterator iter=optionsCopy.iterator(); iter.hasNext(); ) {
    String option=(String)iter.next();
    if (option.startsWith(""String_Node_Str"")) {
      newOptions.add(""String_Node_Str"" + option.substring(1));
    }
 else {
      throw new Error(""String_Node_Str"" + option);
    }
  }
  result.setOptionsArray((String[])newOptions.toArray(new String[0]));
}","/** 
 * post-process result  - use file name as keyword - clip / for dir offsets - extract purejava keyword variants - extract bugID - convert test options to force-options - detect illegal xml characters
 */
private void cleanup(AjcTest.Spec result,UtilLineReader lineReader){
  LangUtil.throwIaxIfNull(result,""String_Node_Str"");
  LangUtil.throwIaxIfNull(lineReader,""String_Node_Str"");
  File suiteFile=lineReader.getFile();
  String name=suiteFile.getName();
  if (!name.endsWith(""String_Node_Str"")) {
    throw new Error(""String_Node_Str"" + name);
  }
  result.addKeyword(""String_Node_Str"" + name.substring(0,name.length() - 4));
  final String dir=result.testDirOffset;
  if (dir.endsWith(""String_Node_Str"")) {
    result.testDirOffset=dir.substring(0,dir.length() - 1);
  }
  StringBuffer description=new StringBuffer(result.description);
  if (strip(description,""String_Node_Str"")) {
    result.addKeyword(""String_Node_Str"");
  }
  if (strip(description,""String_Node_Str"")) {
    result.addKeyword(""String_Node_Str"");
  }
  if (strip(description,""String_Node_Str"")) {
    result.addKeyword(""String_Node_Str"");
  }
  String input=description.toString();
  int loc=input.indexOf(""String_Node_Str"");
  if (-1 != loc) {
    String prefix=input.substring(0,loc).trim();
    String pr=input.substring(loc + 3,loc + 6).trim();
    String suffix=input.substring(loc + 6).trim();
    description.setLength(0);
    description.append((prefix + ""String_Node_Str"" + suffix).trim());
    try {
      result.setBugId(Integer.valueOf(pr).intValue());
    }
 catch (    NumberFormatException e) {
      throw new Error(""String_Node_Str"" + pr + ""String_Node_Str""+ result+ ""String_Node_Str""+ lineReader);
    }
  }
  input=description.toString();
  String error=null;
  if (-1 != input.indexOf(""String_Node_Str"")) {
    error=""String_Node_Str"";
  }
 else   if (-1 != input.indexOf(""String_Node_Str"")) {
    error=""String_Node_Str"";
  }
 else   if (-1 != input.indexOf(""String_Node_Str"")) {
    error=""String_Node_Str"";
  }
 else   if (-1 != input.indexOf(""String_Node_Str"")) {
    error=""String_Node_Str"";
  }
  if (null != error) {
    throw new Error(error + ""String_Node_Str"" + input+ ""String_Node_Str""+ lineReader);
  }
  result.description=input;
  ArrayList newOptions=new ArrayList();
  ArrayList optionsCopy=result.getOptionsList();
  for (Iterator iter=optionsCopy.iterator(); iter.hasNext(); ) {
    String option=(String)iter.next();
    if (option.startsWith(""String_Node_Str"")) {
      newOptions.add(""String_Node_Str"" + option.substring(1));
    }
 else {
      throw new Error(""String_Node_Str"" + option);
    }
  }
  result.setOptionsArray((String[])newOptions.toArray(new String[0]));
}",0.9992565055762082
9147,"/** 
 * This constructs an AjcTest.Spec assuming we are at the start of a test definition in reader and taking the parent directory of the reader as the base directory for the test suite root. 
 * @return the next AjcTest in reader, or null
 * @see org.aspectj.testing.harness.bridge.SFileReader.Maker#make(LineReader)
 */
public Object make(final LineReader reader) throws AbortException, IOException {
  final AjcTest.Spec result=new AjcTest.Spec();
  boolean usingEclipse=false;
  /** 
 * handle read errors by throwing AbortException with context info 
 */
class R {
    public String read(    String context) throws IOException {
      return read(context,true);
    }
    public String read(    String context,    boolean required) throws IOException {
      final boolean skipEmpties=false;
      String result=reader.nextLine(skipEmpties);
      if ((null != result) && (0 == result.length())) {
        result=null;
      }
      if ((null == result) && required) {
        String s=""String_Node_Str"" + context + ""String_Node_Str""+ reader;
        throw new AbortException(s);
      }
      return result;
    }
  }
  final R r=new R();
  String line;
  String[] words;
  final int startLine=reader.getLineNumber() - 1;
  result.description=reader.lastLine();
  if (null == result.description) {
    throw new AbortException(""String_Node_Str"" + reader);
  }
  line=r.read(""String_Node_Str"");
  words=LangUtil.split(line);
  if ((null == words) || (0 == words.length)) {
    throw new AbortException(""String_Node_Str"" + reader);
  }
  result.setTestDirOffset(words[0]);
  String[] compileOptions=new String[words.length - 1];
  System.arraycopy(words,1,compileOptions,0,words.length - 1);
  CompilerRun.Spec lastCompileSpec=null;
  File lastFile=null;
  while (null != (line=r.read(""String_Node_Str""))) {
    words=LangUtil.split(line);
    if (0 == FileUtil.sourceSuffixLength(words[0])) {
      break;
    }
 else {
      lastCompileSpec=new CompilerRun.Spec();
      lastCompileSpec.testSrcDirOffset=null;
      lastCompileSpec.addOptions(compileOptions);
      lastCompileSpec.addPaths(words);
      lastFile=new File(words[words.length - 1]);
      result.addChild(lastCompileSpec);
    }
  }
  if (null == lastCompileSpec) {
    throw new AbortException(""String_Node_Str"" + reader);
  }
  ArrayList exp=new ArrayList();
  String first=words[0];
  if (""String_Node_Str"".equals(first)) {
  }
 else   if (""String_Node_Str"".equals(first)) {
  }
 else   if (isNumber(first) || (-1 != first.indexOf(""String_Node_Str""))) {
    exp.addAll(makeMessages(IMessage.ERROR,words,0,lastFile));
  }
 else {
    String[] args=new String[words.length - 1];
    System.arraycopy(words,0,args,0,args.length);
    JavaRun.Spec spec=new JavaRun.Spec();
    spec.className=first;
    spec.addOptions(args);
    result.addChild(spec);
  }
  boolean gotErrors=false;
  while (null != (line=r.read(""String_Node_Str"",false))) {
    words=LangUtil.split(line);
    first=words[0];
    if (""String_Node_Str"".equals(first)) {
      if (usingEclipse) {
        exp.addAll(makeMessages(IMessage.WARNING,words,0,lastFile));
      }
    }
 else     if (""String_Node_Str"".equals(first)) {
      if (usingEclipse) {
        exp.addAll(makeMessages(IMessage.ERROR,words,0,lastFile));
      }
    }
 else     if (""String_Node_Str"".equals(first)) {
      exp.addAll(makeMessages(IMessage.WARNING,words,0,lastFile));
    }
 else     if (gotErrors) {
      exp.addAll(makeMessages(IMessage.WARNING,words,0,lastFile));
    }
 else {
      exp.addAll(makeMessages(IMessage.ERROR,words,0,lastFile));
      gotErrors=true;
    }
  }
  lastCompileSpec.addMessages(exp);
  int endLine=reader.getLineNumber();
  File sourceFile=reader.getFile();
  ISourceLocation sl=new SourceLocation(sourceFile,startLine,endLine,0);
  result.setSourceLocation(sl);
  if (clean) {
    cleanup(result,reader);
  }
  return result;
}","/** 
 * This constructs an AjcTest.Spec assuming we are at the start of a test definition in reader and taking the parent directory of the reader as the base directory for the test suite root. 
 * @return the next AjcTest in reader, or null
 * @see org.aspectj.testing.harness.bridge.SFileReader.Maker#make(UtilLineReader)
 */
public Object make(final UtilLineReader reader) throws AbortException, IOException {
  final AjcTest.Spec result=new AjcTest.Spec();
  boolean usingEclipse=false;
  /** 
 * handle read errors by throwing AbortException with context info 
 */
class R {
    public String read(    String context) throws IOException {
      return read(context,true);
    }
    public String read(    String context,    boolean required) throws IOException {
      final boolean skipEmpties=false;
      String result=reader.nextLine(skipEmpties);
      if ((null != result) && (0 == result.length())) {
        result=null;
      }
      if ((null == result) && required) {
        String s=""String_Node_Str"" + context + ""String_Node_Str""+ reader;
        throw new AbortException(s);
      }
      return result;
    }
  }
  final R r=new R();
  String line;
  String[] words;
  final int startLine=reader.getLineNumber() - 1;
  result.description=reader.lastLine();
  if (null == result.description) {
    throw new AbortException(""String_Node_Str"" + reader);
  }
  line=r.read(""String_Node_Str"");
  words=LangUtil.split(line);
  if ((null == words) || (0 == words.length)) {
    throw new AbortException(""String_Node_Str"" + reader);
  }
  result.setTestDirOffset(words[0]);
  String[] compileOptions=new String[words.length - 1];
  System.arraycopy(words,1,compileOptions,0,words.length - 1);
  CompilerRun.Spec lastCompileSpec=null;
  File lastFile=null;
  while (null != (line=r.read(""String_Node_Str""))) {
    words=LangUtil.split(line);
    if (0 == FileUtil.sourceSuffixLength(words[0])) {
      break;
    }
 else {
      lastCompileSpec=new CompilerRun.Spec();
      lastCompileSpec.testSrcDirOffset=null;
      lastCompileSpec.addOptions(compileOptions);
      lastCompileSpec.addPaths(words);
      lastFile=new File(words[words.length - 1]);
      result.addChild(lastCompileSpec);
    }
  }
  if (null == lastCompileSpec) {
    throw new AbortException(""String_Node_Str"" + reader);
  }
  ArrayList exp=new ArrayList();
  String first=words[0];
  if (""String_Node_Str"".equals(first)) {
  }
 else   if (""String_Node_Str"".equals(first)) {
  }
 else   if (isNumber(first) || (-1 != first.indexOf(""String_Node_Str""))) {
    exp.addAll(makeMessages(IMessage.ERROR,words,0,lastFile));
  }
 else {
    String[] args=new String[words.length - 1];
    System.arraycopy(words,0,args,0,args.length);
    JavaRun.Spec spec=new JavaRun.Spec();
    spec.className=first;
    spec.addOptions(args);
    result.addChild(spec);
  }
  boolean gotErrors=false;
  while (null != (line=r.read(""String_Node_Str"",false))) {
    words=LangUtil.split(line);
    first=words[0];
    if (""String_Node_Str"".equals(first)) {
      if (usingEclipse) {
        exp.addAll(makeMessages(IMessage.WARNING,words,0,lastFile));
      }
    }
 else     if (""String_Node_Str"".equals(first)) {
      if (usingEclipse) {
        exp.addAll(makeMessages(IMessage.ERROR,words,0,lastFile));
      }
    }
 else     if (""String_Node_Str"".equals(first)) {
      exp.addAll(makeMessages(IMessage.WARNING,words,0,lastFile));
    }
 else     if (gotErrors) {
      exp.addAll(makeMessages(IMessage.WARNING,words,0,lastFile));
    }
 else {
      exp.addAll(makeMessages(IMessage.ERROR,words,0,lastFile));
      gotErrors=true;
    }
  }
  lastCompileSpec.addMessages(exp);
  int endLine=reader.getLineNumber();
  File sourceFile=reader.getFile();
  ISourceLocation sl=new SourceLocation(sourceFile,startLine,endLine,0);
  result.setSourceLocation(sl);
  if (clean) {
    cleanup(result,reader);
  }
  return result;
}",0.9989706639217704
9148,"/** 
 * This implementation skips if: <ul> <li>current VM is not at least any specified javaVersion </li> </ul>
 * @return false if this wants to be skipped, true otherwise
 */
protected boolean doAdoptParentValues(RT parentRuntime,IMessageHandler handler){
  if (!super.doAdoptParentValues(parentRuntime,handler)) {
    return false;
  }
  if ((null != javaVersion) && (!LangUtil.supportsJava(javaVersion))) {
    skipMessage(handler,""String_Node_Str"" + javaVersion);
    return false;
  }
  return true;
}","/** 
 * This implementation skips if: <ul> <li>current VM is not at least any specified javaVersion </li> </ul>
 * @return false if this wants to be skipped, true otherwise
 */
protected boolean doAdoptParentValues(RT parentRuntime,IMessageHandler handler){
  if (!super.doAdoptParentValues(parentRuntime,handler)) {
    return false;
  }
  if ((null != javaVersion) && (!Globals.supportsJava(javaVersion))) {
    skipMessage(handler,""String_Node_Str"" + javaVersion);
    return false;
  }
  return true;
}",0.9851924975320828
9149,"/** 
 * Run in another VM by grabbing Java, bootclasspath, classpath, etc. This assumes any exception or output to System.err is a failure, and any normal completion is a pass.
 * @param status
 * @param libs
 * @param dirs
 * @return
 */
protected boolean runInOtherVM(IRunStatus status,File[] libs,File[] dirs){
  ArrayList cmd=new ArrayList();
  cmd.add(FileUtil.getBestPath(spec.forkSpec.java));
  if (!LangUtil.isEmpty(spec.forkSpec.vmargs)) {
    cmd.addAll(Arrays.asList(spec.forkSpec.vmargs));
  }
  final String classpath;
{
    StringBuffer cp=new StringBuffer();
    appendClasspath(cp,spec.forkSpec.bootclasspath);
    appendClasspath(cp,dirs);
    appendClasspath(cp,libs);
    File[] classpathFiles=sandbox.findFiles(spec.classpath);
    int cpLength=(null == classpathFiles ? 0 : classpathFiles.length);
    int spLength=(null == spec.classpath ? 0 : spec.classpath.length);
    if (cpLength != spLength) {
      throw new Error(""String_Node_Str"" + Arrays.asList(spec.classpath) + ""String_Node_Str""+ Arrays.asList(classpathFiles));
    }
    appendClasspath(cp,classpathFiles);
    File[] stdlibs={Globals.F_aspectjrt_jar,Globals.F_testingclient_jar};
    appendClasspath(cp,stdlibs);
    classpath=cp.toString();
  }
  if (!spec.isLTW()) {
    cmd.add(""String_Node_Str"");
    cmd.add(classpath);
  }
 else {
    if (!LangUtil.supportsJava(""String_Node_Str"")) {
      throw new Error(""String_Node_Str"");
    }
    cmd.add(""String_Node_Str"");
    cmd.add(""String_Node_Str"");
    cmd.add(System.getProperty(""String_Node_Str""));
    File[] aspectJars=sandbox.findFiles(spec.aspectpath);
    if (aspectJars.length != spec.aspectpath.length) {
      throw new Error(""String_Node_Str"" + Arrays.asList(spec.aspectpath));
    }
    StringBuffer cp=new StringBuffer();
    appendClasspath(cp,aspectJars);
    cmd.add(""String_Node_Str"" + cp.toString());
    cp.append(classpath);
    cmd.add(""String_Node_Str"" + cp.toString());
  }
  cmd.add(spec.className);
  cmd.addAll(spec.options);
  String[] command=(String[])cmd.toArray(new String[0]);
  final IMessageHandler handler=status;
class DoneFlag {
    boolean done;
    boolean failed;
    int code;
  }
  final StringBuffer commandLabel=new StringBuffer();
  final DoneFlag doneFlag=new DoneFlag();
  LangUtil.ProcessController controller=new LangUtil.ProcessController(){
    protected void doCompleting(    Thrown ex,    int result){
      if (!ex.thrown && (0 == result)) {
        doneFlag.done=true;
        return;
      }
      String context=spec.className + ""String_Node_Str"" + commandLabel+ ""String_Node_Str"";
      if (null != ex.fromProcess) {
        if (!expectedException(ex.fromProcess)) {
          String m=""String_Node_Str"" + context;
          MessageUtil.abort(handler,m,ex.fromProcess);
          doneFlag.failed=true;
        }
      }
 else       if (0 != result) {
        doneFlag.code=result;
      }
      if (null != ex.fromInPipe) {
        String m=""String_Node_Str"" + context;
        MessageUtil.abort(handler,m,ex.fromInPipe);
        doneFlag.failed=true;
      }
      if (null != ex.fromOutPipe) {
        String m=""String_Node_Str"" + context;
        MessageUtil.abort(handler,m,ex.fromOutPipe);
        doneFlag.failed=true;
      }
      if (null != ex.fromErrPipe) {
        String m=""String_Node_Str"" + context;
        MessageUtil.abort(handler,m,ex.fromErrPipe);
        doneFlag.failed=true;
      }
      doneFlag.done=true;
    }
  }
;
  controller.init(command,spec.className);
  if (null != spec.forkSpec.javaHome) {
    controller.setEnvp(new String[]{""String_Node_Str"" + spec.forkSpec.javaHome});
  }
  commandLabel.append(Arrays.asList(controller.getCommand()).toString());
  final ByteArrayOutputStream errSnoop=new ByteArrayOutputStream();
  final ByteArrayOutputStream outSnoop=new ByteArrayOutputStream();
  controller.setErrSnoop(errSnoop);
  controller.setOutSnoop(outSnoop);
  controller.start();
  long maxTime=System.currentTimeMillis() + 3 * 60 * 1000;
  boolean waitingForStop=false;
  while (!doneFlag.done) {
    if (maxTime < System.currentTimeMillis()) {
      if (waitingForStop) {
        break;
      }
      MessageUtil.fail(status,""String_Node_Str"");
      doneFlag.failed=true;
      controller.stop();
      waitingForStop=true;
      maxTime=System.currentTimeMillis() + 1 * 60 * 1000;
    }
    try {
      Thread.sleep(300);
    }
 catch (    InterruptedException e) {
    }
  }
  boolean foundException=false;
  if (0 < errSnoop.size()) {
    if (expectedException(errSnoop)) {
      foundException=true;
    }
 else     if (spec.errStreamIsError) {
      MessageUtil.error(handler,errSnoop.toString());
      if (!doneFlag.failed) {
        doneFlag.failed=true;
      }
    }
 else {
      MessageUtil.info(handler,""String_Node_Str"" + errSnoop.toString());
    }
  }
  if (0 < outSnoop.size()) {
    if (expectedException(outSnoop)) {
      foundException=true;
    }
 else     if (spec.outStreamIsError) {
      MessageUtil.error(handler,outSnoop.toString());
      if (!doneFlag.failed) {
        doneFlag.failed=true;
      }
    }
 else {
      MessageUtil.info(handler,""String_Node_Str"" + outSnoop.toString());
    }
  }
  if (!foundException) {
    if (null != spec.expectedException) {
      String m=""String_Node_Str"" + spec.expectedException;
      MessageUtil.fail(handler,m);
      doneFlag.failed=true;
    }
 else     if (0 != doneFlag.code) {
      String m=doneFlag.code + ""String_Node_Str"" + commandLabel;
      MessageUtil.fail(handler,m);
      doneFlag.failed=true;
    }
  }
  if (doneFlag.failed) {
    MessageUtil.info(handler,""String_Node_Str"" + commandLabel);
  }
  return !doneFlag.failed;
}","/** 
 * Run in another VM by grabbing Java, bootclasspath, classpath, etc. This assumes any exception or output to System.err is a failure, and any normal completion is a pass.
 * @param status
 * @param libs
 * @param dirs
 * @return
 */
protected boolean runInOtherVM(IRunStatus status,File[] libs,File[] dirs){
  ArrayList cmd=new ArrayList();
  cmd.add(FileUtil.getBestPath(spec.forkSpec.java));
  if (!LangUtil.isEmpty(spec.forkSpec.vmargs)) {
    cmd.addAll(Arrays.asList(spec.forkSpec.vmargs));
  }
  final String classpath;
{
    StringBuffer cp=new StringBuffer();
    appendClasspath(cp,spec.forkSpec.bootclasspath);
    appendClasspath(cp,dirs);
    appendClasspath(cp,libs);
    File[] classpathFiles=sandbox.findFiles(spec.classpath);
    int cpLength=(null == classpathFiles ? 0 : classpathFiles.length);
    int spLength=(null == spec.classpath ? 0 : spec.classpath.length);
    if (cpLength != spLength) {
      throw new Error(""String_Node_Str"" + Arrays.asList(spec.classpath) + ""String_Node_Str""+ Arrays.asList(classpathFiles));
    }
    appendClasspath(cp,classpathFiles);
    File[] stdlibs={Globals.F_aspectjrt_jar,Globals.F_testingclient_jar};
    appendClasspath(cp,stdlibs);
    classpath=cp.toString();
  }
  if (!spec.isLTW()) {
    cmd.add(""String_Node_Str"");
    cmd.add(classpath);
  }
 else {
    if (!Globals.supportsJava(""String_Node_Str"")) {
      throw new Error(""String_Node_Str"");
    }
    cmd.add(""String_Node_Str"");
    cmd.add(""String_Node_Str"");
    cmd.add(System.getProperty(""String_Node_Str""));
    File[] aspectJars=sandbox.findFiles(spec.aspectpath);
    if (aspectJars.length != spec.aspectpath.length) {
      throw new Error(""String_Node_Str"" + Arrays.asList(spec.aspectpath));
    }
    StringBuffer cp=new StringBuffer();
    appendClasspath(cp,aspectJars);
    cmd.add(""String_Node_Str"" + cp.toString());
    cp.append(classpath);
    cmd.add(""String_Node_Str"" + cp.toString());
  }
  cmd.add(spec.className);
  cmd.addAll(spec.options);
  String[] command=(String[])cmd.toArray(new String[0]);
  final IMessageHandler handler=status;
class DoneFlag {
    boolean done;
    boolean failed;
    int code;
  }
  final StringBuffer commandLabel=new StringBuffer();
  final DoneFlag doneFlag=new DoneFlag();
  LangUtil.ProcessController controller=new LangUtil.ProcessController(){
    protected void doCompleting(    Thrown ex,    int result){
      if (!ex.thrown && (0 == result)) {
        doneFlag.done=true;
        return;
      }
      String context=spec.className + ""String_Node_Str"" + commandLabel+ ""String_Node_Str"";
      if (null != ex.fromProcess) {
        if (!expectedException(ex.fromProcess)) {
          String m=""String_Node_Str"" + context;
          MessageUtil.abort(handler,m,ex.fromProcess);
          doneFlag.failed=true;
        }
      }
 else       if (0 != result) {
        doneFlag.code=result;
      }
      if (null != ex.fromInPipe) {
        String m=""String_Node_Str"" + context;
        MessageUtil.abort(handler,m,ex.fromInPipe);
        doneFlag.failed=true;
      }
      if (null != ex.fromOutPipe) {
        String m=""String_Node_Str"" + context;
        MessageUtil.abort(handler,m,ex.fromOutPipe);
        doneFlag.failed=true;
      }
      if (null != ex.fromErrPipe) {
        String m=""String_Node_Str"" + context;
        MessageUtil.abort(handler,m,ex.fromErrPipe);
        doneFlag.failed=true;
      }
      doneFlag.done=true;
    }
  }
;
  controller.init(command,spec.className);
  if (null != spec.forkSpec.javaHome) {
    controller.setEnvp(new String[]{""String_Node_Str"" + spec.forkSpec.javaHome});
  }
  commandLabel.append(Arrays.asList(controller.getCommand()).toString());
  final ByteArrayOutputStream errSnoop=new ByteArrayOutputStream();
  final ByteArrayOutputStream outSnoop=new ByteArrayOutputStream();
  controller.setErrSnoop(errSnoop);
  controller.setOutSnoop(outSnoop);
  controller.start();
  long maxTime=System.currentTimeMillis() + 3 * 60 * 1000;
  boolean waitingForStop=false;
  while (!doneFlag.done) {
    if (maxTime < System.currentTimeMillis()) {
      if (waitingForStop) {
        break;
      }
      MessageUtil.fail(status,""String_Node_Str"");
      doneFlag.failed=true;
      controller.stop();
      waitingForStop=true;
      maxTime=System.currentTimeMillis() + 1 * 60 * 1000;
    }
    try {
      Thread.sleep(300);
    }
 catch (    InterruptedException e) {
    }
  }
  boolean foundException=false;
  if (0 < errSnoop.size()) {
    if (expectedException(errSnoop)) {
      foundException=true;
    }
 else     if (spec.errStreamIsError) {
      MessageUtil.error(handler,errSnoop.toString());
      if (!doneFlag.failed) {
        doneFlag.failed=true;
      }
    }
 else {
      MessageUtil.info(handler,""String_Node_Str"" + errSnoop.toString());
    }
  }
  if (0 < outSnoop.size()) {
    if (expectedException(outSnoop)) {
      foundException=true;
    }
 else     if (spec.outStreamIsError) {
      MessageUtil.error(handler,outSnoop.toString());
      if (!doneFlag.failed) {
        doneFlag.failed=true;
      }
    }
 else {
      MessageUtil.info(handler,""String_Node_Str"" + outSnoop.toString());
    }
  }
  if (!foundException) {
    if (null != spec.expectedException) {
      String m=""String_Node_Str"" + spec.expectedException;
      MessageUtil.fail(handler,m);
      doneFlag.failed=true;
    }
 else     if (0 != doneFlag.code) {
      String m=doneFlag.code + ""String_Node_Str"" + commandLabel;
      MessageUtil.fail(handler,m);
      doneFlag.failed=true;
    }
  }
  if (doneFlag.failed) {
    MessageUtil.info(handler,""String_Node_Str"" + commandLabel);
  }
  return !doneFlag.failed;
}",0.9986736227783182
9150,"/** 
 * @param version ""1.1"", ""1.2"", ""1.3"", ""1.4""
 * @throws IllegalArgumentException if version is not recognized
 */
public void setJavaVersion(String version){
  LangUtil.supportsJava(version);
  this.javaVersion=version;
}","/** 
 * @param version ""1.1"", ""1.2"", ""1.3"", ""1.4""
 * @throws IllegalArgumentException if version is not recognized
 */
public void setJavaVersion(String version){
  Globals.supportsJava(version);
  this.javaVersion=version;
}",0.966740576496674
9151,"/** 
 * Creates a (potentially recursive) tree of node by reading from the file and constructing using the maker. Clients may read results in Node tree form when complete or snoop the selector for a list of objects made. The selector can prevent collection in the node by returning false. Results are guaranteed by the Maker to be of the Maker's type.
 * @param file an absolute path to a structured file
 * @param selector determines whether not to keep an object made.(if null, then all are kept)
 * @return Node with objects available from getItems()and sub-suite Node available from getNodes()
 * @throws Error on any read error if abortOnReadError (default)
 */
public Node readNodes(final File file,final ObjectChecker selector,final boolean abortOnReadError,final PrintStream err) throws IOException {
  final Node result=new Node(file.getPath(),maker.getType());
  if (null == file) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else   if (!file.isAbsolute()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  LineReader reader=null;
  try {
    reader=LineReader.createTester(file);
    if (null == reader) {
      throw new IOException(""String_Node_Str"" + file);
    }
    final String baseDir=file.getParent();
    String line;
    boolean skipEmpties=true;
    while (null != (line=reader.nextLine(skipEmpties))) {
      if (line.charAt(0) == '@') {
        if (line.length() > 1) {
          String newFilePath=line.substring(1).trim();
          File newFile=new File(newFilePath);
          if (!newFile.isAbsolute()) {
            newFile=new File(baseDir,newFilePath);
          }
          Node node=readNodes(newFile,selector,abortOnReadError,err);
          if (!result.addNode(node)) {
            System.err.println(""String_Node_Str"" + node);
            break;
          }
        }
      }
 else {
        try {
          Object made=maker.make(reader);
          if ((null == selector) || (selector.isValid(made))) {
            if (!result.add(made)) {
              break;
            }
          }
        }
 catch (        AbortException e) {
          if (abortOnReadError) {
            throw e;
          }
          if (null != err) {
            String m;
            IMessage mssg=e.getIMessage();
            if (null != mssg) {
              m=""String_Node_Str"" + mssg;
            }
 else {
              m=LangUtil.unqualifiedClassName(e) + ""String_Node_Str"" + e.getMessage();
            }
            err.println(m);
          }
          reader.readToBlankLine();
        }
      }
    }
  }
  finally {
    try {
      if (null != reader) {
        reader.close();
      }
    }
 catch (    IOException e) {
    }
  }
  return result;
}","/** 
 * Creates a (potentially recursive) tree of node by reading from the file and constructing using the maker. Clients may read results in Node tree form when complete or snoop the selector for a list of objects made. The selector can prevent collection in the node by returning false. Results are guaranteed by the Maker to be of the Maker's type.
 * @param file an absolute path to a structured file
 * @param selector determines whether not to keep an object made.(if null, then all are kept)
 * @return Node with objects available from getItems()and sub-suite Node available from getNodes()
 * @throws Error on any read error if abortOnReadError (default)
 */
public Node readNodes(final File file,final ObjectChecker selector,final boolean abortOnReadError,final PrintStream err) throws IOException {
  final Node result=new Node(file.getPath(),maker.getType());
  if (null == file) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else   if (!file.isAbsolute()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  UtilLineReader reader=null;
  try {
    reader=UtilLineReader.createTester(file);
    if (null == reader) {
      throw new IOException(""String_Node_Str"" + file);
    }
    final String baseDir=file.getParent();
    String line;
    boolean skipEmpties=true;
    while (null != (line=reader.nextLine(skipEmpties))) {
      if (line.charAt(0) == '@') {
        if (line.length() > 1) {
          String newFilePath=line.substring(1).trim();
          File newFile=new File(newFilePath);
          if (!newFile.isAbsolute()) {
            newFile=new File(baseDir,newFilePath);
          }
          Node node=readNodes(newFile,selector,abortOnReadError,err);
          if (!result.addNode(node)) {
            System.err.println(""String_Node_Str"" + node);
            break;
          }
        }
      }
 else {
        try {
          Object made=maker.make(reader);
          if ((null == selector) || (selector.isValid(made))) {
            if (!result.add(made)) {
              break;
            }
          }
        }
 catch (        AbortException e) {
          if (abortOnReadError) {
            throw e;
          }
          if (null != err) {
            String m;
            IMessage mssg=e.getIMessage();
            if (null != mssg) {
              m=""String_Node_Str"" + mssg;
            }
 else {
              m=LangUtil.unqualifiedClassName(e) + ""String_Node_Str"" + e.getMessage();
            }
            err.println(m);
          }
          reader.readToBlankLine();
        }
      }
    }
  }
  finally {
    try {
      if (null != reader) {
        reader.close();
      }
    }
 catch (    IOException e) {
    }
  }
  return result;
}",0.998529411764706
9152,"public Object make(LineReader reader){
  return reader + ""String_Node_Str"" + reader.lastLine();
}","public Object make(UtilLineReader reader){
  return reader + ""String_Node_Str"" + reader.lastLine();
}",0.9797979797979798
9153,"/** 
 * @param buildFresh - true if want to force a full build, false otherwise
 */
public void doBuild(boolean buildFresh){
  if (!buildFresh) {
    buildFresh=updateAsmManagerInformation();
  }
  try {
    startNotifiers();
    handleMessage(new Message(getFormattedOptionsString(),IMessage.INFO,null,null));
    CompilationAndWeavingContext.reset();
    AjBuildConfig buildConfig=genAjBuildConfig();
    if (buildConfig == null)     return;
    if (buildFresh) {
      ajBuildManager.batchBuild(buildConfig,msgHandlerAdapter);
    }
 else {
      ajBuildManager.incrementalBuild(buildConfig,msgHandlerAdapter);
    }
    IncrementalStateManager.recordSuccessfulBuild(compiler.getId(),ajBuildManager.getState());
  }
 catch (  ConfigParser.ParseException pe) {
    handleMessage(new Message(""String_Node_Str"" + pe.getFile().getPath() + ""String_Node_Str""+ pe.getLine(),IMessage.WARNING,null,null));
  }
catch (  AbortException e) {
    final IMessage message=e.getIMessage();
    if (message == null) {
      handleMessage(new Message(LangUtil.unqualifiedClassName(e) + ""String_Node_Str"" + e.getMessage(),IMessage.ERROR,e,null));
    }
 else {
      handleMessage(new Message(message.getMessage() + ""String_Node_Str"" + CompilationAndWeavingContext.getCurrentContext(),IMessage.ERROR,e,null));
    }
    ;
  }
catch (  Throwable t) {
    handleMessage(new Message(""String_Node_Str"" + LangUtil.unqualifiedClassName(t) + ""String_Node_Str""+ ""String_Node_Str""+ t.getMessage(),IMessage.ABORT,t,null));
  }
 finally {
    compiler.getBuildProgressMonitor().finish(ajBuildManager.wasFullBuild());
  }
}","/** 
 * @param buildFresh - true if want to force a full build, false otherwise
 */
public void doBuild(boolean buildFresh){
  if (!buildFresh) {
    buildFresh=updateAsmManagerInformation();
  }
  try {
    startNotifiers();
    handleMessage(new Message(getFormattedOptionsString(),IMessage.INFO,null,null));
    CompilationAndWeavingContext.reset();
    AjBuildConfig buildConfig=genAjBuildConfig();
    if (buildConfig == null)     return;
    if (buildFresh) {
      ajBuildManager.batchBuild(buildConfig,msgHandlerAdapter);
    }
 else {
      ajBuildManager.incrementalBuild(buildConfig,msgHandlerAdapter);
    }
    IncrementalStateManager.recordSuccessfulBuild(compiler.getId(),ajBuildManager.getState());
  }
 catch (  ConfigParser.ParseException pe) {
    handleMessage(new Message(""String_Node_Str"" + pe.getFile().getPath() + ""String_Node_Str""+ pe.getLine(),IMessage.WARNING,null,null));
  }
catch (  AbortException e) {
    final IMessage message=e.getIMessage();
    if (message == null) {
      handleMessage(new Message(LangUtil.unqualifiedClassName(e) + ""String_Node_Str"" + e.getMessage(),IMessage.ERROR,e,null));
    }
 else {
      handleMessage(new Message(message.getMessage() + ""String_Node_Str"" + CompilationAndWeavingContext.getCurrentContext(),IMessage.ERROR,e,null));
    }
  }
catch (  Throwable t) {
    handleMessage(new Message(""String_Node_Str"" + LangUtil.unqualifiedClassName(t) + ""String_Node_Str""+ ""String_Node_Str""+ t.getMessage(),IMessage.ABORT,t,null));
  }
 finally {
    compiler.getBuildProgressMonitor().finish(ajBuildManager.wasFullBuild());
  }
}",0.9981155778894472
9154,"public void testDeclareMessageContents(){
  List msgs=handler.getMessages();
  IMessage msg=(IMessage)((TestMessageHandler.TestMessage)msgs.get(1)).getContainedMessage();
  assertEquals(""String_Node_Str"",msg.getMessage());
  assertEquals(""String_Node_Str"",msg.getDetails());
}","public void testDeclareMessageContents(){
  List msgs=handler.getMessages();
  IMessage msg=((TestMessageHandler.TestMessage)msgs.get(1)).getContainedMessage();
  assertEquals(""String_Node_Str"",msg.getMessage());
  assertEquals(""String_Node_Str"",msg.getDetails());
}",0.981549815498155
9155,"protected void setUp() throws Exception {
  super.setUp();
  initialiseProject(PROJECT_DIR);
  handler=(TestMessageHandler)getCompiler().getMessageHandler();
  compilerConfig=(TestCompilerConfiguration)getCompiler().getCompilerConfiguration();
  testProps=getAbsoluteProjectDir() + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str"";
}","protected void setUp() throws Exception {
  super.setUp();
  initialiseProject(PROJECT_DIR);
  handler=(TestMessageHandler)getCompiler().getMessageHandler();
  compilerConfig=(TestCompilerConfiguration)getCompiler().getCompilerConfiguration();
}",0.7728706624605678
9156,"public void testRoot(){
  IProgramElement root=(IProgramElement)model.getRoot();
  assertNotNull(root);
  assertEquals(""String_Node_Str"" + root.toLabelString(),root.toLabelString(),""String_Node_Str"");
}","public void testRoot(){
  IProgramElement root=model.getRoot();
  assertNotNull(root);
  assertEquals(""String_Node_Str"" + root.toLabelString(),root.toLabelString(),""String_Node_Str"");
}",0.9560723514211886
9157,"protected void setUp() throws Exception {
  super.setUp();
  initialiseProject(""String_Node_Str"");
  handler=(TestMessageHandler)getCompiler().getMessageHandler();
  compilerConfig=(TestCompilerConfiguration)getCompiler().getCompilerConfiguration();
  compilerConfig.setProjectSourceFiles(getSourceFileList(files));
  doBuild();
  model=AsmManager.getDefault().getHierarchy();
}","protected void setUp() throws Exception {
  super.setUp();
  initialiseProject(""String_Node_Str"");
  compilerConfig=(TestCompilerConfiguration)getCompiler().getCompilerConfiguration();
  compilerConfig.setProjectSourceFiles(getSourceFileList(files));
  doBuild();
  model=AsmManager.getDefault().getHierarchy();
}",0.9059334298118668
9158,"public void testAbstract(){
  IProgramElement node=(IProgramElement)model.getRoot();
  assertNotNull(node);
  IProgramElement aspect=AsmManager.getDefault().getHierarchy().findElementForType(null,""String_Node_Str"");
  assertNotNull(aspect);
  String abst=""String_Node_Str"";
  IProgramElement abstNode=model.findElementForSignature(aspect,IProgramElement.Kind.POINTCUT,abst);
  assertNotNull(abstNode);
  assertEquals(abstNode.toLabelString(),abst);
}","public void testAbstract(){
  IProgramElement node=model.getRoot();
  assertNotNull(node);
  IProgramElement aspect=AsmManager.getDefault().getHierarchy().findElementForType(null,""String_Node_Str"");
  assertNotNull(aspect);
  String abst=""String_Node_Str"";
  IProgramElement abstNode=model.findElementForSignature(aspect,IProgramElement.Kind.POINTCUT,abst);
  assertNotNull(abstNode);
  assertEquals(abstNode.toLabelString(),abst);
}",0.9807474518686295
9159,"public void testInterTypeMemberDeclares(){
  IProgramElement node=(IProgramElement)model.getRoot();
  assertNotNull(node);
  IProgramElement aspect=AsmManager.getDefault().getHierarchy().findElementForType(null,""String_Node_Str"");
  assertNotNull(aspect);
  String fieldMsg=""String_Node_Str"";
  IProgramElement fieldNode=model.findElementForLabel(aspect,IProgramElement.Kind.INTER_TYPE_FIELD,fieldMsg);
  assertNotNull(fieldNode);
  assertEquals(fieldNode.toLabelString(),fieldMsg);
  String methodMsg=""String_Node_Str"";
  IProgramElement methodNode=model.findElementForLabel(aspect,IProgramElement.Kind.INTER_TYPE_METHOD,methodMsg);
  assertNotNull(methodNode);
  assertEquals(methodNode.toLabelString(),methodMsg);
}","public void testInterTypeMemberDeclares(){
  IProgramElement node=model.getRoot();
  assertNotNull(node);
  IProgramElement aspect=AsmManager.getDefault().getHierarchy().findElementForType(null,""String_Node_Str"");
  assertNotNull(aspect);
  String fieldMsg=""String_Node_Str"";
  IProgramElement fieldNode=model.findElementForLabel(aspect,IProgramElement.Kind.INTER_TYPE_FIELD,fieldMsg);
  assertNotNull(fieldNode);
  assertEquals(fieldNode.toLabelString(),fieldMsg);
  String methodMsg=""String_Node_Str"";
  IProgramElement methodNode=model.findElementForLabel(aspect,IProgramElement.Kind.INTER_TYPE_METHOD,methodMsg);
  assertNotNull(methodNode);
  assertEquals(methodNode.toLabelString(),methodMsg);
}",0.9880197322057788
9160,"public void testPointcuts(){
  IProgramElement node=(IProgramElement)model.getRoot();
  assertNotNull(node);
  IProgramElement aspect=AsmManager.getDefault().getHierarchy().findElementForType(null,""String_Node_Str"");
  assertNotNull(aspect);
  String ptct=""String_Node_Str"";
  IProgramElement ptctNode=model.findElementForSignature(aspect,IProgramElement.Kind.POINTCUT,ptct);
  assertNotNull(ptctNode);
  assertEquals(ptctNode.toLabelString(),ptct);
  String params=""String_Node_Str"";
  IProgramElement paramsNode=model.findElementForSignature(aspect,IProgramElement.Kind.POINTCUT,params);
  assertNotNull(paramsNode);
  assertEquals(paramsNode.toLabelString(),params);
}","public void testPointcuts(){
  IProgramElement node=model.getRoot();
  assertNotNull(node);
  IProgramElement aspect=AsmManager.getDefault().getHierarchy().findElementForType(null,""String_Node_Str"");
  assertNotNull(aspect);
  String ptct=""String_Node_Str"";
  IProgramElement ptctNode=model.findElementForSignature(aspect,IProgramElement.Kind.POINTCUT,ptct);
  assertNotNull(ptctNode);
  assertEquals(ptctNode.toLabelString(),ptct);
  String params=""String_Node_Str"";
  IProgramElement paramsNode=model.findElementForSignature(aspect,IProgramElement.Kind.POINTCUT,params);
  assertNotNull(paramsNode);
  assertEquals(paramsNode.toLabelString(),params);
}",0.9871698113207548
9161,"protected void tearDown() throws Exception {
  super.tearDown();
  handler=null;
  compilerConfig=null;
  model=null;
}","protected void tearDown() throws Exception {
  super.tearDown();
  compilerConfig=null;
  model=null;
}",0.927927927927928
9162,"public void testAdvice(){
  IProgramElement node=(IProgramElement)model.getRoot();
  assertNotNull(node);
  IProgramElement aspect=AsmManager.getDefault().getHierarchy().findElementForType(null,""String_Node_Str"");
  assertNotNull(aspect);
  String anon=""String_Node_Str"";
  IProgramElement anonNode=model.findElementForLabel(aspect,IProgramElement.Kind.ADVICE,anon);
  assertNotNull(anonNode);
  assertEquals(anonNode.toLabelString(),anon);
  String named=""String_Node_Str"";
  IProgramElement namedNode=model.findElementForLabel(aspect,IProgramElement.Kind.ADVICE,named);
  assertNotNull(namedNode);
  assertEquals(namedNode.toLabelString(),named);
  String namedWithOneArg=""String_Node_Str"";
  IProgramElement namedWithOneArgNode=model.findElementForLabel(aspect,IProgramElement.Kind.ADVICE,namedWithOneArg);
  assertNotNull(namedWithOneArgNode);
  assertEquals(namedWithOneArgNode.toLabelString(),namedWithOneArg);
  String afterReturning=""String_Node_Str"";
  IProgramElement afterReturningNode=model.findElementForLabel(aspect,IProgramElement.Kind.ADVICE,afterReturning);
  assertNotNull(afterReturningNode);
  assertEquals(afterReturningNode.toLabelString(),afterReturning);
  String around=""String_Node_Str"";
  IProgramElement aroundNode=model.findElementForLabel(aspect,IProgramElement.Kind.ADVICE,around);
  assertNotNull(aroundNode);
  assertEquals(aroundNode.toLabelString(),around);
  String compAnon=""String_Node_Str"";
  IProgramElement compAnonNode=model.findElementForLabel(aspect,IProgramElement.Kind.ADVICE,compAnon);
  assertNotNull(compAnonNode);
  assertEquals(compAnonNode.toLabelString(),compAnon);
  String compNamed=""String_Node_Str"";
  IProgramElement compNamedNode=model.findElementForLabel(aspect,IProgramElement.Kind.ADVICE,compNamed);
  assertNotNull(compNamedNode);
  assertEquals(compNamedNode.toLabelString(),compNamed);
}","public void testAdvice(){
  IProgramElement node=model.getRoot();
  assertNotNull(node);
  IProgramElement aspect=AsmManager.getDefault().getHierarchy().findElementForType(null,""String_Node_Str"");
  assertNotNull(aspect);
  String anon=""String_Node_Str"";
  IProgramElement anonNode=model.findElementForLabel(aspect,IProgramElement.Kind.ADVICE,anon);
  assertNotNull(anonNode);
  assertEquals(anonNode.toLabelString(),anon);
  String named=""String_Node_Str"";
  IProgramElement namedNode=model.findElementForLabel(aspect,IProgramElement.Kind.ADVICE,named);
  assertNotNull(namedNode);
  assertEquals(namedNode.toLabelString(),named);
  String namedWithOneArg=""String_Node_Str"";
  IProgramElement namedWithOneArgNode=model.findElementForLabel(aspect,IProgramElement.Kind.ADVICE,namedWithOneArg);
  assertNotNull(namedWithOneArgNode);
  assertEquals(namedWithOneArgNode.toLabelString(),namedWithOneArg);
  String afterReturning=""String_Node_Str"";
  IProgramElement afterReturningNode=model.findElementForLabel(aspect,IProgramElement.Kind.ADVICE,afterReturning);
  assertNotNull(afterReturningNode);
  assertEquals(afterReturningNode.toLabelString(),afterReturning);
  String around=""String_Node_Str"";
  IProgramElement aroundNode=model.findElementForLabel(aspect,IProgramElement.Kind.ADVICE,around);
  assertNotNull(aroundNode);
  assertEquals(aroundNode.toLabelString(),around);
  String compAnon=""String_Node_Str"";
  IProgramElement compAnonNode=model.findElementForLabel(aspect,IProgramElement.Kind.ADVICE,compAnon);
  assertNotNull(compAnonNode);
  assertEquals(compAnonNode.toLabelString(),compAnon);
  String compNamed=""String_Node_Str"";
  IProgramElement compNamedNode=model.findElementForLabel(aspect,IProgramElement.Kind.ADVICE,compNamed);
  assertNotNull(compNamedNode);
  assertEquals(compNamedNode.toLabelString(),compNamed);
}",0.9953892053159752
9163,"protected void setUp() throws Exception {
  super.setUp();
  initialiseProject(""String_Node_Str"");
  handler=(TestMessageHandler)getCompiler().getMessageHandler();
  compilerConfig=(TestCompilerConfiguration)getCompiler().getCompilerConfiguration();
  compilerConfig.setProjectSourceFiles(getSourceFileList(files));
  doBuild();
  manager=AsmManager.getDefault();
}","protected void setUp() throws Exception {
  super.setUp();
  initialiseProject(""String_Node_Str"");
  compilerConfig=(TestCompilerConfiguration)getCompiler().getCompilerConfiguration();
  compilerConfig.setProjectSourceFiles(getSourceFileList(files));
  doBuild();
  manager=AsmManager.getDefault();
}",0.9022556390977444
9164,"protected void tearDown() throws Exception {
  super.tearDown();
  handler=null;
  compilerConfig=null;
  manager=null;
}","protected void tearDown() throws Exception {
  super.tearDown();
  compilerConfig=null;
  manager=null;
}",0.9292035398230089
9165,"public void testPointcutName() throws IOException {
  File testFile=openFile(""String_Node_Str"" + File.separator + ""String_Node_Str"");
  IProgramElement node=manager.getHierarchy().findElementForSourceFile(testFile.getAbsolutePath());
  assertTrue(""String_Node_Str"",node != null);
  IProgramElement pNode=(IProgramElement)((IProgramElement)node).getChildren().get(2);
  IProgramElement pointcut=(IProgramElement)pNode.getChildren().get(0);
  assertTrue(""String_Node_Str"",pointcut.getKind().equals(IProgramElement.Kind.POINTCUT));
  assertTrue(""String_Node_Str"" + pointcut.getName(),pointcut.toLabelString().equals(""String_Node_Str""));
}","public void testPointcutName() throws IOException {
  File testFile=openFile(""String_Node_Str"" + File.separator + ""String_Node_Str"");
  IProgramElement node=manager.getHierarchy().findElementForSourceFile(testFile.getAbsolutePath());
  assertTrue(""String_Node_Str"",node != null);
  IProgramElement pNode=(IProgramElement)(node).getChildren().get(2);
  IProgramElement pointcut=(IProgramElement)pNode.getChildren().get(0);
  assertTrue(""String_Node_Str"",pointcut.getKind().equals(IProgramElement.Kind.POINTCUT));
  assertTrue(""String_Node_Str"" + pointcut.getName(),pointcut.toLabelString().equals(""String_Node_Str""));
}",0.9864325618515564
9166,"public void testFileNodeFind() throws IOException {
  File testFile=openFile(""String_Node_Str"" + File.separator + ""String_Node_Str"");
  IProgramElement node=manager.getHierarchy().findElementForSourceLine(testFile.getAbsolutePath(),1);
  assertTrue(""String_Node_Str"",node != null);
  assertEquals(""String_Node_Str"",3,node.getChildren().size());
  IProgramElement pNode=(IProgramElement)node;
  assertTrue(""String_Node_Str"" + pNode.getName(),pNode.getKind().equals(IProgramElement.Kind.FILE_JAVA));
}","public void testFileNodeFind() throws IOException {
  File testFile=openFile(""String_Node_Str"" + File.separator + ""String_Node_Str"");
  IProgramElement node=manager.getHierarchy().findElementForSourceLine(testFile.getAbsolutePath(),1);
  assertTrue(""String_Node_Str"",node != null);
  assertEquals(""String_Node_Str"",3,node.getChildren().size());
  assertTrue(""String_Node_Str"" + node.getName(),node.getKind().equals(IProgramElement.Kind.FILE_JAVA));
}",0.9441517386722866
9167,"/** 
 * @todo	add negative test to make sure things that aren't runnable aren't annotated
 */
public void testMainClassNodeInfo() throws IOException {
  IHierarchy model=manager.getHierarchy();
  assertTrue(""String_Node_Str"",model != null);
  assertTrue(""String_Node_Str"",model.getRoot() != null);
  File testFile=openFile(""String_Node_Str"" + File.separator + ""String_Node_Str"");
  IProgramElement node=model.findElementForSourceLine(testFile.getAbsolutePath(),11);
  assertTrue(""String_Node_Str"",node != null);
  IProgramElement pNode=(IProgramElement)((IProgramElement)node).getParent();
  if (null == pNode) {
    assertTrue(""String_Node_Str"" + node,false);
  }
  assertTrue(""String_Node_Str"" + pNode.getName(),pNode.isRunnable());
}","/** 
 * @todo	add negative test to make sure things that aren't runnable aren't annotated
 */
public void testMainClassNodeInfo() throws IOException {
  IHierarchy model=manager.getHierarchy();
  assertTrue(""String_Node_Str"",model != null);
  assertTrue(""String_Node_Str"",model.getRoot() != null);
  File testFile=openFile(""String_Node_Str"" + File.separator + ""String_Node_Str"");
  IProgramElement node=model.findElementForSourceLine(testFile.getAbsolutePath(),11);
  assertTrue(""String_Node_Str"",node != null);
  IProgramElement pNode=node.getParent();
  if (null == pNode) {
    assertTrue(""String_Node_Str"" + node,false);
  }
  assertTrue(""String_Node_Str"" + pNode.getName(),pNode.isRunnable());
}",0.9693593314763232
9168,"protected void setUp() throws Exception {
  super.setUp();
  initialiseProject(""String_Node_Str"");
  handler=(TestMessageHandler)getCompiler().getMessageHandler();
  compilerConfig=(TestCompilerConfiguration)getCompiler().getCompilerConfiguration();
  compilerConfig.setProjectSourceFiles(getSourceFileList(files));
  doBuild();
  manager=AsmManager.getDefault();
}","protected void setUp() throws Exception {
  super.setUp();
  initialiseProject(""String_Node_Str"");
  compilerConfig=(TestCompilerConfiguration)getCompiler().getCompilerConfiguration();
  compilerConfig.setProjectSourceFiles(getSourceFileList(files));
  doBuild();
  manager=AsmManager.getDefault();
}",0.9022556390977444
9169,"public void testRootForSourceFile() throws IOException {
  File testFile=openFile(""String_Node_Str"" + File.separator + ""String_Node_Str"");
  IProgramElement node=manager.getHierarchy().findElementForSourceFile(testFile.getAbsolutePath());
  assertTrue(""String_Node_Str"",node != null);
  IProgramElement pNode=(IProgramElement)node;
  String child=((IProgramElement)pNode.getChildren().get(1)).getName();
  assertTrue(""String_Node_Str"" + child,child.equals(""String_Node_Str""));
}","public void testRootForSourceFile() throws IOException {
  File testFile=openFile(""String_Node_Str"" + File.separator + ""String_Node_Str"");
  IProgramElement node=manager.getHierarchy().findElementForSourceFile(testFile.getAbsolutePath());
  assertTrue(""String_Node_Str"",node != null);
  String child=((IProgramElement)node.getChildren().get(1)).getName();
  assertTrue(""String_Node_Str"" + child,child.equals(""String_Node_Str""));
}",0.6828193832599119
9170,"protected void tearDown() throws Exception {
  super.tearDown();
  handler=null;
  compilerConfig=null;
  manager=null;
}","protected void tearDown() throws Exception {
  super.tearDown();
  compilerConfig=null;
  manager=null;
}",0.9292035398230089
9171,"/** 
 * Entry point for a test. This reads in the arguments,  creates the test suite(s) from the input file(s), and for each suite does setup, run, report, and cleanup.  When arguments are read, any option ending with ""-"" causes option variants, a set of args with and another without the option. See   {@link LangUtil.optionVariants(String[])} for more details.
 * @param args the String[] for the test suite - use -help to get options,and use ""-"" suffixes for variants.
 * @param resultList List for IRunStatus results - ignored if null 
 */
public void runMain(String[] args,List resultList){
  LangUtil.throwIaxIfFalse(!LangUtil.isEmpty(args),""String_Node_Str"");
  final ArrayList globals=new ArrayList();
  final ArrayList files=new ArrayList();
  final LinkedList argList=new LinkedList();
  argList.addAll(Arrays.asList(args));
  for (int i=0; i < argList.size(); i++) {
    String arg=(String)argList.get(i);
    List aliases=aliasOptions(arg);
    if (!LangUtil.isEmpty(aliases)) {
      argList.remove(i);
      argList.addAll(i,aliases);
      i--;
      continue;
    }
    if (""String_Node_Str"".equals(arg)) {
      logln(""String_Node_Str"" + Harness.class.getName() + ""String_Node_Str"");
      printSyntax(getLogStream());
      return;
    }
 else     if (isSuiteFile(arg)) {
      files.add(arg);
    }
 else     if (!acceptOption(arg)) {
      globals.add(arg);
    }
  }
  if (0 == files.size()) {
    logln(""String_Node_Str"");
    logln(""String_Node_Str"" + Harness.class.getName() + ""String_Node_Str"");
    printSyntax(getLogStream());
    return;
  }
  String[] globalOptions=(String[])globals.toArray(new String[0]);
  String[][] globalOptionVariants=LangUtil.optionVariants(globalOptions);
  AbstractRunSpec.RT runtime=new AbstractRunSpec.RT();
  if (verboseHarness) {
    runtime.setVerbose(true);
  }
  AjcTest.Suite.Spec spec;
  for (Iterator iter=files.iterator(); iter.hasNext(); ) {
    File suiteFile=new File((String)iter.next());
    if (!suiteFile.canRead()) {
      logln(""String_Node_Str"" + suiteFile);
      continue;
    }
    if (null == (spec=readSuite(suiteFile))) {
      logln(""String_Node_Str"" + suiteFile);
      continue;
    }
    MessageHandler holder=new MessageHandler();
    for (int i=0; i < globalOptionVariants.length; i++) {
      runtime.setOptions(globalOptionVariants[i]);
      holder.init();
      boolean skip=!spec.adoptParentValues(runtime,holder);
      final List skipList=MessageUtil.getMessages(holder,IMessage.INFO,false,""String_Node_Str"");
      if ((verboseHarness || skip || (0 < skipList.size()))) {
        final List curArgs=Arrays.asList(globalOptionVariants[i]);
        logln(""String_Node_Str"" + suiteFile + ""String_Node_Str""+ curArgs+ ""String_Node_Str"");
        if (verboseHarness) {
          String format=""String_Node_Str"";
          SimpleDateFormat formatter=new SimpleDateFormat(format);
          String date=formatter.format(new Date());
          logln(""String_Node_Str"" + date);
          logln(""String_Node_Str"" + listFeatureNames());
          logln(""String_Node_Str"" + JAVA_VERSION);
          logln(""String_Node_Str"" + ASPECTJ_VERSION);
        }
        if (!(quietHarness || silentHarness) && holder.hasAnyMessage(null,true)) {
          MessageUtil.print(getLogStream(),holder,""String_Node_Str"");
          MessageUtil.printMessageCounts(getLogStream(),holder,""String_Node_Str"");
        }
      }
      if (!skip) {
        doStartSuite(suiteFile);
        long elapsed=0;
        RunResult result=null;
        try {
          final long startTime=System.currentTimeMillis();
          result=run(spec);
          if (null != resultList) {
            resultList.add(result);
          }
          elapsed=System.currentTimeMillis() - startTime;
          report(result.status,skipList.size(),result.numIncomplete,elapsed);
        }
  finally {
          doEndSuite(suiteFile,elapsed);
        }
        if (exitOnFailure && (null != result)) {
          int numFailures=RunUtils.numFailures(result.status,true);
          if (0 < numFailures) {
            System.exit(numFailures);
          }
          Object value=result.status.getResult();
          if ((value instanceof Boolean) && !((Boolean)value).booleanValue()) {
            System.exit(-1);
          }
        }
      }
    }
  }
}","/** 
 * Entry point for a test. This reads in the arguments,  creates the test suite(s) from the input file(s), and for each suite does setup, run, report, and cleanup.  When arguments are read, any option ending with ""-"" causes option variants, a set of args with and another without the option. See   {@link LangUtil.optionVariants(String[])} for more details.
 * @param args the String[] for the test suite - use -help to get options,and use ""-"" suffixes for variants.
 * @param resultList List for IRunStatus results - ignored if null 
 */
public void runMain(String[] args,List resultList){
  LangUtil.throwIaxIfFalse(!LangUtil.isEmpty(args),""String_Node_Str"");
  final ArrayList globals=new ArrayList();
  final ArrayList files=new ArrayList();
  final LinkedList argList=new LinkedList();
  argList.addAll(Arrays.asList(args));
  for (int i=0; i < argList.size(); i++) {
    String arg=(String)argList.get(i);
    List aliases=aliasOptions(arg);
    if (!LangUtil.isEmpty(aliases)) {
      argList.remove(i);
      argList.addAll(i,aliases);
      i--;
      continue;
    }
    if (""String_Node_Str"".equals(arg)) {
      logln(""String_Node_Str"" + Harness.class.getName() + ""String_Node_Str"");
      printSyntax(getLogStream());
      return;
    }
 else     if (isSuiteFile(arg)) {
      files.add(arg);
    }
 else     if (!acceptOption(arg)) {
      globals.add(arg);
    }
  }
  if (0 == files.size()) {
    logln(""String_Node_Str"");
    logln(""String_Node_Str"" + Harness.class.getName() + ""String_Node_Str"");
    printSyntax(getLogStream());
    return;
  }
  String[] globalOptions=(String[])globals.toArray(new String[0]);
  String[][] globalOptionVariants=optionVariants(globalOptions);
  AbstractRunSpec.RT runtime=new AbstractRunSpec.RT();
  if (verboseHarness) {
    runtime.setVerbose(true);
  }
  AjcTest.Suite.Spec spec;
  for (Iterator iter=files.iterator(); iter.hasNext(); ) {
    File suiteFile=new File((String)iter.next());
    if (!suiteFile.canRead()) {
      logln(""String_Node_Str"" + suiteFile);
      continue;
    }
    if (null == (spec=readSuite(suiteFile))) {
      logln(""String_Node_Str"" + suiteFile);
      continue;
    }
    MessageHandler holder=new MessageHandler();
    for (int i=0; i < globalOptionVariants.length; i++) {
      runtime.setOptions(globalOptionVariants[i]);
      holder.init();
      boolean skip=!spec.adoptParentValues(runtime,holder);
      final List skipList=MessageUtil.getMessages(holder,IMessage.INFO,false,""String_Node_Str"");
      if ((verboseHarness || skip || (0 < skipList.size()))) {
        final List curArgs=Arrays.asList(globalOptionVariants[i]);
        logln(""String_Node_Str"" + suiteFile + ""String_Node_Str""+ curArgs+ ""String_Node_Str"");
        if (verboseHarness) {
          String format=""String_Node_Str"";
          SimpleDateFormat formatter=new SimpleDateFormat(format);
          String date=formatter.format(new Date());
          logln(""String_Node_Str"" + date);
          logln(""String_Node_Str"" + listFeatureNames());
          logln(""String_Node_Str"" + JAVA_VERSION);
          logln(""String_Node_Str"" + ASPECTJ_VERSION);
        }
        if (!(quietHarness || silentHarness) && holder.hasAnyMessage(null,true)) {
          MessageUtil.print(getLogStream(),holder,""String_Node_Str"");
          MessageUtil.printMessageCounts(getLogStream(),holder,""String_Node_Str"");
        }
      }
      if (!skip) {
        doStartSuite(suiteFile);
        long elapsed=0;
        RunResult result=null;
        try {
          final long startTime=System.currentTimeMillis();
          result=run(spec);
          if (null != resultList) {
            resultList.add(result);
          }
          elapsed=System.currentTimeMillis() - startTime;
          report(result.status,skipList.size(),result.numIncomplete,elapsed);
        }
  finally {
          doEndSuite(suiteFile,elapsed);
        }
        if (exitOnFailure) {
          int numFailures=RunUtils.numFailures(result.status,true);
          if (0 < numFailures) {
            System.exit(numFailures);
          }
          Object value=result.status.getResult();
          if ((value instanceof Boolean) && !((Boolean)value).booleanValue()) {
            System.exit(-1);
          }
        }
      }
    }
  }
}",0.9966101694915256
9172,"protected void doStartSuite(File suite){
  super.doStartSuite(suite);
  this.suite=suite;
  numTests=0;
  numFails=0;
  junitOutput=new StringBuffer();
}","protected void doStartSuite(File suite){
  super.doStartSuite(suite);
  numTests=0;
  numFails=0;
  junitOutput=new StringBuffer();
}",0.93006993006993
9173,"private SpecTests(AjctestsAdapter ajctestsAdapter,AjcTest.Spec[] tests){
  mAjctestsAdapter=ajctestsAdapter;
  Map map=new HashMap();
  for (int i=0; i < tests.length; i++) {
    map.put(tests[i].getDescription(),tests[i]);
  }
  ;
  mDescriptionToAjcTestSpec=Collections.unmodifiableMap(map);
}","private SpecTests(AjctestsAdapter ajctestsAdapter,AjcTest.Spec[] tests){
  mAjctestsAdapter=ajctestsAdapter;
  Map map=new HashMap();
  for (int i=0; i < tests.length; i++) {
    map.put(tests[i].getDescription(),tests[i]);
  }
  mDescriptionToAjcTestSpec=Collections.unmodifiableMap(map);
}",0.9931740614334472
9174,"/** 
 * Factory to make and populate suite
 * @param suitePath the String path to a harness suite file
 * @param options the String[] options to use when creating tests
 * @return AjctestJUnitSuite populated with tests
 */
public static AjctestsAdapter make(String suitePath,String[] options){
  AjctestsAdapter result=new AjctestsAdapter(suitePath,options);
  AjcTest.Spec[] tests=AjcTest.Suite.getTests(result.getSpec());
  if (VERBOSE) {
    log(""String_Node_Str"" + tests.length + ""String_Node_Str""+ suitePath);
  }
  for (int i=0; i < tests.length; i++) {
    AjcTest.Spec ajcTest=(AjcTest.Spec)tests[i];
    result.addTest(new AjcTestSpecAsTest(ajcTest,result));
  }
  return result;
}","/** 
 * Factory to make and populate suite
 * @param suitePath the String path to a harness suite file
 * @param options the String[] options to use when creating tests
 * @return AjctestJUnitSuite populated with tests
 */
public static AjctestsAdapter make(String suitePath,String[] options){
  AjctestsAdapter result=new AjctestsAdapter(suitePath,options);
  AjcTest.Spec[] tests=AjcTest.Suite.getTests(result.getSpec());
  if (VERBOSE) {
    log(""String_Node_Str"" + tests.length + ""String_Node_Str""+ suitePath);
  }
  for (int i=0; i < tests.length; i++) {
    AjcTest.Spec ajcTest=tests[i];
    result.addTest(new AjcTestSpecAsTest(ajcTest,result));
  }
  return result;
}",0.9897510980966324
9175,"/** 
 * Report results as error, failure, or success (ignored), differently if result is null
 * @param description the String description of the result
 * @param isError if true, report as failure
 * @param isFailure if true and not isError, report as failure
 * @param test the Test case
 * @param result the TestResult sink - ignored if null
 * @return 0
 */
private static int reportResultToJUnit(String description,boolean isError,boolean isFailure,Test test,TestResult result){
  if (null != result) {
    if (isError) {
      result.addError(test,new AssertionFailedError(description));
    }
 else     if (isFailure) {
      result.addFailure(test,new AssertionFailedError(description));
    }
  }
 else {
    if (isError) {
      String m=safeTestName(test) + ""String_Node_Str"" + description;
      throw new Error(m);
    }
 else     if (isFailure) {
      String m=safeTestName(test) + ""String_Node_Str"" + description;
      throw new AssertionFailedError(description);
    }
  }
  return 0;
}","/** 
 * Report results as error, failure, or success (ignored), differently if result is null
 * @param description the String description of the result
 * @param isError if true, report as failure
 * @param isFailure if true and not isError, report as failure
 * @param test the Test case
 * @param result the TestResult sink - ignored if null
 * @return 0
 */
private static int reportResultToJUnit(String description,boolean isError,boolean isFailure,Test test,TestResult result){
  if (null != result) {
    if (isError) {
      result.addError(test,new AssertionFailedError(description));
    }
 else     if (isFailure) {
      result.addFailure(test,new AssertionFailedError(description));
    }
  }
 else {
    if (isError) {
      String m=safeTestName(test) + ""String_Node_Str"" + description;
      throw new Error(m);
    }
 else     if (isFailure) {
      throw new AssertionFailedError(description);
    }
  }
  return 0;
}",0.964414646725116
9176,"protected UnresolvedType parameterize(UnresolvedType aType,Map typeVariableMap,boolean inParameterizedType,World w){
  if (aType instanceof TypeVariableReference) {
    String variableName=((TypeVariableReference)aType).getTypeVariable().getName();
    if (!typeVariableMap.containsKey(variableName)) {
      return aType;
    }
    return (UnresolvedType)typeVariableMap.get(variableName);
  }
 else   if (aType.isParameterizedType()) {
    if (inParameterizedType) {
      if (aType instanceof UnresolvedType) {
        if (w != null)         aType=aType.resolve(w);
 else {
          aType=aType.resolve(((ResolvedType)getDeclaringType()).getWorld());
        }
      }
      return aType.parameterize(typeVariableMap);
    }
 else {
      return aType.getRawType();
    }
  }
 else   if (aType.isArray()) {
    int dims=1;
    String sig=aType.getSignature();
    while (sig.charAt(dims) == '[')     dims++;
    UnresolvedType componentSig=UnresolvedType.forSignature(sig.substring(dims));
    UnresolvedType arrayType=ResolvedType.makeArray(parameterize(componentSig,typeVariableMap,inParameterizedType),dims);
    return arrayType;
  }
  return aType;
}","protected UnresolvedType parameterize(UnresolvedType aType,Map typeVariableMap,boolean inParameterizedType,World w){
  if (aType instanceof TypeVariableReference) {
    String variableName=((TypeVariableReference)aType).getTypeVariable().getName();
    if (!typeVariableMap.containsKey(variableName)) {
      return aType;
    }
    return (UnresolvedType)typeVariableMap.get(variableName);
  }
 else   if (aType.isParameterizedType()) {
    if (inParameterizedType) {
      if (w != null)       aType=aType.resolve(w);
 else {
        aType=aType.resolve(((ResolvedType)getDeclaringType()).getWorld());
      }
      return aType.parameterize(typeVariableMap);
    }
 else {
      return aType.getRawType();
    }
  }
 else   if (aType.isArray()) {
    int dims=1;
    String sig=aType.getSignature();
    while (sig.charAt(dims) == '[')     dims++;
    UnresolvedType componentSig=UnresolvedType.forSignature(sig.substring(dims));
    UnresolvedType arrayType=ResolvedType.makeArray(parameterize(componentSig,typeVariableMap,inParameterizedType),dims);
    return arrayType;
  }
  return aType;
}",0.972972972972973
9177,"/** 
 * Replace occurrences of type variables in the signature with values contained in the map.  The map is of the form A=String,B=Integer and so a signature List<A> Foo.m(B i) {} would become List<String> Foo.m(Integer i) {}
 */
public ResolvedMember parameterizedWith(Map m,World w){
  declaringType=declaringType.resolve(w);
  if (declaringType.isRawType())   declaringType=((ResolvedType)declaringType).getGenericType();
  TypeVariable[] typeVariables=getDeclaringType().getTypeVariables();
  UnresolvedType parameterizedReturnType=parameterize(getGenericReturnType(),m,true,w);
  UnresolvedType[] parameterizedParameterTypes=new UnresolvedType[getGenericParameterTypes().length];
  UnresolvedType[] genericParameterTypes=getGenericParameterTypes();
  for (int i=0; i < parameterizedParameterTypes.length; i++) {
    parameterizedParameterTypes[i]=parameterize(genericParameterTypes[i],m,true,w);
  }
  ResolvedMemberImpl ret=new ResolvedMemberImpl(getKind(),declaringType,getModifiers(),parameterizedReturnType,getName(),parameterizedParameterTypes,getExceptions(),this);
  ret.setTypeVariables(getTypeVariables());
  ret.setSourceContext(getSourceContext());
  ret.setPosition(getStart(),getEnd());
  ret.setParameterNames(getParameterNames());
  return ret;
}","/** 
 * Replace occurrences of type variables in the signature with values contained in the map.  The map is of the form A=String,B=Integer and so a signature List<A> Foo.m(B i) {} would become List<String> Foo.m(Integer i) {}
 */
public ResolvedMember parameterizedWith(Map m,World w){
  declaringType=declaringType.resolve(w);
  if (declaringType.isRawType())   declaringType=((ResolvedType)declaringType).getGenericType();
  UnresolvedType parameterizedReturnType=parameterize(getGenericReturnType(),m,true,w);
  UnresolvedType[] parameterizedParameterTypes=new UnresolvedType[getGenericParameterTypes().length];
  UnresolvedType[] genericParameterTypes=getGenericParameterTypes();
  for (int i=0; i < parameterizedParameterTypes.length; i++) {
    parameterizedParameterTypes[i]=parameterize(genericParameterTypes[i],m,true,w);
  }
  ResolvedMemberImpl ret=new ResolvedMemberImpl(getKind(),declaringType,getModifiers(),parameterizedReturnType,getName(),parameterizedParameterTypes,getExceptions(),this);
  ret.setTypeVariables(getTypeVariables());
  ret.setSourceContext(getSourceContext());
  ret.setPosition(getStart(),getEnd());
  ret.setParameterNames(getParameterNames());
  return ret;
}",0.8287337662337663
9178,"/** 
 * Read @Pointcut and handle the resolving in a lazy way to deal with pointcut references
 * @param runtimeAnnotations
 * @param struct
 * @return true if a pointcut was handled
 */
private static boolean handlePointcutAnnotation(RuntimeAnnotations runtimeAnnotations,AjAttributeMethodStruct struct){
  AnnotationGen pointcut=getAnnotation(runtimeAnnotations,AjcMemberMaker.POINTCUT_ANNOTATION);
  if (pointcut == null)   return false;
  ElementNameValuePairGen pointcutExpr=getAnnotationElement(pointcut,VALUE);
  if (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType()) && struct.method.isStatic() && struct.method.isPublic()))) {
    reportWarning(""String_Node_Str"",struct);
    ;
  }
  if (struct.method.getExceptionTable() != null) {
    reportWarning(""String_Node_Str"",struct);
    ;
  }
  String argumentNames=getArgNamesValue(pointcut);
  if (argumentNames != null) {
    struct.unparsedArgumentNames=argumentNames;
  }
  final IScope binding;
  try {
    if (struct.method.isAbstract()) {
      binding=null;
    }
 else {
      binding=new BindingScope(struct.enclosingType,struct.context,extractBindings(struct));
    }
  }
 catch (  UnreadableDebugInfoException e) {
    return false;
  }
  UnresolvedType[] argumentTypes=new UnresolvedType[struct.method.getArgumentTypes().length];
  for (int i=0; i < argumentTypes.length; i++) {
    argumentTypes[i]=UnresolvedType.forSignature(struct.method.getArgumentTypes()[i].getSignature());
  }
  Pointcut pc=null;
  if (struct.method.isAbstract()) {
    if ((pointcutExpr != null && isNullOrEmpty(pointcutExpr.getValue().stringifyValue())) || pointcutExpr == null) {
    }
 else {
      reportError(""String_Node_Str"",struct);
      return false;
    }
  }
 else {
    if (pointcutExpr == null || (pointcutExpr != null && isNullOrEmpty(pointcutExpr.getValue().stringifyValue()))) {
    }
 else {
      if (pointcutExpr != null) {
        pc=parsePointcut(pointcutExpr.getValue().stringifyValue(),struct,true);
        if (pc == null)         return false;
        pc.setLocation(struct.context,-1,-1);
      }
 else {
        reportError(""String_Node_Str"",struct);
        return false;
      }
    }
  }
  struct.ajAttributes.add(new AjAttribute.PointcutDeclarationAttribute(new LazyResolvedPointcutDefinition(struct.enclosingType,struct.method.getModifiers(),struct.method.getName(),argumentTypes,UnresolvedType.forSignature(struct.method.getReturnType().getSignature()),pc,binding)));
  return true;
}","/** 
 * Read @Pointcut and handle the resolving in a lazy way to deal with pointcut references
 * @param runtimeAnnotations
 * @param struct
 * @return true if a pointcut was handled
 */
private static boolean handlePointcutAnnotation(RuntimeAnnotations runtimeAnnotations,AjAttributeMethodStruct struct){
  AnnotationGen pointcut=getAnnotation(runtimeAnnotations,AjcMemberMaker.POINTCUT_ANNOTATION);
  if (pointcut == null)   return false;
  ElementNameValuePairGen pointcutExpr=getAnnotationElement(pointcut,VALUE);
  if (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType()) && struct.method.isStatic() && struct.method.isPublic()))) {
    reportWarning(""String_Node_Str"",struct);
    ;
  }
  if (struct.method.getExceptionTable() != null) {
    reportWarning(""String_Node_Str"",struct);
    ;
  }
  String argumentNames=getArgNamesValue(pointcut);
  if (argumentNames != null) {
    struct.unparsedArgumentNames=argumentNames;
  }
  final IScope binding;
  try {
    if (struct.method.isAbstract()) {
      binding=null;
    }
 else {
      binding=new BindingScope(struct.enclosingType,struct.context,extractBindings(struct));
    }
  }
 catch (  UnreadableDebugInfoException e) {
    return false;
  }
  UnresolvedType[] argumentTypes=new UnresolvedType[struct.method.getArgumentTypes().length];
  for (int i=0; i < argumentTypes.length; i++) {
    argumentTypes[i]=UnresolvedType.forSignature(struct.method.getArgumentTypes()[i].getSignature());
  }
  Pointcut pc=null;
  if (struct.method.isAbstract()) {
    if ((pointcutExpr != null && isNullOrEmpty(pointcutExpr.getValue().stringifyValue())) || pointcutExpr == null) {
    }
 else {
      reportError(""String_Node_Str"",struct);
      return false;
    }
  }
 else {
    if (pointcutExpr == null || isNullOrEmpty(pointcutExpr.getValue().stringifyValue())) {
    }
 else {
      pc=parsePointcut(pointcutExpr.getValue().stringifyValue(),struct,true);
      if (pc == null)       return false;
      pc.setLocation(struct.context,-1,-1);
    }
  }
  struct.ajAttributes.add(new AjAttribute.PointcutDeclarationAttribute(new LazyResolvedPointcutDefinition(struct.enclosingType,struct.method.getModifiers(),struct.method.getName(),argumentTypes,UnresolvedType.forSignature(struct.method.getReturnType().getSignature()),pc,binding)));
  return true;
}",0.9279408745637446
9179,"private boolean mungeNewMethod(BcelClassWeaver weaver,NewMethodTypeMunger munger){
  World w=weaver.getWorld();
  ResolvedMember unMangledInterMethod=munger.getSignature().resolve(w);
  ResolvedMember interMethodBody=munger.getDeclaredInterMethodBody(aspectType,w);
  ResolvedMember interMethodDispatcher=munger.getDeclaredInterMethodDispatcher(aspectType,w);
  ResolvedMember memberHoldingAnyAnnotations=interMethodDispatcher;
  ResolvedType onType=weaver.getWorld().resolve(unMangledInterMethod.getDeclaringType(),munger.getSourceLocation());
  LazyClassGen gen=weaver.getLazyClassGen();
  boolean mungingInterface=gen.isInterface();
  if (onType.isRawType())   onType=onType.getGenericType();
  boolean onInterface=onType.isInterface();
  if (onType.isAnnotation()) {
    signalError(WeaverMessages.ITDM_ON_ANNOTATION_NOT_ALLOWED,weaver,onType);
    return false;
  }
  if (onType.isEnum()) {
    signalError(WeaverMessages.ITDM_ON_ENUM_NOT_ALLOWED,weaver,onType);
    return false;
  }
  if (onInterface && gen.getLazyMethodGen(unMangledInterMethod.getName(),unMangledInterMethod.getSignature(),true) != null) {
    return false;
  }
  if (onType.equals(gen.getType())) {
    ResolvedMember mangledInterMethod=AjcMemberMaker.interMethod(unMangledInterMethod,aspectType,onInterface);
    LazyMethodGen newMethod=makeMethodGen(gen,mangledInterMethod);
    if (mungingInterface) {
      newMethod.setAccessFlags(Modifier.PUBLIC | Modifier.ABSTRACT);
    }
    if (weaver.getWorld().isInJava5Mode()) {
      AnnotationX annotationsOnRealMember[]=null;
      ResolvedType toLookOn=aspectType;
      if (aspectType.isRawType())       toLookOn=aspectType.getGenericType();
      ResolvedMember realMember=getRealMemberForITDFromAspect(toLookOn,memberHoldingAnyAnnotations,false);
      if (realMember == null)       throw new BCException(""String_Node_Str"" + memberHoldingAnyAnnotations + ""String_Node_Str""+ aspectType);
      annotationsOnRealMember=realMember.getAnnotations();
      if (annotationsOnRealMember != null) {
        for (int i=0; i < annotationsOnRealMember.length; i++) {
          AnnotationX annotationX=annotationsOnRealMember[i];
          AnnotationGen a=annotationX.getBcelAnnotation();
          AnnotationGen ag=new AnnotationGen(a,weaver.getLazyClassGen().getConstantPool(),true);
          newMethod.addAnnotation(new AnnotationX(ag,weaver.getWorld()));
        }
      }
      List allDecams=weaver.getWorld().getDeclareAnnotationOnMethods();
      for (Iterator i=allDecams.iterator(); i.hasNext(); ) {
        DeclareAnnotation decaMC=(DeclareAnnotation)i.next();
        if (decaMC.matches(unMangledInterMethod,weaver.getWorld()) && newMethod.getEnclosingClass().getType() == aspectType) {
          newMethod.addAnnotation(decaMC.getAnnotationX());
        }
      }
    }
    if (!onInterface && !Modifier.isAbstract(mangledInterMethod.getModifiers())) {
      InstructionList body=newMethod.getBody();
      InstructionFactory fact=gen.getFactory();
      int pos=0;
      if (!unMangledInterMethod.isStatic()) {
        body.append(InstructionFactory.createThis());
        pos++;
      }
      Type[] paramTypes=BcelWorld.makeBcelTypes(mangledInterMethod.getParameterTypes());
      for (int i=0, len=paramTypes.length; i < len; i++) {
        Type paramType=paramTypes[i];
        body.append(InstructionFactory.createLoad(paramType,pos));
        pos+=paramType.getSize();
      }
      body.append(Utility.createInvoke(fact,weaver.getWorld(),interMethodBody));
      body.append(InstructionFactory.createReturn(BcelWorld.makeBcelType(mangledInterMethod.getReturnType())));
      if (weaver.getWorld().isInJava5Mode()) {
        createAnyBridgeMethodsForCovariance(weaver,munger,unMangledInterMethod,onType,gen,paramTypes);
      }
    }
 else {
    }
    if (weaver.getWorld().isInJava5Mode()) {
      String basicSignature=mangledInterMethod.getSignature();
      String genericSignature=((ResolvedMemberImpl)mangledInterMethod).getSignatureForAttribute();
      if (!basicSignature.equals(genericSignature)) {
        newMethod.addAttribute(createSignatureAttribute(gen.getConstantPool(),genericSignature));
      }
    }
    weaver.addLazyMethodGen(newMethod);
    weaver.getLazyClassGen().warnOnAddedMethod(newMethod.getMethod(),getSignature().getSourceLocation());
    addNeededSuperCallMethods(weaver,onType,munger.getSuperMethodsCalled());
    return true;
  }
 else   if (onInterface && !Modifier.isAbstract(unMangledInterMethod.getModifiers())) {
    if (!gen.getType().isTopmostImplementor(onType)) {
      ResolvedType rtx=gen.getType().getTopmostImplementor(onType);
      if (!rtx.isExposedToWeaver()) {
        ISourceLocation sLoc=munger.getSourceLocation();
        weaver.getWorld().getMessageHandler().handleMessage(MessageUtil.error(WeaverMessages.format(WeaverMessages.ITD_NON_EXPOSED_IMPLEMENTOR,rtx,getAspectType().getName()),(sLoc == null ? getAspectType().getSourceLocation() : sLoc)));
      }
 else {
      }
      return false;
    }
 else {
      ResolvedMember mangledInterMethod=AjcMemberMaker.interMethod(unMangledInterMethod,aspectType,false);
      LazyMethodGen mg=makeMethodGen(gen,mangledInterMethod);
      if (weaver.getWorld().isInJava5Mode()) {
        AnnotationX annotationsOnRealMember[]=null;
        ResolvedType toLookOn=aspectType;
        if (aspectType.isRawType())         toLookOn=aspectType.getGenericType();
        ResolvedMember realMember=getRealMemberForITDFromAspect(toLookOn,memberHoldingAnyAnnotations,false);
        if (realMember == null)         throw new BCException(""String_Node_Str"" + memberHoldingAnyAnnotations + ""String_Node_Str""+ aspectType);
        annotationsOnRealMember=realMember.getAnnotations();
        if (annotationsOnRealMember != null) {
          for (int i=0; i < annotationsOnRealMember.length; i++) {
            AnnotationX annotationX=annotationsOnRealMember[i];
            AnnotationGen a=annotationX.getBcelAnnotation();
            AnnotationGen ag=new AnnotationGen(a,weaver.getLazyClassGen().getConstantPool(),true);
            mg.addAnnotation(new AnnotationX(ag,weaver.getWorld()));
          }
        }
      }
      if (mungingInterface) {
        mg.setAccessFlags(Modifier.PUBLIC | Modifier.ABSTRACT);
      }
      Type[] paramTypes=BcelWorld.makeBcelTypes(mangledInterMethod.getParameterTypes());
      Type returnType=BcelWorld.makeBcelType(mangledInterMethod.getReturnType());
      InstructionList body=mg.getBody();
      InstructionFactory fact=gen.getFactory();
      int pos=0;
      if (!mangledInterMethod.isStatic()) {
        body.append(InstructionFactory.createThis());
        pos++;
      }
      for (int i=0, len=paramTypes.length; i < len; i++) {
        Type paramType=paramTypes[i];
        body.append(InstructionFactory.createLoad(paramType,pos));
        pos+=paramType.getSize();
      }
      body.append(Utility.createInvoke(fact,weaver.getWorld(),interMethodBody));
      Type t=BcelWorld.makeBcelType(interMethodBody.getReturnType());
      if (!t.equals(returnType)) {
        body.append(fact.createCast(t,returnType));
      }
      body.append(InstructionFactory.createReturn(returnType));
      mg.definingType=onType;
      if (weaver.getWorld().isInJava5Mode()) {
        String basicSignature=mangledInterMethod.getSignature();
        String genericSignature=((ResolvedMemberImpl)mangledInterMethod).getSignatureForAttribute();
        if (!basicSignature.equals(genericSignature)) {
          mg.addAttribute(createSignatureAttribute(gen.getConstantPool(),genericSignature));
        }
      }
      weaver.addOrReplaceLazyMethodGen(mg);
      addNeededSuperCallMethods(weaver,onType,munger.getSuperMethodsCalled());
      if (munger.getDeclaredSignature() != null) {
        boolean needsbridging=false;
        ResolvedMember toBridgeTo=munger.getDeclaredSignature().parameterizedWith(null,munger.getSignature().getDeclaringType().resolve(getWorld()),false,munger.getTypeVariableAliases());
        if (!toBridgeTo.getReturnType().getErasureSignature().equals(munger.getSignature().getReturnType().getErasureSignature()))         needsbridging=true;
        UnresolvedType[] originalParams=toBridgeTo.getParameterTypes();
        UnresolvedType[] newParams=munger.getSignature().getParameterTypes();
        for (int ii=0; ii < originalParams.length; ii++) {
          if (!originalParams[ii].getErasureSignature().equals(newParams[ii].getErasureSignature()))           needsbridging=true;
        }
        if (toBridgeTo != null && needsbridging) {
          ResolvedMember bridgerMethod=AjcMemberMaker.bridgerToInterMethod(unMangledInterMethod,gen.getType());
          ResolvedMember bridgingSetter=AjcMemberMaker.interMethod(toBridgeTo,aspectType,false);
          LazyMethodGen bridgeMethod=makeMethodGen(gen,bridgingSetter);
          paramTypes=BcelWorld.makeBcelTypes(bridgingSetter.getParameterTypes());
          Type[] bridgingToParms=BcelWorld.makeBcelTypes(unMangledInterMethod.getParameterTypes());
          returnType=BcelWorld.makeBcelType(bridgingSetter.getReturnType());
          body=bridgeMethod.getBody();
          fact=gen.getFactory();
          pos=0;
          if (!bridgingSetter.isStatic()) {
            body.append(InstructionFactory.createThis());
            pos++;
          }
          for (int i=0, len=paramTypes.length; i < len; i++) {
            Type paramType=paramTypes[i];
            body.append(InstructionFactory.createLoad(paramType,pos));
            if (!bridgingSetter.getParameterTypes()[i].getErasureSignature().equals(unMangledInterMethod.getParameterTypes()[i].getErasureSignature())) {
              body.append(fact.createCast(paramType,bridgingToParms[i]));
            }
            pos+=paramType.getSize();
          }
          body.append(Utility.createInvoke(fact,weaver.getWorld(),bridgerMethod));
          body.append(InstructionFactory.createReturn(returnType));
          gen.addMethodGen(bridgeMethod);
        }
      }
      return true;
    }
  }
 else {
    return false;
  }
}","private boolean mungeNewMethod(BcelClassWeaver weaver,NewMethodTypeMunger munger){
  World w=weaver.getWorld();
  ResolvedMember unMangledInterMethod=munger.getSignature().resolve(w);
  ResolvedMember interMethodBody=munger.getDeclaredInterMethodBody(aspectType,w);
  ResolvedMember interMethodDispatcher=munger.getDeclaredInterMethodDispatcher(aspectType,w);
  ResolvedMember memberHoldingAnyAnnotations=interMethodDispatcher;
  ResolvedType onType=weaver.getWorld().resolve(unMangledInterMethod.getDeclaringType(),munger.getSourceLocation());
  LazyClassGen gen=weaver.getLazyClassGen();
  boolean mungingInterface=gen.isInterface();
  if (onType.isRawType())   onType=onType.getGenericType();
  boolean onInterface=onType.isInterface();
  if (onType.isAnnotation()) {
    signalError(WeaverMessages.ITDM_ON_ANNOTATION_NOT_ALLOWED,weaver,onType);
    return false;
  }
  if (onType.isEnum()) {
    signalError(WeaverMessages.ITDM_ON_ENUM_NOT_ALLOWED,weaver,onType);
    return false;
  }
  if (onInterface && gen.getLazyMethodGen(unMangledInterMethod.getName(),unMangledInterMethod.getSignature(),true) != null) {
    return false;
  }
  if (onType.equals(gen.getType())) {
    ResolvedMember mangledInterMethod=AjcMemberMaker.interMethod(unMangledInterMethod,aspectType,onInterface);
    LazyMethodGen newMethod=makeMethodGen(gen,mangledInterMethod);
    if (mungingInterface) {
      newMethod.setAccessFlags(Modifier.PUBLIC | Modifier.ABSTRACT);
    }
    if (weaver.getWorld().isInJava5Mode()) {
      AnnotationX annotationsOnRealMember[]=null;
      ResolvedType toLookOn=aspectType;
      if (aspectType.isRawType())       toLookOn=aspectType.getGenericType();
      ResolvedMember realMember=getRealMemberForITDFromAspect(toLookOn,memberHoldingAnyAnnotations,false);
      if (realMember == null)       throw new BCException(""String_Node_Str"" + memberHoldingAnyAnnotations + ""String_Node_Str""+ aspectType);
      annotationsOnRealMember=realMember.getAnnotations();
      if (annotationsOnRealMember != null) {
        for (int i=0; i < annotationsOnRealMember.length; i++) {
          AnnotationX annotationX=annotationsOnRealMember[i];
          AnnotationGen a=annotationX.getBcelAnnotation();
          AnnotationGen ag=new AnnotationGen(a,weaver.getLazyClassGen().getConstantPool(),true);
          newMethod.addAnnotation(new AnnotationX(ag,weaver.getWorld()));
        }
      }
      List allDecams=weaver.getWorld().getDeclareAnnotationOnMethods();
      for (Iterator i=allDecams.iterator(); i.hasNext(); ) {
        DeclareAnnotation decaMC=(DeclareAnnotation)i.next();
        if (decaMC.matches(unMangledInterMethod,weaver.getWorld()) && newMethod.getEnclosingClass().getType() == aspectType) {
          newMethod.addAnnotation(decaMC.getAnnotationX());
        }
      }
    }
    if (!onInterface && !Modifier.isAbstract(mangledInterMethod.getModifiers())) {
      InstructionList body=newMethod.getBody();
      InstructionFactory fact=gen.getFactory();
      int pos=0;
      if (!unMangledInterMethod.isStatic()) {
        body.append(InstructionFactory.createThis());
        pos++;
      }
      Type[] paramTypes=BcelWorld.makeBcelTypes(mangledInterMethod.getParameterTypes());
      for (int i=0, len=paramTypes.length; i < len; i++) {
        Type paramType=paramTypes[i];
        body.append(InstructionFactory.createLoad(paramType,pos));
        pos+=paramType.getSize();
      }
      body.append(Utility.createInvoke(fact,weaver.getWorld(),interMethodBody));
      body.append(InstructionFactory.createReturn(BcelWorld.makeBcelType(mangledInterMethod.getReturnType())));
      if (weaver.getWorld().isInJava5Mode()) {
        createAnyBridgeMethodsForCovariance(weaver,munger,unMangledInterMethod,onType,gen,paramTypes);
      }
    }
 else {
    }
    if (weaver.getWorld().isInJava5Mode()) {
      String basicSignature=mangledInterMethod.getSignature();
      String genericSignature=((ResolvedMemberImpl)mangledInterMethod).getSignatureForAttribute();
      if (!basicSignature.equals(genericSignature)) {
        newMethod.addAttribute(createSignatureAttribute(gen.getConstantPool(),genericSignature));
      }
    }
    weaver.addLazyMethodGen(newMethod);
    weaver.getLazyClassGen().warnOnAddedMethod(newMethod.getMethod(),getSignature().getSourceLocation());
    addNeededSuperCallMethods(weaver,onType,munger.getSuperMethodsCalled());
    return true;
  }
 else   if (onInterface && !Modifier.isAbstract(unMangledInterMethod.getModifiers())) {
    if (!gen.getType().isTopmostImplementor(onType)) {
      ResolvedType rtx=gen.getType().getTopmostImplementor(onType);
      if (!rtx.isExposedToWeaver()) {
        ISourceLocation sLoc=munger.getSourceLocation();
        weaver.getWorld().getMessageHandler().handleMessage(MessageUtil.error(WeaverMessages.format(WeaverMessages.ITD_NON_EXPOSED_IMPLEMENTOR,rtx,getAspectType().getName()),(sLoc == null ? getAspectType().getSourceLocation() : sLoc)));
      }
 else {
      }
      return false;
    }
 else {
      ResolvedMember mangledInterMethod=AjcMemberMaker.interMethod(unMangledInterMethod,aspectType,false);
      LazyMethodGen mg=makeMethodGen(gen,mangledInterMethod);
      if (weaver.getWorld().isInJava5Mode()) {
        AnnotationX annotationsOnRealMember[]=null;
        ResolvedType toLookOn=aspectType;
        if (aspectType.isRawType())         toLookOn=aspectType.getGenericType();
        ResolvedMember realMember=getRealMemberForITDFromAspect(toLookOn,memberHoldingAnyAnnotations,false);
        if (realMember == null)         throw new BCException(""String_Node_Str"" + memberHoldingAnyAnnotations + ""String_Node_Str""+ aspectType);
        annotationsOnRealMember=realMember.getAnnotations();
        if (annotationsOnRealMember != null) {
          for (int i=0; i < annotationsOnRealMember.length; i++) {
            AnnotationX annotationX=annotationsOnRealMember[i];
            AnnotationGen a=annotationX.getBcelAnnotation();
            AnnotationGen ag=new AnnotationGen(a,weaver.getLazyClassGen().getConstantPool(),true);
            mg.addAnnotation(new AnnotationX(ag,weaver.getWorld()));
          }
        }
      }
      if (mungingInterface) {
        mg.setAccessFlags(Modifier.PUBLIC | Modifier.ABSTRACT);
      }
      Type[] paramTypes=BcelWorld.makeBcelTypes(mangledInterMethod.getParameterTypes());
      Type returnType=BcelWorld.makeBcelType(mangledInterMethod.getReturnType());
      InstructionList body=mg.getBody();
      InstructionFactory fact=gen.getFactory();
      int pos=0;
      if (!mangledInterMethod.isStatic()) {
        body.append(InstructionFactory.createThis());
        pos++;
      }
      for (int i=0, len=paramTypes.length; i < len; i++) {
        Type paramType=paramTypes[i];
        body.append(InstructionFactory.createLoad(paramType,pos));
        pos+=paramType.getSize();
      }
      body.append(Utility.createInvoke(fact,weaver.getWorld(),interMethodBody));
      Type t=BcelWorld.makeBcelType(interMethodBody.getReturnType());
      if (!t.equals(returnType)) {
        body.append(fact.createCast(t,returnType));
      }
      body.append(InstructionFactory.createReturn(returnType));
      mg.definingType=onType;
      if (weaver.getWorld().isInJava5Mode()) {
        String basicSignature=mangledInterMethod.getSignature();
        String genericSignature=((ResolvedMemberImpl)mangledInterMethod).getSignatureForAttribute();
        if (!basicSignature.equals(genericSignature)) {
          mg.addAttribute(createSignatureAttribute(gen.getConstantPool(),genericSignature));
        }
      }
      weaver.addOrReplaceLazyMethodGen(mg);
      addNeededSuperCallMethods(weaver,onType,munger.getSuperMethodsCalled());
      if (munger.getDeclaredSignature() != null) {
        boolean needsbridging=false;
        ResolvedMember toBridgeTo=munger.getDeclaredSignature().parameterizedWith(null,munger.getSignature().getDeclaringType().resolve(getWorld()),false,munger.getTypeVariableAliases());
        if (!toBridgeTo.getReturnType().getErasureSignature().equals(munger.getSignature().getReturnType().getErasureSignature()))         needsbridging=true;
        UnresolvedType[] originalParams=toBridgeTo.getParameterTypes();
        UnresolvedType[] newParams=munger.getSignature().getParameterTypes();
        for (int ii=0; ii < originalParams.length; ii++) {
          if (!originalParams[ii].getErasureSignature().equals(newParams[ii].getErasureSignature()))           needsbridging=true;
        }
        if (needsbridging) {
          ResolvedMember bridgerMethod=AjcMemberMaker.bridgerToInterMethod(unMangledInterMethod,gen.getType());
          ResolvedMember bridgingSetter=AjcMemberMaker.interMethod(toBridgeTo,aspectType,false);
          LazyMethodGen bridgeMethod=makeMethodGen(gen,bridgingSetter);
          paramTypes=BcelWorld.makeBcelTypes(bridgingSetter.getParameterTypes());
          Type[] bridgingToParms=BcelWorld.makeBcelTypes(unMangledInterMethod.getParameterTypes());
          returnType=BcelWorld.makeBcelType(bridgingSetter.getReturnType());
          body=bridgeMethod.getBody();
          fact=gen.getFactory();
          pos=0;
          if (!bridgingSetter.isStatic()) {
            body.append(InstructionFactory.createThis());
            pos++;
          }
          for (int i=0, len=paramTypes.length; i < len; i++) {
            Type paramType=paramTypes[i];
            body.append(InstructionFactory.createLoad(paramType,pos));
            if (!bridgingSetter.getParameterTypes()[i].getErasureSignature().equals(unMangledInterMethod.getParameterTypes()[i].getErasureSignature())) {
              body.append(fact.createCast(paramType,bridgingToParms[i]));
            }
            pos+=paramType.getSize();
          }
          body.append(Utility.createInvoke(fact,weaver.getWorld(),bridgerMethod));
          body.append(InstructionFactory.createReturn(returnType));
          gen.addMethodGen(bridgeMethod);
        }
      }
      return true;
    }
  }
 else {
    return false;
  }
}",0.998902524194353
9180,"private void checkTX(UnresolvedType tx,boolean shouldBeParameterized,int numberOfTypeParameters){
  assertTrue(""String_Node_Str"" + shouldBeParameterized,tx.isParameterizedType() == shouldBeParameterized);
  if (numberOfTypeParameters == 0) {
    UnresolvedType[] params=tx.getTypeParameters();
    assertTrue(""String_Node_Str"" + params.length,params == null || params.length == 0);
  }
 else {
    assertTrue(""String_Node_Str"" + numberOfTypeParameters,tx.getTypeParameters().length == numberOfTypeParameters);
  }
}","private void checkTX(UnresolvedType tx,boolean shouldBeParameterized,int numberOfTypeParameters){
  assertTrue(""String_Node_Str"" + shouldBeParameterized,tx.isParameterizedType() == shouldBeParameterized);
  if (numberOfTypeParameters == 0) {
    UnresolvedType[] params=tx.getTypeParameters();
    assertTrue(""String_Node_Str"" + params.length,params.length == 0);
  }
 else {
    assertTrue(""String_Node_Str"" + numberOfTypeParameters,tx.getTypeParameters().length == numberOfTypeParameters);
  }
}",0.982213438735178
9181,"public void testParseBadPattern(){
  PatternParser p=new PatternParser(""String_Node_Str"");
  try {
    AnnotationTypePattern bad=p.maybeParseAnnotationPattern();
    fail(""String_Node_Str"");
  }
 catch (  ParserException pEx) {
    assertEquals(""String_Node_Str"",pEx.getMessage());
  }
}","public void testParseBadPattern(){
  PatternParser p=new PatternParser(""String_Node_Str"");
  try {
    p.maybeParseAnnotationPattern();
    fail(""String_Node_Str"");
  }
 catch (  ParserException pEx) {
    assertEquals(""String_Node_Str"",pEx.getMessage());
  }
}",0.9525547445255474
9182,"/** 
 * If the provided configFile is the same as the id for the last compiler then returns that, otherwise clears the state for the saved compiler and creates a new one for the provided configFile
 * @param configFile
 * @return the AjCompiler with the id of the given configFile
 */
public AjCompiler getCompilerForConfigFile(String configFile){
  if (configFile == null)   return null;
  if ((compiler == null || !compiler.getId().equals(configFile)) && configFile != null) {
    if (compiler != null) {
      compiler.clearLastState();
    }
    getMessageHandler().reset();
    compiler=new AjCompiler(configFile,getCompilerConfig(),getBuildProgressMonitor(),getMessageHandler());
  }
  return compiler;
}","/** 
 * If the provided configFile is the same as the id for the last compiler then returns that, otherwise clears the state for the saved compiler and creates a new one for the provided configFile
 * @param configFile
 * @return the AjCompiler with the id of the given configFile
 */
public AjCompiler getCompilerForConfigFile(String configFile){
  if (configFile == null)   return null;
  if ((compiler == null || !compiler.getId().equals(configFile))) {
    if (compiler != null) {
      compiler.clearLastState();
    }
    getMessageHandler().reset();
    compiler=new AjCompiler(configFile,getCompilerConfig(),getBuildProgressMonitor(),getMessageHandler());
  }
  return compiler;
}",0.984263233190272
9183,"/** 
 * Utility to run the project main class from the project properties in a new VM. Errors are logged to the ErrorHandler.
 * @return LangUtil.ProcessController running with process, or null ifunable to start
 */
public LangUtil.ProcessController runInNewVM(){
  final RunProperties props=new RunProperties(compilerConfig,runtimeProperties,uiBuildMsgHandler,rootFrame);
  if (!props.valid) {
    return null;
  }
  final StringBuffer command=new StringBuffer();
  LangUtil.ProcessController controller=new LangUtil.ProcessController(){
    public void doCompleting(    Throwable thrown,    int result){
      LangUtil.ProcessController.Thrown any=getThrown();
      if (!any.thrown && (null == thrown) && (0 == result)) {
        return;
      }
      String context=props.mainClass + ""String_Node_Str"" + command+ ""String_Node_Str"";
      if (null != thrown) {
        String m=""String_Node_Str"" + context;
        uiBuildMsgHandler.handleMessage(new Message(m,IMessage.ERROR,thrown,null));
      }
 else       if (0 != result) {
        String m=""String_Node_Str"" + context;
        uiBuildMsgHandler.handleMessage(new Message(m,IMessage.ERROR,thrown,null));
      }
      if (null != any.fromInPipe) {
        String m=""String_Node_Str"" + context;
        uiBuildMsgHandler.handleMessage(new Message(m,IMessage.ERROR,thrown,null));
      }
      if (null != any.fromOutPipe) {
        String m=""String_Node_Str"" + context;
        uiBuildMsgHandler.handleMessage(new Message(m,IMessage.ERROR,thrown,null));
      }
      if (null != any.fromErrPipe) {
        String m=""String_Node_Str"" + context;
        uiBuildMsgHandler.handleMessage(new Message(m,IMessage.ERROR,thrown,null));
      }
    }
  }
;
  controller=LangUtil.makeProcess(controller,props.classpath,props.mainClass,props.args);
  command.append(Arrays.asList(controller.getCommand()).toString());
  controller.start();
  return controller;
}","/** 
 * Utility to run the project main class from the project properties in a new VM. Errors are logged to the ErrorHandler.
 * @return LangUtil.ProcessController running with process, or null ifunable to start
 */
public LangUtil.ProcessController runInNewVM(){
  final RunProperties props=new RunProperties(compilerConfig,runtimeProperties,uiBuildMsgHandler,rootFrame);
  if (!props.valid) {
    return null;
  }
  final StringBuffer command=new StringBuffer();
  LangUtil.ProcessController controller=new LangUtil.ProcessController(){
    public void doCompleting(    Throwable thrown,    int result){
      LangUtil.ProcessController.Thrown any=getThrown();
      if (!any.thrown && (null == thrown) && (0 == result)) {
        return;
      }
      String context=props.mainClass + ""String_Node_Str"" + command+ ""String_Node_Str"";
      if (null != thrown) {
        String m=""String_Node_Str"" + context;
        uiBuildMsgHandler.handleMessage(new Message(m,IMessage.ERROR,thrown,null));
      }
 else       if (0 != result) {
        String m=""String_Node_Str"" + context;
        uiBuildMsgHandler.handleMessage(new Message(m,IMessage.ERROR,null,null));
      }
      if (null != any.fromInPipe) {
        String m=""String_Node_Str"" + context;
        uiBuildMsgHandler.handleMessage(new Message(m,IMessage.ERROR,thrown,null));
      }
      if (null != any.fromOutPipe) {
        String m=""String_Node_Str"" + context;
        uiBuildMsgHandler.handleMessage(new Message(m,IMessage.ERROR,thrown,null));
      }
      if (null != any.fromErrPipe) {
        String m=""String_Node_Str"" + context;
        uiBuildMsgHandler.handleMessage(new Message(m,IMessage.ERROR,thrown,null));
      }
    }
  }
;
  controller=LangUtil.makeProcess(controller,props.classpath,props.mainClass,props.args);
  command.append(Arrays.asList(controller.getCommand()).toString());
  controller.start();
  return controller;
}",0.99738082765846
9184,"public void doCompleting(Throwable thrown,int result){
  LangUtil.ProcessController.Thrown any=getThrown();
  if (!any.thrown && (null == thrown) && (0 == result)) {
    return;
  }
  String context=props.mainClass + ""String_Node_Str"" + command+ ""String_Node_Str"";
  if (null != thrown) {
    String m=""String_Node_Str"" + context;
    uiBuildMsgHandler.handleMessage(new Message(m,IMessage.ERROR,thrown,null));
  }
 else   if (0 != result) {
    String m=""String_Node_Str"" + context;
    uiBuildMsgHandler.handleMessage(new Message(m,IMessage.ERROR,thrown,null));
  }
  if (null != any.fromInPipe) {
    String m=""String_Node_Str"" + context;
    uiBuildMsgHandler.handleMessage(new Message(m,IMessage.ERROR,thrown,null));
  }
  if (null != any.fromOutPipe) {
    String m=""String_Node_Str"" + context;
    uiBuildMsgHandler.handleMessage(new Message(m,IMessage.ERROR,thrown,null));
  }
  if (null != any.fromErrPipe) {
    String m=""String_Node_Str"" + context;
    uiBuildMsgHandler.handleMessage(new Message(m,IMessage.ERROR,thrown,null));
  }
}","public void doCompleting(Throwable thrown,int result){
  LangUtil.ProcessController.Thrown any=getThrown();
  if (!any.thrown && (null == thrown) && (0 == result)) {
    return;
  }
  String context=props.mainClass + ""String_Node_Str"" + command+ ""String_Node_Str"";
  if (null != thrown) {
    String m=""String_Node_Str"" + context;
    uiBuildMsgHandler.handleMessage(new Message(m,IMessage.ERROR,thrown,null));
  }
 else   if (0 != result) {
    String m=""String_Node_Str"" + context;
    uiBuildMsgHandler.handleMessage(new Message(m,IMessage.ERROR,null,null));
  }
  if (null != any.fromInPipe) {
    String m=""String_Node_Str"" + context;
    uiBuildMsgHandler.handleMessage(new Message(m,IMessage.ERROR,thrown,null));
  }
  if (null != any.fromOutPipe) {
    String m=""String_Node_Str"" + context;
    uiBuildMsgHandler.handleMessage(new Message(m,IMessage.ERROR,thrown,null));
  }
  if (null != any.fromErrPipe) {
    String m=""String_Node_Str"" + context;
    uiBuildMsgHandler.handleMessage(new Message(m,IMessage.ERROR,thrown,null));
  }
}",0.9952107279693486
9185,"public BuildConfigModel buildModel(String configFilePath){
  File configFile=new File(configFilePath);
  String rootPath=configFile.getParent();
  String configFileName=configFile.getName();
  BuildConfigModel model=new BuildConfigModel(configFilePath);
  List configFiles=new ArrayList();
  List importedFiles=new ArrayList();
  List badEntries=null;
  try {
    LstBuildConfigFileParser configParser=new LstBuildConfigFileParser(configFilePath);
    configParser.parseConfigFile(new File(configFilePath));
    configFiles=configParser.getFiles();
    importedFiles=configParser.getImportedFiles();
    badEntries=configParser.getProblemEntries();
  }
 catch (  ConfigParser.ParseException pe) {
    IMessage message=new Message(pe.getMessage(),IMessage.ERROR,pe,new SourceLocation(pe.getFile(),pe.getLine(),1));
    Ajde.getDefault().getMessageHandler().handleMessage(message);
  }
  List relativePaths=relativizeFilePaths(configFiles,rootPath);
  BuildConfigNode root=new BuildConfigNode(configFileName,BuildConfigNode.Kind.FILE_LST,rootPath);
  buildDirTree(root,rootPath,importedFiles,configFileName);
  model.setRoot(root);
  addFilesToDirTree(model,relativePaths,badEntries);
  pruneEmptyDirs(root);
  sortModel((BuildConfigNode)model.getRoot(),ALPHABETICAL_COMPARATOR);
  addProblemEntries(root,badEntries);
  return model;
}","public BuildConfigModel buildModel(String configFilePath){
  File configFile=new File(configFilePath);
  String rootPath=configFile.getParent();
  String configFileName=configFile.getName();
  BuildConfigModel model=new BuildConfigModel(configFilePath);
  List configFiles=new ArrayList();
  List importedFiles=new ArrayList();
  List badEntries=null;
  try {
    LstBuildConfigFileParser configParser=new LstBuildConfigFileParser(configFilePath);
    configParser.parseConfigFile(new File(configFilePath));
    configFiles=configParser.getFiles();
    importedFiles=configParser.getImportedFiles();
    badEntries=configParser.getProblemEntries();
  }
 catch (  ConfigParser.ParseException pe) {
    IMessage message=new Message(pe.getMessage(),IMessage.ERROR,pe,new SourceLocation(pe.getFile(),pe.getLine(),1));
    Ajde.getDefault().getMessageHandler().handleMessage(message);
  }
  List relativePaths=relativizeFilePaths(configFiles,rootPath);
  BuildConfigNode root=new BuildConfigNode(configFileName,BuildConfigNode.Kind.FILE_LST,rootPath);
  buildDirTree(root,rootPath,importedFiles,configFileName);
  model.setRoot(root);
  addFilesToDirTree(model,relativePaths,badEntries);
  pruneEmptyDirs(root);
  sortModel(model.getRoot(),ALPHABETICAL_COMPARATOR);
  addProblemEntries(root,badEntries);
  return model;
}",0.9935824839562098
9186,"/** 
 * @return	null if the kind could not be resolved
 */
protected AbstractIcon getStructureIcon(IProgramElement.Kind kind,IProgramElement.Accessibility accessibility){
  return getStructureIcon(kind,IProgramElement.Accessibility.PUBLIC);
}","/** 
 * @return	null if the kind could not be resolved
 */
protected abstract AbstractIcon getStructureIcon(IProgramElement.Kind kind,IProgramElement.Accessibility accessibility);",0.8076009501187649
9187,"private boolean matches(BuildConfigNode node,String sourceFilePath,int lineNumber){
  try {
    return node != null && node.getSourceLocation() != null && node.getSourceLocation().getSourceFile().getCanonicalPath().equals(sourceFilePath) && ((node.getSourceLocation().getLine() <= lineNumber && node.getSourceLocation().getEndLine() >= lineNumber) || (lineNumber <= 1 && node instanceof BuildConfigNode));
  }
 catch (  IOException ioe) {
    return false;
  }
}","private boolean matches(BuildConfigNode node,String sourceFilePath,int lineNumber){
  try {
    return node != null && node.getSourceLocation() != null && node.getSourceLocation().getSourceFile().getCanonicalPath().equals(sourceFilePath) && ((node.getSourceLocation().getLine() <= lineNumber && node.getSourceLocation().getEndLine() >= lineNumber) || (lineNumber <= 1));
  }
 catch (  IOException ioe) {
    return false;
  }
}",0.9606299212598424
9188,"public List getActiveNodes(BuildConfigNode.Kind kind){
  List nodes=new ArrayList();
  getActiveNodesHelper((BuildConfigNode)getRoot(),kind,nodes);
  return nodes;
}","public List getActiveNodes(BuildConfigNode.Kind kind){
  List nodes=new ArrayList();
  getActiveNodesHelper(root,kind,nodes);
  return nodes;
}",0.922077922077922
9189,"/** 
 * @param path	java.io.File.separator delimited path
 * @return corresponding node if the path is found, the root otherwise
 */
public BuildConfigNode getNodeForPath(String path){
  BuildConfigNode upPathMatch=searchUpPaths(path);
  if (upPathMatch != null && upPathMatch != root) {
    return upPathMatch;
  }
 else {
    StringTokenizer st=new StringTokenizer(path,""String_Node_Str"");
    BuildConfigNode node=(BuildConfigNode)root;
    return getNodeForPathHelper(st,node);
  }
}","/** 
 * @param path	java.io.File.separator delimited path
 * @return corresponding node if the path is found, the root otherwise
 */
public BuildConfigNode getNodeForPath(String path){
  BuildConfigNode upPathMatch=searchUpPaths(path);
  if (upPathMatch != null && upPathMatch != root) {
    return upPathMatch;
  }
 else {
    StringTokenizer st=new StringTokenizer(path,""String_Node_Str"");
    return getNodeForPathHelper(st,root);
  }
}",0.8898488120950324
9190,"/** 
 * Comparison is string-name based only.
 */
public int compareTo(Object o) throws ClassCastException {
  if (this == o) {
    return 0;
  }
 else {
    BuildConfigNode sn=(BuildConfigNode)o;
    return this.getName().compareTo(sn.getName());
  }
}","/** 
 * Comparison is string-name based only.
 */
public int compareTo(Object o) throws ClassCastException {
  if (o instanceof BuildConfigNode) {
    BuildConfigNode sn=(BuildConfigNode)o;
    return this.getName().compareTo(sn.getName());
  }
  return -1;
}",0.50390625
9191,"private List findMatchesHelper(IProgramElement node,String pattern,IProgramElement.Kind kind,List matches){
  if (node != null && node.getName().indexOf(pattern) != -1) {
    if (kind == null || node.getKind().equals(kind)) {
      matches.add(node);
    }
  }
  if (node != null && node.getChildren() != null) {
    for (Iterator it=node.getChildren().iterator(); it.hasNext(); ) {
      IProgramElement nextNode=(IProgramElement)it.next();
      if (nextNode instanceof IProgramElement) {
        findMatchesHelper((IProgramElement)nextNode,pattern,kind,matches);
      }
    }
  }
  return matches;
}","private List findMatchesHelper(IProgramElement node,String pattern,IProgramElement.Kind kind,List matches){
  if (node != null && node.getName().indexOf(pattern) != -1) {
    if (kind == null || node.getKind().equals(kind)) {
      matches.add(node);
    }
  }
  if (node != null && node.getChildren() != null) {
    for (Iterator it=node.getChildren().iterator(); it.hasNext(); ) {
      IProgramElement nextNode=(IProgramElement)it.next();
      if (nextNode != null) {
        findMatchesHelper(nextNode,pattern,kind,matches);
      }
    }
  }
  return matches;
}",0.9247863247863248
9192,"/** 
 * @param pattern		case-sensitive substring of node name
 * @return 	null if a corresponding node was not found
 */
public List findMatches(String pattern,IProgramElement.Kind kind){
  List matches=new ArrayList();
  IHierarchy model=AsmManager.getDefault().getHierarchy();
  if (model.equals(IHierarchy.NO_STRUCTURE)) {
    return null;
  }
 else {
    return findMatchesHelper((IProgramElement)model.getRoot(),pattern,kind,matches);
  }
}","/** 
 * @param pattern		case-sensitive substring of node name
 * @return 	null if a corresponding node was not found
 */
public List findMatches(String pattern,IProgramElement.Kind kind){
  List matches=new ArrayList();
  IHierarchy model=AsmManager.getDefault().getHierarchy();
  if (model.getRoot().equals(IHierarchy.NO_STRUCTURE)) {
    return null;
  }
 else {
    return findMatchesHelper(model.getRoot(),pattern,kind,matches);
  }
}",0.9694224235560588
9193,"/** 
 * @return		the view node corresponding to the active ProgramElementNode or null
 */
public IStructureViewNode getActiveNode(){
  if (activeNode != null && activeNode.getStructureNode() instanceof IProgramElement) {
    return activeNode;
  }
 else {
    return null;
  }
}","/** 
 * @return		the view node corresponding to the active ProgramElementNode or null
 */
public IStructureViewNode getActiveNode(){
  if (activeNode != null && activeNode.getStructureNode() != null) {
    return activeNode;
  }
 else {
    return null;
  }
}",0.7932960893854749
9194,"/** 
 * Highlights the given node in all structure views.  If the node represents code and as such is below the granularity visible in the view the parent is highlighted, along with the corresponding sourceline.
 */
private void navigationAction(IProgramElement node,boolean recordHistory){
  if (node == null)   return;
  Ajde.getDefault().logEvent(""String_Node_Str"" + node + ""String_Node_Str""+ recordHistory);
  if (recordHistory)   historyModel.navigateToNode(node);
  if (defaultFileView != null && node.getSourceLocation() != null) {
    String newFilePath=node.getSourceLocation().getSourceFile().getAbsolutePath();
    if (defaultFileView.getSourceFile() != null && !defaultFileView.getSourceFile().equals(newFilePath)) {
      defaultFileView.setSourceFile(newFilePath);
      treeViewBuilder.buildView(defaultFileView,AsmManager.getDefault().getHierarchy());
    }
  }
  for (Iterator it=structureViews.iterator(); it.hasNext(); ) {
    StructureView view=(StructureView)it.next();
    if (!(view instanceof GlobalStructureView) || !recordHistory || defaultFileView == null) {
      if (node.getKind().equals(IProgramElement.Kind.CODE)) {
        IProgramElement parentNode=(IProgramElement)node.getParent();
        if (parentNode != null) {
          IStructureViewNode currNode=view.findCorrespondingViewNode(parentNode);
          int lineOffset=node.getSourceLocation().getLine() - parentNode.getSourceLocation().getLine();
          if (currNode != null)           view.setActiveNode(currNode,lineOffset);
        }
      }
 else {
        IStructureViewNode currNode=view.findCorrespondingViewNode(node);
        if (currNode != null)         view.setActiveNode(currNode);
      }
    }
  }
}","/** 
 * Highlights the given node in all structure views.  If the node represents code and as such is below the granularity visible in the view the parent is highlighted, along with the corresponding sourceline.
 */
private void navigationAction(IProgramElement node,boolean recordHistory){
  if (node == null)   return;
  Ajde.getDefault().logEvent(""String_Node_Str"" + node + ""String_Node_Str""+ recordHistory);
  if (recordHistory)   historyModel.navigateToNode(node);
  if (defaultFileView != null && node.getSourceLocation() != null) {
    String newFilePath=node.getSourceLocation().getSourceFile().getAbsolutePath();
    if (defaultFileView.getSourceFile() != null && !defaultFileView.getSourceFile().equals(newFilePath)) {
      defaultFileView.setSourceFile(newFilePath);
      treeViewBuilder.buildView(defaultFileView,AsmManager.getDefault().getHierarchy());
    }
  }
  for (Iterator it=structureViews.iterator(); it.hasNext(); ) {
    StructureView view=(StructureView)it.next();
    if (!(view instanceof GlobalStructureView) || !recordHistory || defaultFileView == null) {
      if (node.getKind().equals(IProgramElement.Kind.CODE)) {
        IProgramElement parentNode=node.getParent();
        if (parentNode != null) {
          IStructureViewNode currNode=view.findCorrespondingViewNode(parentNode);
          int lineOffset=node.getSourceLocation().getLine() - parentNode.getSourceLocation().getLine();
          if (currNode != null)           view.setActiveNode(currNode,lineOffset);
        }
      }
 else {
        IStructureViewNode currNode=view.findCorrespondingViewNode(node);
        if (currNode != null)         view.setActiveNode(currNode);
      }
    }
  }
}",0.9949985289791116
9195,"public int compare(Object o1,Object o2){
  IProgramElement sv1=((IStructureViewNode)o1).getStructureNode();
  IProgramElement sv2=((IStructureViewNode)o2).getStructureNode();
  if (sv1 instanceof IProgramElement && sv2 instanceof IProgramElement) {
    IProgramElement p1=(IProgramElement)sv1;
    IProgramElement p2=(IProgramElement)sv2;
    if (p2.getKind() == IProgramElement.Kind.IMPORT_REFERENCE)     return 1;
    if (p1.getKind() == IProgramElement.Kind.IMPORT_REFERENCE)     return -1;
    if (p1.getSourceLocation() == null || p2.getSourceLocation() == null) {
      return 0;
    }
 else     if (p1.getSourceLocation().getLine() < p2.getSourceLocation().getLine()) {
      return -1;
    }
 else {
      return 1;
    }
  }
 else {
    return 0;
  }
}","public int compare(Object o1,Object o2){
  IProgramElement sv1=((IStructureViewNode)o1).getStructureNode();
  IProgramElement sv2=((IStructureViewNode)o2).getStructureNode();
  if (sv1 != null && sv2 != null) {
    if (sv2.getKind() == IProgramElement.Kind.IMPORT_REFERENCE)     return 1;
    if (sv1.getKind() == IProgramElement.Kind.IMPORT_REFERENCE)     return -1;
    if (sv1.getSourceLocation() == null || sv2.getSourceLocation() == null) {
      return 0;
    }
 else     if (sv1.getSourceLocation().getLine() < sv2.getSourceLocation().getLine()) {
      return -1;
    }
 else {
      return 1;
    }
  }
 else {
    return 0;
  }
}",0.8614285714285714
9196,"private boolean acceptNode(IProgramElement node,StructureViewProperties properties){
  if (node instanceof IProgramElement) {
    IProgramElement pNode=(IProgramElement)node;
    if (!acceptGranularity(pNode.getKind(),properties.getGranularity())) {
      return false;
    }
 else     if (pNode.getKind().isMember()) {
      if (properties.getFilteredMemberAccessibility().contains(pNode.getAccessibility())) {
        return false;
      }
      if (properties.getFilteredMemberKinds().contains(pNode.getKind())) {
        return false;
      }
      for (Iterator it=pNode.getModifiers().iterator(); it.hasNext(); ) {
        if (properties.getFilteredMemberModifiers().contains(it.next())) {
          return false;
        }
      }
    }
  }
 else {
    return true;
  }
  return true;
}","private boolean acceptNode(IProgramElement node,StructureViewProperties properties){
  if (node != null) {
    IProgramElement pNode=node;
    if (!acceptGranularity(pNode.getKind(),properties.getGranularity())) {
      return false;
    }
 else     if (pNode.getKind().isMember()) {
      if (properties.getFilteredMemberAccessibility().contains(pNode.getAccessibility())) {
        return false;
      }
      if (properties.getFilteredMemberKinds().contains(pNode.getKind())) {
        return false;
      }
      for (Iterator it=pNode.getModifiers().iterator(); it.hasNext(); ) {
        if (properties.getFilteredMemberModifiers().contains(it.next())) {
          return false;
        }
      }
    }
  }
  return true;
}",0.9388560157790928
9197,"public void updateView(StructureView structureView){
  if (structureView instanceof GlobalStructureView) {
    treeManager.updateTree((GlobalStructureView)structureView);
  }
}","public void updateView(StructureView structureView){
  if (structureView instanceof GlobalStructureView) {
    treeManager.updateTree(structureView);
  }
}",0.9365558912386708
9198,"public void singleClickNavigation(MouseEvent e){
  SwingTreeViewNode treeNode=(SwingTreeViewNode)tree.getLastSelectedPathComponent();
  if (treeNode != null && !e.isControlDown() && !e.isShiftDown() && e.getModifiers() != 4) {
    IProgramElement currNode=(IProgramElement)treeNode.getUserObject();
    if (currNode instanceof IProgramElement && !e.isControlDown() && !e.isShiftDown()&& e.getModifiers() != 4) {
    }
  }
}","public void singleClickNavigation(MouseEvent e){
  SwingTreeViewNode treeNode=(SwingTreeViewNode)tree.getLastSelectedPathComponent();
  if (treeNode != null && !e.isControlDown() && !e.isShiftDown() && e.getModifiers() != 4) {
    IProgramElement currNode=(IProgramElement)treeNode.getUserObject();
    if (currNode != null && !e.isControlDown() && !e.isShiftDown() && e.getModifiers() != 4) {
    }
  }
}",0.9589371980676328
9199,"public void doubleClickNavigation(MouseEvent e){
  SwingTreeViewNode treeNode=(SwingTreeViewNode)tree.getLastSelectedPathComponent();
  if (treeNode != null) {
    IProgramElement currNode=(IProgramElement)treeNode.getUserObject();
    if (currNode instanceof IProgramElement && !e.isControlDown() && !e.isShiftDown()&& e.getModifiers() != 4) {
    }
  }
}","public void doubleClickNavigation(MouseEvent e){
  SwingTreeViewNode treeNode=(SwingTreeViewNode)tree.getLastSelectedPathComponent();
  if (treeNode != null) {
    IProgramElement currNode=(IProgramElement)treeNode.getUserObject();
    if (currNode != null && !e.isControlDown() && !e.isShiftDown() && e.getModifiers() != 4) {
    }
  }
}",0.9510086455331412
9200,"public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  String label=""String_Node_Str"";
  String detail=null;
  IMessage.Kind kind=IMessage.ERROR;
  if (value instanceof IMessage) {
    IMessage cm=(IMessage)value;
    label=cm.getMessage();
    if (LangUtil.isEmpty(label)) {
      label=cm.getMessage().toString();
    }
    kind=cm.getKind();
    Throwable thrown=cm.getThrown();
    if (null != thrown) {
      detail=LangUtil.renderException(thrown);
    }
  }
 else   if (null != value) {
    label=value.toString();
  }
  setText(label);
  if (kind.equals(IMessage.WARNING)) {
    setIcon(Ajde.getDefault().getIconRegistry().getWarningIcon());
  }
 else   if (IMessage.ERROR.isSameOrLessThan(kind)) {
    setIcon(Ajde.getDefault().getIconRegistry().getErrorIcon());
  }
 else {
    setIcon(Ajde.getDefault().getIconRegistry().getInfoIcon());
  }
  if (isSelected) {
    setBackground(list.getSelectionBackground());
    setForeground(list.getSelectionForeground());
  }
 else {
    setBackground(list.getBackground());
    setForeground(list.getForeground());
  }
  setEnabled(list.isEnabled());
  setFont(list.getFont());
  setOpaque(true);
  if (null != detail) {
    setToolTipText(detail);
  }
  return this;
}","public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  String label=""String_Node_Str"";
  String detail=null;
  IMessage.Kind kind=IMessage.ERROR;
  if (value instanceof IMessage) {
    IMessage cm=(IMessage)value;
    label=cm.getMessage();
    if (LangUtil.isEmpty(label)) {
      label=cm.getMessage();
    }
    kind=cm.getKind();
    Throwable thrown=cm.getThrown();
    if (null != thrown) {
      detail=LangUtil.renderException(thrown);
    }
  }
 else   if (null != value) {
    label=value.toString();
  }
  setText(label);
  if (kind.equals(IMessage.WARNING)) {
    setIcon(Ajde.getDefault().getIconRegistry().getWarningIcon());
  }
 else   if (IMessage.ERROR.isSameOrLessThan(kind)) {
    setIcon(Ajde.getDefault().getIconRegistry().getErrorIcon());
  }
 else {
    setIcon(Ajde.getDefault().getIconRegistry().getInfoIcon());
  }
  if (isSelected) {
    setBackground(list.getSelectionBackground());
    setForeground(list.getSelectionForeground());
  }
 else {
    setBackground(list.getBackground());
    setForeground(list.getForeground());
  }
  setEnabled(list.isEnabled());
  setFont(list.getFont());
  setOpaque(true);
  if (null != detail) {
    setToolTipText(detail);
  }
  return this;
}",0.995714842228282
9201,"private void highlightNode(SwingTreeViewNode parent,IProgramElement node){
  for (int i=0; i < parent.getChildCount(); i++) {
    SwingTreeViewNode currNode=(SwingTreeViewNode)parent.getChildAt(i);
    IProgramElement sNode=(IProgramElement)currNode.getStructureNode();
    if (sNode != null && sNode.equals(node) && currNode.getKind() != IStructureViewNode.Kind.LINK) {
      TreePath path=new TreePath(currNode.getPath());
      structureTree.setSelectionPath(path);
      int currRow=structureTree.getRowForPath(path);
      structureTree.expandRow(currRow);
      structureTree.scrollRowToVisible(currRow);
    }
 else {
      highlightNode(currNode,node);
    }
  }
}","private void highlightNode(SwingTreeViewNode parent,IProgramElement node){
  for (int i=0; i < parent.getChildCount(); i++) {
    SwingTreeViewNode currNode=(SwingTreeViewNode)parent.getChildAt(i);
    IProgramElement sNode=currNode.getStructureNode();
    if (sNode != null && sNode.equals(node) && currNode.getKind() != IStructureViewNode.Kind.LINK) {
      TreePath path=new TreePath(currNode.getPath());
      structureTree.setSelectionPath(path);
      int currRow=structureTree.getRowForPath(path);
      structureTree.expandRow(currRow);
      structureTree.scrollRowToVisible(currRow);
    }
 else {
      highlightNode(currNode,node);
    }
  }
}",0.987189148455162
9202,"public void highlightActiveNode(){
  if (currentView.getActiveNode() == null)   return;
  IProgramElement node=currentView.getActiveNode().getStructureNode();
  if (node instanceof IProgramElement) {
    treeManager.highlightNode((IProgramElement)node);
  }
}","public void highlightActiveNode(){
  if (currentView.getActiveNode() == null)   return;
  IProgramElement node=currentView.getActiveNode().getStructureNode();
  if (node != null) {
    treeManager.highlightNode(node);
  }
}",0.8962655601659751
9203,"public void setActiveNode(IStructureViewNode node,int lineOffset){
  if (node == null)   return;
  IProgramElement pNode=(IProgramElement)node.getStructureNode();
  treeManager.highlightNode(pNode);
  if (pNode.getSourceLocation() != null) {
    Ajde.getDefault().getEditorAdapter().showSourceLine(pNode.getSourceLocation().getSourceFile().getAbsolutePath(),pNode.getSourceLocation().getLine() + lineOffset,true);
  }
}","public void setActiveNode(IStructureViewNode node,int lineOffset){
  if (node == null)   return;
  IProgramElement pNode=node.getStructureNode();
  treeManager.highlightNode(pNode);
  if (pNode.getSourceLocation() != null) {
    Ajde.getDefault().getEditorAdapter().showSourceLine(pNode.getSourceLocation().getSourceFile().getAbsolutePath(),pNode.getSourceLocation().getLine() + lineOffset,true);
  }
}",0.979293544457978
9204,"public void openFile(String configFile) throws IOException, InvalidResourceException {
  try {
    if (configFile == null) {
      Message msg=new Message(""String_Node_Str"",IMessage.ERROR,null,null);
      Ajde.getDefault().getMessageHandler().handleMessage(msg);
      return;
    }
    jbInit();
    jLabel1.setText(""String_Node_Str"" + configFile);
    model=Ajde.getDefault().getBuildConfigManager().buildModel(configFile);
    root=buildTree((BuildConfigNode)model.getRoot());
    buildConfig_tree.setModel(new DefaultTreeModel(root));
    buildConfig_tree.addMouseListener(new ConfigFileMouseAdapter(buildConfig_tree));
    buildConfig_tree.setCellRenderer(new ConfigTreeCellRenderer());
    for (int j=0; j < buildConfig_tree.getRowCount(); j++) {
      buildConfig_tree.expandPath(buildConfig_tree.getPathForRow(j));
    }
  }
 catch (  Exception e) {
    Message msg=new Message(""String_Node_Str"",IMessage.ERROR,e,null);
    Ajde.getDefault().getMessageHandler().handleMessage(msg);
  }
}","public void openFile(String configFile) throws IOException, InvalidResourceException {
  try {
    if (configFile == null) {
      Message msg=new Message(""String_Node_Str"",IMessage.ERROR,null,null);
      Ajde.getDefault().getMessageHandler().handleMessage(msg);
      return;
    }
    jbInit();
    jLabel1.setText(""String_Node_Str"" + configFile);
    model=Ajde.getDefault().getBuildConfigManager().buildModel(configFile);
    root=buildTree(model.getRoot());
    buildConfig_tree.setModel(new DefaultTreeModel(root));
    buildConfig_tree.addMouseListener(new ConfigFileMouseAdapter(buildConfig_tree));
    buildConfig_tree.setCellRenderer(new ConfigTreeCellRenderer());
    for (int j=0; j < buildConfig_tree.getRowCount(); j++) {
      buildConfig_tree.expandPath(buildConfig_tree.getPathForRow(j));
    }
  }
 catch (  Exception e) {
    Message msg=new Message(""String_Node_Str"",IMessage.ERROR,e,null);
    Ajde.getDefault().getMessageHandler().handleMessage(msg);
  }
}",0.9913924050632912
9205,"public void resolveBindings(IScope scope,Bindings bindings){
  if (onTypeSymbolic != null) {
    onType=onTypeSymbolic.resolveExactType(scope,bindings);
    if (ResolvedType.isMissing(onType))     return;
  }
  ResolvedType searchType;
  if (onType != null) {
    searchType=scope.getWorld().resolve(onType);
  }
 else {
    searchType=scope.getEnclosingType();
  }
  if (searchType.isTypeVariableReference()) {
    searchType=((TypeVariableReference)searchType).getTypeVariable().getUpperBound().resolve(scope.getWorld());
  }
  arguments.resolveBindings(scope,bindings,true,true);
  ResolvedPointcutDefinition pointcutDef=searchType.findPointcut(name);
  if (pointcutDef == null && onType == null) {
    while (true) {
      UnresolvedType declaringType=searchType.getDeclaringType();
      if (declaringType == null)       break;
      searchType=declaringType.resolve(scope.getWorld());
      pointcutDef=searchType.findPointcut(name);
      if (pointcutDef != null) {
        onType=searchType;
        break;
      }
    }
  }
  if (pointcutDef == null) {
    scope.message(IMessage.ERROR,this,""String_Node_Str"" + name);
    return;
  }
  if (!pointcutDef.isVisible(scope.getEnclosingType())) {
    scope.message(IMessage.ERROR,this,""String_Node_Str"" + pointcutDef + ""String_Node_Str"");
    return;
  }
  if (Modifier.isAbstract(pointcutDef.getModifiers())) {
    if (onType != null && !onType.isTypeVariableReference()) {
      scope.message(IMessage.ERROR,this,""String_Node_Str"");
      return;
    }
 else     if (!searchType.isAbstract()) {
      scope.message(IMessage.ERROR,this,""String_Node_Str"");
      return;
    }
  }
  ResolvedType[] parameterTypes=scope.getWorld().resolve(pointcutDef.getParameterTypes());
  if (parameterTypes.length != arguments.size()) {
    scope.message(IMessage.ERROR,this,""String_Node_Str"" + parameterTypes.length + ""String_Node_Str""+ arguments.size());
    return;
  }
  if (onType != null) {
    if (onType.isParameterizedType()) {
      typeVariableMap=new HashMap();
      ResolvedType underlyingGenericType=((ResolvedType)onType).getGenericType();
      TypeVariable[] tVars=underlyingGenericType.getTypeVariables();
      ResolvedType[] typeParams=((ResolvedType)onType).getResolvedTypeParameters();
      for (int i=0; i < tVars.length; i++) {
        typeVariableMap.put(tVars[i].getName(),typeParams[i]);
      }
    }
 else     if (onType.isGenericType()) {
      scope.message(MessageUtil.error(WeaverMessages.format(WeaverMessages.CANT_REFERENCE_POINTCUT_IN_RAW_TYPE),getSourceLocation()));
    }
  }
  for (int i=0, len=arguments.size(); i < len; i++) {
    TypePattern p=arguments.get(i);
    if (typeVariableMap != null) {
      p=p.parameterizeWith(typeVariableMap,scope.getWorld());
    }
    if (p == TypePattern.NO) {
      scope.message(IMessage.ERROR,this,""String_Node_Str"");
      return;
    }
    boolean reportProblem=false;
    if (parameterTypes[i].isTypeVariableReference() && p.getExactType().isTypeVariableReference()) {
      UnresolvedType One=((TypeVariableReference)parameterTypes[i]).getTypeVariable().getFirstBound();
      UnresolvedType Two=((TypeVariableReference)p.getExactType()).getTypeVariable().getFirstBound();
      reportProblem=!One.resolve(scope.getWorld()).isAssignableFrom(Two.resolve(scope.getWorld()));
    }
 else {
      reportProblem=!p.matchesSubtypes(parameterTypes[i]) && !p.getExactType().equals(UnresolvedType.OBJECT);
    }
    if (reportProblem) {
      scope.message(IMessage.ERROR,p,""String_Node_Str"" + parameterTypes[i].getName() + ""String_Node_Str""+ p+ ""String_Node_Str"");
      return;
    }
  }
}","public void resolveBindings(IScope scope,Bindings bindings){
  if (onTypeSymbolic != null) {
    onType=onTypeSymbolic.resolveExactType(scope,bindings);
    if (ResolvedType.isMissing(onType))     return;
  }
  ResolvedType searchType;
  if (onType != null) {
    searchType=scope.getWorld().resolve(onType);
  }
 else {
    searchType=scope.getEnclosingType();
  }
  if (searchType.isTypeVariableReference()) {
    searchType=((TypeVariableReference)searchType).getTypeVariable().getUpperBound().resolve(scope.getWorld());
  }
  arguments.resolveBindings(scope,bindings,true,true);
  ResolvedPointcutDefinition pointcutDef=searchType.findPointcut(name);
  if (pointcutDef == null && onType == null) {
    while (true) {
      UnresolvedType declaringType=searchType.getDeclaringType();
      if (declaringType == null)       break;
      searchType=declaringType.resolve(scope.getWorld());
      pointcutDef=searchType.findPointcut(name);
      if (pointcutDef != null) {
        onType=searchType;
        break;
      }
    }
  }
  if (pointcutDef == null) {
    scope.message(IMessage.ERROR,this,""String_Node_Str"" + name);
    return;
  }
  if (!pointcutDef.isVisible(scope.getEnclosingType())) {
    scope.message(IMessage.ERROR,this,""String_Node_Str"" + pointcutDef + ""String_Node_Str"");
    return;
  }
  if (Modifier.isAbstract(pointcutDef.getModifiers())) {
    if (onType != null && !onType.isTypeVariableReference()) {
      scope.message(IMessage.ERROR,this,""String_Node_Str"");
      return;
    }
 else     if (!searchType.isAbstract()) {
      scope.message(IMessage.ERROR,this,""String_Node_Str"");
      return;
    }
  }
  ResolvedType[] parameterTypes=scope.getWorld().resolve(pointcutDef.getParameterTypes());
  if (parameterTypes.length != arguments.size()) {
    scope.message(IMessage.ERROR,this,""String_Node_Str"" + parameterTypes.length + ""String_Node_Str""+ arguments.size());
    return;
  }
  if (onType != null) {
    if (onType.isParameterizedType()) {
      typeVariableMap=new HashMap();
      ResolvedType underlyingGenericType=((ResolvedType)onType).getGenericType();
      TypeVariable[] tVars=underlyingGenericType.getTypeVariables();
      ResolvedType[] typeParams=((ResolvedType)onType).getResolvedTypeParameters();
      for (int i=0; i < tVars.length; i++) {
        typeVariableMap.put(tVars[i].getName(),typeParams[i]);
      }
    }
 else     if (onType.isGenericType()) {
      scope.message(MessageUtil.error(WeaverMessages.format(WeaverMessages.CANT_REFERENCE_POINTCUT_IN_RAW_TYPE),getSourceLocation()));
    }
  }
  for (int i=0, len=arguments.size(); i < len; i++) {
    TypePattern p=arguments.get(i);
    if (typeVariableMap != null) {
      p=p.parameterizeWith(typeVariableMap,scope.getWorld());
    }
    if (p == TypePattern.NO) {
      scope.message(IMessage.ERROR,this,""String_Node_Str"");
      return;
    }
    boolean reportProblem=false;
    if (parameterTypes[i].isTypeVariableReference() && p.getExactType().isTypeVariableReference()) {
      UnresolvedType One=((TypeVariableReference)parameterTypes[i]).getTypeVariable().getFirstBound();
      UnresolvedType Two=((TypeVariableReference)p.getExactType()).getTypeVariable().getFirstBound();
      reportProblem=!One.resolve(scope.getWorld()).isAssignableFrom(Two.resolve(scope.getWorld()));
    }
 else {
      reportProblem=!p.matchesSubtypes(parameterTypes[i]) && !p.getExactType().equals(UnresolvedType.OBJECT);
    }
    if (reportProblem) {
      scope.message(IMessage.ERROR,this,""String_Node_Str"" + parameterTypes[i].getName() + ""String_Node_Str""+ p+ ""String_Node_Str"");
      return;
    }
  }
}",0.9993073832940852
9206,"public boolean match(Shadow shadow,World world){
  if (super.match(shadow,world)) {
    if (shadow.getKind() == Shadow.ExceptionHandler) {
      if (kind.isAfter() || kind == AdviceKind.Around) {
        world.showMessage(IMessage.WARNING,WeaverMessages.format(WeaverMessages.ONLY_BEFORE_ON_HANDLER),getSourceLocation(),shadow.getSourceLocation());
        return false;
      }
    }
    if (shadow.getKind() == Shadow.SynchronizationLock || shadow.getKind() == Shadow.SynchronizationUnlock) {
      if (kind == AdviceKind.Around) {
        world.showMessage(IMessage.WARNING,WeaverMessages.format(WeaverMessages.NO_AROUND_ON_SYNCHRONIZATION),getSourceLocation(),shadow.getSourceLocation());
        return false;
      }
    }
    if (hasExtraParameter() && kind == AdviceKind.AfterReturning) {
      ResolvedType resolvedExtraParameterType=getExtraParameterType().resolve(world);
      ResolvedType shadowReturnType=shadow.getReturnType().resolve(world);
      boolean matches=(resolvedExtraParameterType.isConvertableFrom(shadowReturnType) && shadow.getKind().hasReturnValue());
      if (matches && resolvedExtraParameterType.isParameterizedType()) {
        maybeIssueUncheckedMatchWarning(resolvedExtraParameterType,shadowReturnType,shadow,world);
      }
      return matches;
    }
 else     if (hasExtraParameter() && kind == AdviceKind.AfterThrowing) {
      ResolvedType exceptionType=getExtraParameterType().resolve(world);
      if (!exceptionType.isCheckedException())       return true;
      UnresolvedType[] shadowThrows=shadow.getSignature().getExceptions(world);
      boolean matches=false;
      for (int i=0; i < shadowThrows.length && !matches; i++) {
        ResolvedType type=shadowThrows[i].resolve(world);
        if (exceptionType.isAssignableFrom(type))         matches=true;
      }
      return matches;
    }
 else     if (kind == AdviceKind.PerTargetEntry) {
      return shadow.hasTarget();
    }
 else     if (kind == AdviceKind.PerThisEntry) {
      return shadow.hasThis();
    }
 else     if (kind == AdviceKind.Around) {
      if (shadow.getKind() == Shadow.PreInitialization) {
        world.showMessage(IMessage.ERROR,WeaverMessages.format(WeaverMessages.AROUND_ON_PREINIT),getSourceLocation(),shadow.getSourceLocation());
        return false;
      }
 else       if (shadow.getKind() == Shadow.Initialization) {
        world.showMessage(IMessage.ERROR,WeaverMessages.format(WeaverMessages.AROUND_ON_INIT),getSourceLocation(),shadow.getSourceLocation());
        return false;
      }
 else       if (shadow.getKind() == Shadow.StaticInitialization && shadow.getEnclosingType().resolve(world).isInterface()) {
        world.showMessage(IMessage.ERROR,WeaverMessages.format(WeaverMessages.AROUND_ON_INTERFACE_STATICINIT,shadow.getEnclosingType().getName()),getSourceLocation(),shadow.getSourceLocation());
        return false;
      }
 else {
        if (getSignature().getReturnType() == ResolvedType.VOID) {
          if (shadow.getReturnType() != ResolvedType.VOID) {
            world.showMessage(IMessage.ERROR,WeaverMessages.format(WeaverMessages.NON_VOID_RETURN,shadow),getSourceLocation(),shadow.getSourceLocation());
            return false;
          }
        }
 else         if (getSignature().getReturnType().equals(UnresolvedType.OBJECT)) {
          return true;
        }
 else {
          ResolvedType shadowReturnType=shadow.getReturnType().resolve(world);
          ResolvedType adviceReturnType=getSignature().getGenericReturnType().resolve(world);
          if (shadowReturnType.isParameterizedType() && adviceReturnType.isRawType()) {
            ResolvedType shadowReturnGenericType=shadowReturnType.getGenericType();
            ResolvedType adviceReturnGenericType=adviceReturnType.getGenericType();
            if (shadowReturnGenericType.isAssignableFrom(adviceReturnGenericType) && world.getLint().uncheckedAdviceConversion.isEnabled()) {
              world.getLint().uncheckedAdviceConversion.signal(new String[]{shadow.toString(),shadowReturnType.getName(),adviceReturnType.getName()},shadow.getSourceLocation(),new ISourceLocation[]{getSourceLocation()});
            }
          }
 else           if (!shadowReturnType.isAssignableFrom(adviceReturnType)) {
            world.showMessage(IMessage.ERROR,WeaverMessages.format(WeaverMessages.INCOMPATIBLE_RETURN_TYPE,shadow),getSourceLocation(),shadow.getSourceLocation());
            return false;
          }
        }
      }
    }
    return true;
  }
 else {
    return false;
  }
}","public boolean match(Shadow shadow,World world){
  if (super.match(shadow,world)) {
    if (shadow.getKind() == Shadow.ExceptionHandler) {
      if (kind.isAfter() || kind == AdviceKind.Around) {
        world.showMessage(IMessage.WARNING,WeaverMessages.format(WeaverMessages.ONLY_BEFORE_ON_HANDLER),getSourceLocation(),shadow.getSourceLocation());
        return false;
      }
    }
    if (shadow.getKind() == Shadow.SynchronizationLock || shadow.getKind() == Shadow.SynchronizationUnlock) {
      if (kind == AdviceKind.Around) {
        world.showMessage(IMessage.WARNING,WeaverMessages.format(WeaverMessages.NO_AROUND_ON_SYNCHRONIZATION),getSourceLocation(),shadow.getSourceLocation());
        return false;
      }
    }
    if (hasExtraParameter() && kind == AdviceKind.AfterReturning) {
      ResolvedType resolvedExtraParameterType=getExtraParameterType().resolve(world);
      ResolvedType shadowReturnType=shadow.getReturnType().resolve(world);
      boolean matches=(resolvedExtraParameterType.isConvertableFrom(shadowReturnType) && shadow.getKind().hasReturnValue());
      if (matches && resolvedExtraParameterType.isParameterizedType()) {
        maybeIssueUncheckedMatchWarning(resolvedExtraParameterType,shadowReturnType,shadow,world);
      }
      return matches;
    }
 else     if (hasExtraParameter() && kind == AdviceKind.AfterThrowing) {
      ResolvedType exceptionType=getExtraParameterType().resolve(world);
      if (!exceptionType.isCheckedException())       return true;
      UnresolvedType[] shadowThrows=shadow.getSignature().getExceptions(world);
      boolean matches=false;
      for (int i=0; i < shadowThrows.length && !matches; i++) {
        ResolvedType type=shadowThrows[i].resolve(world);
        if (exceptionType.isAssignableFrom(type))         matches=true;
      }
      return matches;
    }
 else     if (kind == AdviceKind.PerTargetEntry) {
      return shadow.hasTarget();
    }
 else     if (kind == AdviceKind.PerThisEntry) {
      return shadow.hasThis();
    }
 else     if (kind == AdviceKind.Around) {
      if (shadow.getKind() == Shadow.PreInitialization) {
        world.showMessage(IMessage.WARNING,WeaverMessages.format(WeaverMessages.AROUND_ON_PREINIT),getSourceLocation(),shadow.getSourceLocation());
        return false;
      }
 else       if (shadow.getKind() == Shadow.Initialization) {
        world.showMessage(IMessage.WARNING,WeaverMessages.format(WeaverMessages.AROUND_ON_INIT),getSourceLocation(),shadow.getSourceLocation());
        return false;
      }
 else       if (shadow.getKind() == Shadow.StaticInitialization && shadow.getEnclosingType().resolve(world).isInterface()) {
        world.showMessage(IMessage.ERROR,WeaverMessages.format(WeaverMessages.AROUND_ON_INTERFACE_STATICINIT,shadow.getEnclosingType().getName()),getSourceLocation(),shadow.getSourceLocation());
        return false;
      }
 else {
        if (getSignature().getReturnType() == ResolvedType.VOID) {
          if (shadow.getReturnType() != ResolvedType.VOID) {
            world.showMessage(IMessage.ERROR,WeaverMessages.format(WeaverMessages.NON_VOID_RETURN,shadow),getSourceLocation(),shadow.getSourceLocation());
            return false;
          }
        }
 else         if (getSignature().getReturnType().equals(UnresolvedType.OBJECT)) {
          return true;
        }
 else {
          ResolvedType shadowReturnType=shadow.getReturnType().resolve(world);
          ResolvedType adviceReturnType=getSignature().getGenericReturnType().resolve(world);
          if (shadowReturnType.isParameterizedType() && adviceReturnType.isRawType()) {
            ResolvedType shadowReturnGenericType=shadowReturnType.getGenericType();
            ResolvedType adviceReturnGenericType=adviceReturnType.getGenericType();
            if (shadowReturnGenericType.isAssignableFrom(adviceReturnGenericType) && world.getLint().uncheckedAdviceConversion.isEnabled()) {
              world.getLint().uncheckedAdviceConversion.signal(new String[]{shadow.toString(),shadowReturnType.getName(),adviceReturnType.getName()},shadow.getSourceLocation(),new ISourceLocation[]{getSourceLocation()});
            }
          }
 else           if (!shadowReturnType.isAssignableFrom(adviceReturnType)) {
            world.showMessage(IMessage.ERROR,WeaverMessages.format(WeaverMessages.INCOMPATIBLE_RETURN_TYPE,shadow),getSourceLocation(),shadow.getSourceLocation());
            return false;
          }
        }
      }
    }
    return true;
  }
 else {
    return false;
  }
}",0.99734219269103
9207,"public void afterProcessing(CompilationUnitDeclaration unit,int unitIndex){
  CompilationAndWeavingContext.leavingPhase(processingToken);
  eWorld.finishedCompilationUnit(unit);
  InterimCompilationResult intRes=new InterimCompilationResult(unit.compilationResult,outputFileNameProvider);
  if (unit.compilationResult.hasErrors())   reportedErrors=true;
  if (intermediateResultsRequestor != null) {
    intermediateResultsRequestor.acceptResult(intRes);
  }
  if (isXTerminateAfterCompilation || (reportedErrors && !proceedOnError)) {
    acceptResult(unit.compilationResult);
  }
 else {
    queueForWeaving(intRes);
  }
}","public void afterProcessing(CompilationUnitDeclaration unit,int unitIndex){
  CompilationAndWeavingContext.leavingPhase(processingToken);
  eWorld.finishedCompilationUnit(unit);
  InterimCompilationResult intRes=new InterimCompilationResult(unit.compilationResult,outputFileNameProvider);
  if (unit.compilationResult.hasErrors())   reportedErrors=true;
  if (intermediateResultsRequestor != null) {
    intermediateResultsRequestor.acceptResult(intRes);
  }
  if (unit.compilationResult.hasErrors() || (isXTerminateAfterCompilation || (reportedErrors && !proceedOnError))) {
    acceptResult(unit.compilationResult);
  }
 else {
    queueForWeaving(intRes);
  }
}",0.968944099378882
9208,"/** 
 * @throws AbortException if check for runtime fails 
 */
protected boolean doBuild(AjBuildConfig buildConfig,IMessageHandler baseHandler,boolean batch) throws IOException, AbortException {
  boolean ret=true;
  batchCompile=batch;
  wasFullBuild=batch;
  if (baseHandler instanceof ILifecycleAware) {
    ((ILifecycleAware)baseHandler).buildStarting(!batch);
  }
  CompilationAndWeavingContext.reset();
  int phase=batch ? CompilationAndWeavingContext.BATCH_BUILD : CompilationAndWeavingContext.INCREMENTAL_BUILD;
  ContextToken ct=CompilationAndWeavingContext.enteringPhase(phase,buildConfig);
  try {
    if (batch) {
      this.state=new AjState(this);
    }
    this.state.setCouldBeSubsequentIncrementalBuild(this.environmentSupportsIncrementalCompilation);
    boolean canIncremental=state.prepareForNextBuild(buildConfig);
    if (!canIncremental && !batch) {
      CompilationAndWeavingContext.leavingPhase(ct);
      if (state.listenerDefined())       state.getListener().recordDecision(""String_Node_Str"");
      return doBuild(buildConfig,baseHandler,true);
    }
    this.handler=CountingMessageHandler.makeCountingMessageHandler(baseHandler);
    if (buildConfig == null || buildConfig.isCheckRuntimeVersion()) {
      if (DO_RUNTIME_VERSION_CHECK) {
        String check=checkRtJar(buildConfig);
        if (check != null) {
          if (FAIL_IF_RUNTIME_NOT_FOUND) {
            MessageUtil.error(handler,check);
            CompilationAndWeavingContext.leavingPhase(ct);
            return false;
          }
 else {
            MessageUtil.warn(handler,check);
          }
        }
      }
    }
    setBuildConfig(buildConfig);
    if (batch || !AsmManager.attemptIncrementalModelRepairs) {
      setupModel(buildConfig);
    }
    if (batch) {
      initBcelWorld(handler);
    }
    if (handler.hasErrors()) {
      CompilationAndWeavingContext.leavingPhase(ct);
      return false;
    }
    if (buildConfig.getOutputJar() != null) {
      if (!openOutputStream(buildConfig.getOutputJar())) {
        CompilationAndWeavingContext.leavingPhase(ct);
        return false;
      }
    }
    if (batch) {
      if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode()) {
        getWorld().setModel(AsmManager.getDefault().getHierarchy());
      }
      binarySourcesForTheNextCompile=state.getBinaryFilesToCompile(true);
      performCompilation(buildConfig.getFiles());
      state.clearBinarySourceFiles();
      if (!continueWhenErrors && handler.hasErrors()) {
        CompilationAndWeavingContext.leavingPhase(ct);
        if (AsmManager.isReporting())         AsmManager.getDefault().reportModelInfo(""String_Node_Str"");
        return false;
      }
      if (AsmManager.isReporting())       AsmManager.getDefault().reportModelInfo(""String_Node_Str"");
    }
 else {
      binarySourcesForTheNextCompile=state.getBinaryFilesToCompile(true);
      Set files=state.getFilesToCompile(true);
      if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode())       if (AsmManager.attemptIncrementalModelRepairs)       AsmManager.getDefault().processDelta(files,state.getAddedFiles(),state.getDeletedFiles());
      boolean hereWeGoAgain=!(files.isEmpty() && binarySourcesForTheNextCompile.isEmpty());
      for (int i=0; (i < 5) && hereWeGoAgain; i++) {
        if (state.listenerDefined())         state.getListener().recordInformation(""String_Node_Str"" + (i + 1) + ""String_Node_Str"");
        performCompilation(files);
        if ((!continueWhenErrors && handler.hasErrors()) || (progressListener != null && progressListener.isCancelledRequested())) {
          CompilationAndWeavingContext.leavingPhase(ct);
          return false;
        }
        if (state.requiresFullBatchBuild()) {
          if (state.listenerDefined())           state.getListener().recordInformation(""String_Node_Str"");
          return batchBuild(buildConfig,baseHandler);
        }
        binarySourcesForTheNextCompile=state.getBinaryFilesToCompile(false);
        files=state.getFilesToCompile(false);
        hereWeGoAgain=!(files.isEmpty() && binarySourcesForTheNextCompile.isEmpty());
        if (hereWeGoAgain) {
          if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode())           if (AsmManager.attemptIncrementalModelRepairs)           AsmManager.getDefault().processDelta(files,state.getAddedFiles(),state.getDeletedFiles());
        }
      }
      if (!files.isEmpty()) {
        CompilationAndWeavingContext.leavingPhase(ct);
        return batchBuild(buildConfig,baseHandler);
      }
 else {
        if (AsmManager.isReporting())         AsmManager.getDefault().reportModelInfo(""String_Node_Str"");
      }
    }
    if (buildConfig.isEmacsSymMode()) {
      new org.aspectj.ajdt.internal.core.builder.EmacsStructureModelManager().externalizeModel();
    }
    if (buildConfig.isGenerateCrossRefsMode()) {
      File configFileProxy=new File(buildConfig.getOutputDir(),CROSSREFS_FILE_NAME);
      AsmManager.getDefault().writeStructureModel(configFileProxy.getAbsolutePath());
    }
    state.successfulCompile(buildConfig,batch);
    copyResourcesToDestination();
    if (buildConfig.getOutxmlName() != null) {
      writeOutxmlFile();
    }
    if (buildConfig.isGenerateModelMode()) {
      AsmManager.getDefault().fireModelUpdated();
    }
    CompilationAndWeavingContext.leavingPhase(ct);
  }
  finally {
    if (baseHandler instanceof ILifecycleAware) {
      ((ILifecycleAware)baseHandler).buildFinished(!batch);
    }
    if (zos != null) {
      closeOutputStream(buildConfig.getOutputJar());
    }
    ret=!handler.hasErrors();
    if (getBcelWorld() != null)     getBcelWorld().tidyUp();
    if (getWeaver() != null)     getWeaver().tidyUp();
  }
  return ret;
}","/** 
 * @throws AbortException if check for runtime fails 
 */
protected boolean doBuild(AjBuildConfig buildConfig,IMessageHandler baseHandler,boolean batch) throws IOException, AbortException {
  boolean ret=true;
  batchCompile=batch;
  wasFullBuild=batch;
  if (baseHandler instanceof ILifecycleAware) {
    ((ILifecycleAware)baseHandler).buildStarting(!batch);
  }
  CompilationAndWeavingContext.reset();
  int phase=batch ? CompilationAndWeavingContext.BATCH_BUILD : CompilationAndWeavingContext.INCREMENTAL_BUILD;
  ContextToken ct=CompilationAndWeavingContext.enteringPhase(phase,buildConfig);
  try {
    if (batch) {
      this.state=new AjState(this);
    }
    this.state.setCouldBeSubsequentIncrementalBuild(this.environmentSupportsIncrementalCompilation);
    boolean canIncremental=state.prepareForNextBuild(buildConfig);
    if (!canIncremental && !batch) {
      CompilationAndWeavingContext.leavingPhase(ct);
      if (state.listenerDefined())       state.getListener().recordDecision(""String_Node_Str"");
      return doBuild(buildConfig,baseHandler,true);
    }
    this.handler=CountingMessageHandler.makeCountingMessageHandler(baseHandler);
    if (buildConfig == null || buildConfig.isCheckRuntimeVersion()) {
      if (DO_RUNTIME_VERSION_CHECK) {
        String check=checkRtJar(buildConfig);
        if (check != null) {
          if (FAIL_IF_RUNTIME_NOT_FOUND) {
            MessageUtil.error(handler,check);
            CompilationAndWeavingContext.leavingPhase(ct);
            return false;
          }
 else {
            MessageUtil.warn(handler,check);
          }
        }
      }
    }
    setBuildConfig(buildConfig);
    if (batch || !AsmManager.attemptIncrementalModelRepairs) {
      setupModel(buildConfig);
    }
    if (batch) {
      initBcelWorld(handler);
    }
    if (handler.hasErrors()) {
      CompilationAndWeavingContext.leavingPhase(ct);
      return false;
    }
    if (buildConfig.getOutputJar() != null) {
      if (!openOutputStream(buildConfig.getOutputJar())) {
        CompilationAndWeavingContext.leavingPhase(ct);
        return false;
      }
    }
    if (batch) {
      if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode()) {
        getWorld().setModel(AsmManager.getDefault().getHierarchy());
      }
      binarySourcesForTheNextCompile=state.getBinaryFilesToCompile(true);
      performCompilation(buildConfig.getFiles());
      state.clearBinarySourceFiles();
      if (!proceedOnError() && handler.hasErrors()) {
        CompilationAndWeavingContext.leavingPhase(ct);
        if (AsmManager.isReporting())         AsmManager.getDefault().reportModelInfo(""String_Node_Str"");
        return false;
      }
      if (AsmManager.isReporting())       AsmManager.getDefault().reportModelInfo(""String_Node_Str"");
    }
 else {
      binarySourcesForTheNextCompile=state.getBinaryFilesToCompile(true);
      Set files=state.getFilesToCompile(true);
      if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode())       if (AsmManager.attemptIncrementalModelRepairs)       AsmManager.getDefault().processDelta(files,state.getAddedFiles(),state.getDeletedFiles());
      boolean hereWeGoAgain=!(files.isEmpty() && binarySourcesForTheNextCompile.isEmpty());
      for (int i=0; (i < 5) && hereWeGoAgain; i++) {
        if (state.listenerDefined())         state.getListener().recordInformation(""String_Node_Str"" + (i + 1) + ""String_Node_Str"");
        performCompilation(files);
        if ((!proceedOnError() && handler.hasErrors()) || (progressListener != null && progressListener.isCancelledRequested())) {
          CompilationAndWeavingContext.leavingPhase(ct);
          return false;
        }
        if (state.requiresFullBatchBuild()) {
          if (state.listenerDefined())           state.getListener().recordInformation(""String_Node_Str"");
          return batchBuild(buildConfig,baseHandler);
        }
        binarySourcesForTheNextCompile=state.getBinaryFilesToCompile(false);
        files=state.getFilesToCompile(false);
        hereWeGoAgain=!(files.isEmpty() && binarySourcesForTheNextCompile.isEmpty());
        if (hereWeGoAgain) {
          if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode())           if (AsmManager.attemptIncrementalModelRepairs)           AsmManager.getDefault().processDelta(files,state.getAddedFiles(),state.getDeletedFiles());
        }
      }
      if (!files.isEmpty()) {
        CompilationAndWeavingContext.leavingPhase(ct);
        return batchBuild(buildConfig,baseHandler);
      }
 else {
        if (AsmManager.isReporting())         AsmManager.getDefault().reportModelInfo(""String_Node_Str"");
      }
    }
    if (buildConfig.isEmacsSymMode()) {
      new org.aspectj.ajdt.internal.core.builder.EmacsStructureModelManager().externalizeModel();
    }
    if (buildConfig.isGenerateCrossRefsMode()) {
      File configFileProxy=new File(buildConfig.getOutputDir(),CROSSREFS_FILE_NAME);
      AsmManager.getDefault().writeStructureModel(configFileProxy.getAbsolutePath());
    }
    state.successfulCompile(buildConfig,batch);
    copyResourcesToDestination();
    if (buildConfig.getOutxmlName() != null) {
      writeOutxmlFile();
    }
    if (buildConfig.isGenerateModelMode()) {
      AsmManager.getDefault().fireModelUpdated();
    }
    CompilationAndWeavingContext.leavingPhase(ct);
  }
  finally {
    if (baseHandler instanceof ILifecycleAware) {
      ((ILifecycleAware)baseHandler).buildFinished(!batch);
    }
    if (zos != null) {
      closeOutputStream(buildConfig.getOutputJar());
    }
    ret=!handler.hasErrors();
    if (getBcelWorld() != null)     getBcelWorld().tidyUp();
    if (getWeaver() != null)     getWeaver().tidyUp();
  }
  return ret;
}",0.9961659114674104
9209,"public ICompilerRequestor getBatchRequestor(){
  return new ICompilerRequestor(){
    public void acceptResult(    CompilationResult unitResult){
      if (!((unitResult.hasErrors() && !continueWhenErrors) && !proceedOnError())) {
        Collection classFiles=unitResult.compiledTypes.values();
        boolean shouldAddAspectName=(buildConfig.getOutxmlName() != null);
        for (Iterator iter=classFiles.iterator(); iter.hasNext(); ) {
          ClassFile classFile=(ClassFile)iter.next();
          String filename=new String(classFile.fileName());
          String classname=filename.replace('/','.');
          filename=filename.replace('/',File.separatorChar) + ""String_Node_Str"";
          try {
            if (buildConfig.getOutputJar() == null) {
              writeDirectoryEntry(unitResult,classFile,filename);
            }
 else {
              writeZipEntry(classFile,filename);
            }
            if (shouldAddAspectName)             addAspectName(classname,unitResult.getFileName());
          }
 catch (          IOException ex) {
            IMessage message=EclipseAdapterUtils.makeErrorMessage(new String(unitResult.fileName),CANT_WRITE_RESULT,ex);
            handler.handleMessage(message);
          }
        }
        unitResult.compiledTypes.clear();
      }
      if (unitResult.hasProblems() || unitResult.hasTasks()) {
        IProblem[] problems=unitResult.getAllProblems();
        for (int i=0; i < problems.length; i++) {
          IMessage message=EclipseAdapterUtils.makeMessage(unitResult.compilationUnit,problems[i],getBcelWorld());
          handler.handleMessage(message);
        }
      }
    }
    private void writeDirectoryEntry(    CompilationResult unitResult,    ClassFile classFile,    String filename) throws IOException {
      File destinationPath=buildConfig.getOutputDir();
      if (buildConfig.getCompilationResultDestinationManager() != null) {
        destinationPath=buildConfig.getCompilationResultDestinationManager().getOutputLocationForClass(new File(new String(unitResult.fileName)));
      }
      String outFile;
      if (destinationPath == null) {
        outFile=new File(filename).getName();
        outFile=new File(extractDestinationPathFromSourceFile(unitResult),outFile).getPath();
      }
 else {
        outFile=new File(destinationPath,filename).getPath();
      }
      BufferedOutputStream os=FileUtil.makeOutputStream(new File(outFile));
      os.write(classFile.getBytes());
      os.close();
    }
    private void writeZipEntry(    ClassFile classFile,    String name) throws IOException {
      name=name.replace(File.separatorChar,'/');
      ZipEntry newEntry=new ZipEntry(name);
      zos.putNextEntry(newEntry);
      zos.write(classFile.getBytes());
      zos.closeEntry();
    }
    private void addAspectName(    String name,    char[] fileContainingAspect){
      BcelWorld world=getBcelWorld();
      ResolvedType type=world.resolve(name);
      if (type.isAspect()) {
        if (state.getAspectNamesToFileNameMap() == null) {
          state.initializeAspectNamesToFileNameMap();
        }
        if (!state.getAspectNamesToFileNameMap().containsKey(name)) {
          state.getAspectNamesToFileNameMap().put(name,fileContainingAspect);
        }
      }
    }
  }
;
}","public ICompilerRequestor getBatchRequestor(){
  return new ICompilerRequestor(){
    public void acceptResult(    CompilationResult unitResult){
      if (!unitResult.hasErrors() || proceedOnError()) {
        Collection classFiles=unitResult.compiledTypes.values();
        boolean shouldAddAspectName=(buildConfig.getOutxmlName() != null);
        for (Iterator iter=classFiles.iterator(); iter.hasNext(); ) {
          ClassFile classFile=(ClassFile)iter.next();
          String filename=new String(classFile.fileName());
          String classname=filename.replace('/','.');
          filename=filename.replace('/',File.separatorChar) + ""String_Node_Str"";
          try {
            if (buildConfig.getOutputJar() == null) {
              writeDirectoryEntry(unitResult,classFile,filename);
            }
 else {
              writeZipEntry(classFile,filename);
            }
            if (shouldAddAspectName)             addAspectName(classname,unitResult.getFileName());
          }
 catch (          IOException ex) {
            IMessage message=EclipseAdapterUtils.makeErrorMessage(new String(unitResult.fileName),CANT_WRITE_RESULT,ex);
            handler.handleMessage(message);
          }
        }
        unitResult.compiledTypes.clear();
      }
      if (unitResult.hasProblems() || unitResult.hasTasks()) {
        IProblem[] problems=unitResult.getAllProblems();
        for (int i=0; i < problems.length; i++) {
          IMessage message=EclipseAdapterUtils.makeMessage(unitResult.compilationUnit,problems[i],getBcelWorld());
          handler.handleMessage(message);
        }
      }
    }
    private void writeDirectoryEntry(    CompilationResult unitResult,    ClassFile classFile,    String filename) throws IOException {
      File destinationPath=buildConfig.getOutputDir();
      if (buildConfig.getCompilationResultDestinationManager() != null) {
        destinationPath=buildConfig.getCompilationResultDestinationManager().getOutputLocationForClass(new File(new String(unitResult.fileName)));
      }
      String outFile;
      if (destinationPath == null) {
        outFile=new File(filename).getName();
        outFile=new File(extractDestinationPathFromSourceFile(unitResult),outFile).getPath();
      }
 else {
        outFile=new File(destinationPath,filename).getPath();
      }
      BufferedOutputStream os=FileUtil.makeOutputStream(new File(outFile));
      os.write(classFile.getBytes());
      os.close();
    }
    private void writeZipEntry(    ClassFile classFile,    String name) throws IOException {
      name=name.replace(File.separatorChar,'/');
      ZipEntry newEntry=new ZipEntry(name);
      zos.putNextEntry(newEntry);
      zos.write(classFile.getBytes());
      zos.closeEntry();
    }
    private void addAspectName(    String name,    char[] fileContainingAspect){
      BcelWorld world=getBcelWorld();
      ResolvedType type=world.resolve(name);
      if (type.isAspect()) {
        if (state.getAspectNamesToFileNameMap() == null) {
          state.initializeAspectNamesToFileNameMap();
        }
        if (!state.getAspectNamesToFileNameMap().containsKey(name)) {
          state.getAspectNamesToFileNameMap().put(name,fileContainingAspect);
        }
      }
    }
  }
;
}",0.9920245398773008
9210,"public void acceptResult(CompilationResult unitResult){
  if (!((unitResult.hasErrors() && !continueWhenErrors) && !proceedOnError())) {
    Collection classFiles=unitResult.compiledTypes.values();
    boolean shouldAddAspectName=(buildConfig.getOutxmlName() != null);
    for (Iterator iter=classFiles.iterator(); iter.hasNext(); ) {
      ClassFile classFile=(ClassFile)iter.next();
      String filename=new String(classFile.fileName());
      String classname=filename.replace('/','.');
      filename=filename.replace('/',File.separatorChar) + ""String_Node_Str"";
      try {
        if (buildConfig.getOutputJar() == null) {
          writeDirectoryEntry(unitResult,classFile,filename);
        }
 else {
          writeZipEntry(classFile,filename);
        }
        if (shouldAddAspectName)         addAspectName(classname,unitResult.getFileName());
      }
 catch (      IOException ex) {
        IMessage message=EclipseAdapterUtils.makeErrorMessage(new String(unitResult.fileName),CANT_WRITE_RESULT,ex);
        handler.handleMessage(message);
      }
    }
    unitResult.compiledTypes.clear();
  }
  if (unitResult.hasProblems() || unitResult.hasTasks()) {
    IProblem[] problems=unitResult.getAllProblems();
    for (int i=0; i < problems.length; i++) {
      IMessage message=EclipseAdapterUtils.makeMessage(unitResult.compilationUnit,problems[i],getBcelWorld());
      handler.handleMessage(message);
    }
  }
}","public void acceptResult(CompilationResult unitResult){
  if (!unitResult.hasErrors() || proceedOnError()) {
    Collection classFiles=unitResult.compiledTypes.values();
    boolean shouldAddAspectName=(buildConfig.getOutxmlName() != null);
    for (Iterator iter=classFiles.iterator(); iter.hasNext(); ) {
      ClassFile classFile=(ClassFile)iter.next();
      String filename=new String(classFile.fileName());
      String classname=filename.replace('/','.');
      filename=filename.replace('/',File.separatorChar) + ""String_Node_Str"";
      try {
        if (buildConfig.getOutputJar() == null) {
          writeDirectoryEntry(unitResult,classFile,filename);
        }
 else {
          writeZipEntry(classFile,filename);
        }
        if (shouldAddAspectName)         addAspectName(classname,unitResult.getFileName());
      }
 catch (      IOException ex) {
        IMessage message=EclipseAdapterUtils.makeErrorMessage(new String(unitResult.fileName),CANT_WRITE_RESULT,ex);
        handler.handleMessage(message);
      }
    }
    unitResult.compiledTypes.clear();
  }
  if (unitResult.hasProblems() || unitResult.hasTasks()) {
    IProblem[] problems=unitResult.getAllProblems();
    for (int i=0; i < problems.length; i++) {
      IMessage message=EclipseAdapterUtils.makeMessage(unitResult.compilationUnit,problems[i],getBcelWorld());
      handler.handleMessage(message);
    }
  }
}",0.9816124469589816
9211,"/** 
 * Compile C1.java that defines C.class then compile C2.java which contains another version of C.class but also contains errors.  Because -proceedOnError is not supplied, the .class file should not be touched when compiling C2.java.
 */
public void testNoProceedOnError() throws IOException {
  try {
    AjBuildManager.continueWhenErrors=false;
    checkCompile(""String_Node_Str"",NO_ERRORS);
    File f=new File(getSandboxName(),""String_Node_Str"");
    long oldmodtime=f.lastModified();
    pause(2);
    checkCompile(""String_Node_Str"",new int[]{1});
    f=new File(getSandboxName(),""String_Node_Str"");
    long newmodtime=f.lastModified();
    assertTrue(""String_Node_Str"" + new Date(oldmodtime).toString() + ""String_Node_Str""+ new Date(newmodtime).toString()+ ""String_Node_Str"",oldmodtime == newmodtime);
  }
  finally {
    AjBuildManager.continueWhenErrors=true;
  }
}","/** 
 * Compile C1.java that defines C.class then compile C2.java which contains another version of C.class but also contains errors.  Because -proceedOnError is not supplied, the .class file should not be touched when compiling C2.java.
 */
public void testNoProceedOnError() throws IOException {
  checkCompile(""String_Node_Str"",NO_ERRORS);
  File f=new File(getSandboxName(),""String_Node_Str"");
  long oldmodtime=f.lastModified();
  pause(2);
  checkCompile(""String_Node_Str"",new int[]{1});
  f=new File(getSandboxName(),""String_Node_Str"");
  long newmodtime=f.lastModified();
  assertTrue(""String_Node_Str"" + new Date(oldmodtime).toString() + ""String_Node_Str""+ new Date(newmodtime).toString()+ ""String_Node_Str"",oldmodtime == newmodtime);
}",0.918052988293284
9212,"/** 
 * Generate a new AjBuildConfig from the compiler configuration associated with this AjdeCoreBuildManager
 * @return null if invalid configuration, corresponding AjBuildConfig otherwise
 */
public AjBuildConfig genAjBuildConfig(){
  File configFile=new File(compiler.getId());
  String[] args=null;
  if (configFile.exists() && configFile.isFile()) {
    args=new String[]{""String_Node_Str"" + configFile.getAbsolutePath()};
  }
 else {
    List l=compiler.getCompilerConfiguration().getProjectSourceFiles();
    if (l == null)     return null;
    args=new String[l.size()];
    int counter=0;
    for (Iterator iter=l.iterator(); iter.hasNext(); ) {
      String element=(String)iter.next();
      args[counter]=element;
      counter++;
    }
  }
  CountingMessageHandler handler=CountingMessageHandler.makeCountingMessageHandler(msgHandlerAdapter);
  BuildArgParser parser=new BuildArgParser(handler);
  AjBuildConfig config=new AjBuildConfig();
  parser.populateBuildConfig(config,args,false,configFile);
  configureCompilerOptions(config);
  ISourceLocation location=null;
  if (config.getConfigFile() != null) {
    location=new SourceLocation(config.getConfigFile(),0);
  }
  String message=parser.getOtherMessages(true);
  if (null != message) {
    IMessage m=new Message(message,IMessage.ERROR,null,location);
    handler.handleMessage(m);
  }
  config.setGenerateModelMode(true);
  config.setIncrementalMode(true);
  return config;
}","/** 
 * Generate a new AjBuildConfig from the compiler configuration associated with this AjdeCoreBuildManager
 * @return null if invalid configuration, corresponding AjBuildConfig otherwise
 */
public AjBuildConfig genAjBuildConfig(){
  File configFile=new File(compiler.getId());
  String[] args=null;
  if (configFile.exists() && configFile.isFile()) {
    args=new String[]{""String_Node_Str"" + configFile.getAbsolutePath()};
  }
 else {
    List l=compiler.getCompilerConfiguration().getProjectSourceFiles();
    if (l == null)     return null;
    args=new String[l.size()];
    int counter=0;
    for (Iterator iter=l.iterator(); iter.hasNext(); ) {
      String element=(String)iter.next();
      args[counter]=element;
      counter++;
    }
  }
  CountingMessageHandler handler=CountingMessageHandler.makeCountingMessageHandler(msgHandlerAdapter);
  BuildArgParser parser=new BuildArgParser(handler);
  AjBuildConfig config=new AjBuildConfig();
  parser.populateBuildConfig(config,args,false,configFile);
  configureCompilerOptions(config);
  ISourceLocation location=null;
  if (config.getConfigFile() != null) {
    location=new SourceLocation(config.getConfigFile(),0);
  }
  String message=parser.getOtherMessages(true);
  if (null != message) {
    IMessage m=new Message(message,IMessage.ERROR,null,location);
    handler.handleMessage(m);
  }
  config.setGenerateModelMode(true);
  config.setIncrementalMode(true);
  config.setProceedOnError(true);
  return config;
}",0.9884038199181446
9213,"/** 
 * resolve one of these funky things. Need to: <br> (a) Check the formal is bound <br> (b) Check the annotation type is valid
 */
public AnnotationTypePattern resolveBindings(IScope scope,Bindings bindings,boolean allowBinding){
  if (resolved)   return this;
  resolved=true;
  FormalBinding formalBinding=scope.lookupFormal(formalName);
  if (formalBinding == null) {
    scope.message(IMessage.ERROR,this,""String_Node_Str"");
  }
  annotationType=scope.getWorld().resolve(annotationType,true);
  if (ResolvedType.isMissing(annotationType)) {
    String cleanname=annotationType.getName();
    UnresolvedType type=null;
    while (ResolvedType.isMissing(type=scope.lookupType(cleanname,this))) {
      int lastDot=cleanname.lastIndexOf('.');
      if (lastDot == -1)       break;
      cleanname=cleanname.substring(0,lastDot) + ""String_Node_Str"" + cleanname.substring(lastDot + 1);
    }
    annotationType=scope.getWorld().resolve(type,true);
  }
  verifyIsAnnotationType((ResolvedType)annotationType,scope);
  if (!formalBinding.getType().resolve(scope.getWorld()).isEnum()) {
    scope.message(IMessage.ERROR,this,""String_Node_Str"" + formalBinding.getType() + ""String_Node_Str"");
  }
  bindingPattern=true;
  ReferenceType theAnnotationType=(ReferenceType)annotationType;
  ResolvedMember[] annotationFields=theAnnotationType.getDeclaredMethods();
  field=null;
  for (int i=0; i < annotationFields.length; i++) {
    ResolvedMember resolvedMember=annotationFields[i];
    if (resolvedMember.getReturnType().equals(formalBinding.getType())) {
      if (field != null) {
        scope.message(IMessage.ERROR,this,""String_Node_Str"" + formalBinding.getType() + ""String_Node_Str""+ theAnnotationType.getName()+ ""String_Node_Str"");
      }
      field=resolvedMember;
    }
  }
  if (field == null) {
    scope.message(IMessage.ERROR,this,""String_Node_Str"" + formalBinding.getType() + ""String_Node_Str""+ theAnnotationType.getName()+ ""String_Node_Str"");
  }
  BindingAnnotationFieldTypePattern binding=new BindingAnnotationFieldTypePattern(formalBinding.getType(),formalBinding.getIndex(),theAnnotationType);
  binding.copyLocationFrom(this);
  bindings.register(binding,scope);
  binding.resolveBinding(scope.getWorld());
  return binding;
}","/** 
 * resolve one of these funky things. Need to: <br> (a) Check the formal is bound <br> (b) Check the annotation type is valid
 */
public AnnotationTypePattern resolveBindings(IScope scope,Bindings bindings,boolean allowBinding){
  if (resolved)   return this;
  resolved=true;
  FormalBinding formalBinding=scope.lookupFormal(formalName);
  if (formalBinding == null) {
    scope.message(IMessage.ERROR,this,""String_Node_Str"");
    return this;
  }
  annotationType=scope.getWorld().resolve(annotationType,true);
  if (ResolvedType.isMissing(annotationType)) {
    String cleanname=annotationType.getName();
    UnresolvedType type=null;
    while (ResolvedType.isMissing(type=scope.lookupType(cleanname,this))) {
      int lastDot=cleanname.lastIndexOf('.');
      if (lastDot == -1)       break;
      cleanname=cleanname.substring(0,lastDot) + ""String_Node_Str"" + cleanname.substring(lastDot + 1);
    }
    annotationType=scope.getWorld().resolve(type,true);
  }
  verifyIsAnnotationType((ResolvedType)annotationType,scope);
  if (!formalBinding.getType().resolve(scope.getWorld()).isEnum()) {
    scope.message(IMessage.ERROR,this,""String_Node_Str"" + formalBinding.getType() + ""String_Node_Str"");
  }
  bindingPattern=true;
  ReferenceType theAnnotationType=(ReferenceType)annotationType;
  ResolvedMember[] annotationFields=theAnnotationType.getDeclaredMethods();
  field=null;
  for (int i=0; i < annotationFields.length; i++) {
    ResolvedMember resolvedMember=annotationFields[i];
    if (resolvedMember.getReturnType().equals(formalBinding.getType())) {
      if (field != null) {
        scope.message(IMessage.ERROR,this,""String_Node_Str"" + formalBinding.getType() + ""String_Node_Str""+ theAnnotationType.getName()+ ""String_Node_Str"");
      }
      field=resolvedMember;
    }
  }
  if (field == null) {
    scope.message(IMessage.ERROR,this,""String_Node_Str"" + formalBinding.getType() + ""String_Node_Str""+ theAnnotationType.getName()+ ""String_Node_Str"");
  }
  BindingAnnotationFieldTypePattern binding=new BindingAnnotationFieldTypePattern(formalBinding.getType(),formalBinding.getIndex(),theAnnotationType);
  binding.copyLocationFrom(this);
  bindings.register(binding,scope);
  binding.resolveBinding(scope.getWorld());
  return binding;
}",0.9962280896383404
9214,"public AnnotationTargetKind[] getAnnotationTargetKinds(){
  if ((bitflag & DISCOVERED_ANNOTATION_TARGET_KINDS) != 0)   return annotationTargetKinds;
  bitflag|=DISCOVERED_ANNOTATION_TARGET_KINDS;
  annotationTargetKinds=null;
  List targetKinds=new ArrayList();
  if (isAnnotation()) {
    Annotation[] annotationsOnThisType=javaClass.getAnnotations();
    for (int i=0; i < annotationsOnThisType.length; i++) {
      Annotation a=annotationsOnThisType[i];
      if (a.getTypeName().equals(UnresolvedType.AT_TARGET.getName())) {
        ArrayElementValue arrayValue=(ArrayElementValue)((ElementNameValuePair)a.getValues().get(0)).getValue();
        ElementValue[] evs=arrayValue.getElementValuesArray();
        if (evs != null) {
          for (int j=0; j < evs.length; j++) {
            String targetKind=((EnumElementValue)evs[j]).getEnumValueString();
            if (targetKind.equals(""String_Node_Str"")) {
              targetKinds.add(AnnotationTargetKind.ANNOTATION_TYPE);
            }
 else             if (targetKind.equals(""String_Node_Str"")) {
              targetKinds.add(AnnotationTargetKind.CONSTRUCTOR);
            }
 else             if (targetKind.equals(""String_Node_Str"")) {
              targetKinds.add(AnnotationTargetKind.FIELD);
            }
 else             if (targetKind.equals(""String_Node_Str"")) {
              targetKinds.add(AnnotationTargetKind.LOCAL_VARIABLE);
            }
 else             if (targetKind.equals(""String_Node_Str"")) {
              targetKinds.add(AnnotationTargetKind.METHOD);
            }
 else             if (targetKind.equals(""String_Node_Str"")) {
              targetKinds.add(AnnotationTargetKind.PACKAGE);
            }
 else             if (targetKind.equals(""String_Node_Str"")) {
              targetKinds.add(AnnotationTargetKind.PARAMETER);
            }
 else             if (targetKind.equals(""String_Node_Str"")) {
              targetKinds.add(AnnotationTargetKind.TYPE);
            }
          }
        }
      }
    }
    if (!targetKinds.isEmpty()) {
      annotationTargetKinds=new AnnotationTargetKind[targetKinds.size()];
      return (AnnotationTargetKind[])targetKinds.toArray(annotationTargetKinds);
    }
  }
  return annotationTargetKinds;
}","public AnnotationTargetKind[] getAnnotationTargetKinds(){
  if ((bitflag & DISCOVERED_ANNOTATION_TARGET_KINDS) != 0)   return annotationTargetKinds;
  bitflag|=DISCOVERED_ANNOTATION_TARGET_KINDS;
  annotationTargetKinds=null;
  List targetKinds=new ArrayList();
  if (isAnnotation()) {
    AnnotationX[] annotationsOnThisType=getAnnotations();
    for (int i=0; i < annotationsOnThisType.length; i++) {
      Annotation a=annotationsOnThisType[i].getBcelAnnotation();
      if (a.getTypeName().equals(UnresolvedType.AT_TARGET.getName())) {
        ArrayElementValue arrayValue=(ArrayElementValue)((ElementNameValuePair)a.getValues().get(0)).getValue();
        ElementValue[] evs=arrayValue.getElementValuesArray();
        if (evs != null) {
          for (int j=0; j < evs.length; j++) {
            String targetKind=((EnumElementValue)evs[j]).getEnumValueString();
            if (targetKind.equals(""String_Node_Str"")) {
              targetKinds.add(AnnotationTargetKind.ANNOTATION_TYPE);
            }
 else             if (targetKind.equals(""String_Node_Str"")) {
              targetKinds.add(AnnotationTargetKind.CONSTRUCTOR);
            }
 else             if (targetKind.equals(""String_Node_Str"")) {
              targetKinds.add(AnnotationTargetKind.FIELD);
            }
 else             if (targetKind.equals(""String_Node_Str"")) {
              targetKinds.add(AnnotationTargetKind.LOCAL_VARIABLE);
            }
 else             if (targetKind.equals(""String_Node_Str"")) {
              targetKinds.add(AnnotationTargetKind.METHOD);
            }
 else             if (targetKind.equals(""String_Node_Str"")) {
              targetKinds.add(AnnotationTargetKind.PACKAGE);
            }
 else             if (targetKind.equals(""String_Node_Str"")) {
              targetKinds.add(AnnotationTargetKind.PARAMETER);
            }
 else             if (targetKind.equals(""String_Node_Str"")) {
              targetKinds.add(AnnotationTargetKind.TYPE);
            }
          }
        }
      }
    }
    if (!targetKinds.isEmpty()) {
      annotationTargetKinds=new AnnotationTargetKind[targetKinds.size()];
      return (AnnotationTargetKind[])targetKinds.toArray(annotationTargetKinds);
    }
  }
  return annotationTargetKinds;
}",0.993069528280796
9215,"public void abstractMethodMustBeImplemented(SourceTypeBinding type,MethodBinding abstractMethod){
  if (isPointcutDeclaration(abstractMethod))   return;
  if (isIntertypeDeclaration(abstractMethod))   return;
  if (CharOperation.prefixEquals(""String_Node_Str"".toCharArray(),abstractMethod.selector)) {
    return;
  }
  ResolvedType onTypeX=null;
  if (!type.isAnonymousType()) {
    onTypeX=factory.fromEclipse(type);
  }
 else {
    onTypeX=factory.fromEclipse(type.superclass());
  }
  for (Iterator i=onTypeX.getInterTypeMungersIncludingSupers().iterator(); i.hasNext(); ) {
    ConcreteTypeMunger m=(ConcreteTypeMunger)i.next();
    ResolvedMember sig=m.getSignature();
    if (!Modifier.isAbstract(sig.getModifiers())) {
      if (ResolvedType.matches(AjcMemberMaker.interMethod(sig,m.getAspectType(),sig.getDeclaringType().resolve(factory.getWorld()).isInterface()),factory.makeResolvedMember(abstractMethod))) {
        return;
      }
    }
  }
  super.abstractMethodMustBeImplemented(type,abstractMethod);
}","public void abstractMethodMustBeImplemented(SourceTypeBinding type,MethodBinding abstractMethod){
  if (isPointcutDeclaration(abstractMethod))   return;
  if (isIntertypeDeclaration(abstractMethod))   return;
  if (CharOperation.prefixEquals(""String_Node_Str"".toCharArray(),abstractMethod.selector)) {
    return;
  }
  ResolvedType onTypeX=null;
  if (!type.isAnonymousType()) {
    onTypeX=factory.fromEclipse(type);
  }
 else {
    onTypeX=factory.fromEclipse(type.superclass());
  }
  if (onTypeX.isRawType())   onTypeX=onTypeX.getGenericType();
  for (Iterator i=onTypeX.getInterTypeMungersIncludingSupers().iterator(); i.hasNext(); ) {
    ConcreteTypeMunger m=(ConcreteTypeMunger)i.next();
    ResolvedMember sig=m.getSignature();
    if (!Modifier.isAbstract(sig.getModifiers())) {
      ResolvedMember abstractMember=factory.makeResolvedMember(abstractMethod);
      if (abstractMember.getName().startsWith(""String_Node_Str"")) {
        if (ResolvedType.matches(AjcMemberMaker.interMethod(sig,m.getAspectType(),sig.getDeclaringType().resolve(factory.getWorld()).isInterface()),abstractMember)) {
          return;
        }
      }
 else {
        if (ResolvedType.matches(sig,factory.makeResolvedMember(abstractMethod)))         return;
      }
    }
  }
  super.abstractMethodMustBeImplemented(type,abstractMethod);
}",0.8656716417910447
9216,"/** 
 * Weave
 * @param className
 * @param bytes
 * @param loader
 * @return weaved bytes
 */
public byte[] preProcess(String className,byte[] bytes,ClassLoader loader){
  if (loader == null || className == null) {
    return bytes;
  }
  if (trace.isTraceEnabled())   trace.enter(""String_Node_Str"",this,new Object[]{className,bytes,loader});
  if (trace.isTraceEnabled())   trace.event(""String_Node_Str"",this,new Object[]{loader.getParent(),Thread.currentThread().getContextClassLoader()});
  try {
synchronized (loader) {
      WeavingAdaptor weavingAdaptor=WeaverContainer.getWeaver(loader,weavingContext);
      if (weavingAdaptor == null) {
        if (trace.isTraceEnabled())         trace.exit(""String_Node_Str"");
        return bytes;
      }
      byte[] newBytes=weavingAdaptor.weaveClass(className,bytes);
      Dump.dumpOnExit(weavingAdaptor.getMessageHolder(),true);
      if (trace.isTraceEnabled())       trace.exit(""String_Node_Str"",newBytes);
      return newBytes;
    }
  }
 catch (  Throwable th) {
    trace.error(className,th);
    Dump.dumpWithException(th);
    if (trace.isTraceEnabled())     trace.exit(""String_Node_Str"",th);
    return bytes;
  }
}","/** 
 * Weave
 * @param className
 * @param bytes
 * @param loader
 * @return weaved bytes
 */
public byte[] preProcess(String className,byte[] bytes,ClassLoader loader){
  if (loader == null || className == null) {
    return bytes;
  }
  if (trace.isTraceEnabled())   trace.enter(""String_Node_Str"",this,new Object[]{className,bytes,loader});
  if (trace.isTraceEnabled())   trace.event(""String_Node_Str"",this,new Object[]{loader.getParent(),Thread.currentThread().getContextClassLoader()});
  try {
synchronized (loader) {
      WeavingAdaptor weavingAdaptor=WeaverContainer.getWeaver(loader,weavingContext);
      if (weavingAdaptor == null) {
        if (trace.isTraceEnabled())         trace.exit(""String_Node_Str"");
        return bytes;
      }
      byte[] newBytes=weavingAdaptor.weaveClass(className,bytes,false);
      Dump.dumpOnExit(weavingAdaptor.getMessageHolder(),true);
      if (trace.isTraceEnabled())       trace.exit(""String_Node_Str"",newBytes);
      return newBytes;
    }
  }
 catch (  Throwable th) {
    trace.error(className,th);
    Dump.dumpWithException(th);
    if (trace.isTraceEnabled())     trace.exit(""String_Node_Str"",th);
    return bytes;
  }
}",0.9974554707379136
9217,"private boolean weaveAndDefineConceteAspects(){
  if (trace.isTraceEnabled())   trace.enter(""String_Node_Str"",this,concreteAspects);
  boolean success=true;
  for (Iterator iterator=concreteAspects.iterator(); iterator.hasNext(); ) {
    ConcreteAspectCodeGen gen=(ConcreteAspectCodeGen)iterator.next();
    String name=gen.getClassName();
    byte[] bytes=gen.getBytes();
    try {
      byte[] newBytes=weaveClass(name,bytes);
      this.generatedClassHandler.acceptClass(name,newBytes);
    }
 catch (    IOException ex) {
      trace.error(""String_Node_Str"",ex);
      error(""String_Node_Str"" + name + ""String_Node_Str"",ex);
    }
  }
  if (trace.isTraceEnabled())   trace.exit(""String_Node_Str"",success);
  return success;
}","private boolean weaveAndDefineConceteAspects(){
  if (trace.isTraceEnabled())   trace.enter(""String_Node_Str"",this,concreteAspects);
  boolean success=true;
  for (Iterator iterator=concreteAspects.iterator(); iterator.hasNext(); ) {
    ConcreteAspectCodeGen gen=(ConcreteAspectCodeGen)iterator.next();
    String name=gen.getClassName();
    byte[] bytes=gen.getBytes();
    try {
      byte[] newBytes=weaveClass(name,bytes,true);
      this.generatedClassHandler.acceptClass(name,newBytes);
    }
 catch (    IOException ex) {
      trace.error(""String_Node_Str"",ex);
      error(""String_Node_Str"" + name + ""String_Node_Str"",ex);
    }
  }
  if (trace.isTraceEnabled())   trace.exit(""String_Node_Str"",success);
  return success;
}",0.9965823650034176
9218,"/** 
 * Override to weave class using WeavingAdaptor 
 */
protected Class defineClass(String name,byte[] b,CodeSource cs) throws IOException {
  if (trace.isTraceEnabled())   trace.enter(""String_Node_Str"",this,new Object[]{name,b,cs});
  if (!initializingAdaptor) {
    if (adaptor == null && !initializingAdaptor) {
      createAdaptor();
    }
    try {
      b=adaptor.weaveClass(name,b);
    }
 catch (    AbortException ex) {
      trace.error(""String_Node_Str"",ex);
      throw ex;
    }
catch (    Throwable th) {
      trace.error(""String_Node_Str"",th);
    }
  }
  Class clazz=super.defineClass(name,b,cs);
  if (trace.isTraceEnabled())   trace.exit(""String_Node_Str"",clazz);
  return clazz;
}","/** 
 * Override to weave class using WeavingAdaptor 
 */
protected Class defineClass(String name,byte[] b,CodeSource cs) throws IOException {
  if (trace.isTraceEnabled())   trace.enter(""String_Node_Str"",this,new Object[]{name,b,cs});
  if (!initializingAdaptor) {
    if (adaptor == null && !initializingAdaptor) {
      createAdaptor();
    }
    try {
      b=adaptor.weaveClass(name,b,false);
    }
 catch (    AbortException ex) {
      trace.error(""String_Node_Str"",ex);
      throw ex;
    }
catch (    Throwable th) {
      trace.error(""String_Node_Str"",th);
    }
  }
  Class clazz=super.defineClass(name,b,cs);
  if (trace.isTraceEnabled())   trace.exit(""String_Node_Str"",clazz);
  return clazz;
}",0.9957446808510638
9219,"/** 
 * Weave a class using aspects previously supplied to the adaptor.
 * @param name the name of the class
 * @param bytes the class bytes
 * @return the woven bytes
 * @exception IOException weave failed
 */
public byte[] weaveClass(String name,byte[] bytes) throws IOException {
  if (trace.isTraceEnabled())   trace.enter(""String_Node_Str"",this,new Object[]{name,bytes});
  if (!enabled) {
    if (trace.isTraceEnabled())     trace.exit(""String_Node_Str"",false);
    return bytes;
  }
  try {
    delegateForCurrentClass=null;
    name=name.replace('/','.');
    if (couldWeave(name,bytes)) {
      if (accept(name,bytes)) {
        debug(""String_Node_Str"" + name + ""String_Node_Str"");
        bytes=getWovenBytes(name,bytes);
      }
 else       if (shouldWeaveAnnotationStyleAspect(name,bytes)) {
        debug(""String_Node_Str"" + name + ""String_Node_Str"");
        bytes=getAtAspectJAspectBytes(name,bytes);
      }
 else {
        debug(""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
 else {
      debug(""String_Node_Str"" + name + ""String_Node_Str"");
    }
  }
  finally {
    delegateForCurrentClass=null;
  }
  if (trace.isTraceEnabled())   trace.exit(""String_Node_Str"",bytes);
  return bytes;
}","/** 
 * Weave a class using aspects previously supplied to the adaptor.
 * @param name the name of the class
 * @param bytes the class bytes
 * @param mustWeave if true then this class *must* get woven (used for concrete aspects generated from XML)
 * @return the woven bytes
 * @exception IOException weave failed
 */
public byte[] weaveClass(String name,byte[] bytes,boolean mustWeave) throws IOException {
  if (trace.isTraceEnabled())   trace.enter(""String_Node_Str"",this,new Object[]{name,bytes});
  if (!enabled) {
    if (trace.isTraceEnabled())     trace.exit(""String_Node_Str"",false);
    return bytes;
  }
  try {
    delegateForCurrentClass=null;
    name=name.replace('/','.');
    if (couldWeave(name,bytes)) {
      if (accept(name,bytes)) {
        debug(""String_Node_Str"" + name + ""String_Node_Str"");
        bytes=getWovenBytes(name,bytes);
      }
 else       if (shouldWeaveAnnotationStyleAspect(name,bytes)) {
        if (mustWeave) {
          error(""String_Node_Str"" + name + ""String_Node_Str"");
        }
        debug(""String_Node_Str"" + name + ""String_Node_Str"");
        bytes=getAtAspectJAspectBytes(name,bytes);
      }
 else {
        debug(""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
 else {
      debug(""String_Node_Str"" + name + ""String_Node_Str"");
    }
  }
  finally {
    delegateForCurrentClass=null;
  }
  if (trace.isTraceEnabled())   trace.exit(""String_Node_Str"",bytes);
  return bytes;
}",0.915915915915916
9220,"static final BranchHandle getBranchHandle(BranchInstruction i){
  if (bh_list == null)   return new BranchHandle(i);
 else {
    BranchHandle bh=bh_list;
    bh_list=(BranchHandle)bh.next;
    bh.setInstruction(i);
    return bh;
  }
}","/** 
 * Factory methods.
 */
static final BranchHandle getBranchHandle(BranchInstruction i){
  return new BranchHandle(i);
}",0.5292479108635098
9221,"/** 
 * Factory method.
 */
static final InstructionHandle getInstructionHandle(Instruction i){
  if (ih_list == null)   return new InstructionHandle(i);
 else {
    InstructionHandle ih=ih_list;
    ih_list=ih.next;
    ih.setInstruction(i);
    return ih;
  }
}","/** 
 * Factory method.
 */
static final InstructionHandle getInstructionHandle(Instruction i){
  return new InstructionHandle(i);
}",0.6683544303797468
9222,"/** 
 * Delete contents, i.e., remove user access and make handle reusable.
 */
void dispose(){
  next=prev=null;
  instruction.dispose();
  instruction=null;
  i_position=-1;
  attributes=null;
  removeAllTargeters();
  addHandle();
}","/** 
 * Delete contents, i.e., remove user access and make handle reusable.
 */
void dispose(){
  next=prev=null;
  instruction.dispose();
  instruction=null;
  i_position=-1;
  attributes=null;
  removeAllTargeters();
}",0.967032967032967
9223,"public String[] getParameterNames(){
  if (argumentNames != null)   return argumentNames;
  TypeDeclaration typeDecl=getTypeDeclaration();
  AbstractMethodDeclaration methodDecl=typeDecl.declarationOf((MethodBinding)realBinding);
  Argument[] args=(methodDecl == null ? null : methodDecl.arguments);
  if (args == null) {
    argumentNames=NO_ARGS;
  }
 else {
    argumentNames=new String[args.length];
    for (int i=0; i < argumentNames.length; i++) {
      argumentNames[i]=new String(methodDecl.arguments[i].name);
    }
  }
  return argumentNames;
}","public String[] getParameterNames(){
  if (argumentNames != null)   return argumentNames;
  if (realBinding instanceof FieldBinding) {
    argumentNames=NO_ARGS;
  }
 else {
    TypeDeclaration typeDecl=getTypeDeclaration();
    AbstractMethodDeclaration methodDecl=typeDecl.declarationOf((MethodBinding)realBinding);
    Argument[] args=(methodDecl == null ? null : methodDecl.arguments);
    if (args == null) {
      argumentNames=NO_ARGS;
    }
 else {
      argumentNames=new String[args.length];
      for (int i=0; i < argumentNames.length; i++) {
        argumentNames[i]=new String(methodDecl.arguments[i].name);
      }
    }
  }
  return argumentNames;
}",0.5278688524590164
9224,"public boolean isNested(){
  return ((declaration.modifiers & ASTNode.IsMemberTypeMASK) != 0);
}","public boolean isNested(){
  if (declaration.binding != null)   return (declaration.binding.isMemberType());
  return ((declaration.modifiers & ASTNode.IsMemberTypeMASK) != 0);
}",0.7007299270072993
9225,"public Aj(IWeavingContext context){
  if (trace.isTraceEnabled())   trace.enter(""String_Node_Str"",this,new Object[]{context});
  this.weavingContext=context;
  if (trace.isTraceEnabled())   trace.exit(""String_Node_Str"");
}","public Aj(IWeavingContext context){
  if (trace.isTraceEnabled())   trace.enter(""String_Node_Str"",this,new Object[]{context,getClass().getClassLoader()});
  this.weavingContext=context;
  if (trace.isTraceEnabled())   trace.exit(""String_Node_Str"");
}",0.940677966101695
9226,"/** 
 * Weave
 * @param className
 * @param bytes
 * @param loader
 * @return weaved bytes
 */
public byte[] preProcess(String className,byte[] bytes,ClassLoader loader){
  if (trace.isTraceEnabled())   trace.enter(""String_Node_Str"",this,new Object[]{className,bytes,loader});
  if (loader == null || className == null) {
    if (trace.isTraceEnabled())     trace.exit(""String_Node_Str"",bytes);
    return bytes;
  }
  try {
synchronized (loader) {
      WeavingAdaptor weavingAdaptor=WeaverContainer.getWeaver(loader,weavingContext);
      if (weavingAdaptor == null) {
        if (trace.isTraceEnabled())         trace.exit(""String_Node_Str"");
        return bytes;
      }
      if (trace.isTraceEnabled())       trace.exit(""String_Node_Str"",bytes);
      return weavingAdaptor.weaveClass(className,bytes);
    }
  }
 catch (  Exception t) {
    trace.error(""String_Node_Str"",t);
    t.printStackTrace();
    if (trace.isTraceEnabled())     trace.exit(""String_Node_Str"",bytes);
    return bytes;
  }
}","/** 
 * Weave
 * @param className
 * @param bytes
 * @param loader
 * @return weaved bytes
 */
public byte[] preProcess(String className,byte[] bytes,ClassLoader loader){
  if (loader == null || className == null) {
    return bytes;
  }
  if (trace.isTraceEnabled())   trace.enter(""String_Node_Str"",this,new Object[]{className,bytes,loader,Thread.currentThread().getContextClassLoader()});
  try {
synchronized (loader) {
      WeavingAdaptor weavingAdaptor=WeaverContainer.getWeaver(loader,weavingContext);
      if (weavingAdaptor == null) {
        if (trace.isTraceEnabled())         trace.exit(""String_Node_Str"");
        return bytes;
      }
      byte[] newBytes=weavingAdaptor.weaveClass(className,bytes);
      if (trace.isTraceEnabled())       trace.exit(""String_Node_Str"",newBytes);
      return newBytes;
    }
  }
 catch (  Exception ex) {
    trace.error(""String_Node_Str"",ex);
    ex.printStackTrace();
    if (trace.isTraceEnabled())     trace.exit(""String_Node_Str"",ex);
    return bytes;
  }
}",0.5602379771938523
9227,"public CrosscuttingMembersSet(World world){
  this.world=world;
}","public CrosscuttingMembersSet(World world){
  trace.enter(""String_Node_Str"",this,world);
  this.world=world;
  trace.exit(""String_Node_Str"");
}",0.625
9228,"/** 
 * @return whether or not that was a change to the global signatureXXX for efficiency we will need a richer representation than this
 */
public boolean addOrReplaceAspect(ResolvedType aspectType,boolean inWeavingPhase){
  boolean change=false;
  CrosscuttingMembers xcut=(CrosscuttingMembers)members.get(aspectType);
  if (xcut == null) {
    members.put(aspectType,aspectType.collectCrosscuttingMembers(inWeavingPhase));
    clearCaches();
    CflowPointcut.clearCaches(aspectType);
    change=true;
  }
 else {
    if (xcut.replaceWith(aspectType.collectCrosscuttingMembers(inWeavingPhase),inWeavingPhase)) {
      clearCaches();
      CflowPointcut.clearCaches(aspectType);
      change=true;
    }
 else {
      if (!AsmManager.getDefault().getHandleProvider().dependsOnLocation() && inWeavingPhase) {
        shadowMungers=null;
      }
      change=false;
    }
  }
  if (aspectType.isAbstract()) {
    boolean ancestorChange=addOrReplaceDescendantsOf(aspectType,inWeavingPhase);
    change=change || ancestorChange;
  }
  changedSinceLastReset=changedSinceLastReset || change;
  return change;
}","/** 
 * @return whether or not that was a change to the global signatureXXX for efficiency we will need a richer representation than this
 */
public boolean addOrReplaceAspect(ResolvedType aspectType,boolean inWeavingPhase){
  trace.enter(""String_Node_Str"",this,new Object[]{aspectType,new Boolean(inWeavingPhase)});
  boolean change=false;
  CrosscuttingMembers xcut=(CrosscuttingMembers)members.get(aspectType);
  if (xcut == null) {
    members.put(aspectType,aspectType.collectCrosscuttingMembers(inWeavingPhase));
    clearCaches();
    CflowPointcut.clearCaches(aspectType);
    change=true;
  }
 else {
    if (xcut.replaceWith(aspectType.collectCrosscuttingMembers(inWeavingPhase),inWeavingPhase)) {
      clearCaches();
      CflowPointcut.clearCaches(aspectType);
      change=true;
    }
 else {
      if (!AsmManager.getDefault().getHandleProvider().dependsOnLocation() && inWeavingPhase) {
        shadowMungers=null;
      }
      change=false;
    }
  }
  if (aspectType.isAbstract()) {
    boolean ancestorChange=addOrReplaceDescendantsOf(aspectType,inWeavingPhase);
    change=change || ancestorChange;
  }
  changedSinceLastReset=changedSinceLastReset || change;
  trace.exit(""String_Node_Str"",change);
  return change;
}",0.9437340153452686
9229,"private void weaveAndNotify(UnwovenClassFile classFile,BcelObjectType classType,IWeaveRequestor requestor) throws IOException {
  ContextToken tok=CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.WEAVING_TYPE,classType.getResolvedTypeX().getName());
  LazyClassGen clazz=weaveWithoutDump(classFile,classType);
  classType.finishedWith();
  if (clazz != null) {
    UnwovenClassFile[] newClasses=getClassFilesFor(clazz);
    for (int i=0; i < newClasses.length; i++) {
      requestor.acceptResult(newClasses[i]);
    }
  }
 else {
    requestor.acceptResult(classFile);
  }
  classType.weavingCompleted();
  CompilationAndWeavingContext.leavingPhase(tok);
}","private void weaveAndNotify(UnwovenClassFile classFile,BcelObjectType classType,IWeaveRequestor requestor) throws IOException {
  trace.enter(""String_Node_Str"",this,new Object[]{classFile,classType,requestor});
  ContextToken tok=CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.WEAVING_TYPE,classType.getResolvedTypeX().getName());
  LazyClassGen clazz=weaveWithoutDump(classFile,classType);
  classType.finishedWith();
  if (clazz != null) {
    UnwovenClassFile[] newClasses=getClassFilesFor(clazz);
    for (int i=0; i < newClasses.length; i++) {
      requestor.acceptResult(newClasses[i]);
    }
  }
 else {
    requestor.acceptResult(classFile);
  }
  classType.weavingCompleted();
  CompilationAndWeavingContext.leavingPhase(tok);
  trace.exit(""String_Node_Str"");
}",0.9214092140921408
9230,"/** 
 * Calculate the SerialVersionUID for a class.
 */
public long getSUID(){
  try {
    Field[] fields=getFields();
    Method[] methods=getMethods();
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    DataOutputStream dos=new DataOutputStream(baos);
    dos.writeUTF(getClassName());
    int classmods=0;
    classmods|=(isPublic() ? Constants.ACC_PUBLIC : 0);
    classmods|=(isFinal() ? Constants.ACC_FINAL : 0);
    classmods|=(isInterface() ? Constants.ACC_INTERFACE : 0);
    if (isInterface() && isAbstract()) {
      if (methods.length > 0)       classmods|=Constants.ACC_ABSTRACT;
    }
    dos.writeInt(classmods);
    List list=new ArrayList();
    String[] names=getInterfaceNames();
    if (names != null) {
      Arrays.sort(names);
      for (int i=0; i < names.length; i++)       dos.writeUTF(names[i]);
    }
    list.clear();
    for (int i=0; i < fields.length; i++) {
      Field field=fields[i];
      if (!(field.isPrivate() && field.isStatic()) && !(field.isPrivate() && field.isTransient()))       list.add(field);
    }
    Collections.sort(list,new FieldComparator());
    int relevantFlags=Constants.ACC_PUBLIC | Constants.ACC_PRIVATE | Constants.ACC_PROTECTED| Constants.ACC_STATIC| Constants.ACC_FINAL| Constants.ACC_VOLATILE| Constants.ACC_TRANSIENT;
    for (Iterator iter=list.iterator(); iter.hasNext(); ) {
      Field f=(Field)iter.next();
      dos.writeUTF(f.getName());
      dos.writeInt(relevantFlags & f.getModifiers());
      dos.writeUTF(f.getType().getSignature());
    }
    list.clear();
    List ctors=new ArrayList();
    boolean hasClinit=false;
    for (int i=0; i < methods.length; i++) {
      Method m=methods[i];
      boolean couldBeInitializer=m.getName().charAt(0) == '<';
      if (couldBeInitializer && m.getName().equals(""String_Node_Str"")) {
        hasClinit=true;
      }
 else       if (couldBeInitializer && m.getName().equals(""String_Node_Str"")) {
        if (!m.isPrivate())         ctors.add(m);
      }
 else {
        if (!m.isPrivate())         list.add(m);
      }
    }
    Collections.sort(ctors,new ConstructorComparator());
    Collections.sort(list,new MethodComparator());
    if (hasClinit) {
      dos.writeUTF(""String_Node_Str"");
      dos.writeInt(Modifier.STATIC);
      dos.writeUTF(""String_Node_Str"");
    }
    relevantFlags=Constants.ACC_PUBLIC | Constants.ACC_PRIVATE | Constants.ACC_PROTECTED| Constants.ACC_STATIC| Constants.ACC_FINAL| Constants.ACC_SYNCHRONIZED| Constants.ACC_NATIVE| Constants.ACC_ABSTRACT| Constants.ACC_STRICT;
    for (Iterator iter=ctors.iterator(); iter.hasNext(); ) {
      Method m=(Method)iter.next();
      dos.writeUTF(m.getName());
      dos.writeInt(relevantFlags & m.getModifiers());
      dos.writeUTF(m.getSignature().replace('/','.'));
    }
    for (Iterator iter=list.iterator(); iter.hasNext(); ) {
      Method m=(Method)iter.next();
      dos.writeUTF(m.getName());
      dos.writeInt(relevantFlags & m.getModifiers());
      dos.writeUTF(m.getSignature().replace('/','.'));
    }
    dos.flush();
    dos.close();
    byte[] bs=baos.toByteArray();
    MessageDigest md=MessageDigest.getInstance(""String_Node_Str"");
    byte[] result=md.digest(bs);
    long suid=0L;
    int pos=result.length > 8 ? 7 : result.length - 1;
    while (pos >= 0) {
      suid=suid << 8 | ((long)result[pos--] & 0xff);
    }
    return suid;
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + getClassName());
    e.printStackTrace();
    throw new RuntimeException(""String_Node_Str"" + getClassName() + ""String_Node_Str""+ e.toString());
  }
}","/** 
 * Calculate the SerialVersionUID for a class.
 */
public long getSUID(){
  try {
    Field[] fields=getFields();
    Method[] methods=getMethods();
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    DataOutputStream dos=new DataOutputStream(baos);
    dos.writeUTF(getClassName());
    int classmods=0;
    classmods|=(isPublic() ? Constants.ACC_PUBLIC : 0);
    classmods|=(isFinal() ? Constants.ACC_FINAL : 0);
    classmods|=(isInterface() ? Constants.ACC_INTERFACE : 0);
    if (isAbstract()) {
      if (isInterface()) {
        if (methods.length > 0)         classmods|=Constants.ACC_ABSTRACT;
      }
 else {
        classmods|=Constants.ACC_ABSTRACT;
      }
    }
    dos.writeInt(classmods);
    List list=new ArrayList();
    String[] names=getInterfaceNames();
    if (names != null) {
      Arrays.sort(names);
      for (int i=0; i < names.length; i++)       dos.writeUTF(names[i]);
    }
    list.clear();
    for (int i=0; i < fields.length; i++) {
      Field field=fields[i];
      if (!(field.isPrivate() && field.isStatic()) && !(field.isPrivate() && field.isTransient()))       list.add(field);
    }
    Collections.sort(list,new FieldComparator());
    int relevantFlags=Constants.ACC_PUBLIC | Constants.ACC_PRIVATE | Constants.ACC_PROTECTED| Constants.ACC_STATIC| Constants.ACC_FINAL| Constants.ACC_VOLATILE| Constants.ACC_TRANSIENT;
    for (Iterator iter=list.iterator(); iter.hasNext(); ) {
      Field f=(Field)iter.next();
      dos.writeUTF(f.getName());
      dos.writeInt(relevantFlags & f.getModifiers());
      dos.writeUTF(f.getType().getSignature());
    }
    list.clear();
    List ctors=new ArrayList();
    boolean hasClinit=false;
    for (int i=0; i < methods.length; i++) {
      Method m=methods[i];
      boolean couldBeInitializer=m.getName().charAt(0) == '<';
      if (couldBeInitializer && m.getName().equals(""String_Node_Str"")) {
        hasClinit=true;
      }
 else       if (couldBeInitializer && m.getName().equals(""String_Node_Str"")) {
        if (!m.isPrivate())         ctors.add(m);
      }
 else {
        if (!m.isPrivate())         list.add(m);
      }
    }
    Collections.sort(ctors,new ConstructorComparator());
    Collections.sort(list,new MethodComparator());
    if (hasClinit) {
      dos.writeUTF(""String_Node_Str"");
      dos.writeInt(Modifier.STATIC);
      dos.writeUTF(""String_Node_Str"");
    }
    relevantFlags=Constants.ACC_PUBLIC | Constants.ACC_PRIVATE | Constants.ACC_PROTECTED| Constants.ACC_STATIC| Constants.ACC_FINAL| Constants.ACC_SYNCHRONIZED| Constants.ACC_NATIVE| Constants.ACC_ABSTRACT| Constants.ACC_STRICT;
    for (Iterator iter=ctors.iterator(); iter.hasNext(); ) {
      Method m=(Method)iter.next();
      dos.writeUTF(m.getName());
      dos.writeInt(relevantFlags & m.getModifiers());
      dos.writeUTF(m.getSignature().replace('/','.'));
    }
    for (Iterator iter=list.iterator(); iter.hasNext(); ) {
      Method m=(Method)iter.next();
      dos.writeUTF(m.getName());
      dos.writeInt(relevantFlags & m.getModifiers());
      dos.writeUTF(m.getSignature().replace('/','.'));
    }
    dos.flush();
    dos.close();
    byte[] bs=baos.toByteArray();
    MessageDigest md=MessageDigest.getInstance(""String_Node_Str"");
    byte[] result=md.digest(bs);
    long suid=0L;
    int pos=result.length > 8 ? 7 : result.length - 1;
    while (pos >= 0) {
      suid=suid << 8 | ((long)result[pos--] & 0xff);
    }
    return suid;
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + getClassName());
    e.printStackTrace();
    throw new RuntimeException(""String_Node_Str"" + getClassName() + ""String_Node_Str""+ e.toString());
  }
}",0.9844288273391208
9231,"private boolean isAspect(TypeDeclaration declaration){
  if (declaration instanceof AspectDeclaration)   return true;
 else   if (declaration.annotations != null) {
    for (int index=0; index < declaration.annotations.length; index++) {
      TypeDeclaration.resolveAnnotations(declaration.staticInitializerScope,declaration.annotations,declaration.binding);
      Annotation a=declaration.annotations[index];
      if (CharOperation.equals(a.resolvedType.signature(),aspectSig))       return true;
    }
  }
  return false;
}","private boolean isAspect(TypeDeclaration declaration){
  if (declaration instanceof AspectDeclaration)   return true;
 else   if (declaration.annotations != null) {
    for (int index=0; index < declaration.annotations.length; index++) {
      TypeDeclaration.resolveAnnotations(declaration.staticInitializerScope,declaration.annotations,declaration.binding);
      Annotation a=declaration.annotations[index];
      if (a.resolvedType == null)       continue;
      if (CharOperation.equals(a.resolvedType.signature(),aspectSig))       return true;
    }
  }
  return false;
}",0.9547101449275364
9232,"public void testDeclareAtTypeInStructureModel_pr115607(){
  AsmManager.setReporting(""String_Node_Str"",true,true,true,true);
  runTest(""String_Node_Str"");
  IHierarchy top=AsmManager.getDefault().getHierarchy();
  IProgramElement pe=top.findElementForLabel(top.getRoot(),IProgramElement.Kind.DECLARE_ANNOTATION_AT_TYPE,""String_Node_Str"");
  assertNotNull(""String_Node_Str"",pe);
  List l=AsmManager.getDefault().getRelationshipMap().get(pe);
  assertNotNull(""String_Node_Str"",l);
}","public void testDeclareAtTypeInStructureModel_pr115607(){
  runTest(""String_Node_Str"");
  IHierarchy top=AsmManager.getDefault().getHierarchy();
  IProgramElement pe=top.findElementForLabel(top.getRoot(),IProgramElement.Kind.DECLARE_ANNOTATION_AT_TYPE,""String_Node_Str"");
  assertNotNull(""String_Node_Str"",pe);
  List l=AsmManager.getDefault().getRelationshipMap().get(pe);
  assertNotNull(""String_Node_Str"",l);
}",0.9260089686098656
9233,"public void removeUnnecessaryProblems(Member member,int problemLineNumber){
  if (result == null)   return;
  IProblem[] probs=result.getProblems();
  for (int i=0; i < probs.length; i++) {
    IProblem problem=probs[i];
    if (problem == null)     continue;
    if (problem.getID() == IProblem.UnusedMethodDeclaredThrownException || problem.getID() == IProblem.UnusedConstructorDeclaredThrownException) {
      if (problem.getSourceLineNumber() == problemLineNumber) {
        UnusedDeclaredThrownExceptionFilter filter=new UnusedDeclaredThrownExceptionFilter(problem);
        result.removeProblems(filter);
      }
    }
  }
}","public void removeUnnecessaryProblems(Member member,int problemLineNumber){
  if (result == null)   return;
  IProblem[] probs=result.getProblems();
  if (probs != null) {
    for (int i=0; i < probs.length; i++) {
      IProblem problem=probs[i];
      if (problem == null)       continue;
      if (problem.getID() == IProblem.UnusedMethodDeclaredThrownException || problem.getID() == IProblem.UnusedConstructorDeclaredThrownException) {
        if (problem.getSourceLineNumber() == problemLineNumber) {
          UnusedDeclaredThrownExceptionFilter filter=new UnusedDeclaredThrownExceptionFilter(problem);
          result.removeProblems(filter);
        }
      }
    }
  }
}",0.9090909090909092
9234,"private void createMessageHandler(){
  messageHolder=new WeavingAdaptorMessageHandler(new PrintWriter(System.err));
  messageHandler=messageHolder;
  if (verbose)   messageHandler.dontIgnore(IMessage.INFO);
  if (Boolean.getBoolean(SHOW_WEAVE_INFO_PROPERTY))   messageHandler.dontIgnore(IMessage.WEAVEINFO);
  info(""String_Node_Str"" + Version.text + ""String_Node_Str""+ Version.time_text);
}","protected void createMessageHandler(){
  messageHolder=new WeavingAdaptorMessageHandler(new PrintWriter(System.err));
  messageHandler=messageHolder;
  if (verbose)   messageHandler.dontIgnore(IMessage.INFO);
  if (Boolean.getBoolean(SHOW_WEAVE_INFO_PROPERTY))   messageHandler.dontIgnore(IMessage.WEAVEINFO);
  info(""String_Node_Str"" + Version.text + ""String_Node_Str""+ Version.time_text);
}",0.9846547314578004
9235,"static WeavingAdaptor getWeaver(ClassLoader loader,IWeavingContext weavingContext){
  ExplicitlyInitializedClassLoaderWeavingAdaptor adaptor=null;
synchronized (weavingAdaptors) {
    adaptor=(ExplicitlyInitializedClassLoaderWeavingAdaptor)weavingAdaptors.get(loader);
    if (adaptor == null) {
      String loaderClassName=loader.getClass().getName();
      if (loaderClassName.equals(""String_Node_Str"")) {
        return null;
      }
 else {
        ClassLoaderWeavingAdaptor weavingAdaptor=new ClassLoaderWeavingAdaptor(loader,weavingContext);
        adaptor=new ExplicitlyInitializedClassLoaderWeavingAdaptor(weavingAdaptor);
        weavingAdaptors.put(loader,adaptor);
      }
    }
  }
  return adaptor.getWeavingAdaptor(loader,weavingContext);
}","static WeavingAdaptor getWeaver(ClassLoader loader,IWeavingContext weavingContext){
  ExplicitlyInitializedClassLoaderWeavingAdaptor adaptor=null;
synchronized (weavingAdaptors) {
    adaptor=(ExplicitlyInitializedClassLoaderWeavingAdaptor)weavingAdaptors.get(loader);
    if (adaptor == null) {
      String loaderClassName=loader.getClass().getName();
      if (loaderClassName.equals(""String_Node_Str"")) {
        return null;
      }
 else {
        ClassLoaderWeavingAdaptor weavingAdaptor=new ClassLoaderWeavingAdaptor();
        adaptor=new ExplicitlyInitializedClassLoaderWeavingAdaptor(weavingAdaptor);
        weavingAdaptors.put(loader,adaptor);
      }
    }
  }
  return adaptor.getWeavingAdaptor(loader,weavingContext);
}",0.9859154929577464
9236,"public ClassLoaderWeavingAdaptor(final ClassLoader loader,IWeavingContext wContext){
  super();
  if (trace.isTraceEnabled())   trace.enter(""String_Node_Str"",this);
  this.classLoader=loader;
  this.weavingContext=wContext;
  if (trace.isTraceEnabled())   trace.exit(""String_Node_Str"");
}","/** 
 * We don't need a reference to the class loader and using it during  construction can cause problems with recursion. It also makes sense to supply the weaving context during initialization to. 
 * @deprecated
 */
public ClassLoaderWeavingAdaptor(final ClassLoader deprecatedLoader,final IWeavingContext deprecatedContext){
  super();
  if (trace.isTraceEnabled())   trace.enter(""String_Node_Str"",this,new Object[]{deprecatedLoader,deprecatedContext});
  if (trace.isTraceEnabled())   trace.exit(""String_Node_Str"");
}",0.5851851851851851
9237,"protected void initialize(final ClassLoader deprecatedLoader,IWeavingContext deprecatedContext){
  if (initialized)   return;
  if (weavingContext == null) {
    weavingContext=new DefaultWeavingContext(classLoader);
  }
  createMessageHandler();
  this.generatedClassHandler=new GeneratedClassHandler(){
    /** 
 * Callback when we need to define a Closure in the JVM
 * @param name
 * @param bytes
 */
    public void acceptClass(    String name,    byte[] bytes){
      try {
        if (shouldDump(name.replace('/','.'),false)) {
          dump(name,bytes,false);
        }
      }
 catch (      Throwable throwable) {
        throwable.printStackTrace();
      }
      defineClass(classLoader,name,bytes);
    }
  }
;
  List definitions=parseDefinitions(classLoader);
  if (!enabled) {
    return;
  }
  bcelWorld=new LTWWorld(classLoader,getMessageHandler(),new ICrossReferenceHandler(){
    public void addCrossReference(    ISourceLocation from,    ISourceLocation to,    IRelationship.Kind kind,    boolean runtimeTest){
      ;
    }
  }
);
  weaver=new BcelWeaver(bcelWorld);
  registerDefinitions(weaver,classLoader,definitions);
  if (enabled) {
    weaver.prepareForWeave();
  }
 else {
    bcelWorld=null;
    weaver=null;
  }
  initialized=true;
}","protected void initialize(final ClassLoader classLoader,IWeavingContext context){
  if (initialized)   return;
  if (trace.isTraceEnabled())   trace.enter(""String_Node_Str"",this,new Object[]{classLoader,context});
  this.weavingContext=context;
  if (weavingContext == null) {
    weavingContext=new DefaultWeavingContext(classLoader);
  }
  createMessageHandler();
  this.generatedClassHandler=new GeneratedClassHandler(){
    /** 
 * Callback when we need to define a Closure in the JVM
 * @param name
 * @param bytes
 */
    public void acceptClass(    String name,    byte[] bytes){
      try {
        if (shouldDump(name.replace('/','.'),false)) {
          dump(name,bytes,false);
        }
      }
 catch (      Throwable throwable) {
        throwable.printStackTrace();
      }
      defineClass(classLoader,name,bytes);
    }
  }
;
  List definitions=parseDefinitions(classLoader);
  if (!enabled) {
    if (trace.isTraceEnabled())     trace.exit(""String_Node_Str"",enabled);
    return;
  }
  bcelWorld=new LTWWorld(classLoader,getMessageHandler(),new ICrossReferenceHandler(){
    public void addCrossReference(    ISourceLocation from,    ISourceLocation to,    IRelationship.Kind kind,    boolean runtimeTest){
      ;
    }
  }
);
  weaver=new BcelWeaver(bcelWorld);
  registerDefinitions(weaver,classLoader,definitions);
  if (enabled) {
    weaver.prepareForWeave();
  }
 else {
    bcelWorld=null;
    weaver=null;
  }
  initialized=true;
  if (trace.isTraceEnabled())   trace.exit(""String_Node_Str"",enabled);
}",0.8693161475116362
9238,"/** 
 * Override to weave class using WeavingAdaptor 
 */
protected Class defineClass(String name,byte[] b,CodeSource cs) throws IOException {
  if (!initializingAdaptor) {
    if (adaptor == null && !initializingAdaptor) {
      DefaultWeavingContext weavingContext=new DefaultWeavingContext(this){
        public String getClassLoaderName(){
          return loader.getClass().getName();
        }
      }
;
      ClassLoaderWeavingAdaptor clwAdaptor=new ClassLoaderWeavingAdaptor(this,weavingContext);
      initializingAdaptor=true;
      clwAdaptor.initialize(this,weavingContext);
      initializingAdaptor=false;
      adaptor=clwAdaptor;
    }
    b=adaptor.weaveClass(name,b);
  }
  return super.defineClass(name,b,cs);
}","/** 
 * Override to weave class using WeavingAdaptor 
 */
protected Class defineClass(String name,byte[] b,CodeSource cs) throws IOException {
  if (!initializingAdaptor) {
    if (adaptor == null && !initializingAdaptor) {
      DefaultWeavingContext weavingContext=new DefaultWeavingContext(this){
        public String getClassLoaderName(){
          return loader.getClass().getName();
        }
      }
;
      ClassLoaderWeavingAdaptor clwAdaptor=new ClassLoaderWeavingAdaptor();
      initializingAdaptor=true;
      clwAdaptor.initialize(this,weavingContext);
      initializingAdaptor=false;
      adaptor=clwAdaptor;
    }
    b=adaptor.weaveClass(name,b);
  }
  return super.defineClass(name,b,cs);
}",0.9868147120055516
9239,"public void testGetNamespace(){
  ClassLoader loader=new URLClassLoader(new URL[]{},null);
  ClassLoaderWeavingAdaptor adaptor=new ClassLoaderWeavingAdaptor(loader,null);
  String namespace=adaptor.getNamespace();
  assertEquals(""String_Node_Str"",""String_Node_Str"",namespace);
}","public void testGetNamespace(){
  ClassLoader loader=new URLClassLoader(new URL[]{},null);
  ClassLoaderWeavingAdaptor adaptor=new ClassLoaderWeavingAdaptor();
  adaptor.initialize(loader,null);
  String namespace=adaptor.getNamespace();
  assertEquals(""String_Node_Str"",""String_Node_Str"",namespace);
}",0.9586206896551724
9240,"public void testGeneratedClassesExistFor(){
  ClassLoader loader=new URLClassLoader(new URL[]{},null);
  ClassLoaderWeavingAdaptor adaptor=new ClassLoaderWeavingAdaptor(loader,null);
  boolean exist=adaptor.generatedClassesExistFor(""String_Node_Str"");
  assertFalse(""String_Node_Str"",exist);
}","public void testGeneratedClassesExistFor(){
  ClassLoader loader=new URLClassLoader(new URL[]{},null);
  ClassLoaderWeavingAdaptor adaptor=new ClassLoaderWeavingAdaptor();
  adaptor.initialize(loader,null);
  boolean exist=adaptor.generatedClassesExistFor(""String_Node_Str"");
  assertFalse(""String_Node_Str"",exist);
}",0.960655737704918
9241,"public void testFlushGeneratedClasses(){
  ClassLoader loader=new URLClassLoader(new URL[]{},null);
  ClassLoaderWeavingAdaptor adaptor=new ClassLoaderWeavingAdaptor(loader,null);
  adaptor.flushGeneratedClasses();
  boolean exist=adaptor.generatedClassesExistFor(""String_Node_Str"");
  assertFalse(""String_Node_Str"",exist);
}","public void testFlushGeneratedClasses(){
  ClassLoader loader=new URLClassLoader(new URL[]{},null);
  ClassLoaderWeavingAdaptor adaptor=new ClassLoaderWeavingAdaptor();
  adaptor.initialize(loader,null);
  adaptor.flushGeneratedClasses();
  boolean exist=adaptor.generatedClassesExistFor(""String_Node_Str"");
  assertFalse(""String_Node_Str"",exist);
}",0.9643916913946587
9242,"public void testClassLoaderWeavingAdaptor(){
  ClassLoader loader=new URLClassLoader(new URL[]{},null);
  ClassLoaderWeavingAdaptor adaptor=new ClassLoaderWeavingAdaptor(loader,null);
}","public void testClassLoaderWeavingAdaptor(){
  ClassLoader loader=new URLClassLoader(new URL[]{},null);
  ClassLoaderWeavingAdaptor adaptor=new ClassLoaderWeavingAdaptor();
  adaptor.initialize(loader,null);
}",0.9390862944162436
9243,"public void testGetBundleIdFromURL(){
  URLClassLoader loader=new URLClassLoader(new URL[]{},null);
  IWeavingContext context=new TestWeavingContext(loader){
    public String getBundleIdFromURL(    URL url){
      throw new UnsupportedOperationException();
    }
  }
;
  ClassLoaderWeavingAdaptor adaptor=new ClassLoaderWeavingAdaptor(loader,context);
  try {
    adaptor.initialize(null,null);
  }
 catch (  UnsupportedOperationException ex) {
    fail(""String_Node_Str"");
  }
}","public void testGetBundleIdFromURL(){
  URLClassLoader loader=new URLClassLoader(new URL[]{},null);
  IWeavingContext context=new TestWeavingContext(loader){
    public String getBundleIdFromURL(    URL url){
      throw new UnsupportedOperationException();
    }
  }
;
  ClassLoaderWeavingAdaptor adaptor=new ClassLoaderWeavingAdaptor();
  try {
    adaptor.initialize(loader,context);
  }
 catch (  UnsupportedOperationException ex) {
    fail(""String_Node_Str"");
  }
}",0.9190325972660356
9244,"public void testGetClassLoaderName(){
  URLClassLoader loader=new URLClassLoader(new URL[]{},null);
  IWeavingContext context=new TestWeavingContext(loader){
    public String getClassLoaderName(){
      called=true;
      return super.getClassLoaderName();
    }
  }
;
  ClassLoaderWeavingAdaptor adaptor=new ClassLoaderWeavingAdaptor(loader,context);
  adaptor.initialize(null,null);
  assertTrue(""String_Node_Str"",called);
}","public void testGetClassLoaderName(){
  URLClassLoader loader=new URLClassLoader(new URL[]{},null);
  IWeavingContext context=new TestWeavingContext(loader){
    public String getClassLoaderName(){
      called=true;
      return super.getClassLoaderName();
    }
  }
;
  ClassLoaderWeavingAdaptor adaptor=new ClassLoaderWeavingAdaptor();
  adaptor.initialize(loader,context);
  assertTrue(""String_Node_Str"",called);
}",0.9325443786982248
9245,"public void testWeavingContext(){
  URLClassLoader loader=new URLClassLoader(new URL[]{},null);
  IWeavingContext context=new TestWeavingContext(loader);
  ClassLoaderWeavingAdaptor adaptor=new ClassLoaderWeavingAdaptor(loader,context);
}","public void testWeavingContext(){
  URLClassLoader loader=new URLClassLoader(new URL[]{},null);
  IWeavingContext context=new TestWeavingContext(loader);
  ClassLoaderWeavingAdaptor adaptor=new ClassLoaderWeavingAdaptor();
  adaptor.initialize(loader,context);
}",0.952
9246,"public void testGetResources(){
  URLClassLoader loader=new URLClassLoader(new URL[]{},null);
  IWeavingContext context=new TestWeavingContext(loader){
    public Enumeration getResources(    String name) throws IOException {
      called=true;
      return super.getResources(name);
    }
  }
;
  ClassLoaderWeavingAdaptor adaptor=new ClassLoaderWeavingAdaptor(loader,context);
  adaptor.initialize(null,null);
  assertTrue(""String_Node_Str"",called);
}","public void testGetResources(){
  URLClassLoader loader=new URLClassLoader(new URL[]{},null);
  IWeavingContext context=new TestWeavingContext(loader){
    public Enumeration getResources(    String name) throws IOException {
      called=true;
      return super.getResources(name);
    }
  }
;
  ClassLoaderWeavingAdaptor adaptor=new ClassLoaderWeavingAdaptor();
  adaptor.initialize(loader,context);
  assertTrue(""String_Node_Str"",called);
}",0.9364548494983278
9247,"public void testGetId() throws IOException {
  File file=new File(""String_Node_Str"");
  URL fileURL=file.getCanonicalFile().toURL();
  URLClassLoader loader=new URLClassLoader(new URL[]{fileURL},null);
  IWeavingContext context=new TestWeavingContext(loader){
    public String getId(){
      called=true;
      return super.getId();
    }
  }
;
  ClassLoaderWeavingAdaptor adaptor=new ClassLoaderWeavingAdaptor(loader,context);
  adaptor.initialize(null,null);
  assertTrue(""String_Node_Str"",called);
}","public void testGetId() throws IOException {
  File file=new File(""String_Node_Str"");
  URL fileURL=file.getCanonicalFile().toURL();
  URLClassLoader loader=new URLClassLoader(new URL[]{fileURL},null);
  IWeavingContext context=new TestWeavingContext(loader){
    public String getId(){
      called=true;
      return super.getId();
    }
  }
;
  ClassLoaderWeavingAdaptor adaptor=new ClassLoaderWeavingAdaptor();
  adaptor.initialize(loader,context);
  assertTrue(""String_Node_Str"",called);
}",0.9428284854563692
9248,"public void testGetFile() throws IOException {
  File file=new File(""String_Node_Str"");
  URL fileURL=file.getCanonicalFile().toURL();
  URLClassLoader loader=new URLClassLoader(new URL[]{fileURL},null);
  IWeavingContext context=new TestWeavingContext(loader){
    public String getFile(    URL url){
      called=true;
      return super.getFile(url);
    }
  }
;
  ClassLoaderWeavingAdaptor adaptor=new ClassLoaderWeavingAdaptor(loader,context);
  adaptor.initialize(null,null);
  assertTrue(""String_Node_Str"",called);
}","public void testGetFile() throws IOException {
  File file=new File(""String_Node_Str"");
  URL fileURL=file.getCanonicalFile().toURL();
  URLClassLoader loader=new URLClassLoader(new URL[]{fileURL},null);
  IWeavingContext context=new TestWeavingContext(loader){
    public String getFile(    URL url){
      called=true;
      return super.getFile(url);
    }
  }
;
  ClassLoaderWeavingAdaptor adaptor=new ClassLoaderWeavingAdaptor();
  adaptor.initialize(loader,context);
  assertTrue(""String_Node_Str"",called);
}",0.9450337512054002
9249,"public void genLabelAndKind(MethodDeclaration methodDeclaration,IProgramElement node){
  if (methodDeclaration instanceof AdviceDeclaration) {
    AdviceDeclaration ad=(AdviceDeclaration)methodDeclaration;
    node.setKind(IProgramElement.Kind.ADVICE);
    if (ad.kind == AdviceKind.Around) {
      node.setCorrespondingType(ad.returnType.toString());
    }
    StringBuffer details=new StringBuffer();
    if (ad.pointcutDesignator != null) {
      if (ad.pointcutDesignator.getPointcut() instanceof ReferencePointcut) {
        ReferencePointcut rp=(ReferencePointcut)ad.pointcutDesignator.getPointcut();
        details.append(rp.name).append(""String_Node_Str"");
      }
 else       if (ad.pointcutDesignator.getPointcut() instanceof AndPointcut) {
        AndPointcut ap=(AndPointcut)ad.pointcutDesignator.getPointcut();
        if (ap.getLeft() instanceof ReferencePointcut) {
          details.append(ap.getLeft().toString()).append(DOUBLE_DOTS);
        }
 else {
          details.append(POINTCUT_ANONYMOUS).append(DOUBLE_DOTS);
        }
      }
 else       if (ad.pointcutDesignator.getPointcut() instanceof OrPointcut) {
        OrPointcut op=(OrPointcut)ad.pointcutDesignator.getPointcut();
        if (op.getLeft() instanceof ReferencePointcut) {
          details.append(op.getLeft().toString()).append(DOUBLE_DOTS);
        }
 else {
          details.append(POINTCUT_ANONYMOUS).append(DOUBLE_DOTS);
        }
      }
 else {
        details.append(POINTCUT_ANONYMOUS);
      }
    }
 else {
      details.append(POINTCUT_ABSTRACT);
    }
    node.setName(ad.kind.toString());
    node.setDetails(details.toString());
    setParameters(methodDeclaration,node);
  }
 else   if (methodDeclaration instanceof PointcutDeclaration) {
    PointcutDeclaration pd=(PointcutDeclaration)methodDeclaration;
    node.setKind(IProgramElement.Kind.POINTCUT);
    node.setName(translatePointcutName(new String(methodDeclaration.selector)));
    setParameters(methodDeclaration,node);
  }
 else   if (methodDeclaration instanceof DeclareDeclaration) {
    DeclareDeclaration declare=(DeclareDeclaration)methodDeclaration;
    String name=DEC_LABEL + ""String_Node_Str"";
    if (declare.declareDecl instanceof DeclareErrorOrWarning) {
      DeclareErrorOrWarning deow=(DeclareErrorOrWarning)declare.declareDecl;
      if (deow.isError()) {
        node.setKind(IProgramElement.Kind.DECLARE_ERROR);
        name+=DECLARE_ERROR;
      }
 else {
        node.setKind(IProgramElement.Kind.DECLARE_WARNING);
        name+=DECLARE_WARNING;
      }
      node.setName(name);
      node.setDetails(""String_Node_Str"" + genDeclareMessage(deow.getMessage()) + ""String_Node_Str"");
    }
 else     if (declare.declareDecl instanceof DeclareParents) {
      node.setKind(IProgramElement.Kind.DECLARE_PARENTS);
      DeclareParents dp=(DeclareParents)declare.declareDecl;
      node.setName(name + DECLARE_PARENTS);
      String kindOfDP=null;
      StringBuffer details=new StringBuffer(""String_Node_Str"");
      TypePattern[] newParents=dp.getParents().getTypePatterns();
      for (int i=0; i < newParents.length; i++) {
        TypePattern tp=newParents[i];
        UnresolvedType tx=tp.getExactType();
        if (kindOfDP == null) {
          kindOfDP=""String_Node_Str"";
          try {
            ResolvedType rtx=tx.resolve(((AjLookupEnvironment)declare.scope.environment()).factory.getWorld());
            if (!rtx.isInterface())             kindOfDP=""String_Node_Str"";
          }
 catch (          Throwable t) {
          }
        }
        String typename=tp.toString();
        if (typename.lastIndexOf(""String_Node_Str"") != -1) {
          typename=typename.substring(typename.lastIndexOf(""String_Node_Str"") + 1);
        }
        details.append(typename);
        if ((i + 1) < newParents.length)         details.append(""String_Node_Str"");
      }
      node.setDetails(kindOfDP + details.toString());
    }
 else     if (declare.declareDecl instanceof DeclareSoft) {
      node.setKind(IProgramElement.Kind.DECLARE_SOFT);
      DeclareSoft ds=(DeclareSoft)declare.declareDecl;
      node.setName(name + DECLARE_SOFT);
      node.setDetails(genTypePatternLabel(ds.getException()));
    }
 else     if (declare.declareDecl instanceof DeclarePrecedence) {
      node.setKind(IProgramElement.Kind.DECLARE_PRECEDENCE);
      DeclarePrecedence ds=(DeclarePrecedence)declare.declareDecl;
      node.setName(name + DECLARE_PRECEDENCE);
      node.setDetails(genPrecedenceListLabel(ds.getPatterns()));
    }
 else     if (declare.declareDecl instanceof DeclareAnnotation) {
      DeclareAnnotation deca=(DeclareAnnotation)declare.declareDecl;
      String thekind=deca.getKind().toString();
      node.setName(name + ""String_Node_Str"" + thekind.substring(3));
      if (deca.getKind() == DeclareAnnotation.AT_CONSTRUCTOR) {
        node.setKind(IProgramElement.Kind.DECLARE_ANNOTATION_AT_CONSTRUCTOR);
      }
 else       if (deca.getKind() == DeclareAnnotation.AT_FIELD) {
        node.setKind(IProgramElement.Kind.DECLARE_ANNOTATION_AT_FIELD);
      }
 else       if (deca.getKind() == DeclareAnnotation.AT_METHOD) {
        node.setKind(IProgramElement.Kind.DECLARE_ANNOTATION_AT_METHOD);
      }
 else       if (deca.getKind() == DeclareAnnotation.AT_TYPE) {
        node.setKind(IProgramElement.Kind.DECLARE_ANNOTATION_AT_TYPE);
      }
      node.setDetails(genDecaLabel(deca));
    }
 else {
      node.setKind(IProgramElement.Kind.ERROR);
      node.setName(DECLARE_UNKNONWN);
    }
  }
 else   if (methodDeclaration instanceof InterTypeDeclaration) {
    InterTypeDeclaration itd=(InterTypeDeclaration)methodDeclaration;
    String name=itd.getOnType().toString() + ""String_Node_Str"" + new String(itd.getDeclaredSelector());
    if (methodDeclaration instanceof InterTypeFieldDeclaration) {
      node.setKind(IProgramElement.Kind.INTER_TYPE_FIELD);
      node.setName(name);
    }
 else     if (methodDeclaration instanceof InterTypeMethodDeclaration) {
      node.setKind(IProgramElement.Kind.INTER_TYPE_METHOD);
      node.setName(name);
    }
 else     if (methodDeclaration instanceof InterTypeConstructorDeclaration) {
      node.setKind(IProgramElement.Kind.INTER_TYPE_CONSTRUCTOR);
      node.setName(itd.getOnType().toString() + ""String_Node_Str"" + itd.getOnType().toString());
    }
 else {
      node.setKind(IProgramElement.Kind.ERROR);
      node.setName(name);
    }
    node.setCorrespondingType(itd.returnType.toString());
    if (node.getKind() != IProgramElement.Kind.INTER_TYPE_FIELD) {
      setParameters(methodDeclaration,node);
    }
  }
 else {
    if (methodDeclaration.isConstructor()) {
      node.setKind(IProgramElement.Kind.CONSTRUCTOR);
    }
 else {
      node.setKind(IProgramElement.Kind.METHOD);
      if (true && methodDeclaration != null && methodDeclaration.annotations != null && methodDeclaration.scope != null) {
        for (int i=0; i < methodDeclaration.annotations.length; i++) {
          Annotation annotation=methodDeclaration.annotations[i];
          String annotationSig=new String(annotation.type.getTypeBindingPublic(methodDeclaration.scope).signature());
          if (annotationSig != null && annotationSig.charAt(1) == 'o') {
            if (""String_Node_Str"".equals(annotationSig)) {
              node.setKind(IProgramElement.Kind.POINTCUT);
              break;
            }
 else             if (""String_Node_Str"".equals(annotationSig) || ""String_Node_Str"".equals(annotationSig) || ""String_Node_Str"".equals(annotationSig)|| ""String_Node_Str"".equals(annotationSig)|| ""String_Node_Str"".equals(annotationSig)) {
              node.setKind(IProgramElement.Kind.ADVICE);
              node.setDetails(POINTCUT_ANONYMOUS);
              break;
            }
          }
        }
      }
    }
    node.setName(new String(methodDeclaration.selector));
    setParameters(methodDeclaration,node);
  }
}","public void genLabelAndKind(MethodDeclaration methodDeclaration,IProgramElement node){
  if (methodDeclaration instanceof AdviceDeclaration) {
    AdviceDeclaration ad=(AdviceDeclaration)methodDeclaration;
    node.setKind(IProgramElement.Kind.ADVICE);
    if (ad.kind == AdviceKind.Around) {
      node.setCorrespondingType(ad.returnType.toString());
    }
    StringBuffer details=new StringBuffer();
    if (ad.pointcutDesignator != null) {
      details.append(AsmRelationshipUtils.genPointcutDetails(ad.pointcutDesignator.getPointcut()));
    }
 else {
      details.append(AsmRelationshipUtils.POINTCUT_ABSTRACT);
    }
    node.setName(ad.kind.toString());
    node.setDetails(details.toString());
    setParameters(methodDeclaration,node);
  }
 else   if (methodDeclaration instanceof PointcutDeclaration) {
    PointcutDeclaration pd=(PointcutDeclaration)methodDeclaration;
    node.setKind(IProgramElement.Kind.POINTCUT);
    node.setName(translatePointcutName(new String(methodDeclaration.selector)));
    setParameters(methodDeclaration,node);
  }
 else   if (methodDeclaration instanceof DeclareDeclaration) {
    DeclareDeclaration declare=(DeclareDeclaration)methodDeclaration;
    String name=AsmRelationshipUtils.DEC_LABEL + ""String_Node_Str"";
    if (declare.declareDecl instanceof DeclareErrorOrWarning) {
      DeclareErrorOrWarning deow=(DeclareErrorOrWarning)declare.declareDecl;
      if (deow.isError()) {
        node.setKind(IProgramElement.Kind.DECLARE_ERROR);
        name+=AsmRelationshipUtils.DECLARE_ERROR;
      }
 else {
        node.setKind(IProgramElement.Kind.DECLARE_WARNING);
        name+=AsmRelationshipUtils.DECLARE_WARNING;
      }
      node.setName(name);
      node.setDetails(""String_Node_Str"" + AsmRelationshipUtils.genDeclareMessage(deow.getMessage()) + ""String_Node_Str"");
    }
 else     if (declare.declareDecl instanceof DeclareParents) {
      node.setKind(IProgramElement.Kind.DECLARE_PARENTS);
      DeclareParents dp=(DeclareParents)declare.declareDecl;
      node.setName(name + AsmRelationshipUtils.DECLARE_PARENTS);
      String kindOfDP=null;
      StringBuffer details=new StringBuffer(""String_Node_Str"");
      TypePattern[] newParents=dp.getParents().getTypePatterns();
      for (int i=0; i < newParents.length; i++) {
        TypePattern tp=newParents[i];
        UnresolvedType tx=tp.getExactType();
        if (kindOfDP == null) {
          kindOfDP=""String_Node_Str"";
          try {
            ResolvedType rtx=tx.resolve(((AjLookupEnvironment)declare.scope.environment()).factory.getWorld());
            if (!rtx.isInterface())             kindOfDP=""String_Node_Str"";
          }
 catch (          Throwable t) {
          }
        }
        String typename=tp.toString();
        if (typename.lastIndexOf(""String_Node_Str"") != -1) {
          typename=typename.substring(typename.lastIndexOf(""String_Node_Str"") + 1);
        }
        details.append(typename);
        if ((i + 1) < newParents.length)         details.append(""String_Node_Str"");
      }
      node.setDetails(kindOfDP + details.toString());
    }
 else     if (declare.declareDecl instanceof DeclareSoft) {
      node.setKind(IProgramElement.Kind.DECLARE_SOFT);
      DeclareSoft ds=(DeclareSoft)declare.declareDecl;
      node.setName(name + AsmRelationshipUtils.DECLARE_SOFT);
      node.setDetails(genTypePatternLabel(ds.getException()));
    }
 else     if (declare.declareDecl instanceof DeclarePrecedence) {
      node.setKind(IProgramElement.Kind.DECLARE_PRECEDENCE);
      DeclarePrecedence ds=(DeclarePrecedence)declare.declareDecl;
      node.setName(name + AsmRelationshipUtils.DECLARE_PRECEDENCE);
      node.setDetails(genPrecedenceListLabel(ds.getPatterns()));
    }
 else     if (declare.declareDecl instanceof DeclareAnnotation) {
      DeclareAnnotation deca=(DeclareAnnotation)declare.declareDecl;
      String thekind=deca.getKind().toString();
      node.setName(name + ""String_Node_Str"" + thekind.substring(3));
      if (deca.getKind() == DeclareAnnotation.AT_CONSTRUCTOR) {
        node.setKind(IProgramElement.Kind.DECLARE_ANNOTATION_AT_CONSTRUCTOR);
      }
 else       if (deca.getKind() == DeclareAnnotation.AT_FIELD) {
        node.setKind(IProgramElement.Kind.DECLARE_ANNOTATION_AT_FIELD);
      }
 else       if (deca.getKind() == DeclareAnnotation.AT_METHOD) {
        node.setKind(IProgramElement.Kind.DECLARE_ANNOTATION_AT_METHOD);
      }
 else       if (deca.getKind() == DeclareAnnotation.AT_TYPE) {
        node.setKind(IProgramElement.Kind.DECLARE_ANNOTATION_AT_TYPE);
      }
      node.setDetails(genDecaLabel(deca));
    }
 else {
      node.setKind(IProgramElement.Kind.ERROR);
      node.setName(AsmRelationshipUtils.DECLARE_UNKNONWN);
    }
  }
 else   if (methodDeclaration instanceof InterTypeDeclaration) {
    InterTypeDeclaration itd=(InterTypeDeclaration)methodDeclaration;
    String name=itd.getOnType().toString() + ""String_Node_Str"" + new String(itd.getDeclaredSelector());
    if (methodDeclaration instanceof InterTypeFieldDeclaration) {
      node.setKind(IProgramElement.Kind.INTER_TYPE_FIELD);
      node.setName(name);
    }
 else     if (methodDeclaration instanceof InterTypeMethodDeclaration) {
      node.setKind(IProgramElement.Kind.INTER_TYPE_METHOD);
      node.setName(name);
    }
 else     if (methodDeclaration instanceof InterTypeConstructorDeclaration) {
      node.setKind(IProgramElement.Kind.INTER_TYPE_CONSTRUCTOR);
      node.setName(itd.getOnType().toString() + ""String_Node_Str"" + itd.getOnType().toString());
    }
 else {
      node.setKind(IProgramElement.Kind.ERROR);
      node.setName(name);
    }
    node.setCorrespondingType(itd.returnType.toString());
    if (node.getKind() != IProgramElement.Kind.INTER_TYPE_FIELD) {
      setParameters(methodDeclaration,node);
    }
  }
 else {
    if (methodDeclaration.isConstructor()) {
      node.setKind(IProgramElement.Kind.CONSTRUCTOR);
    }
 else {
      node.setKind(IProgramElement.Kind.METHOD);
      if (true && methodDeclaration != null && methodDeclaration.annotations != null && methodDeclaration.scope != null) {
        for (int i=0; i < methodDeclaration.annotations.length; i++) {
          Annotation annotation=methodDeclaration.annotations[i];
          String annotationSig=new String(annotation.type.getTypeBindingPublic(methodDeclaration.scope).signature());
          if (annotationSig != null && annotationSig.charAt(1) == 'o') {
            if (""String_Node_Str"".equals(annotationSig)) {
              node.setKind(IProgramElement.Kind.POINTCUT);
              break;
            }
 else             if (""String_Node_Str"".equals(annotationSig) || ""String_Node_Str"".equals(annotationSig) || ""String_Node_Str"".equals(annotationSig)|| ""String_Node_Str"".equals(annotationSig)|| ""String_Node_Str"".equals(annotationSig)) {
              node.setKind(IProgramElement.Kind.ADVICE);
              node.setDetails(AsmRelationshipUtils.POINTCUT_ANONYMOUS);
              break;
            }
          }
        }
      }
    }
    node.setName(new String(methodDeclaration.selector));
    setParameters(methodDeclaration,node);
  }
}",0.0853308406222875
9250,"public ClassLoaderWeavingAdaptor(final ClassLoader loader,IWeavingContext wContext){
  this.weavingContext=wContext;
}","public ClassLoaderWeavingAdaptor(final ClassLoader loader,IWeavingContext wContext){
  super();
  this.classLoader=loader;
  this.weavingContext=wContext;
}",0.8613138686131386
9251,"/** 
 * Callback when we need to define a Closure in the JVM
 * @param name
 * @param bytes
 */
public void acceptClass(String name,byte[] bytes){
  try {
    if (shouldDump(name.replace('/','.'),false)) {
      dump(name,bytes,false);
    }
  }
 catch (  Throwable throwable) {
    throwable.printStackTrace();
  }
  defineClass(loader,name,bytes);
}","/** 
 * Callback when we need to define a Closure in the JVM
 * @param name
 * @param bytes
 */
public void acceptClass(String name,byte[] bytes){
  try {
    if (shouldDump(name.replace('/','.'),false)) {
      dump(name,bytes,false);
    }
  }
 catch (  Throwable throwable) {
    throwable.printStackTrace();
  }
  defineClass(classLoader,name,bytes);
}",0.99009900990099
9252,"protected void initialize(final ClassLoader loader,IWeavingContext wContext){
  this.generatedClassHandler=new GeneratedClassHandler(){
    /** 
 * Callback when we need to define a Closure in the JVM
 * @param name
 * @param bytes
 */
    public void acceptClass(    String name,    byte[] bytes){
      try {
        if (shouldDump(name.replace('/','.'),false)) {
          dump(name,bytes,false);
        }
      }
 catch (      Throwable throwable) {
        throwable.printStackTrace();
      }
      defineClass(loader,name,bytes);
    }
  }
;
  if (wContext == null) {
    weavingContext=new DefaultWeavingContext(loader);
  }
 else {
    weavingContext=wContext;
  }
  List definitions=parseDefinitions(loader);
  if (!enabled) {
    return;
  }
  bcelWorld=new LTWWorld(loader,getMessageHandler(),new ICrossReferenceHandler(){
    public void addCrossReference(    ISourceLocation from,    ISourceLocation to,    IRelationship.Kind kind,    boolean runtimeTest){
      ;
    }
  }
);
  weaver=new BcelWeaver(bcelWorld);
  registerDefinitions(weaver,loader,definitions);
  if (enabled) {
    weaver.prepareForWeave();
  }
 else {
    bcelWorld=null;
    weaver=null;
  }
}","protected void initialize(final ClassLoader deprecatedLoader,IWeavingContext deprecatedContext){
  if (initialized)   return;
  if (weavingContext == null) {
    weavingContext=new DefaultWeavingContext(classLoader);
  }
  createMessageHandler();
  this.generatedClassHandler=new GeneratedClassHandler(){
    /** 
 * Callback when we need to define a Closure in the JVM
 * @param name
 * @param bytes
 */
    public void acceptClass(    String name,    byte[] bytes){
      try {
        if (shouldDump(name.replace('/','.'),false)) {
          dump(name,bytes,false);
        }
      }
 catch (      Throwable throwable) {
        throwable.printStackTrace();
      }
      defineClass(classLoader,name,bytes);
    }
  }
;
  List definitions=parseDefinitions(classLoader);
  if (!enabled) {
    return;
  }
  bcelWorld=new LTWWorld(classLoader,getMessageHandler(),new ICrossReferenceHandler(){
    public void addCrossReference(    ISourceLocation from,    ISourceLocation to,    IRelationship.Kind kind,    boolean runtimeTest){
      ;
    }
  }
);
  weaver=new BcelWeaver(bcelWorld);
  registerDefinitions(weaver,classLoader,definitions);
  if (enabled) {
    weaver.prepareForWeave();
  }
 else {
    bcelWorld=null;
    weaver=null;
  }
  initialized=true;
}",0.8346972176759411
9253,"/** 
 * In an OSGi environment, determin which bundle a URL originated from. In a non-OSGi environment, implementors should return <code>null<code>.
 * @param url
 * @return
 */
public String getBundleIdFromURL(URL url);","/** 
 * In an OSGi environment, determin which bundle a URL originated from. In a non-OSGi environment, implementors should return <code>null<code>.
 * @param url
 * @return
 * @deprecated use getFile() or getClassLoaderName()
 */
public String getBundleIdFromURL(URL url);",0.8924949290060852
9254,"/** 
 * In an environment with multiple class loaders allows each to be identified using something safer and than toString
 * @return name of the associated class loader
 */
public String getClassLoaderName();","/** 
 * In an environment with multiple class loaders allows each to be identified using something safer and possibly shorter than toString
 * @return name of the associated class loader
 */
public String getClassLoaderName();",0.960919540229885
9255,"/** 
 * Run the given class, and return the result in a RunResult. The program runs with a classpath containing the sandbox directory, runtime, testing-client, bridge, and util projects (all used by the Tester class), and any jars in the sandbox.
 * @param args the arguments to pass to the program.
 * @param classpath the execution classpath, the sandbox directory, runtime, testing-client,bridge, and util projects will all be appended to the classpath, as will any jars in the sandbox.
 */
public RunResult run(String className,String[] args,final String classpath,boolean useLTW){
  lastRunResult=null;
  StringBuffer cp=new StringBuffer();
  if (classpath != null) {
    cp.append(substituteSandbox(classpath));
    cp.append(File.pathSeparator);
  }
  cp.append(ajc.getSandboxDirectory().getAbsolutePath());
  getAnyJars(ajc.getSandboxDirectory(),cp);
  URLClassLoader cLoader;
  ClassLoader parent=getClass().getClassLoader().getParent();
  if (useLTW) {
    ClassLoader aspectjLoader=new URLClassLoader(getURLs(DEFAULT_CLASSPATH_ENTRIES),parent);
    URL[] urls=getURLs(cp.toString());
    cLoader=createWeavingClassLoader(urls,aspectjLoader);
  }
 else {
    cp.append(DEFAULT_CLASSPATH_ENTRIES);
    URL[] urls=getURLs(cp.toString());
    cLoader=new URLClassLoader(urls,parent);
  }
  StringBuffer command=new StringBuffer(""String_Node_Str"");
  command.append(cp.toString());
  command.append(""String_Node_Str"");
  command.append(className);
  for (int i=0; i < args.length; i++) {
    command.append(""String_Node_Str"");
    command.append(args[i]);
  }
  ByteArrayOutputStream baosOut=new ByteArrayOutputStream();
  ByteArrayOutputStream baosErr=new ByteArrayOutputStream();
  try {
    try {
      Class testerClass=cLoader.loadClass(""String_Node_Str"");
      Method setBaseDir=testerClass.getDeclaredMethod(""String_Node_Str"",new Class[]{File.class});
      setBaseDir.invoke(null,new Object[]{ajc.getSandboxDirectory()});
    }
 catch (    InvocationTargetException itEx) {
      fail(""String_Node_Str"" + itEx.getTargetException());
    }
catch (    Exception ex) {
      fail(""String_Node_Str"" + ex);
    }
    startCapture(baosErr,baosOut);
    Class toRun=cLoader.loadClass(className);
    Method mainMethod=toRun.getMethod(""String_Node_Str"",new Class[]{String[].class});
    mainMethod.invoke(null,new Object[]{args});
    lastRunResult=new RunResult(command.toString(),new String(baosOut.toByteArray()),new String(baosErr.toByteArray()));
  }
 catch (  ClassNotFoundException cnf) {
    fail(""String_Node_Str"" + className);
  }
catch (  NoSuchMethodException nsm) {
    fail(className + ""String_Node_Str"");
  }
catch (  IllegalAccessException illEx) {
    fail(""String_Node_Str"" + className + ""String_Node_Str"");
  }
catch (  InvocationTargetException invTgt) {
    fail(""String_Node_Str"" + className + ""String_Node_Str""+ invTgt.getTargetException());
  }
 finally {
    stopCapture(baosErr,baosOut);
  }
  return lastRunResult;
}","/** 
 * Run the given class, and return the result in a RunResult. The program runs with a classpath containing the sandbox directory, runtime, testing-client, bridge, and util projects (all used by the Tester class), and any jars in the sandbox.
 * @param args the arguments to pass to the program.
 * @param classpath the execution classpath, the sandbox directory, runtime, testing-client,bridge, and util projects will all be appended to the classpath, as will any jars in the sandbox.
 */
public RunResult run(String className,String[] args,final String classpath,boolean useLTW){
  lastRunResult=null;
  StringBuffer cp=new StringBuffer();
  if (classpath != null) {
    cp.append(substituteSandbox(classpath));
    cp.append(File.pathSeparator);
  }
  cp.append(ajc.getSandboxDirectory().getAbsolutePath());
  getAnyJars(ajc.getSandboxDirectory(),cp);
  URLClassLoader sandboxLoader;
  URLClassLoader testLoader=(URLClassLoader)getClass().getClassLoader();
  ClassLoader parentLoader=testLoader.getParent();
  if (useLTW) {
    URL[] testUrls=testLoader.getURLs();
    URL[] java5Urls=getURLs(JAVA5_CLASSPATH_ENTRIES);
    URL[] urls=new URL[testUrls.length + java5Urls.length];
    System.arraycopy(testUrls,0,urls,0,testUrls.length);
    System.arraycopy(java5Urls,0,urls,testUrls.length,java5Urls.length);
    ClassLoader aspectjLoader=new URLClassLoader(urls,parentLoader);
    URL[] sandboxUrls=getURLs(cp.toString());
    sandboxLoader=createWeavingClassLoader(sandboxUrls,aspectjLoader);
  }
 else {
    cp.append(DEFAULT_CLASSPATH_ENTRIES);
    URL[] urls=getURLs(cp.toString());
    sandboxLoader=new URLClassLoader(urls,parentLoader);
  }
  StringBuffer command=new StringBuffer(""String_Node_Str"");
  command.append(cp.toString());
  command.append(""String_Node_Str"");
  command.append(className);
  for (int i=0; i < args.length; i++) {
    command.append(""String_Node_Str"");
    command.append(args[i]);
  }
  ByteArrayOutputStream baosOut=new ByteArrayOutputStream();
  ByteArrayOutputStream baosErr=new ByteArrayOutputStream();
  ClassLoader contexClassLoader=Thread.currentThread().getContextClassLoader();
  try {
    try {
      Class testerClass=sandboxLoader.loadClass(""String_Node_Str"");
      Method setBaseDir=testerClass.getDeclaredMethod(""String_Node_Str"",new Class[]{File.class});
      setBaseDir.invoke(null,new Object[]{ajc.getSandboxDirectory()});
    }
 catch (    InvocationTargetException itEx) {
      fail(""String_Node_Str"" + itEx.getTargetException());
    }
catch (    Exception ex) {
      fail(""String_Node_Str"" + ex);
    }
    startCapture(baosErr,baosOut);
    Thread.currentThread().setContextClassLoader(sandboxLoader);
    Class toRun=sandboxLoader.loadClass(className);
    Method mainMethod=toRun.getMethod(""String_Node_Str"",new Class[]{String[].class});
    mainMethod.invoke(null,new Object[]{args});
    lastRunResult=new RunResult(command.toString(),new String(baosOut.toByteArray()),new String(baosErr.toByteArray()));
  }
 catch (  ClassNotFoundException cnf) {
    fail(""String_Node_Str"" + className);
  }
catch (  NoSuchMethodException nsm) {
    fail(className + ""String_Node_Str"");
  }
catch (  IllegalAccessException illEx) {
    fail(""String_Node_Str"" + className + ""String_Node_Str"");
  }
catch (  InvocationTargetException invTgt) {
    fail(""String_Node_Str"" + className + ""String_Node_Str""+ invTgt.getTargetException());
  }
 finally {
    Thread.currentThread().setContextClassLoader(contexClassLoader);
    stopCapture(baosErr,baosOut);
  }
  return lastRunResult;
}",0.8734391860644366
9256,"public void acceptResult(UnwovenClassFile result){
  if (wovenClass == null) {
    wovenClass=result;
    String name=result.getClassName();
    if (shouldDump(name.replace('/','.'),false)) {
      dump(name,result.getBytes(),false);
    }
  }
 else {
    String className=result.getClassName();
    System.err.println(""String_Node_Str"" + wovenClass.getClassName() + ""String_Node_Str""+ className);
    generatedClasses.put(className,result);
    generatedClasses.put(wovenClass.getClassName(),result);
    generatedClassHandler.acceptClass(className,result.getBytes());
  }
}","public void acceptResult(UnwovenClassFile result){
  if (wovenClass == null) {
    wovenClass=result;
    String name=result.getClassName();
    if (shouldDump(name.replace('/','.'),false)) {
      dump(name,result.getBytes(),false);
    }
  }
 else {
    String className=result.getClassName();
    generatedClasses.put(className,result);
    generatedClasses.put(wovenClass.getClassName(),result);
    generatedClassHandler.acceptClass(className,result.getBytes());
  }
}",0.9026717557251908
9257,"public IWeaveRequestor getRequestor(){
  return new IWeaveRequestor(){
    public void acceptResult(    UnwovenClassFile result){
      if (wovenClass == null) {
        wovenClass=result;
        String name=result.getClassName();
        if (shouldDump(name.replace('/','.'),false)) {
          dump(name,result.getBytes(),false);
        }
      }
 else {
        String className=result.getClassName();
        System.err.println(""String_Node_Str"" + wovenClass.getClassName() + ""String_Node_Str""+ className);
        generatedClasses.put(className,result);
        generatedClasses.put(wovenClass.getClassName(),result);
        generatedClassHandler.acceptClass(className,result.getBytes());
      }
    }
    public void processingReweavableState(){
    }
    public void addingTypeMungers(){
    }
    public void weavingAspects(){
    }
    public void weavingClasses(){
    }
    public void weaveCompleted(){
      if (delegate != null)       delegate.weavingCompleted();
      ResolvedType.resetPrimitives();
    }
  }
;
}","public IWeaveRequestor getRequestor(){
  return new IWeaveRequestor(){
    public void acceptResult(    UnwovenClassFile result){
      if (wovenClass == null) {
        wovenClass=result;
        String name=result.getClassName();
        if (shouldDump(name.replace('/','.'),false)) {
          dump(name,result.getBytes(),false);
        }
      }
 else {
        String className=result.getClassName();
        generatedClasses.put(className,result);
        generatedClasses.put(wovenClass.getClassName(),result);
        generatedClassHandler.acceptClass(className,result.getBytes());
      }
    }
    public void processingReweavableState(){
    }
    public void addingTypeMungers(){
    }
    public void weavingAspects(){
    }
    public void weavingClasses(){
    }
    public void weaveCompleted(){
      if (delegate != null)       delegate.weavingCompleted();
      ResolvedType.resetPrimitives();
    }
  }
;
}",0.9459183673469388
9258,"protected ReferenceTypeDelegate resolveIfBootstrapDelegate(ReferenceType ty){
  String name=ty.getName();
  Reference bootRef=(Reference)bootstrapTypes.get(name);
  if (bootRef != null) {
    ReferenceTypeDelegate rtd=(ReferenceTypeDelegate)bootRef.get();
    if (rtd != null) {
      return rtd;
    }
  }
  char fc=name.charAt(0);
  if (fc == 'j' || fc == 'c' || fc == 'o' || fc == 's') {
    if (name.startsWith(""String_Node_Str"") || name.startsWith(""String_Node_Str"") || name.startsWith(""String_Node_Str"")|| name.startsWith(""String_Node_Str"")|| name.startsWith(""String_Node_Str"")) {
      ReferenceTypeDelegate bootstrapLoaderDelegate=resolveReflectionTypeDelegate(ty,loader);
      if (bootstrapLoaderDelegate != null) {
        bootstrapTypes.put(ty.getName(),new WeakReference(bootstrapLoaderDelegate));
      }
      return bootstrapLoaderDelegate;
    }
  }
  return null;
}","protected ReferenceTypeDelegate resolveIfBootstrapDelegate(ReferenceType ty){
  String name=ty.getName();
  Reference bootRef=(Reference)bootstrapTypes.get(name);
  if (bootRef != null) {
    ReferenceTypeDelegate rtd=(ReferenceTypeDelegate)bootRef.get();
    if (rtd != null) {
      return rtd;
    }
  }
  char fc=name.charAt(0);
  if (fc == 'j' || fc == 'c' || fc == 'o' || fc == 's') {
    if (name.startsWith(""String_Node_Str"") || name.startsWith(""String_Node_Str"") || name.startsWith(""String_Node_Str"")|| name.startsWith(""String_Node_Str"")|| name.startsWith(""String_Node_Str"")) {
      ReferenceTypeDelegate bootstrapLoaderDelegate=resolveReflectionTypeDelegate(ty,null);
      if (bootstrapLoaderDelegate != null) {
        bootstrapTypes.put(ty.getName(),new WeakReference(bootstrapLoaderDelegate));
      }
      return bootstrapLoaderDelegate;
    }
  }
  return null;
}",0.9943310657596371
9259,"/** 
 * Run the given class, and return the result in a RunResult. The program runs with a classpath containing the sandbox directory, runtime, testing-client, bridge, and util projects (all used by the Tester class), and any jars in the sandbox.
 * @param args the arguments to pass to the program.
 * @param classpath the execution classpath, the sandbox directory, runtime, testing-client,bridge, and util projects will all be appended to the classpath, as will any jars in the sandbox.
 */
public RunResult run(String className,String[] args,String classpath,boolean useLTW){
  lastRunResult=null;
  StringBuffer cp=new StringBuffer();
  if (classpath != null) {
    cp.append(substituteSandbox(classpath));
    cp.append(File.pathSeparator);
  }
  cp.append(ajc.getSandboxDirectory().getAbsolutePath());
  cp.append(DEFAULT_CLASSPATH_ENTRIES);
  getAnyJars(ajc.getSandboxDirectory(),cp);
  classpath=cp.toString();
  StringBuffer command=new StringBuffer(""String_Node_Str"");
  command.append(classpath);
  command.append(""String_Node_Str"");
  command.append(className);
  for (int i=0; i < args.length; i++) {
    command.append(""String_Node_Str"");
    command.append(args[i]);
  }
  ByteArrayOutputStream baosOut=new ByteArrayOutputStream();
  ByteArrayOutputStream baosErr=new ByteArrayOutputStream();
  StringTokenizer strTok=new StringTokenizer(classpath,File.pathSeparator);
  URL[] urls=new URL[strTok.countTokens()];
  try {
    for (int i=0; i < urls.length; i++) {
      urls[i]=new File(strTok.nextToken()).getCanonicalFile().toURL();
    }
  }
 catch (  Exception malEx) {
    fail(""String_Node_Str"" + classpath);
  }
  URLClassLoader cLoader;
  if (useLTW) {
    ClassLoader parent=getClass().getClassLoader();
    cLoader=new WeavingURLClassLoader(urls,parent);
  }
 else {
    cLoader=new URLClassLoader(urls,null);
  }
  try {
    try {
      Class testerClass=cLoader.loadClass(""String_Node_Str"");
      Method setBaseDir=testerClass.getDeclaredMethod(""String_Node_Str"",new Class[]{File.class});
      setBaseDir.invoke(null,new Object[]{ajc.getSandboxDirectory()});
    }
 catch (    Exception ex) {
      fail(""String_Node_Str"" + ex);
    }
    startCapture(baosErr,baosOut);
    Class toRun=cLoader.loadClass(className);
    Method mainMethod=toRun.getMethod(""String_Node_Str"",new Class[]{String[].class});
    mainMethod.invoke(null,new Object[]{args});
    lastRunResult=new RunResult(command.toString(),new String(baosOut.toByteArray()),new String(baosErr.toByteArray()));
  }
 catch (  ClassNotFoundException cnf) {
    fail(""String_Node_Str"" + className);
  }
catch (  NoSuchMethodException nsm) {
    fail(className + ""String_Node_Str"");
  }
catch (  IllegalAccessException illEx) {
    fail(""String_Node_Str"" + className + ""String_Node_Str"");
  }
catch (  InvocationTargetException invTgt) {
    fail(""String_Node_Str"" + className + ""String_Node_Str""+ invTgt.getTargetException());
  }
 finally {
    stopCapture(baosErr,baosOut);
  }
  return lastRunResult;
}","/** 
 * Run the given class, and return the result in a RunResult. The program runs with a classpath containing the sandbox directory, runtime, testing-client, bridge, and util projects (all used by the Tester class), and any jars in the sandbox.
 * @param args the arguments to pass to the program.
 * @param classpath the execution classpath, the sandbox directory, runtime, testing-client,bridge, and util projects will all be appended to the classpath, as will any jars in the sandbox.
 */
public RunResult run(String className,String[] args,final String classpath,boolean useLTW){
  lastRunResult=null;
  StringBuffer cp=new StringBuffer();
  if (classpath != null) {
    cp.append(substituteSandbox(classpath));
    cp.append(File.pathSeparator);
  }
  cp.append(ajc.getSandboxDirectory().getAbsolutePath());
  getAnyJars(ajc.getSandboxDirectory(),cp);
  URLClassLoader cLoader;
  ClassLoader parent=getClass().getClassLoader().getParent();
  if (useLTW) {
    ClassLoader aspectjLoader=new URLClassLoader(getURLs(DEFAULT_CLASSPATH_ENTRIES),parent);
    URL[] urls=getURLs(cp.toString());
    cLoader=createWeavingClassLoader(urls,aspectjLoader);
  }
 else {
    cp.append(DEFAULT_CLASSPATH_ENTRIES);
    URL[] urls=getURLs(cp.toString());
    cLoader=new URLClassLoader(urls,parent);
  }
  StringBuffer command=new StringBuffer(""String_Node_Str"");
  command.append(cp.toString());
  command.append(""String_Node_Str"");
  command.append(className);
  for (int i=0; i < args.length; i++) {
    command.append(""String_Node_Str"");
    command.append(args[i]);
  }
  ByteArrayOutputStream baosOut=new ByteArrayOutputStream();
  ByteArrayOutputStream baosErr=new ByteArrayOutputStream();
  try {
    try {
      Class testerClass=cLoader.loadClass(""String_Node_Str"");
      Method setBaseDir=testerClass.getDeclaredMethod(""String_Node_Str"",new Class[]{File.class});
      setBaseDir.invoke(null,new Object[]{ajc.getSandboxDirectory()});
    }
 catch (    InvocationTargetException itEx) {
      fail(""String_Node_Str"" + itEx.getTargetException());
    }
catch (    Exception ex) {
      fail(""String_Node_Str"" + ex);
    }
    startCapture(baosErr,baosOut);
    Class toRun=cLoader.loadClass(className);
    Method mainMethod=toRun.getMethod(""String_Node_Str"",new Class[]{String[].class});
    mainMethod.invoke(null,new Object[]{args});
    lastRunResult=new RunResult(command.toString(),new String(baosOut.toByteArray()),new String(baosErr.toByteArray()));
  }
 catch (  ClassNotFoundException cnf) {
    fail(""String_Node_Str"" + className);
  }
catch (  NoSuchMethodException nsm) {
    fail(className + ""String_Node_Str"");
  }
catch (  IllegalAccessException illEx) {
    fail(""String_Node_Str"" + className + ""String_Node_Str"");
  }
catch (  InvocationTargetException invTgt) {
    fail(""String_Node_Str"" + className + ""String_Node_Str""+ invTgt.getTargetException());
  }
 finally {
    stopCapture(baosErr,baosOut);
  }
  return lastRunResult;
}",0.6891095775122034
9260,"private static ReflectionBasedReferenceTypeDelegate create15Delegate(ReferenceType forReferenceType,Class forClass,ClassLoader usingClassLoader,World inWorld){
  try {
    Class delegateClass=Class.forName(""String_Node_Str"",true,usingClassLoader);
    ReflectionBasedReferenceTypeDelegate ret=(ReflectionBasedReferenceTypeDelegate)delegateClass.newInstance();
    ret.initialize(forReferenceType,forClass,usingClassLoader,inWorld);
    return ret;
  }
 catch (  ClassNotFoundException cnfEx) {
    throw new IllegalStateException(""String_Node_Str"");
  }
catch (  InstantiationException insEx) {
    throw new IllegalStateException(""String_Node_Str"" + insEx + ""String_Node_Str"");
  }
catch (  IllegalAccessException illAccEx) {
    throw new IllegalStateException(""String_Node_Str"" + illAccEx + ""String_Node_Str"");
  }
}","private static ReflectionBasedReferenceTypeDelegate create15Delegate(ReferenceType forReferenceType,Class forClass,ClassLoader usingClassLoader,World inWorld){
  try {
    Class delegateClass=Class.forName(""String_Node_Str"");
    ReflectionBasedReferenceTypeDelegate ret=(ReflectionBasedReferenceTypeDelegate)delegateClass.newInstance();
    ret.initialize(forReferenceType,forClass,usingClassLoader,inWorld);
    return ret;
  }
 catch (  ClassNotFoundException cnfEx) {
    throw new IllegalStateException(""String_Node_Str"");
  }
catch (  InstantiationException insEx) {
    throw new IllegalStateException(""String_Node_Str"" + insEx + ""String_Node_Str"");
  }
catch (  IllegalAccessException illAccEx) {
    throw new IllegalStateException(""String_Node_Str"" + illAccEx + ""String_Node_Str"");
  }
}",0.3304455445544554
9261,"/** 
 * 1) Advice must be public 2) Advice must have a void return type if not around advice 3) Advice must not have any other @AspectJ annotations 4) After throwing advice must declare the thrown formal 5) After returning advice must declare the returning formal
 */
private void validateAdvice(MethodDeclaration methodDeclaration){
  if (!insideAspect()) {
    methodDeclaration.scope.problemReporter().signalError(methodDeclaration.sourceStart,methodDeclaration.sourceEnd,""String_Node_Str"");
  }
  if (!Modifier.isPublic(methodDeclaration.modifiers)) {
    methodDeclaration.scope.problemReporter().signalError(methodDeclaration.sourceStart,methodDeclaration.sourceEnd,""String_Node_Str"");
  }
  if (ajAnnotations.hasMultipleAdviceAnnotations) {
    methodDeclaration.scope.problemReporter().disallowedTargetForAnnotation(ajAnnotations.duplicateAdviceAnnotation);
  }
  if (ajAnnotations.hasPointcutAnnotation) {
    methodDeclaration.scope.problemReporter().disallowedTargetForAnnotation(ajAnnotations.pointcutAnnotation);
  }
  if (ajAnnotations.hasAspectAnnotation) {
    methodDeclaration.scope.problemReporter().disallowedTargetForAnnotation(ajAnnotations.aspectAnnotation);
  }
  if (ajAnnotations.hasAdviceNameAnnotation) {
    methodDeclaration.scope.problemReporter().disallowedTargetForAnnotation(ajAnnotations.adviceNameAnnotation);
  }
  if (ajAnnotations.adviceKind != AdviceKind.Around) {
    ensureVoidReturnType(methodDeclaration);
  }
  if (ajAnnotations.adviceKind == AdviceKind.AfterThrowing) {
    int[] throwingLocation=new int[2];
    String thrownFormal=getStringLiteralFor(""String_Node_Str"",ajAnnotations.adviceAnnotation,throwingLocation);
    if (thrownFormal != null) {
      Argument[] arguments=methodDeclaration.arguments;
      if (!toArgumentNames(methodDeclaration.arguments).contains(thrownFormal)) {
        methodDeclaration.scope.problemReporter().signalError(methodDeclaration.sourceStart,methodDeclaration.sourceEnd,""String_Node_Str"" + thrownFormal + ""String_Node_Str"");
      }
    }
  }
  if (ajAnnotations.adviceKind == AdviceKind.AfterReturning) {
    int[] throwingLocation=new int[2];
    String returningFormal=getStringLiteralFor(""String_Node_Str"",ajAnnotations.adviceAnnotation,throwingLocation);
    if (returningFormal != null) {
      if (!toArgumentNames(methodDeclaration.arguments).contains(returningFormal)) {
        methodDeclaration.scope.problemReporter().signalError(methodDeclaration.sourceStart,methodDeclaration.sourceEnd,""String_Node_Str"" + returningFormal + ""String_Node_Str"");
      }
    }
  }
  resolveAndSetPointcut(methodDeclaration,ajAnnotations.adviceAnnotation);
}","/** 
 * 1) Advice must be public 2) Advice must have a void return type if not around advice 3) Advice must not have any other @AspectJ annotations 4) After throwing advice must declare the thrown formal 5) After returning advice must declare the returning formal 6) Advice must not be static
 */
private void validateAdvice(MethodDeclaration methodDeclaration){
  if (!insideAspect()) {
    methodDeclaration.scope.problemReporter().signalError(methodDeclaration.sourceStart,methodDeclaration.sourceEnd,""String_Node_Str"");
  }
  if (!Modifier.isPublic(methodDeclaration.modifiers)) {
    methodDeclaration.scope.problemReporter().signalError(methodDeclaration.sourceStart,methodDeclaration.sourceEnd,""String_Node_Str"");
  }
  if (Modifier.isStatic(methodDeclaration.modifiers)) {
    methodDeclaration.scope.problemReporter().signalError(methodDeclaration.sourceStart,methodDeclaration.sourceEnd,""String_Node_Str"");
  }
  if (ajAnnotations.hasMultipleAdviceAnnotations) {
    methodDeclaration.scope.problemReporter().disallowedTargetForAnnotation(ajAnnotations.duplicateAdviceAnnotation);
  }
  if (ajAnnotations.hasPointcutAnnotation) {
    methodDeclaration.scope.problemReporter().disallowedTargetForAnnotation(ajAnnotations.pointcutAnnotation);
  }
  if (ajAnnotations.hasAspectAnnotation) {
    methodDeclaration.scope.problemReporter().disallowedTargetForAnnotation(ajAnnotations.aspectAnnotation);
  }
  if (ajAnnotations.hasAdviceNameAnnotation) {
    methodDeclaration.scope.problemReporter().disallowedTargetForAnnotation(ajAnnotations.adviceNameAnnotation);
  }
  if (ajAnnotations.adviceKind != AdviceKind.Around) {
    ensureVoidReturnType(methodDeclaration);
  }
  if (ajAnnotations.adviceKind == AdviceKind.AfterThrowing) {
    int[] throwingLocation=new int[2];
    String thrownFormal=getStringLiteralFor(""String_Node_Str"",ajAnnotations.adviceAnnotation,throwingLocation);
    if (thrownFormal != null) {
      Argument[] arguments=methodDeclaration.arguments;
      if (!toArgumentNames(methodDeclaration.arguments).contains(thrownFormal)) {
        methodDeclaration.scope.problemReporter().signalError(methodDeclaration.sourceStart,methodDeclaration.sourceEnd,""String_Node_Str"" + thrownFormal + ""String_Node_Str"");
      }
    }
  }
  if (ajAnnotations.adviceKind == AdviceKind.AfterReturning) {
    int[] throwingLocation=new int[2];
    String returningFormal=getStringLiteralFor(""String_Node_Str"",ajAnnotations.adviceAnnotation,throwingLocation);
    if (returningFormal != null) {
      if (!toArgumentNames(methodDeclaration.arguments).contains(returningFormal)) {
        methodDeclaration.scope.problemReporter().signalError(methodDeclaration.sourceStart,methodDeclaration.sourceEnd,""String_Node_Str"" + returningFormal + ""String_Node_Str"");
      }
    }
  }
  resolveAndSetPointcut(methodDeclaration,ajAnnotations.adviceAnnotation);
}",0.9591132109758314
9262,"private String getKey(Pointcut p,ResolvedType a){
  StringBuffer sb=new StringBuffer();
  sb.append(a.getName());
  sb.append(""String_Node_Str"");
  sb.append(p.toString());
  return sb.toString();
}","private String getKey(Pointcut p,ResolvedType a,String stackOrCounter){
  StringBuffer sb=new StringBuffer();
  sb.append(a.getName());
  sb.append(""String_Node_Str"");
  sb.append(p.toString());
  sb.append(""String_Node_Str"");
  sb.append(stackOrCounter);
  return sb.toString();
}",0.826722338204593
9263,"private Object getCflowfield(Pointcut pcutkey,ResolvedType concreteAspect){
  String key=getKey(pcutkey,concreteAspect);
  Object o=null;
  if (isBelow) {
    o=cflowBelowFields.get(key);
  }
 else {
    o=cflowFields.get(key);
  }
  return o;
}","private Object getCflowfield(Pointcut pcutkey,ResolvedType concreteAspect,String stackOrCounter){
  String key=getKey(pcutkey,concreteAspect,stackOrCounter);
  Object o=null;
  if (isBelow)   o=cflowBelowFields.get(key);
 else   o=cflowFields.get(key);
  return o;
}",0.7279843444227005
9264,"public Pointcut concretize1(ResolvedType inAspect,ResolvedType declaringType,IntMap bindings){
  if (isDeclare(bindings.getEnclosingAdvice())) {
    inAspect.getWorld().showMessage(IMessage.ERROR,WeaverMessages.format(WeaverMessages.CFLOW_IN_DECLARE,isBelow ? ""String_Node_Str"" : ""String_Node_Str""),bindings.getEnclosingAdvice().getSourceLocation(),null);
    return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
  }
  IntMap entryBindings=new IntMap();
  if (freeVars != null) {
    for (int i=0, len=freeVars.length; i < len; i++) {
      int freeVar=freeVars[i];
      entryBindings.put(freeVar,i);
    }
  }
  entryBindings.copyContext(bindings);
  World world=inAspect.getWorld();
  Pointcut concreteEntry;
  ResolvedType concreteAspect=bindings.getConcreteAspect();
  CrosscuttingMembers xcut=concreteAspect.crosscuttingMembers;
  Collection previousCflowEntries=xcut.getCflowEntries();
  entryBindings.pushEnclosingDefinition(CFLOW_MARKER);
  try {
    concreteEntry=entry.concretize(inAspect,declaringType,entryBindings);
  }
  finally {
    entryBindings.popEnclosingDefinitition();
  }
  List innerCflowEntries=new ArrayList(xcut.getCflowEntries());
  innerCflowEntries.removeAll(previousCflowEntries);
  Object field=getCflowfield(concreteEntry,concreteAspect);
  if (freeVars == null || freeVars.length == 0) {
    ResolvedMember localCflowField=null;
    if (field != null) {
      localCflowField=(ResolvedMember)field;
    }
 else {
      localCflowField=new ResolvedMemberImpl(Member.FIELD,concreteAspect,Modifier.STATIC | Modifier.PUBLIC | Modifier.FINAL,NameMangler.cflowCounter(xcut),UnresolvedType.forName(NameMangler.CFLOW_COUNTER_TYPE).getSignature());
      concreteAspect.crosscuttingMembers.addTypeMunger(world.makeCflowCounterFieldAdder(localCflowField));
      concreteAspect.crosscuttingMembers.addConcreteShadowMunger(Advice.makeCflowEntry(world,concreteEntry,isBelow,localCflowField,freeVars == null ? 0 : freeVars.length,innerCflowEntries,inAspect));
      putCflowfield(concreteEntry,concreteAspect,localCflowField);
    }
    Pointcut ret=new ConcreteCflowPointcut(localCflowField,null,true);
    ret.copyLocationFrom(this);
    return ret;
  }
 else {
    List slots=new ArrayList();
    for (int i=0, len=freeVars.length; i < len; i++) {
      int freeVar=freeVars[i];
      if (!bindings.hasKey(freeVar))       continue;
      int formalIndex=bindings.get(freeVar);
      ResolvedPointcutDefinition enclosingDef=bindings.peekEnclosingDefinition();
      ResolvedType formalType=null;
      if (enclosingDef != null && enclosingDef.getParameterTypes().length > 0) {
        formalType=enclosingDef.getParameterTypes()[freeVar].resolve(world);
      }
 else {
        formalType=bindings.getAdviceSignature().getParameterTypes()[formalIndex].resolve(world);
      }
      ConcreteCflowPointcut.Slot slot=new ConcreteCflowPointcut.Slot(formalIndex,formalType,i);
      slots.add(slot);
    }
    ResolvedMember localCflowField=null;
    if (field != null) {
      localCflowField=(ResolvedMember)field;
    }
 else {
      localCflowField=new ResolvedMemberImpl(Member.FIELD,concreteAspect,Modifier.STATIC | Modifier.PUBLIC | Modifier.FINAL,NameMangler.cflowStack(xcut),UnresolvedType.forName(NameMangler.CFLOW_STACK_TYPE).getSignature());
      concreteAspect.crosscuttingMembers.addConcreteShadowMunger(Advice.makeCflowEntry(world,concreteEntry,isBelow,localCflowField,freeVars.length,innerCflowEntries,inAspect));
      concreteAspect.crosscuttingMembers.addTypeMunger(world.makeCflowStackFieldAdder(localCflowField));
      putCflowfield(concreteEntry,concreteAspect,localCflowField);
    }
    Pointcut ret=new ConcreteCflowPointcut(localCflowField,slots,false);
    ret.copyLocationFrom(this);
    return ret;
  }
}","public Pointcut concretize1(ResolvedType inAspect,ResolvedType declaringType,IntMap bindings){
  if (isDeclare(bindings.getEnclosingAdvice())) {
    inAspect.getWorld().showMessage(IMessage.ERROR,WeaverMessages.format(WeaverMessages.CFLOW_IN_DECLARE,isBelow ? ""String_Node_Str"" : ""String_Node_Str""),bindings.getEnclosingAdvice().getSourceLocation(),null);
    return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
  }
  IntMap entryBindings=new IntMap();
  if (freeVars != null) {
    for (int i=0, len=freeVars.length; i < len; i++) {
      int freeVar=freeVars[i];
      entryBindings.put(freeVar,i);
    }
  }
  entryBindings.copyContext(bindings);
  World world=inAspect.getWorld();
  Pointcut concreteEntry;
  ResolvedType concreteAspect=bindings.getConcreteAspect();
  CrosscuttingMembers xcut=concreteAspect.crosscuttingMembers;
  Collection previousCflowEntries=xcut.getCflowEntries();
  entryBindings.pushEnclosingDefinition(CFLOW_MARKER);
  try {
    concreteEntry=entry.concretize(inAspect,declaringType,entryBindings);
  }
  finally {
    entryBindings.popEnclosingDefinitition();
  }
  List innerCflowEntries=new ArrayList(xcut.getCflowEntries());
  innerCflowEntries.removeAll(previousCflowEntries);
  if (freeVars == null || freeVars.length == 0) {
    ResolvedMember localCflowField=null;
    Object field=getCflowfield(concreteEntry,concreteAspect,""String_Node_Str"");
    if (field != null) {
      localCflowField=(ResolvedMember)field;
    }
 else {
      localCflowField=new ResolvedMemberImpl(Member.FIELD,concreteAspect,Modifier.STATIC | Modifier.PUBLIC | Modifier.FINAL,NameMangler.cflowCounter(xcut),UnresolvedType.forName(NameMangler.CFLOW_COUNTER_TYPE).getSignature());
      concreteAspect.crosscuttingMembers.addTypeMunger(world.makeCflowCounterFieldAdder(localCflowField));
      concreteAspect.crosscuttingMembers.addConcreteShadowMunger(Advice.makeCflowEntry(world,concreteEntry,isBelow,localCflowField,freeVars == null ? 0 : freeVars.length,innerCflowEntries,inAspect));
      putCflowfield(concreteEntry,concreteAspect,localCflowField,""String_Node_Str"");
    }
    Pointcut ret=new ConcreteCflowPointcut(localCflowField,null,true);
    ret.copyLocationFrom(this);
    return ret;
  }
 else {
    List slots=new ArrayList();
    for (int i=0, len=freeVars.length; i < len; i++) {
      int freeVar=freeVars[i];
      if (!bindings.hasKey(freeVar))       continue;
      int formalIndex=bindings.get(freeVar);
      ResolvedPointcutDefinition enclosingDef=bindings.peekEnclosingDefinition();
      ResolvedType formalType=null;
      if (enclosingDef != null && enclosingDef.getParameterTypes().length > 0) {
        formalType=enclosingDef.getParameterTypes()[freeVar].resolve(world);
      }
 else {
        formalType=bindings.getAdviceSignature().getParameterTypes()[formalIndex].resolve(world);
      }
      ConcreteCflowPointcut.Slot slot=new ConcreteCflowPointcut.Slot(formalIndex,formalType,i);
      slots.add(slot);
    }
    ResolvedMember localCflowField=null;
    Object field=getCflowfield(concreteEntry,concreteAspect,""String_Node_Str"");
    if (field != null) {
      localCflowField=(ResolvedMember)field;
    }
 else {
      localCflowField=new ResolvedMemberImpl(Member.FIELD,concreteAspect,Modifier.STATIC | Modifier.PUBLIC | Modifier.FINAL,NameMangler.cflowStack(xcut),UnresolvedType.forName(NameMangler.CFLOW_STACK_TYPE).getSignature());
      concreteAspect.crosscuttingMembers.addConcreteShadowMunger(Advice.makeCflowEntry(world,concreteEntry,isBelow,localCflowField,freeVars.length,innerCflowEntries,inAspect));
      concreteAspect.crosscuttingMembers.addTypeMunger(world.makeCflowStackFieldAdder(localCflowField));
      putCflowfield(concreteEntry,concreteAspect,localCflowField,""String_Node_Str"");
    }
    Pointcut ret=new ConcreteCflowPointcut(localCflowField,slots,false);
    ret.copyLocationFrom(this);
    return ret;
  }
}",0.9581589958158996
9265,"private void putCflowfield(Pointcut pcutkey,ResolvedType concreteAspect,Object o){
  String key=getKey(pcutkey,concreteAspect);
  if (isBelow) {
    cflowBelowFields.put(key,o);
  }
 else {
    cflowFields.put(key,o);
  }
}","private void putCflowfield(Pointcut pcutkey,ResolvedType concreteAspect,Object o,String stackOrCounter){
  String key=getKey(pcutkey,concreteAspect,stackOrCounter);
  if (isBelow) {
    cflowBelowFields.put(key,o);
  }
 else {
    cflowFields.put(key,o);
  }
}",0.9233954451345756
9266,"private void writeResource(String filename,byte[] content,File srcLocation) throws IOException {
  if (state.hasResource(filename)) {
    IMessage msg=new Message(""String_Node_Str"" + filename + ""String_Node_Str"",IMessage.WARNING,null,new SourceLocation(srcLocation,0));
    handler.handleMessage(msg);
    return;
  }
  if (zos != null) {
    ZipEntry newEntry=new ZipEntry(filename);
    zos.putNextEntry(newEntry);
    zos.write(content);
    zos.closeEntry();
  }
 else {
    File destDir=buildConfig.getOutputDir();
    if (buildConfig.getCompilationResultDestinationManager() != null) {
      destDir=buildConfig.getCompilationResultDestinationManager().getOutputLocationForResource(srcLocation.getAbsolutePath());
    }
    OutputStream fos=FileUtil.makeOutputStream(new File(destDir,filename));
    fos.write(content);
    fos.close();
  }
  state.recordResource(filename);
}","private void writeResource(String filename,byte[] content,File srcLocation) throws IOException {
  if (state.hasResource(filename)) {
    IMessage msg=new Message(""String_Node_Str"" + filename + ""String_Node_Str"",IMessage.WARNING,null,new SourceLocation(srcLocation,0));
    handler.handleMessage(msg);
    return;
  }
  if (zos != null) {
    ZipEntry newEntry=new ZipEntry(filename);
    zos.putNextEntry(newEntry);
    zos.write(content);
    zos.closeEntry();
  }
 else {
    File destDir=buildConfig.getOutputDir();
    if (buildConfig.getCompilationResultDestinationManager() != null) {
      destDir=buildConfig.getCompilationResultDestinationManager().getOutputLocationForResource(srcLocation.getAbsolutePath());
    }
    try {
      OutputStream fos=FileUtil.makeOutputStream(new File(destDir,filename));
      fos.write(content);
      fos.close();
    }
 catch (    FileNotFoundException fnfe) {
      IMessage msg=new Message(""String_Node_Str"" + filename + ""String_Node_Str""+ fnfe.getMessage(),IMessage.ERROR,null,new SourceLocation(srcLocation,0));
      handler.handleMessage(msg);
    }
  }
  state.recordResource(filename);
}",0.8274839347503707
9267,"public void afterCompiling(CompilationUnitDeclaration[] units){
  this.eWorld.cleanup();
  try {
    if (isXTerminateAfterCompilation || (reportedErrors && !proceedOnError)) {
      notifyRequestor();
    }
 else {
      weave();
      weaver.getWorld().flush();
    }
  }
 catch (  IOException ex) {
    AbortCompilation ac=new AbortCompilation(null,ex);
    throw ac;
  }
catch (  RuntimeException rEx) {
    if (rEx instanceof AbortCompilation)     throw rEx;
    throw new AbortCompilation(true,rEx);
  }
}","public void afterCompiling(CompilationUnitDeclaration[] units){
  this.eWorld.cleanup();
  try {
    if (!reportedErrors && units != null) {
      for (int i=0; i < units.length; i++) {
        if (units[i] != null && units[i].compilationResult != null && units[i].compilationResult.hasErrors()) {
          reportedErrors=true;
          break;
        }
      }
    }
    if (isXTerminateAfterCompilation || (reportedErrors && !proceedOnError)) {
      notifyRequestor();
    }
 else {
      weave();
      weaver.getWorld().flush();
    }
  }
 catch (  IOException ex) {
    AbortCompilation ac=new AbortCompilation(null,ex);
    throw ac;
  }
catch (  RuntimeException rEx) {
    if (rEx instanceof AbortCompilation)     throw rEx;
    throw new AbortCompilation(true,rEx);
  }
}",0.7888631090487239
9268,"/** 
 * Checks that concrete aspect is valid
 * @return true if ok, false otherwise
 */
public boolean validate(){
  if (!(m_world instanceof BcelWorld)) {
    reportError(""String_Node_Str"");
    return false;
  }
  ResolvedType current=m_world.resolve(m_concreteAspect.name,true);
  if (!current.isMissing()) {
    reportError(""String_Node_Str"" + stringify());
    return false;
  }
  if (m_concreteAspect.extend == null && m_concreteAspect.precedence != null) {
    if (m_concreteAspect.pointcuts.isEmpty()) {
      m_isValid=true;
      m_perClause=new PerSingleton();
      m_parent=null;
      return true;
    }
 else {
      reportError(""String_Node_Str"" + stringify());
      return false;
    }
  }
  m_parent=m_world.resolve(m_concreteAspect.extend,true);
  if (m_parent.isMissing()) {
    String fixedName=m_concreteAspect.extend;
    int hasDot=fixedName.lastIndexOf('.');
    while (hasDot > 0) {
      char[] fixedNameChars=fixedName.toCharArray();
      fixedNameChars[hasDot]='$';
      fixedName=new String(fixedNameChars);
      hasDot=fixedName.lastIndexOf('.');
      m_parent=m_world.resolve(UnresolvedType.forName(fixedName),true);
      if (!m_parent.isMissing()) {
        break;
      }
    }
  }
  if (m_parent.isMissing()) {
    reportError(""String_Node_Str"" + stringify());
    return false;
  }
  if (!m_parent.isAbstract()) {
    reportError(""String_Node_Str"" + stringify());
    return false;
  }
  if (!m_parent.isAspect()) {
    reportError(""String_Node_Str"" + stringify());
    return false;
  }
  List elligibleAbstractions=new ArrayList();
  Iterator methods=m_parent.getMethods();
  while (methods.hasNext()) {
    ResolvedMember method=(ResolvedMember)methods.next();
    if (method.isAbstract()) {
      if (""String_Node_Str"".equals(method.getSignature())) {
        elligibleAbstractions.add(method.getName());
      }
 else {
        reportError(""String_Node_Str"" + method.getName() + ""String_Node_Str""+ stringify());
        return false;
      }
    }
  }
  List pointcutNames=new ArrayList();
  for (Iterator it=m_concreteAspect.pointcuts.iterator(); it.hasNext(); ) {
    Definition.Pointcut abstractPc=(Definition.Pointcut)it.next();
    pointcutNames.add(abstractPc.name);
  }
  for (Iterator it=elligibleAbstractions.iterator(); it.hasNext(); ) {
    String elligiblePc=(String)it.next();
    if (!pointcutNames.contains(elligiblePc)) {
      reportError(""String_Node_Str"" + elligiblePc + ""String_Node_Str""+ stringify());
      return false;
    }
  }
  m_perClause=m_parent.getPerClause();
  m_isValid=true;
  return m_isValid;
}","/** 
 * Checks that concrete aspect is valid
 * @return true if ok, false otherwise
 */
public boolean validate(){
  if (!(m_world instanceof BcelWorld)) {
    reportError(""String_Node_Str"");
    return false;
  }
  ResolvedType current=m_world.resolve(m_concreteAspect.name,true);
  if (!current.isMissing()) {
    reportError(""String_Node_Str"" + stringify());
    return false;
  }
  if (m_concreteAspect.extend == null && m_concreteAspect.precedence != null) {
    if (m_concreteAspect.pointcuts.isEmpty()) {
      m_isValid=true;
      m_perClause=new PerSingleton();
      m_parent=null;
      return true;
    }
 else {
      reportError(""String_Node_Str"" + stringify());
      return false;
    }
  }
  m_parent=m_world.resolve(m_concreteAspect.extend,true);
  if (m_parent.isMissing()) {
    String fixedName=m_concreteAspect.extend;
    int hasDot=fixedName.lastIndexOf('.');
    while (hasDot > 0) {
      char[] fixedNameChars=fixedName.toCharArray();
      fixedNameChars[hasDot]='$';
      fixedName=new String(fixedNameChars);
      hasDot=fixedName.lastIndexOf('.');
      m_parent=m_world.resolve(UnresolvedType.forName(fixedName),true);
      if (!m_parent.isMissing()) {
        break;
      }
    }
  }
  if (m_parent.isMissing()) {
    reportError(""String_Node_Str"" + stringify());
    return false;
  }
  if (!m_parent.isAbstract()) {
    reportError(""String_Node_Str"" + stringify());
    return false;
  }
  if (!m_parent.isAspect()) {
    reportError(""String_Node_Str"" + stringify());
    return false;
  }
  List elligibleAbstractions=new ArrayList();
  Iterator methods=m_parent.getMethods();
  while (methods.hasNext()) {
    ResolvedMember method=(ResolvedMember)methods.next();
    if (method.isAbstract()) {
      if (""String_Node_Str"".equals(method.getSignature())) {
        String n=method.getName();
        if (n.startsWith(""String_Node_Str"")) {
          n=n.substring(14);
          n=n.substring(0,n.indexOf(""String_Node_Str""));
          elligibleAbstractions.add(n);
        }
 else {
          elligibleAbstractions.add(method.getName());
        }
      }
 else {
        reportError(""String_Node_Str"" + method.getName() + ""String_Node_Str""+ stringify());
        return false;
      }
    }
  }
  List pointcutNames=new ArrayList();
  for (Iterator it=m_concreteAspect.pointcuts.iterator(); it.hasNext(); ) {
    Definition.Pointcut abstractPc=(Definition.Pointcut)it.next();
    pointcutNames.add(abstractPc.name);
  }
  for (Iterator it=elligibleAbstractions.iterator(); it.hasNext(); ) {
    String elligiblePc=(String)it.next();
    if (!pointcutNames.contains(elligiblePc)) {
      reportError(""String_Node_Str"" + elligiblePc + ""String_Node_Str""+ stringify());
      return false;
    }
  }
  m_perClause=m_parent.getPerClause();
  m_isValid=true;
  return m_isValid;
}",0.9558769002595476
9269,"/** 
 * init only on initial batch compile? no file-specific options 
 */
private void initBcelWorld(IMessageHandler handler) throws IOException {
  List cp=buildConfig.getBootclasspath();
  cp.addAll(buildConfig.getClasspath());
  BcelWorld bcelWorld=new BcelWorld(cp,handler,null);
  bcelWorld.setBehaveInJava5Way(buildConfig.getBehaveInJava5Way());
  bcelWorld.setTargetAspectjRuntimeLevel(buildConfig.getTargetAspectjRuntimeLevel());
  bcelWorld.setOptionalJoinpoints(buildConfig.getXJoinpoints());
  bcelWorld.setXnoInline(buildConfig.isXnoInline());
  bcelWorld.setXlazyTjp(buildConfig.isXlazyTjp());
  bcelWorld.setXHasMemberSupportEnabled(buildConfig.isXHasMemberEnabled());
  bcelWorld.setPinpointMode(buildConfig.isXdevPinpoint());
  BcelWeaver bcelWeaver=new BcelWeaver(bcelWorld);
  state.setWorld(bcelWorld);
  state.setWeaver(bcelWeaver);
  state.binarySourceFiles=new HashMap();
  for (Iterator i=buildConfig.getAspectpath().iterator(); i.hasNext(); ) {
    File f=(File)i.next();
    bcelWeaver.addLibraryJarFile(f);
  }
  if (buildConfig.getLintMode().equals(AjBuildConfig.AJLINT_DEFAULT)) {
    bcelWorld.getLint().loadDefaultProperties();
  }
 else {
    bcelWorld.getLint().setAll(buildConfig.getLintMode());
  }
  if (buildConfig.getLintSpecFile() != null) {
    bcelWorld.getLint().setFromProperties(buildConfig.getLintSpecFile());
  }
  for (Iterator i=buildConfig.getInJars().iterator(); i.hasNext(); ) {
    File inJar=(File)i.next();
    List unwovenClasses=bcelWeaver.addJarFile(inJar,buildConfig.getOutputDir(),false);
    state.binarySourceFiles.put(inJar.getPath(),unwovenClasses);
  }
  for (Iterator i=buildConfig.getInpath().iterator(); i.hasNext(); ) {
    File inPathElement=(File)i.next();
    if (!inPathElement.isDirectory()) {
      List unwovenClasses=bcelWeaver.addJarFile(inPathElement,buildConfig.getOutputDir(),true);
      state.binarySourceFiles.put(inPathElement.getPath(),unwovenClasses);
    }
 else {
      File[] binSrcs=FileUtil.listFiles(inPathElement,binarySourceFilter);
      for (int j=0; j < binSrcs.length; j++) {
        UnwovenClassFile ucf=bcelWeaver.addClassFile(binSrcs[j],inPathElement,buildConfig.getOutputDir());
        List ucfl=new ArrayList();
        ucfl.add(ucf);
        state.binarySourceFiles.put(binSrcs[j].getPath(),ucfl);
      }
    }
  }
  bcelWeaver.setReweavableMode(buildConfig.isXNotReweavable());
  ResolvedType joinPoint=bcelWorld.resolve(""String_Node_Str"");
  if (joinPoint.isMissing()) {
    IMessage message=new Message(""String_Node_Str"",null,true);
    handler.handleMessage(message);
  }
}","/** 
 * init only on initial batch compile? no file-specific options 
 */
private void initBcelWorld(IMessageHandler handler) throws IOException {
  List cp=buildConfig.getBootclasspath();
  cp.addAll(buildConfig.getClasspath());
  BcelWorld bcelWorld=new BcelWorld(cp,handler,null);
  bcelWorld.setBehaveInJava5Way(buildConfig.getBehaveInJava5Way());
  bcelWorld.setTargetAspectjRuntimeLevel(buildConfig.getTargetAspectjRuntimeLevel());
  bcelWorld.setOptionalJoinpoints(buildConfig.getXJoinpoints());
  bcelWorld.setXnoInline(buildConfig.isXnoInline());
  bcelWorld.setXlazyTjp(buildConfig.isXlazyTjp());
  bcelWorld.setXHasMemberSupportEnabled(buildConfig.isXHasMemberEnabled());
  bcelWorld.setPinpointMode(buildConfig.isXdevPinpoint());
  BcelWeaver bcelWeaver=new BcelWeaver(bcelWorld);
  state.setWorld(bcelWorld);
  state.setWeaver(bcelWeaver);
  state.binarySourceFiles=new HashMap();
  for (Iterator i=buildConfig.getAspectpath().iterator(); i.hasNext(); ) {
    File f=(File)i.next();
    if (!f.exists()) {
      IMessage message=new Message(""String_Node_Str"" + f.getName(),null,true);
      handler.handleMessage(message);
    }
 else {
      bcelWeaver.addLibraryJarFile(f);
    }
  }
  if (buildConfig.getLintMode().equals(AjBuildConfig.AJLINT_DEFAULT)) {
    bcelWorld.getLint().loadDefaultProperties();
  }
 else {
    bcelWorld.getLint().setAll(buildConfig.getLintMode());
  }
  if (buildConfig.getLintSpecFile() != null) {
    bcelWorld.getLint().setFromProperties(buildConfig.getLintSpecFile());
  }
  for (Iterator i=buildConfig.getInJars().iterator(); i.hasNext(); ) {
    File inJar=(File)i.next();
    List unwovenClasses=bcelWeaver.addJarFile(inJar,buildConfig.getOutputDir(),false);
    state.binarySourceFiles.put(inJar.getPath(),unwovenClasses);
  }
  for (Iterator i=buildConfig.getInpath().iterator(); i.hasNext(); ) {
    File inPathElement=(File)i.next();
    if (!inPathElement.isDirectory()) {
      List unwovenClasses=bcelWeaver.addJarFile(inPathElement,buildConfig.getOutputDir(),true);
      state.binarySourceFiles.put(inPathElement.getPath(),unwovenClasses);
    }
 else {
      File[] binSrcs=FileUtil.listFiles(inPathElement,binarySourceFilter);
      for (int j=0; j < binSrcs.length; j++) {
        UnwovenClassFile ucf=bcelWeaver.addClassFile(binSrcs[j],inPathElement,buildConfig.getOutputDir());
        List ucfl=new ArrayList();
        ucfl.add(ucf);
        state.binarySourceFiles.put(binSrcs[j].getPath(),ucfl);
      }
    }
  }
  bcelWeaver.setReweavableMode(buildConfig.isXNotReweavable());
  ResolvedType joinPoint=bcelWorld.resolve(""String_Node_Str"");
  if (joinPoint.isMissing()) {
    IMessage message=new Message(""String_Node_Str"",null,true);
    handler.handleMessage(message);
  }
}",0.9695831768681936
9270,"protected void setUp() throws Exception {
  super.setUp();
  MyStateListener.reset();
  MyBuildProgressMonitor.reset();
  MyTaskListManager.reset();
  createEmptySandbox();
}","protected void setUp() throws Exception {
  super.setUp();
  MyStateListener.reset();
  MyBuildProgressMonitor.reset();
  MyTaskListManager.reset();
  MyProjectPropertiesAdapter.reset();
  createEmptySandbox();
}",0.9015544041450776
9271,"public Set getAspectPath(){
  log(""String_Node_Str"");
  return null;
}","public Set getAspectPath(){
  log(""String_Node_Str"" + aspectPath + ""String_Node_Str"");
  return aspectPath;
}",0.7374301675977654
9272,"/** 
 * Generate the ""public int""-type information about the given IProgramElement. Used when dealing with ITDs. To mirror the behaviour of methods and fields in classes, if we're generating the summary information we don't want to  include ""public"" if the accessibility of the IProgramElement is public. 
 */
private static String generateModifierInformation(IProgramElement decl,boolean isDetails){
  String intro=""String_Node_Str"";
  if (isDetails || !decl.getAccessibility().equals(IProgramElement.Accessibility.PUBLIC)) {
    intro+=""String_Node_Str"" + decl.getAccessibility().toString() + ""String_Node_Str"";
  }
  if (decl.getKind().equals(IProgramElement.Kind.INTER_TYPE_FIELD)) {
    return intro + decl.getCorrespondingType() + ""String_Node_Str"";
  }
 else   if (decl.getKind().equals(IProgramElement.Kind.INTER_TYPE_CONSTRUCTOR) && isDetails) {
    return intro + ""String_Node_Str"";
  }
 else {
    return intro + decl.getCorrespondingType(true) + ""String_Node_Str"";
  }
}","/** 
 * Generate the ""public int""-type information about the given IProgramElement. Used when dealing with ITDs. To mirror the behaviour of methods and fields in classes, if we're generating the summary information we don't want to  include ""public"" if the accessibility of the IProgramElement is public. 
 */
private static String generateModifierInformation(IProgramElement decl,boolean isDetails){
  String intro=""String_Node_Str"";
  if (decl.getKind().isDeclare()) {
    return intro + ""String_Node_Str"";
  }
  if (isDetails || !decl.getAccessibility().equals(IProgramElement.Accessibility.PUBLIC)) {
    intro+=""String_Node_Str"" + decl.getAccessibility().toString() + ""String_Node_Str"";
  }
  if (decl.getKind().equals(IProgramElement.Kind.INTER_TYPE_FIELD)) {
    return intro + decl.getCorrespondingType() + ""String_Node_Str"";
  }
 else   if (decl.getKind().equals(IProgramElement.Kind.INTER_TYPE_CONSTRUCTOR) && isDetails) {
    return intro + ""String_Node_Str"";
  }
 else {
    return intro + decl.getCorrespondingType(true) + ""String_Node_Str"";
  }
}",0.9618021547502448
9273,"private static void processMembers(List members,PrintWriter writer,boolean declaringTypeIsInterface) throws DocException {
  for (Iterator it=members.iterator(); it.hasNext(); ) {
    IProgramElement member=(IProgramElement)it.next();
    if (member.getKind().isType()) {
      if (!member.getParent().getKind().equals(IProgramElement.Kind.METHOD) && !StructureUtil.isAnonymous(member)) {
        processTypeDeclaration(member,writer);
      }
    }
 else {
      String formalComment=addDeclID(member,member.getFormalComment());
      ;
      writer.println(formalComment);
      String signature=""String_Node_Str"";
      if (!member.getKind().equals(IProgramElement.Kind.POINTCUT) && !member.getKind().equals(IProgramElement.Kind.ADVICE)) {
        signature=member.getSourceSignature();
        if (member.getKind().equals(IProgramElement.Kind.ENUM_VALUE)) {
          if (((IProgramElement)members.get(members.indexOf(member) + 1)).getKind().equals(IProgramElement.Kind.ENUM_VALUE)) {
            signature=signature + ""String_Node_Str"";
          }
 else {
            signature=signature + ""String_Node_Str"";
          }
        }
      }
      if (member.getKind().isDeclare()) {
      }
 else       if (signature != null && signature != ""String_Node_Str"" && !member.getKind().isInterTypeMember() && !member.getKind().equals(IProgramElement.Kind.INITIALIZER) && !StructureUtil.isAnonymous(member)) {
        writer.print(signature);
      }
 else {
      }
      if (member.getKind().equals(IProgramElement.Kind.METHOD) || member.getKind().equals(IProgramElement.Kind.CONSTRUCTOR)) {
        if (member.getParent().getKind().equals(IProgramElement.Kind.INTERFACE) || signature.indexOf(""String_Node_Str"") != -1) {
          writer.println(""String_Node_Str"");
        }
 else {
          writer.println(""String_Node_Str"");
        }
      }
 else       if (member.getKind().equals(IProgramElement.Kind.FIELD)) {
      }
    }
  }
}","private static void processMembers(List members,PrintWriter writer,boolean declaringTypeIsInterface) throws DocException {
  for (Iterator it=members.iterator(); it.hasNext(); ) {
    IProgramElement member=(IProgramElement)it.next();
    if (member.getKind().isType()) {
      if (!member.getParent().getKind().equals(IProgramElement.Kind.METHOD) && !StructureUtil.isAnonymous(member)) {
        processTypeDeclaration(member,writer);
      }
    }
 else {
      String formalComment=addDeclID(member,member.getFormalComment());
      ;
      writer.println(formalComment);
      String signature=""String_Node_Str"";
      if (!member.getKind().equals(IProgramElement.Kind.POINTCUT) && !member.getKind().equals(IProgramElement.Kind.ADVICE)) {
        signature=member.getSourceSignature();
        if (member.getKind().equals(IProgramElement.Kind.ENUM_VALUE)) {
          int index=members.indexOf(member);
          if ((index + 1 < members.size()) && ((IProgramElement)members.get(index + 1)).getKind().equals(IProgramElement.Kind.ENUM_VALUE)) {
            signature=signature + ""String_Node_Str"";
          }
 else {
            signature=signature + ""String_Node_Str"";
          }
        }
      }
      if (member.getKind().isDeclare()) {
      }
 else       if (signature != null && signature != ""String_Node_Str"" && !member.getKind().isInterTypeMember() && !member.getKind().equals(IProgramElement.Kind.INITIALIZER) && !StructureUtil.isAnonymous(member)) {
        writer.print(signature);
      }
 else {
      }
      if (member.getKind().equals(IProgramElement.Kind.METHOD) || member.getKind().equals(IProgramElement.Kind.CONSTRUCTOR)) {
        if (member.getParent().getKind().equals(IProgramElement.Kind.INTERFACE) || signature.indexOf(""String_Node_Str"") != -1) {
          writer.println(""String_Node_Str"");
        }
 else {
          writer.println(""String_Node_Str"");
        }
      }
 else       if (member.getKind().equals(IProgramElement.Kind.FIELD)) {
      }
    }
  }
}",0.968201475451539
9274,"public static Test suite(){
  TestSuite suite=new TestSuite(AjdocTests.class.getName());
  suite.addTestSuite(DeclareFormsTest.class);
  suite.addTestSuite(SpacewarTestCase.class);
  suite.addTestSuite(PatternsTestCase.class);
  suite.addTestSuite(CoverageTestCase.class);
  suite.addTestSuite(ITDTest.class);
  suite.addTestSuite(FullyQualifiedArgumentTest.class);
  suite.addTestSuite(ExecutionTestCase.class);
  return suite;
}","public static Test suite(){
  TestSuite suite=new TestSuite(AjdocTests.class.getName());
  suite.addTestSuite(DeclareFormsTest.class);
  suite.addTestSuite(SpacewarTestCase.class);
  suite.addTestSuite(PatternsTestCase.class);
  suite.addTestSuite(CoverageTestCase.class);
  suite.addTestSuite(ITDTest.class);
  suite.addTestSuite(FullyQualifiedArgumentTest.class);
  suite.addTestSuite(EnumTest.class);
  suite.addTestSuite(ExecutionTestCase.class);
  return suite;
}",0.9576837416481068
9275,"protected boolean accept(String className,byte[] bytes){
  if (m_excludeTypePattern.isEmpty() && m_includeTypePattern.isEmpty()) {
    return true;
  }
  String fastClassName=className.replace('/','.').replace('$','.');
  for (int i=0; i < m_excludeStartsWith.size(); i++) {
    if (fastClassName.startsWith((String)m_excludeStartsWith.get(i))) {
      return false;
    }
  }
  boolean fastAccept=false;
  for (int i=0; i < m_includeStartsWith.size(); i++) {
    fastAccept=fastClassName.startsWith((String)m_includeStartsWith.get(i));
    if (fastAccept) {
      break;
    }
  }
  if (fastAccept) {
    return true;
  }
  BcelObjectType bct=((BcelWorld)weaver.getWorld()).addSourceObjectType(Utility.makeJavaClass(null,bytes));
  ResolvedType classInfo=bct.getResolvedTypeX();
  for (Iterator iterator=m_excludeTypePattern.iterator(); iterator.hasNext(); ) {
    TypePattern typePattern=(TypePattern)iterator.next();
    if (typePattern.matchesStatically(classInfo)) {
      return false;
    }
  }
  boolean accept=true;
  for (Iterator iterator=m_includeTypePattern.iterator(); iterator.hasNext(); ) {
    TypePattern typePattern=(TypePattern)iterator.next();
    accept=typePattern.matchesStatically(classInfo);
    if (accept) {
      break;
    }
  }
  return accept;
}","protected boolean accept(String className,byte[] bytes){
  if (m_excludeTypePattern.isEmpty() && m_includeTypePattern.isEmpty()) {
    return true;
  }
  String fastClassName=className.replace('/','.').replace('$','.');
  for (int i=0; i < m_excludeStartsWith.size(); i++) {
    if (fastClassName.startsWith((String)m_excludeStartsWith.get(i))) {
      return false;
    }
  }
  if (m_excludeTypePattern.isEmpty()) {
    boolean fastAccept=false;
    for (int i=0; i < m_includeStartsWith.size(); i++) {
      fastAccept=fastClassName.startsWith((String)m_includeStartsWith.get(i));
      if (fastAccept) {
        break;
      }
    }
  }
  BcelObjectType bct=((BcelWorld)weaver.getWorld()).addSourceObjectType(Utility.makeJavaClass(null,bytes));
  ResolvedType classInfo=bct.getResolvedTypeX();
  for (Iterator iterator=m_excludeTypePattern.iterator(); iterator.hasNext(); ) {
    TypePattern typePattern=(TypePattern)iterator.next();
    if (typePattern.matchesStatically(classInfo)) {
      return false;
    }
  }
  boolean accept=true;
  for (Iterator iterator=m_includeTypePattern.iterator(); iterator.hasNext(); ) {
    TypePattern typePattern=(TypePattern)iterator.next();
    accept=typePattern.matchesStatically(classInfo);
    if (accept) {
      break;
    }
  }
  return accept;
}",0.9646052119797744
9276,"/** 
 * Return a version of this parameterized type in which any type parameters that are type variable references are replaced by their matching type variable binding.
 */
public UnresolvedType parameterize(Map typeBindings){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","/** 
 * Return a version of this parameterized type in which any type parameters that are type variable references are replaced by their matching type variable binding.
 */
public UnresolvedType parameterize(Map typeBindings){
  throw new UnsupportedOperationException(""String_Node_Str"" + signature);
}",0.9797297297297296
9277,"/** 
 * Install global values into local config unless values conflict: <ul> <li>Collections are unioned</li> <li>values takes local value unless default and global set</li> <li>this only sets one of outputDir and outputJar as needed</li> <ul> This also configures super if javaOptions change.
 * @param global the AjBuildConfig to read globals from
 */
public void installGlobals(AjBuildConfig global){
  join(aspectpath,global.aspectpath);
  join(classpath,global.classpath);
  if (null == configFile) {
    configFile=global.configFile;
  }
  if (!isEmacsSymMode() && global.isEmacsSymMode()) {
    setEmacsSymMode(true);
  }
  join(files,global.files);
  if (!isGenerateModelMode() && global.isGenerateModelMode()) {
    setGenerateModelMode(true);
  }
  if (null == incrementalFile) {
    incrementalFile=global.incrementalFile;
  }
  if (!incrementalMode && global.incrementalMode) {
    incrementalMode=true;
  }
  join(inJars,global.inJars);
  join(inPath,global.inPath);
  if ((null == lintMode) || (AJLINT_DEFAULT.equals(lintMode))) {
    setLintMode(global.lintMode);
  }
  if (null == lintSpecFile) {
    lintSpecFile=global.lintSpecFile;
  }
  if (!isNoWeave() && global.isNoWeave()) {
    setNoWeave(true);
  }
  if ((null == outputDir) && (null == outputJar)) {
    if (null != global.outputDir) {
      outputDir=global.outputDir;
    }
    if (null != global.outputJar) {
      outputJar=global.outputJar;
    }
  }
  join(sourceRoots,global.sourceRoots);
  if (!isXnoInline() && global.isXnoInline()) {
    setXnoInline(true);
  }
  if (!isXserializableAspects() && global.isXserializableAspects()) {
    setXserializableAspects(true);
  }
  if (!isXlazyTjp() && global.isXlazyTjp()) {
    setXlazyTjp(true);
  }
  if (!isXHasMemberEnabled() && global.isXHasMemberEnabled()) {
    setXHasMemberSupport(true);
  }
  if (!isXNotReweavable() && global.isXNotReweavable()) {
    setXnotReweavable(true);
  }
}","/** 
 * Install global values into local config unless values conflict: <ul> <li>Collections are unioned</li> <li>values takes local value unless default and global set</li> <li>this only sets one of outputDir and outputJar as needed</li> <ul> This also configures super if javaOptions change.
 * @param global the AjBuildConfig to read globals from
 */
public void installGlobals(AjBuildConfig global){
  join(aspectpath,global.aspectpath);
  join(classpath,global.classpath);
  if (null == configFile) {
    configFile=global.configFile;
  }
  if (!isEmacsSymMode() && global.isEmacsSymMode()) {
    setEmacsSymMode(true);
  }
  join(files,global.files);
  if (!isGenerateModelMode() && global.isGenerateModelMode()) {
    setGenerateModelMode(true);
  }
  if (null == incrementalFile) {
    incrementalFile=global.incrementalFile;
  }
  if (!incrementalMode && global.incrementalMode) {
    incrementalMode=true;
  }
  join(inJars,global.inJars);
  join(inPath,global.inPath);
  if ((null == lintMode) || (AJLINT_DEFAULT.equals(lintMode))) {
    setLintMode(global.lintMode);
  }
  if (null == lintSpecFile) {
    lintSpecFile=global.lintSpecFile;
  }
  if (!isNoWeave() && global.isNoWeave()) {
    setNoWeave(true);
  }
  if ((null == outputDir) && (null == outputJar)) {
    if (null != global.outputDir) {
      outputDir=global.outputDir;
    }
    if (null != global.outputJar) {
      outputJar=global.outputJar;
    }
  }
  join(sourceRoots,global.sourceRoots);
  if (!isXnoInline() && global.isXnoInline()) {
    setXnoInline(true);
  }
  if (!isXserializableAspects() && global.isXserializableAspects()) {
    setXserializableAspects(true);
  }
  if (!isXlazyTjp() && global.isXlazyTjp()) {
    setXlazyTjp(true);
  }
  if (!getProceedOnError() && global.getProceedOnError()) {
    setProceedOnError(true);
  }
  setTargetAspectjRuntimeLevel(global.getTargetAspectjRuntimeLevel());
  if (!isXHasMemberEnabled() && global.isXHasMemberEnabled()) {
    setXHasMemberSupport(true);
  }
  if (!isXNotReweavable() && global.isXNotReweavable()) {
    setXnotReweavable(true);
  }
}",0.9591022443890276
9278,"public String getNonStandardOptions(){
  return null;
}","public String getNonStandardOptions(){
  return nonstandardoptions;
}",0.8387096774193549
9279,"/** 
 * For a long time, AspectJ did not allow binary weaving of declare parents.  This restriction is now lifted but could do with more testing!
 */
private boolean mungeNewParent(BcelClassWeaver weaver,NewParentTypeMunger munger){
  LazyClassGen newParentTarget=weaver.getLazyClassGen();
  ResolvedType newParent=munger.getNewParent();
  boolean cont=true;
  cont=enforceDecpRule1_abstractMethodsImplemented(weaver,munger.getSourceLocation(),newParentTarget,newParent);
  cont=enforceDecpRule2_cantExtendFinalClass(weaver,munger.getSourceLocation(),newParentTarget,newParent) && cont;
  List methods=newParent.getMethodsWithoutIterator(false,true);
  for (Iterator iter=methods.iterator(); iter.hasNext(); ) {
    ResolvedMember superMethod=(ResolvedMember)iter.next();
    if (!superMethod.getName().equals(""String_Node_Str"")) {
      LazyMethodGen subMethod=findMatchingMethod(newParentTarget,superMethod);
      if (subMethod != null) {
        cont=enforceDecpRule3_visibilityChanges(weaver,newParent,superMethod,subMethod) && cont;
        cont=enforceDecpRule4_compatibleReturnTypes(weaver,superMethod,subMethod) && cont;
        cont=enforceDecpRule5_cantChangeFromStaticToNonstatic(weaver,munger.getSourceLocation(),superMethod,subMethod) && cont;
      }
    }
  }
  if (!cont)   return false;
  if (newParent.isClass()) {
    if (!attemptToModifySuperCalls(weaver,newParentTarget,newParent))     return false;
    newParentTarget.setSuperClass(newParent);
  }
 else {
    newParentTarget.addInterface(newParent,getSourceLocation());
  }
  return true;
}","/** 
 * For a long time, AspectJ did not allow binary weaving of declare parents.  This restriction is now lifted but could do with more testing!
 */
private boolean mungeNewParent(BcelClassWeaver weaver,NewParentTypeMunger munger){
  LazyClassGen newParentTarget=weaver.getLazyClassGen();
  ResolvedType newParent=munger.getNewParent();
  boolean cont=true;
  cont=enforceDecpRule1_abstractMethodsImplemented(weaver,munger.getSourceLocation(),newParentTarget,newParent);
  cont=enforceDecpRule2_cantExtendFinalClass(weaver,munger.getSourceLocation(),newParentTarget,newParent) && cont;
  List methods=newParent.getMethodsWithoutIterator(false,true);
  for (Iterator iter=methods.iterator(); iter.hasNext(); ) {
    ResolvedMember superMethod=(ResolvedMember)iter.next();
    if (!superMethod.getName().equals(""String_Node_Str"")) {
      LazyMethodGen subMethod=findMatchingMethod(newParentTarget,superMethod);
      if (subMethod != null && !subMethod.isBridgeMethod()) {
        cont=enforceDecpRule3_visibilityChanges(weaver,newParent,superMethod,subMethod) && cont;
        cont=enforceDecpRule4_compatibleReturnTypes(weaver,superMethod,subMethod) && cont;
        cont=enforceDecpRule5_cantChangeFromStaticToNonstatic(weaver,munger.getSourceLocation(),superMethod,subMethod) && cont;
      }
    }
  }
  if (!cont)   return false;
  if (newParent.isClass()) {
    if (!attemptToModifySuperCalls(weaver,newParentTarget,newParent))     return false;
    newParentTarget.setSuperClass(newParent);
  }
 else {
    newParentTarget.addInterface(newParent,getSourceLocation());
  }
  return true;
}",0.9901929769060424
9280,"void accept0(ASTVisitor visitor){
  AjASTVisitor ajvis=(AjASTVisitor)visitor;
  boolean visitChildren=ajvis.visit(this);
  if (visitChildren) {
    acceptChild(ajvis,getJavadoc());
    if (this.ast.apiLevel == AST.JLS2_INTERNAL) {
      acceptChild(ajvis,getReturnType());
    }
 else {
      acceptChildren(ajvis,this.modifiers);
      acceptChildren(ajvis,(NodeList)this.typeParameters());
      acceptChild(ajvis,getReturnType2());
    }
    acceptChild(ajvis,getName());
    acceptChildren(ajvis,this.parameters);
    acceptChildren(ajvis,(NodeList)this.thrownExceptions());
    acceptChild(ajvis,getBody());
  }
  ajvis.endVisit(this);
}","void accept0(ASTVisitor ajvis){
  boolean visitChildren=ajvis.visit(this);
  if (visitChildren) {
    acceptChild(ajvis,getJavadoc());
    if (this.ast.apiLevel == AST.JLS2_INTERNAL) {
      acceptChild(ajvis,getReturnType());
    }
 else {
      acceptChildren(ajvis,this.modifiers);
      acceptChildren(ajvis,(NodeList)this.typeParameters());
      acceptChild(ajvis,getReturnType2());
    }
    acceptChild(ajvis,getName());
    acceptChildren(ajvis,this.parameters);
    acceptChildren(ajvis,(NodeList)this.thrownExceptions());
    acceptChild(ajvis,getBody());
  }
  ajvis.endVisit(this);
}",0.9547657512116317
9281,"/** 
 * Read arguments in as if from a command line,  mainly to support compiler adapter compilerarg subelement. 
 * @param args the String[] of arguments to read
 */
public void readArguments(String[] args){
  if ((null == args) || (0 == args.length)) {
    return;
  }
  /** 
 * String[] wrapper with increment, error reporting 
 */
class Args {
    final String[] args;
    int index=0;
    Args(    String[] args){
      this.args=args;
    }
    boolean hasNext(){
      return index < args.length;
    }
    String next(){
      String err=null;
      if (!hasNext()) {
        err=""String_Node_Str"" + args[args.length - 1];
      }
 else {
        String s=args[index++];
        if (null == s) {
          err=""String_Node_Str"";
        }
 else {
          s=s.trim();
          if (0 == s.trim().length()) {
            err=""String_Node_Str"";
          }
 else {
            return s;
          }
        }
      }
      err+=""String_Node_Str"" + index + ""String_Node_Str""+ Arrays.asList(args);
      throw new BuildException(err);
    }
  }
  Args in=new Args(args);
  String flag;
  while (in.hasNext()) {
    flag=in.next();
    if (""String_Node_Str"".equals(flag)) {
      setCompliance(flag);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setCompliance(flag);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setCompliance(""String_Node_Str"");
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setArgfiles(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setAspectpath(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setClasspath(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setExtdirs(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setCopyInjars(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setDebug(true);
    }
 else     if (flag.startsWith(""String_Node_Str"")) {
      setDebugLevel(flag.substring(2));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setDeprecation(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setDestdir(new File(in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setEmacssym(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setEncoding(in.next());
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setFailonerror(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setFork(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setForkclasspath(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setHelp(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setIncremental(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setInjars(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setInpath(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setListFileArgs(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setMaxmem(in.next());
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setMessageHolderClass(in.next());
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setNoExit(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setNoExit(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setNoExit(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setNoImportError(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setNowarn(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setNoExit(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setOutjar(new File(in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setPreserveAllLocals(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setProceedOnError(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setReferenceInfo(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setSource(in.next());
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setSourceRootCopyFilter(in.next());
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setSourceRoots(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setSrcDir(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setTagFile(new File(in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setTarget(in.next());
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setTime(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setTime(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setVerbose(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setShowWeaveInfo(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setVersion(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setWarn(in.next());
    }
 else     if (flag.startsWith(""String_Node_Str"")) {
      setWarn(flag.substring(6));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setXlintwarnings(true);
    }
 else     if (flag.startsWith(""String_Node_Str"")) {
      setXlint(flag.substring(7));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setXlintfile(new File(in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setXNoweave(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setXReweavable(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setXNotReweavable(true);
    }
 else     if (flag.startsWith(""String_Node_Str"")) {
      File file=new File(flag.substring(1));
      if (file.canRead()) {
        setArgfiles(new Path(project,file.getPath()));
      }
 else {
        ignore(flag);
      }
    }
 else {
      File file=new File(flag);
      if (file.isFile() && file.canRead() && FileUtil.hasSourceSuffix(file)) {
        addFile(file);
      }
 else {
        ignore(flag);
      }
    }
  }
}","/** 
 * Read arguments in as if from a command line,  mainly to support compiler adapter compilerarg subelement. 
 * @param args the String[] of arguments to read
 */
public void readArguments(String[] args){
  if ((null == args) || (0 == args.length)) {
    return;
  }
  /** 
 * String[] wrapper with increment, error reporting 
 */
class Args {
    final String[] args;
    int index=0;
    Args(    String[] args){
      this.args=args;
    }
    boolean hasNext(){
      return index < args.length;
    }
    String next(){
      String err=null;
      if (!hasNext()) {
        err=""String_Node_Str"" + args[args.length - 1];
      }
 else {
        String s=args[index++];
        if (null == s) {
          err=""String_Node_Str"";
        }
 else {
          s=s.trim();
          if (0 == s.trim().length()) {
            err=""String_Node_Str"";
          }
 else {
            return s;
          }
        }
      }
      err+=""String_Node_Str"" + index + ""String_Node_Str""+ Arrays.asList(args);
      throw new BuildException(err);
    }
  }
  Args in=new Args(args);
  String flag;
  while (in.hasNext()) {
    flag=in.next();
    if (""String_Node_Str"".equals(flag)) {
      setCompliance(flag);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setCompliance(flag);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setCompliance(""String_Node_Str"");
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setArgfiles(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setAspectpath(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setClasspath(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setExtdirs(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setCopyInjars(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setDebug(true);
    }
 else     if (flag.startsWith(""String_Node_Str"")) {
      setDebugLevel(flag.substring(2));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setDeprecation(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setDestdir(new File(in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setCrossrefs(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setEmacssym(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setEncoding(in.next());
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setFailonerror(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setFork(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setForkclasspath(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setHelp(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setIncremental(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setInjars(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setInpath(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setListFileArgs(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setMaxmem(in.next());
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setMessageHolderClass(in.next());
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setNoExit(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setNoExit(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setNoExit(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setNoImportError(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setNowarn(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setNoExit(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setOutjar(new File(in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setPreserveAllLocals(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setProceedOnError(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setReferenceInfo(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setSource(in.next());
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setSourceRootCopyFilter(in.next());
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setSourceRoots(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setSrcDir(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setTagFile(new File(in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setTarget(in.next());
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setTime(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setTime(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setVerbose(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setShowWeaveInfo(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setVersion(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setWarn(in.next());
    }
 else     if (flag.startsWith(""String_Node_Str"")) {
      setWarn(flag.substring(6));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setXlintwarnings(true);
    }
 else     if (flag.startsWith(""String_Node_Str"")) {
      setXlint(flag.substring(7));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setXlintfile(new File(in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setXNoweave(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setXReweavable(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setXNotReweavable(true);
    }
 else     if (flag.startsWith(""String_Node_Str"")) {
      File file=new File(flag.substring(1));
      if (file.canRead()) {
        setArgfiles(new Path(project,file.getPath()));
      }
 else {
        ignore(flag);
      }
    }
 else {
      File file=new File(flag);
      if (file.isFile() && file.canRead() && FileUtil.hasSourceSuffix(file)) {
        addFile(file);
      }
 else {
        ignore(flag);
      }
    }
  }
}",0.9935442220787604
9282,"public static Test suite(){
  TestSuite suite=new TestSuite(AjdeTests.class.getName());
  suite.addTestSuite(ShowWeaveMessagesTestCase.class);
  suite.addTestSuite(DuplicateManifestTest.class);
  suite.addTestSuite(BuildOptionsTest.class);
  suite.addTestSuite(BuildConfigurationTests.class);
  suite.addTestSuite(StructureModelRegressionTest.class);
  suite.addTestSuite(StructureModelTest.class);
  suite.addTestSuite(VersionTest.class);
  suite.addTestSuite(CompilerMessagesTest.class);
  suite.addTestSuite(AsmDeclarationsTest.class);
  suite.addTestSuite(AsmRelationshipsTest.class);
  suite.addTestSuite(InpathTestcase.class);
  suite.addTestSuite(ReweavableTestCase.class);
  suite.addTestSuite(ResourceCopyTestCase.class);
  suite.addTestSuite(ModelPerformanceTest.class);
  suite.addTestSuite(SavedModelConsistencyTest.class);
  suite.addTestSuite(BuildCancellingTest.class);
  suite.addTestSuite(JarManifestTest.class);
  suite.addTestSuite(ExtensionTests.class);
  suite.addTestSuite(GenericsTest.class);
  suite.addTestSuite(OutxmlTest.class);
  return suite;
}","public static Test suite(){
  TestSuite suite=new TestSuite(AjdeTests.class.getName());
  suite.addTestSuite(SymbolFileGenerationTest.class);
  suite.addTestSuite(ShowWeaveMessagesTestCase.class);
  suite.addTestSuite(DuplicateManifestTest.class);
  suite.addTestSuite(BuildOptionsTest.class);
  suite.addTestSuite(BuildConfigurationTests.class);
  suite.addTestSuite(StructureModelRegressionTest.class);
  suite.addTestSuite(StructureModelTest.class);
  suite.addTestSuite(VersionTest.class);
  suite.addTestSuite(CompilerMessagesTest.class);
  suite.addTestSuite(AsmDeclarationsTest.class);
  suite.addTestSuite(AsmRelationshipsTest.class);
  suite.addTestSuite(InpathTestcase.class);
  suite.addTestSuite(ReweavableTestCase.class);
  suite.addTestSuite(ResourceCopyTestCase.class);
  suite.addTestSuite(ModelPerformanceTest.class);
  suite.addTestSuite(SavedModelConsistencyTest.class);
  suite.addTestSuite(BuildCancellingTest.class);
  suite.addTestSuite(JarManifestTest.class);
  suite.addTestSuite(ExtensionTests.class);
  suite.addTestSuite(GenericsTest.class);
  suite.addTestSuite(OutxmlTest.class);
  return suite;
}",0.9754545454545456
9283,"public String toString(){
  StringBuffer buf=new StringBuffer();
  buf.append(""String_Node_Str"");
  buf.append(getDeclaringType().getName());
  buf.append(""String_Node_Str"");
  buf.append(getName());
  buf.append(""String_Node_Str"");
  for (int i=0; i < getParameterTypes().length; i++) {
    if (i > 0)     buf.append(""String_Node_Str"");
    buf.append(getParameterTypes()[i].toString());
  }
  buf.append(""String_Node_Str"");
  return buf.toString();
}","public String toString(){
  StringBuffer buf=new StringBuffer();
  buf.append(""String_Node_Str"");
  buf.append((getDeclaringType() == null ? ""String_Node_Str"" : getDeclaringType().getName()));
  buf.append(""String_Node_Str"");
  buf.append(getName());
  buf.append(""String_Node_Str"");
  for (int i=0; i < getParameterTypes().length; i++) {
    if (i > 0)     buf.append(""String_Node_Str"");
    buf.append(getParameterTypes()[i].toString());
  }
  buf.append(""String_Node_Str"");
  return buf.toString();
}",0.9465968586387434
9284,"/** 
 * Find all the ITDs and Declares, but it is important we do this from the supertypes down to the subtypes.
 * @param sourceType
 * @param yetToProcess
 */
private void collectAllITDsAndDeclares(SourceTypeBinding sourceType,Collection yetToProcess){
  ContextToken tok=CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.COLLECTING_ITDS_AND_DECLARES,sourceType.sourceName);
  ReferenceBinding superType=sourceType.superclass();
  if (yetToProcess.contains(superType) && superType instanceof SourceTypeBinding) {
    collectAllITDsAndDeclares((SourceTypeBinding)superType,yetToProcess);
  }
  buildInterTypeAndPerClause(sourceType.scope);
  addCrosscuttingStructures(sourceType.scope);
  yetToProcess.remove(sourceType);
  CompilationAndWeavingContext.leavingPhase(tok);
}","/** 
 * Find all the ITDs and Declares, but it is important we do this from the supertypes down to the subtypes.
 * @param sourceType
 * @param yetToProcess
 */
private void collectAllITDsAndDeclares(SourceTypeBinding sourceType,Collection yetToProcess){
  ContextToken tok=CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.COLLECTING_ITDS_AND_DECLARES,sourceType.sourceName);
  ReferenceBinding superType=sourceType.superclass();
  if (superType instanceof SourceTypeBinding) {
    if (yetToProcess.contains(superType)) {
      collectAllITDsAndDeclares((SourceTypeBinding)superType,yetToProcess);
    }
  }
 else   if (superType instanceof ParameterizedTypeBinding) {
    ParameterizedTypeBinding ptb=(ParameterizedTypeBinding)superType;
    if (ptb.type instanceof SourceTypeBinding && yetToProcess.contains(ptb.type)) {
      collectAllITDsAndDeclares((SourceTypeBinding)ptb.type,yetToProcess);
    }
  }
  buildInterTypeAndPerClause(sourceType.scope);
  addCrosscuttingStructures(sourceType.scope);
  yetToProcess.remove(sourceType);
  CompilationAndWeavingContext.leavingPhase(tok);
}",0.5125786163522013
9285,"static void addAspectDocumentation(IProgramElement node,StringBuffer fileBuffer,int index){
  List pointcuts=new ArrayList();
  List advice=new ArrayList();
  for (Iterator it=node.getChildren().iterator(); it.hasNext(); ) {
    IProgramElement member=(IProgramElement)it.next();
    if (member.getKind().equals(IProgramElement.Kind.POINTCUT)) {
      pointcuts.add(member);
    }
 else     if (member.getKind().equals(IProgramElement.Kind.ADVICE)) {
      advice.add(member);
    }
  }
  if (pointcuts.size() > 0) {
    insertDeclarationsSummary(fileBuffer,pointcuts,""String_Node_Str"",index);
    insertDeclarationsDetails(fileBuffer,pointcuts,""String_Node_Str"",index);
  }
  if (advice.size() > 0) {
    insertDeclarationsSummary(fileBuffer,advice,""String_Node_Str"",index);
    insertDeclarationsDetails(fileBuffer,advice,""String_Node_Str"",index);
  }
}","static void addAspectDocumentation(IProgramElement node,StringBuffer fileBuffer,int index){
  List pointcuts=new ArrayList();
  List advice=new ArrayList();
  List declares=new ArrayList();
  for (Iterator it=node.getChildren().iterator(); it.hasNext(); ) {
    IProgramElement member=(IProgramElement)it.next();
    if (member.getKind().equals(IProgramElement.Kind.POINTCUT)) {
      pointcuts.add(member);
    }
 else     if (member.getKind().equals(IProgramElement.Kind.ADVICE)) {
      advice.add(member);
    }
 else     if (member.getKind().isDeclare() || member.getKind().isInterTypeMember()) {
      declares.add(member);
    }
  }
  if (declares.size() > 0) {
    insertDeclarationsDetails(fileBuffer,declares,DECLARE_DETAIL,index);
    insertDeclarationsSummary(fileBuffer,declares,DECLARE_SUMMARY,index);
  }
  if (pointcuts.size() > 0) {
    insertDeclarationsSummary(fileBuffer,pointcuts,POINTCUT_SUMMARY,index);
    insertDeclarationsDetails(fileBuffer,pointcuts,POINTCUT_DETAIL,index);
  }
  if (advice.size() > 0) {
    insertDeclarationsSummary(fileBuffer,advice,ADVICE_SUMMARY,index);
    insertDeclarationsDetails(fileBuffer,advice,ADVICE_DETAIL,index);
  }
}",0.7338908017707821
9286,"static void insertDeclarationsDetails(StringBuffer fileBuffer,List decls,String kind,int index){
  if (!declsAboveVisibilityExist(decls))   return;
  int insertIndex=findDetailsIndex(fileBuffer,index);
  String detailsHeading=""String_Node_Str"" + ""String_Node_Str"" + kind.toUpperCase() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ kind+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  fileBuffer.insert(insertIndex,detailsHeading);
  insertIndex+=detailsHeading.length();
  for (int i=0; i < decls.size(); i++) {
    IProgramElement decl=(IProgramElement)decls.get(i);
    if (isAboveVisibility(decl)) {
      String entry=""String_Node_Str"";
      entry+=""String_Node_Str"" + generateHREFName(decl) + ""String_Node_Str"";
      if (kind.equals(""String_Node_Str"")) {
        entry+=""String_Node_Str"" + decl.getName() + ""String_Node_Str"";
        entry+=""String_Node_Str"" + generateAdviceSignatures(decl) + ""String_Node_Str""+ ""String_Node_Str""+ generateDetailsComment(decl)+ ""String_Node_Str""+ generateAffects(decl,false);
      }
 else       if (kind.equals(""String_Node_Str"")) {
        entry+=""String_Node_Str"" + decl.toLabelString() + ""String_Node_Str""+ generateDetailsComment(decl);
      }
 else       if (kind.equals(""String_Node_Str"")) {
        entry+=""String_Node_Str"" + decl.toLabelString() + ""String_Node_Str"";
        entry+=generateIntroductionSignatures(decl,true) + generateAffects(decl,true) + generateDetailsComment(decl);
      }
      if (i != decls.size() - 1) {
        entry+=""String_Node_Str"";
      }
 else {
        entry+=""String_Node_Str"";
      }
      fileBuffer.insert(insertIndex,entry);
      insertIndex+=entry.length();
    }
  }
}","static void insertDeclarationsDetails(StringBuffer fileBuffer,List decls,String kind,int index){
  if (!declsAboveVisibilityExist(decls))   return;
  int insertIndex=findDetailsIndex(fileBuffer,index);
  String detailsHeading=""String_Node_Str"" + ""String_Node_Str"" + kind.toUpperCase() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ kind+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  fileBuffer.insert(insertIndex,detailsHeading);
  insertIndex+=detailsHeading.length();
  for (int i=0; i < decls.size(); i++) {
    IProgramElement decl=(IProgramElement)decls.get(i);
    if (isAboveVisibility(decl)) {
      String entry=""String_Node_Str"";
      entry+=""String_Node_Str"" + generateHREFName(decl) + ""String_Node_Str"";
      if (kind.equals(ADVICE_DETAIL)) {
        entry+=""String_Node_Str"" + decl.getName() + ""String_Node_Str"";
        entry+=""String_Node_Str"" + generateAdviceSignatures(decl) + ""String_Node_Str""+ ""String_Node_Str""+ generateDetailsComment(decl)+ ""String_Node_Str""+ generateAffects(decl,false);
      }
 else       if (kind.equals(POINTCUT_DETAIL)) {
        entry+=""String_Node_Str"" + decl.toLabelString() + ""String_Node_Str""+ generateDetailsComment(decl);
      }
 else       if (kind.equals(DECLARE_DETAIL)) {
        entry+=""String_Node_Str"" + decl.toLabelString() + ""String_Node_Str"";
        entry+=generateIntroductionSignatures(decl,true) + generateAffects(decl,true) + generateDetailsComment(decl);
      }
      if (i != decls.size() - 1) {
        entry+=""String_Node_Str"";
      }
 else {
        entry+=""String_Node_Str"";
      }
      fileBuffer.insert(insertIndex,entry);
      insertIndex+=entry.length();
    }
  }
}",0.972941518766366
9287,"static void decorateMemberDocumentation(IProgramElement node,StringBuffer fileContentsBuffer,int index){
  List targets=StructureUtil.getTargets(node,IRelationship.Kind.ADVICE);
  if (targets != null && !targets.isEmpty()) {
    String prevName=""String_Node_Str"";
    String adviceDoc=""String_Node_Str"" + ""String_Node_Str"";
    String relativePackagePath=getRelativePathFromHere(node.getPackageName().replace('.','/') + Config.DIR_SEP_CHAR);
    List addedNames=new ArrayList();
    for (Iterator it=targets.iterator(); it.hasNext(); ) {
      String currHandle=(String)it.next();
      IProgramElement currDecl=AsmManager.getDefault().getHierarchy().findElementForHandle(currHandle);
      String packagePath=""String_Node_Str"";
      if (currDecl.getPackageName() != null && !currDecl.getPackageName().equals(""String_Node_Str"")) {
        packagePath=currDecl.getPackageName().replace('.','/') + Config.DIR_SEP_CHAR;
      }
      String hrefName=""String_Node_Str"";
      String hrefLink=""String_Node_Str"";
      hrefLink=relativePackagePath + packagePath;
      if (currDecl.getPackageName() != null) {
        hrefName=currDecl.getPackageName().replace('.','/');
      }
      hrefName+=Config.DIR_SEP_CHAR + currDecl.getParent().toLinkLabelString() + ""String_Node_Str""+ currDecl.getName();
      hrefLink+=currDecl.getParent().toLinkLabelString() + ""String_Node_Str"" + ""String_Node_Str""+ currDecl.toLabelString();
      if (!addedNames.contains(hrefName)) {
        adviceDoc=adviceDoc + ""String_Node_Str"" + hrefLink+ ""String_Node_Str""+ hrefName.replace('/','.')+ ""String_Node_Str"";
        if (it.hasNext())         adviceDoc+=""String_Node_Str"";
        addedNames.add(hrefName);
      }
    }
    adviceDoc+=""String_Node_Str"";
    fileContentsBuffer.insert(index,adviceDoc);
  }
}","static void decorateMemberDocumentation(IProgramElement node,StringBuffer fileContentsBuffer,int index){
  List targets=StructureUtil.getTargets(node,IRelationship.Kind.ADVICE);
  if (targets != null && !targets.isEmpty()) {
    String adviceDoc=""String_Node_Str"" + ""String_Node_Str"";
    String relativePackagePath=getRelativePathFromHere(node.getPackageName().replace('.','/') + Config.DIR_SEP_CHAR);
    List addedNames=new ArrayList();
    for (Iterator it=targets.iterator(); it.hasNext(); ) {
      String currHandle=(String)it.next();
      IProgramElement currDecl=AsmManager.getDefault().getHierarchy().findElementForHandle(currHandle);
      String packagePath=""String_Node_Str"";
      if (currDecl.getPackageName() != null && !currDecl.getPackageName().equals(""String_Node_Str"")) {
        packagePath=currDecl.getPackageName().replace('.','/') + Config.DIR_SEP_CHAR;
      }
      String hrefName=""String_Node_Str"";
      String hrefLink=""String_Node_Str"";
      hrefLink=relativePackagePath + packagePath;
      if (currDecl.getPackageName() != null) {
        hrefName=currDecl.getPackageName().replace('.','/');
      }
      hrefName+=Config.DIR_SEP_CHAR + currDecl.getParent().toLinkLabelString() + ""String_Node_Str""+ currDecl.getName();
      hrefLink+=currDecl.getParent().toLinkLabelString() + ""String_Node_Str"" + ""String_Node_Str""+ currDecl.toLabelString();
      if (!addedNames.contains(hrefName)) {
        adviceDoc=adviceDoc + ""String_Node_Str"" + hrefLink+ ""String_Node_Str""+ hrefName.replace('/','.')+ ""String_Node_Str"";
        if (it.hasNext())         adviceDoc+=""String_Node_Str"";
        addedNames.add(hrefName);
      }
    }
    adviceDoc+=""String_Node_Str"";
    fileContentsBuffer.insert(index,adviceDoc);
  }
}",0.9889612227568638
9288,"static String generateHREFName(IProgramElement decl){
  String hrefLink=decl.toLabelString();
  return hrefLink;
}","static String generateHREFName(IProgramElement decl){
  String hrefLink=decl.toLabelString().replace(""String_Node_Str"",""String_Node_Str"");
  return hrefLink;
}",0.8351648351648352
9289,"/** 
 * Skips files that are public in the model but not public in the source, e.g. nested aspects.
 */
static void decorateHTMLFile(File file) throws IOException {
  if (!file.exists())   return;
  System.out.println(""String_Node_Str"" + file.getCanonicalPath() + ""String_Node_Str"");
  BufferedReader reader=new BufferedReader(new FileReader(file));
  StringBuffer fileContents=new StringBuffer();
  String line=reader.readLine();
  while (line != null) {
    fileContents.append(line + ""String_Node_Str"");
    line=reader.readLine();
  }
  boolean isSecond=false;
  int index=0;
  IProgramElement decl;
  while (true) {
    String contents=fileContents.toString();
    int start=contents.indexOf(Config.DECL_ID_STRING,index);
    int end=contents.indexOf(Config.DECL_ID_TERMINATOR,index);
    if (start == -1)     decl=null;
 else     if (end == -1)     throw new Error(""String_Node_Str"");
 else {
      String tid=contents.substring(start + Config.DECL_ID_STRING.length(),end);
      decl=(IProgramElement)declIDTable.get(tid);
      index=start;
    }
    if (decl == null)     break;
    fileContents.delete(start,end + Config.DECL_ID_TERMINATOR.length());
    if (decl.getKind().isType()) {
      isSecond=true;
      addAspectDocumentation(decl,fileContents,index);
    }
 else {
      decorateMemberDocumentation(decl,fileContents,index);
    }
  }
  int classStartIndex=fileContents.toString().indexOf(""String_Node_Str"");
  int pointcutSummaryIndex=fileContents.toString().indexOf(""String_Node_Str"");
  int adviceSummaryIndex=fileContents.toString().indexOf(""String_Node_Str"");
  if (classStartIndex != -1 && (adviceSummaryIndex != -1 || pointcutSummaryIndex != -1)) {
    int classEndIndex=fileContents.toString().indexOf(""String_Node_Str"",classStartIndex);
    if (classStartIndex != -1 && classEndIndex != -1) {
      String classLine=fileContents.toString().substring(classStartIndex,classEndIndex);
      String aspectLine=""String_Node_Str"" + ""String_Node_Str"" + classLine.substring(11,classLine.length());
      fileContents.delete(classStartIndex,classEndIndex);
      fileContents.insert(classStartIndex,aspectLine);
    }
  }
  file.delete();
  FileOutputStream fos=new FileOutputStream(file);
  fos.write(fileContents.toString().getBytes());
}","/** 
 * Skips files that are public in the model but not public in the source, e.g. nested aspects.
 */
static void decorateHTMLFile(File file) throws IOException {
  if (!file.exists())   return;
  System.out.println(""String_Node_Str"" + file.getCanonicalPath() + ""String_Node_Str"");
  BufferedReader reader=new BufferedReader(new FileReader(file));
  StringBuffer fileContents=new StringBuffer();
  String line=reader.readLine();
  while (line != null) {
    fileContents.append(line + ""String_Node_Str"");
    line=reader.readLine();
  }
  boolean isSecond=false;
  int index=0;
  IProgramElement decl;
  while (true) {
    String contents=fileContents.toString();
    int start=contents.indexOf(Config.DECL_ID_STRING,index);
    int end=contents.indexOf(Config.DECL_ID_TERMINATOR,index);
    if (start == -1)     decl=null;
 else     if (end == -1)     throw new Error(""String_Node_Str"");
 else {
      String tid=contents.substring(start + Config.DECL_ID_STRING.length(),end);
      decl=(IProgramElement)declIDTable.get(tid);
      index=start;
    }
    if (decl == null)     break;
    fileContents.delete(start,end + Config.DECL_ID_TERMINATOR.length());
    if (decl.getKind().isType()) {
      isSecond=true;
      addAspectDocumentation(decl,fileContents,index);
    }
 else {
      decorateMemberDocumentation(decl,fileContents,index);
    }
  }
  int classStartIndex=fileContents.toString().indexOf(""String_Node_Str"");
  int pointcutSummaryIndex=fileContents.toString().indexOf(POINTCUT_SUMMARY);
  int adviceSummaryIndex=fileContents.toString().indexOf(ADVICE_SUMMARY);
  if (classStartIndex != -1 && (adviceSummaryIndex != -1 || pointcutSummaryIndex != -1)) {
    int classEndIndex=fileContents.toString().indexOf(""String_Node_Str"",classStartIndex);
    if (classStartIndex != -1 && classEndIndex != -1) {
      String classLine=fileContents.toString().substring(classStartIndex,classEndIndex);
      String aspectLine=""String_Node_Str"" + ""String_Node_Str"" + classLine.substring(11,classLine.length());
      fileContents.delete(classStartIndex,classEndIndex);
      fileContents.insert(classStartIndex,aspectLine);
    }
  }
  file.delete();
  FileOutputStream fos=new FileOutputStream(file);
  fos.write(fileContents.toString().getBytes());
}",0.9862771137671535
9290,"static void insertDeclarationsSummary(StringBuffer fileBuffer,List decls,String kind,int index){
  if (!declsAboveVisibilityExist(decls))   return;
  int insertIndex=findSummaryIndex(fileBuffer,index);
  String tableHead=""String_Node_Str"" + kind.toUpperCase() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ kind+ ""String_Node_Str"";
  fileBuffer.insert(insertIndex,tableHead);
  insertIndex+=tableHead.length();
  for (int i=0; i < decls.size(); i++) {
    IProgramElement decl=(IProgramElement)decls.get(i);
    if (isAboveVisibility(decl)) {
      String comment=generateSummaryComment(decl);
      String entry=""String_Node_Str"";
      if (kind.equals(""String_Node_Str"")) {
        entry+=""String_Node_Str"" + ""String_Node_Str"" + generateHREFName(decl) + ""String_Node_Str""+ ""String_Node_Str""+ generateAdviceSignatures(decl)+ ""String_Node_Str"";
        if (!comment.equals(""String_Node_Str"")) {
          entry+=comment + ""String_Node_Str"";
        }
        entry+=generateAffects(decl,false) + ""String_Node_Str"" + ""String_Node_Str"";
      }
 else       if (kind.equals(""String_Node_Str"")) {
        entry+=""String_Node_Str"" + ""String_Node_Str"" + genAccessibility(decl) + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ generateHREFName(decl)+ ""String_Node_Str""+ decl.toLabelString()+ ""String_Node_Str"";
        if (!comment.equals(""String_Node_Str"")) {
          entry+=comment + ""String_Node_Str"";
        }
        entry+=""String_Node_Str"";
      }
 else       if (kind.equals(""String_Node_Str"")) {
        entry+=""String_Node_Str"" + ""String_Node_Str"" + decl.getModifiers() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ generateHREFName(decl)+ ""String_Node_Str""+ ""String_Node_Str""+ decl.toLabelString()+ ""String_Node_Str""+ generateIntroductionSignatures(decl,false)+ generateAffects(decl,true);
      }
      fileBuffer.insert(insertIndex,entry);
      insertIndex+=entry.length();
    }
  }
  String tableTail=""String_Node_Str"";
  fileBuffer.insert(insertIndex,tableTail);
  insertIndex+=tableTail.length();
}","static void insertDeclarationsSummary(StringBuffer fileBuffer,List decls,String kind,int index){
  if (!declsAboveVisibilityExist(decls))   return;
  int insertIndex=findSummaryIndex(fileBuffer,index);
  String tableHead=""String_Node_Str"" + kind.toUpperCase() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ kind+ ""String_Node_Str"";
  fileBuffer.insert(insertIndex,tableHead);
  insertIndex+=tableHead.length();
  for (int i=0; i < decls.size(); i++) {
    IProgramElement decl=(IProgramElement)decls.get(i);
    if (isAboveVisibility(decl)) {
      String comment=generateSummaryComment(decl);
      String entry=""String_Node_Str"";
      if (kind.equals(ADVICE_SUMMARY)) {
        entry+=""String_Node_Str"" + ""String_Node_Str"" + generateHREFName(decl) + ""String_Node_Str""+ ""String_Node_Str""+ generateAdviceSignatures(decl)+ ""String_Node_Str"";
        if (!comment.equals(""String_Node_Str"")) {
          entry+=comment + ""String_Node_Str"";
        }
        entry+=generateAffects(decl,false) + ""String_Node_Str"" + ""String_Node_Str"";
      }
 else       if (kind.equals(POINTCUT_SUMMARY)) {
        entry+=""String_Node_Str"" + ""String_Node_Str"" + genAccessibility(decl) + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ generateHREFName(decl)+ ""String_Node_Str""+ decl.toLabelString()+ ""String_Node_Str"";
        if (!comment.equals(""String_Node_Str"")) {
          entry+=comment + ""String_Node_Str"";
        }
        entry+=""String_Node_Str"";
      }
 else       if (kind.equals(DECLARE_SUMMARY)) {
        entry+=""String_Node_Str"" + ""String_Node_Str"" + decl.getModifiers() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ generateHREFName(decl)+ ""String_Node_Str""+ ""String_Node_Str""+ decl.toLabelString()+ ""String_Node_Str""+ generateIntroductionSignatures(decl,true)+ generateAffects(decl,true);
      }
      fileBuffer.insert(insertIndex,entry);
      insertIndex+=entry.length();
    }
  }
  String tableTail=""String_Node_Str"";
  fileBuffer.insert(insertIndex,tableTail);
  insertIndex+=tableTail.length();
}",0.9754936949797764
9291,"/** 
 * TODO: probably want to make this the same for intros and advice.
 */
static String generateAffects(IProgramElement decl,boolean isIntroduction){
  List targets=StructureUtil.getTargets(decl,IRelationship.Kind.ADVICE);
  if (targets == null)   return null;
  List packageList=new ArrayList();
  String entry=""String_Node_Str"" + ""String_Node_Str"";
  String relativePackagePath=getRelativePathFromHere(decl.getPackageName().replace('.','/') + Config.DIR_SEP_CHAR);
  List addedNames=new ArrayList();
  for (Iterator it=targets.iterator(); it.hasNext(); ) {
    String currHandle=(String)it.next();
    IProgramElement currDecl=AsmManager.getDefault().getHierarchy().findElementForHandle(currHandle);
    if (currDecl.getKind().equals(IProgramElement.Kind.CODE)) {
      currDecl=currDecl.getParent();
    }
    if (currDecl != null && !StructureUtil.isAnonymous(currDecl.getParent())) {
      String packagePath=""String_Node_Str"";
      if (currDecl.getPackageName() != null && !currDecl.getPackageName().equals(""String_Node_Str"")) {
        packagePath=currDecl.getPackageName().replace('.','/') + Config.DIR_SEP_CHAR;
      }
      String typeSignature=constructNestedTypeName(currDecl);
      String hrefName=packagePath + typeSignature;
      String hrefLink=relativePackagePath + packagePath + typeSignature+ ""String_Node_Str"";
      if (!currDecl.getKind().isType()) {
        hrefName+='.' + currDecl.getName();
        hrefLink+=""String_Node_Str"" + currDecl.toLabelString();
      }
      if (!addedNames.contains(hrefName)) {
        entry+=""String_Node_Str"" + hrefLink + ""String_Node_Str""+ hrefName.replace('/','.')+ ""String_Node_Str"";
        if (it.hasNext())         entry+=""String_Node_Str"";
        addedNames.add(hrefName);
      }
    }
  }
  entry+=""String_Node_Str"";
  return entry;
}","/** 
 * TODO: probably want to make this the same for intros and advice.
 */
static String generateAffects(IProgramElement decl,boolean isIntroduction){
  List targets=null;
  if (isIntroduction) {
    targets=StructureUtil.getDeclareTargets(decl);
  }
 else {
    targets=StructureUtil.getTargets(decl,IRelationship.Kind.ADVICE);
  }
  if (targets == null)   return ""String_Node_Str"";
  String entry=""String_Node_Str"";
  if (!isIntroduction) {
    entry+=""String_Node_Str"";
  }
 else {
    entry+=""String_Node_Str"";
  }
  String relativePackagePath=getRelativePathFromHere(decl.getPackageName().replace('.','/') + Config.DIR_SEP_CHAR);
  List addedNames=new ArrayList();
  for (Iterator it=targets.iterator(); it.hasNext(); ) {
    String currHandle=(String)it.next();
    IProgramElement currDecl=AsmManager.getDefault().getHierarchy().findElementForHandle(currHandle);
    if (currDecl.getKind().equals(IProgramElement.Kind.CODE)) {
      currDecl=currDecl.getParent();
    }
    if (currDecl != null && !StructureUtil.isAnonymous(currDecl.getParent())) {
      String packagePath=""String_Node_Str"";
      if (currDecl.getPackageName() != null && !currDecl.getPackageName().equals(""String_Node_Str"")) {
        packagePath=currDecl.getPackageName().replace('.','/') + Config.DIR_SEP_CHAR;
      }
      String typeSignature=constructNestedTypeName(currDecl);
      String hrefName=packagePath + typeSignature;
      String hrefLink=relativePackagePath + packagePath + typeSignature+ ""String_Node_Str"";
      if (!currDecl.getKind().isType()) {
        hrefName+='.' + currDecl.getName();
        hrefLink+=""String_Node_Str"" + currDecl.toLabelString();
      }
      if (!addedNames.contains(hrefName)) {
        entry+=""String_Node_Str"" + hrefLink + ""String_Node_Str""+ hrefName.replace('/','.')+ ""String_Node_Str"";
        if (it.hasNext())         entry+=""String_Node_Str"";
        addedNames.add(hrefName);
      }
    }
  }
  entry+=""String_Node_Str"";
  return entry;
}",0.893999471319059
9292,"private static void processMembers(List members,PrintWriter writer,boolean declaringTypeIsInterface) throws DocException {
  for (Iterator it=members.iterator(); it.hasNext(); ) {
    IProgramElement member=(IProgramElement)it.next();
    if (member.getKind().isType()) {
      if (!member.getParent().getKind().equals(IProgramElement.Kind.METHOD) && !StructureUtil.isAnonymous(member)) {
        processTypeDeclaration(member,writer);
      }
    }
 else {
      String formalComment=addDeclID(member,member.getFormalComment());
      ;
      writer.println(formalComment);
      String signature=""String_Node_Str"";
      if (!member.getKind().equals(IProgramElement.Kind.POINTCUT) && !member.getKind().equals(IProgramElement.Kind.ADVICE)) {
        signature=member.getSourceSignature();
        if (member.getKind().equals(IProgramElement.Kind.ENUM_VALUE)) {
          if (((IProgramElement)members.get(members.indexOf(member) + 1)).getKind().equals(IProgramElement.Kind.ENUM_VALUE)) {
            signature=signature + ""String_Node_Str"";
          }
 else {
            signature=signature + ""String_Node_Str"";
          }
        }
      }
      if (member.getKind().isDeclare()) {
        System.err.println(""String_Node_Str"" + member.toLabelString());
      }
 else       if (signature != null && signature != ""String_Node_Str"" && !member.getKind().isInterTypeMember() && !member.getKind().equals(IProgramElement.Kind.INITIALIZER) && !StructureUtil.isAnonymous(member)) {
        writer.print(signature);
      }
 else {
      }
      if (member.getKind().equals(IProgramElement.Kind.METHOD) || member.getKind().equals(IProgramElement.Kind.CONSTRUCTOR)) {
        if (member.getParent().getKind().equals(IProgramElement.Kind.INTERFACE) || signature.indexOf(""String_Node_Str"") != -1) {
          writer.println(""String_Node_Str"");
        }
 else {
          writer.println(""String_Node_Str"");
        }
      }
 else       if (member.getKind().equals(IProgramElement.Kind.FIELD)) {
      }
    }
  }
}","private static void processMembers(List members,PrintWriter writer,boolean declaringTypeIsInterface) throws DocException {
  for (Iterator it=members.iterator(); it.hasNext(); ) {
    IProgramElement member=(IProgramElement)it.next();
    if (member.getKind().isType()) {
      if (!member.getParent().getKind().equals(IProgramElement.Kind.METHOD) && !StructureUtil.isAnonymous(member)) {
        processTypeDeclaration(member,writer);
      }
    }
 else {
      String formalComment=addDeclID(member,member.getFormalComment());
      ;
      writer.println(formalComment);
      String signature=""String_Node_Str"";
      if (!member.getKind().equals(IProgramElement.Kind.POINTCUT) && !member.getKind().equals(IProgramElement.Kind.ADVICE)) {
        signature=member.getSourceSignature();
        if (member.getKind().equals(IProgramElement.Kind.ENUM_VALUE)) {
          if (((IProgramElement)members.get(members.indexOf(member) + 1)).getKind().equals(IProgramElement.Kind.ENUM_VALUE)) {
            signature=signature + ""String_Node_Str"";
          }
 else {
            signature=signature + ""String_Node_Str"";
          }
        }
      }
      if (member.getKind().isDeclare()) {
      }
 else       if (signature != null && signature != ""String_Node_Str"" && !member.getKind().isInterTypeMember() && !member.getKind().equals(IProgramElement.Kind.INITIALIZER) && !StructureUtil.isAnonymous(member)) {
        writer.print(signature);
      }
 else {
      }
      if (member.getKind().equals(IProgramElement.Kind.METHOD) || member.getKind().equals(IProgramElement.Kind.CONSTRUCTOR)) {
        if (member.getParent().getKind().equals(IProgramElement.Kind.INTERFACE) || signature.indexOf(""String_Node_Str"") != -1) {
          writer.println(""String_Node_Str"");
        }
 else {
          writer.println(""String_Node_Str"");
        }
      }
 else       if (member.getKind().equals(IProgramElement.Kind.FIELD)) {
      }
    }
  }
}",0.9817444219066938
9293,"void extractInstructionsInto(LazyMethodGen freshMethod,IntMap remap,boolean addReturn){
  LazyMethodGen.assertGoodBody(getBody(),toString());
  freshMethod.assertGoodBody();
  InstructionList freshBody=freshMethod.getBody();
  for (InstructionHandle oldIh=start.getNext(); oldIh != end; oldIh=oldIh.getNext()) {
    Instruction oldI=oldIh.getInstruction();
    Instruction freshI=(oldI == RANGEINSTRUCTION) ? oldI : Utility.copyInstruction(oldI);
    InstructionHandle freshIh;
    if (freshI instanceof BranchInstruction) {
      BranchInstruction oldBranch=(BranchInstruction)oldI;
      BranchInstruction freshBranch=(BranchInstruction)freshI;
      InstructionHandle oldTarget=oldBranch.getTarget();
      oldTarget.removeTargeter(oldBranch);
      oldTarget.addTargeter(freshBranch);
      if (freshBranch instanceof Select) {
        Select oldSelect=(Select)oldI;
        Select freshSelect=(Select)freshI;
        InstructionHandle[] oldTargets=freshSelect.getTargets();
        for (int k=oldTargets.length - 1; k >= 0; k--) {
          oldTargets[k].removeTargeter(oldSelect);
          oldTargets[k].addTargeter(freshSelect);
        }
      }
      freshIh=freshBody.append(freshBranch);
    }
 else {
      freshIh=freshBody.append(freshI);
    }
    InstructionTargeter[] sources=oldIh.getTargeters();
    if (sources != null) {
      for (int j=sources.length - 1; j >= 0; j--) {
        InstructionTargeter source=sources[j];
        if (source instanceof LocalVariableTag) {
          Shadow.Kind kind=getKind();
          if (kind == Shadow.AdviceExecution || kind == Shadow.ConstructorExecution || kind == Shadow.MethodExecution || kind == Shadow.PreInitialization || kind == Shadow.Initialization || kind == Shadow.StaticInitialization) {
            source.updateTarget(oldIh,freshIh);
          }
 else {
            source.updateTarget(oldIh,null);
          }
        }
 else         if (source instanceof Range) {
          ((Range)source).updateTarget(oldIh,freshIh,freshBody);
        }
 else {
          source.updateTarget(oldIh,freshIh);
        }
      }
    }
    if (freshI instanceof LocalVariableInstruction || freshI instanceof RET) {
      IndexedInstruction indexedI=(IndexedInstruction)freshI;
      int oldIndex=indexedI.getIndex();
      int freshIndex;
      if (!remap.hasKey(oldIndex)) {
        freshIndex=freshMethod.allocateLocal(2);
        remap.put(oldIndex,freshIndex);
      }
 else {
        freshIndex=remap.get(oldIndex);
      }
      indexedI.setIndex(freshIndex);
    }
  }
  try {
    for (InstructionHandle oldIh=start.getNext(); oldIh != end; ) {
      InstructionHandle next=oldIh.getNext();
      body.delete(oldIh);
      oldIh=next;
    }
  }
 catch (  TargetLostException e) {
    throw new BCException(""String_Node_Str"");
  }
  InstructionHandle ret=null;
  if (addReturn) {
    ret=freshBody.append(InstructionFactory.createReturn(freshMethod.getReturnType()));
  }
  InstructionTargeter[] ts=end.getTargeters();
  if (ts != null) {
    for (int j=ts.length - 1; j >= 0; j--) {
      InstructionTargeter t=ts[j];
      if (t == this)       continue;
      if (!addReturn) {
        throw new BCException(""String_Node_Str"");
      }
 else {
        t.updateTarget(end,ret);
      }
    }
  }
  LazyMethodGen.assertGoodBody(getBody(),toString());
  freshMethod.assertGoodBody();
}","void extractInstructionsInto(LazyMethodGen freshMethod,IntMap remap,boolean addReturn){
  LazyMethodGen.assertGoodBody(getBody(),toString());
  freshMethod.assertGoodBody();
  InstructionList freshBody=freshMethod.getBody();
  for (InstructionHandle oldIh=start.getNext(); oldIh != end; oldIh=oldIh.getNext()) {
    Instruction oldI=oldIh.getInstruction();
    Instruction freshI=(oldI == RANGEINSTRUCTION) ? oldI : Utility.copyInstruction(oldI);
    InstructionHandle freshIh;
    if (freshI instanceof BranchInstruction) {
      BranchInstruction oldBranch=(BranchInstruction)oldI;
      BranchInstruction freshBranch=(BranchInstruction)freshI;
      InstructionHandle oldTarget=oldBranch.getTarget();
      oldTarget.removeTargeter(oldBranch);
      oldTarget.addTargeter(freshBranch);
      if (freshBranch instanceof Select) {
        Select oldSelect=(Select)oldI;
        Select freshSelect=(Select)freshI;
        InstructionHandle[] oldTargets=freshSelect.getTargets();
        for (int k=oldTargets.length - 1; k >= 0; k--) {
          oldTargets[k].removeTargeter(oldSelect);
          oldTargets[k].addTargeter(freshSelect);
        }
      }
      freshIh=freshBody.append(freshBranch);
    }
 else {
      freshIh=freshBody.append(freshI);
    }
    InstructionTargeter[] sources=oldIh.getTargeters();
    if (sources != null) {
      for (int j=sources.length - 1; j >= 0; j--) {
        InstructionTargeter source=sources[j];
        if (source instanceof LocalVariableTag) {
          Shadow.Kind kind=getKind();
          if (kind == Shadow.AdviceExecution || kind == Shadow.ConstructorExecution || kind == Shadow.MethodExecution || kind == Shadow.PreInitialization || kind == Shadow.Initialization || kind == Shadow.StaticInitialization) {
            source.updateTarget(oldIh,freshIh);
          }
 else {
            source.updateTarget(oldIh,null);
          }
        }
 else         if (source instanceof Range) {
          ((Range)source).updateTarget(oldIh,freshIh,freshBody);
        }
 else {
          source.updateTarget(oldIh,freshIh);
        }
      }
    }
    if (freshI instanceof LocalVariableInstruction || freshI instanceof RET) {
      IndexedInstruction indexedI=(IndexedInstruction)freshI;
      int oldIndex=indexedI.getIndex();
      int freshIndex;
      if (!remap.hasKey(oldIndex)) {
        freshIndex=freshMethod.allocateLocal(2);
        remap.put(oldIndex,freshIndex);
      }
 else {
        freshIndex=remap.get(oldIndex);
      }
      indexedI.setIndex(freshIndex);
    }
  }
  for (InstructionHandle newIh=freshBody.getStart(); newIh != freshBody.getEnd(); newIh=newIh.getNext()) {
    InstructionTargeter[] sources=newIh.getTargeters();
    if (sources != null) {
      for (int i=sources.length - 1; i >= 0; i--) {
        if (sources[i] instanceof LocalVariableTag) {
          LocalVariableTag lvt=(LocalVariableTag)sources[i];
          if (!lvt.isRemapped() && remap.hasKey(lvt.getSlot())) {
            lvt.updateSlot(remap.get(lvt.getSlot()));
          }
        }
      }
    }
  }
  try {
    for (InstructionHandle oldIh=start.getNext(); oldIh != end; ) {
      InstructionHandle next=oldIh.getNext();
      body.delete(oldIh);
      oldIh=next;
    }
  }
 catch (  TargetLostException e) {
    throw new BCException(""String_Node_Str"");
  }
  InstructionHandle ret=null;
  if (addReturn) {
    ret=freshBody.append(InstructionFactory.createReturn(freshMethod.getReturnType()));
  }
  InstructionTargeter[] ts=end.getTargeters();
  if (ts != null) {
    for (int j=ts.length - 1; j >= 0; j--) {
      InstructionTargeter t=ts[j];
      if (t == this)       continue;
      if (!addReturn) {
        throw new BCException(""String_Node_Str"");
      }
 else {
        t.updateTarget(end,ret);
      }
    }
  }
  LazyMethodGen.assertGoodBody(getBody(),toString());
  freshMethod.assertGoodBody();
}",0.9282840893327784
9294,"protected ResolvedType[] getAnnotations(Member relevantMember,ResolvedType relevantType){
  if (relevantMember == null) {
    List mungers=relevantType.resolve(world).getInterTypeMungers();
    for (Iterator iter=mungers.iterator(); iter.hasNext(); ) {
      BcelTypeMunger typeMunger=(BcelTypeMunger)iter.next();
      if (typeMunger.getMunger() instanceof NewMethodTypeMunger || typeMunger.getMunger() instanceof NewConstructorTypeMunger) {
        ResolvedMember fakerm=typeMunger.getSignature();
        ResolvedMember ajcMethod=(getSignature().getKind() == ResolvedMember.CONSTRUCTOR ? AjcMemberMaker.postIntroducedConstructor(typeMunger.getAspectType(),fakerm.getDeclaringType(),fakerm.getParameterTypes()) : AjcMemberMaker.interMethodDispatcher(fakerm,typeMunger.getAspectType()));
        ResolvedMember rmm=findMethod(typeMunger.getAspectType(),ajcMethod);
        if (fakerm.getName().equals(getSignature().getName()) && fakerm.getParameterSignature().equals(getSignature().getParameterSignature())) {
          relevantType=typeMunger.getAspectType();
          relevantMember=rmm;
          return relevantMember.getAnnotationTypes();
        }
      }
    }
  }
  return relevantMember.getAnnotationTypes();
}","protected ResolvedType[] getAnnotations(Member foundMember,Member relevantMember,ResolvedType relevantType){
  if (foundMember == null) {
    List mungers=relevantType.resolve(world).getInterTypeMungers();
    for (Iterator iter=mungers.iterator(); iter.hasNext(); ) {
      BcelTypeMunger typeMunger=(BcelTypeMunger)iter.next();
      if (typeMunger.getMunger() instanceof NewMethodTypeMunger || typeMunger.getMunger() instanceof NewConstructorTypeMunger) {
        ResolvedMember fakerm=typeMunger.getSignature();
        ResolvedMember ajcMethod=(getSignature().getKind() == ResolvedMember.CONSTRUCTOR ? AjcMemberMaker.postIntroducedConstructor(typeMunger.getAspectType(),fakerm.getDeclaringType(),fakerm.getParameterTypes()) : AjcMemberMaker.interMethodDispatcher(fakerm,typeMunger.getAspectType()));
        ResolvedMember rmm=findMethod(typeMunger.getAspectType(),ajcMethod);
        if (fakerm.getName().equals(getSignature().getName()) && fakerm.getParameterSignature().equals(getSignature().getParameterSignature())) {
          relevantType=typeMunger.getAspectType();
          foundMember=rmm;
          return foundMember.getAnnotationTypes();
        }
      }
    }
    foundMember=relevantType.lookupMemberWithSupersAndITDs(relevantMember);
    if (foundMember == null) {
      throw new IllegalStateException(""String_Node_Str"" + relevantMember + ""String_Node_Str""+ relevantType);
    }
  }
  return foundMember.getAnnotationTypes();
}",0.8305274971941639
9295,"public void initializeKindedAnnotationVars(){
  if (kindedAnnotationVars != null)   return;
  kindedAnnotationVars=new HashMap();
  ResolvedType[] annotations=null;
  Member relevantMember=getSignature();
  ResolvedType relevantType=relevantMember.getDeclaringType().resolve(world);
  if (getKind() == Shadow.StaticInitialization) {
    annotations=relevantType.resolve(world).getAnnotationTypes();
  }
 else   if (getKind() == Shadow.MethodCall || getKind() == Shadow.ConstructorCall) {
    relevantMember=findMethod2(relevantType.resolve(world).getDeclaredMethods(),getSignature());
    annotations=getAnnotations(relevantMember,relevantType);
    relevantMember=getRelevantMember(relevantMember,relevantType);
  }
 else   if (getKind() == Shadow.FieldSet || getKind() == Shadow.FieldGet) {
    relevantMember=findField(relevantType.getDeclaredFields(),getSignature());
    if (relevantMember == null) {
      List mungers=relevantType.resolve(world).getInterTypeMungers();
      for (Iterator iter=mungers.iterator(); iter.hasNext(); ) {
        BcelTypeMunger typeMunger=(BcelTypeMunger)iter.next();
        if (typeMunger.getMunger() instanceof NewFieldTypeMunger) {
          ResolvedMember fakerm=typeMunger.getSignature();
          ResolvedMember ajcMethod=AjcMemberMaker.interFieldInitializer(fakerm,typeMunger.getAspectType());
          ResolvedMember rmm=findMethod(typeMunger.getAspectType(),ajcMethod);
          if (fakerm.equals(getSignature())) {
            relevantType=typeMunger.getAspectType();
            relevantMember=rmm;
          }
        }
      }
    }
    annotations=relevantMember.getAnnotationTypes();
  }
 else   if (getKind() == Shadow.MethodExecution || getKind() == Shadow.ConstructorExecution || getKind() == Shadow.AdviceExecution) {
    ResolvedMember rm[]=relevantType.getDeclaredMethods();
    relevantMember=findMethod2(relevantType.getDeclaredMethods(),getSignature());
    annotations=getAnnotations(relevantMember,relevantType);
    relevantMember=getRelevantMember(relevantMember,relevantType);
  }
 else   if (getKind() == Shadow.ExceptionHandler) {
    relevantType=getSignature().getParameterTypes()[0].resolve(world);
    annotations=relevantType.getAnnotationTypes();
  }
 else   if (getKind() == Shadow.PreInitialization || getKind() == Shadow.Initialization) {
    ResolvedMember found=findMethod2(relevantType.getDeclaredMethods(),getSignature());
    annotations=found.getAnnotationTypes();
  }
  if (annotations == null) {
    throw new BCException(""String_Node_Str"" + getKind());
  }
  for (int i=0; i < annotations.length; i++) {
    ResolvedType aTX=annotations[i];
    KindedAnnotationAccessVar kaav=new KindedAnnotationAccessVar(getKind(),aTX.resolve(world),relevantType,relevantMember);
    kindedAnnotationVars.put(aTX,kaav);
  }
}","public void initializeKindedAnnotationVars(){
  if (kindedAnnotationVars != null)   return;
  kindedAnnotationVars=new HashMap();
  ResolvedType[] annotations=null;
  Member relevantMember=getSignature();
  ResolvedType relevantType=relevantMember.getDeclaringType().resolve(world);
  if (getKind() == Shadow.StaticInitialization) {
    annotations=relevantType.resolve(world).getAnnotationTypes();
  }
 else   if (getKind() == Shadow.MethodCall || getKind() == Shadow.ConstructorCall) {
    Member foundMember=findMethod2(relevantType.resolve(world).getDeclaredMethods(),getSignature());
    annotations=getAnnotations(foundMember,relevantMember,relevantType);
    relevantMember=getRelevantMember(foundMember,relevantMember,relevantType);
    relevantType=relevantMember.getDeclaringType().resolve(world);
  }
 else   if (getKind() == Shadow.FieldSet || getKind() == Shadow.FieldGet) {
    relevantMember=findField(relevantType.getDeclaredFields(),getSignature());
    if (relevantMember == null) {
      List mungers=relevantType.resolve(world).getInterTypeMungers();
      for (Iterator iter=mungers.iterator(); iter.hasNext(); ) {
        BcelTypeMunger typeMunger=(BcelTypeMunger)iter.next();
        if (typeMunger.getMunger() instanceof NewFieldTypeMunger) {
          ResolvedMember fakerm=typeMunger.getSignature();
          ResolvedMember ajcMethod=AjcMemberMaker.interFieldInitializer(fakerm,typeMunger.getAspectType());
          ResolvedMember rmm=findMethod(typeMunger.getAspectType(),ajcMethod);
          if (fakerm.equals(getSignature())) {
            relevantType=typeMunger.getAspectType();
            relevantMember=rmm;
          }
        }
      }
    }
    annotations=relevantMember.getAnnotationTypes();
  }
 else   if (getKind() == Shadow.MethodExecution || getKind() == Shadow.ConstructorExecution || getKind() == Shadow.AdviceExecution) {
    ResolvedMember rm[]=relevantType.getDeclaredMethods();
    Member foundMember=findMethod2(relevantType.getDeclaredMethods(),getSignature());
    annotations=getAnnotations(foundMember,relevantMember,relevantType);
    relevantMember=foundMember;
    relevantMember=getRelevantMember(foundMember,relevantMember,relevantType);
  }
 else   if (getKind() == Shadow.ExceptionHandler) {
    relevantType=getSignature().getParameterTypes()[0].resolve(world);
    annotations=relevantType.getAnnotationTypes();
  }
 else   if (getKind() == Shadow.PreInitialization || getKind() == Shadow.Initialization) {
    ResolvedMember found=findMethod2(relevantType.getDeclaredMethods(),getSignature());
    annotations=found.getAnnotationTypes();
  }
  if (annotations == null) {
    throw new BCException(""String_Node_Str"" + getKind());
  }
  for (int i=0; i < annotations.length; i++) {
    ResolvedType aTX=annotations[i];
    KindedAnnotationAccessVar kaav=new KindedAnnotationAccessVar(getKind(),aTX.resolve(world),relevantType,relevantMember);
    kindedAnnotationVars.put(aTX,kaav);
  }
}",0.9560229445506692
9296,"protected Member getRelevantMember(Member relevantMember,ResolvedType relevantType){
  if (relevantMember != null) {
    return relevantMember;
  }
  relevantMember=getSignature().resolve(world);
  List mungers=relevantType.resolve(world).getInterTypeMungers();
  for (Iterator iter=mungers.iterator(); iter.hasNext(); ) {
    BcelTypeMunger typeMunger=(BcelTypeMunger)iter.next();
    if (typeMunger.getMunger() instanceof NewMethodTypeMunger || typeMunger.getMunger() instanceof NewConstructorTypeMunger) {
      ResolvedMember fakerm=typeMunger.getSignature();
      if (fakerm.getName().equals(getSignature().getName()) && fakerm.getParameterSignature().equals(getSignature().getParameterSignature())) {
        if (relevantMember.getKind() == ResolvedMember.CONSTRUCTOR) {
          relevantMember=AjcMemberMaker.interConstructor(relevantType,(ResolvedMember)relevantMember,typeMunger.getAspectType());
        }
 else {
          relevantMember=AjcMemberMaker.interMethod((ResolvedMember)relevantMember,typeMunger.getAspectType(),false);
        }
        return relevantMember;
      }
    }
  }
  return null;
}","protected Member getRelevantMember(Member foundMember,Member relevantMember,ResolvedType relevantType){
  if (foundMember != null) {
    return foundMember;
  }
  foundMember=getSignature().resolve(world);
  if (foundMember == null && relevantMember != null) {
    foundMember=relevantType.lookupMemberWithSupersAndITDs(relevantMember);
  }
  List mungers=relevantType.resolve(world).getInterTypeMungers();
  for (Iterator iter=mungers.iterator(); iter.hasNext(); ) {
    BcelTypeMunger typeMunger=(BcelTypeMunger)iter.next();
    if (typeMunger.getMunger() instanceof NewMethodTypeMunger || typeMunger.getMunger() instanceof NewConstructorTypeMunger) {
      ResolvedMember fakerm=typeMunger.getSignature();
      if (fakerm.getName().equals(getSignature().getName()) && fakerm.getParameterSignature().equals(getSignature().getParameterSignature())) {
        if (foundMember.getKind() == ResolvedMember.CONSTRUCTOR) {
          foundMember=AjcMemberMaker.interConstructor(relevantType,(ResolvedMember)foundMember,typeMunger.getAspectType());
        }
 else {
          foundMember=AjcMemberMaker.interMethod((ResolvedMember)foundMember,typeMunger.getAspectType(),false);
        }
        return foundMember;
      }
    }
  }
  return foundMember;
}",0.8794266441821248
9297,"public static TypePattern read(VersionedDataInputStream s,ISourceContext context) throws IOException {
  TypePattern ret=new BindingTypePattern(UnresolvedType.read(s),s.readShort(),s.readBoolean());
  ret.readLocation(context,s);
  return ret;
}","public static TypePattern read(VersionedDataInputStream s,ISourceContext context) throws IOException {
  UnresolvedType type=UnresolvedType.read(s);
  int index=s.readShort();
  boolean isVarargs=false;
  if (s.getMajorVersion() >= AjAttribute.WeaverVersionInfo.WEAVER_VERSION_MAJOR_AJ150) {
    isVarargs=s.readBoolean();
  }
  TypePattern ret=new BindingTypePattern(type,index,isVarargs);
  ret.readLocation(context,s);
  return ret;
}",0.5718475073313783
9298,"/** 
 * Populate options in a build configuration, using the Ajde BuildOptionsAdapter. Added by AMC 01.20.2003, bugzilla #29769
 */
private static boolean configureBuildOptions(AjBuildConfig config,BuildOptionsAdapter options,IMessageHandler handler){
  LangUtil.throwIaxIfNull(options,""String_Node_Str"");
  LangUtil.throwIaxIfNull(config,""String_Node_Str"");
  Map optionsToSet=new HashMap();
  LangUtil.throwIaxIfNull(optionsToSet,""String_Node_Str"");
  if (options.getSourceCompatibilityLevel() != null && options.getSourceCompatibilityLevel().equals(CompilerOptions.VERSION_1_5)) {
    optionsToSet.put(CompilerOptions.OPTION_Compliance,CompilerOptions.VERSION_1_5);
    optionsToSet.put(CompilerOptions.OPTION_Source,CompilerOptions.VERSION_1_5);
  }
 else   if (options.getSourceOnePointFourMode() || options.getSourceCompatibilityLevel() != null && options.getSourceCompatibilityLevel().equals(CompilerOptions.VERSION_1_4)) {
    optionsToSet.put(CompilerOptions.OPTION_Compliance,CompilerOptions.VERSION_1_4);
    optionsToSet.put(CompilerOptions.OPTION_Source,CompilerOptions.VERSION_1_4);
  }
  String enc=options.getCharacterEncoding();
  if (!LangUtil.isEmpty(enc)) {
    optionsToSet.put(CompilerOptions.OPTION_Encoding,enc);
  }
  String compliance=options.getComplianceLevel();
  if (!LangUtil.isEmpty(compliance)) {
    String version=CompilerOptions.VERSION_1_4;
    if (compliance.equals(BuildOptionsAdapter.VERSION_13)) {
      version=CompilerOptions.VERSION_1_3;
    }
    optionsToSet.put(CompilerOptions.OPTION_Compliance,version);
    optionsToSet.put(CompilerOptions.OPTION_Source,version);
  }
  String sourceLevel=options.getSourceCompatibilityLevel();
  if (!LangUtil.isEmpty(sourceLevel)) {
    String slVersion=CompilerOptions.VERSION_1_4;
    if (sourceLevel.equals(BuildOptionsAdapter.VERSION_13)) {
      slVersion=CompilerOptions.VERSION_1_3;
    }
    if (sourceLevel.equals(CompilerOptions.VERSION_1_5)) {
      optionsToSet.put(CompilerOptions.OPTION_Source,CompilerOptions.VERSION_1_5);
    }
 else {
      String setCompliance=(String)optionsToSet.get(CompilerOptions.OPTION_Compliance);
      if (!(setCompliance.equals(CompilerOptions.VERSION_1_4) && slVersion.equals(CompilerOptions.VERSION_1_3))) {
        optionsToSet.put(CompilerOptions.OPTION_Source,slVersion);
      }
    }
  }
  Set warnings=options.getWarnings();
  if (!LangUtil.isEmpty(warnings)) {
    disableWarnings(optionsToSet);
    enableWarnings(optionsToSet,warnings);
  }
 else   if (warnings == null) {
    enableWarnings(optionsToSet,DEFAULT__AJDE_WARNINGS);
  }
  Set debugOptions=options.getDebugLevel();
  if (!LangUtil.isEmpty(debugOptions)) {
    boolean sourceLine=false;
    boolean varAttr=false;
    boolean lineNo=false;
    Iterator it=debugOptions.iterator();
    while (it.hasNext()) {
      String debug=(String)it.next();
      if (debug.equals(BuildOptionsAdapter.DEBUG_ALL)) {
        sourceLine=true;
        varAttr=true;
        lineNo=true;
      }
 else       if (debug.equals(BuildOptionsAdapter.DEBUG_LINES)) {
        lineNo=true;
      }
 else       if (debug.equals(BuildOptionsAdapter.DEBUG_SOURCE)) {
        sourceLine=true;
      }
 else       if (debug.equals(BuildOptionsAdapter.DEBUG_VARS)) {
        varAttr=true;
      }
    }
    if (sourceLine)     optionsToSet.put(CompilerOptions.OPTION_SourceFileAttribute,CompilerOptions.GENERATE);
    if (varAttr)     optionsToSet.put(CompilerOptions.OPTION_LocalVariableAttribute,CompilerOptions.GENERATE);
    if (lineNo)     optionsToSet.put(CompilerOptions.OPTION_LineNumberAttribute,CompilerOptions.GENERATE);
  }
  if (options.getPreserveAllLocals()) {
    optionsToSet.put(CompilerOptions.OPTION_PreserveUnusedLocal,CompilerOptions.PRESERVE);
  }
  if (!config.isIncrementalMode() && options.getIncrementalMode()) {
    config.setIncrementalMode(true);
  }
  Map jom=options.getJavaOptionsMap();
  if (jom != null) {
    String version=(String)jom.get(CompilerOptions.OPTION_Compliance);
    if (version != null && version.equals(CompilerOptions.VERSION_1_5)) {
      config.setBehaveInJava5Way(true);
    }
  }
  config.getOptions().set(optionsToSet);
  String toAdd=options.getNonStandardOptions();
  return LangUtil.isEmpty(toAdd) ? true : configureNonStandardOptions(config,toAdd,handler);
}","/** 
 * Populate options in a build configuration, using the Ajde BuildOptionsAdapter. Added by AMC 01.20.2003, bugzilla #29769
 */
private static boolean configureBuildOptions(AjBuildConfig config,BuildOptionsAdapter options,IMessageHandler handler){
  LangUtil.throwIaxIfNull(options,""String_Node_Str"");
  LangUtil.throwIaxIfNull(config,""String_Node_Str"");
  Map optionsToSet=new HashMap();
  LangUtil.throwIaxIfNull(optionsToSet,""String_Node_Str"");
  if (options.getSourceCompatibilityLevel() != null && options.getSourceCompatibilityLevel().equals(CompilerOptions.VERSION_1_5)) {
    optionsToSet.put(CompilerOptions.OPTION_Compliance,CompilerOptions.VERSION_1_5);
    optionsToSet.put(CompilerOptions.OPTION_Source,CompilerOptions.VERSION_1_5);
  }
 else   if (options.getSourceOnePointFourMode() || options.getSourceCompatibilityLevel() != null && options.getSourceCompatibilityLevel().equals(CompilerOptions.VERSION_1_4)) {
    optionsToSet.put(CompilerOptions.OPTION_Compliance,CompilerOptions.VERSION_1_4);
    optionsToSet.put(CompilerOptions.OPTION_Source,CompilerOptions.VERSION_1_4);
  }
  String enc=options.getCharacterEncoding();
  if (!LangUtil.isEmpty(enc)) {
    optionsToSet.put(CompilerOptions.OPTION_Encoding,enc);
  }
  String compliance=options.getComplianceLevel();
  if (!LangUtil.isEmpty(compliance)) {
    String version=CompilerOptions.VERSION_1_4;
    if (compliance.equals(BuildOptionsAdapter.VERSION_13)) {
      version=CompilerOptions.VERSION_1_3;
    }
    optionsToSet.put(CompilerOptions.OPTION_Compliance,version);
    optionsToSet.put(CompilerOptions.OPTION_Source,version);
  }
  String sourceLevel=options.getSourceCompatibilityLevel();
  if (!LangUtil.isEmpty(sourceLevel)) {
    String slVersion=CompilerOptions.VERSION_1_4;
    if (sourceLevel.equals(BuildOptionsAdapter.VERSION_13)) {
      slVersion=CompilerOptions.VERSION_1_3;
    }
    if (sourceLevel.equals(CompilerOptions.VERSION_1_5)) {
      optionsToSet.put(CompilerOptions.OPTION_Source,CompilerOptions.VERSION_1_5);
    }
 else {
      if (optionsToSet.containsKey(CompilerOptions.OPTION_Compliance)) {
        String setCompliance=(String)optionsToSet.get(CompilerOptions.OPTION_Compliance);
        if (!(setCompliance.equals(CompilerOptions.VERSION_1_4) && slVersion.equals(CompilerOptions.VERSION_1_3))) {
          optionsToSet.put(CompilerOptions.OPTION_Source,slVersion);
        }
      }
    }
  }
  Set warnings=options.getWarnings();
  if (!LangUtil.isEmpty(warnings)) {
    disableWarnings(optionsToSet);
    enableWarnings(optionsToSet,warnings);
  }
 else   if (warnings == null) {
    enableWarnings(optionsToSet,DEFAULT__AJDE_WARNINGS);
  }
  Set debugOptions=options.getDebugLevel();
  if (!LangUtil.isEmpty(debugOptions)) {
    boolean sourceLine=false;
    boolean varAttr=false;
    boolean lineNo=false;
    Iterator it=debugOptions.iterator();
    while (it.hasNext()) {
      String debug=(String)it.next();
      if (debug.equals(BuildOptionsAdapter.DEBUG_ALL)) {
        sourceLine=true;
        varAttr=true;
        lineNo=true;
      }
 else       if (debug.equals(BuildOptionsAdapter.DEBUG_LINES)) {
        lineNo=true;
      }
 else       if (debug.equals(BuildOptionsAdapter.DEBUG_SOURCE)) {
        sourceLine=true;
      }
 else       if (debug.equals(BuildOptionsAdapter.DEBUG_VARS)) {
        varAttr=true;
      }
    }
    if (sourceLine)     optionsToSet.put(CompilerOptions.OPTION_SourceFileAttribute,CompilerOptions.GENERATE);
    if (varAttr)     optionsToSet.put(CompilerOptions.OPTION_LocalVariableAttribute,CompilerOptions.GENERATE);
    if (lineNo)     optionsToSet.put(CompilerOptions.OPTION_LineNumberAttribute,CompilerOptions.GENERATE);
  }
  if (options.getPreserveAllLocals()) {
    optionsToSet.put(CompilerOptions.OPTION_PreserveUnusedLocal,CompilerOptions.PRESERVE);
  }
  if (!config.isIncrementalMode() && options.getIncrementalMode()) {
    config.setIncrementalMode(true);
  }
  Map jom=options.getJavaOptionsMap();
  if (jom != null) {
    String version=(String)jom.get(CompilerOptions.OPTION_Compliance);
    if (version != null && version.equals(CompilerOptions.VERSION_1_5)) {
      config.setBehaveInJava5Way(true);
    }
  }
  config.getOptions().set(optionsToSet);
  String toAdd=options.getNonStandardOptions();
  return LangUtil.isEmpty(toAdd) ? true : configureNonStandardOptions(config,toAdd,handler);
}",0.9818936685503402
9299,"public final boolean isAssignableFrom(ResolvedType other){
  if (other.isPrimitiveType()) {
    if (!world.isInJava5Mode())     return false;
    if (ResolvedType.validBoxing.contains(this.getSignature() + other.getSignature()))     return true;
  }
  if (this == other)   return true;
  if ((this.isRawType() || this.isGenericType()) && other.isParameterizedType()) {
    if (isAssignableFrom((ResolvedType)other.getRawType()))     return true;
  }
  if (this.isRawType() && other.isGenericType()) {
    if (isAssignableFrom((ResolvedType)other.getRawType()))     return true;
  }
  if (this.isGenericType() && other.isRawType()) {
    if (isAssignableFrom((ResolvedType)other.getGenericType()))     return true;
  }
  if (this.isParameterizedType()) {
    if (((ReferenceType)this.getRawType()).isAssignableFrom(other)) {
      boolean wildcardsAllTheWay=true;
      ResolvedType[] myParameters=this.getResolvedTypeParameters();
      for (int i=0; i < myParameters.length; i++) {
        if (!myParameters[i].isGenericWildcard()) {
          wildcardsAllTheWay=false;
        }
 else         if (myParameters[i].isExtends() || myParameters[i].isSuper()) {
          wildcardsAllTheWay=false;
        }
      }
      if (wildcardsAllTheWay && !other.isParameterizedType())       return true;
      ResolvedType[] theirParameters=other.getResolvedTypeParameters();
      boolean parametersAssignable=true;
      if (myParameters.length == theirParameters.length) {
        for (int i=0; i < myParameters.length; i++) {
          if (myParameters[i] == theirParameters[i])           continue;
          if (!myParameters[i].isGenericWildcard()) {
            parametersAssignable=false;
            break;
          }
 else {
            BoundedReferenceType wildcardType=(BoundedReferenceType)myParameters[i];
            if (!wildcardType.alwaysMatches(theirParameters[i])) {
              parametersAssignable=false;
              break;
            }
          }
        }
      }
 else {
        parametersAssignable=false;
      }
      if (parametersAssignable)       return true;
    }
  }
  for (Iterator i=other.getDirectSupertypes(); i.hasNext(); ) {
    if (this.isAssignableFrom((ResolvedType)i.next()))     return true;
  }
  return false;
}","public final boolean isAssignableFrom(ResolvedType other){
  if (other.isPrimitiveType()) {
    if (!world.isInJava5Mode())     return false;
    if (ResolvedType.validBoxing.contains(this.getSignature() + other.getSignature()))     return true;
  }
  if (this == other)   return true;
  if ((this.isRawType() || this.isGenericType()) && other.isParameterizedType()) {
    if (isAssignableFrom((ResolvedType)other.getRawType()))     return true;
  }
  if (this.isRawType() && other.isGenericType()) {
    if (isAssignableFrom((ResolvedType)other.getRawType()))     return true;
  }
  if (this.isGenericType() && other.isRawType()) {
    if (isAssignableFrom((ResolvedType)other.getGenericType()))     return true;
  }
  if (this.isParameterizedType()) {
    if (((ReferenceType)this.getRawType()).isAssignableFrom(other)) {
      boolean wildcardsAllTheWay=true;
      ResolvedType[] myParameters=this.getResolvedTypeParameters();
      for (int i=0; i < myParameters.length; i++) {
        if (!myParameters[i].isGenericWildcard()) {
          wildcardsAllTheWay=false;
        }
 else         if (myParameters[i].isExtends() || myParameters[i].isSuper()) {
          wildcardsAllTheWay=false;
        }
      }
      if (wildcardsAllTheWay && !other.isParameterizedType())       return true;
      ResolvedType[] theirParameters=other.getResolvedTypeParameters();
      boolean parametersAssignable=true;
      if (myParameters.length == theirParameters.length) {
        for (int i=0; i < myParameters.length; i++) {
          if (myParameters[i] == theirParameters[i])           continue;
          if (!myParameters[i].isGenericWildcard()) {
            parametersAssignable=false;
            break;
          }
 else {
            BoundedReferenceType wildcardType=(BoundedReferenceType)myParameters[i];
            if (!wildcardType.alwaysMatches(theirParameters[i])) {
              parametersAssignable=false;
              break;
            }
          }
        }
      }
 else {
        parametersAssignable=false;
      }
      if (parametersAssignable)       return true;
    }
  }
  if (other.isTypeVariableReference()) {
    TypeVariableReferenceType otherType=(TypeVariableReferenceType)other;
    return this.isAssignableFrom(otherType.getUpperBound().resolve(world));
  }
  for (Iterator i=other.getDirectSupertypes(); i.hasNext(); ) {
    if (this.isAssignableFrom((ResolvedType)i.next()))     return true;
  }
  return false;
}",0.9585547290116896
9300,"public NamePattern extractName(){
  if (isIncludeSubtypes() || isVarArgs() || isArray()) {
    return null;
  }
  int len=namePatterns.length;
  NamePattern ret=namePatterns[len - 1];
  NamePattern[] newNames=new NamePattern[len - 1];
  System.arraycopy(namePatterns,0,newNames,0,len - 1);
  namePatterns=newNames;
  return ret;
}","public NamePattern extractName(){
  if (isIncludeSubtypes() || isVarArgs() || isArray()) {
    return null;
  }
  int len=namePatterns.length;
  if (len == 1 && !annotationPattern.isAny())   return null;
  NamePattern ret=namePatterns[len - 1];
  NamePattern[] newNames=new NamePattern[len - 1];
  System.arraycopy(namePatterns,0,newNames,0,len - 1);
  namePatterns=newNames;
  return ret;
}",0.9153952843273232
9301,"private void convertToPointcutDeclaration(MethodDeclaration methodDeclaration,ClassScope scope){
  TypeDeclaration typeDecl=(TypeDeclaration)typeStack.peek();
  if (typeDecl.binding != null) {
    if (!typeDecl.binding.isClass()) {
      methodDeclaration.scope.problemReporter().signalError(methodDeclaration.sourceStart,methodDeclaration.sourceEnd,""String_Node_Str"");
    }
  }
  if (methodDeclaration.thrownExceptions != null && methodDeclaration.thrownExceptions.length > 0) {
    methodDeclaration.scope.problemReporter().signalError(methodDeclaration.sourceStart,methodDeclaration.sourceEnd,""String_Node_Str"");
  }
  PointcutDeclaration pcDecl=new PointcutDeclaration(unit.compilationResult);
  copyAllFields(methodDeclaration,pcDecl);
  if (ajAnnotations.hasAdviceAnnotation) {
    methodDeclaration.scope.problemReporter().disallowedTargetForAnnotation(ajAnnotations.adviceAnnotation);
  }
  if (ajAnnotations.hasAspectAnnotation) {
    methodDeclaration.scope.problemReporter().disallowedTargetForAnnotation(ajAnnotations.aspectAnnotation);
  }
  if (ajAnnotations.hasAdviceNameAnnotation) {
    methodDeclaration.scope.problemReporter().disallowedTargetForAnnotation(ajAnnotations.adviceNameAnnotation);
  }
  boolean containsIfPcd=false;
  int[] pcLocation=new int[2];
  String pointcutExpression=getStringLiteralFor(""String_Node_Str"",ajAnnotations.pointcutAnnotation,pcLocation);
  try {
    ISourceContext context=new EclipseSourceContext(unit.compilationResult,pcLocation[0]);
    Pointcut pc=new PatternParser(pointcutExpression,context).parsePointcut();
    pcDecl.pointcutDesignator=new PointcutDesignator(pc);
    pcDecl.setGenerateSyntheticPointcutMethod();
    TypeDeclaration onType=(TypeDeclaration)typeStack.peek();
    pcDecl.postParse(onType);
    EclipseFactory factory=EclipseFactory.fromScopeLookupEnvironment(methodDeclaration.scope);
    int argsLength=methodDeclaration.arguments == null ? 0 : methodDeclaration.arguments.length;
    FormalBinding[] bindings=new FormalBinding[argsLength];
    for (int i=0, len=bindings.length; i < len; i++) {
      Argument arg=methodDeclaration.arguments[i];
      String name=new String(arg.name);
      UnresolvedType type=factory.fromBinding(methodDeclaration.binding.parameters[i]);
      bindings[i]=new FormalBinding(type,name,i,arg.sourceStart,arg.sourceEnd,""String_Node_Str"");
    }
    swap(onType,methodDeclaration,pcDecl);
    pc.resolve(new EclipseScope(bindings,methodDeclaration.scope));
    HasIfPCDVisitor ifFinder=new HasIfPCDVisitor();
    pc.traverse(ifFinder,null);
    containsIfPcd=ifFinder.containsIfPcd;
  }
 catch (  ParserException pEx) {
    methodDeclaration.scope.problemReporter().parseError(pcLocation[0] + pEx.getLocation().getStart(),pcLocation[0] + pEx.getLocation().getEnd(),-1,pointcutExpression.toCharArray(),pointcutExpression,new String[]{pEx.getMessage()});
  }
  boolean returnsVoid=false;
  boolean returnsBoolean=false;
  if ((methodDeclaration.returnType instanceof SingleTypeReference)) {
    SingleTypeReference retType=(SingleTypeReference)methodDeclaration.returnType;
    if (CharOperation.equals(voidType,retType.token))     returnsVoid=true;
    if (CharOperation.equals(booleanType,retType.token))     returnsBoolean=true;
  }
  if (!returnsVoid && !containsIfPcd) {
    methodDeclaration.scope.problemReporter().signalError(methodDeclaration.returnType.sourceStart,methodDeclaration.returnType.sourceEnd,""String_Node_Str"");
  }
  if (!returnsBoolean && containsIfPcd) {
    methodDeclaration.scope.problemReporter().signalError(methodDeclaration.returnType.sourceStart,methodDeclaration.returnType.sourceEnd,""String_Node_Str"");
  }
  if (methodDeclaration.statements != null && methodDeclaration.statements.length > 0 && !containsIfPcd) {
    methodDeclaration.scope.problemReporter().signalError(methodDeclaration.returnType.sourceStart,methodDeclaration.returnType.sourceEnd,""String_Node_Str"");
  }
}","private void convertToPointcutDeclaration(MethodDeclaration methodDeclaration,ClassScope scope){
  TypeDeclaration typeDecl=(TypeDeclaration)typeStack.peek();
  if (typeDecl.binding != null) {
    if (!typeDecl.binding.isClass()) {
      methodDeclaration.scope.problemReporter().signalError(methodDeclaration.sourceStart,methodDeclaration.sourceEnd,""String_Node_Str"");
    }
  }
  if (methodDeclaration.thrownExceptions != null && methodDeclaration.thrownExceptions.length > 0) {
    methodDeclaration.scope.problemReporter().signalError(methodDeclaration.sourceStart,methodDeclaration.sourceEnd,""String_Node_Str"");
  }
  PointcutDeclaration pcDecl=new PointcutDeclaration(unit.compilationResult);
  copyAllFields(methodDeclaration,pcDecl);
  if (ajAnnotations.hasAdviceAnnotation) {
    methodDeclaration.scope.problemReporter().disallowedTargetForAnnotation(ajAnnotations.adviceAnnotation);
  }
  if (ajAnnotations.hasAspectAnnotation) {
    methodDeclaration.scope.problemReporter().disallowedTargetForAnnotation(ajAnnotations.aspectAnnotation);
  }
  if (ajAnnotations.hasAdviceNameAnnotation) {
    methodDeclaration.scope.problemReporter().disallowedTargetForAnnotation(ajAnnotations.adviceNameAnnotation);
  }
  boolean containsIfPcd=false;
  int[] pcLocation=new int[2];
  String pointcutExpression=getStringLiteralFor(""String_Node_Str"",ajAnnotations.pointcutAnnotation,pcLocation);
  try {
    ISourceContext context=new EclipseSourceContext(unit.compilationResult,pcLocation[0]);
    Pointcut pc=new PatternParser(pointcutExpression,context).parsePointcut();
    pcDecl.pointcutDesignator=new PointcutDesignator(pc);
    pcDecl.setGenerateSyntheticPointcutMethod();
    TypeDeclaration onType=(TypeDeclaration)typeStack.peek();
    pcDecl.postParse(onType);
    FormalBinding[] bindings=buildFormalAdviceBindingsFrom(methodDeclaration);
    swap(onType,methodDeclaration,pcDecl);
    pc.resolve(new EclipseScope(bindings,methodDeclaration.scope));
    HasIfPCDVisitor ifFinder=new HasIfPCDVisitor();
    pc.traverse(ifFinder,null);
    containsIfPcd=ifFinder.containsIfPcd;
  }
 catch (  ParserException pEx) {
    methodDeclaration.scope.problemReporter().parseError(pcLocation[0] + pEx.getLocation().getStart(),pcLocation[0] + pEx.getLocation().getEnd(),-1,pointcutExpression.toCharArray(),pointcutExpression,new String[]{pEx.getMessage()});
  }
  boolean returnsVoid=false;
  boolean returnsBoolean=false;
  if ((methodDeclaration.returnType instanceof SingleTypeReference)) {
    SingleTypeReference retType=(SingleTypeReference)methodDeclaration.returnType;
    if (CharOperation.equals(voidType,retType.token))     returnsVoid=true;
    if (CharOperation.equals(booleanType,retType.token))     returnsBoolean=true;
  }
  if (!returnsVoid && !containsIfPcd) {
    methodDeclaration.scope.problemReporter().signalError(methodDeclaration.returnType.sourceStart,methodDeclaration.returnType.sourceEnd,""String_Node_Str"");
  }
  if (!returnsBoolean && containsIfPcd) {
    methodDeclaration.scope.problemReporter().signalError(methodDeclaration.returnType.sourceStart,methodDeclaration.returnType.sourceEnd,""String_Node_Str"");
  }
  if (methodDeclaration.statements != null && methodDeclaration.statements.length > 0 && !containsIfPcd) {
    methodDeclaration.scope.problemReporter().signalError(methodDeclaration.returnType.sourceStart,methodDeclaration.returnType.sourceEnd,""String_Node_Str"");
  }
}",0.9207907293796864
9302,"private ClassTypeSignature parseClassTypeSignature(){
  SimpleClassTypeSignature outerType=null;
  SimpleClassTypeSignature[] nestedTypes=new SimpleClassTypeSignature[0];
  StringBuffer ret=new StringBuffer();
  String identifier=eatIdentifier();
  ret.append(identifier);
  while (maybeEat(""String_Node_Str"")) {
    ret.append(""String_Node_Str"");
    ret.append(eatIdentifier());
  }
  identifier=ret.toString();
  while (!maybeEat(""String_Node_Str"")) {
    if (maybeEat(""String_Node_Str"")) {
      outerType=new SimpleClassTypeSignature(identifier);
      List nestedTypeList=new ArrayList();
      do {
        ret.append(""String_Node_Str"");
        SimpleClassTypeSignature sig=parseSimpleClassTypeSignature();
        ret.append(sig.toString());
        nestedTypeList.add(ret);
      }
 while (maybeEat(""String_Node_Str""));
      nestedTypes=new SimpleClassTypeSignature[nestedTypeList.size()];
      nestedTypeList.toArray(nestedTypes);
    }
 else     if (tokenStream[tokenIndex].equals(""String_Node_Str"")) {
      ret.append(""String_Node_Str"");
      TypeArgument[] tArgs=maybeParseTypeArguments();
      for (int i=0; i < tArgs.length; i++) {
        ret.append(tArgs[i].toString());
      }
      ret.append(""String_Node_Str"");
      outerType=new SimpleClassTypeSignature(identifier,tArgs);
      List nestedTypeList=new ArrayList();
      while (maybeEat(""String_Node_Str"")) {
        ret.append(""String_Node_Str"");
        SimpleClassTypeSignature sig=parseSimpleClassTypeSignature();
        ret.append(sig.toString());
        nestedTypeList.add(ret);
      }
      nestedTypes=new SimpleClassTypeSignature[nestedTypeList.size()];
      nestedTypeList.toArray(nestedTypes);
    }
 else {
      throw new IllegalStateException(""String_Node_Str"" + tokenStream[tokenIndex]);
    }
  }
  ret.append(""String_Node_Str"");
  if (outerType == null)   outerType=new SimpleClassTypeSignature(ret.toString());
  return new ClassTypeSignature(ret.toString(),outerType,nestedTypes);
}","private ClassTypeSignature parseClassTypeSignature(){
  SimpleClassTypeSignature outerType=null;
  SimpleClassTypeSignature[] nestedTypes=new SimpleClassTypeSignature[0];
  StringBuffer ret=new StringBuffer();
  String identifier=eatIdentifier();
  ret.append(identifier);
  while (maybeEat(""String_Node_Str"")) {
    ret.append(""String_Node_Str"");
    ret.append(eatIdentifier());
  }
  identifier=ret.toString();
  while (!maybeEat(""String_Node_Str"")) {
    if (maybeEat(""String_Node_Str"")) {
      outerType=new SimpleClassTypeSignature(identifier);
      List nestedTypeList=new ArrayList();
      do {
        ret.append(""String_Node_Str"");
        SimpleClassTypeSignature sig=parseSimpleClassTypeSignature();
        ret.append(sig.toString());
        nestedTypeList.add(ret);
      }
 while (maybeEat(""String_Node_Str""));
      nestedTypes=new SimpleClassTypeSignature[nestedTypeList.size()];
      nestedTypeList.toArray(nestedTypes);
    }
 else     if (tokenStream[tokenIndex].equals(""String_Node_Str"")) {
      ret.append(""String_Node_Str"");
      TypeArgument[] tArgs=maybeParseTypeArguments();
      for (int i=0; i < tArgs.length; i++) {
        ret.append(tArgs[i].toString());
      }
      ret.append(""String_Node_Str"");
      outerType=new SimpleClassTypeSignature(identifier,tArgs);
      List nestedTypeList=new ArrayList();
      while (maybeEat(""String_Node_Str"")) {
        ret.append(""String_Node_Str"");
        SimpleClassTypeSignature sig=parseSimpleClassTypeSignature();
        ret.append(sig.toString());
        nestedTypeList.add(sig);
      }
      nestedTypes=new SimpleClassTypeSignature[nestedTypeList.size()];
      nestedTypeList.toArray(nestedTypes);
    }
 else {
      throw new IllegalStateException(""String_Node_Str"" + tokenStream[tokenIndex]);
    }
  }
  ret.append(""String_Node_Str"");
  if (outerType == null)   outerType=new SimpleClassTypeSignature(ret.toString());
  return new ClassTypeSignature(ret.toString(),outerType,nestedTypes);
}",0.9984894259818732
9303,"protected void generateAttributes(ClassFile classFile){
  if (!isAbstract())   generatePerSupportMembers(classFile);
  generateInlineAccessMembers(classFile);
  classFile.extraAttributes.add(new EclipseAttributeAdapter(new AjAttribute.Aspect(perClause)));
  if (binding.privilegedHandler != null) {
    ResolvedMember[] members=((PrivilegedHandler)binding.privilegedHandler).getMembers();
    classFile.extraAttributes.add(new EclipseAttributeAdapter(new AjAttribute.PrivilegedAttribute(members)));
  }
  classFile.extraAttributes.add(new EclipseAttributeAdapter(new AjAttribute.SourceContextAttribute(new String(compilationResult().getFileName()),compilationResult().lineSeparatorPositions)));
  super.generateAttributes(classFile);
}","protected void generateAttributes(ClassFile classFile){
  if (!isAbstract())   generatePerSupportMembers(classFile);
  generateInlineAccessMembers(classFile);
  classFile.extraAttributes.add(new EclipseAttributeAdapter(new AjAttribute.WeaverVersionInfo()));
  classFile.extraAttributes.add(new EclipseAttributeAdapter(new AjAttribute.Aspect(perClause)));
  if (binding.privilegedHandler != null) {
    ResolvedMember[] members=((PrivilegedHandler)binding.privilegedHandler).getMembers();
    classFile.extraAttributes.add(new EclipseAttributeAdapter(new AjAttribute.PrivilegedAttribute(members)));
  }
  classFile.extraAttributes.add(new EclipseAttributeAdapter(new AjAttribute.SourceContextAttribute(new String(compilationResult().getFileName()),compilationResult().lineSeparatorPositions)));
  super.generateAttributes(classFile);
}",0.9369024856596558
9304,"/** 
 * A pointcut declaration exists in a classfile only as an attibute on the class.  Unlike advice and inter-type declarations, it has no corresponding method.
 */
public void generateCode(ClassScope classScope,ClassFile classFile){
  this.world=EclipseFactory.fromScopeLookupEnvironment(classScope);
  if (ignoreFurtherInvestigation)   return;
  classFile.extraAttributes.add(new EclipseAttributeAdapter(makeAttribute()));
  if (generateSyntheticPointcutMethod) {
    super.generateCode(classScope,classFile);
  }
  return;
}","/** 
 * A pointcut declaration exists in a classfile only as an attibute on the class.  Unlike advice and inter-type declarations, it has no corresponding method.
 */
public void generateCode(ClassScope classScope,ClassFile classFile){
  this.world=EclipseFactory.fromScopeLookupEnvironment(classScope);
  if (ignoreFurtherInvestigation)   return;
  classFile.extraAttributes.add(new EclipseAttributeAdapter(makeAttribute()));
  addVersionAttributeIfNecessary(classFile);
  if (generateSyntheticPointcutMethod) {
    super.generateCode(classScope,classFile);
  }
  return;
}",0.9592021758839528
9305,"public static List readAjAttributes(String classname,Attribute[] as,ISourceContext context,IMessageHandler msgHandler){
  List l=new ArrayList();
  AjAttribute.WeaverVersionInfo version=new WeaverVersionInfo();
  for (int i=as.length - 1; i >= 0; i--) {
    Attribute a=as[i];
    if (a instanceof Unknown) {
      Unknown u=(Unknown)a;
      String name=u.getName();
      if (name.startsWith(AjAttribute.AttributePrefix)) {
        AjAttribute attr=AjAttribute.read(version,name,u.getBytes(),context,msgHandler);
        if (attr != null && attr instanceof AjAttribute.WeaverVersionInfo) {
          version=(AjAttribute.WeaverVersionInfo)attr;
          if (version.getMajorVersion() > WeaverVersionInfo.getCurrentWeaverMajorVersion()) {
            throw new BCException(""String_Node_Str"" + WeaverVersionInfo.toCurrentVersionString() + ""String_Node_Str""+ classname+ ""String_Node_Str""+ version.toString());
          }
        }
        if (attr != null)         l.add(attr);
      }
    }
  }
  return l;
}","public static List readAjAttributes(String classname,Attribute[] as,ISourceContext context,IMessageHandler msgHandler,AjAttribute.WeaverVersionInfo version){
  List l=new ArrayList();
  List forSecondPass=new ArrayList();
  for (int i=as.length - 1; i >= 0; i--) {
    Attribute a=as[i];
    if (a instanceof Unknown) {
      Unknown u=(Unknown)a;
      String name=u.getName();
      if (name.startsWith(AjAttribute.AttributePrefix)) {
        if (name.endsWith(WeaverVersionInfo.AttributeName)) {
          version=(AjAttribute.WeaverVersionInfo)AjAttribute.read(version,name,u.getBytes(),context,msgHandler);
          if (version.getMajorVersion() > WeaverVersionInfo.getCurrentWeaverMajorVersion()) {
            throw new BCException(""String_Node_Str"" + WeaverVersionInfo.toCurrentVersionString() + ""String_Node_Str""+ classname+ ""String_Node_Str""+ version.toString());
          }
        }
        forSecondPass.add(a);
      }
    }
  }
  for (int i=forSecondPass.size() - 1; i >= 0; i--) {
    Unknown a=(Unknown)forSecondPass.get(i);
    String name=a.getName();
    AjAttribute attr=AjAttribute.read(version,name,a.getBytes(),context,msgHandler);
    if (attr != null)     l.add(attr);
  }
  return l;
}",0.710431654676259
9306,"private void unpackAttributes(World world){
  Attribute[] attrs=field.getAttributes();
  List as=BcelAttributes.readAjAttributes(getDeclaringType().getClassName(),attrs,getSourceContext(world),world.getMessageHandler());
  as.addAll(AtAjAttributes.readAj5FieldAttributes(field,world.resolve(getDeclaringType()),getSourceContext(world),world.getMessageHandler()));
  for (Iterator iter=as.iterator(); iter.hasNext(); ) {
    AjAttribute a=(AjAttribute)iter.next();
    if (a instanceof AjAttribute.AjSynthetic) {
      isAjSynthetic=true;
    }
 else {
      throw new BCException(""String_Node_Str"" + a);
    }
  }
  isAjSynthetic=false;
  for (int i=attrs.length - 1; i >= 0; i--) {
    if (attrs[i] instanceof Synthetic)     isSynthetic=true;
  }
}","private void unpackAttributes(World world){
  Attribute[] attrs=field.getAttributes();
  List as=BcelAttributes.readAjAttributes(getDeclaringType().getClassName(),attrs,getSourceContext(world),world.getMessageHandler(),bcelObjectType.getWeaverVersionAttribute());
  as.addAll(AtAjAttributes.readAj5FieldAttributes(field,world.resolve(getDeclaringType()),getSourceContext(world),world.getMessageHandler()));
  for (Iterator iter=as.iterator(); iter.hasNext(); ) {
    AjAttribute a=(AjAttribute)iter.next();
    if (a instanceof AjAttribute.AjSynthetic) {
      isAjSynthetic=true;
    }
 else {
      throw new BCException(""String_Node_Str"" + a);
    }
  }
  isAjSynthetic=false;
  for (int i=attrs.length - 1; i >= 0; i--) {
    if (attrs[i] instanceof Synthetic)     isSynthetic=true;
  }
}",0.9720960415314732
9307,"BcelField(BcelObjectType declaringType,Field field){
  super(FIELD,declaringType.getResolvedTypeX(),field.getAccessFlags(),field.getName(),field.getSignature());
  this.field=field;
  this.world=declaringType.getResolvedTypeX().getWorld();
  unpackAttributes(world);
  checkedExceptions=UnresolvedType.NONE;
}","BcelField(BcelObjectType declaringType,Field field){
  super(FIELD,declaringType.getResolvedTypeX(),field.getAccessFlags(),field.getName(),field.getSignature());
  this.field=field;
  this.world=declaringType.getResolvedTypeX().getWorld();
  this.bcelObjectType=declaringType;
  unpackAttributes(world);
  checkedExceptions=UnresolvedType.NONE;
}",0.9435114503816794
9308,"private void unpackAjAttributes(World world){
  associatedShadowMunger=null;
  List as=BcelAttributes.readAjAttributes(getDeclaringType().getClassName(),method.getAttributes(),getSourceContext(world),world.getMessageHandler());
  processAttributes(world,as);
  as=AtAjAttributes.readAj5MethodAttributes(method,this,world.resolve(getDeclaringType()),preResolvedPointcut,getSourceContext(world),world.getMessageHandler());
  processAttributes(world,as);
}","private void unpackAjAttributes(World world){
  associatedShadowMunger=null;
  List as=BcelAttributes.readAjAttributes(getDeclaringType().getClassName(),method.getAttributes(),getSourceContext(world),world.getMessageHandler(),bcelObjectType.getWeaverVersionAttribute());
  processAttributes(world,as);
  as=AtAjAttributes.readAj5MethodAttributes(method,this,world.resolve(getDeclaringType()),preResolvedPointcut,getSourceContext(world),world.getMessageHandler());
  processAttributes(world,as);
}",0.9546891464699684
9309,"private void unpackAspectAttributes(){
  isUnpacked=true;
  List pointcuts=new ArrayList();
  typeMungers=new ArrayList();
  declares=new ArrayList();
  List l=BcelAttributes.readAjAttributes(javaClass.getClassName(),javaClass.getAttributes(),getResolvedTypeX().getSourceContext(),getResolvedTypeX().getWorld().getMessageHandler());
  processAttributes(l,pointcuts,false);
  l=AtAjAttributes.readAj5ClassAttributes(javaClass,getResolvedTypeX(),getResolvedTypeX().getSourceContext(),getResolvedTypeX().getWorld().getMessageHandler(),isCodeStyleAspect);
  processAttributes(l,pointcuts,true);
  this.pointcuts=(ResolvedPointcutDefinition[])pointcuts.toArray(new ResolvedPointcutDefinition[pointcuts.size()]);
}","private void unpackAspectAttributes(){
  isUnpacked=true;
  List pointcuts=new ArrayList();
  typeMungers=new ArrayList();
  declares=new ArrayList();
  List l=BcelAttributes.readAjAttributes(javaClass.getClassName(),javaClass.getAttributes(),getResolvedTypeX().getSourceContext(),getResolvedTypeX().getWorld().getMessageHandler(),AjAttribute.WeaverVersionInfo.UNKNOWN);
  processAttributes(l,pointcuts,false);
  l=AtAjAttributes.readAj5ClassAttributes(javaClass,getResolvedTypeX(),getResolvedTypeX().getSourceContext(),getResolvedTypeX().getWorld().getMessageHandler(),isCodeStyleAspect);
  processAttributes(l,pointcuts,true);
  this.pointcuts=(ResolvedPointcutDefinition[])pointcuts.toArray(new ResolvedPointcutDefinition[pointcuts.size()]);
}",0.9738651994497936
9310,"private void printAspectAttributes(PrintStream out){
  ISourceContext context=null;
  if (enclosingClass != null && enclosingClass.getType() != null) {
    context=enclosingClass.getType().getSourceContext();
  }
  List as=BcelAttributes.readAjAttributes(getClassName(),attributes,context,null);
  if (!as.isEmpty()) {
    out.println(""String_Node_Str"" + as.get(0));
  }
}","private void printAspectAttributes(PrintStream out){
  ISourceContext context=null;
  if (enclosingClass != null && enclosingClass.getType() != null) {
    context=enclosingClass.getType().getSourceContext();
  }
  List as=BcelAttributes.readAjAttributes(getClassName(),attributes,context,null,AjAttribute.WeaverVersionInfo.UNKNOWN);
  if (!as.isEmpty()) {
    out.println(""String_Node_Str"" + as.get(0));
  }
}",0.9514066496163684
9311,"private boolean acceptAspect(String aspectClassName){
  if (m_aspectExcludeTypePattern.isEmpty()) {
    return true;
  }
  ResolvedType classInfo=weaver.getWorld().getCoreType(UnresolvedType.forName(aspectClassName));
  for (Iterator iterator=m_aspectExcludeTypePattern.iterator(); iterator.hasNext(); ) {
    TypePattern typePattern=(TypePattern)iterator.next();
    if (typePattern.matchesStatically(classInfo)) {
      return false;
    }
  }
  return true;
}","private boolean acceptAspect(String aspectClassName){
  if (m_aspectExcludeTypePattern.isEmpty()) {
    return true;
  }
  ResolvedType classInfo=weaver.getWorld().resolve(UnresolvedType.forName(aspectClassName),true);
  for (Iterator iterator=m_aspectExcludeTypePattern.iterator(); iterator.hasNext(); ) {
    TypePattern typePattern=(TypePattern)iterator.next();
    if (typePattern.matchesStatically(classInfo)) {
      return false;
    }
  }
  return true;
}",0.9016216216216216
9312,"public boolean shouldDump(String className){
  if (m_dumpTypePattern.isEmpty()) {
    return false;
  }
  ResolvedType classInfo=weaver.getWorld().getCoreType(UnresolvedType.forName(className));
  for (Iterator iterator=m_dumpTypePattern.iterator(); iterator.hasNext(); ) {
    TypePattern typePattern=(TypePattern)iterator.next();
    if (typePattern.matchesStatically(classInfo)) {
      return true;
    }
  }
  return false;
}","public boolean shouldDump(String className){
  if (m_dumpTypePattern.isEmpty()) {
    return false;
  }
  ResolvedType classInfo=weaver.getWorld().resolve(UnresolvedType.forName(className),true);
  for (Iterator iterator=m_dumpTypePattern.iterator(); iterator.hasNext(); ) {
    TypePattern typePattern=(TypePattern)iterator.next();
    if (typePattern.matchesStatically(classInfo)) {
      return true;
    }
  }
  return false;
}",0.975609756097561
9313,"protected boolean accept(String className){
  if (m_excludeTypePattern.isEmpty() && m_includeTypePattern.isEmpty()) {
    return true;
  }
  ResolvedType classInfo=weaver.getWorld().getCoreType(UnresolvedType.forName(className));
  for (Iterator iterator=m_excludeTypePattern.iterator(); iterator.hasNext(); ) {
    TypePattern typePattern=(TypePattern)iterator.next();
    if (typePattern.matchesStatically(classInfo)) {
      return false;
    }
  }
  for (Iterator iterator=m_includeTypePattern.iterator(); iterator.hasNext(); ) {
    TypePattern typePattern=(TypePattern)iterator.next();
    if (!typePattern.matchesStatically(classInfo)) {
      return false;
    }
  }
  return true;
}","protected boolean accept(String className){
  if (m_excludeTypePattern.isEmpty() && m_includeTypePattern.isEmpty()) {
    return true;
  }
  ResolvedType classInfo=weaver.getWorld().resolve(UnresolvedType.forName(className),true);
  for (Iterator iterator=m_excludeTypePattern.iterator(); iterator.hasNext(); ) {
    TypePattern typePattern=(TypePattern)iterator.next();
    if (typePattern.matchesStatically(classInfo)) {
      return false;
    }
  }
  for (Iterator iterator=m_includeTypePattern.iterator(); iterator.hasNext(); ) {
    TypePattern typePattern=(TypePattern)iterator.next();
    if (!typePattern.matchesStatically(classInfo)) {
      return false;
    }
  }
  return true;
}",0.9848156182212582
9314,"/** 
 * Create a reference type for a generic type
 */
public ReferenceType(TypeX genericType,World world){
  super(genericType.getSignature(),world);
  genericSignature=genericType.genericSignature;
}","/** 
 * Create a reference type for a generic type
 */
public ReferenceType(TypeX genericType,World world){
  super(genericType.getSignature(),world);
  genericSignature=genericType.genericSignature;
  typeKind=GENERIC;
}",0.95260663507109
9315,"public void setGenericType(ReferenceType rt){
  this.genericType=rt;
}","public void setGenericType(ReferenceType rt){
  genericType=rt;
  if (typeKind == TypeX.SIMPLE) {
    typeKind=TypeX.RAW;
    rawTypeSignature=signature;
  }
}",0.5676855895196506
9316,"/** 
 * @param s the String to parse for [on|off|true|false]
 * @param iaxOnError if true and input is bad, throwIllegalArgumentException
 * @return true if input is true, false otherwise
 * @throws IllegalArgumentException if iaxOnError and input is bad
 */
public static boolean parseBoolean(final String input,boolean iaxOnError){
  final String syntax=""String_Node_Str"";
  if (null == input) {
    return false;
  }
  String lc=input.trim().toLowerCase();
  boolean result=false;
  boolean valid=false;
switch (lc.length()) {
case 2:
    if (valid=""String_Node_Str"".equals(lc)) {
      result=true;
    }
  break;
case 3:
valid=""String_Node_Str"".equals(lc);
break;
case 4:
if (valid=""String_Node_Str"".equals(lc)) {
result=true;
}
break;
case 5:
valid=""String_Node_Str"".equals(lc);
break;
}
if (iaxOnError && !valid) {
throw new IllegalArgumentException(input + syntax);
}
return result;
}","/** 
 * @param input the String to parse for [on|off|true|false]
 * @param iaxOnError if true and input is bad, throwIllegalArgumentException
 * @return true if input is true, false otherwise
 * @throws IllegalArgumentException if iaxOnError and input is bad
 */
public static boolean parseBoolean(final String input,boolean iaxOnError){
  final String syntax=""String_Node_Str"";
  if (null == input) {
    return false;
  }
  String lc=input.trim().toLowerCase();
  boolean result=false;
  boolean valid=false;
switch (lc.length()) {
case 2:
    if (valid=""String_Node_Str"".equals(lc)) {
      result=true;
    }
  break;
case 3:
valid=""String_Node_Str"".equals(lc);
break;
case 4:
if (valid=""String_Node_Str"".equals(lc)) {
result=true;
}
break;
case 5:
valid=""String_Node_Str"".equals(lc);
break;
}
if (iaxOnError && !valid) {
throw new IllegalArgumentException(input + syntax);
}
return result;
}",0.9966442953020134
9317,"/** 
 * Some generics notes: Andy 6-May-05 We were having trouble with parameterized types in a couple of places - due to TypeVariableBindings.  When we see a TypeVariableBinding now we default to either the firstBound if it is specified or java.lang.Object.  Not sure when/if this gets us unstuck?  It does mean we forget that it is a type variable when going back the other way from the TypeX and that would seem a bad thing - but I've yet to see the reason we need to remember the type variable.
 */
public static TypeX fromBinding(TypeBinding binding){
  if (binding instanceof HelperInterfaceBinding) {
    return ((HelperInterfaceBinding)binding).getTypeX();
  }
  if (binding == null || binding.qualifiedSourceName() == null) {
    return ResolvedTypeX.MISSING;
  }
  if (binding instanceof TypeVariableBinding) {
    TypeVariableBinding tvb=(TypeVariableBinding)binding;
    if (tvb.firstBound != null) {
      return TypeX.forName(getName(tvb.firstBound));
    }
 else {
      return TypeX.forName(getName(tvb.superclass));
    }
  }
  if (binding instanceof ParameterizedTypeBinding) {
    if (binding instanceof RawTypeBinding) {
      return TypeX.forRawTypeNames(getName(binding));
    }
    ParameterizedTypeBinding ptb=(ParameterizedTypeBinding)binding;
    String[] arguments=new String[ptb.arguments.length];
    for (int i=0; i < arguments.length; i++) {
      if (ptb.arguments[i] instanceof WildcardBinding) {
        WildcardBinding wcb=(WildcardBinding)ptb.arguments[i];
        arguments[i]=getName(((TypeVariableBinding)wcb.typeVariable()).firstBound);
      }
 else {
        arguments[i]=fromBinding(ptb.arguments[i]).getName();
      }
    }
    return TypeX.forParameterizedTypeNames(getName(binding),arguments);
  }
  return TypeX.forName(getName(binding));
}","/** 
 * Some generics notes: Andy 6-May-05 We were having trouble with parameterized types in a couple of places - due to TypeVariableBindings.  When we see a TypeVariableBinding now we default to either the firstBound if it is specified or java.lang.Object.  Not sure when/if this gets us unstuck?  It does mean we forget that it is a type variable when going back the other way from the TypeX and that would seem a bad thing - but I've yet to see the reason we need to remember the type variable.
 */
public static TypeX fromBinding(TypeBinding binding){
  if (binding instanceof HelperInterfaceBinding) {
    return ((HelperInterfaceBinding)binding).getTypeX();
  }
  if (binding == null || binding.qualifiedSourceName() == null) {
    return ResolvedTypeX.MISSING;
  }
  if (binding instanceof TypeVariableBinding) {
    TypeVariableBinding tvb=(TypeVariableBinding)binding;
    if (tvb.firstBound != null) {
      return TypeX.forName(getName(tvb.firstBound));
    }
 else {
      return TypeX.forName(getName(tvb.superclass));
    }
  }
  if (binding instanceof ParameterizedTypeBinding) {
    if (binding instanceof RawTypeBinding) {
      return TypeX.forRawTypeNames(getName(binding));
    }
    ParameterizedTypeBinding ptb=(ParameterizedTypeBinding)binding;
    String[] arguments=null;
    if (ptb.arguments != null) {
      arguments=new String[ptb.arguments.length];
      for (int i=0; i < arguments.length; i++) {
        if (ptb.arguments[i] instanceof WildcardBinding) {
          WildcardBinding wcb=(WildcardBinding)ptb.arguments[i];
          arguments[i]=getName(((TypeVariableBinding)wcb.typeVariable()).firstBound);
        }
 else {
          arguments[i]=fromBinding(ptb.arguments[i]).getName();
        }
      }
    }
    return TypeX.forParameterizedTypeNames(getName(binding),arguments);
  }
  return TypeX.forName(getName(binding));
}",0.9789214344374488
9318,"/** 
 * Some generics notes: Andy 6-May-05 We were having trouble with parameterized types in a couple of places - due to TypeVariableBindings.  When we see a TypeVariableBinding now we default to either the firstBound if it is specified or java.lang.Object.  Not sure when/if this gets us unstuck?  It does mean we forget that it is a type variable when going back the other way from the TypeX and that would seem a bad thing - but I've yet to see the reason we need to remember the type variable.
 */
public static TypeX fromBinding(TypeBinding binding){
  if (binding instanceof HelperInterfaceBinding) {
    return ((HelperInterfaceBinding)binding).getTypeX();
  }
  if (binding == null || binding.qualifiedSourceName() == null) {
    return ResolvedTypeX.MISSING;
  }
  if (binding instanceof TypeVariableBinding) {
    TypeVariableBinding tvb=(TypeVariableBinding)binding;
    if (tvb.firstBound != null) {
      return TypeX.forName(getName(tvb.firstBound));
    }
 else {
      return TypeX.forName(getName(tvb.superclass));
    }
  }
  if (binding instanceof ParameterizedTypeBinding) {
    if (binding instanceof RawTypeBinding) {
      return TypeX.forRawTypeNames(getName(binding));
    }
    ParameterizedTypeBinding ptb=(ParameterizedTypeBinding)binding;
    String[] arguments=new String[ptb.arguments.length];
    for (int i=0; i < arguments.length; i++) {
      if (ptb.arguments[i] instanceof WildcardBinding) {
        WildcardBinding wcb=(WildcardBinding)ptb.arguments[i];
        arguments[i]=getName(((TypeVariableBinding)wcb.typeVariable()).firstBound);
      }
 else {
        arguments[i]=getName(ptb.arguments[i]);
      }
    }
    return TypeX.forParameterizedTypeNames(getName(binding),arguments);
  }
  return TypeX.forName(getName(binding));
}","/** 
 * Some generics notes: Andy 6-May-05 We were having trouble with parameterized types in a couple of places - due to TypeVariableBindings.  When we see a TypeVariableBinding now we default to either the firstBound if it is specified or java.lang.Object.  Not sure when/if this gets us unstuck?  It does mean we forget that it is a type variable when going back the other way from the TypeX and that would seem a bad thing - but I've yet to see the reason we need to remember the type variable.
 */
public static TypeX fromBinding(TypeBinding binding){
  if (binding instanceof HelperInterfaceBinding) {
    return ((HelperInterfaceBinding)binding).getTypeX();
  }
  if (binding == null || binding.qualifiedSourceName() == null) {
    return ResolvedTypeX.MISSING;
  }
  if (binding instanceof TypeVariableBinding) {
    TypeVariableBinding tvb=(TypeVariableBinding)binding;
    if (tvb.firstBound != null) {
      return TypeX.forName(getName(tvb.firstBound));
    }
 else {
      return TypeX.forName(getName(tvb.superclass));
    }
  }
  if (binding instanceof ParameterizedTypeBinding) {
    if (binding instanceof RawTypeBinding) {
      return TypeX.forRawTypeNames(getName(binding));
    }
    ParameterizedTypeBinding ptb=(ParameterizedTypeBinding)binding;
    String[] arguments=new String[ptb.arguments.length];
    for (int i=0; i < arguments.length; i++) {
      if (ptb.arguments[i] instanceof WildcardBinding) {
        WildcardBinding wcb=(WildcardBinding)ptb.arguments[i];
        arguments[i]=getName(((TypeVariableBinding)wcb.typeVariable()).firstBound);
      }
 else {
        arguments[i]=fromBinding(ptb.arguments[i]).getName();
      }
    }
    return TypeX.forParameterizedTypeNames(getName(binding),arguments);
  }
  return TypeX.forName(getName(binding));
}",0.987085906793936
9319,"private TypeBinding makeTypeBinding1(TypeX typeX){
  if (typeX.isPrimitive()) {
    if (typeX == ResolvedTypeX.BOOLEAN)     return BaseTypes.BooleanBinding;
    if (typeX == ResolvedTypeX.BYTE)     return BaseTypes.ByteBinding;
    if (typeX == ResolvedTypeX.CHAR)     return BaseTypes.CharBinding;
    if (typeX == ResolvedTypeX.DOUBLE)     return BaseTypes.DoubleBinding;
    if (typeX == ResolvedTypeX.FLOAT)     return BaseTypes.FloatBinding;
    if (typeX == ResolvedTypeX.INT)     return BaseTypes.IntBinding;
    if (typeX == ResolvedTypeX.LONG)     return BaseTypes.LongBinding;
    if (typeX == ResolvedTypeX.SHORT)     return BaseTypes.ShortBinding;
    if (typeX == ResolvedTypeX.VOID)     return BaseTypes.VoidBinding;
    throw new RuntimeException(""String_Node_Str"" + typeX);
  }
 else   if (typeX.isArray()) {
    int dim=0;
    while (typeX.isArray()) {
      dim++;
      typeX=typeX.getComponentType();
    }
    return lookupEnvironment.createArrayType(makeTypeBinding(typeX),dim);
  }
 else   if (typeX.isParameterized()) {
    if (typeX.isRawType()) {
      ReferenceBinding baseTypeBinding=lookupBinding(typeX.getBaseName());
      RawTypeBinding rtb=lookupEnvironment.createRawType(baseTypeBinding,baseTypeBinding.enclosingType());
      return rtb;
    }
 else {
      TypeX[] typeParameters=typeX.getTypeParameters();
      ReferenceBinding baseTypeBinding=lookupBinding(typeX.getBaseName());
      ReferenceBinding[] argumentBindings=new ReferenceBinding[typeParameters.length];
      for (int i=0; i < argumentBindings.length; i++) {
        argumentBindings[i]=lookupBinding(typeParameters[i].getName());
      }
      ParameterizedTypeBinding ptb=lookupEnvironment.createParameterizedType(baseTypeBinding,argumentBindings,baseTypeBinding.enclosingType());
      return ptb;
    }
  }
 else {
    return lookupBinding(typeX.getName());
  }
}","private TypeBinding makeTypeBinding1(TypeX typeX){
  if (typeX.isPrimitive()) {
    if (typeX == ResolvedTypeX.BOOLEAN)     return BaseTypes.BooleanBinding;
    if (typeX == ResolvedTypeX.BYTE)     return BaseTypes.ByteBinding;
    if (typeX == ResolvedTypeX.CHAR)     return BaseTypes.CharBinding;
    if (typeX == ResolvedTypeX.DOUBLE)     return BaseTypes.DoubleBinding;
    if (typeX == ResolvedTypeX.FLOAT)     return BaseTypes.FloatBinding;
    if (typeX == ResolvedTypeX.INT)     return BaseTypes.IntBinding;
    if (typeX == ResolvedTypeX.LONG)     return BaseTypes.LongBinding;
    if (typeX == ResolvedTypeX.SHORT)     return BaseTypes.ShortBinding;
    if (typeX == ResolvedTypeX.VOID)     return BaseTypes.VoidBinding;
    throw new RuntimeException(""String_Node_Str"" + typeX);
  }
 else   if (typeX.isArray()) {
    int dim=0;
    while (typeX.isArray()) {
      dim++;
      typeX=typeX.getComponentType();
    }
    return lookupEnvironment.createArrayType(makeTypeBinding(typeX),dim);
  }
 else   if (typeX.isParameterized()) {
    if (typeX.isRawType()) {
      ReferenceBinding baseTypeBinding=lookupBinding(typeX.getBaseName());
      RawTypeBinding rtb=lookupEnvironment.createRawType(baseTypeBinding,baseTypeBinding.enclosingType());
      return rtb;
    }
 else {
      TypeX[] typeParameters=typeX.getTypeParameters();
      ReferenceBinding baseTypeBinding=lookupBinding(typeX.getBaseName());
      TypeBinding[] argumentBindings=new TypeBinding[typeParameters.length];
      for (int i=0; i < argumentBindings.length; i++) {
        argumentBindings[i]=makeTypeBinding(typeParameters[i]);
      }
      ParameterizedTypeBinding ptb=lookupEnvironment.createParameterizedType(baseTypeBinding,argumentBindings,baseTypeBinding.enclosingType());
      return ptb;
    }
  }
 else {
    return lookupBinding(typeX.getName());
  }
}",0.9881720430107528
9320,"static void defineClass(ClassLoader loader,String name,byte[] bytes){
  try {
    Method defineClass=ClassLoader.class.getDeclaredMethod(""String_Node_Str"",new Class[]{String.class,bytes.getClass(),int.class,int.class});
    defineClass.setAccessible(true);
    defineClass.invoke(loader,new Object[]{name,bytes,new Integer(0),new Integer(bytes.length)});
  }
 catch (  Throwable t) {
    t.printStackTrace();
  }
}","static void defineClass(ClassLoader loader,String name,byte[] bytes){
  try {
    Method defineClass=ClassLoader.class.getDeclaredMethod(""String_Node_Str"",new Class[]{String.class,bytes.getClass(),int.class,int.class});
    defineClass.setAccessible(true);
    defineClass.invoke(loader,new Object[]{name,bytes,new Integer(0),new Integer(bytes.length)});
  }
 catch (  InvocationTargetException e) {
    if (e.getTargetException() instanceof LinkageError) {
      ;
    }
 else {
      e.printStackTrace();
    }
  }
catch (  Exception e) {
    e.printStackTrace();
  }
}",0.7959390862944162
9321,"public static WeaverOption parse(String options,ClassLoader laoder){
  List flags=LangUtil.anySplit(options,""String_Node_Str"");
  Collections.reverse(flags);
  WeaverOption weaverOption=new WeaverOption();
  weaverOption.messageHandler=new DefaultMessageHandler();
  for (Iterator iterator=flags.iterator(); iterator.hasNext(); ) {
    String arg=(String)iterator.next();
    if (arg.startsWith(OPTIONVALUED_messageHolder)) {
      if (arg.length() > OPTIONVALUED_messageHolder.length()) {
        String handlerClass=arg.substring(OPTIONVALUED_messageHolder.length()).trim();
        try {
          Class handler=Class.forName(handlerClass,false,laoder);
          weaverOption.messageHandler=((IMessageHandler)handler.newInstance());
        }
 catch (        Throwable t) {
          weaverOption.messageHandler.handleMessage(new Message(""String_Node_Str"" + handlerClass,IMessage.ERROR,t,null));
        }
      }
    }
  }
  for (Iterator iterator=flags.iterator(); iterator.hasNext(); ) {
    String arg=(String)iterator.next();
    if (arg.equals(OPTION_15)) {
      weaverOption.java5=true;
    }
 else     if (arg.equalsIgnoreCase(OPTION_lazyTjp)) {
      weaverOption.lazyTjp=true;
    }
 else     if (arg.equalsIgnoreCase(OPTION_noinline)) {
      weaverOption.noInline=true;
    }
 else     if (arg.equalsIgnoreCase(OPTION_noWarn) || arg.equalsIgnoreCase(OPTION_noWarnNone)) {
      weaverOption.noWarn=true;
    }
 else     if (arg.equalsIgnoreCase(OPTION_proceedOnError)) {
      weaverOption.proceedOnError=true;
    }
 else     if (arg.equalsIgnoreCase(OPTION_reweavable)) {
      weaverOption.reWeavable=true;
    }
 else     if (arg.equalsIgnoreCase(OPTION_showWeaveInfo)) {
      weaverOption.showWeaveInfo=true;
    }
 else     if (arg.equalsIgnoreCase(OPTION_verbose)) {
      weaverOption.verbose=true;
    }
 else     if (arg.startsWith(OPTIONVALUED_messageHolder)) {
      ;
    }
 else {
      weaverOption.messageHandler.handleMessage(new Message(""String_Node_Str"" + arg + ""String_Node_Str"",IMessage.WARNING,null,null));
    }
  }
  if (weaverOption.noWarn) {
    weaverOption.messageHandler.dontIgnore(IMessage.WARNING);
  }
  if (weaverOption.verbose) {
    weaverOption.messageHandler.dontIgnore(IMessage.DEBUG);
  }
  if (weaverOption.showWeaveInfo) {
    weaverOption.messageHandler.dontIgnore(IMessage.WEAVEINFO);
  }
  return weaverOption;
}","public static WeaverOption parse(String options,ClassLoader laoder){
  if (LangUtil.isEmpty(options)) {
    return new WeaverOption();
  }
  List flags=LangUtil.anySplit(options,""String_Node_Str"");
  Collections.reverse(flags);
  WeaverOption weaverOption=new WeaverOption();
  for (Iterator iterator=flags.iterator(); iterator.hasNext(); ) {
    String arg=(String)iterator.next();
    if (arg.startsWith(OPTIONVALUED_messageHolder)) {
      if (arg.length() > OPTIONVALUED_messageHolder.length()) {
        String handlerClass=arg.substring(OPTIONVALUED_messageHolder.length()).trim();
        try {
          Class handler=Class.forName(handlerClass,false,laoder);
          weaverOption.messageHandler=((IMessageHandler)handler.newInstance());
        }
 catch (        Throwable t) {
          weaverOption.messageHandler.handleMessage(new Message(""String_Node_Str"" + handlerClass,IMessage.ERROR,t,null));
        }
      }
    }
  }
  for (Iterator iterator=flags.iterator(); iterator.hasNext(); ) {
    String arg=(String)iterator.next();
    if (arg.equals(OPTION_15)) {
      weaverOption.java5=true;
    }
 else     if (arg.equalsIgnoreCase(OPTION_lazyTjp)) {
      weaverOption.lazyTjp=true;
    }
 else     if (arg.equalsIgnoreCase(OPTION_noinline)) {
      weaverOption.noInline=true;
    }
 else     if (arg.equalsIgnoreCase(OPTION_noWarn) || arg.equalsIgnoreCase(OPTION_noWarnNone)) {
      weaverOption.noWarn=true;
    }
 else     if (arg.equalsIgnoreCase(OPTION_proceedOnError)) {
      weaverOption.proceedOnError=true;
    }
 else     if (arg.equalsIgnoreCase(OPTION_reweavable)) {
      weaverOption.reWeavable=true;
    }
 else     if (arg.equalsIgnoreCase(OPTION_showWeaveInfo)) {
      weaverOption.showWeaveInfo=true;
    }
 else     if (arg.equalsIgnoreCase(OPTION_verbose)) {
      weaverOption.verbose=true;
    }
 else     if (arg.startsWith(OPTIONVALUED_messageHolder)) {
      ;
    }
 else {
      weaverOption.messageHandler.handleMessage(new Message(""String_Node_Str"" + arg + ""String_Node_Str"",IMessage.WARNING,null,null));
    }
  }
  if (weaverOption.noWarn) {
    weaverOption.messageHandler.dontIgnore(IMessage.WARNING);
  }
  if (weaverOption.verbose) {
    weaverOption.messageHandler.dontIgnore(IMessage.DEBUG);
  }
  if (weaverOption.showWeaveInfo) {
    weaverOption.messageHandler.dontIgnore(IMessage.WEAVEINFO);
  }
  return weaverOption;
}",0.9728934650136584
9322,"/** 
 * Some generics notes: Andy 6-May-05 We were having trouble with parameterized types in a couple of places - due to TypeVariableBindings.  When we see a TypeVariableBinding now we default to either the firstBound if it is specified or java.lang.Object.  Not sure when/if this gets us unstuck?  It does mean we forget that it is a type variable when going back the other way from the TypeX and that would seem a bad thing - but I've yet to see the reason we need to remember the type variable.
 */
public static TypeX fromBinding(TypeBinding binding){
  if (binding instanceof HelperInterfaceBinding) {
    return ((HelperInterfaceBinding)binding).getTypeX();
  }
  if (binding == null || binding.qualifiedSourceName() == null) {
    return ResolvedTypeX.MISSING;
  }
  if (binding instanceof TypeVariableBinding) {
    TypeVariableBinding tvb=(TypeVariableBinding)binding;
    if (tvb.firstBound != null) {
      return TypeX.forName(getName(tvb.firstBound));
    }
 else {
      return TypeX.forName(getName(tvb.superclass));
    }
  }
  if (binding instanceof ParameterizedTypeBinding && !(binding instanceof RawTypeBinding)) {
    ParameterizedTypeBinding ptb=(ParameterizedTypeBinding)binding;
    String[] arguments=new String[ptb.arguments.length];
    for (int i=0; i < arguments.length; i++) {
      if (ptb.arguments[i] instanceof WildcardBinding) {
        WildcardBinding wcb=(WildcardBinding)ptb.arguments[i];
        arguments[i]=getName(((TypeVariableBinding)wcb.typeVariable()).firstBound);
      }
 else {
        arguments[i]=getName(ptb.arguments[i]);
      }
    }
    return TypeX.forParameterizedTypeNames(getName(binding),arguments);
  }
  return TypeX.forName(getName(binding));
}","/** 
 * Some generics notes: Andy 6-May-05 We were having trouble with parameterized types in a couple of places - due to TypeVariableBindings.  When we see a TypeVariableBinding now we default to either the firstBound if it is specified or java.lang.Object.  Not sure when/if this gets us unstuck?  It does mean we forget that it is a type variable when going back the other way from the TypeX and that would seem a bad thing - but I've yet to see the reason we need to remember the type variable.
 */
public static TypeX fromBinding(TypeBinding binding){
  if (binding instanceof HelperInterfaceBinding) {
    return ((HelperInterfaceBinding)binding).getTypeX();
  }
  if (binding == null || binding.qualifiedSourceName() == null) {
    return ResolvedTypeX.MISSING;
  }
  if (binding instanceof TypeVariableBinding) {
    TypeVariableBinding tvb=(TypeVariableBinding)binding;
    if (tvb.firstBound != null) {
      return TypeX.forName(getName(tvb.firstBound));
    }
 else {
      return TypeX.forName(getName(tvb.superclass));
    }
  }
  if (binding instanceof ParameterizedTypeBinding) {
    if (binding instanceof RawTypeBinding) {
      return TypeX.forRawTypeNames(getName(binding));
    }
    ParameterizedTypeBinding ptb=(ParameterizedTypeBinding)binding;
    String[] arguments=new String[ptb.arguments.length];
    for (int i=0; i < arguments.length; i++) {
      if (ptb.arguments[i] instanceof WildcardBinding) {
        WildcardBinding wcb=(WildcardBinding)ptb.arguments[i];
        arguments[i]=getName(((TypeVariableBinding)wcb.typeVariable()).firstBound);
      }
 else {
        arguments[i]=getName(ptb.arguments[i]);
      }
    }
    return TypeX.forParameterizedTypeNames(getName(binding),arguments);
  }
  return TypeX.forName(getName(binding));
}",0.977892621303474
9323,"private TypeBinding makeTypeBinding1(TypeX typeX){
  if (typeX.isPrimitive()) {
    if (typeX == ResolvedTypeX.BOOLEAN)     return BaseTypes.BooleanBinding;
    if (typeX == ResolvedTypeX.BYTE)     return BaseTypes.ByteBinding;
    if (typeX == ResolvedTypeX.CHAR)     return BaseTypes.CharBinding;
    if (typeX == ResolvedTypeX.DOUBLE)     return BaseTypes.DoubleBinding;
    if (typeX == ResolvedTypeX.FLOAT)     return BaseTypes.FloatBinding;
    if (typeX == ResolvedTypeX.INT)     return BaseTypes.IntBinding;
    if (typeX == ResolvedTypeX.LONG)     return BaseTypes.LongBinding;
    if (typeX == ResolvedTypeX.SHORT)     return BaseTypes.ShortBinding;
    if (typeX == ResolvedTypeX.VOID)     return BaseTypes.VoidBinding;
    throw new RuntimeException(""String_Node_Str"" + typeX);
  }
 else   if (typeX.isArray()) {
    int dim=0;
    while (typeX.isArray()) {
      dim++;
      typeX=typeX.getComponentType();
    }
    return lookupEnvironment.createArrayType(makeTypeBinding(typeX),dim);
  }
 else   if (typeX.isParameterized()) {
    TypeX[] typeParameters=typeX.getTypeParameters();
    ReferenceBinding baseTypeBinding=lookupBinding(typeX.getBaseName());
    ReferenceBinding[] argumentBindings=new ReferenceBinding[typeParameters.length];
    for (int i=0; i < argumentBindings.length; i++) {
      argumentBindings[i]=lookupBinding(typeParameters[i].getName());
    }
    ParameterizedTypeBinding ptb=lookupEnvironment.createParameterizedType(baseTypeBinding,argumentBindings,baseTypeBinding.enclosingType());
    return ptb;
  }
 else {
    return lookupBinding(typeX.getName());
  }
}","private TypeBinding makeTypeBinding1(TypeX typeX){
  if (typeX.isPrimitive()) {
    if (typeX == ResolvedTypeX.BOOLEAN)     return BaseTypes.BooleanBinding;
    if (typeX == ResolvedTypeX.BYTE)     return BaseTypes.ByteBinding;
    if (typeX == ResolvedTypeX.CHAR)     return BaseTypes.CharBinding;
    if (typeX == ResolvedTypeX.DOUBLE)     return BaseTypes.DoubleBinding;
    if (typeX == ResolvedTypeX.FLOAT)     return BaseTypes.FloatBinding;
    if (typeX == ResolvedTypeX.INT)     return BaseTypes.IntBinding;
    if (typeX == ResolvedTypeX.LONG)     return BaseTypes.LongBinding;
    if (typeX == ResolvedTypeX.SHORT)     return BaseTypes.ShortBinding;
    if (typeX == ResolvedTypeX.VOID)     return BaseTypes.VoidBinding;
    throw new RuntimeException(""String_Node_Str"" + typeX);
  }
 else   if (typeX.isArray()) {
    int dim=0;
    while (typeX.isArray()) {
      dim++;
      typeX=typeX.getComponentType();
    }
    return lookupEnvironment.createArrayType(makeTypeBinding(typeX),dim);
  }
 else   if (typeX.isParameterized()) {
    if (typeX.isRawType()) {
      ReferenceBinding baseTypeBinding=lookupBinding(typeX.getBaseName());
      RawTypeBinding rtb=lookupEnvironment.createRawType(baseTypeBinding,baseTypeBinding.enclosingType());
      return rtb;
    }
 else {
      TypeX[] typeParameters=typeX.getTypeParameters();
      ReferenceBinding baseTypeBinding=lookupBinding(typeX.getBaseName());
      ReferenceBinding[] argumentBindings=new ReferenceBinding[typeParameters.length];
      for (int i=0; i < argumentBindings.length; i++) {
        argumentBindings[i]=lookupBinding(typeParameters[i].getName());
      }
      ParameterizedTypeBinding ptb=lookupEnvironment.createParameterizedType(baseTypeBinding,argumentBindings,baseTypeBinding.enclosingType());
      return ptb;
    }
  }
 else {
    return lookupBinding(typeX.getName());
  }
}",0.9236970918514252
9324,"Collection getModifiedFiles(long lastBuildTime){
  List ret=new ArrayList();
  for (Iterator i=buildConfig.getFiles().iterator(); i.hasNext(); ) {
    File file=(File)i.next();
    if (!file.exists())     continue;
    long modTime=file.lastModified();
    if (modTime + 1000 >= lastBuildTime) {
      ret.add(file);
    }
  }
  return ret;
}","Collection getModifiedFiles(long lastBuildTime){
  List ret=new ArrayList();
  for (Iterator i=buildConfig.getFiles().iterator(); i.hasNext(); ) {
    File file=(File)i.next();
    if (!file.exists())     continue;
    long modTime=file.lastModified();
    if (modTime + 1000 > lastBuildTime) {
      ret.add(file);
    }
  }
  return ret;
}",0.9985358711566618
9325,"public void adviceMunger(IHierarchy model,Shadow shadow,ShadowMunger munger){
  if (!AsmManager.isCreatingModel())   return;
  if (munger instanceof Advice) {
    Advice advice=(Advice)munger;
    if (advice.getKind().isPerEntry() || advice.getKind().isCflow()) {
      return;
    }
    IRelationshipMap mapper=AsmManager.getDefault().getRelationshipMap();
    IProgramElement targetNode=getNode(AsmManager.getDefault().getHierarchy(),shadow);
    boolean runtimeTest=((BcelAdvice)munger).hasDynamicTests();
    IProgramElement.ExtraInformation ai=new IProgramElement.ExtraInformation();
    String adviceHandle=advice.getHandle();
    AdviceKind ak=((Advice)munger).getKind();
    ai.setExtraAdviceInformation(ak.getName());
    IProgramElement adviceElement=AsmManager.getDefault().getHierarchy().findElementForHandle(adviceHandle);
    adviceElement.setExtraInfo(ai);
    if (adviceHandle != null && targetNode != null) {
      if (targetNode != null) {
        String targetHandle=targetNode.getHandleIdentifier();
        IRelationship foreward=mapper.get(adviceHandle,IRelationship.Kind.ADVICE,ADVISES,runtimeTest,true);
        if (foreward != null)         foreward.addTarget(targetHandle);
        IRelationship back=mapper.get(targetHandle,IRelationship.Kind.ADVICE,ADVISED_BY,runtimeTest,true);
        if (back != null)         back.addTarget(adviceHandle);
      }
    }
  }
}","public void adviceMunger(IHierarchy model,Shadow shadow,ShadowMunger munger){
  if (!AsmManager.isCreatingModel())   return;
  if (munger instanceof Advice) {
    Advice advice=(Advice)munger;
    if (advice.getKind().isPerEntry() || advice.getKind().isCflow()) {
      return;
    }
    IRelationshipMap mapper=AsmManager.getDefault().getRelationshipMap();
    IProgramElement targetNode=getNode(AsmManager.getDefault().getHierarchy(),shadow);
    boolean runtimeTest=((BcelAdvice)munger).hasDynamicTests();
    IProgramElement.ExtraInformation ai=new IProgramElement.ExtraInformation();
    String adviceHandle=advice.getHandle();
    AdviceKind ak=((Advice)munger).getKind();
    ai.setExtraAdviceInformation(ak.getName());
    IProgramElement adviceElement=AsmManager.getDefault().getHierarchy().findElementForHandle(adviceHandle);
    adviceElement.setExtraInfo(ai);
    if (adviceHandle != null && targetNode != null) {
      if (targetNode != null) {
        String targetHandle=targetNode.getHandleIdentifier();
        if (advice.getKind().equals(AdviceKind.Softener)) {
          IRelationship foreward=mapper.get(adviceHandle,IRelationship.Kind.DECLARE_SOFT,SOFTENS,runtimeTest,true);
          if (foreward != null)           foreward.addTarget(targetHandle);
          IRelationship back=mapper.get(targetHandle,IRelationship.Kind.DECLARE,SOFTENED_BY,runtimeTest,true);
          if (back != null)           back.addTarget(adviceHandle);
        }
 else {
          IRelationship foreward=mapper.get(adviceHandle,IRelationship.Kind.ADVICE,ADVISES,runtimeTest,true);
          if (foreward != null)           foreward.addTarget(targetHandle);
          IRelationship back=mapper.get(targetHandle,IRelationship.Kind.ADVICE,ADVISED_BY,runtimeTest,true);
          if (back != null)           back.addTarget(adviceHandle);
        }
      }
    }
  }
}",0.8440479852353122
9326,"public static TypeX fromBinding(TypeBinding binding){
  if (binding instanceof HelperInterfaceBinding) {
    return ((HelperInterfaceBinding)binding).getTypeX();
  }
  if (binding == null || binding.qualifiedSourceName() == null) {
    return ResolvedTypeX.MISSING;
  }
  if (binding instanceof TypeVariableBinding) {
    TypeVariableBinding tvb=(TypeVariableBinding)binding;
    return TypeX.forName(getName(tvb.firstBound));
  }
  if (binding instanceof ParameterizedTypeBinding) {
    ParameterizedTypeBinding ptb=(ParameterizedTypeBinding)binding;
    String[] arguments=new String[ptb.arguments.length];
    for (int i=0; i < arguments.length; i++) {
      if (ptb.arguments[i] instanceof WildcardBinding) {
        WildcardBinding wcb=(WildcardBinding)ptb.arguments[i];
        arguments[i]=getName(((TypeVariableBinding)wcb.typeVariable()).firstBound);
      }
 else {
        arguments[i]=getName(ptb.arguments[i]);
      }
    }
    return TypeX.forParameterizedTypeNames(getName(binding),arguments);
  }
  return TypeX.forName(getName(binding));
}","public static TypeX fromBinding(TypeBinding binding){
  if (binding instanceof HelperInterfaceBinding) {
    return ((HelperInterfaceBinding)binding).getTypeX();
  }
  if (binding == null || binding.qualifiedSourceName() == null) {
    return ResolvedTypeX.MISSING;
  }
  if (binding instanceof TypeVariableBinding) {
    TypeVariableBinding tvb=(TypeVariableBinding)binding;
    return TypeX.forName(getName(tvb.firstBound));
  }
  if (binding instanceof ParameterizedTypeBinding && !(binding instanceof RawTypeBinding)) {
    ParameterizedTypeBinding ptb=(ParameterizedTypeBinding)binding;
    String[] arguments=new String[ptb.arguments.length];
    for (int i=0; i < arguments.length; i++) {
      if (ptb.arguments[i] instanceof WildcardBinding) {
        WildcardBinding wcb=(WildcardBinding)ptb.arguments[i];
        arguments[i]=getName(((TypeVariableBinding)wcb.typeVariable()).firstBound);
      }
 else {
        arguments[i]=getName(ptb.arguments[i]);
      }
    }
    return TypeX.forParameterizedTypeNames(getName(binding),arguments);
  }
  return TypeX.forName(getName(binding));
}",0.9814298978644382
9327,"/** 
 * delete not just this file, but any files in the same directory that were generated as a result of weaving it (e.g. for an around closure). 
 */
public void deleteRealFile() throws IOException {
  File victim=new File(filename);
  String namePrefix=victim.getName();
  namePrefix=namePrefix.substring(0,namePrefix.lastIndexOf('.'));
  final String targetPrefix=namePrefix + ""String_Node_Str"";
  File dir=victim.getParentFile();
  if (dir != null) {
    File[] weaverGenerated=dir.listFiles(new FilenameFilter(){
      public boolean accept(      File dir,      String name){
        return name.startsWith(targetPrefix);
      }
    }
);
    for (int i=0; i < weaverGenerated.length; i++) {
      weaverGenerated[i].delete();
    }
  }
  victim.delete();
}","/** 
 * delete not just this file, but any files in the same directory that were generated as a result of weaving it (e.g. for an around closure). 
 */
public void deleteRealFile() throws IOException {
  File victim=new File(filename);
  String namePrefix=victim.getName();
  namePrefix=namePrefix.substring(0,namePrefix.lastIndexOf('.'));
  final String targetPrefix=namePrefix + ""String_Node_Str"";
  File dir=victim.getParentFile();
  if (dir != null) {
    File[] weaverGenerated=dir.listFiles(new FilenameFilter(){
      public boolean accept(      File dir,      String name){
        return name.startsWith(targetPrefix);
      }
    }
);
    if (weaverGenerated != null) {
      for (int i=0; i < weaverGenerated.length; i++) {
        weaverGenerated[i].delete();
      }
    }
  }
  victim.delete();
}",0.9485060394151305
9328,"public void postParse(TypeDeclaration typeDec){
  super.postParse(typeDec);
  ((DeclareAnnotation)declareDecl).setAnnotationMethod(new String(selector));
}","public void postParse(TypeDeclaration typeDec){
  super.postParse(typeDec);
  if (declareDecl != null) {
    ((DeclareAnnotation)declareDecl).setAnnotationMethod(new String(selector));
  }
}",0.8985507246376812
9329,"public static TypeX fromBinding(TypeBinding binding){
  if (binding instanceof HelperInterfaceBinding) {
    return ((HelperInterfaceBinding)binding).getTypeX();
  }
  if (binding == null || binding.qualifiedSourceName() == null) {
    return ResolvedTypeX.MISSING;
  }
  return TypeX.forName(getName(binding));
}","public static TypeX fromBinding(TypeBinding binding){
  if (binding instanceof HelperInterfaceBinding) {
    return ((HelperInterfaceBinding)binding).getTypeX();
  }
  if (binding == null || binding.qualifiedSourceName() == null) {
    return ResolvedTypeX.MISSING;
  }
  if (binding instanceof TypeVariableBinding) {
    TypeVariableBinding tvb=(TypeVariableBinding)binding;
    return TypeX.forName(getName(tvb.firstBound));
  }
  return TypeX.forName(getName(binding));
}",0.7776365946632783
9330,"public ISourceLocation getSourceLocation(){
  int sourceLine=getSourceLine();
  if (sourceLine == 0 || sourceLine == -1) {
    return getEnclosingClass().getType().getSourceLocation();
  }
 else {
    return getEnclosingClass().getType().getSourceContext().makeSourceLocation(sourceLine);
  }
}","public ISourceLocation getSourceLocation(){
  int sourceLine=getSourceLine();
  if (sourceLine == 0 || sourceLine == -1) {
    return getEnclosingClass().getType().getSourceLocation();
  }
 else {
    if (getKind() == Shadow.StaticInitialization && getEnclosingClass().getType().getSourceLocation().getOffset() != 0)     return getEnclosingClass().getType().getSourceLocation();
 else     return getEnclosingClass().getType().getSourceContext().makeSourceLocation(sourceLine);
  }
}",0.7422680412371134
9331,"private boolean classFileChangedInDirSinceLastBuild(File dir){
  File[] classFiles=FileUtil.listFiles(dir,new FileFilter(){
    public boolean accept(    File pathname){
      return pathname.getName().endsWith(""String_Node_Str"");
    }
  }
);
  for (int i=0; i < classFiles.length; i++) {
    long modTime=classFiles[i].lastModified();
    if (modTime + 1000 >= lastSuccessfulBuildTime)     return true;
  }
  return false;
}","private boolean classFileChangedInDirSinceLastBuild(File dir){
  File[] classFiles=FileUtil.listFiles(dir,new FileFilter(){
    public boolean accept(    File pathname){
      return pathname.getName().endsWith(""String_Node_Str"");
    }
  }
);
  for (int i=0; i < classFiles.length; i++) {
    long modTime=classFiles[i].lastModified();
    if (modTime + 1000 >= lastSuccessfulBuildTime) {
      return true;
    }
  }
  return false;
}",0.948955916473318
9332,"/** 
 * Returns false if a batch build is needed.
 */
boolean prepareForNextBuild(AjBuildConfig newBuildConfig){
  currentBuildTime=System.currentTimeMillis();
  addedClassFiles=new ArrayList();
  if (lastSuccessfulBuildTime == -1 || buildConfig == null) {
    return false;
  }
  if (newBuildConfig.getOutputJar() != null)   return false;
  if (pathChange(buildConfig,newBuildConfig)) {
    removeAllResultsOfLastBuild();
    return false;
  }
  simpleStrings=new ArrayList();
  qualifiedStrings=new ArrayList();
  Set oldFiles=new HashSet(buildConfig.getFiles());
  Set newFiles=new HashSet(newBuildConfig.getFiles());
  addedFiles=new HashSet(newFiles);
  addedFiles.removeAll(oldFiles);
  deletedFiles=new HashSet(oldFiles);
  deletedFiles.removeAll(newFiles);
  Set oldBinaryFiles=new HashSet(buildConfig.getBinaryFiles());
  Set newBinaryFiles=new HashSet(newBuildConfig.getBinaryFiles());
  addedBinaryFiles=new HashSet(newBinaryFiles);
  addedBinaryFiles.removeAll(oldBinaryFiles);
  deletedBinaryFiles=new HashSet(oldBinaryFiles);
  deletedBinaryFiles.removeAll(newBinaryFiles);
  this.newBuildConfig=newBuildConfig;
  return true;
}","/** 
 * Returns false if a batch build is needed.
 */
boolean prepareForNextBuild(AjBuildConfig newBuildConfig){
  currentBuildTime=System.currentTimeMillis();
  addedClassFiles=new ArrayList();
  if (lastSuccessfulBuildTime == -1 || buildConfig == null) {
    return false;
  }
  if (newBuildConfig.getOutputJar() != null)   return false;
  if (pathChange(buildConfig,newBuildConfig)) {
    removeAllResultsOfLastBuild();
    if (stateListener != null)     stateListener.pathChangeDetected();
    return false;
  }
  simpleStrings=new ArrayList();
  qualifiedStrings=new ArrayList();
  Set oldFiles=new HashSet(buildConfig.getFiles());
  Set newFiles=new HashSet(newBuildConfig.getFiles());
  addedFiles=new HashSet(newFiles);
  addedFiles.removeAll(oldFiles);
  deletedFiles=new HashSet(oldFiles);
  deletedFiles.removeAll(newFiles);
  Set oldBinaryFiles=new HashSet(buildConfig.getBinaryFiles());
  Set newBinaryFiles=new HashSet(newBuildConfig.getBinaryFiles());
  addedBinaryFiles=new HashSet(newBinaryFiles);
  addedBinaryFiles.removeAll(oldBinaryFiles);
  deletedBinaryFiles=new HashSet(oldBinaryFiles);
  deletedBinaryFiles.removeAll(newBinaryFiles);
  this.newBuildConfig=newBuildConfig;
  return true;
}",0.9698513800424629
9333,"private boolean pathChange(AjBuildConfig oldConfig,AjBuildConfig newConfig){
  boolean changed=false;
  List oldClasspath=oldConfig.getClasspath();
  List newClasspath=newConfig.getClasspath();
  if (changed(oldClasspath,newClasspath,true))   return true;
  List oldAspectpath=oldConfig.getAspectpath();
  List newAspectpath=newConfig.getAspectpath();
  if (changed(oldAspectpath,newAspectpath,true))   return true;
  List oldInJars=oldConfig.getInJars();
  List newInJars=newConfig.getInJars();
  if (changed(oldInJars,newInJars,false))   return true;
  List oldInPath=oldConfig.getInpath();
  List newInPath=newConfig.getInpath();
  if (changed(oldInPath,newInPath,false))   return true;
  return changed;
}","private boolean pathChange(AjBuildConfig oldConfig,AjBuildConfig newConfig){
  boolean changed=false;
  List oldClasspath=oldConfig.getClasspath();
  List newClasspath=newConfig.getClasspath();
  if (stateListener != null)   stateListener.aboutToCompareClasspaths(oldClasspath,newClasspath);
  if (changed(oldClasspath,newClasspath,true,oldConfig.getOutputDir()))   return true;
  List oldAspectpath=oldConfig.getAspectpath();
  List newAspectpath=newConfig.getAspectpath();
  if (changed(oldAspectpath,newAspectpath,true,oldConfig.getOutputDir()))   return true;
  List oldInJars=oldConfig.getInJars();
  List newInJars=newConfig.getInJars();
  if (changed(oldInJars,newInJars,false,oldConfig.getOutputDir()))   return true;
  List oldInPath=oldConfig.getInpath();
  List newInPath=newConfig.getInpath();
  if (changed(oldInPath,newInPath,false,oldConfig.getOutputDir()))   return true;
  return changed;
}",0.8056930693069307
9334,"private boolean changed(List oldPath,List newPath,boolean checkClassFiles){
  if (oldPath == null)   oldPath=new ArrayList();
  if (newPath == null)   newPath=new ArrayList();
  if (oldPath.size() != newPath.size()) {
    return true;
  }
  for (int i=0; i < oldPath.size(); i++) {
    if (!oldPath.get(i).equals(newPath.get(i))) {
      return true;
    }
    Object o=oldPath.get(i);
    File f=null;
    if (o instanceof String) {
      f=new File((String)o);
    }
 else {
      f=(File)o;
    }
    if (f.exists() && !f.isDirectory() && (f.lastModified() >= lastSuccessfulBuildTime)) {
      return true;
    }
    if (f.exists() && f.isDirectory() && checkClassFiles) {
      return classFileChangedInDirSinceLastBuild(f);
    }
  }
  return false;
}","private boolean changed(List oldPath,List newPath,boolean checkClassFiles,File oldOutputLocation){
  if (oldPath == null)   oldPath=new ArrayList();
  if (newPath == null)   newPath=new ArrayList();
  if (oldPath.size() != newPath.size()) {
    return true;
  }
  for (int i=0; i < oldPath.size(); i++) {
    if (!oldPath.get(i).equals(newPath.get(i))) {
      return true;
    }
    Object o=oldPath.get(i);
    File f=null;
    if (o instanceof String) {
      f=new File((String)o);
    }
 else {
      f=(File)o;
    }
    if (f.exists() && !f.isDirectory() && (f.lastModified() >= lastSuccessfulBuildTime)) {
      return true;
    }
    if (f.exists() && f.isDirectory() && checkClassFiles&& !(f.equals(oldOutputLocation))) {
      boolean b=classFileChangedInDirSinceLastBuild(f);
      if (b && stateListener != null)       stateListener.detectedClassChangeInThisDir(f);
      if (b)       return true;
    }
  }
  return false;
}",0.8842975206611571
9335,"private ResolvedMember getPointcutDeclaration(ReferencePointcut rp,MethodDeclaration declaration){
  World world=((AjLookupEnvironment)declaration.scope.environment()).factory.getWorld();
  TypeX onType=rp.onType;
  if (onType == null) {
    Member member=EclipseFactory.makeResolvedMember(declaration.binding);
    onType=member.getDeclaringType();
  }
  ResolvedMember[] members=onType.getDeclaredPointcuts(world);
  if (members != null) {
    for (int i=0; i < members.length; i++) {
      if (members[i].getName().equals(rp.name)) {
        return members[i];
      }
    }
  }
  return null;
}","private ResolvedMember getPointcutDeclaration(ReferencePointcut rp,MethodDeclaration declaration){
  World world=((AjLookupEnvironment)declaration.scope.environment()).factory.getWorld();
  TypeX onType=rp.onType;
  if (onType == null) {
    if (declaration.binding != null) {
      Member member=EclipseFactory.makeResolvedMember(declaration.binding);
      onType=member.getDeclaringType();
    }
 else {
      return null;
    }
  }
  ResolvedMember[] members=onType.getDeclaredPointcuts(world);
  if (members != null) {
    for (int i=0; i < members.length; i++) {
      if (members[i].getName().equals(rp.name)) {
        return members[i];
      }
    }
  }
  return null;
}",0.9358372456964006
9336,"/** 
 * Need to determine if I'm really a pattern or a reference to a formal We may wish to further optimize the case of pattern vs. non-pattern We will be replaced by what we return
 */
public TypePattern resolveBindings(IScope scope,Bindings bindings,boolean allowBinding,boolean requireExactType){
  if (isStar()) {
    if (annotationPattern == AnnotationTypePattern.ANY) {
      if (dim == 0) {
        return TypePattern.ANY;
      }
    }
 else {
      annotationPattern=annotationPattern.resolveBindings(scope,bindings,allowBinding);
      AnyWithAnnotationTypePattern ret=new AnyWithAnnotationTypePattern(annotationPattern);
      ret.setLocation(sourceContext,start,end);
      return ret;
    }
  }
  annotationPattern=annotationPattern.resolveBindings(scope,bindings,allowBinding);
  String simpleName=maybeGetSimpleName();
  if (simpleName != null) {
    FormalBinding formalBinding=scope.lookupFormal(simpleName);
    if (formalBinding != null) {
      if (bindings == null) {
        scope.message(IMessage.ERROR,this,""String_Node_Str"");
        return this;
      }
      if (!allowBinding) {
        scope.message(IMessage.ERROR,this,""String_Node_Str"");
        return this;
      }
      BindingTypePattern binding=new BindingTypePattern(formalBinding,isVarArgs);
      binding.copyLocationFrom(this);
      bindings.register(binding,scope);
      return binding;
    }
  }
  String cleanName=maybeGetCleanName();
  String originalName=cleanName;
  ResolvedTypeX resolvedTypeInTheWorld=null;
  if (cleanName != null) {
    TypeX type;
    resolvedTypeInTheWorld=scope.getWorld().resolve(TypeX.forName(cleanName),true);
    while ((type=scope.lookupType(cleanName,this)) == ResolvedTypeX.MISSING) {
      int lastDot=cleanName.lastIndexOf('.');
      if (lastDot == -1)       break;
      cleanName=cleanName.substring(0,lastDot) + '$' + cleanName.substring(lastDot + 1);
      if (resolvedTypeInTheWorld == ResolvedTypeX.MISSING)       resolvedTypeInTheWorld=scope.getWorld().resolve(TypeX.forName(cleanName),true);
    }
    if (type == ResolvedTypeX.MISSING) {
      if (requireExactType) {
        if (!allowBinding) {
          scope.getWorld().getMessageHandler().handleMessage(MessageUtil.error(WeaverMessages.format(WeaverMessages.CANT_BIND_TYPE,originalName),getSourceLocation()));
        }
 else         if (scope.getWorld().getLint().invalidAbsoluteTypeName.isEnabled()) {
          scope.getWorld().getLint().invalidAbsoluteTypeName.signal(originalName,getSourceLocation());
        }
        return NO;
      }
 else       if (scope.getWorld().getLint().invalidAbsoluteTypeName.isEnabled()) {
        if (resolvedTypeInTheWorld == ResolvedTypeX.MISSING)         scope.getWorld().getLint().invalidAbsoluteTypeName.signal(originalName,getSourceLocation());
      }
    }
 else {
      if (dim != 0)       type=TypeX.makeArray(type,dim);
      TypePattern ret=new ExactTypePattern(type,includeSubtypes,isVarArgs);
      ret.copyLocationFrom(this);
      return ret;
    }
  }
 else {
    if (requireExactType) {
      scope.getWorld().getMessageHandler().handleMessage(MessageUtil.error(WeaverMessages.format(WeaverMessages.WILDCARD_NOT_ALLOWED),getSourceLocation()));
      return NO;
    }
  }
  importedPrefixes=scope.getImportedPrefixes();
  knownMatches=preMatch(scope.getImportedNames());
  return this;
}","/** 
 * Need to determine if I'm really a pattern or a reference to a formal We may wish to further optimize the case of pattern vs. non-pattern We will be replaced by what we return
 */
public TypePattern resolveBindings(IScope scope,Bindings bindings,boolean allowBinding,boolean requireExactType){
  if (isNamePatternStar()) {
    if (annotationPattern == AnnotationTypePattern.ANY) {
      if (dim == 0) {
        return TypePattern.ANY;
      }
    }
 else {
      annotationPattern=annotationPattern.resolveBindings(scope,bindings,allowBinding);
      AnyWithAnnotationTypePattern ret=new AnyWithAnnotationTypePattern(annotationPattern);
      ret.setLocation(sourceContext,start,end);
      return ret;
    }
  }
  annotationPattern=annotationPattern.resolveBindings(scope,bindings,allowBinding);
  String simpleName=maybeGetSimpleName();
  if (simpleName != null) {
    FormalBinding formalBinding=scope.lookupFormal(simpleName);
    if (formalBinding != null) {
      if (bindings == null) {
        scope.message(IMessage.ERROR,this,""String_Node_Str"");
        return this;
      }
      if (!allowBinding) {
        scope.message(IMessage.ERROR,this,""String_Node_Str"");
        return this;
      }
      BindingTypePattern binding=new BindingTypePattern(formalBinding,isVarArgs);
      binding.copyLocationFrom(this);
      bindings.register(binding,scope);
      return binding;
    }
  }
  String cleanName=maybeGetCleanName();
  String originalName=cleanName;
  ResolvedTypeX resolvedTypeInTheWorld=null;
  if (cleanName != null) {
    TypeX type;
    resolvedTypeInTheWorld=scope.getWorld().resolve(TypeX.forName(cleanName),true);
    while ((type=scope.lookupType(cleanName,this)) == ResolvedTypeX.MISSING) {
      int lastDot=cleanName.lastIndexOf('.');
      if (lastDot == -1)       break;
      cleanName=cleanName.substring(0,lastDot) + '$' + cleanName.substring(lastDot + 1);
      if (resolvedTypeInTheWorld == ResolvedTypeX.MISSING)       resolvedTypeInTheWorld=scope.getWorld().resolve(TypeX.forName(cleanName),true);
    }
    if (type == ResolvedTypeX.MISSING) {
      if (requireExactType) {
        if (!allowBinding) {
          scope.getWorld().getMessageHandler().handleMessage(MessageUtil.error(WeaverMessages.format(WeaverMessages.CANT_BIND_TYPE,originalName),getSourceLocation()));
        }
 else         if (scope.getWorld().getLint().invalidAbsoluteTypeName.isEnabled()) {
          scope.getWorld().getLint().invalidAbsoluteTypeName.signal(originalName,getSourceLocation());
        }
        return NO;
      }
 else       if (scope.getWorld().getLint().invalidAbsoluteTypeName.isEnabled()) {
        if (resolvedTypeInTheWorld == ResolvedTypeX.MISSING)         scope.getWorld().getLint().invalidAbsoluteTypeName.signal(originalName,getSourceLocation());
      }
    }
 else {
      if (dim != 0)       type=TypeX.makeArray(type,dim);
      TypePattern ret=new ExactTypePattern(type,includeSubtypes,isVarArgs);
      ret.copyLocationFrom(this);
      return ret;
    }
  }
 else {
    if (requireExactType) {
      scope.getWorld().getMessageHandler().handleMessage(MessageUtil.error(WeaverMessages.format(WeaverMessages.WILDCARD_NOT_ALLOWED),getSourceLocation()));
      return NO;
    }
  }
  importedPrefixes=scope.getImportedPrefixes();
  knownMatches=preMatch(scope.getImportedNames());
  return this;
}",0.9983550171975476
9337,"/** 
 * @param targetTypeName
 * @return
 */
private boolean matchesExactlyByName(String targetTypeName){
  if (knownMatches == null && importedPrefixes == null) {
    return innerMatchesExactly(targetTypeName);
  }
  if (isStar()) {
    int numDimensionsInTargetType=0;
    if (dim > 0) {
      int index;
      while ((index=targetTypeName.indexOf('[')) != -1) {
        numDimensionsInTargetType++;
        targetTypeName=targetTypeName.substring(index + 1);
      }
      if (numDimensionsInTargetType == dim) {
        return true;
      }
 else {
        return false;
      }
    }
  }
  if (namePatterns.length == 1) {
    for (int i=0, len=knownMatches.length; i < len; i++) {
      if (knownMatches[i].equals(targetTypeName))       return true;
    }
  }
 else {
    for (int i=0, len=knownMatches.length; i < len; i++) {
      String knownPrefix=knownMatches[i] + ""String_Node_Str"";
      if (targetTypeName.startsWith(knownPrefix)) {
        int pos=lastIndexOfDotOrDollar(knownMatches[i]);
        if (innerMatchesExactly(targetTypeName.substring(pos + 1))) {
          return true;
        }
      }
    }
  }
  for (int i=0, len=importedPrefixes.length; i < len; i++) {
    String prefix=importedPrefixes[i];
    if (targetTypeName.startsWith(prefix)) {
      if (innerMatchesExactly(targetTypeName.substring(prefix.length()))) {
        return true;
      }
    }
  }
  return innerMatchesExactly(targetTypeName);
}","/** 
 * @param targetTypeName
 * @return
 */
private boolean matchesExactlyByName(String targetTypeName){
  if (knownMatches == null && importedPrefixes == null) {
    return innerMatchesExactly(targetTypeName);
  }
  if (isNamePatternStar()) {
    int numDimensionsInTargetType=0;
    if (dim > 0) {
      int index;
      while ((index=targetTypeName.indexOf('[')) != -1) {
        numDimensionsInTargetType++;
        targetTypeName=targetTypeName.substring(index + 1);
      }
      if (numDimensionsInTargetType == dim) {
        return true;
      }
 else {
        return false;
      }
    }
  }
  if (namePatterns.length == 1) {
    for (int i=0, len=knownMatches.length; i < len; i++) {
      if (knownMatches[i].equals(targetTypeName))       return true;
    }
  }
 else {
    for (int i=0, len=knownMatches.length; i < len; i++) {
      String knownPrefix=knownMatches[i] + ""String_Node_Str"";
      if (targetTypeName.startsWith(knownPrefix)) {
        int pos=lastIndexOfDotOrDollar(knownMatches[i]);
        if (innerMatchesExactly(targetTypeName.substring(pos + 1))) {
          return true;
        }
      }
    }
  }
  for (int i=0, len=importedPrefixes.length; i < len; i++) {
    String prefix=importedPrefixes[i];
    if (targetTypeName.startsWith(prefix)) {
      if (innerMatchesExactly(targetTypeName.substring(prefix.length()))) {
        return true;
      }
    }
  }
  return innerMatchesExactly(targetTypeName);
}",0.9961712495649148
9338,"public boolean isStar(){
  return namePatterns.length == 1 && namePatterns[0].isAny();
}","public boolean isStar(){
  boolean annPatternStar=annotationPattern == AnnotationTypePattern.ANY;
  return (isNamePatternStar() && annPatternStar);
}",0.5147679324894515
9339,"public FuzzyBoolean matches(ResolvedTypeX[] someArgs){
  int numArgsMatchedByEllipsis=(someArgs.length + ellipsisCount) - typePatterns.length;
  if (numArgsMatchedByEllipsis < 0)   return FuzzyBoolean.NO;
  if ((numArgsMatchedByEllipsis > 0) && (ellipsisCount == 0)) {
    return FuzzyBoolean.NO;
  }
  FuzzyBoolean ret=FuzzyBoolean.YES;
  int argsIndex=0;
  for (int i=0; i < typePatterns.length; i++) {
    if (typePatterns[i] == AnnotationTypePattern.ELLIPSIS) {
      argsIndex+=numArgsMatchedByEllipsis;
    }
 else     if (typePatterns[i] == AnnotationTypePattern.ANY) {
      argsIndex++;
    }
 else {
      ExactAnnotationTypePattern ap=(ExactAnnotationTypePattern)typePatterns[i];
      FuzzyBoolean matches=ap.matches(someArgs[argsIndex]);
      if (matches == FuzzyBoolean.NO) {
        return FuzzyBoolean.MAYBE;
      }
 else {
        argsIndex++;
        ret=ret.and(matches);
      }
    }
  }
  return ret;
}","public FuzzyBoolean matches(ResolvedTypeX[] someArgs){
  int numArgsMatchedByEllipsis=(someArgs.length + ellipsisCount) - typePatterns.length;
  if (numArgsMatchedByEllipsis < 0)   return FuzzyBoolean.NO;
  if ((numArgsMatchedByEllipsis > 0) && (ellipsisCount == 0)) {
    return FuzzyBoolean.NO;
  }
  FuzzyBoolean ret=FuzzyBoolean.YES;
  int argsIndex=0;
  for (int i=0; i < typePatterns.length; i++) {
    if (typePatterns[i] == AnnotationTypePattern.ELLIPSIS) {
      argsIndex+=numArgsMatchedByEllipsis;
    }
 else     if (typePatterns[i] == AnnotationTypePattern.ANY) {
      argsIndex++;
    }
 else {
      ExactAnnotationTypePattern ap=(ExactAnnotationTypePattern)typePatterns[i];
      FuzzyBoolean matches=ap.matchesRuntimeType(someArgs[argsIndex]);
      if (matches == FuzzyBoolean.NO) {
        return FuzzyBoolean.MAYBE;
      }
 else {
        argsIndex++;
        ret=ret.and(matches);
      }
    }
  }
  return ret;
}",0.9940955448201824
9340,"protected FuzzyBoolean matchInternal(Shadow shadow){
  if (!couldMatch(shadow))   return FuzzyBoolean.NO;
  ResolvedTypeX toMatchAgainst=(isThis ? shadow.getThisType() : shadow.getTargetType()).resolve(shadow.getIWorld());
  annotationTypePattern.resolve(shadow.getIWorld());
  if (annotationTypePattern.matches(toMatchAgainst).alwaysTrue()) {
    return FuzzyBoolean.YES;
  }
 else {
    return FuzzyBoolean.MAYBE;
  }
}","protected FuzzyBoolean matchInternal(Shadow shadow){
  if (!couldMatch(shadow))   return FuzzyBoolean.NO;
  ResolvedTypeX toMatchAgainst=(isThis ? shadow.getThisType() : shadow.getTargetType()).resolve(shadow.getIWorld());
  annotationTypePattern.resolve(shadow.getIWorld());
  if (annotationTypePattern.matchesRuntimeType(toMatchAgainst).alwaysTrue()) {
    return FuzzyBoolean.YES;
  }
 else {
    return FuzzyBoolean.MAYBE;
  }
}",0.9871043376318874
9341,"/** 
 * Causes the aspect instance to be *set* for later retrievable through localAspectof()/aspectOf()
 */
public void weavePerTypeWithinAspectInitialization(final BcelAdvice munger,TypeX t){
  final InstructionFactory fact=getFactory();
  InstructionList entryInstructions=new InstructionList();
  InstructionList entrySuccessInstructions=new InstructionList();
  BcelObjectType aspectType=BcelWorld.getBcelObjectType(munger.getConcreteAspect());
  String aspectname=munger.getConcreteAspect().getName();
  String ptwField=NameMangler.perTypeWithinFieldForTarget(munger.getConcreteAspect());
  entrySuccessInstructions.append(new PUSH(fact.getConstantPool(),t.getName()));
  entrySuccessInstructions.append(fact.createInvoke(aspectname,""String_Node_Str"",new ObjectType(aspectname),new Type[]{new ObjectType(""String_Node_Str"")},Constants.INVOKESTATIC));
  entrySuccessInstructions.append(fact.createPutStatic(t.getName(),ptwField,new ObjectType(aspectname)));
  entryInstructions.append(entrySuccessInstructions);
  range.insert(entryInstructions,Range.InsideBefore);
}","/** 
 * Causes the aspect instance to be *set* for later retrievable through localAspectof()/aspectOf()
 */
public void weavePerTypeWithinAspectInitialization(final BcelAdvice munger,TypeX t){
  if (t.isInterface(world))   return;
  final InstructionFactory fact=getFactory();
  InstructionList entryInstructions=new InstructionList();
  InstructionList entrySuccessInstructions=new InstructionList();
  BcelObjectType aspectType=BcelWorld.getBcelObjectType(munger.getConcreteAspect());
  String aspectname=munger.getConcreteAspect().getName();
  String ptwField=NameMangler.perTypeWithinFieldForTarget(munger.getConcreteAspect());
  entrySuccessInstructions.append(new PUSH(fact.getConstantPool(),t.getName()));
  entrySuccessInstructions.append(fact.createInvoke(aspectname,""String_Node_Str"",new ObjectType(aspectname),new Type[]{new ObjectType(""String_Node_Str"")},Constants.INVOKESTATIC));
  entrySuccessInstructions.append(fact.createPutStatic(t.getName(),ptwField,new ObjectType(aspectname)));
  entryInstructions.append(entrySuccessInstructions);
  range.insert(entryInstructions,Range.InsideBefore);
}",0.9825528007346188
9342,"/** 
 * Populate options in a build configuration, using the Ajde BuildOptionsAdapter. Added by AMC 01.20.2003, bugzilla #29769
 */
private static boolean configureBuildOptions(AjBuildConfig config,BuildOptionsAdapter options,IMessageHandler handler){
  LangUtil.throwIaxIfNull(options,""String_Node_Str"");
  LangUtil.throwIaxIfNull(config,""String_Node_Str"");
  Map optionsToSet=new HashMap();
  LangUtil.throwIaxIfNull(optionsToSet,""String_Node_Str"");
  if (options.getSourceOnePointFourMode()) {
    optionsToSet.put(CompilerOptions.OPTION_Compliance,CompilerOptions.VERSION_1_4);
    optionsToSet.put(CompilerOptions.OPTION_Source,CompilerOptions.VERSION_1_4);
  }
  String enc=options.getCharacterEncoding();
  if (!LangUtil.isEmpty(enc)) {
    optionsToSet.put(CompilerOptions.OPTION_Encoding,enc);
  }
  String compliance=options.getComplianceLevel();
  if (!LangUtil.isEmpty(compliance)) {
    String version=CompilerOptions.VERSION_1_4;
    if (compliance.equals(BuildOptionsAdapter.VERSION_13)) {
      version=CompilerOptions.VERSION_1_3;
    }
    optionsToSet.put(CompilerOptions.OPTION_Compliance,version);
    optionsToSet.put(CompilerOptions.OPTION_Source,version);
  }
  String sourceLevel=options.getSourceCompatibilityLevel();
  if (!LangUtil.isEmpty(sourceLevel)) {
    String slVersion=CompilerOptions.VERSION_1_4;
    if (sourceLevel.equals(BuildOptionsAdapter.VERSION_13)) {
      slVersion=CompilerOptions.VERSION_1_3;
    }
    String setCompliance=(String)optionsToSet.get(CompilerOptions.OPTION_Compliance);
    if (!(setCompliance.equals(CompilerOptions.VERSION_1_4) && slVersion.equals(CompilerOptions.VERSION_1_3))) {
      optionsToSet.put(CompilerOptions.OPTION_Source,slVersion);
    }
  }
  Set warnings=options.getWarnings();
  if (!LangUtil.isEmpty(warnings)) {
    disableWarnings(optionsToSet);
    enableWarnings(optionsToSet,warnings);
  }
 else   if (warnings == null) {
    enableWarnings(optionsToSet,DEFAULT__AJDE_WARNINGS);
  }
  Set debugOptions=options.getDebugLevel();
  if (!LangUtil.isEmpty(debugOptions)) {
    boolean sourceLine=false;
    boolean varAttr=false;
    boolean lineNo=false;
    Iterator it=debugOptions.iterator();
    while (it.hasNext()) {
      String debug=(String)it.next();
      if (debug.equals(BuildOptionsAdapter.DEBUG_ALL)) {
        sourceLine=true;
        varAttr=true;
        lineNo=true;
      }
 else       if (debug.equals(BuildOptionsAdapter.DEBUG_LINES)) {
        lineNo=true;
      }
 else       if (debug.equals(BuildOptionsAdapter.DEBUG_SOURCE)) {
        sourceLine=true;
      }
 else       if (debug.equals(BuildOptionsAdapter.DEBUG_VARS)) {
        varAttr=true;
      }
    }
    if (sourceLine)     optionsToSet.put(CompilerOptions.OPTION_SourceFileAttribute,CompilerOptions.GENERATE);
    if (varAttr)     optionsToSet.put(CompilerOptions.OPTION_LocalVariableAttribute,CompilerOptions.GENERATE);
    if (lineNo)     optionsToSet.put(CompilerOptions.OPTION_LineNumberAttribute,CompilerOptions.GENERATE);
  }
  if (options.getPreserveAllLocals()) {
    optionsToSet.put(CompilerOptions.OPTION_PreserveUnusedLocal,CompilerOptions.PRESERVE);
  }
  if (!config.isIncrementalMode() && options.getIncrementalMode()) {
    config.setIncrementalMode(true);
  }
  config.getOptions().set(optionsToSet);
  String toAdd=options.getNonStandardOptions();
  return LangUtil.isEmpty(toAdd) ? true : configureNonStandardOptions(config,toAdd,handler);
}","/** 
 * Populate options in a build configuration, using the Ajde BuildOptionsAdapter. Added by AMC 01.20.2003, bugzilla #29769
 */
private static boolean configureBuildOptions(AjBuildConfig config,BuildOptionsAdapter options,IMessageHandler handler){
  LangUtil.throwIaxIfNull(options,""String_Node_Str"");
  LangUtil.throwIaxIfNull(config,""String_Node_Str"");
  Map optionsToSet=new HashMap();
  LangUtil.throwIaxIfNull(optionsToSet,""String_Node_Str"");
  if (options.getSourceCompatibilityLevel() != null && options.getSourceCompatibilityLevel().equals(CompilerOptions.VERSION_1_5)) {
    optionsToSet.put(CompilerOptions.OPTION_Compliance,CompilerOptions.VERSION_1_5);
    optionsToSet.put(CompilerOptions.OPTION_Source,CompilerOptions.VERSION_1_5);
  }
 else   if (options.getSourceOnePointFourMode() || options.getSourceCompatibilityLevel() != null && options.getSourceCompatibilityLevel().equals(CompilerOptions.VERSION_1_4)) {
    optionsToSet.put(CompilerOptions.OPTION_Compliance,CompilerOptions.VERSION_1_4);
    optionsToSet.put(CompilerOptions.OPTION_Source,CompilerOptions.VERSION_1_4);
  }
  String enc=options.getCharacterEncoding();
  if (!LangUtil.isEmpty(enc)) {
    optionsToSet.put(CompilerOptions.OPTION_Encoding,enc);
  }
  String compliance=options.getComplianceLevel();
  if (!LangUtil.isEmpty(compliance)) {
    String version=CompilerOptions.VERSION_1_4;
    if (compliance.equals(BuildOptionsAdapter.VERSION_13)) {
      version=CompilerOptions.VERSION_1_3;
    }
    optionsToSet.put(CompilerOptions.OPTION_Compliance,version);
    optionsToSet.put(CompilerOptions.OPTION_Source,version);
  }
  String sourceLevel=options.getSourceCompatibilityLevel();
  if (!LangUtil.isEmpty(sourceLevel)) {
    String slVersion=CompilerOptions.VERSION_1_4;
    if (sourceLevel.equals(BuildOptionsAdapter.VERSION_13)) {
      slVersion=CompilerOptions.VERSION_1_3;
    }
    if (sourceLevel.equals(CompilerOptions.VERSION_1_5)) {
      optionsToSet.put(CompilerOptions.OPTION_Source,CompilerOptions.VERSION_1_5);
    }
 else {
      String setCompliance=(String)optionsToSet.get(CompilerOptions.OPTION_Compliance);
      if (!(setCompliance.equals(CompilerOptions.VERSION_1_4) && slVersion.equals(CompilerOptions.VERSION_1_3))) {
        optionsToSet.put(CompilerOptions.OPTION_Source,slVersion);
      }
    }
  }
  Set warnings=options.getWarnings();
  if (!LangUtil.isEmpty(warnings)) {
    disableWarnings(optionsToSet);
    enableWarnings(optionsToSet,warnings);
  }
 else   if (warnings == null) {
    enableWarnings(optionsToSet,DEFAULT__AJDE_WARNINGS);
  }
  Set debugOptions=options.getDebugLevel();
  if (!LangUtil.isEmpty(debugOptions)) {
    boolean sourceLine=false;
    boolean varAttr=false;
    boolean lineNo=false;
    Iterator it=debugOptions.iterator();
    while (it.hasNext()) {
      String debug=(String)it.next();
      if (debug.equals(BuildOptionsAdapter.DEBUG_ALL)) {
        sourceLine=true;
        varAttr=true;
        lineNo=true;
      }
 else       if (debug.equals(BuildOptionsAdapter.DEBUG_LINES)) {
        lineNo=true;
      }
 else       if (debug.equals(BuildOptionsAdapter.DEBUG_SOURCE)) {
        sourceLine=true;
      }
 else       if (debug.equals(BuildOptionsAdapter.DEBUG_VARS)) {
        varAttr=true;
      }
    }
    if (sourceLine)     optionsToSet.put(CompilerOptions.OPTION_SourceFileAttribute,CompilerOptions.GENERATE);
    if (varAttr)     optionsToSet.put(CompilerOptions.OPTION_LocalVariableAttribute,CompilerOptions.GENERATE);
    if (lineNo)     optionsToSet.put(CompilerOptions.OPTION_LineNumberAttribute,CompilerOptions.GENERATE);
  }
  if (options.getPreserveAllLocals()) {
    optionsToSet.put(CompilerOptions.OPTION_PreserveUnusedLocal,CompilerOptions.PRESERVE);
  }
  if (!config.isIncrementalMode() && options.getIncrementalMode()) {
    config.setIncrementalMode(true);
  }
  config.getOptions().set(optionsToSet);
  String toAdd=options.getNonStandardOptions();
  return LangUtil.isEmpty(toAdd) ? true : configureNonStandardOptions(config,toAdd,handler);
}",0.9025174076057848
9343,"public void saveOptions() throws IOException {
  AjdeUIManager.getDefault().getBuildOptions().setSourceOnePointFourMode(assertions_checkBox.isSelected());
  AjdeUIManager.getDefault().getBuildOptions().setPreprocessMode(preprocess_checkBox.isSelected());
  AjdeUIManager.getDefault().getBuildOptions().setUseJavacMode(useJavac_checkBox.isSelected());
  AjdeUIManager.getDefault().getBuildOptions().setIncrementalMode(incremental_checkBox.isSelected());
  AjdeUIManager.getDefault().getBuildOptions().setNonStandardOptions(nonStandard_field.getText());
  AjdeUIManager.getDefault().getBuildOptions().setWorkingDir(workingDir_field.getText());
}","public void saveOptions() throws IOException {
  if (oneFive_checkBox.isSelected()) {
    AjdeUIManager.getDefault().getBuildOptions().setSourceCompatibilityLevel(CompilerOptions.VERSION_1_5);
  }
 else   if (assertions_checkBox.isSelected()) {
    AjdeUIManager.getDefault().getBuildOptions().setSourceOnePointFourMode(true);
    AjdeUIManager.getDefault().getBuildOptions().setSourceCompatibilityLevel(CompilerOptions.VERSION_1_4);
  }
 else {
    AjdeUIManager.getDefault().getBuildOptions().setSourceCompatibilityLevel(CompilerOptions.VERSION_1_3);
  }
  AjdeUIManager.getDefault().getBuildOptions().setPreprocessMode(preprocess_checkBox.isSelected());
  AjdeUIManager.getDefault().getBuildOptions().setUseJavacMode(useJavac_checkBox.isSelected());
  AjdeUIManager.getDefault().getBuildOptions().setIncrementalMode(incremental_checkBox.isSelected());
  AjdeUIManager.getDefault().getBuildOptions().setNonStandardOptions(nonStandard_field.getText());
  AjdeUIManager.getDefault().getBuildOptions().setWorkingDir(workingDir_field.getText());
}",0.5296208530805687
9344,"private void jbInit() throws Exception {
  titledBorder1=new TitledBorder(BorderFactory.createEtchedBorder(Color.white,new Color(156,156,158)),""String_Node_Str"");
  border3=BorderFactory.createCompoundBorder(new TitledBorder(BorderFactory.createEtchedBorder(Color.white,new Color(156,156,158)),""String_Node_Str""),BorderFactory.createEmptyBorder(5,5,5,5));
  border4=BorderFactory.createEtchedBorder(Color.white,new Color(156,156,158));
  border2=BorderFactory.createCompoundBorder(titledBorder1,BorderFactory.createEmptyBorder(5,5,5,5));
  titledBorder1.setTitle(""String_Node_Str"");
  titledBorder1.setTitleFont(new java.awt.Font(""String_Node_Str"",0,11));
  this.setLayout(borderLayout6);
  compileOptions_panel1.setLayout(borderLayout8);
  build_panel1.setLayout(borderLayout5);
  build_panel1.setFont(new java.awt.Font(""String_Node_Str"",0,11));
  build_panel1.setBorder(border1);
  build_panel1.setMaximumSize(new Dimension(2147483647,109));
  workingDir_field.setFont(new java.awt.Font(""String_Node_Str"",0,11));
  workingDir_field.setMinimumSize(new Dimension(200,21));
  workingDir_field.setPreferredSize(new Dimension(350,21));
  jPanel2.setLayout(borderLayout3);
  jPanel1.setLayout(borderLayout2);
  build_panel.setLayout(borderLayout4);
  build_panel.setBorder(border2);
  nonStandard_field.setFont(new java.awt.Font(""String_Node_Str"",0,11));
  nonStandard_field.setMinimumSize(new Dimension(200,21));
  nonStandard_field.setPreferredSize(new Dimension(350,21));
  compileOptions_panel.setLayout(borderLayout1);
  nonStandard_label.setText(""String_Node_Str"");
  nonStandard_label.setFont(new java.awt.Font(""String_Node_Str"",0,11));
  nonStandard_label.setPreferredSize(new Dimension(80,16));
  nonStandard_label.setToolTipText(""String_Node_Str"");
  jPanel3.setLayout(borderLayout7);
  workingDir_label.setFont(new java.awt.Font(""String_Node_Str"",0,11));
  workingDir_label.setPreferredSize(new Dimension(80,16));
  workingDir_label.setText(""String_Node_Str"");
  incrementalNote.setBackground(AjdeWidgetStyles.DEFAULT_BACKGROUND_COLOR);
  incrementalNote.setFont(new java.awt.Font(""String_Node_Str"",0,11));
  incrementalNote.setEditable(false);
  incrementalNote.setText(INCREMENTAL_NOTE);
  spacer_label.setText(""String_Node_Str"");
  assertions_checkBox.setFont(new java.awt.Font(""String_Node_Str"",0,11));
  assertions_checkBox.setText(""String_Node_Str"");
  incremental_checkBox.setText(""String_Node_Str"");
  incremental_checkBox.setToolTipText(""String_Node_Str"");
  incremental_checkBox.setFont(new java.awt.Font(""String_Node_Str"",0,11));
  useJavac_checkBox.setText(""String_Node_Str"");
  useJavac_checkBox.setFont(new java.awt.Font(""String_Node_Str"",0,11));
  preprocess_checkBox.setFont(new java.awt.Font(""String_Node_Str"",0,11));
  preprocess_checkBox.setToolTipText(""String_Node_Str"");
  preprocess_checkBox.setText(""String_Node_Str"");
  spacer_label1.setText(""String_Node_Str"");
  this.add(jPanel3,BorderLayout.NORTH);
  jPanel2.add(workingDir_label,BorderLayout.CENTER);
  jPanel2.add(workingDir_field,BorderLayout.EAST);
  compileOptions_panel.add(options_box2,BorderLayout.CENTER);
  options_box2.add(incrementalNote,null);
  options_box2.add(spacer_label1,null);
  compileOptions_panel.add(options_box,BorderLayout.NORTH);
  options_box.add(assertions_checkBox,null);
  options_box.add(preprocess_checkBox,null);
  options_box.add(useJavac_checkBox,null);
  options_box.add(incremental_checkBox,null);
  options_box.add(spacer_label,null);
  fields_box.add(jPanel1,null);
  fields_box.add(jPanel2,null);
  jPanel1.add(nonStandard_label,BorderLayout.CENTER);
  jPanel1.add(nonStandard_field,BorderLayout.EAST);
  compileOptions_panel.add(fields_box,BorderLayout.SOUTH);
  jPanel3.add(build_panel,BorderLayout.CENTER);
  build_panel.add(compileOptions_panel,BorderLayout.NORTH);
  jPanel3.add(build_panel1,BorderLayout.SOUTH);
  build_panel1.add(compileOptions_panel1,BorderLayout.NORTH);
  compileOptions_panel1.add(options_box1,BorderLayout.NORTH);
  this.add(jPanel4,BorderLayout.CENTER);
}","private void jbInit() throws Exception {
  titledBorder1=new TitledBorder(BorderFactory.createEtchedBorder(Color.white,new Color(156,156,158)),""String_Node_Str"");
  border3=BorderFactory.createCompoundBorder(new TitledBorder(BorderFactory.createEtchedBorder(Color.white,new Color(156,156,158)),""String_Node_Str""),BorderFactory.createEmptyBorder(5,5,5,5));
  border4=BorderFactory.createEtchedBorder(Color.white,new Color(156,156,158));
  border2=BorderFactory.createCompoundBorder(titledBorder1,BorderFactory.createEmptyBorder(5,5,5,5));
  titledBorder1.setTitle(""String_Node_Str"");
  titledBorder1.setTitleFont(new java.awt.Font(""String_Node_Str"",0,11));
  this.setLayout(borderLayout6);
  compileOptions_panel1.setLayout(borderLayout8);
  build_panel1.setLayout(borderLayout5);
  build_panel1.setFont(new java.awt.Font(""String_Node_Str"",0,11));
  build_panel1.setBorder(border1);
  build_panel1.setMaximumSize(new Dimension(2147483647,109));
  workingDir_field.setFont(new java.awt.Font(""String_Node_Str"",0,11));
  workingDir_field.setMinimumSize(new Dimension(200,21));
  workingDir_field.setPreferredSize(new Dimension(350,21));
  jPanel2.setLayout(borderLayout3);
  jPanel1.setLayout(borderLayout2);
  build_panel.setLayout(borderLayout4);
  build_panel.setBorder(border2);
  nonStandard_field.setFont(new java.awt.Font(""String_Node_Str"",0,11));
  nonStandard_field.setMinimumSize(new Dimension(200,21));
  nonStandard_field.setPreferredSize(new Dimension(350,21));
  compileOptions_panel.setLayout(borderLayout1);
  nonStandard_label.setText(""String_Node_Str"");
  nonStandard_label.setFont(new java.awt.Font(""String_Node_Str"",0,11));
  nonStandard_label.setPreferredSize(new Dimension(80,16));
  nonStandard_label.setToolTipText(""String_Node_Str"");
  jPanel3.setLayout(borderLayout7);
  workingDir_label.setFont(new java.awt.Font(""String_Node_Str"",0,11));
  workingDir_label.setPreferredSize(new Dimension(80,16));
  workingDir_label.setText(""String_Node_Str"");
  incrementalNote.setBackground(AjdeWidgetStyles.DEFAULT_BACKGROUND_COLOR);
  incrementalNote.setFont(new java.awt.Font(""String_Node_Str"",0,11));
  incrementalNote.setEditable(false);
  incrementalNote.setText(INCREMENTAL_NOTE);
  spacer_label.setText(""String_Node_Str"");
  assertions_checkBox.setFont(new java.awt.Font(""String_Node_Str"",0,11));
  assertions_checkBox.setText(""String_Node_Str"");
  oneFive_checkBox.setFont(new java.awt.Font(""String_Node_Str"",0,11));
  oneFive_checkBox.setText(""String_Node_Str"");
  incremental_checkBox.setText(""String_Node_Str"");
  incremental_checkBox.setToolTipText(""String_Node_Str"");
  incremental_checkBox.setFont(new java.awt.Font(""String_Node_Str"",0,11));
  useJavac_checkBox.setText(""String_Node_Str"");
  useJavac_checkBox.setFont(new java.awt.Font(""String_Node_Str"",0,11));
  preprocess_checkBox.setFont(new java.awt.Font(""String_Node_Str"",0,11));
  preprocess_checkBox.setToolTipText(""String_Node_Str"");
  preprocess_checkBox.setText(""String_Node_Str"");
  spacer_label1.setText(""String_Node_Str"");
  this.add(jPanel3,BorderLayout.NORTH);
  jPanel2.add(workingDir_label,BorderLayout.CENTER);
  jPanel2.add(workingDir_field,BorderLayout.EAST);
  compileOptions_panel.add(options_box2,BorderLayout.CENTER);
  options_box2.add(incrementalNote,null);
  options_box2.add(spacer_label1,null);
  compileOptions_panel.add(options_box,BorderLayout.NORTH);
  options_box.add(assertions_checkBox,null);
  options_box.add(oneFive_checkBox,null);
  options_box.add(preprocess_checkBox,null);
  options_box.add(useJavac_checkBox,null);
  options_box.add(incremental_checkBox,null);
  options_box.add(spacer_label,null);
  fields_box.add(jPanel1,null);
  fields_box.add(jPanel2,null);
  jPanel1.add(nonStandard_label,BorderLayout.CENTER);
  jPanel1.add(nonStandard_field,BorderLayout.EAST);
  compileOptions_panel.add(fields_box,BorderLayout.SOUTH);
  jPanel3.add(build_panel,BorderLayout.CENTER);
  build_panel.add(compileOptions_panel,BorderLayout.NORTH);
  jPanel3.add(build_panel1,BorderLayout.SOUTH);
  build_panel1.add(compileOptions_panel1,BorderLayout.NORTH);
  compileOptions_panel1.add(options_box1,BorderLayout.NORTH);
  this.add(jPanel4,BorderLayout.CENTER);
}",0.9804353142577648
9345,"public void loadOptions() throws IOException {
  assertions_checkBox.setSelected(Ajde.getDefault().getBuildManager().getBuildOptions().getSourceOnePointFourMode());
  preprocess_checkBox.setSelected(Ajde.getDefault().getBuildManager().getBuildOptions().getPreprocessMode());
  useJavac_checkBox.setSelected(Ajde.getDefault().getBuildManager().getBuildOptions().getUseJavacMode());
  incremental_checkBox.setSelected(Ajde.getDefault().getBuildManager().getBuildOptions().getIncrementalMode());
  nonStandard_field.setText(Ajde.getDefault().getBuildManager().getBuildOptions().getNonStandardOptions());
  workingDir_field.setText(Ajde.getDefault().getBuildManager().getBuildOptions().getWorkingOutputPath());
}","public void loadOptions() throws IOException {
  if (Ajde.getDefault().getBuildManager().getBuildOptions().getSourceCompatibilityLevel() != null) {
    oneFive_checkBox.setSelected(Ajde.getDefault().getBuildManager().getBuildOptions().getSourceCompatibilityLevel().equals(CompilerOptions.VERSION_1_5));
  }
  if (Ajde.getDefault().getBuildManager().getBuildOptions().getSourceCompatibilityLevel() != null) {
    assertions_checkBox.setSelected(Ajde.getDefault().getBuildManager().getBuildOptions().getSourceCompatibilityLevel().equals(CompilerOptions.VERSION_1_4));
  }
  preprocess_checkBox.setSelected(Ajde.getDefault().getBuildManager().getBuildOptions().getPreprocessMode());
  useJavac_checkBox.setSelected(Ajde.getDefault().getBuildManager().getBuildOptions().getUseJavacMode());
  incremental_checkBox.setSelected(Ajde.getDefault().getBuildManager().getBuildOptions().getIncrementalMode());
  nonStandard_field.setText(Ajde.getDefault().getBuildManager().getBuildOptions().getNonStandardOptions());
  workingDir_field.setText(Ajde.getDefault().getBuildManager().getBuildOptions().getWorkingOutputPath());
}",0.7270730367929709
9346,"public boolean matches(ResolvedTypeX matchType,ResolvedTypeX aspectType){
  return isWithinType(matchType).alwaysTrue();
}","public boolean matches(ResolvedTypeX matchType,ResolvedTypeX aspectType){
  return isWithinType(matchType).alwaysTrue() && !matchType.isInterface();
}",0.8970588235294118
9347,"public boolean matches(ResolvedTypeX matchType,ResolvedTypeX aspectType){
  return testPointcut.getTypePattern().matches(matchType,TypePattern.STATIC).alwaysTrue();
}","public boolean matches(ResolvedTypeX matchType,ResolvedTypeX aspectType){
  return isWithinType(matchType).alwaysTrue();
}",0.8125
9348,"public PerClause concretize(ResolvedTypeX inAspect){
  PerTypeWithin ret=new PerTypeWithin(typePattern);
  ret.copyLocationFrom(this);
  ret.inAspect=inAspect;
  if (inAspect.isAbstract())   return ret;
  World world=inAspect.getWorld();
  SignaturePattern sigpat=new SignaturePattern(Member.STATIC_INITIALIZATION,ModifiersPattern.ANY,TypePattern.ANY,typePattern,NamePattern.ANY,TypePatternList.ANY,ThrowsPattern.ANY,AnnotationTypePattern.ANY);
  Pointcut testPc=new KindedPointcut(Shadow.StaticInitialization,sigpat);
  Pointcut testPc2=new WithinPointcut(typePattern);
  inAspect.crosscuttingMembers.addConcreteShadowMunger(Advice.makePerTypeWithinEntry(world,testPc,inAspect));
  ResolvedTypeMunger munger=new PerTypeWithinTargetTypeMunger(inAspect,ret);
  inAspect.crosscuttingMembers.addTypeMunger(world.concreteTypeMunger(munger,inAspect));
  return ret;
}","public PerClause concretize(ResolvedTypeX inAspect){
  PerTypeWithin ret=new PerTypeWithin(typePattern);
  ret.copyLocationFrom(this);
  ret.inAspect=inAspect;
  if (inAspect.isAbstract())   return ret;
  World world=inAspect.getWorld();
  SignaturePattern sigpat=new SignaturePattern(Member.STATIC_INITIALIZATION,ModifiersPattern.ANY,TypePattern.ANY,TypePattern.ANY,NamePattern.ANY,TypePatternList.ANY,ThrowsPattern.ANY,AnnotationTypePattern.ANY);
  Pointcut staticInitStar=new KindedPointcut(Shadow.StaticInitialization,sigpat);
  Pointcut withinTp=new WithinPointcut(typePattern);
  Pointcut andPcut=new AndPointcut(staticInitStar,withinTp);
  inAspect.crosscuttingMembers.addConcreteShadowMunger(Advice.makePerTypeWithinEntry(world,andPcut,inAspect));
  ResolvedTypeMunger munger=new PerTypeWithinTargetTypeMunger(inAspect,ret);
  inAspect.crosscuttingMembers.addTypeMunger(world.concreteTypeMunger(munger,inAspect));
  return ret;
}",0.8593663146192329
9349,"static void insertDeclarationsDetails(StringBuffer fileBuffer,List decls,String kind,int index){
  int insertIndex=findDetailsIndex(fileBuffer,index);
  String detailsHeading=""String_Node_Str"" + ""String_Node_Str"" + kind.toUpperCase() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ kind+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  fileBuffer.insert(insertIndex,detailsHeading);
  insertIndex+=detailsHeading.length();
  for (int i=0; i < decls.size(); i++) {
    IProgramElement decl=(IProgramElement)decls.get(i);
    String entry=""String_Node_Str"";
    entry+=""String_Node_Str"" + generateHREFName(decl) + ""String_Node_Str"";
    if (kind.equals(""String_Node_Str"")) {
      entry+=""String_Node_Str"" + decl.getName() + ""String_Node_Str"";
      entry+=""String_Node_Str"" + generateAdviceSignatures(decl) + ""String_Node_Str""+ ""String_Node_Str""+ generateDetailsComment(decl)+ ""String_Node_Str""+ generateAffects(decl,false);
    }
 else     if (kind.equals(""String_Node_Str"")) {
      entry+=""String_Node_Str"" + decl.toLabelString() + ""String_Node_Str""+ generateDetailsComment(decl);
    }
 else     if (kind.equals(""String_Node_Str"")) {
      entry+=""String_Node_Str"" + decl.toLabelString() + ""String_Node_Str"";
      entry+=generateIntroductionSignatures(decl,true) + generateAffects(decl,true) + generateDetailsComment(decl);
    }
    if (i != decls.size() - 1) {
      entry+=""String_Node_Str"";
    }
 else {
      entry+=""String_Node_Str"";
    }
    fileBuffer.insert(insertIndex,entry);
    insertIndex+=entry.length();
  }
}","static void insertDeclarationsDetails(StringBuffer fileBuffer,List decls,String kind,int index){
  if (!declsAboveVisibilityExist(decls))   return;
  int insertIndex=findDetailsIndex(fileBuffer,index);
  String detailsHeading=""String_Node_Str"" + ""String_Node_Str"" + kind.toUpperCase() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ kind+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  fileBuffer.insert(insertIndex,detailsHeading);
  insertIndex+=detailsHeading.length();
  for (int i=0; i < decls.size(); i++) {
    IProgramElement decl=(IProgramElement)decls.get(i);
    if (isAboveVisibility(decl)) {
      String entry=""String_Node_Str"";
      entry+=""String_Node_Str"" + generateHREFName(decl) + ""String_Node_Str"";
      if (kind.equals(""String_Node_Str"")) {
        entry+=""String_Node_Str"" + decl.getName() + ""String_Node_Str"";
        entry+=""String_Node_Str"" + generateAdviceSignatures(decl) + ""String_Node_Str""+ ""String_Node_Str""+ generateDetailsComment(decl)+ ""String_Node_Str""+ generateAffects(decl,false);
      }
 else       if (kind.equals(""String_Node_Str"")) {
        entry+=""String_Node_Str"" + decl.toLabelString() + ""String_Node_Str""+ generateDetailsComment(decl);
      }
 else       if (kind.equals(""String_Node_Str"")) {
        entry+=""String_Node_Str"" + decl.toLabelString() + ""String_Node_Str"";
        entry+=generateIntroductionSignatures(decl,true) + generateAffects(decl,true) + generateDetailsComment(decl);
      }
      if (i != decls.size() - 1) {
        entry+=""String_Node_Str"";
      }
 else {
        entry+=""String_Node_Str"";
      }
      fileBuffer.insert(insertIndex,entry);
      insertIndex+=entry.length();
    }
  }
}",0.96016898008449
9350,"static void decorateHTMLFromInputFiles(Hashtable table,File newRootDir,SymbolManager sm,File[] inputFiles,String docModifier) throws IOException {
  rootDir=newRootDir;
  declIDTable=table;
  symbolManager=sm;
  for (int i=0; i < inputFiles.length; i++) {
    decorateHTMLFromDecls(symbolManager.getDeclarations(inputFiles[i].getCanonicalPath()),rootDir.getCanonicalPath() + Config.DIR_SEP_CHAR,docModifier,false);
  }
}","static void decorateHTMLFromInputFiles(Hashtable table,File newRootDir,SymbolManager sm,File[] inputFiles,String docModifier) throws IOException {
  rootDir=newRootDir;
  declIDTable=table;
  symbolManager=sm;
  docVisibilityModifier=docModifier;
  for (int i=0; i < inputFiles.length; i++) {
    decorateHTMLFromDecls(symbolManager.getDeclarations(inputFiles[i].getCanonicalPath()),rootDir.getCanonicalPath() + Config.DIR_SEP_CHAR,docModifier,false);
  }
}",0.9578107183580388
9351,"/** 
 * Skips files that are public in the model but not public in the source, e.g. nested aspects.
 */
static void decorateHTMLFile(File file) throws IOException {
  if (!file.exists())   return;
  System.out.println(""String_Node_Str"" + file.getCanonicalPath() + ""String_Node_Str"");
  BufferedReader reader=new BufferedReader(new FileReader(file));
  StringBuffer fileContents=new StringBuffer();
  String line=reader.readLine();
  while (line != null) {
    fileContents.append(line + ""String_Node_Str"");
    line=reader.readLine();
  }
  boolean isSecond=false;
  int index=0;
  IProgramElement decl;
  while (true) {
    String contents=fileContents.toString();
    int start=contents.indexOf(Config.DECL_ID_STRING,index);
    int end=contents.indexOf(Config.DECL_ID_TERMINATOR,index);
    if (start == -1)     decl=null;
 else     if (end == -1)     throw new Error(""String_Node_Str"");
 else {
      String tid=contents.substring(start + Config.DECL_ID_STRING.length(),end);
      decl=(IProgramElement)declIDTable.get(tid);
      index=start;
    }
    if (decl == null)     break;
    fileContents.delete(start,end + Config.DECL_ID_TERMINATOR.length());
    if (decl.getKind().isType()) {
      isSecond=true;
      addAspectDocumentation(decl,fileContents,index);
    }
 else {
      decorateMemberDocumentation(decl,fileContents,index);
    }
  }
  int classStartIndex=fileContents.toString().indexOf(""String_Node_Str"");
  if (classStartIndex != -1 && fileContents.toString().indexOf(""String_Node_Str"") != -1) {
    int classEndIndex=fileContents.toString().indexOf(""String_Node_Str"",classStartIndex);
    if (classStartIndex != -1 && classEndIndex != -1) {
      String classLine=fileContents.toString().substring(classStartIndex,classEndIndex);
      String aspectLine=""String_Node_Str"" + ""String_Node_Str"" + classLine.substring(11,classLine.length());
      fileContents.delete(classStartIndex,classEndIndex);
      fileContents.insert(classStartIndex,aspectLine);
    }
  }
  file.delete();
  FileOutputStream fos=new FileOutputStream(file);
  fos.write(fileContents.toString().getBytes());
}","/** 
 * Skips files that are public in the model but not public in the source, e.g. nested aspects.
 */
static void decorateHTMLFile(File file) throws IOException {
  if (!file.exists())   return;
  System.out.println(""String_Node_Str"" + file.getCanonicalPath() + ""String_Node_Str"");
  BufferedReader reader=new BufferedReader(new FileReader(file));
  StringBuffer fileContents=new StringBuffer();
  String line=reader.readLine();
  while (line != null) {
    fileContents.append(line + ""String_Node_Str"");
    line=reader.readLine();
  }
  boolean isSecond=false;
  int index=0;
  IProgramElement decl;
  while (true) {
    String contents=fileContents.toString();
    int start=contents.indexOf(Config.DECL_ID_STRING,index);
    int end=contents.indexOf(Config.DECL_ID_TERMINATOR,index);
    if (start == -1)     decl=null;
 else     if (end == -1)     throw new Error(""String_Node_Str"");
 else {
      String tid=contents.substring(start + Config.DECL_ID_STRING.length(),end);
      decl=(IProgramElement)declIDTable.get(tid);
      index=start;
    }
    if (decl == null)     break;
    fileContents.delete(start,end + Config.DECL_ID_TERMINATOR.length());
    if (decl.getKind().isType()) {
      isSecond=true;
      addAspectDocumentation(decl,fileContents,index);
    }
 else {
      decorateMemberDocumentation(decl,fileContents,index);
    }
  }
  int classStartIndex=fileContents.toString().indexOf(""String_Node_Str"");
  int pointcutSummaryIndex=fileContents.toString().indexOf(""String_Node_Str"");
  int adviceSummaryIndex=fileContents.toString().indexOf(""String_Node_Str"");
  if (classStartIndex != -1 && (adviceSummaryIndex != -1 || pointcutSummaryIndex != -1)) {
    int classEndIndex=fileContents.toString().indexOf(""String_Node_Str"",classStartIndex);
    if (classStartIndex != -1 && classEndIndex != -1) {
      String classLine=fileContents.toString().substring(classStartIndex,classEndIndex);
      String aspectLine=""String_Node_Str"" + ""String_Node_Str"" + classLine.substring(11,classLine.length());
      fileContents.delete(classStartIndex,classEndIndex);
      fileContents.insert(classStartIndex,aspectLine);
    }
  }
  file.delete();
  FileOutputStream fos=new FileOutputStream(file);
  fos.write(fileContents.toString().getBytes());
}",0.9413650939074668
9352,"static void insertDeclarationsSummary(StringBuffer fileBuffer,List decls,String kind,int index){
  int insertIndex=findSummaryIndex(fileBuffer,index);
  String tableHead=""String_Node_Str"" + kind.toUpperCase() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ kind+ ""String_Node_Str"";
  fileBuffer.insert(insertIndex,tableHead);
  insertIndex+=tableHead.length();
  for (int i=0; i < decls.size(); i++) {
    IProgramElement decl=(IProgramElement)decls.get(i);
    String comment=generateSummaryComment(decl);
    String entry=""String_Node_Str"";
    if (kind.equals(""String_Node_Str"")) {
      entry+=""String_Node_Str"" + ""String_Node_Str"" + generateHREFName(decl) + ""String_Node_Str""+ ""String_Node_Str""+ generateAdviceSignatures(decl)+ ""String_Node_Str"";
      if (!comment.equals(""String_Node_Str"")) {
        entry+=comment + ""String_Node_Str"";
      }
      entry+=generateAffects(decl,false) + ""String_Node_Str"" + ""String_Node_Str"";
    }
 else     if (kind.equals(""String_Node_Str"")) {
      entry+=""String_Node_Str"" + ""String_Node_Str"" + genAccessibility(decl) + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ generateHREFName(decl)+ ""String_Node_Str""+ decl.toLabelString()+ ""String_Node_Str"";
      if (!comment.equals(""String_Node_Str"")) {
        entry+=comment + ""String_Node_Str"";
      }
      entry+=""String_Node_Str"";
    }
 else     if (kind.equals(""String_Node_Str"")) {
      entry+=""String_Node_Str"" + ""String_Node_Str"" + decl.getModifiers() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ generateHREFName(decl)+ ""String_Node_Str""+ ""String_Node_Str""+ decl.toLabelString()+ ""String_Node_Str""+ generateIntroductionSignatures(decl,false)+ generateAffects(decl,true);
    }
    fileBuffer.insert(insertIndex,entry);
    insertIndex+=entry.length();
  }
  String tableTail=""String_Node_Str"";
  fileBuffer.insert(insertIndex,tableTail);
  insertIndex+=tableTail.length();
}","static void insertDeclarationsSummary(StringBuffer fileBuffer,List decls,String kind,int index){
  if (!declsAboveVisibilityExist(decls))   return;
  int insertIndex=findSummaryIndex(fileBuffer,index);
  String tableHead=""String_Node_Str"" + kind.toUpperCase() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ kind+ ""String_Node_Str"";
  fileBuffer.insert(insertIndex,tableHead);
  insertIndex+=tableHead.length();
  for (int i=0; i < decls.size(); i++) {
    IProgramElement decl=(IProgramElement)decls.get(i);
    if (isAboveVisibility(decl)) {
      String comment=generateSummaryComment(decl);
      String entry=""String_Node_Str"";
      if (kind.equals(""String_Node_Str"")) {
        entry+=""String_Node_Str"" + ""String_Node_Str"" + generateHREFName(decl) + ""String_Node_Str""+ ""String_Node_Str""+ generateAdviceSignatures(decl)+ ""String_Node_Str"";
        if (!comment.equals(""String_Node_Str"")) {
          entry+=comment + ""String_Node_Str"";
        }
        entry+=generateAffects(decl,false) + ""String_Node_Str"" + ""String_Node_Str"";
      }
 else       if (kind.equals(""String_Node_Str"")) {
        entry+=""String_Node_Str"" + ""String_Node_Str"" + genAccessibility(decl) + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ generateHREFName(decl)+ ""String_Node_Str""+ decl.toLabelString()+ ""String_Node_Str"";
        if (!comment.equals(""String_Node_Str"")) {
          entry+=comment + ""String_Node_Str"";
        }
        entry+=""String_Node_Str"";
      }
 else       if (kind.equals(""String_Node_Str"")) {
        entry+=""String_Node_Str"" + ""String_Node_Str"" + decl.getModifiers() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ generateHREFName(decl)+ ""String_Node_Str""+ ""String_Node_Str""+ decl.toLabelString()+ ""String_Node_Str""+ generateIntroductionSignatures(decl,false)+ generateAffects(decl,true);
      }
      fileBuffer.insert(insertIndex,entry);
      insertIndex+=entry.length();
    }
  }
  String tableTail=""String_Node_Str"";
  fileBuffer.insert(insertIndex,tableTail);
  insertIndex+=tableTail.length();
}",0.9671246319921492
9353,"/** 
 * Before attempting to decorate the HTML file we have to verify that it exists, which depends on the documentation visibility specified to c. Depending on docModifier, can document - public: only public - protected: protected and public (default) - package: package protected and public - private: everything
 */
static void decorateHTMLFromDecl(Declaration decl,String base,String docModifier,boolean exceededNestingLevel) throws IOException {
  boolean nestedClass=false;
  if (decl.isType()) {
    boolean decorateFile=true;
    if ((docModifier.equals(""String_Node_Str"")) || (docModifier.equals(""String_Node_Str"") && decl.getModifiers().indexOf(""String_Node_Str"") == -1) || (docModifier.equals(""String_Node_Str"") && (decl.getModifiers().indexOf(""String_Node_Str"") != -1 || decl.getModifiers().indexOf(""String_Node_Str"") != -1))|| (docModifier.equals(""String_Node_Str"") && decl.getModifiers().indexOf(""String_Node_Str"") != -1)) {
      visibleFileList.add(decl.getSignature());
      String packageName=decl.getPackageName();
      String filename=""String_Node_Str"";
      if (packageName != null) {
        int index1=base.lastIndexOf(Config.DIR_SEP_CHAR);
        int index2=base.lastIndexOf(""String_Node_Str"");
        String currFileClass=""String_Node_Str"";
        if (index1 > -1 && index2 > 0 && index1 < index2) {
          currFileClass=base.substring(index1 + 1,index2);
        }
        if (currFileClass.equals(decl.getDeclaringType())) {
          nestedClass=true;
          packageName=packageName.replace('.','/');
          String newBase=""String_Node_Str"";
          if (base.lastIndexOf(Config.DIR_SEP_CHAR) > 0) {
            newBase=base.substring(0,base.lastIndexOf(Config.DIR_SEP_CHAR));
          }
          String signature=constructNestedTypeName(decl.getNode());
          filename=newBase + Config.DIR_SEP_CHAR + packageName+ Config.DIR_SEP_CHAR+ currFileClass+ signature+ ""String_Node_Str"";
        }
 else {
          packageName=packageName.replace('.','/');
          filename=base + packageName + Config.DIR_SEP_CHAR+ decl.getSignature()+ ""String_Node_Str"";
        }
      }
 else {
        filename=base + decl.getSignature() + ""String_Node_Str"";
      }
      if (!exceededNestingLevel) {
        decorateHTMLFile(new File(filename));
        decorateHTMLFromDecls(decl.getDeclarations(),base + decl.getSignature() + ""String_Node_Str"",docModifier,nestedClass);
      }
 else {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + decl.getSignature());
      }
    }
  }
}","/** 
 * Before attempting to decorate the HTML file we have to verify that it exists, which depends on the documentation visibility specified to c. Depending on docModifier, can document - public: only public - protected: protected and public (default) - package: package protected and public - private: everything
 */
static void decorateHTMLFromDecl(Declaration decl,String base,String docModifier,boolean exceededNestingLevel) throws IOException {
  boolean nestedClass=false;
  if (decl.isType()) {
    boolean decorateFile=true;
    if (isAboveVisibility(decl.getNode())) {
      visibleFileList.add(decl.getSignature());
      String packageName=decl.getPackageName();
      String filename=""String_Node_Str"";
      if (packageName != null) {
        int index1=base.lastIndexOf(Config.DIR_SEP_CHAR);
        int index2=base.lastIndexOf(""String_Node_Str"");
        String currFileClass=""String_Node_Str"";
        if (index1 > -1 && index2 > 0 && index1 < index2) {
          currFileClass=base.substring(index1 + 1,index2);
        }
        if (currFileClass.equals(decl.getDeclaringType())) {
          nestedClass=true;
          packageName=packageName.replace('.','/');
          String newBase=""String_Node_Str"";
          if (base.lastIndexOf(Config.DIR_SEP_CHAR) > 0) {
            newBase=base.substring(0,base.lastIndexOf(Config.DIR_SEP_CHAR));
          }
          String signature=constructNestedTypeName(decl.getNode());
          filename=newBase + Config.DIR_SEP_CHAR + packageName+ Config.DIR_SEP_CHAR+ currFileClass+ signature+ ""String_Node_Str"";
        }
 else {
          packageName=packageName.replace('.','/');
          filename=base + packageName + Config.DIR_SEP_CHAR+ decl.getSignature()+ ""String_Node_Str"";
        }
      }
 else {
        filename=base + decl.getSignature() + ""String_Node_Str"";
      }
      if (!exceededNestingLevel) {
        decorateHTMLFile(new File(filename));
        decorateHTMLFromDecls(decl.getDeclarations(),base + decl.getSignature() + ""String_Node_Str"",docModifier,nestedClass);
      }
 else {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + decl.getSignature());
      }
    }
  }
}",0.9098639455782312
9354,"static int findDetailsIndex(StringBuffer fileBuffer,int index){
  String fbs=fileBuffer.toString();
  String MARKER_1=""String_Node_Str"";
  String MARKER_2=""String_Node_Str"";
  String MARKER_3=""String_Node_Str"";
  int index1=fbs.indexOf(MARKER_1,index);
  int index2=fbs.indexOf(MARKER_2,index);
  int index3=fbs.indexOf(MARKER_3,index);
  if (index1 < index2 && index1 < index3) {
    return index1;
  }
 else   if (index2 < index1 && index2 < index3) {
    return index2;
  }
 else {
    return index3;
  }
}","static int findDetailsIndex(StringBuffer fileBuffer,int index){
  String fbs=fileBuffer.toString();
  String MARKER_1=""String_Node_Str"";
  String MARKER_2=""String_Node_Str"";
  String MARKER_3=""String_Node_Str"";
  int index1=fbs.indexOf(MARKER_1,index);
  int index2=fbs.indexOf(MARKER_2,index);
  int index3=fbs.indexOf(MARKER_3,index);
  if (index1 != -1 && index1 < index2 && index1 < index3) {
    return index1;
  }
 else   if (index2 != -1 && index2 < index1 && index2 < index3) {
    return index2;
  }
 else   if (index3 != -1) {
    return index3;
  }
 else {
    return index;
  }
}",0.9254545454545454
9355,"/** 
 * TODO: don't place the summary first.
 */
static int findSummaryIndex(StringBuffer fileBuffer,int index){
  String fbs=fileBuffer.toString();
  String MARKER_1=""String_Node_Str"";
  String MARKER_2=""String_Node_Str"";
  int index1=fbs.indexOf(MARKER_1,index);
  int index2=fbs.indexOf(MARKER_2,index);
  if (index1 < index2) {
    return index1;
  }
 else {
    return index2;
  }
}","/** 
 * TODO: don't place the summary first.
 */
static int findSummaryIndex(StringBuffer fileBuffer,int index){
  String fbs=fileBuffer.toString();
  String MARKER_1=""String_Node_Str"";
  String MARKER_2=""String_Node_Str"";
  int index1=fbs.indexOf(MARKER_1,index);
  int index2=fbs.indexOf(MARKER_2,index);
  if (index1 < index2 && index1 != -1) {
    return index1;
  }
 else   if (index2 != -1) {
    return index2;
  }
 else {
    return index;
  }
}",0.9214285714285714
9356,"public void testCoverage(){
  outdir.delete();
  String[] args={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",outdir.getAbsolutePath(),aspect1.getAbsolutePath(),file0.getAbsolutePath(),file1.getAbsolutePath(),file2.getAbsolutePath(),file3.getAbsolutePath(),file4.getAbsolutePath(),file5.getAbsolutePath(),file6.getAbsolutePath(),file7.getAbsolutePath(),file8.getAbsolutePath(),file9.getAbsolutePath()};
  org.aspectj.tools.ajdoc.Main.main(args);
}","public void testCoverage(){
  outdir.delete();
  String[] args={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",outdir.getAbsolutePath(),aspect1.getAbsolutePath(),file0.getAbsolutePath(),file1.getAbsolutePath(),file2.getAbsolutePath(),file3.getAbsolutePath(),file4.getAbsolutePath(),file5.getAbsolutePath(),file6.getAbsolutePath(),file7.getAbsolutePath(),file8.getAbsolutePath(),file9.getAbsolutePath(),file10.getAbsolutePath()};
  org.aspectj.tools.ajdoc.Main.main(args);
}",0.9742533470648816
9357,"public static Test suite(){
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTest(Ajc150Tests.suite());
  suite.addTest(AccBridgeMethods.suite());
  suite.addTestSuite(CovarianceTests.class);
  suite.addTestSuite(Enums.class);
  suite.addTestSuite(Annotations.class);
  suite.addTestSuite(AnnotationPointcutsTests.class);
  suite.addTestSuite(VarargsTests.class);
  suite.addTestSuite(AnnotationRuntimeTests.class);
  return suite;
}","public static Test suite(){
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTestSuite(MigrationTests.class);
  suite.addTest(Ajc150Tests.suite());
  suite.addTest(AccBridgeMethods.suite());
  suite.addTestSuite(CovarianceTests.class);
  suite.addTestSuite(Enums.class);
  suite.addTestSuite(Annotations.class);
  suite.addTestSuite(AnnotationPointcutsTests.class);
  suite.addTestSuite(VarargsTests.class);
  suite.addTestSuite(AnnotationRuntimeTests.class);
  return suite;
}",0.953091684434968
9358,"public static AdviceKind read(DataInputStream s) throws IOException {
  int key=s.readByte();
switch (key) {
case 1:
    return Before;
case 2:
  return After;
case 3:
return AfterThrowing;
case 4:
return AfterReturning;
case 5:
return Around;
case 6:
return CflowEntry;
case 7:
return CflowBelowEntry;
case 8:
return InterInitializer;
case 9:
return PerCflowEntry;
case 10:
return PerCflowBelowEntry;
case 11:
return PerThisEntry;
case 12:
return PerTargetEntry;
case 13:
return Softener;
}
throw new RuntimeException(""String_Node_Str"" + key);
}","public static AdviceKind read(VersionedDataInputStream s) throws IOException {
  int key=s.readByte();
switch (key) {
case 1:
    return Before;
case 2:
  return After;
case 3:
return AfterThrowing;
case 4:
return AfterReturning;
case 5:
return Around;
case 6:
return CflowEntry;
case 7:
return CflowBelowEntry;
case 8:
return InterInitializer;
case 9:
return PerCflowEntry;
case 10:
return PerCflowBelowEntry;
case 11:
return PerThisEntry;
case 12:
return PerTargetEntry;
case 13:
return Softener;
}
throw new RuntimeException(""String_Node_Str"" + key);
}",0.9918256130790192
9359,"public static EffectiveSignatureAttribute read(DataInputStream s,ISourceContext context) throws IOException {
  return new EffectiveSignatureAttribute(ResolvedMember.readResolvedMember(s,context),Shadow.Kind.read(s),s.readBoolean());
}","public static EffectiveSignatureAttribute read(VersionedDataInputStream s,ISourceContext context) throws IOException {
  return new EffectiveSignatureAttribute(ResolvedMember.readResolvedMember(s,context),Shadow.Kind.read(s),s.readBoolean());
}",0.9812108559498957
9360,"public static ResolvedPointcutDefinition read(DataInputStream s,ISourceContext context) throws IOException {
  return new ResolvedPointcutDefinition(TypeX.read(s),s.readInt(),s.readUTF(),TypeX.readArray(s),Pointcut.read(s,context));
}","public static ResolvedPointcutDefinition read(VersionedDataInputStream s,ISourceContext context) throws IOException {
  return new ResolvedPointcutDefinition(TypeX.read(s),s.readInt(),s.readUTF(),TypeX.readArray(s),Pointcut.read(s,context));
}",0.981132075471698
9361,"public static final WeaverStateInfo read(DataInputStream s,ISourceContext context) throws IOException {
  byte b=s.readByte();
  boolean isReweavable=((b & REWEAVABLE_BIT) != 0);
  if (isReweavable)   b=(byte)(b - REWEAVABLE_BIT);
  boolean isReweavableCompressed=((b & REWEAVABLE_COMPRESSION_BIT) != 0);
  if (isReweavableCompressed)   b=(byte)(b - REWEAVABLE_COMPRESSION_BIT);
switch (b) {
case UNTOUCHED:
    throw new RuntimeException(""String_Node_Str"");
case WOVEN:
  return new WeaverStateInfo(Collections.EMPTY_LIST,true,isReweavable,isReweavableCompressed);
case EXTENDED:
int n=s.readShort();
List l=new ArrayList();
for (int i=0; i < n; i++) {
TypeX aspectType=TypeX.read(s);
ResolvedTypeMunger typeMunger=ResolvedTypeMunger.read(s,context);
l.add(new Entry(aspectType,typeMunger));
}
WeaverStateInfo wsi=new WeaverStateInfo(l,false,isReweavable,isReweavableCompressed);
readAnyReweavableData(wsi,s);
return wsi;
}
throw new RuntimeException(""String_Node_Str"" + b);
}","public static final WeaverStateInfo read(VersionedDataInputStream s,ISourceContext context) throws IOException {
  byte b=s.readByte();
  boolean isReweavable=((b & REWEAVABLE_BIT) != 0);
  if (isReweavable)   b=(byte)(b - REWEAVABLE_BIT);
  boolean isReweavableCompressed=((b & REWEAVABLE_COMPRESSION_BIT) != 0);
  if (isReweavableCompressed)   b=(byte)(b - REWEAVABLE_COMPRESSION_BIT);
switch (b) {
case UNTOUCHED:
    throw new RuntimeException(""String_Node_Str"");
case WOVEN:
  return new WeaverStateInfo(Collections.EMPTY_LIST,true,isReweavable,isReweavableCompressed);
case EXTENDED:
int n=s.readShort();
List l=new ArrayList();
for (int i=0; i < n; i++) {
TypeX aspectType=TypeX.read(s);
ResolvedTypeMunger typeMunger=ResolvedTypeMunger.read(s,context);
l.add(new Entry(aspectType,typeMunger));
}
WeaverStateInfo wsi=new WeaverStateInfo(l,false,isReweavable,isReweavableCompressed);
readAnyReweavableData(wsi,s);
return wsi;
}
throw new RuntimeException(""String_Node_Str"" + b);
}",0.9954151808456444
9362,"public static List readAjAttributes(Attribute[] as,ISourceContext context,IMessageHandler msgHandler){
  List l=new ArrayList();
  for (int i=as.length - 1; i >= 0; i--) {
    Attribute a=as[i];
    if (a instanceof Unknown) {
      Unknown u=(Unknown)a;
      String name=u.getName();
      if (name.startsWith(AjAttribute.AttributePrefix)) {
        AjAttribute attr=AjAttribute.read(name,u.getBytes(),context,msgHandler);
        if (attr != null)         l.add(attr);
      }
    }
  }
  return l;
}","public static List readAjAttributes(String classname,Attribute[] as,ISourceContext context,IMessageHandler msgHandler){
  List l=new ArrayList();
  AjAttribute.WeaverVersionInfo version=new WeaverVersionInfo();
  for (int i=as.length - 1; i >= 0; i--) {
    Attribute a=as[i];
    if (a instanceof Unknown) {
      Unknown u=(Unknown)a;
      String name=u.getName();
      if (name.startsWith(AjAttribute.AttributePrefix)) {
        AjAttribute attr=AjAttribute.read(version,name,u.getBytes(),context,msgHandler);
        if (attr != null && attr instanceof AjAttribute.WeaverVersionInfo) {
          version=(AjAttribute.WeaverVersionInfo)attr;
          if (version.getMajorVersion() > WeaverVersionInfo.getCurrentWeaverMajorVersion()) {
            throw new BCException(""String_Node_Str"" + WeaverVersionInfo.toCurrentVersionString() + ""String_Node_Str""+ classname+ ""String_Node_Str""+ version.toString());
          }
        }
        if (attr != null)         l.add(attr);
      }
    }
  }
  return l;
}",0.6649041639127561
9363,"private void unpackAttributes(World world){
  Attribute[] attrs=field.getAttributes();
  List as=BcelAttributes.readAjAttributes(attrs,getSourceContext(world),world.getMessageHandler());
  for (Iterator iter=as.iterator(); iter.hasNext(); ) {
    AjAttribute a=(AjAttribute)iter.next();
    if (a instanceof AjAttribute.AjSynthetic) {
      isAjSynthetic=true;
    }
 else {
      throw new BCException(""String_Node_Str"" + a);
    }
  }
  isAjSynthetic=false;
  for (int i=attrs.length - 1; i >= 0; i--) {
    if (attrs[i] instanceof Synthetic)     isSynthetic=true;
  }
}","private void unpackAttributes(World world){
  Attribute[] attrs=field.getAttributes();
  List as=BcelAttributes.readAjAttributes(getDeclaringType().getClassName(),attrs,getSourceContext(world),world.getMessageHandler());
  for (Iterator iter=as.iterator(); iter.hasNext(); ) {
    AjAttribute a=(AjAttribute)iter.next();
    if (a instanceof AjAttribute.AjSynthetic) {
      isAjSynthetic=true;
    }
 else {
      throw new BCException(""String_Node_Str"" + a);
    }
  }
  isAjSynthetic=false;
  for (int i=attrs.length - 1; i >= 0; i--) {
    if (attrs[i] instanceof Synthetic)     isSynthetic=true;
  }
}",0.9711375212224108
9364,"private void unpackAjAttributes(World world){
  List as=BcelAttributes.readAjAttributes(method.getAttributes(),getSourceContext(world),world.getMessageHandler());
  for (Iterator iter=as.iterator(); iter.hasNext(); ) {
    AjAttribute a=(AjAttribute)iter.next();
    if (a instanceof AjAttribute.MethodDeclarationLineNumberAttribute) {
      declarationLineNumber=(AjAttribute.MethodDeclarationLineNumberAttribute)a;
    }
 else     if (a instanceof AjAttribute.AdviceAttribute) {
      associatedShadowMunger=((AjAttribute.AdviceAttribute)a).reify(this,world);
      return;
    }
 else     if (a instanceof AjAttribute.AjSynthetic) {
      isAjSynthetic=true;
    }
 else     if (a instanceof AjAttribute.EffectiveSignatureAttribute) {
      effectiveSignature=(AjAttribute.EffectiveSignatureAttribute)a;
    }
 else {
      throw new BCException(""String_Node_Str"" + a);
    }
  }
  associatedShadowMunger=null;
}","private void unpackAjAttributes(World world){
  List as=BcelAttributes.readAjAttributes(getDeclaringType().getClassName(),method.getAttributes(),getSourceContext(world),world.getMessageHandler());
  for (Iterator iter=as.iterator(); iter.hasNext(); ) {
    AjAttribute a=(AjAttribute)iter.next();
    if (a instanceof AjAttribute.MethodDeclarationLineNumberAttribute) {
      declarationLineNumber=(AjAttribute.MethodDeclarationLineNumberAttribute)a;
    }
 else     if (a instanceof AjAttribute.AdviceAttribute) {
      associatedShadowMunger=((AjAttribute.AdviceAttribute)a).reify(this,world);
      return;
    }
 else     if (a instanceof AjAttribute.AjSynthetic) {
      isAjSynthetic=true;
    }
 else     if (a instanceof AjAttribute.EffectiveSignatureAttribute) {
      effectiveSignature=(AjAttribute.EffectiveSignatureAttribute)a;
    }
 else {
      throw new BCException(""String_Node_Str"" + a);
    }
  }
  associatedShadowMunger=null;
}",0.9817596566523604
9365,"private void unpackAspectAttributes(){
  List pointcuts=new ArrayList();
  typeMungers=new ArrayList();
  declares=new ArrayList();
  List l=BcelAttributes.readAjAttributes(javaClass.getAttributes(),getResolvedTypeX().getSourceContext(),getResolvedTypeX().getWorld().getMessageHandler());
  for (Iterator iter=l.iterator(); iter.hasNext(); ) {
    AjAttribute a=(AjAttribute)iter.next();
    if (a instanceof AjAttribute.Aspect) {
      perClause=((AjAttribute.Aspect)a).reify(this.getResolvedTypeX());
    }
 else     if (a instanceof AjAttribute.PointcutDeclarationAttribute) {
      pointcuts.add(((AjAttribute.PointcutDeclarationAttribute)a).reify());
    }
 else     if (a instanceof AjAttribute.WeaverState) {
      weaverState=((AjAttribute.WeaverState)a).reify();
    }
 else     if (a instanceof AjAttribute.TypeMunger) {
      typeMungers.add(((AjAttribute.TypeMunger)a).reify(getResolvedTypeX().getWorld(),getResolvedTypeX()));
    }
 else     if (a instanceof AjAttribute.DeclareAttribute) {
      declares.add(((AjAttribute.DeclareAttribute)a).getDeclare());
    }
 else     if (a instanceof AjAttribute.PrivilegedAttribute) {
      privilegedAccess=((AjAttribute.PrivilegedAttribute)a).getAccessedMembers();
    }
 else     if (a instanceof AjAttribute.SourceContextAttribute) {
      if (getResolvedTypeX().getSourceContext() instanceof BcelSourceContext) {
        ((BcelSourceContext)getResolvedTypeX().getSourceContext()).addAttributeInfo((AjAttribute.SourceContextAttribute)a);
      }
    }
 else     if (a instanceof AjAttribute.WeaverVersionInfo) {
      wvInfo=(AjAttribute.WeaverVersionInfo)a;
      if (wvInfo.getMajorVersion() > WeaverVersionInfo.getCurrentWeaverMajorVersion()) {
        throw new BCException(""String_Node_Str"" + WeaverVersionInfo.toCurrentVersionString() + ""String_Node_Str""+ javaClass.getClassName()+ ""String_Node_Str""+ wvInfo.toString());
      }
    }
 else {
      throw new BCException(""String_Node_Str"" + a);
    }
  }
  this.pointcuts=(ResolvedPointcutDefinition[])pointcuts.toArray(new ResolvedPointcutDefinition[pointcuts.size()]);
}","private void unpackAspectAttributes(){
  List pointcuts=new ArrayList();
  typeMungers=new ArrayList();
  declares=new ArrayList();
  List l=BcelAttributes.readAjAttributes(javaClass.getClassName(),javaClass.getAttributes(),getResolvedTypeX().getSourceContext(),getResolvedTypeX().getWorld().getMessageHandler());
  for (Iterator iter=l.iterator(); iter.hasNext(); ) {
    AjAttribute a=(AjAttribute)iter.next();
    if (a instanceof AjAttribute.Aspect) {
      perClause=((AjAttribute.Aspect)a).reify(this.getResolvedTypeX());
    }
 else     if (a instanceof AjAttribute.PointcutDeclarationAttribute) {
      pointcuts.add(((AjAttribute.PointcutDeclarationAttribute)a).reify());
    }
 else     if (a instanceof AjAttribute.WeaverState) {
      weaverState=((AjAttribute.WeaverState)a).reify();
    }
 else     if (a instanceof AjAttribute.TypeMunger) {
      typeMungers.add(((AjAttribute.TypeMunger)a).reify(getResolvedTypeX().getWorld(),getResolvedTypeX()));
    }
 else     if (a instanceof AjAttribute.DeclareAttribute) {
      declares.add(((AjAttribute.DeclareAttribute)a).getDeclare());
    }
 else     if (a instanceof AjAttribute.PrivilegedAttribute) {
      privilegedAccess=((AjAttribute.PrivilegedAttribute)a).getAccessedMembers();
    }
 else     if (a instanceof AjAttribute.SourceContextAttribute) {
      if (getResolvedTypeX().getSourceContext() instanceof BcelSourceContext) {
        ((BcelSourceContext)getResolvedTypeX().getSourceContext()).addAttributeInfo((AjAttribute.SourceContextAttribute)a);
      }
    }
 else     if (a instanceof AjAttribute.WeaverVersionInfo) {
      wvInfo=(AjAttribute.WeaverVersionInfo)a;
    }
 else {
      throw new BCException(""String_Node_Str"" + a);
    }
  }
  this.pointcuts=(ResolvedPointcutDefinition[])pointcuts.toArray(new ResolvedPointcutDefinition[pointcuts.size()]);
}",0.9197043079276064
9366,"private void printAspectAttributes(PrintStream out){
  ISourceContext context=null;
  if (enclosingClass != null && enclosingClass.getType() != null) {
    context=enclosingClass.getType().getSourceContext();
  }
  List as=BcelAttributes.readAjAttributes(attributes,context,null);
  if (!as.isEmpty()) {
    out.println(""String_Node_Str"" + as.get(0));
  }
}","private void printAspectAttributes(PrintStream out){
  ISourceContext context=null;
  if (enclosingClass != null && enclosingClass.getType() != null) {
    context=enclosingClass.getType().getSourceContext();
  }
  List as=BcelAttributes.readAjAttributes(getClassName(),attributes,context,null);
  if (!as.isEmpty()) {
    out.println(""String_Node_Str"" + as.get(0));
  }
}",0.9794238683127572
9367,"public static AnnotationTypePattern read(DataInputStream s,ISourceContext context) throws IOException {
  AnnotationTypePattern p=new AndAnnotationTypePattern(AnnotationTypePattern.read(s,context),AnnotationTypePattern.read(s,context));
  p.readLocation(context,s);
  return p;
}","public static AnnotationTypePattern read(VersionedDataInputStream s,ISourceContext context) throws IOException {
  AnnotationTypePattern p=new AndAnnotationTypePattern(AnnotationTypePattern.read(s,context),AnnotationTypePattern.read(s,context));
  p.readLocation(context,s);
  return p;
}",0.984126984126984
9368,"private WeaveMessage(String message){
  super(message,IMessage.WEAVEINFO,null,null);
}","private WeaveMessage(String message,String affectedtypename,String aspectname){
  super(message,IMessage.WEAVEINFO,null,null);
  this.affectedtypename=affectedtypename;
  this.aspectname=aspectname;
}",0.6013986013986014
9369,"/** 
 * Static helper method for constructing weaving messages.
 * @param kind what kind of message (e.g. declare parents)
 * @param inserts inserts for the message (inserts are marked %n in the message)
 * @param affectedtypename the type which is being advised/declaredUpon
 * @param aspectname the aspect that defined the advice or declares
 * @return new weaving message
 */
public static WeaveMessage constructWeavingMessage(WeaveMessageKind kind,String[] inserts){
  StringBuffer str=new StringBuffer(kind.getMessage());
  int pos=-1;
  while ((pos=new String(str).indexOf(""String_Node_Str"")) != -1) {
    int n=Character.getNumericValue(str.charAt(pos + 1));
    str.replace(pos,pos + 2,inserts[n - 1]);
  }
  return new WeaveMessage(str.toString());
}","/** 
 * Static helper method for constructing weaving messages.
 * @param kind what kind of message (e.g. declare parents)
 * @param inserts inserts for the message (inserts are marked %n in the message)
 * @param affectedtypename the type which is being advised/declaredUpon
 * @param aspectname the aspect that defined the advice or declares
 * @return new weaving message
 */
public static WeaveMessage constructWeavingMessage(WeaveMessageKind kind,String[] inserts,String affectedtypename,String aspectname){
  StringBuffer str=new StringBuffer(kind.getMessage());
  int pos=-1;
  while ((pos=new String(str).indexOf(""String_Node_Str"")) != -1) {
    int n=Character.getNumericValue(str.charAt(pos + 1));
    str.replace(pos,pos + 2,inserts[n - 1]);
  }
  return new WeaveMessage(str.toString(),affectedtypename,aspectname);
}",0.9559193954659948
9370,"private void reportWeavingMessage(ShadowMunger munger){
  Advice advice=(Advice)munger;
  AdviceKind aKind=advice.getKind();
  if (aKind == null || advice.getConcreteAspect() == null) {
    return;
  }
  if (!(aKind.equals(AdviceKind.Before) || aKind.equals(AdviceKind.After) || aKind.equals(AdviceKind.AfterReturning)|| aKind.equals(AdviceKind.AfterThrowing)|| aKind.equals(AdviceKind.Around)|| aKind.equals(AdviceKind.Softener)))   return;
  String description=advice.getKind().toString();
  String advisedType=this.getEnclosingType().getName();
  String advisingType=advice.getConcreteAspect().getName();
  Message msg=null;
  if (advice.getKind().equals(AdviceKind.Softener)) {
    msg=WeaveMessage.constructWeavingMessage(WeaveMessage.WEAVEMESSAGE_SOFTENS,new String[]{advisedType,beautifyLocation(getSourceLocation()),advisingType,beautifyLocation(munger.getSourceLocation())});
  }
 else {
    boolean runtimeTest=((BcelAdvice)advice).hasDynamicTests();
    msg=WeaveMessage.constructWeavingMessage(WeaveMessage.WEAVEMESSAGE_ADVISES,new String[]{advisedType,beautifyLocation(getSourceLocation()),description,advisingType,beautifyLocation(munger.getSourceLocation()),(runtimeTest ? ""String_Node_Str"" : ""String_Node_Str"")});
  }
  getIWorld().getMessageHandler().handleMessage(msg);
}","private void reportWeavingMessage(ShadowMunger munger){
  Advice advice=(Advice)munger;
  AdviceKind aKind=advice.getKind();
  if (aKind == null || advice.getConcreteAspect() == null) {
    return;
  }
  if (!(aKind.equals(AdviceKind.Before) || aKind.equals(AdviceKind.After) || aKind.equals(AdviceKind.AfterReturning)|| aKind.equals(AdviceKind.AfterThrowing)|| aKind.equals(AdviceKind.Around)|| aKind.equals(AdviceKind.Softener)))   return;
  String description=advice.getKind().toString();
  String advisedType=this.getEnclosingType().getName();
  String advisingType=advice.getConcreteAspect().getName();
  Message msg=null;
  if (advice.getKind().equals(AdviceKind.Softener)) {
    msg=WeaveMessage.constructWeavingMessage(WeaveMessage.WEAVEMESSAGE_SOFTENS,new String[]{advisedType,beautifyLocation(getSourceLocation()),advisingType,beautifyLocation(munger.getSourceLocation())},advisedType,advisingType);
  }
 else {
    boolean runtimeTest=((BcelAdvice)advice).hasDynamicTests();
    msg=WeaveMessage.constructWeavingMessage(WeaveMessage.WEAVEMESSAGE_ADVISES,new String[]{advisedType,beautifyLocation(getSourceLocation()),description,advisingType,beautifyLocation(munger.getSourceLocation()),(runtimeTest ? ""String_Node_Str"" : ""String_Node_Str"")},advisedType,advisingType);
  }
  getIWorld().getMessageHandler().handleMessage(msg);
}",0.9809741248097412
9371,"public boolean munge(BcelClassWeaver weaver){
  boolean changed=false;
  boolean worthReporting=true;
  if (munger.getKind() == ResolvedTypeMunger.Field) {
    changed=mungeNewField(weaver,(NewFieldTypeMunger)munger);
  }
 else   if (munger.getKind() == ResolvedTypeMunger.Method) {
    changed=mungeNewMethod(weaver,(NewMethodTypeMunger)munger);
  }
 else   if (munger.getKind() == ResolvedTypeMunger.PerObjectInterface) {
    changed=mungePerObjectInterface(weaver,(PerObjectInterfaceTypeMunger)munger);
    worthReporting=false;
  }
 else   if (munger.getKind() == ResolvedTypeMunger.PrivilegedAccess) {
    changed=mungePrivilegedAccess(weaver,(PrivilegedAccessMunger)munger);
    worthReporting=false;
  }
 else   if (munger.getKind() == ResolvedTypeMunger.Constructor) {
    changed=mungeNewConstructor(weaver,(NewConstructorTypeMunger)munger);
  }
 else   if (munger.getKind() == ResolvedTypeMunger.Parent) {
    changed=mungeNewParent(weaver,(NewParentTypeMunger)munger);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (changed && munger.changesPublicSignature()) {
    WeaverStateInfo info=weaver.getLazyClassGen().getOrCreateWeaverStateInfo();
    info.addConcreteMunger(this);
  }
  if (ResolvedTypeMunger.persistSourceLocation) {
    if (changed) {
      if (munger.getKind().equals(ResolvedTypeMunger.Parent)) {
        AsmRelationshipProvider.getDefault().addRelationship(weaver.getLazyClassGen().getType(),munger,getAspectType());
      }
 else {
        AsmRelationshipProvider.getDefault().addRelationship(weaver.getLazyClassGen().getType(),munger,getAspectType());
      }
    }
  }
  if (changed && worthReporting && munger != null && !weaver.getWorld().getMessageHandler().isIgnoring(IMessage.WEAVEINFO)) {
    String tName=weaver.getLazyClassGen().getType().getSourceLocation().getSourceFile().getName();
    if (tName.indexOf(""String_Node_Str"") != -1)     tName=""String_Node_Str"";
 else     tName=getShortname(weaver.getLazyClassGen().getType().getSourceLocation().getSourceFile().getPath());
    String fName=getShortname(getAspectType().getSourceLocation().getSourceFile().getPath());
    if (munger.getKind().equals(ResolvedTypeMunger.Parent)) {
      NewParentTypeMunger parentTM=(NewParentTypeMunger)munger;
      if (parentTM.getNewParent().isInterface()) {
        weaver.getWorld().getMessageHandler().handleMessage(WeaveMessage.constructWeavingMessage(WeaveMessage.WEAVEMESSAGE_DECLAREPARENTSIMPLEMENTS,new String[]{weaver.getLazyClassGen().getType().getName(),tName,parentTM.getNewParent().getName(),fName}));
      }
 else {
        System.err.println(""String_Node_Str"");
      }
    }
 else {
      weaver.getWorld().getMessageHandler().handleMessage(WeaveMessage.constructWeavingMessage(WeaveMessage.WEAVEMESSAGE_ITD,new String[]{weaver.getLazyClassGen().getType().getName(),tName,munger.getKind().toString().toLowerCase(),getAspectType().getName(),fName + ""String_Node_Str"" + munger.getSignature()+ ""String_Node_Str""}));
    }
  }
  return changed;
}","public boolean munge(BcelClassWeaver weaver){
  boolean changed=false;
  boolean worthReporting=true;
  if (munger.getKind() == ResolvedTypeMunger.Field) {
    changed=mungeNewField(weaver,(NewFieldTypeMunger)munger);
  }
 else   if (munger.getKind() == ResolvedTypeMunger.Method) {
    changed=mungeNewMethod(weaver,(NewMethodTypeMunger)munger);
  }
 else   if (munger.getKind() == ResolvedTypeMunger.PerObjectInterface) {
    changed=mungePerObjectInterface(weaver,(PerObjectInterfaceTypeMunger)munger);
    worthReporting=false;
  }
 else   if (munger.getKind() == ResolvedTypeMunger.PrivilegedAccess) {
    changed=mungePrivilegedAccess(weaver,(PrivilegedAccessMunger)munger);
    worthReporting=false;
  }
 else   if (munger.getKind() == ResolvedTypeMunger.Constructor) {
    changed=mungeNewConstructor(weaver,(NewConstructorTypeMunger)munger);
  }
 else   if (munger.getKind() == ResolvedTypeMunger.Parent) {
    changed=mungeNewParent(weaver,(NewParentTypeMunger)munger);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (changed && munger.changesPublicSignature()) {
    WeaverStateInfo info=weaver.getLazyClassGen().getOrCreateWeaverStateInfo();
    info.addConcreteMunger(this);
  }
  if (ResolvedTypeMunger.persistSourceLocation) {
    if (changed) {
      if (munger.getKind().equals(ResolvedTypeMunger.Parent)) {
        AsmRelationshipProvider.getDefault().addRelationship(weaver.getLazyClassGen().getType(),munger,getAspectType());
      }
 else {
        AsmRelationshipProvider.getDefault().addRelationship(weaver.getLazyClassGen().getType(),munger,getAspectType());
      }
    }
  }
  if (changed && worthReporting && munger != null && !weaver.getWorld().getMessageHandler().isIgnoring(IMessage.WEAVEINFO)) {
    String tName=weaver.getLazyClassGen().getType().getSourceLocation().getSourceFile().getName();
    if (tName.indexOf(""String_Node_Str"") != -1)     tName=""String_Node_Str"";
 else     tName=getShortname(weaver.getLazyClassGen().getType().getSourceLocation().getSourceFile().getPath());
    String fName=getShortname(getAspectType().getSourceLocation().getSourceFile().getPath());
    if (munger.getKind().equals(ResolvedTypeMunger.Parent)) {
      NewParentTypeMunger parentTM=(NewParentTypeMunger)munger;
      if (parentTM.getNewParent().isInterface()) {
        weaver.getWorld().getMessageHandler().handleMessage(WeaveMessage.constructWeavingMessage(WeaveMessage.WEAVEMESSAGE_DECLAREPARENTSIMPLEMENTS,new String[]{weaver.getLazyClassGen().getType().getName(),tName,parentTM.getNewParent().getName(),fName},weaver.getLazyClassGen().getClassName(),getAspectType().getName()));
      }
 else {
        System.err.println(""String_Node_Str"");
      }
    }
 else {
      weaver.getWorld().getMessageHandler().handleMessage(WeaveMessage.constructWeavingMessage(WeaveMessage.WEAVEMESSAGE_ITD,new String[]{weaver.getLazyClassGen().getType().getName(),tName,munger.getKind().toString().toLowerCase(),getAspectType().getName(),fName + ""String_Node_Str"" + munger.getSignature()+ ""String_Node_Str""},weaver.getLazyClassGen().getClassName(),getAspectType().getName()));
    }
  }
  return changed;
}",0.978550536236594
9372,"private BcelObjectType makeBcelObjectType(ResolvedTypeX.Name resolvedTypeX,JavaClass jc,boolean exposedToWeaver){
  BcelObjectType ret=new BcelObjectType(resolvedTypeX,jc,exposedToWeaver);
  resolvedTypeX.setDelegate(ret);
  return ret;
}","protected BcelObjectType makeBcelObjectType(ResolvedTypeX.Name resolvedTypeX,JavaClass jc,boolean exposedToWeaver){
  BcelObjectType ret=new BcelObjectType(resolvedTypeX,jc,exposedToWeaver);
  resolvedTypeX.setDelegate(ret);
  return ret;
}",0.9748953974895398
9373,"public void addInterface(TypeX typeX,ISourceLocation sourceLocation){
  myGen.addInterface(typeX.getName());
  warnOnAddedInterface(typeX.getName(),sourceLocation);
}","public void addInterface(TypeX typeX,ISourceLocation sourceLocation){
  myGen.addInterface(typeX.getName());
  if (!typeX.equals(TypeX.SERIALIZABLE))   warnOnAddedInterface(typeX.getName(),sourceLocation);
}",0.8900804289544236
9374,"public void checkerMunger(IHierarchy model,Shadow shadow,Checker checker){
  if (shadow.getSourceLocation() == null || checker.getSourceLocation() == null)   return;
  String sourceHandle=ProgramElement.createHandleIdentifier(checker.getSourceLocation().getSourceFile(),checker.getSourceLocation().getLine(),checker.getSourceLocation().getColumn(),checker.getSourceLocation().getOffset());
  String targetHandle=ProgramElement.createHandleIdentifier(shadow.getSourceLocation().getSourceFile(),shadow.getSourceLocation().getLine(),shadow.getSourceLocation().getColumn(),shadow.getSourceLocation().getOffset());
  IRelationshipMap mapper=AsmManager.getDefault().getRelationshipMap();
  if (sourceHandle != null && targetHandle != null) {
    IRelationship foreward=mapper.get(sourceHandle,IRelationship.Kind.DECLARE,MATCHED_BY,false,true);
    foreward.addTarget(targetHandle);
    IRelationship back=mapper.get(targetHandle,IRelationship.Kind.DECLARE,MATCHES_DECLARE,false,true);
    if (back != null && back.getTargets() != null) {
      back.addTarget(sourceHandle);
    }
  }
}","public void checkerMunger(IHierarchy model,Shadow shadow,Checker checker){
  if (shadow.getSourceLocation() == null || checker.getSourceLocation() == null)   return;
  IProgramElement targetNode=getNode(AsmManager.getDefault().getHierarchy(),shadow);
  String sourceHandle=ProgramElement.createHandleIdentifier(checker.getSourceLocation().getSourceFile(),checker.getSourceLocation().getLine(),checker.getSourceLocation().getColumn(),checker.getSourceLocation().getOffset());
  String targetHandle=ProgramElement.createHandleIdentifier(shadow.getSourceLocation().getSourceFile(),shadow.getSourceLocation().getLine(),shadow.getSourceLocation().getColumn(),shadow.getSourceLocation().getOffset());
  IRelationshipMap mapper=AsmManager.getDefault().getRelationshipMap();
  if (sourceHandle != null && targetHandle != null) {
    IRelationship foreward=mapper.get(sourceHandle,IRelationship.Kind.DECLARE,MATCHED_BY,false,true);
    foreward.addTarget(targetHandle);
    IRelationship back=mapper.get(targetHandle,IRelationship.Kind.DECLARE,MATCHES_DECLARE,false,true);
    if (back != null && back.getTargets() != null) {
      back.addTarget(sourceHandle);
    }
  }
}",0.9621043245653144
9375,"public void completeTypeBindings(){
  stepCompleted=BUILD_TYPE_HIERARCHY;
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    units[i].scope.checkAndSetImports();
  }
  stepCompleted=CHECK_AND_SET_IMPORTS;
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    units[i].scope.connectTypeHierarchy();
  }
  stepCompleted=CONNECT_TYPE_HIERARCHY;
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    units[i].scope.buildFieldsAndMethods();
  }
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    SourceTypeBinding[] b=units[i].scope.topLevelTypes;
    for (int j=0; j < b.length; j++) {
      factory.addSourceTypeBinding(b[j]);
    }
  }
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    SourceTypeBinding[] b=units[i].scope.topLevelTypes;
    for (int j=0; j < b.length; j++) {
      buildInterTypeAndPerClause(b[j].scope);
      addCrosscuttingStructures(b[j].scope);
    }
  }
  factory.finishTypeMungers();
  Collection typeMungers=factory.getTypeMungers();
  Collection declareParents=factory.getDeclareParents();
  doPendingWeaves();
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    weaveInterTypeDeclarations(units[i].scope,typeMungers,declareParents);
  }
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    SourceTypeBinding[] b=units[i].scope.topLevelTypes;
    for (int j=0; j < b.length; j++) {
      resolvePointcutDeclarations(b[j].scope);
    }
  }
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    SourceTypeBinding[] b=units[i].scope.topLevelTypes;
    for (int j=0; j < b.length; j++) {
      addAdviceLikeDeclares(b[j].scope);
    }
  }
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    units[i]=null;
  }
  stepCompleted=BUILD_FIELDS_AND_METHODS;
  lastCompletedUnitIndex=lastUnitIndex;
}","public void completeTypeBindings(){
  stepCompleted=BUILD_TYPE_HIERARCHY;
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    units[i].scope.checkAndSetImports();
  }
  stepCompleted=CHECK_AND_SET_IMPORTS;
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    units[i].scope.connectTypeHierarchy();
  }
  stepCompleted=CONNECT_TYPE_HIERARCHY;
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    units[i].scope.buildFieldsAndMethods();
  }
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    SourceTypeBinding[] b=units[i].scope.topLevelTypes;
    for (int j=0; j < b.length; j++) {
      factory.addSourceTypeBinding(b[j]);
    }
  }
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    SourceTypeBinding[] b=units[i].scope.topLevelTypes;
    for (int j=0; j < b.length; j++) {
      buildInterTypeAndPerClause(b[j].scope);
      addCrosscuttingStructures(b[j].scope);
    }
  }
  factory.finishTypeMungers();
  Collection typeMungers=factory.getTypeMungers();
  Collection declareParents=factory.getDeclareParents();
  doPendingWeaves();
  boolean typeProcessingOrderIsImportant=declareParents.size() > 0;
  if (typeProcessingOrderIsImportant) {
    List typesToProcess=new ArrayList();
    for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
      CompilationUnitScope cus=units[i].scope;
      SourceTypeBinding[] stbs=cus.topLevelTypes;
      for (int j=0; j < stbs.length; j++) {
        SourceTypeBinding stb=stbs[j];
        typesToProcess.add(stb);
      }
    }
    while (typesToProcess.size() > 0) {
      weaveIntertypes(typesToProcess,(SourceTypeBinding)typesToProcess.get(0),typeMungers,declareParents);
    }
  }
 else {
    for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
      weaveInterTypeDeclarations(units[i].scope,typeMungers,declareParents);
    }
  }
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    SourceTypeBinding[] b=units[i].scope.topLevelTypes;
    for (int j=0; j < b.length; j++) {
      resolvePointcutDeclarations(b[j].scope);
    }
  }
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    SourceTypeBinding[] b=units[i].scope.topLevelTypes;
    for (int j=0; j < b.length; j++) {
      addAdviceLikeDeclares(b[j].scope);
    }
  }
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    units[i]=null;
  }
  stepCompleted=BUILD_FIELDS_AND_METHODS;
  lastCompletedUnitIndex=lastUnitIndex;
}",0.8589598001362707
9376,"/** 
 * @throws AbortException if check for runtime fails 
 */
protected boolean doBuild(AjBuildConfig buildConfig,IMessageHandler baseHandler,boolean batch) throws IOException, AbortException {
  boolean ret=true;
  batchCompile=batch;
  try {
    if (batch) {
      this.state=new AjState(this);
    }
    boolean canIncremental=state.prepareForNextBuild(buildConfig);
    if (!canIncremental && !batch) {
      return doBuild(buildConfig,baseHandler,true);
    }
    this.handler=CountingMessageHandler.makeCountingMessageHandler(baseHandler);
    String check=checkRtJar(buildConfig);
    if (check != null) {
      if (FAIL_IF_RUNTIME_NOT_FOUND) {
        MessageUtil.error(handler,check);
        return false;
      }
 else {
        MessageUtil.warn(handler,check);
      }
    }
    setBuildConfig(buildConfig);
    if (batch || !AsmManager.attemptIncrementalModelRepairs) {
      setupModel(buildConfig);
    }
    if (batch) {
      initBcelWorld(handler);
    }
    if (handler.hasErrors()) {
      return false;
    }
    if (buildConfig.getOutputJar() != null) {
      if (!openOutputStream(buildConfig.getOutputJar()))       return false;
    }
    if (batch) {
      if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode()) {
        bcelWorld.setModel(AsmManager.getDefault().getHierarchy());
      }
      binarySourcesForTheNextCompile=state.getBinaryFilesToCompile(true);
      performCompilation(buildConfig.getFiles());
      if (handler.hasErrors()) {
        return false;
      }
      if (AsmManager.isReporting())       AsmManager.getDefault().reportModelInfo(""String_Node_Str"");
    }
 else {
      binarySourcesForTheNextCompile=state.getBinaryFilesToCompile(true);
      List files=state.getFilesToCompile(true);
      if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode())       if (AsmManager.attemptIncrementalModelRepairs)       AsmManager.getDefault().processDelta(files,state.addedFiles,state.deletedFiles);
      boolean hereWeGoAgain=!(files.isEmpty() && binarySourcesForTheNextCompile.isEmpty());
      for (int i=0; (i < 5) && hereWeGoAgain; i++) {
        performCompilation(files);
        if (handler.hasErrors() || (progressListener != null && progressListener.isCancelledRequested())) {
          return false;
        }
        binarySourcesForTheNextCompile=state.getBinaryFilesToCompile(false);
        files=state.getFilesToCompile(false);
        hereWeGoAgain=!(files.isEmpty() && binarySourcesForTheNextCompile.isEmpty());
        if (hereWeGoAgain)         if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode())         if (AsmManager.attemptIncrementalModelRepairs)         AsmManager.getDefault().processDelta(files,state.addedFiles,state.deletedFiles);
      }
      if (!files.isEmpty()) {
        return batchBuild(buildConfig,baseHandler);
      }
 else {
        if (AsmManager.isReporting())         AsmManager.getDefault().reportModelInfo(""String_Node_Str"");
      }
    }
    if (buildConfig.isEmacsSymMode()) {
      new org.aspectj.ajdt.internal.core.builder.EmacsStructureModelManager().externalizeModel();
    }
    state.successfulCompile(buildConfig);
    copyResourcesToDestination();
    if (buildConfig.isGenerateModelMode()) {
      AsmManager.getDefault().fireModelUpdated();
    }
  }
  finally {
    if (zos != null) {
      closeOutputStream(buildConfig.getOutputJar());
    }
    ret=!handler.hasErrors();
  }
  return ret;
}","/** 
 * @throws AbortException if check for runtime fails 
 */
protected boolean doBuild(AjBuildConfig buildConfig,IMessageHandler baseHandler,boolean batch) throws IOException, AbortException {
  boolean ret=true;
  batchCompile=batch;
  try {
    if (batch) {
      this.state=new AjState(this);
    }
    boolean canIncremental=state.prepareForNextBuild(buildConfig);
    if (!canIncremental && !batch) {
      return doBuild(buildConfig,baseHandler,true);
    }
    this.handler=CountingMessageHandler.makeCountingMessageHandler(baseHandler);
    String check=checkRtJar(buildConfig);
    if (check != null) {
      if (FAIL_IF_RUNTIME_NOT_FOUND) {
        MessageUtil.error(handler,check);
        return false;
      }
 else {
        MessageUtil.warn(handler,check);
      }
    }
    setBuildConfig(buildConfig);
    if (batch || !AsmManager.attemptIncrementalModelRepairs) {
      setupModel(buildConfig);
    }
    if (batch) {
      initBcelWorld(handler);
    }
    if (handler.hasErrors()) {
      return false;
    }
    if (buildConfig.getOutputJar() != null) {
      if (!openOutputStream(buildConfig.getOutputJar()))       return false;
    }
    if (batch) {
      if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode()) {
        bcelWorld.setModel(AsmManager.getDefault().getHierarchy());
      }
      binarySourcesForTheNextCompile=state.getBinaryFilesToCompile(true);
      performCompilation(buildConfig.getFiles());
      if (handler.hasErrors()) {
        return false;
      }
      if (AsmManager.isReporting())       AsmManager.getDefault().reportModelInfo(""String_Node_Str"");
    }
 else {
      binarySourcesForTheNextCompile=state.getBinaryFilesToCompile(true);
      List files=state.getFilesToCompile(true);
      if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode())       if (AsmManager.attemptIncrementalModelRepairs)       AsmManager.getDefault().processDelta(files,state.addedFiles,state.deletedFiles);
      boolean hereWeGoAgain=!(files.isEmpty() && binarySourcesForTheNextCompile.isEmpty());
      for (int i=0; (i < 5) && hereWeGoAgain; i++) {
        performCompilation(files);
        if (handler.hasErrors() || (progressListener != null && progressListener.isCancelledRequested())) {
          return false;
        }
        binarySourcesForTheNextCompile=state.getBinaryFilesToCompile(false);
        files=state.getFilesToCompile(false);
        hereWeGoAgain=!(files.isEmpty() && binarySourcesForTheNextCompile.isEmpty());
        if (hereWeGoAgain)         if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode())         if (AsmManager.attemptIncrementalModelRepairs)         AsmManager.getDefault().processDelta(files,state.addedFiles,state.deletedFiles);
      }
      if (!files.isEmpty()) {
        return batchBuild(buildConfig,baseHandler);
      }
 else {
        if (AsmManager.isReporting())         AsmManager.getDefault().reportModelInfo(""String_Node_Str"");
      }
    }
    if (buildConfig.isEmacsSymMode()) {
      new org.aspectj.ajdt.internal.core.builder.EmacsStructureModelManager().externalizeModel();
    }
    state.successfulCompile(buildConfig);
    copyResourcesToDestination();
    if (buildConfig.isGenerateModelMode()) {
      AsmManager.getDefault().fireModelUpdated();
    }
  }
  finally {
    if (zos != null) {
      closeOutputStream(buildConfig.getOutputJar());
    }
    ret=!handler.hasErrors();
    bcelWorld.tidyUp();
  }
  return ret;
}",0.9965327939901762
9377,"public InputStream getInputStream() throws IOException {
  return new ByteArrayInputStream(source.getReferenceBytes());
}","public InputStream getInputStream() throws IOException {
  is=new ByteArrayInputStream(source.getReferenceBytes());
  return is;
}",0.9083665338645418
9378,"private JavaClass lookupJavaClass(ClassPathManager classPath,String name){
  if (classPath == null)   return null;
  try {
    ClassPathManager.ClassFile file=classPath.find(TypeX.forName(name));
    if (file == null)     return null;
    ClassParser parser=new ClassParser(file.getInputStream(),file.getPath());
    JavaClass jc=parser.parse();
    return jc;
  }
 catch (  IOException ioe) {
    return null;
  }
}","private JavaClass lookupJavaClass(ClassPathManager classPath,String name){
  if (classPath == null)   return null;
  try {
    ClassPathManager.ClassFile file=classPath.find(TypeX.forName(name));
    if (file == null)     return null;
    ClassParser parser=new ClassParser(file.getInputStream(),file.getPath());
    JavaClass jc=parser.parse();
    file.close();
    return jc;
  }
 catch (  IOException ioe) {
    return null;
  }
}",0.9788235294117648
9379,"public BcelWorld(ClassPathManager cpm,IMessageHandler handler,ICrossReferenceHandler xrefHandler){
  this.classPath=cpm;
  setMessageHandler(handler);
  setXRefHandler(xrefHandler);
}","public BcelWorld(ClassPathManager cpm,IMessageHandler handler,ICrossReferenceHandler xrefHandler){
  this.classPath=cpm;
  setMessageHandler(handler);
  setXRefHandler(xrefHandler);
  org.aspectj.apache.bcel.Repository.setRepository(this);
}",0.8632075471698113
9380,"public ZipEntryClassFile(ZipFile zipFile,ZipEntry entry){
  this.zipFile=zipFile;
  this.entry=entry;
}","public ZipEntryClassFile(ZipFileEntry zipFile,ZipEntry entry){
  this.zipFile=zipFile;
  this.entry=entry;
}",0.976303317535545
9381,"public ClassFile find(String name){
  String key=name.replace('.','/') + ""String_Node_Str"";
  ZipEntry entry=zipFile.getEntry(key);
  if (entry != null)   return new ZipEntryClassFile(zipFile,entry);
 else   return null;
}","public ClassFile find(String name){
  ensureOpen();
  String key=name.replace('.','/') + ""String_Node_Str"";
  ZipEntry entry=zipFile.getEntry(key);
  if (entry != null)   return new ZipEntryClassFile(this,entry);
 else   return null;
}",0.9409190371991248
9382,"public String toString(){
  return zipFile.getName();
}","public String toString(){
  return file.getName();
}",0.9532710280373832
9383,"public List getAllClassFiles(){
  List ret=new ArrayList();
  for (Enumeration e=zipFile.entries(); e.hasMoreElements(); ) {
    ZipEntry entry=(ZipEntry)e.nextElement();
    String name=entry.getName();
    if (hasClassExtension(name))     ret.add(new ZipEntryClassFile(zipFile,entry));
  }
  return ret;
}","public List getAllClassFiles(){
  ensureOpen();
  List ret=new ArrayList();
  for (Enumeration e=zipFile.entries(); e.hasMoreElements(); ) {
    ZipEntry entry=(ZipEntry)e.nextElement();
    String name=entry.getName();
    if (hasClassExtension(name))     ret.add(new ZipEntryClassFile(this,entry));
  }
  return ret;
}",0.9569377990430622
9384,"public InputStream getInputStream() throws IOException {
  return zipFile.getInputStream(entry);
}","public InputStream getInputStream() throws IOException {
  is=zipFile.getZipFile().getInputStream(entry);
  return is;
}",0.8348623853211009
9385,"public void abstractMethodMustBeImplemented(SourceTypeBinding type,MethodBinding abstractMethod){
  if (isPointcutDeclaration(abstractMethod)) {
    return;
  }
  if (CharOperation.prefixEquals(""String_Node_Str"".toCharArray(),abstractMethod.selector)) {
    return;
  }
  ResolvedTypeX onTypeX=factory.fromEclipse(type);
  for (Iterator i=onTypeX.getInterTypeMungersIncludingSupers().iterator(); i.hasNext(); ) {
    ConcreteTypeMunger m=(ConcreteTypeMunger)i.next();
    ResolvedMember sig=m.getSignature();
    if (!Modifier.isAbstract(sig.getModifiers())) {
      if (ResolvedTypeX.matches(AjcMemberMaker.interMethod(sig,m.getAspectType(),sig.getDeclaringType().isInterface(factory.getWorld())),EclipseFactory.makeResolvedMember(abstractMethod))) {
        return;
      }
    }
  }
  super.abstractMethodMustBeImplemented(type,abstractMethod);
}","public void abstractMethodMustBeImplemented(SourceTypeBinding type,MethodBinding abstractMethod){
  if (isPointcutDeclaration(abstractMethod)) {
    return;
  }
  if (CharOperation.prefixEquals(""String_Node_Str"".toCharArray(),abstractMethod.selector)) {
    return;
  }
  ResolvedTypeX onTypeX=null;
  if (!type.isAnonymousType()) {
    onTypeX=factory.fromEclipse(type);
  }
 else {
    onTypeX=factory.fromEclipse(type.superclass());
  }
  for (Iterator i=onTypeX.getInterTypeMungersIncludingSupers().iterator(); i.hasNext(); ) {
    ConcreteTypeMunger m=(ConcreteTypeMunger)i.next();
    ResolvedMember sig=m.getSignature();
    if (!Modifier.isAbstract(sig.getModifiers())) {
      if (ResolvedTypeX.matches(AjcMemberMaker.interMethod(sig,m.getAspectType(),sig.getDeclaringType().isInterface(factory.getWorld())),EclipseFactory.makeResolvedMember(abstractMethod))) {
        return;
      }
    }
  }
  super.abstractMethodMustBeImplemented(type,abstractMethod);
}",0.9345074298293892
9386,"public static List readAjAttributes(Attribute[] as,ISourceContext context){
  List l=new ArrayList();
  for (int i=as.length - 1; i >= 0; i--) {
    Attribute a=as[i];
    if (a instanceof Unknown) {
      Unknown u=(Unknown)a;
      String name=u.getName();
      if (name.startsWith(AjAttribute.AttributePrefix)) {
        l.add(AjAttribute.read(name,u.getBytes(),context));
      }
    }
  }
  return l;
}","public static List readAjAttributes(Attribute[] as,ISourceContext context,IMessageHandler msgHandler){
  List l=new ArrayList();
  for (int i=as.length - 1; i >= 0; i--) {
    Attribute a=as[i];
    if (a instanceof Unknown) {
      Unknown u=(Unknown)a;
      String name=u.getName();
      if (name.startsWith(AjAttribute.AttributePrefix)) {
        AjAttribute attr=AjAttribute.read(name,u.getBytes(),context,msgHandler);
        if (attr != null)         l.add(attr);
      }
    }
  }
  return l;
}",0.8803512623490669
9387,"private void unpackAttributes(World world){
  Attribute[] attrs=field.getAttributes();
  List as=BcelAttributes.readAjAttributes(attrs,getSourceContext(world));
  for (Iterator iter=as.iterator(); iter.hasNext(); ) {
    AjAttribute a=(AjAttribute)iter.next();
    if (a instanceof AjAttribute.AjSynthetic) {
      isAjSynthetic=true;
    }
 else {
      throw new BCException(""String_Node_Str"" + a);
    }
  }
  isAjSynthetic=false;
  for (int i=attrs.length - 1; i >= 0; i--) {
    if (attrs[i] instanceof Synthetic)     isSynthetic=true;
  }
}","private void unpackAttributes(World world){
  Attribute[] attrs=field.getAttributes();
  List as=BcelAttributes.readAjAttributes(attrs,getSourceContext(world),world.getMessageHandler());
  for (Iterator iter=as.iterator(); iter.hasNext(); ) {
    AjAttribute a=(AjAttribute)iter.next();
    if (a instanceof AjAttribute.AjSynthetic) {
      isAjSynthetic=true;
    }
 else {
      throw new BCException(""String_Node_Str"" + a);
    }
  }
  isAjSynthetic=false;
  for (int i=attrs.length - 1; i >= 0; i--) {
    if (attrs[i] instanceof Synthetic)     isSynthetic=true;
  }
}",0.9767441860465116
9388,"private void unpackAjAttributes(World world){
  List as=BcelAttributes.readAjAttributes(method.getAttributes(),getSourceContext(world));
  for (Iterator iter=as.iterator(); iter.hasNext(); ) {
    AjAttribute a=(AjAttribute)iter.next();
    if (a instanceof AjAttribute.MethodDeclarationLineNumberAttribute) {
      declarationLineNumber=(AjAttribute.MethodDeclarationLineNumberAttribute)a;
    }
 else     if (a instanceof AjAttribute.AdviceAttribute) {
      associatedShadowMunger=((AjAttribute.AdviceAttribute)a).reify(this,world);
      return;
    }
 else     if (a instanceof AjAttribute.AjSynthetic) {
      isAjSynthetic=true;
    }
 else     if (a instanceof AjAttribute.EffectiveSignatureAttribute) {
      effectiveSignature=(AjAttribute.EffectiveSignatureAttribute)a;
    }
 else {
      throw new BCException(""String_Node_Str"" + a);
    }
  }
  associatedShadowMunger=null;
}","private void unpackAjAttributes(World world){
  List as=BcelAttributes.readAjAttributes(method.getAttributes(),getSourceContext(world),world.getMessageHandler());
  for (Iterator iter=as.iterator(); iter.hasNext(); ) {
    AjAttribute a=(AjAttribute)iter.next();
    if (a instanceof AjAttribute.MethodDeclarationLineNumberAttribute) {
      declarationLineNumber=(AjAttribute.MethodDeclarationLineNumberAttribute)a;
    }
 else     if (a instanceof AjAttribute.AdviceAttribute) {
      associatedShadowMunger=((AjAttribute.AdviceAttribute)a).reify(this,world);
      return;
    }
 else     if (a instanceof AjAttribute.AjSynthetic) {
      isAjSynthetic=true;
    }
 else     if (a instanceof AjAttribute.EffectiveSignatureAttribute) {
      effectiveSignature=(AjAttribute.EffectiveSignatureAttribute)a;
    }
 else {
      throw new BCException(""String_Node_Str"" + a);
    }
  }
  associatedShadowMunger=null;
}",0.9855875831485588
9389,"private void unpackAspectAttributes(){
  List pointcuts=new ArrayList();
  typeMungers=new ArrayList();
  declares=new ArrayList();
  List l=BcelAttributes.readAjAttributes(javaClass.getAttributes(),getResolvedTypeX().getSourceContext());
  for (Iterator iter=l.iterator(); iter.hasNext(); ) {
    AjAttribute a=(AjAttribute)iter.next();
    if (a instanceof AjAttribute.Aspect) {
      perClause=((AjAttribute.Aspect)a).reify(this.getResolvedTypeX());
    }
 else     if (a instanceof AjAttribute.PointcutDeclarationAttribute) {
      pointcuts.add(((AjAttribute.PointcutDeclarationAttribute)a).reify());
    }
 else     if (a instanceof AjAttribute.WeaverState) {
      weaverState=((AjAttribute.WeaverState)a).reify();
    }
 else     if (a instanceof AjAttribute.TypeMunger) {
      typeMungers.add(((AjAttribute.TypeMunger)a).reify(getResolvedTypeX().getWorld(),getResolvedTypeX()));
    }
 else     if (a instanceof AjAttribute.DeclareAttribute) {
      declares.add(((AjAttribute.DeclareAttribute)a).getDeclare());
    }
 else     if (a instanceof AjAttribute.PrivilegedAttribute) {
      privilegedAccess=((AjAttribute.PrivilegedAttribute)a).getAccessedMembers();
    }
 else     if (a instanceof AjAttribute.SourceContextAttribute) {
      if (getResolvedTypeX().getSourceContext() instanceof BcelSourceContext) {
        ((BcelSourceContext)getResolvedTypeX().getSourceContext()).addAttributeInfo((AjAttribute.SourceContextAttribute)a);
      }
    }
 else {
      throw new BCException(""String_Node_Str"" + a);
    }
  }
  this.pointcuts=(ResolvedPointcutDefinition[])pointcuts.toArray(new ResolvedPointcutDefinition[pointcuts.size()]);
}","private void unpackAspectAttributes(){
  List pointcuts=new ArrayList();
  typeMungers=new ArrayList();
  declares=new ArrayList();
  List l=BcelAttributes.readAjAttributes(javaClass.getAttributes(),getResolvedTypeX().getSourceContext(),getResolvedTypeX().getWorld().getMessageHandler());
  for (Iterator iter=l.iterator(); iter.hasNext(); ) {
    AjAttribute a=(AjAttribute)iter.next();
    if (a instanceof AjAttribute.Aspect) {
      perClause=((AjAttribute.Aspect)a).reify(this.getResolvedTypeX());
    }
 else     if (a instanceof AjAttribute.PointcutDeclarationAttribute) {
      pointcuts.add(((AjAttribute.PointcutDeclarationAttribute)a).reify());
    }
 else     if (a instanceof AjAttribute.WeaverState) {
      weaverState=((AjAttribute.WeaverState)a).reify();
    }
 else     if (a instanceof AjAttribute.TypeMunger) {
      typeMungers.add(((AjAttribute.TypeMunger)a).reify(getResolvedTypeX().getWorld(),getResolvedTypeX()));
    }
 else     if (a instanceof AjAttribute.DeclareAttribute) {
      declares.add(((AjAttribute.DeclareAttribute)a).getDeclare());
    }
 else     if (a instanceof AjAttribute.PrivilegedAttribute) {
      privilegedAccess=((AjAttribute.PrivilegedAttribute)a).getAccessedMembers();
    }
 else     if (a instanceof AjAttribute.SourceContextAttribute) {
      if (getResolvedTypeX().getSourceContext() instanceof BcelSourceContext) {
        ((BcelSourceContext)getResolvedTypeX().getSourceContext()).addAttributeInfo((AjAttribute.SourceContextAttribute)a);
      }
    }
 else     if (a instanceof AjAttribute.WeaverVersionInfo) {
      wvInfo=(AjAttribute.WeaverVersionInfo)a;
      if (wvInfo.getMajorVersion() > wvInfo.getCurrentWeaverMajorVersion()) {
        throw new BCException(""String_Node_Str"" + wvInfo.toCurrentVersionString() + ""String_Node_Str""+ javaClass.getClassName()+ ""String_Node_Str""+ wvInfo.toString());
      }
    }
 else {
      throw new BCException(""String_Node_Str"" + a);
    }
  }
  this.pointcuts=(ResolvedPointcutDefinition[])pointcuts.toArray(new ResolvedPointcutDefinition[pointcuts.size()]);
}",0.3641260436304874
9390,"private void writeBack(BcelWorld world){
  if (getConstantPoolGen().getSize() > Short.MAX_VALUE) {
    myGen=new ClassGen(myGen.getClassName(),myGen.getSuperclassName(),myGen.getFileName(),myGen.getAccessFlags(),myGen.getInterfaceNames());
    getWorld().showMessage(IMessage.ERROR,WeaverMessages.format(WeaverMessages.CLASS_TOO_BIG,this.getClassName()),new SourceLocation(new File(myGen.getFileName()),0),null);
    return;
  }
  if (myType != null && myType.getWeaverState() != null) {
    myGen.addAttribute(BcelAttributes.bcelAttribute(new AjAttribute.WeaverState(myType.getWeaverState()),getConstantPoolGen()));
  }
  addAjcInitializers();
  int len=methodGens.size();
  myGen.setMethods(new Method[0]);
  calculateSourceDebugExtensionOffsets();
  for (int i=0; i < len; i++) {
    LazyMethodGen gen=(LazyMethodGen)methodGens.get(i);
    if (isEmptyClinit(gen))     continue;
    myGen.addMethod(gen.getMethod());
  }
  if (inlinedFiles.size() != 0) {
    if (hasSourceDebugExtensionAttribute(myGen)) {
      world.showMessage(IMessage.WARNING,WeaverMessages.format(WeaverMessages.OVERWRITE_JSR45,getFileName()),null,null);
    }
    myGen.addAttribute(getSourceDebugExtensionAttribute());
  }
}","private void writeBack(BcelWorld world){
  if (getConstantPoolGen().getSize() > Short.MAX_VALUE) {
    myGen=new ClassGen(myGen.getClassName(),myGen.getSuperclassName(),myGen.getFileName(),myGen.getAccessFlags(),myGen.getInterfaceNames());
    getWorld().showMessage(IMessage.ERROR,WeaverMessages.format(WeaverMessages.CLASS_TOO_BIG,this.getClassName()),new SourceLocation(new File(myGen.getFileName()),0),null);
    return;
  }
  myGen.addAttribute(BcelAttributes.bcelAttribute(new AjAttribute.WeaverVersionInfo(),getConstantPoolGen()));
  if (myType != null && myType.getWeaverState() != null) {
    myGen.addAttribute(BcelAttributes.bcelAttribute(new AjAttribute.WeaverState(myType.getWeaverState()),getConstantPoolGen()));
  }
  addAjcInitializers();
  int len=methodGens.size();
  myGen.setMethods(new Method[0]);
  calculateSourceDebugExtensionOffsets();
  for (int i=0; i < len; i++) {
    LazyMethodGen gen=(LazyMethodGen)methodGens.get(i);
    if (isEmptyClinit(gen))     continue;
    myGen.addMethod(gen.getMethod());
  }
  if (inlinedFiles.size() != 0) {
    if (hasSourceDebugExtensionAttribute(myGen)) {
      world.showMessage(IMessage.WARNING,WeaverMessages.format(WeaverMessages.OVERWRITE_JSR45,getFileName()),null,null);
    }
    myGen.addAttribute(getSourceDebugExtensionAttribute());
  }
}",0.9561752988047808
9391,"private void printAspectAttributes(PrintStream out){
  ISourceContext context=null;
  if (enclosingClass != null && enclosingClass.getType() != null) {
    context=enclosingClass.getType().getSourceContext();
  }
  List as=BcelAttributes.readAjAttributes(attributes,context);
  if (!as.isEmpty()) {
    out.println(""String_Node_Str"" + as.get(0));
  }
}","private void printAspectAttributes(PrintStream out){
  ISourceContext context=null;
  if (enclosingClass != null && enclosingClass.getType() != null) {
    context=enclosingClass.getType().getSourceContext();
  }
  List as=BcelAttributes.readAjAttributes(attributes,context,null);
  if (!as.isEmpty()) {
    out.println(""String_Node_Str"" + as.get(0));
  }
}",0.9929478138222848
9392,"public void unhandledException(TypeBinding exceptionType,ASTNode location){
  if (!factory.getWorld().getDeclareSoft().isEmpty()) {
    Shadow callSite=factory.makeShadow(location,referenceContext);
    Shadow enclosingExec=factory.makeShadow(referenceContext);
    for (Iterator i=factory.getWorld().getDeclareSoft().iterator(); i.hasNext(); ) {
      DeclareSoft d=(DeclareSoft)i.next();
      ResolvedTypeX throwException=factory.fromEclipse((ReferenceBinding)exceptionType);
      FuzzyBoolean isExceptionTypeOrSubtype=d.getException().matchesInstanceof(throwException);
      if (!isExceptionTypeOrSubtype.alwaysTrue())       continue;
      if (callSite != null) {
        FuzzyBoolean match=d.getPointcut().match(callSite);
        if (match.alwaysTrue()) {
          return;
        }
 else         if (!match.alwaysFalse()) {
        }
      }
      if (enclosingExec != null) {
        FuzzyBoolean match=d.getPointcut().match(enclosingExec);
        if (match.alwaysTrue()) {
          return;
        }
 else         if (!match.alwaysFalse()) {
        }
      }
    }
  }
  if (location instanceof Proceed) {
    return;
  }
  super.unhandledException(exceptionType,location);
}","public void unhandledException(TypeBinding exceptionType,ASTNode location){
  if (!factory.getWorld().getDeclareSoft().isEmpty()) {
    Shadow callSite=factory.makeShadow(location,referenceContext);
    Shadow enclosingExec=factory.makeShadow(referenceContext);
    if ((callSite == null) && (enclosingExec.getKind() == Shadow.ConstructorExecution) && (location instanceof ExplicitConstructorCall)) {
      super.unhandledException(exceptionType,location);
      return;
    }
    for (Iterator i=factory.getWorld().getDeclareSoft().iterator(); i.hasNext(); ) {
      DeclareSoft d=(DeclareSoft)i.next();
      ResolvedTypeX throwException=factory.fromEclipse((ReferenceBinding)exceptionType);
      FuzzyBoolean isExceptionTypeOrSubtype=d.getException().matchesInstanceof(throwException);
      if (!isExceptionTypeOrSubtype.alwaysTrue())       continue;
      if (callSite != null) {
        FuzzyBoolean match=d.getPointcut().match(callSite);
        if (match.alwaysTrue()) {
          return;
        }
 else         if (!match.alwaysFalse()) {
        }
      }
      if (enclosingExec != null) {
        FuzzyBoolean match=d.getPointcut().match(enclosingExec);
        if (match.alwaysTrue()) {
          return;
        }
 else         if (!match.alwaysFalse()) {
        }
      }
    }
  }
  if (location instanceof Proceed) {
    return;
  }
  super.unhandledException(exceptionType,location);
}",0.9172121678860224
9393,"Root(String s) throws IOException {
}","Root(String s){
}",0.6296296296296297
9394,"/** 
 * Extract AspectJ-specific options (except for argfiles). Caller should warn when sourceroots is empty but in  incremental mode. Signals warnings or errors through handler set in constructor.
 */
public void parseOption(String arg,LinkedList args){
  int nextArgIndex=args.indexOf(arg) + 1;
  if (LangUtil.isEmpty(arg)) {
    showWarning(""String_Node_Str"");
  }
 else   if (arg.equals(""String_Node_Str"")) {
    ;
    if (args.size() > nextArgIndex) {
      List inPath=buildConfig.getInpath();
      StringTokenizer st=new StringTokenizer(((ConfigParser.Arg)args.get(nextArgIndex)).getValue(),File.pathSeparator);
      while (st.hasMoreTokens()) {
        String filename=st.nextToken();
        File file=makeFile(filename);
        if (file.exists() && FileUtil.hasZipSuffix(filename)) {
          inPath.add(file);
        }
 else {
          if (file.isDirectory()) {
            inPath.add(file);
          }
 else           showError(""String_Node_Str"" + filename);
        }
      }
      buildConfig.setInPath(inPath);
      args.remove(args.get(nextArgIndex));
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    ;
    if (args.size() > nextArgIndex) {
      StringTokenizer st=new StringTokenizer(((ConfigParser.Arg)args.get(nextArgIndex)).getValue(),File.pathSeparator);
      while (st.hasMoreTokens()) {
        String filename=st.nextToken();
        File jarFile=makeFile(filename);
        if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
          buildConfig.getInJars().add(jarFile);
        }
 else {
          File dirFile=makeFile(filename);
          if (dirFile.isDirectory()) {
            buildConfig.getInJars().add(dirFile);
          }
 else           showError(""String_Node_Str"" + filename);
        }
      }
      args.remove(args.get(nextArgIndex));
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    ;
    if (args.size() > nextArgIndex) {
      StringTokenizer st=new StringTokenizer(((ConfigParser.Arg)args.get(nextArgIndex)).getValue(),File.pathSeparator);
      while (st.hasMoreTokens()) {
        String filename=st.nextToken();
        File jarFile=makeFile(filename);
        if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
          buildConfig.getAspectpath().add(jarFile);
        }
 else {
          showError(""String_Node_Str"" + filename);
        }
      }
      args.remove(args.get(nextArgIndex));
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      List sourceRoots=new ArrayList();
      StringTokenizer st=new StringTokenizer(((ConfigParser.Arg)args.get(nextArgIndex)).getValue(),File.pathSeparator);
      while (st.hasMoreTokens()) {
        File f=makeFile(st.nextToken());
        if (f.isDirectory() && f.canRead()) {
          sourceRoots.add(f);
        }
 else {
          showError(""String_Node_Str"" + f);
        }
      }
      if (0 < sourceRoots.size()) {
        buildConfig.setSourceRoots(sourceRoots);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      File jarFile=makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
      if (FileUtil.hasZipSuffix(jarFile)) {
        try {
          if (!jarFile.exists()) {
            jarFile.createNewFile();
          }
          buildConfig.setOutputJar(jarFile);
        }
 catch (        IOException ioe) {
          showError(""String_Node_Str"" + jarFile);
        }
      }
 else {
        showError(""String_Node_Str"" + jarFile);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setIncrementalMode(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      File file=makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
      buildConfig.setIncrementalFile(file);
      if (!file.canRead()) {
        showError(""String_Node_Str"" + file);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setEmacsSymMode(true);
    buildConfig.setGenerateModelMode(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setGenerateModelMode(true);
    buildConfig.setGenerateJavadocsInModelMode(true);
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    buildConfig.setNoWeave(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setXserializableAspects(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setXlazyTjp(true);
  }
 else   if (arg.startsWith(""String_Node_Str"")) {
    buildConfig.setXreweavable(true);
    if (arg.endsWith(""String_Node_Str"")) {
      buildConfig.setXreweavableCompressClasses(true);
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setXnoInline(true);
  }
 else   if (arg.startsWith(""String_Node_Str"")) {
    buildConfig.setShowWeavingInformation(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      File lintSpecFile=makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
      if (lintSpecFile.canRead() && lintSpecFile.getName().endsWith(""String_Node_Str"")) {
        buildConfig.setLintSpecFile(lintSpecFile);
      }
 else {
        showError(""String_Node_Str"" + lintSpecFile);
        buildConfig.setLintSpecFile(null);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setLintMode(AjBuildConfig.AJLINT_DEFAULT);
  }
 else   if (arg.startsWith(""String_Node_Str"")) {
    if (7 < arg.length()) {
      buildConfig.setLintMode(arg.substring(7));
    }
 else {
      showError(""String_Node_Str"" + arg);
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      String bcpArg=((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
      StringBuffer bcp=new StringBuffer();
      StringTokenizer strTok=new StringTokenizer(bcpArg,File.pathSeparator);
      while (strTok.hasMoreTokens()) {
        bcp.append(makeFile(strTok.nextToken()));
        if (strTok.hasMoreTokens()) {
          bcp.append(File.pathSeparator);
        }
      }
      bootclasspath=bcp.toString();
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      String cpArg=((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
      StringBuffer cp=new StringBuffer();
      StringTokenizer strTok=new StringTokenizer(cpArg,File.pathSeparator);
      while (strTok.hasMoreTokens()) {
        cp.append(makeFile(strTok.nextToken()));
        if (strTok.hasMoreTokens()) {
          cp.append(File.pathSeparator);
        }
      }
      classpath=cp.toString();
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      String extdirsArg=((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
      StringBuffer ed=new StringBuffer();
      StringTokenizer strTok=new StringTokenizer(extdirsArg,File.pathSeparator);
      while (strTok.hasMoreTokens()) {
        ed.append(makeFile(strTok.nextToken()));
        if (strTok.hasMoreTokens()) {
          ed.append(File.pathSeparator);
        }
      }
      extdirs=ed.toString();
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    dirLookahead(arg,args,nextArgIndex);
  }
 else   if (new File(arg).isDirectory()) {
    showError(""String_Node_Str"" + arg);
  }
 else {
    unparsedArgs.add(arg);
  }
}","/** 
 * Extract AspectJ-specific options (except for argfiles). Caller should warn when sourceroots is empty but in  incremental mode. Signals warnings or errors through handler set in constructor.
 */
public void parseOption(String arg,LinkedList args){
  int nextArgIndex=args.indexOf(arg) + 1;
  if (LangUtil.isEmpty(arg)) {
    showWarning(""String_Node_Str"");
  }
 else   if (arg.equals(""String_Node_Str"")) {
    ;
    if (args.size() > nextArgIndex) {
      List inPath=buildConfig.getInpath();
      StringTokenizer st=new StringTokenizer(((ConfigParser.Arg)args.get(nextArgIndex)).getValue(),File.pathSeparator);
      while (st.hasMoreTokens()) {
        String filename=st.nextToken();
        File file=makeFile(filename);
        if (file.exists() && FileUtil.hasZipSuffix(filename)) {
          inPath.add(file);
        }
 else {
          if (file.isDirectory()) {
            inPath.add(file);
          }
 else           showError(""String_Node_Str"" + filename);
        }
      }
      buildConfig.setInPath(inPath);
      args.remove(args.get(nextArgIndex));
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    ;
    if (args.size() > nextArgIndex) {
      StringTokenizer st=new StringTokenizer(((ConfigParser.Arg)args.get(nextArgIndex)).getValue(),File.pathSeparator);
      while (st.hasMoreTokens()) {
        String filename=st.nextToken();
        File jarFile=makeFile(filename);
        if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
          buildConfig.getInJars().add(jarFile);
        }
 else {
          File dirFile=makeFile(filename);
          if (dirFile.isDirectory()) {
            buildConfig.getInJars().add(dirFile);
          }
 else           showError(""String_Node_Str"" + filename);
        }
      }
      args.remove(args.get(nextArgIndex));
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    ;
    if (args.size() > nextArgIndex) {
      StringTokenizer st=new StringTokenizer(((ConfigParser.Arg)args.get(nextArgIndex)).getValue(),File.pathSeparator);
      while (st.hasMoreTokens()) {
        String filename=st.nextToken();
        File jarFile=makeFile(filename);
        if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
          buildConfig.getAspectpath().add(jarFile);
        }
 else {
          showError(""String_Node_Str"" + filename);
        }
      }
      args.remove(args.get(nextArgIndex));
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      List sourceRoots=new ArrayList();
      StringTokenizer st=new StringTokenizer(((ConfigParser.Arg)args.get(nextArgIndex)).getValue(),File.pathSeparator);
      while (st.hasMoreTokens()) {
        File f=makeFile(st.nextToken());
        if (f.isDirectory() && f.canRead()) {
          sourceRoots.add(f);
        }
 else {
          showError(""String_Node_Str"" + f);
        }
      }
      if (0 < sourceRoots.size()) {
        buildConfig.setSourceRoots(sourceRoots);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      File jarFile=makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
      if (FileUtil.hasZipSuffix(jarFile)) {
        try {
          if (!jarFile.exists()) {
            jarFile.createNewFile();
          }
          buildConfig.setOutputJar(jarFile);
        }
 catch (        IOException ioe) {
          showError(""String_Node_Str"" + jarFile);
        }
      }
 else {
        showError(""String_Node_Str"" + jarFile);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setIncrementalMode(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      File file=makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
      buildConfig.setIncrementalFile(file);
      if (!file.canRead()) {
        showError(""String_Node_Str"" + file);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setEmacsSymMode(true);
    buildConfig.setGenerateModelMode(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setGenerateModelMode(true);
    buildConfig.setGenerateJavadocsInModelMode(true);
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    buildConfig.setNoWeave(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setXserializableAspects(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setXlazyTjp(true);
  }
 else   if (arg.startsWith(""String_Node_Str"")) {
    buildConfig.setXreweavable(true);
    if (arg.endsWith(""String_Node_Str"")) {
      buildConfig.setXreweavableCompressClasses(true);
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setXnoInline(true);
  }
 else   if (arg.startsWith(""String_Node_Str"")) {
    buildConfig.setShowWeavingInformation(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      File lintSpecFile=makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
      if (lintSpecFile.canRead() && lintSpecFile.getName().endsWith(""String_Node_Str"")) {
        buildConfig.setLintSpecFile(lintSpecFile);
      }
 else {
        showError(""String_Node_Str"" + lintSpecFile);
        buildConfig.setLintSpecFile(null);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setLintMode(AjBuildConfig.AJLINT_DEFAULT);
  }
 else   if (arg.startsWith(""String_Node_Str"")) {
    if (7 < arg.length()) {
      buildConfig.setLintMode(arg.substring(7));
    }
 else {
      showError(""String_Node_Str"" + arg);
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      String bcpArg=((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
      StringBuffer bcp=new StringBuffer();
      StringTokenizer strTok=new StringTokenizer(bcpArg,File.pathSeparator);
      while (strTok.hasMoreTokens()) {
        bcp.append(makeFile(strTok.nextToken()));
        if (strTok.hasMoreTokens()) {
          bcp.append(File.pathSeparator);
        }
      }
      bootclasspath=bcp.toString();
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      String cpArg=((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
      StringBuffer cp=new StringBuffer();
      StringTokenizer strTok=new StringTokenizer(cpArg,File.pathSeparator);
      while (strTok.hasMoreTokens()) {
        cp.append(makeFile(strTok.nextToken()));
        if (strTok.hasMoreTokens()) {
          cp.append(File.pathSeparator);
        }
      }
      classpath=cp.toString();
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      String extdirsArg=((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
      StringBuffer ed=new StringBuffer();
      StringTokenizer strTok=new StringTokenizer(extdirsArg,File.pathSeparator);
      while (strTok.hasMoreTokens()) {
        ed.append(makeFile(strTok.nextToken()));
        if (strTok.hasMoreTokens()) {
          ed.append(File.pathSeparator);
        }
      }
      extdirs=ed.toString();
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    dirLookahead(arg,args,nextArgIndex);
  }
 else   if (new File(arg).isDirectory()) {
    showError(""String_Node_Str"" + arg);
  }
 else {
    unparsedArgs.add(arg);
  }
}",0.9979414883662904
9395,"public MessageHolderChecker(int aborts,int fails,int errors,int warnings,int infos){
  this.aborts=aborts;
  this.fails=fails;
  this.errors=errors;
  this.warnings=warnings;
  this.infos=infos;
}","public MessageHolderChecker(int aborts,int fails,int errors,int warnings,int infos){
  this.aborts=aborts;
  this.fails=fails;
  this.errors=errors;
  this.warnings=warnings;
  this.infos=infos;
  this.weaveinfos=IGNORE;
}",0.937799043062201
9396,"private void replaceEffectivelyStaticRef(MessageSend call){
  NameReference receiver=(NameReference)call.receiver;
  receiver.binding=thisJoinPointStaticPartDecLocal;
  receiver.codegenBinding=thisJoinPointStaticPartDecLocal;
  ReferenceBinding thisJoinPointStaticPartType=(ReferenceBinding)thisJoinPointStaticPartDec.type;
  receiver.receiverType=receiver.actualReceiverType=receiver.resolvedType=thisJoinPointStaticPartType;
  call.setActualReceiverType(thisJoinPointStaticPartType);
  AstUtil.replaceMethodBinding(call,getEquivalentStaticBinding(call.binding));
}","private void replaceEffectivelyStaticRef(MessageSend call){
  NameReference receiver=(NameReference)call.receiver;
  if (call.binding == null)   return;
  receiver.binding=thisJoinPointStaticPartDecLocal;
  receiver.codegenBinding=thisJoinPointStaticPartDecLocal;
  ReferenceBinding thisJoinPointStaticPartType=(ReferenceBinding)thisJoinPointStaticPartDec.type;
  receiver.receiverType=receiver.actualReceiverType=receiver.resolvedType=thisJoinPointStaticPartType;
  call.setActualReceiverType(thisJoinPointStaticPartType);
  AstUtil.replaceMethodBinding(call,getEquivalentStaticBinding(call.binding));
}",0.9675213675213676
9397,"public void saveContents() throws IOException {
  if (filePath != NO_FILE && filePath != ""String_Node_Str"" && editorPane.getText() != ""String_Node_Str"") {
    BufferedWriter writer=new BufferedWriter(new FileWriter(filePath));
    writer.write(editorPane.getText());
    writer.flush();
  }
}","public void saveContents() throws IOException {
  if (!filePath.equals(NO_FILE) && !filePath.equals(""String_Node_Str"") && !editorPane.getText().equals(""String_Node_Str"")) {
    BufferedWriter writer=new BufferedWriter(new FileWriter(filePath));
    writer.write(editorPane.getText());
    writer.close();
  }
}",0.9136212624584718
9398,"private String readFile(String filePath,int lineNumber){
  try {
    File file=new File(filePath);
    if (!file.exists()) {
      return ""String_Node_Str"" + filePath + ""String_Node_Str"";
    }
    BufferedReader reader=new BufferedReader(new FileReader(file));
    StringBuffer contents=new StringBuffer();
    String line=reader.readLine();
    int numLines=0;
    while (line != null) {
      numLines++;
      if (numLines < lineNumber) {
        currHighlightStart+=line.length() + 1;
      }
      if (numLines == lineNumber) {
        currHighlightEnd=currHighlightStart + line.length();
      }
      contents.append(line);
      contents.append('\n');
      line=reader.readLine();
    }
    return contents.toString();
  }
 catch (  IOException ioe) {
    return ""String_Node_Str"" + filePath + ""String_Node_Str"";
  }
}","private String readFile(String filePath,int lineNumber){
  try {
    File file=new File(filePath);
    if (!file.exists()) {
      return ""String_Node_Str"" + filePath + ""String_Node_Str"";
    }
    BufferedReader reader=new BufferedReader(new FileReader(file));
    StringBuffer contents=new StringBuffer();
    String line=reader.readLine();
    int numLines=0;
    while (line != null) {
      numLines++;
      if (numLines < lineNumber) {
        currHighlightStart+=line.length() + 1;
      }
      if (numLines == lineNumber) {
        currHighlightEnd=currHighlightStart + line.length();
      }
      contents.append(line);
      contents.append('\n');
      line=reader.readLine();
    }
    reader.close();
    return contents.toString();
  }
 catch (  IOException ioe) {
    return ""String_Node_Str"" + filePath + ""String_Node_Str"";
  }
}",0.9880668257756564
9399,"public boolean compile(String configFile,BuildProgressMonitor progressMonitor,boolean buildModel){
  if (configFile == null) {
    Ajde.getDefault().getErrorHandler().handleError(""String_Node_Str"");
  }
  init();
  try {
    AjBuildConfig buildConfig=genBuildConfig(configFile);
    buildConfig.setGenerateModelMode(buildModel);
    if (null == buildConfig) {
      return false;
    }
    currNotifier=new BuildNotifierAdapter(progressMonitor,buildManager);
    buildManager.setProgressListener(currNotifier);
    messageHandler.setBuildNotifierAdapter(currNotifier);
    String rtInfo=buildManager.checkRtJar(buildConfig);
    if (rtInfo != null) {
      Ajde.getDefault().getErrorHandler().handleWarning(""String_Node_Str"" + rtInfo + ""String_Node_Str"");
      return false;
    }
    boolean incrementalEnabled=buildConfig.isIncrementalMode() || buildConfig.isIncrementalFileMode();
    if (incrementalEnabled && nextBuild) {
      return buildManager.incrementalBuild(buildConfig,messageHandler);
    }
 else {
      if (incrementalEnabled) {
        nextBuild=incrementalEnabled;
      }
      return buildManager.batchBuild(buildConfig,messageHandler);
    }
  }
 catch (  AbortException e) {
    final IMessage message=e.getIMessage();
    if (null == message) {
      signalThrown(e);
    }
 else     if (null != message.getMessage()) {
      Ajde.getDefault().getErrorHandler().handleWarning(message.getMessage());
    }
 else     if (null != message.getThrown()) {
      signalThrown(message.getThrown());
    }
 else {
      signalThrown(e);
    }
    return false;
  }
catch (  Throwable t) {
    signalThrown(t);
    return false;
  }
}","public boolean compile(String configFile,BuildProgressMonitor progressMonitor,boolean buildModel){
  if (configFile == null) {
    Ajde.getDefault().getErrorHandler().handleError(""String_Node_Str"");
  }
  init();
  try {
    AjBuildConfig buildConfig=genBuildConfig(configFile);
    if (buildConfig == null) {
      return false;
    }
    buildConfig.setGenerateModelMode(buildModel);
    currNotifier=new BuildNotifierAdapter(progressMonitor,buildManager);
    buildManager.setProgressListener(currNotifier);
    messageHandler.setBuildNotifierAdapter(currNotifier);
    String rtInfo=buildManager.checkRtJar(buildConfig);
    if (rtInfo != null) {
      Ajde.getDefault().getErrorHandler().handleWarning(""String_Node_Str"" + rtInfo + ""String_Node_Str"");
      return false;
    }
    boolean incrementalEnabled=buildConfig.isIncrementalMode() || buildConfig.isIncrementalFileMode();
    if (incrementalEnabled && nextBuild) {
      return buildManager.incrementalBuild(buildConfig,messageHandler);
    }
 else {
      if (incrementalEnabled) {
        nextBuild=incrementalEnabled;
      }
      return buildManager.batchBuild(buildConfig,messageHandler);
    }
  }
 catch (  AbortException e) {
    final IMessage message=e.getIMessage();
    if (null == message) {
      signalThrown(e);
    }
 else     if (null != message.getMessage()) {
      Ajde.getDefault().getErrorHandler().handleWarning(message.getMessage());
    }
 else     if (null != message.getThrown()) {
      signalThrown(message.getThrown());
    }
 else {
      signalThrown(e);
    }
    return false;
  }
catch (  Throwable t) {
    signalThrown(t);
    return false;
  }
}",0.9538834951456312
9400,"/** 
 * Reads the entries of a configuration file.
 */
public List readConfigFile(String filePath){
  try {
    File configFile=new File(filePath);
    if (!configFile.exists()) {
      Ajde.getDefault().getErrorHandler().handleWarning(""String_Node_Str"" + filePath + ""String_Node_Str"");
    }
    List fileContents=new ArrayList();
    BufferedReader reader=new BufferedReader(new FileReader(configFile));
    String line=reader.readLine();
    while (line != null) {
      fileContents.add(line.replace('\\','/'));
      line=reader.readLine();
    }
    return fileContents;
  }
 catch (  IOException ioe) {
    Ajde.getDefault().getErrorHandler().handleError(""String_Node_Str"",ioe);
  }
  return null;
}","/** 
 * Reads the entries of a configuration file.
 */
public List readConfigFile(String filePath){
  try {
    File configFile=new File(filePath);
    if (!configFile.exists()) {
      Ajde.getDefault().getErrorHandler().handleWarning(""String_Node_Str"" + filePath + ""String_Node_Str"");
    }
    List fileContents=new ArrayList();
    BufferedReader reader=new BufferedReader(new FileReader(configFile));
    String line=reader.readLine();
    while (line != null) {
      fileContents.add(line.replace('\\','/'));
      line=reader.readLine();
    }
    reader.close();
    return fileContents;
  }
 catch (  IOException ioe) {
    Ajde.getDefault().getErrorHandler().handleError(""String_Node_Str"",ioe);
  }
  return null;
}",0.9860335195530726
9401,"private void writeFile(String contents,String filePath){
  try {
    FileOutputStream fos=new FileOutputStream(filePath,false);
    fos.write(contents.getBytes());
    fos.close();
  }
 catch (  IOException ioe) {
    Ajde.getDefault().getErrorHandler().handleError(""String_Node_Str"" + filePath,ioe);
  }
}","private void writeFile(String contents,String filePath){
  FileOutputStream fos=null;
  try {
    fos=new FileOutputStream(filePath,false);
    fos.write(contents.getBytes());
  }
 catch (  IOException ioe) {
    Ajde.getDefault().getErrorHandler().handleError(""String_Node_Str"" + filePath,ioe);
  }
 finally {
    if (fos != null)     try {
      fos.close();
    }
 catch (    IOException ioe) {
    }
  }
}",0.7580419580419581
9402,"public static List getPackagesInModel(){
  List packages=new ArrayList();
  IHierarchy model=Ajde.getDefault().getStructureModelManager().getHierarchy();
  if (model.equals(IHierarchy.NO_STRUCTURE)) {
    return null;
  }
 else {
    return getPackagesHelper((IProgramElement)model.getRoot(),IProgramElement.Kind.PACKAGE,null,packages);
  }
}","public static List getPackagesInModel(){
  List packages=new ArrayList();
  IHierarchy model=Ajde.getDefault().getStructureModelManager().getHierarchy();
  if (model.getRoot().equals(IHierarchy.NO_STRUCTURE)) {
    return null;
  }
 else {
    return getPackagesHelper((IProgramElement)model.getRoot(),IProgramElement.Kind.PACKAGE,null,packages);
  }
}",0.9855907780979828
9403,"private List findMatchesHelper(IProgramElement node,String pattern,IProgramElement.Kind kind,List matches){
  if (node != null && node.getName().indexOf(pattern) != -1) {
    if (kind == null || node.getKind().equals(kind)) {
      matches.add(node);
    }
  }
  for (Iterator it=node.getChildren().iterator(); it.hasNext(); ) {
    IProgramElement nextNode=(IProgramElement)it.next();
    if (nextNode instanceof IProgramElement) {
      findMatchesHelper((IProgramElement)nextNode,pattern,kind,matches);
    }
  }
  return matches;
}","private List findMatchesHelper(IProgramElement node,String pattern,IProgramElement.Kind kind,List matches){
  if (node != null && node.getName().indexOf(pattern) != -1) {
    if (kind == null || node.getKind().equals(kind)) {
      matches.add(node);
    }
  }
  if (node.getChildren() != null) {
    for (Iterator it=node.getChildren().iterator(); it.hasNext(); ) {
      IProgramElement nextNode=(IProgramElement)it.next();
      if (nextNode instanceof IProgramElement) {
        findMatchesHelper((IProgramElement)nextNode,pattern,kind,matches);
      }
    }
  }
  return matches;
}",0.9233511586452764
9404,"public void tearDown(){
  BcweaverTests.removeOutDir();
  outDir=null;
  outDirPath=null;
}","public void tearDown() throws Exception {
  super.tearDown();
  BcweaverTests.removeOutDir();
  outDir=null;
  outDirPath=null;
}",0.8272727272727273
9405,"/** 
 * Add new options from the ProjectPropertiesAdapter to the configuration. <ul> <li>New list entries are added if not duplicates in, for classpath, aspectpath, injars, inpath and sourceroots</li> <li>New bootclasspath entries are ignored XXX</li> <li>Set only one new entry for output dir or output jar only if there is no output dir/jar entry in the config</li> </ul> Subsequent changes to the ProjectPropertiesAdapter will not affect the configuration. <p>Added by AMC 01.20.2003, bugzilla #29769
 */
private void configureProjectOptions(AjBuildConfig config,ProjectPropertiesAdapter properties){
  String propcp=properties.getClasspath();
  if (!LangUtil.isEmpty(propcp)) {
    StringTokenizer st=new StringTokenizer(propcp,File.pathSeparator);
    List configClasspath=config.getClasspath();
    ArrayList toAdd=new ArrayList();
    while (st.hasMoreTokens()) {
      String entry=st.nextToken();
      if (!configClasspath.contains(entry)) {
        toAdd.add(entry);
      }
    }
    if (0 < toAdd.size()) {
      ArrayList both=new ArrayList(configClasspath.size() + toAdd.size());
      both.addAll(configClasspath);
      both.addAll(toAdd);
      config.setClasspath(both);
      Ajde.getDefault().logEvent(""String_Node_Str"" + both);
    }
  }
  if ((null == config.getOutputDir() && (null == config.getOutputJar()))) {
    String outPath=properties.getOutputPath();
    if (!LangUtil.isEmpty(outPath)) {
      config.setOutputDir(new File(outPath));
    }
    String outJar=properties.getOutJar();
    if (!LangUtil.isEmpty(outJar)) {
      config.setOutputJar(new File(outJar));
    }
  }
  join(config.getSourceRoots(),properties.getSourceRoots());
  join(config.getInJars(),properties.getInJars());
  join(config.getInpath(),properties.getInpath());
  config.setSourcePathResources(properties.getSourcePathResources());
  join(config.getAspectpath(),properties.getAspectPath());
}","/** 
 * Add new options from the ProjectPropertiesAdapter to the configuration. <ul> <li>New list entries are added if not duplicates in, for classpath, aspectpath, injars, inpath and sourceroots</li> <li>Set only one new entry for output dir or output jar only if there is no output dir/jar entry in the config</li> </ul> Subsequent changes to the ProjectPropertiesAdapter will not affect the configuration. <p>Added by AMC 01.20.2003, bugzilla #29769
 */
private void configureProjectOptions(AjBuildConfig config,ProjectPropertiesAdapter properties){
  String propcp=properties.getClasspath();
  if (!LangUtil.isEmpty(propcp)) {
    StringTokenizer st=new StringTokenizer(propcp,File.pathSeparator);
    List configClasspath=config.getClasspath();
    ArrayList toAdd=new ArrayList();
    while (st.hasMoreTokens()) {
      String entry=st.nextToken();
      if (!configClasspath.contains(entry)) {
        toAdd.add(entry);
      }
    }
    if (0 < toAdd.size()) {
      ArrayList both=new ArrayList(configClasspath.size() + toAdd.size());
      both.addAll(configClasspath);
      both.addAll(toAdd);
      config.setClasspath(both);
      Ajde.getDefault().logEvent(""String_Node_Str"" + both);
    }
  }
  propcp=properties.getBootClasspath();
  if (!LangUtil.isEmpty(propcp)) {
    StringTokenizer st=new StringTokenizer(propcp,File.pathSeparator);
    List configClasspath=config.getBootclasspath();
    ArrayList toAdd=new ArrayList();
    while (st.hasMoreTokens()) {
      String entry=st.nextToken();
      if (!configClasspath.contains(entry)) {
        toAdd.add(entry);
      }
    }
    if (0 < toAdd.size()) {
      ArrayList both=new ArrayList(configClasspath.size() + toAdd.size());
      both.addAll(configClasspath);
      both.addAll(toAdd);
      config.setBootclasspath(both);
      Ajde.getDefault().logEvent(""String_Node_Str"" + both);
    }
  }
  if ((null == config.getOutputDir() && (null == config.getOutputJar()))) {
    String outPath=properties.getOutputPath();
    if (!LangUtil.isEmpty(outPath)) {
      config.setOutputDir(new File(outPath));
    }
    String outJar=properties.getOutJar();
    if (!LangUtil.isEmpty(outJar)) {
      config.setOutputJar(new File(outJar));
    }
  }
  join(config.getSourceRoots(),properties.getSourceRoots());
  join(config.getInJars(),properties.getInJars());
  join(config.getInpath(),properties.getInpath());
  config.setSourcePathResources(properties.getSourcePathResources());
  join(config.getAspectpath(),properties.getAspectPath());
}",0.8385487528344672
9406,"/** 
 * If the classpath is not set, we use the environment's java.class.path, but remove the aspectjtools.jar entry from that list in order to prevent wierd bootstrap issues (refer to bug#39959).
 */
public List getClasspath(AjcConfigParser parser){
  List ret=new ArrayList();
  if (parser.bootclasspath == null) {
    addClasspath(System.getProperty(""String_Node_Str"",""String_Node_Str""),ret);
  }
 else {
    addClasspath(parser.bootclasspath,ret);
  }
  String extdirs=parser.extdirs;
  if (extdirs == null) {
    extdirs=System.getProperty(""String_Node_Str"",""String_Node_Str"");
  }
  addExtDirs(extdirs,ret);
  if (parser.classpath == null) {
    addClasspath(System.getProperty(""String_Node_Str"",""String_Node_Str""),ret);
    List fixedList=new ArrayList();
    for (Iterator it=ret.iterator(); it.hasNext(); ) {
      String entry=(String)it.next();
      if (!entry.endsWith(""String_Node_Str"")) {
        fixedList.add(entry);
      }
    }
    ret=fixedList;
  }
 else {
    addClasspath(parser.classpath,ret);
  }
  return ret;
}","/** 
 * If the classpath is not set, we use the environment's java.class.path, but remove the aspectjtools.jar entry from that list in order to prevent wierd bootstrap issues (refer to bug#39959).
 */
public List getClasspath(AjcConfigParser parser){
  List ret=new ArrayList();
  String extdirs=parser.extdirs;
  if (extdirs == null) {
    extdirs=System.getProperty(""String_Node_Str"",""String_Node_Str"");
  }
  addExtDirs(extdirs,ret);
  if (parser.classpath == null) {
    addClasspath(System.getProperty(""String_Node_Str"",""String_Node_Str""),ret);
    List fixedList=new ArrayList();
    for (Iterator it=ret.iterator(); it.hasNext(); ) {
      String entry=(String)it.next();
      if (!entry.endsWith(""String_Node_Str"")) {
        fixedList.add(entry);
      }
    }
    ret=fixedList;
  }
 else {
    addClasspath(parser.classpath,ret);
  }
  return ret;
}",0.4644549763033175
9407,"/** 
 * Generate build configuration for the input args, passing to handler any error messages.
 * @param args the String[] arguments for the build configuration
 * @param setClasspath	determines if the classpath should be parsed and set on the build configuration
 * @param configFile	can be null
 * @return AjBuildConfig per args, which will be invalid unless there are no handler errors.
 */
public AjBuildConfig populateBuildConfig(AjBuildConfig buildConfig,String[] args,boolean setClasspath,File configFile){
  Dump.saveCommandLine(args);
  buildConfig.setConfigFile(configFile);
  try {
    super.filenames=new String[]{""String_Node_Str""};
    AjcConfigParser parser=new AjcConfigParser(buildConfig,handler);
    parser.parseCommandLine(args);
    boolean swi=buildConfig.getShowWeavingInformation();
    if (handler instanceof CountingMessageHandler) {
      IMessageHandler delegate=((CountingMessageHandler)handler).delegate;
      if (delegate instanceof MessageHandler) {
        if (swi)         ((MessageHandler)delegate).dontIgnore(IMessage.WEAVEINFO);
 else         ((MessageHandler)delegate).ignore(IMessage.WEAVEINFO);
      }
    }
    boolean incrementalMode=buildConfig.isIncrementalMode() || buildConfig.isIncrementalFileMode();
    List fileList=new ArrayList();
    List files=parser.getFiles();
    if (!LangUtil.isEmpty(files)) {
      if (incrementalMode) {
        MessageUtil.error(handler,""String_Node_Str"");
      }
 else {
        fileList.addAll(files);
      }
    }
    List javaArgList=new ArrayList();
    javaArgList.add(""String_Node_Str"");
    javaArgList.add(""String_Node_Str"");
    javaArgList.add(System.getProperty(""String_Node_Str""));
    javaArgList.add(""String_Node_Str"");
    javaArgList.add(System.getProperty(""String_Node_Str""));
    javaArgList.addAll(parser.getUnparsedArgs());
    super.configure((String[])javaArgList.toArray(new String[javaArgList.size()]));
    if (!proceed) {
      buildConfig.doNotProceed();
      return buildConfig;
    }
    if (buildConfig.getSourceRoots() != null) {
      for (Iterator i=buildConfig.getSourceRoots().iterator(); i.hasNext(); ) {
        fileList.addAll(collectSourceRootFiles((File)i.next()));
      }
    }
    buildConfig.setFiles(fileList);
    if (destinationPath != null) {
      buildConfig.setOutputDir(new File(destinationPath));
    }
    if (setClasspath) {
      buildConfig.setClasspath(getClasspath(parser));
    }
    if (incrementalMode && (0 == buildConfig.getSourceRoots().size())) {
      MessageUtil.error(handler,""String_Node_Str"");
    }
    File outjar=buildConfig.getOutputJar();
    if (outjar != null) {
      for (Iterator i=buildConfig.getInJars().iterator(); i.hasNext(); ) {
        File injar=(File)i.next();
        if (injar.equals(outjar)) {
          String message=WeaverMessages.format(WeaverMessages.OUTJAR_IN_INPUT_PATH);
          MessageUtil.error(handler,message);
        }
      }
      for (Iterator i=buildConfig.getInpath().iterator(); i.hasNext(); ) {
        File inPathElement=(File)i.next();
        if (!inPathElement.isDirectory() && inPathElement.equals(outjar)) {
          String message=WeaverMessages.format(WeaverMessages.OUTJAR_IN_INPUT_PATH);
          MessageUtil.error(handler,message);
        }
      }
      for (Iterator i=buildConfig.getAspectpath().iterator(); i.hasNext(); ) {
        File pathElement=(File)i.next();
        if (!pathElement.isDirectory() && pathElement.equals(outjar)) {
          String message=WeaverMessages.format(WeaverMessages.OUTJAR_IN_INPUT_PATH);
          MessageUtil.error(handler,message);
        }
      }
    }
    setDebugOptions();
    buildConfig.getOptions().set(options);
  }
 catch (  InvalidInputException iie) {
    ISourceLocation location=null;
    if (buildConfig.getConfigFile() != null) {
      location=new SourceLocation(buildConfig.getConfigFile(),0);
    }
    IMessage m=new Message(iie.getMessage(),IMessage.ERROR,null,location);
    handler.handleMessage(m);
  }
  return buildConfig;
}","/** 
 * Generate build configuration for the input args, passing to handler any error messages.
 * @param args the String[] arguments for the build configuration
 * @param setClasspath	determines if the classpath should be parsed and set on the build configuration
 * @param configFile	can be null
 * @return AjBuildConfig per args, which will be invalid unless there are no handler errors.
 */
public AjBuildConfig populateBuildConfig(AjBuildConfig buildConfig,String[] args,boolean setClasspath,File configFile){
  Dump.saveCommandLine(args);
  buildConfig.setConfigFile(configFile);
  try {
    super.filenames=new String[]{""String_Node_Str""};
    AjcConfigParser parser=new AjcConfigParser(buildConfig,handler);
    parser.parseCommandLine(args);
    boolean swi=buildConfig.getShowWeavingInformation();
    if (handler instanceof CountingMessageHandler) {
      IMessageHandler delegate=((CountingMessageHandler)handler).delegate;
      if (delegate instanceof MessageHandler) {
        if (swi)         ((MessageHandler)delegate).dontIgnore(IMessage.WEAVEINFO);
 else         ((MessageHandler)delegate).ignore(IMessage.WEAVEINFO);
      }
    }
    boolean incrementalMode=buildConfig.isIncrementalMode() || buildConfig.isIncrementalFileMode();
    List fileList=new ArrayList();
    List files=parser.getFiles();
    if (!LangUtil.isEmpty(files)) {
      if (incrementalMode) {
        MessageUtil.error(handler,""String_Node_Str"");
      }
 else {
        fileList.addAll(files);
      }
    }
    List javaArgList=new ArrayList();
    javaArgList.add(""String_Node_Str"");
    javaArgList.add(""String_Node_Str"");
    javaArgList.add(System.getProperty(""String_Node_Str""));
    javaArgList.add(""String_Node_Str"");
    javaArgList.add(System.getProperty(""String_Node_Str""));
    javaArgList.addAll(parser.getUnparsedArgs());
    super.configure((String[])javaArgList.toArray(new String[javaArgList.size()]));
    if (!proceed) {
      buildConfig.doNotProceed();
      return buildConfig;
    }
    if (buildConfig.getSourceRoots() != null) {
      for (Iterator i=buildConfig.getSourceRoots().iterator(); i.hasNext(); ) {
        fileList.addAll(collectSourceRootFiles((File)i.next()));
      }
    }
    buildConfig.setFiles(fileList);
    if (destinationPath != null) {
      buildConfig.setOutputDir(new File(destinationPath));
    }
    if (setClasspath) {
      buildConfig.setClasspath(getClasspath(parser));
      buildConfig.setBootclasspath(getBootclasspath(parser));
    }
    if (incrementalMode && (0 == buildConfig.getSourceRoots().size())) {
      MessageUtil.error(handler,""String_Node_Str"");
    }
    File outjar=buildConfig.getOutputJar();
    if (outjar != null) {
      for (Iterator i=buildConfig.getInJars().iterator(); i.hasNext(); ) {
        File injar=(File)i.next();
        if (injar.equals(outjar)) {
          String message=WeaverMessages.format(WeaverMessages.OUTJAR_IN_INPUT_PATH);
          MessageUtil.error(handler,message);
        }
      }
      for (Iterator i=buildConfig.getInpath().iterator(); i.hasNext(); ) {
        File inPathElement=(File)i.next();
        if (!inPathElement.isDirectory() && inPathElement.equals(outjar)) {
          String message=WeaverMessages.format(WeaverMessages.OUTJAR_IN_INPUT_PATH);
          MessageUtil.error(handler,message);
        }
      }
      for (Iterator i=buildConfig.getAspectpath().iterator(); i.hasNext(); ) {
        File pathElement=(File)i.next();
        if (!pathElement.isDirectory() && pathElement.equals(outjar)) {
          String message=WeaverMessages.format(WeaverMessages.OUTJAR_IN_INPUT_PATH);
          MessageUtil.error(handler,message);
        }
      }
    }
    setDebugOptions();
    buildConfig.getOptions().set(options);
  }
 catch (  InvalidInputException iie) {
    ISourceLocation location=null;
    if (buildConfig.getConfigFile() != null) {
      location=new SourceLocation(buildConfig.getConfigFile(),0);
    }
    IMessage m=new Message(iie.getMessage(),IMessage.ERROR,null,location);
    handler.handleMessage(m);
  }
  return buildConfig;
}",0.992322932144626
9408,"/** 
 * This includes all entries from -bootclasspath, -extdirs, -classpath, 
 */
public List getClasspath(){
  return classpath;
}","/** 
 * This does not include -bootclasspath but includes -extdirs and -classpath
 */
public List getClasspath(){
  return classpath;
}",0.8195488721804511
9409,"/** 
 * @return List (String) classpath of injars, inpath, aspectpath entries, specified classpath (bootclasspath, extdirs, and  classpath), and output dir or jar
 */
public List getFullClasspath(){
  List full=new ArrayList();
  for (Iterator i=inJars.iterator(); i.hasNext(); ) {
    full.add(((File)i.next()).getAbsolutePath());
  }
  for (Iterator i=inPath.iterator(); i.hasNext(); ) {
    full.add(((File)i.next()).getAbsolutePath());
  }
  for (Iterator i=aspectpath.iterator(); i.hasNext(); ) {
    full.add(((File)i.next()).getAbsolutePath());
  }
  full.addAll(getClasspath());
  return full;
}","/** 
 * @return List (String) classpath of bootclasspath, injars, inpath, aspectpath entries, specified classpath (extdirs, and classpath), and output dir or jar
 */
public List getFullClasspath(){
  List full=new ArrayList();
  full.addAll(getBootclasspath());
  for (Iterator i=inJars.iterator(); i.hasNext(); ) {
    full.add(((File)i.next()).getAbsolutePath());
  }
  for (Iterator i=inPath.iterator(); i.hasNext(); ) {
    full.add(((File)i.next()).getAbsolutePath());
  }
  for (Iterator i=aspectpath.iterator(); i.hasNext(); ) {
    full.add(((File)i.next()).getAbsolutePath());
  }
  full.addAll(getClasspath());
  return full;
}",0.9306451612903226
9410,"/** 
 * init only on initial batch compile? no file-specific options 
 */
private void initBcelWorld(IMessageHandler handler) throws IOException {
  bcelWorld=new BcelWorld(buildConfig.getClasspath(),handler,null);
  bcelWorld.setXnoInline(buildConfig.isXnoInline());
  bcelWorld.setXlazyTjp(buildConfig.isXlazyTjp());
  bcelWeaver=new BcelWeaver(bcelWorld);
  state.binarySourceFiles=new HashMap();
  for (Iterator i=buildConfig.getAspectpath().iterator(); i.hasNext(); ) {
    File f=(File)i.next();
    bcelWeaver.addLibraryJarFile(f);
  }
  if (buildConfig.getLintMode().equals(AjBuildConfig.AJLINT_DEFAULT)) {
    bcelWorld.getLint().loadDefaultProperties();
  }
 else {
    bcelWorld.getLint().setAll(buildConfig.getLintMode());
  }
  if (buildConfig.getLintSpecFile() != null) {
    bcelWorld.getLint().setFromProperties(buildConfig.getLintSpecFile());
  }
  for (Iterator i=buildConfig.getInJars().iterator(); i.hasNext(); ) {
    File inJar=(File)i.next();
    List unwovenClasses=bcelWeaver.addJarFile(inJar,buildConfig.getOutputDir(),false);
    state.binarySourceFiles.put(inJar.getPath(),unwovenClasses);
  }
  for (Iterator i=buildConfig.getInpath().iterator(); i.hasNext(); ) {
    File inPathElement=(File)i.next();
    if (!inPathElement.isDirectory()) {
      List unwovenClasses=bcelWeaver.addJarFile(inPathElement,buildConfig.getOutputDir(),true);
      state.binarySourceFiles.put(inPathElement.getPath(),unwovenClasses);
    }
 else {
      File[] binSrcs=FileUtil.listFiles(inPathElement,binarySourceFilter);
      for (int j=0; j < binSrcs.length; j++) {
        UnwovenClassFile ucf=bcelWeaver.addClassFile(binSrcs[j],inPathElement,buildConfig.getOutputDir());
        List ucfl=new ArrayList();
        ucfl.add(ucf);
        state.binarySourceFiles.put(binSrcs[j].getPath(),ucfl);
      }
    }
  }
  bcelWeaver.setReweavableMode(buildConfig.isXreweavable(),buildConfig.getXreweavableCompressClasses());
  bcelWorld.resolve(""String_Node_Str"");
}","/** 
 * init only on initial batch compile? no file-specific options 
 */
private void initBcelWorld(IMessageHandler handler) throws IOException {
  List cp=buildConfig.getBootclasspath();
  cp.addAll(buildConfig.getClasspath());
  bcelWorld=new BcelWorld(cp,handler,null);
  bcelWorld.setXnoInline(buildConfig.isXnoInline());
  bcelWorld.setXlazyTjp(buildConfig.isXlazyTjp());
  bcelWeaver=new BcelWeaver(bcelWorld);
  state.binarySourceFiles=new HashMap();
  for (Iterator i=buildConfig.getAspectpath().iterator(); i.hasNext(); ) {
    File f=(File)i.next();
    bcelWeaver.addLibraryJarFile(f);
  }
  if (buildConfig.getLintMode().equals(AjBuildConfig.AJLINT_DEFAULT)) {
    bcelWorld.getLint().loadDefaultProperties();
  }
 else {
    bcelWorld.getLint().setAll(buildConfig.getLintMode());
  }
  if (buildConfig.getLintSpecFile() != null) {
    bcelWorld.getLint().setFromProperties(buildConfig.getLintSpecFile());
  }
  for (Iterator i=buildConfig.getInJars().iterator(); i.hasNext(); ) {
    File inJar=(File)i.next();
    List unwovenClasses=bcelWeaver.addJarFile(inJar,buildConfig.getOutputDir(),false);
    state.binarySourceFiles.put(inJar.getPath(),unwovenClasses);
  }
  for (Iterator i=buildConfig.getInpath().iterator(); i.hasNext(); ) {
    File inPathElement=(File)i.next();
    if (!inPathElement.isDirectory()) {
      List unwovenClasses=bcelWeaver.addJarFile(inPathElement,buildConfig.getOutputDir(),true);
      state.binarySourceFiles.put(inPathElement.getPath(),unwovenClasses);
    }
 else {
      File[] binSrcs=FileUtil.listFiles(inPathElement,binarySourceFilter);
      for (int j=0; j < binSrcs.length; j++) {
        UnwovenClassFile ucf=bcelWeaver.addClassFile(binSrcs[j],inPathElement,buildConfig.getOutputDir());
        List ucfl=new ArrayList();
        ucfl.add(ucf);
        state.binarySourceFiles.put(binSrcs[j].getPath(),ucfl);
      }
    }
  }
  bcelWeaver.setReweavableMode(buildConfig.isXreweavable(),buildConfig.getXreweavableCompressClasses());
  bcelWorld.resolve(""String_Node_Str"");
}",0.9722707969023232
9411,"String makeClasspathString(){
  if (buildConfig == null || buildConfig.getClasspath() == null)   return ""String_Node_Str"";
  StringBuffer buf=new StringBuffer();
  boolean first=true;
  for (Iterator it=buildConfig.getClasspath().iterator(); it.hasNext(); ) {
    if (first) {
      first=false;
    }
 else {
      buf.append(File.pathSeparator);
    }
    buf.append(it.next().toString());
  }
  return buf.toString();
}","String makeClasspathString(){
  if (buildConfig == null || buildConfig.getFullClasspath() == null)   return ""String_Node_Str"";
  StringBuffer buf=new StringBuffer();
  boolean first=true;
  for (Iterator it=buildConfig.getFullClasspath().iterator(); it.hasNext(); ) {
    if (first) {
      first=false;
    }
 else {
      buf.append(File.pathSeparator);
    }
    buf.append(it.next().toString());
  }
  return buf.toString();
}",0.9906103286384976
9412,"/** 
 * This will return null if aspectjrt.jar is present and has the correct version. Otherwise it will return a string message indicating the problem.
 */
public String checkRtJar(AjBuildConfig buildConfig){
  if (Version.text.equals(Version.DEVELOPMENT)) {
    return null;
  }
  if (buildConfig == null || buildConfig.getClasspath() == null)   return ""String_Node_Str"";
  for (Iterator it=buildConfig.getClasspath().iterator(); it.hasNext(); ) {
    File p=new File((String)it.next());
    if (p.isFile() && p.getName().equals(""String_Node_Str"")) {
      try {
        String version=null;
        Manifest manifest=new JarFile(p).getManifest();
        if (manifest == null) {
          return ""String_Node_Str"" + p.getAbsolutePath() + ""String_Node_Str""+ Version.text;
        }
        Attributes attr=manifest.getAttributes(""String_Node_Str"");
        if (null != attr) {
          version=attr.getValue(Attributes.Name.IMPLEMENTATION_VERSION);
          if (null != version) {
            version=version.trim();
          }
        }
        if (Version.DEVELOPMENT.equals(version)) {
          return null;
        }
 else         if (!Version.text.equals(version)) {
          return ""String_Node_Str"" + p.getAbsolutePath() + ""String_Node_Str""+ Version.text+ ""String_Node_Str""+ version;
        }
      }
 catch (      IOException ioe) {
        return ""String_Node_Str"" + p.getAbsolutePath() + ""String_Node_Str""+ ioe;
      }
      return null;
    }
 else {
    }
  }
  return ""String_Node_Str"" + makeClasspathString();
}","/** 
 * This will return null if aspectjrt.jar is present and has the correct version. Otherwise it will return a string message indicating the problem.
 */
public String checkRtJar(AjBuildConfig buildConfig){
  if (Version.text.equals(Version.DEVELOPMENT)) {
    return null;
  }
  if (buildConfig == null || buildConfig.getFullClasspath() == null)   return ""String_Node_Str"";
  for (Iterator it=buildConfig.getFullClasspath().iterator(); it.hasNext(); ) {
    File p=new File((String)it.next());
    if (p.isFile() && p.getName().equals(""String_Node_Str"")) {
      try {
        String version=null;
        Manifest manifest=new JarFile(p).getManifest();
        if (manifest == null) {
          return ""String_Node_Str"" + p.getAbsolutePath() + ""String_Node_Str""+ Version.text;
        }
        Attributes attr=manifest.getAttributes(""String_Node_Str"");
        if (null != attr) {
          version=attr.getValue(Attributes.Name.IMPLEMENTATION_VERSION);
          if (null != version) {
            version=version.trim();
          }
        }
        if (Version.DEVELOPMENT.equals(version)) {
          return null;
        }
 else         if (!Version.text.equals(version)) {
          return ""String_Node_Str"" + p.getAbsolutePath() + ""String_Node_Str""+ Version.text+ ""String_Node_Str""+ version;
        }
      }
 catch (      IOException ioe) {
        return ""String_Node_Str"" + p.getAbsolutePath() + ""String_Node_Str""+ ioe;
      }
      return null;
    }
 else {
    }
  }
  return ""String_Node_Str"" + makeClasspathString();
}",0.9973992197659298
9413,"public void testPathResolutionFromConfigArgs(){
  String FILE_PATH=""String_Node_Str"" + TEST_DIR + ""String_Node_Str"";
  AjBuildConfig config=genBuildConfig(new String[]{FILE_PATH},messageWriter);
  List classpath=config.getClasspath();
  assertEquals(""String_Node_Str"",3,classpath.size());
  Iterator cpIter=classpath.iterator();
  try {
    assertEquals(""String_Node_Str"",new File(TEST_DIR + File.separator + ""String_Node_Str"").getCanonicalPath(),cpIter.next());
    assertEquals(""String_Node_Str"",new File(TEST_DIR + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"").getCanonicalPath(),cpIter.next());
    assertEquals(""String_Node_Str"",new File(TEST_DIR + File.separator + ""String_Node_Str"").getCanonicalPath(),cpIter.next());
    List files=config.getFiles();
    assertEquals(""String_Node_Str"",2,files.size());
    Iterator fIter=files.iterator();
    assertEquals(""String_Node_Str"",new File(TEST_DIR + File.separator + ""String_Node_Str"").getCanonicalFile(),fIter.next());
    assertEquals(""String_Node_Str"",new File(TEST_DIR + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"").getCanonicalFile(),fIter.next());
  }
 catch (  IOException ex) {
    fail(""String_Node_Str"" + ex);
  }
}","public void testPathResolutionFromConfigArgs(){
  String FILE_PATH=""String_Node_Str"" + TEST_DIR + ""String_Node_Str"";
  AjBuildConfig config=genBuildConfig(new String[]{FILE_PATH},messageWriter);
  List classpath=config.getFullClasspath();
  assertEquals(""String_Node_Str"",3,classpath.size());
  Iterator cpIter=classpath.iterator();
  try {
    assertEquals(""String_Node_Str"",new File(TEST_DIR + File.separator + ""String_Node_Str"").getCanonicalPath(),cpIter.next());
    assertEquals(""String_Node_Str"",new File(TEST_DIR + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"").getCanonicalPath(),cpIter.next());
    assertEquals(""String_Node_Str"",new File(TEST_DIR + File.separator + ""String_Node_Str"").getCanonicalPath(),cpIter.next());
    List files=config.getFiles();
    assertEquals(""String_Node_Str"",2,files.size());
    Iterator fIter=files.iterator();
    assertEquals(""String_Node_Str"",new File(TEST_DIR + File.separator + ""String_Node_Str"").getCanonicalFile(),fIter.next());
    assertEquals(""String_Node_Str"",new File(TEST_DIR + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str"").getCanonicalFile(),fIter.next());
  }
 catch (  IOException ex) {
    fail(""String_Node_Str"" + ex);
  }
}",0.9983753046303818
9414,"public void testBootclasspath() throws InvalidInputException {
  final String PATH=""String_Node_Str"" + File.separator + ""String_Node_Str"";
  AjBuildConfig config=genBuildConfig(new String[]{""String_Node_Str"",PATH},messageWriter);
  assertTrue(""String_Node_Str"" + PATH + ""String_Node_Str""+ config.getClasspath().toString(),((String)config.getClasspath().get(0)).indexOf(PATH) != -1);
  config=genBuildConfig(new String[]{},messageWriter);
  assertTrue(config.getClasspath().toString(),!config.getClasspath().get(0).equals(PATH));
}","public void testBootclasspath() throws InvalidInputException {
  final String PATH=""String_Node_Str"" + File.separator + ""String_Node_Str"";
  AjBuildConfig config=genBuildConfig(new String[]{""String_Node_Str"",PATH},messageWriter);
  assertTrue(""String_Node_Str"" + PATH + ""String_Node_Str""+ config.getBootclasspath().toString(),((String)config.getBootclasspath().get(0)).indexOf(PATH) != -1);
  config=genBuildConfig(new String[]{},messageWriter);
  assertTrue(config.getBootclasspath().toString(),!config.getBootclasspath().get(0).equals(PATH));
}",0.9776951672862454
9415,"/** 
 * Delegate of both runCommand and repeatCommand. This invokes the argument parser each time (even when repeating). If the parser detects errors, this signals an  abort with the usage message and returns false.
 * @param handler the IMessageHandler sink for any messages
 * @param repeat if true, do incremental build, else do batch build
 * @return false if handler has any errors or command failed
 */
protected boolean doCommand(IMessageHandler handler,boolean repeat){
  try {
    CountingMessageHandler counter=new CountingMessageHandler(handler);
    if (counter.hasErrors()) {
      return false;
    }
    AjBuildConfig config=genBuildConfig(savedArgs,counter);
    if (!config.shouldProceed()) {
      return true;
    }
    if (!config.hasSources()) {
      MessageUtil.error(counter,""String_Node_Str"");
    }
    if (counter.hasErrors()) {
      String usage=BuildArgParser.getUsage();
      MessageUtil.abort(handler,usage);
      return false;
    }
    return ((repeat ? buildManager.incrementalBuild(config,handler) : buildManager.batchBuild(config,handler)) && !counter.hasErrors());
  }
 catch (  AbortException ae) {
    if (ae.isSilent()) {
      throw ae;
    }
 else {
      MessageUtil.abort(handler,ABORT_MESSAGE,ae);
    }
  }
catch (  MissingSourceFileException t) {
    MessageUtil.error(handler,t.getMessage());
  }
catch (  Throwable t) {
    MessageUtil.abort(handler,ABORT_MESSAGE,t);
  }
  return false;
}","/** 
 * Delegate of both runCommand and repeatCommand. This invokes the argument parser each time (even when repeating). If the parser detects errors, this signals an  abort with the usage message and returns false.
 * @param handler the IMessageHandler sink for any messages
 * @param repeat if true, do incremental build, else do batch build
 * @return false if handler has any errors or command failed
 */
protected boolean doCommand(IMessageHandler handler,boolean repeat){
  try {
    CountingMessageHandler counter=new CountingMessageHandler(handler);
    if (counter.hasErrors()) {
      return false;
    }
    AjBuildConfig config=genBuildConfig(savedArgs,counter);
    if (!config.shouldProceed()) {
      return true;
    }
    if (!config.hasSources()) {
      MessageUtil.error(counter,""String_Node_Str"");
    }
    if (counter.hasErrors()) {
      String usage=BuildArgParser.getUsage();
      MessageUtil.abort(handler,usage);
      return false;
    }
    boolean result=((repeat ? buildManager.incrementalBuild(config,handler) : buildManager.batchBuild(config,handler)) && !counter.hasErrors());
    Dump.dumpOnExit();
    return result;
  }
 catch (  AbortException ae) {
    if (ae.isSilent()) {
      throw ae;
    }
 else {
      MessageUtil.abort(handler,ABORT_MESSAGE,ae);
    }
  }
catch (  MissingSourceFileException t) {
    MessageUtil.error(handler,t.getMessage());
  }
catch (  Throwable t) {
    MessageUtil.abort(handler,ABORT_MESSAGE,t);
    Dump.dumpWithException(t);
  }
  return false;
}",0.9679379007762404
9416,"/** 
 * Generate build configuration for the input args, passing to handler any error messages.
 * @param args the String[] arguments for the build configuration
 * @param setClasspath	determines if the classpath should be parsed and set on the build configuration
 * @param configFile	can be null
 * @return AjBuildConfig per args, which will be invalid unless there are no handler errors.
 */
public AjBuildConfig populateBuildConfig(AjBuildConfig buildConfig,String[] args,boolean setClasspath,File configFile){
  buildConfig.setConfigFile(configFile);
  try {
    super.filenames=new String[]{""String_Node_Str""};
    AjcConfigParser parser=new AjcConfigParser(buildConfig,handler);
    parser.parseCommandLine(args);
    boolean swi=buildConfig.getShowWeavingInformation();
    if (handler instanceof CountingMessageHandler) {
      IMessageHandler delegate=((CountingMessageHandler)handler).delegate;
      if (delegate instanceof MessageHandler) {
        if (swi)         ((MessageHandler)delegate).dontIgnore(IMessage.WEAVEINFO);
 else         ((MessageHandler)delegate).ignore(IMessage.WEAVEINFO);
      }
    }
    boolean incrementalMode=buildConfig.isIncrementalMode() || buildConfig.isIncrementalFileMode();
    List fileList=new ArrayList();
    List files=parser.getFiles();
    if (!LangUtil.isEmpty(files)) {
      if (incrementalMode) {
        MessageUtil.error(handler,""String_Node_Str"");
      }
 else {
        fileList.addAll(files);
      }
    }
    List javaArgList=new ArrayList();
    javaArgList.add(""String_Node_Str"");
    javaArgList.add(""String_Node_Str"");
    javaArgList.add(System.getProperty(""String_Node_Str""));
    javaArgList.add(""String_Node_Str"");
    javaArgList.add(System.getProperty(""String_Node_Str""));
    javaArgList.addAll(parser.getUnparsedArgs());
    super.configure((String[])javaArgList.toArray(new String[javaArgList.size()]));
    if (!proceed) {
      buildConfig.doNotProceed();
      return buildConfig;
    }
    if (buildConfig.getSourceRoots() != null) {
      for (Iterator i=buildConfig.getSourceRoots().iterator(); i.hasNext(); ) {
        fileList.addAll(collectSourceRootFiles((File)i.next()));
      }
    }
    buildConfig.setFiles(fileList);
    if (destinationPath != null) {
      buildConfig.setOutputDir(new File(destinationPath));
    }
    if (setClasspath) {
      buildConfig.setClasspath(getClasspath(parser));
    }
    if (incrementalMode && (0 == buildConfig.getSourceRoots().size())) {
      MessageUtil.error(handler,""String_Node_Str"");
    }
    File outjar=buildConfig.getOutputJar();
    if (outjar != null) {
      for (Iterator i=buildConfig.getInJars().iterator(); i.hasNext(); ) {
        File injar=(File)i.next();
        if (injar.equals(outjar)) {
          String message=WeaverMessages.format(WeaverMessages.OUTJAR_IN_INPUT_PATH);
          MessageUtil.error(handler,message);
        }
      }
      for (Iterator i=buildConfig.getInpath().iterator(); i.hasNext(); ) {
        File inPathElement=(File)i.next();
        if (!inPathElement.isDirectory() && inPathElement.equals(outjar)) {
          String message=WeaverMessages.format(WeaverMessages.OUTJAR_IN_INPUT_PATH);
          MessageUtil.error(handler,message);
        }
      }
      for (Iterator i=buildConfig.getAspectpath().iterator(); i.hasNext(); ) {
        File pathElement=(File)i.next();
        if (!pathElement.isDirectory() && pathElement.equals(outjar)) {
          String message=WeaverMessages.format(WeaverMessages.OUTJAR_IN_INPUT_PATH);
          MessageUtil.error(handler,message);
        }
      }
    }
    setDebugOptions();
    buildConfig.getOptions().set(options);
  }
 catch (  InvalidInputException iie) {
    ISourceLocation location=null;
    if (buildConfig.getConfigFile() != null) {
      location=new SourceLocation(buildConfig.getConfigFile(),0);
    }
    IMessage m=new Message(iie.getMessage(),IMessage.ERROR,null,location);
    handler.handleMessage(m);
  }
  return buildConfig;
}","/** 
 * Generate build configuration for the input args, passing to handler any error messages.
 * @param args the String[] arguments for the build configuration
 * @param setClasspath	determines if the classpath should be parsed and set on the build configuration
 * @param configFile	can be null
 * @return AjBuildConfig per args, which will be invalid unless there are no handler errors.
 */
public AjBuildConfig populateBuildConfig(AjBuildConfig buildConfig,String[] args,boolean setClasspath,File configFile){
  Dump.saveCommandLine(args);
  buildConfig.setConfigFile(configFile);
  try {
    super.filenames=new String[]{""String_Node_Str""};
    AjcConfigParser parser=new AjcConfigParser(buildConfig,handler);
    parser.parseCommandLine(args);
    boolean swi=buildConfig.getShowWeavingInformation();
    if (handler instanceof CountingMessageHandler) {
      IMessageHandler delegate=((CountingMessageHandler)handler).delegate;
      if (delegate instanceof MessageHandler) {
        if (swi)         ((MessageHandler)delegate).dontIgnore(IMessage.WEAVEINFO);
 else         ((MessageHandler)delegate).ignore(IMessage.WEAVEINFO);
      }
    }
    boolean incrementalMode=buildConfig.isIncrementalMode() || buildConfig.isIncrementalFileMode();
    List fileList=new ArrayList();
    List files=parser.getFiles();
    if (!LangUtil.isEmpty(files)) {
      if (incrementalMode) {
        MessageUtil.error(handler,""String_Node_Str"");
      }
 else {
        fileList.addAll(files);
      }
    }
    List javaArgList=new ArrayList();
    javaArgList.add(""String_Node_Str"");
    javaArgList.add(""String_Node_Str"");
    javaArgList.add(System.getProperty(""String_Node_Str""));
    javaArgList.add(""String_Node_Str"");
    javaArgList.add(System.getProperty(""String_Node_Str""));
    javaArgList.addAll(parser.getUnparsedArgs());
    super.configure((String[])javaArgList.toArray(new String[javaArgList.size()]));
    if (!proceed) {
      buildConfig.doNotProceed();
      return buildConfig;
    }
    if (buildConfig.getSourceRoots() != null) {
      for (Iterator i=buildConfig.getSourceRoots().iterator(); i.hasNext(); ) {
        fileList.addAll(collectSourceRootFiles((File)i.next()));
      }
    }
    buildConfig.setFiles(fileList);
    if (destinationPath != null) {
      buildConfig.setOutputDir(new File(destinationPath));
    }
    if (setClasspath) {
      buildConfig.setClasspath(getClasspath(parser));
    }
    if (incrementalMode && (0 == buildConfig.getSourceRoots().size())) {
      MessageUtil.error(handler,""String_Node_Str"");
    }
    File outjar=buildConfig.getOutputJar();
    if (outjar != null) {
      for (Iterator i=buildConfig.getInJars().iterator(); i.hasNext(); ) {
        File injar=(File)i.next();
        if (injar.equals(outjar)) {
          String message=WeaverMessages.format(WeaverMessages.OUTJAR_IN_INPUT_PATH);
          MessageUtil.error(handler,message);
        }
      }
      for (Iterator i=buildConfig.getInpath().iterator(); i.hasNext(); ) {
        File inPathElement=(File)i.next();
        if (!inPathElement.isDirectory() && inPathElement.equals(outjar)) {
          String message=WeaverMessages.format(WeaverMessages.OUTJAR_IN_INPUT_PATH);
          MessageUtil.error(handler,message);
        }
      }
      for (Iterator i=buildConfig.getAspectpath().iterator(); i.hasNext(); ) {
        File pathElement=(File)i.next();
        if (!pathElement.isDirectory() && pathElement.equals(outjar)) {
          String message=WeaverMessages.format(WeaverMessages.OUTJAR_IN_INPUT_PATH);
          MessageUtil.error(handler,message);
        }
      }
    }
    setDebugOptions();
    buildConfig.getOptions().set(options);
  }
 catch (  InvalidInputException iie) {
    ISourceLocation location=null;
    if (buildConfig.getConfigFile() != null) {
      location=new SourceLocation(buildConfig.getConfigFile(),0);
    }
    IMessage m=new Message(iie.getMessage(),IMessage.ERROR,null,location);
    handler.handleMessage(m);
  }
  return buildConfig;
}",0.9962424849699398
9417,"public void performCompilation(List files){
  if (progressListener != null) {
    compiledCount=0;
    sourceFileCount=files.size();
    progressListener.setText(""String_Node_Str"");
  }
  String[] filenames=new String[files.size()];
  String[] encodings=new String[files.size()];
  for (int i=0; i < files.size(); i++) {
    filenames[i]=((File)files.get(i)).getPath();
  }
  List cps=buildConfig.getFullClasspath();
  String[] classpaths=new String[cps.size()];
  for (int i=0; i < cps.size(); i++) {
    classpaths[i]=(String)cps.get(i);
  }
  environment=getLibraryAccess(classpaths,filenames);
  if (!state.classesFromName.isEmpty()) {
    environment=new StatefulNameEnvironment(environment,state.classesFromName);
  }
  org.eclipse.jdt.internal.compiler.Compiler.setCompilerAdapterFactory(this);
  org.eclipse.jdt.internal.compiler.Compiler compiler=new org.eclipse.jdt.internal.compiler.Compiler(environment,DefaultErrorHandlingPolicies.proceedWithAllProblems(),buildConfig.getOptions().getMap(),getBatchRequestor(),getProblemFactory());
  CompilerOptions options=compiler.options;
  options.produceReferenceInfo=true;
  try {
    compiler.compile(getCompilationUnits(filenames,encodings));
  }
 catch (  OperationCanceledException oce) {
    handler.handleMessage(new Message(""String_Node_Str"" + oce.getMessage(),IMessage.WARNING,null,null));
  }
  environment.cleanup();
  environment=null;
}","public void performCompilation(List files){
  if (progressListener != null) {
    compiledCount=0;
    sourceFileCount=files.size();
    progressListener.setText(""String_Node_Str"");
  }
  String[] filenames=new String[files.size()];
  String[] encodings=new String[files.size()];
  for (int i=0; i < files.size(); i++) {
    filenames[i]=((File)files.get(i)).getPath();
  }
  List cps=buildConfig.getFullClasspath();
  Dump.saveFullClasspath(cps);
  String[] classpaths=new String[cps.size()];
  for (int i=0; i < cps.size(); i++) {
    classpaths[i]=(String)cps.get(i);
  }
  environment=getLibraryAccess(classpaths,filenames);
  if (!state.classesFromName.isEmpty()) {
    environment=new StatefulNameEnvironment(environment,state.classesFromName);
  }
  org.eclipse.jdt.internal.compiler.Compiler.setCompilerAdapterFactory(this);
  org.eclipse.jdt.internal.compiler.Compiler compiler=new org.eclipse.jdt.internal.compiler.Compiler(environment,DefaultErrorHandlingPolicies.proceedWithAllProblems(),buildConfig.getOptions().getMap(),getBatchRequestor(),getProblemFactory());
  CompilerOptions options=compiler.options;
  options.produceReferenceInfo=true;
  try {
    compiler.compile(getCompilationUnits(filenames,encodings));
  }
 catch (  OperationCanceledException oce) {
    handler.handleMessage(new Message(""String_Node_Str"" + oce.getMessage(),IMessage.WARNING,null,null));
  }
  environment.cleanup();
  environment=null;
}",0.9890575361807272
9418,"/** 
 * Run without using System.exit(..), putting all messages in holder: <ul> <li>ERROR: compiler error</li> <li>WARNING: compiler warning</li> <li>FAIL: command error (bad arguments, exception thrown)</li> </ul> This handles incremental behavior: <ul> <li>If args include ""-incremental"", repeat for every input char until 'q' is entered.<li> <li>If args include ""-incrementalTagFile {file}"", repeat every time we detect that {file} modification time has changed. </li> <li>Either way, list files recompiled each time if args includes ""-verbose"".</li> <li>Exit when the commmand/compiler throws any Throwable.</li> </ul> When complete, this contains all the messages of the final run of the command and/or any FAIL messages produced in running the command, including any Throwable thrown by the command itself.
 * @param args the String[] command line for the compiler
 * @param holder the MessageHandler sink for messages.
 */
public void run(String[] args,IMessageHolder holder){
  if (LangUtil.isEmpty(args)) {
    args=new String[]{""String_Node_Str""};
  }
 else   if (controller.running()) {
    fail(holder,""String_Node_Str"" + controller,null);
    return;
  }
  args=controller.init(args,holder);
  if (0 < holder.numMessages(IMessage.ERROR,true)) {
    return;
  }
  ICommand command=ReflectionFactory.makeCommand(commandName,holder);
  if (0 < holder.numMessages(IMessage.ERROR,true)) {
    return;
  }
  try {
    outer:     while (true) {
      boolean passed=command.runCommand(args,holder);
      if (report(passed,holder) && controller.incremental()) {
        while (controller.doRepeatCommand(command)) {
          holder.clearMessages();
          if (controller.buildFresh()) {
            continue outer;
          }
 else {
            passed=command.repeatCommand(holder);
          }
          if (!report(passed,holder)) {
            break;
          }
        }
      }
      break;
    }
  }
 catch (  AbortException ae) {
    if (ae.isSilent()) {
      quit();
    }
 else {
      IMessage message=ae.getIMessage();
      Throwable thrown=ae.getThrown();
      if (null == thrown) {
        if (null != message) {
          holder.handleMessage(message);
        }
 else {
          fail(holder,""String_Node_Str"",ae);
        }
      }
 else       if (null == message) {
        fail(holder,""String_Node_Str"",thrown);
      }
 else {
        String mssg=MessageUtil.MESSAGE_MOST.renderToString(message);
        fail(holder,mssg,thrown);
      }
    }
  }
catch (  Throwable t) {
    fail(holder,""String_Node_Str"",t);
  }
}","/** 
 * Run without using System.exit(..), putting all messages in holder: <ul> <li>ERROR: compiler error</li> <li>WARNING: compiler warning</li> <li>FAIL: command error (bad arguments, exception thrown)</li> </ul> This handles incremental behavior: <ul> <li>If args include ""-incremental"", repeat for every input char until 'q' is entered.<li> <li>If args include ""-incrementalTagFile {file}"", repeat every time we detect that {file} modification time has changed. </li> <li>Either way, list files recompiled each time if args includes ""-verbose"".</li> <li>Exit when the commmand/compiler throws any Throwable.</li> </ul> When complete, this contains all the messages of the final run of the command and/or any FAIL messages produced in running the command, including any Throwable thrown by the command itself.
 * @param args the String[] command line for the compiler
 * @param holder the MessageHandler sink for messages.
 */
public void run(String[] args,IMessageHolder holder){
  Dump.saveMessageHolder(holder);
  if (LangUtil.isEmpty(args)) {
    args=new String[]{""String_Node_Str""};
  }
 else   if (controller.running()) {
    fail(holder,""String_Node_Str"" + controller,null);
    return;
  }
  args=controller.init(args,holder);
  if (0 < holder.numMessages(IMessage.ERROR,true)) {
    return;
  }
  ICommand command=ReflectionFactory.makeCommand(commandName,holder);
  if (0 < holder.numMessages(IMessage.ERROR,true)) {
    return;
  }
  try {
    outer:     while (true) {
      boolean passed=command.runCommand(args,holder);
      if (report(passed,holder) && controller.incremental()) {
        while (controller.doRepeatCommand(command)) {
          holder.clearMessages();
          if (controller.buildFresh()) {
            continue outer;
          }
 else {
            passed=command.repeatCommand(holder);
          }
          if (!report(passed,holder)) {
            break;
          }
        }
      }
      break;
    }
  }
 catch (  AbortException ae) {
    if (ae.isSilent()) {
      quit();
    }
 else {
      IMessage message=ae.getIMessage();
      Throwable thrown=ae.getThrown();
      if (null == thrown) {
        if (null != message) {
          holder.handleMessage(message);
        }
 else {
          fail(holder,""String_Node_Str"",ae);
        }
      }
 else       if (null == message) {
        fail(holder,""String_Node_Str"",thrown);
      }
 else {
        String mssg=MessageUtil.MESSAGE_MOST.renderToString(message);
        fail(holder,mssg,thrown);
      }
    }
  }
catch (  Throwable t) {
    fail(holder,""String_Node_Str"",t);
  }
}",0.993380062305296
9419,"protected void prepareForMungers(){
  if (getKind() == ConstructorCall) {
    deleteNewAndDup();
    initializeArgVars();
  }
 else   if (getKind() == ExceptionHandler) {
    ShadowRange range=getRange();
    InstructionList body=range.getBody();
    InstructionHandle start=range.getStart();
    InstructionHandle freshIh=body.insert(start,InstructionConstants.NOP);
    InstructionTargeter[] targeters=start.getTargeters();
    for (int i=0; i < targeters.length; i++) {
      InstructionTargeter t=targeters[i];
      if (t instanceof ExceptionRange) {
        ExceptionRange er=(ExceptionRange)t;
        er.updateTarget(start,freshIh,body);
      }
    }
  }
  isThisJoinPointLazy=world.isXlazyTjp();
  for (Iterator iter=mungers.iterator(); iter.hasNext(); ) {
    ShadowMunger munger=(ShadowMunger)iter.next();
    munger.specializeOn(this);
  }
  initializeThisJoinPoint();
  InstructionFactory fact=getFactory();
  if (getKind().argsOnStack() && argVars != null) {
    range.insert(BcelRenderer.renderExprs(fact,world,argVars),Range.InsideBefore);
    if (targetVar != null) {
      range.insert(BcelRenderer.renderExpr(fact,world,targetVar),Range.InsideBefore);
    }
    if (getKind() == ConstructorCall) {
      range.insert((Instruction)InstructionFactory.createDup(1),Range.InsideBefore);
      range.insert(fact.createNew((ObjectType)BcelWorld.makeBcelType(getSignature().getDeclaringType())),Range.InsideBefore);
    }
  }
}","protected void prepareForMungers(){
  if (getKind() == ConstructorCall) {
    deleteNewAndDup();
    initializeArgVars();
  }
 else   if (getKind() == ExceptionHandler) {
    ShadowRange range=getRange();
    InstructionList body=range.getBody();
    InstructionHandle start=range.getStart();
    argVars=new BcelVar[1];
    int positionOffset=(hasTarget() ? 1 : 0) + ((hasThis() && !getKind().isTargetSameAsThis()) ? 1 : 0);
    TypeX tx=getArgType(0);
    argVars[0]=genTempVar(tx,""String_Node_Str"");
    InstructionHandle insertedInstruction=range.insert(argVars[0].createStore(getFactory()),Range.OutsideBefore);
    InstructionTargeter[] targeters=start.getTargeters();
    for (int i=0; i < targeters.length; i++) {
      InstructionTargeter t=targeters[i];
      if (t instanceof ExceptionRange) {
        ExceptionRange er=(ExceptionRange)t;
        er.updateTarget(start,insertedInstruction,body);
      }
    }
  }
  isThisJoinPointLazy=world.isXlazyTjp();
  for (Iterator iter=mungers.iterator(); iter.hasNext(); ) {
    ShadowMunger munger=(ShadowMunger)iter.next();
    munger.specializeOn(this);
  }
  initializeThisJoinPoint();
  InstructionFactory fact=getFactory();
  if (getKind().argsOnStack() && argVars != null) {
    if (getKind() == ExceptionHandler && range.getEnd().getNext().getInstruction().equals(InstructionConstants.POP)) {
      range.getEnd().getNext().setInstruction(InstructionConstants.NOP);
    }
 else {
      range.insert(BcelRenderer.renderExprs(fact,world,argVars),Range.InsideBefore);
      if (targetVar != null) {
        range.insert(BcelRenderer.renderExpr(fact,world,targetVar),Range.InsideBefore);
      }
      if (getKind() == ConstructorCall) {
        range.insert((Instruction)InstructionFactory.createDup(1),Range.InsideBefore);
        range.insert(fact.createNew((ObjectType)BcelWorld.makeBcelType(getSignature().getDeclaringType())),Range.InsideBefore);
      }
    }
  }
}",0.804986642920748
9420,"public void postParse(TypeDeclaration typeDec){
  if (arguments == null)   arguments=new Argument[0];
  this.declaredModifiers=modifiers;
  this.declaredName=new String(selector);
  selector=CharOperation.concat(mangledPrefix,'$',selector,'$',Integer.toHexString(sourceStart).toCharArray());
  if (Modifier.isAbstract(this.declaredModifiers) && !(typeDec instanceof AspectDeclaration)) {
    typeDec.scope.problemReporter().signalError(sourceStart,sourceEnd,""String_Node_Str"" + new String(declaredName) + ""String_Node_Str"");
    ignoreFurtherInvestigation=true;
    return;
  }
  if (pointcutDesignator != null) {
    pointcutDesignator.postParse(typeDec,this);
  }
}","public void postParse(TypeDeclaration typeDec){
  if (arguments == null)   arguments=new Argument[0];
  this.declaredModifiers=modifiers;
  this.declaredName=new String(selector);
  selector=CharOperation.concat(mangledPrefix,'$',selector,'$',Integer.toHexString(sourceStart).toCharArray());
  if (Modifier.isAbstract(this.declaredModifiers)) {
    if (!(typeDec instanceof AspectDeclaration)) {
      typeDec.scope.problemReporter().signalError(sourceStart,sourceEnd,""String_Node_Str"" + new String(declaredName) + ""String_Node_Str"");
      ignoreFurtherInvestigation=true;
      return;
    }
 else     if (!Modifier.isAbstract(typeDec.modifiers)) {
      typeDec.scope.problemReporter().signalError(sourceStart,sourceEnd,""String_Node_Str"" + new String(declaredName) + ""String_Node_Str"");
      ignoreFurtherInvestigation=true;
      return;
    }
  }
  if (pointcutDesignator != null) {
    pointcutDesignator.postParse(typeDec,this);
  }
}",0.8154133001864512
9421,"public static Test suite(){
  TestSuite suite=new TestSuite(AjdtBatchTests.class.getName());
  suite.addTestSuite(BasicCommandTestCase.class);
  suite.addTestSuite(BinaryFormsTestCase.class);
  suite.addTestSuite(CompileAndRunTestCase.class);
  suite.addTestSuite(PerformanceTestCase.class);
  suite.addTestSuite(ImageTestCase.class);
  suite.addTestSuite(MultipleCompileTestCase.class);
  return suite;
}","public static Test suite(){
  TestSuite suite=new TestSuite(AjdtBatchTests.class.getName());
  suite.addTestSuite(BasicCommandTestCase.class);
  suite.addTestSuite(BinaryFormsTestCase.class);
  suite.addTestSuite(CompileAndRunTestCase.class);
  suite.addTestSuite(PerformanceTestCase.class);
  suite.addTestSuite(ImageTestCase.class);
  suite.addTestSuite(MultipleCompileTestCase.class);
  suite.addTestSuite(JavadocTest.class);
  return suite;
}",0.9518213866039952
9422,"static void parseArgs(List vargs,File currentWorkingDir){
  boolean addNextAsOption=false;
  boolean addNextAsArgFile=false;
  boolean addNextToAJCOptions=false;
  boolean addNextAsDocDir=false;
  boolean addNextAsClasspath=false;
  boolean ignoreArg=false;
  boolean addNextAsSourcePath=false;
  if (vargs.size() == 0) {
    displayHelpAndExit(null);
  }
  for (int i=0; i < vargs.size(); i++) {
    String arg=(String)vargs.get(i);
    ignoreArg=false;
    if (addNextToAJCOptions) {
      ajcOptions.addElement(arg);
      addNextToAJCOptions=false;
    }
    if (addNextAsDocDir) {
      docDir=arg;
      addNextAsDocDir=false;
    }
    if (addNextAsClasspath) {
      addNextAsClasspath=false;
    }
    if (addNextAsSourcePath) {
      setSourcepath(arg);
      addNextAsSourcePath=false;
      ignoreArg=true;
    }
    if (arg.startsWith(""String_Node_Str"")) {
      expandAtSignFile(arg.substring(1),currentWorkingDir);
    }
 else     if (arg.equals(""String_Node_Str"")) {
      addNextAsArgFile=true;
    }
 else     if (addNextAsArgFile) {
      expandAtSignFile(arg,currentWorkingDir);
      addNextAsArgFile=false;
    }
 else     if (arg.equals(""String_Node_Str"")) {
      addNextAsOption=true;
      options.addElement(arg);
      addNextAsDocDir=true;
    }
 else     if (arg.equals(""String_Node_Str"")) {
      addNextAsOption=true;
      addNextToAJCOptions=true;
      options.addElement(arg);
      ajcOptions.addElement(arg);
    }
 else     if (arg.equals(""String_Node_Str"")) {
      addNextAsOption=true;
      addNextToAJCOptions=true;
      addNextAsClasspath=true;
      options.addElement(arg);
      ajcOptions.addElement(arg);
    }
 else     if (arg.equals(""String_Node_Str"")) {
      addNextAsOption=true;
      addNextToAJCOptions=true;
      addNextAsClasspath=true;
      options.addElement(arg);
      ajcOptions.addElement(arg);
    }
 else     if (arg.equals(""String_Node_Str"")) {
      addNextAsSourcePath=true;
    }
 else     if (arg.equals(""String_Node_Str"")) {
      deleteTempFilesOnExit=false;
    }
 else     if (arg.equals(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"");
    }
 else     if (arg.equals(""String_Node_Str"")) {
    }
 else     if (arg.startsWith(""String_Node_Str"") || addNextAsOption) {
      if (arg.equals(""String_Node_Str"")) {
        docModifier=""String_Node_Str"";
      }
 else       if (arg.equals(""String_Node_Str"")) {
        docModifier=""String_Node_Str"";
      }
 else       if (arg.equals(""String_Node_Str"")) {
        docModifier=""String_Node_Str"";
      }
 else       if (arg.equals(""String_Node_Str"")) {
        docModifier=""String_Node_Str"";
      }
 else       if (arg.equals(""String_Node_Str"")) {
        verboseMode=true;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        authorStandardDocletSwitch=true;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        versionStandardDocletSwitch=true;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        System.out.println(getVersion());
        exit(0);
      }
 else       if (arg.equals(""String_Node_Str"")) {
        displayHelpAndExit(null);
      }
 else       if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        exit(0);
      }
 else       if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
      }
 else       if (addNextAsOption) {
      }
 else {
        System.err.println(""String_Node_Str"" + arg);
        displayHelpAndExit(null);
      }
      options.addElement(arg);
      addNextAsOption=false;
    }
 else {
      String entryName=arg.substring(arg.lastIndexOf(File.separator) + 1);
      if (FileUtil.hasSourceSuffix(arg) || arg.endsWith(""String_Node_Str"") && arg != null) {
        File f=new File(arg);
        if (f.isAbsolute()) {
          filenames.addElement(arg);
        }
 else {
          filenames.addElement(currentWorkingDir + Config.DIR_SEP_CHAR + arg);
        }
        fileList.addElement(arg);
      }
 else       if (!ignoreArg) {
        packageMode=true;
        packageList.addElement(arg);
        arg=arg.replace('.','/');
        for (int c=0; c < sourcepath.size(); c++) {
          String path=(String)sourcepath.elementAt(c) + Config.DIR_SEP_CHAR + arg;
          File pkg=new File(path);
          if (pkg.isDirectory()) {
            String[] files=pkg.list(new FilenameFilter(){
              public boolean accept(              File dir,              String name){
                int index1=name.lastIndexOf(""String_Node_Str"");
                int index2=name.length();
                if ((index1 >= 0 && index2 >= 0) && (name.substring(index1,index2).equals(""String_Node_Str"") || name.substring(index1,index2).equals(""String_Node_Str""))) {
                  return true;
                }
 else {
                  return false;
                }
              }
            }
);
            for (int j=0; j < files.length; j++) {
              filenames.addElement((String)sourcepath.elementAt(c) + Config.DIR_SEP_CHAR + arg+ Config.DIR_SEP_CHAR+ files[j]);
            }
          }
 else           if (c == sourcepath.size()) {
            System.out.println(""String_Node_Str"" + ""String_Node_Str"" + arg + ""String_Node_Str"");
          }
 else {
          }
        }
      }
    }
  }
  if (!options.contains(""String_Node_Str"") && !options.contains(""String_Node_Str"") && !options.contains(""String_Node_Str"")&& !options.contains(""String_Node_Str"")) {
    options.addElement(""String_Node_Str"");
  }
}","static void parseArgs(List vargs,File currentWorkingDir){
  boolean addNextAsOption=false;
  boolean addNextAsArgFile=false;
  boolean addNextToAJCOptions=false;
  boolean addNextAsDocDir=false;
  boolean addNextAsClasspath=false;
  boolean ignoreArg=false;
  boolean addNextAsSourcePath=false;
  if (vargs.size() == 0) {
    displayHelpAndExit(null);
  }
  for (int i=0; i < vargs.size(); i++) {
    String arg=(String)vargs.get(i);
    ignoreArg=false;
    if (addNextToAJCOptions) {
      ajcOptions.addElement(arg);
      addNextToAJCOptions=false;
    }
    if (addNextAsDocDir) {
      docDir=arg;
      addNextAsDocDir=false;
    }
    if (addNextAsClasspath) {
      addNextAsClasspath=false;
    }
    if (addNextAsSourcePath) {
      setSourcepath(arg);
      addNextAsSourcePath=false;
      ignoreArg=true;
    }
    if (arg.startsWith(""String_Node_Str"")) {
      expandAtSignFile(arg.substring(1),currentWorkingDir);
    }
 else     if (arg.equals(""String_Node_Str"")) {
      addNextAsArgFile=true;
    }
 else     if (addNextAsArgFile) {
      expandAtSignFile(arg,currentWorkingDir);
      addNextAsArgFile=false;
    }
 else     if (arg.equals(""String_Node_Str"")) {
      addNextAsOption=true;
      options.addElement(arg);
      addNextAsDocDir=true;
    }
 else     if (arg.equals(""String_Node_Str"")) {
      addNextAsOption=true;
      addNextToAJCOptions=true;
      options.addElement(arg);
      ajcOptions.addElement(arg);
    }
 else     if (arg.equals(""String_Node_Str"")) {
      addNextAsOption=true;
      addNextToAJCOptions=true;
      addNextAsClasspath=true;
      options.addElement(arg);
      ajcOptions.addElement(arg);
    }
 else     if (arg.equals(""String_Node_Str"")) {
      addNextAsOption=true;
      addNextToAJCOptions=true;
      addNextAsClasspath=true;
      options.addElement(arg);
      ajcOptions.addElement(arg);
    }
 else     if (arg.equals(""String_Node_Str"")) {
      addNextAsOption=true;
      addNextToAJCOptions=false;
      options.addElement(arg);
    }
 else     if (arg.equals(""String_Node_Str"")) {
      addNextAsOption=true;
      addNextToAJCOptions=false;
      options.addElement(arg);
    }
 else     if (arg.equals(""String_Node_Str"")) {
      addNextAsOption=true;
      addNextToAJCOptions=false;
      options.addElement(arg);
    }
 else     if (arg.equals(""String_Node_Str"")) {
      addNextAsSourcePath=true;
    }
 else     if (arg.equals(""String_Node_Str"")) {
      deleteTempFilesOnExit=false;
    }
 else     if (arg.equals(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"");
    }
 else     if (arg.equals(""String_Node_Str"")) {
    }
 else     if (arg.startsWith(""String_Node_Str"") || addNextAsOption) {
      if (arg.equals(""String_Node_Str"")) {
        docModifier=""String_Node_Str"";
      }
 else       if (arg.equals(""String_Node_Str"")) {
        docModifier=""String_Node_Str"";
      }
 else       if (arg.equals(""String_Node_Str"")) {
        docModifier=""String_Node_Str"";
      }
 else       if (arg.equals(""String_Node_Str"")) {
        docModifier=""String_Node_Str"";
      }
 else       if (arg.equals(""String_Node_Str"")) {
        verboseMode=true;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        authorStandardDocletSwitch=true;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        versionStandardDocletSwitch=true;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        System.out.println(getVersion());
        exit(0);
      }
 else       if (arg.equals(""String_Node_Str"")) {
        displayHelpAndExit(null);
      }
 else       if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        exit(0);
      }
 else       if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
      }
 else       if (addNextAsOption) {
      }
 else {
        System.err.println(""String_Node_Str"" + arg);
        displayHelpAndExit(null);
      }
      options.addElement(arg);
      addNextAsOption=false;
    }
 else {
      String entryName=arg.substring(arg.lastIndexOf(File.separator) + 1);
      if (FileUtil.hasSourceSuffix(arg) || arg.endsWith(""String_Node_Str"") && arg != null) {
        File f=new File(arg);
        if (f.isAbsolute()) {
          filenames.addElement(arg);
        }
 else {
          filenames.addElement(currentWorkingDir + Config.DIR_SEP_CHAR + arg);
        }
        fileList.addElement(arg);
      }
 else       if (!ignoreArg) {
        packageMode=true;
        packageList.addElement(arg);
        arg=arg.replace('.','/');
        for (int c=0; c < sourcepath.size(); c++) {
          String path=(String)sourcepath.elementAt(c) + Config.DIR_SEP_CHAR + arg;
          File pkg=new File(path);
          if (pkg.isDirectory()) {
            String[] files=pkg.list(new FilenameFilter(){
              public boolean accept(              File dir,              String name){
                int index1=name.lastIndexOf(""String_Node_Str"");
                int index2=name.length();
                if ((index1 >= 0 && index2 >= 0) && (name.substring(index1,index2).equals(""String_Node_Str"") || name.substring(index1,index2).equals(""String_Node_Str""))) {
                  return true;
                }
 else {
                  return false;
                }
              }
            }
);
            for (int j=0; j < files.length; j++) {
              filenames.addElement((String)sourcepath.elementAt(c) + Config.DIR_SEP_CHAR + arg+ Config.DIR_SEP_CHAR+ files[j]);
            }
          }
 else           if (c == sourcepath.size()) {
            System.out.println(""String_Node_Str"" + ""String_Node_Str"" + arg + ""String_Node_Str"");
          }
 else {
          }
        }
      }
    }
  }
  if (!options.contains(""String_Node_Str"") && !options.contains(""String_Node_Str"") && !options.contains(""String_Node_Str"")&& !options.contains(""String_Node_Str"")) {
    options.addElement(""String_Node_Str"");
  }
}",0.9627472809797036
9423,"public static Test suite(){
  TestSuite suite=new TestSuite(AjdeTests.class.getName());
  suite.addTestSuite(BuildOptionsTest.class);
  suite.addTestSuite(BuildConfigurationTests.class);
  suite.addTestSuite(StructureModelRegressionTest.class);
  suite.addTestSuite(StructureModelTest.class);
  suite.addTestSuite(VersionTest.class);
  suite.addTestSuite(CompilerMessagesTest.class);
  suite.addTestSuite(AsmDeclarationsTest.class);
  suite.addTestSuite(AsmRelationshipsTest.class);
  suite.addTestSuite(InpathTestcase.class);
  suite.addTestSuite(ReweavableTestCase.class);
  suite.addTestSuite(ResourceCopyTestCase.class);
  suite.addTestSuite(ModelPerformanceTest.class);
  suite.addTestSuite(SavedModelConsistencyTest.class);
  suite.addTestSuite(BuildCancellingTest.class);
  suite.addTestSuite(JarManifestTest.class);
  suite.addTestSuite(DuplicateManifestTest.class);
  suite.addTestSuite(ShowWeaveMessagesTestCase.class);
  return suite;
}","public static Test suite(){
  TestSuite suite=new TestSuite(AjdeTests.class.getName());
  suite.addTestSuite(BuildOptionsTest.class);
  suite.addTestSuite(BuildConfigurationTests.class);
  suite.addTestSuite(StructureModelRegressionTest.class);
  suite.addTestSuite(StructureModelTest.class);
  suite.addTestSuite(VersionTest.class);
  suite.addTestSuite(CompilerMessagesTest.class);
  suite.addTestSuite(AsmDeclarationsTest.class);
  suite.addTestSuite(AsmRelationshipsTest.class);
  suite.addTestSuite(InpathTestcase.class);
  suite.addTestSuite(ReweavableTestCase.class);
  suite.addTestSuite(ResourceCopyTestCase.class);
  suite.addTestSuite(ModelPerformanceTest.class);
  suite.addTestSuite(SavedModelConsistencyTest.class);
  suite.addTestSuite(BuildCancellingTest.class);
  suite.addTestSuite(JarManifestTest.class);
  suite.addTestSuite(DuplicateManifestTest.class);
  suite.addTestSuite(ShowWeaveMessagesTestCase.class);
  suite.addTestSuite(ExtensionTests.class);
  return suite;
}",0.977296181630547
9424,"/** 
 * Extract message text and source location, including context. 
 */
public static IMessage makeMessage(ICompilationUnit unit,IProblem problem){
  ISourceLocation sourceLocation=makeSourceLocation(unit,problem);
  IProblem[] seeAlso=problem.seeAlso();
  ISourceLocation[] seeAlsoLocations=new ISourceLocation[seeAlso.length];
  for (int i=0; i < seeAlso.length; i++) {
    seeAlsoLocations[i]=new SourceLocation(new File(new String(seeAlso[i].getOriginatingFileName())),seeAlso[i].getSourceLineNumber());
  }
  String extraDetails=problem.getSupplementaryMessageInfo();
  boolean declared=false;
  if (extraDetails != null && extraDetails.endsWith(""String_Node_Str"")) {
    declared=true;
    extraDetails=extraDetails.substring(0,extraDetails.length() - ""String_Node_Str"".length());
  }
  IMessage msg=new Message(problem.getMessage(),extraDetails,problem.isError() ? IMessage.ERROR : IMessage.WARNING,sourceLocation,null,seeAlsoLocations,declared);
  return msg;
}","/** 
 * Extract message text and source location, including context. 
 */
public static IMessage makeMessage(ICompilationUnit unit,IProblem problem){
  ISourceLocation sourceLocation=makeSourceLocation(unit,problem);
  IProblem[] seeAlso=problem.seeAlso();
  ISourceLocation[] seeAlsoLocations=new ISourceLocation[seeAlso.length];
  for (int i=0; i < seeAlso.length; i++) {
    seeAlsoLocations[i]=new SourceLocation(new File(new String(seeAlso[i].getOriginatingFileName())),seeAlso[i].getSourceLineNumber());
  }
  String extraDetails=problem.getSupplementaryMessageInfo();
  boolean declared=false;
  if (extraDetails != null && extraDetails.endsWith(""String_Node_Str"")) {
    declared=true;
    extraDetails=extraDetails.substring(0,extraDetails.length() - ""String_Node_Str"".length());
  }
  IMessage msg=new Message(problem.getMessage(),extraDetails,problem.isError() ? IMessage.ERROR : IMessage.WARNING,sourceLocation,null,seeAlsoLocations,declared,problem.getID());
  return msg;
}",0.9918283963227784
9425,"public boolean match(Shadow shadow,World world){
  if (super.match(shadow,world)) {
    IMessage message=new Message(msg,shadow.toString(),isError ? IMessage.ERROR : IMessage.WARNING,shadow.getSourceLocation(),null,new ISourceLocation[]{this.getSourceLocation()},true);
    world.getMessageHandler().handleMessage(message);
    if (world.xrefHandler != null) {
      world.xrefHandler.addCrossReference(this.getSourceLocation(),shadow.getSourceLocation(),(this.isError ? IRelationship.Kind.DECLARE_ERROR : IRelationship.Kind.DECLARE_WARNING),false);
    }
    if (world.getModel() != null) {
      AsmRelationshipProvider.checkerMunger(world.getModel(),shadow,this);
    }
  }
  return false;
}","public boolean match(Shadow shadow,World world){
  if (super.match(shadow,world)) {
    IMessage message=new Message(msg,shadow.toString(),isError ? IMessage.ERROR : IMessage.WARNING,shadow.getSourceLocation(),null,new ISourceLocation[]{this.getSourceLocation()},true,0);
    world.getMessageHandler().handleMessage(message);
    if (world.xrefHandler != null) {
      world.xrefHandler.addCrossReference(this.getSourceLocation(),shadow.getSourceLocation(),(this.isError ? IRelationship.Kind.DECLARE_ERROR : IRelationship.Kind.DECLARE_WARNING),false);
    }
    if (world.getModel() != null) {
      AsmRelationshipProvider.checkerMunger(world.getModel(),shadow,this);
    }
  }
  return false;
}",0.9985611510791368
9426,"protected int generateInfoAttributes(ClassFile classFile){
  List l=new ArrayList(1);
  l.add(new EclipseAttributeAdapter(makeAttribute()));
  return classFile.generateMethodInfoAttribute(binding,l);
}","protected int generateInfoAttributes(ClassFile classFile){
  List l=new ArrayList(1);
  l.add(new EclipseAttributeAdapter(makeAttribute()));
  addDeclarationStartLineAttribute(l,classFile);
  return classFile.generateMethodInfoAttribute(binding,l);
}",0.8913525498891353
9427,"protected int generateInfoAttributes(ClassFile classFile){
  List l;
  ;
  Shadow.Kind kind=getShadowKindForBody();
  if (kind != null) {
    l=makeEffectiveSignatureAttribute(munger.getSignature(),kind,true);
  }
 else {
    l=new ArrayList(0);
  }
  return classFile.generateMethodInfoAttribute(binding,l);
}","protected int generateInfoAttributes(ClassFile classFile){
  List l;
  ;
  Shadow.Kind kind=getShadowKindForBody();
  if (kind != null) {
    l=makeEffectiveSignatureAttribute(munger.getSignature(),kind,true);
  }
 else {
    l=new ArrayList(0);
  }
  addDeclarationStartLineAttribute(l,classFile);
  return classFile.generateMethodInfoAttribute(binding,l);
}",0.9267563527653214
9428,"/** 
 * Extract message text and source location, including context. 
 */
public static IMessage makeMessage(ICompilationUnit unit,IProblem problem){
  ISourceLocation sourceLocation=makeSourceLocation(unit,problem);
  IProblem[] seeAlso=problem.seeAlso();
  ISourceLocation[] seeAlsoLocations=new ISourceLocation[seeAlso.length];
  for (int i=0; i < seeAlso.length; i++) {
    seeAlsoLocations[i]=new SourceLocation(new File(new String(seeAlso[i].getOriginatingFileName())),seeAlso[i].getSourceLineNumber());
  }
  String extraDetails=problem.getSupplementaryMessageInfo();
  boolean declared=false;
  if (extraDetails != null && extraDetails.endsWith(""String_Node_Str"")) {
    declared=true;
    extraDetails=extraDetails.substring(0,extraDetails.length() - ""String_Node_Str"".length());
  }
  IMessage msg=new Message(problem.getMessage(),extraDetails,problem.isError() ? IMessage.ERROR : IMessage.WARNING,sourceLocation,null,seeAlsoLocations,declared,problem.getID());
  return msg;
}","/** 
 * Extract message text and source location, including context. 
 */
public static IMessage makeMessage(ICompilationUnit unit,IProblem problem){
  ISourceLocation sourceLocation=makeSourceLocation(unit,problem);
  IProblem[] seeAlso=problem.seeAlso();
  ISourceLocation[] seeAlsoLocations=new ISourceLocation[seeAlso.length];
  for (int i=0; i < seeAlso.length; i++) {
    seeAlsoLocations[i]=new SourceLocation(new File(new String(seeAlso[i].getOriginatingFileName())),seeAlso[i].getSourceLineNumber());
  }
  String extraDetails=problem.getSupplementaryMessageInfo();
  boolean declared=false;
  if (extraDetails != null && extraDetails.endsWith(""String_Node_Str"")) {
    declared=true;
    extraDetails=extraDetails.substring(0,extraDetails.length() - ""String_Node_Str"".length());
  }
  IMessage msg=new Message(problem.getMessage(),extraDetails,problem.isError() ? IMessage.ERROR : IMessage.WARNING,sourceLocation,null,seeAlsoLocations,declared,problem.getID(),problem.getSourceStart(),problem.getSourceEnd());
  return msg;
}",0.9762611275964392
9429,"public boolean match(Shadow shadow,World world){
  if (super.match(shadow,world)) {
    IMessage message=new Message(msg,shadow.toString(),isError ? IMessage.ERROR : IMessage.WARNING,shadow.getSourceLocation(),null,new ISourceLocation[]{this.getSourceLocation()},true,0);
    world.getMessageHandler().handleMessage(message);
    if (world.xrefHandler != null) {
      world.xrefHandler.addCrossReference(this.getSourceLocation(),shadow.getSourceLocation(),(this.isError ? IRelationship.Kind.DECLARE_ERROR : IRelationship.Kind.DECLARE_WARNING),false);
    }
    if (world.getModel() != null) {
      AsmRelationshipProvider.checkerMunger(world.getModel(),shadow,this);
    }
  }
  return false;
}","public boolean match(Shadow shadow,World world){
  if (super.match(shadow,world)) {
    IMessage message=new Message(msg,shadow.toString(),isError ? IMessage.ERROR : IMessage.WARNING,shadow.getSourceLocation(),null,new ISourceLocation[]{this.getSourceLocation()},true,0,-1,-1);
    world.getMessageHandler().handleMessage(message);
    if (world.xrefHandler != null) {
      world.xrefHandler.addCrossReference(this.getSourceLocation(),shadow.getSourceLocation(),(this.isError ? IRelationship.Kind.DECLARE_ERROR : IRelationship.Kind.DECLARE_WARNING),false);
    }
    if (world.getModel() != null) {
      AsmRelationshipProvider.checkerMunger(world.getModel(),shadow,this);
    }
  }
  return false;
}",0.9957081545064378
9430,"public Object[] getArgs(){
  return args;
}","public Object[] getArgs(){
  if (args == null) {
    args=new Object[0];
  }
  Object[] argsCopy=new Object[args.length];
  System.arraycopy(args,0,argsCopy,0,args.length);
  return argsCopy;
}",0.3644067796610169
9431,"public static TestSuite suite(){
  TestSuite suite=new TestSuite(RuntimeModuleTests.class.getName());
  suite.addTestSuite(RuntimeModuleTests.class);
  suite.addTestSuite(SignatureTest.class);
  return suite;
}","public static TestSuite suite(){
  TestSuite suite=new TestSuite(RuntimeModuleTests.class.getName());
  suite.addTestSuite(RuntimeModuleTests.class);
  suite.addTestSuite(SignatureTest.class);
  suite.addTestSuite(JoinPointImplTest.class);
  return suite;
}",0.8993576017130621
9432,"public Method getMethod(){
  if (savedMethod != null)   return savedMethod;
  try {
    MethodGen gen=pack();
    return gen.getMethod();
  }
 catch (  ClassGenException e) {
    enclosingClass.getBcelObjectType().getResolvedTypeX().getWorld().showMessage(IMessage.ERROR,WeaverMessages.format(WeaverMessages.PROBLEM_GENERATING_METHOD,this.getClassName(),this.getName(),e.getMessage()),this.getMemberView() == null ? null : this.getMemberView().getSourceLocation(),null);
    throw e;
  }
}","public Method getMethod(){
  if (savedMethod != null)   return savedMethod;
  try {
    MethodGen gen=pack();
    return gen.getMethod();
  }
 catch (  ClassGenException e) {
    enclosingClass.getBcelObjectType().getResolvedTypeX().getWorld().showMessage(IMessage.ERROR,WeaverMessages.format(WeaverMessages.PROBLEM_GENERATING_METHOD,this.getClassName(),this.getName(),e.getMessage()),this.getMemberView() == null ? null : this.getMemberView().getSourceLocation(),null);
    body=null;
    MethodGen gen=pack();
    return gen.getMethod();
  }
}",0.9323017408123792
9433,"private IProgramElement createFileStructureNode(String sourceFilePath){
  String fileName=new File(sourceFilePath).getName();
  IProgramElement fileNode=new ProgramElement(fileName,IProgramElement.Kind.FILE_JAVA,null);
  fileNode.setSourceLocation(new SourceLocation(new File(sourceFilePath),1,1));
  fileNode.addChild(NO_STRUCTURE);
  return fileNode;
}","private IProgramElement createFileStructureNode(String sourceFilePath){
  int lastSlash=sourceFilePath.lastIndexOf('\\');
  if (lastSlash == -1) {
    lastSlash=sourceFilePath.lastIndexOf('/');
  }
  String fileName=sourceFilePath.substring(lastSlash + 1);
  IProgramElement fileNode=new ProgramElement(fileName,IProgramElement.Kind.FILE_JAVA,null);
  fileNode.setSourceLocation(new SourceLocation(new File(sourceFilePath),1,1));
  fileNode.addChild(NO_STRUCTURE);
  return fileNode;
}",0.7270560190703218
9434,"private void generateMethod(ClassFile classFile,MethodBinding methodBinding,BodyGenerator gen){
  classFile.generateMethodInfoHeader(methodBinding);
  int methodAttributeOffset=classFile.contentsOffset;
  int attributeNumber=classFile.generateMethodInfoAttribute(methodBinding,AstUtil.getAjSyntheticAttribute());
  int codeAttributeOffset=classFile.contentsOffset;
  classFile.generateCodeAttributeHeader();
  CodeStream codeStream=classFile.codeStream;
  MethodDeclaration md=AstUtil.makeMethodDeclaration(methodBinding);
  md.scope=initializerScope;
  codeStream.reset(md,classFile);
  gen.generate(codeStream);
  classFile.completeCodeAttribute(codeAttributeOffset);
  attributeNumber++;
  classFile.completeMethodInfo(methodAttributeOffset,attributeNumber);
}","private void generateMethod(ClassFile classFile,MethodBinding methodBinding,List additionalAttributes,BodyGenerator gen){
  classFile.generateMethodInfoHeader(methodBinding);
  int methodAttributeOffset=classFile.contentsOffset;
  int attributeNumber;
  if (additionalAttributes != null) {
    List attrs=new ArrayList();
    attrs.addAll(AstUtil.getAjSyntheticAttribute());
    attrs.addAll(additionalAttributes);
    attributeNumber=classFile.generateMethodInfoAttribute(methodBinding,attrs);
  }
 else {
    attributeNumber=classFile.generateMethodInfoAttribute(methodBinding,AstUtil.getAjSyntheticAttribute());
  }
  int codeAttributeOffset=classFile.contentsOffset;
  classFile.generateCodeAttributeHeader();
  CodeStream codeStream=classFile.codeStream;
  MethodDeclaration md=AstUtil.makeMethodDeclaration(methodBinding);
  md.scope=initializerScope;
  codeStream.reset(md,classFile);
  gen.generate(codeStream);
  classFile.completeCodeAttribute(codeAttributeOffset);
  attributeNumber++;
  classFile.completeMethodInfo(methodAttributeOffset,attributeNumber);
}",0.7762008733624454
9435,"private void generateInlineAccessors(ClassFile classFile,final InlineAccessFieldBinding accessField,final ResolvedMember field){
  final FieldBinding fieldBinding=factory.makeFieldBinding(field);
  generateMethod(classFile,accessField.reader,new BodyGenerator(){
    public void generate(    CodeStream codeStream){
      if (field.isStatic()) {
        codeStream.getstatic(fieldBinding);
      }
 else {
        codeStream.aload_0();
        codeStream.getfield(fieldBinding);
      }
      AstUtil.generateReturn(accessField.reader.returnType,codeStream);
    }
  }
);
  generateMethod(classFile,accessField.writer,new BodyGenerator(){
    public void generate(    CodeStream codeStream){
      if (field.isStatic()) {
        codeStream.load(fieldBinding.type,0);
        codeStream.putstatic(fieldBinding);
      }
 else {
        codeStream.aload_0();
        codeStream.load(fieldBinding.type,1);
        codeStream.putfield(fieldBinding);
      }
      codeStream.return_();
    }
  }
);
}","private void generateInlineAccessors(ClassFile classFile,final InlineAccessFieldBinding accessField,final ResolvedMember field){
  final FieldBinding fieldBinding=factory.makeFieldBinding(field);
  generateMethod(classFile,accessField.reader,makeEffectiveSignatureAttribute(field,Shadow.FieldGet,false),new BodyGenerator(){
    public void generate(    CodeStream codeStream){
      if (field.isStatic()) {
        codeStream.getstatic(fieldBinding);
      }
 else {
        codeStream.aload_0();
        codeStream.getfield(fieldBinding);
      }
      AstUtil.generateReturn(accessField.reader.returnType,codeStream);
    }
  }
);
  generateMethod(classFile,accessField.writer,makeEffectiveSignatureAttribute(field,Shadow.FieldSet,false),new BodyGenerator(){
    public void generate(    CodeStream codeStream){
      if (field.isStatic()) {
        codeStream.load(fieldBinding.type,0);
        codeStream.putstatic(fieldBinding);
      }
 else {
        codeStream.aload_0();
        codeStream.load(fieldBinding.type,1);
        codeStream.putfield(fieldBinding);
      }
      codeStream.return_();
    }
  }
);
}",0.94234404536862
9436,"private void generateInlineAccessMethod(ClassFile classFile,final MethodBinding accessMethod,final ResolvedMember method){
  generateMethod(classFile,accessMethod,new BodyGenerator(){
    public void generate(    CodeStream codeStream){
      AstUtil.generateParameterLoads(accessMethod.parameters,codeStream);
      if (method.isStatic()) {
        codeStream.invokestatic(factory.makeMethodBinding(method));
      }
 else {
        codeStream.invokevirtual(factory.makeMethodBinding(method));
      }
      AstUtil.generateReturn(accessMethod.returnType,codeStream);
    }
  }
);
}","private void generateInlineAccessMethod(ClassFile classFile,final MethodBinding accessMethod,final ResolvedMember method){
  generateMethod(classFile,accessMethod,makeEffectiveSignatureAttribute(method,Shadow.MethodCall,false),new BodyGenerator(){
    public void generate(    CodeStream codeStream){
      AstUtil.generateParameterLoads(accessMethod.parameters,codeStream);
      if (method.isStatic()) {
        codeStream.invokestatic(factory.makeMethodBinding(method));
      }
 else {
        codeStream.invokevirtual(factory.makeMethodBinding(method));
      }
      AstUtil.generateReturn(accessMethod.returnType,codeStream);
    }
  }
);
}",0.9479674796747968
9437,"public void resolve(ClassScope upperScope){
  if (munger == null)   ignoreFurtherInvestigation=true;
  if (ignoreFurtherInvestigation)   return;
  EclipseFactory world=EclipseFactory.fromScopeLookupEnvironment(upperScope);
  ResolvedMember sig=munger.getSignature();
  TypeX aspectType=EclipseFactory.fromBinding(upperScope.referenceContext.binding);
  if (sig.getReturnType() == ResolvedTypeX.VOID || (sig.getReturnType().isArray() && (sig.getReturnType().getComponentType() == ResolvedTypeX.VOID))) {
    upperScope.problemReporter().signalError(sourceStart,sourceEnd,""String_Node_Str"");
  }
  if (initialization != null && initialization instanceof ArrayInitializer) {
    ArrayAllocationExpression aae=new ArrayAllocationExpression();
    aae.initializer=(ArrayInitializer)initialization;
    ArrayBinding arrayType=(ArrayBinding)world.makeTypeBinding(sig.getReturnType());
    aae.type=AstUtil.makeTypeReference(arrayType.leafComponentType());
    aae.sourceStart=initialization.sourceStart;
    aae.sourceEnd=initialization.sourceEnd;
    aae.dimensions=new Expression[arrayType.dimensions];
    initialization=aae;
  }
  if (initialization == null) {
    this.statements=new Statement[]{new ReturnStatement(null,0,0)};
  }
 else   if (!onTypeBinding.isInterface()) {
    FieldBinding interField=world.makeFieldBinding(AjcMemberMaker.interFieldClassField(sig,aspectType));
    Reference ref=new KnownFieldReference(interField,0);
    this.statements=new Statement[]{new Assignment(ref,initialization,initialization.sourceEnd)};
  }
 else {
    MethodBinding writeMethod=world.makeMethodBinding(AjcMemberMaker.interFieldInterfaceSetter(sig,sig.getDeclaringType().resolve(world.getWorld()),aspectType));
    if (Modifier.isStatic(declaredModifiers)) {
      this.statements=new Statement[]{new KnownMessageSend(writeMethod,AstUtil.makeNameReference(writeMethod.declaringClass),new Expression[]{initialization})};
    }
 else {
      this.statements=new Statement[]{new KnownMessageSend(writeMethod,AstUtil.makeLocalVariableReference(arguments[0].binding),new Expression[]{initialization})};
    }
  }
  super.resolve(upperScope);
}","public void resolve(ClassScope upperScope){
  if (munger == null)   ignoreFurtherInvestigation=true;
  if (ignoreFurtherInvestigation)   return;
  EclipseFactory world=EclipseFactory.fromScopeLookupEnvironment(upperScope);
  ResolvedMember sig=munger.getSignature();
  TypeX aspectType=EclipseFactory.fromBinding(upperScope.referenceContext.binding);
  if (sig.getReturnType() == ResolvedTypeX.VOID || (sig.getReturnType().isArray() && (sig.getReturnType().getComponentType() == ResolvedTypeX.VOID))) {
    upperScope.problemReporter().signalError(sourceStart,sourceEnd,""String_Node_Str"");
  }
  if (initialization != null && initialization instanceof ArrayInitializer) {
    ArrayAllocationExpression aae=new ArrayAllocationExpression();
    aae.initializer=(ArrayInitializer)initialization;
    ArrayBinding arrayType=(ArrayBinding)world.makeTypeBinding(sig.getReturnType());
    aae.type=AstUtil.makeTypeReference(arrayType.leafComponentType());
    aae.sourceStart=initialization.sourceStart;
    aae.sourceEnd=initialization.sourceEnd;
    aae.dimensions=new Expression[arrayType.dimensions];
    initialization=aae;
  }
  if (initialization == null) {
    this.statements=new Statement[]{new ReturnStatement(null,0,0)};
  }
 else   if (!onTypeBinding.isInterface()) {
    MethodBinding writeMethod=world.makeMethodBinding(AjcMemberMaker.interFieldSetDispatcher(sig,aspectType));
    if (Modifier.isStatic(declaredModifiers)) {
      this.statements=new Statement[]{new KnownMessageSend(writeMethod,AstUtil.makeNameReference(writeMethod.declaringClass),new Expression[]{initialization})};
    }
 else {
      this.statements=new Statement[]{new KnownMessageSend(writeMethod,AstUtil.makeNameReference(writeMethod.declaringClass),new Expression[]{AstUtil.makeLocalVariableReference(arguments[0].binding),initialization})};
    }
  }
 else {
    MethodBinding writeMethod=world.makeMethodBinding(AjcMemberMaker.interFieldInterfaceSetter(sig,sig.getDeclaringType().resolve(world.getWorld()),aspectType));
    if (Modifier.isStatic(declaredModifiers)) {
      this.statements=new Statement[]{new KnownMessageSend(writeMethod,AstUtil.makeNameReference(writeMethod.declaringClass),new Expression[]{initialization})};
    }
 else {
      this.statements=new Statement[]{new KnownMessageSend(writeMethod,AstUtil.makeLocalVariableReference(arguments[0].binding),new Expression[]{initialization})};
    }
  }
  super.resolve(upperScope);
}",0.6725043782837128
9438,"private MethodBinding getAccessibleMethod(MethodBinding binding,TypeBinding receiverType){
  if (!binding.isValidBinding())   return binding;
  makePublic(receiverType);
  if (isPublic(binding))   return binding;
  if (binding instanceof InterTypeMethodBinding)   return binding;
  if (binding.isPrivate() && binding.declaringClass != inAspect.binding) {
    binding.modifiers=AstUtil.makePackageVisible(binding.modifiers);
  }
  ResolvedMember m=EclipseFactory.makeResolvedMember(binding,receiverType);
  if (inAspect.accessForInline.containsKey(m))   return (MethodBinding)inAspect.accessForInline.get(m);
  MethodBinding ret=world.makeMethodBinding(AjcMemberMaker.inlineAccessMethodForMethod(inAspect.typeX,m));
  inAspect.accessForInline.put(m,ret);
  return ret;
}","private MethodBinding getAccessibleMethod(MethodBinding binding,TypeBinding receiverType){
  if (!binding.isValidBinding())   return binding;
  makePublic(receiverType);
  if (isPublic(binding))   return binding;
  if (binding instanceof InterTypeMethodBinding)   return binding;
  ResolvedMember m=null;
  if (binding.isPrivate() && binding.declaringClass != inAspect.binding) {
    binding.modifiers=AstUtil.makePackageVisible(binding.modifiers);
    m=EclipseFactory.makeResolvedMember(binding);
  }
 else {
    m=EclipseFactory.makeResolvedMember(binding,receiverType);
  }
  if (inAspect.accessForInline.containsKey(m))   return (MethodBinding)inAspect.accessForInline.get(m);
  MethodBinding ret=world.makeMethodBinding(AjcMemberMaker.inlineAccessMethodForMethod(inAspect.typeX,m));
  inAspect.accessForInline.put(m,ret);
  return ret;
}",0.9317617866004962
9439,"static ITokenSource makeTokenSource(String input){
  char[] chars=input.toCharArray();
  int i=0;
  List tokens=new ArrayList();
  while (i < chars.length) {
    char ch=chars[i++];
switch (ch) {
case ' ':
case '\t':
case '\n':
case '\r':
      continue;
case '*':
case '.':
case '(':
case ')':
case '+':
case '[':
case ']':
case ',':
case '!':
case ':':
    tokens.add(BasicToken.makeOperator(makeString(ch),i - 1,i - 1));
  continue;
case '&':
case '|':
if (i == chars.length) {
  throw new BCException(""String_Node_Str"" + ch);
}
char nextChar=chars[i++];
if (nextChar == ch) {
tokens.add(BasicToken.makeOperator(makeString(ch,2),i - 2,i - 1));
}
 else {
throw new RuntimeException(""String_Node_Str"" + ch);
}
continue;
case '\""':
int start0=i - 1;
while (i < chars.length && !(chars[i] == '\""')) i++;
i+=1;
tokens.add(BasicToken.makeLiteral(new String(chars,start0 + 1,i - start0 - 2),""String_Node_Str"",start0,i - 1));
default :
int start=i - 1;
while (i < chars.length && Character.isJavaIdentifierPart(chars[i])) {
i++;
}
tokens.add(BasicToken.makeIdentifier(new String(chars,start,i - start),start,i - 1));
}
}
return new BasicTokenSource((IToken[])tokens.toArray(new IToken[tokens.size()]),null);
}","static ITokenSource makeTokenSource(String input){
  char[] chars=input.toCharArray();
  int i=0;
  List tokens=new ArrayList();
  while (i < chars.length) {
    char ch=chars[i++];
switch (ch) {
case ' ':
case '\t':
case '\n':
case '\r':
      continue;
case '*':
case '.':
case '(':
case ')':
case '+':
case '[':
case ']':
case ',':
case '!':
case ':':
    tokens.add(BasicToken.makeOperator(makeString(ch),i - 1,i - 1));
  continue;
case '&':
case '|':
if (i == chars.length) {
  throw new BCException(""String_Node_Str"" + ch);
}
char nextChar=chars[i++];
if (nextChar == ch) {
tokens.add(BasicToken.makeOperator(makeString(ch,2),i - 2,i - 1));
}
 else {
throw new RuntimeException(""String_Node_Str"" + ch);
}
continue;
case '\""':
int start0=i - 1;
while (i < chars.length && !(chars[i] == '\""')) i++;
i+=1;
tokens.add(BasicToken.makeLiteral(new String(chars,start0 + 1,i - start0 - 2),""String_Node_Str"",start0,i - 1));
continue;
default :
int start=i - 1;
while (i < chars.length && Character.isJavaIdentifierPart(chars[i])) {
i++;
}
tokens.add(BasicToken.makeIdentifier(new String(chars,start,i - start),start,i - 1));
}
}
return new BasicTokenSource((IToken[])tokens.toArray(new IToken[tokens.size()]),null);
}",0.9958643507030605
9440,"/** 
 * Extract AspectJ-specific options (except for argfiles). Caller should warn when sourceroots is empty but in  incremental mode. Signals warnings or errors through handler set in constructor.
 */
public void parseOption(String arg,LinkedList args){
  int nextArgIndex=args.indexOf(arg) + 1;
  if (LangUtil.isEmpty(arg)) {
    showWarning(""String_Node_Str"");
  }
 else   if (arg.equals(""String_Node_Str"")) {
    ;
    if (args.size() > nextArgIndex) {
      List inPath=buildConfig.getInpath();
      StringTokenizer st=new StringTokenizer(((ConfigParser.Arg)args.get(nextArgIndex)).getValue(),File.pathSeparator);
      while (st.hasMoreTokens()) {
        String filename=st.nextToken();
        File file=makeFile(filename);
        if (file.exists() && FileUtil.hasZipSuffix(filename)) {
          inPath.add(file);
        }
 else {
          if (file.isDirectory()) {
            inPath.add(file);
          }
 else           showError(""String_Node_Str"" + filename);
        }
      }
      buildConfig.setInPath(inPath);
      args.remove(args.get(nextArgIndex));
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    ;
    if (args.size() > nextArgIndex) {
      StringTokenizer st=new StringTokenizer(((ConfigParser.Arg)args.get(nextArgIndex)).getValue(),File.pathSeparator);
      while (st.hasMoreTokens()) {
        String filename=st.nextToken();
        File jarFile=makeFile(filename);
        if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
          buildConfig.getInJars().add(jarFile);
        }
 else {
          File dirFile=makeFile(filename);
          if (dirFile.isDirectory()) {
            buildConfig.getInJars().add(dirFile);
          }
 else           showError(""String_Node_Str"" + filename);
        }
      }
      args.remove(args.get(nextArgIndex));
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    ;
    if (args.size() > nextArgIndex) {
      StringTokenizer st=new StringTokenizer(((ConfigParser.Arg)args.get(nextArgIndex)).getValue(),File.pathSeparator);
      while (st.hasMoreTokens()) {
        String filename=st.nextToken();
        File jarFile=makeFile(filename);
        if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
          buildConfig.getAspectpath().add(jarFile);
        }
 else {
          showError(""String_Node_Str"" + filename);
        }
      }
      args.remove(args.get(nextArgIndex));
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      List sourceRoots=new ArrayList();
      StringTokenizer st=new StringTokenizer(((ConfigParser.Arg)args.get(nextArgIndex)).getValue(),File.pathSeparator);
      while (st.hasMoreTokens()) {
        File f=makeFile(st.nextToken());
        if (f.isDirectory() && f.canRead()) {
          sourceRoots.add(f);
        }
 else {
          showError(""String_Node_Str"" + f);
        }
      }
      if (0 < sourceRoots.size()) {
        buildConfig.setSourceRoots(sourceRoots);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      File jarFile=makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
      if (FileUtil.hasZipSuffix(jarFile)) {
        try {
          if (!jarFile.exists()) {
            jarFile.createNewFile();
          }
          buildConfig.setOutputJar(jarFile);
        }
 catch (        IOException ioe) {
          showError(""String_Node_Str"" + jarFile);
        }
      }
 else {
        showError(""String_Node_Str"" + jarFile);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setIncrementalMode(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      File file=makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
      buildConfig.setIncrementalFile(file);
      if (!file.canRead()) {
        showError(""String_Node_Str"" + file);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setEmacsSymMode(true);
    buildConfig.setGenerateModelMode(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setGenerateModelMode(true);
    buildConfig.setGenerateJavadocsInModelMode(true);
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    buildConfig.setNoWeave(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setXserializableAspects(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setXlazyTjp(true);
  }
 else   if (arg.startsWith(""String_Node_Str"")) {
    buildConfig.setXreweavable(true);
    if (arg.endsWith(""String_Node_Str"")) {
      buildConfig.setXreweavableCompressClasses(true);
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setXnoInline(true);
  }
 else   if (arg.startsWith(""String_Node_Str"")) {
    buildConfig.setShowWeavingInformation(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      File lintSpecFile=makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
      if (lintSpecFile.canRead() && lintSpecFile.getName().endsWith(""String_Node_Str"")) {
        buildConfig.setLintSpecFile(lintSpecFile);
      }
 else {
        showError(""String_Node_Str"" + lintSpecFile);
        buildConfig.setLintSpecFile(null);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setLintMode(AjBuildConfig.AJLINT_DEFAULT);
  }
 else   if (arg.startsWith(""String_Node_Str"")) {
    if (7 < arg.length()) {
      buildConfig.setLintMode(arg.substring(7));
    }
 else {
      showError(""String_Node_Str"" + arg);
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      bootclasspath=((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      classpath=((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      extdirs=((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    dirLookahead(arg,args,nextArgIndex);
  }
 else   if (new File(arg).isDirectory()) {
    showError(""String_Node_Str"" + arg);
  }
 else {
    unparsedArgs.add(arg);
  }
}","/** 
 * Extract AspectJ-specific options (except for argfiles). Caller should warn when sourceroots is empty but in  incremental mode. Signals warnings or errors through handler set in constructor.
 */
public void parseOption(String arg,LinkedList args){
  int nextArgIndex=args.indexOf(arg) + 1;
  if (LangUtil.isEmpty(arg)) {
    showWarning(""String_Node_Str"");
  }
 else   if (arg.equals(""String_Node_Str"")) {
    ;
    if (args.size() > nextArgIndex) {
      List inPath=buildConfig.getInpath();
      StringTokenizer st=new StringTokenizer(((ConfigParser.Arg)args.get(nextArgIndex)).getValue(),File.pathSeparator);
      while (st.hasMoreTokens()) {
        String filename=st.nextToken();
        File file=makeFile(filename);
        if (file.exists() && FileUtil.hasZipSuffix(filename)) {
          inPath.add(file);
        }
 else {
          if (file.isDirectory()) {
            inPath.add(file);
          }
 else           showError(""String_Node_Str"" + filename);
        }
      }
      buildConfig.setInPath(inPath);
      args.remove(args.get(nextArgIndex));
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    ;
    if (args.size() > nextArgIndex) {
      StringTokenizer st=new StringTokenizer(((ConfigParser.Arg)args.get(nextArgIndex)).getValue(),File.pathSeparator);
      while (st.hasMoreTokens()) {
        String filename=st.nextToken();
        File jarFile=makeFile(filename);
        if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
          buildConfig.getInJars().add(jarFile);
        }
 else {
          File dirFile=makeFile(filename);
          if (dirFile.isDirectory()) {
            buildConfig.getInJars().add(dirFile);
          }
 else           showError(""String_Node_Str"" + filename);
        }
      }
      args.remove(args.get(nextArgIndex));
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    ;
    if (args.size() > nextArgIndex) {
      StringTokenizer st=new StringTokenizer(((ConfigParser.Arg)args.get(nextArgIndex)).getValue(),File.pathSeparator);
      while (st.hasMoreTokens()) {
        String filename=st.nextToken();
        File jarFile=makeFile(filename);
        if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
          buildConfig.getAspectpath().add(jarFile);
        }
 else {
          showError(""String_Node_Str"" + filename);
        }
      }
      args.remove(args.get(nextArgIndex));
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      List sourceRoots=new ArrayList();
      StringTokenizer st=new StringTokenizer(((ConfigParser.Arg)args.get(nextArgIndex)).getValue(),File.pathSeparator);
      while (st.hasMoreTokens()) {
        File f=makeFile(st.nextToken());
        if (f.isDirectory() && f.canRead()) {
          sourceRoots.add(f);
        }
 else {
          showError(""String_Node_Str"" + f);
        }
      }
      if (0 < sourceRoots.size()) {
        buildConfig.setSourceRoots(sourceRoots);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      File jarFile=makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
      if (FileUtil.hasZipSuffix(jarFile)) {
        try {
          if (!jarFile.exists()) {
            jarFile.createNewFile();
          }
          buildConfig.setOutputJar(jarFile);
        }
 catch (        IOException ioe) {
          showError(""String_Node_Str"" + jarFile);
        }
      }
 else {
        showError(""String_Node_Str"" + jarFile);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setIncrementalMode(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      File file=makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
      buildConfig.setIncrementalFile(file);
      if (!file.canRead()) {
        showError(""String_Node_Str"" + file);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setEmacsSymMode(true);
    buildConfig.setGenerateModelMode(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setGenerateModelMode(true);
    buildConfig.setGenerateJavadocsInModelMode(true);
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    buildConfig.setNoWeave(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setXserializableAspects(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setXlazyTjp(true);
  }
 else   if (arg.startsWith(""String_Node_Str"")) {
    buildConfig.setXreweavable(true);
    if (arg.endsWith(""String_Node_Str"")) {
      buildConfig.setXreweavableCompressClasses(true);
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setXnoInline(true);
  }
 else   if (arg.startsWith(""String_Node_Str"")) {
    buildConfig.setShowWeavingInformation(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      File lintSpecFile=makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
      if (lintSpecFile.canRead() && lintSpecFile.getName().endsWith(""String_Node_Str"")) {
        buildConfig.setLintSpecFile(lintSpecFile);
      }
 else {
        showError(""String_Node_Str"" + lintSpecFile);
        buildConfig.setLintSpecFile(null);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setLintMode(AjBuildConfig.AJLINT_DEFAULT);
  }
 else   if (arg.startsWith(""String_Node_Str"")) {
    if (7 < arg.length()) {
      buildConfig.setLintMode(arg.substring(7));
    }
 else {
      showError(""String_Node_Str"" + arg);
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      String bcpArg=((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
      StringBuffer bcp=new StringBuffer();
      StringTokenizer strTok=new StringTokenizer(bcpArg,File.pathSeparator);
      while (strTok.hasMoreTokens()) {
        bcp.append(makeFile(strTok.nextToken()));
        if (strTok.hasMoreTokens()) {
          bcp.append(File.pathSeparator);
        }
      }
      bootclasspath=bcp.toString();
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      String cpArg=((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
      StringBuffer cp=new StringBuffer();
      StringTokenizer strTok=new StringTokenizer(cpArg,File.pathSeparator);
      while (strTok.hasMoreTokens()) {
        cp.append(makeFile(strTok.nextToken()));
        if (strTok.hasMoreTokens()) {
          cp.append(File.pathSeparator);
        }
      }
      classpath=cp.toString();
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      String extdirsArg=((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
      StringBuffer ed=new StringBuffer();
      StringTokenizer strTok=new StringTokenizer(extdirsArg,File.pathSeparator);
      while (strTok.hasMoreTokens()) {
        ed.append(makeFile(strTok.nextToken()));
        if (strTok.hasMoreTokens()) {
          ed.append(File.pathSeparator);
        }
      }
      extdirs=ed.toString();
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    dirLookahead(arg,args,nextArgIndex);
  }
 else   if (new File(arg).isDirectory()) {
    showError(""String_Node_Str"" + arg);
  }
 else {
    unparsedArgs.add(arg);
  }
}",0.9168392224968273
9441,"public static InstructionList createConversion(InstructionFactory fact,Type fromType,Type toType){
  InstructionList il=new InstructionList();
  if (fromType.equals(toType))   return il;
  if (toType.equals(Type.VOID)) {
    il.append(InstructionFactory.createPop(fromType.getSize()));
    return il;
  }
  if (fromType.equals(Type.VOID)) {
    if (toType instanceof BasicType)     throw new BCException(""String_Node_Str"");
    il.append(InstructionFactory.createNull(Type.OBJECT));
    return il;
  }
  if (fromType.equals(Type.OBJECT)) {
    if (toType instanceof BasicType) {
      String name=toType.toString() + ""String_Node_Str"";
      il.append(fact.createInvoke(""String_Node_Str"",name,toType,new Type[]{Type.OBJECT},Constants.INVOKESTATIC));
      return il;
    }
  }
  if (toType.equals(Type.OBJECT)) {
    if (fromType instanceof BasicType) {
      String name=fromType.toString() + ""String_Node_Str"";
      il.append(fact.createInvoke(""String_Node_Str"",name,Type.OBJECT,new Type[]{fromType},Constants.INVOKESTATIC));
      return il;
    }
 else     if (fromType instanceof ReferenceType) {
      return il;
    }
 else {
      throw new RuntimeException();
    }
  }
  if (fromType instanceof ReferenceType && ((ReferenceType)fromType).isAssignmentCompatibleWith(toType)) {
    return il;
  }
  il.append(fact.createCast(fromType,toType));
  return il;
}","public static InstructionList createConversion(InstructionFactory fact,Type fromType,Type toType){
  InstructionList il=new InstructionList();
  if ((fromType.equals(Type.BYTE) || fromType.equals(Type.CHAR) || fromType.equals(Type.SHORT)) && (toType.equals(Type.INT))) {
    return il;
  }
  if (fromType.equals(toType))   return il;
  if (toType.equals(Type.VOID)) {
    il.append(InstructionFactory.createPop(fromType.getSize()));
    return il;
  }
  if (fromType.equals(Type.VOID)) {
    if (toType instanceof BasicType)     throw new BCException(""String_Node_Str"");
    il.append(InstructionFactory.createNull(Type.OBJECT));
    return il;
  }
  if (fromType.equals(Type.OBJECT)) {
    if (toType instanceof BasicType) {
      String name=toType.toString() + ""String_Node_Str"";
      il.append(fact.createInvoke(""String_Node_Str"",name,toType,new Type[]{Type.OBJECT},Constants.INVOKESTATIC));
      return il;
    }
  }
  if (toType.equals(Type.OBJECT)) {
    if (fromType instanceof BasicType) {
      String name=fromType.toString() + ""String_Node_Str"";
      il.append(fact.createInvoke(""String_Node_Str"",name,Type.OBJECT,new Type[]{fromType},Constants.INVOKESTATIC));
      return il;
    }
 else     if (fromType instanceof ReferenceType) {
      return il;
    }
 else {
      throw new RuntimeException();
    }
  }
  if (fromType instanceof ReferenceType && ((ReferenceType)fromType).isAssignmentCompatibleWith(toType)) {
    return il;
  }
  il.append(fact.createCast(fromType,toType));
  return il;
}",0.948976049982645
9442,"/** 
 * Returns false if a batch build is needed.
 */
boolean prepareForNextBuild(AjBuildConfig newBuildConfig){
  currentBuildTime=System.currentTimeMillis();
  addedClassFiles=new ArrayList();
  if (lastSuccessfulBuildTime == -1 || buildConfig == null) {
    return false;
  }
  if (newBuildConfig.getOutputJar() != null)   return false;
  if (pathChange(buildConfig,newBuildConfig))   return false;
  simpleStrings=new ArrayList();
  qualifiedStrings=new ArrayList();
  Set oldFiles=new HashSet(buildConfig.getFiles());
  Set newFiles=new HashSet(newBuildConfig.getFiles());
  addedFiles=new HashSet(newFiles);
  addedFiles.removeAll(oldFiles);
  deletedFiles=new HashSet(oldFiles);
  deletedFiles.removeAll(newFiles);
  Set oldBinaryFiles=new HashSet(buildConfig.getBinaryFiles());
  Set newBinaryFiles=new HashSet(newBuildConfig.getBinaryFiles());
  addedBinaryFiles=new HashSet(newBinaryFiles);
  addedBinaryFiles.removeAll(oldBinaryFiles);
  deletedBinaryFiles=new HashSet(oldBinaryFiles);
  deletedBinaryFiles.removeAll(newBinaryFiles);
  this.newBuildConfig=newBuildConfig;
  return true;
}","/** 
 * Returns false if a batch build is needed.
 */
boolean prepareForNextBuild(AjBuildConfig newBuildConfig){
  currentBuildTime=System.currentTimeMillis();
  addedClassFiles=new ArrayList();
  if (lastSuccessfulBuildTime == -1 || buildConfig == null) {
    return false;
  }
  if (newBuildConfig.getOutputJar() != null)   return false;
  if (pathChange(buildConfig,newBuildConfig)) {
    removeAllResultsOfLastBuild();
    return false;
  }
  simpleStrings=new ArrayList();
  qualifiedStrings=new ArrayList();
  Set oldFiles=new HashSet(buildConfig.getFiles());
  Set newFiles=new HashSet(newBuildConfig.getFiles());
  addedFiles=new HashSet(newFiles);
  addedFiles.removeAll(oldFiles);
  deletedFiles=new HashSet(oldFiles);
  deletedFiles.removeAll(newFiles);
  Set oldBinaryFiles=new HashSet(buildConfig.getBinaryFiles());
  Set newBinaryFiles=new HashSet(newBuildConfig.getBinaryFiles());
  addedBinaryFiles=new HashSet(newBinaryFiles);
  addedBinaryFiles.removeAll(oldBinaryFiles);
  deletedBinaryFiles=new HashSet(oldBinaryFiles);
  deletedBinaryFiles.removeAll(newBinaryFiles);
  this.newBuildConfig=newBuildConfig;
  return true;
}",0.967425256581883
9443,"/** 
 * Need to determine if I'm really a pattern or a reference to a formal We may wish to further optimize the case of pattern vs. non-pattern We will be replaced by what we return
 */
public TypePattern resolveBindings(IScope scope,Bindings bindings,boolean allowBinding,boolean requireExactType){
  if (isStar()) {
    return TypePattern.ANY;
  }
  String simpleName=maybeGetSimpleName();
  if (simpleName != null) {
    FormalBinding formalBinding=scope.lookupFormal(simpleName);
    if (formalBinding != null) {
      if (bindings == null) {
        scope.message(IMessage.ERROR,this,""String_Node_Str"");
        return this;
      }
      if (!allowBinding) {
        scope.message(IMessage.ERROR,this,""String_Node_Str"");
        return this;
      }
      BindingTypePattern binding=new BindingTypePattern(formalBinding);
      binding.copyLocationFrom(this);
      bindings.register(binding,scope);
      return binding;
    }
  }
  String cleanName=maybeGetCleanName();
  String originalName=cleanName;
  if (cleanName != null) {
    TypeX type;
    while ((type=scope.lookupType(cleanName,this)) == ResolvedTypeX.MISSING) {
      int lastDot=cleanName.lastIndexOf('.');
      if (lastDot == -1)       break;
      cleanName=cleanName.substring(0,lastDot) + '$' + cleanName.substring(lastDot + 1);
    }
    if (type == ResolvedTypeX.MISSING) {
      if (requireExactType) {
        if (!allowBinding) {
          scope.getWorld().getMessageHandler().handleMessage(MessageUtil.error(WeaverMessages.format(WeaverMessages.CANT_BIND_TYPE,originalName),getSourceLocation()));
        }
 else         if (scope.getWorld().getLint().invalidAbsoluteTypeName.isEnabled()) {
          scope.getWorld().getLint().invalidAbsoluteTypeName.signal(originalName,getSourceLocation());
        }
        return NO;
      }
 else       if (scope.getWorld().getLint().invalidAbsoluteTypeName.isEnabled()) {
        scope.getWorld().getLint().invalidAbsoluteTypeName.signal(originalName,getSourceLocation());
      }
    }
 else {
      if (dim != 0)       type=TypeX.makeArray(type,dim);
      TypePattern ret=new ExactTypePattern(type,includeSubtypes);
      ret.copyLocationFrom(this);
      return ret;
    }
  }
 else {
    if (requireExactType) {
      scope.getWorld().getMessageHandler().handleMessage(MessageUtil.error(WeaverMessages.format(WeaverMessages.WILDCARD_NOT_ALLOWED),getSourceLocation()));
      return NO;
    }
  }
  importedPrefixes=scope.getImportedPrefixes();
  knownMatches=preMatch(scope.getImportedNames());
  return this;
}","/** 
 * Need to determine if I'm really a pattern or a reference to a formal We may wish to further optimize the case of pattern vs. non-pattern We will be replaced by what we return
 */
public TypePattern resolveBindings(IScope scope,Bindings bindings,boolean allowBinding,boolean requireExactType){
  if (isStar()) {
    return TypePattern.ANY;
  }
  String simpleName=maybeGetSimpleName();
  if (simpleName != null) {
    FormalBinding formalBinding=scope.lookupFormal(simpleName);
    if (formalBinding != null) {
      if (bindings == null) {
        scope.message(IMessage.ERROR,this,""String_Node_Str"");
        return this;
      }
      if (!allowBinding) {
        scope.message(IMessage.ERROR,this,""String_Node_Str"");
        return this;
      }
      BindingTypePattern binding=new BindingTypePattern(formalBinding);
      binding.copyLocationFrom(this);
      bindings.register(binding,scope);
      return binding;
    }
  }
  String cleanName=maybeGetCleanName();
  String originalName=cleanName;
  ResolvedTypeX resolvedTypeInTheWorld=null;
  if (cleanName != null) {
    TypeX type;
    resolvedTypeInTheWorld=scope.getWorld().resolve(TypeX.forName(cleanName),true);
    while ((type=scope.lookupType(cleanName,this)) == ResolvedTypeX.MISSING) {
      int lastDot=cleanName.lastIndexOf('.');
      if (lastDot == -1)       break;
      cleanName=cleanName.substring(0,lastDot) + '$' + cleanName.substring(lastDot + 1);
      if (resolvedTypeInTheWorld == ResolvedTypeX.MISSING)       resolvedTypeInTheWorld=scope.getWorld().resolve(TypeX.forName(cleanName),true);
    }
    if (type == ResolvedTypeX.MISSING) {
      if (requireExactType) {
        if (!allowBinding) {
          scope.getWorld().getMessageHandler().handleMessage(MessageUtil.error(WeaverMessages.format(WeaverMessages.CANT_BIND_TYPE,originalName),getSourceLocation()));
        }
 else         if (scope.getWorld().getLint().invalidAbsoluteTypeName.isEnabled()) {
          scope.getWorld().getLint().invalidAbsoluteTypeName.signal(originalName,getSourceLocation());
        }
        return NO;
      }
 else       if (scope.getWorld().getLint().invalidAbsoluteTypeName.isEnabled()) {
        if (resolvedTypeInTheWorld == ResolvedTypeX.MISSING)         scope.getWorld().getLint().invalidAbsoluteTypeName.signal(originalName,getSourceLocation());
      }
    }
 else {
      if (dim != 0)       type=TypeX.makeArray(type,dim);
      TypePattern ret=new ExactTypePattern(type,includeSubtypes);
      ret.copyLocationFrom(this);
      return ret;
    }
  }
 else {
    if (requireExactType) {
      scope.getWorld().getMessageHandler().handleMessage(MessageUtil.error(WeaverMessages.format(WeaverMessages.WILDCARD_NOT_ALLOWED),getSourceLocation()));
      return NO;
    }
  }
  importedPrefixes=scope.getImportedPrefixes();
  knownMatches=preMatch(scope.getImportedNames());
  return this;
}",0.9329887391545136
9444,"public Pointcut maybeGetParsedPointcut(){
  pointcut=new IfPointcut(new ResolvedMember(Member.METHOD,TypeX.OBJECT,0,""String_Node_Str"",""String_Node_Str""),0);
  return pointcut;
}","public Pointcut maybeGetParsedPointcut(){
  if (expr instanceof FalseLiteral) {
    return IfPointcut.makeIfFalsePointcut(Pointcut.SYMBOLIC);
  }
 else   if (expr instanceof TrueLiteral) {
    return IfPointcut.makeIfTruePointcut(Pointcut.SYMBOLIC);
  }
 else {
    pointcut=new IfPointcut(new ResolvedMember(Member.METHOD,TypeX.OBJECT,0,""String_Node_Str"",""String_Node_Str""),0);
  }
  return pointcut;
}",0.6103448275862069
9445,"public void openFile(String filePath){
  try {
    if (filePath.endsWith(""String_Node_Str"")) {
      AjdeUIManager.getDefault().getBuildConfigEditor().openFile(filePath);
      topFrame.setEditorPanel(AjdeUIManager.getDefault().getBuildConfigEditor());
    }
 else     if (filePath.endsWith(""String_Node_Str"") || filePath.endsWith(""String_Node_Str"")) {
      editorManager.showSourceLine(filePath,0,false);
    }
 else {
      Ajde.getDefault().getErrorHandler().handleError(""String_Node_Str"" + filePath + ""String_Node_Str"");
    }
  }
 catch (  IOException ioe) {
    Ajde.getDefault().getErrorHandler().handleError(""String_Node_Str"" + filePath,ioe);
  }
catch (  InvalidResourceException ire) {
    Ajde.getDefault().getErrorHandler().handleError(""String_Node_Str"" + filePath,ire);
  }
  browserProjectProperties.setLastOpenSourceFilePath(filePath);
}","public void openFile(String filePath){
  try {
    if (filePath.endsWith(""String_Node_Str"")) {
      AjdeUIManager.getDefault().getBuildConfigEditor().openFile(filePath);
      topFrame.setEditorPanel(AjdeUIManager.getDefault().getBuildConfigEditor());
    }
 else     if (FileUtil.hasSourceSuffix(filePath)) {
      editorManager.showSourceLine(filePath,0,false);
    }
 else {
      Ajde.getDefault().getErrorHandler().handleError(""String_Node_Str"" + filePath + ""String_Node_Str"");
    }
  }
 catch (  IOException ioe) {
    Ajde.getDefault().getErrorHandler().handleError(""String_Node_Str"" + filePath,ioe);
  }
catch (  InvalidResourceException ire) {
    Ajde.getDefault().getErrorHandler().handleError(""String_Node_Str"" + filePath,ire);
  }
  browserProjectProperties.setLastOpenSourceFilePath(filePath);
}",0.935096153846154
9446,"public boolean isValidResource(){
  return name.endsWith(""String_Node_Str"") || name.endsWith(""String_Node_Str"") || name.endsWith(""String_Node_Str"");
}","public boolean isValidResource(){
  return FileUtil.hasSourceSuffix(name) || name.endsWith(""String_Node_Str"");
}",0.6641221374045801
9447,"public void execute() throws BuildException {
  if (srcdir == null && argfiles == null) {
    throw new BuildException(""String_Node_Str"",location);
  }
  if (destdir != null) {
    cmd.createArgument().setValue(""String_Node_Str"");
    cmd.createArgument().setFile(destdir);
  }
  if (classpath != null) {
    cmd.createArgument().setValue(""String_Node_Str"");
    cmd.createArgument().setPath(classpath);
  }
  if (bootclasspath != null) {
    cmd.createArgument().setValue(""String_Node_Str"");
    cmd.createArgument().setPath(bootclasspath);
  }
  if (extdirs != null) {
    cmd.createArgument().setValue(""String_Node_Str"");
    cmd.createArgument().setPath(extdirs);
  }
  if (null != encoding) {
    cmd.createArgument().setValue(""String_Node_Str"");
    cmd.createArgument().setValue(encoding);
  }
  if (null != source) {
    cmd.createArgument().setValue(""String_Node_Str"");
    cmd.createArgument().setValue(source);
  }
  int numargfiles=0;
  if (argfiles != null) {
    for (Iterator i=argfiles.iterator(); i.hasNext(); ) {
      String name=i.next() + ""String_Node_Str"";
      File argfile=project.resolveFile(name);
      if (check(argfile,name,false,location)) {
        cmd.createArgument().setValue(""String_Node_Str"");
        cmd.createArgument().setFile(argfile);
        numargfiles++;
      }
    }
  }
  int numfiles=0;
  if (srcdir != null) {
    String[] dirs=srcdir.list();
    for (int i=0; i < dirs.length; i++) {
      File dir=project.resolveFile(dirs[i]);
      check(dir,dirs[i],true,location);
      String[] files=getDirectoryScanner(dir).getIncludedFiles();
      for (int j=0; j < files.length; j++) {
        File file=new File(dir,files[j]);
        if (file.getName().endsWith(""String_Node_Str"") || file.getName().endsWith(""String_Node_Str"")) {
          cmd.createArgument().setFile(file);
          numfiles++;
        }
      }
    }
  }
  if ((null != ignoredOptions) && (ignoredOptions.size() > 0)) {
    log(""String_Node_Str"" + ignoredOptions,Project.MSG_WARN);
    if (ignoredOptions.contains(""String_Node_Str"")) {
      throw new BuildException(""String_Node_Str"");
    }
  }
  log(""String_Node_Str"" + numfiles + ""String_Node_Str""+ +numargfiles+ ""String_Node_Str""+ (null == destdir ? ""String_Node_Str"" : ""String_Node_Str"" + destdir.getPath()),Project.MSG_INFO);
  if (fork || (internalclasspath != null)) {
    log(""String_Node_Str"",Project.MSG_WARN);
  }
  int result=spoon();
  if (result != 0) {
    String msg=""String_Node_Str"" + result;
    if (failonerror) {
      reset();
      throw new BuildException(msg);
    }
 else {
      log(msg,Project.MSG_WARN);
    }
  }
  reset();
}","public void execute() throws BuildException {
  if (srcdir == null && argfiles == null) {
    throw new BuildException(""String_Node_Str"",location);
  }
  if (destdir != null) {
    cmd.createArgument().setValue(""String_Node_Str"");
    cmd.createArgument().setFile(destdir);
  }
  if (classpath != null) {
    cmd.createArgument().setValue(""String_Node_Str"");
    cmd.createArgument().setPath(classpath);
  }
  if (bootclasspath != null) {
    cmd.createArgument().setValue(""String_Node_Str"");
    cmd.createArgument().setPath(bootclasspath);
  }
  if (extdirs != null) {
    cmd.createArgument().setValue(""String_Node_Str"");
    cmd.createArgument().setPath(extdirs);
  }
  if (null != encoding) {
    cmd.createArgument().setValue(""String_Node_Str"");
    cmd.createArgument().setValue(encoding);
  }
  if (null != source) {
    cmd.createArgument().setValue(""String_Node_Str"");
    cmd.createArgument().setValue(source);
  }
  int numargfiles=0;
  if (argfiles != null) {
    for (Iterator i=argfiles.iterator(); i.hasNext(); ) {
      String name=i.next() + ""String_Node_Str"";
      File argfile=project.resolveFile(name);
      if (check(argfile,name,false,location)) {
        cmd.createArgument().setValue(""String_Node_Str"");
        cmd.createArgument().setFile(argfile);
        numargfiles++;
      }
    }
  }
  int numfiles=0;
  if (srcdir != null) {
    String[] dirs=srcdir.list();
    for (int i=0; i < dirs.length; i++) {
      File dir=project.resolveFile(dirs[i]);
      check(dir,dirs[i],true,location);
      String[] files=getDirectoryScanner(dir).getIncludedFiles();
      for (int j=0; j < files.length; j++) {
        File file=new File(dir,files[j]);
        if (FileUtil.hasSourceSuffix(file)) {
          cmd.createArgument().setFile(file);
          numfiles++;
        }
      }
    }
  }
  if ((null != ignoredOptions) && (ignoredOptions.size() > 0)) {
    log(""String_Node_Str"" + ignoredOptions,Project.MSG_WARN);
    if (ignoredOptions.contains(""String_Node_Str"")) {
      throw new BuildException(""String_Node_Str"");
    }
  }
  log(""String_Node_Str"" + numfiles + ""String_Node_Str""+ +numargfiles+ ""String_Node_Str""+ (null == destdir ? ""String_Node_Str"" : ""String_Node_Str"" + destdir.getPath()),Project.MSG_INFO);
  if (fork || (internalclasspath != null)) {
    log(""String_Node_Str"",Project.MSG_WARN);
  }
  int result=spoon();
  if (result != 0) {
    String msg=""String_Node_Str"" + result;
    if (failonerror) {
      reset();
      throw new BuildException(msg);
    }
 else {
      log(msg,Project.MSG_WARN);
    }
  }
  reset();
}",0.9780515979976896
9448,"static void parseArgs(List vargs,File currentWorkingDir){
  boolean addNextAsOption=false;
  boolean addNextAsArgFile=false;
  boolean addNextToAJCOptions=false;
  boolean addNextAsDocDir=false;
  boolean addNextAsClasspath=false;
  boolean ignoreArg=false;
  boolean addNextAsSourcePath=false;
  if (vargs.size() == 0) {
    displayHelpAndExit(null);
  }
  for (int i=0; i < vargs.size(); i++) {
    String arg=(String)vargs.get(i);
    ignoreArg=false;
    if (addNextToAJCOptions) {
      ajcOptions.addElement(arg);
      addNextToAJCOptions=false;
    }
    if (addNextAsDocDir) {
      docDir=arg;
      addNextAsDocDir=false;
    }
    if (addNextAsClasspath) {
      addNextAsClasspath=false;
    }
    if (addNextAsSourcePath) {
      setSourcepath(arg);
      addNextAsSourcePath=false;
      ignoreArg=true;
    }
    if (arg.startsWith(""String_Node_Str"")) {
      expandAtSignFile(arg.substring(1),currentWorkingDir);
    }
 else     if (arg.equals(""String_Node_Str"")) {
      addNextAsArgFile=true;
    }
 else     if (addNextAsArgFile) {
      expandAtSignFile(arg,currentWorkingDir);
      addNextAsArgFile=false;
    }
 else     if (arg.equals(""String_Node_Str"")) {
      addNextAsOption=true;
      options.addElement(arg);
      addNextAsDocDir=true;
    }
 else     if (arg.equals(""String_Node_Str"")) {
      addNextAsOption=true;
      addNextToAJCOptions=true;
      options.addElement(arg);
      ajcOptions.addElement(arg);
    }
 else     if (arg.equals(""String_Node_Str"")) {
      addNextAsOption=true;
      addNextToAJCOptions=true;
      addNextAsClasspath=true;
      options.addElement(arg);
      ajcOptions.addElement(arg);
    }
 else     if (arg.equals(""String_Node_Str"")) {
      addNextAsOption=true;
      addNextToAJCOptions=true;
      addNextAsClasspath=true;
      options.addElement(arg);
      ajcOptions.addElement(arg);
    }
 else     if (arg.equals(""String_Node_Str"")) {
      addNextAsSourcePath=true;
    }
 else     if (arg.equals(""String_Node_Str"")) {
      deleteTempFilesOnExit=false;
    }
 else     if (arg.equals(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"");
    }
 else     if (arg.equals(""String_Node_Str"")) {
    }
 else     if (arg.startsWith(""String_Node_Str"") || addNextAsOption) {
      if (arg.equals(""String_Node_Str"")) {
        docModifier=""String_Node_Str"";
      }
 else       if (arg.equals(""String_Node_Str"")) {
        docModifier=""String_Node_Str"";
      }
 else       if (arg.equals(""String_Node_Str"")) {
        docModifier=""String_Node_Str"";
      }
 else       if (arg.equals(""String_Node_Str"")) {
        docModifier=""String_Node_Str"";
      }
 else       if (arg.equals(""String_Node_Str"")) {
        verboseMode=true;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        authorStandardDocletSwitch=true;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        versionStandardDocletSwitch=true;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        System.out.println(getVersion());
        exit(0);
      }
 else       if (arg.equals(""String_Node_Str"")) {
        displayHelpAndExit(null);
      }
 else       if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        exit(0);
      }
 else       if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
      }
 else       if (addNextAsOption) {
      }
 else {
        System.err.println(""String_Node_Str"" + arg);
        displayHelpAndExit(null);
      }
      options.addElement(arg);
      addNextAsOption=false;
    }
 else {
      String entryName=arg.substring(arg.lastIndexOf(File.separator) + 1);
      if ((arg.endsWith(""String_Node_Str"") && entryName.indexOf('.') == entryName.length() - 5) || (arg.endsWith(""String_Node_Str"") && entryName.indexOf('.') == entryName.length() - 3) || arg.endsWith(""String_Node_Str"") && arg != null) {
        File f=new File(arg);
        if (f.isAbsolute()) {
          filenames.addElement(arg);
        }
 else {
          filenames.addElement(currentWorkingDir + Config.DIR_SEP_CHAR + arg);
        }
        fileList.addElement(arg);
      }
 else       if (!ignoreArg) {
        packageMode=true;
        packageList.addElement(arg);
        arg=arg.replace('.','/');
        for (int c=0; c < sourcepath.size(); c++) {
          String path=(String)sourcepath.elementAt(c) + Config.DIR_SEP_CHAR + arg;
          File pkg=new File(path);
          if (pkg.isDirectory()) {
            String[] files=pkg.list(new FilenameFilter(){
              public boolean accept(              File dir,              String name){
                int index1=name.lastIndexOf(""String_Node_Str"");
                int index2=name.length();
                if ((index1 >= 0 && index2 >= 0) && (name.substring(index1,index2).equals(""String_Node_Str"") || name.substring(index1,index2).equals(""String_Node_Str""))) {
                  return true;
                }
 else {
                  return false;
                }
              }
            }
);
            for (int j=0; j < files.length; j++) {
              filenames.addElement((String)sourcepath.elementAt(c) + Config.DIR_SEP_CHAR + arg+ Config.DIR_SEP_CHAR+ files[j]);
            }
          }
 else           if (c == sourcepath.size()) {
            System.out.println(""String_Node_Str"" + ""String_Node_Str"" + arg + ""String_Node_Str"");
          }
 else {
          }
        }
      }
    }
  }
  if (!options.contains(""String_Node_Str"") && !options.contains(""String_Node_Str"") && !options.contains(""String_Node_Str"")&& !options.contains(""String_Node_Str"")) {
    options.addElement(""String_Node_Str"");
  }
}","static void parseArgs(List vargs,File currentWorkingDir){
  boolean addNextAsOption=false;
  boolean addNextAsArgFile=false;
  boolean addNextToAJCOptions=false;
  boolean addNextAsDocDir=false;
  boolean addNextAsClasspath=false;
  boolean ignoreArg=false;
  boolean addNextAsSourcePath=false;
  if (vargs.size() == 0) {
    displayHelpAndExit(null);
  }
  for (int i=0; i < vargs.size(); i++) {
    String arg=(String)vargs.get(i);
    ignoreArg=false;
    if (addNextToAJCOptions) {
      ajcOptions.addElement(arg);
      addNextToAJCOptions=false;
    }
    if (addNextAsDocDir) {
      docDir=arg;
      addNextAsDocDir=false;
    }
    if (addNextAsClasspath) {
      addNextAsClasspath=false;
    }
    if (addNextAsSourcePath) {
      setSourcepath(arg);
      addNextAsSourcePath=false;
      ignoreArg=true;
    }
    if (arg.startsWith(""String_Node_Str"")) {
      expandAtSignFile(arg.substring(1),currentWorkingDir);
    }
 else     if (arg.equals(""String_Node_Str"")) {
      addNextAsArgFile=true;
    }
 else     if (addNextAsArgFile) {
      expandAtSignFile(arg,currentWorkingDir);
      addNextAsArgFile=false;
    }
 else     if (arg.equals(""String_Node_Str"")) {
      addNextAsOption=true;
      options.addElement(arg);
      addNextAsDocDir=true;
    }
 else     if (arg.equals(""String_Node_Str"")) {
      addNextAsOption=true;
      addNextToAJCOptions=true;
      options.addElement(arg);
      ajcOptions.addElement(arg);
    }
 else     if (arg.equals(""String_Node_Str"")) {
      addNextAsOption=true;
      addNextToAJCOptions=true;
      addNextAsClasspath=true;
      options.addElement(arg);
      ajcOptions.addElement(arg);
    }
 else     if (arg.equals(""String_Node_Str"")) {
      addNextAsOption=true;
      addNextToAJCOptions=true;
      addNextAsClasspath=true;
      options.addElement(arg);
      ajcOptions.addElement(arg);
    }
 else     if (arg.equals(""String_Node_Str"")) {
      addNextAsSourcePath=true;
    }
 else     if (arg.equals(""String_Node_Str"")) {
      deleteTempFilesOnExit=false;
    }
 else     if (arg.equals(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"");
    }
 else     if (arg.equals(""String_Node_Str"")) {
    }
 else     if (arg.startsWith(""String_Node_Str"") || addNextAsOption) {
      if (arg.equals(""String_Node_Str"")) {
        docModifier=""String_Node_Str"";
      }
 else       if (arg.equals(""String_Node_Str"")) {
        docModifier=""String_Node_Str"";
      }
 else       if (arg.equals(""String_Node_Str"")) {
        docModifier=""String_Node_Str"";
      }
 else       if (arg.equals(""String_Node_Str"")) {
        docModifier=""String_Node_Str"";
      }
 else       if (arg.equals(""String_Node_Str"")) {
        verboseMode=true;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        authorStandardDocletSwitch=true;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        versionStandardDocletSwitch=true;
      }
 else       if (arg.equals(""String_Node_Str"")) {
        System.out.println(getVersion());
        exit(0);
      }
 else       if (arg.equals(""String_Node_Str"")) {
        displayHelpAndExit(null);
      }
 else       if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        exit(0);
      }
 else       if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
      }
 else       if (addNextAsOption) {
      }
 else {
        System.err.println(""String_Node_Str"" + arg);
        displayHelpAndExit(null);
      }
      options.addElement(arg);
      addNextAsOption=false;
    }
 else {
      String entryName=arg.substring(arg.lastIndexOf(File.separator) + 1);
      if (FileUtil.hasSourceSuffix(arg) || arg.endsWith(""String_Node_Str"") && arg != null) {
        File f=new File(arg);
        if (f.isAbsolute()) {
          filenames.addElement(arg);
        }
 else {
          filenames.addElement(currentWorkingDir + Config.DIR_SEP_CHAR + arg);
        }
        fileList.addElement(arg);
      }
 else       if (!ignoreArg) {
        packageMode=true;
        packageList.addElement(arg);
        arg=arg.replace('.','/');
        for (int c=0; c < sourcepath.size(); c++) {
          String path=(String)sourcepath.elementAt(c) + Config.DIR_SEP_CHAR + arg;
          File pkg=new File(path);
          if (pkg.isDirectory()) {
            String[] files=pkg.list(new FilenameFilter(){
              public boolean accept(              File dir,              String name){
                int index1=name.lastIndexOf(""String_Node_Str"");
                int index2=name.length();
                if ((index1 >= 0 && index2 >= 0) && (name.substring(index1,index2).equals(""String_Node_Str"") || name.substring(index1,index2).equals(""String_Node_Str""))) {
                  return true;
                }
 else {
                  return false;
                }
              }
            }
);
            for (int j=0; j < files.length; j++) {
              filenames.addElement((String)sourcepath.elementAt(c) + Config.DIR_SEP_CHAR + arg+ Config.DIR_SEP_CHAR+ files[j]);
            }
          }
 else           if (c == sourcepath.size()) {
            System.out.println(""String_Node_Str"" + ""String_Node_Str"" + arg + ""String_Node_Str"");
          }
 else {
          }
        }
      }
    }
  }
  if (!options.contains(""String_Node_Str"") && !options.contains(""String_Node_Str"") && !options.contains(""String_Node_Str"")&& !options.contains(""String_Node_Str"")) {
    options.addElement(""String_Node_Str"");
  }
}",0.9826995696847282
9449,"public BinaryTypeBinding createBinaryTypeFrom(IBinaryType binaryType,PackageBinding packageBinding,boolean needFieldsAndMethods){
  if (inBinaryTypeCreation) {
    BinaryTypeBinding ret=super.createBinaryTypeFrom(binaryType,packageBinding,needFieldsAndMethods);
    pendingTypesToFinish.add(ret);
    return ret;
  }
  inBinaryTypeCreation=true;
  try {
    BinaryTypeBinding ret=super.createBinaryTypeFrom(binaryType,packageBinding,needFieldsAndMethods);
    weaveInterTypeDeclarations(ret);
    return ret;
  }
  finally {
    inBinaryTypeCreation=false;
    if (!pendingTypesToFinish.isEmpty()) {
      for (Iterator i=pendingTypesToFinish.iterator(); i.hasNext(); ) {
        weaveInterTypeDeclarations((BinaryTypeBinding)i.next());
      }
      pendingTypesToFinish.clear();
    }
  }
}","public BinaryTypeBinding createBinaryTypeFrom(IBinaryType binaryType,PackageBinding packageBinding,boolean needFieldsAndMethods){
  if (inBinaryTypeCreationAndWeaving) {
    BinaryTypeBinding ret=super.createBinaryTypeFrom(binaryType,packageBinding,needFieldsAndMethods);
    pendingTypesToFinish.add(ret);
    return ret;
  }
  inBinaryTypeCreationAndWeaving=true;
  try {
    BinaryTypeBinding ret=super.createBinaryTypeFrom(binaryType,packageBinding,needFieldsAndMethods);
    weaveInterTypeDeclarations(ret);
    return ret;
  }
  finally {
    inBinaryTypeCreationAndWeaving=false;
    if (pendingTypesToFinish.size() > 0) {
      processingTheQueue=true;
      while (!pendingTypesToFinish.isEmpty()) {
        BinaryTypeBinding nextVictim=(BinaryTypeBinding)pendingTypesToFinish.remove(0);
        weaveInterTypeDeclarations(nextVictim);
      }
      processingTheQueue=false;
    }
  }
}",0.7322274881516587
9450,"static void decorateHTMLFile(File file) throws IOException {
  System.out.println(""String_Node_Str"" + file.getCanonicalPath() + ""String_Node_Str"");
  BufferedReader reader=new BufferedReader(new FileReader(file));
  StringBuffer fileContents=new StringBuffer();
  String line=reader.readLine();
  while (line != null) {
    fileContents.append(line + ""String_Node_Str"");
    line=reader.readLine();
  }
  boolean isSecond=false;
  int index=0;
  IProgramElement decl;
  while (true) {
    String contents=fileContents.toString();
    int start=contents.indexOf(Config.DECL_ID_STRING,index);
    int end=contents.indexOf(Config.DECL_ID_TERMINATOR,index);
    if (start == -1)     decl=null;
 else     if (end == -1)     throw new Error(""String_Node_Str"");
 else {
      String tid=contents.substring(start + Config.DECL_ID_STRING.length(),end);
      decl=(IProgramElement)declIDTable.get(tid);
      index=start;
    }
    if (decl == null)     break;
    fileContents.delete(start,end + Config.DECL_ID_TERMINATOR.length());
    if (decl.getKind().isType()) {
      isSecond=true;
      addAspectDocumentation(decl,fileContents,index);
    }
 else {
      decorateMemberDocumentation(decl,fileContents,index);
    }
  }
  int classStartIndex=fileContents.toString().indexOf(""String_Node_Str"");
  if (classStartIndex != -1 && fileContents.toString().indexOf(""String_Node_Str"") != -1) {
    int classEndIndex=fileContents.toString().indexOf(""String_Node_Str"",classStartIndex);
    if (classStartIndex != -1 && classEndIndex != -1) {
      String classLine=fileContents.toString().substring(classStartIndex,classEndIndex);
      String aspectLine=""String_Node_Str"" + ""String_Node_Str"" + classLine.substring(11,classLine.length());
      fileContents.delete(classStartIndex,classEndIndex);
      fileContents.insert(classStartIndex,aspectLine);
    }
  }
  file.delete();
  FileOutputStream fos=new FileOutputStream(file);
  fos.write(fileContents.toString().getBytes());
}","/** 
 * Skips files that are public in the model but not public in the source, e.g. nested aspects.
 */
static void decorateHTMLFile(File file) throws IOException {
  if (!file.exists())   return;
  System.out.println(""String_Node_Str"" + file.getCanonicalPath() + ""String_Node_Str"");
  BufferedReader reader=new BufferedReader(new FileReader(file));
  StringBuffer fileContents=new StringBuffer();
  String line=reader.readLine();
  while (line != null) {
    fileContents.append(line + ""String_Node_Str"");
    line=reader.readLine();
  }
  boolean isSecond=false;
  int index=0;
  IProgramElement decl;
  while (true) {
    String contents=fileContents.toString();
    int start=contents.indexOf(Config.DECL_ID_STRING,index);
    int end=contents.indexOf(Config.DECL_ID_TERMINATOR,index);
    if (start == -1)     decl=null;
 else     if (end == -1)     throw new Error(""String_Node_Str"");
 else {
      String tid=contents.substring(start + Config.DECL_ID_STRING.length(),end);
      decl=(IProgramElement)declIDTable.get(tid);
      index=start;
    }
    if (decl == null)     break;
    fileContents.delete(start,end + Config.DECL_ID_TERMINATOR.length());
    if (decl.getKind().isType()) {
      isSecond=true;
      addAspectDocumentation(decl,fileContents,index);
    }
 else {
      decorateMemberDocumentation(decl,fileContents,index);
    }
  }
  int classStartIndex=fileContents.toString().indexOf(""String_Node_Str"");
  if (classStartIndex != -1 && fileContents.toString().indexOf(""String_Node_Str"") != -1) {
    int classEndIndex=fileContents.toString().indexOf(""String_Node_Str"",classStartIndex);
    if (classStartIndex != -1 && classEndIndex != -1) {
      String classLine=fileContents.toString().substring(classStartIndex,classEndIndex);
      String aspectLine=""String_Node_Str"" + ""String_Node_Str"" + classLine.substring(11,classLine.length());
      fileContents.delete(classStartIndex,classEndIndex);
      fileContents.insert(classStartIndex,aspectLine);
    }
  }
  file.delete();
  FileOutputStream fos=new FileOutputStream(file);
  fos.write(fileContents.toString().getBytes());
}",0.9666175748649976
9451,"public void testCoverage(){
  File file0=new File(""String_Node_Str"");
  File file1=new File(""String_Node_Str"");
  File aspect1=new File(""String_Node_Str"");
  File file2=new File(""String_Node_Str"");
  File file3=new File(""String_Node_Str"");
  File file4=new File(""String_Node_Str"");
  File file5=new File(""String_Node_Str"");
  File file6=new File(""String_Node_Str"");
  File file7=new File(""String_Node_Str"");
  File file8=new File(""String_Node_Str"");
  File outdir=new File(""String_Node_Str"");
  String[] args={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",outdir.getAbsolutePath(),aspect1.getAbsolutePath(),file0.getAbsolutePath(),file1.getAbsolutePath(),file2.getAbsolutePath(),file3.getAbsolutePath(),file4.getAbsolutePath(),file5.getAbsolutePath(),file6.getAbsolutePath(),file7.getAbsolutePath(),file8.getAbsolutePath()};
  org.aspectj.tools.ajdoc.Main.main(args);
}","public void testCoverage(){
  outdir.delete();
  String[] args={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",outdir.getAbsolutePath(),aspect1.getAbsolutePath(),file0.getAbsolutePath(),file1.getAbsolutePath(),file2.getAbsolutePath(),file3.getAbsolutePath(),file4.getAbsolutePath(),file5.getAbsolutePath(),file6.getAbsolutePath(),file7.getAbsolutePath(),file8.getAbsolutePath(),file9.getAbsolutePath()};
  org.aspectj.tools.ajdoc.Main.main(args);
}",0.6359649122807017
9452,"protected void setUp() throws Exception {
  super.setUp();
}","protected void setUp() throws Exception {
  super.setUp();
  new File(""String_Node_Str"").delete();
}",0.75
9453,"static void processFile(SymbolManager symbolManager,File inputFile,File signatureFile){
  try {
    String path=StructureUtil.translateAjPathName(signatureFile.getCanonicalPath());
    PrintWriter writer=new PrintWriter(new BufferedWriter(new FileWriter(path)));
    String packageName=StructureUtil.getPackageDeclarationFromFile(inputFile);
    if (packageName != null) {
      writer.println(""String_Node_Str"" + packageName + ""String_Node_Str"");
    }
    IProgramElement fileNode=(IProgramElement)AsmManager.getDefault().getHierarchy().findElementForSourceFile(inputFile.getAbsolutePath());
    for (Iterator it=fileNode.getChildren().iterator(); it.hasNext(); ) {
      IProgramElement node=(IProgramElement)it.next();
      if (node.getKind().equals(IProgramElement.Kind.IMPORT_REFERENCE)) {
        processImportDeclaration(node,writer);
      }
 else {
        processTypeDeclaration(node,writer);
      }
    }
    writer.close();
  }
 catch (  IOException e) {
    System.err.println(e.getMessage());
    e.printStackTrace();
  }
}","static void processFile(SymbolManager symbolManager,File inputFile,File signatureFile){
  try {
    String path=StructureUtil.translateAjPathName(signatureFile.getCanonicalPath());
    PrintWriter writer=new PrintWriter(new BufferedWriter(new FileWriter(path)));
    String packageName=StructureUtil.getPackageDeclarationFromFile(inputFile);
    if (packageName != null && packageName != ""String_Node_Str"") {
      writer.println(""String_Node_Str"" + packageName + ""String_Node_Str"");
    }
    IProgramElement fileNode=(IProgramElement)AsmManager.getDefault().getHierarchy().findElementForSourceFile(inputFile.getAbsolutePath());
    for (Iterator it=fileNode.getChildren().iterator(); it.hasNext(); ) {
      IProgramElement node=(IProgramElement)it.next();
      if (node.getKind().equals(IProgramElement.Kind.IMPORT_REFERENCE)) {
        processImportDeclaration(node,writer);
      }
 else {
        processTypeDeclaration(node,writer);
      }
    }
    writer.close();
  }
 catch (  IOException e) {
    System.err.println(e.getMessage());
    e.printStackTrace();
  }
}",0.9829867674858224
9454,"public void testCoverage(){
  File file1=new File(""String_Node_Str"");
  File aspect1=new File(""String_Node_Str"");
  File file2=new File(""String_Node_Str"");
  File file3=new File(""String_Node_Str"");
  File file4=new File(""String_Node_Str"");
  File file5=new File(""String_Node_Str"");
  File file6=new File(""String_Node_Str"");
  File file7=new File(""String_Node_Str"");
  File file8=new File(""String_Node_Str"");
  File outdir=new File(""String_Node_Str"");
  String[] args={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",outdir.getAbsolutePath(),aspect1.getAbsolutePath(),file1.getAbsolutePath(),file2.getAbsolutePath(),file3.getAbsolutePath(),file4.getAbsolutePath(),file5.getAbsolutePath(),file6.getAbsolutePath(),file7.getAbsolutePath(),file8.getAbsolutePath()};
  org.aspectj.tools.ajdoc.Main.main(args);
}","public void testCoverage(){
  File file0=new File(""String_Node_Str"");
  File file1=new File(""String_Node_Str"");
  File aspect1=new File(""String_Node_Str"");
  File file2=new File(""String_Node_Str"");
  File file3=new File(""String_Node_Str"");
  File file4=new File(""String_Node_Str"");
  File file5=new File(""String_Node_Str"");
  File file6=new File(""String_Node_Str"");
  File file7=new File(""String_Node_Str"");
  File file8=new File(""String_Node_Str"");
  File outdir=new File(""String_Node_Str"");
  String[] args={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",outdir.getAbsolutePath(),aspect1.getAbsolutePath(),file0.getAbsolutePath(),file1.getAbsolutePath(),file2.getAbsolutePath(),file3.getAbsolutePath(),file4.getAbsolutePath(),file5.getAbsolutePath(),file6.getAbsolutePath(),file7.getAbsolutePath(),file8.getAbsolutePath()};
  org.aspectj.tools.ajdoc.Main.main(args);
}",0.9617169373549884
9455,"/** 
 * Run AspectJ compiler, wrapping any exceptions thrown as ABORT messages (containing ABORT_MESSAGE String).
 * @param args the String[] for the compiler
 * @param handler the IMessageHandler for any messages
 * @see org.aspectj.bridge.ICommand#runCommand(String[],IMessageHandler)
 * @return false if handler has errors or the command failed
 */
public boolean runCommand(String[] args,IMessageHandler handler){
  buildManager=new AjBuildManager(handler);
  savedArgs=new String[args.length];
  System.arraycopy(args,0,savedArgs,0,savedArgs.length);
  for (int i=0; i < args.length; i++) {
    if (""String_Node_Str"".equals(args[i])) {
      MessageUtil.abort(handler,BuildArgParser.getUsage());
      return true;
    }
  }
  return doCommand(handler,false);
}","/** 
 * Run AspectJ compiler, wrapping any exceptions thrown as ABORT messages (containing ABORT_MESSAGE String).
 * @param args the String[] for the compiler
 * @param handler the IMessageHandler for any messages
 * @see org.aspectj.bridge.ICommand#runCommand(String[],IMessageHandler)
 * @return false if handler has errors or the command failed
 */
public boolean runCommand(String[] args,IMessageHandler handler){
  buildManager=new AjBuildManager(handler);
  savedArgs=new String[args.length];
  System.arraycopy(args,0,savedArgs,0,savedArgs.length);
  for (int i=0; i < args.length; i++) {
    if (""String_Node_Str"".equals(args[i])) {
      MessageUtil.abort(handler,BuildArgParser.getXOptionUsage());
      return true;
    }
  }
  return doCommand(handler,false);
}",0.99545159194282
9456,"private void inlineSelfConstructors(List methodGens){
  for (Iterator i=methodGens.iterator(); i.hasNext(); ) {
    LazyMethodGen mg=(LazyMethodGen)i.next();
    if (!mg.getName().equals(""String_Node_Str""))     continue;
    InstructionHandle ih=findSuperOrThisCall(mg);
    if (ih != null && isThisCall(ih)) {
      LazyMethodGen donor=getCalledMethod(ih);
      inlineMethod(donor,mg,ih);
    }
  }
}","private boolean inlineSelfConstructors(List methodGens){
  boolean inlinedSomething=false;
  for (Iterator i=methodGens.iterator(); i.hasNext(); ) {
    LazyMethodGen mg=(LazyMethodGen)i.next();
    if (!mg.getName().equals(""String_Node_Str""))     continue;
    InstructionHandle ih=findSuperOrThisCall(mg);
    if (ih != null && isThisCall(ih)) {
      LazyMethodGen donor=getCalledMethod(ih);
      inlineMethod(donor,mg,ih);
      inlinedSomething=true;
    }
  }
  return inlinedSomething;
}",0.887402452619844
9457,"public boolean weave(){
  if (clazz.isWoven() && !clazz.isReweavable()) {
    world.showMessage(IMessage.ERROR,""String_Node_Str"" + clazz.getType().getName() + ""String_Node_Str"",ty.getSourceLocation(),null);
    return false;
  }
  Set aspectsAffectingType=null;
  if (inReweavableMode)   aspectsAffectingType=new HashSet();
  boolean isChanged=false;
  if (clazz.getType().isAspect())   isChanged=true;
  for (Iterator i=typeMungers.iterator(); i.hasNext(); ) {
    Object o=i.next();
    if (!(o instanceof BcelTypeMunger)) {
      continue;
    }
    BcelTypeMunger munger=(BcelTypeMunger)o;
    boolean typeMungerAffectedType=munger.munge(this);
    if (typeMungerAffectedType) {
      isChanged=true;
      if (inReweavableMode)       aspectsAffectingType.add(munger.getAspectType().getName());
    }
  }
  addedSuperInitializersAsList=new ArrayList(addedSuperInitializers.values());
  addedSuperInitializersAsList=PartialOrder.sort(addedSuperInitializersAsList);
  if (addedSuperInitializersAsList == null) {
    throw new BCException(""String_Node_Str"");
  }
  LazyMethodGen staticInit=clazz.getStaticInitializer();
  staticInit.getBody().insert(genInitInstructions(addedClassInitializers,true));
  List methodGens=new ArrayList(clazz.getMethodGens());
  for (Iterator i=methodGens.iterator(); i.hasNext(); ) {
    LazyMethodGen mg=(LazyMethodGen)i.next();
    if (!mg.hasBody())     continue;
    boolean shadowMungerMatched=match(mg);
    if (shadowMungerMatched) {
      if (inReweavableMode)       aspectsAffectingType.addAll(findAspectsForMungers(mg));
      isChanged=true;
    }
  }
  if (!isChanged)   return false;
  for (Iterator i=methodGens.iterator(); i.hasNext(); ) {
    LazyMethodGen mg=(LazyMethodGen)i.next();
    if (!mg.hasBody())     continue;
    implement(mg);
  }
  if (!initializationShadows.isEmpty()) {
    inlineSelfConstructors(methodGens);
    positionAndImplement(initializationShadows);
  }
  if (isChanged) {
    clazz.getOrCreateWeaverStateInfo();
    weaveInAddedMethods();
  }
  if (inReweavableMode) {
    WeaverStateInfo wsi=clazz.getOrCreateWeaverStateInfo();
    wsi.addAspectsAffectingType(aspectsAffectingType);
    wsi.setUnwovenClassFileData(ty.getJavaClass().getBytes());
    wsi.setReweavable(true,compressReweavableAttributes);
  }
 else {
    clazz.getOrCreateWeaverStateInfo().setReweavable(false,false);
  }
  return isChanged;
}","public boolean weave(){
  if (clazz.isWoven() && !clazz.isReweavable()) {
    world.showMessage(IMessage.ERROR,""String_Node_Str"" + clazz.getType().getName() + ""String_Node_Str"",ty.getSourceLocation(),null);
    return false;
  }
  Set aspectsAffectingType=null;
  if (inReweavableMode)   aspectsAffectingType=new HashSet();
  boolean isChanged=false;
  if (clazz.getType().isAspect())   isChanged=true;
  for (Iterator i=typeMungers.iterator(); i.hasNext(); ) {
    Object o=i.next();
    if (!(o instanceof BcelTypeMunger)) {
      continue;
    }
    BcelTypeMunger munger=(BcelTypeMunger)o;
    boolean typeMungerAffectedType=munger.munge(this);
    if (typeMungerAffectedType) {
      isChanged=true;
      if (inReweavableMode)       aspectsAffectingType.add(munger.getAspectType().getName());
    }
  }
  addedSuperInitializersAsList=new ArrayList(addedSuperInitializers.values());
  addedSuperInitializersAsList=PartialOrder.sort(addedSuperInitializersAsList);
  if (addedSuperInitializersAsList == null) {
    throw new BCException(""String_Node_Str"");
  }
  LazyMethodGen staticInit=clazz.getStaticInitializer();
  staticInit.getBody().insert(genInitInstructions(addedClassInitializers,true));
  List methodGens=new ArrayList(clazz.getMethodGens());
  for (Iterator i=methodGens.iterator(); i.hasNext(); ) {
    LazyMethodGen mg=(LazyMethodGen)i.next();
    if (!mg.hasBody())     continue;
    boolean shadowMungerMatched=match(mg);
    if (shadowMungerMatched) {
      if (inReweavableMode)       aspectsAffectingType.addAll(findAspectsForMungers(mg));
      isChanged=true;
    }
  }
  if (!isChanged)   return false;
  for (Iterator i=methodGens.iterator(); i.hasNext(); ) {
    LazyMethodGen mg=(LazyMethodGen)i.next();
    if (!mg.hasBody())     continue;
    implement(mg);
  }
  if (!initializationShadows.isEmpty()) {
    while (inlineSelfConstructors(methodGens))     ;
    positionAndImplement(initializationShadows);
  }
  if (isChanged) {
    clazz.getOrCreateWeaverStateInfo();
    weaveInAddedMethods();
  }
  if (inReweavableMode) {
    WeaverStateInfo wsi=clazz.getOrCreateWeaverStateInfo();
    wsi.addAspectsAffectingType(aspectsAffectingType);
    wsi.setUnwovenClassFileData(ty.getJavaClass().getBytes());
    wsi.setReweavable(true,compressReweavableAttributes);
  }
 else {
    clazz.getOrCreateWeaverStateInfo().setReweavable(false,false);
  }
  return isChanged;
}",0.9972809035766576
9458,"public Pointcut concretize1(ResolvedTypeX inAspect,IntMap bindings){
  if (isDeclare(bindings.getEnclosingAdvice())) {
    inAspect.getWorld().showMessage(IMessage.ERROR,""String_Node_Str"",bindings.getEnclosingAdvice().getSourceLocation(),null);
    return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
  }
  if (partiallyConcretized != null) {
    return partiallyConcretized;
  }
  IfPointcut ret=new IfPointcut(testMethod,extraParameterFlags);
  partiallyConcretized=ret;
  if (bindings.directlyInAdvice()) {
    ShadowMunger advice=bindings.getEnclosingAdvice();
    if (advice instanceof Advice) {
      ret.baseArgsCount=((Advice)advice).getBaseParameterCount();
    }
 else {
      ret.baseArgsCount=0;
    }
    ret.residueSource=advice.getPointcut().concretize(inAspect,ret.baseArgsCount,advice);
  }
 else {
    ResolvedPointcutDefinition def=bindings.peekEnclosingDefinitition();
    if (def == CflowPointcut.CFLOW_MARKER) {
      inAspect.getWorld().showMessage(IMessage.ERROR,""String_Node_Str"",getSourceLocation(),null);
      return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
    }
    ret.baseArgsCount=def.getParameterTypes().length;
    IntMap newBindings=IntMap.idMap(ret.baseArgsCount);
    newBindings.copyContext(bindings);
    ret.residueSource=def.getPointcut().concretize(inAspect,newBindings);
  }
  return ret;
}","public Pointcut concretize1(ResolvedTypeX inAspect,IntMap bindings){
  if (isDeclare(bindings.getEnclosingAdvice())) {
    inAspect.getWorld().showMessage(IMessage.ERROR,""String_Node_Str"",bindings.getEnclosingAdvice().getSourceLocation(),null);
    return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
  }
  if (partiallyConcretized != null) {
    return partiallyConcretized;
  }
  IfPointcut ret=new IfPointcut(testMethod,extraParameterFlags);
  partiallyConcretized=ret;
  if (bindings.directlyInAdvice() && bindings.getEnclosingAdvice() == null) {
    inAspect.getWorld().showMessage(IMessage.ERROR,""String_Node_Str"",this.getSourceLocation(),null);
    return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
  }
  if (bindings.directlyInAdvice()) {
    ShadowMunger advice=bindings.getEnclosingAdvice();
    if (advice instanceof Advice) {
      ret.baseArgsCount=((Advice)advice).getBaseParameterCount();
    }
 else {
      ret.baseArgsCount=0;
    }
    ret.residueSource=advice.getPointcut().concretize(inAspect,ret.baseArgsCount,advice);
  }
 else {
    ResolvedPointcutDefinition def=bindings.peekEnclosingDefinitition();
    if (def == CflowPointcut.CFLOW_MARKER) {
      inAspect.getWorld().showMessage(IMessage.ERROR,""String_Node_Str"",getSourceLocation(),null);
      return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
    }
    ret.baseArgsCount=def.getParameterTypes().length;
    IntMap newBindings=IntMap.idMap(ret.baseArgsCount);
    newBindings.copyContext(bindings);
    ret.residueSource=def.getPointcut().concretize(inAspect,newBindings);
  }
  return ret;
}",0.6313993174061433
9459,"public boolean handleMessage(IMessage message) throws AbortException {
  if (!(message.isError() || message.isWarning()))   return sink.handleMessage(message);
  ISourceLocation sLoc=message.getSourceLocation();
  CompilationResult problemSource=currentlyWeaving;
  if (problemSource == null) {
    if (sLoc instanceof EclipseSourceLocation) {
      problemSource=((EclipseSourceLocation)sLoc).getCompilationResult();
    }
    if (problemSource == null) {
      return sink.handleMessage(message);
    }
  }
  int startPos=getStartPos(sLoc,problemSource);
  int endPos=getEndPos(sLoc,problemSource);
  int severity=message.isError() ? ProblemSeverities.Error : ProblemSeverities.Warning;
  char[] filename=problemSource.fileName;
  boolean usedBinarySourceFileName=false;
  if (problemSource.isFromBinarySource()) {
    if (sLoc != null) {
      filename=sLoc.getSourceFile().getPath().toCharArray();
      usedBinarySourceFileName=true;
    }
  }
  ReferenceContext referenceContext=findReferenceContextFor(problemSource);
  IProblem problem=compiler.problemReporter.createProblem(filename,IProblem.Unclassified,new String[0],new String[]{message.getMessage()},severity,startPos,endPos,sLoc != null ? sLoc.getLine() : 0,referenceContext,problemSource);
  IProblem[] seeAlso=buildSeeAlsoProblems(message.getExtraSourceLocations(),problemSource,usedBinarySourceFileName);
  problem.setSeeAlsoProblems(seeAlso);
  if (message.getDetails() != null) {
    problem.setSupplementaryMessageInfo(message.getDetails());
  }
  compiler.problemReporter.record(problem,problemSource,referenceContext);
  return true;
}","public boolean handleMessage(IMessage message) throws AbortException {
  if (!(message.isError() || message.isWarning()))   return sink.handleMessage(message);
  ISourceLocation sLoc=message.getSourceLocation();
  if (sLoc instanceof EclipseSourceLocation) {
    EclipseSourceLocation esLoc=(EclipseSourceLocation)sLoc;
    if (currentlyWeaving != null && esLoc.getCompilationResult() != null) {
      if (!currentlyWeaving.equals(((EclipseSourceLocation)sLoc).getCompilationResult()))       return sink.handleMessage(message);
    }
  }
  CompilationResult problemSource=currentlyWeaving;
  if (problemSource == null) {
    if (sLoc instanceof EclipseSourceLocation) {
      problemSource=((EclipseSourceLocation)sLoc).getCompilationResult();
    }
    if (problemSource == null) {
      return sink.handleMessage(message);
    }
  }
  int startPos=getStartPos(sLoc,problemSource);
  int endPos=getEndPos(sLoc,problemSource);
  int severity=message.isError() ? ProblemSeverities.Error : ProblemSeverities.Warning;
  char[] filename=problemSource.fileName;
  boolean usedBinarySourceFileName=false;
  if (problemSource.isFromBinarySource()) {
    if (sLoc != null) {
      filename=sLoc.getSourceFile().getPath().toCharArray();
      usedBinarySourceFileName=true;
    }
  }
  ReferenceContext referenceContext=findReferenceContextFor(problemSource);
  IProblem problem=compiler.problemReporter.createProblem(filename,IProblem.Unclassified,new String[0],new String[]{message.getMessage()},severity,startPos,endPos,sLoc != null ? sLoc.getLine() : 0,referenceContext,problemSource);
  IProblem[] seeAlso=buildSeeAlsoProblems(message.getExtraSourceLocations(),problemSource,usedBinarySourceFileName);
  problem.setSeeAlsoProblems(seeAlso);
  if (message.getDetails() != null) {
    problem.setSupplementaryMessageInfo(message.getDetails());
  }
  compiler.problemReporter.record(problem,problemSource,referenceContext);
  return true;
}",0.907909604519774
9460,"private Test findResidueNoEllipsis(Shadow shadow,ExposedState state,TypePattern[] patterns){
  int len=shadow.getArgCount();
  if (patterns.length != len) {
    return Literal.FALSE;
  }
  Test ret=Literal.TRUE;
  for (int i=0; i < len; i++) {
    TypeX argType=shadow.getArgType(i);
    TypePattern type=patterns[i];
    if (!(type instanceof BindingTypePattern)) {
      if (type.matchesInstanceof(shadow.getIWorld().resolve(argType)).alwaysTrue()) {
        continue;
      }
    }
    ret=Test.makeAnd(ret,exposeStateForVar(shadow.getArgVar(i),type,state,shadow.getIWorld()));
  }
  return ret;
}","private Test findResidueNoEllipsis(Shadow shadow,ExposedState state,TypePattern[] patterns){
  int len=shadow.getArgCount();
  if (patterns.length != len) {
    return Literal.FALSE;
  }
  Test ret=Literal.TRUE;
  for (int i=0; i < len; i++) {
    TypeX argType=shadow.getArgType(i);
    TypePattern type=patterns[i];
    if (!(type instanceof BindingTypePattern)) {
      if (type.matchesInstanceof(shadow.getIWorld().resolve(argType)).alwaysTrue()) {
        continue;
      }
    }
 else {
      BindingTypePattern btp=(BindingTypePattern)type;
      if (state.get(btp.getFormalIndex()) != null) {
        ISourceLocation isl=getSourceLocation();
        Message errorMessage=new Message(""String_Node_Str"" + type.getExactType().toString() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",shadow.getSourceLocation(),true,new ISourceLocation[]{getSourceLocation()});
        shadow.getIWorld().getMessageHandler().handleMessage(errorMessage);
      }
    }
    ret=Test.makeAnd(ret,exposeStateForVar(shadow.getArgVar(i),type,state,shadow.getIWorld()));
  }
  return ret;
}",0.6183115338882283
9461,"protected Test exposeStateForVar(Var var,TypePattern type,ExposedState state,World world){
  if (type instanceof BindingTypePattern) {
    BindingTypePattern b=(BindingTypePattern)type;
    if (state.get(b.getFormalIndex()) != null) {
      world.getMessageHandler().handleMessage(MessageUtil.error(""String_Node_Str"" + type.getExactType().toString() + ""String_Node_Str"",getSourceLocation()));
    }
 else {
      state.set(b.getFormalIndex(),var);
    }
  }
  TypeX myType=type.getExactType();
  return Test.makeInstanceof(var,myType.resolve(world));
}","protected Test exposeStateForVar(Var var,TypePattern type,ExposedState state,World world){
  if (type instanceof BindingTypePattern) {
    BindingTypePattern b=(BindingTypePattern)type;
    state.set(b.getFormalIndex(),var);
  }
  TypeX myType=type.getExactType();
  return Test.makeInstanceof(var,myType.resolve(world));
}",0.5485714285714286
9462,"protected Test exposeStateForVar(Var var,TypePattern type,ExposedState state,World world){
  if (type instanceof BindingTypePattern) {
    BindingTypePattern b=(BindingTypePattern)type;
    state.set(b.getFormalIndex(),var);
  }
  TypeX myType=type.getExactType();
  return Test.makeInstanceof(var,myType.resolve(world));
}","protected Test exposeStateForVar(Var var,TypePattern type,ExposedState state,World world){
  if (type instanceof BindingTypePattern) {
    BindingTypePattern b=(BindingTypePattern)type;
    if (state.get(b.getFormalIndex()) != null) {
      world.getMessageHandler().handleMessage(MessageUtil.error(""String_Node_Str"" + type.getExactType().toString() + ""String_Node_Str"",getSourceLocation()));
    }
 else {
      state.set(b.getFormalIndex(),var);
    }
  }
  TypeX myType=type.getExactType();
  return Test.makeInstanceof(var,myType.resolve(world));
}",0.7382857142857143
9463,"public EclipseTypeMunger build(ClassScope classScope){
  EclipseFactory world=EclipseFactory.fromScopeLookupEnvironment(classScope);
  binding=classScope.referenceContext.binding.resolveTypesFor(binding);
  resolveOnType(classScope);
  if (ignoreFurtherInvestigation)   return null;
  if (onTypeBinding.isInterface()) {
    classScope.problemReporter().signalError(sourceStart,sourceEnd,""String_Node_Str"");
    ignoreFurtherInvestigation=true;
    return null;
  }
  if (onTypeBinding.isNestedType()) {
    classScope.problemReporter().signalError(sourceStart,sourceEnd,""String_Node_Str"");
    ignoreFurtherInvestigation=true;
    return null;
  }
  ResolvedTypeX declaringTypeX=world.fromEclipse(onTypeBinding);
  ResolvedTypeX aspectType=world.fromEclipse(classScope.referenceContext.binding);
  ResolvedMember bindingAsMember=EclipseFactory.makeResolvedMember(binding);
  ResolvedMember signature=new ResolvedMember(Member.CONSTRUCTOR,declaringTypeX,declaredModifiers,ResolvedTypeX.VOID,""String_Node_Str"",bindingAsMember.getParameterTypes(),world.fromEclipse(binding.thrownExceptions));
  ResolvedMember syntheticInterMember=AjcMemberMaker.interConstructor(declaringTypeX,signature,aspectType);
  NewConstructorTypeMunger myMunger=new NewConstructorTypeMunger(signature,syntheticInterMember,null,null);
  setMunger(myMunger);
  myMunger.check(world.getWorld());
  this.selector=binding.selector=NameMangler.postIntroducedConstructor(EclipseFactory.fromBinding(binding.declaringClass),declaringTypeX).toCharArray();
  return new EclipseTypeMunger(world,myMunger,aspectType,this);
}","public EclipseTypeMunger build(ClassScope classScope){
  EclipseFactory world=EclipseFactory.fromScopeLookupEnvironment(classScope);
  resolveOnType(classScope);
  if (ignoreFurtherInvestigation)   return null;
  binding=classScope.referenceContext.binding.resolveTypesFor(binding);
  if (onTypeBinding.isInterface()) {
    classScope.problemReporter().signalError(sourceStart,sourceEnd,""String_Node_Str"");
    ignoreFurtherInvestigation=true;
    return null;
  }
  if (onTypeBinding.isNestedType()) {
    classScope.problemReporter().signalError(sourceStart,sourceEnd,""String_Node_Str"");
    ignoreFurtherInvestigation=true;
    return null;
  }
  ResolvedTypeX declaringTypeX=world.fromEclipse(onTypeBinding);
  ResolvedTypeX aspectType=world.fromEclipse(classScope.referenceContext.binding);
  ResolvedMember bindingAsMember=EclipseFactory.makeResolvedMember(binding);
  ResolvedMember signature=new ResolvedMember(Member.CONSTRUCTOR,declaringTypeX,declaredModifiers,ResolvedTypeX.VOID,""String_Node_Str"",bindingAsMember.getParameterTypes(),world.fromEclipse(binding.thrownExceptions));
  ResolvedMember syntheticInterMember=AjcMemberMaker.interConstructor(declaringTypeX,signature,aspectType);
  NewConstructorTypeMunger myMunger=new NewConstructorTypeMunger(signature,syntheticInterMember,null,null);
  setMunger(myMunger);
  myMunger.check(world.getWorld());
  this.selector=binding.selector=NameMangler.postIntroducedConstructor(EclipseFactory.fromBinding(binding.declaringClass),declaringTypeX).toCharArray();
  return new EclipseTypeMunger(world,myMunger,aspectType,this);
}",0.950726468730259
9464,"/** 
 * @throws AbortException if check for runtime fails 
 */
protected boolean doBuild(AjBuildConfig buildConfig,IMessageHandler baseHandler,boolean batch) throws IOException, AbortException {
  boolean ret=true;
  batchCompile=batch;
  try {
    if (batch) {
      this.state=new AjState(this);
    }
    boolean canIncremental=state.prepareForNextBuild(buildConfig);
    if (!canIncremental && !batch) {
      return doBuild(buildConfig,baseHandler,true);
    }
    this.handler=CountingMessageHandler.makeCountingMessageHandler(baseHandler);
    String check=checkRtJar(buildConfig);
    if (check != null) {
      if (FAIL_IF_RUNTIME_NOT_FOUND) {
        MessageUtil.error(handler,check);
        return false;
      }
 else {
        MessageUtil.warn(handler,check);
      }
    }
    setBuildConfig(buildConfig);
    setupModel();
    if (batch) {
      initBcelWorld(handler);
    }
    if (handler.hasErrors()) {
      return false;
    }
    if (buildConfig.getOutputJar() != null) {
      if (!openOutputStream(buildConfig.getOutputJar()))       return false;
    }
    if (batch) {
      if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode()) {
        bcelWorld.setModel(AsmManager.getDefault().getHierarchy());
      }
      binarySourcesForTheNextCompile=state.getBinaryFilesToCompile(true);
      performCompilation(buildConfig.getFiles());
      if (handler.hasErrors()) {
        return false;
      }
    }
 else {
      binarySourcesForTheNextCompile=state.getBinaryFilesToCompile(true);
      List files=state.getFilesToCompile(true);
      boolean hereWeGoAgain=!(files.isEmpty() && binarySourcesForTheNextCompile.isEmpty());
      for (int i=0; (i < 5) && hereWeGoAgain; i++) {
        performCompilation(files);
        if (handler.hasErrors() || (progressListener != null && progressListener.isCancelledRequested())) {
          return false;
        }
        binarySourcesForTheNextCompile=state.getBinaryFilesToCompile(false);
        files=state.getFilesToCompile(false);
        hereWeGoAgain=!(files.isEmpty() && binarySourcesForTheNextCompile.isEmpty());
      }
      if (!files.isEmpty()) {
        return batchBuild(buildConfig,baseHandler);
      }
    }
    if (buildConfig.isEmacsSymMode()) {
      new org.aspectj.ajdt.internal.core.builder.EmacsStructureModelManager().externalizeModel();
    }
    state.successfulCompile(buildConfig);
    copyResourcesToDestination();
    if (buildConfig.isGenerateModelMode()) {
      AsmManager.getDefault().fireModelUpdated();
    }
  }
  finally {
    if (zos != null) {
      closeOutputStream();
    }
    ret=!handler.hasErrors();
    handler=null;
  }
  return ret;
}","/** 
 * @throws AbortException if check for runtime fails 
 */
protected boolean doBuild(AjBuildConfig buildConfig,IMessageHandler baseHandler,boolean batch) throws IOException, AbortException {
  boolean ret=true;
  batchCompile=batch;
  try {
    if (batch) {
      this.state=new AjState(this);
    }
    boolean canIncremental=state.prepareForNextBuild(buildConfig);
    if (!canIncremental && !batch) {
      return doBuild(buildConfig,baseHandler,true);
    }
    this.handler=CountingMessageHandler.makeCountingMessageHandler(baseHandler);
    String check=checkRtJar(buildConfig);
    if (check != null) {
      if (FAIL_IF_RUNTIME_NOT_FOUND) {
        MessageUtil.error(handler,check);
        return false;
      }
 else {
        MessageUtil.warn(handler,check);
      }
    }
    setBuildConfig(buildConfig);
    setupModel();
    if (batch) {
      initBcelWorld(handler);
    }
    if (handler.hasErrors()) {
      return false;
    }
    if (buildConfig.getOutputJar() != null) {
      if (!openOutputStream(buildConfig.getOutputJar()))       return false;
    }
    if (batch) {
      if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode()) {
        bcelWorld.setModel(AsmManager.getDefault().getHierarchy());
      }
      binarySourcesForTheNextCompile=state.getBinaryFilesToCompile(true);
      performCompilation(buildConfig.getFiles());
      if (handler.hasErrors()) {
        return false;
      }
    }
 else {
      binarySourcesForTheNextCompile=state.getBinaryFilesToCompile(true);
      List files=state.getFilesToCompile(true);
      boolean hereWeGoAgain=!(files.isEmpty() && binarySourcesForTheNextCompile.isEmpty());
      for (int i=0; (i < 5) && hereWeGoAgain; i++) {
        performCompilation(files);
        if (handler.hasErrors() || (progressListener != null && progressListener.isCancelledRequested())) {
          return false;
        }
        binarySourcesForTheNextCompile=state.getBinaryFilesToCompile(false);
        files=state.getFilesToCompile(false);
        hereWeGoAgain=!(files.isEmpty() && binarySourcesForTheNextCompile.isEmpty());
      }
      if (!files.isEmpty()) {
        return batchBuild(buildConfig,baseHandler);
      }
    }
    if (buildConfig.isEmacsSymMode()) {
      new org.aspectj.ajdt.internal.core.builder.EmacsStructureModelManager().externalizeModel();
    }
    state.successfulCompile(buildConfig);
    copyResourcesToDestination();
    if (buildConfig.isGenerateModelMode()) {
      AsmManager.getDefault().fireModelUpdated();
    }
  }
  finally {
    if (zos != null) {
      closeOutputStream();
    }
    ret=!handler.hasErrors();
  }
  return ret;
}",0.996615268898082
9465,"public EclipseTypeMunger build(ClassScope classScope){
  EclipseFactory world=EclipseFactory.fromScopeLookupEnvironment(classScope);
  resolveOnType(classScope);
  if (ignoreFurtherInvestigation)   return null;
  binding=classScope.referenceContext.binding.resolveTypesFor(binding);
  if (binding == null) {
    throw new AbortCompilation();
  }
  ResolvedMember sig=new ResolvedMember(Member.METHOD,EclipseFactory.fromBinding(onTypeBinding),declaredModifiers,EclipseFactory.fromBinding(binding.returnType),new String(declaredSelector),EclipseFactory.fromBindings(binding.parameters),world.fromEclipse(binding.thrownExceptions));
  NewMethodTypeMunger myMunger=new NewMethodTypeMunger(sig,null);
  setMunger(myMunger);
  ResolvedTypeX aspectType=world.fromEclipse(classScope.referenceContext.binding);
  ResolvedMember me=myMunger.getDispatchMethod(aspectType);
  this.selector=binding.selector=me.getName().toCharArray();
  return new EclipseTypeMunger(world,myMunger,aspectType,this);
}","public EclipseTypeMunger build(ClassScope classScope){
  EclipseFactory world=EclipseFactory.fromScopeLookupEnvironment(classScope);
  resolveOnType(classScope);
  if (ignoreFurtherInvestigation)   return null;
  binding=classScope.referenceContext.binding.resolveTypesFor(binding);
  if (binding == null) {
    throw new AbortCompilation(compilationResult);
  }
  ResolvedMember sig=new ResolvedMember(Member.METHOD,EclipseFactory.fromBinding(onTypeBinding),declaredModifiers,EclipseFactory.fromBinding(binding.returnType),new String(declaredSelector),EclipseFactory.fromBindings(binding.parameters),world.fromEclipse(binding.thrownExceptions));
  NewMethodTypeMunger myMunger=new NewMethodTypeMunger(sig,null);
  setMunger(myMunger);
  ResolvedTypeX aspectType=world.fromEclipse(classScope.referenceContext.binding);
  ResolvedMember me=myMunger.getDispatchMethod(aspectType);
  this.selector=binding.selector=me.getName().toCharArray();
  return new EclipseTypeMunger(world,myMunger,aspectType,this);
}",0.9914701455092824
9466,"public ISourceLocation getSourceLocation(){
  int sourceLine=getSourceLine();
  if (sourceLine == 0) {
    return getEnclosingClass().getType().getSourceLocation();
  }
 else {
    return getEnclosingClass().getType().getSourceContext().makeSourceLocation(sourceLine);
  }
}","public ISourceLocation getSourceLocation(){
  int sourceLine=getSourceLine();
  if (sourceLine == 0 || sourceLine == -1) {
    return getEnclosingClass().getType().getSourceLocation();
  }
 else {
    return getEnclosingClass().getType().getSourceContext().makeSourceLocation(sourceLine);
  }
}",0.9647887323943662
9467,"private List getBinarySourcesFrom(Map binarySourceEntries){
  List ret=new ArrayList();
  for (Iterator binIter=binarySourceEntries.keySet().iterator(); binIter.hasNext(); ) {
    String sourceFileName=(String)binIter.next();
    List unwovenClassFiles=(List)binarySourceEntries.get(sourceFileName);
    CompilationResult result=new CompilationResult(sourceFileName.toCharArray(),0,0,compiler.options.maxProblemsPerUnit);
    result.noSourceAvailable();
    InterimCompilationResult binarySource=new InterimCompilationResult(result,unwovenClassFiles);
    ret.add(binarySource);
  }
  return ret;
}","private List getBinarySourcesFrom(Map binarySourceEntries){
  List ret=new ArrayList();
  for (Iterator binIter=binarySourceEntries.keySet().iterator(); binIter.hasNext(); ) {
    String sourceFileName=(String)binIter.next();
    List unwovenClassFiles=(List)binarySourceEntries.get(sourceFileName);
    CompilationResult result=new CompilationResult(sourceFileName.toCharArray(),0,0,Integer.MAX_VALUE);
    result.noSourceAvailable();
    InterimCompilationResult binarySource=new InterimCompilationResult(result,unwovenClassFiles);
    ret.add(binarySource);
  }
  return ret;
}",0.9575551782682512
9468,"public static String makeLocationContext(ICompilationUnit compilationUnit,IProblem problem){
  int startPosition=problem.getSourceStart();
  int endPosition=problem.getSourceEnd();
  if ((startPosition > endPosition) || ((startPosition <= 0) && (endPosition <= 0)))   return ""String_Node_Str"";
  final char SPACE='\u0020';
  final char MARK='^';
  final char TAB='\t';
  char[] source=compilationUnit.getContents();
  int begin=startPosition >= source.length ? source.length - 1 : startPosition;
  int relativeStart=0;
  int end=endPosition >= source.length ? source.length - 1 : endPosition;
  int relativeEnd=0;
  label:   for (relativeStart=0; ; relativeStart++) {
    if (begin == 0)     break label;
    if ((source[begin - 1] == '\n') || (source[begin - 1] == '\r'))     break label;
    begin--;
  }
  label:   for (relativeEnd=0; ; relativeEnd++) {
    if ((end + 1) >= source.length)     break label;
    if ((source[end + 1] == '\r') || (source[end + 1] == '\n')) {
      break label;
    }
    end++;
  }
  char[] extract=new char[end - begin + 1];
  System.arraycopy(source,begin,extract,0,extract.length);
  char c;
  int trimLeftIndex=0;
  while (((c=extract[trimLeftIndex++]) == TAB) || (c == SPACE)) {
  }
  ;
  System.arraycopy(extract,trimLeftIndex - 1,extract=new char[extract.length - trimLeftIndex + 1],0,extract.length);
  relativeStart-=trimLeftIndex;
  int pos=0;
  char[] underneath=new char[extract.length];
  for (int i=0; i <= relativeStart; i++) {
    if (extract[i] == TAB) {
      underneath[pos++]=TAB;
    }
 else {
      underneath[pos++]=SPACE;
    }
  }
  for (int i=startPosition + trimLeftIndex; i <= (endPosition >= source.length ? source.length - 1 : endPosition); i++)   underneath[pos++]=MARK;
  System.arraycopy(underneath,0,underneath=new char[pos],0,pos);
  return new String(extract) + ""String_Node_Str"" + new String(underneath);
}","public static String makeLocationContext(ICompilationUnit compilationUnit,IProblem problem){
  int startPosition=problem.getSourceStart();
  int endPosition=problem.getSourceEnd();
  if ((startPosition > endPosition) || ((startPosition <= 0) && (endPosition <= 0)) || compilationUnit == null)   return ""String_Node_Str"";
  final char SPACE='\u0020';
  final char MARK='^';
  final char TAB='\t';
  char[] source=compilationUnit.getContents();
  int begin=startPosition >= source.length ? source.length - 1 : startPosition;
  int relativeStart=0;
  int end=endPosition >= source.length ? source.length - 1 : endPosition;
  int relativeEnd=0;
  label:   for (relativeStart=0; ; relativeStart++) {
    if (begin == 0)     break label;
    if ((source[begin - 1] == '\n') || (source[begin - 1] == '\r'))     break label;
    begin--;
  }
  label:   for (relativeEnd=0; ; relativeEnd++) {
    if ((end + 1) >= source.length)     break label;
    if ((source[end + 1] == '\r') || (source[end + 1] == '\n')) {
      break label;
    }
    end++;
  }
  char[] extract=new char[end - begin + 1];
  System.arraycopy(source,begin,extract,0,extract.length);
  char c;
  int trimLeftIndex=0;
  while (((c=extract[trimLeftIndex++]) == TAB) || (c == SPACE)) {
  }
  ;
  System.arraycopy(extract,trimLeftIndex - 1,extract=new char[extract.length - trimLeftIndex + 1],0,extract.length);
  relativeStart-=trimLeftIndex;
  int pos=0;
  char[] underneath=new char[extract.length];
  for (int i=0; i <= relativeStart; i++) {
    if (extract[i] == TAB) {
      underneath[pos++]=TAB;
    }
 else {
      underneath[pos++]=SPACE;
    }
  }
  for (int i=startPosition + trimLeftIndex; i <= (endPosition >= source.length ? source.length - 1 : endPosition); i++)   underneath[pos++]=MARK;
  System.arraycopy(underneath,0,underneath=new char[pos],0,pos);
  return new String(extract) + ""String_Node_Str"" + new String(underneath);
}",0.992859032002116
9469,"private void generateMethod(ClassFile classFile,MethodBinding methodBinding,BodyGenerator gen){
  classFile.generateMethodInfoHeader(methodBinding);
  int methodAttributeOffset=classFile.contentsOffset;
  int attributeNumber=classFile.generateMethodInfoAttribute(methodBinding,AstUtil.getAjSyntheticAttribute());
  int codeAttributeOffset=classFile.contentsOffset;
  classFile.generateCodeAttributeHeader();
  CodeStream codeStream=classFile.codeStream;
  codeStream.init(classFile);
  codeStream.initializeMaxLocals(methodBinding);
  gen.generate(codeStream);
  classFile.completeCodeAttribute(codeAttributeOffset);
  attributeNumber++;
  classFile.completeMethodInfo(methodAttributeOffset,attributeNumber);
}","private void generateMethod(ClassFile classFile,MethodBinding methodBinding,BodyGenerator gen){
  classFile.generateMethodInfoHeader(methodBinding);
  int methodAttributeOffset=classFile.contentsOffset;
  int attributeNumber=classFile.generateMethodInfoAttribute(methodBinding,AstUtil.getAjSyntheticAttribute());
  int codeAttributeOffset=classFile.contentsOffset;
  classFile.generateCodeAttributeHeader();
  CodeStream codeStream=classFile.codeStream;
  MethodDeclaration md=AstUtil.makeMethodDeclaration(methodBinding);
  md.scope=initializerScope;
  codeStream.reset(md,classFile);
  gen.generate(codeStream);
  classFile.completeCodeAttribute(codeAttributeOffset);
  attributeNumber++;
  classFile.completeMethodInfo(methodAttributeOffset,attributeNumber);
}",0.8852681602172437
9470,"Collection getModifiedFiles(long lastBuildTime){
  List ret=new ArrayList();
  for (Iterator i=buildConfig.getFiles().iterator(); i.hasNext(); ) {
    File file=(File)i.next();
    if (!file.exists())     continue;
    long modTime=file.lastModified();
    if (modTime >= lastBuildTime) {
      ret.add(file);
    }
  }
  return ret;
}","Collection getModifiedFiles(long lastBuildTime){
  List ret=new ArrayList();
  for (Iterator i=buildConfig.getFiles().iterator(); i.hasNext(); ) {
    File file=(File)i.next();
    if (!file.exists())     continue;
    long modTime=file.lastModified();
    if (modTime + 1000 >= lastBuildTime) {
      ret.add(file);
    }
  }
  return ret;
}",0.9896602658788776
9471,"Collection getModifiedBinaryFiles(long lastBuildTime){
  List ret=new ArrayList();
  for (Iterator i=buildConfig.getBinaryFiles().iterator(); i.hasNext(); ) {
    AjBuildConfig.BinarySourceFile bsfile=(AjBuildConfig.BinarySourceFile)i.next();
    File file=bsfile.binSrc;
    if (!file.exists())     continue;
    long modTime=file.lastModified();
    if (modTime >= lastBuildTime) {
      ret.add(bsfile);
    }
  }
  return ret;
}","Collection getModifiedBinaryFiles(long lastBuildTime){
  List ret=new ArrayList();
  for (Iterator i=buildConfig.getBinaryFiles().iterator(); i.hasNext(); ) {
    AjBuildConfig.BinarySourceFile bsfile=(AjBuildConfig.BinarySourceFile)i.next();
    File file=bsfile.binSrc;
    if (!file.exists())     continue;
    long modTime=file.lastModified();
    if (modTime + 1000 >= lastBuildTime) {
      ret.add(bsfile);
    }
  }
  return ret;
}",0.9919632606199772
9472,"private List getBinarySourcesFrom(Map binarySourceEntries){
  List ret=new ArrayList();
  for (Iterator binIter=binarySourceEntries.keySet().iterator(); binIter.hasNext(); ) {
    String sourceFileName=(String)binIter.next();
    List unwovenClassFiles=(List)binarySourceEntries.get(sourceFileName);
    CompilationResult result=new CompilationResult(sourceFileName.toCharArray(),0,0,20);
    result.noSourceAvailable();
    InterimCompilationResult binarySource=new InterimCompilationResult(result,unwovenClassFiles);
    ret.add(binarySource);
  }
  return ret;
}","private List getBinarySourcesFrom(Map binarySourceEntries){
  List ret=new ArrayList();
  for (Iterator binIter=binarySourceEntries.keySet().iterator(); binIter.hasNext(); ) {
    String sourceFileName=(String)binIter.next();
    List unwovenClassFiles=(List)binarySourceEntries.get(sourceFileName);
    CompilationResult result=new CompilationResult(sourceFileName.toCharArray(),0,0,compiler.options.maxProblemsPerUnit);
    result.noSourceAvailable();
    InterimCompilationResult binarySource=new InterimCompilationResult(result,unwovenClassFiles);
    ret.add(binarySource);
  }
  return ret;
}",0.9681857265692176
9473,"private static String findHandlerParamName(InstructionHandle startOfHandler){
  if (startOfHandler.getInstruction() instanceof StoreInstruction && startOfHandler.getNext() != null) {
    int slot=((StoreInstruction)startOfHandler.getInstruction()).getIndex();
    InstructionTargeter[] targeters=startOfHandler.getNext().getTargeters();
    for (int i=targeters.length - 1; i >= 0; i--) {
      if (targeters[i] instanceof LocalVariableTag) {
        LocalVariableTag t=(LocalVariableTag)targeters[i];
        if (t.getSlot() == slot) {
          return t.getName();
        }
      }
    }
  }
  return ""String_Node_Str"";
}","private static String findHandlerParamName(InstructionHandle startOfHandler){
  if (startOfHandler.getInstruction() instanceof StoreInstruction && startOfHandler.getNext() != null) {
    int slot=((StoreInstruction)startOfHandler.getInstruction()).getIndex();
    InstructionTargeter[] targeters=startOfHandler.getNext().getTargeters();
    if (targeters != null) {
      for (int i=targeters.length - 1; i >= 0; i--) {
        if (targeters[i] instanceof LocalVariableTag) {
          LocalVariableTag t=(LocalVariableTag)targeters[i];
          if (t.getSlot() == slot) {
            return t.getName();
          }
        }
      }
    }
  }
  return ""String_Node_Str"";
}",0.9607390300230948
9474,"public void afterCompiling(){
  try {
    if (isXNoWeave || reportedErrors) {
      notifyRequestor();
    }
 else {
      weave();
    }
  }
 catch (  IOException ex) {
    AbortCompilation ac=new AbortCompilation(null,ex);
    throw ac;
  }
}","public void afterCompiling(){
  try {
    if (isXNoWeave || reportedErrors) {
      notifyRequestor();
    }
 else {
      weave();
    }
  }
 catch (  IOException ex) {
    AbortCompilation ac=new AbortCompilation(null,ex);
    throw ac;
  }
catch (  RuntimeException rEx) {
    if (rEx instanceof AbortCompilation)     throw rEx;
    throw new AbortCompilation(true,rEx);
  }
}",0.7800963081861958
9475,"public BcelSourceContext(BcelObjectType inObject){
  this.inObject=inObject;
  sourceFileName=inObject.getJavaClass().getSourceFileName();
  String pname=inObject.getResolvedTypeX().getPackageName();
  if (pname != null) {
    sourceFileName=pname.replace('.','/') + '/' + sourceFileName;
  }
}","public BcelSourceContext(BcelObjectType inObject){
  this.inObject=inObject;
  sourceFileName=inObject.getJavaClass().getSourceFileName();
  if (sourceFileName != null && sourceFileName.equals(""String_Node_Str"")) {
    sourceFileName=""String_Node_Str"" + inObject.getResolvedTypeX().getName() + ""String_Node_Str"";
  }
 else {
    String pname=inObject.getResolvedTypeX().getPackageName();
    if (pname != null) {
      sourceFileName=pname.replace('.','/') + '/' + sourceFileName;
    }
  }
}",0.7150127226463104
9476,"public FieldBinding getField(SourceTypeBinding sourceTypeBinding,char[] fieldName,InvocationSite site,Scope scope){
  FieldBinding retField=sourceTypeBinding.getFieldBase(fieldName,false);
  if (interTypeFields.isEmpty())   return retField;
  int fieldLength=fieldName.length;
  for (int i=0, len=interTypeFields.size(); i < len; i++) {
    FieldBinding field=(FieldBinding)interTypeFields.get(i);
    if (field.name.length == fieldLength && CharOperation.prefixEquals(field.name,fieldName)) {
      retField=resolveConflicts(sourceTypeBinding,retField,field,site,scope);
    }
  }
  return retField;
}","public FieldBinding getField(SourceTypeBinding sourceTypeBinding,char[] fieldName,InvocationSite site,Scope scope){
  FieldBinding retField=sourceTypeBinding.getFieldBase(fieldName,true);
  if (interTypeFields.isEmpty())   return retField;
  int fieldLength=fieldName.length;
  for (int i=0, len=interTypeFields.size(); i < len; i++) {
    FieldBinding field=(FieldBinding)interTypeFields.get(i);
    if (field.name.length == fieldLength && CharOperation.prefixEquals(field.name,fieldName)) {
      retField=resolveConflicts(sourceTypeBinding,retField,field,site,scope);
    }
  }
  return retField;
}",0.9941812136325852
9477,"public static void makeTestJars() throws IOException {
  List args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"" + File.pathSeparator + System.getProperty(""String_Node_Str""));
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"" + File.pathSeparator + System.getProperty(""String_Node_Str""));
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"" + File.pathSeparator + System.getProperty(""String_Node_Str""));
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"" + File.pathSeparator + System.getProperty(""String_Node_Str""));
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
}","public static void makeTestJars() throws IOException {
  List args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"" + File.pathSeparator + System.getProperty(""String_Node_Str""));
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"" + File.pathSeparator + System.getProperty(""String_Node_Str""));
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"" + File.pathSeparator + System.getProperty(""String_Node_Str""));
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"" + File.pathSeparator + System.getProperty(""String_Node_Str""));
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"" + File.pathSeparator + System.getProperty(""String_Node_Str""));
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
}",0.8959120577121265
9478,"public static void makeURLWeavingClassLoaderJars() throws IOException {
  List args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"" + File.pathSeparator + System.getProperty(""String_Node_Str""));
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(AjdtAjcTests.TESTDATA_PATH + ""String_Node_Str"");
  args.add(AjdtAjcTests.TESTDATA_PATH + ""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"" + File.pathSeparator + System.getProperty(""String_Node_Str""));
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(AjdtAjcTests.TESTDATA_PATH + ""String_Node_Str"");
  args.add(AjdtAjcTests.TESTDATA_PATH + ""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"" + File.pathSeparator + System.getProperty(""String_Node_Str""));
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(AjdtAjcTests.TESTDATA_PATH + ""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"" + File.pathSeparator + System.getProperty(""String_Node_Str""));
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(AjdtAjcTests.TESTDATA_PATH + ""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"" + File.pathSeparator + System.getProperty(""String_Node_Str""));
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(AjdtAjcTests.TESTDATA_PATH + ""String_Node_Str"");
  args.add(AjdtAjcTests.TESTDATA_PATH + ""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"" + File.pathSeparator + System.getProperty(""String_Node_Str""));
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(AjdtAjcTests.TESTDATA_PATH + ""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
}","public static void makeURLWeavingClassLoaderJars() throws IOException {
  List args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"" + File.pathSeparator + System.getProperty(""String_Node_Str""));
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(AjdtAjcTests.TESTDATA_PATH + ""String_Node_Str"");
  args.add(AjdtAjcTests.TESTDATA_PATH + ""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"" + File.pathSeparator + System.getProperty(""String_Node_Str""));
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(AjdtAjcTests.TESTDATA_PATH + ""String_Node_Str"");
  args.add(AjdtAjcTests.TESTDATA_PATH + ""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"" + File.pathSeparator + System.getProperty(""String_Node_Str""));
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(AjdtAjcTests.TESTDATA_PATH + ""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"" + File.pathSeparator + System.getProperty(""String_Node_Str""));
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(AjdtAjcTests.TESTDATA_PATH + ""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"" + File.pathSeparator + System.getProperty(""String_Node_Str""));
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(AjdtAjcTests.TESTDATA_PATH + ""String_Node_Str"");
  args.add(AjdtAjcTests.TESTDATA_PATH + ""String_Node_Str"");
  args.add(AjdtAjcTests.TESTDATA_PATH + ""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"" + File.pathSeparator + System.getProperty(""String_Node_Str""));
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(AjdtAjcTests.TESTDATA_PATH + ""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
}",0.987018606663782
9479,"/** 
 * Returns false if a batch build is needed.
 */
boolean prepareForNextBuild(AjBuildConfig newBuildConfig){
  currentBuildTime=System.currentTimeMillis();
  addedClassFiles=new ArrayList();
  if (lastSuccessfulBuildTime == -1 || buildConfig == null) {
    return false;
  }
  simpleStrings=new ArrayList();
  qualifiedStrings=new ArrayList();
  Set oldFiles=new HashSet(buildConfig.getFiles());
  Set newFiles=new HashSet(newBuildConfig.getFiles());
  addedFiles=new HashSet(newFiles);
  addedFiles.removeAll(oldFiles);
  deletedFiles=new HashSet(oldFiles);
  deletedFiles.removeAll(newFiles);
  this.newBuildConfig=newBuildConfig;
  return true;
}","/** 
 * Returns false if a batch build is needed.
 */
boolean prepareForNextBuild(AjBuildConfig newBuildConfig){
  currentBuildTime=System.currentTimeMillis();
  addedClassFiles=new ArrayList();
  if (lastSuccessfulBuildTime == -1 || buildConfig == null) {
    return false;
  }
  if (newBuildConfig.getOutputJar() != null)   return false;
  simpleStrings=new ArrayList();
  qualifiedStrings=new ArrayList();
  Set oldFiles=new HashSet(buildConfig.getFiles());
  Set newFiles=new HashSet(newBuildConfig.getFiles());
  addedFiles=new HashSet(newFiles);
  addedFiles.removeAll(oldFiles);
  deletedFiles=new HashSet(oldFiles);
  deletedFiles.removeAll(newFiles);
  this.newBuildConfig=newBuildConfig;
  return true;
}",0.9553767373811266
9480,"private void copyResourcesToDestination() throws IOException {
  if (buildConfig.getOutputJar() != null) {
    bcelWeaver.dumpResourcesToOutJar(zos);
  }
 else {
    bcelWeaver.dumpResourcesToOutPath();
  }
}","private void copyResourcesToDestination() throws IOException {
  for (Iterator i=buildConfig.getInJars().iterator(); i.hasNext(); ) {
    File inJar=(File)i.next();
    copyResourcesFromJarFile(inJar);
  }
  for (Iterator i=buildConfig.getInpath().iterator(); i.hasNext(); ) {
    File inPathElement=(File)i.next();
    if (inPathElement.isDirectory()) {
      copyResourcesFromDirectory(inPathElement);
    }
 else {
      copyResourcesFromJarFile(inPathElement);
    }
  }
  if (buildConfig.getSourcePathResources() != null) {
    for (Iterator i=buildConfig.getSourcePathResources().keySet().iterator(); i.hasNext(); ) {
      String resource=(String)i.next();
      copyResourcesFromFile((File)buildConfig.getSourcePathResources().get(resource),resource);
    }
  }
}",0.2512768130745659
9481,"private void closeOutputStream(){
  try {
    if (zos != null)     zos.close();
  }
 catch (  IOException ex) {
    IMessage message=new Message(""String_Node_Str"" + buildConfig.getOutputJar().getPath() + ""String_Node_Str""+ ex.getMessage()+ ""String_Node_Str"",new SourceLocation(buildConfig.getOutputJar(),0),true);
    handler.handleMessage(message);
  }
}","private void closeOutputStream(){
  try {
    if (zos != null)     zos.close();
    zos=null;
  }
 catch (  IOException ex) {
    IMessage message=new Message(""String_Node_Str"" + buildConfig.getOutputJar().getPath() + ""String_Node_Str""+ ex.getMessage()+ ""String_Node_Str"",new SourceLocation(buildConfig.getOutputJar(),0),true);
    handler.handleMessage(message);
  }
}",0.9806629834254144
9482,"/** 
 * init only on initial batch compile? no file-specific options 
 */
private void initBcelWorld(IMessageHandler handler) throws IOException {
  bcelWorld=new BcelWorld(buildConfig.getClasspath(),handler,null);
  bcelWorld.setXnoInline(buildConfig.isXnoInline());
  bcelWorld.setXlazyTjp(buildConfig.isXlazyTjp());
  bcelWeaver=new BcelWeaver(bcelWorld);
  state.binarySourceFiles=new HashMap();
  for (Iterator i=buildConfig.getAspectpath().iterator(); i.hasNext(); ) {
    File f=(File)i.next();
    bcelWeaver.addLibraryJarFile(f);
  }
  if (buildConfig.getLintMode().equals(AjBuildConfig.AJLINT_DEFAULT)) {
    bcelWorld.getLint().loadDefaultProperties();
  }
 else {
    bcelWorld.getLint().setAll(buildConfig.getLintMode());
  }
  if (buildConfig.getLintSpecFile() != null) {
    bcelWorld.getLint().setFromProperties(buildConfig.getLintSpecFile());
  }
  for (Iterator i=buildConfig.getInJars().iterator(); i.hasNext(); ) {
    File inJar=(File)i.next();
    List unwovenClasses=bcelWeaver.addJarFile(inJar,buildConfig.getOutputDir(),false);
    state.binarySourceFiles.put(inJar.getPath(),unwovenClasses);
  }
  for (Iterator i=buildConfig.getInpath().iterator(); i.hasNext(); ) {
    File inPathElement=(File)i.next();
    List unwovenClasses=bcelWeaver.addJarFile(inPathElement,buildConfig.getOutputDir(),true);
    state.binarySourceFiles.put(inPathElement.getPath(),unwovenClasses);
  }
  if (buildConfig.getSourcePathResources() != null) {
    for (Iterator i=buildConfig.getSourcePathResources().keySet().iterator(); i.hasNext(); ) {
      String resource=(String)i.next();
      bcelWeaver.addResource(resource,(File)buildConfig.getSourcePathResources().get(resource),buildConfig.getOutputDir());
    }
  }
  bcelWeaver.setReweavableMode(buildConfig.isXreweavable(),buildConfig.getXreweavableCompressClasses());
  bcelWorld.resolve(""String_Node_Str"");
}","/** 
 * init only on initial batch compile? no file-specific options 
 */
private void initBcelWorld(IMessageHandler handler) throws IOException {
  bcelWorld=new BcelWorld(buildConfig.getClasspath(),handler,null);
  bcelWorld.setXnoInline(buildConfig.isXnoInline());
  bcelWorld.setXlazyTjp(buildConfig.isXlazyTjp());
  bcelWeaver=new BcelWeaver(bcelWorld);
  state.binarySourceFiles=new HashMap();
  for (Iterator i=buildConfig.getAspectpath().iterator(); i.hasNext(); ) {
    File f=(File)i.next();
    bcelWeaver.addLibraryJarFile(f);
  }
  if (buildConfig.getLintMode().equals(AjBuildConfig.AJLINT_DEFAULT)) {
    bcelWorld.getLint().loadDefaultProperties();
  }
 else {
    bcelWorld.getLint().setAll(buildConfig.getLintMode());
  }
  if (buildConfig.getLintSpecFile() != null) {
    bcelWorld.getLint().setFromProperties(buildConfig.getLintSpecFile());
  }
  for (Iterator i=buildConfig.getInJars().iterator(); i.hasNext(); ) {
    File inJar=(File)i.next();
    List unwovenClasses=bcelWeaver.addJarFile(inJar,buildConfig.getOutputDir(),false);
    state.binarySourceFiles.put(inJar.getPath(),unwovenClasses);
  }
  for (Iterator i=buildConfig.getInpath().iterator(); i.hasNext(); ) {
    File inPathElement=(File)i.next();
    List unwovenClasses=bcelWeaver.addJarFile(inPathElement,buildConfig.getOutputDir(),true);
    state.binarySourceFiles.put(inPathElement.getPath(),unwovenClasses);
  }
  bcelWeaver.setReweavableMode(buildConfig.isXreweavable(),buildConfig.getXreweavableCompressClasses());
  bcelWorld.resolve(""String_Node_Str"");
}",0.9055831628178896
9483,"public List getFilesToCompile(boolean firstPass){
  List thisTime=new ArrayList();
  if (firstPass) {
    compiledSourceFiles=new ArrayList();
    Collection modifiedFiles=getModifiedFiles();
    thisTime.addAll(modifiedFiles);
    thisTime.addAll(addedFiles);
    deleteClassFiles();
    addAffectedSourceFiles(thisTime,thisTime);
  }
 else {
    addAffectedSourceFiles(thisTime,compiledSourceFiles);
  }
  compiledSourceFiles=thisTime;
  return thisTime;
}","public List getFilesToCompile(boolean firstPass){
  List thisTime=new ArrayList();
  if (firstPass) {
    compiledSourceFiles=new ArrayList();
    Collection modifiedFiles=getModifiedFiles();
    thisTime.addAll(modifiedFiles);
    thisTime.addAll(addedFiles);
    deleteClassFiles();
    deleteResources();
    addAffectedSourceFiles(thisTime,thisTime);
  }
 else {
    addAffectedSourceFiles(thisTime,compiledSourceFiles);
  }
  compiledSourceFiles=thisTime;
  return thisTime;
}",0.9755058572949948
9484,"/** 
 * Render message differently. If abort, then prefix stack trace with feedback request. If the actual message is empty, then use toString on the whole. Prefix message part with file:line; If it has context, suffix message with context.
 * @param message the IMessage to render
 * @return String rendering IMessage (never null)
 */
protected String render(IMessage message){
  StringBuffer sb=new StringBuffer();
  String text=message.getMessage();
  if (text.equals(AbortException.NO_MESSAGE_TEXT)) {
    text=null;
  }
  boolean toString=(LangUtil.isEmpty(text));
  if (toString) {
    text=message.toString();
  }
  ISourceLocation loc=message.getSourceLocation();
  String context=null;
  if (null != loc) {
    File file=loc.getSourceFile();
    if (null != file) {
      String name=file.getName();
      if (!toString || (-1 == text.indexOf(name))) {
        sb.append(FileUtil.getBestPath(file));
        if (loc.getLine() > 0) {
          sb.append(""String_Node_Str"" + loc.getLine());
        }
        int col=loc.getColumn();
        if (0 < col) {
          sb.append(""String_Node_Str"" + col);
        }
        sb.append(""String_Node_Str"");
      }
    }
    context=loc.getContext();
  }
  if (message.getKind() == IMessage.ERROR) {
    sb.append(""String_Node_Str"");
  }
 else   if (message.getKind() == IMessage.WARNING) {
    sb.append(""String_Node_Str"");
  }
  sb.append(text);
  if (null != context) {
    sb.append(LangUtil.EOL);
    sb.append(context);
  }
  Throwable thrown=message.getThrown();
  if (null != thrown) {
    sb.append(LangUtil.EOL);
    sb.append(Main.renderExceptionForUser(thrown));
  }
  if (message.getExtraSourceLocations().isEmpty()) {
    return sb.toString();
  }
 else {
    return MessageUtil.addExtraSourceLocations(message,sb.toString());
  }
}","/** 
 * Render message differently. If abort, then prefix stack trace with feedback request. If the actual message is empty, then use toString on the whole. Prefix message part with file:line; If it has context, suffix message with context.
 * @param message the IMessage to render
 * @return String rendering IMessage (never null)
 */
protected String render(IMessage message){
  StringBuffer sb=new StringBuffer();
  String text=message.getMessage();
  if (text.equals(AbortException.NO_MESSAGE_TEXT)) {
    text=null;
  }
  boolean toString=(LangUtil.isEmpty(text));
  if (toString) {
    text=message.toString();
  }
  ISourceLocation loc=message.getSourceLocation();
  String context=null;
  if (null != loc) {
    File file=loc.getSourceFile();
    if (null != file) {
      String name=file.getName();
      if (!toString || (-1 == text.indexOf(name))) {
        sb.append(FileUtil.getBestPath(file));
        if (loc.getLine() > 0) {
          sb.append(""String_Node_Str"" + loc.getLine());
        }
        int col=loc.getColumn();
        if (0 < col) {
          sb.append(""String_Node_Str"" + col);
        }
        sb.append(""String_Node_Str"");
      }
    }
    context=loc.getContext();
  }
  if (message.getKind() == IMessage.ERROR) {
    sb.append(""String_Node_Str"");
  }
 else   if (message.getKind() == IMessage.WARNING) {
    sb.append(""String_Node_Str"");
  }
  sb.append(text);
  if (null != context) {
    sb.append(LangUtil.EOL);
    sb.append(context);
  }
  String details=message.getDetails();
  if (details != null) {
    sb.append(LangUtil.EOL);
    sb.append('\t');
    sb.append(details);
  }
  Throwable thrown=message.getThrown();
  if (null != thrown) {
    sb.append(LangUtil.EOL);
    sb.append(Main.renderExceptionForUser(thrown));
  }
  if (message.getExtraSourceLocations().isEmpty()) {
    return sb.toString();
  }
 else {
    return MessageUtil.addExtraSourceLocations(message,sb.toString());
  }
}",0.933083511777302
9485,"public EclipseTypeMunger build(ClassScope classScope){
  EclipseFactory world=EclipseFactory.fromScopeLookupEnvironment(classScope);
  resolveOnType(classScope);
  if (ignoreFurtherInvestigation)   return null;
  binding=classScope.referenceContext.binding.resolveTypesFor(binding);
  ResolvedMember sig=new ResolvedMember(Member.METHOD,EclipseFactory.fromBinding(onTypeBinding),declaredModifiers,EclipseFactory.fromBinding(binding.returnType),new String(declaredSelector),EclipseFactory.fromBindings(binding.parameters),world.fromEclipse(binding.thrownExceptions));
  NewMethodTypeMunger myMunger=new NewMethodTypeMunger(sig,null);
  setMunger(myMunger);
  ResolvedTypeX aspectType=world.fromEclipse(classScope.referenceContext.binding);
  ResolvedMember me=myMunger.getDispatchMethod(aspectType);
  this.selector=binding.selector=me.getName().toCharArray();
  return new EclipseTypeMunger(world,myMunger,aspectType,this);
}","public EclipseTypeMunger build(ClassScope classScope){
  EclipseFactory world=EclipseFactory.fromScopeLookupEnvironment(classScope);
  resolveOnType(classScope);
  if (ignoreFurtherInvestigation)   return null;
  binding=classScope.referenceContext.binding.resolveTypesFor(binding);
  if (binding == null) {
    throw new AbortCompilation();
  }
  ResolvedMember sig=new ResolvedMember(Member.METHOD,EclipseFactory.fromBinding(onTypeBinding),declaredModifiers,EclipseFactory.fromBinding(binding.returnType),new String(declaredSelector),EclipseFactory.fromBindings(binding.parameters),world.fromEclipse(binding.thrownExceptions));
  NewMethodTypeMunger myMunger=new NewMethodTypeMunger(sig,null);
  setMunger(myMunger);
  ResolvedTypeX aspectType=world.fromEclipse(classScope.referenceContext.binding);
  ResolvedMember me=myMunger.getDispatchMethod(aspectType);
  this.selector=binding.selector=me.getName().toCharArray();
  return new EclipseTypeMunger(world,myMunger,aspectType,this);
}",0.967067433350758
9486,"/** 
 * @throws AbortException if check for runtime fails 
 */
protected boolean doBuild(AjBuildConfig buildConfig,IMessageHandler baseHandler,boolean batch) throws IOException, AbortException {
  batchCompile=batch;
  try {
    if (batch) {
      this.state=new AjState(this);
    }
    boolean canIncremental=state.prepareForNextBuild(buildConfig);
    if (!canIncremental && !batch) {
      return doBuild(buildConfig,baseHandler,true);
    }
    this.handler=CountingMessageHandler.makeCountingMessageHandler(baseHandler);
    String check=checkRtJar(buildConfig);
    if (check != null) {
      if (FAIL_IF_RUNTIME_NOT_FOUND) {
        MessageUtil.error(handler,check);
        return false;
      }
 else {
        MessageUtil.warn(handler,check);
      }
    }
    setBuildConfig(buildConfig);
    setupModel();
    if (batch) {
      initBcelWorld(handler);
    }
    if (handler.hasErrors()) {
      return false;
    }
    if (buildConfig.getOutputJar() != null) {
      OutputStream os=FileUtil.makeOutputStream(buildConfig.getOutputJar());
      zos=new ZipOutputStream(os);
    }
    if (batch) {
      if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode()) {
        bcelWorld.setModel(AsmManager.getDefault().getHierarchy());
      }
      performCompilation(buildConfig.getFiles());
      if (handler.hasErrors()) {
        return false;
      }
    }
 else {
      List files=state.getFilesToCompile(true);
      for (int i=0; (i < 5) && !files.isEmpty(); i++) {
        performCompilation(files);
        if (handler.hasErrors()) {
          return false;
        }
        files=state.getFilesToCompile(false);
      }
      if (!files.isEmpty()) {
        return batchBuild(buildConfig,baseHandler);
      }
    }
    if (buildConfig.isEmacsSymMode()) {
      new org.aspectj.ajdt.internal.core.builder.EmacsStructureModelManager().externalizeModel();
    }
    state.successfulCompile(buildConfig);
    copyResourcesToDestination();
    if (buildConfig.isGenerateModelMode()) {
      AsmManager.getDefault().fireModelUpdated();
    }
    return !handler.hasErrors();
  }
  finally {
    if (zos != null) {
      zos.close();
    }
    handler=null;
  }
}","/** 
 * @throws AbortException if check for runtime fails 
 */
protected boolean doBuild(AjBuildConfig buildConfig,IMessageHandler baseHandler,boolean batch) throws IOException, AbortException {
  boolean ret=true;
  batchCompile=batch;
  try {
    if (batch) {
      this.state=new AjState(this);
    }
    boolean canIncremental=state.prepareForNextBuild(buildConfig);
    if (!canIncremental && !batch) {
      return doBuild(buildConfig,baseHandler,true);
    }
    this.handler=CountingMessageHandler.makeCountingMessageHandler(baseHandler);
    String check=checkRtJar(buildConfig);
    if (check != null) {
      if (FAIL_IF_RUNTIME_NOT_FOUND) {
        MessageUtil.error(handler,check);
        return false;
      }
 else {
        MessageUtil.warn(handler,check);
      }
    }
    setBuildConfig(buildConfig);
    setupModel();
    if (batch) {
      initBcelWorld(handler);
    }
    if (handler.hasErrors()) {
      return false;
    }
    if (buildConfig.getOutputJar() != null) {
      if (!openOutputStream(buildConfig.getOutputJar()))       return false;
    }
    if (batch) {
      if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode()) {
        bcelWorld.setModel(AsmManager.getDefault().getHierarchy());
      }
      performCompilation(buildConfig.getFiles());
      if (handler.hasErrors()) {
        return false;
      }
    }
 else {
      List files=state.getFilesToCompile(true);
      for (int i=0; (i < 5) && !files.isEmpty(); i++) {
        performCompilation(files);
        if (handler.hasErrors()) {
          return false;
        }
        files=state.getFilesToCompile(false);
      }
      if (!files.isEmpty()) {
        return batchBuild(buildConfig,baseHandler);
      }
    }
    if (buildConfig.isEmacsSymMode()) {
      new org.aspectj.ajdt.internal.core.builder.EmacsStructureModelManager().externalizeModel();
    }
    state.successfulCompile(buildConfig);
    copyResourcesToDestination();
    if (buildConfig.isGenerateModelMode()) {
      AsmManager.getDefault().fireModelUpdated();
    }
  }
  finally {
    if (zos != null) {
      closeOutputStream();
    }
    ret=!handler.hasErrors();
    handler=null;
  }
  return ret;
}",0.9402644778841768
9487,"/** 
 * Extract AspectJ-specific options (except for argfiles). Caller should warn when sourceroots is empty but in  incremental mode. Signals warnings or errors through handler set in constructor.
 */
public void parseOption(String arg,LinkedList args){
  int nextArgIndex=args.indexOf(arg) + 1;
  if (LangUtil.isEmpty(arg)) {
    showWarning(""String_Node_Str"");
  }
 else   if (arg.equals(""String_Node_Str"")) {
    ;
    if (args.size() > nextArgIndex) {
      buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_Inpath,CompilerOptions.PRESERVE);
      StringTokenizer st=new StringTokenizer(((ConfigParser.Arg)args.get(nextArgIndex)).getValue(),File.pathSeparator);
      while (st.hasMoreTokens()) {
        String filename=st.nextToken();
        File file=makeFile(filename);
        if (file.exists() && FileUtil.hasZipSuffix(filename)) {
          buildConfig.getInpath().add(file);
        }
 else {
          if (file.isDirectory()) {
            buildConfig.getInpath().add(file);
          }
 else           showError(""String_Node_Str"" + filename);
        }
      }
      args.remove(args.get(nextArgIndex));
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    ;
    if (args.size() > nextArgIndex) {
      buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_InJARs,CompilerOptions.PRESERVE);
      StringTokenizer st=new StringTokenizer(((ConfigParser.Arg)args.get(nextArgIndex)).getValue(),File.pathSeparator);
      while (st.hasMoreTokens()) {
        String filename=st.nextToken();
        File jarFile=makeFile(filename);
        if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
          buildConfig.getInJars().add(jarFile);
        }
 else {
          File dirFile=makeFile(filename);
          if (dirFile.isDirectory()) {
            buildConfig.getInJars().add(dirFile);
          }
 else           showError(""String_Node_Str"" + filename);
        }
      }
      args.remove(args.get(nextArgIndex));
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    ;
    if (args.size() > nextArgIndex) {
      StringTokenizer st=new StringTokenizer(((ConfigParser.Arg)args.get(nextArgIndex)).getValue(),File.pathSeparator);
      while (st.hasMoreTokens()) {
        String filename=st.nextToken();
        File jarFile=makeFile(filename);
        if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
          buildConfig.getAspectpath().add(jarFile);
        }
 else {
          showError(""String_Node_Str"" + filename);
        }
      }
      args.remove(args.get(nextArgIndex));
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      List sourceRoots=new ArrayList();
      StringTokenizer st=new StringTokenizer(((ConfigParser.Arg)args.get(nextArgIndex)).getValue(),File.pathSeparator);
      while (st.hasMoreTokens()) {
        File f=makeFile(st.nextToken());
        if (f.isDirectory() && f.canRead()) {
          sourceRoots.add(f);
        }
 else {
          showError(""String_Node_Str"" + f);
        }
      }
      if (0 < sourceRoots.size()) {
        buildConfig.setSourceRoots(sourceRoots);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_OutJAR,CompilerOptions.GENERATE);
      File jarFile=makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
      if (FileUtil.hasZipSuffix(jarFile)) {
        try {
          if (!jarFile.exists()) {
            jarFile.createNewFile();
          }
          buildConfig.setOutputJar(jarFile);
        }
 catch (        IOException ioe) {
          showError(""String_Node_Str"" + jarFile);
        }
      }
 else {
        showError(""String_Node_Str"" + jarFile);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setIncrementalMode(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      File file=makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
      buildConfig.setIncrementalFile(file);
      if (!file.canRead()) {
        showError(""String_Node_Str"" + file);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setEmacsSymMode(true);
    buildConfig.setGenerateModelMode(true);
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    buildConfig.setNoWeave(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setXserializableAspects(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setXlazyTjp(true);
  }
 else   if (arg.startsWith(""String_Node_Str"")) {
    buildConfig.setXreweavable(true);
    if (arg.endsWith(""String_Node_Str"")) {
      buildConfig.setXreweavableCompressClasses(true);
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setXnoInline(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      File lintSpecFile=makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
      if (lintSpecFile.canRead() && lintSpecFile.getName().endsWith(""String_Node_Str"")) {
        buildConfig.setLintSpecFile(lintSpecFile);
      }
 else {
        showError(""String_Node_Str"" + lintSpecFile);
        buildConfig.setLintSpecFile(null);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_Xlint,CompilerOptions.GENERATE);
    buildConfig.setLintMode(AjBuildConfig.AJLINT_DEFAULT);
  }
 else   if (arg.startsWith(""String_Node_Str"")) {
    if (7 < arg.length()) {
      buildConfig.setLintMode(arg.substring(7));
    }
 else {
      showError(""String_Node_Str"" + arg);
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      bootclasspath=((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      classpath=((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      extdirs=((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    dirLookahead(arg,args,nextArgIndex);
  }
 else   if (new File(arg).isDirectory()) {
    showError(""String_Node_Str"" + arg);
  }
 else {
    unparsedArgs.add(arg);
  }
}","/** 
 * Extract AspectJ-specific options (except for argfiles). Caller should warn when sourceroots is empty but in  incremental mode. Signals warnings or errors through handler set in constructor.
 */
public void parseOption(String arg,LinkedList args){
  int nextArgIndex=args.indexOf(arg) + 1;
  if (LangUtil.isEmpty(arg)) {
    showWarning(""String_Node_Str"");
  }
 else   if (arg.equals(""String_Node_Str"")) {
    ;
    if (args.size() > nextArgIndex) {
      buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_Inpath,CompilerOptions.PRESERVE);
      List inPath=buildConfig.getInpath();
      StringTokenizer st=new StringTokenizer(((ConfigParser.Arg)args.get(nextArgIndex)).getValue(),File.pathSeparator);
      while (st.hasMoreTokens()) {
        String filename=st.nextToken();
        File file=makeFile(filename);
        if (file.exists() && FileUtil.hasZipSuffix(filename)) {
          inPath.add(file);
        }
 else {
          if (file.isDirectory()) {
            inPath.add(file);
          }
 else           showError(""String_Node_Str"" + filename);
        }
      }
      buildConfig.setInPath(inPath);
      args.remove(args.get(nextArgIndex));
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    ;
    if (args.size() > nextArgIndex) {
      buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_InJARs,CompilerOptions.PRESERVE);
      StringTokenizer st=new StringTokenizer(((ConfigParser.Arg)args.get(nextArgIndex)).getValue(),File.pathSeparator);
      while (st.hasMoreTokens()) {
        String filename=st.nextToken();
        File jarFile=makeFile(filename);
        if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
          buildConfig.getInJars().add(jarFile);
        }
 else {
          File dirFile=makeFile(filename);
          if (dirFile.isDirectory()) {
            buildConfig.getInJars().add(dirFile);
          }
 else           showError(""String_Node_Str"" + filename);
        }
      }
      args.remove(args.get(nextArgIndex));
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    ;
    if (args.size() > nextArgIndex) {
      StringTokenizer st=new StringTokenizer(((ConfigParser.Arg)args.get(nextArgIndex)).getValue(),File.pathSeparator);
      while (st.hasMoreTokens()) {
        String filename=st.nextToken();
        File jarFile=makeFile(filename);
        if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
          buildConfig.getAspectpath().add(jarFile);
        }
 else {
          showError(""String_Node_Str"" + filename);
        }
      }
      args.remove(args.get(nextArgIndex));
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      List sourceRoots=new ArrayList();
      StringTokenizer st=new StringTokenizer(((ConfigParser.Arg)args.get(nextArgIndex)).getValue(),File.pathSeparator);
      while (st.hasMoreTokens()) {
        File f=makeFile(st.nextToken());
        if (f.isDirectory() && f.canRead()) {
          sourceRoots.add(f);
        }
 else {
          showError(""String_Node_Str"" + f);
        }
      }
      if (0 < sourceRoots.size()) {
        buildConfig.setSourceRoots(sourceRoots);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_OutJAR,CompilerOptions.GENERATE);
      File jarFile=makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
      if (FileUtil.hasZipSuffix(jarFile)) {
        try {
          if (!jarFile.exists()) {
            jarFile.createNewFile();
          }
          buildConfig.setOutputJar(jarFile);
        }
 catch (        IOException ioe) {
          showError(""String_Node_Str"" + jarFile);
        }
      }
 else {
        showError(""String_Node_Str"" + jarFile);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setIncrementalMode(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      File file=makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
      buildConfig.setIncrementalFile(file);
      if (!file.canRead()) {
        showError(""String_Node_Str"" + file);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setEmacsSymMode(true);
    buildConfig.setGenerateModelMode(true);
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    buildConfig.setNoWeave(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setXserializableAspects(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setXlazyTjp(true);
  }
 else   if (arg.startsWith(""String_Node_Str"")) {
    buildConfig.setXreweavable(true);
    if (arg.endsWith(""String_Node_Str"")) {
      buildConfig.setXreweavableCompressClasses(true);
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setXnoInline(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      File lintSpecFile=makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
      if (lintSpecFile.canRead() && lintSpecFile.getName().endsWith(""String_Node_Str"")) {
        buildConfig.setLintSpecFile(lintSpecFile);
      }
 else {
        showError(""String_Node_Str"" + lintSpecFile);
        buildConfig.setLintSpecFile(null);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_Xlint,CompilerOptions.GENERATE);
    buildConfig.setLintMode(AjBuildConfig.AJLINT_DEFAULT);
  }
 else   if (arg.startsWith(""String_Node_Str"")) {
    if (7 < arg.length()) {
      buildConfig.setLintMode(arg.substring(7));
    }
 else {
      showError(""String_Node_Str"" + arg);
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      bootclasspath=((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      classpath=((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      extdirs=((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    dirLookahead(arg,args,nextArgIndex);
  }
 else   if (new File(arg).isDirectory()) {
    showError(""String_Node_Str"" + arg);
  }
 else {
    unparsedArgs.add(arg);
  }
}",0.991102951560514
9488,"/** 
 * Create an adapter, and tell it everything it needs to now to drive the AspectJ parts of a compile cycle.
 * @param compiler	the JDT compiler that produces class files from source
 * @param isBatchCompile  true if this is a full build (non-incremental)
 * @param world  the bcelWorld used for type resolution during weaving
 * @param weaver the weaver
 * @param intRequestor  recipient of interim compilation results from compiler (pre-weave)
 * @param outputFileNameProvider implementor of a strategy providing output file names for results
 * @param binarySourceEntries binary source that we didn't compile, but that we need to weave
 * @param resultSetForFullWeave if we are doing an incremental build, and the weaver determinesthat we need to weave the world, this is the set of intermediate results that will be passed to the weaver.
 * @param isXNoWeave
 */
public AjCompilerAdapter(Compiler compiler,boolean isBatchCompile,BcelWorld world,BcelWeaver weaver,EclipseFactory eFactory,IIntermediateResultsRequestor intRequestor,IProgressListener progressListener,IOutputClassFileNameProvider outputFileNameProvider,Map binarySourceEntries,Collection resultSetForFullWeave,boolean isXNoWeave){
  this.compiler=compiler;
  this.isBatchCompile=isBatchCompile;
  this.weaver=weaver;
  this.intermediateResultsRequestor=intRequestor;
  this.progressListener=progressListener;
  this.outputFileNameProvider=outputFileNameProvider;
  this.isXNoWeave=isXNoWeave;
  this.resultSetForFullWeave=resultSetForFullWeave;
  this.eWorld=eFactory;
  IMessageHandler msgHandler=world.getMessageHandler();
  weaverMessageHandler=new WeaverMessageHandler(msgHandler,compiler);
  world.setMessageHandler(weaverMessageHandler);
  addBinarySource(binarySourceEntries);
}","/** 
 * Create an adapter, and tell it everything it needs to now to drive the AspectJ parts of a compile cycle.
 * @param compiler	the JDT compiler that produces class files from source
 * @param isBatchCompile  true if this is a full build (non-incremental)
 * @param world  the bcelWorld used for type resolution during weaving
 * @param weaver the weaver
 * @param intRequestor  recipient of interim compilation results from compiler (pre-weave)
 * @param outputFileNameProvider implementor of a strategy providing output file names for results
 * @param binarySourceEntries binary source that we didn't compile, but that we need to weave
 * @param resultSetForFullWeave if we are doing an incremental build, and the weaver determinesthat we need to weave the world, this is the set of intermediate results that will be passed to the weaver.
 * @param isXNoWeave
 */
public AjCompilerAdapter(Compiler compiler,boolean isBatchCompile,BcelWorld world,BcelWeaver weaver,EclipseFactory eFactory,IIntermediateResultsRequestor intRequestor,IProgressListener progressListener,IOutputClassFileNameProvider outputFileNameProvider,IBinarySourceProvider binarySourceProvider,Map fullBinarySourceEntries,Collection resultSetForFullWeave,boolean isXNoWeave){
  this.compiler=compiler;
  this.isBatchCompile=isBatchCompile;
  this.weaver=weaver;
  this.intermediateResultsRequestor=intRequestor;
  this.progressListener=progressListener;
  this.outputFileNameProvider=outputFileNameProvider;
  this.binarySourceProvider=binarySourceProvider;
  this.isXNoWeave=isXNoWeave;
  this.binarySourceSetForFullWeave=fullBinarySourceEntries;
  this.resultSetForFullWeave=resultSetForFullWeave;
  this.eWorld=eFactory;
  IMessageHandler msgHandler=world.getMessageHandler();
  weaverMessageHandler=new WeaverMessageHandler(msgHandler,compiler);
  world.setMessageHandler(weaverMessageHandler);
}",0.942990911594602
9489,"private void weave() throws IOException {
  for (Iterator iter=resultsPendingWeave.iterator(); iter.hasNext(); ) {
    InterimCompilationResult iresult=(InterimCompilationResult)iter.next();
    for (int i=0; i < iresult.unwovenClassFiles().length; i++) {
      weaver.addClassFile(iresult.unwovenClassFiles()[i]);
    }
  }
  weaver.prepareForWeave();
  if (isBatchCompile) {
    resultsPendingWeave.addAll(binarySources);
  }
 else   if (weaver.needToReweaveWorld()) {
    addAllKnownClassesToWeaveList();
  }
  weaver.weave(new WeaverAdapter(this,weaverMessageHandler,progressListener));
}","private void weave() throws IOException {
  for (Iterator iter=resultsPendingWeave.iterator(); iter.hasNext(); ) {
    InterimCompilationResult iresult=(InterimCompilationResult)iter.next();
    for (int i=0; i < iresult.unwovenClassFiles().length; i++) {
      weaver.addClassFile(iresult.unwovenClassFiles()[i]);
    }
  }
  weaver.prepareForWeave();
  if (weaver.needToReweaveWorld()) {
    if (!isBatchCompile)     addAllKnownClassesToWeaveList();
    resultsPendingWeave.addAll(getBinarySourcesFrom(binarySourceSetForFullWeave));
  }
 else {
    Map binarySourcesToAdd=binarySourceProvider.getBinarySourcesForThisWeave();
    resultsPendingWeave.addAll(getBinarySourcesFrom(binarySourcesToAdd));
  }
  weaver.weave(new WeaverAdapter(this,weaverMessageHandler,progressListener));
}",0.6405228758169934
9490,"public void setInPath(List dirsOrJars){
  inPath=dirsOrJars;
}","public void setInPath(List dirsOrJars){
  inPath=dirsOrJars;
  binaryFiles=new ArrayList();
  FileFilter filter=new FileFilter(){
    public boolean accept(    File pathname){
      return pathname.getPath().endsWith(""String_Node_Str"");
    }
  }
;
  for (Iterator iter=dirsOrJars.iterator(); iter.hasNext(); ) {
    File inpathElement=(File)iter.next();
    if (inpathElement.isDirectory()) {
      File[] files=FileUtil.listFiles(inpathElement,filter);
      for (int i=0; i < files.length; i++) {
        binaryFiles.add(new BinarySourceFile(inpathElement,files[i]));
      }
    }
  }
}",0.1901840490797546
9491,"/** 
 * @throws AbortException if check for runtime fails 
 */
protected boolean doBuild(AjBuildConfig buildConfig,IMessageHandler baseHandler,boolean batch) throws IOException, AbortException {
  boolean ret=true;
  batchCompile=batch;
  try {
    if (batch) {
      this.state=new AjState(this);
    }
    boolean canIncremental=state.prepareForNextBuild(buildConfig);
    if (!canIncremental && !batch) {
      return doBuild(buildConfig,baseHandler,true);
    }
    this.handler=CountingMessageHandler.makeCountingMessageHandler(baseHandler);
    String check=checkRtJar(buildConfig);
    if (check != null) {
      if (FAIL_IF_RUNTIME_NOT_FOUND) {
        MessageUtil.error(handler,check);
        return false;
      }
 else {
        MessageUtil.warn(handler,check);
      }
    }
    setBuildConfig(buildConfig);
    setupModel();
    if (batch) {
      initBcelWorld(handler);
    }
    if (handler.hasErrors()) {
      return false;
    }
    if (buildConfig.getOutputJar() != null) {
      if (!openOutputStream(buildConfig.getOutputJar()))       return false;
    }
    if (batch) {
      if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode()) {
        bcelWorld.setModel(AsmManager.getDefault().getHierarchy());
      }
      performCompilation(buildConfig.getFiles());
      if (handler.hasErrors()) {
        return false;
      }
    }
 else {
      List files=state.getFilesToCompile(true);
      for (int i=0; (i < 5) && !files.isEmpty(); i++) {
        performCompilation(files);
        if (handler.hasErrors() || (progressListener != null && progressListener.isCancelledRequested())) {
          return false;
        }
        files=state.getFilesToCompile(false);
      }
      if (!files.isEmpty()) {
        return batchBuild(buildConfig,baseHandler);
      }
    }
    if (buildConfig.isEmacsSymMode()) {
      new org.aspectj.ajdt.internal.core.builder.EmacsStructureModelManager().externalizeModel();
    }
    state.successfulCompile(buildConfig);
    copyResourcesToDestination();
    if (buildConfig.isGenerateModelMode()) {
      AsmManager.getDefault().fireModelUpdated();
    }
  }
  finally {
    if (zos != null) {
      closeOutputStream();
    }
    ret=!handler.hasErrors();
    handler=null;
  }
  return ret;
}","/** 
 * @throws AbortException if check for runtime fails 
 */
protected boolean doBuild(AjBuildConfig buildConfig,IMessageHandler baseHandler,boolean batch) throws IOException, AbortException {
  boolean ret=true;
  batchCompile=batch;
  try {
    if (batch) {
      this.state=new AjState(this);
    }
    boolean canIncremental=state.prepareForNextBuild(buildConfig);
    if (!canIncremental && !batch) {
      return doBuild(buildConfig,baseHandler,true);
    }
    this.handler=CountingMessageHandler.makeCountingMessageHandler(baseHandler);
    String check=checkRtJar(buildConfig);
    if (check != null) {
      if (FAIL_IF_RUNTIME_NOT_FOUND) {
        MessageUtil.error(handler,check);
        return false;
      }
 else {
        MessageUtil.warn(handler,check);
      }
    }
    setBuildConfig(buildConfig);
    setupModel();
    if (batch) {
      initBcelWorld(handler);
    }
    if (handler.hasErrors()) {
      return false;
    }
    if (buildConfig.getOutputJar() != null) {
      if (!openOutputStream(buildConfig.getOutputJar()))       return false;
    }
    if (batch) {
      if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode()) {
        bcelWorld.setModel(AsmManager.getDefault().getHierarchy());
      }
      binarySourcesForTheNextCompile=state.getBinaryFilesToCompile();
      performCompilation(buildConfig.getFiles());
      if (handler.hasErrors()) {
        return false;
      }
    }
 else {
      List files=state.getFilesToCompile(true);
      binarySourcesForTheNextCompile=state.getBinaryFilesToCompile();
      boolean hereWeGoAgain=!(files.isEmpty() && binarySourcesForTheNextCompile.isEmpty());
      for (int i=0; (i < 5) && hereWeGoAgain; i++) {
        performCompilation(files);
        if (handler.hasErrors() || (progressListener != null && progressListener.isCancelledRequested())) {
          return false;
        }
        files=state.getFilesToCompile(false);
        binarySourcesForTheNextCompile=state.getBinaryFilesToCompile();
        hereWeGoAgain=!(files.isEmpty() && binarySourcesForTheNextCompile.isEmpty());
      }
      if (!files.isEmpty()) {
        return batchBuild(buildConfig,baseHandler);
      }
    }
    if (buildConfig.isEmacsSymMode()) {
      new org.aspectj.ajdt.internal.core.builder.EmacsStructureModelManager().externalizeModel();
    }
    state.successfulCompile(buildConfig);
    copyResourcesToDestination();
    if (buildConfig.isGenerateModelMode()) {
      AsmManager.getDefault().fireModelUpdated();
    }
  }
  finally {
    if (zos != null) {
      closeOutputStream();
    }
    ret=!handler.hasErrors();
    handler=null;
  }
  return ret;
}",0.901076579321552
9492,"public ICompilerAdapter getAdapter(org.eclipse.jdt.internal.compiler.Compiler forCompiler){
  AjProblemReporter pr=new AjProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),forCompiler.options,getProblemFactory());
  forCompiler.problemReporter=pr;
  AjLookupEnvironment le=new AjLookupEnvironment(forCompiler,forCompiler.options,pr,environment);
  EclipseFactory factory=new EclipseFactory(le);
  le.factory=factory;
  pr.factory=factory;
  le.factory.buildManager=this;
  forCompiler.lookupEnvironment=le;
  forCompiler.parser=new Parser(pr,forCompiler.options.parseLiteralExpressionsAsConstants);
  return new AjCompilerAdapter(forCompiler,batchCompile,bcelWorld,bcelWeaver,factory,getInterimResultRequestor(),progressListener,this,state.binarySourceFiles,state.resultsFromFile.values(),buildConfig.isNoWeave());
}","public ICompilerAdapter getAdapter(org.eclipse.jdt.internal.compiler.Compiler forCompiler){
  AjProblemReporter pr=new AjProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),forCompiler.options,getProblemFactory());
  forCompiler.problemReporter=pr;
  AjLookupEnvironment le=new AjLookupEnvironment(forCompiler,forCompiler.options,pr,environment);
  EclipseFactory factory=new EclipseFactory(le);
  le.factory=factory;
  pr.factory=factory;
  le.factory.buildManager=this;
  forCompiler.lookupEnvironment=le;
  forCompiler.parser=new Parser(pr,forCompiler.options.parseLiteralExpressionsAsConstants);
  return new AjCompilerAdapter(forCompiler,batchCompile,bcelWorld,bcelWeaver,factory,getInterimResultRequestor(),progressListener,this,this,state.binarySourceFiles,state.resultsFromFile.values(),buildConfig.isNoWeave());
}",0.9970149253731344
9493,"/** 
 * init only on initial batch compile? no file-specific options 
 */
private void initBcelWorld(IMessageHandler handler) throws IOException {
  bcelWorld=new BcelWorld(buildConfig.getClasspath(),handler,null);
  bcelWorld.setXnoInline(buildConfig.isXnoInline());
  bcelWorld.setXlazyTjp(buildConfig.isXlazyTjp());
  bcelWeaver=new BcelWeaver(bcelWorld);
  state.binarySourceFiles=new HashMap();
  for (Iterator i=buildConfig.getAspectpath().iterator(); i.hasNext(); ) {
    File f=(File)i.next();
    bcelWeaver.addLibraryJarFile(f);
  }
  if (buildConfig.getLintMode().equals(AjBuildConfig.AJLINT_DEFAULT)) {
    bcelWorld.getLint().loadDefaultProperties();
  }
 else {
    bcelWorld.getLint().setAll(buildConfig.getLintMode());
  }
  if (buildConfig.getLintSpecFile() != null) {
    bcelWorld.getLint().setFromProperties(buildConfig.getLintSpecFile());
  }
  for (Iterator i=buildConfig.getInJars().iterator(); i.hasNext(); ) {
    File inJar=(File)i.next();
    List unwovenClasses=bcelWeaver.addJarFile(inJar,buildConfig.getOutputDir(),false);
    state.binarySourceFiles.put(inJar.getPath(),unwovenClasses);
  }
  for (Iterator i=buildConfig.getInpath().iterator(); i.hasNext(); ) {
    File inPathElement=(File)i.next();
    List unwovenClasses=bcelWeaver.addJarFile(inPathElement,buildConfig.getOutputDir(),true);
    state.binarySourceFiles.put(inPathElement.getPath(),unwovenClasses);
  }
  bcelWeaver.setReweavableMode(buildConfig.isXreweavable(),buildConfig.getXreweavableCompressClasses());
  bcelWorld.resolve(""String_Node_Str"");
}","/** 
 * init only on initial batch compile? no file-specific options 
 */
private void initBcelWorld(IMessageHandler handler) throws IOException {
  bcelWorld=new BcelWorld(buildConfig.getClasspath(),handler,null);
  bcelWorld.setXnoInline(buildConfig.isXnoInline());
  bcelWorld.setXlazyTjp(buildConfig.isXlazyTjp());
  bcelWeaver=new BcelWeaver(bcelWorld);
  state.binarySourceFiles=new HashMap();
  for (Iterator i=buildConfig.getAspectpath().iterator(); i.hasNext(); ) {
    File f=(File)i.next();
    bcelWeaver.addLibraryJarFile(f);
  }
  if (buildConfig.getLintMode().equals(AjBuildConfig.AJLINT_DEFAULT)) {
    bcelWorld.getLint().loadDefaultProperties();
  }
 else {
    bcelWorld.getLint().setAll(buildConfig.getLintMode());
  }
  if (buildConfig.getLintSpecFile() != null) {
    bcelWorld.getLint().setFromProperties(buildConfig.getLintSpecFile());
  }
  for (Iterator i=buildConfig.getInJars().iterator(); i.hasNext(); ) {
    File inJar=(File)i.next();
    List unwovenClasses=bcelWeaver.addJarFile(inJar,buildConfig.getOutputDir(),false);
    state.binarySourceFiles.put(inJar.getPath(),unwovenClasses);
  }
  for (Iterator i=buildConfig.getInpath().iterator(); i.hasNext(); ) {
    File inPathElement=(File)i.next();
    if (!inPathElement.isDirectory()) {
      List unwovenClasses=bcelWeaver.addJarFile(inPathElement,buildConfig.getOutputDir(),true);
      state.binarySourceFiles.put(inPathElement.getPath(),unwovenClasses);
    }
 else {
      File[] binSrcs=FileUtil.listFiles(inPathElement,binarySourceFilter);
      for (int j=0; j < binSrcs.length; j++) {
        UnwovenClassFile ucf=bcelWeaver.addClassFile(binSrcs[j],inPathElement,buildConfig.getOutputDir());
        List ucfl=new ArrayList();
        ucfl.add(ucf);
        state.binarySourceFiles.put(binSrcs[j].getPath(),ucfl);
      }
    }
  }
  bcelWeaver.setReweavableMode(buildConfig.isXreweavable(),buildConfig.getXreweavableCompressClasses());
  bcelWorld.resolve(""String_Node_Str"");
}",0.8798636750923033
9494,"public List getFilesToCompile(boolean firstPass){
  List sourceFiles=new ArrayList();
  if (firstPass) {
    Collection modifiedFiles=getModifiedFiles();
    sourceFiles.addAll(modifiedFiles);
    sourceFiles.addAll(addedFiles);
    deleteClassFiles();
    addAffectedSourceFiles(sourceFiles);
  }
 else {
    addAffectedSourceFiles(sourceFiles);
  }
  return sourceFiles;
}","public List getFilesToCompile(boolean firstPass){
  List thisTime=new ArrayList();
  if (firstPass) {
    compiledSourceFiles=new ArrayList();
    Collection modifiedFiles=getModifiedFiles();
    thisTime.addAll(modifiedFiles);
    thisTime.addAll(addedFiles);
    deleteClassFiles();
    addAffectedSourceFiles(thisTime,thisTime);
  }
 else {
    addAffectedSourceFiles(thisTime,compiledSourceFiles);
  }
  compiledSourceFiles=thisTime;
  return thisTime;
}",0.7644230769230769
9495,"protected void addAffectedSourceFiles(List sourceFiles){
  if (qualifiedStrings.isEmpty() && simpleStrings.isEmpty())   return;
  char[][][] qualifiedNames=ReferenceCollection.internQualifiedNames(makeStringSet(qualifiedStrings));
  if (qualifiedNames.length < qualifiedStrings.size())   qualifiedNames=null;
  char[][] simpleNames=ReferenceCollection.internSimpleNames(makeStringSet(simpleStrings));
  if (simpleNames.length < simpleStrings.size())   simpleNames=null;
  for (Iterator i=references.entrySet().iterator(); i.hasNext(); ) {
    Map.Entry entry=(Map.Entry)i.next();
    ReferenceCollection refs=(ReferenceCollection)entry.getValue();
    if (refs != null && refs.includes(qualifiedNames,simpleNames)) {
      File file=(File)entry.getKey();
      if (file.exists()) {
        if (!sourceFiles.contains(file)) {
          sourceFiles.add(file);
        }
      }
    }
  }
  qualifiedStrings.clear();
  simpleStrings.clear();
}","protected void addAffectedSourceFiles(List addTo,List lastTimeSources){
  if (qualifiedStrings.isEmpty() && simpleStrings.isEmpty())   return;
  char[][][] qualifiedNames=ReferenceCollection.internQualifiedNames(makeStringSet(qualifiedStrings));
  if (qualifiedNames.length < qualifiedStrings.size())   qualifiedNames=null;
  char[][] simpleNames=ReferenceCollection.internSimpleNames(makeStringSet(simpleStrings));
  if (simpleNames.length < simpleStrings.size())   simpleNames=null;
  for (Iterator i=references.entrySet().iterator(); i.hasNext(); ) {
    Map.Entry entry=(Map.Entry)i.next();
    ReferenceCollection refs=(ReferenceCollection)entry.getValue();
    if (refs != null && refs.includes(qualifiedNames,simpleNames)) {
      File file=(File)entry.getKey();
      if (file.exists()) {
        if (!lastTimeSources.contains(file)) {
          addTo.add(file);
        }
      }
    }
  }
  qualifiedStrings.clear();
  simpleStrings.clear();
}",0.9624933967247756
9496,"private void addParent(SourceTypeBinding sourceType,ResolvedTypeX parent){
  ReferenceBinding parentBinding=(ReferenceBinding)factory.makeTypeBinding(parent);
  if (parentBinding.isClass()) {
    sourceType.superclass=parentBinding;
  }
 else {
    ReferenceBinding[] oldI=sourceType.superInterfaces;
    ReferenceBinding[] newI;
    if (oldI == null) {
      newI=new ReferenceBinding[1];
      newI[0]=parentBinding;
    }
 else {
      int n=oldI.length;
      newI=new ReferenceBinding[n + 1];
      System.arraycopy(oldI,0,newI,0,n);
      newI[n]=parentBinding;
    }
    sourceType.superInterfaces=newI;
  }
}","private void addParent(SourceTypeBinding sourceType,ResolvedTypeX parent){
  ReferenceBinding parentBinding=(ReferenceBinding)factory.makeTypeBinding(parent);
  if (parentBinding.isClass()) {
    sourceType.superclass=parentBinding;
  }
 else {
    ReferenceBinding[] oldI=sourceType.superInterfaces;
    ReferenceBinding[] newI;
    if (oldI == null) {
      newI=new ReferenceBinding[1];
      newI[0]=parentBinding;
    }
 else {
      int n=oldI.length;
      newI=new ReferenceBinding[n + 1];
      System.arraycopy(oldI,0,newI,0,n);
      newI[n]=parentBinding;
    }
    sourceType.superInterfaces=newI;
    warnOnAddedInterface(factory.fromEclipse(sourceType),parent);
  }
}",0.9491525423728814
9497,"public static void makeTestJars() throws IOException {
  List args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"" + File.pathSeparator + System.getProperty(""String_Node_Str""));
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"" + File.pathSeparator + System.getProperty(""String_Node_Str""));
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"" + File.pathSeparator + System.getProperty(""String_Node_Str""));
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
}","public static void makeTestJars() throws IOException {
  List args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"" + File.pathSeparator + System.getProperty(""String_Node_Str""));
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"" + File.pathSeparator + System.getProperty(""String_Node_Str""));
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"" + File.pathSeparator + System.getProperty(""String_Node_Str""));
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"" + File.pathSeparator + System.getProperty(""String_Node_Str""));
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
}",0.8531222515391381
9498,"String toString(StringMaker sm){
  StringBuffer buf=new StringBuffer(""String_Node_Str"");
  buf.append(sm.makeModifiersString(getModifiers()));
  if (sm.includeArgs)   buf.append(sm.makeTypeName(getReturnType()));
  if (sm.includeArgs)   buf.append(""String_Node_Str"");
  buf.append(sm.makePrimaryTypeName(getDeclaringType()));
  buf.append(""String_Node_Str"");
  buf.append(getName());
  sm.addSignature(buf,getParameterTypes());
  sm.addThrows(buf,getExceptionTypes());
  return buf.toString();
}","String toString(StringMaker sm){
  StringBuffer buf=new StringBuffer(""String_Node_Str"");
  buf.append(sm.makeModifiersString(getModifiers()));
  if (sm.includeArgs)   buf.append(sm.makeTypeName(getReturnType()));
  if (sm.includeArgs)   buf.append(""String_Node_Str"");
  buf.append(sm.makePrimaryTypeName(getDeclaringType(),getDeclaringTypeName()));
  buf.append(""String_Node_Str"");
  buf.append(getName());
  sm.addSignature(buf,getParameterTypes());
  sm.addThrows(buf,getExceptionTypes());
  return buf.toString();
}",0.9772951628825272
9499,"String toString(StringMaker sm){
  StringBuffer buf=new StringBuffer();
  buf.append(sm.makeModifiersString(getModifiers()));
  buf.append(sm.makePrimaryTypeName(getDeclaringType()));
  sm.addSignature(buf,getParameterTypes());
  sm.addThrows(buf,getExceptionTypes());
  return buf.toString();
}","String toString(StringMaker sm){
  StringBuffer buf=new StringBuffer();
  buf.append(sm.makeModifiersString(getModifiers()));
  buf.append(sm.makePrimaryTypeName(getDeclaringType(),getDeclaringTypeName()));
  sm.addSignature(buf,getParameterTypes());
  sm.addThrows(buf,getExceptionTypes());
  return buf.toString();
}",0.9624796084828712
9500,"String toString(StringMaker sm){
  StringBuffer buf=new StringBuffer();
  buf.append(sm.makeModifiersString(getModifiers()));
  if (sm.includeArgs)   buf.append(sm.makeTypeName(getFieldType()));
  if (sm.includeArgs)   buf.append(""String_Node_Str"");
  buf.append(sm.makePrimaryTypeName(getDeclaringType()));
  buf.append(""String_Node_Str"");
  buf.append(getName());
  return buf.toString();
}","String toString(StringMaker sm){
  StringBuffer buf=new StringBuffer();
  buf.append(sm.makeModifiersString(getModifiers()));
  if (sm.includeArgs)   buf.append(sm.makeTypeName(getFieldType()));
  if (sm.includeArgs)   buf.append(""String_Node_Str"");
  buf.append(sm.makePrimaryTypeName(getDeclaringType(),getDeclaringTypeName()));
  buf.append(""String_Node_Str"");
  buf.append(getName());
  return buf.toString();
}",0.9714993804213136
9501,"String toString(StringMaker sm){
  StringBuffer buf=new StringBuffer();
  buf.append(sm.makeModifiersString(getModifiers()));
  buf.append(sm.makePrimaryTypeName(getDeclaringType()));
  buf.append(""String_Node_Str"");
  buf.append(getName());
  return buf.toString();
}","String toString(StringMaker sm){
  StringBuffer buf=new StringBuffer();
  buf.append(sm.makeModifiersString(getModifiers()));
  buf.append(sm.makePrimaryTypeName(getDeclaringType(),getDeclaringTypeName()));
  buf.append(""String_Node_Str"");
  buf.append(getName());
  return buf.toString();
}",0.958855098389982
9502,"String toString(StringMaker sm){
  StringBuffer buf=new StringBuffer();
  buf.append(sm.makeModifiersString(getModifiers()));
  if (sm.includeArgs)   buf.append(sm.makeTypeName(getReturnType()));
  if (sm.includeArgs)   buf.append(""String_Node_Str"");
  buf.append(sm.makePrimaryTypeName(getDeclaringType()));
  buf.append(""String_Node_Str"");
  buf.append(getName());
  sm.addSignature(buf,getParameterTypes());
  sm.addThrows(buf,getExceptionTypes());
  return buf.toString();
}","String toString(StringMaker sm){
  StringBuffer buf=new StringBuffer();
  buf.append(sm.makeModifiersString(getModifiers()));
  if (sm.includeArgs)   buf.append(sm.makeTypeName(getReturnType()));
  if (sm.includeArgs)   buf.append(""String_Node_Str"");
  buf.append(sm.makePrimaryTypeName(getDeclaringType(),getDeclaringTypeName()));
  buf.append(""String_Node_Str"");
  buf.append(getName());
  sm.addSignature(buf,getParameterTypes());
  sm.addThrows(buf,getExceptionTypes());
  return buf.toString();
}",0.9765066394279878
9503,"public String makeTypeName(Class type){
  return makeTypeName(type,shortTypeNames);
}","public String makeTypeName(Class type){
  return makeTypeName(type,type.getName(),shortTypeNames);
}",0.918918918918919
9504,"public String makePrimaryTypeName(Class type){
  return makeTypeName(type,shortPrimaryTypeNames);
}","public String makePrimaryTypeName(Class type,String typeName){
  return makeTypeName(type,typeName,shortPrimaryTypeNames);
}",0.8878923766816144
9505,"public static TestSuite suite(){
  TestSuite suite=new TestSuite(RuntimeModuleTests.class.getName());
  suite.addTestSuite(RuntimeModuleTests.class);
  return suite;
}","public static TestSuite suite(){
  TestSuite suite=new TestSuite(RuntimeModuleTests.class.getName());
  suite.addTestSuite(RuntimeModuleTests.class);
  suite.addTestSuite(SignatureTest.class);
  return suite;
}",0.8753315649867374
9506,"/** 
 * Returns false if a batch build is needed.
 */
boolean prepareForNextBuild(AjBuildConfig newBuildConfig){
  currentBuildTime=System.currentTimeMillis();
  addedClassFiles=new ArrayList();
  if (lastSuccessfulBuildTime == -1 || buildConfig == null) {
    return false;
  }
  if (newBuildConfig.getOutputJar() != null)   return false;
  simpleStrings=new ArrayList();
  qualifiedStrings=new ArrayList();
  Set oldFiles=new HashSet(buildConfig.getFiles());
  Set newFiles=new HashSet(newBuildConfig.getFiles());
  addedFiles=new HashSet(newFiles);
  addedFiles.removeAll(oldFiles);
  deletedFiles=new HashSet(oldFiles);
  deletedFiles.removeAll(newFiles);
  this.newBuildConfig=newBuildConfig;
  return true;
}","/** 
 * Returns false if a batch build is needed.
 */
boolean prepareForNextBuild(AjBuildConfig newBuildConfig){
  currentBuildTime=System.currentTimeMillis();
  addedClassFiles=new ArrayList();
  if (lastSuccessfulBuildTime == -1 || buildConfig == null) {
    return false;
  }
  if (newBuildConfig.getOutputJar() != null)   return false;
  if (pathChange(buildConfig,newBuildConfig))   return false;
  simpleStrings=new ArrayList();
  qualifiedStrings=new ArrayList();
  Set oldFiles=new HashSet(buildConfig.getFiles());
  Set newFiles=new HashSet(newBuildConfig.getFiles());
  addedFiles=new HashSet(newFiles);
  addedFiles.removeAll(oldFiles);
  deletedFiles=new HashSet(oldFiles);
  deletedFiles.removeAll(newFiles);
  this.newBuildConfig=newBuildConfig;
  return true;
}",0.9583892617449664
9507,"/** 
 * Setup result evaluation and command line, run, and evaluate result. <li>setup an AjcMessageHandler using the expected messages from  {@link Spec#getMessages()}.<li> <li>heed any globals interpreted into a TestSetup by reading  {@link Spec@getOptions()}.  For a list of supported globals, see  {@link setupArgs(ArrayList, IMessageHandler}.</li> <li>construct a command line, using as classpath   {@link Sandbox.classpathToString()}<li> <li>construct a compiler using   {@link Spec#compiler}or any overriding value set in TestSetup.<li> <li>Just before running, set the compiler in the sandbox using   {@link Sandbox.setCompiler(ICommand)}.<li> <li>After running, report AjcMessageHandler results to the status parameter. If the AjcMessageHandler reports a failure, then send info messages for the Spec, TestSetup, and command line.<li>
 * @see org.aspectj.testing.run.IRun#run(IRunStatus)
 */
public boolean run(IRunStatus status){
  if (null == spec.testSetup) {
    MessageUtil.abort(status,""String_Node_Str"");
    return false;
  }
 else   if (!spec.testSetup.result) {
    MessageUtil.abort(status,spec.testSetup.failureReason);
    return false;
  }
  AjcMessageHandler handler=new AjcMessageHandler(spec.getMessages());
  handler.init();
  boolean handlerResult=false;
  boolean result=false;
  boolean commandResult=false;
  ArrayList argList=new ArrayList();
  final Spec.TestSetup setupResult=spec.testSetup;
  try {
    argList.add(""String_Node_Str"");
    String outputDirPath=sandbox.classesDir.getAbsolutePath();
    try {
      outputDirPath=sandbox.classesDir.getCanonicalPath();
    }
 catch (    IOException e) {
      MessageUtil.abort(status,""String_Node_Str"" + sandbox.classesDir,e);
    }
    argList.add(outputDirPath);
    String path=sandbox.classpathToString(this);
    if (!LangUtil.isEmpty(path)) {
      argList.add(""String_Node_Str"");
      argList.add(path);
    }
    path=sandbox.getBootclasspath(this);
    if (!LangUtil.isEmpty(path)) {
      argList.add(""String_Node_Str"");
      argList.add(path);
    }
    path=sandbox.aspectpathToString(this);
    if (!LangUtil.isEmpty(path)) {
      argList.add(""String_Node_Str"");
      argList.add(path);
    }
    if (0 < injars.size()) {
      argList.add(""String_Node_Str"");
      argList.add(FileUtil.flatten((String[])injars.toArray(new String[0]),null));
    }
    if (0 < inpaths.size()) {
      argList.add(""String_Node_Str"");
      argList.add(FileUtil.flatten((String[])inpaths.toArray(new String[0]),null));
    }
    argList.addAll(setupResult.commandOptions);
    argList.addAll(arguments);
    if (null != setupResult.seek) {
      String slopPrefix=Spec.SEEK_MESSAGE_PREFIX + ""String_Node_Str"";
      PrintStream slop=MessageUtil.handlerPrintStream(status,IMessage.INFO,System.err,slopPrefix);
      List found=FileUtil.lineSeek(setupResult.seek,arguments,false,slop);
      if (!LangUtil.isEmpty(found)) {
        for (Iterator iter=found.iterator(); iter.hasNext(); ) {
          MessageUtil.info(status,Spec.SEEK_MESSAGE_PREFIX + iter.next());
        }
      }
    }
    ICommand compiler=spec.reuseCompiler ? sandbox.getCommand(this) : ReflectionFactory.makeCommand(setupResult.compilerName,status);
    DirChanges dirChanges=null;
    if (null == compiler) {
      MessageUtil.fail(status,""String_Node_Str"" + setupResult.compilerName);
      return false;
    }
 else {
      if (setupResult.compilerName != Spec.DEFAULT_COMPILER) {
        MessageUtil.info(status,""String_Node_Str"" + setupResult.compilerName);
      }
      if (status.aborted()) {
        MessageUtil.debug(status,""String_Node_Str"" + compiler);
      }
 else {
        if (!LangUtil.isEmpty(spec.dirChanges)) {
          LangUtil.throwIaxIfFalse(1 == spec.dirChanges.size(),""String_Node_Str"");
          dirChanges=new DirChanges((DirChanges.Spec)spec.dirChanges.get(0));
          if (!dirChanges.start(status,sandbox.classesDir)) {
            return false;
          }
        }
        MessageUtil.info(status,compiler + ""String_Node_Str"" + argList+ ""String_Node_Str"");
        sandbox.setCommand(compiler,this);
        String[] args=(String[])argList.toArray(RA_String);
        commandResult=compiler.runCommand(args,handler);
      }
    }
    handlerResult=handler.passed();
    if (!handlerResult) {
      return false;
    }
 else {
      result=(commandResult == handler.expectingCommandTrue());
      if (!result) {
        String m=commandResult ? ""String_Node_Str"" : ""String_Node_Str"";
        MessageUtil.fail(status,m);
      }
 else       if (null != dirChanges) {
        result=dirChanges.end(status,sandbox.testBaseDir);
      }
    }
    return result;
  }
  finally {
    if (!handlerResult) {
      MessageUtil.info(handler,spec.toLongString());
      MessageUtil.info(handler,""String_Node_Str"" + argList);
      if (null != setupResult) {
        MessageUtil.info(handler,""String_Node_Str"" + setupResult);
      }
    }
    handler.report(status);
  }
}","/** 
 * Setup result evaluation and command line, run, and evaluate result. <li>setup an AjcMessageHandler using the expected messages from  {@link Spec#getMessages()}.<li> <li>heed any globals interpreted into a TestSetup by reading  {@link Spec@getOptions()}.  For a list of supported globals, see  {@link setupArgs(ArrayList, IMessageHandler}.</li> <li>construct a command line, using as classpath   {@link Sandbox.classpathToString()}<li> <li>construct a compiler using   {@link Spec#compiler}or any overriding value set in TestSetup.<li> <li>Just before running, set the compiler in the sandbox using   {@link Sandbox.setCompiler(ICommand)}.<li> <li>After running, report AjcMessageHandler results to the status parameter. If the AjcMessageHandler reports a failure, then send info messages for the Spec, TestSetup, and command line.<li>
 * @see org.aspectj.testing.run.IRun#run(IRunStatus)
 */
public boolean run(IRunStatus status){
  if (null == spec.testSetup) {
    MessageUtil.abort(status,""String_Node_Str"");
    return false;
  }
 else   if (!spec.testSetup.result) {
    MessageUtil.abort(status,spec.testSetup.failureReason);
    return false;
  }
  AjcMessageHandler handler=new AjcMessageHandler(spec.getMessages());
  handler.init();
  boolean handlerResult=false;
  boolean result=false;
  boolean commandResult=false;
  ArrayList argList=new ArrayList();
  final Spec.TestSetup setupResult=spec.testSetup;
  try {
    if (spec.outjar == null) {
      argList.add(""String_Node_Str"");
      String outputDirPath=sandbox.classesDir.getAbsolutePath();
      try {
        outputDirPath=sandbox.classesDir.getCanonicalPath();
      }
 catch (      IOException e) {
        MessageUtil.abort(status,""String_Node_Str"" + sandbox.classesDir,e);
      }
      argList.add(outputDirPath);
    }
    String path=sandbox.classpathToString(this);
    if (!LangUtil.isEmpty(path)) {
      argList.add(""String_Node_Str"");
      argList.add(path);
    }
    path=sandbox.getBootclasspath(this);
    if (!LangUtil.isEmpty(path)) {
      argList.add(""String_Node_Str"");
      argList.add(path);
    }
    path=sandbox.aspectpathToString(this);
    if (!LangUtil.isEmpty(path)) {
      argList.add(""String_Node_Str"");
      argList.add(path);
    }
    if (0 < injars.size()) {
      argList.add(""String_Node_Str"");
      argList.add(FileUtil.flatten((String[])injars.toArray(new String[0]),null));
    }
    if (0 < inpaths.size()) {
      argList.add(""String_Node_Str"");
      argList.add(FileUtil.flatten((String[])inpaths.toArray(new String[0]),null));
    }
    argList.addAll(setupResult.commandOptions);
    argList.addAll(arguments);
    if (null != setupResult.seek) {
      String slopPrefix=Spec.SEEK_MESSAGE_PREFIX + ""String_Node_Str"";
      PrintStream slop=MessageUtil.handlerPrintStream(status,IMessage.INFO,System.err,slopPrefix);
      List found=FileUtil.lineSeek(setupResult.seek,arguments,false,slop);
      if (!LangUtil.isEmpty(found)) {
        for (Iterator iter=found.iterator(); iter.hasNext(); ) {
          MessageUtil.info(status,Spec.SEEK_MESSAGE_PREFIX + iter.next());
        }
      }
    }
    ICommand compiler=spec.reuseCompiler ? sandbox.getCommand(this) : ReflectionFactory.makeCommand(setupResult.compilerName,status);
    DirChanges dirChanges=null;
    if (null == compiler) {
      MessageUtil.fail(status,""String_Node_Str"" + setupResult.compilerName);
      return false;
    }
 else {
      if (setupResult.compilerName != Spec.DEFAULT_COMPILER) {
        MessageUtil.info(status,""String_Node_Str"" + setupResult.compilerName);
      }
      if (status.aborted()) {
        MessageUtil.debug(status,""String_Node_Str"" + compiler);
      }
 else {
        if (!LangUtil.isEmpty(spec.dirChanges)) {
          LangUtil.throwIaxIfFalse(1 == spec.dirChanges.size(),""String_Node_Str"");
          dirChanges=new DirChanges((DirChanges.Spec)spec.dirChanges.get(0));
          if (!dirChanges.start(status,sandbox.classesDir)) {
            return false;
          }
        }
        MessageUtil.info(status,compiler + ""String_Node_Str"" + argList+ ""String_Node_Str"");
        sandbox.setCommand(compiler,this);
        String[] args=(String[])argList.toArray(RA_String);
        commandResult=compiler.runCommand(args,handler);
      }
    }
    handlerResult=handler.passed();
    if (!handlerResult) {
      return false;
    }
 else {
      result=(commandResult == handler.expectingCommandTrue());
      if (!result) {
        String m=commandResult ? ""String_Node_Str"" : ""String_Node_Str"";
        MessageUtil.fail(status,m);
      }
 else       if (null != dirChanges) {
        result=dirChanges.end(status,sandbox.testBaseDir);
      }
    }
    return result;
  }
  finally {
    if (!handlerResult) {
      MessageUtil.info(handler,spec.toLongString());
      MessageUtil.info(handler,""String_Node_Str"" + argList);
      if (null != setupResult) {
        MessageUtil.info(handler,""String_Node_Str"" + setupResult);
      }
    }
    handler.report(status);
  }
}",0.994475138121547
9508,"/** 
 * This checks that the spec is reasonable and does setup: <ul> <li>calculate and set sandbox testBaseSrcDir as {Sandbox.testBaseDir}/ {Spec.testSrcDirOffset}/<li> <li>get the list of source File to compile as {Sandbox.testBaseSrcDir} / {Spec.getPaths..}</li> <li>get the list of extraClasspath entries to add to default classpath as {Sandbox.testBaseSrcDir} / {Spec.classpath..}</li> <li>get the list of aspectpath entries to use as the aspectpath as {Sandbox. testBaseSrcDir} / {Spec.aspectpath..}</li> </ul> All sources must be readable at this time,  unless spec.badInput is true (for invalid-input tests). If staging, the source files and source roots are copied to a separate staging directory so they can be modified for incremental tests.   Note that (as of this writing) the compiler only handles source roots for incremental tests.
 * @param classesDir the File
 * @see org.aspectj.testing.harness.bridge.AjcTest.IAjcRun#setup(File,File)
 * @throws AbortException containing IOException or IllegalArgumentExceptionif the staging operations fail
 */
public boolean setupAjcRun(Sandbox sandbox,Validator validator){
  if (!validator.nullcheck(spec.getOptionsArray(),""String_Node_Str"") || !validator.nullcheck(sandbox,""String_Node_Str"") || !validator.nullcheck(spec.compiler,""String_Node_Str"")|| !validator.canRead(Globals.F_aspectjrt_jar,""String_Node_Str"")|| !validator.canRead(Globals.F_testingclient_jar,""String_Node_Str"")) {
    return false;
  }
  this.sandbox=sandbox;
  String rdir=spec.testSrcDirOffset;
  File testBaseSrcDir;
  if ((null == rdir) || (0 == rdir.length())) {
    testBaseSrcDir=sandbox.testBaseDir;
  }
 else {
    testBaseSrcDir=new File(sandbox.testBaseDir,rdir);
    if (!validator.canReadDir(testBaseSrcDir,""String_Node_Str"")) {
      return false;
    }
  }
  sandbox.setTestBaseSrcDir(testBaseSrcDir,this);
  final String[] inpathPaths;
  final String[] injarPaths;
  final String[] srcPaths;
{
    final String[] paths=spec.getPathsArray();
    srcPaths=LangUtil.endsWith(paths,CompilerRun.SOURCE_SUFFIXES,true);
    injarPaths=LangUtil.endsWith(paths,CompilerRun.JAR_SUFFIXES,true);
    inpathPaths=LangUtil.selectDirectories(paths,testBaseSrcDir);
    if (!spec.badInput) {
      int found=inpathPaths.length + injarPaths.length + srcPaths.length;
      if (paths.length != found) {
        validator.fail(""String_Node_Str"" + found + ""String_Node_Str""+ paths.length+ ""String_Node_Str"");
      }
    }
  }
  if (!spec.badInput) {
    if (!validator.canRead(testBaseSrcDir,srcPaths,""String_Node_Str"") || !validator.canRead(testBaseSrcDir,injarPaths,""String_Node_Str"") || !validator.canRead(testBaseSrcDir,inpathPaths,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.argfiles,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.classpath,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.aspectpath,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.sourceroots,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.extdirs,""String_Node_Str"")) {
      return false;
    }
  }
  int numSources=srcPaths.length + injarPaths.length + inpathPaths.length+ spec.argfiles.length+ spec.sourceroots.length;
  if (!spec.badInput && (numSources < 1)) {
    validator.fail(""String_Node_Str"");
    return false;
  }
  final File[] argFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.argfiles);
  final File[] injarFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,injarPaths);
  final File[] inpathFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,inpathPaths);
  final File[] aspectFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.aspectpath);
  final File[] extdirFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.extdirs);
  final File[] classFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.classpath);
  final File[] xlintFiles=(null == spec.xlintfile ? new File[0] : FileUtil.getBaseDirFiles(testBaseSrcDir,new String[]{spec.xlintfile}));
  if (!spec.badInput) {
    if (!validator.canRead(argFiles,""String_Node_Str"") || !validator.canRead(injarFiles,""String_Node_Str"") || !validator.canRead(inpathFiles,""String_Node_Str"")|| !validator.canRead(aspectFiles,""String_Node_Str"")|| !validator.canRead(classFiles,""String_Node_Str"")|| !validator.canRead(xlintFiles,""String_Node_Str"")) {
      return false;
    }
  }
  final File[] srcFiles;
  File[] sourcerootFiles=new File[0];
  if (!spec.isStaging()) {
    srcFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,srcPaths,CompilerRun.SOURCE_SUFFIXES);
    if (!LangUtil.isEmpty(spec.sourceroots)) {
      sourcerootFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.sourceroots,null);
    }
  }
 else {
    if (spec.badInput) {
      validator.info(""String_Node_Str"");
    }
    try {
      srcFiles=FileUtil.copyFiles(testBaseSrcDir,srcPaths,sandbox.stagingDir);
      if (!LangUtil.isEmpty(spec.sourceroots)) {
        sourcerootFiles=FileUtil.copyFiles(testBaseSrcDir,spec.sourceroots,sandbox.stagingDir);
        FileFilter pickIncFiles=new FileFilter(){
          public boolean accept(          File file){
            if (file.isDirectory()) {
              return true;
            }
            String path=file.getPath();
            if (!FileUtil.hasSourceSuffix(path)) {
              return false;
            }
            int first=path.indexOf(""String_Node_Str"");
            int last=path.lastIndexOf(""String_Node_Str"");
            return (first != last);
          }
        }
;
        for (int i=0; i < sourcerootFiles.length; i++) {
          FileUtil.deleteContents(sourcerootFiles[i],pickIncFiles,false);
        }
        if (0 < sourcerootFiles.length) {
          FileUtil.sleepPastFinalModifiedTime(sourcerootFiles);
        }
      }
      File[] files=FileUtil.getBaseDirFiles(sandbox.stagingDir,srcPaths);
      if (0 < files.length) {
        FileUtil.sleepPastFinalModifiedTime(files);
      }
    }
 catch (    IllegalArgumentException e) {
      validator.fail(""String_Node_Str"",e);
      return false;
    }
catch (    IOException e) {
      validator.fail(""String_Node_Str"",e);
      return false;
    }
  }
  if (!spec.badInput && !validator.canRead(srcFiles,""String_Node_Str"")) {
    return false;
  }
  arguments.clear();
  if (!LangUtil.isEmpty(xlintFiles)) {
    arguments.add(""String_Node_Str"");
    String sr=FileUtil.flatten(xlintFiles,null);
    arguments.add(sr);
  }
  if (spec.outjar != null) {
    arguments.add(""String_Node_Str"");
    arguments.add(spec.outjar);
  }
  if (!LangUtil.isEmpty(extdirFiles)) {
    arguments.add(""String_Node_Str"");
    String sr=FileUtil.flatten(extdirFiles,null);
    arguments.add(sr);
  }
  if (!LangUtil.isEmpty(sourcerootFiles)) {
    arguments.add(""String_Node_Str"");
    String sr=FileUtil.flatten(sourcerootFiles,null);
    arguments.add(sr);
  }
  if (!LangUtil.isEmpty(srcFiles)) {
    arguments.addAll(Arrays.asList(FileUtil.getPaths(srcFiles)));
  }
  injars.clear();
  if (!LangUtil.isEmpty(injarFiles)) {
    injars.addAll(Arrays.asList(FileUtil.getPaths(injarFiles)));
  }
  inpaths.clear();
  if (!LangUtil.isEmpty(inpathFiles)) {
    inpaths.addAll(Arrays.asList(FileUtil.getPaths(inpathFiles)));
  }
  if (!LangUtil.isEmpty(argFiles)) {
    String[] ra=FileUtil.getPaths(argFiles);
    for (int j=0; j < ra.length; j++) {
      arguments.add(""String_Node_Str"" + ra[j]);
    }
    if (!spec.badInput && spec.isStaging) {
      validator.fail(""String_Node_Str"");
    }
  }
  final boolean checkReadable=!spec.badInput;
  int size=spec.includeClassesDir ? 3 : 2;
  File[] cp=new File[size + classFiles.length];
  System.arraycopy(classFiles,0,cp,0,classFiles.length);
  int index=classFiles.length;
  if (spec.includeClassesDir) {
    cp[index++]=sandbox.classesDir;
  }
  cp[index++]=Globals.F_aspectjrt_jar;
  cp[index++]=Globals.F_testingclient_jar;
  sandbox.setClasspath(cp,checkReadable,this);
  if (0 < aspectFiles.length) {
    sandbox.setAspectpath(aspectFiles,checkReadable,this);
  }
  AbstractRunSpec.Fork fork=spec.getFork();
  String bootclasspath=fork.getJavaBootclasspath();
  if (fork.fork() && (!LangUtil.isEmpty(bootclasspath))) {
    sandbox.setBootclasspath(bootclasspath,this);
  }
  return true;
}","/** 
 * This checks that the spec is reasonable and does setup: <ul> <li>calculate and set sandbox testBaseSrcDir as {Sandbox.testBaseDir}/ {Spec.testSrcDirOffset}/<li> <li>get the list of source File to compile as {Sandbox.testBaseSrcDir} / {Spec.getPaths..}</li> <li>get the list of extraClasspath entries to add to default classpath as {Sandbox.testBaseSrcDir} / {Spec.classpath..}</li> <li>get the list of aspectpath entries to use as the aspectpath as {Sandbox. testBaseSrcDir} / {Spec.aspectpath..}</li> </ul> All sources must be readable at this time,  unless spec.badInput is true (for invalid-input tests). If staging, the source files and source roots are copied to a separate staging directory so they can be modified for incremental tests.   Note that (as of this writing) the compiler only handles source roots for incremental tests.
 * @param classesDir the File
 * @see org.aspectj.testing.harness.bridge.AjcTest.IAjcRun#setup(File,File)
 * @throws AbortException containing IOException or IllegalArgumentExceptionif the staging operations fail
 */
public boolean setupAjcRun(Sandbox sandbox,Validator validator){
  if (!validator.nullcheck(spec.getOptionsArray(),""String_Node_Str"") || !validator.nullcheck(sandbox,""String_Node_Str"") || !validator.nullcheck(spec.compiler,""String_Node_Str"")|| !validator.canRead(Globals.F_aspectjrt_jar,""String_Node_Str"")|| !validator.canRead(Globals.F_testingclient_jar,""String_Node_Str"")) {
    return false;
  }
  this.sandbox=sandbox;
  String rdir=spec.testSrcDirOffset;
  File testBaseSrcDir;
  if ((null == rdir) || (0 == rdir.length())) {
    testBaseSrcDir=sandbox.testBaseDir;
  }
 else {
    testBaseSrcDir=new File(sandbox.testBaseDir,rdir);
    if (!validator.canReadDir(testBaseSrcDir,""String_Node_Str"")) {
      return false;
    }
  }
  sandbox.setTestBaseSrcDir(testBaseSrcDir,this);
  final String[] inpathPaths;
  final String[] injarPaths;
  final String[] srcPaths;
{
    final String[] paths=spec.getPathsArray();
    srcPaths=LangUtil.endsWith(paths,CompilerRun.SOURCE_SUFFIXES,true);
    injarPaths=LangUtil.endsWith(paths,CompilerRun.JAR_SUFFIXES,true);
    inpathPaths=LangUtil.selectDirectories(paths,testBaseSrcDir);
    if (!spec.badInput) {
      int found=inpathPaths.length + injarPaths.length + srcPaths.length;
      if (paths.length != found) {
        validator.fail(""String_Node_Str"" + found + ""String_Node_Str""+ paths.length+ ""String_Node_Str"");
      }
    }
  }
  if (!spec.badInput) {
    if (!validator.canRead(testBaseSrcDir,srcPaths,""String_Node_Str"") || !validator.canRead(testBaseSrcDir,injarPaths,""String_Node_Str"") || !validator.canRead(testBaseSrcDir,inpathPaths,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.argfiles,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.classpath,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.aspectpath,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.sourceroots,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.extdirs,""String_Node_Str"")) {
      return false;
    }
  }
  int numSources=srcPaths.length + injarPaths.length + inpathPaths.length+ spec.argfiles.length+ spec.sourceroots.length;
  if (!spec.badInput && (numSources < 1)) {
    validator.fail(""String_Node_Str"");
    return false;
  }
  final File[] argFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.argfiles);
  final File[] injarFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,injarPaths);
  final File[] inpathFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,inpathPaths);
  final File[] aspectFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.aspectpath);
  final File[] extdirFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.extdirs);
  final File[] classFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.classpath);
  final File[] xlintFiles=(null == spec.xlintfile ? new File[0] : FileUtil.getBaseDirFiles(testBaseSrcDir,new String[]{spec.xlintfile}));
  if (!spec.badInput) {
    if (!validator.canRead(argFiles,""String_Node_Str"") || !validator.canRead(injarFiles,""String_Node_Str"") || !validator.canRead(inpathFiles,""String_Node_Str"")|| !validator.canRead(aspectFiles,""String_Node_Str"")|| !validator.canRead(classFiles,""String_Node_Str"")|| !validator.canRead(xlintFiles,""String_Node_Str"")) {
      return false;
    }
  }
  final File[] srcFiles;
  File[] sourcerootFiles=new File[0];
  if (!spec.isStaging()) {
    srcFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,srcPaths,CompilerRun.SOURCE_SUFFIXES);
    if (!LangUtil.isEmpty(spec.sourceroots)) {
      sourcerootFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.sourceroots,null);
    }
  }
 else {
    if (spec.badInput) {
      validator.info(""String_Node_Str"");
    }
    try {
      srcFiles=FileUtil.copyFiles(testBaseSrcDir,srcPaths,sandbox.stagingDir);
      if (!LangUtil.isEmpty(spec.sourceroots)) {
        sourcerootFiles=FileUtil.copyFiles(testBaseSrcDir,spec.sourceroots,sandbox.stagingDir);
        FileFilter pickIncFiles=new FileFilter(){
          public boolean accept(          File file){
            if (file.isDirectory()) {
              return true;
            }
            String path=file.getPath();
            if (!FileUtil.hasSourceSuffix(path)) {
              return false;
            }
            int first=path.indexOf(""String_Node_Str"");
            int last=path.lastIndexOf(""String_Node_Str"");
            return (first != last);
          }
        }
;
        for (int i=0; i < sourcerootFiles.length; i++) {
          FileUtil.deleteContents(sourcerootFiles[i],pickIncFiles,false);
        }
        if (0 < sourcerootFiles.length) {
          FileUtil.sleepPastFinalModifiedTime(sourcerootFiles);
        }
      }
      File[] files=FileUtil.getBaseDirFiles(sandbox.stagingDir,srcPaths);
      if (0 < files.length) {
        FileUtil.sleepPastFinalModifiedTime(files);
      }
    }
 catch (    IllegalArgumentException e) {
      validator.fail(""String_Node_Str"",e);
      return false;
    }
catch (    IOException e) {
      validator.fail(""String_Node_Str"",e);
      return false;
    }
  }
  if (!spec.badInput && !validator.canRead(srcFiles,""String_Node_Str"")) {
    return false;
  }
  arguments.clear();
  if (!LangUtil.isEmpty(xlintFiles)) {
    arguments.add(""String_Node_Str"");
    String sr=FileUtil.flatten(xlintFiles,null);
    arguments.add(sr);
  }
  if (spec.outjar != null) {
    arguments.add(""String_Node_Str"");
    arguments.add(new File(sandbox.classesDir,spec.outjar).getPath());
  }
  if (!LangUtil.isEmpty(extdirFiles)) {
    arguments.add(""String_Node_Str"");
    String sr=FileUtil.flatten(extdirFiles,null);
    arguments.add(sr);
  }
  if (!LangUtil.isEmpty(sourcerootFiles)) {
    arguments.add(""String_Node_Str"");
    String sr=FileUtil.flatten(sourcerootFiles,null);
    arguments.add(sr);
  }
  if (!LangUtil.isEmpty(srcFiles)) {
    arguments.addAll(Arrays.asList(FileUtil.getPaths(srcFiles)));
  }
  injars.clear();
  if (!LangUtil.isEmpty(injarFiles)) {
    injars.addAll(Arrays.asList(FileUtil.getPaths(injarFiles)));
  }
  inpaths.clear();
  if (!LangUtil.isEmpty(inpathFiles)) {
    inpaths.addAll(Arrays.asList(FileUtil.getPaths(inpathFiles)));
  }
  if (!LangUtil.isEmpty(argFiles)) {
    String[] ra=FileUtil.getPaths(argFiles);
    for (int j=0; j < ra.length; j++) {
      arguments.add(""String_Node_Str"" + ra[j]);
    }
    if (!spec.badInput && spec.isStaging) {
      validator.fail(""String_Node_Str"");
    }
  }
  final boolean checkReadable=!spec.badInput;
  int size=spec.includeClassesDir ? 3 : 2;
  File[] cp=new File[size + classFiles.length];
  System.arraycopy(classFiles,0,cp,0,classFiles.length);
  int index=classFiles.length;
  if (spec.includeClassesDir) {
    cp[index++]=sandbox.classesDir;
  }
  cp[index++]=Globals.F_aspectjrt_jar;
  cp[index++]=Globals.F_testingclient_jar;
  sandbox.setClasspath(cp,checkReadable,this);
  if (0 < aspectFiles.length) {
    sandbox.setAspectpath(aspectFiles,checkReadable,this);
  }
  AbstractRunSpec.Fork fork=spec.getFork();
  String bootclasspath=fork.getJavaBootclasspath();
  if (fork.fork() && (!LangUtil.isEmpty(bootclasspath))) {
    sandbox.setBootclasspath(bootclasspath,this);
  }
  return true;
}",0.9976083890353836
9509,"/** 
 * This checks that the spec is reasonable and does setup: <ul> <li>calculate and set sandbox testBaseSrcDir as {Sandbox.testBaseDir}/ {Spec.testSrcDirOffset}/<li> <li>get the list of source File to compile as {Sandbox.testBaseSrcDir} / {Spec.getPaths..}</li> <li>get the list of extraClasspath entries to add to default classpath as {Sandbox.testBaseSrcDir} / {Spec.classpath..}</li> <li>get the list of aspectpath entries to use as the aspectpath as {Sandbox. testBaseSrcDir} / {Spec.aspectpath..}</li> </ul> All sources must be readable at this time,  unless spec.badInput is true (for invalid-input tests). If staging, the source files and source roots are copied to a separate staging directory so they can be modified for incremental tests.   Note that (as of this writing) the compiler only handles source roots for incremental tests.
 * @param classesDir the File
 * @see org.aspectj.testing.harness.bridge.AjcTest.IAjcRun#setup(File,File)
 * @throws AbortException containing IOException or IllegalArgumentExceptionif the staging operations fail
 */
public boolean setupAjcRun(Sandbox sandbox,Validator validator){
  if (!validator.nullcheck(spec.getOptionsArray(),""String_Node_Str"") || !validator.nullcheck(sandbox,""String_Node_Str"") || !validator.nullcheck(spec.compiler,""String_Node_Str"")|| !validator.canRead(Globals.F_aspectjrt_jar,""String_Node_Str"")|| !validator.canRead(Globals.F_testingclient_jar,""String_Node_Str"")) {
    return false;
  }
  this.sandbox=sandbox;
  String rdir=spec.testSrcDirOffset;
  File testBaseSrcDir;
  if ((null == rdir) || (0 == rdir.length())) {
    testBaseSrcDir=sandbox.testBaseDir;
  }
 else {
    testBaseSrcDir=new File(sandbox.testBaseDir,rdir);
    if (!validator.canReadDir(testBaseSrcDir,""String_Node_Str"")) {
      return false;
    }
  }
  sandbox.setTestBaseSrcDir(testBaseSrcDir,this);
  final String[] inpathPaths;
  final String[] injarPaths;
  final String[] srcPaths;
{
    final String[] paths=spec.getPathsArray();
    srcPaths=LangUtil.endsWith(paths,CompilerRun.SOURCE_SUFFIXES,true);
    injarPaths=LangUtil.endsWith(paths,CompilerRun.JAR_SUFFIXES,true);
    inpathPaths=LangUtil.selectDirectories(paths,testBaseSrcDir);
    if (!spec.badInput) {
      int found=inpathPaths.length + injarPaths.length + srcPaths.length;
      if (paths.length != found) {
        validator.fail(""String_Node_Str"" + found + ""String_Node_Str""+ paths.length+ ""String_Node_Str"");
      }
    }
  }
  if (!spec.badInput) {
    if (!validator.canRead(testBaseSrcDir,srcPaths,""String_Node_Str"") || !validator.canRead(testBaseSrcDir,injarPaths,""String_Node_Str"") || !validator.canRead(testBaseSrcDir,inpathPaths,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.argfiles,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.classpath,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.aspectpath,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.sourceroots,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.extdirs,""String_Node_Str"")) {
      return false;
    }
  }
  int numSources=srcPaths.length + injarPaths.length + inpathPaths.length+ spec.argfiles.length+ spec.sourceroots.length;
  if (!spec.badInput && (numSources < 1)) {
    validator.fail(""String_Node_Str"");
    return false;
  }
  final File[] argFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.argfiles);
  final File[] injarFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,injarPaths);
  final File[] inpathFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,inpathPaths);
  final File[] aspectFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.aspectpath);
  final File[] extdirFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.extdirs);
  final File[] classFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.classpath);
  final File[] xlintFiles=(null == spec.xlintfile ? new File[0] : FileUtil.getBaseDirFiles(testBaseSrcDir,new String[]{spec.xlintfile}));
  if (!spec.badInput) {
    if (!validator.canRead(argFiles,""String_Node_Str"") || !validator.canRead(injarFiles,""String_Node_Str"") || !validator.canRead(inpathFiles,""String_Node_Str"")|| !validator.canRead(aspectFiles,""String_Node_Str"")|| !validator.canRead(classFiles,""String_Node_Str"")|| !validator.canRead(xlintFiles,""String_Node_Str"")) {
      return false;
    }
  }
  final File[] srcFiles;
  File[] sourcerootFiles=new File[0];
  if (!spec.isStaging()) {
    srcFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,srcPaths,CompilerRun.SOURCE_SUFFIXES);
    if (!LangUtil.isEmpty(spec.sourceroots)) {
      sourcerootFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.sourceroots,null);
    }
  }
 else {
    if (spec.badInput) {
      validator.info(""String_Node_Str"");
    }
    try {
      srcFiles=FileUtil.copyFiles(testBaseSrcDir,srcPaths,sandbox.stagingDir);
      if (!LangUtil.isEmpty(spec.sourceroots)) {
        sourcerootFiles=FileUtil.copyFiles(testBaseSrcDir,spec.sourceroots,sandbox.stagingDir);
        FileFilter pickIncFiles=new FileFilter(){
          public boolean accept(          File file){
            if (file.isDirectory()) {
              return true;
            }
            String path=file.getPath();
            if (!FileUtil.hasSourceSuffix(path)) {
              return false;
            }
            int first=path.indexOf(""String_Node_Str"");
            int last=path.lastIndexOf(""String_Node_Str"");
            return (first != last);
          }
        }
;
        for (int i=0; i < sourcerootFiles.length; i++) {
          FileUtil.deleteContents(sourcerootFiles[i],pickIncFiles,false);
        }
        if (0 < sourcerootFiles.length) {
          FileUtil.sleepPastFinalModifiedTime(sourcerootFiles);
        }
      }
      File[] files=FileUtil.getBaseDirFiles(sandbox.stagingDir,srcPaths);
      if (0 < files.length) {
        FileUtil.sleepPastFinalModifiedTime(files);
      }
    }
 catch (    IllegalArgumentException e) {
      validator.fail(""String_Node_Str"",e);
      return false;
    }
catch (    IOException e) {
      validator.fail(""String_Node_Str"",e);
      return false;
    }
  }
  if (!spec.badInput && !validator.canRead(srcFiles,""String_Node_Str"")) {
    return false;
  }
  arguments.clear();
  if (!LangUtil.isEmpty(xlintFiles)) {
    arguments.add(""String_Node_Str"");
    String sr=FileUtil.flatten(xlintFiles,null);
    arguments.add(sr);
  }
  if (!LangUtil.isEmpty(extdirFiles)) {
    arguments.add(""String_Node_Str"");
    String sr=FileUtil.flatten(extdirFiles,null);
    arguments.add(sr);
  }
  if (!LangUtil.isEmpty(sourcerootFiles)) {
    arguments.add(""String_Node_Str"");
    String sr=FileUtil.flatten(sourcerootFiles,null);
    arguments.add(sr);
  }
  if (!LangUtil.isEmpty(srcFiles)) {
    arguments.addAll(Arrays.asList(FileUtil.getPaths(srcFiles)));
  }
  injars.clear();
  if (!LangUtil.isEmpty(injarFiles)) {
    injars.addAll(Arrays.asList(FileUtil.getPaths(injarFiles)));
  }
  inpaths.clear();
  if (!LangUtil.isEmpty(inpathFiles)) {
    inpaths.addAll(Arrays.asList(FileUtil.getPaths(inpathFiles)));
  }
  if (!LangUtil.isEmpty(argFiles)) {
    String[] ra=FileUtil.getPaths(argFiles);
    for (int j=0; j < ra.length; j++) {
      arguments.add(""String_Node_Str"" + ra[j]);
    }
    if (!spec.badInput && spec.isStaging) {
      validator.fail(""String_Node_Str"");
    }
  }
  final boolean checkReadable=!spec.badInput;
  int size=spec.includeClassesDir ? 3 : 2;
  File[] cp=new File[size + classFiles.length];
  System.arraycopy(classFiles,0,cp,0,classFiles.length);
  int index=classFiles.length;
  if (spec.includeClassesDir) {
    cp[index++]=sandbox.classesDir;
  }
  cp[index++]=Globals.F_aspectjrt_jar;
  cp[index++]=Globals.F_testingclient_jar;
  sandbox.setClasspath(cp,checkReadable,this);
  if (0 < aspectFiles.length) {
    sandbox.setAspectpath(aspectFiles,checkReadable,this);
  }
  AbstractRunSpec.Fork fork=spec.getFork();
  String bootclasspath=fork.getJavaBootclasspath();
  if (fork.fork() && (!LangUtil.isEmpty(bootclasspath))) {
    sandbox.setBootclasspath(bootclasspath,this);
  }
  return true;
}","/** 
 * This checks that the spec is reasonable and does setup: <ul> <li>calculate and set sandbox testBaseSrcDir as {Sandbox.testBaseDir}/ {Spec.testSrcDirOffset}/<li> <li>get the list of source File to compile as {Sandbox.testBaseSrcDir} / {Spec.getPaths..}</li> <li>get the list of extraClasspath entries to add to default classpath as {Sandbox.testBaseSrcDir} / {Spec.classpath..}</li> <li>get the list of aspectpath entries to use as the aspectpath as {Sandbox. testBaseSrcDir} / {Spec.aspectpath..}</li> </ul> All sources must be readable at this time,  unless spec.badInput is true (for invalid-input tests). If staging, the source files and source roots are copied to a separate staging directory so they can be modified for incremental tests.   Note that (as of this writing) the compiler only handles source roots for incremental tests.
 * @param classesDir the File
 * @see org.aspectj.testing.harness.bridge.AjcTest.IAjcRun#setup(File,File)
 * @throws AbortException containing IOException or IllegalArgumentExceptionif the staging operations fail
 */
public boolean setupAjcRun(Sandbox sandbox,Validator validator){
  if (!validator.nullcheck(spec.getOptionsArray(),""String_Node_Str"") || !validator.nullcheck(sandbox,""String_Node_Str"") || !validator.nullcheck(spec.compiler,""String_Node_Str"")|| !validator.canRead(Globals.F_aspectjrt_jar,""String_Node_Str"")|| !validator.canRead(Globals.F_testingclient_jar,""String_Node_Str"")) {
    return false;
  }
  this.sandbox=sandbox;
  String rdir=spec.testSrcDirOffset;
  File testBaseSrcDir;
  if ((null == rdir) || (0 == rdir.length())) {
    testBaseSrcDir=sandbox.testBaseDir;
  }
 else {
    testBaseSrcDir=new File(sandbox.testBaseDir,rdir);
    if (!validator.canReadDir(testBaseSrcDir,""String_Node_Str"")) {
      return false;
    }
  }
  sandbox.setTestBaseSrcDir(testBaseSrcDir,this);
  final String[] inpathPaths;
  final String[] injarPaths;
  final String[] srcPaths;
{
    final String[] paths=spec.getPathsArray();
    srcPaths=LangUtil.endsWith(paths,CompilerRun.SOURCE_SUFFIXES,true);
    injarPaths=LangUtil.endsWith(paths,CompilerRun.JAR_SUFFIXES,true);
    inpathPaths=LangUtil.selectDirectories(paths,testBaseSrcDir);
    if (!spec.badInput) {
      int found=inpathPaths.length + injarPaths.length + srcPaths.length;
      if (paths.length != found) {
        validator.fail(""String_Node_Str"" + found + ""String_Node_Str""+ paths.length+ ""String_Node_Str"");
      }
    }
  }
  if (!spec.badInput) {
    if (!validator.canRead(testBaseSrcDir,srcPaths,""String_Node_Str"") || !validator.canRead(testBaseSrcDir,injarPaths,""String_Node_Str"") || !validator.canRead(testBaseSrcDir,inpathPaths,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.argfiles,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.classpath,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.aspectpath,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.sourceroots,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.extdirs,""String_Node_Str"")) {
      return false;
    }
  }
  int numSources=srcPaths.length + injarPaths.length + inpathPaths.length+ spec.argfiles.length+ spec.sourceroots.length;
  if (!spec.badInput && (numSources < 1)) {
    validator.fail(""String_Node_Str"");
    return false;
  }
  final File[] argFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.argfiles);
  final File[] injarFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,injarPaths);
  final File[] inpathFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,inpathPaths);
  final File[] aspectFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.aspectpath);
  final File[] extdirFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.extdirs);
  final File[] classFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.classpath);
  final File[] xlintFiles=(null == spec.xlintfile ? new File[0] : FileUtil.getBaseDirFiles(testBaseSrcDir,new String[]{spec.xlintfile}));
  if (!spec.badInput) {
    if (!validator.canRead(argFiles,""String_Node_Str"") || !validator.canRead(injarFiles,""String_Node_Str"") || !validator.canRead(inpathFiles,""String_Node_Str"")|| !validator.canRead(aspectFiles,""String_Node_Str"")|| !validator.canRead(classFiles,""String_Node_Str"")|| !validator.canRead(xlintFiles,""String_Node_Str"")) {
      return false;
    }
  }
  final File[] srcFiles;
  File[] sourcerootFiles=new File[0];
  if (!spec.isStaging()) {
    srcFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,srcPaths,CompilerRun.SOURCE_SUFFIXES);
    if (!LangUtil.isEmpty(spec.sourceroots)) {
      sourcerootFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.sourceroots,null);
    }
  }
 else {
    if (spec.badInput) {
      validator.info(""String_Node_Str"");
    }
    try {
      srcFiles=FileUtil.copyFiles(testBaseSrcDir,srcPaths,sandbox.stagingDir);
      if (!LangUtil.isEmpty(spec.sourceroots)) {
        sourcerootFiles=FileUtil.copyFiles(testBaseSrcDir,spec.sourceroots,sandbox.stagingDir);
        FileFilter pickIncFiles=new FileFilter(){
          public boolean accept(          File file){
            if (file.isDirectory()) {
              return true;
            }
            String path=file.getPath();
            if (!FileUtil.hasSourceSuffix(path)) {
              return false;
            }
            int first=path.indexOf(""String_Node_Str"");
            int last=path.lastIndexOf(""String_Node_Str"");
            return (first != last);
          }
        }
;
        for (int i=0; i < sourcerootFiles.length; i++) {
          FileUtil.deleteContents(sourcerootFiles[i],pickIncFiles,false);
        }
        if (0 < sourcerootFiles.length) {
          FileUtil.sleepPastFinalModifiedTime(sourcerootFiles);
        }
      }
      File[] files=FileUtil.getBaseDirFiles(sandbox.stagingDir,srcPaths);
      if (0 < files.length) {
        FileUtil.sleepPastFinalModifiedTime(files);
      }
    }
 catch (    IllegalArgumentException e) {
      validator.fail(""String_Node_Str"",e);
      return false;
    }
catch (    IOException e) {
      validator.fail(""String_Node_Str"",e);
      return false;
    }
  }
  if (!spec.badInput && !validator.canRead(srcFiles,""String_Node_Str"")) {
    return false;
  }
  arguments.clear();
  if (!LangUtil.isEmpty(xlintFiles)) {
    arguments.add(""String_Node_Str"");
    String sr=FileUtil.flatten(xlintFiles,null);
    arguments.add(sr);
  }
  if (spec.outjar != null) {
    arguments.add(""String_Node_Str"");
    arguments.add(spec.outjar);
  }
  if (!LangUtil.isEmpty(extdirFiles)) {
    arguments.add(""String_Node_Str"");
    String sr=FileUtil.flatten(extdirFiles,null);
    arguments.add(sr);
  }
  if (!LangUtil.isEmpty(sourcerootFiles)) {
    arguments.add(""String_Node_Str"");
    String sr=FileUtil.flatten(sourcerootFiles,null);
    arguments.add(sr);
  }
  if (!LangUtil.isEmpty(srcFiles)) {
    arguments.addAll(Arrays.asList(FileUtil.getPaths(srcFiles)));
  }
  injars.clear();
  if (!LangUtil.isEmpty(injarFiles)) {
    injars.addAll(Arrays.asList(FileUtil.getPaths(injarFiles)));
  }
  inpaths.clear();
  if (!LangUtil.isEmpty(inpathFiles)) {
    inpaths.addAll(Arrays.asList(FileUtil.getPaths(inpathFiles)));
  }
  if (!LangUtil.isEmpty(argFiles)) {
    String[] ra=FileUtil.getPaths(argFiles);
    for (int j=0; j < ra.length; j++) {
      arguments.add(""String_Node_Str"" + ra[j]);
    }
    if (!spec.badInput && spec.isStaging) {
      validator.fail(""String_Node_Str"");
    }
  }
  final boolean checkReadable=!spec.badInput;
  int size=spec.includeClassesDir ? 3 : 2;
  File[] cp=new File[size + classFiles.length];
  System.arraycopy(classFiles,0,cp,0,classFiles.length);
  int index=classFiles.length;
  if (spec.includeClassesDir) {
    cp[index++]=sandbox.classesDir;
  }
  cp[index++]=Globals.F_aspectjrt_jar;
  cp[index++]=Globals.F_testingclient_jar;
  sandbox.setClasspath(cp,checkReadable,this);
  if (0 < aspectFiles.length) {
    sandbox.setAspectpath(aspectFiles,checkReadable,this);
  }
  AbstractRunSpec.Fork fork=spec.getFork();
  String bootclasspath=fork.getJavaBootclasspath();
  if (fork.fork() && (!LangUtil.isEmpty(bootclasspath))) {
    sandbox.setBootclasspath(bootclasspath,this);
  }
  return true;
}",0.993628209093721
9510,"protected void initClone(Spec spec) throws CloneNotSupportedException {
  super.initClone(spec);
  spec.argfiles=copy(argfiles);
  spec.aspectpath=copy(aspectpath);
  spec.classpath=copy(classpath);
  spec.compiler=compiler;
  spec.includeClassesDir=includeClassesDir;
  spec.reuseCompiler=reuseCompiler;
  spec.permitAnyCompiler=permitAnyCompiler;
  spec.sourceroots=copy(sourceroots);
  spec.extdirs=copy(extdirs);
  spec.testSetup=null;
  if (null != testSetup) {
    spec.testSetup=(TestSetup)testSetup.clone();
  }
  spec.testSrcDirOffset=testSrcDirOffset;
}","protected void initClone(Spec spec) throws CloneNotSupportedException {
  super.initClone(spec);
  spec.argfiles=copy(argfiles);
  spec.aspectpath=copy(aspectpath);
  spec.classpath=copy(classpath);
  spec.compiler=compiler;
  spec.includeClassesDir=includeClassesDir;
  spec.reuseCompiler=reuseCompiler;
  spec.permitAnyCompiler=permitAnyCompiler;
  spec.sourceroots=copy(sourceroots);
  spec.extdirs=copy(extdirs);
  spec.outjar=outjar;
  spec.testSetup=null;
  if (null != testSetup) {
    spec.testSetup=(TestSetup)testSetup.clone();
  }
  spec.testSrcDirOffset=testSrcDirOffset;
}",0.980836236933798
9511,"/** 
 * This is only to do compile-time checking for the APIs impliedly used in setupDigester(..). The property setter checks are redundant with tests based on expectedProperties().
 */
private static void setupDigesterCompileTimeCheck(){
  if (true) {
    throw new Error(""String_Node_Str"");
  }
  AjcTest.Suite.Spec suite=new AjcTest.Suite.Spec();
  AjcTest.Spec test=new AjcTest.Spec();
  Sandbox sandbox=null;
  Validator validator=null;
  CompilerRun.Spec crunSpec=new CompilerRun.Spec();
  crunSpec.addMessage((IMessage)null);
  crunSpec.addWrapFile((AbstractRunSpec.WrapFile)null);
  crunSpec.setOptions((String)null);
  crunSpec.setPaths((String)null);
  crunSpec.setIncludeClassesDir(false);
  crunSpec.setReuseCompiler(false);
  crunSpec.setXlintfile((String)null);
  IncCompilerRun.Spec icrunSpec=new IncCompilerRun.Spec();
  icrunSpec.addMessage((IMessage)null);
  icrunSpec.setTag((String)null);
  icrunSpec.setFresh(false);
  JavaRun.Spec jrunspec=new JavaRun.Spec();
  jrunspec.addMessage((IMessage)null);
  jrunspec.setClassName((String)null);
  jrunspec.addMessage((IMessage)null);
  jrunspec.setSkipTester(true);
  jrunspec.setErrStreamIsError(true);
  jrunspec.setOutStreamIsError(true);
  DirChanges.Spec dcspec=new DirChanges.Spec();
  dcspec.setAdded((String)null);
  dcspec.setRemoved((String)null);
  dcspec.setUpdated((String)null);
  dcspec.setDefaultSuffix((String)null);
  dcspec.setDirToken((String)null);
  SoftMessage m=new SoftMessage();
  m.setSourceLocation((ISourceLocation)null);
  m.setText((String)null);
  m.setKindAsString((String)null);
  m.setDetails((String)null);
  SoftSourceLocation sl=new SoftSourceLocation();
  sl.setFile((String)null);
  sl.setLine((String)null);
  sl.setColumn((String)null);
  sl.setEndLine((String)null);
}","/** 
 * This is only to do compile-time checking for the APIs impliedly used in setupDigester(..). The property setter checks are redundant with tests based on expectedProperties().
 */
private static void setupDigesterCompileTimeCheck(){
  if (true) {
    throw new Error(""String_Node_Str"");
  }
  AjcTest.Suite.Spec suite=new AjcTest.Suite.Spec();
  AjcTest.Spec test=new AjcTest.Spec();
  Sandbox sandbox=null;
  Validator validator=null;
  CompilerRun.Spec crunSpec=new CompilerRun.Spec();
  crunSpec.addMessage((IMessage)null);
  crunSpec.addWrapFile((AbstractRunSpec.WrapFile)null);
  crunSpec.setOptions((String)null);
  crunSpec.setPaths((String)null);
  crunSpec.setIncludeClassesDir(false);
  crunSpec.setReuseCompiler(false);
  crunSpec.setXlintfile((String)null);
  crunSpec.setOutjar((String)null);
  IncCompilerRun.Spec icrunSpec=new IncCompilerRun.Spec();
  icrunSpec.addMessage((IMessage)null);
  icrunSpec.setTag((String)null);
  icrunSpec.setFresh(false);
  JavaRun.Spec jrunspec=new JavaRun.Spec();
  jrunspec.addMessage((IMessage)null);
  jrunspec.setClassName((String)null);
  jrunspec.addMessage((IMessage)null);
  jrunspec.setSkipTester(true);
  jrunspec.setErrStreamIsError(true);
  jrunspec.setOutStreamIsError(true);
  DirChanges.Spec dcspec=new DirChanges.Spec();
  dcspec.setAdded((String)null);
  dcspec.setRemoved((String)null);
  dcspec.setUpdated((String)null);
  dcspec.setDefaultSuffix((String)null);
  dcspec.setDirToken((String)null);
  SoftMessage m=new SoftMessage();
  m.setSourceLocation((ISourceLocation)null);
  m.setText((String)null);
  m.setKindAsString((String)null);
  m.setDetails((String)null);
  SoftSourceLocation sl=new SoftSourceLocation();
  sl.setFile((String)null);
  sl.setLine((String)null);
  sl.setColumn((String)null);
  sl.setEndLine((String)null);
}",0.9899665551839464
9512,"/** 
 * Get expected bean properties for introspection tests.  This should return an expected property for every attribute in DOCTYPE, using any mapped-to names from setupDigester.
 */
static BProps[] expectedProperties(){
  return new BProps[]{new BProps(AjcTest.Suite.Spec.class,new String[]{""String_Node_Str""}),new BProps(AjcTest.Spec.class,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}),new BProps(CompilerRun.Spec.class,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}),new BProps(IncCompilerRun.Spec.class,new String[]{""String_Node_Str""}),new BProps(JavaRun.Spec.class,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}),new BProps(DirChanges.Spec.class,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}),new BProps(AbstractRunSpec.WrapFile.class,new String[]{""String_Node_Str""}),new BProps(SoftMessage.class,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""})};
}","/** 
 * Get expected bean properties for introspection tests.  This should return an expected property for every attribute in DOCTYPE, using any mapped-to names from setupDigester.
 */
static BProps[] expectedProperties(){
  return new BProps[]{new BProps(AjcTest.Suite.Spec.class,new String[]{""String_Node_Str""}),new BProps(AjcTest.Spec.class,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}),new BProps(CompilerRun.Spec.class,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}),new BProps(IncCompilerRun.Spec.class,new String[]{""String_Node_Str""}),new BProps(JavaRun.Spec.class,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}),new BProps(DirChanges.Spec.class,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}),new BProps(AbstractRunSpec.WrapFile.class,new String[]{""String_Node_Str""}),new BProps(SoftMessage.class,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""})};
}",0.9929577464788732
9513,"private void copyResourcesToDestination() throws IOException {
  for (Iterator i=buildConfig.getInJars().iterator(); i.hasNext(); ) {
    File inJar=(File)i.next();
    copyResourcesFromJarFile(inJar);
  }
  for (Iterator i=buildConfig.getInpath().iterator(); i.hasNext(); ) {
    File inPathElement=(File)i.next();
    if (inPathElement.isDirectory()) {
      copyResourcesFromDirectory(inPathElement);
    }
 else {
      copyResourcesFromJarFile(inPathElement);
    }
  }
  if (buildConfig.getSourcePathResources() != null) {
    for (Iterator i=buildConfig.getSourcePathResources().keySet().iterator(); i.hasNext(); ) {
      String resource=(String)i.next();
      copyResourcesFromFile((File)buildConfig.getSourcePathResources().get(resource),resource);
    }
  }
}","private void copyResourcesToDestination() throws IOException {
  for (Iterator i=buildConfig.getInJars().iterator(); i.hasNext(); ) {
    File inJar=(File)i.next();
    copyResourcesFromJarFile(inJar);
  }
  for (Iterator i=buildConfig.getInpath().iterator(); i.hasNext(); ) {
    File inPathElement=(File)i.next();
    if (inPathElement.isDirectory()) {
      copyResourcesFromDirectory(inPathElement);
    }
 else {
      copyResourcesFromJarFile(inPathElement);
    }
  }
  if (buildConfig.getSourcePathResources() != null) {
    for (Iterator i=buildConfig.getSourcePathResources().keySet().iterator(); i.hasNext(); ) {
      String resource=(String)i.next();
      File from=(File)buildConfig.getSourcePathResources().get(resource);
      copyResourcesFromFile(from,resource,from);
    }
  }
}",0.911408540471638
9514,"private void copyResourcesFromJarFile(File jarFile) throws IOException {
  ZipInputStream inStream=null;
  try {
    inStream=new ZipInputStream(new FileInputStream(jarFile));
    while (true) {
      ZipEntry entry=inStream.getNextEntry();
      if (entry == null)       break;
      String filename=entry.getName();
      if (!entry.isDirectory() && acceptResource(filename)) {
        byte[] bytes=FileUtil.readAsByteArray(inStream);
        writeResource(filename,bytes);
      }
      inStream.closeEntry();
    }
  }
  finally {
    if (inStream != null)     inStream.close();
  }
}","private void copyResourcesFromJarFile(File jarFile) throws IOException {
  ZipInputStream inStream=null;
  try {
    inStream=new ZipInputStream(new FileInputStream(jarFile));
    while (true) {
      ZipEntry entry=inStream.getNextEntry();
      if (entry == null)       break;
      String filename=entry.getName();
      if (!entry.isDirectory() && acceptResource(filename)) {
        byte[] bytes=FileUtil.readAsByteArray(inStream);
        writeResource(filename,bytes,jarFile);
      }
      inStream.closeEntry();
    }
  }
  finally {
    if (inStream != null)     inStream.close();
  }
}",0.9932432432432432
9515,"private void writeResource(String filename,byte[] content) throws IOException {
  if (state.resources.contains(filename))   return;
  if (zos != null) {
    ZipEntry newEntry=new ZipEntry(filename);
    zos.putNextEntry(newEntry);
    zos.write(content);
    zos.closeEntry();
  }
 else {
    OutputStream fos=FileUtil.makeOutputStream(new File(buildConfig.getOutputDir(),filename));
    fos.write(content);
    fos.close();
  }
  state.resources.add(filename);
}","private void writeResource(String filename,byte[] content,File srcLocation) throws IOException {
  if (state.resources.contains(filename)) {
    IMessage msg=new Message(""String_Node_Str"" + filename + ""String_Node_Str"",IMessage.WARNING,null,new SourceLocation(srcLocation,0));
    handler.handleMessage(msg);
    return;
  }
  if (zos != null) {
    ZipEntry newEntry=new ZipEntry(filename);
    zos.putNextEntry(newEntry);
    zos.write(content);
    zos.closeEntry();
  }
 else {
    OutputStream fos=FileUtil.makeOutputStream(new File(buildConfig.getOutputDir(),filename));
    fos.write(content);
    fos.close();
  }
  state.resources.add(filename);
}",0.8114387846291331
9516,"private void copyResourcesFromFile(File f,String filename) throws IOException {
  if (!acceptResource(filename))   return;
  FileInputStream fis=null;
  try {
    fis=new FileInputStream(f);
    byte[] bytes=FileUtil.readAsByteArray(fis);
    writeResource(filename,bytes);
  }
  finally {
    if (fis != null)     fis.close();
  }
}","private void copyResourcesFromFile(File f,String filename,File src) throws IOException {
  if (!acceptResource(filename))   return;
  FileInputStream fis=null;
  try {
    fis=new FileInputStream(f);
    byte[] bytes=FileUtil.readAsByteArray(fis);
    writeResource(filename,bytes,src);
  }
  finally {
    if (fis != null)     fis.close();
  }
}",0.9808541973490428
9517,"private void copyResourcesFromDirectory(File dir) throws IOException {
  File[] files=FileUtil.listFiles(dir,new FileFilter(){
    public boolean accept(    File f){
      boolean accept=!(f.isDirectory() || f.getName().endsWith(""String_Node_Str""));
      return accept;
    }
  }
);
  for (int i=0; i < files.length; i++) {
    String filename=files[i].getAbsolutePath().substring(dir.getAbsolutePath().length() + 1);
    copyResourcesFromFile(files[i],filename);
  }
}","private void copyResourcesFromDirectory(File dir) throws IOException {
  if (!COPY_INPATH_DIR_RESOURCES)   return;
  File[] files=FileUtil.listFiles(dir,new FileFilter(){
    public boolean accept(    File f){
      boolean accept=!(f.isDirectory() || f.getName().endsWith(""String_Node_Str""));
      return accept;
    }
  }
);
  for (int i=0; i < files.length; i++) {
    String filename=files[i].getAbsolutePath().substring(dir.getAbsolutePath().length() + 1);
    copyResourcesFromFile(files[i],filename,dir);
  }
}",0.951417004048583
9518,"private void deleteResources(){
  List oldResources=new ArrayList();
  oldResources.addAll(resources);
  for (Iterator i=buildConfig.getInpath().iterator(); i.hasNext(); ) {
    File inPathElement=(File)i.next();
    if (inPathElement.isDirectory()) {
      deleteResourcesFromDirectory(inPathElement,oldResources);
    }
  }
  if (buildConfig.getSourcePathResources() != null) {
    for (Iterator i=buildConfig.getSourcePathResources().keySet().iterator(); i.hasNext(); ) {
      String resource=(String)i.next();
      maybeDeleteResource(resource,oldResources);
    }
  }
  for (Iterator iter=oldResources.iterator(); iter.hasNext(); ) {
    String victim=(String)iter.next();
    File f=new File(buildConfig.getOutputDir(),victim);
    if (f.exists()) {
      f.delete();
    }
    resources.remove(victim);
  }
}","private void deleteResources(){
  List oldResources=new ArrayList();
  oldResources.addAll(resources);
  for (Iterator i=buildConfig.getInpath().iterator(); i.hasNext(); ) {
    File inPathElement=(File)i.next();
    if (inPathElement.isDirectory() && AjBuildManager.COPY_INPATH_DIR_RESOURCES) {
      deleteResourcesFromDirectory(inPathElement,oldResources);
    }
  }
  if (buildConfig.getSourcePathResources() != null) {
    for (Iterator i=buildConfig.getSourcePathResources().keySet().iterator(); i.hasNext(); ) {
      String resource=(String)i.next();
      maybeDeleteResource(resource,oldResources);
    }
  }
  for (Iterator iter=oldResources.iterator(); iter.hasNext(); ) {
    String victim=(String)iter.next();
    File f=new File(buildConfig.getOutputDir(),victim);
    if (f.exists()) {
      f.delete();
    }
    resources.remove(victim);
  }
}",0.9737783075089392
9519,"private MethodBinding getAccessibleMethod(MethodBinding binding){
  if (!binding.isValidBinding())   return binding;
  makePublic(binding.declaringClass);
  if (isPublic(binding))   return binding;
  if (binding instanceof InterTypeMethodBinding)   return binding;
  if (binding.isPrivate() && binding.declaringClass != inAspect.binding) {
    binding.modifiers=AstUtil.makePackageVisible(binding.modifiers);
  }
  ResolvedMember m=EclipseFactory.makeResolvedMember(binding);
  if (inAspect.accessForInline.containsKey(m))   return (MethodBinding)inAspect.accessForInline.get(m);
  MethodBinding ret=world.makeMethodBinding(AjcMemberMaker.inlineAccessMethodForMethod(inAspect.typeX,m));
  inAspect.accessForInline.put(m,ret);
  return ret;
}","private MethodBinding getAccessibleMethod(MethodBinding binding,TypeBinding receiverType){
  if (!binding.isValidBinding())   return binding;
  makePublic(receiverType);
  if (isPublic(binding))   return binding;
  if (binding instanceof InterTypeMethodBinding)   return binding;
  if (binding.isPrivate() && binding.declaringClass != inAspect.binding) {
    binding.modifiers=AstUtil.makePackageVisible(binding.modifiers);
  }
  ResolvedMember m=EclipseFactory.makeResolvedMember(binding,receiverType);
  if (inAspect.accessForInline.containsKey(m))   return (MethodBinding)inAspect.accessForInline.get(m);
  MethodBinding ret=world.makeMethodBinding(AjcMemberMaker.inlineAccessMethodForMethod(inAspect.typeX,m));
  inAspect.accessForInline.put(m,ret);
  return ret;
}",0.952317880794702
9520,"private FieldBinding getAccessibleField(FieldBinding binding){
  if (!binding.isValidBinding())   return binding;
  makePublic(binding.declaringClass);
  if (isPublic(binding))   return binding;
  if (binding instanceof PrivilegedFieldBinding)   return binding;
  if (binding instanceof InterTypeFieldBinding)   return binding;
  if (binding.isPrivate() && binding.declaringClass != inAspect.binding) {
    binding.modifiers=AstUtil.makePackageVisible(binding.modifiers);
  }
  ResolvedMember m=EclipseFactory.makeResolvedMember(binding);
  if (inAspect.accessForInline.containsKey(m))   return (FieldBinding)inAspect.accessForInline.get(m);
  FieldBinding ret=new InlineAccessFieldBinding(inAspect,binding);
  inAspect.accessForInline.put(m,ret);
  return ret;
}","private FieldBinding getAccessibleField(FieldBinding binding,TypeBinding receiverType){
  if (!binding.isValidBinding())   return binding;
  makePublic(receiverType);
  if (isPublic(binding))   return binding;
  if (binding instanceof PrivilegedFieldBinding)   return binding;
  if (binding instanceof InterTypeFieldBinding)   return binding;
  if (binding.isPrivate() && binding.declaringClass != inAspect.binding) {
    binding.modifiers=AstUtil.makePackageVisible(binding.modifiers);
  }
  ResolvedMember m=EclipseFactory.makeResolvedMember(binding,receiverType);
  if (inAspect.accessForInline.containsKey(m))   return (FieldBinding)inAspect.accessForInline.get(m);
  FieldBinding ret=new InlineAccessFieldBinding(inAspect,binding,m);
  inAspect.accessForInline.put(m,ret);
  return ret;
}",0.6825192802056556
9521,"public static ResolvedMember makeResolvedMember(FieldBinding binding){
  return new ResolvedMember(Member.FIELD,fromBinding(binding.declaringClass),binding.modifiers,fromBinding(binding.type),new String(binding.name),TypeX.NONE);
}","public static ResolvedMember makeResolvedMember(FieldBinding binding,TypeBinding receiverType){
  return new ResolvedMember(Member.FIELD,fromBinding(receiverType),binding.modifiers,fromBinding(binding.type),new String(binding.name),TypeX.NONE);
}",0.8763102725366876
9522,"public InlineAccessFieldBinding(AspectDeclaration inAspect,FieldBinding baseField){
  super(baseField,baseField.declaringClass);
  this.reader=new SimpleSyntheticAccessMethodBinding(inAspect.factory.makeMethodBinding(AjcMemberMaker.inlineAccessMethodForFieldGet(inAspect.typeX,EclipseFactory.makeResolvedMember(baseField))));
  this.writer=new SimpleSyntheticAccessMethodBinding(inAspect.factory.makeMethodBinding(AjcMemberMaker.inlineAccessMethodForFieldSet(inAspect.typeX,EclipseFactory.makeResolvedMember(baseField))));
  this.constant=ASTNode.NotAConstant;
  this.baseField=baseField;
}","public InlineAccessFieldBinding(AspectDeclaration inAspect,FieldBinding baseField,ResolvedMember resolvedField){
  super(baseField,baseField.declaringClass);
  this.reader=new SimpleSyntheticAccessMethodBinding(inAspect.factory.makeMethodBinding(AjcMemberMaker.inlineAccessMethodForFieldGet(inAspect.typeX,resolvedField)));
  this.writer=new SimpleSyntheticAccessMethodBinding(inAspect.factory.makeMethodBinding(AjcMemberMaker.inlineAccessMethodForFieldSet(inAspect.typeX,resolvedField)));
  this.constant=ASTNode.NotAConstant;
  this.baseField=baseField;
}",0.8997384481255449
9523,"public String getSignature(){
  return memberView.getSignature();
}","public String getSignature(){
  if (memberView != null)   return memberView.getSignature();
  return Member.typesToSignature(BcelWorld.fromBcel(getReturnType()),BcelWorld.fromBcel(getArgumentTypes()));
}",0.4444444444444444
9524,"protected void generatePostSyntheticCode(ClassScope classScope,CodeStream codeStream){
  super.generatePostSyntheticCode(classScope,codeStream);
  if (hasPost) {
    final EclipseFactory world=EclipseFactory.fromScopeLookupEnvironment(classScope);
    codeStream.invokestatic(world.makeMethodBindingForCall(AjcMemberMaker.ajcPostClinitMethod(EclipseFactory.fromBinding(classScope.referenceContext.binding))));
  }
  if (initFailureField != null) {
    handlerLabel.placeEnd();
    Label endLabel=new Label(codeStream);
    codeStream.goto_(endLabel);
    handlerLabel.place();
    codeStream.putstatic(initFailureField);
    endLabel.place();
  }
}","protected void generatePostSyntheticCode(ClassScope classScope,CodeStream codeStream){
  super.generatePostSyntheticCode(classScope,codeStream);
  if (hasPost) {
    final EclipseFactory world=EclipseFactory.fromScopeLookupEnvironment(classScope);
    codeStream.invokestatic(world.makeMethodBindingForCall(AjcMemberMaker.ajcPostClinitMethod(EclipseFactory.fromBinding(classScope.referenceContext.binding))));
  }
  if (initFailureField != null) {
    handlerLabel.placeEnd();
    Label endLabel=new Label(codeStream);
    codeStream.goto_(endLabel);
    handlerLabel.place();
    codeStream.astore_0();
    codeStream.aload_0();
    codeStream.putstatic(initFailureField);
    endLabel.place();
  }
}",0.960711638250556
9525,"private boolean isInitFailureHandler(InstructionHandle ih){
  if (ih.getInstruction() instanceof PUTSTATIC) {
    String name=((PUTSTATIC)ih.getInstruction()).getFieldName(cpg);
    if (name.equals(NameMangler.INITFAILURECAUSE_FIELD_NAME))     return true;
  }
  return false;
}","private boolean isInitFailureHandler(InstructionHandle ih){
  InstructionHandle twoInstructionsAway=ih.getNext().getNext();
  if (twoInstructionsAway.getInstruction() instanceof PUTSTATIC) {
    String name=((PUTSTATIC)twoInstructionsAway.getInstruction()).getFieldName(cpg);
    if (name.equals(NameMangler.INITFAILURECAUSE_FIELD_NAME))     return true;
  }
  return false;
}",0.8379204892966361
9526,"public static Test suite(){
  TestSuite suite=new TestSuite(AjdeTests.class.getName());
  suite.addTestSuite(BuildOptionsTest.class);
  suite.addTestSuite(BuildConfigurationTests.class);
  suite.addTestSuite(StructureModelRegressionTest.class);
  suite.addTestSuite(StructureModelTest.class);
  suite.addTestSuite(VersionTest.class);
  suite.addTestSuite(CompilerMessagesTest.class);
  suite.addTestSuite(AsmDeclarationsTest.class);
  suite.addTestSuite(AsmRelationshipsTest.class);
  suite.addTestSuite(InpathTestcase.class);
  suite.addTestSuite(ResourceCopyTestCase.class);
  suite.addTestSuite(ModelPerformanceTest.class);
  return suite;
}","public static Test suite(){
  TestSuite suite=new TestSuite(AjdeTests.class.getName());
  suite.addTestSuite(BuildOptionsTest.class);
  suite.addTestSuite(BuildConfigurationTests.class);
  suite.addTestSuite(StructureModelRegressionTest.class);
  suite.addTestSuite(StructureModelTest.class);
  suite.addTestSuite(VersionTest.class);
  suite.addTestSuite(CompilerMessagesTest.class);
  suite.addTestSuite(AsmDeclarationsTest.class);
  suite.addTestSuite(AsmRelationshipsTest.class);
  suite.addTestSuite(InpathTestcase.class);
  suite.addTestSuite(ResourceCopyTestCase.class);
  suite.addTestSuite(ModelPerformanceTest.class);
  suite.addTestSuite(SavedModelConsistencyTest.class);
  return suite;
}",0.9590469099032016
9527,"public MethodBinding getExactMethod(SourceTypeBinding sourceTypeBinding,char[] selector,TypeBinding[] argumentTypes){
  MethodBinding ret=sourceTypeBinding.getExactMethodBase(selector,argumentTypes);
  if (ret != null)   return ret;
  for (int i=0, len=interTypeMethods.size(); i < len; i++) {
    MethodBinding im=(MethodBinding)interTypeMethods.get(i);
    if (matches(im,selector,argumentTypes)) {
      return im;
    }
  }
  return null;
}","public MethodBinding getExactMethod(SourceTypeBinding sourceTypeBinding,char[] selector,TypeBinding[] argumentTypes){
  MethodBinding ret=sourceTypeBinding.getExactMethodBase(selector,argumentTypes);
  for (int i=0, len=interTypeMethods.size(); i < len; i++) {
    MethodBinding im=(MethodBinding)interTypeMethods.get(i);
    if (matches(im,selector,argumentTypes)) {
      return im;
    }
  }
  return ret;
}",0.9531615925058547
9528,"public EclipseTypeMunger build(ClassScope classScope){
  EclipseFactory world=EclipseFactory.fromScopeLookupEnvironment(classScope);
  binding=classScope.referenceContext.binding.resolveTypesFor(binding);
  resolveOnType(classScope);
  if (ignoreFurtherInvestigation)   return null;
  if (onTypeBinding.isInterface()) {
    ignoreFurtherInvestigation=true;
    return null;
  }
  if (onTypeBinding.isNestedType()) {
    classScope.problemReporter().signalError(sourceStart,sourceEnd,""String_Node_Str"");
    ignoreFurtherInvestigation=true;
    return null;
  }
  ResolvedTypeX declaringTypeX=world.fromEclipse(onTypeBinding);
  ResolvedTypeX aspectType=world.fromEclipse(classScope.referenceContext.binding);
  ResolvedMember bindingAsMember=EclipseFactory.makeResolvedMember(binding);
  ResolvedMember signature=new ResolvedMember(Member.CONSTRUCTOR,declaringTypeX,declaredModifiers,ResolvedTypeX.VOID,""String_Node_Str"",bindingAsMember.getParameterTypes(),world.fromEclipse(binding.thrownExceptions));
  ResolvedMember syntheticInterMember=AjcMemberMaker.interConstructor(declaringTypeX,signature,aspectType);
  NewConstructorTypeMunger myMunger=new NewConstructorTypeMunger(signature,syntheticInterMember,null,null);
  setMunger(myMunger);
  myMunger.check(world.getWorld());
  this.selector=binding.selector=NameMangler.postIntroducedConstructor(EclipseFactory.fromBinding(binding.declaringClass),declaringTypeX).toCharArray();
  return new EclipseTypeMunger(world,myMunger,aspectType,this);
}","public EclipseTypeMunger build(ClassScope classScope){
  EclipseFactory world=EclipseFactory.fromScopeLookupEnvironment(classScope);
  binding=classScope.referenceContext.binding.resolveTypesFor(binding);
  resolveOnType(classScope);
  if (ignoreFurtherInvestigation)   return null;
  if (onTypeBinding.isInterface()) {
    classScope.problemReporter().signalError(sourceStart,sourceEnd,""String_Node_Str"");
    ignoreFurtherInvestigation=true;
    return null;
  }
  if (onTypeBinding.isNestedType()) {
    classScope.problemReporter().signalError(sourceStart,sourceEnd,""String_Node_Str"");
    ignoreFurtherInvestigation=true;
    return null;
  }
  ResolvedTypeX declaringTypeX=world.fromEclipse(onTypeBinding);
  ResolvedTypeX aspectType=world.fromEclipse(classScope.referenceContext.binding);
  ResolvedMember bindingAsMember=EclipseFactory.makeResolvedMember(binding);
  ResolvedMember signature=new ResolvedMember(Member.CONSTRUCTOR,declaringTypeX,declaredModifiers,ResolvedTypeX.VOID,""String_Node_Str"",bindingAsMember.getParameterTypes(),world.fromEclipse(binding.thrownExceptions));
  ResolvedMember syntheticInterMember=AjcMemberMaker.interConstructor(declaringTypeX,signature,aspectType);
  NewConstructorTypeMunger myMunger=new NewConstructorTypeMunger(signature,syntheticInterMember,null,null);
  setMunger(myMunger);
  myMunger.check(world.getWorld());
  this.selector=binding.selector=NameMangler.postIntroducedConstructor(EclipseFactory.fromBinding(binding.declaringClass),declaringTypeX).toCharArray();
  return new EclipseTypeMunger(world,myMunger,aspectType,this);
}",0.9717440727508933
9529,"public void postParse(TypeDeclaration typeDec){
  this.selector=NameMangler.adviceName(EclipseFactory.fromBinding(typeDec.binding),kind,sourceStart).toCharArray();
  if (arguments != null) {
    baseArgumentCount=arguments.length;
  }
  if (kind == AdviceKind.Around) {
    extraArgument=makeFinalArgument(""String_Node_Str"",AjTypeConstants.getAroundClosureType());
  }
  int addedArguments=3;
  if (extraArgument != null) {
    addedArguments+=1;
  }
  arguments=extendArgumentsLength(arguments,addedArguments);
  int index=baseArgumentCount;
  if (extraArgument != null) {
    arguments[index++]=extraArgument;
  }
  arguments[index++]=makeFinalArgument(""String_Node_Str"",AjTypeConstants.getJoinPointStaticPartType());
  arguments[index++]=makeFinalArgument(""String_Node_Str"",AjTypeConstants.getJoinPointType());
  arguments[index++]=makeFinalArgument(""String_Node_Str"",AjTypeConstants.getJoinPointStaticPartType());
  if (pointcutDesignator.isError()) {
    this.ignoreFurtherInvestigation=true;
  }
  pointcutDesignator.postParse(typeDec,this);
}","public void postParse(TypeDeclaration typeDec){
  int adviceSequenceNumberInType=((AspectDeclaration)typeDec).adviceCounter++;
  StringBuffer stringifiedPointcut=new StringBuffer(30);
  pointcutDesignator.print(0,stringifiedPointcut);
  this.selector=NameMangler.adviceName(EclipseFactory.fromBinding(typeDec.binding),kind,adviceSequenceNumberInType,stringifiedPointcut.toString().hashCode()).toCharArray();
  if (arguments != null) {
    baseArgumentCount=arguments.length;
  }
  if (kind == AdviceKind.Around) {
    extraArgument=makeFinalArgument(""String_Node_Str"",AjTypeConstants.getAroundClosureType());
  }
  int addedArguments=3;
  if (extraArgument != null) {
    addedArguments+=1;
  }
  arguments=extendArgumentsLength(arguments,addedArguments);
  int index=baseArgumentCount;
  if (extraArgument != null) {
    arguments[index++]=extraArgument;
  }
  arguments[index++]=makeFinalArgument(""String_Node_Str"",AjTypeConstants.getJoinPointStaticPartType());
  arguments[index++]=makeFinalArgument(""String_Node_Str"",AjTypeConstants.getJoinPointType());
  arguments[index++]=makeFinalArgument(""String_Node_Str"",AjTypeConstants.getJoinPointStaticPartType());
  if (pointcutDesignator.isError()) {
    this.ignoreFurtherInvestigation=true;
  }
  pointcutDesignator.postParse(typeDec,this);
}",0.8864218616567037
9530,"public static Test suite(){
  TestSuite suite=new TestSuite(BcweaverModuleTests.class.getName());
  suite.addTest(org.aspectj.weaver.bcel.BcelTests.suite());
  suite.addTest(org.aspectj.weaver.BcweaverTests.suite());
  suite.addTest(org.aspectj.weaver.patterns.PatternsTests.suite());
  return suite;
}","public static Test suite(){
  TestSuite suite=new TestSuite(BcweaverModuleTests.class.getName());
  suite.addTest(org.aspectj.weaver.bcel.BcelTests.suite());
  suite.addTest(org.aspectj.weaver.BcweaverTests.suite());
  suite.addTest(org.aspectj.weaver.patterns.PatternsTests.suite());
  suite.addTestSuite(LocaleTest.class);
  return suite;
}",0.937888198757764
9531,"/** 
 * Determines if the variables of this type could be assigned values of another type without casting.  This still allows for assignment conversion as per JLS 2ed 5.2.
 * @param other the other type
 * @param world the {@link World} in which the possible assignment should be checked.
 * @return true iff variables of this type could be assigned values of other without casting
 * @exception NullPointerException if other is null
 */
public boolean isAssignableFrom(TypeX other,World world){
  if (other.isPrimitive())   return false;
  return world.isAssignableFrom(this,other);
}","/** 
 * Determines if the variables of this type could be assigned values of another type without casting.  This still allows for assignment conversion as per JLS 2ed 5.2.  For object types, this means supertypeOrEqual(THIS, OTHER).
 * @param other the other type
 * @param world the {@link World} in which the possible assignment should be checked.
 * @return true iff variables of this type could be assigned values of other without casting
 * @exception NullPointerException if other is null
 */
public boolean isAssignableFrom(TypeX other,World world){
  if (other.isPrimitive())   return false;
  return world.isAssignableFrom(this,other);
}",0.950446791226645
9532,"/** 
 * Determines if variables of this type could be assigned values of another with lots of help.  This is the same as isCoercableFrom, but java.lang.Object is convertable from and to all types. 
 * @param other the other type
 * @param world the {@link World} in which the possible assignment should be checked.
 * @return true iff variables of this type could be assigned values of other with possible conversion
 */
public final boolean isConvertableFrom(TypeX other,World world){
  if (this.equals(OBJECT) || other.equals(OBJECT))   return true;
  return this.isCoerceableFrom(other,world);
}","/** 
 * Determines if variables of this type could be assigned values of another with lots of help.   java.lang.Object is convertable from all types. A primitive type is convertable from X iff it's assignable from X. A reference type is convertable from X iff it's coerceable from X. In other words, X isConvertableFrom Y iff the compiler thinks that _some_ value of Y could be assignable to a variable of type X without loss of precision. 
 * @param other the other type
 * @param world the {@link World} in which the possible assignment should be checked.
 * @return true iff variables of this type could be assigned values of other with possible conversion
 */
public final boolean isConvertableFrom(TypeX other,World world){
  if (this.equals(OBJECT))   return true;
  if (this.isPrimitive() || other.isPrimitive())   return this.isAssignableFrom(other,world);
  return this.isCoerceableFrom(other,world);
}",0.6613651424784626
9533,"/** 
 * Run without throwing exceptions but optionally using System.exit(..). This sets up a message handler which emits messages immediately, so report(boolean, IMessageHandler) only reports total number of errors or warnings.
 * @param args the String[] command line for the compiler
 * @param useSystemExit if true, use System.exit(int) to completeunless one of the args is -noExit.  and signal result (0 no exceptions/error, <0 exceptions, >0 compiler errors).
 */
public void runMain(String[] args,boolean useSystemExit){
  boolean verbose=(-1 != (""String_Node_Str"" + LangUtil.arrayAsList(args)).indexOf(""String_Node_Str""));
  IMessageHolder holder=clientHolder;
  if (null == holder) {
    holder=ourHandler;
    if (verbose) {
      ourHandler.setInterceptor(MessagePrinter.VERBOSE);
    }
 else {
      ourHandler.ignore(IMessage.INFO);
      ourHandler.setInterceptor(MessagePrinter.TERSE);
    }
  }
  run(args,holder);
  boolean skipExit=false;
  if (useSystemExit && !LangUtil.isEmpty(args)) {
    for (int i=0; i < args.length; i++) {
      if (""String_Node_Str"".equals(args[i])) {
        skipExit=true;
        break;
      }
    }
  }
  if (useSystemExit && !skipExit) {
    systemExit(holder);
  }
}","/** 
 * Run without throwing exceptions but optionally using System.exit(..). This sets up a message handler which emits messages immediately, so report(boolean, IMessageHandler) only reports total number of errors or warnings.
 * @param args the String[] command line for the compiler
 * @param useSystemExit if true, use System.exit(int) to completeunless one of the args is -noExit.  and signal result (0 no exceptions/error, <0 exceptions, >0 compiler errors).
 */
public void runMain(String[] args,boolean useSystemExit){
  boolean verbose=(-1 != (""String_Node_Str"" + LangUtil.arrayAsList(args)).indexOf(""String_Node_Str""));
  IMessageHolder holder=clientHolder;
  if (null == holder) {
    holder=ourHandler;
    if (verbose) {
      ourHandler.setInterceptor(MessagePrinter.VERBOSE);
    }
 else {
      ourHandler.ignore(IMessage.INFO);
      ourHandler.setInterceptor(MessagePrinter.TERSE);
    }
  }
  try {
    run(args,holder);
  }
 catch (  OutOfMemoryError outOfMemory) {
    IMessage outOfMemoryMessage=new Message(OUT_OF_MEMORY_MSG,null,true);
    holder.handleMessage(outOfMemoryMessage);
    systemExit(holder);
  }
  boolean skipExit=false;
  if (useSystemExit && !LangUtil.isEmpty(args)) {
    for (int i=0; i < args.length; i++) {
      if (""String_Node_Str"".equals(args[i])) {
        skipExit=true;
        break;
      }
    }
  }
  if (useSystemExit && !skipExit) {
    systemExit(holder);
  }
}",0.9226100151745068
9534,"public void resolveStatements(){
  if (!Modifier.isAbstract(declaredModifiers))   super.resolveStatements();
  if (Modifier.isStatic(declaredModifiers)) {
    if (onTypeBinding.isInterface()) {
      scope.problemReporter().signalError(sourceStart,sourceEnd,""String_Node_Str"");
    }
  }
}","public void resolveStatements(){
  if ((modifiers & AccSemicolonBody) != 0) {
    if ((declaredModifiers & AccAbstract) == 0)     scope.problemReporter().methodNeedingAbstractModifier(this);
  }
 else {
    if (((declaredModifiers & AccAbstract) != 0))     scope.problemReporter().methodNeedingNoBody(this);
  }
  if (!Modifier.isAbstract(declaredModifiers))   super.resolveStatements();
  if (Modifier.isStatic(declaredModifiers)) {
    if (onTypeBinding.isInterface()) {
      scope.problemReporter().signalError(sourceStart,sourceEnd,""String_Node_Str"");
    }
  }
}",0.6744457409568262
9535,"private void weaveInterTypeDeclarations(SourceTypeBinding sourceType,Collection typeMungers,Collection declareParents,boolean skipInners){
  ResolvedTypeX onType=factory.fromEclipse(sourceType);
  WeaverStateInfo info=onType.getWeaverState();
  if (info != null && !info.isOldStyle()) {
    Collection mungers=onType.getWeaverState().getTypeMungers(onType);
    for (Iterator i=mungers.iterator(); i.hasNext(); ) {
      ConcreteTypeMunger m=(ConcreteTypeMunger)i.next();
      EclipseTypeMunger munger=factory.makeEclipseTypeMunger(m);
      if (munger.munge(sourceType)) {
        if (onType.isInterface() && munger.getMunger().needsAccessToTopmostImplementor()) {
          if (!onType.getWorld().getCrosscuttingMembersSet().containsAspect(munger.getAspectType())) {
            dangerousInterfaces.put(onType,""String_Node_Str"" + onType + ""String_Node_Str""+ munger.getAspectType());
          }
        }
      }
    }
    return;
  }
  for (Iterator i=dangerousInterfaces.entrySet().iterator(); i.hasNext(); ) {
    Map.Entry entry=(Map.Entry)i.next();
    ResolvedTypeX interfaceType=(ResolvedTypeX)entry.getKey();
    if (onType.isTopmostImplementor(interfaceType)) {
      factory.showMessage(IMessage.ERROR,onType + ""String_Node_Str"" + entry.getValue(),onType.getSourceLocation(),null);
    }
  }
  boolean needOldStyleWarning=(info != null && info.isOldStyle());
  onType.clearInterTypeMungers();
  for (Iterator i=declareParents.iterator(); i.hasNext(); ) {
    doDeclareParents((DeclareParents)i.next(),sourceType);
  }
  for (Iterator i=typeMungers.iterator(); i.hasNext(); ) {
    EclipseTypeMunger munger=(EclipseTypeMunger)i.next();
    if (munger.matches(onType)) {
      if (needOldStyleWarning) {
        factory.showMessage(IMessage.WARNING,""String_Node_Str"" + onType + ""String_Node_Str"",onType.getSourceLocation(),null);
        needOldStyleWarning=false;
      }
      onType.addInterTypeMunger(munger);
      AsmInterTypeRelationshipProvider.addRelationship(onType,munger);
    }
  }
  for (Iterator i=onType.getInterTypeMungers().iterator(); i.hasNext(); ) {
    EclipseTypeMunger munger=(EclipseTypeMunger)i.next();
    munger.munge(sourceType);
  }
  if (skipInners)   return;
  ReferenceBinding[] memberTypes=sourceType.memberTypes;
  for (int i=0, length=memberTypes.length; i < length; i++) {
    if (memberTypes[i] instanceof SourceTypeBinding) {
      weaveInterTypeDeclarations((SourceTypeBinding)memberTypes[i],typeMungers,declareParents,false);
    }
  }
}","private void weaveInterTypeDeclarations(SourceTypeBinding sourceType,Collection typeMungers,Collection declareParents,boolean skipInners){
  ResolvedTypeX onType=factory.fromEclipse(sourceType);
  WeaverStateInfo info=onType.getWeaverState();
  if (info != null && !info.isOldStyle()) {
    Collection mungers=onType.getWeaverState().getTypeMungers(onType);
    for (Iterator i=mungers.iterator(); i.hasNext(); ) {
      ConcreteTypeMunger m=(ConcreteTypeMunger)i.next();
      EclipseTypeMunger munger=factory.makeEclipseTypeMunger(m);
      if (munger.munge(sourceType)) {
        if (onType.isInterface() && munger.getMunger().needsAccessToTopmostImplementor()) {
          if (!onType.getWorld().getCrosscuttingMembersSet().containsAspect(munger.getAspectType())) {
            dangerousInterfaces.put(onType,""String_Node_Str"" + onType + ""String_Node_Str""+ munger.getAspectType());
          }
        }
      }
    }
    return;
  }
  for (Iterator i=dangerousInterfaces.entrySet().iterator(); i.hasNext(); ) {
    Map.Entry entry=(Map.Entry)i.next();
    ResolvedTypeX interfaceType=(ResolvedTypeX)entry.getKey();
    if (onType.isTopmostImplementor(interfaceType)) {
      factory.showMessage(IMessage.ERROR,onType + ""String_Node_Str"" + entry.getValue(),onType.getSourceLocation(),null);
    }
  }
  boolean needOldStyleWarning=(info != null && info.isOldStyle());
  onType.clearInterTypeMungers();
  for (Iterator i=declareParents.iterator(); i.hasNext(); ) {
    doDeclareParents((DeclareParents)i.next(),sourceType);
  }
  for (Iterator i=typeMungers.iterator(); i.hasNext(); ) {
    EclipseTypeMunger munger=(EclipseTypeMunger)i.next();
    if (munger.matches(onType)) {
      if (needOldStyleWarning) {
        factory.showMessage(IMessage.WARNING,""String_Node_Str"" + onType + ""String_Node_Str"",onType.getSourceLocation(),null);
        needOldStyleWarning=false;
      }
      onType.addInterTypeMunger(munger);
      AsmInterTypeRelationshipProvider.addRelationship(onType,munger);
    }
  }
  onType.checkInterTypeMungers();
  for (Iterator i=onType.getInterTypeMungers().iterator(); i.hasNext(); ) {
    EclipseTypeMunger munger=(EclipseTypeMunger)i.next();
    munger.munge(sourceType);
  }
  if (skipInners)   return;
  ReferenceBinding[] memberTypes=sourceType.memberTypes;
  for (int i=0, length=memberTypes.length; i < length; i++) {
    if (memberTypes[i] instanceof SourceTypeBinding) {
      weaveInterTypeDeclarations((SourceTypeBinding)memberTypes[i],typeMungers,declareParents,false);
    }
  }
}",0.9932162809257782
9536,"private LazyMethodGen makeMethodGen(LazyClassGen gen,ResolvedMember member){
  LazyMethodGen ret=new LazyMethodGen(member.getModifiers(),BcelWorld.makeBcelType(member.getReturnType()),member.getName(),BcelWorld.makeBcelTypes(member.getParameterTypes()),TypeX.getNames(member.getExceptions()),gen);
  ret.makeSynthetic();
  return ret;
}","private LazyMethodGen makeMethodGen(LazyClassGen gen,ResolvedMember member){
  LazyMethodGen ret=new LazyMethodGen(member.getModifiers(),BcelWorld.makeBcelType(member.getReturnType()),member.getName(),BcelWorld.makeBcelTypes(member.getParameterTypes()),TypeX.getNames(member.getExceptions()),gen);
  return ret;
}",0.9645608628659476
9537,"private LazyClassGen weave(UnwovenClassFile classFile,BcelObjectType classType,boolean dump) throws IOException {
  if (classType.isSynthetic()) {
    if (dump)     dumpUnchanged(classFile);
    return null;
  }
  JavaClass javaClass=classType.getJavaClass();
  List shadowMungers=fastMatch(shadowMungerList,classType.getResolvedTypeX());
  List typeMungers=classType.getResolvedTypeX().getInterTypeMungers();
  LazyClassGen clazz=null;
  if (shadowMungers.size() > 0 || typeMungers.size() > 0 || classType.isAspect()) {
    clazz=classType.getLazyClassGen();
    try {
      boolean isChanged=BcelClassWeaver.weave(world,clazz,shadowMungers,typeMungers);
      if (isChanged) {
        if (dump)         dump(classFile,clazz);
        return clazz;
      }
    }
 catch (    RuntimeException re) {
      System.err.println(""String_Node_Str"");
      clazz.print(System.err);
      throw re;
    }
catch (    Error re) {
      System.err.println(""String_Node_Str"");
      clazz.print(System.err);
      throw re;
    }
  }
  if (dump) {
    dumpUnchanged(classFile);
    return clazz;
  }
 else {
    return null;
  }
}","private LazyClassGen weave(UnwovenClassFile classFile,BcelObjectType classType,boolean dump) throws IOException {
  if (classType.isSynthetic()) {
    if (dump)     dumpUnchanged(classFile);
    return null;
  }
  JavaClass javaClass=classType.getJavaClass();
  List shadowMungers=fastMatch(shadowMungerList,classType.getResolvedTypeX());
  List typeMungers=classType.getResolvedTypeX().getInterTypeMungers();
  classType.getResolvedTypeX().checkInterTypeMungers();
  LazyClassGen clazz=null;
  if (shadowMungers.size() > 0 || typeMungers.size() > 0 || classType.isAspect()) {
    clazz=classType.getLazyClassGen();
    try {
      boolean isChanged=BcelClassWeaver.weave(world,clazz,shadowMungers,typeMungers);
      if (isChanged) {
        if (dump)         dump(classFile,clazz);
        return clazz;
      }
    }
 catch (    RuntimeException re) {
      System.err.println(""String_Node_Str"");
      clazz.print(System.err);
      throw re;
    }
catch (    Error re) {
      System.err.println(""String_Node_Str"");
      clazz.print(System.err);
      throw re;
    }
  }
  if (dump) {
    dumpUnchanged(classFile);
    return clazz;
  }
 else {
    return null;
  }
}",0.975567190226876
9538,"public void unhandledException(TypeBinding exceptionType,ASTNode location){
  if (!world.getWorld().getDeclareSoft().isEmpty()) {
    Shadow callSite=world.makeShadow(location,referenceContext);
    Shadow enclosingExec=world.makeShadow(referenceContext);
    for (Iterator i=world.getWorld().getDeclareSoft().iterator(); i.hasNext(); ) {
      DeclareSoft d=(DeclareSoft)i.next();
      ResolvedTypeX throwException=world.fromEclipse((ReferenceBinding)exceptionType);
      FuzzyBoolean isExceptionTypeOrSubtype=d.getException().matchesInstanceof(throwException);
      if (!isExceptionTypeOrSubtype.alwaysTrue())       continue;
      if (callSite != null) {
        FuzzyBoolean match=d.getPointcut().match(callSite);
        if (match.alwaysTrue()) {
          return;
        }
 else         if (!match.alwaysFalse()) {
        }
      }
      if (enclosingExec != null) {
        FuzzyBoolean match=d.getPointcut().match(enclosingExec);
        if (match.alwaysTrue()) {
          return;
        }
 else         if (!match.alwaysFalse()) {
        }
      }
    }
  }
  if (location instanceof Proceed) {
    return;
  }
  super.unhandledException(exceptionType,location);
}","public void unhandledException(TypeBinding exceptionType,ASTNode location){
  if (!factory.getWorld().getDeclareSoft().isEmpty()) {
    Shadow callSite=factory.makeShadow(location,referenceContext);
    Shadow enclosingExec=factory.makeShadow(referenceContext);
    for (Iterator i=factory.getWorld().getDeclareSoft().iterator(); i.hasNext(); ) {
      DeclareSoft d=(DeclareSoft)i.next();
      ResolvedTypeX throwException=factory.fromEclipse((ReferenceBinding)exceptionType);
      FuzzyBoolean isExceptionTypeOrSubtype=d.getException().matchesInstanceof(throwException);
      if (!isExceptionTypeOrSubtype.alwaysTrue())       continue;
      if (callSite != null) {
        FuzzyBoolean match=d.getPointcut().match(callSite);
        if (match.alwaysTrue()) {
          return;
        }
 else         if (!match.alwaysFalse()) {
        }
      }
      if (enclosingExec != null) {
        FuzzyBoolean match=d.getPointcut().match(enclosingExec);
        if (match.alwaysTrue()) {
          return;
        }
 else         if (!match.alwaysFalse()) {
        }
      }
    }
  }
  if (location instanceof Proceed) {
    return;
  }
  super.unhandledException(exceptionType,location);
}",0.9232715008431704
9539,"public void abstractMethodMustBeImplemented(SourceTypeBinding type,MethodBinding abstractMethod){
  if (isPointcutDeclaration(abstractMethod)) {
    return;
  }
  if (CharOperation.prefixEquals(""String_Node_Str"".toCharArray(),abstractMethod.selector)) {
    return;
  }
  ResolvedTypeX onTypeX=world.fromEclipse(type);
  for (Iterator i=onTypeX.getInterTypeMungers().iterator(); i.hasNext(); ) {
    ConcreteTypeMunger m=(ConcreteTypeMunger)i.next();
    if (m.matches(onTypeX)) {
      ResolvedMember sig=m.getSignature();
      if (Modifier.isPublic(sig.getModifiers()) && !Modifier.isAbstract(sig.getModifiers())) {
        if (ResolvedTypeX.matches(sig,world.makeResolvedMember(abstractMethod))) {
          return;
        }
      }
    }
  }
  super.abstractMethodMustBeImplemented(type,abstractMethod);
}","public void abstractMethodMustBeImplemented(SourceTypeBinding type,MethodBinding abstractMethod){
  if (isPointcutDeclaration(abstractMethod)) {
    return;
  }
  if (CharOperation.prefixEquals(""String_Node_Str"".toCharArray(),abstractMethod.selector)) {
    return;
  }
  ResolvedTypeX onTypeX=factory.fromEclipse(type);
  for (Iterator i=onTypeX.getInterTypeMungers().iterator(); i.hasNext(); ) {
    ConcreteTypeMunger m=(ConcreteTypeMunger)i.next();
    if (m.matches(onTypeX)) {
      ResolvedMember sig=m.getSignature();
      if (!Modifier.isAbstract(sig.getModifiers())) {
        if (ResolvedTypeX.matches(AjcMemberMaker.interMethod(sig,m.getAspectType(),sig.getDeclaringType().isInterface(factory.getWorld())),EclipseFactory.makeResolvedMember(abstractMethod))) {
          return;
        }
      }
    }
  }
  super.abstractMethodMustBeImplemented(type,abstractMethod);
}",0.8978145304193739
9540,"public void performCompilation(List files){
  if (progressListener != null) {
    compiledCount=0;
    sourceFileCount=files.size();
    progressListener.setText(""String_Node_Str"");
  }
  String[] filenames=new String[files.size()];
  String[] encodings=new String[files.size()];
  for (int i=0; i < files.size(); i++) {
    filenames[i]=((File)files.get(i)).getPath();
  }
  List cps=buildConfig.getFullClasspath();
  String[] classpaths=new String[cps.size()];
  for (int i=0; i < cps.size(); i++) {
    classpaths[i]=(String)cps.get(i);
  }
  INameEnvironment environment=getLibraryAccess(classpaths,filenames);
  if (!state.classesFromName.isEmpty()) {
    environment=new StatefulNameEnvironment(environment,state.classesFromName);
  }
  AjCompiler compiler=new AjCompiler(environment,DefaultErrorHandlingPolicies.proceedWithAllProblems(),buildConfig.getJavaOptions(),getBatchRequestor(),getProblemFactory());
  AjProblemReporter pr=new AjProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),compiler.options,getProblemFactory());
  compiler.problemReporter=pr;
  AjLookupEnvironment le=new AjLookupEnvironment(compiler,compiler.options,pr,environment);
  EclipseFactory factory=new EclipseFactory(le);
  le.factory=factory;
  pr.world=factory;
  le.factory.buildManager=this;
  compiler.lookupEnvironment=le;
  compiler.parser=new AjParser(pr,compiler.options.parseLiteralExpressionsAsConstants);
  CompilerOptions options=compiler.options;
  options.produceReferenceInfo(true);
  compiler.compile(getCompilationUnits(filenames,encodings));
  environment.cleanup();
}","public void performCompilation(List files){
  if (progressListener != null) {
    compiledCount=0;
    sourceFileCount=files.size();
    progressListener.setText(""String_Node_Str"");
  }
  String[] filenames=new String[files.size()];
  String[] encodings=new String[files.size()];
  for (int i=0; i < files.size(); i++) {
    filenames[i]=((File)files.get(i)).getPath();
  }
  List cps=buildConfig.getFullClasspath();
  String[] classpaths=new String[cps.size()];
  for (int i=0; i < cps.size(); i++) {
    classpaths[i]=(String)cps.get(i);
  }
  INameEnvironment environment=getLibraryAccess(classpaths,filenames);
  if (!state.classesFromName.isEmpty()) {
    environment=new StatefulNameEnvironment(environment,state.classesFromName);
  }
  AjCompiler compiler=new AjCompiler(environment,DefaultErrorHandlingPolicies.proceedWithAllProblems(),buildConfig.getJavaOptions(),getBatchRequestor(),getProblemFactory());
  AjProblemReporter pr=new AjProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),compiler.options,getProblemFactory());
  compiler.problemReporter=pr;
  AjLookupEnvironment le=new AjLookupEnvironment(compiler,compiler.options,pr,environment);
  EclipseFactory factory=new EclipseFactory(le);
  le.factory=factory;
  pr.factory=factory;
  le.factory.buildManager=this;
  compiler.lookupEnvironment=le;
  compiler.parser=new AjParser(pr,compiler.options.parseLiteralExpressionsAsConstants);
  CompilerOptions options=compiler.options;
  options.produceReferenceInfo(true);
  compiler.compile(getCompilationUnits(filenames,encodings));
  environment.cleanup();
}",0.9962287869264612
9541,"protected void consumeAspectHeaderName(boolean isPrivileged){
  AspectDeclaration aspectDecl=new AspectDeclaration(this.compilationUnit.compilationResult);
  println(""String_Node_Str"");
  this.display();
  long pos=identifierPositionStack[identifierPtr];
  aspectDecl.sourceEnd=(int)pos;
  aspectDecl.sourceStart=(int)(pos >>> 32);
  aspectDecl.name=identifierStack[identifierPtr--];
  identifierLengthPtr--;
  eatIdentifier();
  if (isPrivileged) {
    pos=eatIdentifier();
    int end=(int)pos;
    int start=(int)(pos >>> 32);
    aspectDecl.isPrivileged=true;
  }
  aspectDecl.modifiersSourceStart=intStack[intPtr--];
  aspectDecl.modifiers=intStack[intPtr--];
  if (aspectDecl.modifiersSourceStart >= 0) {
    aspectDecl.declarationSourceStart=aspectDecl.modifiersSourceStart;
  }
  println(""String_Node_Str"" + aspectDecl.modifiers);
  aspectDecl.bodyStart=aspectDecl.sourceEnd + 1;
  pushOnAstStack(aspectDecl);
  listLength=0;
  if (currentElement != null) {
    lastCheckPoint=aspectDecl.bodyStart;
    currentElement=currentElement.add(aspectDecl,0);
    lastIgnoredToken=-1;
  }
  this.display();
}","protected void consumeAspectHeaderName(boolean isPrivileged){
  AspectDeclaration aspectDecl=new AspectDeclaration(this.compilationUnit.compilationResult);
  println(""String_Node_Str"");
  this.display();
  long pos=identifierPositionStack[identifierPtr];
  aspectDecl.sourceEnd=(int)pos;
  aspectDecl.sourceStart=(int)(pos >>> 32);
  aspectDecl.name=identifierStack[identifierPtr--];
  identifierLengthPtr--;
  eatIdentifier();
  if (isPrivileged) {
    pos=eatIdentifier();
    int end=(int)pos;
    int start=(int)(pos >>> 32);
    aspectDecl.isPrivileged=true;
  }
  aspectDecl.modifiersSourceStart=intStack[intPtr--];
  aspectDecl.modifiers=intStack[intPtr--];
  if (isPrivileged) {
    aspectDecl.modifiersSourceStart=intStack[intPtr--];
    aspectDecl.modifiers|=intStack[intPtr--];
  }
  if (aspectDecl.modifiersSourceStart >= 0) {
    aspectDecl.declarationSourceStart=aspectDecl.modifiersSourceStart;
  }
  println(""String_Node_Str"" + aspectDecl.modifiers);
  aspectDecl.bodyStart=aspectDecl.sourceEnd + 1;
  pushOnAstStack(aspectDecl);
  listLength=0;
  if (currentElement != null) {
    lastCheckPoint=aspectDecl.bodyStart;
    currentElement=currentElement.add(aspectDecl,0);
    lastIgnoredToken=-1;
  }
  this.display();
}",0.9453924914675768
9542,"/** 
 * Create a message, handling null values for message and kind if thrown is not null.
 * @param message the String used as the underlying message
 * @param kind the IMessage.Kind of message - not null
 * @param thrown the Throwable, if any, associated with this message
 * @param sourceLocation the ISourceLocation, if any, associated with this message
 * @throws IllegalArgumentException if message is null andthrown is null or has a null message, or if kind is null and thrown is null.
 */
public Message(String message,IMessage.Kind kind,Throwable thrown,ISourceLocation sourceLocation){
  this.message=message;
  this.kind=kind;
  this.thrown=thrown;
  this.sourceLocation=sourceLocation;
  this.details=""String_Node_Str"";
  if (null == message) {
    if (null != thrown) {
      message=thrown.getMessage();
    }
    if (null == message) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  if (null == kind) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}","/** 
 * Create a message, handling null values for message and kind if thrown is not null.
 * @param message the String used as the underlying message
 * @param kind the IMessage.Kind of message - not null
 * @param thrown the Throwable, if any, associated with this message
 * @param sourceLocation the ISourceLocation, if any, associated with this message
 * @throws IllegalArgumentException if message is null andthrown is null or has a null message, or if kind is null and thrown is null.
 */
public Message(String message,IMessage.Kind kind,Throwable thrown,ISourceLocation sourceLocation){
  this(message,""String_Node_Str"",kind,sourceLocation,thrown,null);
}",0.7452153110047847
9543,"public String toString(){
  return Message.renderToString(this);
}","public String toString(){
  return MessageUtil.renderMessage(this,false);
}",0.8368794326241135
9544,"/** 
 * This renders IMessage as String, ignoring empty elements and eliding any thrown.
 * @return ""((IMessage) null)"" if null or String rendering otherwise,including everything (esp. throwable stack trace)
 * @see renderSourceLocation(ISourceLocation loc)
 */
public static String renderMessage(IMessage message,boolean elide){
  if (null == message) {
    return ""String_Node_Str"";
  }
  StringBuffer result=new StringBuffer();
  result.append(message.getKind().toString());
  result.append(""String_Node_Str"");
  String messageString=message.getMessage();
  if (!LangUtil.isEmpty(messageString)) {
    result.append(messageString);
    result.append(""String_Node_Str"");
  }
  ISourceLocation loc=message.getSourceLocation();
  if ((null != loc) && (loc != ISourceLocation.EMPTY)) {
    result.append(""String_Node_Str"" + renderSourceLocation(loc));
  }
  Throwable thrown=message.getThrown();
  if (null != thrown) {
    result.append(""String_Node_Str"" + LangUtil.renderExceptionShort(thrown));
    result.append(""String_Node_Str"" + LangUtil.renderException(thrown,elide));
  }
  return result.toString();
}","/** 
 * This renders IMessage as String, ignoring empty elements and eliding any thrown.
 * @return ""((IMessage) null)"" if null or String rendering otherwise,including everything (esp. throwable stack trace)
 * @see renderSourceLocation(ISourceLocation loc)
 */
public static String renderMessage(IMessage message,boolean elide){
  if (null == message) {
    return ""String_Node_Str"";
  }
  ISourceLocation loc=message.getSourceLocation();
  String locString=(null == loc ? ""String_Node_Str"" : ""String_Node_Str"" + loc);
  String result=message.getKind() + locString + ""String_Node_Str""+ message.getMessage();
  Throwable thrown=message.getThrown();
  if (thrown != null) {
    result+=""String_Node_Str"" + LangUtil.renderExceptionShort(thrown);
    result+=""String_Node_Str"" + LangUtil.renderException(thrown,elide);
  }
  if (message.getExtraSourceLocations().isEmpty()) {
    return result;
  }
 else {
    return addExtraSourceLocations(message,result);
  }
}",0.5294685990338164
9545,"/** 
 * @return String {context\n}{file:}line{:column} 
 */
public String toString(){
  StringBuffer sb=new StringBuffer();
  if (null != context) {
    sb.append(context);
    sb.append(LangUtil.EOL);
  }
  if (sourceFile != ISourceLocation.NO_FILE) {
    sb.append(sourceFile.getPath());
    sb.append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"" + startLine + ""String_Node_Str""+ endLine);
  if (!noColumn) {
    sb.append(""String_Node_Str"" + column);
  }
  return sb.toString();
}","/** 
 * @return String {context\n}{file:}line{:column} 
 */
public String toString(){
  StringBuffer sb=new StringBuffer();
  if (null != context) {
    sb.append(context);
    sb.append(LangUtil.EOL);
  }
  if (sourceFile != ISourceLocation.NO_FILE) {
    sb.append(sourceFile.getPath());
    sb.append(""String_Node_Str"");
  }
  sb.append(startLine);
  if (!noColumn) {
    sb.append(""String_Node_Str"" + column);
  }
  return sb.toString();
}",0.7828877005347593
9546,"/** 
 * Render message differently. If abort, then prefix stack trace with feedback request. If the actual message is empty, then use toString on the whole. Prefix message part with file:line; If it has context, suffix message with context.
 * @param message the IMessage to render
 * @return String rendering IMessage (never null)
 */
protected String render(IMessage message){
  IMessage.Kind kind=message.getKind();
  StringBuffer sb=new StringBuffer();
  String text=message.getMessage();
  if (text.equals(AbortException.NO_MESSAGE_TEXT)) {
    text=null;
  }
  boolean toString=(LangUtil.isEmpty(text));
  if (toString) {
    text=message.toString();
  }
  ISourceLocation loc=message.getSourceLocation();
  String context=null;
  if (null != loc) {
    File file=loc.getSourceFile();
    if (null != file) {
      String name=file.getName();
      if (!toString || (-1 == text.indexOf(name))) {
        sb.append(FileUtil.getBestPath(file));
        sb.append(""String_Node_Str"" + loc.getLine());
        int col=loc.getColumn();
        if (0 < col) {
          sb.append(""String_Node_Str"" + col);
        }
        sb.append(""String_Node_Str"");
      }
    }
    context=loc.getContext();
  }
  sb.append(text);
  if (null != context) {
    sb.append(LangUtil.EOL);
    sb.append(context);
  }
  Throwable thrown=message.getThrown();
  if (null != thrown) {
    sb.append(LangUtil.EOL);
    sb.append(Main.renderExceptionForUser(thrown));
  }
  return sb.toString();
}","/** 
 * Render message differently. If abort, then prefix stack trace with feedback request. If the actual message is empty, then use toString on the whole. Prefix message part with file:line; If it has context, suffix message with context.
 * @param message the IMessage to render
 * @return String rendering IMessage (never null)
 */
protected String render(IMessage message){
  IMessage.Kind kind=message.getKind();
  StringBuffer sb=new StringBuffer();
  String text=message.getMessage();
  if (text.equals(AbortException.NO_MESSAGE_TEXT)) {
    text=null;
  }
  boolean toString=(LangUtil.isEmpty(text));
  if (toString) {
    text=message.toString();
  }
  ISourceLocation loc=message.getSourceLocation();
  String context=null;
  if (null != loc) {
    File file=loc.getSourceFile();
    if (null != file) {
      String name=file.getName();
      if (!toString || (-1 == text.indexOf(name))) {
        sb.append(FileUtil.getBestPath(file));
        sb.append(""String_Node_Str"" + loc.getLine());
        int col=loc.getColumn();
        if (0 < col) {
          sb.append(""String_Node_Str"" + col);
        }
        sb.append(""String_Node_Str"");
      }
    }
    context=loc.getContext();
  }
  sb.append(text);
  if (null != context) {
    sb.append(LangUtil.EOL);
    sb.append(context);
  }
  Throwable thrown=message.getThrown();
  if (null != thrown) {
    sb.append(LangUtil.EOL);
    sb.append(Main.renderExceptionForUser(thrown));
  }
  if (message.getExtraSourceLocations().isEmpty()) {
    return sb.toString();
  }
 else {
    return MessageUtil.addExtraSourceLocations(message,sb.toString());
  }
}",0.9541047188106012
9547,"void addFiles(File dir,FileFilter filter){
  if (dir == null)   dir=new File(System.getProperty(""String_Node_Str""));
  if (!dir.isDirectory()) {
    showError(""String_Node_Str"" + dir.getPath());
  }
  File[] files=dir.listFiles(filter);
  if (files.length == 0) {
    showWarning(""String_Node_Str"" + dir);
  }
  for (int i=0; i < files.length; i++) {
    addFile(files[i]);
  }
}","void addFiles(File dir,FileFilter filter){
  if (dir == null)   dir=new File(System.getProperty(""String_Node_Str""));
  if (!dir.isDirectory()) {
    showError(""String_Node_Str"" + dir.getPath());
  }
 else {
    File[] files=dir.listFiles(filter);
    if (files.length == 0) {
      showWarning(""String_Node_Str"" + dir);
    }
    for (int i=0; i < files.length; i++) {
      addFile(files[i]);
    }
  }
}",0.9668367346938777
9548,"public void resolve(){
  if (binding == null) {
    ignoreFurtherInvestigation=true;
    return;
  }
  if (concreteName != null)   concreteName.checkPointcutDeclarations();
  super.resolve();
}","public void resolve(){
  if (binding == null) {
    ignoreFurtherInvestigation=true;
    return;
  }
  super.resolve();
}",0.7707006369426752
9549,"private void resolvePointcutDeclarations(ClassScope s){
  TypeDeclaration dec=s.referenceContext;
  SourceTypeBinding sourceType=s.referenceContext.binding;
  AbstractMethodDeclaration[] methods=dec.methods;
  boolean initializedMethods=false;
  if (methods != null) {
    for (int i=0; i < methods.length; i++) {
      if (methods[i] instanceof PointcutDeclaration) {
        if (!initializedMethods) {
          sourceType.methods();
          initializedMethods=true;
        }
        ((PointcutDeclaration)methods[i]).resolvePointcut(s);
      }
    }
  }
  ReferenceBinding[] memberTypes=sourceType.memberTypes;
  for (int i=0, length=memberTypes.length; i < length; i++) {
    resolvePointcutDeclarations(((SourceTypeBinding)memberTypes[i]).scope);
  }
}","private void resolvePointcutDeclarations(ClassScope s){
  TypeDeclaration dec=s.referenceContext;
  SourceTypeBinding sourceType=s.referenceContext.binding;
  boolean hasPointcuts=false;
  AbstractMethodDeclaration[] methods=dec.methods;
  boolean initializedMethods=false;
  if (methods != null) {
    for (int i=0; i < methods.length; i++) {
      if (methods[i] instanceof PointcutDeclaration) {
        hasPointcuts=true;
        if (!initializedMethods) {
          sourceType.methods();
          initializedMethods=true;
        }
        ((PointcutDeclaration)methods[i]).resolvePointcut(s);
      }
    }
  }
  if (hasPointcuts || dec instanceof AspectDeclaration) {
    ResolvedTypeX.Name name=(ResolvedTypeX.Name)factory.fromEclipse(sourceType);
    EclipseSourceType eclipseSourceType=(EclipseSourceType)name.getDelegate();
    eclipseSourceType.checkPointcutDeclarations();
  }
  ReferenceBinding[] memberTypes=sourceType.memberTypes;
  for (int i=0, length=memberTypes.length; i < length; i++) {
    resolvePointcutDeclarations(((SourceTypeBinding)memberTypes[i]).scope);
  }
}",0.8218142548596112
9550,"protected void consumeExtraParameterNoFormal(){
  long pos=identifierPositionStack[identifierPtr];
  int end=(int)pos;
  int start=(int)(pos >>> 32);
  char[] name=identifierStack[identifierPtr--];
  identifierLengthPtr--;
  AdviceDeclaration adviceDecl=(AdviceDeclaration)astStack[astPtr];
  if (adviceDecl.kind != AdviceKind.After) {
  }
  if (CharOperation.equals(name,""String_Node_Str"".toCharArray())) {
    adviceDecl.kind=AdviceKind.AfterThrowing;
  }
 else   if (CharOperation.equals(name,""String_Node_Str"".toCharArray())) {
    adviceDecl.kind=AdviceKind.AfterReturning;
  }
 else {
  }
}","protected void consumeExtraParameterNoFormal(){
  long pos=identifierPositionStack[identifierPtr];
  int end=(int)pos;
  int start=(int)(pos >>> 32);
  char[] name=identifierStack[identifierPtr--];
  identifierLengthPtr--;
  AdviceDeclaration adviceDecl=(AdviceDeclaration)astStack[astPtr];
  if (adviceDecl.kind != AdviceKind.After) {
  }
  if (CharOperation.equals(name,""String_Node_Str"".toCharArray())) {
    adviceDecl.kind=AdviceKind.AfterThrowing;
  }
 else   if (CharOperation.equals(name,""String_Node_Str"".toCharArray())) {
    adviceDecl.kind=AdviceKind.AfterReturning;
  }
 else {
    problemReporter().parseError(start,end,name,String.valueOf(name),new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  }
}",0.8940646130728775
9551,"private void replaceEffectivelyStaticRef(MessageSend call){
  NameReference receiver=(NameReference)call.receiver;
  receiver.binding=thisJoinPointStaticPartDecLocal;
  receiver.codegenBinding=thisJoinPointStaticPartDecLocal;
  call.binding=call.codegenBinding=getEquivalentStaticBinding(call.binding);
}","private void replaceEffectivelyStaticRef(MessageSend call){
  NameReference receiver=(NameReference)call.receiver;
  receiver.binding=thisJoinPointStaticPartDecLocal;
  receiver.codegenBinding=thisJoinPointStaticPartDecLocal;
  ReferenceBinding thisJoinPointStaticPartType=(ReferenceBinding)thisJoinPointStaticPartDec.type;
  receiver.receiverType=receiver.actualReceiverType=receiver.resolvedType=thisJoinPointStaticPartType;
  call.setActualReceiverType(thisJoinPointStaticPartType);
  call.binding=call.codegenBinding=getEquivalentStaticBinding(call.binding);
}",0.7004608294930875
9552,"public void setJavac(Javac javac){
  this.javac=javac;
}","public void setJavac(Javac javac){
  this.javac=javac;
  javac.setTaskName(javac.getTaskName() + ""String_Node_Str"");
}",0.6436781609195402
9553,"public boolean execute() throws BuildException {
  checkJavac();
  if (recurse()) {
    javac.execute();
  }
 else {
    try {
      AjcTask ajc=new AjcTask();
      String err=ajc.setupAjc(javac);
      if (null != err) {
        throw new BuildException(err,javac.getLocation());
      }
      ajc.execute();
    }
  finally {
      doneRecursing();
    }
  }
  return true;
}","public boolean execute() throws BuildException {
  if (null == javac) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (!((Boolean)inSelfCall.get()).booleanValue() && afterCleaningDirs()) {
    inSelfCall.set(Boolean.TRUE);
    javac.execute();
  }
 else {
    try {
      AjcTask ajc=new AjcTask();
      String err=ajc.setupAjc(javac);
      if (null != err) {
        throw new BuildException(err,javac.getLocation());
      }
      ajc.execute();
    }
  finally {
      inSelfCall.set(Boolean.FALSE);
    }
  }
  return true;
}",0.6551724137931034
9554,"/** 
 * This method extracts javac arguments to ajc, and add arguments to make ajc behave more like javac in copying resources. <p> Pass ajc-specific options using compilerarg sub-element: <pre> &lt;javac srcdir=""src""> &lt;compilerarg compiler=""..."" line=""-argfile src/args.lst""/> &lt;javac> </pre> Some javac arguments are not supported in this component (yet): <pre> String memoryInitialSize; boolean includeAntRuntime = true; boolean includeJavaRuntime = false; </pre> Other javac arguments are not supported in ajc 1.1: <pre> boolean optimize; String forkedExecutable; FacadeTaskHelper facade; boolean depend; String debugLevel; Path compileSourcepath; </pre>
 * @param javac the Javac command to implement (not null)
 * @param ajc the AjcTask to adapt (not null)
 * @param destDir the File class destination directory (may be null)
 * @return null if no error, or String error otherwise
 */
public String setupAjc(Javac javac){
  if (null == javac) {
    return ""String_Node_Str"";
  }
  AjcTask ajc=this;
  ajc.setProject(javac.getProject());
  ajc.setLocation(javac.getLocation());
  ajc.setTaskName(""String_Node_Str"");
  ajc.setDebug(javac.getDebug());
  ajc.setDeprecation(javac.getDeprecation());
  ajc.setFailonerror(javac.getFailonerror());
  final boolean fork=javac.isForkedJavac();
  ajc.setFork(fork);
  if (fork) {
    ajc.setMaxmem(javac.getMemoryMaximumSize());
  }
  ajc.setNowarn(javac.getNowarn());
  ajc.setListFileArgs(javac.getListfiles());
  ajc.setVerbose(javac.getVerbose());
  ajc.setTarget(javac.getTarget());
  ajc.setSource(javac.getSource());
  ajc.setEncoding(javac.getEncoding());
  File javacDestDir=javac.getDestdir();
  if (null != javacDestDir) {
    ajc.setDestdir(javacDestDir);
  }
  ajc.setBootclasspath(javac.getBootclasspath());
  ajc.setExtdirs(javac.getExtdirs());
  ajc.setClasspath(javac.getClasspath());
  ajc.addFiles(javac.getFileList());
  ajc.setSourceRootCopyFilter(""String_Node_Str"");
  ajc.readArguments(javac.getCurrentCompilerArgs());
  return null;
}","/** 
 * This method extracts javac arguments to ajc, and add arguments to make ajc behave more like javac in copying resources. <p> Pass ajc-specific options using compilerarg sub-element: <pre> &lt;javac srcdir=""src""> &lt;compilerarg compiler=""..."" line=""-argfile src/args.lst""/> &lt;javac> </pre> Some javac arguments are not supported in this component (yet): <pre> String memoryInitialSize; boolean includeAntRuntime = true; boolean includeJavaRuntime = false; </pre> Other javac arguments are not supported in ajc 1.1: <pre> boolean optimize; String forkedExecutable; FacadeTaskHelper facade; boolean depend; String debugLevel; Path compileSourcepath; </pre>
 * @param javac the Javac command to implement (not null)
 * @param ajc the AjcTask to adapt (not null)
 * @param destDir the File class destination directory (may be null)
 * @return null if no error, or String error otherwise
 */
public String setupAjc(Javac javac){
  if (null == javac) {
    return ""String_Node_Str"";
  }
  AjcTask ajc=this;
  ajc.setProject(javac.getProject());
  ajc.setLocation(javac.getLocation());
  ajc.setTaskName(""String_Node_Str"");
  ajc.setDebug(javac.getDebug());
  ajc.setDeprecation(javac.getDeprecation());
  ajc.setFailonerror(javac.getFailonerror());
  final boolean fork=javac.isForkedJavac();
  ajc.setFork(fork);
  if (fork) {
    ajc.setMaxmem(javac.getMemoryMaximumSize());
  }
  ajc.setNowarn(javac.getNowarn());
  ajc.setListFileArgs(javac.getListfiles());
  ajc.setVerbose(javac.getVerbose());
  ajc.setTarget(javac.getTarget());
  ajc.setSource(javac.getSource());
  ajc.setEncoding(javac.getEncoding());
  File javacDestDir=javac.getDestdir();
  if (null != javacDestDir) {
    ajc.setDestdir(javacDestDir);
    ajc.setSourceRootCopyFilter(""String_Node_Str"");
  }
  ajc.setBootclasspath(javac.getBootclasspath());
  ajc.setExtdirs(javac.getExtdirs());
  ajc.setClasspath(javac.getClasspath());
  ajc.addFiles(javac.getFileList());
  ajc.readArguments(javac.getCurrentCompilerArgs());
  return null;
}",0.9567164179104478
9555,"/** 
 * Compile using ajc per settings.
 * @exception BuildException if the compilation has problemsor if there were compiler errors and failonerror is true.
 */
public void execute() throws BuildException {
  if (executing) {
    throw new IllegalStateException(""String_Node_Str"");
  }
 else {
    executing=true;
  }
  verifyOptions();
  try {
    String[] args=makeCommand();
    if (verbose || listFileArgs) {
      log(""String_Node_Str"" + Arrays.asList(args),Project.MSG_VERBOSE);
    }
    if (!fork) {
      executeInSameVM(args);
    }
 else {
      executeInOtherVM(args);
    }
  }
 catch (  BuildException e) {
    throw e;
  }
catch (  Throwable x) {
    System.err.println(Main.renderExceptionForUser(x));
    throw new BuildException(""String_Node_Str"" + LangUtil.unqualifiedClassName(x) + ""String_Node_Str"");
  }
 finally {
    executing=false;
    if (null != tmpOutjar) {
      tmpOutjar.delete();
    }
  }
}","/** 
 * Compile using ajc per settings.
 * @exception BuildException if the compilation has problemsor if there were compiler errors and failonerror is true.
 */
public void execute() throws BuildException {
  if (executing) {
    throw new IllegalStateException(""String_Node_Str"");
  }
 else {
    executing=true;
  }
  setupOptions();
  verifyOptions();
  try {
    String[] args=makeCommand();
    if (verbose || listFileArgs) {
      log(""String_Node_Str"" + Arrays.asList(args),Project.MSG_VERBOSE);
    }
    if (!fork) {
      executeInSameVM(args);
    }
 else {
      executeInOtherVM(args);
    }
  }
 catch (  BuildException e) {
    throw e;
  }
catch (  Throwable x) {
    System.err.println(Main.renderExceptionForUser(x));
    throw new BuildException(""String_Node_Str"" + LangUtil.unqualifiedClassName(x) + ""String_Node_Str"");
  }
 finally {
    executing=false;
    if (null != tmpOutjar) {
      tmpOutjar.delete();
    }
  }
}",0.9903640256959316
9556,"/** 
 * to use this same Task more than once (testing) 
 */
public void reset(){
  adapterArguments=null;
  adapterFiles=new ArrayList();
  argfiles=null;
  executing=false;
  aspectpath=null;
  bootclasspath=null;
  classpath=null;
  cmd=new GuardedCommand();
  copyInjars=false;
  destDir=DEFAULT_DESTDIR;
  executing=false;
  executingInOtherVM=false;
  extdirs=null;
  failonerror=true;
  forkclasspath=null;
  inIncrementalMode=false;
  inIncrementalFileMode=false;
  ignored=new ArrayList();
  injars=null;
  listFileArgs=false;
  maxMem=null;
  messageHolder=null;
  outjar=null;
  sourceRootCopyFilter=null;
  sourceRoots=null;
  srcdir=null;
  tmpOutjar=null;
  verbose=false;
}","/** 
 * to use this same Task more than once (testing) 
 */
public void reset(){
  adapterArguments=null;
  adapterFiles=new ArrayList();
  argfiles=null;
  executing=false;
  aspectpath=null;
  bootclasspath=null;
  classpath=null;
  cmd=new GuardedCommand();
  copyInjars=false;
  destDir=DEFAULT_DESTDIR;
  executing=false;
  executingInOtherVM=false;
  extdirs=null;
  failonerror=true;
  forkclasspath=null;
  inIncrementalMode=false;
  inIncrementalFileMode=false;
  ignored=new ArrayList();
  injars=null;
  listFileArgs=false;
  maxMem=null;
  messageHolder=null;
  outjar=null;
  sourceRootCopyFilter=null;
  sourceRoots=null;
  srcdir=null;
  tmpOutjar=null;
  verbose=false;
  xweaveDir=null;
}",0.9870689655172412
9557,"/** 
 * Run the compile in the same VM by loading the compiler (Main),  setting up any message holders, doing the compile, and converting abort/failure and error messages to BuildException, as appropriate.
 * @throws BuildException if abort or failure messagesor if errors and failonerror.
 */
protected void executeInSameVM(String[] args){
  if (null != maxMem) {
    log(""String_Node_Str"" + maxMem,Project.MSG_WARN);
  }
  IMessageHolder holder=messageHolder;
  int numPreviousErrors;
  if (null == holder) {
    MessageHandler mhandler=new MessageHandler(true);
    final IMessageHandler delegate=verbose ? MessagePrinter.VERBOSE : MessagePrinter.TERSE;
    mhandler.setInterceptor(delegate);
    if (!verbose) {
      mhandler.ignore(IMessage.INFO);
    }
    holder=mhandler;
    numPreviousErrors=0;
  }
 else {
    numPreviousErrors=holder.numMessages(IMessage.ERROR,true);
  }
{
    Main newmain=new Main();
    newmain.setHolder(holder);
    newmain.setCompletionRunner(new Runnable(){
      public void run(){
        doCompletionTasks();
      }
    }
);
    if (null != main) {
      MessageUtil.fail(holder,""String_Node_Str"");
      return;
    }
    main=newmain;
  }
  try {
    main.runMain(args,false);
  }
  finally {
    main=null;
  }
  if (failonerror) {
    int errs=holder.numMessages(IMessage.ERROR,false);
    errs-=numPreviousErrors;
    if (0 < errs) {
      throw new BuildException(errs + ""String_Node_Str"");
    }
  }
{
    IMessage[] fails=holder.getMessages(IMessage.FAIL,true);
    if (!LangUtil.isEmpty(fails)) {
      StringBuffer sb=new StringBuffer();
      String prefix=""String_Node_Str"";
      int numThrown=0;
      for (int i=0; i < fails.length; i++) {
        String message=fails[i].getMessage();
        if (LangUtil.isEmpty(message)) {
          message=""String_Node_Str"";
        }
 else         if (-1 != message.indexOf(USAGE_SUBSTRING)) {
          continue;
        }
        Throwable t=fails[i].getThrown();
        if (null != t) {
          numThrown++;
          sb.append(prefix);
          sb.append(LangUtil.unqualifiedClassName(t.getClass()));
          String thrownMessage=t.getMessage();
          if (!LangUtil.isEmpty(thrownMessage)) {
            sb.append(""String_Node_Str"" + thrownMessage + ""String_Node_Str"");
          }
        }
        sb.append(""String_Node_Str"" + message + ""String_Node_Str"");
        prefix=""String_Node_Str"";
      }
      if (0 < sb.length()) {
        sb.append(""String_Node_Str"" + numThrown + ""String_Node_Str"");
        throw new BuildException(sb.toString());
      }
    }
  }
}","/** 
 * Run the compile in the same VM by loading the compiler (Main),  setting up any message holders, doing the compile, and converting abort/failure and error messages to BuildException, as appropriate.
 * @throws BuildException if abort or failure messagesor if errors and failonerror.
 */
protected void executeInSameVM(String[] args){
  if (null != maxMem) {
    log(""String_Node_Str"" + maxMem,Project.MSG_WARN);
  }
  IMessageHolder holder=messageHolder;
  int numPreviousErrors;
  if (null == holder) {
    MessageHandler mhandler=new MessageHandler(true);
    final IMessageHandler delegate=verbose ? MessagePrinter.VERBOSE : MessagePrinter.TERSE;
    mhandler.setInterceptor(delegate);
    if (!verbose) {
      mhandler.ignore(IMessage.INFO);
    }
    holder=mhandler;
    numPreviousErrors=0;
  }
 else {
    numPreviousErrors=holder.numMessages(IMessage.ERROR,true);
  }
{
    Main newmain=new Main();
    newmain.setHolder(holder);
    newmain.setCompletionRunner(new Runnable(){
      public void run(){
        doCompletionTasks();
      }
    }
);
    if (null != main) {
      MessageUtil.fail(holder,""String_Node_Str"");
      return;
    }
    main=newmain;
  }
  try {
    main.runMain(args,false);
  }
  finally {
    main=null;
  }
  if (failonerror) {
    int errs=holder.numMessages(IMessage.ERROR,false);
    errs-=numPreviousErrors;
    if (0 < errs) {
      String m=errs + ""String_Node_Str"";
      MessageUtil.print(System.err,holder,""String_Node_Str"",MessageUtil.MESSAGE_ALL,MessageUtil.PICK_ERROR,true);
      throw new BuildException(m);
    }
  }
{
    IMessage[] fails=holder.getMessages(IMessage.FAIL,true);
    if (!LangUtil.isEmpty(fails)) {
      StringBuffer sb=new StringBuffer();
      String prefix=""String_Node_Str"";
      int numThrown=0;
      for (int i=0; i < fails.length; i++) {
        String message=fails[i].getMessage();
        if (LangUtil.isEmpty(message)) {
          message=""String_Node_Str"";
        }
 else         if (-1 != message.indexOf(USAGE_SUBSTRING)) {
          continue;
        }
        Throwable t=fails[i].getThrown();
        if (null != t) {
          numThrown++;
          sb.append(prefix);
          sb.append(LangUtil.unqualifiedClassName(t.getClass()));
          String thrownMessage=t.getMessage();
          if (!LangUtil.isEmpty(thrownMessage)) {
            sb.append(""String_Node_Str"" + thrownMessage + ""String_Node_Str"");
          }
        }
        sb.append(""String_Node_Str"" + message + ""String_Node_Str"");
        prefix=""String_Node_Str"";
      }
      if (0 < sb.length()) {
        sb.append(""String_Node_Str"" + numThrown + ""String_Node_Str"");
        throw new BuildException(sb.toString());
      }
    }
  }
}",0.9659735349716446
9558,"public static void checkerMunger(IHierarchy model,Shadow shadow,Checker checker){
  if (shadow.getSourceLocation() == null || checker.getSourceLocation() == null)   return;
  String sourceHandle=ProgramElement.createHandleIdentifier(checker.getSourceLocation().getSourceFile(),checker.getSourceLocation().getLine(),checker.getSourceLocation().getColumn());
  String targetHandle=ProgramElement.createHandleIdentifier(shadow.getSourceLocation().getSourceFile(),shadow.getSourceLocation().getLine(),shadow.getSourceLocation().getColumn());
  IRelationshipMap mapper=AsmManager.getDefault().getRelationshipMap();
  if (sourceHandle != null && targetHandle != null) {
    IRelationship foreward=mapper.get(sourceHandle,IRelationship.Kind.DECLARE,MATCHED_BY);
    foreward.getTargets().add(targetHandle);
    IRelationship back=mapper.get(targetHandle,IRelationship.Kind.DECLARE,MATCHES_DECLARE);
    back.getTargets().add(sourceHandle);
  }
}","public static void checkerMunger(IHierarchy model,Shadow shadow,Checker checker){
  if (shadow.getSourceLocation() == null || checker.getSourceLocation() == null)   return;
  String sourceHandle=ProgramElement.createHandleIdentifier(checker.getSourceLocation().getSourceFile(),checker.getSourceLocation().getLine(),checker.getSourceLocation().getColumn());
  String targetHandle=ProgramElement.createHandleIdentifier(shadow.getSourceLocation().getSourceFile(),shadow.getSourceLocation().getLine(),shadow.getSourceLocation().getColumn());
  IRelationshipMap mapper=AsmManager.getDefault().getRelationshipMap();
  if (sourceHandle != null && targetHandle != null) {
    IRelationship foreward=mapper.get(sourceHandle,IRelationship.Kind.DECLARE,MATCHED_BY);
    foreward.getTargets().add(targetHandle);
    IRelationship back=mapper.get(targetHandle,IRelationship.Kind.DECLARE,MATCHES_DECLARE);
    if (back != null && back.getTargets() != null) {
      back.getTargets().add(sourceHandle);
    }
  }
}",0.9685080020650492
9559,"/** 
 * Generate AjBuildConfig from the local configFile parameter plus global project and build options. Errors signalled using signal... methods.
 * @param configFile
 * @return null if invalid configuration, corresponding AjBuildConfig otherwise
 */
public AjBuildConfig genBuildConfig(String configFilePath){
  init();
  File configFile=new File(configFilePath);
  if (!configFile.exists()) {
    signalError(""String_Node_Str"" + configFile + ""String_Node_Str"");
    return null;
  }
  String[] args=new String[]{""String_Node_Str"" + configFile.getAbsolutePath()};
  CountingMessageHandler handler=CountingMessageHandler.makeCountingMessageHandler(messageHandler);
  BuildArgParser parser=new BuildArgParser();
  AjBuildConfig config=parser.genBuildConfig(args,handler,false,configFile);
  configureProjectOptions(config,Ajde.getDefault().getProjectProperties());
  AjBuildConfig global=new AjBuildConfig();
  BuildOptionsAdapter buildOptions=Ajde.getDefault().getBuildManager().getBuildOptions();
  if (!configureBuildOptions(global,buildOptions,handler)) {
    return null;
  }
  ProjectPropertiesAdapter projectOptions=Ajde.getDefault().getProjectProperties();
  configureProjectOptions(global,projectOptions);
  config.installGlobals(global);
  ISourceLocation location=null;
  if (config.getConfigFile() != null) {
    location=new SourceLocation(config.getConfigFile(),0);
  }
  String message=parser.getOtherMessages(true);
  if (null != message) {
    IMessage m=new Message(message,IMessage.ERROR,null,location);
    handler.handleMessage(m);
  }
  config.setGenerateModelMode(true);
  if (Ajde.getDefault().getBuildManager().getBuildOptions().getJavaOptionsMap() != null) {
    config.getJavaOptions().putAll(Ajde.getDefault().getBuildManager().getBuildOptions().getJavaOptionsMap());
  }
  return config;
}","/** 
 * Generate AjBuildConfig from the local configFile parameter plus global project and build options. Errors signalled using signal... methods.
 * @param configFile	
 * @return null if invalid configuration, corresponding AjBuildConfig otherwise
 */
public AjBuildConfig genBuildConfig(String configFilePath){
  init();
  File configFile=new File(configFilePath);
  if (!configFile.exists()) {
    Ajde.getDefault().getErrorHandler().handleError(""String_Node_Str"" + configFile + ""String_Node_Str"");
    return null;
  }
  String[] args=new String[]{""String_Node_Str"" + configFile.getAbsolutePath()};
  CountingMessageHandler handler=CountingMessageHandler.makeCountingMessageHandler(messageHandler);
  BuildArgParser parser=new BuildArgParser();
  AjBuildConfig config=parser.genBuildConfig(args,handler,false,configFile);
  configureProjectOptions(config,Ajde.getDefault().getProjectProperties());
  AjBuildConfig global=new AjBuildConfig();
  BuildOptionsAdapter buildOptions=Ajde.getDefault().getBuildManager().getBuildOptions();
  if (!configureBuildOptions(global,buildOptions,handler)) {
    return null;
  }
  ProjectPropertiesAdapter projectOptions=Ajde.getDefault().getProjectProperties();
  configureProjectOptions(global,projectOptions);
  config.installGlobals(global);
  ISourceLocation location=null;
  if (config.getConfigFile() != null) {
    location=new SourceLocation(config.getConfigFile(),0);
  }
  String message=parser.getOtherMessages(true);
  if (null != message) {
    IMessage m=new Message(message,IMessage.ERROR,null,location);
    handler.handleMessage(m);
  }
  config.setGenerateModelMode(true);
  if (Ajde.getDefault().getBuildManager().getBuildOptions().getJavaOptionsMap() != null) {
    config.getJavaOptions().putAll(Ajde.getDefault().getBuildManager().getBuildOptions().getJavaOptionsMap());
  }
  return config;
}",0.9866666666666668
9560,"public boolean compile(String configFile,BuildProgressMonitor progressMonitor,boolean buildModel){
  init();
  try {
    AjBuildConfig buildConfig=genBuildConfig(configFile);
    buildConfig.setGenerateModelMode(buildModel);
    if (null == buildConfig) {
      return false;
    }
    currNotifier=new BuildNotifierAdapter(progressMonitor);
    buildManager.setProgressListener(currNotifier);
    messageHandler.setBuildNotifierAdapter(currNotifier);
    String rtInfo=buildManager.checkRtJar(buildConfig);
    if (rtInfo != null) {
      signalWarning(""String_Node_Str"" + rtInfo + ""String_Node_Str"");
      return false;
    }
    boolean incrementalEnabled=buildConfig.isIncrementalMode() || buildConfig.isIncrementalFileMode();
    if (incrementalEnabled && nextBuild) {
      return buildManager.incrementalBuild(buildConfig,messageHandler);
    }
 else {
      if (incrementalEnabled) {
        nextBuild=incrementalEnabled;
      }
      return buildManager.batchBuild(buildConfig,messageHandler);
    }
  }
 catch (  OperationCanceledException ce) {
    signalWarning(""String_Node_Str"");
    return false;
  }
catch (  AbortException e) {
    final IMessage message=e.getIMessage();
    if (null == message) {
      signalThrown(e);
    }
 else     if (null != message.getMessage()) {
      signalWarning(message.getMessage());
    }
 else     if (null != message.getThrown()) {
      signalThrown(message.getThrown());
    }
 else {
      signalThrown(e);
    }
    return false;
  }
catch (  Throwable t) {
    signalThrown(t);
    return false;
  }
}","public boolean compile(String configFile,BuildProgressMonitor progressMonitor,boolean buildModel){
  if (configFile == null) {
    Ajde.getDefault().getErrorHandler().handleError(""String_Node_Str"");
  }
  init();
  try {
    AjBuildConfig buildConfig=genBuildConfig(configFile);
    buildConfig.setGenerateModelMode(buildModel);
    if (null == buildConfig) {
      return false;
    }
    currNotifier=new BuildNotifierAdapter(progressMonitor);
    buildManager.setProgressListener(currNotifier);
    messageHandler.setBuildNotifierAdapter(currNotifier);
    String rtInfo=buildManager.checkRtJar(buildConfig);
    if (rtInfo != null) {
      Ajde.getDefault().getErrorHandler().handleWarning(""String_Node_Str"" + rtInfo + ""String_Node_Str"");
      return false;
    }
    boolean incrementalEnabled=buildConfig.isIncrementalMode() || buildConfig.isIncrementalFileMode();
    if (incrementalEnabled && nextBuild) {
      return buildManager.incrementalBuild(buildConfig,messageHandler);
    }
 else {
      if (incrementalEnabled) {
        nextBuild=incrementalEnabled;
      }
      return buildManager.batchBuild(buildConfig,messageHandler);
    }
  }
 catch (  OperationCanceledException ce) {
    Ajde.getDefault().getErrorHandler().handleWarning(""String_Node_Str"");
    return false;
  }
catch (  AbortException e) {
    final IMessage message=e.getIMessage();
    if (null == message) {
      signalThrown(e);
    }
 else     if (null != message.getMessage()) {
      Ajde.getDefault().getErrorHandler().handleWarning(message.getMessage());
    }
 else     if (null != message.getThrown()) {
      signalThrown(message.getThrown());
    }
 else {
      signalThrown(e);
    }
    return false;
  }
catch (  Throwable t) {
    signalThrown(t);
    return false;
  }
}",0.9256148770245952
9561,"public void buildInterTypeAndPerClause(ClassScope classScope){
  factory=EclipseFactory.fromScopeLookupEnvironment(scope);
  if (isPrivileged) {
    binding.privilegedHandler=new PrivilegedHandler(this);
  }
  checkSpec(classScope);
  if (ignoreFurtherInvestigation)   return;
  buildPerClause(scope);
  if (methods != null) {
    for (int i=0; i < methods.length; i++) {
      if (methods[i] instanceof InterTypeDeclaration) {
        EclipseTypeMunger m=((InterTypeDeclaration)methods[i]).build(classScope);
        if (m != null)         concreteName.typeMungers.add(m);
      }
 else       if (methods[i] instanceof DeclareDeclaration) {
        Declare d=((DeclareDeclaration)methods[i]).build(classScope);
        if (d != null)         concreteName.declares.add(d);
      }
    }
  }
  factory.getWorld().getCrosscuttingMembersSet().addOrReplaceAspect(typeX);
  if (typeX.getSuperclass().isAspect() && !typeX.getSuperclass().isExposedToWeaver()) {
    factory.getWorld().getCrosscuttingMembersSet().addOrReplaceAspect(typeX.getSuperclass());
  }
}","public void buildInterTypeAndPerClause(ClassScope classScope){
  factory=EclipseFactory.fromScopeLookupEnvironment(scope);
  if (isPrivileged) {
    binding.privilegedHandler=new PrivilegedHandler(this);
  }
  checkSpec(classScope);
  if (ignoreFurtherInvestigation)   return;
  buildPerClause(scope);
  if (methods != null) {
    for (int i=0; i < methods.length; i++) {
      if (methods[i] instanceof InterTypeDeclaration) {
        EclipseTypeMunger m=((InterTypeDeclaration)methods[i]).build(classScope);
        if (m != null)         concreteName.typeMungers.add(m);
      }
 else       if (methods[i] instanceof DeclareDeclaration) {
        Declare d=((DeclareDeclaration)methods[i]).build(classScope);
        if (d != null)         concreteName.declares.add(d);
      }
    }
  }
  concreteName.getDeclaredPointcuts();
}",0.8424403183023873
9562,"public ResolvedPointcutDefinition makeResolvedPointcutDefinition(){
  ResolvedPointcutDefinition ret=new ResolvedPointcutDefinition(EclipseFactory.fromBinding(this.binding.declaringClass),declaredModifiers,declaredName,EclipseFactory.fromBindings(this.binding.parameters),getPointcut());
  ret.setPosition(sourceStart,sourceEnd);
  ret.setSourceContext(new EclipseSourceContext(compilationResult));
  return ret;
}","public ResolvedPointcutDefinition makeResolvedPointcutDefinition(){
  if (resolvedPointcutDeclaration != null)   return resolvedPointcutDeclaration;
  resolvedPointcutDeclaration=new ResolvedPointcutDefinition(EclipseFactory.fromBinding(this.binding.declaringClass),declaredModifiers,declaredName,EclipseFactory.fromBindings(this.binding.parameters),getPointcut());
  resolvedPointcutDeclaration.setPosition(sourceStart,sourceEnd);
  resolvedPointcutDeclaration.setSourceContext(new EclipseSourceContext(compilationResult));
  return resolvedPointcutDeclaration;
}",0.7791411042944786
9563,"public void resolveStatements(){
  if (isAbstract()) {
    this.modifiers|=AccSemicolonBody;
  }
  if (binding == null || ignoreFurtherInvestigation)   return;
  if (Modifier.isAbstract(this.declaredModifiers) && (pointcutDesignator != null)) {
    scope.problemReporter().signalError(sourceStart,sourceEnd,""String_Node_Str"");
    ignoreFurtherInvestigation=true;
    return;
  }
  if (pointcutDesignator != null) {
    pointcutDesignator.finishResolveTypes(this,this.binding,arguments.length,scope.enclosingSourceType());
  }
  super.resolveStatements();
}","public void resolveStatements(){
  if (isAbstract()) {
    this.modifiers|=AccSemicolonBody;
  }
  if (binding == null || ignoreFurtherInvestigation)   return;
  if (Modifier.isAbstract(this.declaredModifiers) && (pointcutDesignator != null)) {
    scope.problemReporter().signalError(sourceStart,sourceEnd,""String_Node_Str"");
    ignoreFurtherInvestigation=true;
    return;
  }
  if (pointcutDesignator != null) {
    pointcutDesignator.finishResolveTypes(this,this.binding,arguments.length,scope.enclosingSourceType());
  }
  makeResolvedPointcutDefinition();
  resolvedPointcutDeclaration.setPointcut(getPointcut());
  super.resolveStatements();
}",0.9221854304635762
9564,"public void completeTypeBindings(){
  stepCompleted=BUILD_TYPE_HIERARCHY;
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    units[i].scope.checkAndSetImports();
  }
  stepCompleted=CHECK_AND_SET_IMPORTS;
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    units[i].scope.connectTypeHierarchy();
  }
  stepCompleted=CONNECT_TYPE_HIERARCHY;
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    units[i].scope.buildFieldsAndMethods();
  }
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    SourceTypeBinding[] b=units[i].scope.topLevelTypes;
    for (int j=0; j < b.length; j++) {
      factory.addSourceTypeBinding(b[j]);
    }
  }
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    SourceTypeBinding[] b=units[i].scope.topLevelTypes;
    for (int j=0; j < b.length; j++) {
      buildInterTypeAndPerClause(b[j].scope);
    }
  }
  factory.finishTypeMungers();
  Collection typeMungers=factory.getTypeMungers();
  Collection declareParents=factory.getDeclareParents();
  doPendingWeaves();
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    weaveInterTypeDeclarations(units[i].scope,typeMungers,declareParents);
    units[i]=null;
  }
  stepCompleted=BUILD_FIELDS_AND_METHODS;
  lastCompletedUnitIndex=lastUnitIndex;
}","public void completeTypeBindings(){
  stepCompleted=BUILD_TYPE_HIERARCHY;
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    units[i].scope.checkAndSetImports();
  }
  stepCompleted=CHECK_AND_SET_IMPORTS;
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    units[i].scope.connectTypeHierarchy();
  }
  stepCompleted=CONNECT_TYPE_HIERARCHY;
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    units[i].scope.buildFieldsAndMethods();
  }
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    SourceTypeBinding[] b=units[i].scope.topLevelTypes;
    for (int j=0; j < b.length; j++) {
      factory.addSourceTypeBinding(b[j]);
    }
  }
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    SourceTypeBinding[] b=units[i].scope.topLevelTypes;
    for (int j=0; j < b.length; j++) {
      buildInterTypeAndPerClause(b[j].scope);
    }
  }
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    SourceTypeBinding[] b=units[i].scope.topLevelTypes;
    for (int j=0; j < b.length; j++) {
      resolvePointcutDeclarations(b[j].scope);
    }
  }
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    SourceTypeBinding[] b=units[i].scope.topLevelTypes;
    for (int j=0; j < b.length; j++) {
      addCrosscuttingStructures(b[j].scope);
    }
  }
  factory.finishTypeMungers();
  Collection typeMungers=factory.getTypeMungers();
  Collection declareParents=factory.getDeclareParents();
  doPendingWeaves();
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    weaveInterTypeDeclarations(units[i].scope,typeMungers,declareParents);
    units[i]=null;
  }
  stepCompleted=BUILD_FIELDS_AND_METHODS;
  lastCompletedUnitIndex=lastUnitIndex;
}",0.8595253367543297
9565,"public void completeTypeBindings(){
  stepCompleted=BUILD_TYPE_HIERARCHY;
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    units[i].scope.checkAndSetImports();
  }
  stepCompleted=CHECK_AND_SET_IMPORTS;
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    units[i].scope.connectTypeHierarchy();
  }
  stepCompleted=CONNECT_TYPE_HIERARCHY;
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    units[i].scope.buildFieldsAndMethods();
  }
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    SourceTypeBinding[] b=units[i].scope.topLevelTypes;
    for (int j=0; j < b.length; j++) {
      factory.addSourceTypeBinding(b[j]);
    }
  }
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    SourceTypeBinding[] b=units[i].scope.topLevelTypes;
    for (int j=0; j < b.length; j++) {
      buildInterTypeAndPerClause(b[j].scope);
    }
  }
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    SourceTypeBinding[] b=units[i].scope.topLevelTypes;
    for (int j=0; j < b.length; j++) {
      resolvePointcutDeclarations(b[j].scope);
    }
  }
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    SourceTypeBinding[] b=units[i].scope.topLevelTypes;
    for (int j=0; j < b.length; j++) {
      addCrosscuttingStructures(b[j].scope);
    }
  }
  factory.finishTypeMungers();
  Collection typeMungers=factory.getTypeMungers();
  Collection declareParents=factory.getDeclareParents();
  doPendingWeaves();
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    weaveInterTypeDeclarations(units[i].scope,typeMungers,declareParents);
    units[i]=null;
  }
  stepCompleted=BUILD_FIELDS_AND_METHODS;
  lastCompletedUnitIndex=lastUnitIndex;
}","public void completeTypeBindings(){
  stepCompleted=BUILD_TYPE_HIERARCHY;
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    units[i].scope.checkAndSetImports();
  }
  stepCompleted=CHECK_AND_SET_IMPORTS;
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    units[i].scope.connectTypeHierarchy();
  }
  stepCompleted=CONNECT_TYPE_HIERARCHY;
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    units[i].scope.buildFieldsAndMethods();
  }
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    SourceTypeBinding[] b=units[i].scope.topLevelTypes;
    for (int j=0; j < b.length; j++) {
      factory.addSourceTypeBinding(b[j]);
    }
  }
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    SourceTypeBinding[] b=units[i].scope.topLevelTypes;
    for (int j=0; j < b.length; j++) {
      buildInterTypeAndPerClause(b[j].scope);
      addCrosscuttingStructures(b[j].scope);
    }
  }
  factory.finishTypeMungers();
  Collection typeMungers=factory.getTypeMungers();
  Collection declareParents=factory.getDeclareParents();
  doPendingWeaves();
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    weaveInterTypeDeclarations(units[i].scope,typeMungers,declareParents);
  }
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    SourceTypeBinding[] b=units[i].scope.topLevelTypes;
    for (int j=0; j < b.length; j++) {
      resolvePointcutDeclarations(b[j].scope);
    }
  }
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    SourceTypeBinding[] b=units[i].scope.topLevelTypes;
    for (int j=0; j < b.length; j++) {
      addAdviceLikeDeclares(b[j].scope);
    }
  }
  for (int i=lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
    units[i]=null;
  }
  stepCompleted=BUILD_FIELDS_AND_METHODS;
  lastCompletedUnitIndex=lastUnitIndex;
}",0.7206323248841646
9566,"public String toLinkLabelString(){
  String label;
  if (kind == Kind.CODE || kind == Kind.INITIALIZER) {
    label=parent.getParent().getName() + ""String_Node_Str"";
  }
 else   if (kind.isInterTypeMemberKind()) {
    int dotIndex=name.indexOf('.');
    if (dotIndex != -1) {
      return parent.getName() + ""String_Node_Str"" + toLabelString().substring(dotIndex + 1);
    }
 else {
      label=parent.getName() + '.';
    }
  }
 else   if (kind == Kind.CLASS || kind == Kind.ASPECT) {
    label=""String_Node_Str"";
  }
 else {
    label=parent.getName() + '.';
  }
  label+=toLabelString();
  return label;
}","/** 
 * TODO: move the ""parent != null""==>injar heuristic to more explicit 
 */
public String toLinkLabelString(){
  String label;
  if (kind == Kind.CODE || kind == Kind.INITIALIZER) {
    label=parent.getParent().getName() + ""String_Node_Str"";
  }
 else   if (kind.isInterTypeMemberKind()) {
    int dotIndex=name.indexOf('.');
    if (dotIndex != -1) {
      return parent.getName() + ""String_Node_Str"" + toLabelString().substring(dotIndex + 1);
    }
 else {
      label=parent.getName() + '.';
    }
  }
 else   if (kind == Kind.CLASS || kind == Kind.ASPECT) {
    label=""String_Node_Str"";
  }
 else {
    if (parent != null) {
      label=parent.getName() + '.';
    }
 else {
      label=""String_Node_Str"";
    }
  }
  label+=toLabelString();
  return label;
}",0.8843636363636364
9567,"private PerClause.Kind lookupPerClauseKind(ReferenceBinding binding){
  if (binding instanceof SourceTypeBinding && !(binding instanceof BinaryTypeBinding)) {
    SourceTypeBinding sourceSc=(SourceTypeBinding)binding;
    if (sourceSc.scope.referenceContext instanceof AspectDeclaration) {
      PerClause perClause=((AspectDeclaration)sourceSc.scope.referenceContext).perClause;
      if (perClause == null)       return lookupPerClauseKind(binding.superclass());
 else       return perClause.getKind();
    }
 else {
      return null;
    }
  }
 else {
    return null;
  }
}","private PerClause.Kind lookupPerClauseKind(ReferenceBinding binding){
  PerClause perClause;
  if (binding instanceof BinaryTypeBinding) {
    ResolvedTypeX superTypeX=factory.fromEclipse(binding);
    perClause=superTypeX.getPerClause();
  }
 else   if (binding instanceof SourceTypeBinding) {
    SourceTypeBinding sourceSc=(SourceTypeBinding)binding;
    if (sourceSc.scope.referenceContext instanceof AspectDeclaration) {
      perClause=((AspectDeclaration)sourceSc.scope.referenceContext).perClause;
    }
 else {
      return null;
    }
  }
 else {
    return null;
  }
  if (perClause == null) {
    return lookupPerClauseKind(binding.superclass());
  }
 else {
    return perClause.getKind();
  }
}",0.432348367029549
9568,"/** 
 * @return a String suitable as an inlined DOCTYPE statement 
 */
public static String inlineDocType(){
  return ""String_Node_Str"" + AjcTest.Suite.Spec.XMLNAME + ""String_Node_Str""+ AjcSpecXmlReader.getDocType()+ EOL+ ""String_Node_Str"";
}","/** 
 * @deprecated
 * @return a String suitable as an inlined DOCTYPE statement 
 */
public static String inlineDocType(){
  return ""String_Node_Str"" + AjcTest.Suite.Spec.XMLNAME + ""String_Node_Str""+ AjcSpecXmlReader.getDocType()+ EOL+ ""String_Node_Str"";
}",0.969939879759519
9569,"/** 
 * Write a DTD to dtdFile.
 * @param dtdFile the File to write to
 */
public static void writeDTD(File dtdFile) throws IOException {
  LangUtil.throwIaxIfNull(dtdFile,""String_Node_Str"");
  PrintWriter out=new PrintWriter(new FileWriter(dtdFile));
  try {
    out.println(""String_Node_Str"" + AjcSpecXmlReader.class.getName() + ""String_Node_Str"");
    out.println(getDocType());
  }
  finally {
    out.close();
  }
}","/** 
 * Write a DTD to dtdFile.
 * @deprecated
 * @param dtdFile the File to write to
 */
public static void writeDTD(File dtdFile) throws IOException {
  LangUtil.throwIaxIfNull(dtdFile,""String_Node_Str"");
  PrintWriter out=new PrintWriter(new FileWriter(dtdFile));
  try {
    out.println(""String_Node_Str"" + AjcSpecXmlReader.class.getName() + ""String_Node_Str"");
    out.println(getDocType());
  }
  finally {
    out.close();
  }
}",0.9824561403508772
9570,"/** 
 * Read the specifications for a suite of AjcTest from an XML file. This also sets the suite dir in the specification.
 * @param file the File must be readable, comply with DOCTYPE.
 * @return AjcTest.Suite.Spec read from file
 * @see setLogLevel(int)
 */
public AjcTest.Suite.Spec readAjcSuite(File file) throws IOException, AbortException {
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  System.setProperty(""String_Node_Str"",LOG[logLevel]);
  final Digester digester=new Digester();
  setupDigester(digester);
  SuiteHolder holder=new SuiteHolder();
  digester.push(holder);
  FileInputStream input=new FileInputStream(file);
  try {
    digester.parse(input);
  }
 catch (  SAXException e) {
    MessageUtil.fail(""String_Node_Str"" + file,e);
  }
 finally {
    if (null != input) {
      input.close();
      input=null;
    }
  }
  AjcTest.Suite.Spec result=holder.spec;
  if (null != result) {
    file=file.getAbsoluteFile();
    result.setSourceLocation(new SourceLocation(file,1));
    File suiteDir=file.getParentFile();
    if (null == suiteDir) {
      suiteDir=new File(""String_Node_Str"");
    }
    result.setSuiteDirFile(suiteDir);
    if (result.runtime.isVerbose()) {
      RunUtils.enableVerbose(result);
    }
  }
  return result;
}","/** 
 * Read the specifications for a suite of AjcTest from an XML file. This also sets the suite dir in the specification.
 * @param file the File must be readable, comply with DOCTYPE.
 * @return AjcTest.Suite.Spec read from file
 * @see setLogLevel(int)
 */
public AjcTest.Suite.Spec readAjcSuite(File file) throws IOException, AbortException {
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  System.setProperty(""String_Node_Str"",LOG[logLevel]);
  final Digester digester=makeDigester(file);
  SuiteHolder holder=new SuiteHolder();
  digester.push(holder);
  FileInputStream input=new FileInputStream(file);
  try {
    digester.parse(input);
  }
 catch (  SAXException e) {
    MessageUtil.fail(""String_Node_Str"" + file,e);
  }
 finally {
    if (null != input) {
      input.close();
      input=null;
    }
  }
  AjcTest.Suite.Spec result=holder.spec;
  if (null != result) {
    file=file.getAbsoluteFile();
    result.setSourceLocation(new SourceLocation(file,1));
    File suiteDir=file.getParentFile();
    if (null == suiteDir) {
      suiteDir=new File(""String_Node_Str"");
    }
    result.setSuiteDirFile(suiteDir);
    if (result.runtime.isVerbose()) {
      RunUtils.enableVerbose(result);
    }
  }
  return result;
}",0.984493041749503
9571,"/** 
 * @return the elements of a document type as a String,using EOL as a line delimiter
 */
public static String getDocType(){
  if (true) {
    throw new Error(""String_Node_Str"");
  }
  StringBuffer r=new StringBuffer();
  final String suiteX=AjcTest.Suite.Spec.XMLNAME;
  final String ajctestX=AjcTest.Spec.XMLNAME;
  final String compileX=CompilerRun.Spec.XMLNAME;
  final String inccompileX=IncCompilerRun.Spec.XMLNAME;
  final String runX=JavaRun.Spec.XMLNAME;
  final String dirchangesX=DirChanges.Spec.XMLNAME;
  final String messageX=SoftMessage.XMLNAME;
  r.append(EOL + ""String_Node_Str"" + suiteX+ ""String_Node_Str""+ ajctestX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + suiteX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + ajctestX+ ""String_Node_Str""+ compileX+ ""String_Node_Str""+ compileX+ ""String_Node_Str""+ inccompileX+ ""String_Node_Str""+ runX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + ajctestX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + ajctestX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + ajctestX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + ajctestX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + compileX+ ""String_Node_Str""+ dirchangesX+ ""String_Node_Str""+ messageX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + compileX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + compileX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + compileX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + inccompileX+ ""String_Node_Str""+ dirchangesX+ ""String_Node_Str""+ messageX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + inccompileX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + runX+ ""String_Node_Str""+ dirchangesX+ ""String_Node_Str""+ messageX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + runX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + runX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + runX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + messageX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + messageX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + messageX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + messageX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + messageX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + dirchangesX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + dirchangesX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + dirchangesX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + dirchangesX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + dirchangesX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + dirchangesX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + dirchangesX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"");
  return r.toString();
}","/** 
 * @deprecated
 * @return the elements of a document type as a String,using EOL as a line delimiter
 */
public static String getDocType(){
  if (true) {
    throw new Error(""String_Node_Str"");
  }
  StringBuffer r=new StringBuffer();
  final String suiteX=AjcTest.Suite.Spec.XMLNAME;
  final String ajctestX=AjcTest.Spec.XMLNAME;
  final String compileX=CompilerRun.Spec.XMLNAME;
  final String inccompileX=IncCompilerRun.Spec.XMLNAME;
  final String runX=JavaRun.Spec.XMLNAME;
  final String dirchangesX=DirChanges.Spec.XMLNAME;
  final String messageX=SoftMessage.XMLNAME;
  r.append(EOL + ""String_Node_Str"" + suiteX+ ""String_Node_Str""+ ajctestX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + suiteX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + ajctestX+ ""String_Node_Str""+ compileX+ ""String_Node_Str""+ compileX+ ""String_Node_Str""+ inccompileX+ ""String_Node_Str""+ runX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + ajctestX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + ajctestX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + ajctestX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + ajctestX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + compileX+ ""String_Node_Str""+ dirchangesX+ ""String_Node_Str""+ messageX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + compileX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + compileX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + compileX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + inccompileX+ ""String_Node_Str""+ dirchangesX+ ""String_Node_Str""+ messageX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + inccompileX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + runX+ ""String_Node_Str""+ dirchangesX+ ""String_Node_Str""+ messageX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + runX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + runX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + runX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + messageX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + messageX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + messageX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + messageX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + messageX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + dirchangesX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + dirchangesX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + dirchangesX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + dirchangesX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + dirchangesX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + dirchangesX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"" + dirchangesX+ ""String_Node_Str"");
  r.append(EOL + ""String_Node_Str"");
  return r.toString();
}",0.9976876830584246
9572,"/** 
 * Assumes ""public"" visibility for the icon.
 * @return	null if the kind could not be resolved
 */
public AbstractIcon getIcon(IProgramElement.Kind kind){
  if (kind == IProgramElement.Kind.PROJECT) {
    return PROJECT;
  }
 else   if (kind == IProgramElement.Kind.PACKAGE) {
    return PACKAGE;
  }
 else   if (kind == IProgramElement.Kind.FILE) {
    return FILE;
  }
 else   if (kind == IProgramElement.Kind.FILE_JAVA) {
    return FILE_JAVA;
  }
 else   if (kind == IProgramElement.Kind.FILE_ASPECTJ) {
    return FILE_ASPECTJ;
  }
 else   if (kind == IProgramElement.Kind.FILE_LST) {
    return FILE_LST;
  }
 else   if (kind == IProgramElement.Kind.CLASS) {
    return CLASS;
  }
 else   if (kind == IProgramElement.Kind.INTERFACE) {
    return INTERFACE;
  }
 else   if (kind == IProgramElement.Kind.ASPECT) {
    return ASPECT;
  }
 else   if (kind == IProgramElement.Kind.INITIALIZER) {
    return INITIALIZER;
  }
 else   if (kind == IProgramElement.Kind.INTER_TYPE_CONSTRUCTOR) {
    return INTRODUCTION;
  }
 else   if (kind == IProgramElement.Kind.INTER_TYPE_FIELD) {
    return INTRODUCTION;
  }
 else   if (kind == IProgramElement.Kind.INTER_TYPE_METHOD) {
    return INTRODUCTION;
  }
 else   if (kind == IProgramElement.Kind.CONSTRUCTOR) {
    return CONSTRUCTOR;
  }
 else   if (kind == IProgramElement.Kind.METHOD) {
    return METHOD;
  }
 else   if (kind == IProgramElement.Kind.FIELD) {
    return FIELD;
  }
 else   if (kind == IProgramElement.Kind.POINTCUT) {
    return POINTCUT;
  }
 else   if (kind == IProgramElement.Kind.ADVICE) {
    return ADVICE;
  }
 else   if (kind == IProgramElement.Kind.DECLARE_PARENTS) {
    return DECLARE_PARENTS;
  }
 else   if (kind == IProgramElement.Kind.DECLARE_WARNING) {
    return DECLARE_WARNING;
  }
 else   if (kind == IProgramElement.Kind.DECLARE_ERROR) {
    return DECLARE_ERROR;
  }
 else   if (kind == IProgramElement.Kind.DECLARE_SOFT) {
    return DECLARE_SOFT;
  }
 else   if (kind == IProgramElement.Kind.DECLARE_PRECEDENCE) {
    return DECLARE_SOFT;
  }
 else   if (kind == IProgramElement.Kind.CODE) {
    return CODE;
  }
 else   if (kind == IProgramElement.Kind.ERROR) {
    return ERROR;
  }
 else {
    System.err.println(""String_Node_Str"" + kind);
    return null;
  }
}","/** 
 * Assumes ""public"" visibility for the icon.
 * @return	null if the kind could not be resolved
 */
public AbstractIcon getIcon(IProgramElement.Kind kind){
  if (kind == IProgramElement.Kind.PROJECT) {
    return PROJECT;
  }
 else   if (kind == IProgramElement.Kind.PACKAGE) {
    return PACKAGE;
  }
 else   if (kind == IProgramElement.Kind.FILE) {
    return FILE;
  }
 else   if (kind == IProgramElement.Kind.FILE_JAVA) {
    return FILE_JAVA;
  }
 else   if (kind == IProgramElement.Kind.FILE_ASPECTJ) {
    return FILE_ASPECTJ;
  }
 else   if (kind == IProgramElement.Kind.FILE_LST) {
    return FILE_LST;
  }
 else   if (kind == IProgramElement.Kind.CLASS) {
    return CLASS;
  }
 else   if (kind == IProgramElement.Kind.INTERFACE) {
    return INTERFACE;
  }
 else   if (kind == IProgramElement.Kind.ASPECT) {
    return ASPECT;
  }
 else   if (kind == IProgramElement.Kind.INITIALIZER) {
    return INITIALIZER;
  }
 else   if (kind == IProgramElement.Kind.INTER_TYPE_CONSTRUCTOR) {
    return INTRODUCTION;
  }
 else   if (kind == IProgramElement.Kind.INTER_TYPE_FIELD) {
    return INTRODUCTION;
  }
 else   if (kind == IProgramElement.Kind.INTER_TYPE_METHOD) {
    return INTRODUCTION;
  }
 else   if (kind == IProgramElement.Kind.CONSTRUCTOR) {
    return CONSTRUCTOR;
  }
 else   if (kind == IProgramElement.Kind.METHOD) {
    return METHOD;
  }
 else   if (kind == IProgramElement.Kind.FIELD) {
    return FIELD;
  }
 else   if (kind == IProgramElement.Kind.POINTCUT) {
    return POINTCUT;
  }
 else   if (kind == IProgramElement.Kind.ADVICE) {
    return ADVICE;
  }
 else   if (kind == IProgramElement.Kind.DECLARE_PARENTS) {
    return DECLARE_PARENTS;
  }
 else   if (kind == IProgramElement.Kind.DECLARE_WARNING) {
    return DECLARE_WARNING;
  }
 else   if (kind == IProgramElement.Kind.DECLARE_ERROR) {
    return DECLARE_ERROR;
  }
 else   if (kind == IProgramElement.Kind.DECLARE_SOFT) {
    return DECLARE_SOFT;
  }
 else   if (kind == IProgramElement.Kind.DECLARE_PRECEDENCE) {
    return DECLARE_SOFT;
  }
 else   if (kind == IProgramElement.Kind.CODE) {
    return CODE;
  }
 else   if (kind == IProgramElement.Kind.ERROR) {
    return ERROR;
  }
 else   if (kind == IProgramElement.Kind.IMPORT_REFERENCE) {
    return RELATION_REFERENCE_FORWARD;
  }
 else {
    System.err.println(""String_Node_Str"" + kind);
    return null;
  }
}",0.977518374405534
9573,"public int compare(Object o1,Object o2){
  IProgramElement sv1=((IStructureViewNode)o1).getStructureNode();
  IProgramElement sv2=((IStructureViewNode)o2).getStructureNode();
  if (sv1 instanceof IProgramElement && sv2 instanceof IProgramElement) {
    IProgramElement p1=(IProgramElement)sv1;
    IProgramElement p2=(IProgramElement)sv2;
    if (p1.getSourceLocation() == null) {
      return 0;
    }
 else     if (p1.getSourceLocation().getLine() < p2.getSourceLocation().getLine()) {
      return -1;
    }
 else {
      return 1;
    }
  }
 else {
    return 0;
  }
}","public int compare(Object o1,Object o2){
  IProgramElement sv1=((IStructureViewNode)o1).getStructureNode();
  IProgramElement sv2=((IStructureViewNode)o2).getStructureNode();
  if (sv1 instanceof IProgramElement && sv2 instanceof IProgramElement) {
    IProgramElement p1=(IProgramElement)sv1;
    IProgramElement p2=(IProgramElement)sv2;
    if (p2.getKind() == IProgramElement.Kind.IMPORT_REFERENCE)     return 1;
    if (p1.getKind() == IProgramElement.Kind.IMPORT_REFERENCE)     return -1;
    if (p1.getSourceLocation() == null || p2.getSourceLocation() == null) {
      return 0;
    }
 else     if (p1.getSourceLocation().getLine() < p2.getSourceLocation().getLine()) {
      return -1;
    }
 else {
      return 1;
    }
  }
 else {
    return 0;
  }
}",0.8582145536384096
9574,"private void expandTree(int depth){
  for (int i=0; i < structureTree.getRowCount(); i++) {
    TreePath path=structureTree.getPathForRow(i);
    SwingTreeViewNode node=(SwingTreeViewNode)path.getLastPathComponent();
    if (path.getPath().length - 1 > depth || node.getUserObject() instanceof IRelationship) {
      structureTree.collapsePath(path);
    }
 else {
      structureTree.expandPath(path);
    }
  }
  structureTree.expandPath(structureTree.getPathForRow(0));
}","private void expandTree(int depth){
  for (int i=0; i < structureTree.getRowCount(); i++) {
    TreePath path=structureTree.getPathForRow(i);
    SwingTreeViewNode node=(SwingTreeViewNode)path.getLastPathComponent();
    if (path.getPath().length - 1 > depth || node.getKind() == IStructureViewNode.Kind.RELATIONSHIP) {
      structureTree.collapsePath(path);
    }
 else {
      structureTree.expandPath(path);
    }
  }
  structureTree.expandPath(structureTree.getPathForRow(0));
}",0.9174503657262278
9575,"private void highlightNode(SwingTreeViewNode parent,IProgramElement node){
  for (int i=0; i < parent.getChildCount(); i++) {
    SwingTreeViewNode currNode=(SwingTreeViewNode)parent.getChildAt(i);
    IProgramElement sNode=(IProgramElement)currNode.getUserObject();
    if (sNode instanceof IProgramElement && ((IProgramElement)sNode).equals(node)) {
      TreePath path=new TreePath(currNode.getPath());
      structureTree.setSelectionPath(path);
      int currRow=structureTree.getRowForPath(path);
      structureTree.expandRow(currRow);
      structureTree.scrollRowToVisible(currRow);
    }
 else {
      highlightNode(currNode,node);
    }
  }
}","private void highlightNode(SwingTreeViewNode parent,IProgramElement node){
  for (int i=0; i < parent.getChildCount(); i++) {
    SwingTreeViewNode currNode=(SwingTreeViewNode)parent.getChildAt(i);
    IProgramElement sNode=(IProgramElement)currNode.getStructureNode();
    if (sNode != null && sNode.equals(node) && currNode.getKind() != IStructureViewNode.Kind.LINK) {
      TreePath path=new TreePath(currNode.getPath());
      structureTree.setSelectionPath(path);
      int currRow=structureTree.getRowForPath(path);
      structureTree.expandRow(currRow);
      structureTree.scrollRowToVisible(currRow);
    }
 else {
      highlightNode(currNode,node);
    }
  }
}",0.8769811320754717
9576,"public void setActiveNode(IStructureViewNode node,int lineOffset){
  if (node == null)   return;
  if (!(node.getStructureNode() instanceof IProgramElement))   return;
  IProgramElement pNode=(IProgramElement)node.getStructureNode();
  treeManager.highlightNode(pNode);
  if (pNode.getSourceLocation() != null) {
    Ajde.getDefault().getEditorAdapter().showSourceLine(pNode.getSourceLocation().getSourceFile().getAbsolutePath(),pNode.getSourceLocation().getLine() + lineOffset,true);
  }
}","public void setActiveNode(IStructureViewNode node,int lineOffset){
  if (node == null)   return;
  IProgramElement pNode=(IProgramElement)node.getStructureNode();
  treeManager.highlightNode(pNode);
  if (pNode.getSourceLocation() != null) {
    Ajde.getDefault().getEditorAdapter().showSourceLine(pNode.getSourceLocation().getSourceFile().getAbsolutePath(),pNode.getSourceLocation().getLine() + lineOffset,true);
  }
}",0.921892189218922
9577,"public void test(){
  String testLstFile=""String_Node_Str"";
  File f=new File(testLstFile);
  assertTrue(testLstFile,f.canRead());
  assertTrue(""String_Node_Str"" + testLstFile,verifyAgainstSavedModel(testLstFile));
}","public void test(){
  String testLstFile=""String_Node_Str"";
  File f=new File(testLstFile);
  assertTrue(testLstFile,f.canRead());
}",0.7586206896551724
9578,"public void testFileNodeFind() throws IOException {
  File testFile=openFile(""String_Node_Str"");
  IProgramElement node=Ajde.getDefault().getStructureModelManager().getHierarchy().findElementForSourceLine(testFile.getCanonicalPath(),1);
  assertTrue(""String_Node_Str"",node != null);
  assertEquals(""String_Node_Str"",2,node.getChildren().size());
  IProgramElement pNode=(IProgramElement)node;
  assertTrue(""String_Node_Str"" + pNode.getName(),pNode.getKind().equals(IProgramElement.Kind.FILE_JAVA));
}","public void testFileNodeFind() throws IOException {
  File testFile=openFile(""String_Node_Str"");
  IProgramElement node=Ajde.getDefault().getStructureModelManager().getHierarchy().findElementForSourceLine(testFile.getCanonicalPath(),1);
  assertTrue(""String_Node_Str"",node != null);
  assertEquals(""String_Node_Str"",3,node.getChildren().size());
  IProgramElement pNode=(IProgramElement)node;
  assertTrue(""String_Node_Str"" + pNode.getName(),pNode.getKind().equals(IProgramElement.Kind.FILE_JAVA));
}",0.998
9579,"public void testPointcutName() throws IOException {
  File testFile=openFile(""String_Node_Str"");
  IProgramElement node=Ajde.getDefault().getStructureModelManager().getHierarchy().findElementForSourceFile(testFile.getAbsolutePath());
  assertTrue(""String_Node_Str"",node != null);
  IProgramElement pNode=(IProgramElement)((IProgramElement)node).getChildren().get(1);
  IProgramElement pointcut=(IProgramElement)pNode.getChildren().get(0);
  assertTrue(""String_Node_Str"",pointcut.getKind().equals(IProgramElement.Kind.POINTCUT));
  assertTrue(""String_Node_Str"" + pointcut.getName(),pointcut.toLabelString().equals(""String_Node_Str""));
}","public void testPointcutName() throws IOException {
  File testFile=openFile(""String_Node_Str"");
  IProgramElement node=Ajde.getDefault().getStructureModelManager().getHierarchy().findElementForSourceFile(testFile.getAbsolutePath());
  assertTrue(""String_Node_Str"",node != null);
  IProgramElement pNode=(IProgramElement)((IProgramElement)node).getChildren().get(2);
  IProgramElement pointcut=(IProgramElement)pNode.getChildren().get(0);
  assertTrue(""String_Node_Str"",pointcut.getKind().equals(IProgramElement.Kind.POINTCUT));
  assertTrue(""String_Node_Str"" + pointcut.getName(),pointcut.toLabelString().equals(""String_Node_Str""));
}",0.9984251968503935
9580,"public void testRootForSourceFile() throws IOException {
  File testFile=openFile(""String_Node_Str"");
  IProgramElement node=Ajde.getDefault().getStructureModelManager().getHierarchy().findElementForSourceFile(testFile.getAbsolutePath());
  assertTrue(""String_Node_Str"",node != null);
  IProgramElement pNode=(IProgramElement)node;
  String child=((IProgramElement)pNode.getChildren().get(0)).getName();
  assertTrue(""String_Node_Str"" + child,child.equals(""String_Node_Str""));
}","public void testRootForSourceFile() throws IOException {
  File testFile=openFile(""String_Node_Str"");
  IProgramElement node=Ajde.getDefault().getStructureModelManager().getHierarchy().findElementForSourceFile(testFile.getAbsolutePath());
  assertTrue(""String_Node_Str"",node != null);
  IProgramElement pNode=(IProgramElement)node;
  String child=((IProgramElement)pNode.getChildren().get(1)).getName();
  assertTrue(""String_Node_Str"" + child,child.equals(""String_Node_Str""));
}",0.997907949790795
9581,"private static List genModifiers(int modifiers){
  List modifiersList=new ArrayList();
  if ((modifiers & AccStatic) != 0)   modifiersList.add(IProgramElement.Modifiers.STATIC);
  if ((modifiers & AccFinal) != 0)   modifiersList.add(IProgramElement.Modifiers.STATIC);
  if ((modifiers & AccSynchronized) != 0)   modifiersList.add(IProgramElement.Modifiers.STATIC);
  if ((modifiers & AccVolatile) != 0)   modifiersList.add(IProgramElement.Modifiers.STATIC);
  if ((modifiers & AccTransient) != 0)   modifiersList.add(IProgramElement.Modifiers.STATIC);
  if ((modifiers & AccNative) != 0)   modifiersList.add(IProgramElement.Modifiers.STATIC);
  if ((modifiers & AccAbstract) != 0)   modifiersList.add(IProgramElement.Modifiers.STATIC);
  return modifiersList;
}","private static List genModifiers(int modifiers){
  List modifiersList=new ArrayList();
  if ((modifiers & AccStatic) != 0)   modifiersList.add(IProgramElement.Modifiers.STATIC);
  if ((modifiers & AccFinal) != 0)   modifiersList.add(IProgramElement.Modifiers.FINAL);
  if ((modifiers & AccSynchronized) != 0)   modifiersList.add(IProgramElement.Modifiers.SYNCHRONIZED);
  if ((modifiers & AccVolatile) != 0)   modifiersList.add(IProgramElement.Modifiers.VOLATILE);
  if ((modifiers & AccTransient) != 0)   modifiersList.add(IProgramElement.Modifiers.TRANSIENT);
  if ((modifiers & AccNative) != 0)   modifiersList.add(IProgramElement.Modifiers.NATIVE);
  if ((modifiers & AccAbstract) != 0)   modifiersList.add(IProgramElement.Modifiers.ABSTRACT);
  return modifiersList;
}",0.9530638852672751
9582,"/** 
 * Called only by  build(CompilationUnitDeclaration unit, StructureModel structureModel) 
 */
private void internalBuild(CompilationUnitDeclaration unit,IHierarchy structureModel){
  LangUtil.throwIaxIfNull(structureModel,""String_Node_Str"");
  if (!currCompilationResult.equals(unit.compilationResult())) {
    throw new IllegalArgumentException(""String_Node_Str"" + unit);
  }
  final File file=new File(new String(unit.getFileName()));
  final IProgramElement cuNode;
{
    int startLine=getStartLine(unit);
    int endLine=getEndLine(unit);
    ISourceLocation sourceLocation=new SourceLocation(file,startLine,endLine);
    cuNode=new ProgramElement(new String(file.getName()),IProgramElement.Kind.FILE_JAVA,sourceLocation,0,""String_Node_Str"",new ArrayList());
  }
  final IProgramElement addToNode=genAddToNode(unit,structureModel);
  for (ListIterator itt=addToNode.getChildren().listIterator(); itt.hasNext(); ) {
    IProgramElement child=(IProgramElement)itt.next();
    ISourceLocation childLoc=child.getSourceLocation();
    if (null == childLoc) {
    }
 else     if (childLoc.getSourceFile().equals(file)) {
      itt.remove();
    }
  }
  addToNode.addChild(cuNode);
  stack.push(cuNode);
  unit.traverse(this,unit.scope);
  try {
    structureModel.addToFileMap(file.getCanonicalPath(),cuNode);
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + e.getMessage() + ""String_Node_Str""+ file);
  }
}","/** 
 * Called only by  build(CompilationUnitDeclaration unit, StructureModel structureModel) 
 */
private void internalBuild(CompilationUnitDeclaration unit,IHierarchy structureModel){
  LangUtil.throwIaxIfNull(structureModel,""String_Node_Str"");
  if (!currCompilationResult.equals(unit.compilationResult())) {
    throw new IllegalArgumentException(""String_Node_Str"" + unit);
  }
  final File file=new File(new String(unit.getFileName()));
  final IProgramElement cuNode;
{
    int startLine=getStartLine(unit);
    int endLine=getEndLine(unit);
    ISourceLocation sourceLocation=new SourceLocation(file,startLine,endLine);
    cuNode=new ProgramElement(new String(file.getName()),IProgramElement.Kind.FILE_JAVA,sourceLocation,0,""String_Node_Str"",new ArrayList());
  }
  cuNode.addChild(new ProgramElement(""String_Node_Str"",IProgramElement.Kind.IMPORT_REFERENCE,null,0,""String_Node_Str"",new ArrayList()));
  final IProgramElement addToNode=genAddToNode(unit,structureModel);
  for (ListIterator itt=addToNode.getChildren().listIterator(); itt.hasNext(); ) {
    IProgramElement child=(IProgramElement)itt.next();
    ISourceLocation childLoc=child.getSourceLocation();
    if (null == childLoc) {
    }
 else     if (childLoc.getSourceFile().equals(file)) {
      itt.remove();
    }
  }
  addToNode.addChild(cuNode);
  stack.push(cuNode);
  unit.traverse(this,unit.scope);
  try {
    structureModel.addToFileMap(file.getCanonicalPath(),cuNode);
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + e.getMessage() + ""String_Node_Str""+ file);
  }
}",0.9544396408380446
9583,"public static void checkerMunger(IHierarchy model,Shadow shadow,Checker checker){
  if (shadow.getSourceLocation() == null || checker == null)   return;
  String sourceHandle=ProgramElement.createHandleIdentifier(checker.getSourceLocation().getSourceFile(),checker.getSourceLocation().getLine(),checker.getSourceLocation().getColumn());
  String targetHandle=ProgramElement.createHandleIdentifier(shadow.getSourceLocation().getSourceFile(),shadow.getSourceLocation().getLine(),shadow.getSourceLocation().getColumn());
  IRelationshipMap mapper=AsmManager.getDefault().getRelationshipMap();
  if (sourceHandle != null && targetHandle != null) {
    IRelationship foreward=mapper.get(sourceHandle,IRelationship.Kind.DECLARE,MATCHED_BY);
    foreward.getTargets().add(targetHandle);
    IRelationship back=mapper.get(targetHandle,IRelationship.Kind.DECLARE,MATCHES_DECLARE);
    back.getTargets().add(sourceHandle);
  }
}","public static void checkerMunger(IHierarchy model,Shadow shadow,Checker checker){
  if (shadow.getSourceLocation() == null || checker.getSourceLocation() == null)   return;
  String sourceHandle=ProgramElement.createHandleIdentifier(checker.getSourceLocation().getSourceFile(),checker.getSourceLocation().getLine(),checker.getSourceLocation().getColumn());
  String targetHandle=ProgramElement.createHandleIdentifier(shadow.getSourceLocation().getSourceFile(),shadow.getSourceLocation().getLine(),shadow.getSourceLocation().getColumn());
  IRelationshipMap mapper=AsmManager.getDefault().getRelationshipMap();
  if (sourceHandle != null && targetHandle != null) {
    IRelationship foreward=mapper.get(sourceHandle,IRelationship.Kind.DECLARE,MATCHED_BY);
    foreward.getTargets().add(targetHandle);
    IRelationship back=mapper.get(targetHandle,IRelationship.Kind.DECLARE,MATCHES_DECLARE);
    back.getTargets().add(sourceHandle);
  }
}",0.9892241379310344
9584,"private void doDeclareParents(DeclareParents declareParents,SourceTypeBinding sourceType){
  List newParents=declareParents.findMatchingNewParents(factory.fromEclipse(sourceType));
  if (!newParents.isEmpty()) {
    for (Iterator i=newParents.iterator(); i.hasNext(); ) {
      ResolvedTypeX parent=(ResolvedTypeX)i.next();
      addParent(sourceType,parent);
    }
  }
}","private void doDeclareParents(DeclareParents declareParents,SourceTypeBinding sourceType){
  List newParents=declareParents.findMatchingNewParents(factory.fromEclipse(sourceType));
  if (!newParents.isEmpty()) {
    for (Iterator i=newParents.iterator(); i.hasNext(); ) {
      ResolvedTypeX parent=(ResolvedTypeX)i.next();
      if (dangerousInterfaces.containsKey(parent)) {
        ResolvedTypeX onType=factory.fromEclipse(sourceType);
        factory.showMessage(IMessage.ERROR,onType + ""String_Node_Str"" + dangerousInterfaces.get(parent),onType.getSourceLocation(),null);
      }
      addParent(sourceType,parent);
    }
  }
}",0.6879361914257228
9585,"public static Test suite(){
  TestSuite suite=new TestSuite(AjdeTests.class.getName());
  suite.addTestSuite(BuildOptionsTest.class);
  suite.addTestSuite(BuildConfigurationTests.class);
  suite.addTestSuite(StructureModelRegressionTest.class);
  suite.addTestSuite(StructureModelTest.class);
  suite.addTestSuite(VersionTest.class);
  suite.addTestSuite(CompilerMessagesTest.class);
  suite.addTestSuite(AsmDeclarationsTest.class);
  suite.addTestSuite(AsmRelationshipsTest.class);
  suite.addTestSuite(ResourceCopyTestCase.class);
  return suite;
}","public static Test suite(){
  TestSuite suite=new TestSuite(AjdeTests.class.getName());
  suite.addTestSuite(BuildOptionsTest.class);
  suite.addTestSuite(BuildConfigurationTests.class);
  suite.addTestSuite(StructureModelRegressionTest.class);
  suite.addTestSuite(StructureModelTest.class);
  suite.addTestSuite(VersionTest.class);
  suite.addTestSuite(CompilerMessagesTest.class);
  suite.addTestSuite(AsmDeclarationsTest.class);
  suite.addTestSuite(AsmRelationshipsTest.class);
  return suite;
}",0.9523809523809524
9586,"/** 
 * @todo	add negative test to make sure things that aren't runnable aren't annotated
 */
public void testMainClassNodeInfo() throws IOException {
  StructureModel model=Ajde.getDefault().getStructureModelManager().getStructureModel();
  assertTrue(""String_Node_Str"",model != null);
  assertTrue(""String_Node_Str"",model.getRoot() != null);
  File testFile=openFile(""String_Node_Str"");
  IProgramElement node=model.findNodeForSourceLine(testFile.getCanonicalPath(),11);
  assertTrue(""String_Node_Str"",node != null);
  System.err.println(""String_Node_Str"" + node);
  IProgramElement pNode=(IProgramElement)((IProgramElement)node).getParent();
  if (null == pNode) {
    assertTrue(""String_Node_Str"" + node,false);
  }
  assertTrue(""String_Node_Str"" + pNode.getName(),pNode.isRunnable());
}","/** 
 * @todo	add negative test to make sure things that aren't runnable aren't annotated
 */
public void testMainClassNodeInfo() throws IOException {
  StructureModel model=Ajde.getDefault().getStructureModelManager().getStructureModel();
  assertTrue(""String_Node_Str"",model != null);
  assertTrue(""String_Node_Str"",model.getRoot() != null);
  File testFile=openFile(""String_Node_Str"");
  IProgramElement node=model.findNodeForSourceLine(testFile.getCanonicalPath(),11);
  assertTrue(""String_Node_Str"",node != null);
  IProgramElement pNode=(IProgramElement)((IProgramElement)node).getParent();
  if (null == pNode) {
    assertTrue(""String_Node_Str"" + node,false);
  }
  assertTrue(""String_Node_Str"" + pNode.getName(),pNode.isRunnable());
}",0.96870925684485
9587,"/** 
 * Use to create program element nodes that correspond to source locations.
 */
public ProgramElement(String name,Kind kind,List modifiers,Accessibility accessibility,String declaringType,String packageName,String formalComment,ISourceLocation sourceLocation,List relations,List children,boolean member){
  this(name,kind,children);
  this.sourceLocation=sourceLocation;
  this.kind=kind;
  this.modifiers=modifiers;
  this.accessibility=accessibility;
  this.declaringType=declaringType;
  this.packageName=packageName;
  this.formalComment=formalComment;
  this.relations=relations;
}","/** 
 * Use to create program element nodes that correspond to source locations.
 */
public ProgramElement(String name,Kind kind,int modifiers,Accessibility accessibility,String declaringType,String packageName,String formalComment,ISourceLocation sourceLocation,List relations,List children,boolean member){
  this(name,kind,children);
  this.sourceLocation=sourceLocation;
  this.kind=kind;
  this.modifiers=genModifiers(modifiers);
  this.accessibility=accessibility;
  this.declaringType=declaringType;
  this.packageName=packageName;
  this.formalComment=formalComment;
  this.relations=relations;
}",0.982426778242678
9588,"public static List genModifiers(int modifiers){
  List modifiersList=new ArrayList();
  if ((modifiers & AccStatic) != 0)   modifiersList.add(IProgramElement.Modifiers.STATIC);
  if ((modifiers & AccFinal) != 0)   modifiersList.add(IProgramElement.Modifiers.STATIC);
  if ((modifiers & AccSynchronized) != 0)   modifiersList.add(IProgramElement.Modifiers.STATIC);
  if ((modifiers & AccVolatile) != 0)   modifiersList.add(IProgramElement.Modifiers.STATIC);
  if ((modifiers & AccTransient) != 0)   modifiersList.add(IProgramElement.Modifiers.STATIC);
  if ((modifiers & AccNative) != 0)   modifiersList.add(IProgramElement.Modifiers.STATIC);
  if ((modifiers & AccAbstract) != 0)   modifiersList.add(IProgramElement.Modifiers.STATIC);
  return modifiersList;
}","private static List genModifiers(int modifiers){
  List modifiersList=new ArrayList();
  if ((modifiers & AccStatic) != 0)   modifiersList.add(IProgramElement.Modifiers.STATIC);
  if ((modifiers & AccFinal) != 0)   modifiersList.add(IProgramElement.Modifiers.STATIC);
  if ((modifiers & AccSynchronized) != 0)   modifiersList.add(IProgramElement.Modifiers.STATIC);
  if ((modifiers & AccVolatile) != 0)   modifiersList.add(IProgramElement.Modifiers.STATIC);
  if ((modifiers & AccTransient) != 0)   modifiersList.add(IProgramElement.Modifiers.STATIC);
  if ((modifiers & AccNative) != 0)   modifiersList.add(IProgramElement.Modifiers.STATIC);
  if ((modifiers & AccAbstract) != 0)   modifiersList.add(IProgramElement.Modifiers.STATIC);
  return modifiersList;
}",0.9927679158448388
9589,"public EclipseTypeMunger build(ClassScope classScope){
  EclipseFactory world=EclipseFactory.fromScopeLookupEnvironment(classScope);
  binding=classScope.referenceContext.binding.resolveTypesFor(binding);
  resolveOnType(classScope);
  if (ignoreFurtherInvestigation)   return null;
  if (onTypeBinding.isInterface()) {
    ignoreFurtherInvestigation=true;
    return null;
  }
  if (onTypeBinding.isNestedType()) {
    classScope.problemReporter().signalError(sourceStart,sourceEnd,""String_Node_Str"");
    ignoreFurtherInvestigation=true;
    return null;
  }
  ResolvedTypeX declaringTypeX=world.fromEclipse(onTypeBinding);
  ResolvedTypeX aspectType=world.fromEclipse(classScope.referenceContext.binding);
  ResolvedMember bindingAsMember=world.makeResolvedMember(binding);
  ResolvedMember signature=new ResolvedMember(Member.CONSTRUCTOR,declaringTypeX,declaredModifiers,ResolvedTypeX.VOID,""String_Node_Str"",bindingAsMember.getParameterTypes());
  signature.setCheckedExceptions(world.fromEclipse(binding.thrownExceptions));
  ResolvedMember syntheticInterMember=AjcMemberMaker.interConstructor(declaringTypeX,signature,aspectType);
  NewConstructorTypeMunger myMunger=new NewConstructorTypeMunger(signature,syntheticInterMember,null,null);
  setMunger(myMunger);
  myMunger.check(world.getWorld());
  this.selector=binding.selector=NameMangler.postIntroducedConstructor(EclipseFactory.fromBinding(binding.declaringClass),declaringTypeX).toCharArray();
  return new EclipseTypeMunger(world,myMunger,aspectType,this);
}","public EclipseTypeMunger build(ClassScope classScope){
  EclipseFactory world=EclipseFactory.fromScopeLookupEnvironment(classScope);
  binding=classScope.referenceContext.binding.resolveTypesFor(binding);
  resolveOnType(classScope);
  if (ignoreFurtherInvestigation)   return null;
  if (onTypeBinding.isInterface()) {
    ignoreFurtherInvestigation=true;
    return null;
  }
  if (onTypeBinding.isNestedType()) {
    classScope.problemReporter().signalError(sourceStart,sourceEnd,""String_Node_Str"");
    ignoreFurtherInvestigation=true;
    return null;
  }
  ResolvedTypeX declaringTypeX=world.fromEclipse(onTypeBinding);
  ResolvedTypeX aspectType=world.fromEclipse(classScope.referenceContext.binding);
  ResolvedMember bindingAsMember=world.makeResolvedMember(binding);
  ResolvedMember signature=new ResolvedMember(Member.CONSTRUCTOR,declaringTypeX,declaredModifiers,ResolvedTypeX.VOID,""String_Node_Str"",bindingAsMember.getParameterTypes(),world.fromEclipse(binding.thrownExceptions));
  ResolvedMember syntheticInterMember=AjcMemberMaker.interConstructor(declaringTypeX,signature,aspectType);
  NewConstructorTypeMunger myMunger=new NewConstructorTypeMunger(signature,syntheticInterMember,null,null);
  setMunger(myMunger);
  myMunger.check(world.getWorld());
  this.selector=binding.selector=NameMangler.postIntroducedConstructor(EclipseFactory.fromBinding(binding.declaringClass),declaringTypeX).toCharArray();
  return new EclipseTypeMunger(world,myMunger,aspectType,this);
}",0.9877035559986708
9590,"public EclipseTypeMunger build(ClassScope classScope){
  EclipseFactory world=EclipseFactory.fromScopeLookupEnvironment(classScope);
  resolveOnType(classScope);
  if (ignoreFurtherInvestigation)   return null;
  binding=classScope.referenceContext.binding.resolveTypesFor(binding);
  ResolvedMember sig=new ResolvedMember(Member.METHOD,EclipseFactory.fromBinding(onTypeBinding),declaredModifiers,EclipseFactory.fromBinding(binding.returnType),new String(declaredSelector),EclipseFactory.fromBindings(binding.parameters));
  sig.setCheckedExceptions(world.fromEclipse(binding.thrownExceptions));
  NewMethodTypeMunger myMunger=new NewMethodTypeMunger(sig,null);
  setMunger(myMunger);
  ResolvedTypeX aspectType=world.fromEclipse(classScope.referenceContext.binding);
  ResolvedMember me=myMunger.getDispatchMethod(aspectType);
  this.selector=binding.selector=me.getName().toCharArray();
  return new EclipseTypeMunger(world,myMunger,aspectType,this);
}","public EclipseTypeMunger build(ClassScope classScope){
  EclipseFactory world=EclipseFactory.fromScopeLookupEnvironment(classScope);
  resolveOnType(classScope);
  if (ignoreFurtherInvestigation)   return null;
  binding=classScope.referenceContext.binding.resolveTypesFor(binding);
  ResolvedMember sig=new ResolvedMember(Member.METHOD,EclipseFactory.fromBinding(onTypeBinding),declaredModifiers,EclipseFactory.fromBinding(binding.returnType),new String(declaredSelector),EclipseFactory.fromBindings(binding.parameters),world.fromEclipse(binding.thrownExceptions));
  NewMethodTypeMunger myMunger=new NewMethodTypeMunger(sig,null);
  setMunger(myMunger);
  ResolvedTypeX aspectType=world.fromEclipse(classScope.referenceContext.binding);
  ResolvedMember me=myMunger.getDispatchMethod(aspectType);
  this.selector=binding.selector=me.getName().toCharArray();
  return new EclipseTypeMunger(world,myMunger,aspectType,this);
}",0.564129856306546
9591,"private void weaveInterTypeDeclarations(SourceTypeBinding sourceType,Collection typeMungers,Collection declareParents,boolean skipInners){
  ResolvedTypeX onType=factory.fromEclipse(sourceType);
  onType.clearInterTypeMungers();
  for (Iterator i=declareParents.iterator(); i.hasNext(); ) {
    doDeclareParents((DeclareParents)i.next(),sourceType);
  }
  for (Iterator i=typeMungers.iterator(); i.hasNext(); ) {
    EclipseTypeMunger munger=(EclipseTypeMunger)i.next();
    if (munger.matches(onType)) {
      onType.addInterTypeMunger(munger);
    }
  }
  for (Iterator i=onType.getInterTypeMungers().iterator(); i.hasNext(); ) {
    EclipseTypeMunger munger=(EclipseTypeMunger)i.next();
    munger.munge(sourceType);
  }
  if (skipInners)   return;
  ReferenceBinding[] memberTypes=sourceType.memberTypes;
  for (int i=0, length=memberTypes.length; i < length; i++) {
    if (memberTypes[i] instanceof SourceTypeBinding) {
      weaveInterTypeDeclarations((SourceTypeBinding)memberTypes[i],typeMungers,declareParents,false);
    }
  }
}","private void weaveInterTypeDeclarations(SourceTypeBinding sourceType,Collection typeMungers,Collection declareParents,boolean skipInners){
  ResolvedTypeX onType=factory.fromEclipse(sourceType);
  WeaverStateInfo info=onType.getWeaverState();
  if (info != null && !info.isOldStyle()) {
    Collection mungers=onType.getWeaverState().getTypeMungers(onType);
    for (Iterator i=mungers.iterator(); i.hasNext(); ) {
      ConcreteTypeMunger m=(ConcreteTypeMunger)i.next();
      EclipseTypeMunger munger=factory.makeEclipseTypeMunger(m);
      if (munger.munge(sourceType)) {
        if (onType.isInterface() && munger.getMunger().needsAccessToTopmostImplementor()) {
          if (!onType.getWorld().getCrosscuttingMembersSet().containsAspect(munger.getAspectType())) {
            dangerousInterfaces.put(onType,""String_Node_Str"" + onType + ""String_Node_Str""+ munger.getAspectType());
          }
        }
      }
    }
    return;
  }
  for (Iterator i=dangerousInterfaces.entrySet().iterator(); i.hasNext(); ) {
    Map.Entry entry=(Map.Entry)i.next();
    ResolvedTypeX interfaceType=(ResolvedTypeX)entry.getKey();
    if (onType.isTopmostImplementor(interfaceType)) {
      factory.showMessage(IMessage.ERROR,onType + ""String_Node_Str"" + entry.getValue(),onType.getSourceLocation(),null);
    }
  }
  boolean needOldStyleWarning=(info != null && info.isOldStyle());
  onType.clearInterTypeMungers();
  for (Iterator i=declareParents.iterator(); i.hasNext(); ) {
    doDeclareParents((DeclareParents)i.next(),sourceType);
  }
  for (Iterator i=typeMungers.iterator(); i.hasNext(); ) {
    EclipseTypeMunger munger=(EclipseTypeMunger)i.next();
    if (munger.matches(onType)) {
      if (needOldStyleWarning) {
        factory.showMessage(IMessage.WARNING,""String_Node_Str"" + onType + ""String_Node_Str"",onType.getSourceLocation(),null);
        needOldStyleWarning=false;
      }
      onType.addInterTypeMunger(munger);
    }
  }
  for (Iterator i=onType.getInterTypeMungers().iterator(); i.hasNext(); ) {
    EclipseTypeMunger munger=(EclipseTypeMunger)i.next();
    munger.munge(sourceType);
  }
  if (skipInners)   return;
  ReferenceBinding[] memberTypes=sourceType.memberTypes;
  for (int i=0, length=memberTypes.length; i < length; i++) {
    if (memberTypes[i] instanceof SourceTypeBinding) {
      weaveInterTypeDeclarations((SourceTypeBinding)memberTypes[i],typeMungers,declareParents,false);
    }
  }
}",0.5906855655192363
9592,"public void testJar1() throws IOException {
  List args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
  TestUtil.runMain(""String_Node_Str"",""String_Node_Str"");
  TestUtil.runMain(""String_Node_Str"",""String_Node_Str"");
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
  TestUtil.runMain(""String_Node_Str"",""String_Node_Str"");
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  CommandTestCase.runCompiler(args,new int[]{24,30});
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  CommandTestCase.runCompiler(args,new int[]{9,11,15,17});
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
}","public void testJar1() throws IOException {
  List args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
  TestUtil.runMain(""String_Node_Str"",""String_Node_Str"");
  TestUtil.runMain(""String_Node_Str"",""String_Node_Str"");
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
  TestUtil.runMain(""String_Node_Str"",""String_Node_Str"");
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  CommandTestCase.runCompiler(args,new int[]{24,30});
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  CommandTestCase.runCompiler(args,new int[]{15,17,22});
  args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
}",0.998088867654085
9593,"public void mouseClicked(MouseEvent e){
  if (e.getClickCount() >= 1) {
    int index=list.locationToIndex(e.getPoint());
    if (listModel.getSize() >= index && index != -1) {
      CompilerMessage cm=(CompilerMessage)listModel.getElementAt(index);
      if ((null != cm) && (null != cm.message)) {
        displayMessage(cm.message);
      }
    }
  }
}","public void mouseClicked(MouseEvent e){
  if (e.getClickCount() >= 1) {
    int index=list.locationToIndex(e.getPoint());
    if (listModel.getSize() >= index && index != -1) {
      IMessage message=(IMessage)listModel.getElementAt(index);
      Ajde.getDefault().getEditorAdapter().showSourceLine(message.getISourceLocation(),true);
    }
  }
}",0.5706134094151213
9594,"public void addSourcelineTask(IMessage message){
  listModel.addElement(new CompilerMessage(message));
  if (!hasWarning && IMessage.WARNING.isSameOrLessThan(message.getKind())) {
    hasWarning=true;
  }
  BrowserManager.getDefault().showMessages();
}","public void addSourcelineTask(String message,ISourceLocation sourceLocation,IMessage.Kind kind){
  listModel.addElement(new Message(message,kind,null,sourceLocation));
  checkIfWarning(kind);
}",0.4764044943820225
9595,"public CompilerMessagesPanel(){
  try {
    jbInit();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  list.setModel(listModel);
  MouseListener mouseListener=new MouseAdapter(){
    public void mouseClicked(    MouseEvent e){
      if (e.getClickCount() >= 1) {
        int index=list.locationToIndex(e.getPoint());
        if (listModel.getSize() >= index && index != -1) {
          CompilerMessage cm=(CompilerMessage)listModel.getElementAt(index);
          if ((null != cm) && (null != cm.message)) {
            displayMessage(cm.message);
          }
        }
      }
    }
  }
;
  list.addMouseListener(mouseListener);
  list.setCellRenderer(new CompilerMessagesCellRenderer());
}","public CompilerMessagesPanel(){
  try {
    jbInit();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  list.setModel(listModel);
  MouseListener mouseListener=new MouseAdapter(){
    public void mouseClicked(    MouseEvent e){
      if (e.getClickCount() >= 1) {
        int index=list.locationToIndex(e.getPoint());
        if (listModel.getSize() >= index && index != -1) {
          IMessage message=(IMessage)listModel.getElementAt(index);
          Ajde.getDefault().getEditorAdapter().showSourceLine(message.getISourceLocation(),true);
        }
      }
    }
  }
;
  list.addMouseListener(mouseListener);
  list.setCellRenderer(new CompilerMessagesCellRenderer());
}",0.5978339350180505
9596,"public void addProjectTask(String message,IMessage.Kind kind){
  IMessage m=new Message(message,kind,null,null);
  listModel.addElement(new CompilerMessage(m));
  if (!hasWarning && IMessage.WARNING.isSameOrLessThan(kind)) {
    hasWarning=true;
  }
  BrowserManager.getDefault().showMessages();
}","public void addProjectTask(String message,IMessage.Kind kind){
  listModel.addElement(new Message(message,kind,null,null));
  checkIfWarning(kind);
}",0.5695067264573991
9597,"public void clearTasks(){
  listModel.clear();
}","public void clearTasks(){
  listModel.clear();
  hasWarning=false;
}",0.8275862068965517
9598,"/** 
 * Add new options from the ProjectPropertiesAdapter to the configuration. <ul> <li>New list entries are added if not duplicates, for classpath, aspectpath, injars, and sourceroots</li> <li>New bootclasspath entries are ignored XXX</li> <li>Set only one new entry for output dir or output jar only if there is no output dir/jar entry in the config</li> </ul> Subsequent changes to the ProjectPropertiesAdapter will not affect the configuration. <p>Added by AMC 01.20.2003, bugzilla #29769
 */
private void configureProjectOptions(AjBuildConfig config,ProjectPropertiesAdapter properties){
  String propcp=properties.getClasspath();
  if (!LangUtil.isEmpty(propcp)) {
    StringTokenizer st=new StringTokenizer(propcp,File.pathSeparator);
    List configClasspath=config.getClasspath();
    ArrayList toAdd=new ArrayList();
    while (st.hasMoreTokens()) {
      String entry=st.nextToken();
      if (!configClasspath.contains(entry)) {
        toAdd.add(entry);
      }
    }
    if (0 < toAdd.size()) {
      ArrayList both=new ArrayList(configClasspath.size() + toAdd.size());
      both.addAll(configClasspath);
      both.addAll(toAdd);
      config.setClasspath(both);
      Ajde.getDefault().logEvent(""String_Node_Str"" + both);
    }
  }
  if ((null == config.getOutputDir() && (null == config.getOutputJar()))) {
    String outPath=properties.getOutputPath();
    if (!LangUtil.isEmpty(outPath)) {
      config.setOutputDir(new File(outPath));
    }
    String outJar=properties.getOutJar();
    if (!LangUtil.isEmpty(outJar)) {
      config.setOutputJar(new File(outJar));
    }
  }
  join(config.getSourceRoots(),properties.getSourceRoots());
  join(config.getInJars(),properties.getInJars());
  join(config.getAspectpath(),properties.getAspectPath());
}","/** 
 * Add new options from the ProjectPropertiesAdapter to the configuration. <ul> <li>New list entries are added if not duplicates, for classpath, aspectpath, injars, and sourceroots</li> <li>New bootclasspath entries are ignored XXX</li> <li>Set only one new entry for output dir or output jar only if there is no output dir/jar entry in the config</li> </ul> Subsequent changes to the ProjectPropertiesAdapter will not affect the configuration. <p>Added by AMC 01.20.2003, bugzilla #29769
 */
private void configureProjectOptions(AjBuildConfig config,ProjectPropertiesAdapter properties){
  String propcp=properties.getClasspath();
  if (!LangUtil.isEmpty(propcp)) {
    StringTokenizer st=new StringTokenizer(propcp,File.pathSeparator);
    List configClasspath=config.getClasspath();
    ArrayList toAdd=new ArrayList();
    while (st.hasMoreTokens()) {
      String entry=st.nextToken();
      if (!configClasspath.contains(entry)) {
        toAdd.add(entry);
      }
    }
    if (0 < toAdd.size()) {
      ArrayList both=new ArrayList(configClasspath.size() + toAdd.size());
      both.addAll(configClasspath);
      both.addAll(toAdd);
      config.setClasspath(both);
      Ajde.getDefault().logEvent(""String_Node_Str"" + both);
    }
  }
  if ((null == config.getOutputDir() && (null == config.getOutputJar()))) {
    String outPath=properties.getOutputPath();
    if (!LangUtil.isEmpty(outPath)) {
      config.setOutputDir(new File(outPath));
    }
    String outJar=properties.getOutJar();
    if (!LangUtil.isEmpty(outJar)) {
      config.setOutputJar(new File(outJar));
    }
  }
  join(config.getSourceRoots(),properties.getSourceRoots());
  join(config.getInJars(),properties.getInJars());
  config.setSourcePathResources(properties.getSourcePathResources());
  join(config.getAspectpath(),properties.getAspectPath());
}",0.98059866962306
9599,"public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  String label=""String_Node_Str"";
  String detail=null;
  IMessage.Kind kind=IMessage.INFO;
  if (value instanceof IMessage) {
    IMessage cm=(IMessage)value;
    label=cm.getMessage();
    if (LangUtil.isEmpty(label)) {
      label=cm.getMessage().toString();
    }
    kind=cm.getKind();
    Throwable thrown=cm.getThrown();
    if (null != thrown) {
      detail=LangUtil.renderException(thrown);
    }
  }
 else   if (null != value) {
    label=value.toString();
  }
  setText(label);
  if (kind.equals(IMessage.WARNING)) {
    setIcon(AjdeUIManager.getDefault().getIconRegistry().getWarningIcon());
  }
 else   if (IMessage.ERROR.isSameOrLessThan(kind)) {
    setIcon(AjdeUIManager.getDefault().getIconRegistry().getErrorIcon());
  }
 else {
    setIcon(null);
  }
  if (isSelected) {
    setBackground(list.getSelectionBackground());
    setForeground(list.getSelectionForeground());
  }
 else {
    setBackground(list.getBackground());
    setForeground(list.getForeground());
  }
  setEnabled(list.isEnabled());
  setFont(list.getFont());
  setOpaque(true);
  if (null != detail) {
    setToolTipText(detail);
  }
  return this;
}","public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  String label=""String_Node_Str"";
  String detail=null;
  IMessage.Kind kind=IMessage.ERROR;
  if (value instanceof IMessage) {
    IMessage cm=(IMessage)value;
    label=cm.getMessage();
    if (LangUtil.isEmpty(label)) {
      label=cm.getMessage().toString();
    }
    kind=cm.getKind();
    Throwable thrown=cm.getThrown();
    if (null != thrown) {
      detail=LangUtil.renderException(thrown);
    }
  }
 else   if (null != value) {
    label=value.toString();
  }
  setText(label);
  if (kind.equals(IMessage.WARNING)) {
    setIcon(AjdeUIManager.getDefault().getIconRegistry().getWarningIcon());
  }
 else   if (IMessage.ERROR.isSameOrLessThan(kind)) {
    setIcon(AjdeUIManager.getDefault().getIconRegistry().getErrorIcon());
  }
 else {
    setIcon(null);
  }
  if (isSelected) {
    setBackground(list.getSelectionBackground());
    setForeground(list.getSelectionForeground());
  }
 else {
    setBackground(list.getBackground());
    setForeground(list.getForeground());
  }
  setEnabled(list.isEnabled());
  setFont(list.getFont());
  setOpaque(true);
  if (null != detail) {
    setToolTipText(detail);
  }
  return this;
}",0.5580657946888624
9600,"/** 
 * init only on initial batch compile? no file-specific options 
 */
private void initBcelWorld(IMessageHandler handler) throws IOException {
  bcelWorld=new BcelWorld(buildConfig.getClasspath(),handler);
  bcelWorld.setXnoInline(buildConfig.isXnoInline());
  bcelWeaver=new BcelWeaver(bcelWorld);
  for (Iterator i=buildConfig.getAspectpath().iterator(); i.hasNext(); ) {
    File f=(File)i.next();
    bcelWeaver.addLibraryJarFile(f);
  }
  String lintMode=buildConfig.getLintMode();
  if (buildConfig.getLintMode().equals(AjBuildConfig.AJLINT_DEFAULT)) {
    bcelWorld.getLint().loadDefaultProperties();
  }
 else {
    bcelWorld.getLint().setAll(buildConfig.getLintMode());
  }
  if (buildConfig.getLintSpecFile() != null) {
    bcelWorld.getLint().setFromProperties(buildConfig.getLintSpecFile());
  }
  for (Iterator i=buildConfig.getInJars().iterator(); i.hasNext(); ) {
    File inJar=(File)i.next();
    bcelWeaver.addJarFile(inJar,buildConfig.getOutputDir());
  }
  bcelWorld.resolve(""String_Node_Str"");
}","/** 
 * init only on initial batch compile? no file-specific options 
 */
private void initBcelWorld(IMessageHandler handler) throws IOException {
  bcelWorld=new BcelWorld(buildConfig.getClasspath(),handler);
  bcelWorld.setXnoInline(buildConfig.isXnoInline());
  bcelWeaver=new BcelWeaver(bcelWorld);
  for (Iterator i=buildConfig.getAspectpath().iterator(); i.hasNext(); ) {
    File f=(File)i.next();
    bcelWeaver.addLibraryJarFile(f);
  }
  String lintMode=buildConfig.getLintMode();
  if (buildConfig.getLintMode().equals(AjBuildConfig.AJLINT_DEFAULT)) {
    bcelWorld.getLint().loadDefaultProperties();
  }
 else {
    bcelWorld.getLint().setAll(buildConfig.getLintMode());
  }
  if (buildConfig.getLintSpecFile() != null) {
    bcelWorld.getLint().setFromProperties(buildConfig.getLintSpecFile());
  }
  for (Iterator i=buildConfig.getInJars().iterator(); i.hasNext(); ) {
    File inJar=(File)i.next();
    bcelWeaver.addJarFile(inJar,buildConfig.getOutputDir());
  }
  if (buildConfig.getSourcePathResources() != null) {
    for (Iterator i=buildConfig.getSourcePathResources().keySet().iterator(); i.hasNext(); ) {
      String resource=(String)i.next();
      bcelWeaver.addResource(resource,(File)buildConfig.getSourcePathResources().get(resource),buildConfig.getOutputDir());
    }
  }
  bcelWorld.resolve(""String_Node_Str"");
}",0.8633093525179856
9601,"/** 
 * Adds all class files in the jar
 */
public void addJarFile(File inFile,File outDir) throws IOException {
  needToReweaveWorld=true;
  ZipInputStream inStream=new ZipInputStream(new FileInputStream(inFile));
  while (true) {
    ZipEntry entry=inStream.getNextEntry();
    if (entry == null)     break;
    if (entry.isDirectory() || !entry.getName().endsWith(""String_Node_Str"")) {
      continue;
    }
    byte[] bytes=FileUtil.readAsByteArray(inStream);
    String filename=entry.getName();
    UnwovenClassFile classFile=new UnwovenClassFile(new File(outDir,filename).getAbsolutePath(),bytes);
    inStream.closeEntry();
    this.addClassFile(classFile);
  }
  inStream.close();
}","/** 
 * Adds all class files in the jar
 */
public void addJarFile(File inFile,File outDir) throws IOException {
  needToReweaveWorld=true;
  ZipInputStream inStream=new ZipInputStream(new FileInputStream(inFile));
  while (true) {
    ZipEntry entry=inStream.getNextEntry();
    if (entry == null)     break;
    byte[] bytes=FileUtil.readAsByteArray(inStream);
    String filename=entry.getName();
    if (filename.endsWith(""String_Node_Str"")) {
      UnwovenClassFile classFile=new UnwovenClassFile(new File(outDir,filename).getAbsolutePath(),bytes);
      this.addClassFile(classFile);
    }
 else     if (!entry.isDirectory()) {
      UnwovenClassFile resourceFile=new UnwovenClassFile(filename,bytes);
      addResource(resourceFile);
    }
    inStream.closeEntry();
  }
  inStream.close();
}",0.697986577181208
9602,"public void dumpUnwoven() throws IOException {
  Collection filesToDump=new HashSet(sourceJavaClasses.values());
  for (Iterator i=filesToDump.iterator(); i.hasNext(); ) {
    UnwovenClassFile classFile=(UnwovenClassFile)i.next();
    dumpUnchanged(classFile);
  }
}","public void dumpUnwoven() throws IOException {
  Collection filesToDump=new HashSet(sourceJavaClasses.values());
  for (Iterator i=filesToDump.iterator(); i.hasNext(); ) {
    UnwovenClassFile classFile=(UnwovenClassFile)i.next();
    dumpUnchanged(classFile);
  }
  dumpResourcesToOutPath();
}",0.95
9603,"/** 
 * Should be addOrReplace
 */
public void addClassFile(UnwovenClassFile classFile){
  addedClasses.add(classFile);
  sourceJavaClasses.put(classFile.getClassName(),classFile);
  world.addSourceObjectType(classFile.getJavaClass());
}","/** 
 * Should be addOrReplace
 */
public void addClassFile(UnwovenClassFile classFile){
  addedClasses.add(classFile);
  if (null != sourceJavaClasses.put(classFile.getClassName(),classFile)) {
  }
  world.addSourceObjectType(classFile.getJavaClass());
}",0.959349593495935
9604,"/** 
 * fill the newly created method gen with our body,  inspired by InstructionList.copy()
 */
public void packBody(MethodGen gen){
  HashMap map=new HashMap();
  InstructionList fresh=gen.getInstructionList();
  for (InstructionHandle ih=getBody().getStart(); ih != null; ih=ih.getNext()) {
    if (Range.isRangeHandle(ih)) {
      continue;
    }
    Instruction i=ih.getInstruction();
    Instruction c=Utility.copyInstruction(i);
    if (c instanceof BranchInstruction)     map.put(ih,fresh.append((BranchInstruction)c));
 else     map.put(ih,fresh.append(c));
  }
  InstructionHandle ih=getBody().getStart();
  InstructionHandle jh=fresh.getStart();
  LinkedList exnList=new LinkedList();
  Map localVariableStarts=new HashMap();
  Map localVariableEnds=new HashMap();
  int currLine=-1;
  while (ih != null) {
    if (map.get(ih) == null) {
      Range r=Range.getRange(ih);
      if (r instanceof ExceptionRange) {
        ExceptionRange er=(ExceptionRange)r;
        if (er.getStart() == ih) {
          if (!er.isEmpty()) {
            insertHandler(er,exnList);
          }
        }
      }
 else {
      }
      ih=ih.getNext();
    }
 else {
      Instruction i=ih.getInstruction();
      Instruction j=jh.getInstruction();
      if (i instanceof BranchInstruction) {
        BranchInstruction bi=(BranchInstruction)i;
        BranchInstruction bj=(BranchInstruction)j;
        InstructionHandle itarget=bi.getTarget();
        bj.setTarget(remap(itarget,map));
        if (bi instanceof Select) {
          InstructionHandle[] itargets=((Select)bi).getTargets();
          InstructionHandle[] jtargets=((Select)bj).getTargets();
          for (int k=itargets.length - 1; k >= 0; k--) {
            jtargets[k]=remap(itargets[k],map);
            jtargets[k].addTargeter(bj);
          }
        }
      }
      InstructionTargeter[] targeters=ih.getTargeters();
      if (targeters != null) {
        for (int k=targeters.length - 1; k >= 0; k--) {
          InstructionTargeter targeter=targeters[k];
          if (targeter instanceof LineNumberTag) {
            int line=((LineNumberTag)targeter).getLineNumber();
            if (line != currLine) {
              gen.addLineNumber(jh,line);
              currLine=line;
            }
          }
 else           if (targeter instanceof LocalVariableTag) {
            LocalVariableTag lvt=(LocalVariableTag)targeter;
            if (i instanceof LocalVariableInstruction) {
              int index=((LocalVariableInstruction)i).getIndex();
              if (lvt.getSlot() == index) {
                if (localVariableStarts.get(lvt) == null) {
                  localVariableStarts.put(lvt,jh);
                }
                localVariableEnds.put(lvt,jh);
              }
            }
          }
        }
      }
      ih=ih.getNext();
      jh=jh.getNext();
    }
  }
  for (Iterator iter=exnList.iterator(); iter.hasNext(); ) {
    ExceptionRange r=(ExceptionRange)iter.next();
    if (r.isEmpty())     continue;
    gen.addExceptionHandler(remap(r.getRealStart(),map),remap(r.getRealEnd(),map),remap(r.getHandler(),map),(r.getCatchType() == null) ? null : (ObjectType)BcelWorld.makeBcelType(r.getCatchType()));
  }
  gen.removeLocalVariables();
  for (Iterator iter=localVariableStarts.keySet().iterator(); iter.hasNext(); ) {
    LocalVariableTag tag=(LocalVariableTag)iter.next();
    gen.addLocalVariable(tag.getName(),BcelWorld.makeBcelType(tag.getType()),tag.getSlot(),(InstructionHandle)localVariableStarts.get(tag),(InstructionHandle)localVariableEnds.get(tag));
  }
}","/** 
 * fill the newly created method gen with our body,  inspired by InstructionList.copy()
 */
public void packBody(MethodGen gen){
  HashMap map=new HashMap();
  InstructionList fresh=gen.getInstructionList();
  for (InstructionHandle ih=getBody().getStart(); ih != null; ih=ih.getNext()) {
    if (Range.isRangeHandle(ih)) {
      continue;
    }
    Instruction i=ih.getInstruction();
    Instruction c=Utility.copyInstruction(i);
    if (c instanceof BranchInstruction)     map.put(ih,fresh.append((BranchInstruction)c));
 else     map.put(ih,fresh.append(c));
  }
  InstructionHandle ih=getBody().getStart();
  InstructionHandle jh=fresh.getStart();
  LinkedList exnList=new LinkedList();
  Map localVariableStarts=new HashMap();
  Map localVariableEnds=new HashMap();
  int currLine=-1;
  while (ih != null) {
    if (map.get(ih) == null) {
      Range r=Range.getRange(ih);
      if (r instanceof ExceptionRange) {
        ExceptionRange er=(ExceptionRange)r;
        if (er.getStart() == ih) {
          if (!er.isEmpty()) {
            insertHandler(er,exnList);
          }
        }
      }
 else {
      }
      ih=ih.getNext();
    }
 else {
      Instruction i=ih.getInstruction();
      Instruction j=jh.getInstruction();
      if (i instanceof BranchInstruction) {
        BranchInstruction bi=(BranchInstruction)i;
        BranchInstruction bj=(BranchInstruction)j;
        InstructionHandle itarget=bi.getTarget();
        bj.setTarget(remap(itarget,map));
        if (bi instanceof Select) {
          InstructionHandle[] itargets=((Select)bi).getTargets();
          InstructionHandle[] jtargets=((Select)bj).getTargets();
          for (int k=itargets.length - 1; k >= 0; k--) {
            jtargets[k]=remap(itargets[k],map);
            jtargets[k].addTargeter(bj);
          }
        }
      }
      InstructionTargeter[] targeters=ih.getTargeters();
      if (targeters != null) {
        for (int k=targeters.length - 1; k >= 0; k--) {
          InstructionTargeter targeter=targeters[k];
          if (targeter instanceof LineNumberTag) {
            int line=((LineNumberTag)targeter).getLineNumber();
            if (line != currLine) {
              gen.addLineNumber(jh,line);
              currLine=line;
            }
          }
 else           if (targeter instanceof LocalVariableTag) {
            LocalVariableTag lvt=(LocalVariableTag)targeter;
            if (i instanceof LocalVariableInstruction) {
              int index=((LocalVariableInstruction)i).getIndex();
              if (lvt.getSlot() == index) {
                if (localVariableStarts.get(lvt) == null) {
                  localVariableStarts.put(lvt,jh);
                }
                localVariableEnds.put(lvt,jh);
              }
            }
          }
        }
      }
      ih=ih.getNext();
      jh=jh.getNext();
    }
  }
  for (Iterator iter=exnList.iterator(); iter.hasNext(); ) {
    ExceptionRange r=(ExceptionRange)iter.next();
    if (r.isEmpty())     continue;
    gen.addExceptionHandler(remap(r.getRealStart(),map),remap(r.getRealEnd(),map),remap(r.getHandler(),map),(r.getCatchType() == null) ? null : (ObjectType)BcelWorld.makeBcelType(r.getCatchType()));
  }
  gen.removeLocalVariables();
  Map duplicatedLocalMap=new HashMap();
  for (Iterator iter=localVariableStarts.keySet().iterator(); iter.hasNext(); ) {
    LocalVariableTag tag=(LocalVariableTag)iter.next();
    InstructionHandle start=(InstructionHandle)localVariableStarts.get(tag);
    Set slots=(Set)duplicatedLocalMap.get(start);
    if (slots == null) {
      slots=new HashSet();
      duplicatedLocalMap.put(start,slots);
    }
    if (slots.contains(new Integer(tag.getSlot()))) {
      continue;
    }
    slots.add(new Integer(tag.getSlot()));
    gen.addLocalVariable(tag.getName(),BcelWorld.makeBcelType(tag.getType()),tag.getSlot(),(InstructionHandle)localVariableStarts.get(tag),(InstructionHandle)localVariableEnds.get(tag));
  }
}",0.9483793517406964
9605,"public void postParse(TypeDeclaration typeDec){
  if (arguments == null)   arguments=new Argument[0];
  this.declaredModifiers=modifiers;
  this.declaredName=new String(selector);
  selector=CharOperation.concat(mangledPrefix,'$',selector,'$',Integer.toHexString(sourceStart).toCharArray());
  if (pointcutDesignator == null)   return;
  pointcutDesignator.postParse(typeDec,this);
}","public void postParse(TypeDeclaration typeDec){
  if (arguments == null)   arguments=new Argument[0];
  this.declaredModifiers=modifiers;
  this.declaredName=new String(selector);
  selector=CharOperation.concat(mangledPrefix,'$',selector,'$',Integer.toHexString(sourceStart).toCharArray());
  if (Modifier.isAbstract(this.declaredModifiers) && !(typeDec instanceof AspectDeclaration)) {
    typeDec.scope.problemReporter().signalError(sourceStart,sourceEnd,""String_Node_Str"" + new String(declaredName) + ""String_Node_Str"");
    ignoreFurtherInvestigation=true;
    return;
  }
  if (pointcutDesignator != null) {
    pointcutDesignator.postParse(typeDec,this);
  }
}",0.6571428571428571
9606,"public void resolveStatements(){
  if (isAbstract()) {
    this.modifiers|=AccSemicolonBody;
  }
  if (binding == null || ignoreFurtherInvestigation)   return;
  if (Modifier.isAbstract(this.declaredModifiers) && (pointcutDesignator != null)) {
    scope.problemReporter().signalError(sourceStart,sourceEnd,""String_Node_Str"");
  }
  if (pointcutDesignator != null) {
    pointcutDesignator.finishResolveTypes(this,this.binding,arguments.length,scope.enclosingSourceType());
  }
  super.resolveStatements();
}","public void resolveStatements(){
  if (isAbstract()) {
    this.modifiers|=AccSemicolonBody;
  }
  if (binding == null || ignoreFurtherInvestigation)   return;
  if (Modifier.isAbstract(this.declaredModifiers) && (pointcutDesignator != null)) {
    scope.problemReporter().signalError(sourceStart,sourceEnd,""String_Node_Str"");
    ignoreFurtherInvestigation=true;
    return;
  }
  if (pointcutDesignator != null) {
    pointcutDesignator.finishResolveTypes(this,this.binding,arguments.length,scope.enclosingSourceType());
  }
  super.resolveStatements();
}",0.9539906103286384
9607,"/** 
 * @throw BuildException if options conflict
 */
protected void verifyOptions(){
  if (fork && isInIncrementalMode() && !isInIncrementalFileMode()) {
    String m=""String_Node_Str"";
    throw new BuildException(m);
  }
}","/** 
 * @throw BuildException if options conflict
 */
protected void verifyOptions(){
  StringBuffer sb=new StringBuffer();
  if (fork && isInIncrementalMode() && !isInIncrementalFileMode()) {
    sb.append(""String_Node_Str"");
  }
  if ((null == outjar) && (DEFAULT_DESTDIR == destDir)) {
    final String REQ=""String_Node_Str"";
    if (copyInjars) {
      sb.append(""String_Node_Str"");
      sb.append(REQ);
    }
    if (null != sourceRootCopyFilter) {
      sb.append(""String_Node_Str"");
      sb.append(REQ);
    }
  }
  if (0 < sb.length()) {
    throw new BuildException(sb.toString());
  }
}",0.5078979343863913
9608,"/** 
 * This method extracts javac arguments to ajc, and add arguments to make ajc behave more like javac in copying resources. <p> Pass ajc-specific options using compilerarg sub-element: <pre> &lt;javac srcdir=""src""> &lt;compilerarg compiler=""..."" line=""-argfile src/args.lst""/> &lt;javac> </pre> Some javac arguments are not supported in this component (yet): <pre> String memoryInitialSize; boolean includeAntRuntime = true; boolean includeJavaRuntime = false; </pre> Other javac arguments are not supported in ajc 1.1: <pre> boolean optimize; String forkedExecutable; FacadeTaskHelper facade; boolean depend; String debugLevel; Path compileSourcepath; </pre>
 * @param javac the Javac command to implement (not null)
 * @param ajc the AjcTask to adapt (not null)
 * @param destDir the File class destination directory (may be null)
 * @return null if no error, or String error otherwise
 */
public static String setupAjc(AjcTask ajc,Javac javac,File destDir){
  if (null == ajc) {
    return ""String_Node_Str"";
  }
 else   if (null == javac) {
    return ""String_Node_Str"";
  }
 else   if (null == destDir) {
    destDir=javac.getDestdir();
    if (null == destDir) {
      destDir=new File(""String_Node_Str"");
    }
  }
  ajc.setProject(javac.getProject());
  ajc.setLocation(javac.getLocation());
  ajc.setTaskName(""String_Node_Str"");
  ajc.setDebug(javac.getDebug());
  ajc.setDeprecation(javac.getDeprecation());
  ajc.setFailonerror(javac.getFailonerror());
  final boolean fork=javac.isForkedJavac();
  ajc.setFork(fork);
  if (fork) {
    ajc.setMaxmem(javac.getMemoryMaximumSize());
  }
  ajc.setNowarn(javac.getNowarn());
  ajc.setListFileArgs(javac.getListfiles());
  ajc.setVerbose(javac.getVerbose());
  ajc.setTarget(javac.getTarget());
  ajc.setSource(javac.getSource());
  ajc.setEncoding(javac.getEncoding());
  ajc.setDestdir(destDir);
  ajc.setBootclasspath(javac.getBootclasspath());
  ajc.setExtdirs(javac.getExtdirs());
  ajc.setClasspath(javac.getClasspath());
  ajc.addFiles(javac.getFileList());
  ajc.setSourceRootCopyFilter(""String_Node_Str"");
  ajc.readArguments(javac.getCurrentCompilerArgs());
  return null;
}","/** 
 * This method extracts javac arguments to ajc, and add arguments to make ajc behave more like javac in copying resources. <p> Pass ajc-specific options using compilerarg sub-element: <pre> &lt;javac srcdir=""src""> &lt;compilerarg compiler=""..."" line=""-argfile src/args.lst""/> &lt;javac> </pre> Some javac arguments are not supported in this component (yet): <pre> String memoryInitialSize; boolean includeAntRuntime = true; boolean includeJavaRuntime = false; </pre> Other javac arguments are not supported in ajc 1.1: <pre> boolean optimize; String forkedExecutable; FacadeTaskHelper facade; boolean depend; String debugLevel; Path compileSourcepath; </pre>
 * @param javac the Javac command to implement (not null)
 * @param ajc the AjcTask to adapt (not null)
 * @param destDir the File class destination directory (may be null)
 * @return null if no error, or String error otherwise
 */
public static String setupAjc(AjcTask ajc,Javac javac,File destDir){
  if (null == ajc) {
    return ""String_Node_Str"";
  }
 else   if (null == javac) {
    return ""String_Node_Str"";
  }
 else   if (null == destDir) {
    destDir=javac.getDestdir();
  }
  ajc.setProject(javac.getProject());
  ajc.setLocation(javac.getLocation());
  ajc.setTaskName(""String_Node_Str"");
  ajc.setDebug(javac.getDebug());
  ajc.setDeprecation(javac.getDeprecation());
  ajc.setFailonerror(javac.getFailonerror());
  final boolean fork=javac.isForkedJavac();
  ajc.setFork(fork);
  if (fork) {
    ajc.setMaxmem(javac.getMemoryMaximumSize());
  }
  ajc.setNowarn(javac.getNowarn());
  ajc.setListFileArgs(javac.getListfiles());
  ajc.setVerbose(javac.getVerbose());
  ajc.setTarget(javac.getTarget());
  ajc.setSource(javac.getSource());
  ajc.setEncoding(javac.getEncoding());
  if (DEFAULT_DESTDIR != destDir) {
    ajc.setDestdir(destDir);
  }
  ajc.setBootclasspath(javac.getBootclasspath());
  ajc.setExtdirs(javac.getExtdirs());
  ajc.setClasspath(javac.getClasspath());
  ajc.addFiles(javac.getFileList());
  ajc.setSourceRootCopyFilter(""String_Node_Str"");
  ajc.readArguments(javac.getCurrentCompilerArgs());
  return null;
}",0.5726375176304654
9609,"/** 
 * Complete the destination directory by copying resources from the source root directories (if the filter is specified) and non-.class files from the input jars  (if XCopyInjars is enabled).
 */
private void completeDestdir(){
  if (!copyInjars && (null == sourceRootCopyFilter)) {
    return;
  }
 else   if (!destDir.canWrite()) {
    String s=""String_Node_Str"" + destDir;
    throw new BuildException(s);
  }
  final Project project=getProject();
  if (copyInjars) {
    String taskName=getTaskName() + ""String_Node_Str"";
    String[] paths=injars.list();
    if (!LangUtil.isEmpty(paths)) {
      PatternSet patternSet=new PatternSet();
      patternSet.setProject(project);
      patternSet.setIncludes(""String_Node_Str"");
      patternSet.setExcludes(""String_Node_Str"");
      for (int i=0; i < paths.length; i++) {
        Expand unzip=new Expand();
        unzip.setProject(project);
        unzip.setTaskName(taskName);
        unzip.setDest(destDir);
        unzip.setSrc(new File(paths[i]));
        unzip.addPatternset(patternSet);
        unzip.execute();
      }
    }
  }
  if ((null != sourceRootCopyFilter) && (null != sourceRoots)) {
    String[] paths=sourceRoots.list();
    if (!LangUtil.isEmpty(paths)) {
      Copy copy=new Copy();
      copy.setProject(project);
      copy.setTodir(destDir);
      for (int i=0; i < paths.length; i++) {
        FileSet fileSet=new FileSet();
        fileSet.setDir(new File(paths[i]));
        fileSet.setIncludes(""String_Node_Str"");
        fileSet.setExcludes(sourceRootCopyFilter);
        copy.addFileset(fileSet);
      }
      copy.execute();
    }
  }
}","/** 
 * Complete the destination directory by copying resources from the source root directories (if the filter is specified) and non-.class files from the input jars  (if XCopyInjars is enabled).
 */
private void completeDestdir(){
  if (!copyInjars && (null == sourceRootCopyFilter)) {
    return;
  }
 else   if ((destDir == DEFAULT_DESTDIR) || !destDir.canWrite()) {
    String s=""String_Node_Str"" + destDir;
    throw new BuildException(s);
  }
  final Project project=getProject();
  if (copyInjars) {
    String taskName=getTaskName() + ""String_Node_Str"";
    String[] paths=injars.list();
    if (!LangUtil.isEmpty(paths)) {
      PatternSet patternSet=new PatternSet();
      patternSet.setProject(project);
      patternSet.setIncludes(""String_Node_Str"");
      patternSet.setExcludes(""String_Node_Str"");
      for (int i=0; i < paths.length; i++) {
        Expand unzip=new Expand();
        unzip.setProject(project);
        unzip.setTaskName(taskName);
        unzip.setDest(destDir);
        unzip.setSrc(new File(paths[i]));
        unzip.addPatternset(patternSet);
        unzip.execute();
      }
    }
  }
  if ((null != sourceRootCopyFilter) && (null != sourceRoots)) {
    String[] paths=sourceRoots.list();
    if (!LangUtil.isEmpty(paths)) {
      Copy copy=new Copy();
      copy.setProject(project);
      copy.setTodir(destDir);
      for (int i=0; i < paths.length; i++) {
        FileSet fileSet=new FileSet();
        fileSet.setDir(new File(paths[i]));
        fileSet.setIncludes(""String_Node_Str"");
        fileSet.setExcludes(sourceRootCopyFilter);
        copy.addFileset(fileSet);
      }
      copy.execute();
    }
  }
}",0.9902498476538696
9610,"String[] makeCommand(){
  ArrayList result=new ArrayList();
  if (0 < ignored.size()) {
    for (Iterator iter=ignored.iterator(); iter.hasNext(); ) {
      log(""String_Node_Str"" + iter.next(),Project.MSG_INFO);
    }
  }
  if ((null != outjar) && !outjarFixedup) {
    if (copyInjars || (null != sourceRootCopyFilter)) {
      String path=outjar.getAbsolutePath();
      int len=FileUtil.zipSuffixLength(path);
      if (len < 1) {
        log(""String_Node_Str"" + path);
      }
 else {
        path=path.substring(0,path.length() - len) + ""String_Node_Str"";
        tmpOutjar=new File(path);
      }
    }
    if (null == tmpOutjar) {
      cmd.addFlagged(""String_Node_Str"",outjar.getAbsolutePath());
    }
 else {
      cmd.addFlagged(""String_Node_Str"",tmpOutjar.getAbsolutePath());
    }
    outjarFixedup=true;
  }
  result.addAll(cmd.extractArguments());
  addListArgs(result);
  return (String[])result.toArray(new String[0]);
}","String[] makeCommand(){
  ArrayList result=new ArrayList();
  if (0 < ignored.size()) {
    for (Iterator iter=ignored.iterator(); iter.hasNext(); ) {
      log(""String_Node_Str"" + iter.next(),Project.MSG_INFO);
    }
  }
  if ((null != outjar) && !outjarFixedup) {
    if (copyInjars || (null != sourceRootCopyFilter)) {
      String path=outjar.getAbsolutePath();
      int len=FileUtil.zipSuffixLength(path);
      if (len < 1) {
        log(""String_Node_Str"" + path);
      }
 else {
        path=path.substring(0,path.length() - len) + ""String_Node_Str"";
        tmpOutjar=new File(path);
      }
    }
    if (null == tmpOutjar) {
      cmd.addFlagged(""String_Node_Str"",outjar.getAbsolutePath());
    }
 else {
      cmd.addFlagged(""String_Node_Str"",tmpOutjar.getAbsolutePath());
    }
    outjarFixedup=true;
  }
  result.addAll(cmd.extractArguments());
  addListArgs(result);
  String[] command=(String[])result.toArray(new String[0]);
  if (null != commandEditor) {
    command=commandEditor.editCommand(command);
  }
 else   if (null != COMMAND_EDITOR) {
    command=COMMAND_EDITOR.editCommand(command);
  }
  return command;
}",0.8957528957528957
9611,"protected AjcTask getTask(String input){
  AjcTask task=new AjcTask();
  Project p=new Project();
  task.setProject(p);
  task.setDestdir(getTempDir());
  if (NOFILE.equals(input)) {
  }
 else   if (input.endsWith(""String_Node_Str"")) {
    if (-1 != input.indexOf(""String_Node_Str"")) {
      throw new IllegalArgumentException(""String_Node_Str"" + input);
    }
 else     if (null == testdataDir) {
      throw new Error(""String_Node_Str"");
    }
 else {
      String path=testdataDir + File.separator + input;
      task.setArgfiles(new Path(task.getProject(),path));
    }
  }
 else   if ((input.endsWith(""String_Node_Str"") || input.endsWith(""String_Node_Str""))) {
    FilenameSelector fns=new FilenameSelector();
    fns.setName(input);
    task.addFilename(fns);
  }
 else {
    File dir=new File(input);
    if (dir.canRead() && dir.isDirectory()) {
      task.setSourceRoots(new Path(task.getProject(),input));
    }
  }
  task.setClasspath(new Path(p,""String_Node_Str""));
  task.setVerbose(true);
  return task;
}","protected AjcTask getTask(String input,File destDir){
  AjcTask task=new AjcTask();
  Project p=new Project();
  task.setProject(p);
  if (null != destDir) {
    task.setDestdir(destDir);
  }
  if (NOFILE.equals(input)) {
  }
 else   if (input.endsWith(""String_Node_Str"")) {
    if (-1 != input.indexOf(""String_Node_Str"")) {
      throw new IllegalArgumentException(""String_Node_Str"" + input);
    }
 else     if (null == testdataDir) {
      throw new Error(""String_Node_Str"");
    }
 else {
      String path=testdataDir + File.separator + input;
      task.setArgfiles(new Path(task.getProject(),path));
    }
  }
 else   if ((input.endsWith(""String_Node_Str"") || input.endsWith(""String_Node_Str""))) {
    FilenameSelector fns=new FilenameSelector();
    fns.setName(input);
    task.addFilename(fns);
  }
 else {
    File dir=new File(input);
    if (dir.canRead() && dir.isDirectory()) {
      task.setSourceRoots(new Path(task.getProject(),input));
    }
  }
  task.setClasspath(new Path(p,""String_Node_Str""));
  return task;
}",0.942495126705653
9612,"/** 
 * Generate AjBuildConfig from the local configFile parameter plus global project and build options. Errors signalled using signal... methods.
 * @param configFile
 * @return null if invalid configuration, corresponding AjBuildConfig otherwise
 */
public AjBuildConfig genBuildConfig(String configFile){
  init();
  File config=new File(configFile);
  if (!config.exists()) {
    signalError(""String_Node_Str"" + configFile + ""String_Node_Str"");
    return null;
  }
  String[] args=new String[]{""String_Node_Str"" + config.getAbsolutePath()};
  CountingMessageHandler counter=CountingMessageHandler.makeCountingMessageHandler(messageHandler);
  BuildArgParser parser=new BuildArgParser();
  AjBuildConfig local=parser.genBuildConfig(args,counter,false);
  if (counter.hasErrors()) {
    return null;
  }
  local.setConfigFile(config);
  AjBuildConfig global=new AjBuildConfig();
  BuildOptionsAdapter buildOptions=Ajde.getDefault().getBuildManager().getBuildOptions();
  if (!configureBuildOptions(global,buildOptions,counter)) {
    return null;
  }
  ProjectPropertiesAdapter projectOptions=Ajde.getDefault().getProjectProperties();
  configureProjectOptions(global,projectOptions);
  local.installGlobals(global);
  String errs=local.configErrors();
  if (null != errs) {
    MessageUtil.error(counter,errs);
    return null;
  }
  local.setGenerateModelMode(true);
  return fixupBuildConfig(local,global,buildOptions,projectOptions);
}","/** 
 * Generate AjBuildConfig from the local configFile parameter plus global project and build options. Errors signalled using signal... methods.
 * @param configFile
 * @return null if invalid configuration, corresponding AjBuildConfig otherwise
 */
public AjBuildConfig genBuildConfig(String configFilePath){
  init();
  File configFile=new File(configFilePath);
  if (!configFile.exists()) {
    signalError(""String_Node_Str"" + configFile + ""String_Node_Str"");
    return null;
  }
  String[] args=new String[]{""String_Node_Str"" + configFile.getAbsolutePath()};
  CountingMessageHandler handler=CountingMessageHandler.makeCountingMessageHandler(messageHandler);
  BuildArgParser parser=new BuildArgParser();
  AjBuildConfig config=parser.genBuildConfig(args,handler,false,configFile);
  configureProjectOptions(config,Ajde.getDefault().getProjectProperties());
  AjBuildConfig global=new AjBuildConfig();
  BuildOptionsAdapter buildOptions=Ajde.getDefault().getBuildManager().getBuildOptions();
  if (!configureBuildOptions(global,buildOptions,handler)) {
    return null;
  }
  ProjectPropertiesAdapter projectOptions=Ajde.getDefault().getProjectProperties();
  configureProjectOptions(global,projectOptions);
  config.installGlobals(global);
  ISourceLocation location=null;
  if (config.getConfigFile() != null) {
    location=new SourceLocation(config.getConfigFile(),0);
  }
  String message=parser.getOtherMessages(true);
  if (null != message) {
    IMessage m=new Message(message,IMessage.ERROR,null,location);
    handler.handleMessage(m);
  }
  config.setGenerateModelMode(true);
  if (Ajde.getDefault().getBuildManager().getBuildOptions().getJavaOptionsMap() != null) {
    config.getJavaOptions().putAll(Ajde.getDefault().getBuildManager().getBuildOptions().getJavaOptionsMap());
  }
  return config;
}",0.7431023911710607
9613,"public void init(String[] configFilesArgs,boolean visible){
  try {
    UserPreferencesAdapter preferencesAdapter=new UserPreferencesStore(true);
    browserProjectProperties=new BrowserProperties(preferencesAdapter);
    TaskListManager taskListManager=new CompilerMessagesPanel();
    BasicEditor ajdeEditor=new BasicEditor();
    BrowserUIAdapter browserUIAdapter=new BrowserUIAdapter();
    topFrame=new TopFrame();
    configFiles=getConfigFilesList(configFilesArgs);
    AjdeUIManager.getDefault().init(ajdeEditor,taskListManager,browserProjectProperties,preferencesAdapter,browserUIAdapter,new IconRegistry(),topFrame,true);
    Ajde.getDefault().getBuildManager().addListener(BUILD_MESSAGES_LISTENER);
    MultiStructureViewPanel multiViewPanel=new MultiStructureViewPanel(AjdeUIManager.getDefault().getViewManager().getBrowserPanel(),AjdeUIManager.getDefault().getFileStructurePanel());
    topFrame.init(multiViewPanel,(CompilerMessagesPanel)taskListManager,Ajde.getDefault().getEditorManager().getEditorPanel());
    if (visible)     topFrame.setVisible(true);
    if (configFiles.size() == 0) {
      Ajde.getDefault().getErrorHandler().handleWarning(""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
    }
    AjdeUIManager.getDefault().getOptionsFrame().addOptionsPanel(new BrowserOptionsPanel());
    if (configFilesArgs.length > 0 && configFilesArgs[0] != null) {
      Ajde.getDefault().getConfigurationManager().setActiveConfigFile(configFilesArgs[0]);
    }
  }
 catch (  Throwable t) {
    t.printStackTrace();
    Ajde.getDefault().getErrorHandler().handleError(""String_Node_Str"",t);
  }
}","public void init(String[] configFilesArgs,boolean visible){
  try {
    UserPreferencesAdapter preferencesAdapter=new UserPreferencesStore(true);
    browserProjectProperties=new BrowserProperties(preferencesAdapter);
    TaskListManager taskListManager=new CompilerMessagesPanel();
    BasicEditor ajdeEditor=new BasicEditor();
    BrowserUIAdapter browserUIAdapter=new BrowserUIAdapter();
    topFrame=new TopFrame();
    configFiles=getConfigFilesList(configFilesArgs);
    AjdeUIManager.getDefault().init(ajdeEditor,taskListManager,browserProjectProperties,preferencesAdapter,browserUIAdapter,new IconRegistry(),topFrame);
    editorManager=new EditorManager(ajdeEditor);
    FileStructureView structureView=Ajde.getDefault().getStructureViewManager().createViewForSourceFile(editorManager.getCurrFile(),Ajde.getDefault().getStructureViewManager().getDefaultViewProperties());
    Ajde.getDefault().getStructureViewManager().setDefaultFileView(structureView);
    fileStructurePanel=new StructureViewPanel(structureView);
    Ajde.getDefault().getBuildManager().addListener(BUILD_MESSAGES_LISTENER);
    MultiStructureViewPanel multiViewPanel=new MultiStructureViewPanel(AjdeUIManager.getDefault().getViewManager().getBrowserPanel(),fileStructurePanel);
    topFrame.init(multiViewPanel,(CompilerMessagesPanel)taskListManager,editorManager.getEditorPanel());
    if (visible)     topFrame.setVisible(true);
    if (configFiles.size() == 0) {
      Ajde.getDefault().getErrorHandler().handleWarning(""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
    }
    AjdeUIManager.getDefault().getOptionsFrame().addOptionsPanel(new BrowserOptionsPanel());
    StructureModelManager.getDefault().addListener(VIEW_LISTENER);
    if (configFilesArgs.length > 0 && configFilesArgs[0] != null) {
      Ajde.getDefault().getConfigurationManager().setActiveConfigFile(configFilesArgs[0]);
    }
  }
 catch (  Throwable t) {
    t.printStackTrace();
    Ajde.getDefault().getErrorHandler().handleError(""String_Node_Str"",t);
  }
}",0.6499724821133737
9614,"public void openFile(String filePath){
  try {
    if (filePath.endsWith(""String_Node_Str"")) {
      AjdeUIManager.getDefault().getBuildConfigEditor().openFile(filePath);
      topFrame.setEditorPanel(AjdeUIManager.getDefault().getBuildConfigEditor());
    }
 else     if (filePath.endsWith(""String_Node_Str"") || filePath.endsWith(""String_Node_Str"")) {
      Ajde.getDefault().getEditorManager().showSourceLine(filePath,0,false);
    }
 else {
      Ajde.getDefault().getErrorHandler().handleError(""String_Node_Str"" + filePath + ""String_Node_Str"");
    }
  }
 catch (  IOException ioe) {
    Ajde.getDefault().getErrorHandler().handleError(""String_Node_Str"" + filePath,ioe);
  }
catch (  InvalidResourceException ire) {
    Ajde.getDefault().getErrorHandler().handleError(""String_Node_Str"" + filePath,ire);
  }
  browserProjectProperties.setLastOpenSourceFilePath(filePath);
}","public void openFile(String filePath){
  try {
    if (filePath.endsWith(""String_Node_Str"")) {
      AjdeUIManager.getDefault().getBuildConfigEditor().openFile(filePath);
      topFrame.setEditorPanel(AjdeUIManager.getDefault().getBuildConfigEditor());
    }
 else     if (filePath.endsWith(""String_Node_Str"") || filePath.endsWith(""String_Node_Str"")) {
      editorManager.showSourceLine(filePath,0,false);
    }
 else {
      Ajde.getDefault().getErrorHandler().handleError(""String_Node_Str"" + filePath + ""String_Node_Str"");
    }
  }
 catch (  IOException ioe) {
    Ajde.getDefault().getErrorHandler().handleError(""String_Node_Str"" + filePath,ioe);
  }
catch (  InvalidResourceException ire) {
    Ajde.getDefault().getErrorHandler().handleError(""String_Node_Str"" + filePath,ire);
  }
  browserProjectProperties.setLastOpenSourceFilePath(filePath);
}",0.9855407750144592
9615,"public void saveAll(){
  Ajde.getDefault().getEditorManager().saveContents();
}","public void saveAll(){
  editorManager.saveContents();
}",0.8296296296296296
9616,"/** 
 * called when user double-clicks on a message.
 */
protected void displayMessage(IMessage message){
  ISourceLocation loc=message.getISourceLocation();
  Ajde.getDefault().getEditorManager().showSourceLine(loc,true);
  Throwable thrown=message.getThrown();
  if (null != thrown) {
    Ajde.getDefault().getErrorHandler().handleError(message.getMessage(),thrown);
  }
}","/** 
 * called when user double-clicks on a message.
 */
protected void displayMessage(IMessage message){
  ISourceLocation loc=message.getISourceLocation();
  BrowserManager.getDefault().getEditorManager().showSourceLine(loc,true);
  Throwable thrown=message.getThrown();
  if (null != thrown) {
    Ajde.getDefault().getErrorHandler().handleError(message.getMessage(),thrown);
  }
}",0.5065963060686016
9617,"void save_button_actionPerformed(ActionEvent e){
  Ajde.getDefault().getEditorManager().saveContents();
}","void save_button_actionPerformed(ActionEvent e){
  BrowserManager.getDefault().getEditorManager().saveContents();
}",0.9272727272727272
9618,"void jMenuItem1_actionPerformed(ActionEvent e){
  Ajde.getDefault().getEditorManager().saveContents();
}","void jMenuItem1_actionPerformed(ActionEvent e){
  BrowserManager.getDefault().getEditorManager().saveContents();
}",0.926605504587156
9619,"public void resolve(ClassScope upperScope){
  if (ignoreFurtherInvestigation)   return;
  ClassScope newParent=new InterTypeScope(upperScope,onTypeBinding);
  scope.parent=newParent;
  this.scope.isStatic=Modifier.isStatic(declaredModifiers);
  super.resolve(newParent);
  fixSuperCallsInBody();
}","public void resolve(ClassScope upperScope){
  if (ignoreFurtherInvestigation)   return;
  ClassScope newParent=new InterTypeScope(upperScope,onTypeBinding);
  scope.parent=newParent;
  this.scope.isStatic=Modifier.isStatic(declaredModifiers);
  fixSuperCallsForInterfaceContext(upperScope);
  if (ignoreFurtherInvestigation)   return;
  super.resolve(newParent);
  fixSuperCallsInBody();
}",0.8658892128279884
9620,"/** 
 * Generate AjBuildConfig from the local configFile parameter plus global project and build options. Errors signalled using signal... methods.
 * @param configFile
 * @return null if invalid configuration, corresponding AjBuildConfig otherwise
 */
public AjBuildConfig genBuildConfig(String configFile){
  init();
  File config=new File(configFile);
  if (!config.exists()) {
    signalError(""String_Node_Str"" + configFile + ""String_Node_Str"");
    return null;
  }
  String[] args=new String[]{""String_Node_Str"" + config.getAbsolutePath()};
  CountingMessageHandler counter=CountingMessageHandler.makeCountingMessageHandler(messageHandler);
  AjBuildConfig local=AjdtCommand.genBuildConfig(args,counter);
  if (counter.hasErrors()) {
    return null;
  }
  local.setConfigFile(config);
  AjBuildConfig global=new AjBuildConfig();
  BuildOptionsAdapter buildOptions=Ajde.getDefault().getBuildManager().getBuildOptions();
  if (!configureBuildOptions(global,buildOptions,counter)) {
    return null;
  }
  ProjectPropertiesAdapter projectOptions=Ajde.getDefault().getProjectProperties();
  configureProjectOptions(global,projectOptions);
  local.installGlobals(global);
  String errs=local.configErrors();
  if (null != errs) {
    MessageUtil.error(counter,errs);
    return null;
  }
  local.setGenerateModelMode(true);
  return fixupBuildConfig(local,global,buildOptions,projectOptions);
}","/** 
 * Generate AjBuildConfig from the local configFile parameter plus global project and build options. Errors signalled using signal... methods.
 * @param configFile
 * @return null if invalid configuration, corresponding AjBuildConfig otherwise
 */
public AjBuildConfig genBuildConfig(String configFile){
  init();
  File config=new File(configFile);
  if (!config.exists()) {
    signalError(""String_Node_Str"" + configFile + ""String_Node_Str"");
    return null;
  }
  String[] args=new String[]{""String_Node_Str"" + config.getAbsolutePath()};
  CountingMessageHandler counter=CountingMessageHandler.makeCountingMessageHandler(messageHandler);
  BuildArgParser parser=new BuildArgParser();
  AjBuildConfig local=parser.genBuildConfig(args,counter,false);
  if (counter.hasErrors()) {
    return null;
  }
  local.setConfigFile(config);
  AjBuildConfig global=new AjBuildConfig();
  BuildOptionsAdapter buildOptions=Ajde.getDefault().getBuildManager().getBuildOptions();
  if (!configureBuildOptions(global,buildOptions,counter)) {
    return null;
  }
  ProjectPropertiesAdapter projectOptions=Ajde.getDefault().getProjectProperties();
  configureProjectOptions(global,projectOptions);
  local.installGlobals(global);
  String errs=local.configErrors();
  if (null != errs) {
    MessageUtil.error(counter,errs);
    return null;
  }
  local.setGenerateModelMode(true);
  return fixupBuildConfig(local,global,buildOptions,projectOptions);
}",0.969355406833392
9621,"/** 
 * Generate build configuration for the input args, passing to handler any error messages.
 * @param args the String[] arguments for the build configuration
 * @param handler the IMessageHandler handler for any errors
 * @return AjBuildConfig per args, which will be invalid unless there are no handler errors.
 */
public AjBuildConfig genBuildConfig(String[] args,IMessageHandler handler){
  AjBuildConfig buildConfig=new AjBuildConfig();
  try {
    super.filenames=new String[]{""String_Node_Str""};
    List fileList=new ArrayList();
    AjcConfigParser parser=new AjcConfigParser(buildConfig,handler);
    parser.parseCommandLine(args);
    boolean incrementalMode=buildConfig.isIncrementalMode() || buildConfig.isIncrementalFileMode();
    List files=parser.getFiles();
    if (!LangUtil.isEmpty(files)) {
      if (incrementalMode) {
        MessageUtil.error(handler,""String_Node_Str"");
      }
 else {
        fileList.addAll(files);
      }
    }
    List javaArgList=new ArrayList();
    javaArgList.add(""String_Node_Str"");
    javaArgList.add(""String_Node_Str"");
    javaArgList.add(System.getProperty(""String_Node_Str""));
    javaArgList.add(""String_Node_Str"");
    javaArgList.add(System.getProperty(""String_Node_Str""));
    javaArgList.addAll(parser.getUnparsedArgs());
    super.configure((String[])javaArgList.toArray(new String[javaArgList.size()]));
    if (buildConfig.getSourceRoots() != null) {
      for (Iterator i=buildConfig.getSourceRoots().iterator(); i.hasNext(); ) {
        fileList.addAll(collectSourceRootFiles((File)i.next()));
      }
    }
    buildConfig.setFiles(fileList);
    if (destinationPath != null) {
      buildConfig.setOutputDir(new File(destinationPath));
    }
    buildConfig.setClasspath(getClasspath(parser));
    if (incrementalMode && (0 == buildConfig.getSourceRoots().size())) {
      MessageUtil.error(handler,""String_Node_Str"");
    }
    setDebugOptions();
    buildConfig.setJavaOptions(options);
  }
 catch (  InvalidInputException iie) {
    MessageUtil.error(handler,iie.getMessage());
  }
  return buildConfig;
}","/** 
 * Generate build configuration for the input args, passing to handler any error messages.
 * @param args the String[] arguments for the build configuration
 * @param handler the IMessageHandler handler for any errors
 * @param setClasspath	determines if the classpath should be parsed and set on the build configuration
 * @return AjBuildConfig per args, which will be invalid unless there are no handler errors.
 */
public AjBuildConfig genBuildConfig(String[] args,IMessageHandler handler,boolean setClasspath){
  AjBuildConfig buildConfig=new AjBuildConfig();
  try {
    super.filenames=new String[]{""String_Node_Str""};
    List fileList=new ArrayList();
    AjcConfigParser parser=new AjcConfigParser(buildConfig,handler);
    parser.parseCommandLine(args);
    boolean incrementalMode=buildConfig.isIncrementalMode() || buildConfig.isIncrementalFileMode();
    List files=parser.getFiles();
    if (!LangUtil.isEmpty(files)) {
      if (incrementalMode) {
        MessageUtil.error(handler,""String_Node_Str"");
      }
 else {
        fileList.addAll(files);
      }
    }
    List javaArgList=new ArrayList();
    javaArgList.add(""String_Node_Str"");
    javaArgList.add(""String_Node_Str"");
    javaArgList.add(System.getProperty(""String_Node_Str""));
    javaArgList.add(""String_Node_Str"");
    javaArgList.add(System.getProperty(""String_Node_Str""));
    javaArgList.addAll(parser.getUnparsedArgs());
    super.configure((String[])javaArgList.toArray(new String[javaArgList.size()]));
    if (buildConfig.getSourceRoots() != null) {
      for (Iterator i=buildConfig.getSourceRoots().iterator(); i.hasNext(); ) {
        fileList.addAll(collectSourceRootFiles((File)i.next()));
      }
    }
    buildConfig.setFiles(fileList);
    if (destinationPath != null) {
      buildConfig.setOutputDir(new File(destinationPath));
    }
    if (setClasspath) {
      buildConfig.setClasspath(getClasspath(parser));
    }
    if (incrementalMode && (0 == buildConfig.getSourceRoots().size())) {
      MessageUtil.error(handler,""String_Node_Str"");
    }
    setDebugOptions();
    buildConfig.setJavaOptions(options);
  }
 catch (  InvalidInputException iie) {
    MessageUtil.error(handler,iie.getMessage());
  }
  return buildConfig;
}",0.9638721630384436
9622,"public void resolveStatements(){
  if (binding == null || ignoreFurtherInvestigation)   return;
  ClassScope upperScope=(ClassScope)scope.parent;
  modifiers=binding.modifiers=checkAndSetModifiers(modifiers,upperScope);
  if (kind == AdviceKind.AfterThrowing && extraArgument != null) {
    TypeBinding argTb=extraArgument.binding.type;
    TypeBinding expectedTb=upperScope.getJavaLangThrowable();
    if (!argTb.isCompatibleWith(expectedTb)) {
      scope.problemReporter().typeMismatchError(argTb,expectedTb,extraArgument);
      ignoreFurtherInvestigation=true;
      return;
    }
  }
  pointcutDesignator.finishResolveTypes(this,this.binding,baseArgumentCount,upperScope.referenceContext.binding);
  if (binding == null || ignoreFurtherInvestigation)   return;
  if (kind == AdviceKind.Around) {
    ReferenceBinding[] exceptions=new ReferenceBinding[]{upperScope.getJavaLangThrowable()};
    proceedMethodBinding=new MethodBinding(Modifier.STATIC,""String_Node_Str"".toCharArray(),binding.returnType,resize(baseArgumentCount + 1,binding.parameters),exceptions,binding.declaringClass);
    proceedMethodBinding.selector=CharArrayOps.concat(selector,proceedMethodBinding.selector);
  }
  super.resolveStatements();
  if (binding != null)   determineExtraArgumentFlags();
  if (kind == AdviceKind.Around) {
    int n=proceedCalls.size();
    EclipseFactory world=EclipseFactory.fromScopeLookupEnvironment(upperScope);
    formalsUnchangedToProceed=new boolean[baseArgumentCount];
    proceedCallSignatures=new ResolvedMember[0];
    proceedInInners=false;
    declaredExceptions=new TypeX[0];
    for (int i=0; i < n; i++) {
      Proceed call=(Proceed)proceedCalls.get(i);
      if (call.inInner) {
        proceedInInners=true;
      }
    }
    if (!proceedInInners) {
      PrivilegedHandler handler=(PrivilegedHandler)upperScope.referenceContext.binding.privilegedHandler;
      if (handler == null) {
        handler=new PrivilegedHandler((AspectDeclaration)upperScope.referenceContext);
        upperScope.referenceContext.binding.privilegedHandler=handler;
      }
      this.traverse(new MakeDeclsPublicVisitor(),(ClassScope)null);
      AccessForInlineVisitor v=new AccessForInlineVisitor((AspectDeclaration)upperScope.referenceContext,handler);
      this.traverse(v,(ClassScope)null);
      if (!v.isInlinable)       proceedInInners=true;
    }
  }
}","public void resolveStatements(){
  if (binding == null || ignoreFurtherInvestigation)   return;
  ClassScope upperScope=(ClassScope)scope.parent;
  modifiers=binding.modifiers=checkAndSetModifiers(modifiers,upperScope);
  if (kind == AdviceKind.AfterThrowing && extraArgument != null) {
    TypeBinding argTb=extraArgument.binding.type;
    TypeBinding expectedTb=upperScope.getJavaLangThrowable();
    if (!argTb.isCompatibleWith(expectedTb)) {
      scope.problemReporter().typeMismatchError(argTb,expectedTb,extraArgument);
      ignoreFurtherInvestigation=true;
      return;
    }
  }
  pointcutDesignator.finishResolveTypes(this,this.binding,baseArgumentCount,upperScope.referenceContext.binding);
  if (binding == null || ignoreFurtherInvestigation)   return;
  if (kind == AdviceKind.Around) {
    ReferenceBinding[] exceptions=new ReferenceBinding[]{upperScope.getJavaLangThrowable()};
    proceedMethodBinding=new MethodBinding(Modifier.STATIC,""String_Node_Str"".toCharArray(),binding.returnType,resize(baseArgumentCount + 1,binding.parameters),exceptions,binding.declaringClass);
    proceedMethodBinding.selector=CharArrayOps.concat(selector,proceedMethodBinding.selector);
  }
  super.resolveStatements();
  if (binding != null)   determineExtraArgumentFlags();
  if (kind == AdviceKind.Around) {
    int n=proceedCalls.size();
    EclipseFactory world=EclipseFactory.fromScopeLookupEnvironment(upperScope);
    formalsUnchangedToProceed=new boolean[baseArgumentCount];
    proceedCallSignatures=new ResolvedMember[0];
    proceedInInners=false;
    declaredExceptions=new TypeX[0];
    for (int i=0; i < n; i++) {
      Proceed call=(Proceed)proceedCalls.get(i);
      if (call.inInner) {
        proceedInInners=true;
      }
    }
    if (!proceedInInners) {
      PrivilegedHandler handler=(PrivilegedHandler)upperScope.referenceContext.binding.privilegedHandler;
      if (handler == null) {
        handler=new PrivilegedHandler((AspectDeclaration)upperScope.referenceContext);
      }
      this.traverse(new MakeDeclsPublicVisitor(),(ClassScope)null);
      AccessForInlineVisitor v=new AccessForInlineVisitor((AspectDeclaration)upperScope.referenceContext,handler);
      this.traverse(v,(ClassScope)null);
      if (!v.isInlinable)       proceedInInners=true;
    }
  }
}",0.9847541335623792
9623,"public MethodBinding getPrivilegedAccessMethod(MethodBinding baseMethod,AstNode location){
  if (baseMethod.alwaysNeedsAccessMethod())   return baseMethod;
  ResolvedMember key=inAspect.factory.makeResolvedMember(baseMethod);
  if (accessors.containsKey(key))   return (MethodBinding)accessors.get(key);
  MethodBinding ret;
  if (baseMethod.isConstructor()) {
    ret=baseMethod;
  }
 else {
    ret=inAspect.factory.makeMethodBinding(AjcMemberMaker.privilegedAccessMethodForMethod(inAspect.typeX,key));
  }
  checkWeaveAccess(key.getDeclaringType(),location);
  accessors.put(key,ret);
  return ret;
}","public MethodBinding getPrivilegedAccessMethod(MethodBinding baseMethod,AstNode location){
  if (baseMethod.alwaysNeedsAccessMethod())   return baseMethod;
  ResolvedMember key=EclipseFactory.makeResolvedMember(baseMethod);
  if (accessors.containsKey(key))   return (MethodBinding)accessors.get(key);
  MethodBinding ret;
  if (baseMethod.isConstructor()) {
    ret=new MethodBinding(baseMethod,baseMethod.declaringClass);
    ret.modifiers=AstUtil.makePublic(ret.modifiers);
  }
 else {
    ret=inAspect.factory.makeMethodBinding(AjcMemberMaker.privilegedAccessMethodForMethod(inAspect.typeX,key));
  }
  checkWeaveAccess(key.getDeclaringType(),location);
  accessors.put(key,ret);
  return ret;
}",0.6559139784946236
9624,"public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  String label=""String_Node_Str"";
  String detail=null;
  IMessage.Kind kind=IMessage.INFO;
  if (value instanceof CompilerMessage) {
    CompilerMessage cm=(CompilerMessage)value;
    label=cm.message.getMessage();
    if (LangUtil.isEmpty(label)) {
      label=cm.message.toString();
    }
    kind=cm.message.getKind();
    Throwable thrown=cm.message.getThrown();
    if (null != thrown) {
      detail=LangUtil.renderException(thrown);
    }
  }
 else   if (null != value) {
    label=value.toString();
  }
  setText(label);
  if (kind.equals(IMessage.WARNING)) {
    setIcon(AjdeUIManager.getDefault().getIconRegistry().getWarningIcon());
  }
 else   if (IMessage.ERROR.isSameOrLessThan(kind)) {
    setIcon(AjdeUIManager.getDefault().getIconRegistry().getErrorIcon());
  }
 else {
    setIcon(null);
  }
  if (isSelected) {
    setBackground(list.getSelectionBackground());
    setForeground(list.getSelectionForeground());
  }
 else {
    setBackground(list.getBackground());
    setForeground(list.getForeground());
  }
  setEnabled(list.isEnabled());
  setFont(list.getFont());
  setOpaque(true);
  if (null != detail) {
    setToolTipText(detail);
  }
  return this;
}","public Component getListCellRendererComponent(JList list,Object value,int index,boolean isSelected,boolean cellHasFocus){
  String label=""String_Node_Str"";
  String detail=null;
  IMessage.Kind kind=IMessage.INFO;
  if (value instanceof IMessage) {
    IMessage cm=(IMessage)value;
    label=cm.getMessage();
    if (LangUtil.isEmpty(label)) {
      label=cm.getMessage().toString();
    }
    kind=cm.getKind();
    Throwable thrown=cm.getThrown();
    if (null != thrown) {
      detail=LangUtil.renderException(thrown);
    }
  }
 else   if (null != value) {
    label=value.toString();
  }
  setText(label);
  if (kind.equals(IMessage.WARNING)) {
    setIcon(AjdeUIManager.getDefault().getIconRegistry().getWarningIcon());
  }
 else   if (IMessage.ERROR.isSameOrLessThan(kind)) {
    setIcon(AjdeUIManager.getDefault().getIconRegistry().getErrorIcon());
  }
 else {
    setIcon(null);
  }
  if (isSelected) {
    setBackground(list.getSelectionBackground());
    setForeground(list.getSelectionForeground());
  }
 else {
    setBackground(list.getBackground());
    setForeground(list.getForeground());
  }
  setEnabled(list.isEnabled());
  setFont(list.getFont());
  setOpaque(true);
  if (null != detail) {
    setToolTipText(detail);
  }
  return this;
}",0.9297423887587822
9625,"/** 
 * Compile using ajc per settings.
 * @exception BuildException if the compilation has problemsor if there were compiler errors and failonerror is true.
 */
public void execute() throws BuildException {
  if (executing) {
    throw new IllegalStateException(""String_Node_Str"");
  }
 else {
    executing=true;
  }
  try {
    String[] args=makeCommand();
    if (verbose || listFileArgs) {
      log(""String_Node_Str"" + Arrays.asList(args),Project.MSG_VERBOSE);
    }
    if (!fork) {
      executeInSameVM(args);
    }
 else {
      executeInOtherVM(args);
    }
  }
 catch (  BuildException e) {
    throw e;
  }
catch (  Throwable x) {
    System.err.println(Main.renderExceptionForUser(x));
    throw new BuildException(""String_Node_Str"" + LangUtil.unqualifiedClassName(x) + ""String_Node_Str"");
  }
 finally {
    executing=false;
    if (null != tmpOutjar) {
      tmpOutjar.delete();
    }
  }
}","/** 
 * Compile using ajc per settings.
 * @exception BuildException if the compilation has problemsor if there were compiler errors and failonerror is true.
 */
public void execute() throws BuildException {
  if (executing) {
    throw new IllegalStateException(""String_Node_Str"");
  }
 else {
    executing=true;
  }
  verifyOptions();
  try {
    String[] args=makeCommand();
    if (verbose || listFileArgs) {
      log(""String_Node_Str"" + Arrays.asList(args),Project.MSG_VERBOSE);
    }
    if (!fork) {
      executeInSameVM(args);
    }
 else {
      executeInOtherVM(args);
    }
  }
 catch (  BuildException e) {
    throw e;
  }
catch (  Throwable x) {
    System.err.println(Main.renderExceptionForUser(x));
    throw new BuildException(""String_Node_Str"" + LangUtil.unqualifiedClassName(x) + ""String_Node_Str"");
  }
 finally {
    executing=false;
    if (null != tmpOutjar) {
      tmpOutjar.delete();
    }
  }
}",0.9896231567449482
9626,"/** 
 * to use this same Task more than once (testing) 
 */
public void reset(){
  adapterArguments=null;
  adapterFiles=new ArrayList();
  argfiles=null;
  executing=false;
  aspectpath=null;
  bootclasspath=null;
  classpath=null;
  cmd=new GuardedCommand();
  cmdLength=0;
  copyInjars=false;
  destDir=DEFAULT_DESTDIR;
  executing=false;
  executingInOtherVM=false;
  extdirs=null;
  failonerror=false;
  forkclasspath=null;
  inIncrementalMode=false;
  inIncrementalFileMode=false;
  ignored=new ArrayList();
  injars=null;
  listFileArgs=false;
  maxMem=null;
  messageHolder=null;
  outjar=null;
  sourceRootCopyFilter=null;
  sourceRoots=null;
  srcdir=null;
  tmpOutjar=null;
  verbose=false;
}","/** 
 * to use this same Task more than once (testing) 
 */
public void reset(){
  adapterArguments=null;
  adapterFiles=new ArrayList();
  argfiles=null;
  executing=false;
  aspectpath=null;
  bootclasspath=null;
  classpath=null;
  cmd=new GuardedCommand();
  copyInjars=false;
  destDir=DEFAULT_DESTDIR;
  executing=false;
  executingInOtherVM=false;
  extdirs=null;
  failonerror=true;
  forkclasspath=null;
  inIncrementalMode=false;
  inIncrementalFileMode=false;
  ignored=new ArrayList();
  injars=null;
  listFileArgs=false;
  maxMem=null;
  messageHolder=null;
  outjar=null;
  sourceRootCopyFilter=null;
  sourceRoots=null;
  srcdir=null;
  tmpOutjar=null;
  verbose=false;
}",0.9841726618705036
9627,"/** 
 * Execute in a separate VM. Differences from normal same-VM execution: <ul> <li>ignores any message holder {class} set</li> <li>No resource-copying between interative runs</li> <li>failonerror fails when process interface fails  to return negative values</li> </ul>
 * @param args String[] of the complete compiler command to execute
 * @see DefaultCompilerAdapter#executeExternalCompile(String[],int)
 * @throws BuildException if ajc aborts (negative value)or if failonerror and there were compile errors.
 */
protected void executeInOtherVM(String[] args){
  if (null != messageHolder) {
    log(""String_Node_Str"" + messageHolder.getClass().getName(),Project.MSG_WARN);
  }
  CommandlineJava javaCmd=new CommandlineJava();
  javaCmd.setClassname(org.aspectj.tools.ajc.Main.class.getName());
  final Path vmClasspath=javaCmd.createClasspath(getProject());
  if ((null != forkclasspath) && (0 != forkclasspath.size())) {
    vmClasspath.addExisting(forkclasspath);
  }
 else {
    File aspectjtools=findAspectjtoolsJar();
    if (null != aspectjtools) {
      vmClasspath.createPathElement().setLocation(aspectjtools);
    }
  }
  if (null != maxMem) {
    javaCmd.setMaxmemory(maxMem);
  }
  File tempFile=null;
  int numArgs=args.length;
  args=GuardedCommand.limitTo(args,MAX_COMMANDLINE,getLocation());
  if (args.length != numArgs) {
    tempFile=new File(args[1]);
  }
  try {
    String[] javaArgs=javaCmd.getCommandline();
    String[] both=new String[javaArgs.length + args.length];
    System.arraycopy(javaArgs,0,both,0,javaArgs.length);
    System.arraycopy(args,0,both,javaArgs.length,args.length);
    if (both[0].endsWith(""String_Node_Str"")) {
      String path=both[0];
      path=path.substring(0,path.length() - 4);
      path=path + ""String_Node_Str"";
      File javaw=new File(path);
      if (javaw.canRead() && javaw.isFile()) {
        both[0]=path;
      }
    }
    if (verbose) {
      log(""String_Node_Str"" + Arrays.asList(both));
    }
    int result=execInOtherVM(both);
    if (0 > result) {
      throw new BuildException(""String_Node_Str"" + result + ""String_Node_Str"");
    }
 else     if (failonerror && (0 < result)) {
      throw new BuildException(""String_Node_Str"" + result);
    }
    doCompletionTasks();
  }
  finally {
    if (null != tempFile) {
      tempFile.delete();
    }
  }
}","/** 
 * Execute in a separate VM. Differences from normal same-VM execution: <ul> <li>ignores any message holder {class} set</li> <li>No resource-copying between interative runs</li> <li>failonerror fails when process interface fails  to return negative values</li> </ul>
 * @param args String[] of the complete compiler command to execute
 * @see DefaultCompilerAdapter#executeExternalCompile(String[],int)
 * @throws BuildException if ajc aborts (negative value)or if failonerror and there were compile errors.
 */
protected void executeInOtherVM(String[] args){
  if (null != messageHolder) {
    log(""String_Node_Str"" + messageHolder.getClass().getName(),Project.MSG_WARN);
  }
  CommandlineJava javaCmd=new CommandlineJava();
  javaCmd.setClassname(org.aspectj.tools.ajc.Main.class.getName());
  final Path vmClasspath=javaCmd.createClasspath(getProject());
{
    File aspectjtools=null;
    int vmClasspathSize=vmClasspath.size();
    if ((null != forkclasspath) && (0 != forkclasspath.size())) {
      vmClasspath.addExisting(forkclasspath);
    }
 else {
      aspectjtools=findAspectjtoolsJar();
      if (null != aspectjtools) {
        vmClasspath.createPathElement().setLocation(aspectjtools);
      }
    }
    int newVmClasspathSize=vmClasspath.size();
    if (vmClasspathSize == newVmClasspathSize) {
      String m=""String_Node_Str"";
      if (null != aspectjtools) {
        m+=""String_Node_Str"" + aspectjtools.toString();
      }
 else       if (null != forkclasspath) {
        m+=""String_Node_Str"" + forkclasspath.toString();
      }
 else {
        m+=""String_Node_Str"";
      }
      throw new BuildException(m);
    }
  }
  if (null != maxMem) {
    javaCmd.setMaxmemory(maxMem);
  }
  File tempFile=null;
  int numArgs=args.length;
  args=GuardedCommand.limitTo(args,MAX_COMMANDLINE,getLocation());
  if (args.length != numArgs) {
    tempFile=new File(args[1]);
  }
  try {
    String[] javaArgs=javaCmd.getCommandline();
    String[] both=new String[javaArgs.length + args.length];
    System.arraycopy(javaArgs,0,both,0,javaArgs.length);
    System.arraycopy(args,0,both,javaArgs.length,args.length);
    if (both[0].endsWith(""String_Node_Str"")) {
      String path=both[0];
      path=path.substring(0,path.length() - 4);
      path=path + ""String_Node_Str"";
      File javaw=new File(path);
      if (javaw.canRead() && javaw.isFile()) {
        both[0]=path;
      }
    }
    if (verbose) {
      log(""String_Node_Str"" + Arrays.asList(both));
    }
    int result=execInOtherVM(both);
    if (0 > result) {
      throw new BuildException(""String_Node_Str"" + result + ""String_Node_Str"");
    }
 else     if (failonerror && (0 < result)) {
      throw new BuildException(""String_Node_Str"" + result);
    }
    doCompletionTasks();
  }
  finally {
    if (null != tempFile) {
      tempFile.delete();
    }
  }
}",0.8998065764023211
9628,"/** 
 * Find aspectjtools.jar in the system classpath. Accept <code>aspectj{-}tools{...}.jar</code> mainly to support build systems using maven-style  re-naming  (e.g., <code>aspectj-tools-1.1.0.jar</code>.
 * @return readable File for aspectjtools.jar, or null if not found.
 */
public static File findAspectjtoolsJar(){
  final Path classpath=Path.systemClasspath;
  final String[] paths=classpath.list();
  final String prefix=""String_Node_Str"";
  final String infix=""String_Node_Str"";
  final String altInfix=""String_Node_Str"";
  final String suffix=""String_Node_Str"";
  final int prefixLength=prefix.length();
  final int minLength=prefixLength + infix.length() + suffix.length();
  for (int i=0; i < paths.length; i++) {
    String path=paths[i];
    if (!paths[i].endsWith(suffix)) {
      continue;
    }
    int loc=path.lastIndexOf(prefix);
    if ((-1 != loc) && ((loc + minLength) <= path.length())) {
      String rest=path.substring(loc + prefixLength);
      if (-1 != rest.indexOf(File.pathSeparator)) {
        continue;
      }
      if (rest.startsWith(infix) || rest.startsWith(altInfix)) {
        File result=new File(path);
        if (result.canRead() && result.isFile()) {
          return result;
        }
      }
    }
  }
  return null;
}","/** 
 * Find aspectjtools.jar on the task or system classpath. Accept <code>aspectj{-}tools{...}.jar</code> mainly to support build systems using maven-style  re-naming  (e.g., <code>aspectj-tools-1.1.0.jar</code>. Note that we search the task classpath first,  though an entry on the system classpath would be loaded first, because it seems more correct as the more specific one.
 * @return readable File for aspectjtools.jar, or null if not found.
 */
public static File findAspectjtoolsJar(){
  File result=null;
  ClassLoader loader=AjcTask.class.getClassLoader();
  if (loader instanceof AntClassLoader) {
    AntClassLoader taskLoader=(AntClassLoader)loader;
    String cp=taskLoader.getClasspath();
    String[] cps=LangUtil.splitClasspath(cp);
    for (int i=0; (i < cps.length) && (null == result); i++) {
      result=isAspectjtoolsjar(cps[i]);
    }
  }
  if (null == result) {
    final Path classpath=Path.systemClasspath;
    final String[] paths=classpath.list();
    for (int i=0; (i < paths.length) && (null == result); i++) {
      result=isAspectjtoolsjar(paths[i]);
    }
  }
  return (null == result ? null : result.getAbsoluteFile());
}",0.3909278350515464
9629,"public void setIncremental(boolean incremental){
  cmd.addFlag(""String_Node_Str"",incremental);
  inIncrementalMode=true;
}","public void setIncremental(boolean incremental){
  cmd.addFlag(""String_Node_Str"",incremental);
  inIncrementalMode=incremental;
}",0.9482071713147412
9630,"public void testCompileErrorList(){
  AjcTask task=getTask(""String_Node_Str"");
  runTest(task,NO_EXCEPTION,MessageHolderChecker.ONE_ERROR);
}","public void testCompileErrorList(){
  AjcTask task=getTask(""String_Node_Str"");
  task.setFailonerror(false);
  runTest(task,NO_EXCEPTION,MessageHolderChecker.ONE_ERROR);
}",0.903846153846154
9631,"public void testCompileErrorFile(){
  AjcTask task=getTask(""String_Node_Str"");
  runTest(task,NO_EXCEPTION,MessageHolderChecker.ONE_ERROR);
}","public void testCompileErrorFile(){
  AjcTask task=getTask(""String_Node_Str"");
  task.setFailonerror(false);
  runTest(task,NO_EXCEPTION,MessageHolderChecker.ONE_ERROR);
}",0.903846153846154
9632,"public void testCompileWarningFile(){
  AjcTask task=getTask(""String_Node_Str"");
  runTest(task,NO_EXCEPTION,MessageHolderChecker.ONE_WARNING);
}","public void testCompileWarningFile(){
  AjcTask task=getTask(""String_Node_Str"");
  task.setFailonerror(false);
  runTest(task,NO_EXCEPTION,MessageHolderChecker.ONE_WARNING);
}",0.90625
9633,"public void testNoSuchFile(){
  AjcTask task=getTask(""String_Node_Str"");
  runTest(task,NO_EXCEPTION,MessageHolderChecker.ONE_ERROR_ONE_ABORT);
}","public void testNoSuchFile(){
  AjcTask task=getTask(""String_Node_Str"");
  task.setFailonerror(false);
  runTest(task,NO_EXCEPTION,MessageHolderChecker.ONE_ERROR_ONE_ABORT);
}",0.90625
9634,"public void testFindAspectjtoolsJar(){
  File toolsJar=AjcTask.findAspectjtoolsJar();
}","public void testFindAspectjtoolsJar(){
  File toolsJar=AjcTask.findAspectjtoolsJar();
  if (null != toolsJar) {
    assertNull(""String_Node_Str"" + toolsJar,toolsJar);
  }
}",0.6718146718146718
9635,"public void testNoSuchFileList(){
  AjcTask task=getTask(""String_Node_Str"");
  runTest(task,NO_EXCEPTION,MessageHolderChecker.ONE_ERROR_ONE_ABORT);
}","public void testNoSuchFileList(){
  AjcTask task=getTask(""String_Node_Str"");
  task.setFailonerror(false);
  runTest(task,NO_EXCEPTION,MessageHolderChecker.ONE_ERROR_ONE_ABORT);
}",0.9085365853658536
9636,"public void testNoFile(){
  AjcTask task=getTask(NOFILE);
  runTest(task,NO_EXCEPTION,MessageHolderChecker.ONE_ERROR_ONE_ABORT);
}","public void testNoFile(){
  AjcTask task=getTask(NOFILE);
  task.setFailonerror(false);
  runTest(task,NO_EXCEPTION,MessageHolderChecker.ONE_ERROR_ONE_ABORT);
}",0.896551724137931
9637,"public void outputClassFiles(CompilationResult unitResult){
  if (unitResult == null)   return;
  String sourceFileName=new String(unitResult.fileName);
  if (!(unitResult.hasErrors() && !proceedOnError())) {
    List unwovenClassFiles=new ArrayList();
    Enumeration classFiles=unitResult.compiledTypes.elements();
    while (classFiles.hasMoreElements()) {
      ClassFile classFile=(ClassFile)classFiles.nextElement();
      String filename=new String(classFile.fileName());
      filename=filename.replace('/',File.separatorChar) + ""String_Node_Str"";
      File destinationPath=buildConfig.getOutputDir();
      if (destinationPath == null) {
        destinationPath=new File(extractDestinationPathFromSourceFile(unitResult));
      }
      filename=new File(destinationPath,filename).getPath();
      unwovenClassFiles.add(new UnwovenClassFile(filename,classFile.getBytes()));
    }
    state.noteClassesFromFile(unitResult,sourceFileName,unwovenClassFiles);
  }
 else {
    state.noteClassesFromFile(null,sourceFileName,Collections.EMPTY_LIST);
  }
}","public void outputClassFiles(CompilationResult unitResult){
  if (unitResult == null)   return;
  String sourceFileName=new String(unitResult.fileName);
  if (!(unitResult.hasErrors() && !proceedOnError())) {
    List unwovenClassFiles=new ArrayList();
    Enumeration classFiles=unitResult.compiledTypes.elements();
    while (classFiles.hasMoreElements()) {
      ClassFile classFile=(ClassFile)classFiles.nextElement();
      String filename=new String(classFile.fileName());
      filename=filename.replace('/',File.separatorChar) + ""String_Node_Str"";
      File destinationPath=buildConfig.getOutputDir();
      if (destinationPath == null) {
        filename=new File(filename).getName();
        filename=new File(extractDestinationPathFromSourceFile(unitResult),filename).getPath();
      }
 else {
        filename=new File(destinationPath,filename).getPath();
      }
      unwovenClassFiles.add(new UnwovenClassFile(filename,classFile.getBytes()));
    }
    state.noteClassesFromFile(unitResult,sourceFileName,unwovenClassFiles);
  }
 else {
    state.noteClassesFromFile(null,sourceFileName,Collections.EMPTY_LIST);
  }
}",0.9146508443633043
9638,"/** 
 * returns -1 if no source line attribute 
 */
public static int getSourceLine(InstructionHandle ih){
  if (ih == null)   return -1;
  InstructionTargeter[] ts=ih.getTargeters();
  if (ts != null) {
    for (int j=ts.length - 1; j >= 0; j--) {
      InstructionTargeter t=ts[j];
      if (t instanceof LineNumberTag) {
        return ((LineNumberTag)t).getLineNumber();
      }
    }
  }
  return getSourceLine(ih.getNext());
}","/** 
 * returns -1 if no source line attribute 
 */
public static int getSourceLine(InstructionHandle ih){
  int lookahead=0;
  while (lookahead++ < 100) {
    if (ih == null)     return -1;
    InstructionTargeter[] ts=ih.getTargeters();
    if (ts != null) {
      for (int j=ts.length - 1; j >= 0; j--) {
        InstructionTargeter t=ts[j];
        if (t instanceof LineNumberTag) {
          return ((LineNumberTag)t).getLineNumber();
        }
      }
    }
    ih=ih.getNext();
  }
  return -1;
}",0.8727272727272727
9639,"/** 
 * Read arguments in as if from a command line,  mainly to support compiler adapter compilerarg subelement. 
 * @param args the String[] of arguments to read
 */
public void readArguments(String[] args){
  if ((null == args) || (0 == args.length)) {
    return;
  }
  /** 
 * String[] wrapper with increment, error reporting 
 */
class Args {
    final String[] args;
    int index=0;
    Args(    String[] args){
      this.args=args;
    }
    boolean hasNext(){
      return index < args.length;
    }
    String next(){
      String err=null;
      if (!hasNext()) {
        err=""String_Node_Str"" + args[args.length - 1];
      }
 else {
        String s=args[index++];
        if (null == s) {
          err=""String_Node_Str"";
        }
 else {
          s=s.trim();
          if (0 == s.trim().length()) {
            err=""String_Node_Str"";
          }
 else {
            return s;
          }
        }
      }
      err+=""String_Node_Str"" + index + ""String_Node_Str""+ Arrays.asList(args);
      throw new BuildException(err);
    }
  }
  Args in=new Args(args);
  String flag;
  while (in.hasNext()) {
    flag=in.next();
    if (""String_Node_Str"".equals(flag)) {
      setCompliance(flag);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setCompliance(flag);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setArgfiles(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setAspectpath(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setClasspath(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setCopyInjars(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setDebug(true);
    }
 else     if (flag.startsWith(""String_Node_Str"")) {
      setDebugLevel(flag.substring(2));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setDeprecation(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setDestdir(new File(in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setEmacssym(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setEncoding(in.next());
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setFailonerror(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setFork(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setForkclasspath(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setHelp(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setIncremental(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setInjars(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setListFileArgs(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setMaxmem(in.next());
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setMessageHolderClass(in.next());
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setNoExit(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setNoExit(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setNoExit(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setNoImportError(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setNowarn(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setNoExit(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setOutjar(new File(in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setPreserveAllLocals(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setProceedOnError(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setProgress(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setReferenceInfo(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setSource(in.next());
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setSourceRootCopyFilter(in.next());
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setSourceRoots(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setSrcDir(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setTagFile(new File(in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setTarget(in.next());
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setTime(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setTime(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setVerbose(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setVersion(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setWarn(in.next());
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setXlintwarnings(true);
    }
 else     if (flag.startsWith(""String_Node_Str"")) {
      setXlint(flag.substring(7));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setXlintfile(new File(in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setXNoweave(true);
    }
 else     if (flag.startsWith(""String_Node_Str"")) {
      File file=new File(flag.substring(1));
      if (file.canRead()) {
        setArgfiles(new Path(project,file.getPath()));
      }
 else {
        ignore(flag);
      }
    }
 else {
      File file=new File(flag);
      if (file.isFile() && file.canRead() && FileUtil.hasSourceSuffix(file)) {
        addFile(file);
      }
 else {
        ignore(flag);
      }
    }
  }
}","/** 
 * Read arguments in as if from a command line,  mainly to support compiler adapter compilerarg subelement. 
 * @param args the String[] of arguments to read
 */
public void readArguments(String[] args){
  if ((null == args) || (0 == args.length)) {
    return;
  }
  /** 
 * String[] wrapper with increment, error reporting 
 */
class Args {
    final String[] args;
    int index=0;
    Args(    String[] args){
      this.args=args;
    }
    boolean hasNext(){
      return index < args.length;
    }
    String next(){
      String err=null;
      if (!hasNext()) {
        err=""String_Node_Str"" + args[args.length - 1];
      }
 else {
        String s=args[index++];
        if (null == s) {
          err=""String_Node_Str"";
        }
 else {
          s=s.trim();
          if (0 == s.trim().length()) {
            err=""String_Node_Str"";
          }
 else {
            return s;
          }
        }
      }
      err+=""String_Node_Str"" + index + ""String_Node_Str""+ Arrays.asList(args);
      throw new BuildException(err);
    }
  }
  Args in=new Args(args);
  String flag;
  while (in.hasNext()) {
    flag=in.next();
    if (""String_Node_Str"".equals(flag)) {
      setCompliance(""String_Node_Str"");
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setCompliance(""String_Node_Str"");
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setArgfiles(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setAspectpath(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setClasspath(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setCopyInjars(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setDebug(true);
    }
 else     if (flag.startsWith(""String_Node_Str"")) {
      setDebugLevel(flag.substring(2));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setDeprecation(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setDestdir(new File(in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setEmacssym(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setEncoding(in.next());
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setFailonerror(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setFork(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setForkclasspath(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setHelp(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setIncremental(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setInjars(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setListFileArgs(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setMaxmem(in.next());
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setMessageHolderClass(in.next());
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setNoExit(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setNoExit(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setNoExit(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setNoImportError(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setNowarn(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setNoExit(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setOutjar(new File(in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setPreserveAllLocals(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setProceedOnError(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setProgress(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setReferenceInfo(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setSource(in.next());
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setSourceRootCopyFilter(in.next());
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setSourceRoots(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setSrcDir(new Path(project,in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setTagFile(new File(in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setTarget(in.next());
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setTime(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setTime(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setVerbose(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setVersion(true);
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setWarn(in.next());
    }
 else     if (flag.startsWith(""String_Node_Str"")) {
      setWarn(flag.substring(6));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setXlintwarnings(true);
    }
 else     if (flag.startsWith(""String_Node_Str"")) {
      setXlint(flag.substring(7));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setXlintfile(new File(in.next()));
    }
 else     if (""String_Node_Str"".equals(flag)) {
      setXNoweave(true);
    }
 else     if (flag.startsWith(""String_Node_Str"")) {
      File file=new File(flag.substring(1));
      if (file.canRead()) {
        setArgfiles(new Path(project,file.getPath()));
      }
 else {
        ignore(flag);
      }
    }
 else {
      File file=new File(flag);
      if (file.isFile() && file.canRead() && FileUtil.hasSourceSuffix(file)) {
        addFile(file);
      }
 else {
        ignore(flag);
      }
    }
  }
}",0.9881541725601132
9640,"public Path createBootclasspath(){
  if (classpath == null) {
    classpath=new Path(project);
  }
  return classpath.createPath();
}","public Path createBootclasspath(){
  if (bootclasspath == null) {
    bootclasspath=new Path(project);
  }
  return bootclasspath.createPath();
}",0.9568345323741008
9641,"public Path createClasspath(){
  if (bootclasspath == null) {
    bootclasspath=new Path(project);
  }
  return bootclasspath.createPath();
}","public Path createClasspath(){
  if (classpath == null) {
    classpath=new Path(project);
  }
  return classpath.createPath();
}",0.9555555555555556
9642,"/** 
 * Compile using ajc per settings.
 * @exception BuildException if the compilation has problemsor if there were compiler errors and failonerror is true.
 */
public void execute() throws BuildException {
  if (executing) {
    throw new IllegalStateException(""String_Node_Str"");
  }
 else {
    executing=true;
  }
  try {
    if (0 < ignored.size()) {
      for (Iterator iter=ignored.iterator(); iter.hasNext(); ) {
        log(""String_Node_Str"" + iter.next(),Project.MSG_INFO);
      }
    }
    if (null != outjar) {
      if (copyInjars || (null != sourceRootCopyFilter)) {
        String path=outjar.getAbsolutePath();
        int len=FileUtil.zipSuffixLength(path);
        if (len < 1) {
          log(""String_Node_Str"" + path);
        }
 else {
          path=path.substring(0,path.length() - len) + ""String_Node_Str"";
          tmpOutjar=new File(path);
        }
      }
      if (null == tmpOutjar) {
        cmd.addFlagged(""String_Node_Str"",outjar.getAbsolutePath());
      }
 else {
        cmd.addFlagged(""String_Node_Str"",tmpOutjar.getAbsolutePath());
      }
    }
    addListArgs();
    if (verbose || listFileArgs) {
      String[] args=cmd.extractArguments();
      log(""String_Node_Str"" + Arrays.asList(args),Project.MSG_VERBOSE);
    }
    if (!fork) {
      executeInSameVM();
    }
 else {
      executeInOtherVM();
    }
  }
 catch (  BuildException e) {
    throw e;
  }
catch (  Throwable x) {
    System.err.println(Main.renderExceptionForUser(x));
    throw new BuildException(""String_Node_Str"" + LangUtil.unqualifiedClassName(x) + ""String_Node_Str"");
  }
 finally {
    executing=false;
    if (null != tmpOutjar) {
      tmpOutjar.delete();
    }
  }
}","/** 
 * Compile using ajc per settings.
 * @exception BuildException if the compilation has problemsor if there were compiler errors and failonerror is true.
 */
public void execute() throws BuildException {
  if (executing) {
    throw new IllegalStateException(""String_Node_Str"");
  }
 else {
    executing=true;
  }
  try {
    boolean copyArgs=false;
    setupCommand(copyArgs);
    if (verbose || listFileArgs) {
      String[] args=cmd.extractArguments();
      log(""String_Node_Str"" + Arrays.asList(args),Project.MSG_VERBOSE);
    }
    if (!fork) {
      executeInSameVM();
    }
 else {
      executeInOtherVM();
    }
  }
 catch (  BuildException e) {
    throw e;
  }
catch (  Throwable x) {
    System.err.println(Main.renderExceptionForUser(x));
    throw new BuildException(""String_Node_Str"" + LangUtil.unqualifiedClassName(x) + ""String_Node_Str"");
  }
 finally {
    executing=false;
    if (null != tmpOutjar) {
      tmpOutjar.delete();
    }
  }
}",0.6958160572936298
9643,"public LazyClassGen(BcelObjectType myType){
  myGen=new ClassGen(myType.getJavaClass());
  constantPoolGen=myGen.getConstantPool();
  fact=new InstructionFactory(constantPoolGen);
  this.myType=myType;
  Method[] methods=myGen.getMethods();
  for (int i=0; i < methods.length; i++) {
    addMethodGen(new LazyMethodGen(methods[i],this));
  }
}","public LazyClassGen(BcelObjectType myType){
  myGen=new ClassGen(myType.getJavaClass());
  constantPoolGen=myGen.getConstantPool();
  fact=new InstructionFactory(myGen,constantPoolGen);
  this.myType=myType;
  Method[] methods=myGen.getMethods();
  for (int i=0; i < methods.length; i++) {
    addMethodGen(new LazyMethodGen(methods[i],this));
  }
}",0.9913294797687862
9644,"public static Instruction createConstant(InstructionFactory fact,int i){
  Instruction inst;
switch (i) {
case -1:
    inst=fact.ICONST_M1;
  break;
case 0:
inst=fact.ICONST_0;
break;
case 1:
inst=fact.ICONST_1;
break;
case 2:
inst=fact.ICONST_2;
break;
case 3:
inst=fact.ICONST_3;
break;
case 4:
inst=fact.ICONST_4;
break;
case 5:
inst=fact.ICONST_5;
break;
}
if (i <= Byte.MAX_VALUE && i >= Byte.MIN_VALUE) {
inst=new BIPUSH((byte)i);
}
 else if (i <= Short.MAX_VALUE && i >= Short.MIN_VALUE) {
inst=new SIPUSH((short)i);
}
 else {
inst=new LDC(fact.getClassGen().getConstantPool().addInteger(i));
}
return inst;
}","public static Instruction createConstant(InstructionFactory fact,int i){
  Instruction inst;
switch (i) {
case -1:
    inst=InstructionConstants.ICONST_M1;
  break;
case 0:
inst=InstructionConstants.ICONST_0;
break;
case 1:
inst=InstructionConstants.ICONST_1;
break;
case 2:
inst=InstructionConstants.ICONST_2;
break;
case 3:
inst=InstructionConstants.ICONST_3;
break;
case 4:
inst=InstructionConstants.ICONST_4;
break;
case 5:
inst=InstructionConstants.ICONST_5;
break;
}
if (i <= Byte.MAX_VALUE && i >= Byte.MIN_VALUE) {
inst=new BIPUSH((byte)i);
}
 else if (i <= Short.MAX_VALUE && i >= Short.MIN_VALUE) {
inst=new SIPUSH((short)i);
}
 else {
inst=new LDC(fact.getClassGen().getConstantPool().addInteger(i));
}
return inst;
}",0.875
9645,"/** 
 * This checks that the spec is reasonable and does setup: <ul> <li>calculate and set sandbox testBaseSrcDir as {Sandbox.testBaseDir}/ {Spec.testSrcDirOffset}/<li> <li>get the list of source File to compile as {Sandbox.testBaseSrcDir} / {Spec.getPaths..}</li> <li>get the list of extraClasspath entries to add to default classpath as {Sandbox.testBaseSrcDir} / {Spec.classpath..}</li> <li>get the list of aspectpath entries to use as the aspectpath as {Sandbox. testBaseSrcDir} / {Spec.aspectpath..}</li> </ul> All sources must be readable at this time. If staging, the source files and source roots are copied to a separate staging directory so they can be modified for incremental tests.   Note that (as of this writing) the compiler only handles source roots for incremental tests.
 * @param classesDir the File
 * @see org.aspectj.testing.harness.bridge.AjcTest.IAjcRun#setup(File,File)
 * @throws AbortException containing IOException or IllegalArgumentExceptionif the staging operations fail
 */
public boolean setupAjcRun(Sandbox sandbox,Validator validator){
  if (!validator.nullcheck(spec.getOptionsArray(),""String_Node_Str"") || !validator.nullcheck(sandbox,""String_Node_Str"") || !validator.nullcheck(spec.compiler,""String_Node_Str"")|| !validator.canRead(Globals.F_aspectjrt_jar,""String_Node_Str"")|| !validator.canRead(Globals.F_testingclient_jar,""String_Node_Str"")) {
    return false;
  }
  this.sandbox=sandbox;
  String rdir=spec.testSrcDirOffset;
  File testBaseSrcDir;
  if ((null == rdir) || (0 == rdir.length())) {
    testBaseSrcDir=sandbox.testBaseDir;
  }
 else {
    testBaseSrcDir=new File(sandbox.testBaseDir,rdir);
    if (!validator.canReadDir(testBaseSrcDir,""String_Node_Str"")) {
      return false;
    }
  }
  sandbox.setTestBaseSrcDir(testBaseSrcDir,this);
  final String[] injarPaths;
  final String[] srcPaths;
{
    final String[] paths=spec.getPathsArray();
    srcPaths=LangUtil.endsWith(paths,CompilerRun.SOURCE_SUFFIXES,true);
    injarPaths=LangUtil.endsWith(paths,CompilerRun.JAR_SUFFIXES,true);
  }
  if (!validator.canRead(testBaseSrcDir,srcPaths,""String_Node_Str"") || !validator.canRead(testBaseSrcDir,injarPaths,""String_Node_Str"") || !validator.canRead(testBaseSrcDir,spec.argfiles,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.classpath,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.aspectpath,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.sourceroots,""String_Node_Str"")) {
    return false;
  }
  int numSources=srcPaths.length + injarPaths.length + spec.argfiles.length+ spec.sourceroots.length;
  if (numSources < 1) {
    validator.fail(""String_Node_Str"");
    return false;
  }
  final File[] argFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.argfiles);
  final File[] injarFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,injarPaths);
  final File[] aspectFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.aspectpath);
  final File[] classFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.classpath);
  if (!validator.canRead(argFiles,""String_Node_Str"") || !validator.canRead(injarFiles,""String_Node_Str"") || !validator.canRead(aspectFiles,""String_Node_Str"")|| !validator.canRead(classFiles,""String_Node_Str"")) {
    return false;
  }
  final File[] srcFiles;
  File[] sourcerootFiles=new File[0];
  if (!spec.isStaging()) {
    srcFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,srcPaths,CompilerRun.SOURCE_SUFFIXES);
    if (!LangUtil.isEmpty(spec.sourceroots)) {
      sourcerootFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.sourceroots,null);
    }
  }
 else {
    try {
      srcFiles=FileUtil.copyFiles(testBaseSrcDir,srcPaths,sandbox.stagingDir);
      if (!LangUtil.isEmpty(spec.sourceroots)) {
        sourcerootFiles=FileUtil.copyFiles(testBaseSrcDir,spec.sourceroots,sandbox.stagingDir);
        FileFilter pickIncFiles=new FileFilter(){
          public boolean accept(          File file){
            if (file.isDirectory()) {
              return true;
            }
            String path=file.getPath();
            if (!FileUtil.hasSourceSuffix(path)) {
              return false;
            }
            int first=path.indexOf(""String_Node_Str"");
            int last=path.lastIndexOf(""String_Node_Str"");
            return (first != last);
          }
        }
;
        for (int i=0; i < sourcerootFiles.length; i++) {
          FileUtil.deleteContents(sourcerootFiles[i],pickIncFiles,false);
        }
      }
    }
 catch (    IllegalArgumentException e) {
      validator.fail(""String_Node_Str"",e);
      return false;
    }
catch (    IOException e) {
      validator.fail(""String_Node_Str"",e);
      return false;
    }
  }
  if (!validator.canRead(srcFiles,""String_Node_Str"")) {
    return false;
  }
  arguments.clear();
  if (!LangUtil.isEmpty(sourcerootFiles)) {
    arguments.add(""String_Node_Str"");
    String sr=FileUtil.flatten(sourcerootFiles,null);
    arguments.add(sr);
  }
  if (!LangUtil.isEmpty(srcFiles)) {
    arguments.addAll(Arrays.asList(FileUtil.getPaths(srcFiles)));
  }
  injars.clear();
  if (!LangUtil.isEmpty(injarFiles)) {
    injars.addAll(Arrays.asList(FileUtil.getPaths(injarFiles)));
  }
  if (!LangUtil.isEmpty(argFiles)) {
    String[] ra=FileUtil.getPaths(argFiles);
    for (int j=0; j < ra.length; j++) {
      arguments.add(""String_Node_Str"" + ra[j]);
    }
    if (spec.isStaging) {
      validator.info(""String_Node_Str"");
    }
  }
  final boolean checkReadable=true;
  File[] cp=new File[3 + classFiles.length];
  System.arraycopy(classFiles,0,cp,0,classFiles.length);
  int index=classFiles.length;
  cp[index++]=sandbox.classesDir;
  cp[index++]=Globals.F_aspectjrt_jar;
  cp[index++]=Globals.F_testingclient_jar;
  sandbox.setClasspath(cp,checkReadable,this);
  if (0 < aspectFiles.length) {
    sandbox.setAspectpath(aspectFiles,checkReadable,this);
  }
  if (!LangUtil.isEmpty(JavaRun.BOOTCLASSPATH)) {
    sandbox.setBootclasspath(JavaRun.BOOTCLASSPATH,this);
  }
  return true;
}","/** 
 * This checks that the spec is reasonable and does setup: <ul> <li>calculate and set sandbox testBaseSrcDir as {Sandbox.testBaseDir}/ {Spec.testSrcDirOffset}/<li> <li>get the list of source File to compile as {Sandbox.testBaseSrcDir} / {Spec.getPaths..}</li> <li>get the list of extraClasspath entries to add to default classpath as {Sandbox.testBaseSrcDir} / {Spec.classpath..}</li> <li>get the list of aspectpath entries to use as the aspectpath as {Sandbox. testBaseSrcDir} / {Spec.aspectpath..}</li> </ul> All sources must be readable at this time. If staging, the source files and source roots are copied to a separate staging directory so they can be modified for incremental tests.   Note that (as of this writing) the compiler only handles source roots for incremental tests.
 * @param classesDir the File
 * @see org.aspectj.testing.harness.bridge.AjcTest.IAjcRun#setup(File,File)
 * @throws AbortException containing IOException or IllegalArgumentExceptionif the staging operations fail
 */
public boolean setupAjcRun(Sandbox sandbox,Validator validator){
  if (!validator.nullcheck(spec.getOptionsArray(),""String_Node_Str"") || !validator.nullcheck(sandbox,""String_Node_Str"") || !validator.nullcheck(spec.compiler,""String_Node_Str"")|| !validator.canRead(Globals.F_aspectjrt_jar,""String_Node_Str"")|| !validator.canRead(Globals.F_testingclient_jar,""String_Node_Str"")) {
    return false;
  }
  this.sandbox=sandbox;
  String rdir=spec.testSrcDirOffset;
  File testBaseSrcDir;
  if ((null == rdir) || (0 == rdir.length())) {
    testBaseSrcDir=sandbox.testBaseDir;
  }
 else {
    testBaseSrcDir=new File(sandbox.testBaseDir,rdir);
    if (!validator.canReadDir(testBaseSrcDir,""String_Node_Str"")) {
      return false;
    }
  }
  sandbox.setTestBaseSrcDir(testBaseSrcDir,this);
  final String[] injarPaths;
  final String[] srcPaths;
{
    final String[] paths=spec.getPathsArray();
    srcPaths=LangUtil.endsWith(paths,CompilerRun.SOURCE_SUFFIXES,true);
    injarPaths=LangUtil.endsWith(paths,CompilerRun.JAR_SUFFIXES,true);
  }
  if (!validator.canRead(testBaseSrcDir,srcPaths,""String_Node_Str"") || !validator.canRead(testBaseSrcDir,injarPaths,""String_Node_Str"") || !validator.canRead(testBaseSrcDir,spec.argfiles,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.classpath,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.aspectpath,""String_Node_Str"")|| !validator.canRead(testBaseSrcDir,spec.sourceroots,""String_Node_Str"")) {
    return false;
  }
  int numSources=srcPaths.length + injarPaths.length + spec.argfiles.length+ spec.sourceroots.length;
  if (numSources < 1) {
    validator.fail(""String_Node_Str"");
    return false;
  }
  final File[] argFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.argfiles);
  final File[] injarFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,injarPaths);
  final File[] aspectFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.aspectpath);
  final File[] classFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.classpath);
  if (!validator.canRead(argFiles,""String_Node_Str"") || !validator.canRead(injarFiles,""String_Node_Str"") || !validator.canRead(aspectFiles,""String_Node_Str"")|| !validator.canRead(classFiles,""String_Node_Str"")) {
    return false;
  }
  final File[] srcFiles;
  File[] sourcerootFiles=new File[0];
  if (!spec.isStaging()) {
    srcFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,srcPaths,CompilerRun.SOURCE_SUFFIXES);
    if (!LangUtil.isEmpty(spec.sourceroots)) {
      sourcerootFiles=FileUtil.getBaseDirFiles(testBaseSrcDir,spec.sourceroots,null);
    }
  }
 else {
    try {
      srcFiles=FileUtil.copyFiles(testBaseSrcDir,srcPaths,sandbox.stagingDir);
      if (!LangUtil.isEmpty(spec.sourceroots)) {
        sourcerootFiles=FileUtil.copyFiles(testBaseSrcDir,spec.sourceroots,sandbox.stagingDir);
        FileFilter pickIncFiles=new FileFilter(){
          public boolean accept(          File file){
            if (file.isDirectory()) {
              return true;
            }
            String path=file.getPath();
            if (!FileUtil.hasSourceSuffix(path)) {
              return false;
            }
            int first=path.indexOf(""String_Node_Str"");
            int last=path.lastIndexOf(""String_Node_Str"");
            return (first != last);
          }
        }
;
        for (int i=0; i < sourcerootFiles.length; i++) {
          FileUtil.deleteContents(sourcerootFiles[i],pickIncFiles,false);
        }
      }
    }
 catch (    IllegalArgumentException e) {
      validator.fail(""String_Node_Str"",e);
      return false;
    }
catch (    IOException e) {
      validator.fail(""String_Node_Str"",e);
      return false;
    }
  }
  if (!validator.canRead(srcFiles,""String_Node_Str"")) {
    return false;
  }
  arguments.clear();
  if (!LangUtil.isEmpty(sourcerootFiles)) {
    arguments.add(""String_Node_Str"");
    String sr=FileUtil.flatten(sourcerootFiles,null);
    arguments.add(sr);
  }
  if (!LangUtil.isEmpty(srcFiles)) {
    arguments.addAll(Arrays.asList(FileUtil.getPaths(srcFiles)));
  }
  injars.clear();
  if (!LangUtil.isEmpty(injarFiles)) {
    injars.addAll(Arrays.asList(FileUtil.getPaths(injarFiles)));
  }
  if (!LangUtil.isEmpty(argFiles)) {
    String[] ra=FileUtil.getPaths(argFiles);
    for (int j=0; j < ra.length; j++) {
      arguments.add(""String_Node_Str"" + ra[j]);
    }
    if (spec.isStaging) {
      validator.info(""String_Node_Str"");
    }
  }
  final boolean checkReadable=true;
  File[] cp=new File[2 + classFiles.length];
  System.arraycopy(classFiles,0,cp,0,classFiles.length);
  int index=classFiles.length;
  cp[index++]=Globals.F_aspectjrt_jar;
  cp[index++]=Globals.F_testingclient_jar;
  sandbox.setClasspath(cp,checkReadable,this);
  if (0 < aspectFiles.length) {
    sandbox.setAspectpath(aspectFiles,checkReadable,this);
  }
  if (!LangUtil.isEmpty(JavaRun.BOOTCLASSPATH)) {
    sandbox.setBootclasspath(JavaRun.BOOTCLASSPATH,this);
  }
  return true;
}",0.996971736204576
9646,"/** 
 * This checks the spec for a class name and checks the sandbox for a readable test source directory, a writable run dir, and (non-null, possibly-empty) lists of readable classpath dirs and jars.
 * @return true if all checks pass
 * @see org.aspectj.testing.harness.bridge.AjcTest.IAjcRun#setup(File,File)
 */
public boolean setupAjcRun(Sandbox sandbox,Validator validator){
  this.sandbox=sandbox;
  return (validator.nullcheck(spec.className,""String_Node_Str"") && validator.nullcheck(sandbox,""String_Node_Str"") && validator.canReadDir(sandbox.getTestBaseSrcDir(this),""String_Node_Str"")&& validator.canWriteDir(sandbox.runDir,""String_Node_Str"")&& validator.canReadFiles(sandbox.getClasspathJars(true,this),""String_Node_Str"")&& validator.canReadDirs(sandbox.getClasspathDirectories(true,this),""String_Node_Str""));
}","/** 
 * This checks the spec for a class name and checks the sandbox for a readable test source directory, a writable run dir, and (non-null, possibly-empty) lists of readable classpath dirs and jars.
 * @return true if all checks pass
 * @see org.aspectj.testing.harness.bridge.AjcTest.IAjcRun#setup(File,File)
 */
public boolean setupAjcRun(Sandbox sandbox,Validator validator){
  this.sandbox=sandbox;
  return (validator.nullcheck(spec.className,""String_Node_Str"") && validator.nullcheck(sandbox,""String_Node_Str"") && validator.canReadDir(sandbox.getTestBaseSrcDir(this),""String_Node_Str"")&& validator.canWriteDir(sandbox.runDir,""String_Node_Str"")&& validator.canReadFiles(sandbox.getClasspathJars(true,this),""String_Node_Str"")&& validator.canReadDirs(sandbox.getClasspathDirectories(true,this,true),""String_Node_Str""));
}",0.996964177292046
9647,"/** 
 * caller must record any exceptions 
 */
public boolean run(IRunStatus status) throws IllegalAccessException, InvocationTargetException, ClassNotFoundException, NoSuchMethodException {
  boolean completedNormally=false;
  if (!LangUtil.isEmpty(spec.dirChanges)) {
    MessageUtil.info(status,""String_Node_Str"");
  }
  try {
    final boolean readable=true;
    File[] libs=sandbox.getClasspathJars(readable,this);
    File[] dirs=sandbox.getClasspathDirectories(readable,this);
    completedNormally=FORK ? runInOtherVM(status,libs,dirs) : runInSameVM(status,libs,dirs);
  }
  finally {
    if (!completedNormally) {
      MessageUtil.info(status,spec.toLongString());
      MessageUtil.info(status,""String_Node_Str"" + sandbox);
    }
  }
  return completedNormally;
}","/** 
 * caller must record any exceptions 
 */
public boolean run(IRunStatus status) throws IllegalAccessException, InvocationTargetException, ClassNotFoundException, NoSuchMethodException {
  boolean completedNormally=false;
  if (!LangUtil.isEmpty(spec.dirChanges)) {
    MessageUtil.info(status,""String_Node_Str"");
  }
  try {
    final boolean readable=true;
    File[] libs=sandbox.getClasspathJars(readable,this);
    boolean includeClassesDir=true;
    File[] dirs=sandbox.getClasspathDirectories(readable,this,includeClassesDir);
    completedNormally=FORK ? runInOtherVM(status,libs,dirs) : runInSameVM(status,libs,dirs);
  }
  finally {
    if (!completedNormally) {
      MessageUtil.info(status,spec.toLongString());
      MessageUtil.info(status,""String_Node_Str"" + sandbox);
    }
  }
  return completedNormally;
}",0.9662921348314608
9648,"/** 
 * Get directories for the run classpath by selecting them from the compile classpath. This ignores aspectpath since it may contain only jar files.
 * @param readable if true, omit non-readable directories 
 */
File[] getClasspathDirectories(boolean readable,JavaRun caller){
  LangUtil.throwIaxIfNull(caller,""String_Node_Str"");
  assertState(null != compileClasspath,""String_Node_Str"");
  ArrayList result=new ArrayList();
  File[] src=compileClasspath;
  for (int i=0; i < src.length; i++) {
    File f=src[i];
    if ((null != f) && (f.isDirectory()) && (!readable || f.canRead())) {
      result.add(f);
    }
  }
  return (File[])result.toArray(new File[0]);
}","/** 
 * Get directories for the run classpath by selecting them from the compile classpath. This ignores aspectpath since it may contain only jar files.
 * @param readable if true, omit non-readable directories 
 */
File[] getClasspathDirectories(boolean readable,JavaRun caller,boolean includeOutput){
  LangUtil.throwIaxIfNull(caller,""String_Node_Str"");
  assertState(null != compileClasspath,""String_Node_Str"");
  ArrayList result=new ArrayList();
  File[] src=compileClasspath;
  for (int i=0; i < src.length; i++) {
    File f=src[i];
    if ((null != f) && (f.isDirectory()) && (!readable || f.canRead())) {
      result.add(f);
    }
  }
  if (includeOutput && (null != classesDir) && (!readable || classesDir.canRead())) {
    result.add(classesDir);
  }
  return (File[])result.toArray(new File[0]);
}",0.9054054054054054
9649,"public List getClasspath(AjcConfigParser parser){
  List ret=new ArrayList();
  if (parser.bootclasspath == null) {
    addClasspath(System.getProperty(""String_Node_Str"",""String_Node_Str""),ret);
  }
 else {
    addClasspath(parser.bootclasspath,ret);
  }
  String extdirs=parser.extdirs;
  if (extdirs == null) {
    extdirs=System.getProperty(""String_Node_Str"",""String_Node_Str"");
  }
  addExtDirs(extdirs,ret);
  if ((classpaths == null || classpaths.length == 0) || (classpaths != null && classpaths[0] == ""String_Node_Str"")) {
    addClasspath(System.getProperty(""String_Node_Str"",""String_Node_Str""),ret);
  }
 else {
    ret.addAll(Arrays.asList(classpaths));
  }
  return ret;
}","public List getClasspath(AjcConfigParser parser){
  List ret=new ArrayList();
  if (parser.bootclasspath == null) {
    addClasspath(System.getProperty(""String_Node_Str"",""String_Node_Str""),ret);
  }
 else {
    addClasspath(parser.bootclasspath,ret);
  }
  String extdirs=parser.extdirs;
  if (extdirs == null) {
    extdirs=System.getProperty(""String_Node_Str"",""String_Node_Str"");
  }
  addExtDirs(extdirs,ret);
  if (parser.classpath == null) {
    addClasspath(System.getProperty(""String_Node_Str"",""String_Node_Str""),ret);
  }
 else {
    addClasspath(parser.classpath,ret);
  }
  return ret;
}",0.6978922716627635
9650,"/** 
 * Generate build configuration for the input args, passing to handler any error messages.
 * @param args the String[] arguments for the build configuration
 * @param handler the IMessageHandler handler for any errors
 * @return AjBuildConfig per args, which will be invalid unless there are no handler errors.
 */
public AjBuildConfig genBuildConfig(String[] args,IMessageHandler handler){
  AjBuildConfig buildConfig=new AjBuildConfig();
  try {
    super.filenames=new String[]{""String_Node_Str""};
    List fileList=new ArrayList();
    AjcConfigParser parser=new AjcConfigParser(buildConfig,handler);
    parser.parseCommandLine(args);
    boolean incrementalMode=buildConfig.isIncrementalMode() || buildConfig.isIncrementalFileMode();
    List files=parser.getFiles();
    if (!LangUtil.isEmpty(files)) {
      if (incrementalMode) {
        MessageUtil.error(handler,""String_Node_Str"");
      }
 else {
        fileList.addAll(files);
      }
    }
    List javaArgList=parser.getUnparsedArgs();
    javaArgList.add(0,""String_Node_Str"");
    if (javaArgList.size() != 0) {
      super.configure((String[])javaArgList.toArray(new String[javaArgList.size()]));
    }
    if (buildConfig.getSourceRoots() != null) {
      for (Iterator i=buildConfig.getSourceRoots().iterator(); i.hasNext(); ) {
        fileList.addAll(collectSourceRootFiles((File)i.next()));
      }
    }
    buildConfig.setFiles(fileList);
    if (destinationPath != null) {
      buildConfig.setOutputDir(new File(destinationPath));
    }
    buildConfig.setClasspath(getClasspath(parser));
    if (incrementalMode && (0 == buildConfig.getSourceRoots().size())) {
      MessageUtil.error(handler,""String_Node_Str"");
    }
    setDebugOptions();
    buildConfig.setJavaOptions(options);
  }
 catch (  InvalidInputException iie) {
    MessageUtil.error(handler,iie.getMessage());
  }
  return buildConfig;
}","/** 
 * Generate build configuration for the input args, passing to handler any error messages.
 * @param args the String[] arguments for the build configuration
 * @param handler the IMessageHandler handler for any errors
 * @return AjBuildConfig per args, which will be invalid unless there are no handler errors.
 */
public AjBuildConfig genBuildConfig(String[] args,IMessageHandler handler){
  AjBuildConfig buildConfig=new AjBuildConfig();
  try {
    super.filenames=new String[]{""String_Node_Str""};
    List fileList=new ArrayList();
    AjcConfigParser parser=new AjcConfigParser(buildConfig,handler);
    parser.parseCommandLine(args);
    boolean incrementalMode=buildConfig.isIncrementalMode() || buildConfig.isIncrementalFileMode();
    List files=parser.getFiles();
    if (!LangUtil.isEmpty(files)) {
      if (incrementalMode) {
        MessageUtil.error(handler,""String_Node_Str"");
      }
 else {
        fileList.addAll(files);
      }
    }
    List javaArgList=new ArrayList();
    javaArgList.add(""String_Node_Str"");
    javaArgList.add(""String_Node_Str"");
    javaArgList.add(System.getProperty(""String_Node_Str""));
    javaArgList.add(""String_Node_Str"");
    javaArgList.add(System.getProperty(""String_Node_Str""));
    javaArgList.addAll(parser.getUnparsedArgs());
    super.configure((String[])javaArgList.toArray(new String[javaArgList.size()]));
    if (buildConfig.getSourceRoots() != null) {
      for (Iterator i=buildConfig.getSourceRoots().iterator(); i.hasNext(); ) {
        fileList.addAll(collectSourceRootFiles((File)i.next()));
      }
    }
    buildConfig.setFiles(fileList);
    if (destinationPath != null) {
      buildConfig.setOutputDir(new File(destinationPath));
    }
    buildConfig.setClasspath(getClasspath(parser));
    if (incrementalMode && (0 == buildConfig.getSourceRoots().size())) {
      MessageUtil.error(handler,""String_Node_Str"");
    }
    setDebugOptions();
    buildConfig.setJavaOptions(options);
  }
 catch (  InvalidInputException iie) {
    MessageUtil.error(handler,iie.getMessage());
  }
  return buildConfig;
}",0.9248613212304588
9651,"/** 
 * Extract AspectJ-specific options (except for argfiles). Caller should warn when sourceroots is empty but in  incremental mode. Signals warnings or errors through handler set in constructor.
 */
public void parseOption(String arg,LinkedList args){
  int nextArgIndex=args.indexOf(arg) + 1;
  if (LangUtil.isEmpty(arg)) {
    showWarning(""String_Node_Str"");
  }
 else   if (arg.equals(""String_Node_Str"")) {
    ;
    if (args.size() > nextArgIndex) {
      buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_InJARs,CompilerOptions.PRESERVE);
      StringTokenizer st=new StringTokenizer(((ConfigParser.Arg)args.get(nextArgIndex)).getValue(),File.pathSeparator);
      while (st.hasMoreTokens()) {
        String filename=st.nextToken();
        File jarFile=makeFile(filename);
        if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
          buildConfig.getInJars().add(jarFile);
        }
 else {
          showError(""String_Node_Str"" + filename);
        }
      }
      args.remove(args.get(nextArgIndex));
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    ;
    if (args.size() > nextArgIndex) {
      StringTokenizer st=new StringTokenizer(((ConfigParser.Arg)args.get(nextArgIndex)).getValue(),File.pathSeparator);
      while (st.hasMoreTokens()) {
        String filename=st.nextToken();
        File jarFile=makeFile(filename);
        if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
          buildConfig.getAspectpath().add(jarFile);
        }
 else {
          showError(""String_Node_Str"" + filename);
        }
      }
      args.remove(args.get(nextArgIndex));
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      List sourceRoots=new ArrayList();
      StringTokenizer st=new StringTokenizer(((ConfigParser.Arg)args.get(nextArgIndex)).getValue(),File.pathSeparator);
      while (st.hasMoreTokens()) {
        File f=makeFile(st.nextToken());
        if (f.isDirectory() && f.canRead()) {
          sourceRoots.add(f);
        }
 else {
          showError(""String_Node_Str"" + f);
        }
      }
      if (0 < sourceRoots.size()) {
        buildConfig.setSourceRoots(sourceRoots);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_OutJAR,CompilerOptions.GENERATE);
      File jarFile=makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
      if (FileUtil.hasZipSuffix(jarFile)) {
        try {
          if (!jarFile.exists()) {
            jarFile.createNewFile();
          }
          buildConfig.setOutputJar(jarFile);
        }
 catch (        IOException ioe) {
          showError(""String_Node_Str"" + jarFile);
        }
      }
 else {
        showError(""String_Node_Str"" + jarFile);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setIncrementalMode(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      File file=makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
      buildConfig.setIncrementalFile(file);
      if (!file.canRead()) {
        showError(""String_Node_Str"" + file);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setEmacsSymMode(true);
    buildConfig.setGenerateModelMode(true);
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    buildConfig.setNoWeave(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setXserializableAspects(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setXnoInline(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      File lintSpecFile=makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
      if (lintSpecFile.canRead() && lintSpecFile.getName().endsWith(""String_Node_Str"")) {
        buildConfig.setLintSpecFile(lintSpecFile);
      }
 else {
        showError(""String_Node_Str"" + lintSpecFile);
        buildConfig.setLintSpecFile(null);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_Xlint,CompilerOptions.GENERATE);
    buildConfig.setLintMode(AjBuildConfig.AJLINT_DEFAULT);
  }
 else   if (arg.startsWith(""String_Node_Str"")) {
    if (7 < arg.length()) {
      buildConfig.setLintMode(arg.substring(7));
    }
 else {
      showError(""String_Node_Str"" + arg);
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      bootclasspath=((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      extdirs=((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    dirLookahead(arg,args,nextArgIndex);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    dirLookahead(arg,args,nextArgIndex);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    dirLookahead(arg,args,nextArgIndex);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    dirLookahead(arg,args,nextArgIndex);
  }
 else   if (new File(arg).isDirectory()) {
    showError(""String_Node_Str"" + arg);
  }
 else {
    unparsedArgs.add(arg);
  }
}","/** 
 * Extract AspectJ-specific options (except for argfiles). Caller should warn when sourceroots is empty but in  incremental mode. Signals warnings or errors through handler set in constructor.
 */
public void parseOption(String arg,LinkedList args){
  int nextArgIndex=args.indexOf(arg) + 1;
  if (LangUtil.isEmpty(arg)) {
    showWarning(""String_Node_Str"");
  }
 else   if (arg.equals(""String_Node_Str"")) {
    ;
    if (args.size() > nextArgIndex) {
      buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_InJARs,CompilerOptions.PRESERVE);
      StringTokenizer st=new StringTokenizer(((ConfigParser.Arg)args.get(nextArgIndex)).getValue(),File.pathSeparator);
      while (st.hasMoreTokens()) {
        String filename=st.nextToken();
        File jarFile=makeFile(filename);
        if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
          buildConfig.getInJars().add(jarFile);
        }
 else {
          showError(""String_Node_Str"" + filename);
        }
      }
      args.remove(args.get(nextArgIndex));
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    ;
    if (args.size() > nextArgIndex) {
      StringTokenizer st=new StringTokenizer(((ConfigParser.Arg)args.get(nextArgIndex)).getValue(),File.pathSeparator);
      while (st.hasMoreTokens()) {
        String filename=st.nextToken();
        File jarFile=makeFile(filename);
        if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
          buildConfig.getAspectpath().add(jarFile);
        }
 else {
          showError(""String_Node_Str"" + filename);
        }
      }
      args.remove(args.get(nextArgIndex));
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      List sourceRoots=new ArrayList();
      StringTokenizer st=new StringTokenizer(((ConfigParser.Arg)args.get(nextArgIndex)).getValue(),File.pathSeparator);
      while (st.hasMoreTokens()) {
        File f=makeFile(st.nextToken());
        if (f.isDirectory() && f.canRead()) {
          sourceRoots.add(f);
        }
 else {
          showError(""String_Node_Str"" + f);
        }
      }
      if (0 < sourceRoots.size()) {
        buildConfig.setSourceRoots(sourceRoots);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_OutJAR,CompilerOptions.GENERATE);
      File jarFile=makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
      if (FileUtil.hasZipSuffix(jarFile)) {
        try {
          if (!jarFile.exists()) {
            jarFile.createNewFile();
          }
          buildConfig.setOutputJar(jarFile);
        }
 catch (        IOException ioe) {
          showError(""String_Node_Str"" + jarFile);
        }
      }
 else {
        showError(""String_Node_Str"" + jarFile);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setIncrementalMode(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      File file=makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
      buildConfig.setIncrementalFile(file);
      if (!file.canRead()) {
        showError(""String_Node_Str"" + file);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setEmacsSymMode(true);
    buildConfig.setGenerateModelMode(true);
  }
 else   if (arg.equals(""String_Node_Str"") || arg.equals(""String_Node_Str"")) {
    buildConfig.setNoWeave(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setXserializableAspects(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.setXnoInline(true);
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      File lintSpecFile=makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
      if (lintSpecFile.canRead() && lintSpecFile.getName().endsWith(""String_Node_Str"")) {
        buildConfig.setLintSpecFile(lintSpecFile);
      }
 else {
        showError(""String_Node_Str"" + lintSpecFile);
        buildConfig.setLintSpecFile(null);
      }
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_Xlint,CompilerOptions.GENERATE);
    buildConfig.setLintMode(AjBuildConfig.AJLINT_DEFAULT);
  }
 else   if (arg.startsWith(""String_Node_Str"")) {
    if (7 < arg.length()) {
      buildConfig.setLintMode(arg.substring(7));
    }
 else {
      showError(""String_Node_Str"" + arg);
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      bootclasspath=((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      classpath=((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    if (args.size() > nextArgIndex) {
      extdirs=((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
      args.remove(args.get(nextArgIndex));
    }
 else {
      showError(""String_Node_Str"");
    }
  }
 else   if (arg.equals(""String_Node_Str"")) {
    dirLookahead(arg,args,nextArgIndex);
  }
 else   if (new File(arg).isDirectory()) {
    showError(""String_Node_Str"" + arg);
  }
 else {
    unparsedArgs.add(arg);
  }
}",0.944184064763528
9652,"public void testDefaultClasspathAndTargetCombo() throws InvalidInputException {
  String ENTRY=""String_Node_Str"";
  final String classpath=System.getProperty(""String_Node_Str"");
  try {
    System.setProperty(""String_Node_Str"",ENTRY);
    AjBuildConfig config=parser.genBuildConfig(new String[]{},messageWriter);
    String err=parser.getOtherMessages(true);
    assertTrue(config.getClasspath().toString(),config.getClasspath().contains(""String_Node_Str""));
    assertTrue(config.getClasspath().toString(),config.getClasspath().contains(""String_Node_Str""));
    config=parser.genBuildConfig(new String[]{""String_Node_Str""},messageWriter);
    err=parser.getOtherMessages(true);
    assertTrue(config.getClasspath().toString(),config.getClasspath().contains(""String_Node_Str""));
    assertTrue(config.getClasspath().toString(),config.getClasspath().contains(""String_Node_Str""));
    config=parser.genBuildConfig(new String[]{""String_Node_Str""},messageWriter);
    err=parser.getOtherMessages(true);
    assertTrue(config.getClasspath().toString(),config.getClasspath().contains(""String_Node_Str""));
    assertTrue(config.getClasspath().toString(),config.getClasspath().contains(""String_Node_Str""));
    config=parser.genBuildConfig(new String[]{""String_Node_Str"",ENTRY,""String_Node_Str""},messageWriter);
    err=parser.getOtherMessages(true);
    assertTrue(""String_Node_Str"",null != err);
    assertTrue(config.getClasspath().toString(),config.getClasspath().contains(""String_Node_Str""));
    assertTrue(config.getClasspath().toString(),config.getClasspath().contains(""String_Node_Str""));
  }
  finally {
    System.setProperty(""String_Node_Str"",classpath);
    String setPath=System.getProperty(""String_Node_Str"");
    String m=""String_Node_Str"";
    assertEquals(m,classpath,setPath);
  }
}","public void testDefaultClasspathAndTargetCombo() throws InvalidInputException {
  String ENTRY=""String_Node_Str"";
  final String classpath=System.getProperty(""String_Node_Str"");
  try {
    System.setProperty(""String_Node_Str"",ENTRY);
    AjBuildConfig config=parser.genBuildConfig(new String[]{},messageWriter);
    String err=parser.getOtherMessages(true);
    assertTrue(config.getClasspath().toString(),config.getClasspath().contains(""String_Node_Str""));
    assertTrue(config.getClasspath().toString(),config.getClasspath().contains(""String_Node_Str""));
    config=parser.genBuildConfig(new String[]{""String_Node_Str""},messageWriter);
    assertTrue(config.getClasspath().toString(),config.getClasspath().contains(""String_Node_Str""));
    assertTrue(config.getClasspath().toString(),config.getClasspath().contains(""String_Node_Str""));
    config=parser.genBuildConfig(new String[]{""String_Node_Str""},messageWriter);
    err=parser.getOtherMessages(true);
    assertTrue(config.getClasspath().toString(),config.getClasspath().contains(""String_Node_Str""));
    assertTrue(config.getClasspath().toString(),config.getClasspath().contains(""String_Node_Str""));
    config=parser.genBuildConfig(new String[]{""String_Node_Str"",ENTRY,""String_Node_Str""},messageWriter);
    assertTrue(config.getClasspath().toString(),config.getClasspath().contains(""String_Node_Str""));
    assertTrue(config.getClasspath().toString(),config.getClasspath().contains(""String_Node_Str""));
  }
  finally {
    System.setProperty(""String_Node_Str"",classpath);
    String setPath=System.getProperty(""String_Node_Str"");
    String m=""String_Node_Str"";
    assertEquals(m,classpath,setPath);
  }
}",0.9638832707310026
9653,"/** 
 * @return IMessage.WARNING unless message contains error or info 
 */
protected static IMessage.Kind inferKind(String message){
  if (-1 == message.indexOf(""String_Node_Str"")) {
    return IMessage.ERROR;
  }
 else   if (-1 == message.indexOf(""String_Node_Str"")) {
    return IMessage.INFO;
  }
 else {
    return IMessage.WARNING;
  }
}","/** 
 * @return IMessage.WARNING unless message contains error or info 
 */
protected static IMessage.Kind inferKind(String message){
  if (-1 != message.indexOf(""String_Node_Str"")) {
    return IMessage.ERROR;
  }
 else   if (-1 != message.indexOf(""String_Node_Str"")) {
    return IMessage.INFO;
  }
 else {
    return IMessage.WARNING;
  }
}",0.9941690962099126
9654,"public void endVisit(SingleTypeReference ref,BlockScope scope){
  makePublic(ref.getTypeBinding(scope));
}","public void endVisit(ClassLiteralAccess classLiteral,BlockScope scope){
  isInlinable=false;
}",0.59
9655,"public void resolveStatements(){
  if (binding == null || ignoreFurtherInvestigation)   return;
  ClassScope upperScope=(ClassScope)scope.parent;
  modifiers=binding.modifiers=checkAndSetModifiers(modifiers,upperScope);
  if (kind == AdviceKind.AfterThrowing && extraArgument != null) {
    TypeBinding argTb=extraArgument.binding.type;
    TypeBinding expectedTb=upperScope.getJavaLangThrowable();
    if (!argTb.isCompatibleWith(expectedTb)) {
      scope.problemReporter().typeMismatchError(argTb,expectedTb,extraArgument);
      ignoreFurtherInvestigation=true;
      return;
    }
  }
  pointcutDesignator.finishResolveTypes(this,this.binding,baseArgumentCount,upperScope.referenceContext.binding);
  if (binding == null || ignoreFurtherInvestigation)   return;
  if (kind == AdviceKind.Around) {
    ReferenceBinding[] exceptions=new ReferenceBinding[]{upperScope.getJavaLangThrowable()};
    proceedMethodBinding=new MethodBinding(Modifier.STATIC,""String_Node_Str"".toCharArray(),binding.returnType,resize(baseArgumentCount + 1,binding.parameters),exceptions,binding.declaringClass);
    proceedMethodBinding.selector=CharArrayOps.concat(selector,proceedMethodBinding.selector);
  }
  super.resolveStatements();
  if (binding != null)   determineExtraArgumentFlags();
  if (kind == AdviceKind.Around) {
    int n=proceedCalls.size();
    EclipseFactory world=EclipseFactory.fromScopeLookupEnvironment(upperScope);
    formalsUnchangedToProceed=new boolean[baseArgumentCount];
    proceedCallSignatures=new ResolvedMember[0];
    proceedInInners=false;
    declaredExceptions=new TypeX[0];
    for (int i=0; i < n; i++) {
      Proceed call=(Proceed)proceedCalls.get(i);
      if (call.inInner) {
        proceedInInners=true;
      }
    }
    if (!proceedInInners) {
      PrivilegedHandler handler=(PrivilegedHandler)upperScope.referenceContext.binding.privilegedHandler;
      if (handler == null) {
        handler=new PrivilegedHandler((AspectDeclaration)upperScope.referenceContext);
        upperScope.referenceContext.binding.privilegedHandler=handler;
      }
      this.traverse(new MakeDeclsPublicVisitor(),(ClassScope)null);
      AccessForInlineVisitor v=new AccessForInlineVisitor((AspectDeclaration)upperScope.referenceContext,handler);
      this.traverse(v,(ClassScope)null);
    }
  }
}","public void resolveStatements(){
  if (binding == null || ignoreFurtherInvestigation)   return;
  ClassScope upperScope=(ClassScope)scope.parent;
  modifiers=binding.modifiers=checkAndSetModifiers(modifiers,upperScope);
  if (kind == AdviceKind.AfterThrowing && extraArgument != null) {
    TypeBinding argTb=extraArgument.binding.type;
    TypeBinding expectedTb=upperScope.getJavaLangThrowable();
    if (!argTb.isCompatibleWith(expectedTb)) {
      scope.problemReporter().typeMismatchError(argTb,expectedTb,extraArgument);
      ignoreFurtherInvestigation=true;
      return;
    }
  }
  pointcutDesignator.finishResolveTypes(this,this.binding,baseArgumentCount,upperScope.referenceContext.binding);
  if (binding == null || ignoreFurtherInvestigation)   return;
  if (kind == AdviceKind.Around) {
    ReferenceBinding[] exceptions=new ReferenceBinding[]{upperScope.getJavaLangThrowable()};
    proceedMethodBinding=new MethodBinding(Modifier.STATIC,""String_Node_Str"".toCharArray(),binding.returnType,resize(baseArgumentCount + 1,binding.parameters),exceptions,binding.declaringClass);
    proceedMethodBinding.selector=CharArrayOps.concat(selector,proceedMethodBinding.selector);
  }
  super.resolveStatements();
  if (binding != null)   determineExtraArgumentFlags();
  if (kind == AdviceKind.Around) {
    int n=proceedCalls.size();
    EclipseFactory world=EclipseFactory.fromScopeLookupEnvironment(upperScope);
    formalsUnchangedToProceed=new boolean[baseArgumentCount];
    proceedCallSignatures=new ResolvedMember[0];
    proceedInInners=false;
    declaredExceptions=new TypeX[0];
    for (int i=0; i < n; i++) {
      Proceed call=(Proceed)proceedCalls.get(i);
      if (call.inInner) {
        proceedInInners=true;
      }
    }
    if (!proceedInInners) {
      PrivilegedHandler handler=(PrivilegedHandler)upperScope.referenceContext.binding.privilegedHandler;
      if (handler == null) {
        handler=new PrivilegedHandler((AspectDeclaration)upperScope.referenceContext);
        upperScope.referenceContext.binding.privilegedHandler=handler;
      }
      this.traverse(new MakeDeclsPublicVisitor(),(ClassScope)null);
      AccessForInlineVisitor v=new AccessForInlineVisitor((AspectDeclaration)upperScope.referenceContext,handler);
      this.traverse(v,(ClassScope)null);
      if (!v.isInlinable)       proceedInInners=true;
    }
  }
}",0.9884467265725289
9656,"public static void main(String[] args){
  new C().foo();
}","public static void main(String[] args){
  new C().foo();
  new C().bar();
}",0.8721804511278195
9657,"public static void main(String[] args){
  new C().foo();
}","public static void main(String[] args){
  new C().foo();
  new C().bar();
}",0.8721804511278195
9658,"boolean canTreatAsStatic(String id){
  return id.equals(""String_Node_Str"") || id.equals(""String_Node_Str"") || id.equals(""String_Node_Str"")|| id.equals(""String_Node_Str"")|| id.equals(""String_Node_Str"")|| id.equals(""String_Node_Str"")|| id.equals(""String_Node_Str"");
}","boolean canTreatAsStatic(String id){
  return id.equals(""String_Node_Str"") || id.equals(""String_Node_Str"") || id.equals(""String_Node_Str"")|| id.equals(""String_Node_Str"")|| id.equals(""String_Node_Str"")|| id.equals(""String_Node_Str"");
}",0.937875751503006
9659,"public SyntheticAccessMethodBinding getAccessMethod(boolean isReadAccess){
  if (isReadAccess)   return reader;
 else   return writer;
}","public SyntheticAccessMethodBinding getAccessMethod(boolean isReadAccess){
  if (baseField.alwaysNeedsAccessMethod(isReadAccess)) {
    return baseField.getAccessMethod(isReadAccess);
  }
  if (isReadAccess)   return reader;
 else   return writer;
}",0.5558441558441558
9660,"public FieldBinding getPrivilegedAccessField(FieldBinding baseField,AstNode location){
  ResolvedMember key=inAspect.factory.makeResolvedMember(baseField);
  if (accessors.containsKey(key))   return (FieldBinding)accessors.get(key);
  FieldBinding ret=new PrivilegedFieldBinding(inAspect,baseField);
  checkWeaveAccess(key.getDeclaringType(),location);
  accessors.put(key,ret);
  return ret;
}","public FieldBinding getPrivilegedAccessField(FieldBinding baseField,AstNode location){
  ResolvedMember key=inAspect.factory.makeResolvedMember(baseField);
  if (accessors.containsKey(key))   return (FieldBinding)accessors.get(key);
  FieldBinding ret=new PrivilegedFieldBinding(inAspect,baseField);
  checkWeaveAccess(key.getDeclaringType(),location);
  if (!baseField.alwaysNeedsAccessMethod(true))   accessors.put(key,ret);
  return ret;
}",0.9425837320574164
9661,"public MethodBinding getPrivilegedAccessMethod(MethodBinding baseMethod,AstNode location){
  ResolvedMember key=inAspect.factory.makeResolvedMember(baseMethod);
  if (accessors.containsKey(key))   return (MethodBinding)accessors.get(key);
  MethodBinding ret;
  if (baseMethod.isConstructor()) {
    ret=baseMethod;
  }
 else {
    ret=inAspect.factory.makeMethodBinding(AjcMemberMaker.privilegedAccessMethodForMethod(inAspect.typeX,key));
  }
  checkWeaveAccess(key.getDeclaringType(),location);
  accessors.put(key,ret);
  return ret;
}","public MethodBinding getPrivilegedAccessMethod(MethodBinding baseMethod,AstNode location){
  if (baseMethod.alwaysNeedsAccessMethod())   return baseMethod;
  ResolvedMember key=inAspect.factory.makeResolvedMember(baseMethod);
  if (accessors.containsKey(key))   return (MethodBinding)accessors.get(key);
  MethodBinding ret;
  if (baseMethod.isConstructor()) {
    ret=baseMethod;
  }
 else {
    ret=inAspect.factory.makeMethodBinding(AjcMemberMaker.privilegedAccessMethodForMethod(inAspect.typeX,key));
  }
  checkWeaveAccess(key.getDeclaringType(),location);
  accessors.put(key,ret);
  return ret;
}",0.9430324276950044
9662,"public void resolveStatements(){
  if (isAbstract())   this.modifiers|=AccSemicolonBody;
  if (binding == null || ignoreFurtherInvestigation)   return;
  if (pointcutDesignator != null) {
    pointcutDesignator.finishResolveTypes(this,this.binding,arguments.length,scope.enclosingSourceType());
  }
  super.resolveStatements();
}","public void resolveStatements(){
  if (isAbstract()) {
    this.modifiers|=AccSemicolonBody;
    if (pointcutDesignator != null) {
      scope.problemReporter().signalError(sourceStart,sourceEnd,""String_Node_Str"");
    }
  }
  if (binding == null || ignoreFurtherInvestigation)   return;
  if (pointcutDesignator != null) {
    pointcutDesignator.finishResolveTypes(this,this.binding,arguments.length,scope.enclosingSourceType());
  }
  super.resolveStatements();
}",0.8287153652392947
9663,"public void resolveStatements(){
  if (isAbstract()) {
    this.modifiers|=AccSemicolonBody;
    if (pointcutDesignator != null) {
      scope.problemReporter().signalError(sourceStart,sourceEnd,""String_Node_Str"");
    }
  }
  if (binding == null || ignoreFurtherInvestigation)   return;
  if (pointcutDesignator != null) {
    pointcutDesignator.finishResolveTypes(this,this.binding,arguments.length,scope.enclosingSourceType());
  }
  super.resolveStatements();
}","public void resolveStatements(){
  if (isAbstract()) {
    this.modifiers|=AccSemicolonBody;
  }
  if (binding == null || ignoreFurtherInvestigation)   return;
  if (Modifier.isAbstract(this.declaredModifiers) && (pointcutDesignator != null)) {
    scope.problemReporter().signalError(sourceStart,sourceEnd,""String_Node_Str"");
  }
  if (pointcutDesignator != null) {
    pointcutDesignator.finishResolveTypes(this,this.binding,arguments.length,scope.enclosingSourceType());
  }
  super.resolveStatements();
}",0.8016443987667009
9664,"private static String getName(TypeBinding binding){
  String packageName=new String(binding.qualifiedPackageName());
  String className=new String(binding.qualifiedSourceName()).replace('.','$');
  if (packageName.length() > 0) {
    className=packageName + ""String_Node_Str"" + className;
  }
  return new String(className);
}","private static String getName(TypeBinding binding){
  if (binding instanceof ReferenceBinding) {
    return new String(CharOperation.concatWith(((ReferenceBinding)binding).compoundName,'.'));
  }
  String packageName=new String(binding.qualifiedPackageName());
  String className=new String(binding.qualifiedSourceName()).replace('.','$');
  if (packageName.length() > 0) {
    className=packageName + ""String_Node_Str"" + className;
  }
  return new String(className);
}",0.8190954773869347
9665,"private void doDeclareParents(DeclareParents declareParents,SourceTypeBinding sourceType){
  if (declareParents.match(factory.fromEclipse(sourceType))) {
    TypePatternList l=declareParents.getParents();
    for (int i=0, len=l.size(); i < len; i++) {
      addParent(declareParents,sourceType,l.get(i));
    }
  }
}","private void doDeclareParents(DeclareParents declareParents,SourceTypeBinding sourceType){
  List newParents=declareParents.findMatchingNewParents(factory.fromEclipse(sourceType));
  if (!newParents.isEmpty()) {
    for (Iterator i=newParents.iterator(); i.hasNext(); ) {
      ResolvedTypeX parent=(ResolvedTypeX)i.next();
      addParent(sourceType,parent);
    }
  }
}",0.4505813953488372
9666,"private void addParent(DeclareParents declareParents,SourceTypeBinding sourceType,TypePattern typePattern){
  if (typePattern == TypePattern.NO)   return;
  TypeX iType=typePattern.getExactType();
  ReferenceBinding b=(ReferenceBinding)factory.makeTypeBinding(iType);
  if (b.isClass()) {
    if (sourceType.isInterface()) {
      factory.showMessage(IMessage.ERROR,""String_Node_Str"",declareParents.getSourceLocation(),null);
    }
    if (sourceType == b || sourceType.isSuperclassOf(b)) {
      factory.showMessage(IMessage.ERROR,""String_Node_Str"",declareParents.getSourceLocation(),null);
      return;
    }
    sourceType.superclass=b;
  }
 else {
    if (sourceType.equals(b)) {
      return;
    }
    if (sourceType.isInterface() && b.implementsInterface(sourceType,true)) {
      factory.showMessage(IMessage.ERROR,""String_Node_Str"",declareParents.getSourceLocation(),null);
      return;
    }
    if (sourceType == b || b.isSuperclassOf(sourceType))     return;
    ReferenceBinding[] oldI=sourceType.superInterfaces;
    ReferenceBinding[] newI;
    if (oldI == null) {
      newI=new ReferenceBinding[1];
      newI[0]=b;
    }
 else {
      int n=oldI.length;
      newI=new ReferenceBinding[n + 1];
      System.arraycopy(oldI,0,newI,0,n);
      newI[n]=b;
    }
    sourceType.superInterfaces=newI;
  }
}","private void addParent(SourceTypeBinding sourceType,ResolvedTypeX parent){
  ReferenceBinding parentBinding=(ReferenceBinding)factory.makeTypeBinding(parent);
  if (parentBinding.isClass()) {
    sourceType.superclass=parentBinding;
  }
 else {
    ReferenceBinding[] oldI=sourceType.superInterfaces;
    ReferenceBinding[] newI;
    if (oldI == null) {
      newI=new ReferenceBinding[1];
      newI[0]=parentBinding;
    }
 else {
      int n=oldI.length;
      newI=new ReferenceBinding[n + 1];
      System.arraycopy(oldI,0,newI,0,n);
      newI[n]=parentBinding;
    }
    sourceType.superInterfaces=newI;
  }
}",0.4948347107438016
9667,"public void testDeclareParentsFail() throws IOException {
  CommandTestCase.checkCompile(""String_Node_Str"",new int[]{3,11,19,21});
}","public void testDeclareParentsFail() throws IOException {
  CommandTestCase.checkCompile(""String_Node_Str"",new int[]{3,11,19});
}",0.9885057471264368
9668,"public void buildInterTypeAndPerClause(ClassScope classScope){
  checkSpec(classScope);
  if (ignoreFurtherInvestigation)   return;
  factory=EclipseFactory.fromScopeLookupEnvironment(scope);
  if (isPrivileged) {
    binding.privilegedHandler=new PrivilegedHandler(this);
  }
  buildPerClause(scope);
  if (methods != null) {
    for (int i=0; i < methods.length; i++) {
      if (methods[i] instanceof InterTypeDeclaration) {
        EclipseTypeMunger m=((InterTypeDeclaration)methods[i]).build(classScope);
        if (m != null)         concreteName.typeMungers.add(m);
      }
 else       if (methods[i] instanceof DeclareDeclaration) {
        Declare d=((DeclareDeclaration)methods[i]).build(classScope);
        if (d != null)         concreteName.declares.add(d);
      }
    }
  }
  factory.getWorld().getCrosscuttingMembersSet().addOrReplaceAspect(typeX);
  if (typeX.getSuperclass().isAspect() && !typeX.getSuperclass().isExposedToWeaver()) {
    factory.getWorld().getCrosscuttingMembersSet().addOrReplaceAspect(typeX.getSuperclass());
  }
}","public void buildInterTypeAndPerClause(ClassScope classScope){
  factory=EclipseFactory.fromScopeLookupEnvironment(scope);
  if (isPrivileged) {
    binding.privilegedHandler=new PrivilegedHandler(this);
  }
  checkSpec(classScope);
  if (ignoreFurtherInvestigation)   return;
  buildPerClause(scope);
  if (methods != null) {
    for (int i=0; i < methods.length; i++) {
      if (methods[i] instanceof InterTypeDeclaration) {
        EclipseTypeMunger m=((InterTypeDeclaration)methods[i]).build(classScope);
        if (m != null)         concreteName.typeMungers.add(m);
      }
 else       if (methods[i] instanceof DeclareDeclaration) {
        Declare d=((DeclareDeclaration)methods[i]).build(classScope);
        if (d != null)         concreteName.declares.add(d);
      }
    }
  }
  factory.getWorld().getCrosscuttingMembersSet().addOrReplaceAspect(typeX);
  if (typeX.getSuperclass().isAspect() && !typeX.getSuperclass().isExposedToWeaver()) {
    factory.getWorld().getCrosscuttingMembersSet().addOrReplaceAspect(typeX.getSuperclass());
  }
}",0.9345351043643264
9669,"private void makePublic(TypeBinding binding){
  if (binding instanceof ReferenceBinding) {
    ReferenceBinding rb=(ReferenceBinding)binding;
    if (!rb.isPublic())     handler.notePrivilegedTypeAccess(rb,null);
  }
 else   if (binding instanceof ArrayBinding) {
    makePublic(((ArrayBinding)binding).leafComponentType);
  }
 else {
    return;
  }
}","private void makePublic(TypeBinding binding){
  if (binding == null || !binding.isValidBinding())   return;
  if (binding instanceof ReferenceBinding) {
    ReferenceBinding rb=(ReferenceBinding)binding;
    if (!rb.isPublic())     handler.notePrivilegedTypeAccess(rb,null);
  }
 else   if (binding instanceof ArrayBinding) {
    makePublic(((ArrayBinding)binding).leafComponentType);
  }
 else {
    return;
  }
}",0.9190600522193212
9670,"public EclipseTypeMunger build(ClassScope classScope){
  EclipseFactory world=EclipseFactory.fromScopeLookupEnvironment(classScope);
  resolveOnType(classScope);
  if (classScope.referenceContext.binding == null)   return null;
  binding=classScope.referenceContext.binding.resolveTypesFor(binding);
  if (ignoreFurtherInvestigation)   return null;
  if (!Modifier.isStatic(declaredModifiers)) {
    super.binding.parameters=new TypeBinding[]{onTypeBinding};
    this.arguments=new Argument[]{AstUtil.makeFinalArgument(""String_Node_Str"".toCharArray(),onTypeBinding)};
  }
  ResolvedMember sig=new ResolvedMember(Member.FIELD,EclipseFactory.fromBinding(onTypeBinding),declaredModifiers,EclipseFactory.fromBinding(binding.returnType),new String(declaredSelector),TypeX.NONE);
  NewFieldTypeMunger myMunger=new NewFieldTypeMunger(sig,null);
  setMunger(myMunger);
  ResolvedTypeX aspectType=world.fromEclipse(classScope.referenceContext.binding);
  ResolvedMember me=myMunger.getInitMethod(aspectType);
  this.selector=binding.selector=me.getName().toCharArray();
  this.binding.returnType=TypeBinding.VoidBinding;
  return new EclipseTypeMunger(world,myMunger,aspectType,this);
}","public EclipseTypeMunger build(ClassScope classScope){
  EclipseFactory world=EclipseFactory.fromScopeLookupEnvironment(classScope);
  resolveOnType(classScope);
  if (ignoreFurtherInvestigation)   return null;
  binding=classScope.referenceContext.binding.resolveTypesFor(binding);
  if (ignoreFurtherInvestigation)   return null;
  if (!Modifier.isStatic(declaredModifiers)) {
    super.binding.parameters=new TypeBinding[]{onTypeBinding};
    this.arguments=new Argument[]{AstUtil.makeFinalArgument(""String_Node_Str"".toCharArray(),onTypeBinding)};
  }
  ResolvedMember sig=new ResolvedMember(Member.FIELD,EclipseFactory.fromBinding(onTypeBinding),declaredModifiers,EclipseFactory.fromBinding(binding.returnType),new String(declaredSelector),TypeX.NONE);
  NewFieldTypeMunger myMunger=new NewFieldTypeMunger(sig,null);
  setMunger(myMunger);
  ResolvedTypeX aspectType=world.fromEclipse(classScope.referenceContext.binding);
  ResolvedMember me=myMunger.getInitMethod(aspectType);
  this.selector=binding.selector=me.getName().toCharArray();
  this.binding.returnType=TypeBinding.VoidBinding;
  return new EclipseTypeMunger(world,myMunger,aspectType,this);
}",0.9704749679075738
9671,"public EclipseTypeMunger makeEclipseTypeMunger(ConcreteTypeMunger concrete){
  if (concrete instanceof EclipseTypeMunger)   return (EclipseTypeMunger)concrete;
  if (EclipseTypeMunger.supportsKind(concrete.getMunger().getKind())) {
    return new EclipseTypeMunger(this,concrete.getMunger(),concrete.getAspectType(),null);
  }
 else {
    return null;
  }
}","public EclipseTypeMunger makeEclipseTypeMunger(ConcreteTypeMunger concrete){
  if (concrete instanceof EclipseTypeMunger)   return (EclipseTypeMunger)concrete;
  if (concrete.getMunger() != null && EclipseTypeMunger.supportsKind(concrete.getMunger().getKind())) {
    return new EclipseTypeMunger(this,concrete.getMunger(),concrete.getAspectType(),null);
  }
 else {
    return null;
  }
}",0.9571045576407506
9672,"public static EclipseShadow makeShadow(EclipseFactory world,AstNode astNode,ReferenceContext context){
  if (astNode instanceof AllocationExpression) {
    AllocationExpression e=(AllocationExpression)astNode;
    return new EclipseShadow(world,Shadow.ConstructorCall,world.makeResolvedMember(e.binding),astNode,context);
  }
 else   if (astNode instanceof MessageSend) {
    MessageSend e=(MessageSend)astNode;
    return new EclipseShadow(world,Shadow.MethodCall,world.makeResolvedMember(e.binding),astNode,context);
  }
 else   if (astNode instanceof ExplicitConstructorCall) {
    return null;
  }
 else   if (astNode instanceof AbstractMethodDeclaration) {
    AbstractMethodDeclaration e=(AbstractMethodDeclaration)astNode;
    Shadow.Kind kind;
    if (e instanceof AdviceDeclaration) {
      kind=Shadow.AdviceExecution;
    }
 else     if (e instanceof InterTypeMethodDeclaration) {
      return new EclipseShadow(world,Shadow.MethodExecution,((InterTypeDeclaration)e).getSignature(),astNode,context);
    }
 else     if (e instanceof InterTypeConstructorDeclaration) {
      return new EclipseShadow(world,Shadow.ConstructorExecution,((InterTypeDeclaration)e).getSignature(),astNode,context);
    }
 else     if (e instanceof InterTypeFieldDeclaration) {
      return null;
    }
 else     if (e instanceof MethodDeclaration) {
      kind=Shadow.MethodExecution;
    }
 else     if (e instanceof ConstructorDeclaration) {
      kind=Shadow.ConstructorExecution;
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + e);
    }
    return new EclipseShadow(world,kind,world.makeResolvedMember(e.binding),astNode,context);
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + astNode);
  }
}","public static EclipseShadow makeShadow(EclipseFactory world,AstNode astNode,ReferenceContext context){
  if (astNode instanceof AllocationExpression) {
    AllocationExpression e=(AllocationExpression)astNode;
    return new EclipseShadow(world,Shadow.ConstructorCall,world.makeResolvedMember(e.binding),astNode,context);
  }
 else   if (astNode instanceof MessageSend) {
    MessageSend e=(MessageSend)astNode;
    if (e.isSuperAccess())     return null;
    return new EclipseShadow(world,Shadow.MethodCall,world.makeResolvedMember(e.binding),astNode,context);
  }
 else   if (astNode instanceof ExplicitConstructorCall) {
    return null;
  }
 else   if (astNode instanceof AbstractMethodDeclaration) {
    AbstractMethodDeclaration e=(AbstractMethodDeclaration)astNode;
    Shadow.Kind kind;
    if (e instanceof AdviceDeclaration) {
      kind=Shadow.AdviceExecution;
    }
 else     if (e instanceof InterTypeMethodDeclaration) {
      return new EclipseShadow(world,Shadow.MethodExecution,((InterTypeDeclaration)e).getSignature(),astNode,context);
    }
 else     if (e instanceof InterTypeConstructorDeclaration) {
      return new EclipseShadow(world,Shadow.ConstructorExecution,((InterTypeDeclaration)e).getSignature(),astNode,context);
    }
 else     if (e instanceof InterTypeFieldDeclaration) {
      return null;
    }
 else     if (e instanceof MethodDeclaration) {
      kind=Shadow.MethodExecution;
    }
 else     if (e instanceof ConstructorDeclaration) {
      kind=Shadow.ConstructorExecution;
    }
 else     if (e instanceof Clinit) {
      kind=Shadow.StaticInitialization;
    }
 else {
      return null;
    }
    return new EclipseShadow(world,kind,world.makeResolvedMember(e.binding),astNode,context);
  }
 else   if (astNode instanceof TypeDeclaration) {
    return new EclipseShadow(world,Shadow.StaticInitialization,new Member(Member.STATIC_INITIALIZATION,world.fromBinding(((TypeDeclaration)astNode).binding),0,ResolvedTypeX.VOID,""String_Node_Str"",TypeX.NONE),astNode,context);
  }
 else {
    return null;
  }
}",0.8107247146270241
9673,"public EclipseShadow(EclipseFactory world,Kind kind,Member signature,AstNode astNode,ReferenceContext context){
  super(kind,signature,null);
  this.world=world;
  this.astNode=astNode;
  this.enclosingMethod=(AbstractMethodDeclaration)context;
}","public EclipseShadow(EclipseFactory world,Kind kind,Member signature,AstNode astNode,ReferenceContext context){
  super(kind,signature,null);
  this.world=world;
  this.astNode=astNode;
  this.context=context;
}",0.8927789934354485
9674,"public Member getEnclosingCodeSignature(){
  return world.makeResolvedMember(enclosingMethod.binding);
}","public Member getEnclosingCodeSignature(){
  if (context instanceof TypeDeclaration) {
    return new Member(Member.STATIC_INITIALIZATION,getEnclosingType(),0,ResolvedTypeX.VOID,""String_Node_Str"",TypeX.NONE);
  }
 else   if (context instanceof AbstractMethodDeclaration) {
    return world.makeResolvedMember(((AbstractMethodDeclaration)context).binding);
  }
 else {
    return null;
  }
}",0.3562753036437247
9675,"public TypeX getEnclosingType(){
  return world.fromBinding(enclosingMethod.binding.declaringClass);
}","public TypeX getEnclosingType(){
  if (context instanceof TypeDeclaration) {
    return world.fromBinding(((TypeDeclaration)context).binding);
  }
 else   if (context instanceof AbstractMethodDeclaration) {
    return world.fromBinding(((AbstractMethodDeclaration)context).binding.declaringClass);
  }
 else {
    return ResolvedTypeX.MISSING;
  }
}",0.4124168514412417
9676,"public void unhandledException(TypeBinding exceptionType,AstNode location){
  if (!world.getWorld().getDeclareSoft().isEmpty()) {
    Shadow callSite=world.makeShadow(location,referenceContext);
    if (callSite == null) {
      super.unhandledException(exceptionType,location);
      return;
    }
    Shadow enclosingExec=world.makeShadow(referenceContext);
    for (Iterator i=world.getWorld().getDeclareSoft().iterator(); i.hasNext(); ) {
      DeclareSoft d=(DeclareSoft)i.next();
      FuzzyBoolean match=d.getPointcut().match(callSite);
      if (match.alwaysTrue()) {
        return;
      }
 else       if (!match.alwaysFalse()) {
        throw new RuntimeException(""String_Node_Str"");
      }
      match=d.getPointcut().match(enclosingExec);
      if (match.alwaysTrue()) {
        return;
      }
 else       if (!match.alwaysFalse()) {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
  }
  if (location instanceof Proceed) {
    return;
  }
  super.unhandledException(exceptionType,location);
}","public void unhandledException(TypeBinding exceptionType,AstNode location){
  if (!world.getWorld().getDeclareSoft().isEmpty()) {
    Shadow callSite=world.makeShadow(location,referenceContext);
    Shadow enclosingExec=world.makeShadow(referenceContext);
    for (Iterator i=world.getWorld().getDeclareSoft().iterator(); i.hasNext(); ) {
      DeclareSoft d=(DeclareSoft)i.next();
      if (callSite != null) {
        FuzzyBoolean match=d.getPointcut().match(callSite);
        if (match.alwaysTrue()) {
          return;
        }
 else         if (!match.alwaysFalse()) {
        }
      }
      if (enclosingExec != null) {
        FuzzyBoolean match=d.getPointcut().match(enclosingExec);
        if (match.alwaysTrue()) {
          return;
        }
 else         if (!match.alwaysFalse()) {
        }
      }
    }
  }
  if (location instanceof Proceed) {
    return;
  }
  super.unhandledException(exceptionType,location);
}",0.7744897959183673
9677,"public SourceLocation getSourceLocation(){
  return null;
}","public ISourceLocation getSourceLocation(){
  return null;
}",0.9915966386554622
9678,"public EclipseSourceType(ResolvedTypeX.Name resolvedTypeX,EclipseFactory factory,SourceTypeBinding binding,TypeDeclaration declaration){
  super(resolvedTypeX,true);
  this.factory=factory;
  this.binding=binding;
  this.declaration=declaration;
}","public EclipseSourceType(ResolvedTypeX.Name resolvedTypeX,EclipseFactory factory,SourceTypeBinding binding,TypeDeclaration declaration){
  super(resolvedTypeX,true);
  this.factory=factory;
  this.binding=binding;
  this.declaration=declaration;
  resolvedTypeX.setSourceContext(new EclipseSourceContext(declaration.compilationResult));
  resolvedTypeX.setStartPos(declaration.sourceStart);
  resolvedTypeX.setEndPos(declaration.sourceEnd);
}",0.7169811320754716
9679,"public ISourceLocation makeSourceLocation(IHasPosition position){
  return new EclipseSourceLocation(result,position.getStart(),position.getEnd());
}","public ISourceLocation makeSourceLocation(int line){
  return new SourceLocation(getSourceFile(),line);
}",0.7244094488188977
9680,"/** 
 * @param file File of the source; if null, use ISourceLocation.NO_FILE, not null
 * @param line int starting line of the location - positive number
 * @param endLine int ending line of the location - <= starting line
 * @param column int character position of starting location - positive number
 */
public SourceLocation(File file,int line,int endLine,int column){
  if (column == NO_COLUMN) {
    column=0;
    noColumn=true;
  }
  if (null == file) {
    file=ISourceLocation.NO_FILE;
  }
  validLine(line);
  validLine(endLine);
  LangUtil.throwIaxIfFalse(line <= endLine,line + ""String_Node_Str"" + endLine);
  LangUtil.throwIaxIfFalse(column >= 0,""String_Node_Str"" + column);
  this.sourceFile=file;
  this.startLine=line;
  this.column=column;
  this.endLine=endLine;
}","public SourceLocation(File file,int line,int endLine,int column,String context){
  if (column == NO_COLUMN) {
    column=0;
    noColumn=true;
  }
  if (null == file) {
    file=ISourceLocation.NO_FILE;
  }
  validLine(line);
  validLine(endLine);
  LangUtil.throwIaxIfFalse(line <= endLine,line + ""String_Node_Str"" + endLine);
  LangUtil.throwIaxIfFalse(column >= 0,""String_Node_Str"" + column);
  this.sourceFile=file;
  this.startLine=line;
  this.column=column;
  this.endLine=endLine;
  this.context=context;
}",0.4926640926640926
9681,"/** 
 * @return String {file:}line{:column} 
 */
public String toString(){
  StringBuffer sb=new StringBuffer();
  if (sourceFile != ISourceLocation.NO_FILE) {
    sb.append(sourceFile.getPath());
    sb.append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"" + startLine + ""String_Node_Str""+ endLine);
  if (!noColumn) {
    sb.append(""String_Node_Str"" + column);
  }
  return sb.toString();
}","/** 
 * @return String {context\n}{file:}line{:column} 
 */
public String toString(){
  StringBuffer sb=new StringBuffer();
  if (null != context) {
    sb.append(context);
    sb.append(LangUtil.EOL);
  }
  if (sourceFile != ISourceLocation.NO_FILE) {
    sb.append(sourceFile.getPath());
    sb.append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"" + startLine + ""String_Node_Str""+ endLine);
  if (!noColumn) {
    sb.append(""String_Node_Str"" + column);
  }
  return sb.toString();
}",0.8731762065095399
9682,"public int getEndLine(){
  return getLine();
}","public int getEndLine(){
  if (-1 == endLine) {
    endLine=ProblemHandler.searchLineNumber(result.lineSeparatorPositions,endPos);
  }
  return endLine;
}",0.42
9683,"public File getSourceFile(){
  return new File(new String(result.fileName));
}","public File getSourceFile(){
  if (null == file) {
    file=new File(new String(result.fileName));
  }
  return file;
}",0.7411167512690355
9684,"public int getLine(){
  return ProblemHandler.searchLineNumber(result.lineSeparatorPositions,startPos);
}","public int getLine(){
  if (-1 == startLine) {
    startLine=ProblemHandler.searchLineNumber(result.lineSeparatorPositions,startPos);
  }
  return startLine;
}",0.7803030303030303
9685,"public int getColumn(){
  return 0;
}","public int getColumn(){
  if (-1 == column) {
    int lineNumber=getLine();
    if (0 < lineNumber) {
      int lineStart=result.lineSeparatorPositions[getLine()];
      int col=startPos - lineStart;
      if (0 <= col) {
        column=col;
      }
 else {
        column=0;
      }
    }
  }
  return column;
}",0.154727793696275
9686,"/** 
 * This renders entire message text, but also sets up source location 
 */
public static IMessage makeMessage(ICompilationUnit unit,IProblem problem){
  ISourceLocation sourceLocation=makeSourceLocation(unit,problem);
  String locationContext=makeLocationContext(unit,problem);
  StringBuffer mssg=new StringBuffer();
  mssg.append(problem.getOriginatingFileName());
  mssg.append(""String_Node_Str"" + problem.getSourceLineNumber());
  mssg.append(""String_Node_Str"");
  mssg.append(problem.getMessage());
  mssg.append(LangUtil.EOL);
  mssg.append(locationContext);
  return new Message(mssg.toString(),sourceLocation,problem.isError());
}","/** 
 * Extract message text and source location, including context. 
 */
public static IMessage makeMessage(ICompilationUnit unit,IProblem problem){
  ISourceLocation sourceLocation=makeSourceLocation(unit,problem);
  return new Message(problem.getMessage(),sourceLocation,problem.isError());
}",0.3603411513859275
9687,"public static ISourceLocation makeSourceLocation(ICompilationUnit unit,IProblem problem){
  int line=problem.getSourceLineNumber();
  File file=new File(new String(problem.getOriginatingFileName()));
  return new SourceLocation(file,line,line,0);
}","/** 
 * Extract source location file, start and end lines, and context. Column is not extracted correctly.
 * @return ISourceLocation with correct file and lines but not column.
 */
public static ISourceLocation makeSourceLocation(ICompilationUnit unit,IProblem problem){
  int line=problem.getSourceLineNumber();
  File file=new File(new String(problem.getOriginatingFileName()));
  String context=makeLocationContext(unit,problem);
  return new SourceLocation(file,line,line,0,context);
}",0.6720867208672087
9688,"protected String render(IMessage message){
  IMessage.Kind kind=message.getKind();
  if (kind.equals(IMessage.ABORT)) {
    Throwable t=message.getThrown();
    if (null == t) {
      return ""String_Node_Str"";
    }
 else {
      return Main.renderExceptionForUser(t);
    }
  }
  String m=message.getMessage();
  if (LangUtil.isEmpty(m)) {
    m=message.toString();
  }
  return m;
}","/** 
 * Render message differently. If abort, then prefix stack trace with feedback request. If the actual message is empty, then use toString on the whole. Prefix message part with file:line; If it has context, suffix message with context.
 * @param message the IMessage to render
 * @return String rendering IMessage (never null)
 */
protected String render(IMessage message){
  IMessage.Kind kind=message.getKind();
  if (kind.equals(IMessage.ABORT)) {
    Throwable t=message.getThrown();
    if (null == t) {
      return ""String_Node_Str"";
    }
 else {
      return Main.renderExceptionForUser(t);
    }
  }
  StringBuffer sb=new StringBuffer();
  String text=message.getMessage();
  boolean toString=(LangUtil.isEmpty(text));
  if (toString) {
    text=message.toString();
  }
  ISourceLocation loc=message.getISourceLocation();
  String context=null;
  if (null != loc) {
    File file=loc.getSourceFile();
    if (null != file) {
      String name=file.getName();
      if (!toString || (-1 == text.indexOf(name))) {
        sb.append(FileUtil.getBestPath(file));
        sb.append(""String_Node_Str"" + loc.getLine());
        int col=loc.getColumn();
        if (0 < col) {
          sb.append(""String_Node_Str"" + col);
        }
        sb.append(""String_Node_Str"");
      }
    }
    context=loc.getContext();
  }
  sb.append(text);
  if (null != context) {
    sb.append(LangUtil.EOL);
    sb.append(context);
  }
  return sb.toString();
}",0.3986928104575163
9689,"public BinaryMethodSkeleton(char[] selector,char[] methodDescriptor,char[][] exceptionTypeNames,boolean isConstructor){
  this.selector=selector;
  this.methodDescriptor=methodDescriptor;
  this.exceptionTypeNames=exceptionTypeNames;
  this.isConstructor=isConstructor;
}","public BinaryMethodSkeleton(char[] selector,char[] methodDescriptor,char[][] exceptionTypeNames,boolean isConstructor){
  this.selector=selector;
  this.methodDescriptor=methodDescriptor;
  this.exceptionTypeNames=exceptionTypeNames;
  this.isConstructor=this.isConstructor;
}",0.9908592321755028
9690,"/** 
 * @param sourceFilePath	modified to '/' delimited path for consistency
 * @return		a new structure node for the file if it was not found in the model
 */
public StructureNode findRootNodeForSourceFile(String sourceFilePath){
  if (!isValid() || sourceFilePath == null) {
    return StructureModel.NO_STRUCTURE;
  }
 else {
    String correctedPath=sourceFilePath;
    StructureNode node=(StructureNode)getFileMap().get(correctedPath);
    if (node != null) {
      return node;
    }
 else {
      return createFileStructureNode(sourceFilePath);
    }
  }
}","/** 
 * @param sourceFilePath	modified to '/' delimited path for consistency
 * @return		a new structure node for the file if it was not found in the model
 */
public StructureNode findRootNodeForSourceFile(String sourceFile){
  try {
    if (!isValid() || sourceFile == null) {
      return StructureModel.NO_STRUCTURE;
    }
 else {
      String correctedPath=new File(sourceFile).getCanonicalPath();
      StructureNode node=(StructureNode)getFileMap().get(correctedPath);
      if (node != null) {
        return node;
      }
 else {
        return createFileStructureNode(correctedPath);
      }
    }
  }
 catch (  Exception e) {
    return StructureModel.NO_STRUCTURE;
  }
}",0.7550200803212851
9691,"private void internalBuild(CompilationUnitDeclaration unit,StructureModel structureModel){
  currCompilationResult=unit.compilationResult();
  File file=new File(new String(unit.getFileName()));
  ISourceLocation sourceLocation=new SourceLocation(file,1);
  ProgramElementNode cuNode=new ProgramElementNode(new String(file.getName()),ProgramElementNode.Kind.FILE_JAVA,sourceLocation,0,""String_Node_Str"",new ArrayList());
  ImportReference currentPackage=unit.currentPackage;
  if (currentPackage != null) {
    StringBuffer nameBuffer=new StringBuffer();
    for (int i=0; i < currentPackage.getImportName().length; i++) {
      nameBuffer.append(new String(currentPackage.getImportName()[i]));
      if (i < currentPackage.getImportName().length - 1)       nameBuffer.append('.');
    }
    String pkgName=nameBuffer.toString();
    boolean found=false;
    ProgramElementNode pkgNode=null;
    for (Iterator it=StructureModelManager.INSTANCE.getStructureModel().getRoot().getChildren().iterator(); it.hasNext(); ) {
      ProgramElementNode currNode=(ProgramElementNode)it.next();
      if (currNode.getName().equals(pkgName))       pkgNode=currNode;
    }
    if (pkgNode == null) {
      pkgNode=new ProgramElementNode(pkgName,ProgramElementNode.Kind.PACKAGE,new ArrayList());
      StructureModelManager.INSTANCE.getStructureModel().getRoot().addChild(pkgNode);
    }
    pkgNode.addChild(cuNode);
  }
 else {
    StructureModelManager.INSTANCE.getStructureModel().getRoot().addChild(cuNode);
  }
  stack.push(cuNode);
  unit.traverse(this,unit.scope);
  StructureModelManager.INSTANCE.getStructureModel().getFileMap().put(file.getAbsolutePath().replace('\\','/'),cuNode);
}","private void internalBuild(CompilationUnitDeclaration unit,StructureModel structureModel){
  currCompilationResult=unit.compilationResult();
  File file=new File(new String(unit.getFileName()));
  ISourceLocation sourceLocation=new SourceLocation(file,1);
  ProgramElementNode cuNode=new ProgramElementNode(new String(file.getName()),ProgramElementNode.Kind.FILE_JAVA,sourceLocation,0,""String_Node_Str"",new ArrayList());
  ImportReference currentPackage=unit.currentPackage;
  if (currentPackage != null) {
    StringBuffer nameBuffer=new StringBuffer();
    for (int i=0; i < currentPackage.getImportName().length; i++) {
      nameBuffer.append(new String(currentPackage.getImportName()[i]));
      if (i < currentPackage.getImportName().length - 1)       nameBuffer.append('.');
    }
    String pkgName=nameBuffer.toString();
    boolean found=false;
    ProgramElementNode pkgNode=null;
    for (Iterator it=StructureModelManager.INSTANCE.getStructureModel().getRoot().getChildren().iterator(); it.hasNext(); ) {
      ProgramElementNode currNode=(ProgramElementNode)it.next();
      if (currNode.getName().equals(pkgName))       pkgNode=currNode;
    }
    if (pkgNode == null) {
      pkgNode=new ProgramElementNode(pkgName,ProgramElementNode.Kind.PACKAGE,new ArrayList());
      StructureModelManager.INSTANCE.getStructureModel().getRoot().addChild(pkgNode);
    }
    pkgNode.addChild(cuNode);
  }
 else {
    StructureModelManager.INSTANCE.getStructureModel().getRoot().addChild(cuNode);
  }
  stack.push(cuNode);
  unit.traverse(this,unit.scope);
  try {
    StructureModelManager.INSTANCE.getStructureModel().getFileMap().put(file.getCanonicalPath(),cuNode);
  }
 catch (  IOException ioe) {
  }
}",0.9704840613931524
9692,"private MethodDeclaration makePreMethod(ClassScope scope,ExplicitConstructorCall explicitConstructorCall){
  EclipseWorld world=EclipseWorld.fromScopeLookupEnvironment(scope);
  TypeX aspectTypeX=EclipseWorld.fromBinding(binding.declaringClass);
  TypeX targetTypeX=EclipseWorld.fromBinding(onTypeBinding);
  ArrayBinding objectArrayBinding=scope.createArray(scope.getJavaLangObject(),1);
  MethodDeclaration pre=new MethodDeclaration(compilationResult);
  pre.modifiers=AccPublic | AccStatic;
  pre.returnType=AstUtil.makeTypeReference(objectArrayBinding);
  pre.selector=NameMangler.postIntroducedConstructor(aspectTypeX,targetTypeX).toCharArray();
  pre.arguments=AstUtil.copyArguments(this.arguments);
  pre.scope=new MethodScope(scope,pre,true);
  pre.binding=world.makeMethodBinding(AjcMemberMaker.preIntroducedConstructor(aspectTypeX,targetTypeX,world.fromBindings(binding.parameters)));
  pre.bindArguments();
  pre.bindThrownExceptions();
  if (explicitConstructorCall == null) {
    pre.statements=new Statement[]{};
  }
 else {
    pre.statements=new Statement[]{explicitConstructorCall};
  }
  InterTypeScope newParent=new InterTypeScope(scope,onTypeBinding);
  pre.scope.parent=newParent;
  pre.resolveStatements(newParent);
  int nParams=pre.arguments.length;
  MethodBinding explicitConstructor=null;
  if (explicitConstructorCall != null) {
    explicitConstructor=explicitConstructorCall.binding;
    if (explicitConstructor.alwaysNeedsAccessMethod()) {
      explicitConstructor=explicitConstructor.getAccessMethod();
    }
  }
  int nExprs;
  if (explicitConstructor == null)   nExprs=0;
 else   nExprs=explicitConstructor.parameters.length;
  ArrayInitializer init=new ArrayInitializer();
  init.expressions=new Expression[nExprs + nParams];
  int index=0;
  for (int i=0; i < nExprs; i++) {
    if (i >= explicitConstructorCall.arguments.length) {
      init.expressions[index++]=new NullLiteral(0,0);
      continue;
    }
    Expression arg=explicitConstructorCall.arguments[i];
    ResolvedMember conversionMethod=AjcMemberMaker.toObjectConversionMethod(world.fromBinding(explicitConstructorCall.binding.parameters[i]));
    if (conversionMethod != null) {
      arg=new KnownMessageSend(world.makeMethodBindingForCall(conversionMethod),new CastExpression(new NullLiteral(0,0),AstUtil.makeTypeReference(world.makeTypeBinding(AjcMemberMaker.CONVERSIONS_TYPE))),new Expression[]{arg});
    }
    init.expressions[index++]=arg;
  }
  for (int i=0; i < nParams; i++) {
    LocalVariableBinding binding=pre.arguments[i].binding;
    Expression arg=AstUtil.makeResolvedLocalVariableReference(binding);
    ResolvedMember conversionMethod=AjcMemberMaker.toObjectConversionMethod(world.fromBinding(binding.type));
    if (conversionMethod != null) {
      arg=new KnownMessageSend(world.makeMethodBindingForCall(conversionMethod),new CastExpression(new NullLiteral(0,0),AstUtil.makeTypeReference(world.makeTypeBinding(AjcMemberMaker.CONVERSIONS_TYPE))),new Expression[]{arg});
    }
    init.expressions[index++]=arg;
  }
  init.binding=objectArrayBinding;
  ArrayAllocationExpression newArray=new ArrayAllocationExpression();
  newArray.initializer=init;
  newArray.type=AstUtil.makeTypeReference(scope.getJavaLangObject());
  newArray.dimensions=new Expression[1];
  newArray.constant=NotAConstant;
  pre.statements=new Statement[]{new ReturnStatement(newArray,0,0)};
  return pre;
}","private MethodDeclaration makePreMethod(ClassScope scope,ExplicitConstructorCall explicitConstructorCall){
  EclipseWorld world=EclipseWorld.fromScopeLookupEnvironment(scope);
  TypeX aspectTypeX=EclipseWorld.fromBinding(binding.declaringClass);
  TypeX targetTypeX=EclipseWorld.fromBinding(onTypeBinding);
  ArrayBinding objectArrayBinding=scope.createArray(scope.getJavaLangObject(),1);
  MethodDeclaration pre=new MethodDeclaration(compilationResult);
  pre.modifiers=AccPublic | AccStatic;
  pre.returnType=AstUtil.makeTypeReference(objectArrayBinding);
  pre.selector=NameMangler.postIntroducedConstructor(aspectTypeX,targetTypeX).toCharArray();
  pre.arguments=AstUtil.copyArguments(this.arguments);
  pre.scope=new MethodScope(scope,pre,true);
  pre.binding=world.makeMethodBinding(AjcMemberMaker.preIntroducedConstructor(aspectTypeX,targetTypeX,world.fromBindings(binding.parameters)));
  pre.bindArguments();
  pre.bindThrownExceptions();
  if (explicitConstructorCall == null) {
    pre.statements=new Statement[]{};
  }
 else {
    pre.statements=new Statement[]{explicitConstructorCall};
  }
  InterTypeScope newParent=new InterTypeScope(scope,onTypeBinding);
  pre.scope.parent=newParent;
  pre.resolveStatements(newParent);
  int nParams=pre.arguments.length;
  MethodBinding explicitConstructor=null;
  if (explicitConstructorCall != null) {
    explicitConstructor=explicitConstructorCall.binding;
    if (explicitConstructor.alwaysNeedsAccessMethod()) {
      explicitConstructor=explicitConstructor.getAccessMethod(true);
    }
  }
  int nExprs;
  if (explicitConstructor == null)   nExprs=0;
 else   nExprs=explicitConstructor.parameters.length;
  ArrayInitializer init=new ArrayInitializer();
  init.expressions=new Expression[nExprs + nParams];
  int index=0;
  for (int i=0; i < nExprs; i++) {
    if (i >= explicitConstructorCall.arguments.length) {
      init.expressions[index++]=new NullLiteral(0,0);
      continue;
    }
    Expression arg=explicitConstructorCall.arguments[i];
    ResolvedMember conversionMethod=AjcMemberMaker.toObjectConversionMethod(world.fromBinding(explicitConstructorCall.binding.parameters[i]));
    if (conversionMethod != null) {
      arg=new KnownMessageSend(world.makeMethodBindingForCall(conversionMethod),new CastExpression(new NullLiteral(0,0),AstUtil.makeTypeReference(world.makeTypeBinding(AjcMemberMaker.CONVERSIONS_TYPE))),new Expression[]{arg});
    }
    init.expressions[index++]=arg;
  }
  for (int i=0; i < nParams; i++) {
    LocalVariableBinding binding=pre.arguments[i].binding;
    Expression arg=AstUtil.makeResolvedLocalVariableReference(binding);
    ResolvedMember conversionMethod=AjcMemberMaker.toObjectConversionMethod(world.fromBinding(binding.type));
    if (conversionMethod != null) {
      arg=new KnownMessageSend(world.makeMethodBindingForCall(conversionMethod),new CastExpression(new NullLiteral(0,0),AstUtil.makeTypeReference(world.makeTypeBinding(AjcMemberMaker.CONVERSIONS_TYPE))),new Expression[]{arg});
    }
    init.expressions[index++]=arg;
  }
  init.binding=objectArrayBinding;
  ArrayAllocationExpression newArray=new ArrayAllocationExpression();
  newArray.initializer=init;
  newArray.type=AstUtil.makeTypeReference(scope.getJavaLangObject());
  newArray.dimensions=new Expression[1];
  newArray.constant=NotAConstant;
  pre.statements=new Statement[]{new ReturnStatement(newArray,0,0)};
  return pre;
}",0.9994122832794592
9693,"private AjAttribute makeAttribute(EclipseWorld world){
  if (explicitConstructorCall != null && !(explicitConstructorCall.binding instanceof ProblemMethodBinding)) {
    MethodBinding explicitConstructor=explicitConstructorCall.binding;
    if (explicitConstructor.alwaysNeedsAccessMethod()) {
      explicitConstructor=explicitConstructor.getAccessMethod();
    }
    ((NewConstructorTypeMunger)munger).setExplicitConstructor(world.makeResolvedMember(explicitConstructor));
  }
 else {
    ((NewConstructorTypeMunger)munger).setExplicitConstructor(new ResolvedMember(Member.CONSTRUCTOR,EclipseWorld.fromBinding(onTypeBinding.superclass()),0,ResolvedTypeX.VOID,""String_Node_Str"",TypeX.NONE));
  }
  return new AjAttribute.TypeMunger(munger);
}","private AjAttribute makeAttribute(EclipseWorld world){
  if (explicitConstructorCall != null && !(explicitConstructorCall.binding instanceof ProblemMethodBinding)) {
    MethodBinding explicitConstructor=explicitConstructorCall.binding;
    if (explicitConstructor.alwaysNeedsAccessMethod()) {
      explicitConstructor=explicitConstructor.getAccessMethod(true);
    }
    ((NewConstructorTypeMunger)munger).setExplicitConstructor(world.makeResolvedMember(explicitConstructor));
  }
 else {
    ((NewConstructorTypeMunger)munger).setExplicitConstructor(new ResolvedMember(Member.CONSTRUCTOR,EclipseWorld.fromBinding(onTypeBinding.superclass()),0,ResolvedTypeX.VOID,""String_Node_Str"",TypeX.NONE));
  }
  return new AjAttribute.TypeMunger(munger);
}",0.9973154362416108
9694,"public void endVisit(MessageSend call,BlockScope scope){
  if (call.codegenBinding == null)   return;
  MethodBinding superBinding=call.codegenBinding;
  if (superBinding instanceof ProblemMethodBinding) {
    return;
  }
  char[] accessName;
  if (call.isSuperAccess() && !call.binding.isStatic()) {
    call.receiver=new ThisReference();
    accessName=NameMangler.superDispatchMethod(EclipseWorld.fromBinding(targetClass),new String(superBinding.selector)).toCharArray();
  }
 else   if (call.receiver.isThis() && call.binding.isProtected() && !call.binding.isStatic()) {
    if (superBinding.declaringClass.equals(targetClass)) {
      accessName=NameMangler.protectedDispatchMethod(EclipseWorld.fromBinding(targetClass),new String(superBinding.selector)).toCharArray();
    }
 else {
      accessName=NameMangler.superDispatchMethod(EclipseWorld.fromBinding(targetClass),new String(superBinding.selector)).toCharArray();
    }
  }
 else {
    return;
  }
  MethodBinding superAccessBinding=new MethodBinding(AstNode.AccPublic,accessName,superBinding.returnType,superBinding.parameters,superBinding.thrownExceptions,targetClass);
  call.codegenBinding=superAccessBinding;
  ResolvedMember targetMember=EclipseWorld.makeResolvedMember(superBinding);
  superMethodsCalled.add(targetMember);
}","public void endVisit(MessageSend call,BlockScope scope){
  if (call.codegenBinding == null)   return;
  MethodBinding superBinding=call.codegenBinding;
  if (superBinding instanceof ProblemMethodBinding) {
    return;
  }
  if (superBinding instanceof InterTypeMethodBinding) {
    return;
  }
  char[] accessName;
  if (call.isSuperAccess() && !call.binding.isStatic()) {
    call.receiver=new ThisReference();
    accessName=NameMangler.superDispatchMethod(EclipseWorld.fromBinding(targetClass),new String(superBinding.selector)).toCharArray();
  }
 else   if (call.receiver.isThis() && call.binding.isProtected() && !call.binding.isStatic()) {
    if (superBinding.declaringClass.equals(targetClass)) {
      accessName=NameMangler.protectedDispatchMethod(EclipseWorld.fromBinding(targetClass),new String(superBinding.selector)).toCharArray();
    }
 else {
      accessName=NameMangler.superDispatchMethod(EclipseWorld.fromBinding(targetClass),new String(superBinding.selector)).toCharArray();
    }
  }
 else {
    return;
  }
  MethodBinding superAccessBinding=new MethodBinding(AstNode.AccPublic,accessName,superBinding.returnType,superBinding.parameters,superBinding.thrownExceptions,targetClass);
  call.codegenBinding=superAccessBinding;
  ResolvedMember targetMember=EclipseWorld.makeResolvedMember(superBinding);
  superMethodsCalled.add(targetMember);
}",0.9729323308270676
9695,"public MethodBinding getAccessMethod(){
  return syntheticMethod;
}","public MethodBinding getAccessMethod(boolean staticReference){
  if (staticReference)   return postDispatchMethod;
 else   return syntheticMethod;
}",0.6232558139534884
9696,"public InterTypeMethodBinding(EclipseWorld world,ResolvedMember signature,TypeX withinType,AbstractMethodDeclaration sourceMethod){
  super(world.makeMethodBinding(signature),null);
  this.sourceMethod=sourceMethod;
  targetType=(ReferenceBinding)world.makeTypeBinding(signature.getDeclaringType());
  this.declaringClass=(ReferenceBinding)world.makeTypeBinding(withinType);
  if (signature.getKind() == Member.METHOD) {
    syntheticMethod=world.makeMethodBinding(AjcMemberMaker.interMethodDispatcher(signature,withinType));
  }
 else {
    syntheticMethod=world.makeMethodBinding(AjcMemberMaker.interConstructor(world.resolve(signature.getDeclaringType()),signature,withinType));
  }
}","public InterTypeMethodBinding(EclipseWorld world,ResolvedMember signature,TypeX withinType,AbstractMethodDeclaration sourceMethod){
  super(world.makeMethodBinding(signature),null);
  this.sourceMethod=sourceMethod;
  targetType=(ReferenceBinding)world.makeTypeBinding(signature.getDeclaringType());
  this.declaringClass=(ReferenceBinding)world.makeTypeBinding(withinType);
  if (signature.getKind() == Member.METHOD) {
    syntheticMethod=world.makeMethodBinding(AjcMemberMaker.interMethodDispatcher(signature,withinType));
    postDispatchMethod=world.makeMethodBinding(AjcMemberMaker.interMethodBody(signature,withinType));
  }
 else {
    syntheticMethod=world.makeMethodBinding(AjcMemberMaker.interConstructor(world.resolve(signature.getDeclaringType()),signature,withinType));
    postDispatchMethod=syntheticMethod;
  }
}",0.8759894459102903
9697,"public void manageSyntheticAccessIfNecessary(BlockScope currentScope){
  if (binding.alwaysNeedsAccessMethod()) {
    syntheticAccessor=binding.getAccessMethod();
    return;
  }
  if (binding.isPrivate() && (currentScope.enclosingSourceType() != binding.declaringClass)) {
    if (currentScope.environment().options.isPrivateConstructorAccessChangingVisibility) {
      binding.tagForClearingPrivateModifier();
    }
 else {
      syntheticAccessor=((SourceTypeBinding)binding.declaringClass).addSyntheticMethod(binding);
      currentScope.problemReporter().needToEmulateMethodAccess(binding,this);
    }
  }
}","public void manageSyntheticAccessIfNecessary(BlockScope currentScope){
  if (binding.alwaysNeedsAccessMethod()) {
    syntheticAccessor=binding.getAccessMethod(true);
    return;
  }
  if (binding.isPrivate() && (currentScope.enclosingSourceType() != binding.declaringClass)) {
    if (currentScope.environment().options.isPrivateConstructorAccessChangingVisibility) {
      binding.tagForClearingPrivateModifier();
    }
 else {
      syntheticAccessor=((SourceTypeBinding)binding.declaringClass).addSyntheticMethod(binding);
      currentScope.problemReporter().needToEmulateMethodAccess(binding,this);
    }
  }
}",0.996742671009772
9698,"public void manageSyntheticAccessIfNecessary(BlockScope currentScope){
  if (binding.alwaysNeedsAccessMethod()) {
    syntheticAccessor=binding.getAccessMethod();
    return;
  }
  if (binding.isPrivate() && (accessMode != This)) {
    if (currentScope.environment().options.isPrivateConstructorAccessChangingVisibility) {
      binding.tagForClearingPrivateModifier();
    }
 else {
      syntheticAccessor=((SourceTypeBinding)binding.declaringClass).addSyntheticMethod(binding);
      currentScope.problemReporter().needToEmulateMethodAccess(binding,this);
    }
  }
}","public void manageSyntheticAccessIfNecessary(BlockScope currentScope){
  if (binding.alwaysNeedsAccessMethod()) {
    syntheticAccessor=binding.getAccessMethod(true);
    return;
  }
  if (binding.isPrivate() && (accessMode != This)) {
    if (currentScope.environment().options.isPrivateConstructorAccessChangingVisibility) {
      binding.tagForClearingPrivateModifier();
    }
 else {
      syntheticAccessor=((SourceTypeBinding)binding.declaringClass).addSyntheticMethod(binding);
      currentScope.problemReporter().needToEmulateMethodAccess(binding,this);
    }
  }
}",0.9965034965034965
9699,"public void manageSyntheticAccessIfNecessary(BlockScope currentScope){
  if (binding.alwaysNeedsAccessMethod()) {
    syntheticAccessor=binding.getAccessMethod();
    return;
  }
  if (binding.isPrivate()) {
    if (currentScope.enclosingSourceType() != binding.declaringClass) {
      syntheticAccessor=((SourceTypeBinding)binding.declaringClass).addSyntheticMethod(binding);
      currentScope.problemReporter().needToEmulateMethodAccess(binding,this);
      return;
    }
  }
 else   if (receiver instanceof QualifiedSuperReference) {
    SourceTypeBinding destinationType=(SourceTypeBinding)(((QualifiedSuperReference)receiver).currentCompatibleType);
    syntheticAccessor=destinationType.addSyntheticMethod(binding);
    currentScope.problemReporter().needToEmulateMethodAccess(binding,this);
    return;
  }
 else   if (binding.isProtected()) {
    SourceTypeBinding enclosingSourceType;
    if (((bits & DepthMASK) != 0) && binding.declaringClass.getPackage() != (enclosingSourceType=currentScope.enclosingSourceType()).getPackage()) {
      SourceTypeBinding currentCompatibleType=(SourceTypeBinding)enclosingSourceType.enclosingTypeAt((bits & DepthMASK) >> DepthSHIFT);
      syntheticAccessor=currentCompatibleType.addSyntheticMethod(binding);
      currentScope.problemReporter().needToEmulateMethodAccess(binding,this);
      return;
    }
  }
  if (binding.declaringClass != this.qualifyingType && !this.qualifyingType.isArrayType() && ((currentScope.environment().options.complianceLevel >= CompilerOptions.JDK1_4 && (receiver != ThisReference.ThisImplicit || !binding.isStatic()) && binding.declaringClass.id != T_Object) || !binding.declaringClass.canBeSeenBy(currentScope))) {
    this.codegenBinding=currentScope.enclosingSourceType().getUpdatedMethodBinding(binding,(ReferenceBinding)this.qualifyingType);
  }
}","public void manageSyntheticAccessIfNecessary(BlockScope currentScope){
  if (binding.alwaysNeedsAccessMethod()) {
    syntheticAccessor=binding.getAccessMethod(isSuperAccess());
    return;
  }
  if (binding.isPrivate()) {
    if (currentScope.enclosingSourceType() != binding.declaringClass) {
      syntheticAccessor=((SourceTypeBinding)binding.declaringClass).addSyntheticMethod(binding);
      currentScope.problemReporter().needToEmulateMethodAccess(binding,this);
      return;
    }
  }
 else   if (receiver instanceof QualifiedSuperReference) {
    SourceTypeBinding destinationType=(SourceTypeBinding)(((QualifiedSuperReference)receiver).currentCompatibleType);
    syntheticAccessor=destinationType.addSyntheticMethod(binding);
    currentScope.problemReporter().needToEmulateMethodAccess(binding,this);
    return;
  }
 else   if (binding.isProtected()) {
    SourceTypeBinding enclosingSourceType;
    if (((bits & DepthMASK) != 0) && binding.declaringClass.getPackage() != (enclosingSourceType=currentScope.enclosingSourceType()).getPackage()) {
      SourceTypeBinding currentCompatibleType=(SourceTypeBinding)enclosingSourceType.enclosingTypeAt((bits & DepthMASK) >> DepthSHIFT);
      syntheticAccessor=currentCompatibleType.addSyntheticMethod(binding);
      currentScope.problemReporter().needToEmulateMethodAccess(binding,this);
      return;
    }
  }
  if (binding.declaringClass != this.qualifyingType && !this.qualifyingType.isArrayType() && ((currentScope.environment().options.complianceLevel >= CompilerOptions.JDK1_4 && (receiver != ThisReference.ThisImplicit || !binding.isStatic()) && binding.declaringClass.id != T_Object) || !binding.declaringClass.canBeSeenBy(currentScope))) {
    this.codegenBinding=currentScope.enclosingSourceType().getUpdatedMethodBinding(binding,(ReferenceBinding)this.qualifyingType);
  }
}",0.9959205874354092
9700,"/** 
 * This will only be called if alwaysNeedsAccessMethod() returns true. In that case it should return the access method to be used.
 */
public MethodBinding getAccessMethod(){
  throw new RuntimeException(""String_Node_Str"");
}","/** 
 * This will only be called if alwaysNeedsAccessMethod() returns true. In that case it should return the access method to be used.
 */
public MethodBinding getAccessMethod(boolean staticReference){
  throw new RuntimeException(""String_Node_Str"");
}",0.9523809523809524
9701,"public void endVisit(SingleNameReference ref,BlockScope scope){
  if (isRef(ref,thisJoinPointDec))   needsDynamic=true;
 else   if (isRef(ref,thisJoinPointStaticPartDec))   needsStatic=true;
 else   if (isRef(ref,thisEnclosingJoinPointStaticPartDec))   needsStaticEnclosing=true;
}","public void endVisit(SingleNameReference ref,BlockScope scope){
  if (isRef(ref,thisJoinPointDec)) {
    needsDynamic=true;
  }
 else   if (isRef(ref,thisJoinPointStaticPartDec)) {
    needsStatic=true;
  }
 else   if (isRef(ref,thisEnclosingJoinPointStaticPartDec)) {
    needsStaticEnclosing=true;
  }
}",0.9590443686006824
9702,"private void replaceEffectivelyStaticRef(MessageSend call){
  NameReference receiver=(NameReference)call.receiver;
  receiver.binding=thisJoinPointStaticPartDecLocal;
  receiver.codegenBinding=thisJoinPointStaticPartDecLocal;
  call.binding.declaringClass=(ReferenceBinding)thisJoinPointStaticPartDec.type;
}","private void replaceEffectivelyStaticRef(MessageSend call){
  NameReference receiver=(NameReference)call.receiver;
  receiver.binding=thisJoinPointStaticPartDecLocal;
  receiver.codegenBinding=thisJoinPointStaticPartDecLocal;
  call.binding=call.codegenBinding=getEquivalentStaticBinding(call.binding);
}",0.8202614379084967
9703,"public boolean incrementalBuild(AjBuildConfig buildConfig,IMessageHandler messageHandler) throws CoreException, IOException {
  if (javaBuilder == null || javaBuilder.currentProject == null) {
    return batchBuild(buildConfig,messageHandler);
  }
  final CountingMessageHandler counter=new CountingMessageHandler(messageHandler);
  try {
    currentHandler=counter;
    IncrementalBuilder builder=getIncrementalBuilder(messageHandler);
    IContainer[] sourceFolders=new IContainer[buildConfig.getSourceRoots().size()];
    int count=0;
    for (Iterator i=buildConfig.getSourceRoots().iterator(); i.hasNext(); count++) {
      sourceFolders[count]=new FilesystemFolder(((File)i.next()).getAbsolutePath());
    }
    builder.setSourceFolders(sourceFolders);
    getJavaBuilder().binaryResources=new SimpleLookupTable();
    SimpleLookupTable deltas=getDeltas(buildConfig);
    boolean succeeded=builder.build(deltas);
    if (counter.hasErrors()) {
      return false;
    }
    if (succeeded) {
      return weaveAndGenerateClassFiles(builder.getNewState());
    }
 else {
      return batchBuild(buildConfig,messageHandler);
    }
  }
  finally {
    currentHandler=null;
  }
}","public boolean incrementalBuild(AjBuildConfig buildConfig,IMessageHandler messageHandler) throws CoreException, IOException {
  if (javaBuilder == null || javaBuilder.currentProject == null || javaBuilder.lastState == null) {
    return batchBuild(buildConfig,messageHandler);
  }
  final CountingMessageHandler counter=new CountingMessageHandler(messageHandler);
  try {
    currentHandler=counter;
    IncrementalBuilder builder=getIncrementalBuilder(messageHandler);
    IContainer[] sourceFolders=new IContainer[buildConfig.getSourceRoots().size()];
    int count=0;
    for (Iterator i=buildConfig.getSourceRoots().iterator(); i.hasNext(); count++) {
      sourceFolders[count]=new FilesystemFolder(((File)i.next()).getAbsolutePath());
    }
    builder.setSourceFolders(sourceFolders);
    getJavaBuilder().binaryResources=new SimpleLookupTable();
    SimpleLookupTable deltas=getDeltas(buildConfig);
    boolean succeeded=builder.build(deltas);
    if (counter.hasErrors()) {
      return false;
    }
    if (succeeded) {
      return weaveAndGenerateClassFiles(builder.getNewState());
    }
 else {
      return batchBuild(buildConfig,messageHandler);
    }
  }
  finally {
    currentHandler=null;
  }
}",0.9862097785206854
9704,"void run(){
  assignLabels();
  print();
}","void run(){
  killNops();
  assignLabels();
  print();
}",0.8571428571428571
9705,"public LazyMethodGen(Method m,LazyClassGen enclosingClass){
  this.enclosingClass=enclosingClass;
  if (!m.isAbstract() && m.getCode() == null) {
    throw new RuntimeException(""String_Node_Str"" + m + ""String_Node_Str""+ enclosingClass);
  }
  MethodGen gen=new MethodGen(m,enclosingClass.getName(),enclosingClass.getConstantPoolGen());
  this.memberView=new BcelMethod(enclosingClass.getType(),m);
  this.accessFlags=gen.getAccessFlags();
  this.returnType=gen.getReturnType();
  this.name=gen.getName();
  this.argumentTypes=gen.getArgumentTypes();
  this.declaredExceptions=gen.getExceptions();
  this.attributes=gen.getAttributes();
  this.maxLocals=gen.getMaxLocals();
  if (gen.isAbstract() || gen.isNative()) {
    body=null;
  }
 else {
    body=gen.getInstructionList();
    unpackHandlers(gen);
    unpackLineNumbers(gen);
    unpackLocals(gen);
  }
  assertGoodBody();
}","public LazyMethodGen(Method m,LazyClassGen enclosingClass){
  this.enclosingClass=enclosingClass;
  if (!(m.isAbstract() || m.isNative()) && m.getCode() == null) {
    throw new RuntimeException(""String_Node_Str"" + m + ""String_Node_Str""+ enclosingClass);
  }
  MethodGen gen=new MethodGen(m,enclosingClass.getName(),enclosingClass.getConstantPoolGen());
  this.memberView=new BcelMethod(enclosingClass.getType(),m);
  this.accessFlags=gen.getAccessFlags();
  this.returnType=gen.getReturnType();
  this.name=gen.getName();
  this.argumentTypes=gen.getArgumentTypes();
  this.declaredExceptions=gen.getExceptions();
  this.attributes=gen.getAttributes();
  this.maxLocals=gen.getMaxLocals();
  if (gen.isAbstract() || gen.isNative()) {
    body=null;
  }
 else {
    body=gen.getInstructionList();
    unpackHandlers(gen);
    unpackLineNumbers(gen);
    unpackLocals(gen);
  }
  assertGoodBody();
}",0.9898762654668166
9706,"/** 
 * @param packageName	if null default package is searched
 * @param className 	can't be null
 */
public ProgramElementNode findNodeForClass(String packageName,String className){
  StructureNode packageNode=null;
  if (packageName == null) {
    packageNode=root;
  }
 else {
    for (Iterator it=root.getChildren().iterator(); it.hasNext(); ) {
      StructureNode node=(StructureNode)it.next();
      if (packageName.equals(node.getName())) {
        packageNode=node;
      }
    }
    if (packageNode == null)     return null;
  }
  for (Iterator it=packageNode.getChildren().iterator(); it.hasNext(); ) {
    ProgramElementNode fileNode=(ProgramElementNode)it.next();
    for (Iterator j=fileNode.getChildren().iterator(); j.hasNext(); ) {
      ProgramElementNode classNode=(ProgramElementNode)j.next();
      if (classNode instanceof ProgramElementNode && className.equals(classNode.getName())) {
        return (ProgramElementNode)classNode;
      }
    }
  }
  return null;
}","/** 
 * @param packageName	if null default package is searched
 * @param className 	can't be null
 */
public ProgramElementNode findNodeForClass(String packageName,String className){
  StructureNode packageNode=null;
  if (packageName == null) {
    packageNode=root;
  }
 else {
    for (Iterator it=root.getChildren().iterator(); it.hasNext(); ) {
      StructureNode node=(StructureNode)it.next();
      if (packageName.equals(node.getName())) {
        packageNode=node;
      }
    }
    if (packageNode == null)     return null;
  }
  for (Iterator it=packageNode.getChildren().iterator(); it.hasNext(); ) {
    ProgramElementNode fileNode=(ProgramElementNode)it.next();
    ProgramElementNode ret=findClassInNodes(fileNode.getChildren(),className);
    if (ret != null)     return ret;
  }
  return null;
}",0.7895613548028872
9707,"private static ProgramElementNode findOrCreateBodyNode(ProgramElementNode enclosingNode,Member shadowSig,Shadow shadow){
  for (Iterator it=enclosingNode.getChildren().iterator(); it.hasNext(); ) {
    ProgramElementNode node=(ProgramElementNode)it.next();
    if (shadowSig.getName().equals(node.getBytecodeName()) && shadowSig.getSignature().equals(node.getBytecodeSignature())) {
      return node;
    }
  }
  ISourceLocation sl=shadow.getSourceLocation();
  ProgramElementNode peNode=new ProgramElementNode(shadow.toString(),ProgramElementNode.Kind.CODE,new SourceLocation(enclosingNode.getSourceLocation().getSourceFile(),sl.getLine()),0,""String_Node_Str"",new ArrayList());
  System.err.println(peNode.getSourceLocation());
  peNode.setBytecodeName(shadowSig.getName());
  peNode.setBytecodeSignature(shadowSig.getSignature());
  enclosingNode.addChild(peNode);
  return peNode;
}","private static ProgramElementNode findOrCreateBodyNode(ProgramElementNode enclosingNode,Member shadowSig,Shadow shadow){
  for (Iterator it=enclosingNode.getChildren().iterator(); it.hasNext(); ) {
    ProgramElementNode node=(ProgramElementNode)it.next();
    if (shadowSig.getName().equals(node.getBytecodeName()) && shadowSig.getSignature().equals(node.getBytecodeSignature())) {
      return node;
    }
  }
  ISourceLocation sl=shadow.getSourceLocation();
  ProgramElementNode peNode=new ProgramElementNode(shadow.toString(),ProgramElementNode.Kind.CODE,new SourceLocation(enclosingNode.getSourceLocation().getSourceFile(),sl.getLine()),0,""String_Node_Str"",new ArrayList());
  peNode.setBytecodeName(shadowSig.getName());
  peNode.setBytecodeSignature(shadowSig.getSignature());
  enclosingNode.addChild(peNode);
  return peNode;
}",0.9709639953542392
9708,"private static ProgramElementNode getNode(StructureModel model,Shadow shadow){
  Member enclosingMember=shadow.getEnclosingCodeSignature();
  ProgramElementNode enclosingNode=lookupMember(model,enclosingMember);
  Member shadowSig=shadow.getSignature();
  if (!shadowSig.equals(enclosingMember)) {
    ProgramElementNode bodyNode=findOrCreateBodyNode(enclosingNode,shadowSig,shadow);
    return bodyNode;
  }
 else {
    return enclosingNode;
  }
}","private static ProgramElementNode getNode(StructureModel model,Shadow shadow){
  Member enclosingMember=shadow.getEnclosingCodeSignature();
  ProgramElementNode enclosingNode=lookupMember(model,enclosingMember);
  if (enclosingNode == null) {
    Lint.Kind err=shadow.getIWorld().getLint().shadowNotInStructure;
    if (err.isEnabled()) {
      err.signal(shadow.toString(),shadow.getSourceLocation());
    }
    return null;
  }
  Member shadowSig=shadow.getSignature();
  if (!shadowSig.equals(enclosingMember)) {
    ProgramElementNode bodyNode=findOrCreateBodyNode(enclosingNode,shadowSig,shadow);
    return bodyNode;
  }
 else {
    return enclosingNode;
  }
}",0.8043087971274686
9709,"private static ProgramElementNode findMemberInClass(ProgramElementNode classNode,Member member){
  if (classNode == null)   return null;
  for (Iterator it=classNode.getChildren().iterator(); it.hasNext(); ) {
    ProgramElementNode node=(ProgramElementNode)it.next();
    if (member.getName().equals(node.getBytecodeName()) && member.getSignature().equals(node.getBytecodeSignature())) {
      return node;
    }
  }
  return null;
}","private static ProgramElementNode findMemberInClass(ProgramElementNode classNode,Member member){
  if (classNode == null)   return null;
  for (Iterator it=classNode.getChildren().iterator(); it.hasNext(); ) {
    ProgramElementNode node=(ProgramElementNode)it.next();
    if (member.getName().equals(node.getBytecodeName()) && member.getSignature().equals(node.getBytecodeSignature())) {
      return node;
    }
  }
  return classNode;
}",0.9851088201603666
9710,"/** 
 * Actually implement the (non-empty) mungers associated with this shadow 
 */
private void implementMungers(){
  World world=getIWorld();
  for (Iterator iter=mungers.iterator(); iter.hasNext(); ) {
    ShadowMunger munger=(ShadowMunger)iter.next();
    munger.implementOn(this);
    if (world.getModel() != null) {
      System.err.println(""String_Node_Str"" + munger + ""String_Node_Str""+ this);
      AsmAdaptor.noteMunger(world.getModel(),this,munger);
    }
  }
}","/** 
 * Actually implement the (non-empty) mungers associated with this shadow 
 */
private void implementMungers(){
  World world=getIWorld();
  for (Iterator iter=mungers.iterator(); iter.hasNext(); ) {
    ShadowMunger munger=(ShadowMunger)iter.next();
    munger.implementOn(this);
    if (world.getModel() != null) {
      AsmAdaptor.noteMunger(world.getModel(),this,munger);
    }
  }
}",0.9074074074074074
9711,"/** 
 * This field goes on the class the field is declared onto
 */
public static ResolvedMember interFieldClassField(ResolvedMember field,TypeX aspectType){
  return new ResolvedMember(Member.FIELD,field.getDeclaringType(),makePublic(field.getModifiers()),field.getReturnType(),NameMangler.interFieldClassField(field.getModifiers(),aspectType,field.getDeclaringType(),field.getName()),TypeX.NONE);
}","/** 
 * This field goes on the class the field is declared onto
 */
public static ResolvedMember interFieldClassField(ResolvedMember field,TypeX aspectType){
  return new ResolvedMember(Member.FIELD,field.getDeclaringType(),makePublicNonFinal(field.getModifiers()),field.getReturnType(),NameMangler.interFieldClassField(field.getModifiers(),aspectType,field.getDeclaringType(),field.getName()),TypeX.NONE);
}",0.99009900990099
9712,"/** 
 * This method goes on the target type of the inter-type method. (and possibly the topmost-implemeters, if the target type is an interface) 
 */
public static ResolvedMember interMethod(ResolvedMember meth,TypeX aspectType,boolean onInterface){
  if (Modifier.isPublic(meth.getModifiers()) && !onInterface)   return meth;
  int modifiers=makePublic(meth.getModifiers());
  if (onInterface)   modifiers|=Modifier.ABSTRACT;
  return new ResolvedMember(Member.METHOD,meth.getDeclaringType(),modifiers,meth.getReturnType(),NameMangler.interMethod(meth.getModifiers(),aspectType,meth.getDeclaringType(),meth.getName()),meth.getParameterTypes());
}","/** 
 * This method goes on the target type of the inter-type method. (and possibly the topmost-implemeters, if the target type is an interface) 
 */
public static ResolvedMember interMethod(ResolvedMember meth,TypeX aspectType,boolean onInterface){
  if (Modifier.isPublic(meth.getModifiers()) && !onInterface)   return meth;
  int modifiers=makePublicNonFinal(meth.getModifiers());
  if (onInterface)   modifiers|=Modifier.ABSTRACT;
  return new ResolvedMember(Member.METHOD,meth.getDeclaringType(),modifiers,meth.getReturnType(),NameMangler.interMethod(meth.getModifiers(),aspectType,meth.getDeclaringType(),meth.getName()),meth.getParameterTypes());
}",0.9938556067588326
9713,"/** 
 * This field goes on top-most implementers of the interface the field is declared onto
 */
public static ResolvedMember interFieldInterfaceField(ResolvedMember field,TypeX onClass,TypeX aspectType){
  return new ResolvedMember(Member.FIELD,onClass,makePublic(field.getModifiers()),field.getReturnType(),NameMangler.interFieldInterfaceField(aspectType,field.getDeclaringType(),field.getName()),TypeX.NONE);
}","/** 
 * This field goes on top-most implementers of the interface the field is declared onto
 */
public static ResolvedMember interFieldInterfaceField(ResolvedMember field,TypeX onClass,TypeX aspectType){
  return new ResolvedMember(Member.FIELD,onClass,makePublicNonFinal(field.getModifiers()),field.getReturnType(),NameMangler.interFieldInterfaceField(aspectType,field.getDeclaringType(),field.getName()),TypeX.NONE);
}",0.9904076738609112
9714,"public void resolve(IScope scope){
  patterns=patterns.resolveBindings(scope,Bindings.NONE,false,false);
  for (int i=0; i < patterns.size(); i++) {
    TypePattern pi=patterns.get(i);
    if (pi.isStar())     continue;
    ResolvedTypeX exactType=pi.getExactType().resolve(scope.getWorld());
    if (exactType == ResolvedTypeX.MISSING)     continue;
    for (int j=0; j < patterns.size(); j++) {
      if (j == i)       continue;
      TypePattern pj=patterns.get(j);
      if (pj.isStar())       continue;
      if (pj.matchesStatically(exactType)) {
        scope.getWorld().showMessage(IMessage.ERROR,""String_Node_Str"" + exactType.getName() + ""String_Node_Str"",pi.getSourceLocation(),pj.getSourceLocation());
      }
    }
  }
}","public void resolve(IScope scope){
  patterns=patterns.resolveBindings(scope,Bindings.NONE,false,false);
  boolean seenStar=false;
  for (int i=0; i < patterns.size(); i++) {
    TypePattern pi=patterns.get(i);
    if (pi.isStar()) {
      if (seenStar) {
        scope.getWorld().showMessage(IMessage.ERROR,""String_Node_Str"",pi.getSourceLocation(),null);
      }
      seenStar=true;
      continue;
    }
    ResolvedTypeX exactType=pi.getExactType().resolve(scope.getWorld());
    if (exactType == ResolvedTypeX.MISSING)     continue;
    for (int j=0; j < patterns.size(); j++) {
      if (j == i)       continue;
      TypePattern pj=patterns.get(j);
      if (pj.isStar())       continue;
      if (pj.matchesStatically(exactType)) {
        scope.getWorld().showMessage(IMessage.ERROR,""String_Node_Str"" + exactType.getName() + ""String_Node_Str"",pi.getSourceLocation(),pj.getSourceLocation());
      }
    }
  }
}",0.4627498485766202
9715,"public void resolveBindings(IScope scope,Bindings bindings){
  if (onTypeSymbolic != null) {
    onType=onTypeSymbolic.resolveExactType(scope,bindings);
  }
  ResolvedTypeX searchType;
  if (onType != null) {
    searchType=scope.getWorld().resolve(onType);
  }
 else {
    searchType=scope.getEnclosingType();
  }
  arguments.resolveBindings(scope,bindings,true,true);
  ResolvedPointcutDefinition pointcutDef=searchType.findPointcut(name);
  if (onType == null) {
    while (true) {
      TypeX declaringType=searchType.getDeclaringType();
      if (declaringType == null)       break;
      searchType=declaringType.resolve(scope.getWorld());
      pointcutDef=searchType.findPointcut(name);
      if (pointcutDef != null) {
        onType=searchType;
        break;
      }
    }
  }
  if (pointcutDef == null) {
    scope.message(IMessage.ERROR,this,""String_Node_Str"");
    return;
  }
  if (!pointcutDef.isVisible(scope.getEnclosingType())) {
    scope.message(IMessage.ERROR,this,""String_Node_Str"" + pointcutDef + ""String_Node_Str"");
    return;
  }
  if (Modifier.isAbstract(pointcutDef.getModifiers())) {
    if (onType != null) {
      scope.message(IMessage.ERROR,this,""String_Node_Str"");
      return;
    }
 else     if (!searchType.isAbstract()) {
      scope.message(IMessage.ERROR,this,""String_Node_Str"");
      return;
    }
  }
  ResolvedTypeX[] parameterTypes=scope.getWorld().resolve(pointcutDef.getParameterTypes());
  if (parameterTypes.length != arguments.size()) {
    scope.message(IMessage.ERROR,this,""String_Node_Str"" + parameterTypes.length + ""String_Node_Str""+ arguments.size());
    return;
  }
  for (int i=0, len=arguments.size(); i < len; i++) {
    TypePattern p=arguments.get(i);
    if (p == TypePattern.NO) {
      scope.message(IMessage.ERROR,this,""String_Node_Str"");
      return;
    }
    if (!p.matchesSubtypes(parameterTypes[i]) && !p.getExactType().equals(TypeX.OBJECT)) {
      scope.message(IMessage.ERROR,p,""String_Node_Str"" + parameterTypes[i].getName() + ""String_Node_Str""+ p);
      return;
    }
  }
}","public void resolveBindings(IScope scope,Bindings bindings){
  if (onTypeSymbolic != null) {
    onType=onTypeSymbolic.resolveExactType(scope,bindings);
  }
  ResolvedTypeX searchType;
  if (onType != null) {
    searchType=scope.getWorld().resolve(onType);
  }
 else {
    searchType=scope.getEnclosingType();
  }
  arguments.resolveBindings(scope,bindings,true,true);
  ResolvedPointcutDefinition pointcutDef=searchType.findPointcut(name);
  if (pointcutDef == null && onType == null) {
    while (true) {
      TypeX declaringType=searchType.getDeclaringType();
      if (declaringType == null)       break;
      searchType=declaringType.resolve(scope.getWorld());
      pointcutDef=searchType.findPointcut(name);
      if (pointcutDef != null) {
        onType=searchType;
        break;
      }
    }
  }
  if (pointcutDef == null) {
    scope.message(IMessage.ERROR,this,""String_Node_Str"");
    return;
  }
  if (!pointcutDef.isVisible(scope.getEnclosingType())) {
    scope.message(IMessage.ERROR,this,""String_Node_Str"" + pointcutDef + ""String_Node_Str"");
    return;
  }
  if (Modifier.isAbstract(pointcutDef.getModifiers())) {
    if (onType != null) {
      scope.message(IMessage.ERROR,this,""String_Node_Str"");
      return;
    }
 else     if (!searchType.isAbstract()) {
      scope.message(IMessage.ERROR,this,""String_Node_Str"");
      return;
    }
  }
  ResolvedTypeX[] parameterTypes=scope.getWorld().resolve(pointcutDef.getParameterTypes());
  if (parameterTypes.length != arguments.size()) {
    scope.message(IMessage.ERROR,this,""String_Node_Str"" + parameterTypes.length + ""String_Node_Str""+ arguments.size());
    return;
  }
  for (int i=0, len=arguments.size(); i < len; i++) {
    TypePattern p=arguments.get(i);
    if (p == TypePattern.NO) {
      scope.message(IMessage.ERROR,this,""String_Node_Str"");
      return;
    }
    if (!p.matchesSubtypes(parameterTypes[i]) && !p.getExactType().equals(TypeX.OBJECT)) {
      scope.message(IMessage.ERROR,p,""String_Node_Str"" + parameterTypes[i].getName() + ""String_Node_Str""+ p);
      return;
    }
  }
}",0.9944269445117518
9716,"public void weaveSoftener(BcelAdvice munger,TypeX catchType){
  InstructionFactory fact=getFactory();
  InstructionList handler=new InstructionList();
  BcelVar exceptionVar=genTempVar(catchType);
  exceptionVar.appendStore(handler,fact);
  handler.append(fact.createNew(NameMangler.SOFT_EXCEPTION_TYPE));
  handler.append(fact.createDup(1));
  handler.append(exceptionVar.createLoad(fact));
  handler.append(fact.createInvoke(NameMangler.SOFT_EXCEPTION_TYPE,""String_Node_Str"",Type.VOID,new Type[]{Type.THROWABLE},Constants.INVOKESPECIAL));
  handler.append(fact.ATHROW);
  InstructionHandle handlerStart=handler.getStart();
  if (isFallsThrough()) {
    InstructionHandle jumpTarget=range.getEnd();
    handler.insert(fact.createBranchInstruction(Constants.GOTO,jumpTarget));
  }
  InstructionHandle protectedEnd=handler.getStart();
  range.insert(handler,Range.InsideAfter);
  enclosingMethod.addExceptionHandler(range.getStart().getNext(),protectedEnd.getPrev(),handlerStart,(ObjectType)BcelWorld.makeBcelType(catchType),getKind().hasHighPriorityExceptions());
}","public void weaveSoftener(BcelAdvice munger,TypeX catchType){
  if (getRange().getStart().getNext() == getRange().getEnd())   return;
  InstructionFactory fact=getFactory();
  InstructionList handler=new InstructionList();
  BcelVar exceptionVar=genTempVar(catchType);
  exceptionVar.appendStore(handler,fact);
  handler.append(fact.createNew(NameMangler.SOFT_EXCEPTION_TYPE));
  handler.append(fact.createDup(1));
  handler.append(exceptionVar.createLoad(fact));
  handler.append(fact.createInvoke(NameMangler.SOFT_EXCEPTION_TYPE,""String_Node_Str"",Type.VOID,new Type[]{Type.THROWABLE},Constants.INVOKESPECIAL));
  handler.append(fact.ATHROW);
  InstructionHandle handlerStart=handler.getStart();
  if (isFallsThrough()) {
    InstructionHandle jumpTarget=range.getEnd();
    handler.insert(fact.createBranchInstruction(Constants.GOTO,jumpTarget));
  }
  InstructionHandle protectedEnd=handler.getStart();
  range.insert(handler,Range.InsideAfter);
  enclosingMethod.addExceptionHandler(range.getStart().getNext(),protectedEnd.getPrev(),handlerStart,(ObjectType)BcelWorld.makeBcelType(catchType),getKind().hasHighPriorityExceptions());
}",0.9673024523160764
9717,"public LazyMethodGen getAjcClinit(){
  for (Iterator i=methodGens.iterator(); i.hasNext(); ) {
    LazyMethodGen gen=(LazyMethodGen)i.next();
    if (gen.getName().equals(NameMangler.AJC_CLINIT_NAME))     return gen;
  }
  throw new RuntimeException(""String_Node_Str"");
}","public LazyMethodGen getAjcClinit(){
  for (Iterator i=methodGens.iterator(); i.hasNext(); ) {
    LazyMethodGen gen=(LazyMethodGen)i.next();
    if (gen.getName().equals(NameMangler.AJC_CLINIT_NAME))     return gen;
  }
  LazyMethodGen ajcClinit=new LazyMethodGen(Modifier.STATIC,Type.VOID,NameMangler.AJC_CLINIT_NAME,new Type[0],CollectionUtil.NO_STRINGS,this);
  ajcClinit.getBody().insert(getFactory().RETURN);
  methodGens.add(ajcClinit);
  getStaticInitializer().getBody().insert(Utility.createInvoke(getFactory(),ajcClinit));
  return ajcClinit;
}",0.5696969696969697
9718,"protected boolean copyFile(File fromFile,File toFile,boolean filter){
  Copy copy=makeCopyTask(filter);
  copy.setFile(fromFile);
  copy.setTofile(toFile);
  executeTask(copy);
  return true;
}","/** 
 * Copy file, optionally filtering. (Filters set in project.)
 * @param fromFile the readable File source to copy
 * @param toFile the writable File destination file
 * @param boolean filter if true, enable filtering
 * @see org.aspectj.internal.tools.build.Builder#copyFile(File,File,boolean)
 */
protected boolean copyFile(File fromFile,File toFile,boolean filter){
  Copy copy=makeCopyTask(filter);
  copy.setFile(fromFile);
  copy.setTofile(toFile);
  executeTask(copy);
  return true;
}",0.5370101596516691
9719,"protected boolean buildInstaller(BuildSpec buildSpec,String targDirPath){
  if (buildSpec.verbose) {
    handler.log(""String_Node_Str"" + buildSpec);
  }
  AJInstaller installer=new AJInstaller();
  installer.setProject(project);
  installer.setBasedir(targDirPath);
  File installSrcDir=new File(buildSpec.productDir,""String_Node_Str"");
  Util.iaxIfNotCanReadDir(installSrcDir,""String_Node_Str"");
  installer.setHtmlSrc(installSrcDir.getPath());
  String resourcePath=getProductInstallResourcesSrc(buildSpec);
  File resourceSrcDir=new File(resourcePath);
  Util.iaxIfNotCanReadDir(resourceSrcDir,""String_Node_Str"");
  installer.setResourcesSrc(resourcePath);
  String name=getProductInstallerFileName(buildSpec);
  File outFile=new File(buildSpec.jarDir,name);
  installer.setZipfile(outFile.getPath());
  installer.setMainclass(getProductInstallerMainClass(buildSpec));
  installer.setInstallerclassjar(getBuildJar(buildSpec));
  return executeTask(installer);
}","protected boolean buildInstaller(BuildSpec buildSpec,String targDirPath){
  if (buildSpec.verbose) {
    handler.log(""String_Node_Str"" + buildSpec);
  }
  AJInstaller installer=new AJInstaller();
  setupTask(installer,""String_Node_Str"");
  installer.setBasedir(targDirPath);
  File installSrcDir=new File(buildSpec.productDir,""String_Node_Str"");
  Util.iaxIfNotCanReadDir(installSrcDir,""String_Node_Str"");
  installer.setHtmlSrc(installSrcDir.getPath());
  String resourcePath=getProductInstallResourcesSrc(buildSpec);
  File resourceSrcDir=new File(resourcePath);
  Util.iaxIfNotCanReadDir(resourceSrcDir,""String_Node_Str"");
  installer.setResourcesSrc(resourcePath);
  String name=getProductInstallerFileName(buildSpec);
  File outFile=new File(buildSpec.jarDir,name);
  installer.setZipfile(outFile.getPath());
  installer.setMainclass(getProductInstallerMainClass(buildSpec));
  installer.setInstallerclassjar(getBuildJar(buildSpec));
  return executeTask(installer);
}",0.9664429530201344
9720,"/** 
 * filter if FILTER_ON, use filters 
 */
protected Copy makeCopyTask(boolean filter){
  Copy copy=new Copy();
  copy.setProject(project);
  if (FILTER_ON == filter) {
    copy.setFiltering(true);
  }
  return copy;
}","/** 
 * @param filter if FILTER_ON, use filters 
 */
protected Copy makeCopyTask(boolean filter){
  Copy copy=new Copy();
  setupTask(copy,""String_Node_Str"");
  if (FILTER_ON == filter) {
    copy.setFiltering(true);
  }
  return copy;
}",0.8646288209606987
9721,"/** 
 * Merge classes directory and any merge jars into module jar with any specified manifest file.   META-INF directories are excluded.
 */
protected boolean assemble(Module module,File classesDir,List errors){
  if (!buildingEnabled) {
    return false;
  }
  Zip zip=new Zip();
  zip.setProject(project);
  zip.setDestFile(module.getModuleJar());
  ZipFileSet zipfileset=null;
  for (Iterator iter=module.getSrcDirs().iterator(); iter.hasNext(); ) {
    File srcDir=(File)iter.next();
    zipfileset=new ZipFileSet();
    zipfileset.setProject(project);
    zipfileset.setDir(srcDir);
    zipfileset.setIncludes(RESOURCE_PATTERN);
    zip.addZipfileset(zipfileset);
  }
  List mergeJars=module.getMerges();
  final boolean useManifest=false;
  if (0 < mergeJars.size()) {
    for (Iterator iter=mergeJars.iterator(); iter.hasNext(); ) {
      File mergeJar=(File)iter.next();
      zipfileset=new ZipFileSet();
      zipfileset.setProject(project);
      zipfileset.setSrc(mergeJar);
      zipfileset.setIncludes(""String_Node_Str"");
      zipfileset.setExcludes(""String_Node_Str"");
      zipfileset.setExcludes(""String_Node_Str"");
      zipfileset.setExcludes(""String_Node_Str"");
      zipfileset.setExcludes(""String_Node_Str"");
      zip.addZipfileset(zipfileset);
    }
  }
  File metaInfDir=new File(classesDir,""String_Node_Str"");
  Util.deleteContents(metaInfDir);
  File manifest=new File(module.moduleDir,module.name + ""String_Node_Str"");
  if (Util.canReadFile(manifest)) {
    if (Util.canReadDir(metaInfDir) || metaInfDir.mkdirs()) {
      copyFile(manifest,new File(metaInfDir,""String_Node_Str""),FILTER_ON);
    }
 else {
      errors.add(""String_Node_Str"" + metaInfDir);
      return false;
    }
  }
  zipfileset=new ZipFileSet();
  zipfileset.setProject(project);
  zipfileset.setDir(classesDir);
  zipfileset.setIncludes(""String_Node_Str"");
  zip.addZipfileset(zipfileset);
  try {
    handler.log(""String_Node_Str"" + module + ""String_Node_Str""+ module.getModuleJar());
    return executeTask(zip);
  }
 catch (  BuildException e) {
    errors.add(""String_Node_Str"" + module + ""String_Node_Str""+ e.getMessage());
    return false;
  }
 finally {
    module.clearOutOfDate();
  }
}","/** 
 * Merge classes directory and any merge jars into module jar with any specified manifest file.   META-INF directories are excluded.
 */
protected boolean assemble(Module module,File classesDir,List errors){
  if (!buildingEnabled) {
    return false;
  }
  Zip zip=new Zip();
  setupTask(zip,""String_Node_Str"");
  zip.setDestFile(module.getModuleJar());
  ZipFileSet zipfileset=null;
  for (Iterator iter=module.getSrcDirs().iterator(); iter.hasNext(); ) {
    File srcDir=(File)iter.next();
    zipfileset=new ZipFileSet();
    zipfileset.setProject(project);
    zipfileset.setDir(srcDir);
    zipfileset.setIncludes(RESOURCE_PATTERN);
    zip.addZipfileset(zipfileset);
  }
  List mergeJars=module.getMerges();
  final boolean useManifest=false;
  if (0 < mergeJars.size()) {
    for (Iterator iter=mergeJars.iterator(); iter.hasNext(); ) {
      File mergeJar=(File)iter.next();
      zipfileset=new ZipFileSet();
      zipfileset.setProject(project);
      zipfileset.setSrc(mergeJar);
      zipfileset.setIncludes(""String_Node_Str"");
      zipfileset.setExcludes(""String_Node_Str"");
      zipfileset.setExcludes(""String_Node_Str"");
      zipfileset.setExcludes(""String_Node_Str"");
      zipfileset.setExcludes(""String_Node_Str"");
      zip.addZipfileset(zipfileset);
    }
  }
  File metaInfDir=new File(classesDir,""String_Node_Str"");
  Util.deleteContents(metaInfDir);
  File manifest=new File(module.moduleDir,module.name + ""String_Node_Str"");
  if (Util.canReadFile(manifest)) {
    if (Util.canReadDir(metaInfDir) || metaInfDir.mkdirs()) {
      copyFile(manifest,new File(metaInfDir,""String_Node_Str""),FILTER_ON);
    }
 else {
      errors.add(""String_Node_Str"" + metaInfDir);
      return false;
    }
  }
  zipfileset=new ZipFileSet();
  zipfileset.setProject(project);
  zipfileset.setDir(classesDir);
  zipfileset.setIncludes(""String_Node_Str"");
  zip.addZipfileset(zipfileset);
  try {
    handler.log(""String_Node_Str"" + module + ""String_Node_Str""+ module.getModuleJar());
    return executeTask(zip);
  }
 catch (  BuildException e) {
    errors.add(""String_Node_Str"" + module + ""String_Node_Str""+ e.getMessage());
    return false;
  }
 finally {
    module.clearOutOfDate();
  }
}",0.9879682179341656
9722,"/** 
 * Generate Module.assembledJar with merge of itself and all antecedants
 */
protected boolean assembleAll(Module module,Messager handler){
  if (!buildingEnabled) {
    return false;
  }
  Util.iaxIfNull(module,""String_Node_Str"");
  Util.iaxIfNull(handler,""String_Node_Str"");
  if (module.outOfDate(false)) {
    throw new IllegalStateException(""String_Node_Str"" + module);
  }
  Zip zip=new Zip();
  zip.setProject(project);
  zip.setDestFile(module.getAssembledJar());
  ZipFileSet zipfileset=null;
  ArrayList known=module.findKnownJarAntecedants();
  for (Iterator iter=known.iterator(); iter.hasNext(); ) {
    File jarFile=(File)iter.next();
    zipfileset=new ZipFileSet();
    zipfileset.setProject(project);
    zipfileset.setSrc(jarFile);
    zipfileset.setIncludes(""String_Node_Str"");
    zipfileset.setExcludes(""String_Node_Str"");
    zipfileset.setExcludes(""String_Node_Str"");
    zipfileset.setExcludes(""String_Node_Str"");
    zipfileset.setExcludes(""String_Node_Str"");
    zip.addZipfileset(zipfileset);
  }
  zipfileset=new ZipFileSet();
  zipfileset.setProject(project);
  zipfileset.setSrc(module.getModuleJar());
  zip.addZipfileset(zipfileset);
  try {
    handler.log(""String_Node_Str"" + module + ""String_Node_Str""+ module.getAssembledJar());
    if (verbose) {
      handler.log(""String_Node_Str"" + known);
    }
    return executeTask(zip);
  }
 catch (  BuildException e) {
    handler.logException(""String_Node_Str"" + module,e);
    return false;
  }
 finally {
    module.clearOutOfDate();
  }
}","/** 
 * Generate Module.assembledJar with merge of itself and all antecedants
 */
protected boolean assembleAll(Module module,Messager handler){
  if (!buildingEnabled) {
    return false;
  }
  Util.iaxIfNull(module,""String_Node_Str"");
  Util.iaxIfNull(handler,""String_Node_Str"");
  if (module.outOfDate(false)) {
    throw new IllegalStateException(""String_Node_Str"" + module);
  }
  Zip zip=new Zip();
  setupTask(zip,""String_Node_Str"");
  zip.setDestFile(module.getAssembledJar());
  ZipFileSet zipfileset=null;
  ArrayList known=module.findKnownJarAntecedants();
  for (Iterator iter=known.iterator(); iter.hasNext(); ) {
    File jarFile=(File)iter.next();
    zipfileset=new ZipFileSet();
    zipfileset.setProject(project);
    zipfileset.setSrc(jarFile);
    zipfileset.setIncludes(""String_Node_Str"");
    zipfileset.setExcludes(""String_Node_Str"");
    zipfileset.setExcludes(""String_Node_Str"");
    zipfileset.setExcludes(""String_Node_Str"");
    zipfileset.setExcludes(""String_Node_Str"");
    zip.addZipfileset(zipfileset);
  }
  zipfileset=new ZipFileSet();
  zipfileset.setProject(project);
  zipfileset.setSrc(module.getModuleJar());
  zip.addZipfileset(zipfileset);
  try {
    handler.log(""String_Node_Str"" + module + ""String_Node_Str""+ module.getAssembledJar());
    if (verbose) {
      handler.log(""String_Node_Str"" + known);
    }
    return executeTask(zip);
  }
 catch (  BuildException e) {
    handler.logException(""String_Node_Str"" + module,e);
    return false;
  }
 finally {
    module.clearOutOfDate();
  }
}",0.9826967025791709
9723,"protected boolean compile(Module module,File classesDir,List errors){
  Javac javac=new Javac();
  javac.setProject(project);
  javac.setTaskName(""String_Node_Str"");
  Path path=new Path(project);
  for (Iterator iter=module.getSrcDirs().iterator(); iter.hasNext(); ) {
    File file=(File)iter.next();
    path.createPathElement().setLocation(file);
  }
  javac.setSrcdir(path);
  path=null;
  Path classpath=new Path(project);
  boolean hasLibraries=false;
  for (Iterator iter=module.getRequired().iterator(); iter.hasNext(); ) {
    Module required=(Module)iter.next();
    classpath.createPathElement().setLocation(required.getModuleJar());
    if (!hasLibraries) {
      hasLibraries=true;
    }
  }
  for (Iterator iter=module.getLibJars().iterator(); iter.hasNext(); ) {
    File file=(File)iter.next();
    classpath.createPathElement().setLocation(file);
    if (!hasLibraries) {
      hasLibraries=true;
    }
  }
  boolean inEclipse=true;
  if (hasLibraries && inEclipse) {
    javac.setFork(true);
  }
  classpath.createPathElement().setLocation(classesDir);
  javac.setClasspath(classpath);
  javac.setDestdir(classesDir);
  if (!classesDir.mkdirs()) {
    errors.add(""String_Node_Str"");
    return false;
  }
  try {
    return executeTask(javac);
  }
 catch (  BuildException e) {
    String args=""String_Node_Str"" + Arrays.asList(javac.getCurrentCompilerArgs());
    errors.add(""String_Node_Str"" + module.toLongString() + args+ ""String_Node_Str""+ Util.renderException(e));
    return false;
  }
 finally {
    javac.init();
  }
}","protected boolean compile(Module module,File classesDir,List errors){
  Javac javac=new Javac();
  setupTask(javac,""String_Node_Str"");
  Path path=new Path(project);
  for (Iterator iter=module.getSrcDirs().iterator(); iter.hasNext(); ) {
    File file=(File)iter.next();
    path.createPathElement().setLocation(file);
  }
  javac.setSrcdir(path);
  path=null;
  Path classpath=new Path(project);
  boolean hasLibraries=false;
  for (Iterator iter=module.getRequired().iterator(); iter.hasNext(); ) {
    Module required=(Module)iter.next();
    classpath.createPathElement().setLocation(required.getModuleJar());
    if (!hasLibraries) {
      hasLibraries=true;
    }
  }
  for (Iterator iter=module.getLibJars().iterator(); iter.hasNext(); ) {
    File file=(File)iter.next();
    classpath.createPathElement().setLocation(file);
    if (!hasLibraries) {
      hasLibraries=true;
    }
  }
  boolean inEclipse=true;
  if (hasLibraries && inEclipse) {
    javac.setFork(true);
  }
  classpath.createPathElement().setLocation(classesDir);
  javac.setClasspath(classpath);
  javac.setDestdir(classesDir);
  if (!classesDir.mkdirs()) {
    errors.add(""String_Node_Str"");
    return false;
  }
  try {
    return executeTask(javac);
  }
 catch (  BuildException e) {
    String args=""String_Node_Str"" + Arrays.asList(javac.getCurrentCompilerArgs());
    errors.add(""String_Node_Str"" + module.toLongString() + args+ ""String_Node_Str""+ Util.renderException(e));
    return false;
  }
 finally {
    javac.init();
  }
}",0.9826853969291082
9724,"/** 
 * @see org.aspectj.internal.tools.ant.taskdefs.Builder#copyFiles(File,File,String,String,boolean)
 */
protected boolean copyFiles(File fromDir,File toDir,String includes,String excludes,boolean filter){
  Copy copy=makeCopyTask(filter);
  copy.setTodir(toDir);
  FileSet fileset=new FileSet();
  fileset.setDir(fromDir);
  if (null != includes) {
    fileset.setIncludes(includes);
  }
  if (null != excludes) {
    fileset.setExcludes(excludes);
  }
  copy.addFileset(fileset);
  executeTask(copy);
  return false;
}","/** 
 * (Filters set in project.)
 * @see org.aspectj.internal.tools.ant.taskdefs.Builder#copyFiles(File,File,String,String,boolean)
 */
protected boolean copyFiles(File fromDir,File toDir,String includes,String excludes,boolean filter){
  Copy copy=makeCopyTask(filter);
  copy.setTodir(toDir);
  FileSet fileset=new FileSet();
  fileset.setDir(fromDir);
  if (null != includes) {
    fileset.setIncludes(includes);
  }
  if (null != excludes) {
    fileset.setExcludes(excludes);
  }
  copy.addFileset(fileset);
  executeTask(copy);
  return false;
}",0.9730232558139534
9725,"public void build(ClassScope classScope,CrosscuttingMembers xcut){
  EclipseWorld world=EclipseWorld.fromScopeLookupEnvironment(classScope);
  binding=classScope.referenceContext.binding.resolveTypesFor(binding);
  resolveOnType(classScope);
  if (ignoreFurtherInvestigation)   return;
  if (onTypeBinding.isInterface()) {
    ignoreFurtherInvestigation=true;
    return;
  }
  if (onTypeBinding.isNestedType()) {
    classScope.problemReporter().signalError(sourceStart,sourceEnd,""String_Node_Str"");
    ignoreFurtherInvestigation=true;
    return;
  }
  ResolvedTypeX declaringTypeX=world.fromEclipse(onTypeBinding);
  ResolvedTypeX aspectType=world.fromEclipse(classScope.referenceContext.binding);
  ResolvedMember bindingAsMember=world.makeResolvedMember(binding);
  ResolvedMember signature=new ResolvedMember(Member.CONSTRUCTOR,declaringTypeX,declaredModifiers,ResolvedTypeX.VOID,""String_Node_Str"",bindingAsMember.getParameterTypes());
  ResolvedMember syntheticInterMember=AjcMemberMaker.interConstructor(declaringTypeX,signature,aspectType);
  NewConstructorTypeMunger myMunger=new NewConstructorTypeMunger(signature,syntheticInterMember,null,null);
  this.munger=myMunger;
  this.selector=binding.selector=NameMangler.postIntroducedConstructor(EclipseWorld.fromBinding(binding.declaringClass),declaringTypeX).toCharArray();
  xcut.addTypeMunger(new EclipseTypeMunger(myMunger,aspectType,this));
}","public void build(ClassScope classScope,CrosscuttingMembers xcut){
  EclipseWorld world=EclipseWorld.fromScopeLookupEnvironment(classScope);
  binding=classScope.referenceContext.binding.resolveTypesFor(binding);
  resolveOnType(classScope);
  if (ignoreFurtherInvestigation)   return;
  if (onTypeBinding.isInterface()) {
    ignoreFurtherInvestigation=true;
    return;
  }
  if (onTypeBinding.isNestedType()) {
    classScope.problemReporter().signalError(sourceStart,sourceEnd,""String_Node_Str"");
    ignoreFurtherInvestigation=true;
    return;
  }
  ResolvedTypeX declaringTypeX=world.fromEclipse(onTypeBinding);
  ResolvedTypeX aspectType=world.fromEclipse(classScope.referenceContext.binding);
  ResolvedMember bindingAsMember=world.makeResolvedMember(binding);
  ResolvedMember signature=new ResolvedMember(Member.CONSTRUCTOR,declaringTypeX,declaredModifiers,ResolvedTypeX.VOID,""String_Node_Str"",bindingAsMember.getParameterTypes());
  ResolvedMember syntheticInterMember=AjcMemberMaker.interConstructor(declaringTypeX,signature,aspectType);
  NewConstructorTypeMunger myMunger=new NewConstructorTypeMunger(signature,syntheticInterMember,null,null);
  setMunger(myMunger);
  this.selector=binding.selector=NameMangler.postIntroducedConstructor(EclipseWorld.fromBinding(binding.declaringClass),declaringTypeX).toCharArray();
  xcut.addTypeMunger(new EclipseTypeMunger(myMunger,aspectType,this));
}",0.9861259338313768
9726,"protected int generateInfoAttributes(ClassFile classFile){
  munger.getSignature().setPosition(sourceStart,sourceEnd);
  List l;
  ;
  Shadow.Kind kind=getShadowKindForBody();
  if (kind != null) {
    l=makeEffectiveSignatureAttribute(munger.getSignature(),kind,true);
  }
 else {
    l=new ArrayList(0);
  }
  return classFile.generateMethodInfoAttribute(binding,l);
}","protected int generateInfoAttributes(ClassFile classFile){
  List l;
  ;
  Shadow.Kind kind=getShadowKindForBody();
  if (kind != null) {
    l=makeEffectiveSignatureAttribute(munger.getSignature(),kind,true);
  }
 else {
    l=new ArrayList(0);
  }
  return classFile.generateMethodInfoAttribute(binding,l);
}",0.9117647058823528
9727,"public void build(ClassScope classScope,CrosscuttingMembers xcut){
  EclipseWorld world=EclipseWorld.fromScopeLookupEnvironment(classScope);
  resolveOnType(classScope);
  binding=classScope.referenceContext.binding.resolveTypesFor(binding);
  if (ignoreFurtherInvestigation)   return;
  if (!Modifier.isStatic(declaredModifiers)) {
    super.binding.parameters=new TypeBinding[]{onTypeBinding};
    this.arguments=new Argument[]{AstUtil.makeFinalArgument(""String_Node_Str"".toCharArray(),onTypeBinding)};
  }
  ResolvedMember sig=new ResolvedMember(Member.FIELD,EclipseWorld.fromBinding(onTypeBinding),declaredModifiers,EclipseWorld.fromBinding(binding.returnType),new String(declaredSelector),TypeX.NONE);
  NewFieldTypeMunger myMunger=new NewFieldTypeMunger(sig,null);
  this.munger=myMunger;
  ResolvedTypeX aspectType=world.fromEclipse(classScope.referenceContext.binding);
  ResolvedMember me=myMunger.getInitMethod(aspectType);
  this.selector=binding.selector=me.getName().toCharArray();
  this.binding.returnType=TypeBinding.VoidBinding;
  xcut.addTypeMunger(new EclipseTypeMunger(myMunger,aspectType,this));
}","public void build(ClassScope classScope,CrosscuttingMembers xcut){
  EclipseWorld world=EclipseWorld.fromScopeLookupEnvironment(classScope);
  resolveOnType(classScope);
  binding=classScope.referenceContext.binding.resolveTypesFor(binding);
  if (ignoreFurtherInvestigation)   return;
  if (!Modifier.isStatic(declaredModifiers)) {
    super.binding.parameters=new TypeBinding[]{onTypeBinding};
    this.arguments=new Argument[]{AstUtil.makeFinalArgument(""String_Node_Str"".toCharArray(),onTypeBinding)};
  }
  ResolvedMember sig=new ResolvedMember(Member.FIELD,EclipseWorld.fromBinding(onTypeBinding),declaredModifiers,EclipseWorld.fromBinding(binding.returnType),new String(declaredSelector),TypeX.NONE);
  NewFieldTypeMunger myMunger=new NewFieldTypeMunger(sig,null);
  setMunger(myMunger);
  ResolvedTypeX aspectType=world.fromEclipse(classScope.referenceContext.binding);
  ResolvedMember me=myMunger.getInitMethod(aspectType);
  this.selector=binding.selector=me.getName().toCharArray();
  this.binding.returnType=TypeBinding.VoidBinding;
  xcut.addTypeMunger(new EclipseTypeMunger(myMunger,aspectType,this));
}",0.9825503355704698
9728,"public void build(ClassScope classScope,CrosscuttingMembers xcut){
  EclipseWorld world=EclipseWorld.fromScopeLookupEnvironment(classScope);
  resolveOnType(classScope);
  if (ignoreFurtherInvestigation)   return;
  binding=classScope.referenceContext.binding.resolveTypesFor(binding);
  ResolvedMember sig=new ResolvedMember(Member.METHOD,EclipseWorld.fromBinding(onTypeBinding),declaredModifiers,EclipseWorld.fromBinding(binding.returnType),new String(declaredSelector),EclipseWorld.fromBindings(binding.parameters));
  NewMethodTypeMunger myMunger=new NewMethodTypeMunger(sig,null);
  this.munger=myMunger;
  ResolvedTypeX aspectType=world.fromEclipse(classScope.referenceContext.binding);
  ResolvedMember me=myMunger.getDispatchMethod(aspectType);
  this.selector=binding.selector=me.getName().toCharArray();
  xcut.addTypeMunger(new EclipseTypeMunger(myMunger,aspectType,this));
}","public void build(ClassScope classScope,CrosscuttingMembers xcut){
  EclipseWorld world=EclipseWorld.fromScopeLookupEnvironment(classScope);
  resolveOnType(classScope);
  if (ignoreFurtherInvestigation)   return;
  binding=classScope.referenceContext.binding.resolveTypesFor(binding);
  ResolvedMember sig=new ResolvedMember(Member.METHOD,EclipseWorld.fromBinding(onTypeBinding),declaredModifiers,EclipseWorld.fromBinding(binding.returnType),new String(declaredSelector),EclipseWorld.fromBindings(binding.parameters));
  NewMethodTypeMunger myMunger=new NewMethodTypeMunger(sig,null);
  setMunger(myMunger);
  ResolvedTypeX aspectType=world.fromEclipse(classScope.referenceContext.binding);
  ResolvedMember me=myMunger.getDispatchMethod(aspectType);
  this.selector=binding.selector=me.getName().toCharArray();
  xcut.addTypeMunger(new EclipseTypeMunger(myMunger,aspectType,this));
}",0.9779785431959344
9729,"public void checkPointcutDeclarations(){
  ResolvedMember[] pointcuts=getDeclaredPointcuts();
  for (int i=0, len=pointcuts.length; i < len; i++) {
    if (pointcuts[i].isAbstract()) {
      if (!this.isAspect()) {
        MessageUtil.error(""String_Node_Str"" + pointcuts[i].getName(),pointcuts[i].getSourceLocation());
      }
 else       if (!this.isAbstract()) {
        MessageUtil.error(""String_Node_Str"" + pointcuts[i].getName(),pointcuts[i].getSourceLocation());
      }
    }
    for (int j=i + 1; j < len; j++) {
      if (pointcuts[i].getName().equals(pointcuts[j].getName())) {
        eclipseWorld().getMessageHandler().handleMessage(MessageUtil.error(""String_Node_Str"" + pointcuts[j].getName(),pointcuts[j].getSourceLocation()));
      }
    }
  }
}","public void checkPointcutDeclarations(){
  ResolvedMember[] pointcuts=getDeclaredPointcuts();
  for (int i=0, len=pointcuts.length; i < len; i++) {
    if (pointcuts[i].isAbstract()) {
      if (!this.isAspect()) {
        MessageUtil.error(""String_Node_Str"" + pointcuts[i].getName(),pointcuts[i].getSourceLocation());
      }
 else       if (!this.isAbstract()) {
        MessageUtil.error(""String_Node_Str"" + pointcuts[i].getName(),pointcuts[i].getSourceLocation());
      }
    }
    for (int j=i + 1; j < len; j++) {
      if (pointcuts[i].getName().equals(pointcuts[j].getName())) {
        eclipseWorld().getMessageHandler().handleMessage(MessageUtil.error(""String_Node_Str"" + pointcuts[j].getName(),pointcuts[j].getSourceLocation()));
      }
    }
  }
  if (!isAspect())   return;
}",0.9813023855577048
9730,"private int compareMemberPrecedence(ResolvedMember m1,ResolvedMember m2){
  if (!m1.getReturnType().equals(m2.getReturnType()))   return 0;
  if (Modifier.isAbstract(m1.getModifiers()))   return -1;
  if (Modifier.isAbstract(m2.getModifiers()))   return +1;
  if (m1.getDeclaringType().equals(m2.getDeclaringType()))   return 0;
  ResolvedTypeX t1=m1.getDeclaringType().resolve(world);
  ResolvedTypeX t2=m2.getDeclaringType().resolve(world);
  if (t1.isAssignableFrom(t2)) {
    checkVisibility(m1.getModifiers(),m2.getModifiers());
    return -1;
  }
  if (t2.isAssignableFrom(t1)) {
    checkVisibility(m2.getModifiers(),m1.getModifiers());
    return +1;
  }
  return 0;
}","private int compareMemberPrecedence(ResolvedMember m1,ResolvedMember m2){
  if (Modifier.isAbstract(m1.getModifiers()))   return -1;
  if (Modifier.isAbstract(m2.getModifiers()))   return +1;
  if (m1.getDeclaringType().equals(m2.getDeclaringType()))   return 0;
  ResolvedTypeX t1=m1.getDeclaringType().resolve(world);
  ResolvedTypeX t2=m2.getDeclaringType().resolve(world);
  if (t1.isAssignableFrom(t2)) {
    return -1;
  }
  if (t2.isAssignableFrom(t1)) {
    return +1;
  }
  return 0;
}",0.1658119658119658
9731,"private boolean compareToExistingMembers(ConcreteTypeMunger munger,Iterator existingMembers){
  ResolvedMember sig=munger.getSignature();
  while (existingMembers.hasNext()) {
    ResolvedMember existingMember=(ResolvedMember)existingMembers.next();
    if (conflictingSignature(existingMember,munger.getSignature())) {
      if (isVisible(existingMember.getModifiers(),this,munger.getAspectType())) {
        int c=compareMemberPrecedence(sig,existingMember);
        if (c < 0)         return false;
 else         if (c > 0) {
          continue;
        }
 else {
          if (this instanceof BcelObjectType)           return false;
          getWorld().getMessageHandler().handleMessage(MessageUtil.error(""String_Node_Str"" + munger.getAspectType() + ""String_Node_Str""+ existingMember,munger.getSourceLocation()));
        }
      }
 else {
      }
    }
  }
  return true;
}","private boolean compareToExistingMembers(ConcreteTypeMunger munger,Iterator existingMembers){
  ResolvedMember sig=munger.getSignature();
  while (existingMembers.hasNext()) {
    ResolvedMember existingMember=(ResolvedMember)existingMembers.next();
    if (conflictingSignature(existingMember,munger.getSignature())) {
      if (isVisible(existingMember.getModifiers(),this,munger.getAspectType())) {
        int c=compareMemberPrecedence(sig,existingMember);
        if (c < 0) {
          checkLegalOverride(existingMember,munger.getSignature());
          return false;
        }
 else         if (c > 0) {
          checkLegalOverride(munger.getSignature(),existingMember);
          continue;
        }
 else {
          if (this instanceof BcelObjectType)           return false;
          getWorld().getMessageHandler().handleMessage(MessageUtil.error(""String_Node_Str"" + munger.getAspectType() + ""String_Node_Str""+ existingMember,munger.getSourceLocation()));
        }
      }
 else {
      }
    }
  }
  return true;
}",0.9213836477987422
9732,"public void addInterTypeMunger(ConcreteTypeMunger munger){
  ResolvedMember sig=munger.getSignature();
  if (sig == null) {
    interTypeMungers.add(munger);
    return;
  }
  if (sig.getKind() == Member.METHOD) {
    if (!compareToExistingMembers(munger,getMethods()))     return;
    if (this.isInterface()) {
      if (!compareToExistingMembers(munger,Arrays.asList(world.resolve(OBJECT).getDeclaredMethods()).iterator()))       return;
    }
  }
 else   if (sig.getKind() == Member.FIELD) {
    if (!compareToExistingMembers(munger,Arrays.asList(getDeclaredFields()).iterator()))     return;
  }
 else {
    if (!compareToExistingMembers(munger,Arrays.asList(getDeclaredMethods()).iterator()))     return;
  }
  for (Iterator i=interTypeMungers.iterator(); i.hasNext(); ) {
    ConcreteTypeMunger existingMunger=(ConcreteTypeMunger)i.next();
    if (conflictingSignature(existingMunger.getSignature(),munger.getSignature())) {
      if (isVisible(munger.getSignature().getModifiers(),munger.getAspectType(),existingMunger.getAspectType())) {
        int c=compareMemberPrecedence(sig,existingMunger.getSignature());
        if (c == 0) {
          c=getWorld().comparePrecedence(munger.getAspectType(),existingMunger.getAspectType());
        }
        if (c < 0) {
          return;
        }
 else         if (c > 0) {
          i.remove();
          break;
        }
 else {
          interTypeConflictError(munger,existingMunger);
          interTypeConflictError(existingMunger,munger);
          return;
        }
      }
    }
  }
  interTypeMungers.add(munger);
}","public void addInterTypeMunger(ConcreteTypeMunger munger){
  ResolvedMember sig=munger.getSignature();
  if (sig == null) {
    interTypeMungers.add(munger);
    return;
  }
  if (sig.getKind() == Member.METHOD) {
    if (!compareToExistingMembers(munger,getMethods()))     return;
    if (this.isInterface()) {
      if (!compareToExistingMembers(munger,Arrays.asList(world.resolve(OBJECT).getDeclaredMethods()).iterator()))       return;
    }
  }
 else   if (sig.getKind() == Member.FIELD) {
    if (!compareToExistingMembers(munger,Arrays.asList(getDeclaredFields()).iterator()))     return;
  }
 else {
    if (!compareToExistingMembers(munger,Arrays.asList(getDeclaredMethods()).iterator()))     return;
  }
  for (Iterator i=interTypeMungers.iterator(); i.hasNext(); ) {
    ConcreteTypeMunger existingMunger=(ConcreteTypeMunger)i.next();
    if (conflictingSignature(existingMunger.getSignature(),munger.getSignature())) {
      if (isVisible(munger.getSignature().getModifiers(),munger.getAspectType(),existingMunger.getAspectType())) {
        int c=compareMemberPrecedence(sig,existingMunger.getSignature());
        if (c == 0) {
          c=getWorld().comparePrecedence(munger.getAspectType(),existingMunger.getAspectType());
        }
        if (c < 0) {
          checkLegalOverride(existingMunger.getSignature(),munger.getSignature());
          return;
        }
 else         if (c > 0) {
          checkLegalOverride(munger.getSignature(),existingMunger.getSignature());
          i.remove();
          break;
        }
 else {
          interTypeConflictError(munger,existingMunger);
          interTypeConflictError(existingMunger,munger);
          return;
        }
      }
    }
  }
  interTypeMungers.add(munger);
}",0.9463208685162848
9733,"/** 
 * returns an iterator through all of the pointcuts of this type, in order for checking from JVM spec 2ed 5.4.3.2 (as for fields).  This means that the order is <ul><li> pointcuts from current class </li> <li> recur into direct superinterfaces </li> <li> recur into superclass </li> </ul> We keep a hashSet of interfaces that we've visited so we don't spiral out into 2^n land.
 */
private Iterator getPointcuts(){
  final Iterators.Filter dupFilter=Iterators.dupFilter();
  Iterators.Getter typeGetter=new Iterators.Getter(){
    public Iterator get(    Object o){
      return dupFilter.filter(((ResolvedTypeX)o).getDirectSupertypes());
    }
  }
;
  Iterators.Getter pointcutGetter=new Iterators.Getter(){
    public Iterator get(    Object o){
      return Iterators.array(((ResolvedTypeX)o).getDeclaredPointcuts());
    }
  }
;
  return Iterators.mapOver(Iterators.recur(this,typeGetter),pointcutGetter);
}","/** 
 * returns an iterator through all of the pointcuts of this type, in order for checking from JVM spec 2ed 5.4.3.2 (as for fields).  This means that the order is <ul><li> pointcuts from current class </li> <li> recur into direct superinterfaces </li> <li> recur into superclass </li> </ul> We keep a hashSet of interfaces that we've visited so we don't spiral out into 2^n land.
 */
public Iterator getPointcuts(){
  final Iterators.Filter dupFilter=Iterators.dupFilter();
  Iterators.Getter typeGetter=new Iterators.Getter(){
    public Iterator get(    Object o){
      return dupFilter.filter(((ResolvedTypeX)o).getDirectSupertypes());
    }
  }
;
  Iterators.Getter pointcutGetter=new Iterators.Getter(){
    public Iterator get(    Object o){
      return Iterators.array(((ResolvedTypeX)o).getDeclaredPointcuts());
    }
  }
;
  return Iterators.mapOver(Iterators.recur(this,typeGetter),pointcutGetter);
}",0.99399235390497
9734,"private AjAttribute makeAttribute(EclipseWorld world){
  if (explicitConstructorCall != null) {
    MethodBinding explicitConstructor=explicitConstructorCall.binding;
    if (explicitConstructor.alwaysNeedsAccessMethod()) {
      explicitConstructor=explicitConstructor.getAccessMethod();
    }
    ((NewConstructorTypeMunger)munger).setExplicitConstructor(world.makeResolvedMember(explicitConstructor));
  }
 else {
    ((NewConstructorTypeMunger)munger).setExplicitConstructor(new ResolvedMember(Member.CONSTRUCTOR,EclipseWorld.fromBinding(onTypeBinding.superclass()),0,ResolvedTypeX.VOID,""String_Node_Str"",TypeX.NONE));
  }
  return new AjAttribute.TypeMunger(munger);
}","private AjAttribute makeAttribute(EclipseWorld world){
  if (explicitConstructorCall != null && !(explicitConstructorCall.binding instanceof ProblemMethodBinding)) {
    MethodBinding explicitConstructor=explicitConstructorCall.binding;
    if (explicitConstructor.alwaysNeedsAccessMethod()) {
      explicitConstructor=explicitConstructor.getAccessMethod();
    }
    ((NewConstructorTypeMunger)munger).setExplicitConstructor(world.makeResolvedMember(explicitConstructor));
  }
 else {
    ((NewConstructorTypeMunger)munger).setExplicitConstructor(new ResolvedMember(Member.CONSTRUCTOR,EclipseWorld.fromBinding(onTypeBinding.superclass()),0,ResolvedTypeX.VOID,""String_Node_Str"",TypeX.NONE));
  }
  return new AjAttribute.TypeMunger(munger);
}",0.9505649717514124
9735,"public void generateCode(ClassScope classScope,ClassFile classFile){
  if (ignoreFurtherInvestigation) {
    System.err.println(""String_Node_Str"" + this);
    return;
  }
  classFile.extraAttributes.add(new EclipseAttributeAdapter(makeAttribute()));
  if (!Modifier.isAbstract(declaredModifiers)) {
    super.generateCode(classScope,classFile);
  }
  generateDispatchMethod(classScope,classFile);
}","public void generateCode(ClassScope classScope,ClassFile classFile){
  if (ignoreFurtherInvestigation) {
    return;
  }
  classFile.extraAttributes.add(new EclipseAttributeAdapter(makeAttribute()));
  if (!Modifier.isAbstract(declaredModifiers)) {
    super.generateCode(classScope,classFile);
  }
  generateDispatchMethod(classScope,classFile);
}",0.9329758713136728
9736,"public void endVisit(MessageSend call,BlockScope scope){
  if (call.codegenBinding == null)   return;
  MethodBinding superBinding=call.codegenBinding;
  char[] accessName;
  boolean isSuper;
  if (call.isSuperAccess() && !call.binding.isStatic()) {
    call.receiver=new ThisReference();
    accessName=NameMangler.superDispatchMethod(EclipseWorld.fromBinding(targetClass),new String(superBinding.selector)).toCharArray();
  }
 else   if (call.receiver.isThis() && call.binding.isProtected() && !call.binding.isStatic()) {
    if (superBinding.declaringClass.equals(targetClass)) {
      accessName=NameMangler.protectedDispatchMethod(EclipseWorld.fromBinding(targetClass),new String(superBinding.selector)).toCharArray();
    }
 else {
      accessName=NameMangler.superDispatchMethod(EclipseWorld.fromBinding(targetClass),new String(superBinding.selector)).toCharArray();
    }
  }
 else {
    return;
  }
  MethodBinding superAccessBinding=new MethodBinding(AstNode.AccPublic,accessName,superBinding.returnType,superBinding.parameters,superBinding.thrownExceptions,targetClass);
  call.codegenBinding=superAccessBinding;
  ResolvedMember targetMember=EclipseWorld.makeResolvedMember(superBinding);
  superMethodsCalled.add(targetMember);
}","public void endVisit(MessageSend call,BlockScope scope){
  if (call.codegenBinding == null)   return;
  MethodBinding superBinding=call.codegenBinding;
  if (superBinding instanceof ProblemMethodBinding) {
    return;
  }
  char[] accessName;
  boolean isSuper;
  if (call.isSuperAccess() && !call.binding.isStatic()) {
    call.receiver=new ThisReference();
    accessName=NameMangler.superDispatchMethod(EclipseWorld.fromBinding(targetClass),new String(superBinding.selector)).toCharArray();
  }
 else   if (call.receiver.isThis() && call.binding.isProtected() && !call.binding.isStatic()) {
    if (superBinding.declaringClass.equals(targetClass)) {
      accessName=NameMangler.protectedDispatchMethod(EclipseWorld.fromBinding(targetClass),new String(superBinding.selector)).toCharArray();
    }
 else {
      accessName=NameMangler.superDispatchMethod(EclipseWorld.fromBinding(targetClass),new String(superBinding.selector)).toCharArray();
    }
  }
 else {
    return;
  }
  MethodBinding superAccessBinding=new MethodBinding(AstNode.AccPublic,accessName,superBinding.returnType,superBinding.parameters,superBinding.thrownExceptions,targetClass);
  call.codegenBinding=superAccessBinding;
  ResolvedMember targetMember=EclipseWorld.makeResolvedMember(superBinding);
  superMethodsCalled.add(targetMember);
}",0.9726134585289516
9737,"public PrivilegedFieldBinding(AspectDeclaration inAspect,FieldBinding baseField){
  super(baseField,baseField.declaringClass);
  this.reader=new SimpleSyntheticAccessMethodBinding(inAspect.world.makeMethodBinding(AjcMemberMaker.privilegedAccessMethodForFieldGet(inAspect.typeX,inAspect.world.makeResolvedMember(baseField))));
  this.writer=new SimpleSyntheticAccessMethodBinding(inAspect.world.makeMethodBinding(AjcMemberMaker.privilegedAccessMethodForFieldSet(inAspect.typeX,inAspect.world.makeResolvedMember(baseField))));
}","public PrivilegedFieldBinding(AspectDeclaration inAspect,FieldBinding baseField){
  super(baseField,baseField.declaringClass);
  this.reader=new SimpleSyntheticAccessMethodBinding(inAspect.world.makeMethodBinding(AjcMemberMaker.privilegedAccessMethodForFieldGet(inAspect.typeX,inAspect.world.makeResolvedMember(baseField))));
  this.writer=new SimpleSyntheticAccessMethodBinding(inAspect.world.makeMethodBinding(AjcMemberMaker.privilegedAccessMethodForFieldSet(inAspect.typeX,inAspect.world.makeResolvedMember(baseField))));
  this.constant=AstNode.NotAConstant;
  this.baseField=baseField;
}",0.9409660107334524
9738,"public MethodBinding getPrivilegedAccessMethod(MethodBinding baseMethod){
  ResolvedMember key=inAspect.world.makeResolvedMember(baseMethod);
  if (accessors.containsKey(key))   return (MethodBinding)accessors.get(key);
  MethodBinding ret=inAspect.world.makeMethodBinding(AjcMemberMaker.privilegedAccessMethodForMethod(inAspect.typeX,key));
  accessors.put(key,ret);
  return ret;
}","public MethodBinding getPrivilegedAccessMethod(MethodBinding baseMethod){
  ResolvedMember key=inAspect.world.makeResolvedMember(baseMethod);
  if (accessors.containsKey(key))   return (MethodBinding)accessors.get(key);
  MethodBinding ret;
  if (baseMethod.isConstructor()) {
    ret=baseMethod;
  }
 else {
    ret=inAspect.world.makeMethodBinding(AjcMemberMaker.privilegedAccessMethodForMethod(inAspect.typeX,key));
  }
  accessors.put(key,ret);
  return ret;
}",0.9043683589138136
9739,"public void addDeclare(Declare declare){
  if (declare instanceof DeclareErrorOrWarning) {
    ShadowMunger m=new Checker((DeclareErrorOrWarning)declare);
    addShadowMunger(m);
  }
 else   if (declare instanceof DeclareDominates) {
    declareDominates.add(declare);
  }
 else   if (declare instanceof DeclareParents) {
    declareParents.add(declare);
  }
 else   if (declare instanceof DeclareSoft) {
    DeclareSoft d=(DeclareSoft)declare;
    Pointcut concretePointcut=d.getPointcut().concretize(inAspect,0);
    declareSofts.add(new DeclareSoft(d.getException(),concretePointcut));
    ShadowMunger m=Advice.makeSoftener(world,concretePointcut,d.getException());
    addConcreteShadowMunger(m);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}","public void addDeclare(Declare declare){
  if (declare instanceof DeclareErrorOrWarning) {
    ShadowMunger m=new Checker((DeclareErrorOrWarning)declare);
    addShadowMunger(m);
  }
 else   if (declare instanceof DeclareDominates) {
    declareDominates.add(declare);
  }
 else   if (declare instanceof DeclareParents) {
    DeclareParents dp=(DeclareParents)declare;
    for (Iterator i=dp.getParents().collectAccessTypeMungers(world).iterator(); i.hasNext(); ) {
      addTypeMunger(world.concreteTypeMunger((PrivilegedAccessMunger)i.next(),inAspect));
    }
    declareParents.add(dp);
  }
 else   if (declare instanceof DeclareSoft) {
    DeclareSoft d=(DeclareSoft)declare;
    Pointcut concretePointcut=d.getPointcut().concretize(inAspect,0);
    declareSofts.add(new DeclareSoft(d.getException(),concretePointcut));
    ShadowMunger m=Advice.makeSoftener(world,concretePointcut,d.getException());
    addConcreteShadowMunger(m);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.8529577464788732
9740,"private boolean mungePrivilegedAccess(BcelClassWeaver weaver,PrivilegedAccessMunger munger){
  LazyClassGen gen=weaver.getLazyClassGen();
  ResolvedMember member=munger.getMember();
  ResolvedTypeX onType=weaver.getWorld().resolve(member.getDeclaringType());
  if (onType.equals(gen.getType())) {
    if (member.getKind() == Member.FIELD) {
      addFieldGetter(gen,member,AjcMemberMaker.privilegedAccessMethodForFieldGet(aspectType,member));
      addFieldSetter(gen,member,AjcMemberMaker.privilegedAccessMethodForFieldSet(aspectType,member));
      return true;
    }
 else     if (member.getKind() == Member.METHOD) {
      addMethodDispatch(gen,member,AjcMemberMaker.privilegedAccessMethodForMethod(aspectType,member));
      return true;
    }
 else     if (member.getKind() == Member.STATIC_INITIALIZATION) {
      gen.forcePublic();
      return true;
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
  return false;
}","private boolean mungePrivilegedAccess(BcelClassWeaver weaver,PrivilegedAccessMunger munger){
  LazyClassGen gen=weaver.getLazyClassGen();
  ResolvedMember member=munger.getMember();
  ResolvedTypeX onType=weaver.getWorld().resolve(member.getDeclaringType());
  if (onType.equals(gen.getType())) {
    if (member.getKind() == Member.FIELD) {
      addFieldGetter(gen,member,AjcMemberMaker.privilegedAccessMethodForFieldGet(aspectType,member));
      addFieldSetter(gen,member,AjcMemberMaker.privilegedAccessMethodForFieldSet(aspectType,member));
      return true;
    }
 else     if (member.getKind() == Member.METHOD) {
      addMethodDispatch(gen,member,AjcMemberMaker.privilegedAccessMethodForMethod(aspectType,member));
      return true;
    }
 else     if (member.getKind() == Member.CONSTRUCTOR) {
      for (Iterator i=gen.getMethodGens().iterator(); i.hasNext(); ) {
        LazyMethodGen m=(LazyMethodGen)i.next();
        if (m.getMemberView() != null && m.getMemberView().getKind() == Member.CONSTRUCTOR) {
          m.forcePublic();
        }
      }
      return true;
    }
 else     if (member.getKind() == Member.STATIC_INITIALIZATION) {
      gen.forcePublic();
      return true;
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
  return false;
}",0.8486197684772929
9741,"public Pointcut concretize1(ResolvedTypeX inAspect,IntMap bindings){
  IfPointcut ret=new IfPointcut(testMethod,extraParameterFlags);
  if (this.state == CONCRETE)   return ret;
  this.state=CONCRETE;
  if (bindings.directlyInAdvice()) {
    Advice advice=bindings.getEnclosingAdvice();
    ret.baseArgsCount=advice.getBaseParameterCount();
    ret.residueSource=advice.getPointcut().concretize(inAspect,ret.baseArgsCount,advice);
  }
 else {
    ResolvedPointcutDefinition def=bindings.peekEnclosingDefinitition();
    if (def == CflowPointcut.CFLOW_MARKER) {
      inAspect.getWorld().getMessageHandler().handleMessage(MessageUtil.error(""String_Node_Str"",null));
      return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
    }
    ret.baseArgsCount=def.getParameterTypes().length;
    IntMap newBindings=IntMap.idMap(ret.baseArgsCount);
    newBindings.copyContext(bindings);
    ret.residueSource=def.getPointcut().concretize(inAspect,newBindings);
  }
  return ret;
}","public Pointcut concretize1(ResolvedTypeX inAspect,IntMap bindings){
  if (partiallyConcretized != null) {
    return partiallyConcretized;
  }
  IfPointcut ret=new IfPointcut(testMethod,extraParameterFlags);
  partiallyConcretized=ret;
  if (bindings.directlyInAdvice()) {
    Advice advice=bindings.getEnclosingAdvice();
    ret.baseArgsCount=advice.getBaseParameterCount();
    ret.residueSource=advice.getPointcut().concretize(inAspect,ret.baseArgsCount,advice);
  }
 else {
    ResolvedPointcutDefinition def=bindings.peekEnclosingDefinitition();
    if (def == CflowPointcut.CFLOW_MARKER) {
      inAspect.getWorld().getMessageHandler().handleMessage(MessageUtil.error(""String_Node_Str"",null));
      return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
    }
    ret.baseArgsCount=def.getParameterTypes().length;
    IntMap newBindings=IntMap.idMap(ret.baseArgsCount);
    newBindings.copyContext(bindings);
    ret.residueSource=def.getPointcut().concretize(inAspect,newBindings);
  }
  return ret;
}",0.9183467741935484
9742,"public Test findResidue(Shadow shadow,ExposedState state){
  if (residueSource == null)   return Literal.TRUE;
  ExposedState myState=new ExposedState(baseArgsCount);
  residueSource.findResidue(shadow,myState);
  List args=new ArrayList();
  for (int i=0; i < baseArgsCount; i++) {
    args.add(myState.get(i));
  }
  if ((extraParameterFlags & Advice.ThisJoinPoint) != 0) {
    args.add(shadow.getThisJoinPointVar());
  }
  if ((extraParameterFlags & Advice.ThisJoinPointStaticPart) != 0) {
    args.add(shadow.getThisJoinPointStaticPartVar());
  }
  if ((extraParameterFlags & Advice.ThisEnclosingJoinPointStaticPart) != 0) {
    args.add(shadow.getThisEnclosingJoinPointStaticPartVar());
  }
  return Test.makeCall(testMethod,(Expr[])args.toArray(new Expr[args.size()]));
}","public Test findResidue(Shadow shadow,ExposedState state){
  if (findingResidue)   return Literal.TRUE;
  findingResidue=true;
  try {
    ExposedState myState=new ExposedState(baseArgsCount);
    residueSource.findResidue(shadow,myState);
    List args=new ArrayList();
    for (int i=0; i < baseArgsCount; i++) {
      args.add(myState.get(i));
    }
    if ((extraParameterFlags & Advice.ThisJoinPoint) != 0) {
      args.add(shadow.getThisJoinPointVar());
    }
    if ((extraParameterFlags & Advice.ThisJoinPointStaticPart) != 0) {
      args.add(shadow.getThisJoinPointStaticPartVar());
    }
    if ((extraParameterFlags & Advice.ThisEnclosingJoinPointStaticPart) != 0) {
      args.add(shadow.getThisEnclosingJoinPointStaticPartVar());
    }
    return Test.makeCall(testMethod,(Expr[])args.toArray(new Expr[args.size()]));
  }
  finally {
    findingResidue=false;
  }
}",0.9130434782608696
9743,"/** 
 * The new method always static. It may take some extra arguments:  this, target. If it's argsOnStack, then it must take both this/target If it's argsOnFrame, it shares this and target. ??? rewrite this to do less array munging, please
 */
private LazyMethodGen createMethodGen(String newMethodName){
  Type[] parameterTypes=world.makeBcelTypes(getSignature().getParameterTypes());
  int modifiers=Modifier.FINAL;
  modifiers|=Modifier.STATIC;
  if (targetVar != null && targetVar != thisVar) {
    TypeX targetType=getTargetType();
    ResolvedMember resolvedMember=getSignature().resolve(world);
    if (resolvedMember != null && Modifier.isProtected(resolvedMember.getModifiers()) && !samePackage(targetType.getPackageName(),getThisType().getPackageName())) {
      if (!targetType.isAssignableFrom(getThisType(),world)) {
        throw new BCException(""String_Node_Str"");
      }
      targetType=getThisType();
    }
    parameterTypes=addType(world.makeBcelType(targetType),parameterTypes);
  }
  if (thisVar != null) {
    TypeX thisType=getThisType();
    parameterTypes=addType(world.makeBcelType(thisType),parameterTypes);
  }
  if (thisJoinPointVar != null) {
    parameterTypes=addTypeToEnd(LazyClassGen.tjpType,parameterTypes);
  }
  TypeX returnType;
  if (getKind() == ConstructorCall) {
    returnType=getSignature().getDeclaringType();
  }
 else   if (getKind() == PreInitialization) {
    returnType=TypeX.OBJECTARRAY;
  }
 else {
    returnType=getSignature().getReturnType();
  }
  return new LazyMethodGen(modifiers,world.makeBcelType(returnType),newMethodName,parameterTypes,new String[0],getEnclosingClass());
}","/** 
 * The new method always static. It may take some extra arguments:  this, target. If it's argsOnStack, then it must take both this/target If it's argsOnFrame, it shares this and target. ??? rewrite this to do less array munging, please
 */
private LazyMethodGen createMethodGen(String newMethodName){
  Type[] parameterTypes=world.makeBcelTypes(getArgTypes());
  int modifiers=Modifier.FINAL;
  modifiers|=Modifier.STATIC;
  if (targetVar != null && targetVar != thisVar) {
    TypeX targetType=getTargetType();
    ResolvedMember resolvedMember=getSignature().resolve(world);
    if (resolvedMember != null && Modifier.isProtected(resolvedMember.getModifiers()) && !samePackage(targetType.getPackageName(),getThisType().getPackageName())) {
      if (!targetType.isAssignableFrom(getThisType(),world)) {
        throw new BCException(""String_Node_Str"");
      }
      targetType=getThisType();
    }
    parameterTypes=addType(world.makeBcelType(targetType),parameterTypes);
  }
  if (thisVar != null) {
    TypeX thisType=getThisType();
    parameterTypes=addType(world.makeBcelType(thisType),parameterTypes);
  }
  if (thisJoinPointVar != null) {
    parameterTypes=addTypeToEnd(LazyClassGen.tjpType,parameterTypes);
  }
  TypeX returnType;
  if (getKind() == ConstructorCall) {
    returnType=getSignature().getDeclaringType();
  }
 else   if (getKind() == PreInitialization) {
    returnType=TypeX.OBJECTARRAY;
  }
 else {
    returnType=getSignature().getReturnType();
  }
  return new LazyMethodGen(modifiers,world.makeBcelType(returnType),newMethodName,parameterTypes,new String[0],getEnclosingClass());
}",0.9917101627264354
9744,"private void deleteNewAndDup(){
  final ConstantPoolGen cpg=getEnclosingClass().getConstantPoolGen();
  int depth=1;
  InstructionHandle ih=range.getStart();
  while (true) {
    Instruction inst=ih.getInstruction();
    if (inst instanceof INVOKESPECIAL && ((INVOKESPECIAL)inst).getName(cpg).equals(""String_Node_Str"")) {
      depth++;
    }
 else     if (inst instanceof NEW) {
      depth--;
      if (depth == 0)       break;
    }
    ih=ih.getPrev();
  }
  InstructionHandle newHandle=ih;
  InstructionHandle endHandle=newHandle.getNext();
  InstructionHandle nextHandle;
  if (endHandle.getInstruction() instanceof DUP) {
    nextHandle=endHandle.getNext();
    retargetFrom(newHandle,nextHandle);
    retargetFrom(endHandle,nextHandle);
  }
 else   if (endHandle.getInstruction() instanceof DUP_X1) {
    InstructionHandle dupHandle=endHandle;
    endHandle=endHandle.getNext();
    nextHandle=endHandle.getNext();
    if (endHandle.getInstruction() instanceof SWAP) {
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + endHandle);
    }
    retargetFrom(newHandle,nextHandle);
    retargetFrom(dupHandle,nextHandle);
    retargetFrom(endHandle,nextHandle);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  try {
    range.getBody().delete(newHandle,endHandle);
  }
 catch (  TargetLostException e) {
    throw new BCException(""String_Node_Str"");
  }
}","private void deleteNewAndDup(){
  final ConstantPoolGen cpg=getEnclosingClass().getConstantPoolGen();
  int depth=1;
  InstructionHandle ih=range.getStart();
  while (true) {
    Instruction inst=ih.getInstruction();
    if (inst instanceof INVOKESPECIAL && ((INVOKESPECIAL)inst).getName(cpg).equals(""String_Node_Str"")) {
      depth++;
    }
 else     if (inst instanceof NEW) {
      depth--;
      if (depth == 0)       break;
    }
    ih=ih.getPrev();
  }
  InstructionHandle newHandle=ih;
  InstructionHandle endHandle=newHandle.getNext();
  InstructionHandle nextHandle;
  if (endHandle.getInstruction() instanceof DUP) {
    nextHandle=endHandle.getNext();
    retargetFrom(newHandle,nextHandle);
    retargetFrom(endHandle,nextHandle);
  }
 else   if (endHandle.getInstruction() instanceof DUP_X1) {
    InstructionHandle dupHandle=endHandle;
    endHandle=endHandle.getNext();
    nextHandle=endHandle.getNext();
    if (endHandle.getInstruction() instanceof SWAP) {
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + endHandle);
    }
    retargetFrom(newHandle,nextHandle);
    retargetFrom(dupHandle,nextHandle);
    retargetFrom(endHandle,nextHandle);
  }
 else {
    endHandle=newHandle;
    nextHandle=endHandle.getNext();
    retargetFrom(newHandle,nextHandle);
    getRange().insert(getFactory().POP,Range.OutsideAfter);
  }
  try {
    range.getBody().delete(newHandle,endHandle);
  }
 catch (  TargetLostException e) {
    throw new BCException(""String_Node_Str"");
  }
}",0.9352170916609236
9745,"public void resolve(){
  if (binding == null || ignoreFurtherInvestigation) {
    ignoreFurtherInvestigation=true;
    return;
  }
  if (typeX != null)   typeX.checkPointcutDeclarations();
  super.resolve();
}","public void resolve(){
  if (binding == null) {
    ignoreFurtherInvestigation=true;
    return;
  }
  if (typeX != null)   typeX.checkPointcutDeclarations();
  super.resolve();
}",0.922680412371134
9746,"public static void testOne() throws IOException {
  List args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
  CommandTestCase.printGenerated(""String_Node_Str"",""String_Node_Str"");
  CommandTestCase.printGenerated(""String_Node_Str"",""String_Node_Str"");
  TestUtil.runMain(""String_Node_Str"",""String_Node_Str"");
}","public static void testOne() throws IOException {
  List args=new ArrayList();
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  args.add(""String_Node_Str"");
  CommandTestCase.runCompiler(args,CommandTestCase.NO_ERRORS);
}",0.7677946324387398
9747,"protected int getModifiers(Member member){
  return resolve(member).getModifiers();
}","protected int getModifiers(Member member){
  ResolvedMember r=resolve(member);
  if (r == null)   throw new BCException(""String_Node_Str"" + member);
  return r.getModifiers();
}",0.6106870229007634
9748,"public boolean munge(BcelClassWeaver weaver){
  LazyClassGen gen=weaver.getLazyClassGen();
  if (!gen.getType().equals(cflowStackField.getDeclaringType()))   return false;
  Field f=new FieldGen(cflowStackField.getModifiers(),BcelWorld.makeBcelType(cflowStackField.getReturnType()),cflowStackField.getName(),gen.getConstantPoolGen()).getField();
  gen.addField(f);
  LazyMethodGen clinit=gen.getStaticInitializer();
  InstructionList setup=new InstructionList();
  InstructionFactory fact=gen.getFactory();
  setup.append(fact.createNew(new ObjectType(NameMangler.CFLOW_STACK_TYPE)));
  setup.append(fact.createDup(1));
  setup.append(fact.createInvoke(NameMangler.CFLOW_STACK_TYPE,""String_Node_Str"",Type.VOID,new Type[0],Constants.INVOKESPECIAL));
  setup.append(Utility.createSet(fact,cflowStackField));
  clinit.getBody().insert(setup);
  return true;
}","public boolean munge(BcelClassWeaver weaver){
  LazyClassGen gen=weaver.getLazyClassGen();
  if (!gen.getType().equals(cflowStackField.getDeclaringType()))   return false;
  Field f=new FieldGen(cflowStackField.getModifiers(),BcelWorld.makeBcelType(cflowStackField.getReturnType()),cflowStackField.getName(),gen.getConstantPoolGen()).getField();
  gen.addField(f);
  LazyMethodGen clinit=gen.getAjcClinit();
  InstructionList setup=new InstructionList();
  InstructionFactory fact=gen.getFactory();
  setup.append(fact.createNew(new ObjectType(NameMangler.CFLOW_STACK_TYPE)));
  setup.append(fact.createDup(1));
  setup.append(fact.createInvoke(NameMangler.CFLOW_STACK_TYPE,""String_Node_Str"",Type.VOID,new Type[0],Constants.INVOKESPECIAL));
  setup.append(Utility.createSet(fact,cflowStackField));
  clinit.getBody().insert(setup);
  return true;
}",0.9847417840375586
9749,"private void initializeThisVar(){
  if (thisVar != null)   return;
  thisVar=new BcelVar(getThisType().resolve(world),0);
}","private void initializeThisVar(){
  if (thisVar != null)   return;
  thisVar=new BcelVar(getThisType().resolve(world),0);
  thisVar.setPositionInAroundState(0);
}",0.8631578947368421
9750,"InstructionList makeCallToCallback(LazyMethodGen callbackMethod){
  InstructionFactory fact=getFactory();
  InstructionList callback=new InstructionList();
  if (targetVar != null) {
    callback.append(BcelRenderer.renderExpr(fact,world,targetVar));
  }
  callback.append(BcelRenderer.renderExprs(fact,world,argVars));
  callback.append(Utility.createInvoke(fact,callbackMethod));
  return callback;
}","InstructionList makeCallToCallback(LazyMethodGen callbackMethod){
  InstructionFactory fact=getFactory();
  InstructionList callback=new InstructionList();
  if (thisVar != null) {
    callback.append(fact.ALOAD_0);
  }
  if (targetVar != null && targetVar != thisVar) {
    callback.append(BcelRenderer.renderExpr(fact,world,targetVar));
  }
  callback.append(BcelRenderer.renderExprs(fact,world,argVars));
  if (thisJoinPointVar != null) {
    callback.append(BcelRenderer.renderExpr(fact,world,thisJoinPointVar));
  }
  callback.append(Utility.createInvoke(fact,callbackMethod));
  return callback;
}",0.7900497512437811
9751,"/** 
 * The new method is nonStatic iff we're from nonExpression advice with an enclosing non-static method. Otherwise, it's static
 */
private LazyMethodGen createMethodGen(String newMethodName){
  Type[] parameterTypes=world.makeBcelTypes(getSignature().getParameterTypes());
  int modifiers=Modifier.FINAL;
  modifiers|=Modifier.STATIC;
  if (hasTarget()) {
    TypeX targetType=getTargetType();
    parameterTypes=addType(world.makeBcelType(targetType),parameterTypes);
  }
  if (thisJoinPointVar != null) {
    parameterTypes=addTypeToEnd(LazyClassGen.tjpType,parameterTypes);
  }
  TypeX returnType;
  if (getKind() == ConstructorCall) {
    returnType=getSignature().getDeclaringType();
  }
 else   if (getKind() == PreInitialization) {
    returnType=TypeX.OBJECTARRAY;
  }
 else {
    returnType=getSignature().getReturnType();
  }
  return new LazyMethodGen(modifiers,world.makeBcelType(returnType),newMethodName,parameterTypes,new String[0],getEnclosingClass());
}","/** 
 * The new method always static. It may take some extra arguments:  this, target. If it's argsOnStack, then it must take both this/target If it's argsOnFrame, it shares this and target. ??? rewrite this to do less array munging, please
 */
private LazyMethodGen createMethodGen(String newMethodName){
  Type[] parameterTypes=world.makeBcelTypes(getSignature().getParameterTypes());
  int modifiers=Modifier.FINAL;
  modifiers|=Modifier.STATIC;
  if (targetVar != null && targetVar != thisVar) {
    TypeX targetType=getTargetType();
    ResolvedMember resolvedMember=getSignature().resolve(world);
    if (resolvedMember != null && Modifier.isProtected(resolvedMember.getModifiers()) && !samePackage(targetType.getPackageName(),getThisType().getPackageName())) {
      if (!targetType.isAssignableFrom(getThisType(),world)) {
        throw new BCException(""String_Node_Str"");
      }
      targetType=getThisType();
    }
    parameterTypes=addType(world.makeBcelType(targetType),parameterTypes);
  }
  if (thisVar != null) {
    TypeX thisType=getThisType();
    parameterTypes=addType(world.makeBcelType(thisType),parameterTypes);
  }
  if (thisJoinPointVar != null) {
    parameterTypes=addTypeToEnd(LazyClassGen.tjpType,parameterTypes);
  }
  TypeX returnType;
  if (getKind() == ConstructorCall) {
    returnType=getSignature().getDeclaringType();
  }
 else   if (getKind() == PreInitialization) {
    returnType=TypeX.OBJECTARRAY;
  }
 else {
    returnType=getSignature().getReturnType();
  }
  return new LazyMethodGen(modifiers,world.makeBcelType(returnType),newMethodName,parameterTypes,new String[0],getEnclosingClass());
}",0.6618209640397857
9752,"/** 
 * side-effect-free 
 */
private InstructionList makeClosureInstantiation(Member constructor,BcelVar holder){
  InstructionFactory fact=getFactory();
  BcelVar arrayVar=genTempVar(TypeX.OBJECTARRAY);
  final InstructionList il=new InstructionList();
  int alen=getArgCount() + (targetVar == null ? 0 : 1) + (thisJoinPointVar == null ? 0 : 1);
  il.append(Utility.createConstant(fact,alen));
  il.append((Instruction)fact.createNewArray(Type.OBJECT,(short)1));
  arrayVar.appendStore(il,fact);
  int stateIndex=0;
  if (targetVar != null) {
    arrayVar.appendConvertableArrayStore(il,fact,stateIndex,targetVar);
    targetVar.setPositionInAroundState(stateIndex);
    stateIndex++;
  }
  for (int i=0, len=getArgCount(); i < len; i++) {
    arrayVar.appendConvertableArrayStore(il,fact,stateIndex,argVars[i]);
    argVars[i].setPositionInAroundState(stateIndex);
    stateIndex++;
  }
  if (thisJoinPointVar != null) {
    arrayVar.appendConvertableArrayStore(il,fact,stateIndex,thisJoinPointVar);
    thisJoinPointVar.setPositionInAroundState(stateIndex);
    stateIndex++;
  }
  il.append(fact.createNew(new ObjectType(constructor.getDeclaringType().getName())));
  il.append(new DUP());
  arrayVar.appendLoad(il,fact);
  il.append(Utility.createInvoke(fact,world,constructor));
  if (getKind() == PreInitialization) {
    il.append(fact.DUP);
    holder.appendStore(il,fact);
  }
  return il;
}","/** 
 * side-effect-free 
 */
private InstructionList makeClosureInstantiation(Member constructor,BcelVar holder){
  InstructionFactory fact=getFactory();
  BcelVar arrayVar=genTempVar(TypeX.OBJECTARRAY);
  final InstructionList il=new InstructionList();
  int alen=getArgCount() + (thisVar == null ? 0 : 1) + ((targetVar != null && targetVar != thisVar) ? 1 : 0)+ (thisJoinPointVar == null ? 0 : 1);
  il.append(Utility.createConstant(fact,alen));
  il.append((Instruction)fact.createNewArray(Type.OBJECT,(short)1));
  arrayVar.appendStore(il,fact);
  int stateIndex=0;
  if (thisVar != null) {
    arrayVar.appendConvertableArrayStore(il,fact,stateIndex,thisVar);
    thisVar.setPositionInAroundState(stateIndex);
    stateIndex++;
  }
  if (targetVar != null && targetVar != thisVar) {
    arrayVar.appendConvertableArrayStore(il,fact,stateIndex,targetVar);
    targetVar.setPositionInAroundState(stateIndex);
    stateIndex++;
  }
  for (int i=0, len=getArgCount(); i < len; i++) {
    arrayVar.appendConvertableArrayStore(il,fact,stateIndex,argVars[i]);
    argVars[i].setPositionInAroundState(stateIndex);
    stateIndex++;
  }
  if (thisJoinPointVar != null) {
    arrayVar.appendConvertableArrayStore(il,fact,stateIndex,thisJoinPointVar);
    thisJoinPointVar.setPositionInAroundState(stateIndex);
    stateIndex++;
  }
  il.append(fact.createNew(new ObjectType(constructor.getDeclaringType().getName())));
  il.append(new DUP());
  arrayVar.appendLoad(il,fact);
  il.append(Utility.createInvoke(fact,world,constructor));
  if (getKind() == PreInitialization) {
    il.append(fact.DUP);
    holder.appendStore(il,fact);
  }
  return il;
}",0.7860892388451444
9753,"public static BcelShadow makeStaticInitialization(BcelWorld world,LazyMethodGen enclosingMethod){
  InstructionList body=enclosingMethod.getBody();
  BcelShadow s=new BcelShadow(world,StaticInitialization,world.makeMethodSignature(enclosingMethod),enclosingMethod,null);
  ShadowRange r=new ShadowRange(body);
  r.associateWithShadow(s);
  r.associateWithTargets(Range.genStart(body),Range.genEnd(body));
  return s;
}","public static BcelShadow makeStaticInitialization(BcelWorld world,LazyMethodGen enclosingMethod){
  InstructionList body=enclosingMethod.getBody();
  InstructionHandle ih=body.getStart();
  if (ih.getInstruction() instanceof InvokeInstruction) {
    InvokeInstruction ii=(InvokeInstruction)ih.getInstruction();
    if (ii.getName(enclosingMethod.getEnclosingClass().getConstantPoolGen()).equals(NameMangler.AJC_CLINIT_NAME)) {
      ih=ih.getNext();
    }
  }
  BcelShadow s=new BcelShadow(world,StaticInitialization,world.makeMethodSignature(enclosingMethod),enclosingMethod,null);
  ShadowRange r=new ShadowRange(body);
  r.associateWithShadow(s);
  r.associateWithTargets(Range.genStart(body,ih),Range.genEnd(body));
  return s;
}",0.7263249348392702
9754,"public void weaveAfterThrowing(BcelAdvice munger,TypeX catchType){
  InstructionFactory fact=getFactory();
  InstructionList handler=new InstructionList();
  BcelVar exceptionVar=genTempVar(catchType);
  exceptionVar.appendStore(handler,fact);
  InstructionList endHandler=new InstructionList(exceptionVar.createLoad(fact));
  handler.append(munger.getAdviceInstructions(this,exceptionVar,endHandler.getStart()));
  handler.append(endHandler);
  handler.append(fact.ATHROW);
  InstructionHandle handlerStart=handler.getStart();
  if (isFallsThrough()) {
    InstructionHandle jumpTarget=handler.append(fact.NOP);
    handler.insert(fact.createBranchInstruction(Constants.GOTO,jumpTarget));
  }
  InstructionHandle protectedEnd=handler.getStart();
  range.insert(handler,Range.InsideAfter);
  enclosingMethod.addExceptionHandler(range.getStart().getNext(),protectedEnd.getPrev(),handlerStart,(ObjectType)BcelWorld.makeBcelType(catchType),isExpressionKind());
}","public void weaveAfterThrowing(BcelAdvice munger,TypeX catchType){
  if (getRange().getStart().getNext() == getRange().getEnd())   return;
  InstructionFactory fact=getFactory();
  InstructionList handler=new InstructionList();
  BcelVar exceptionVar=genTempVar(catchType);
  exceptionVar.appendStore(handler,fact);
  InstructionList endHandler=new InstructionList(exceptionVar.createLoad(fact));
  handler.append(munger.getAdviceInstructions(this,exceptionVar,endHandler.getStart()));
  handler.append(endHandler);
  handler.append(fact.ATHROW);
  InstructionHandle handlerStart=handler.getStart();
  if (isFallsThrough()) {
    InstructionHandle jumpTarget=handler.append(fact.NOP);
    handler.insert(fact.createBranchInstruction(Constants.GOTO,jumpTarget));
  }
  InstructionHandle protectedEnd=handler.getStart();
  range.insert(handler,Range.InsideAfter);
  enclosingMethod.addExceptionHandler(range.getStart().getNext(),protectedEnd.getPrev(),handlerStart,(ObjectType)BcelWorld.makeBcelType(catchType),isExpressionKind());
}",0.963819095477387
9755,"public void initializeArgVars(){
  if (argVars != null)   return;
  InstructionFactory fact=getFactory();
  int len=getArgCount();
  argVars=new BcelVar[len];
  if (getKind().argsOnStack()) {
    for (int i=len - 1; i >= 0; i--) {
      TypeX type=getArgType(i);
      BcelVar tmp=genTempVar(type,""String_Node_Str"" + i);
      range.insert(tmp.createStore(getFactory()),Range.OutsideBefore);
      int position=i;
      if (hasTarget())       position+=1;
      tmp.setPositionInAroundState(position);
      argVars[i]=tmp;
    }
  }
 else {
    int index=0;
    if (hasThis())     index++;
    for (int i=0; i < len; i++) {
      TypeX type=getArgType(i);
      BcelVar tmp=genTempVar(type,""String_Node_Str"" + i);
      range.insert(tmp.createCopyFrom(fact,index),Range.OutsideBefore);
      argVars[i]=tmp;
      int position=i;
      if (hasTarget())       position+=1;
      tmp.setPositionInAroundState(position);
      index+=type.getSize();
    }
  }
}","public void initializeArgVars(){
  if (argVars != null)   return;
  InstructionFactory fact=getFactory();
  int len=getArgCount();
  argVars=new BcelVar[len];
  int positionOffset=(hasTarget() ? 0 : 1) + (hasThis() ? 0 : 1);
  if (getKind().argsOnStack()) {
    for (int i=len - 1; i >= 0; i--) {
      TypeX type=getArgType(i);
      BcelVar tmp=genTempVar(type,""String_Node_Str"" + i);
      range.insert(tmp.createStore(getFactory()),Range.OutsideBefore);
      int position=i;
      if (hasTarget())       position+=positionOffset;
      tmp.setPositionInAroundState(position);
      argVars[i]=tmp;
    }
  }
 else {
    int index=0;
    if (hasThis())     index++;
    for (int i=0; i < len; i++) {
      TypeX type=getArgType(i);
      BcelVar tmp=genTempVar(type,""String_Node_Str"" + i);
      range.insert(tmp.createCopyFrom(fact,index),Range.OutsideBefore);
      argVars[i]=tmp;
      int position=i;
      if (hasTarget())       position+=positionOffset;
      tmp.setPositionInAroundState(position);
      index+=type.getSize();
    }
  }
}",0.9522388059701492
9756,"public void initializeForAroundClosure(){
  initializeArgVars();
  if (hasTarget())   initializeTargetVar();
}","public void initializeForAroundClosure(){
  initializeArgVars();
  if (hasTarget())   initializeTargetVar();
  if (hasThis())   initializeThisVar();
}",0.8461538461538461
9757,"/** 
 * make a map from old frame location to new frame location.  Any unkeyed frame location picks out a copied local 
 */
private IntMap makeRemap(){
  IntMap ret=new IntMap(5);
  int reti=0;
  if (targetVar != null) {
    ret.put(targetVar.getSlot(),reti++);
  }
  for (int i=0, len=argVars.length; i < len; i++) {
    ret.put(argVars[i].getSlot(),reti);
    reti+=argVars[i].getType().getSize();
  }
  if (thisJoinPointVar != null) {
    ret.put(thisJoinPointVar.getSlot(),reti++);
  }
  if (!getKind().argsOnStack()) {
    int index=0;
    if (hasThis()) {
      ret.put(0,0);
      index++;
    }
    for (int i=0; i < getArgCount(); i++) {
      TypeX type=getArgType(i);
      ret.put(index,index);
      index+=type.getSize();
    }
  }
  return ret;
}","/** 
 * make a map from old frame location to new frame location.  Any unkeyed frame location picks out a copied local 
 */
private IntMap makeRemap(){
  IntMap ret=new IntMap(5);
  int reti=0;
  if (thisVar != null) {
    ret.put(0,reti++);
  }
  if (targetVar != null && targetVar != thisVar) {
    ret.put(targetVar.getSlot(),reti++);
  }
  for (int i=0, len=argVars.length; i < len; i++) {
    ret.put(argVars[i].getSlot(),reti);
    reti+=argVars[i].getType().getSize();
  }
  if (thisJoinPointVar != null) {
    ret.put(thisJoinPointVar.getSlot(),reti++);
  }
  if (!getKind().argsOnStack()) {
    int oldi=0;
    int newi=0;
    if (hasThis()) {
      ret.put(0,0);
      oldi++;
      newi+=1;
    }
    for (int i=0; i < getArgCount(); i++) {
      TypeX type=getArgType(i);
      ret.put(oldi,newi);
      oldi+=type.getSize();
      newi+=type.getSize();
    }
  }
  return ret;
}",0.8208232445520581
9758,"public void initializeTargetVar(){
  InstructionFactory fact=getFactory();
  if (targetVar != null)   return;
  if (!isExpressionKind()) {
    initializeThisVar();
    targetVar=thisVar;
  }
 else {
    initializeArgVars();
    TypeX type=getTargetType();
    targetVar=genTempVar(type,""String_Node_Str"");
    range.insert(targetVar.createStore(fact),Range.OutsideBefore);
  }
  targetVar.setPositionInAroundState(0);
}","public void initializeTargetVar(){
  InstructionFactory fact=getFactory();
  if (targetVar != null)   return;
  if (!isExpressionKind()) {
    initializeThisVar();
    targetVar=thisVar;
  }
 else {
    initializeArgVars();
    TypeX type=getTargetType();
    targetVar=genTempVar(type,""String_Node_Str"");
    range.insert(targetVar.createStore(fact),Range.OutsideBefore);
    targetVar.setPositionInAroundState(hasThis() ? 1 : 0);
  }
}",0.9742990654205608
9759,"/** 
 * fill the newly created method gen with our body,  inspired by InstructionList.copy()
 */
public void packBody(MethodGen gen){
  HashMap map=new HashMap();
  InstructionList fresh=gen.getInstructionList();
  for (InstructionHandle ih=getBody().getStart(); ih != null; ih=ih.getNext()) {
    if (Range.isRangeHandle(ih)) {
      continue;
    }
    Instruction i=ih.getInstruction();
    Instruction c=i.copy();
    if (c instanceof BranchInstruction)     map.put(ih,fresh.append((BranchInstruction)c));
 else     map.put(ih,fresh.append(c));
  }
  InstructionHandle ih=getBody().getStart();
  InstructionHandle jh=fresh.getStart();
  LinkedList exnList=new LinkedList();
  Map localVariableStarts=new HashMap();
  Map localVariableEnds=new HashMap();
  int currLine=-1;
  while (ih != null) {
    if (map.get(ih) == null) {
      Range r=Range.getRange(ih);
      if (r instanceof ExceptionRange) {
        ExceptionRange er=(ExceptionRange)r;
        if (er.getStart() == ih) {
          insertHandler(er,exnList);
        }
      }
 else {
      }
      ih=ih.getNext();
    }
 else {
      Instruction i=ih.getInstruction();
      Instruction j=jh.getInstruction();
      if (i instanceof BranchInstruction) {
        BranchInstruction bi=(BranchInstruction)i;
        BranchInstruction bj=(BranchInstruction)j;
        InstructionHandle itarget=bi.getTarget();
        bj.setTarget(remap(itarget,map));
        if (bi instanceof Select) {
          InstructionHandle[] itargets=((Select)bi).getTargets();
          InstructionHandle[] jtargets=((Select)bj).getTargets();
          for (int k=itargets.length - 1; k >= 0; k--) {
            jtargets[k]=remap(itargets[k],map);
            jtargets[k].addTargeter(bj);
          }
        }
      }
      InstructionTargeter[] targeters=ih.getTargeters();
      if (targeters != null) {
        for (int k=targeters.length - 1; k >= 0; k--) {
          InstructionTargeter targeter=targeters[k];
          if (targeter instanceof LineNumberTag) {
            int line=((LineNumberTag)targeter).getLineNumber();
            if (line != currLine) {
              gen.addLineNumber(jh,line);
              currLine=line;
            }
          }
 else           if (targeter instanceof LocalVariableTag) {
            LocalVariableTag lvt=(LocalVariableTag)targeter;
            if (i instanceof LocalVariableInstruction) {
              int index=((LocalVariableInstruction)i).getIndex();
              if (lvt.getSlot() == index) {
                if (localVariableStarts.get(lvt) == null) {
                  localVariableStarts.put(lvt,jh);
                }
                localVariableEnds.put(lvt,jh);
              }
            }
          }
        }
      }
      ih=ih.getNext();
      jh=jh.getNext();
    }
  }
  for (Iterator iter=exnList.iterator(); iter.hasNext(); ) {
    ExceptionRange r=(ExceptionRange)iter.next();
    if (r.isEmpty())     continue;
    gen.addExceptionHandler(remap(r.getRealStart(),map),remap(r.getRealEnd(),map),remap(r.getHandler(),map),(r.getCatchType() == null) ? null : (ObjectType)BcelWorld.makeBcelType(r.getCatchType()));
  }
  gen.removeLocalVariables();
  for (Iterator iter=localVariableStarts.keySet().iterator(); iter.hasNext(); ) {
    LocalVariableTag tag=(LocalVariableTag)iter.next();
    gen.addLocalVariable(tag.getName(),BcelWorld.makeBcelType(tag.getType()),tag.getSlot(),(InstructionHandle)localVariableStarts.get(tag),(InstructionHandle)localVariableEnds.get(tag));
  }
}","/** 
 * fill the newly created method gen with our body,  inspired by InstructionList.copy()
 */
public void packBody(MethodGen gen){
  HashMap map=new HashMap();
  InstructionList fresh=gen.getInstructionList();
  for (InstructionHandle ih=getBody().getStart(); ih != null; ih=ih.getNext()) {
    if (Range.isRangeHandle(ih)) {
      continue;
    }
    Instruction i=ih.getInstruction();
    Instruction c=i.copy();
    if (c instanceof BranchInstruction)     map.put(ih,fresh.append((BranchInstruction)c));
 else     map.put(ih,fresh.append(c));
  }
  InstructionHandle ih=getBody().getStart();
  InstructionHandle jh=fresh.getStart();
  LinkedList exnList=new LinkedList();
  Map localVariableStarts=new HashMap();
  Map localVariableEnds=new HashMap();
  int currLine=-1;
  while (ih != null) {
    if (map.get(ih) == null) {
      Range r=Range.getRange(ih);
      if (r instanceof ExceptionRange) {
        ExceptionRange er=(ExceptionRange)r;
        if (er.getStart() == ih) {
          if (!er.isEmpty()) {
            insertHandler(er,exnList);
          }
        }
      }
 else {
      }
      ih=ih.getNext();
    }
 else {
      Instruction i=ih.getInstruction();
      Instruction j=jh.getInstruction();
      if (i instanceof BranchInstruction) {
        BranchInstruction bi=(BranchInstruction)i;
        BranchInstruction bj=(BranchInstruction)j;
        InstructionHandle itarget=bi.getTarget();
        bj.setTarget(remap(itarget,map));
        if (bi instanceof Select) {
          InstructionHandle[] itargets=((Select)bi).getTargets();
          InstructionHandle[] jtargets=((Select)bj).getTargets();
          for (int k=itargets.length - 1; k >= 0; k--) {
            jtargets[k]=remap(itargets[k],map);
            jtargets[k].addTargeter(bj);
          }
        }
      }
      InstructionTargeter[] targeters=ih.getTargeters();
      if (targeters != null) {
        for (int k=targeters.length - 1; k >= 0; k--) {
          InstructionTargeter targeter=targeters[k];
          if (targeter instanceof LineNumberTag) {
            int line=((LineNumberTag)targeter).getLineNumber();
            if (line != currLine) {
              gen.addLineNumber(jh,line);
              currLine=line;
            }
          }
 else           if (targeter instanceof LocalVariableTag) {
            LocalVariableTag lvt=(LocalVariableTag)targeter;
            if (i instanceof LocalVariableInstruction) {
              int index=((LocalVariableInstruction)i).getIndex();
              if (lvt.getSlot() == index) {
                if (localVariableStarts.get(lvt) == null) {
                  localVariableStarts.put(lvt,jh);
                }
                localVariableEnds.put(lvt,jh);
              }
            }
          }
        }
      }
      ih=ih.getNext();
      jh=jh.getNext();
    }
  }
  for (Iterator iter=exnList.iterator(); iter.hasNext(); ) {
    ExceptionRange r=(ExceptionRange)iter.next();
    if (r.isEmpty())     continue;
    gen.addExceptionHandler(remap(r.getRealStart(),map),remap(r.getRealEnd(),map),remap(r.getHandler(),map),(r.getCatchType() == null) ? null : (ObjectType)BcelWorld.makeBcelType(r.getCatchType()));
  }
  gen.removeLocalVariables();
  for (Iterator iter=localVariableStarts.keySet().iterator(); iter.hasNext(); ) {
    LocalVariableTag tag=(LocalVariableTag)iter.next();
    gen.addLocalVariable(tag.getName(),BcelWorld.makeBcelType(tag.getType()),tag.getSlot(),(InstructionHandle)localVariableStarts.get(tag),(InstructionHandle)localVariableEnds.get(tag));
  }
}",0.9935979513444302
9760,"public void generateCode(ClassScope classScope,ClassFile classFile){
  if (proceedMethodBinding != null) {
  }
  super.generateCode(classScope,classFile);
  if (proceedMethodBinding != null) {
    generateProceedMethod(classScope,classFile);
  }
}","public void generateCode(ClassScope classScope,ClassFile classFile){
  super.generateCode(classScope,classFile);
  if (proceedMethodBinding != null) {
    generateProceedMethod(classScope,classFile);
  }
}",0.495575221238938
9761,"public void postParse(TypeDeclaration typeDec){
  this.selector=NameMangler.adviceName(EclipseWorld.fromBinding(typeDec.binding),kind,sourceStart).toCharArray();
  finishParsing();
  pointcutDesignator.postParse(typeDec,this);
}","public void postParse(TypeDeclaration typeDec){
  this.selector=NameMangler.adviceName(EclipseWorld.fromBinding(typeDec.binding),kind,sourceStart).toCharArray();
  if (arguments != null) {
    baseArgumentCount=arguments.length;
  }
  if (kind == AdviceKind.Around) {
    extraArgument=makeFinalArgument(""String_Node_Str"",AjTypeConstants.getAroundClosureType());
  }
  int addedArguments=3;
  if (extraArgument != null) {
    addedArguments+=1;
  }
  arguments=extendArgumentsLength(arguments,addedArguments);
  int index=baseArgumentCount;
  if (extraArgument != null) {
    arguments[index++]=extraArgument;
  }
  arguments[index++]=makeFinalArgument(""String_Node_Str"",AjTypeConstants.getJoinPointStaticPartType());
  arguments[index++]=makeFinalArgument(""String_Node_Str"",AjTypeConstants.getJoinPointType());
  arguments[index++]=makeFinalArgument(""String_Node_Str"",AjTypeConstants.getJoinPointStaticPartType());
  if (pointcutDesignator.isError()) {
    this.ignoreFurtherInvestigation=true;
  }
  pointcutDesignator.postParse(typeDec,this);
}",0.3325490196078431
9762,"public ResolvedPointcutDefinition makeResolvedPointcutDefinition(){
  return new ResolvedPointcutDefinition(EclipseWorld.fromBinding(this.binding.declaringClass),this.modifiers,new String(selector),EclipseWorld.fromBindings(this.binding.parameters),getPointcut());
}","public ResolvedPointcutDefinition makeResolvedPointcutDefinition(){
  ResolvedPointcutDefinition ret=new ResolvedPointcutDefinition(EclipseWorld.fromBinding(this.binding.declaringClass),declaredModifiers,declaredName,EclipseWorld.fromBindings(this.binding.parameters),getPointcut());
  ret.setPosition(sourceStart,sourceEnd);
  ret.setSourceContext(new EclipseSourceContext(compilationResult));
  return ret;
}",0.6893491124260355
9763,"public void postParse(TypeDeclaration typeDec){
  if (arguments == null)   arguments=new Argument[0];
  if (pointcutDesignator == null)   return;
  pointcutDesignator.postParse(typeDec,this);
}","public void postParse(TypeDeclaration typeDec){
  if (arguments == null)   arguments=new Argument[0];
  this.declaredModifiers=modifiers;
  this.declaredName=new String(selector);
  selector=CharOperation.concat(mangledPrefix,'$',selector,'$',Integer.toHexString(sourceStart).toCharArray());
  if (pointcutDesignator == null)   return;
  pointcutDesignator.postParse(typeDec,this);
}",0.4166666666666667
9764,"public void parseStatements(Parser parser,CompilationUnitDeclaration unit){
  if (pointcutDesignator == null) {
  }
 else {
  }
}","public void parseStatements(Parser parser,CompilationUnitDeclaration unit){
}",0.7475728155339806
9765,"public static void main(String[] args) throws Exception {
  Random random=new Random();
  LoremIpsum loremIpsum=new LoremIpsum();
  String file=""String_Node_Str"" + new SimpleDateFormat(""String_Node_Str"").format(new Date()) + ""String_Node_Str"";
  System.out.println(""String_Node_Str"" + file);
  final OutputStream out=new FileOutputStream(file);
  LogglyBatchAppender<String> appender=new LogglyBatchAppender<String>(){
    @Override protected void processLogEntries(    InputStream in) throws IOException {
      IoUtils.copy(in,out);
    }
  }
;
  appender.setInputKey(""String_Node_Str"");
  appender.setLayout(new EchoLayout<String>());
  appender.setDebug(true);
  appender.start();
  assertTrue(""String_Node_Str"",appender.isStarted());
  appender.doAppend(""String_Node_Str"" + new Timestamp(System.currentTimeMillis()));
  for (int i=0; i < 100000; i++) {
    appender.doAppend(i + ""String_Node_Str"" + new Timestamp(System.currentTimeMillis())+ ""String_Node_Str""+ loremIpsum.getWords(random.nextInt(50),random.nextInt(50)));
    TimeUnit.MILLISECONDS.sleep(random.nextInt(30));
    if (i % 100 == 0) {
      System.out.println(i + ""String_Node_Str"" + appender);
    }
  }
  appender.stop();
  out.close();
  System.out.println(appender);
}","public static void main(String[] args) throws Exception {
  Random random=new Random();
  LoremIpsum loremIpsum=new LoremIpsum();
  String file=""String_Node_Str"" + new SimpleDateFormat(""String_Node_Str"").format(new Date()) + ""String_Node_Str"";
  System.out.println(""String_Node_Str"" + file);
  final OutputStream out=new FileOutputStream(file);
  LogglyBatchAppender<String> appender=new LogglyBatchAppender<String>(){
    @Override protected void processLogEntries(    InputStream in){
      try {
        IoUtils.copy(in,out);
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
;
  appender.setInputKey(""String_Node_Str"");
  appender.setLayout(new EchoLayout<String>());
  appender.setDebug(true);
  appender.start();
  assertTrue(""String_Node_Str"",appender.isStarted());
  appender.doAppend(""String_Node_Str"" + new Timestamp(System.currentTimeMillis()));
  for (int i=0; i < 100000; i++) {
    appender.doAppend(i + ""String_Node_Str"" + new Timestamp(System.currentTimeMillis())+ ""String_Node_Str""+ loremIpsum.getWords(random.nextInt(50),random.nextInt(50)));
    TimeUnit.MILLISECONDS.sleep(random.nextInt(30));
    if (i % 100 == 0) {
      System.out.println(i + ""String_Node_Str"" + appender);
    }
  }
  appender.stop();
  out.close();
  System.out.println(appender);
}",0.95141065830721
9766,"@Override protected void processLogEntries(InputStream in) throws IOException {
  IoUtils.copy(in,out);
}","@Override protected void processLogEntries(InputStream in){
  try {
    IoUtils.copy(in,out);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.6846153846153846
9767,"@Override protected void processLogEntries(InputStream in) throws IOException {
  super.processLogEntries(in);
synchronized (appender) {
    notifyAll();
  }
}","@Override protected void processLogEntries(InputStream in){
  super.processLogEntries(in);
synchronized (appender) {
    notifyAll();
  }
}",0.9328859060402684
9768,"/** 
 * Creates a configured HTTP connection to a URL (does not open the connection)
 * @param url target URL
 * @return the newly created HTTP connection
 * @throws IOException
 */
protected HttpURLConnection getHttpConnection(URL url) throws IOException {
  HttpURLConnection conn;
  if (proxy == null) {
    conn=(HttpURLConnection)url.openConnection();
  }
 else {
    conn=(HttpURLConnection)url.openConnection(proxy);
  }
  conn.setDoOutput(true);
  conn.setDoInput(true);
  conn.setRequestProperty(""String_Node_Str"",layout.getContentType() + ""String_Node_Str"" + charset.name());
  conn.setRequestMethod(""String_Node_Str"");
  conn.setReadTimeout(getHttpReadTimeoutInMillis());
  return conn;
}","/** 
 * Creates a configured HTTP connection to a URL (does not open the connection)
 * @param url target URL
 * @return the newly created HTTP connection
 * @throws IOException connection error
 */
protected HttpURLConnection getHttpConnection(URL url) throws IOException {
  HttpURLConnection conn;
  if (proxy == null) {
    conn=(HttpURLConnection)url.openConnection();
  }
 else {
    conn=(HttpURLConnection)url.openConnection(proxy);
  }
  conn.setDoOutput(true);
  conn.setDoInput(true);
  conn.setRequestProperty(""String_Node_Str"",layout.getContentType() + ""String_Node_Str"" + charset.name());
  conn.setRequestMethod(""String_Node_Str"");
  conn.setReadTimeout(getHttpReadTimeoutInMillis());
  return conn;
}",0.9879858657243816
9769,"/** 
 * Send log entries to Loggly
 */
protected void processLogEntries(InputStream in) throws IOException {
  long nanosBefore=System.nanoTime();
  try {
    HttpURLConnection conn=getHttpConnection(new URL(endpointUrl));
    conn.setReadTimeout(connReadTimeoutSeconds * 1000);
    BufferedOutputStream out=new BufferedOutputStream(conn.getOutputStream());
    long len=IoUtils.copy(in,out);
    sentBytes.addAndGet(len);
    out.flush();
    out.close();
    int responseCode=conn.getResponseCode();
    String response=super.readResponseBody(conn.getInputStream());
switch (responseCode) {
case HttpURLConnection.HTTP_OK:
case HttpURLConnection.HTTP_ACCEPTED:
      sendSuccessCount.incrementAndGet();
    break;
default :
  sendExceptionCount.incrementAndGet();
addError(""String_Node_Str"" + responseCode + ""String_Node_Str""+ response);
}
try {
conn.getInputStream().close();
conn.disconnect();
}
 catch (Exception e) {
}
}
 catch (Exception e) {
sendExceptionCount.incrementAndGet();
addError(""String_Node_Str"",e);
}
 finally {
sendDurationInNanos.addAndGet(System.nanoTime() - nanosBefore);
}
}","/** 
 * Send log entries to Loggly
 * @param in log input stream
 */
protected void processLogEntries(InputStream in){
  long nanosBefore=System.nanoTime();
  try {
    HttpURLConnection conn=getHttpConnection(new URL(endpointUrl));
    conn.setReadTimeout(connReadTimeoutSeconds * 1000);
    BufferedOutputStream out=new BufferedOutputStream(conn.getOutputStream());
    long len=IoUtils.copy(in,out);
    sentBytes.addAndGet(len);
    out.flush();
    out.close();
    int responseCode=conn.getResponseCode();
    String response=super.readResponseBody(conn.getInputStream());
switch (responseCode) {
case HttpURLConnection.HTTP_OK:
case HttpURLConnection.HTTP_ACCEPTED:
      sendSuccessCount.incrementAndGet();
    break;
default :
  sendExceptionCount.incrementAndGet();
addError(""String_Node_Str"" + responseCode + ""String_Node_Str""+ response);
}
try {
conn.getInputStream().close();
conn.disconnect();
}
 catch (Exception e) {
}
}
 catch (Exception e) {
sendExceptionCount.incrementAndGet();
addError(""String_Node_Str"",e);
}
 finally {
sendDurationInNanos.addAndGet(System.nanoTime() - nanosBefore);
}
}",0.977355072463768
9770,"/** 
 * Moves the current active bucket to the list of filled buckets and defines a new one. <p/> The new active bucket is reused from the   {@link #recycledBucketPool} pool if one is available or recreated.
 */
public void rollCurrentBucket(){
  currentBucketLock.lock();
  try {
    boolean offered=filledBuckets.offer(currentBucket);
    if (offered) {
      onBucketRoll(currentBucket);
    }
 else {
      onBucketDiscard(currentBucket);
      discardedBucketCount.incrementAndGet();
    }
    currentBucket=newBucket();
  }
  finally {
    currentBucketLock.unlock();
  }
}","/** 
 * Moves the current active bucket to the list of filled buckets and defines a new one. The new active bucket is reused from the   {@link #recycledBucketPool} pool if one is available or recreated.
 */
public void rollCurrentBucket(){
  currentBucketLock.lock();
  try {
    boolean offered=filledBuckets.offer(currentBucket);
    if (offered) {
      onBucketRoll(currentBucket);
    }
 else {
      onBucketDiscard(currentBucket);
      discardedBucketCount.incrementAndGet();
    }
    currentBucket=newBucket();
  }
  finally {
    currentBucketLock.unlock();
  }
}",0.9956634865568084
9771,"/** 
 * Number of discarded buckets. Monitoring oriented metric.
 */
public int getDiscardedBucketCount(){
  return discardedBucketCount.get();
}","/** 
 * @return Number of discarded buckets. Monitoring oriented metric.
 */
public int getDiscardedBucketCount(){
  return discardedBucketCount.get();
}",0.9731543624161074
9772,"/** 
 * @param maxBucketSizeInBytes
 * @param maxBucketCount
 */
public DiscardingRollingOutputStream(int maxBucketSizeInBytes,int maxBucketCount){
  if (maxBucketCount < 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.maxBucketSizeInBytes=maxBucketSizeInBytes;
  this.filledBuckets=new LinkedBlockingDeque<ByteArrayOutputStream>(maxBucketCount);
  this.recycledBucketPool=new ConcurrentLinkedQueue<ByteArrayOutputStream>();
  this.currentBucket=newBucket();
}","/** 
 * @param maxBucketSizeInBytes maximum byte size of each bucket
 * @param maxBucketCount maximum number of buckets
 */
public DiscardingRollingOutputStream(int maxBucketSizeInBytes,int maxBucketCount){
  if (maxBucketCount < 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.maxBucketSizeInBytes=maxBucketSizeInBytes;
  this.filledBuckets=new LinkedBlockingDeque<ByteArrayOutputStream>(maxBucketCount);
  this.recycledBucketPool=new ConcurrentLinkedQueue<ByteArrayOutputStream>();
  this.currentBucket=newBucket();
}",0.9428848015488868
9773,"/** 
 * Initialize Logback, including setting the web app root system property.
 * @param servletContext the current ServletContext
 * @see org.springframework.web.util.WebUtils#setWebAppRootSystemProperty
 */
public static void initLogging(ServletContext servletContext){
  if (exposeWebAppRoot(servletContext)) {
    WebUtils.setWebAppRootSystemProperty(servletContext);
  }
  String location=servletContext.getInitParameter(CONFIG_LOCATION_PARAM);
  if (location != null) {
    try {
      if (!ResourceUtils.isUrl(location)) {
        location=SystemPropertyUtils.resolvePlaceholders(location);
        location=WebUtils.getRealPath(servletContext,location);
      }
      servletContext.log(""String_Node_Str"" + location + ""String_Node_Str"");
      LogbackConfigurer.initLogging(location);
    }
 catch (    FileNotFoundException ex) {
      throw new IllegalArgumentException(""String_Node_Str"" + ex.getMessage());
    }
catch (    JoranException e) {
      throw new RuntimeException(""String_Node_Str"",e);
    }
  }
  try {
    Class<?> julBridge=ClassUtils.forName(""String_Node_Str"",ClassUtils.getDefaultClassLoader());
    Method install=ReflectionUtils.findMethod(julBridge,""String_Node_Str"");
    if (install != null) {
      servletContext.log(""String_Node_Str"");
      ReflectionUtils.invokeMethod(install,null);
    }
  }
 catch (  ClassNotFoundException ignored) {
    servletContext.log(""String_Node_Str"");
  }
}","/** 
 * Initialize Logback, including setting the web app root system property.
 * @param servletContext the current ServletContext
 * @see org.springframework.web.util.WebUtils#setWebAppRootSystemProperty
 */
public static void initLogging(ServletContext servletContext){
  if (exposeWebAppRoot(servletContext)) {
    WebUtils.setWebAppRootSystemProperty(servletContext);
  }
  String location=servletContext.getInitParameter(CONFIG_LOCATION_PARAM);
  if (location != null) {
    try {
      location=SystemPropertyUtils.resolvePlaceholders(location);
      if (!ResourceUtils.isUrl(location)) {
        location=WebUtils.getRealPath(servletContext,location);
      }
      servletContext.log(""String_Node_Str"" + location + ""String_Node_Str"");
      LogbackConfigurer.initLogging(location);
    }
 catch (    FileNotFoundException ex) {
      throw new IllegalArgumentException(""String_Node_Str"" + ex.getMessage());
    }
catch (    JoranException e) {
      throw new RuntimeException(""String_Node_Str"",e);
    }
  }
  try {
    Class<?> julBridge=ClassUtils.forName(""String_Node_Str"",ClassUtils.getDefaultClassLoader());
    Method install=ReflectionUtils.findMethod(julBridge,""String_Node_Str"");
    if (install != null) {
      servletContext.log(""String_Node_Str"");
      ReflectionUtils.invokeMethod(install,null);
    }
  }
 catch (  ClassNotFoundException ignored) {
    servletContext.log(""String_Node_Str"");
  }
}",0.9529824561403508
9774,"@Override public OperableTrigger setExtraPropertiesAfterInstantiation(OperableTrigger trigger,DBObject stored){
  DailyTimeIntervalTriggerImpl t=(DailyTimeIntervalTriggerImpl)trigger;
  Object interval_unit=stored.get(TRIGGER_REPEAT_INTERVAL_UNIT);
  if (interval_unit != null) {
    t.setRepeatCount((Integer)interval_unit);
  }
  Object repeatInterval=stored.get(TRIGGER_REPEAT_INTERVAL);
  if (repeatInterval != null) {
    t.setRepeatInterval((Integer)repeatInterval);
  }
  Object timesTriggered=stored.get(TRIGGER_TIMES_TRIGGERED);
  if (timesTriggered != null) {
    t.setTimesTriggered((Integer)timesTriggered);
  }
  DBObject startTOD=(DBObject)stored.get(TRIGGER_START_TIME_OF_DAY);
  if (startTOD != null) {
    t.setStartTimeOfDay(fromDBObject(startTOD));
  }
  DBObject endTOD=(DBObject)stored.get(TRIGGER_END_TIME_OF_DAY);
  if (endTOD != null) {
    t.setEndTimeOfDay(fromDBObject(endTOD));
  }
  return t;
}","@Override public OperableTrigger setExtraPropertiesAfterInstantiation(OperableTrigger trigger,DBObject stored){
  DailyTimeIntervalTriggerImpl t=(DailyTimeIntervalTriggerImpl)trigger;
  Object interval_unit=stored.get(TRIGGER_REPEAT_INTERVAL_UNIT);
  if (interval_unit != null) {
    t.setRepeatIntervalUnit(DateBuilder.IntervalUnit.valueOf((String)interval_unit));
  }
  Object repeatInterval=stored.get(TRIGGER_REPEAT_INTERVAL);
  if (repeatInterval != null) {
    t.setRepeatInterval((Integer)repeatInterval);
  }
  Object timesTriggered=stored.get(TRIGGER_TIMES_TRIGGERED);
  if (timesTriggered != null) {
    t.setTimesTriggered((Integer)timesTriggered);
  }
  DBObject startTOD=(DBObject)stored.get(TRIGGER_START_TIME_OF_DAY);
  if (startTOD != null) {
    t.setStartTimeOfDay(fromDBObject(startTOD));
  }
  DBObject endTOD=(DBObject)stored.get(TRIGGER_END_TIME_OF_DAY);
  if (endTOD != null) {
    t.setEndTimeOfDay(fromDBObject(endTOD));
  }
  return t;
}",0.9490986214209968
9775,"private void ensureIndexes(){
  BasicDBObject keys=new BasicDBObject();
  keys.put(JOB_KEY_NAME,1);
  keys.put(JOB_KEY_GROUP,1);
  jobCollection.ensureIndex(keys,null,true);
  keys=new BasicDBObject();
  keys.put(KEY_NAME,1);
  keys.put(KEY_GROUP,1);
  keys.put(TRIGGER_NEXT_FIRE_TIME,1);
  keys.put(TRIGGER_PREVIOUS_FIRE_TIME,1);
  triggerCollection.ensureIndex(keys,null,true);
  keys=new BasicDBObject();
  keys.put(LOCK_KEY_NAME,1);
  keys.put(LOCK_KEY_GROUP,1);
  locksCollection.ensureIndex(keys,null,true);
  locksCollection.remove(new BasicDBObject(LOCK_INSTANCE_ID,instanceId));
  keys=new BasicDBObject();
  keys.put(CALENDAR_NAME,1);
  calendarCollection.ensureIndex(keys,null,true);
}","private void ensureIndexes(){
  BasicDBObject keys=new BasicDBObject();
  keys.put(JOB_KEY_NAME,1);
  keys.put(JOB_KEY_GROUP,1);
  jobCollection.ensureIndex(keys,null,true);
  keys=new BasicDBObject();
  keys.put(KEY_NAME,1);
  keys.put(KEY_GROUP,1);
  triggerCollection.ensureIndex(keys,null,true);
  keys=new BasicDBObject();
  keys.put(LOCK_KEY_NAME,1);
  keys.put(LOCK_KEY_GROUP,1);
  locksCollection.ensureIndex(keys,null,true);
  locksCollection.remove(new BasicDBObject(LOCK_INSTANCE_ID,instanceId));
  keys=new BasicDBObject();
  keys.put(CALENDAR_NAME,1);
  calendarCollection.ensureIndex(keys,null,true);
}",0.9390243902439024
9776,"public List<OperableTrigger> acquireNextTriggers(long noLaterThan,int maxCount,long timeWindow) throws JobPersistenceException {
  BasicDBObject query=new BasicDBObject();
  query.put(TRIGGER_NEXT_FIRE_TIME,new BasicDBObject(""String_Node_Str"",new Date(noLaterThan)));
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + maxCount + ""String_Node_Str""+ new Date(noLaterThan));
  }
  List<OperableTrigger> triggers=new ArrayList<OperableTrigger>();
  DBCursor cursor=triggerCollection.find(query);
  BasicDBObject sort=new BasicDBObject();
  sort.put(TRIGGER_NEXT_FIRE_TIME,Integer.valueOf(1));
  cursor.sort(sort);
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + cursor.count() + ""String_Node_Str"");
  }
  while (cursor.hasNext() && maxCount > triggers.size()) {
    DBObject dbObj=cursor.next();
    BasicDBObject lock=new BasicDBObject();
    lock.put(LOCK_KEY_NAME,dbObj.get(KEY_NAME));
    lock.put(LOCK_KEY_GROUP,dbObj.get(KEY_GROUP));
    lock.put(LOCK_INSTANCE_ID,instanceId);
    lock.put(LOCK_TIME,new Date());
    try {
      OperableTrigger trigger=toTrigger(dbObj);
      if (trigger.getNextFireTime() == null) {
        if (log.isDebugEnabled()) {
          log.debug(""String_Node_Str"" + trigger.getKey() + ""String_Node_Str"");
        }
        continue;
      }
      if (applyMisfire(trigger) && trigger.getNextFireTime() == null) {
        if (log.isDebugEnabled()) {
          log.debug(""String_Node_Str"" + trigger.getKey() + ""String_Node_Str"");
        }
        continue;
      }
      log.debug(""String_Node_Str"" + trigger.getKey());
      locksCollection.insert(lock);
      log.debug(""String_Node_Str"" + trigger.getKey());
      triggers.add(trigger);
    }
 catch (    DuplicateKey e) {
      OperableTrigger trigger=toTrigger(dbObj);
      log.debug(""String_Node_Str"" + trigger.getKey() + ""String_Node_Str"");
      lock=new BasicDBObject();
      lock.put(LOCK_KEY_NAME,dbObj.get(KEY_NAME));
      lock.put(LOCK_KEY_GROUP,dbObj.get(KEY_GROUP));
      DBObject existingLock;
      DBCursor lockCursor=locksCollection.find(lock);
      if (lockCursor.hasNext()) {
        existingLock=lockCursor.next();
      }
 else {
        log.error(""String_Node_Str"");
        return acquireNextTriggers(noLaterThan,maxCount,timeWindow);
      }
      if (isTriggerLockExpired(existingLock)) {
        log.error(""String_Node_Str"" + trigger.getKey() + ""String_Node_Str"");
        removeTriggerLock(trigger);
        return acquireNextTriggers(noLaterThan,maxCount,timeWindow);
      }
    }
  }
  return triggers;
}","public List<OperableTrigger> acquireNextTriggers(long noLaterThan,int maxCount,long timeWindow) throws JobPersistenceException {
  BasicDBObject query=new BasicDBObject();
  query.put(TRIGGER_NEXT_FIRE_TIME,new BasicDBObject(""String_Node_Str"",new Date(noLaterThan)));
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + maxCount + ""String_Node_Str""+ new Date(noLaterThan));
  }
  List<OperableTrigger> triggers=new ArrayList<OperableTrigger>();
  DBCursor cursor=triggerCollection.find(query);
  BasicDBObject sort=new BasicDBObject();
  sort.put(TRIGGER_NEXT_FIRE_TIME,Integer.valueOf(1));
  cursor.sort(sort);
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + cursor.count() + ""String_Node_Str"");
  }
  while (cursor.hasNext() && maxCount > triggers.size()) {
    DBObject dbObj=cursor.next();
    BasicDBObject lock=new BasicDBObject();
    lock.put(LOCK_KEY_NAME,dbObj.get(KEY_NAME));
    lock.put(LOCK_KEY_GROUP,dbObj.get(KEY_GROUP));
    lock.put(LOCK_INSTANCE_ID,instanceId);
    lock.put(LOCK_TIME,new Date());
    try {
      OperableTrigger trigger=toTrigger(dbObj);
      if (trigger.getNextFireTime() == null) {
        if (log.isDebugEnabled()) {
          log.debug(""String_Node_Str"" + trigger.getKey() + ""String_Node_Str"");
        }
        continue;
      }
      if (applyMisfire(trigger) && trigger.getNextFireTime() == null) {
        if (log.isDebugEnabled()) {
          log.debug(""String_Node_Str"" + trigger.getKey() + ""String_Node_Str"");
        }
        continue;
      }
      log.debug(""String_Node_Str"" + trigger.getKey());
      locksCollection.insert(lock);
      log.debug(""String_Node_Str"" + trigger.getKey());
      triggers.add(trigger);
    }
 catch (    DuplicateKey e) {
      OperableTrigger trigger=toTrigger(dbObj);
      log.debug(""String_Node_Str"" + trigger.getKey() + ""String_Node_Str"");
      lock=new BasicDBObject();
      lock.put(LOCK_KEY_NAME,dbObj.get(KEY_NAME));
      lock.put(LOCK_KEY_GROUP,dbObj.get(KEY_GROUP));
      DBObject existingLock;
      DBCursor lockCursor=locksCollection.find(lock);
      if (lockCursor.hasNext()) {
        existingLock=lockCursor.next();
      }
 else {
        log.warn(""String_Node_Str"");
        return acquireNextTriggers(noLaterThan,maxCount,timeWindow);
      }
      if (isTriggerLockExpired(existingLock)) {
        log.error(""String_Node_Str"" + trigger.getKey() + ""String_Node_Str"");
        removeTriggerLock(trigger);
        return acquireNextTriggers(noLaterThan,maxCount,timeWindow);
      }
    }
  }
  return triggers;
}",0.9982349480290252
9777,"public void pauseJob(JobKey jobKey) throws JobPersistenceException {
}","public void pauseJob(JobKey jobKey) throws JobPersistenceException {
  throw new UnsupportedOperationException();
}",0.7567567567567568
9778,"public Collection<String> pauseTriggers(GroupMatcher<TriggerKey> matcher) throws JobPersistenceException {
}","public Collection<String> pauseTriggers(GroupMatcher<TriggerKey> matcher) throws JobPersistenceException {
  throw new UnsupportedOperationException();
}",0.8275862068965517
9779,"public void pauseTrigger(TriggerKey triggerKey) throws JobPersistenceException {
}","public void pauseTrigger(TriggerKey triggerKey) throws JobPersistenceException {
  throw new UnsupportedOperationException();
}",0.784688995215311
9780,"public OperableTrigger retrieveTrigger(TriggerKey triggerKey) throws JobPersistenceException {
  DBObject dbObject=triggerCollection.findOne(keyAsDBObject(triggerKey));
  if (dbObject == null) {
    throw new JobPersistenceException(""String_Node_Str"" + triggerKey);
  }
  return toTrigger(triggerKey,dbObject);
}","public OperableTrigger retrieveTrigger(TriggerKey triggerKey) throws JobPersistenceException {
  DBObject dbObject=triggerCollection.findOne(keyAsDBObject(triggerKey));
  if (dbObject == null) {
    return null;
  }
  return toTrigger(triggerKey,dbObject);
}",0.8666666666666667
9781,"public void shutdown(){
}","public void shutdown(){
  mongo.close();
}",0.746268656716418
9782,"/** 
 * Called when a file is closed.
 * @param _this {@link FileInputStream},   {@link FileOutputStream}, or   {@link RandomAccessFile}.
 */
public static synchronized void close(Object _this){
  Record r=TABLE.remove(_this);
  if (r != null && TRACE && !tracing) {
    r.dump(""String_Node_Str"",System.err);
    tracing=true;
    r.dump(""String_Node_Str"",System.err);
    tracing=false;
  }
}","/** 
 * Called when a file is closed.
 * @param _this {@link FileInputStream},   {@link FileOutputStream}, or   {@link RandomAccessFile}.
 */
public static synchronized void close(Object _this){
  Record r=TABLE.remove(_this);
  if (r != null && TRACE && !tracing) {
    tracing=true;
    r.dump(""String_Node_Str"",System.err);
    tracing=false;
  }
}",0.9435483870967742
9783,"/** 
 * Sets the necessary height for all bands in the report, to hold their children
 */
protected void setBandsFinalHeight(){
  log.debug(""String_Node_Str"");
  List<JRBand> bands=new ArrayList<JRBand>();
  Utils.addNotNull(bands,(JRDesignBand)design.getPageHeader());
  Utils.addNotNull(bands,(JRDesignBand)design.getPageFooter());
  Utils.addNotNull(bands,(JRDesignBand)design.getColumnHeader());
  Utils.addNotNull(bands,(JRDesignBand)design.getColumnFooter());
  Utils.addNotNull(bands,(JRDesignBand)design.getSummary());
  Utils.addNotNull(bands,(JRDesignBand)design.getBackground());
  bands.addAll(((JRDesignSection)design.getDetailSection()).getBandsList());
  Utils.addNotNull(bands,(JRDesignBand)design.getLastPageFooter());
  Utils.addNotNull(bands,(JRDesignBand)design.getTitle());
  Utils.addNotNull(bands,(JRDesignBand)design.getPageFooter());
  Utils.addNotNull(bands,(JRDesignBand)design.getNoData());
  for (Iterator iter=design.getGroupsList().iterator(); iter.hasNext(); ) {
    JRGroup jrgroup=(JRGroup)iter.next();
    DJGroup djGroup=(DJGroup)getReferencesMap().get(jrgroup.getName());
    JRDesignSection headerSection=(JRDesignSection)jrgroup.getGroupHeaderSection();
    JRDesignSection footerSection=(JRDesignSection)jrgroup.getGroupFooterSection();
    if (djGroup != null) {
      for (      JRBand headerBand : (List<JRBand>)headerSection.getBandsList()) {
        setBandFinalHeight((JRDesignBand)headerBand,djGroup.getHeaderHeight(),djGroup.isFitHeaderHeightToContent());
      }
      for (      JRBand footerBand : (List<JRBand>)footerSection.getBandsList()) {
        setBandFinalHeight((JRDesignBand)footerBand,djGroup.getFooterHeight(),djGroup.isFitHeaderHeightToContent());
      }
    }
 else {
      bands.addAll(headerSection.getBandsList());
      bands.addAll(footerSection.getBandsList());
    }
  }
  for (  JRBand jrDesignBand : bands) {
    setBandFinalHeight((JRDesignBand)jrDesignBand);
  }
}","/** 
 * Sets the necessary height for all bands in the report, to hold their children
 */
protected void setBandsFinalHeight(){
  log.debug(""String_Node_Str"");
  List<JRBand> bands=new ArrayList<JRBand>();
  Utils.addNotNull(bands,(JRDesignBand)design.getPageHeader());
  Utils.addNotNull(bands,(JRDesignBand)design.getPageFooter());
  Utils.addNotNull(bands,(JRDesignBand)design.getColumnHeader());
  Utils.addNotNull(bands,(JRDesignBand)design.getColumnFooter());
  Utils.addNotNull(bands,(JRDesignBand)design.getSummary());
  Utils.addNotNull(bands,(JRDesignBand)design.getBackground());
  bands.addAll(((JRDesignSection)design.getDetailSection()).getBandsList());
  Utils.addNotNull(bands,(JRDesignBand)design.getLastPageFooter());
  Utils.addNotNull(bands,(JRDesignBand)design.getTitle());
  Utils.addNotNull(bands,(JRDesignBand)design.getPageFooter());
  Utils.addNotNull(bands,(JRDesignBand)design.getNoData());
  for (Iterator iter=design.getGroupsList().iterator(); iter.hasNext(); ) {
    JRGroup jrgroup=(JRGroup)iter.next();
    DJGroup djGroup=(DJGroup)getReferencesMap().get(jrgroup.getName());
    JRDesignSection headerSection=(JRDesignSection)jrgroup.getGroupHeaderSection();
    JRDesignSection footerSection=(JRDesignSection)jrgroup.getGroupFooterSection();
    if (djGroup != null) {
      for (      JRBand headerBand : (List<JRBand>)headerSection.getBandsList()) {
        setBandFinalHeight((JRDesignBand)headerBand,djGroup.getHeaderHeight(),djGroup.isFitHeaderHeightToContent());
      }
      for (      JRBand footerBand : (List<JRBand>)footerSection.getBandsList()) {
        setBandFinalHeight((JRDesignBand)footerBand,djGroup.getFooterHeight(),djGroup.isFitFooterHeightToContent());
      }
    }
 else {
      bands.addAll(headerSection.getBandsList());
      bands.addAll(footerSection.getBandsList());
    }
  }
  for (  JRBand jrDesignBand : bands) {
    setBandFinalHeight((JRDesignBand)jrDesignBand);
  }
}",0.8753219989696033
9784,"private JRDesignBand getPositionBand(DJChart djChart){
  JRDesignGroup jgroup=getGroupFromColumnsGroup(djChart.getColumnsGroup());
  JRDesignGroup parentGroup=getParent(jgroup);
  JRDesignBand band;
  if (djChart.getOptions().getPosition() == DJChartOptions.POSITION_FOOTER)   band=(JRDesignBand)((parentGroup.equals(jgroup)) ? getDesign().getSummary() : parentGroup.getGroupFooter());
 else   band=(JRDesignBand)((parentGroup.equals(jgroup)) ? getDesign().getSummary() : parentGroup.getGroupHeader());
  return band;
}","private JRDesignBand getPositionBand(DJChart djChart){
  JRDesignGroup jgroup=getGroupFromColumnsGroup(djChart.getColumnsGroup());
  JRDesignGroup parentGroup=getParent(jgroup);
  JRDesignBand band;
  if (djChart.getOptions().getPosition() == DJChartOptions.POSITION_FOOTER) {
    band=(JRDesignBand)((parentGroup.equals(jgroup)) ? getDesign().getSummary() : parentGroup.getGroupFooter());
  }
 else {
    band=(JRDesignBand)((parentGroup.equals(jgroup)) ? getDesign().getSummary() : parentGroup.getGroupHeader());
  }
  return band;
}",0.9848197343453512
9785,"private JRDesignChart createChart(DJChart djChart){
  JRDesignGroup jrGroup=getGroupFromColumnsGroup(djChart.getColumnsGroup());
  JRDesignChart chart=new JRDesignChart(new JRDesignStyle().getDefaultStyleProvider(),djChart.getType());
  chart.setDataset(DataSetFactory.getDataset(djChart.getType(),jrGroup,getParent(jrGroup),registerChartVariable(djChart)));
  interpeterOptions(djChart,chart);
  return chart;
}","private JRDesignChart createChart(DJChart djChart){
  JRDesignGroup jrGroup=getGroupFromColumnsGroup(djChart.getColumnsGroup());
  JRDesignChart chart=new JRDesignChart(new JRDesignStyle().getDefaultStyleProvider(),djChart.getType());
  chart.setDataset(DataSetFactory.getDataset(djChart.getType(),jrGroup,getParent(jrGroup),registerChartVariable(djChart)));
  interpeterOptions(djChart,chart);
  chart.setEvaluationTime(JRExpression.EVALUATION_TIME_REPORT);
  return chart;
}",0.927927927927928
9786,"private void interpeterOptions(DJChart djChart,JRDesignChart chart){
  DJChartOptions options=djChart.getOptions();
  chart.setX(options.getX());
  chart.setY(options.getY());
  if (options.isCentered())   chart.setWidth(getReport().getOptions().getPrintableWidth());
 else   chart.setWidth(options.getWidth());
  chart.setHeight(options.getHeight());
  chart.setShowLegend(options.isShowLegend());
  chart.setBackcolor(options.getBackColor());
  if (djChart.getType() == DJChart.BAR_CHART)   ((JRDesignBarPlot)chart.getPlot()).setShowTickLabels(options.isShowLabels());
}","private void interpeterOptions(DJChart djChart,JRDesignChart chart){
  DJChartOptions options=djChart.getOptions();
  if (options.isCentered())   chart.setWidth(getReport().getOptions().getPrintableWidth());
 else   chart.setWidth(options.getWidth());
  chart.setHeight(options.getHeight());
  chart.setX(options.getX());
  chart.setPadding(10);
  chart.setY(options.getY());
  arrangeBand(djChart,chart);
  chart.setShowLegend(options.isShowLegend());
  chart.setBackcolor(options.getBackColor());
  chart.setBorder(options.getBorder());
  if (djChart.getType() == DJChart.BAR_CHART)   ((JRDesignBarPlot)chart.getPlot()).setShowTickLabels(options.isShowLabels());
}",0.6478190630048465
9787,"public DJChartOptions(boolean showLegend,Color backColor,int height,int width,boolean centered,byte position,int y,int x,boolean showLabels){
  super();
  this.showLegend=showLegend;
  this.backColor=backColor;
  this.height=height;
  this.width=width;
  this.centered=centered;
  this.position=position;
  this.y=y;
  this.x=x;
  this.showLabels=showLabels;
}","public DJChartOptions(boolean showLegend,Color backColor,int height,int width,boolean centered,byte position,int y,int x,boolean showLabels,byte border){
  super();
  this.showLegend=showLegend;
  this.backColor=backColor;
  this.height=height;
  this.width=width;
  this.centered=centered;
  this.position=position;
  this.y=y;
  this.x=x;
  this.showLabels=showLabels;
  this.border=border;
}",0.9549071618037136
9788,"private DJChartOptions createDefaultOperations(){
  DJChartOptions options=new DJChartOptions(true,Color.white,300,300,true,DJChartOptions.POSITION_FOOTER,20,0,true);
  return options;
}","private DJChartOptions createDefaultOperations(){
  DJChartOptions options=new DJChartOptions(true,Color.white,300,300,true,DJChartOptions.POSITION_HEADER,0,0,true,(byte)1);
  return options;
}",0.9551451187335092
9789,"public DynamicReport buildReport() throws Exception {
  Style detailStyle=new Style();
  Style headerStyle=new Style();
  headerStyle.setFont(Font.ARIAL_MEDIUM_BOLD);
  headerStyle.setBorder(Border.MEDIUM);
  headerStyle.setHorizontalAlign(HorizontalAlign.CENTER);
  headerStyle.setVerticalAlign(VerticalAlign.MIDDLE);
  Style titleStyle=new Style();
  titleStyle.setFont(new Font(18,Font._FONT_VERDANA,true));
  Style importeStyle=new Style();
  importeStyle.setHorizontalAlign(HorizontalAlign.RIGHT);
  Style oddRowStyle=new Style();
  oddRowStyle.setBorder(Border.NO_BORDER);
  oddRowStyle.setBackgroundColor(Color.LIGHT_GRAY);
  oddRowStyle.setTransparency(Transparency.OPAQUE);
  DynamicReportBuilder drb=new DynamicReportBuilder();
  Integer margin=new Integer(20);
  drb.addTitle(""String_Node_Str"").addTitleStyle(titleStyle).addSubtitle(""String_Node_Str"").addDetailHeight(new Integer(15)).addLeftMargin(margin).addRightMargin(margin).addTopMargin(margin).addBottomMargin(margin).addPrintBackgroundOnOddRows(true).addOddRowBackgroundStyle(oddRowStyle).addColumnsPerPage(new Integer(1)).addColumnSpace(new Integer(5));
  AbstractColumn columnState=ColumnBuilder.getInstance().addColumnProperty(""String_Node_Str"",String.class.getName()).addTitle(""String_Node_Str"").addWidth(new Integer(85)).addStyle(detailStyle).addHeaderStyle(headerStyle).build();
  AbstractColumn columnBranch=ColumnBuilder.getInstance().addColumnProperty(""String_Node_Str"",String.class.getName()).addTitle(""String_Node_Str"").addWidth(new Integer(85)).addStyle(detailStyle).addHeaderStyle(headerStyle).build();
  AbstractColumn columnaProductLine=ColumnBuilder.getInstance().addColumnProperty(""String_Node_Str"",String.class.getName()).addTitle(""String_Node_Str"").addWidth(new Integer(85)).addStyle(detailStyle).addHeaderStyle(headerStyle).build();
  AbstractColumn columnaItem=ColumnBuilder.getInstance().addColumnProperty(""String_Node_Str"",String.class.getName()).addTitle(""String_Node_Str"").addWidth(new Integer(85)).addStyle(detailStyle).addHeaderStyle(headerStyle).build();
  AbstractColumn columnCode=ColumnBuilder.getInstance().addColumnProperty(""String_Node_Str"",Long.class.getName()).addTitle(""String_Node_Str"").addWidth(new Integer(40)).addStyle(importeStyle).addHeaderStyle(headerStyle).build();
  AbstractColumn columnaQuantity=ColumnBuilder.getInstance().addColumnProperty(""String_Node_Str"",Long.class.getName()).addTitle(""String_Node_Str"").addWidth(new Integer(80)).addStyle(importeStyle).addHeaderStyle(headerStyle).build();
  AbstractColumn columnAmount=ColumnBuilder.getInstance().addColumnProperty(""String_Node_Str"",Float.class.getName()).addTitle(""String_Node_Str"").addWidth(new Integer(90)).addPattern(""String_Node_Str"").addStyle(importeStyle).addHeaderStyle(headerStyle).build();
  GroupBuilder gb1=new GroupBuilder();
  ColumnsGroup g1=gb1.addCriteriaColumn((PropertyColumn)columnState).addFooterVariable(columnAmount,ColumnsGroupVariableOperation.SUM).addFooterVariable(columnaQuantity,ColumnsGroupVariableOperation.SUM).addGroupLayout(GroupLayout.VALUE_IN_HEADER_WITH_COLNAMES).build();
  GroupBuilder gb2=new GroupBuilder();
  ColumnsGroup g2=gb2.addCriteriaColumn((PropertyColumn)columnBranch).addFooterVariable(columnAmount,ColumnsGroupVariableOperation.SUM).addFooterVariable(columnaQuantity,ColumnsGroupVariableOperation.SUM).build();
  drb.addColumn(columnState);
  drb.addColumn(columnBranch);
  drb.addColumn(columnaProductLine);
  drb.addColumn(columnaItem);
  drb.addColumn(columnCode);
  drb.addColumn(columnaQuantity);
  drb.addColumn(columnAmount);
  drb.addGroup(g1);
  drb.addGroup(g2);
  drb.addUseFullPageWidth(true);
  DJChartBuilder cb=new DJChartBuilder();
  DJChart chart=cb.addType(DJChart.BAR_CHART).addOperation(DJChart.CALCULATION_SUM).addColumnsGroup(g1).addColumn(columnAmount).build();
  drb.addChart(chart);
  DynamicReport dr=drb.build();
  return dr;
}","public DynamicReport buildReport() throws Exception {
  Style detailStyle=new Style();
  Style headerStyle=new Style();
  headerStyle.setFont(Font.ARIAL_MEDIUM_BOLD);
  headerStyle.setBorder(Border.MEDIUM);
  headerStyle.setHorizontalAlign(HorizontalAlign.CENTER);
  headerStyle.setVerticalAlign(VerticalAlign.MIDDLE);
  Style titleStyle=new Style();
  titleStyle.setFont(new Font(18,Font._FONT_VERDANA,true));
  Style importeStyle=new Style();
  importeStyle.setHorizontalAlign(HorizontalAlign.RIGHT);
  Style oddRowStyle=new Style();
  oddRowStyle.setBorder(Border.NO_BORDER);
  oddRowStyle.setBackgroundColor(Color.LIGHT_GRAY);
  oddRowStyle.setTransparency(Transparency.OPAQUE);
  DynamicReportBuilder drb=new DynamicReportBuilder();
  Integer margin=new Integer(20);
  drb.addTitle(""String_Node_Str"").addTitleStyle(titleStyle).addSubtitle(""String_Node_Str"").addDetailHeight(new Integer(15)).addLeftMargin(margin).addRightMargin(margin).addTopMargin(margin).addBottomMargin(margin).addPrintBackgroundOnOddRows(true).addOddRowBackgroundStyle(oddRowStyle).addColumnsPerPage(new Integer(1)).addColumnSpace(new Integer(5));
  AbstractColumn columnState=ColumnBuilder.getInstance().addColumnProperty(""String_Node_Str"",String.class.getName()).addTitle(""String_Node_Str"").addWidth(new Integer(85)).addStyle(detailStyle).addHeaderStyle(headerStyle).build();
  AbstractColumn columnBranch=ColumnBuilder.getInstance().addColumnProperty(""String_Node_Str"",String.class.getName()).addTitle(""String_Node_Str"").addWidth(new Integer(85)).addStyle(detailStyle).addHeaderStyle(headerStyle).build();
  AbstractColumn columnaProductLine=ColumnBuilder.getInstance().addColumnProperty(""String_Node_Str"",String.class.getName()).addTitle(""String_Node_Str"").addWidth(new Integer(85)).addStyle(detailStyle).addHeaderStyle(headerStyle).build();
  AbstractColumn columnaItem=ColumnBuilder.getInstance().addColumnProperty(""String_Node_Str"",String.class.getName()).addTitle(""String_Node_Str"").addWidth(new Integer(85)).addStyle(detailStyle).addHeaderStyle(headerStyle).build();
  AbstractColumn columnCode=ColumnBuilder.getInstance().addColumnProperty(""String_Node_Str"",Long.class.getName()).addTitle(""String_Node_Str"").addWidth(new Integer(40)).addStyle(importeStyle).addHeaderStyle(headerStyle).build();
  AbstractColumn columnaQuantity=ColumnBuilder.getInstance().addColumnProperty(""String_Node_Str"",Long.class.getName()).addTitle(""String_Node_Str"").addWidth(new Integer(80)).addStyle(importeStyle).addHeaderStyle(headerStyle).build();
  AbstractColumn columnAmount=ColumnBuilder.getInstance().addColumnProperty(""String_Node_Str"",Float.class.getName()).addTitle(""String_Node_Str"").addWidth(new Integer(90)).addPattern(""String_Node_Str"").addStyle(importeStyle).addHeaderStyle(headerStyle).build();
  GroupBuilder gb1=new GroupBuilder();
  ColumnsGroup g1=gb1.addCriteriaColumn((PropertyColumn)columnState).addFooterVariable(columnAmount,ColumnsGroupVariableOperation.SUM).addFooterVariable(columnaQuantity,ColumnsGroupVariableOperation.SUM).addGroupLayout(GroupLayout.VALUE_IN_HEADER_WITH_COLNAMES).build();
  GroupBuilder gb2=new GroupBuilder();
  ColumnsGroup g2=gb2.addCriteriaColumn((PropertyColumn)columnBranch).addFooterVariable(columnAmount,ColumnsGroupVariableOperation.SUM).addFooterVariable(columnaQuantity,ColumnsGroupVariableOperation.SUM).build();
  drb.addColumn(columnState);
  drb.addColumn(columnBranch);
  drb.addColumn(columnaProductLine);
  drb.addColumn(columnaItem);
  drb.addColumn(columnCode);
  drb.addColumn(columnaQuantity);
  drb.addColumn(columnAmount);
  drb.addGroup(g1);
  drb.addGroup(g2);
  drb.addUseFullPageWidth(true);
  DJChartBuilder cb=new DJChartBuilder();
  DJChart chart=cb.addType(DJChart.BAR_CHART).addOperation(DJChart.CALCULATION_SUM).addColumnsGroup(g2).addColumn(columnAmount).build();
  drb.addChart(chart);
  DynamicReport dr=drb.build();
  return dr;
}",0.9997422680412372
9790,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int d=Math.min(measure(widthMeasureSpec),measure(heightMeasureSpec));
  setMeasuredDimension(d,d);
  xPosition=(int)getWidth() / 2;
  yPosition=(int)getWidth() / 2;
  buttonRadius=(int)(d / 2 * 0.25);
  joystickRadius=(int)(d / 2 * 0.75);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int d=Math.min(measure(widthMeasureSpec),measure(heightMeasureSpec));
  setMeasuredDimension(d,d);
}",0.7222222222222222
9791,"/** 
 * Gets the current position within this file. All reads and writes take place at the current file pointer position.
 * @return the current offset in bytes from the beginning of the file.
 * @throws IOException if an error occurs while getting the file pointer of this file.
 */
public long getFilePointer() throws IOException {
  return channel.position();
}","/** 
 * Gets the current position within this file. All reads and writes take place at the current file pointer position.
 * @return the current offset in bytes from the beginning of the file.
 * @throws IOException if an error occurs while getting the file pointer of this file.
 */
public long getFilePointer() throws IOException {
  return fd.position;
}",0.9597780859916782
9792,"@Override public Dialog onCreateDialog(Bundle savedInstanceState){
  return new AlertDialog.Builder(getActivity()).setTitle(getString(R.string.vpn_username_dialog_title)).setView(createConnectView()).setPositiveButton(R.string.vpn_connect_button,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      cb.onSuccess(saveUsername.isChecked(),usernameView.getText(),passwordView.getText());
    }
  }
).create();
}","@Override public Dialog onCreateDialog(Bundle savedInstanceState){
  return new AlertDialog.Builder(getActivity()).setTitle(getString(R.string.vpn_username_dialog_title)).setView(createConnectView()).setPositiveButton(R.string.vpn_connect_button,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      ((VpnSettings)getActivity()).doAuthDialogCallback(saveUsername.isChecked(),usernameView.getText().toString(),passwordView.getText().toString());
    }
  }
).create();
}",0.9200394866732478
9793,"@Override public void onClick(DialogInterface dialog,int which){
  cb.onSuccess(saveUsername.isChecked(),usernameView.getText(),passwordView.getText());
}","@Override public void onClick(DialogInterface dialog,int which){
  ((VpnSettings)getActivity()).doAuthDialogCallback(saveUsername.isChecked(),usernameView.getText().toString(),passwordView.getText().toString());
}",0.779291553133515
9794,"public void onClick(DialogInterface dialog,int id){
  try {
    cb.call();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","@Override public void onClick(DialogInterface dialog,int which){
  getActivity().finish();
}",0.5169491525423728
9795,"@Override public Dialog onCreateDialog(Bundle savedInstanceState){
  final TextView text=new TextView(context);
  text.setPadding(10,10,10,10);
  text.setMovementMethod(new ScrollingMovementMethod());
  text.setTextIsSelectable(true);
  if (log != null)   for (  String s : log) {
    text.append(s + ""String_Node_Str"");
  }
 else   text.append(""String_Node_Str"");
  return new AlertDialog.Builder(context).setTitle(R.string.openvpn_log_dialog_title).setIcon(android.R.drawable.ic_dialog_info).setView(text).create();
}","@Override public Dialog onCreateDialog(Bundle savedInstanceState){
  if (savedInstanceState != null)   log=savedInstanceState.getParcelable(""String_Node_Str"");
  final TextView text=new TextView(getActivity());
  text.setPadding(10,10,10,10);
  text.setMovementMethod(new ScrollingMovementMethod());
  text.setTextIsSelectable(true);
  if (log != null)   for (  String s : log) {
    text.append(s + ""String_Node_Str"");
  }
 else   text.append(""String_Node_Str"");
  return new AlertDialog.Builder(getActivity()).setTitle(R.string.openvpn_log_dialog_title).setIcon(android.R.drawable.ic_dialog_info).setView(text).create();
}",0.8836395450568679
9796,"@Override protected void loadExtraPreferencesTo(Activity activity,PreferenceGroup subpanel){
  final Context c=subpanel.getContext();
  final OpenvpnProfile profile=(OpenvpnProfile)getProfile();
  mUserAuth=new CheckBoxPreference(c);
  mUserAuth.setTitle(R.string.vpn_openvpn_userauth);
  mUserAuth.setSummary(R.string.vpn_openvpn_userauth_summary);
  mUserAuth.setChecked(profile.getUserAuth());
  mUserAuth.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener(){
    public boolean onPreferenceChange(    Preference pref,    Object newValue){
      boolean enabled=(Boolean)newValue;
      profile.setUserAuth(enabled);
      mUserAuth.setChecked(enabled);
      return true;
    }
  }
);
  subpanel.addPreference(mUserAuth);
  mCert=new CertChoosePreference(c);
  mCert.setTitle(R.string.vpn_ca_certificate);
  if (profile.getCertName() != null) {
    Certificate cert=parseCert(profile.getCertName());
    if (cert != null)     mCert.setSummary(cert.toString());
  }
 else {
    mCert.setSummary(R.string.vpn_ca_certificate_title);
  }
  mCert.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener(){
    @Override public boolean onPreferenceChange(    Preference pref,    Object newValue){
      Certificate cert=(Certificate)newValue;
      try {
        KeyStore ks=KeyStore.getInstance(""String_Node_Str"");
        ks.load(null,null);
        ks.setCertificateEntry(""String_Node_Str"",cert);
        ByteArrayOutputStream out=new ByteArrayOutputStream();
        ks.store(out,null);
        profile.setCertName(out.toByteArray());
        ((Activity)c).runOnUiThread(new RunnableEx<String>(cert.toString()){
          @Override public void run(          String cert){
            mCert.setSummary(cert);
          }
        }
);
      }
 catch (      KeyStoreException e) {
        e.printStackTrace();
      }
catch (      NoSuchAlgorithmException e) {
        e.printStackTrace();
      }
catch (      CertificateException e) {
        e.printStackTrace();
      }
catch (      IOException e) {
        e.printStackTrace();
      }
      return true;
    }
  }
);
  mCert.setOnPreferenceClickListener(new FileChooseClickListener(activity));
  subpanel.addPreference(mCert);
  mUserCert=new KeyChoosePreference(c);
  mUserCert.setTitle(R.string.vpn_user_certificate);
  if (profile.getUserCertName() == null) {
    mUserCert.setSummary(R.string.vpn_user_certificate_title);
  }
 else {
    mUserCert.setSummary(profile.getUserCertName());
  }
  mUserCert.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener(){
    @Override public boolean onPreferenceChange(    Preference pref,    Object newValue){
      String alias=(String)newValue;
      profile.setUserCertName(alias);
      ((Activity)c).runOnUiThread(new RunnableEx<String>(alias){
        @Override public void run(        String alias){
          mUserCert.setSummary(alias);
        }
      }
);
      return true;
    }
  }
);
  subpanel.addPreference(mUserCert);
}","@Override protected void loadExtraPreferencesTo(Activity activity,PreferenceGroup subpanel){
  final Context c=subpanel.getContext();
  final OpenvpnProfile profile=(OpenvpnProfile)getProfile();
  mUserAuth=new CheckBoxPreference(c);
  mUserAuth.setTitle(R.string.vpn_openvpn_userauth);
  mUserAuth.setSummary(R.string.vpn_openvpn_userauth_summary);
  mUserAuth.setChecked(profile.getUserAuth());
  mUserAuth.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener(){
    public boolean onPreferenceChange(    Preference pref,    Object newValue){
      boolean enabled=(Boolean)newValue;
      profile.setUserAuth(enabled);
      mUserAuth.setChecked(enabled);
      return true;
    }
  }
);
  subpanel.addPreference(mUserAuth);
  mCert=new CertChoosePreference(c);
  mCert.setTitle(R.string.vpn_ca_certificate);
  if (profile.getCertName() != null) {
    Certificate cert=parseCert(profile.getCertName());
    if (cert != null)     mCert.setSummary(cert.toString());
  }
 else {
    mCert.setSummary(R.string.vpn_ca_certificate_title);
  }
  mCert.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener(){
    @Override public boolean onPreferenceChange(    Preference pref,    Object newValue){
      Certificate cert=(Certificate)newValue;
      try {
        KeyStore ks=KeyStore.getInstance(""String_Node_Str"");
        ks.load(null,null);
        ks.setCertificateEntry(""String_Node_Str"",cert);
        ByteArrayOutputStream out=new ByteArrayOutputStream();
        ks.store(out,null);
        profile.setCertName(out.toByteArray());
        ((Activity)c).runOnUiThread(new RunnableEx<String>(cert.toString()){
          @Override public void run(          String cert){
            mCert.setSummary(cert);
          }
        }
);
      }
 catch (      Exception e) {
        throw new RuntimeException(e);
      }
      return true;
    }
  }
);
  mCert.setOnPreferenceClickListener(new FileChooseClickListener(activity));
  subpanel.addPreference(mCert);
  mUserCert=new KeyChoosePreference(c);
  mUserCert.setTitle(R.string.vpn_user_certificate);
  if (profile.getUserCertName() == null) {
    mUserCert.setSummary(R.string.vpn_user_certificate_title);
  }
 else {
    mUserCert.setSummary(profile.getUserCertName());
  }
  mUserCert.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener(){
    @Override public boolean onPreferenceChange(    Preference pref,    Object newValue){
      String alias=(String)newValue;
      profile.setUserCertName(alias);
      ((Activity)c).runOnUiThread(new RunnableEx<String>(alias){
        @Override public void run(        String alias){
          mUserCert.setSummary(alias);
        }
      }
);
      return true;
    }
  }
);
  subpanel.addPreference(mUserCert);
}",0.9550425273390036
9797,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  this.requestWindowFeature(Window.FEATURE_PROGRESS);
  this.mThreadImagesService=Factory.getContainer().resolve(ThreadImagesService.class);
  this.mCacheDirectoryManager=Factory.getContainer().resolve(ICacheDirectoryManager.class);
  this.mApplicationSettings=Factory.getContainer().resolve(ApplicationSettings.class);
  String imageUrl=this.getIntent().getData().toString();
  this.mThreadUri=this.getIntent().getExtras().getString(Constants.EXTRA_THREAD_URL);
  ArrayList<ThreadImageModel> images=this.mThreadImagesService.getImagesList(this.mThreadUri);
  ThreadImageModel currentImage=this.mThreadImagesService.getImageByUrl(images,imageUrl);
  int imagePosition=images.indexOf(currentImage);
  this.setTheme(this.mApplicationSettings.getTheme());
  this.setContentView(R.layout.image_gallery_view);
  this.mImageText=(TextView)this.findViewById(R.id.image_gallery_text);
  this.mBackgroundColor=AppearanceUtils.getThemeColor(this.getTheme(),R.styleable.Theme_activityRootBackground);
  final ImageGalleryAdapter adapter=new ImageGalleryAdapter(this,images);
  final ExtendedViewPager viewPager=(ExtendedViewPager)this.findViewById(R.id.view_pager);
  viewPager.setAdapter(adapter);
  adapter.subscribeToPageChangeEvent(viewPager);
  viewPager.setCurrentItem(imagePosition);
  ImageButton prevImageButton=(ImageButton)this.findViewById(R.id.image_gallery_prev);
  prevImageButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View arg0){
      viewPager.movePrevious();
    }
  }
);
  ImageButton nextImageButton=(ImageButton)this.findViewById(R.id.image_gallery_next);
  nextImageButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View arg0){
      viewPager.moveNext();
    }
  }
);
  IWebsite website=Websites.fromUri(Uri.parse(imageUrl));
  if (website != null) {
    Factory.resolve(MyTracker.class).setBoardVar(website.getUrlParser().getBoardName(Uri.parse(imageUrl)));
  }
 else {
    Factory.resolve(MyTracker.class).setBoardVar(""String_Node_Str"");
  }
  Factory.resolve(MyTracker.class).trackActivityView(TAG);
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  this.requestWindowFeature(Window.FEATURE_PROGRESS);
  this.mThreadImagesService=Factory.getContainer().resolve(ThreadImagesService.class);
  this.mCacheDirectoryManager=Factory.getContainer().resolve(ICacheDirectoryManager.class);
  this.mApplicationSettings=Factory.getContainer().resolve(ApplicationSettings.class);
  String imageUrl=this.getIntent().getData().toString();
  this.mThreadUri=this.getIntent().getStringExtra(Constants.EXTRA_THREAD_URL);
  ArrayList<ThreadImageModel> images=this.mThreadImagesService.getImagesList(this.mThreadUri);
  if (images.size() == 0) {
    ThreadImageModel singleImage=new ThreadImageModel();
    singleImage.url=imageUrl;
    images.add(singleImage);
  }
  ThreadImageModel currentImage=this.mThreadImagesService.getImageByUrl(images,imageUrl);
  int imagePosition=images.indexOf(currentImage);
  this.setTheme(this.mApplicationSettings.getTheme());
  this.setContentView(R.layout.image_gallery_view);
  this.mImageText=(TextView)this.findViewById(R.id.image_gallery_text);
  this.mBackgroundColor=AppearanceUtils.getThemeColor(this.getTheme(),R.styleable.Theme_activityRootBackground);
  final ImageGalleryAdapter adapter=new ImageGalleryAdapter(this,images);
  final ExtendedViewPager viewPager=(ExtendedViewPager)this.findViewById(R.id.view_pager);
  viewPager.setAdapter(adapter);
  adapter.subscribeToPageChangeEvent(viewPager);
  viewPager.setCurrentItem(imagePosition);
  ImageButton prevImageButton=(ImageButton)this.findViewById(R.id.image_gallery_prev);
  prevImageButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View arg0){
      viewPager.movePrevious();
    }
  }
);
  ImageButton nextImageButton=(ImageButton)this.findViewById(R.id.image_gallery_next);
  nextImageButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View arg0){
      viewPager.moveNext();
    }
  }
);
  IWebsite website=Websites.fromUri(Uri.parse(imageUrl));
  if (website != null) {
    Factory.resolve(MyTracker.class).setBoardVar(website.getUrlParser().getBoardName(Uri.parse(imageUrl)));
  }
 else {
    Factory.resolve(MyTracker.class).setBoardVar(""String_Node_Str"");
  }
  Factory.resolve(MyTracker.class).trackActivityView(TAG);
}",0.9632724873542996
9798,"private void updateOptionsMenu(){
  if (this.mMenu == null) {
    return;
  }
  MenuItem saveMenuItem=this.mMenu.findItem(R.id.save_menu_id);
  MenuItem shareMenuItem=this.mMenu.findItem(R.id.share_menu_id);
  MenuItem refreshMenuItem=this.mMenu.findItem(R.id.refresh_menu_id);
  MenuItem playVideoMenuItem=this.mMenu.findItem(R.id.play_video_menu_id);
  MenuItem searchTineyeMenuItem=this.mMenu.findItem(R.id.menu_search_tineye_id);
  MenuItem searchGoogleMenuItem=this.mMenu.findItem(R.id.menu_search_google_id);
  MenuItem imageOpsMenuItem=this.mMenu.findItem(R.id.menu_image_operations_id);
  saveMenuItem.setVisible(this.mImageLoaded);
  shareMenuItem.setVisible(this.mImageLoaded);
  refreshMenuItem.setVisible(!this.mImageLoaded);
  if (this.mCurrentImageModel != null) {
    playVideoMenuItem.setVisible(this.mImageLoaded && this.mCurrentImageModel.attachment.isVideo());
    searchTineyeMenuItem.setVisible(this.mCurrentImageModel.attachment.isImage());
    searchGoogleMenuItem.setVisible(this.mCurrentImageModel.attachment.isImage());
    imageOpsMenuItem.setVisible(this.mCurrentImageModel.attachment.isImage());
  }
 else {
    playVideoMenuItem.setVisible(false);
    searchTineyeMenuItem.setVisible(false);
    searchGoogleMenuItem.setVisible(false);
    imageOpsMenuItem.setVisible(false);
  }
}","private void updateOptionsMenu(){
  if (this.mMenu == null) {
    return;
  }
  MenuItem saveMenuItem=this.mMenu.findItem(R.id.save_menu_id);
  MenuItem shareMenuItem=this.mMenu.findItem(R.id.share_menu_id);
  MenuItem refreshMenuItem=this.mMenu.findItem(R.id.refresh_menu_id);
  MenuItem playVideoMenuItem=this.mMenu.findItem(R.id.play_video_menu_id);
  MenuItem searchTineyeMenuItem=this.mMenu.findItem(R.id.menu_search_tineye_id);
  MenuItem searchGoogleMenuItem=this.mMenu.findItem(R.id.menu_search_google_id);
  MenuItem imageOpsMenuItem=this.mMenu.findItem(R.id.menu_image_operations_id);
  saveMenuItem.setVisible(this.mImageLoaded);
  shareMenuItem.setVisible(this.mImageLoaded);
  refreshMenuItem.setVisible(!this.mImageLoaded);
  if (this.mCurrentImageModel != null) {
    boolean isImageUrl=UriUtils.isImageUri(Uri.parse(this.mCurrentImageModel.url));
    boolean isVideoUrl=UriUtils.isWebmUri(Uri.parse(this.mCurrentImageModel.url));
    playVideoMenuItem.setVisible(this.mImageLoaded && isVideoUrl);
    searchTineyeMenuItem.setVisible(isImageUrl);
    searchGoogleMenuItem.setVisible(isImageUrl);
    imageOpsMenuItem.setVisible(isImageUrl);
  }
 else {
    playVideoMenuItem.setVisible(false);
    searchTineyeMenuItem.setVisible(false);
    searchGoogleMenuItem.setVisible(false);
    imageOpsMenuItem.setVisible(false);
  }
}",0.8239728609121749
9799,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.open_browser_menu_id:
    BrowserLauncher.launchExternalBrowser(this,this.mCurrentImageModel.url.toString());
  break;
case R.id.save_menu_id:
new DownloadFileTask(this,Uri.parse(this.mCurrentImageModel.url)).execute();
break;
case R.id.refresh_menu_id:
if (this.mCurrentImageViewBag != null) {
this.loadImage(this.mCurrentImageModel,this.mCurrentImageViewBag);
}
break;
case R.id.play_video_menu_id:
File cachedFile=this.mCacheDirectoryManager.getCachedImageFileForRead(Uri.parse(this.mCurrentImageModel.url));
if (cachedFile.exists()) {
BrowserLauncher.playVideoExternal(cachedFile,this);
}
break;
case R.id.share_menu_id:
Intent shareImageIntent=new Intent(Intent.ACTION_SEND);
if (this.mCurrentImageModel.attachment.isImage()) {
shareImageIntent.setType(""String_Node_Str"");
}
 else if (this.mCurrentImageModel.attachment.isVideo()) {
shareImageIntent.setType(""String_Node_Str"");
}
shareImageIntent.putExtra(Intent.EXTRA_STREAM,Uri.fromFile(this.mImageLoadedFile));
this.startActivity(Intent.createChooser(shareImageIntent,this.getString(R.string.share_via)));
break;
case R.id.share_link_menu_id:
if (this.mCurrentImageModel != null && this.mCurrentImageModel.url != null) {
Intent shareLinkIntent=new Intent(Intent.ACTION_SEND);
shareLinkIntent.setType(""String_Node_Str"");
shareLinkIntent.putExtra(Intent.EXTRA_SUBJECT,this.mCurrentImageModel.url.toString());
shareLinkIntent.putExtra(Intent.EXTRA_TEXT,this.mCurrentImageModel.url.toString());
this.startActivity(Intent.createChooser(shareLinkIntent,this.getString(R.string.share_via)));
}
break;
case R.id.menu_search_tineye_id:
String tineyeSearchUrl=""String_Node_Str"" + this.mCurrentImageModel.url;
BrowserLauncher.launchExternalBrowser(this.getApplicationContext(),tineyeSearchUrl);
break;
case R.id.menu_search_google_id:
String googleSearchUrl=""String_Node_Str"" + this.mCurrentImageModel.url;
BrowserLauncher.launchExternalBrowser(this.getApplicationContext(),googleSearchUrl);
break;
case R.id.menu_image_operations_id:
String imageOpsUrl=""String_Node_Str"" + this.mCurrentImageModel.url;
BrowserLauncher.launchExternalBrowser(this.getApplicationContext(),imageOpsUrl);
break;
}
return true;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.open_browser_menu_id:
    BrowserLauncher.launchExternalBrowser(this,this.mCurrentImageModel.url.toString());
  break;
case R.id.save_menu_id:
new DownloadFileTask(this,Uri.parse(this.mCurrentImageModel.url)).execute();
break;
case R.id.refresh_menu_id:
if (this.mCurrentImageViewBag != null) {
this.loadImage(this.mCurrentImageModel,this.mCurrentImageViewBag);
}
break;
case R.id.play_video_menu_id:
File cachedFile=this.mCacheDirectoryManager.getCachedImageFileForRead(Uri.parse(this.mCurrentImageModel.url));
if (cachedFile.exists()) {
BrowserLauncher.playVideoExternal(cachedFile,this);
}
break;
case R.id.share_menu_id:
if (this.mImageLoadedFile == null) {
break;
}
Uri fileUri=Uri.fromFile(this.mImageLoadedFile);
Intent shareImageIntent=new Intent(Intent.ACTION_SEND);
if (UriUtils.isImageUri(fileUri)) {
shareImageIntent.setType(""String_Node_Str"");
}
 else if (UriUtils.isWebmUri(fileUri)) {
shareImageIntent.setType(""String_Node_Str"");
}
shareImageIntent.putExtra(Intent.EXTRA_STREAM,fileUri);
this.startActivity(Intent.createChooser(shareImageIntent,this.getString(R.string.share_via)));
break;
case R.id.share_link_menu_id:
Intent shareLinkIntent=new Intent(Intent.ACTION_SEND);
shareLinkIntent.setType(""String_Node_Str"");
shareLinkIntent.putExtra(Intent.EXTRA_SUBJECT,this.mCurrentImageModel.url.toString());
shareLinkIntent.putExtra(Intent.EXTRA_TEXT,this.mCurrentImageModel.url.toString());
this.startActivity(Intent.createChooser(shareLinkIntent,this.getString(R.string.share_via)));
break;
case R.id.menu_search_tineye_id:
String tineyeSearchUrl=""String_Node_Str"" + this.mCurrentImageModel.url;
BrowserLauncher.launchExternalBrowser(this.getApplicationContext(),tineyeSearchUrl);
break;
case R.id.menu_search_google_id:
String googleSearchUrl=""String_Node_Str"" + this.mCurrentImageModel.url;
BrowserLauncher.launchExternalBrowser(this.getApplicationContext(),googleSearchUrl);
break;
case R.id.menu_image_operations_id:
String imageOpsUrl=""String_Node_Str"" + this.mCurrentImageModel.url;
BrowserLauncher.launchExternalBrowser(this.getApplicationContext(),imageOpsUrl);
break;
}
return true;
}",0.921594982078853
9800,"private void loadImage(ThreadImageModel model,GalleryItemViewBag viewBag){
  if (!model.attachment.isDisplayableInGallery() || (model.attachment.isVideo() && this.mApplicationSettings.isExternalVideoPlayer()) || (model.attachment.isVideo() && Constants.SDK_VERSION < 10)) {
    this.setThumbnail(model.attachment,viewBag);
    return;
  }
  if (this.mCurrentTask != null) {
    this.mCurrentTask.cancel(true);
  }
  this.mImageLoaded=false;
  this.mImageLoadedFile=null;
  this.mCurrentImageModel=model;
  this.mCurrentImageViewBag=viewBag;
  this.updateOptionsMenu();
  Uri uri=Uri.parse(model.url);
  File cachedFile=this.mCacheDirectoryManager.getCachedImageFileForRead(uri);
  if (cachedFile.exists()) {
    this.setProgress(Window.PROGRESS_END);
    this.setImage(cachedFile,viewBag);
  }
 else {
    File writeCachedFile=this.mCacheDirectoryManager.getCachedImageFileForWrite(uri);
    this.mCurrentTask=new DownloadFileTask(this,uri,writeCachedFile,new ImageDownloadView(viewBag),false);
    this.mCurrentTask.execute();
  }
}","private void loadImage(ThreadImageModel model,GalleryItemViewBag viewBag){
  if (UriUtils.isWebmUri(Uri.parse(model.url)) && this.mApplicationSettings.isExternalVideoPlayer()) {
    if (model.attachment != null) {
      this.setThumbnail(model.attachment,viewBag);
    }
 else {
      viewBag.switchToErrorView(this.getString(R.string.error_video_playing));
    }
    return;
  }
  if (this.mCurrentTask != null) {
    this.mCurrentTask.cancel(true);
  }
  this.mImageLoaded=false;
  this.mImageLoadedFile=null;
  this.mCurrentImageModel=model;
  this.mCurrentImageViewBag=viewBag;
  this.updateOptionsMenu();
  Uri uri=Uri.parse(model.url);
  File cachedFile=this.mCacheDirectoryManager.getCachedImageFileForRead(uri);
  if (cachedFile.exists()) {
    this.setProgress(Window.PROGRESS_END);
    this.setImage(cachedFile,viewBag);
  }
 else {
    File writeCachedFile=this.mCacheDirectoryManager.getCachedImageFileForWrite(uri);
    this.mCurrentTask=new DownloadFileTask(this,uri,writeCachedFile,new ImageDownloadView(viewBag),false);
    this.mCurrentTask.execute();
  }
}",0.8533459895586142
9801,"private void setImage(File file,GalleryItemViewBag viewBag){
  if (this.mCurrentImageModel.attachment.isImage()) {
    AppearanceUtils.setImage(file,this,viewBag.layout,ImageGalleryActivity.this.mBackgroundColor);
  }
 else   if (this.mCurrentImageModel.attachment.isVideo()) {
    AppearanceUtils.setVideoFile(file,this,viewBag);
  }
  this.mImageLoaded=true;
  this.mImageLoadedFile=file;
  this.updateOptionsMenu();
}","private void setImage(File file,GalleryItemViewBag viewBag){
  if (UriUtils.isImageUri(Uri.fromFile(file))) {
    AppearanceUtils.setImage(file,this,viewBag.layout,ImageGalleryActivity.this.mBackgroundColor);
  }
 else   if (UriUtils.isWebmUri(Uri.fromFile(file))) {
    AppearanceUtils.setVideoFile(file,this,viewBag);
  }
  this.mImageLoaded=true;
  this.mImageLoadedFile=file;
  this.updateOptionsMenu();
}",0.8057901085645356
9802,"@Override public void updateData(String from,PostModel[] posts){
  if (posts == null) {
    showToastIfVisible(PostsListActivity.this.getResources().getString(R.string.notification_no_new_posts));
    return;
  }
  int addedCount=PostsListActivity.this.mAdapter.updateAdapterData(from,posts);
  if (addedCount != 0) {
    mSerializationService.serializePosts(mWebsite.name(),mBoardName,mThreadNumber,mAdapter.getOriginalPosts());
    showToastIfVisible(PostsListActivity.this.getResources().getQuantityString(R.plurals.data_new_posts_quantity,addedCount,addedCount));
  }
 else {
    showToastIfVisible(PostsListActivity.this.getResources().getString(R.string.notification_no_new_posts));
  }
}","@Override public void updateData(int from,PostModel[] posts){
  if (posts == null) {
    showToastIfVisible(PostsListActivity.this.getResources().getString(R.string.notification_no_new_posts));
    return;
  }
  int addedCount=PostsListActivity.this.mAdapter.updateAdapterData(from,posts);
  if (addedCount != 0) {
    mSerializationService.serializePosts(mWebsite.name(),mBoardName,mThreadNumber,mAdapter.getOriginalPosts());
    showToastIfVisible(PostsListActivity.this.getResources().getQuantityString(R.plurals.data_new_posts_quantity,addedCount,addedCount));
  }
 else {
    showToastIfVisible(PostsListActivity.this.getResources().getString(R.string.notification_no_new_posts));
  }
}",0.9935018050541516
9803,"/** 
 *     
 */
public String getLastPostNumber(){
  return this.mPostsViewModel.getLastPostNumber();
}","/** 
 *     
 */
public int getLastPostNumber(){
  return this.mPostsViewModel.getLastPostNumber();
}",0.9816849816849816
9804,"public int updateAdapterData(String from,PostModel[] posts){
  Integer lastPostNumber;
  try {
    lastPostNumber=!StringUtils.isEmpty(from) ? Integer.valueOf(from) : 0;
  }
 catch (  NumberFormatException e) {
    lastPostNumber=0;
  }
  ArrayList<PostModel> newPosts=new ArrayList<PostModel>();
  for (  PostModel pi : posts) {
    Integer currentNumber=!StringUtils.isEmpty(pi.getNumber()) ? Integer.parseInt(pi.getNumber()) : 0;
    if (currentNumber > lastPostNumber) {
      newPosts.add(pi);
    }
  }
  List<PostItemViewModel> newModels=this.mPostsViewModel.addModels(newPosts,this.mTheme,this,this.mActivity.getResources());
  for (  PostItemViewModel model : newModels) {
    for (int i=0; i < 4; ++i) {
      AttachmentInfo attachment=model.getAttachment(i);
      this.mThreadImagesService.addThreadImage(this.mUri,attachment);
    }
    this.insert(model,this.getCount() - 1);
  }
  this.mOriginalPosts.addAll(newPosts);
  if (newPosts.size() > 0) {
    this.notifyDataSetChanged();
  }
  return newPosts.size();
}","public int updateAdapterData(int from,PostModel[] posts){
  ArrayList<PostModel> newPosts=new ArrayList<PostModel>();
  for (  PostModel pi : posts) {
    Integer currentNumber=!StringUtils.isEmpty(pi.getNumber()) ? Integer.parseInt(pi.getNumber()) : 0;
    if (currentNumber > from) {
      newPosts.add(pi);
    }
  }
  List<PostItemViewModel> newModels=this.mPostsViewModel.addModels(newPosts,this.mTheme,this,this.mActivity.getResources());
  for (  PostItemViewModel model : newModels) {
    for (int i=0; i < 4; ++i) {
      AttachmentInfo attachment=model.getAttachment(i);
      this.mThreadImagesService.addThreadImage(this.mUri,attachment);
    }
    this.insert(model,this.getCount() - 1);
  }
  this.mOriginalPosts.addAll(newPosts);
  if (newPosts.size() > 0) {
    this.notifyDataSetChanged();
  }
  return newPosts.size();
}",0.6991957104557641
9805,"@Override protected Boolean doInBackground(String... params){
  if (params.length > 0) {
    this.mLoadAfterPost=params[0];
  }
 else {
    this.mLoadAfterPost=null;
  }
  try {
    this.mPostsList=this.mJsonReader.readPostsList(this.mBoard,this.mThreadNumber,this.mLoadAfterPost,this.mIsCheckModified,this,this);
    return true;
  }
 catch (  Exception e) {
    this.mUserError=e.getMessage();
  }
  return false;
}","@Override protected Boolean doInBackground(Integer... params){
  if (params.length > 0) {
    this.mLoadAfterPost=params[0];
  }
  try {
    this.mPostsList=this.mJsonReader.readPostsList(this.mBoard,this.mThreadNumber,this.mLoadAfterPost,this.mIsCheckModified,this,this);
    return true;
  }
 catch (  Exception e) {
    this.mUserError=e.getMessage();
  }
  return false;
}",0.9306431273644388
9806,"@Override public PostModel[] readPostsList(String boardName,String threadNumber,String fromNumber,boolean checkModified,IJsonProgressChangeListener listener,ICancelled task) throws JsonApiReaderException, HtmlNotJsonException {
  String uri=this.mFourchanUriBuilder.getThreadUrlApi(boardName,threadNumber);
  JsonNode json=this.mJsonReader.readData(uri,checkModified,listener,task);
  if (json == null) {
    return null;
  }
  FourchanThreadInfo result=parseDataOrThrowError(json,FourchanThreadInfo.class);
  PostModel[] models=this.mFourchanModelsMapper.mapThreadModel(result).getPosts();
  return models;
}","@Override public PostModel[] readPostsList(String boardName,String threadNumber,int fromNumber,boolean checkModified,IJsonProgressChangeListener listener,ICancelled task) throws JsonApiReaderException, HtmlNotJsonException {
  String uri=this.mFourchanUriBuilder.getThreadUrlApi(boardName,threadNumber);
  JsonNode json=this.mJsonReader.readData(uri,checkModified,listener,task);
  if (json == null) {
    return null;
  }
  FourchanThreadInfo result=parseDataOrThrowError(json,FourchanThreadInfo.class);
  PostModel[] models=this.mFourchanModelsMapper.mapThreadModel(result).getPosts();
  return models;
}",0.9925925925925926
9807,"@Override public PostModel[] readPostsList(String boardName,String threadNumber,String fromNumber,boolean checkModified,IJsonProgressChangeListener listener,ICancelled task) throws JsonApiReaderException, HtmlNotJsonException {
  String uri=this.mApplicationSettings.isMobileApi() ? this.mMakabaUriBuilder.getThreadUrlExtendedApi(boardName,threadNumber,fromNumber) : this.mMakabaUriBuilder.getThreadUrlApi(boardName,threadNumber);
  JsonNode json=this.mJsonReader.readData(uri,checkModified,listener,task);
  if (json == null) {
    return null;
  }
  MakabaPostInfo[] data=null;
  if (this.mApplicationSettings.isMobileApi()) {
    data=this.parseDataOrThrowError(json,MakabaPostInfo[].class);
  }
 else {
    data=this.parseDataOrThrowError(json,MakabaThreadsList.class).threads[0].posts;
  }
  PostModel[] models=this.mMakabaModelsMapper.mapPostModels(data);
  return models;
}","@Override public PostModel[] readPostsList(String boardName,String threadNumber,int fromNumber,boolean checkModified,IJsonProgressChangeListener listener,ICancelled task) throws JsonApiReaderException, HtmlNotJsonException {
  boolean isExtendedUrl=this.mApplicationSettings.isMobileApi() && fromNumber != 0;
  String uri=isExtendedUrl ? this.mMakabaUriBuilder.getThreadUrlExtendedApi(boardName,threadNumber,fromNumber + ""String_Node_Str"") : this.mMakabaUriBuilder.getThreadUrlApi(boardName,threadNumber);
  JsonNode json=this.mJsonReader.readData(uri,checkModified,listener,task);
  if (json == null) {
    return null;
  }
  MakabaPostInfo[] data=null;
  if (isExtendedUrl) {
    data=this.parseDataOrThrowError(json,MakabaPostInfo[].class);
  }
 else {
    data=this.parseDataOrThrowError(json,MakabaThreadsList.class).threads[0].posts;
  }
  PostModel[] models=this.mMakabaModelsMapper.mapPostModels(data);
  return models;
}",0.8723051409618574
9808,"PostModel[] readPostsList(String boardName,String threadNumber,String fromNumber,boolean checkModified,IJsonProgressChangeListener listener,ICancelled task) throws JsonApiReaderException, HtmlNotJsonException ;","PostModel[] readPostsList(String boardName,String threadNumber,int fromNumber,boolean checkModified,IJsonProgressChangeListener listener,ICancelled task) throws JsonApiReaderException, HtmlNotJsonException ;",0.9784172661870504
9809,"/** 
 *         
 * @param from ,     
 * @param list  
 */
void updateData(String from,PostModel[] posts);","/** 
 *         
 * @param from ,     
 * @param posts  
 */
void updateData(int from,PostModel[] posts);",0.9675925925925926
9810,"public boolean isVideo(){
  return ""String_Node_Str"".equalsIgnoreCase(this.mSourceExtension);
}","public boolean isVideo(){
  return this.mImageUrl != null && UriUtils.isWebmUri(Uri.parse(this.mImageUrl));
}",0.5588235294117647
9811,"public boolean isImage(){
  return !StringUtils.isEmpty(this.mSourceExtension) && Constants.IMAGE_EXTENSIONS.contains(this.mSourceExtension);
}","public boolean isImage(){
  return this.mImageUrl != null && UriUtils.isImageUri(Uri.parse(this.mImageUrl));
}",0.4822134387351778
9812,"/** 
 *      
 */
public String getLastPostNumber(){
  return this.mLastPostNumber;
}","/** 
 *      
 */
public int getLastPostNumber(){
  return this.mLastPostNumber;
}",0.979757085020243
9813,"private PostItemViewModel addModel(PostModel item,Theme theme,IURLSpanClickListener listener){
  PostItemViewModel viewModel=new PostItemViewModel(this.mWebsite,this.mBoardName,this.mThreadNumber,this.mViewModels.size(),item,theme,listener);
  this.mViewModels.put(viewModel.getNumber(),viewModel);
  this.mLastPostNumber=viewModel.getNumber();
  this.processReferences(viewModel);
  return viewModel;
}","private PostItemViewModel addModel(PostModel item,Theme theme,IURLSpanClickListener listener){
  PostItemViewModel viewModel=new PostItemViewModel(this.mWebsite,this.mBoardName,this.mThreadNumber,this.mViewModels.size(),item,theme,listener);
  this.mViewModels.put(viewModel.getNumber(),viewModel);
  this.mLastPostNumber=Math.max(Integer.parseInt(viewModel.getNumber()),this.mLastPostNumber);
  this.processReferences(viewModel);
  return viewModel;
}",0.9005847953216374
9814,"public boolean isExternalVideoPlayer(){
  return this.mSettings.getBoolean(this.mResources.getString(R.string.pref_external_video_key),false);
}","public boolean isExternalVideoPlayer(){
  return Constants.SDK_VERSION < 10 || this.mSettings.getBoolean(this.mResources.getString(R.string.pref_external_video_key),false);
}",0.9056603773584906
9815,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  width=MeasureSpec.getSize(widthMeasureSpec);
  height=MeasureSpec.getSize(heightMeasureSpec);
  float scaleX=(float)width / (float)bmWidth;
  float scaleY=(float)height / (float)bmHeight;
  float scale=Math.min(scaleX,scaleY);
  defaultScale=Math.min(cDefaultScale,scale);
  defaultScale*=3;
  minScale=Math.min(cMinScale,scale) / defaultScale;
  maxScale=cMaxScale / defaultScale;
  matrix.setScale(defaultScale,defaultScale);
  setImageMatrix(matrix);
  saveScale=1f;
  redundantYSpace=(float)height - (defaultScale * (float)bmHeight);
  redundantXSpace=(float)width - (defaultScale * (float)bmWidth);
  redundantYSpace/=(float)2;
  redundantXSpace/=(float)2;
  matrix.postTranslate(redundantXSpace,redundantYSpace);
  origWidth=width - 2 * redundantXSpace;
  origHeight=height - 2 * redundantYSpace;
  right=width * saveScale - width - (2 * redundantXSpace * saveScale);
  bottom=height * saveScale - height - (2 * redundantYSpace * saveScale);
  setImageMatrix(matrix);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  width=MeasureSpec.getSize(widthMeasureSpec);
  height=MeasureSpec.getSize(heightMeasureSpec);
  float scaleX=(float)width / (float)bmWidth;
  float scaleY=(float)height / (float)bmHeight;
  float scale=Math.min(scaleX,scaleY);
  defaultScale=Math.min(cDefaultScale,scale);
  minScale=Math.min(cMinScale,scale) / defaultScale;
  maxScale=cMaxScale / defaultScale;
  matrix.setScale(defaultScale,defaultScale);
  setImageMatrix(matrix);
  saveScale=1f;
  redundantYSpace=(float)height - (defaultScale * (float)bmHeight);
  redundantXSpace=(float)width - (defaultScale * (float)bmWidth);
  redundantYSpace/=(float)2;
  redundantXSpace/=(float)2;
  matrix.postTranslate(redundantXSpace,redundantYSpace);
  origWidth=width - 2 * redundantXSpace;
  origHeight=height - 2 * redundantYSpace;
  right=width * saveScale - width - (2 * redundantXSpace * saveScale);
  bottom=height * saveScale - height - (2 * redundantYSpace * saveScale);
  setImageMatrix(matrix);
}",0.9913832199546484
9816,"private boolean getDiscardNextActionUp(){
  if (this.mEditor == null) {
    return false;
  }
  try {
    return this.mDiscardNextActionUpField.getBoolean(this.mEditor);
  }
 catch (  Exception e) {
    return false;
  }
}","private boolean getDiscardNextActionUp(){
  if (this.mBaseEditor == null) {
    return false;
  }
  try {
    return this.mDiscardNextActionUpField.getBoolean(this.mBaseEditor);
  }
 catch (  Exception e) {
    return false;
  }
}",0.9823008849557522
9817,"private boolean checkLinksOnTouch(MotionEvent event){
  this.copyBaseEditorIfNecessary();
  int action=event.getAction() & 0xff;
  boolean discardNextActionUp=this.getDiscardNextActionUp();
  final boolean superResult=super.onTouchEvent(event);
  MyLog.v(TAG,""String_Node_Str"" + superResult);
  if (discardNextActionUp && action == MotionEvent.ACTION_UP) {
    MyLog.v(TAG,""String_Node_Str"");
    return superResult;
  }
  final boolean touchIsFinished=(action == MotionEvent.ACTION_UP) && !this.getIgnoreActionUpEvent() && isFocused();
  if (touchIsFinished) {
    Spannable spannable=(Spannable)this.getText();
    int x=(int)event.getX();
    int y=(int)event.getY();
    x-=this.getTotalPaddingLeft();
    y-=this.getTotalPaddingTop();
    x+=this.getScrollX();
    y+=this.getScrollY();
    Layout layout=this.getLayout();
    int line=layout.getLineForVertical(y);
    int off=layout.getOffsetForHorizontal(line,x);
    ClickableSpan[] link=spannable.getSpans(off,off,ClickableSpan.class);
    if (link.length != 0) {
      link[0].onClick(this);
      return true;
    }
  }
  return superResult;
}","private boolean checkLinksOnTouch(MotionEvent event){
  this.copyBaseEditorIfNecessary();
  int action=event.getAction() & 0xff;
  boolean discardNextActionUp=this.getDiscardNextActionUp();
  final boolean superResult=super.onTouchEvent(event);
  if (discardNextActionUp && action == MotionEvent.ACTION_UP) {
    return superResult;
  }
  final boolean touchIsFinished=(action == MotionEvent.ACTION_UP) && !this.getIgnoreActionUpEvent() && isFocused();
  if (touchIsFinished) {
    Spannable spannable=(Spannable)this.getText();
    int x=(int)event.getX();
    int y=(int)event.getY();
    x-=this.getTotalPaddingLeft();
    y-=this.getTotalPaddingTop();
    x+=this.getScrollX();
    y+=this.getScrollY();
    Layout layout=this.getLayout();
    int line=layout.getLineForVertical(y);
    int off=layout.getOffsetForHorizontal(line,x);
    ClickableSpan[] link=spannable.getSpans(off,off,ClickableSpan.class);
    if (link.length != 0) {
      link[0].onClick(this);
      return true;
    }
  }
  return superResult;
}",0.960489181561618
9818,"private boolean getIgnoreActionUpEvent(){
  if (this.mEditor == null) {
    return false;
  }
  try {
    return this.mIgnoreActionUpEventField.getBoolean(this.mEditor);
  }
 catch (  Exception e) {
    return false;
  }
}","private boolean getIgnoreActionUpEvent(){
  if (this.mBaseEditor == null) {
    return false;
  }
  try {
    return this.mIgnoreActionUpEventField.getBoolean(this.mBaseEditor);
  }
 catch (  Exception e) {
    return false;
  }
}",0.9823008849557522
9819,"private final void copyBaseEditorIfNecessary(){
  if (this.mEditorCreated) {
    return;
  }
  try {
    Field field=TextView.class.getDeclaredField(""String_Node_Str"");
    field.setAccessible(true);
    this.mEditor=field.get(this);
    if (this.mEditor != null) {
      this.mDiscardNextActionUpField=this.mEditor.getClass().getDeclaredField(""String_Node_Str"");
      this.mDiscardNextActionUpField.setAccessible(true);
      this.mIgnoreActionUpEventField=this.mEditor.getClass().getDeclaredField(""String_Node_Str"");
      this.mIgnoreActionUpEventField.setAccessible(true);
    }
  }
 catch (  Exception e) {
    MyLog.e(TAG,e);
  }
 finally {
    this.mEditorCreated=true;
  }
}","private void copyBaseEditorIfNecessary(){
  if (this.mBaseEditorCopied) {
    return;
  }
  try {
    Field field=TextView.class.getDeclaredField(""String_Node_Str"");
    field.setAccessible(true);
    this.mBaseEditor=field.get(this);
    if (this.mBaseEditor != null) {
      Class editorClass=this.mBaseEditor.getClass();
      this.mDiscardNextActionUpField=editorClass.getDeclaredField(""String_Node_Str"");
      this.mDiscardNextActionUpField.setAccessible(true);
      this.mIgnoreActionUpEventField=editorClass.getDeclaredField(""String_Node_Str"");
      this.mIgnoreActionUpEventField.setAccessible(true);
    }
  }
 catch (  Exception e) {
    MyLog.e(TAG,e);
  }
 finally {
    this.mBaseEditorCopied=true;
  }
}",0.902352102637206
9820,"@Override protected void onStart(){
  super.onStart();
  SettingsEntity newSettings=this.mSettings.getCurrentSettings();
  if (this.mCurrentSettings.theme != newSettings.theme) {
    this.resetUI();
    return;
  }
  if (this.mCurrentSettings.isDisplayNavigationBar != newSettings.isDisplayNavigationBar) {
    this.mNavigationBar.setVisibility(newSettings.isDisplayNavigationBar ? View.VISIBLE : View.GONE);
  }
  if (this.mCurrentSettings.isLoadThumbnails != newSettings.isLoadThumbnails) {
    this.mAdapter.notifyDataSetChanged();
  }
  this.mCurrentSettings=this.mSettings.getCurrentSettings();
}","@Override protected void onStart(){
  super.onStart();
  SettingsEntity newSettings=this.mSettings.getCurrentSettings();
  if (this.mCurrentSettings.theme != newSettings.theme) {
    this.finish();
    Intent i=new Intent(this,this.getClass());
    i.putExtra(Constants.EXTRA_PREFER_DESERIALIZED,true);
    this.startActivity(i);
    return;
  }
  if (this.mCurrentSettings.isDisplayNavigationBar != newSettings.isDisplayNavigationBar) {
    this.mNavigationBar.setVisibility(newSettings.isDisplayNavigationBar ? View.VISIBLE : View.GONE);
  }
  if (this.mCurrentSettings.isLoadThumbnails != newSettings.isLoadThumbnails) {
    this.mAdapter.notifyDataSetChanged();
  }
  this.mCurrentSettings=this.mSettings.getCurrentSettings();
}",0.8912228057014253
9821,"@Override public PostItemViewModel getItem(int position){
  return this.isStatusView(position) ? null : super.getItem(position);
}","@Override public PostItemViewModel getItem(int position){
  return (position < super.getCount()) ? super.getItem(position) : null;
}",0.8091603053435115
9822,"private final boolean hasStatusView(){
  return this.mIsLoadingMore && super.getCount() > 0;
}","private final boolean hasStatusView(){
  return this.mIsLoadingMore;
}",0.8536585365853658
9823,"public static void showImageProgressBar(final View indeterminateProgressBar,final ImageView imageView){
  imageView.setVisibility(View.GONE);
  if (indeterminateProgressBar != null) {
    indeterminateProgressBar.setVisibility(View.VISIBLE);
  }
}","public static void showImageProgressBar(final View indeterminateProgressBar,final ImageView imageView){
  imageView.setVisibility(View.INVISIBLE);
  if (indeterminateProgressBar != null) {
    indeterminateProgressBar.setVisibility(View.VISIBLE);
  }
}",0.9819639278557114
9824,"@Override public String fromResponse(HttpResponse response){
  try {
    InputStream stream=response.getEntity().getContent();
    ByteArrayOutputStream output=new ByteArrayOutputStream();
    byte data[]=new byte[8192];
    int count;
    while ((count=stream.read(data)) != -1) {
      output.write(data,0,count);
    }
    String result=output.toString(Constants.UTF8_CHARSET.name());
    return result;
  }
 catch (  Exception e) {
    MyLog.e(TAG,e);
  }
 finally {
    ExtendedHttpClient.releaseRequestResponse(null,response);
  }
  return null;
}","@Override public String fromResponse(HttpResponse response){
  try {
    InputStream stream=response.getEntity().getContent();
    String result=IoUtils.convertStreamToString(stream);
    return result;
  }
 catch (  Exception e) {
    MyLog.e(TAG,e);
  }
 finally {
    ExtendedHttpClient.releaseRequestResponse(null,response);
  }
  return null;
}",0.6718403547671841
9825,"/** 
 * @param args the command line arguments
 */
public static void main(String[] args) throws Exception {
  LoggerCount loggerCount=new LoggerCount(logger);
  CommandLineParser cliParser=new GnuParser();
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  SparqlifyCliHelper.addDatabaseOptions(cliOptions);
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  CommandLine commandLine=cliParser.parse(cliOptions,args);
  String portStr=commandLine.getOptionValue(""String_Node_Str"",""String_Node_Str"");
  int port=Integer.parseInt(portStr);
  String outputFormat=commandLine.getOptionValue(""String_Node_Str"",""String_Node_Str"");
  boolean isDump=commandLine.hasOption(""String_Node_Str"");
  String queryString=commandLine.getOptionValue(""String_Node_Str"",""String_Node_Str"");
  boolean isQuery=!queryString.isEmpty();
  if (!isQuery) {
    queryString=null;
  }
  if (isDump) {
    if (isQuery) {
      loggerCount.error(""String_Node_Str"");
    }
  }
  String maxQueryExecutionTimeStr=commandLine.getOptionValue(""String_Node_Str"",null);
  Integer maxQueryExecutionTime=maxQueryExecutionTimeStr == null ? null : Integer.parseInt(maxQueryExecutionTimeStr);
  String maxResultSetSizeStr=commandLine.getOptionValue(""String_Node_Str"",null);
  Long maxResultSetSize=maxResultSetSizeStr == null ? null : Long.parseLong(maxResultSetSizeStr);
  Config config=SparqlifyCliHelper.parseSmlConfigs(commandLine,loggerCount);
  SparqlifyCliHelper.onErrorPrintHelpAndExit(cliOptions,loggerCount,-1);
  DataSource dataSource=SparqlifyCliHelper.parseDataSource(commandLine,loggerCount);
  SparqlifyCliHelper.onErrorPrintHelpAndExit(cliOptions,loggerCount,-1);
  SparqlifyCoreInit.initSparqlifyFunctions();
  ExprRewriteSystem ers=SparqlifyUtils.createDefaultExprRewriteSystem();
  TypeSystem typeSystem=ers.getTypeSystem();
  Map<String,String> typeAlias=MapReader.readFromResource(""String_Node_Str"");
  Connection conn=dataSource.getConnection();
  DatabaseMetaData dbMeta=conn.getMetaData();
  String dbProductName=dbMeta.getDatabaseProductName();
  logger.info(""String_Node_Str"" + dbProductName);
  SqlBackendRegistry backendRegistry=SqlBackendRegistry.get();
  SqlBackendConfig backendConfig=backendRegistry.apply(dbProductName);
  if (backendConfig == null) {
    throw new RuntimeException(""String_Node_Str"" + dbProductName);
  }
  SqlEscaper sqlEscaper=backendConfig.getSqlEscaper();
  DatatypeToString typeSerializer=backendConfig.getTypeSerializer();
  try {
    BasicTableInfoProvider basicTableInfoProvider=new BasicTableProviderJdbc(conn);
    SchemaProvider schemaProvider=new SchemaProviderImpl(basicTableInfoProvider,typeSystem,typeAlias,sqlEscaper);
    SyntaxBridge syntaxBridge=new SyntaxBridge(schemaProvider);
    MappingOps mappingOps=SparqlifyUtils.createDefaultMappingOps(ers);
    CandidateViewSelector<ViewDefinition> candidateViewSelector=new CandidateViewSelectorSparqlify(mappingOps,new ViewDefinitionNormalizerImpl());
    ConfiguratorCandidateSelector.configure(config,syntaxBridge,candidateViewSelector,loggerCount);
  }
  finally {
    conn.close();
  }
  logger.info(""String_Node_Str"" + loggerCount.getErrorCount() + ""String_Node_Str""+ loggerCount.getWarningCount());
  if (loggerCount.getErrorCount() > 0) {
    throw new RuntimeException(""String_Node_Str"" + loggerCount.getErrorCount() + ""String_Node_Str"");
  }
  boolean useSparql11Wrapper=commandLine.hasOption(""String_Node_Str"");
  Long mrs=useSparql11Wrapper ? null : maxResultSetSize;
  QueryExecutionFactoryEx qef=SparqlifyUtils.createDefaultSparqlifyEngine(dataSource,config,typeSerializer,sqlEscaper,mrs,maxQueryExecutionTime);
  if (useSparql11Wrapper) {
    Graph graph=new GraphQueryExecutionFactory(qef);
    Model model=ModelFactory.createModelForGraph(graph);
    QueryExecutionFactory tmp=new QueryExecutionFactoryModel(model);
    if (maxResultSetSize != null) {
      tmp=QueryExecutionFactoryLimit.decorate(tmp,true,maxResultSetSize);
    }
    qef=new QueryExecutionFactoryExWrapper(tmp);
  }
  if (isDump) {
    if (outputFormat.equals(""String_Node_Str"")) {
      Iterator<Quad> itQuad=QueryExecutionUtils.createIteratorDumpQuads(qef);
      NQuadsWriter.write(System.out,itQuad);
    }
 else {
      Iterator<Triple> itTriple=QueryExecutionUtils.createIteratorDumpTriples(qef);
      NTriplesWriter.write(System.out,itTriple);
    }
    return;
  }
 else   if (queryString != null) {
    QueryEx queryEx=QueryFactoryEx.create(queryString);
    if (queryEx.isSelectType()) {
      QueryExecution qe=qef.createQueryExecution(queryEx);
      ResultSet rs=qe.execSelect();
      System.out.println(ResultSetFormatter.asText(rs));
    }
 else     if (queryEx.isConstructType()) {
      QueryExecution qe=qef.createQueryExecution(queryString);
      Iterator<Triple> it=qe.execConstructTriples();
      SparqlFormatterUtils.writeText(System.out,it);
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + queryString);
    }
    return;
  }
  Server server=createSparqlEndpoint(qef,port);
  server.start();
}","/** 
 * @param args the command line arguments
 */
public static void main(String[] args) throws Exception {
  LoggerCount loggerCount=new LoggerCount(logger);
  CommandLineParser cliParser=new GnuParser();
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  SparqlifyCliHelper.addDatabaseOptions(cliOptions);
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  Option mappingSourceOption=new Option(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  mappingSourceOption.setArgs(Option.UNLIMITED_VALUES);
  cliOptions.addOption(mappingSourceOption);
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  CommandLine commandLine=cliParser.parse(cliOptions,args);
  String portStr=commandLine.getOptionValue(""String_Node_Str"",""String_Node_Str"");
  int port=Integer.parseInt(portStr);
  String outputFormat=commandLine.getOptionValue(""String_Node_Str"",""String_Node_Str"");
  boolean isDump=commandLine.hasOption(""String_Node_Str"");
  String queryString=commandLine.getOptionValue(""String_Node_Str"",""String_Node_Str"");
  boolean isQuery=!queryString.isEmpty();
  if (!isQuery) {
    queryString=null;
  }
  if (isDump) {
    if (isQuery) {
      loggerCount.error(""String_Node_Str"");
    }
  }
  String maxQueryExecutionTimeStr=commandLine.getOptionValue(""String_Node_Str"",null);
  Integer maxQueryExecutionTime=maxQueryExecutionTimeStr == null ? null : Integer.parseInt(maxQueryExecutionTimeStr);
  String maxResultSetSizeStr=commandLine.getOptionValue(""String_Node_Str"",null);
  Long maxResultSetSize=maxResultSetSizeStr == null ? null : Long.parseLong(maxResultSetSizeStr);
  Config config=SparqlifyCliHelper.parseSmlConfigs(commandLine,loggerCount);
  SparqlifyCliHelper.onErrorPrintHelpAndExit(cliOptions,loggerCount,-1);
  DataSource dataSource=SparqlifyCliHelper.parseDataSource(commandLine,loggerCount);
  SparqlifyCliHelper.onErrorPrintHelpAndExit(cliOptions,loggerCount,-1);
  SparqlifyCoreInit.initSparqlifyFunctions();
  ExprRewriteSystem ers=SparqlifyUtils.createDefaultExprRewriteSystem();
  TypeSystem typeSystem=ers.getTypeSystem();
  Map<String,String> typeAlias=MapReader.readFromResource(""String_Node_Str"");
  Connection conn=dataSource.getConnection();
  DatabaseMetaData dbMeta=conn.getMetaData();
  String dbProductName=dbMeta.getDatabaseProductName();
  logger.info(""String_Node_Str"" + dbProductName);
  SqlBackendRegistry backendRegistry=SqlBackendRegistry.get();
  SqlBackendConfig backendConfig=backendRegistry.apply(dbProductName);
  if (backendConfig == null) {
    throw new RuntimeException(""String_Node_Str"" + dbProductName);
  }
  SqlEscaper sqlEscaper=backendConfig.getSqlEscaper();
  DatatypeToString typeSerializer=backendConfig.getTypeSerializer();
  try {
    BasicTableInfoProvider basicTableInfoProvider=new BasicTableProviderJdbc(conn);
    SchemaProvider schemaProvider=new SchemaProviderImpl(basicTableInfoProvider,typeSystem,typeAlias,sqlEscaper);
    SyntaxBridge syntaxBridge=new SyntaxBridge(schemaProvider);
    MappingOps mappingOps=SparqlifyUtils.createDefaultMappingOps(ers);
    CandidateViewSelector<ViewDefinition> candidateViewSelector=new CandidateViewSelectorSparqlify(mappingOps,new ViewDefinitionNormalizerImpl());
    ConfiguratorCandidateSelector.configure(config,syntaxBridge,candidateViewSelector,loggerCount);
  }
  finally {
    conn.close();
  }
  logger.info(""String_Node_Str"" + loggerCount.getErrorCount() + ""String_Node_Str""+ loggerCount.getWarningCount());
  if (loggerCount.getErrorCount() > 0) {
    throw new RuntimeException(""String_Node_Str"" + loggerCount.getErrorCount() + ""String_Node_Str"");
  }
  boolean useSparql11Wrapper=commandLine.hasOption(""String_Node_Str"");
  Long mrs=useSparql11Wrapper ? null : maxResultSetSize;
  QueryExecutionFactoryEx qef=SparqlifyUtils.createDefaultSparqlifyEngine(dataSource,config,typeSerializer,sqlEscaper,mrs,maxQueryExecutionTime);
  if (useSparql11Wrapper) {
    Graph graph=new GraphQueryExecutionFactory(qef);
    Model model=ModelFactory.createModelForGraph(graph);
    QueryExecutionFactory tmp=new QueryExecutionFactoryModel(model);
    if (maxResultSetSize != null) {
      tmp=QueryExecutionFactoryLimit.decorate(tmp,true,maxResultSetSize);
    }
    qef=new QueryExecutionFactoryExWrapper(tmp);
  }
  if (isDump) {
    if (outputFormat.equals(""String_Node_Str"")) {
      Iterator<Quad> itQuad=QueryExecutionUtils.createIteratorDumpQuads(qef);
      NQuadsWriter.write(System.out,itQuad);
    }
 else {
      Iterator<Triple> itTriple=QueryExecutionUtils.createIteratorDumpTriples(qef);
      NTriplesWriter.write(System.out,itTriple);
    }
    return;
  }
 else   if (queryString != null) {
    QueryEx queryEx=QueryFactoryEx.create(queryString);
    if (queryEx.isSelectType()) {
      QueryExecution qe=qef.createQueryExecution(queryEx);
      ResultSet rs=qe.execSelect();
      System.out.println(ResultSetFormatter.asText(rs));
    }
 else     if (queryEx.isConstructType()) {
      QueryExecution qe=qef.createQueryExecution(queryString);
      Iterator<Triple> it=qe.execConstructTriples();
      SparqlFormatterUtils.writeText(System.out,it);
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + queryString);
    }
    return;
  }
  Server server=createSparqlEndpoint(qef,port);
  server.start();
}",0.9884462838420416
9826,"/** 
 * @param args the command line arguments
 */
public static void main(String[] args) throws Exception {
  LoggerCount loggerCount=new LoggerCount(logger);
  CommandLineParser cliParser=new GnuParser();
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  SparqlifyCliHelper.addDatabaseOptions(cliOptions);
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  CommandLine commandLine=cliParser.parse(cliOptions,args);
  String portStr=commandLine.getOptionValue(""String_Node_Str"",""String_Node_Str"");
  int port=Integer.parseInt(portStr);
  String outputFormat=commandLine.getOptionValue(""String_Node_Str"",""String_Node_Str"");
  boolean isDump=commandLine.hasOption(""String_Node_Str"");
  String queryString=commandLine.getOptionValue(""String_Node_Str"",""String_Node_Str"");
  boolean isQuery=!queryString.isEmpty();
  if (!isQuery) {
    queryString=null;
  }
  if (isDump) {
    if (isQuery) {
      loggerCount.error(""String_Node_Str"");
    }
  }
  String maxQueryExecutionTimeStr=commandLine.getOptionValue(""String_Node_Str"",null);
  Integer maxQueryExecutionTime=maxQueryExecutionTimeStr == null ? null : Integer.parseInt(maxQueryExecutionTimeStr);
  String maxResultSetSizeStr=commandLine.getOptionValue(""String_Node_Str"",null);
  Long maxResultSetSize=maxResultSetSizeStr == null ? null : Long.parseLong(maxResultSetSizeStr);
  Config config=SparqlifyCliHelper.parseSmlConfigs(commandLine,loggerCount);
  SparqlifyCliHelper.onErrorPrintHelpAndExit(cliOptions,loggerCount,-1);
  DataSource dataSource=SparqlifyCliHelper.parseDataSource(commandLine,loggerCount);
  SparqlifyCliHelper.onErrorPrintHelpAndExit(cliOptions,loggerCount,-1);
  SparqlifyCoreInit.initSparqlifyFunctions();
  ExprRewriteSystem ers=SparqlifyUtils.createDefaultExprRewriteSystem();
  TypeSystem typeSystem=ers.getTypeSystem();
  Map<String,String> typeAlias=MapReader.readFromResource(""String_Node_Str"");
  Connection conn=dataSource.getConnection();
  DatabaseMetaData dbMeta=conn.getMetaData();
  String dbProductName=dbMeta.getDatabaseProductName();
  logger.info(""String_Node_Str"" + dbProductName);
  SqlBackendRegistry backendRegistry=SqlBackendRegistry.get();
  Map<String,SqlBackendConfig> map=backendRegistry.getMap();
  SqlBackendConfig backendConfig=map.get(dbProductName);
  if (backendConfig == null) {
    throw new RuntimeException(""String_Node_Str"" + dbProductName);
  }
  SqlEscaper sqlEscaper=backendConfig.getSqlEscaper();
  DatatypeToString typeSerializer=backendConfig.getTypeSerializer();
  try {
    BasicTableInfoProvider basicTableInfoProvider=new BasicTableProviderJdbc(conn);
    SchemaProvider schemaProvider=new SchemaProviderImpl(basicTableInfoProvider,typeSystem,typeAlias,sqlEscaper);
    SyntaxBridge syntaxBridge=new SyntaxBridge(schemaProvider);
    MappingOps mappingOps=SparqlifyUtils.createDefaultMappingOps(ers);
    CandidateViewSelector<ViewDefinition> candidateViewSelector=new CandidateViewSelectorSparqlify(mappingOps,new ViewDefinitionNormalizerImpl());
    ConfiguratorCandidateSelector.configure(config,syntaxBridge,candidateViewSelector,loggerCount);
  }
  finally {
    conn.close();
  }
  logger.info(""String_Node_Str"" + loggerCount.getErrorCount() + ""String_Node_Str""+ loggerCount.getWarningCount());
  if (loggerCount.getErrorCount() > 0) {
    throw new RuntimeException(""String_Node_Str"" + loggerCount.getErrorCount() + ""String_Node_Str"");
  }
  boolean useSparql11Wrapper=commandLine.hasOption(""String_Node_Str"");
  Long mrs=useSparql11Wrapper ? null : maxResultSetSize;
  QueryExecutionFactoryEx qef=SparqlifyUtils.createDefaultSparqlifyEngine(dataSource,config,typeSerializer,sqlEscaper,mrs,maxQueryExecutionTime);
  if (useSparql11Wrapper) {
    Graph graph=new GraphQueryExecutionFactory(qef);
    Model model=ModelFactory.createModelForGraph(graph);
    QueryExecutionFactory tmp=new QueryExecutionFactoryModel(model);
    if (maxResultSetSize != null) {
      tmp=QueryExecutionFactoryLimit.decorate(tmp,true,maxResultSetSize);
    }
    qef=new QueryExecutionFactoryExWrapper(tmp);
  }
  if (isDump) {
    if (outputFormat.equals(""String_Node_Str"")) {
      Iterator<Quad> itQuad=QueryExecutionUtils.createIteratorDumpQuads(qef);
      NQuadsWriter.write(System.out,itQuad);
    }
 else {
      Iterator<Triple> itTriple=QueryExecutionUtils.createIteratorDumpTriples(qef);
      NTriplesWriter.write(System.out,itTriple);
    }
    return;
  }
 else   if (queryString != null) {
    QueryEx queryEx=QueryFactoryEx.create(queryString);
    if (queryEx.isSelectType()) {
      QueryExecution qe=qef.createQueryExecution(queryEx);
      ResultSet rs=qe.execSelect();
      System.out.println(ResultSetFormatter.asText(rs));
    }
 else     if (queryEx.isConstructType()) {
      QueryExecution qe=qef.createQueryExecution(queryString);
      Iterator<Triple> it=qe.execConstructTriples();
      SparqlFormatterUtils.writeText(System.out,it);
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + queryString);
    }
    return;
  }
  Server server=createSparqlEndpoint(qef,port);
  server.start();
}","/** 
 * @param args the command line arguments
 */
public static void main(String[] args) throws Exception {
  LoggerCount loggerCount=new LoggerCount(logger);
  CommandLineParser cliParser=new GnuParser();
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  SparqlifyCliHelper.addDatabaseOptions(cliOptions);
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  cliOptions.addOption(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  CommandLine commandLine=cliParser.parse(cliOptions,args);
  String portStr=commandLine.getOptionValue(""String_Node_Str"",""String_Node_Str"");
  int port=Integer.parseInt(portStr);
  String outputFormat=commandLine.getOptionValue(""String_Node_Str"",""String_Node_Str"");
  boolean isDump=commandLine.hasOption(""String_Node_Str"");
  String queryString=commandLine.getOptionValue(""String_Node_Str"",""String_Node_Str"");
  boolean isQuery=!queryString.isEmpty();
  if (!isQuery) {
    queryString=null;
  }
  if (isDump) {
    if (isQuery) {
      loggerCount.error(""String_Node_Str"");
    }
  }
  String maxQueryExecutionTimeStr=commandLine.getOptionValue(""String_Node_Str"",null);
  Integer maxQueryExecutionTime=maxQueryExecutionTimeStr == null ? null : Integer.parseInt(maxQueryExecutionTimeStr);
  String maxResultSetSizeStr=commandLine.getOptionValue(""String_Node_Str"",null);
  Long maxResultSetSize=maxResultSetSizeStr == null ? null : Long.parseLong(maxResultSetSizeStr);
  Config config=SparqlifyCliHelper.parseSmlConfigs(commandLine,loggerCount);
  SparqlifyCliHelper.onErrorPrintHelpAndExit(cliOptions,loggerCount,-1);
  DataSource dataSource=SparqlifyCliHelper.parseDataSource(commandLine,loggerCount);
  SparqlifyCliHelper.onErrorPrintHelpAndExit(cliOptions,loggerCount,-1);
  SparqlifyCoreInit.initSparqlifyFunctions();
  ExprRewriteSystem ers=SparqlifyUtils.createDefaultExprRewriteSystem();
  TypeSystem typeSystem=ers.getTypeSystem();
  Map<String,String> typeAlias=MapReader.readFromResource(""String_Node_Str"");
  Connection conn=dataSource.getConnection();
  DatabaseMetaData dbMeta=conn.getMetaData();
  String dbProductName=dbMeta.getDatabaseProductName();
  logger.info(""String_Node_Str"" + dbProductName);
  SqlBackendRegistry backendRegistry=SqlBackendRegistry.get();
  SqlBackendConfig backendConfig=backendRegistry.apply(dbProductName);
  if (backendConfig == null) {
    throw new RuntimeException(""String_Node_Str"" + dbProductName);
  }
  SqlEscaper sqlEscaper=backendConfig.getSqlEscaper();
  DatatypeToString typeSerializer=backendConfig.getTypeSerializer();
  try {
    BasicTableInfoProvider basicTableInfoProvider=new BasicTableProviderJdbc(conn);
    SchemaProvider schemaProvider=new SchemaProviderImpl(basicTableInfoProvider,typeSystem,typeAlias,sqlEscaper);
    SyntaxBridge syntaxBridge=new SyntaxBridge(schemaProvider);
    MappingOps mappingOps=SparqlifyUtils.createDefaultMappingOps(ers);
    CandidateViewSelector<ViewDefinition> candidateViewSelector=new CandidateViewSelectorSparqlify(mappingOps,new ViewDefinitionNormalizerImpl());
    ConfiguratorCandidateSelector.configure(config,syntaxBridge,candidateViewSelector,loggerCount);
  }
  finally {
    conn.close();
  }
  logger.info(""String_Node_Str"" + loggerCount.getErrorCount() + ""String_Node_Str""+ loggerCount.getWarningCount());
  if (loggerCount.getErrorCount() > 0) {
    throw new RuntimeException(""String_Node_Str"" + loggerCount.getErrorCount() + ""String_Node_Str"");
  }
  boolean useSparql11Wrapper=commandLine.hasOption(""String_Node_Str"");
  Long mrs=useSparql11Wrapper ? null : maxResultSetSize;
  QueryExecutionFactoryEx qef=SparqlifyUtils.createDefaultSparqlifyEngine(dataSource,config,typeSerializer,sqlEscaper,mrs,maxQueryExecutionTime);
  if (useSparql11Wrapper) {
    Graph graph=new GraphQueryExecutionFactory(qef);
    Model model=ModelFactory.createModelForGraph(graph);
    QueryExecutionFactory tmp=new QueryExecutionFactoryModel(model);
    if (maxResultSetSize != null) {
      tmp=QueryExecutionFactoryLimit.decorate(tmp,true,maxResultSetSize);
    }
    qef=new QueryExecutionFactoryExWrapper(tmp);
  }
  if (isDump) {
    if (outputFormat.equals(""String_Node_Str"")) {
      Iterator<Quad> itQuad=QueryExecutionUtils.createIteratorDumpQuads(qef);
      NQuadsWriter.write(System.out,itQuad);
    }
 else {
      Iterator<Triple> itTriple=QueryExecutionUtils.createIteratorDumpTriples(qef);
      NTriplesWriter.write(System.out,itTriple);
    }
    return;
  }
 else   if (queryString != null) {
    QueryEx queryEx=QueryFactoryEx.create(queryString);
    if (queryEx.isSelectType()) {
      QueryExecution qe=qef.createQueryExecution(queryEx);
      ResultSet rs=qe.execSelect();
      System.out.println(ResultSetFormatter.asText(rs));
    }
 else     if (queryEx.isConstructType()) {
      QueryExecution qe=qef.createQueryExecution(queryString);
      Iterator<Triple> it=qe.execConstructTriples();
      SparqlFormatterUtils.writeText(System.out,it);
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + queryString);
    }
    return;
  }
  Server server=createSparqlEndpoint(qef,port);
  server.start();
}",0.9926260085017784
9827,"@Override public SqlBackendConfig apply(String t){
  SqlBackendConfig result=nameToConfig.get(t);
  return result;
}","@Override public SqlBackendConfig apply(String t){
  SqlBackendConfig result=nameToConfig.get(t.toLowerCase());
  return result;
}",0.943089430894309
9828,"public void put(String name,SqlBackendConfig config){
  nameToConfig.put(name,config);
}","public void put(String name,SqlBackendConfig config){
  nameToConfig.put(name.toLowerCase(),config);
}",0.9263157894736842
9829,"public Op processLeftJoinSplitLhs(Op left,Op right,Iterable<Expr> exprs,RestrictionManagerImpl restrictions){
  FilterSplit filterSplit=FilterPlacementOptimizer2.splitFilter(left,restrictions);
  RestrictionManagerImpl leftRestrictions=filterSplit.getPushable();
  Op newLeft=_getApplicableViews(left,filterSplit.getPushable());
  newLeft=FilterPlacementOptimizer2.optimize(newLeft,leftRestrictions);
  List<Op> members;
  if (newLeft instanceof OpDisjunction) {
    OpDisjunction union=(OpDisjunction)newLeft;
    members=union.getElements();
  }
 else {
    members=Collections.singletonList(newLeft);
  }
  OpDisjunction newUnion=OpDisjunction.create();
  for (  Op member : members) {
    RestrictionManagerImpl subRestrictions=new RestrictionManagerImpl(leftRestrictions);
    RestrictionManagerImpl tmp=getRestrictions2(member);
    subRestrictions.stateRestriction(tmp);
    if (exprs != null) {
      for (      Expr expr : exprs) {
        subRestrictions.stateExpr(expr);
      }
    }
    FilterSplit rsplit=FilterPlacementOptimizer2.splitFilter(right,subRestrictions);
    RestrictionManagerImpl rclauses=rsplit.getPushable();
    Op newRight=_getApplicableViews(right,rclauses);
    Op item=(OpLeftJoin)OpLeftJoin.create(member,newRight,new ExprList());
    if (!filterSplit.getNonPushable().getCnf().isEmpty()) {
      item=new OpFilterIndexed(item,filterSplit.getNonPushable());
    }
    newUnion.add(item);
  }
  List<Op> elements=newUnion.getElements();
  Op result;
  if (newUnion.size() == 1) {
    result=elements.iterator().next();
  }
 else {
    result=newUnion;
  }
  return result;
}","public Op processLeftJoinSplitLhs(Op left,Op right,Iterable<Expr> exprs,RestrictionManagerImpl restrictions){
  FilterSplit filterSplit=FilterPlacementOptimizer2.splitFilter(left,restrictions);
  RestrictionManagerImpl leftRestrictions=filterSplit.getPushable();
  Op newLeft=_getApplicableViews(left,filterSplit.getPushable());
  newLeft=FilterPlacementOptimizer2.optimize(newLeft,leftRestrictions);
  List<Op> members;
  if (newLeft instanceof OpDisjunction) {
    OpDisjunction union=(OpDisjunction)newLeft;
    members=union.getElements();
  }
 else {
    members=Collections.singletonList(newLeft);
  }
  OpDisjunction newUnion=OpDisjunction.create();
  for (  Op member : members) {
    RestrictionManagerImpl subRestrictions=new RestrictionManagerImpl(leftRestrictions);
    RestrictionManagerImpl tmp=getRestrictions2(member);
    if (tmp != null) {
      subRestrictions.stateRestriction(tmp);
    }
    if (exprs != null) {
      for (      Expr expr : exprs) {
        subRestrictions.stateExpr(expr);
      }
    }
    FilterSplit rsplit=FilterPlacementOptimizer2.splitFilter(right,subRestrictions);
    RestrictionManagerImpl rclauses=rsplit.getPushable();
    Op newRight=_getApplicableViews(right,rclauses);
    Op item=(OpLeftJoin)OpLeftJoin.create(member,newRight,new ExprList());
    if (!filterSplit.getNonPushable().getCnf().isEmpty()) {
      item=new OpFilterIndexed(item,filterSplit.getNonPushable());
    }
    newUnion.add(item);
  }
  List<Op> elements=newUnion.getElements();
  Op result;
  if (newUnion.size() == 1) {
    result=elements.iterator().next();
  }
 else {
    result=newUnion;
  }
  return result;
}",0.9904586026469684
9830,"public boolean stateRestriction(RestrictionManagerImpl rm){
  if (this.isUnsatisfiable()) {
    return false;
  }
  Set<Var> vars=rm.getVariables();
  for (  Var var : vars) {
    RestrictionImpl r=rm.getRestriction(var);
    if (r != null) {
      this.stateRestriction(var,r);
      if (r.isUnsatisfiable()) {
        this.satisfiability=Boolean.FALSE;
        return true;
      }
    }
  }
  if (rm.isUnsatisfiable()) {
    this.satisfiability=Boolean.FALSE;
    return true;
  }
  this.stateCnf(rm.getCnf());
  if (this.isUnsatisfiable()) {
    return true;
  }
  return true;
}","public boolean stateRestriction(RestrictionManagerImpl rm){
  if (this.isUnsatisfiable()) {
    return false;
  }
  if (rm == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  Set<Var> vars=rm.getVariables();
  for (  Var var : vars) {
    RestrictionImpl r=rm.getRestriction(var);
    if (r != null) {
      this.stateRestriction(var,r);
      if (r.isUnsatisfiable()) {
        this.satisfiability=Boolean.FALSE;
        return true;
      }
    }
  }
  if (rm.isUnsatisfiable()) {
    this.satisfiability=Boolean.FALSE;
    return true;
  }
  this.stateCnf(rm.getCnf());
  if (this.isUnsatisfiable()) {
    return true;
  }
  return true;
}",0.9395648670427076
9831,"public static JoinContext _collectJoins(SqlOp sqlOp,Set<String> refs){
  JoinContext result;
  SqlOps type=SqlOps.valueOf(sqlOp.getClass().getSimpleName());
switch (type) {
case SqlOpEmpty:
    result=collectJoins((SqlOpEmpty)sqlOp,refs);
  break;
case SqlOpTable:
result=collectJoins((SqlOpTable)sqlOp,refs);
break;
case SqlOpQuery:
result=collectJoins((SqlOpQuery)sqlOp,refs);
break;
case SqlOpFilter:
result=collectJoins((SqlOpFilter)sqlOp,refs);
break;
case SqlOpExtend:
result=collectJoins((SqlOpExtend)sqlOp,refs);
break;
case SqlOpRename:
result=collectJoins((SqlOpRename)sqlOp,refs);
break;
case SqlOpJoin:
result=collectJoins((SqlOpJoin)sqlOp,refs);
break;
case SqlOpUnionN:
result=collectJoins((SqlOpUnionN)sqlOp,refs);
break;
default :
logger.warn(""String_Node_Str"");
result=MultiMethod.invokeStatic(SqlOpSelectBlockCollectorImpl.class,""String_Node_Str"",sqlOp);
break;
}
return result;
}","public static JoinContext _collectJoins(SqlOp sqlOp,Set<String> refs){
  JoinContext result;
  SqlOps type=SqlOps.valueOf(sqlOp.getClass().getSimpleName());
switch (type) {
case SqlOpEmpty:
    result=collectJoins((SqlOpEmpty)sqlOp,refs);
  break;
case SqlOpTable:
result=collectJoins((SqlOpTable)sqlOp,refs);
break;
case SqlOpQuery:
result=collectJoins((SqlOpQuery)sqlOp,refs);
break;
case SqlOpFilter:
result=collectJoins((SqlOpFilter)sqlOp,refs);
break;
case SqlOpExtend:
result=collectJoins((SqlOpExtend)sqlOp,refs);
break;
case SqlOpRename:
result=collectJoins((SqlOpRename)sqlOp,refs);
break;
case SqlOpJoin:
result=collectJoins((SqlOpJoin)sqlOp,refs);
break;
case SqlOpUnionN:
result=collectJoins((SqlOpUnionN)sqlOp,refs);
break;
case SqlOpDistinct:
{
SqlOpSelectBlock tmp=makeSelect((SqlOpDistinct)sqlOp,refs);
result=collectJoins(tmp,refs);
break;
}
case SqlOpSlice:
{
SqlOpSelectBlock tmp=makeSelect((SqlOpSlice)sqlOp,refs);
result=collectJoins(tmp,refs);
break;
}
default :
throw new RuntimeException(""String_Node_Str"" + sqlOp);
}
return result;
}",0.8047034764826176
9832,"/** 
 * Pushes all constants of a given mapping's varDefinition into the SQL. Used for creating union's of mappings: By pushing variables into the SQL we do not have to deal with disjoint unions (i.e. unions with discriminator columns) in order to know which union member yields the constant. 
 * @param mapping The mapping to process. 
 * @return A new mapping with all constants pushed.
 */
public static Mapping pushConstants(Mapping mapping){
  VarDefinition varDef=mapping.getVarDefinition();
  Set<String> columnNameBlacklist=new HashSet<String>(mapping.getSqlOp().getSchema().getColumnNames());
  Generator aliasGen=GeneratorBlacklist.create(""String_Node_Str"",columnNameBlacklist);
  Projection projection=new Projection();
  VarDefinition newVarDef=new VarDefinition();
  for (  Entry<Var,Collection<RestrictedExpr>> entry : varDef.getMap().asMap().entrySet()) {
    Var var=entry.getKey();
    Collection<RestrictedExpr> restExprs=entry.getValue();
    for (    RestrictedExpr restExpr : restExprs) {
      Expr newExpr;
      Expr expr=restExpr.getExpr();
      E_RdfTerm rdfTerm;
      if (expr.isConstant()) {
        rdfTerm=SqlTranslationUtils.expandConstant(expr);
      }
 else {
        rdfTerm=SqlTranslationUtils.expandRdfTerm(expr);
      }
      boolean isConstantArgsOnly=ExprUtils.isConstantArgsOnly(rdfTerm);
      if (isConstantArgsOnly) {
        NodeValue constant=expr.eval(null,null);
        String alias=aliasGen.next();
        String str=""String_Node_Str"" + NodeValueUtils.getValue(constant);
        S_Constant sqlExpr=new S_Constant(new SqlValue(TypeToken.String,str));
        projection.put(alias,sqlExpr);
        ExprVar exprVar=new ExprVar(alias);
        ExprList exprs=new ExprList();
        List<Expr> args=rdfTerm.getArgs();
        for (int j=0; j < args.size(); ++j) {
          Expr e;
          if (j == 1) {
            e=exprVar;
          }
 else {
            e=args.get(j);
          }
          exprs.add(e);
        }
        newExpr=ExprCopy.getInstance().copy(expr,exprs);
      }
 else {
        newExpr=expr;
      }
      RestrictedExpr newRestExpr=new RestrictedExpr(newExpr,restExpr.getRestrictions());
      newVarDef.getMap().put(var,newRestExpr);
    }
  }
  Mapping result;
  if (projection.isEmpty()) {
    result=mapping;
  }
 else {
    SqlOp sqlOp=mapping.getSqlOp();
    SqlOp newSqlOp=SqlOpExtend.create(sqlOp,projection);
    result=new Mapping(newVarDef,newSqlOp);
  }
  return result;
}","/** 
 * Pushes all constants of a given mapping's varDefinition into the SQL. Used for creating union's of mappings: By pushing variables into the SQL we do not have to deal with disjoint unions (i.e. unions with discriminator columns) in order to know which union member yields the constant. 
 * @param mapping The mapping to process. 
 * @return A new mapping with all constants pushed.
 */
public static Mapping pushConstants(Mapping mapping){
  VarDefinition varDef=mapping.getVarDefinition();
  Set<String> columnNameBlacklist=new HashSet<String>(mapping.getSqlOp().getSchema().getColumnNames());
  Generator aliasGen=GeneratorBlacklist.create(""String_Node_Str"",columnNameBlacklist);
  Projection projection=new Projection();
  VarDefinition newVarDef=new VarDefinition();
  for (  Entry<Var,Collection<RestrictedExpr>> entry : varDef.getMap().asMap().entrySet()) {
    Var var=entry.getKey();
    Collection<RestrictedExpr> restExprs=entry.getValue();
    for (    RestrictedExpr restExpr : restExprs) {
      Expr newExpr;
      Expr expr=restExpr.getExpr();
      E_RdfTerm rdfTerm;
      if (expr.isConstant()) {
        rdfTerm=SqlTranslationUtils.expandConstant(expr);
      }
 else {
        rdfTerm=SqlTranslationUtils.expandRdfTerm(expr);
      }
      boolean isConstantArgsOnly=ExprUtils.isConstantArgsOnly(rdfTerm);
      if (isConstantArgsOnly) {
        NodeValue constant=expr.eval(null,null);
        String alias=aliasGen.next();
        String str=""String_Node_Str"" + NodeValueUtils.getValue(constant);
        S_Constant sqlExpr=new S_Constant(new SqlValue(TypeToken.String,str));
        projection.put(alias,sqlExpr);
        ExprVar exprVar=new ExprVar(alias);
        ExprList exprs=new ExprList();
        List<Expr> args=rdfTerm.getArgs();
        for (int j=0; j < args.size(); ++j) {
          Expr e;
          if (j == 1) {
            e=exprVar;
          }
 else {
            e=args.get(j);
          }
          exprs.add(e);
        }
        newExpr=ExprCopy.getInstance().copy(rdfTerm,exprs);
      }
 else {
        newExpr=expr;
      }
      RestrictedExpr newRestExpr=new RestrictedExpr(newExpr,restExpr.getRestrictions());
      newVarDef.getMap().put(var,newRestExpr);
    }
  }
  Mapping result;
  if (projection.isEmpty()) {
    result=mapping;
  }
 else {
    SqlOp sqlOp=mapping.getSqlOp();
    SqlOp newSqlOp=SqlOpExtend.create(sqlOp,projection);
    result=new Mapping(newVarDef,newSqlOp);
  }
  return result;
}",0.997767404099858
9833,"public WatchDog(Statement stmt,int timeOutInMillis){
  this.stmt=stmt;
  this.timeOutInMillis=timeOutInMillis;
}","public WatchDog(Statement stmt,long timeOutInMillis){
  this.stmt=stmt;
  this.timeOutInMillis=timeOutInMillis;
}",0.9777777777777776
9834,"@Override public ResultSet execSelect(){
  Var idVar=Var.alloc(""String_Node_Str"");
  Var executionTimeVar=Var.alloc(""String_Node_Str"");
  Var timeOutVar=Var.alloc(""String_Node_Str"");
  Var resultSetSizeVar=Var.alloc(""String_Node_Str"");
  Var isErrorVar=Var.alloc(""String_Node_Str"");
  Var errorMsgVar=Var.alloc(""String_Node_Str"");
  Var queryStringVar=Var.alloc(""String_Node_Str"");
  List<String> resultVars=Arrays.asList(idVar.getVarName(),executionTimeVar.getVarName(),timeOutVar.getVarName(),resultSetSizeVar.getVarName(),isErrorVar.getVarName(),errorMsgVar.getVarName(),queryStringVar.getVarName());
  List<Binding> resultBindings=new ArrayList<Binding>();
  SparqlSqlOpRewrite ssoRewrite=sparqlSqlOpRewriter.rewrite(query);
  SqlOp sqlOp=ssoRewrite.getSqlOp();
  int id=0;
  if (sqlOp instanceof SqlOpSelectBlock) {
    SqlOpSelectBlock b=(SqlOpSelectBlock)sqlOp;
    SqlOp subOp=b.getSubOp();
    if (subOp instanceof SqlOpUnionN) {
      SqlOpUnionN u=(SqlOpUnionN)subOp;
      for (      SqlOp member : u.getSubOps()) {
        SqlOpSelectBlock m=(SqlOpSelectBlock)member;
        SqlOpSelectBlock block=SqlOpSelectBlock.create(m.getSubOp());
        block.getProjection().put(""String_Node_Str"",new S_Constant(SqlValue.TRUE));
        block.getConditions().addAll(m.getConditions());
        block.setLimit(100l);
        block.setAliasName(""String_Node_Str"");
        SqlOpSelectBlock wrapper=SqlOpSelectBlock.create(block);
        wrapper.getProjection().put(""String_Node_Str"",new S_Agg(new S_AggCount()));
        ++id;
        String sqlQueryString=sqlOpSerializer.serialize(wrapper);
        logger.info(""String_Node_Str"" + sqlQueryString);
        long start=System.currentTimeMillis();
        long elapsedTime=timeOutInMillis;
        boolean timeOut=true;
        Node resultSetSizeNode=null;
        Node errorMsgNode=null;
        boolean isError=false;
        Connection conn=null;
        java.sql.ResultSet sqlRs=null;
        try {
          conn=dataSource.getConnection();
          conn.setAutoCommit(false);
          Statement stmt=QueryExecutionSelect.createStatement(conn);
          Thread thread=null;
          WatchDog watchDog=null;
          try {
            stmt.setQueryTimeout(timeOutInMillis);
          }
 catch (          Exception e) {
            logger.warn(""String_Node_Str"");
            watchDog=new WatchDog(stmt,timeOutInMillis);
            thread=new Thread(watchDog);
            thread.start();
          }
          sqlRs=stmt.executeQuery(sqlQueryString);
          if (thread != null) {
            timeOut=false;
            watchDog.cancel();
          }
          sqlRs.next();
          long resultSetSize=sqlRs.getLong(""String_Node_Str"");
          resultSetSizeNode=NodeValue.makeInteger(resultSetSize).asNode();
          long end=System.currentTimeMillis();
          elapsedTime=end - start;
        }
 catch (        SQLTimeoutException e) {
          timeOut=true;
        }
catch (        Exception e) {
          String errorMsg=e.getMessage();
          errorMsgNode=NodeValue.makeString(errorMsg).asNode();
          isError=true;
          if (elapsedTime >= timeOutInMillis) {
            timeOut=true;
          }
        }
 finally {
          if (sqlRs != null) {
            try {
              sqlRs.close();
            }
 catch (            SQLException e) {
              throw new RuntimeException(e);
            }
          }
          if (conn != null) {
            try {
              conn.close();
            }
 catch (            SQLException e) {
              throw new RuntimeException(e);
            }
          }
        }
        BindingHashMap binding=new BindingHashMap();
        binding.add(idVar,NodeValue.makeInteger(id).asNode());
        binding.add(executionTimeVar,NodeValue.makeInteger(elapsedTime).asNode());
        binding.add(timeOutVar,NodeValue.makeBoolean(timeOut).asNode());
        binding.add(resultSetSizeVar,resultSetSizeNode);
        binding.add(isErrorVar,NodeValue.makeBoolean(isError).asNode());
        binding.add(errorMsgVar,errorMsgNode);
        binding.add(queryStringVar,NodeValue.makeString(sqlQueryString).asNode());
        resultBindings.add(binding);
      }
    }
  }
  QueryIterator queryIterator=new QueryIterPlainWrapper(resultBindings.iterator());
  ResultSet result=ResultSetFactory.create(queryIterator,resultVars);
  return result;
}","@Override public ResultSet execSelect(){
  Var idVar=Var.alloc(""String_Node_Str"");
  Var executionTimeVar=Var.alloc(""String_Node_Str"");
  Var timeOutVar=Var.alloc(""String_Node_Str"");
  Var resultSetSizeVar=Var.alloc(""String_Node_Str"");
  Var isErrorVar=Var.alloc(""String_Node_Str"");
  Var errorMsgVar=Var.alloc(""String_Node_Str"");
  Var queryStringVar=Var.alloc(""String_Node_Str"");
  List<String> resultVars=Arrays.asList(idVar.getVarName(),executionTimeVar.getVarName(),timeOutVar.getVarName(),resultSetSizeVar.getVarName(),isErrorVar.getVarName(),errorMsgVar.getVarName(),queryStringVar.getVarName());
  List<Binding> resultBindings=new ArrayList<Binding>();
  SparqlSqlOpRewrite ssoRewrite=sparqlSqlOpRewriter.rewrite(query);
  SqlOp sqlOp=ssoRewrite.getSqlOp();
  int id=0;
  if (sqlOp instanceof SqlOpSelectBlock) {
    SqlOpSelectBlock b=(SqlOpSelectBlock)sqlOp;
    SqlOp subOp=b.getSubOp();
    if (subOp instanceof SqlOpUnionN) {
      SqlOpUnionN u=(SqlOpUnionN)subOp;
      for (      SqlOp member : u.getSubOps()) {
        SqlOpSelectBlock m=(SqlOpSelectBlock)member;
        SqlOpSelectBlock block=SqlOpSelectBlock.create(m.getSubOp());
        block.getProjection().put(""String_Node_Str"",new S_Constant(SqlValue.TRUE));
        block.getConditions().addAll(m.getConditions());
        block.setLimit(100l);
        block.setAliasName(""String_Node_Str"");
        SqlOpSelectBlock wrapper=SqlOpSelectBlock.create(block);
        wrapper.getProjection().put(""String_Node_Str"",new S_Agg(new S_AggCount()));
        ++id;
        String sqlQueryString=sqlOpSerializer.serialize(wrapper);
        logger.info(""String_Node_Str"" + sqlQueryString);
        long start=System.currentTimeMillis();
        long queryTimeOutInMillis=queryTimeOutInSeconds * 1000;
        boolean timeOut=true;
        Node resultSetSizeNode=null;
        Node errorMsgNode=null;
        boolean isError=false;
        Connection conn=null;
        java.sql.ResultSet sqlRs=null;
        long elapsedTimeInMillis=0;
        try {
          try {
            conn=dataSource.getConnection();
            conn.setAutoCommit(false);
            Statement stmt=QueryExecutionSelect.createStatement(conn);
            Thread thread=null;
            WatchDog watchDog=null;
            try {
              stmt.setQueryTimeout(queryTimeOutInSeconds);
            }
 catch (            Exception e) {
              logger.warn(""String_Node_Str"");
              watchDog=new WatchDog(stmt,queryTimeOutInMillis);
              thread=new Thread(watchDog);
              thread.start();
            }
            sqlRs=stmt.executeQuery(sqlQueryString);
            if (thread != null) {
              timeOut=false;
              watchDog.cancel();
            }
          }
  finally {
            long end=System.currentTimeMillis();
            elapsedTimeInMillis=end - start;
          }
          sqlRs.next();
          long resultSetSize=sqlRs.getLong(""String_Node_Str"");
          resultSetSizeNode=NodeValue.makeInteger(resultSetSize).asNode();
        }
 catch (        SQLTimeoutException e) {
          timeOut=true;
        }
catch (        Exception e) {
          String errorMsg=e.getMessage();
          errorMsgNode=NodeValue.makeString(errorMsg).asNode();
          isError=true;
          if (elapsedTimeInMillis >= queryTimeOutInSeconds) {
            timeOut=true;
          }
        }
 finally {
          if (sqlRs != null) {
            try {
              sqlRs.close();
            }
 catch (            SQLException e) {
              throw new RuntimeException(e);
            }
          }
          if (conn != null) {
            try {
              conn.close();
            }
 catch (            SQLException e) {
              throw new RuntimeException(e);
            }
          }
        }
        BindingHashMap binding=new BindingHashMap();
        binding.add(idVar,NodeValue.makeInteger(id).asNode());
        binding.add(executionTimeVar,NodeValue.makeInteger(elapsedTimeInMillis).asNode());
        binding.add(timeOutVar,NodeValue.makeBoolean(timeOut).asNode());
        binding.add(resultSetSizeVar,resultSetSizeNode);
        binding.add(isErrorVar,NodeValue.makeBoolean(isError).asNode());
        binding.add(errorMsgVar,errorMsgNode);
        binding.add(queryStringVar,NodeValue.makeString(sqlQueryString).asNode());
        resultBindings.add(binding);
      }
    }
  }
  QueryIterator queryIterator=new QueryIterPlainWrapper(resultBindings.iterator());
  ResultSet result=ResultSetFactory.create(queryIterator,resultVars);
  return result;
}",0.953667522608016
9835,"public static String encodeCell(String cell){
  String result=cell.replace(""String_Node_Str"",""String_Node_Str"");
  return result;
}","public static String encodeCell(String cell){
  String result;
  result=cell.replace(""String_Node_Str"",""String_Node_Str"");
  return result;
}",0.9632352941176472
9836,"@Override public int read(char[] cbuf,int off,int len) throws IOException {
  if (offset < 0) {
    return -1;
  }
  int initOff=off;
  while (len > 0) {
    int lineLen=line == null ? 0 : line.length();
    int lineAvailLen=lineLen - offset;
    int readLen=Math.min(lineAvailLen,len);
    if (readLen > 0) {
      line.getChars(offset,offset + readLen,cbuf,off);
      off+=readLen;
      len-=readLen;
      lineAvailLen-=readLen;
    }
    if (len > 0 && lineAvailLen <= 0) {
      line=nextString();
      if (line == null) {
        offset=-1;
        break;
      }
      offset=0;
    }
  }
  int result=off - initOff;
  return result;
}","@Override public int read(char[] cbuf,int dstBegin,int len) throws IOException {
  if (offset < 0) {
    return -1;
  }
  int initOff=dstBegin;
  while (len > 0) {
    int lineLen=line == null ? 0 : line.length();
    int lineAvailLen=lineLen - offset;
    int readLen=Math.min(lineAvailLen,len);
    if (readLen > 0) {
      int srcEnd=offset + readLen;
      line.getChars(offset,srcEnd,cbuf,dstBegin);
      offset=srcEnd;
      dstBegin+=readLen;
      len-=readLen;
      lineAvailLen-=readLen;
    }
    if (len > 0 && lineAvailLen <= 0) {
      line=nextString();
      if (line == null) {
        offset=-1;
        break;
      }
      offset=0;
    }
  }
  int result=dstBegin - initOff;
  return result;
}",0.8890521675238795
9837,"public static void main(String[] args) throws Exception {
  Model testModel=ModelFactory.createDefaultModel();
  testModel.read(new FileInputStream(new File(""String_Node_Str"")),null,""String_Node_Str"");
  ModelSparqlEndpoint endpoint=new ModelSparqlEndpoint(testModel);
  UpdateGraph graph=new UpdateGraph(endpoint);
  CleanListener cleaner=new CleanListener(endpoint);
  graph.getPreUpdateListeners().add(cleaner);
  String queryString=""String_Node_Str"";
  IncrementalQueryUpdateManager queryUpdates=new IncrementalQueryUpdateManager(queryString,endpoint);
  cleaner.getGraphListeners().add(queryUpdates);
  String inserts=Files.readContent(new File(""String_Node_Str""));
  String stmt=""String_Node_Str"" + inserts + ""String_Node_Str"";
  graph.executeUpdate(stmt);
  processChanges(queryUpdates.getChanges());
  stmt=""String_Node_Str"" + inserts + ""String_Node_Str"";
  graph.executeUpdate(stmt);
  processChanges(queryUpdates.getChanges());
  stmt=""String_Node_Str"";
  graph.executeUpdate(stmt);
  processChanges(queryUpdates.getChanges());
}","public static void main(String[] args) throws Exception {
  Model testModel=ModelFactory.createDefaultModel();
  testModel.read(new FileInputStream(new File(""String_Node_Str"")),null,""String_Node_Str"");
  ModelSparqlEndpoint endpoint=new ModelSparqlEndpoint(testModel);
  UpdateGraph graph=new UpdateGraph(endpoint);
  CleanListener cleaner=new CleanListener(endpoint);
  graph.getPreUpdateListeners().add(cleaner);
  String queryString=""String_Node_Str"";
  IncrementalQueryUpdateManager queryUpdates=new IncrementalQueryUpdateManager(queryString,endpoint);
  cleaner.getGraphListeners().add(queryUpdates);
  String inserts=Files.readContent(new File(""String_Node_Str""));
  String stmt=""String_Node_Str"" + inserts + ""String_Node_Str"";
  graph.executeUpdate(stmt);
  processChanges(queryUpdates.getChanges());
}",0.8755411255411255
9838,"public IteratorResultSetSparqlifyBinding(ResultSet rs,Multimap<Var,RestrictedExpr> sparqlVarMap){
  this.rs=rs;
  this.sparqlVarMap=sparqlVarMap;
}","public IteratorResultSetSparqlifyBinding(ResultSet rs,Multimap<Var,RestrictedExpr> sparqlVarMap,long nextRowId,String rowIdName){
  this.rs=rs;
  this.sparqlVarMap=sparqlVarMap;
  this.nextRowId=nextRowId;
  this.rowIdVar=rowIdName == null ? null : Var.alloc(rowIdName);
}",0.7016706443914081
9839,"@Override protected Binding prefetch() throws Exception {
  if (!rs.next()) {
    return super.finish();
  }
  ResultSetMetaData meta=rs.getMetaData();
  BindingMap binding=new BindingHashMap();
  for (int i=1; i <= meta.getColumnCount(); ++i) {
    String colName=meta.getColumnLabel(i);
    Object colValue=rs.getObject(i);
    NodeValue nodeValue;
    if (colValue instanceof Date) {
      String tmp=colValue.toString();
      nodeValue=NodeValue.makeDate(tmp);
    }
 else     if (colValue instanceof Timestamp) {
      String tmp=colValue.toString();
      String val=tmp.replace(' ','T');
      nodeValue=NodeValue.makeDateTime(val);
    }
 else {
      nodeValue=MakeNodeValue.makeNodeValue(colValue);
    }
    if (nodeValue == null) {
      continue;
    }
    Node node=nodeValue.asNode();
    Var indexVar=Var.alloc(""String_Node_Str"" + i);
    binding.add(indexVar,node);
    Var colVar=Var.alloc(colName);
    if (!binding.contains(colVar)) {
      binding.add(colVar,node);
    }
  }
  boolean debugMode=true;
  BindingMap result=new BindingHashMap();
  for (  Entry<Var,Collection<RestrictedExpr>> entry : sparqlVarMap.asMap().entrySet()) {
    Var bindingVar=entry.getKey();
    Collection<RestrictedExpr> candidateExprs=entry.getValue();
    NodeValue value=null;
    Set<Var> usedVars=new HashSet<Var>();
    for (    RestrictedExpr def : candidateExprs) {
      Expr expr=def.getExpr();
      boolean allBound=true;
      Set<Var> exprVars=expr.getVarsMentioned();
      for (      Var var : exprVars) {
        if (!binding.contains(var)) {
          allBound=false;
          break;
        }
      }
      if (allBound) {
        if (value != null) {
          if (usedVars.containsAll(expr.getVarsMentioned())) {
            continue;
          }
 else           if (usedVars.equals(expr.getVarsMentioned())) {
            throw new RuntimeException(""String_Node_Str"" + bindingVar + ""String_Node_Str""+ entry.getValue());
          }
 else           if (!expr.getVarsMentioned().containsAll(usedVars)) {
            throw new RuntimeException(""String_Node_Str"" + bindingVar + ""String_Node_Str""+ entry.getValue());
          }
        }
        expr=MakeExprPermissive.getInstance().deepCopy(expr);
        value=ExprUtils.eval(expr,binding);
        if (!debugMode) {
          break;
        }
      }
    }
    Node resultValue=value == null ? null : value.asNode();
    if (resultValue == null) {
      logger.trace(""String_Node_Str"" + bindingVar + ""String_Node_Str"");
    }
 else {
      boolean isDatatypeCanonicalization=false;
      Node canonResultValue=canonicalizer.convert(resultValue);
      if (!isDatatypeCanonicalization) {
        if (canonResultValue.isLiteral()) {
          String lex=canonResultValue.getLiteralLexicalForm();
          if (resultValue.isLiteral()) {
            RDFDatatype originalType=resultValue.getLiteralDatatype();
            if (originalType != null) {
              canonResultValue=Node.createLiteral(lex,originalType);
            }
          }
 else {
            throw new RuntimeException(""String_Node_Str"" + resultValue + ""String_Node_Str""+ canonResultValue);
          }
        }
      }
      result.add(bindingVar,canonResultValue);
    }
  }
  return result;
}","@Override protected Binding prefetch() throws Exception {
  if (!rs.next()) {
    return super.finish();
  }
  ResultSetMetaData meta=rs.getMetaData();
  BindingMap binding=new BindingHashMap();
  for (int i=1; i <= meta.getColumnCount(); ++i) {
    String colName=meta.getColumnLabel(i);
    Object colValue=rs.getObject(i);
    NodeValue nodeValue;
    if (colValue instanceof Date) {
      String tmp=colValue.toString();
      nodeValue=NodeValue.makeDate(tmp);
    }
 else     if (colValue instanceof Timestamp) {
      String tmp=colValue.toString();
      String val=tmp.replace(' ','T');
      nodeValue=NodeValue.makeDateTime(val);
    }
 else {
      nodeValue=MakeNodeValue.makeNodeValue(colValue);
    }
    if (nodeValue == null) {
      continue;
    }
    Node node=nodeValue.asNode();
    Var indexVar=Var.alloc(""String_Node_Str"" + i);
    binding.add(indexVar,node);
    Var colVar=Var.alloc(colName);
    if (!binding.contains(colVar)) {
      binding.add(colVar,node);
    }
  }
  if (rowIdVar != null) {
    long rowId=nextRowId++;
    Node node=NodeValue.makeInteger(rowId).asNode();
    binding.add(rowIdVar,node);
  }
  boolean debugMode=true;
  BindingMap result=new BindingHashMap();
  for (  Entry<Var,Collection<RestrictedExpr>> entry : sparqlVarMap.asMap().entrySet()) {
    Var bindingVar=entry.getKey();
    Collection<RestrictedExpr> candidateExprs=entry.getValue();
    NodeValue value=null;
    Set<Var> usedVars=new HashSet<Var>();
    for (    RestrictedExpr def : candidateExprs) {
      Expr expr=def.getExpr();
      boolean allBound=true;
      Set<Var> exprVars=expr.getVarsMentioned();
      for (      Var var : exprVars) {
        if (!binding.contains(var)) {
          allBound=false;
          break;
        }
      }
      if (allBound) {
        if (value != null) {
          if (usedVars.containsAll(expr.getVarsMentioned())) {
            continue;
          }
 else           if (usedVars.equals(expr.getVarsMentioned())) {
            throw new RuntimeException(""String_Node_Str"" + bindingVar + ""String_Node_Str""+ entry.getValue());
          }
 else           if (!expr.getVarsMentioned().containsAll(usedVars)) {
            throw new RuntimeException(""String_Node_Str"" + bindingVar + ""String_Node_Str""+ entry.getValue());
          }
        }
        expr=MakeExprPermissive.getInstance().deepCopy(expr);
        value=ExprUtils.eval(expr,binding);
        if (!debugMode) {
          break;
        }
      }
    }
    Node resultValue=value == null ? null : value.asNode();
    if (resultValue == null) {
      logger.trace(""String_Node_Str"" + bindingVar + ""String_Node_Str"");
    }
 else {
      boolean isDatatypeCanonicalization=false;
      Node canonResultValue=canonicalizer.convert(resultValue);
      if (!isDatatypeCanonicalization) {
        if (canonResultValue.isLiteral()) {
          String lex=canonResultValue.getLiteralLexicalForm();
          if (resultValue.isLiteral()) {
            RDFDatatype originalType=resultValue.getLiteralDatatype();
            if (originalType != null) {
              canonResultValue=Node.createLiteral(lex,originalType);
            }
          }
 else {
            throw new RuntimeException(""String_Node_Str"" + resultValue + ""String_Node_Str""+ canonResultValue);
          }
        }
      }
      result.add(bindingVar,canonResultValue);
    }
  }
  return result;
}",0.9784020540703822
9840,"public void close(){
  if (rs != null) {
    try {
      rs.close();
    }
 catch (    SQLException e) {
      e.printStackTrace();
    }
  }
}","@Override public void close(){
  if (rs != null) {
    try {
      rs.close();
    }
 catch (    SQLException e) {
      e.printStackTrace();
    }
  }
}",0.9662162162162162
9841,"@Override public QueryExecutionStreaming createQueryExecution(Query query){
  logger.info(""String_Node_Str"" + query);
  Connection conn=null;
  try {
    conn=dataSource.getConnection();
    conn.setAutoCommit(false);
    QueryExecutionStreaming result=new QueryExecutionSparqlify(rewriter,conn,true,query,this);
    conn.commit();
    return result;
  }
 catch (  SQLException e) {
    if (conn != null) {
      try {
        conn.rollback();
      }
 catch (      SQLException f) {
        throw new RuntimeException(f);
      }
    }
    throw new RuntimeException(e);
  }
}","@Override public QueryExecutionStreaming createQueryExecution(Query query){
  logger.info(""String_Node_Str"" + query);
  Connection conn=null;
  try {
    conn=dataSource.getConnection();
    System.out.println(""String_Node_Str"" + conn + ""String_Node_Str"");
    conn.setAutoCommit(false);
    QueryExecutionStreaming result=new QueryExecutionSparqlify(rewriter,conn,true,query,this);
    return result;
  }
 catch (  SQLException e) {
    if (conn != null) {
      try {
        conn.rollback();
        conn.close();
      }
 catch (      SQLException f) {
        throw new RuntimeException(f);
      }
    }
    throw new RuntimeException(e);
  }
}",0.9095354523227384
9842,"@Override protected Binding prefetch() throws Exception {
  if (!rs.next()) {
    return super.finish();
  }
  ResultSetMetaData meta=rs.getMetaData();
  BindingMap binding=new BindingHashMap();
  for (int i=1; i <= meta.getColumnCount(); ++i) {
    String colName=meta.getColumnLabel(i);
    Object colValue=rs.getObject(i);
    System.out.println(colValue == null ? ""String_Node_Str"" : colValue.getClass());
    NodeValue nodeValue;
    if (colValue instanceof Date) {
      String tmp=colValue.toString();
      nodeValue=NodeValue.makeDate(tmp);
    }
 else     if (colValue instanceof Timestamp) {
      String tmp=colValue.toString();
      String val=tmp.replace(' ','T');
      nodeValue=NodeValue.makeDateTime(val);
    }
 else {
      nodeValue=MakeNodeValue.makeNodeValue(colValue);
    }
    if (nodeValue == null) {
      continue;
    }
    if (nodeValue.isDateTime()) {
      XSDDateTime val=nodeValue.getDateTime();
      String str=val.timeLexicalForm();
      String b=val.toString();
      System.out.println(""String_Node_Str"");
    }
    Node node=nodeValue.asNode();
    Var indexVar=Var.alloc(""String_Node_Str"" + i);
    binding.add(indexVar,node);
    Var colVar=Var.alloc(colName);
    if (!binding.contains(colVar)) {
      binding.add(colVar,node);
    }
  }
  boolean debugMode=true;
  BindingMap result=new BindingHashMap();
  for (  Entry<Var,Collection<RestrictedExpr>> entry : sparqlVarMap.asMap().entrySet()) {
    Var bindingVar=entry.getKey();
    Collection<RestrictedExpr> candidateExprs=entry.getValue();
    NodeValue value=null;
    Set<Var> usedVars=new HashSet<Var>();
    for (    RestrictedExpr def : candidateExprs) {
      Expr expr=def.getExpr();
      boolean allBound=true;
      Set<Var> exprVars=expr.getVarsMentioned();
      for (      Var var : exprVars) {
        if (!binding.contains(var)) {
          allBound=false;
          break;
        }
      }
      if (allBound) {
        if (value != null) {
          if (usedVars.containsAll(expr.getVarsMentioned())) {
            continue;
          }
 else           if (usedVars.equals(expr.getVarsMentioned())) {
            throw new RuntimeException(""String_Node_Str"" + bindingVar + ""String_Node_Str""+ entry.getValue());
          }
 else           if (!expr.getVarsMentioned().containsAll(usedVars)) {
            throw new RuntimeException(""String_Node_Str"" + bindingVar + ""String_Node_Str""+ entry.getValue());
          }
        }
        expr=MakeExprPermissive.getInstance().deepCopy(expr);
        value=ExprUtils.eval(expr,binding);
        if (!debugMode) {
          break;
        }
      }
    }
    Node resultValue=value == null ? null : value.asNode();
    if (resultValue == null) {
      logger.trace(""String_Node_Str"" + bindingVar + ""String_Node_Str"");
    }
 else {
      boolean isDatatypeCanonicalization=false;
      Node canonResultValue=canonicalizer.convert(resultValue);
      if (!isDatatypeCanonicalization) {
        if (canonResultValue.isLiteral()) {
          String lex=canonResultValue.getLiteralLexicalForm();
          if (resultValue.isLiteral()) {
            RDFDatatype originalType=resultValue.getLiteralDatatype();
            if (originalType != null) {
              canonResultValue=Node.createLiteral(lex,originalType);
            }
          }
 else {
            throw new RuntimeException(""String_Node_Str"" + resultValue + ""String_Node_Str""+ canonResultValue);
          }
        }
      }
      result.add(bindingVar,canonResultValue);
    }
  }
  return result;
}","@Override protected Binding prefetch() throws Exception {
  if (!rs.next()) {
    return super.finish();
  }
  ResultSetMetaData meta=rs.getMetaData();
  BindingMap binding=new BindingHashMap();
  for (int i=1; i <= meta.getColumnCount(); ++i) {
    String colName=meta.getColumnLabel(i);
    Object colValue=rs.getObject(i);
    NodeValue nodeValue;
    if (colValue instanceof Date) {
      String tmp=colValue.toString();
      nodeValue=NodeValue.makeDate(tmp);
    }
 else     if (colValue instanceof Timestamp) {
      String tmp=colValue.toString();
      String val=tmp.replace(' ','T');
      nodeValue=NodeValue.makeDateTime(val);
    }
 else {
      nodeValue=MakeNodeValue.makeNodeValue(colValue);
    }
    if (nodeValue == null) {
      continue;
    }
    if (nodeValue.isDateTime()) {
      XSDDateTime val=nodeValue.getDateTime();
      String str=val.timeLexicalForm();
      String b=val.toString();
      System.out.println(""String_Node_Str"");
    }
    Node node=nodeValue.asNode();
    Var indexVar=Var.alloc(""String_Node_Str"" + i);
    binding.add(indexVar,node);
    Var colVar=Var.alloc(colName);
    if (!binding.contains(colVar)) {
      binding.add(colVar,node);
    }
  }
  boolean debugMode=true;
  BindingMap result=new BindingHashMap();
  for (  Entry<Var,Collection<RestrictedExpr>> entry : sparqlVarMap.asMap().entrySet()) {
    Var bindingVar=entry.getKey();
    Collection<RestrictedExpr> candidateExprs=entry.getValue();
    NodeValue value=null;
    Set<Var> usedVars=new HashSet<Var>();
    for (    RestrictedExpr def : candidateExprs) {
      Expr expr=def.getExpr();
      boolean allBound=true;
      Set<Var> exprVars=expr.getVarsMentioned();
      for (      Var var : exprVars) {
        if (!binding.contains(var)) {
          allBound=false;
          break;
        }
      }
      if (allBound) {
        if (value != null) {
          if (usedVars.containsAll(expr.getVarsMentioned())) {
            continue;
          }
 else           if (usedVars.equals(expr.getVarsMentioned())) {
            throw new RuntimeException(""String_Node_Str"" + bindingVar + ""String_Node_Str""+ entry.getValue());
          }
 else           if (!expr.getVarsMentioned().containsAll(usedVars)) {
            throw new RuntimeException(""String_Node_Str"" + bindingVar + ""String_Node_Str""+ entry.getValue());
          }
        }
        expr=MakeExprPermissive.getInstance().deepCopy(expr);
        value=ExprUtils.eval(expr,binding);
        if (!debugMode) {
          break;
        }
      }
    }
    Node resultValue=value == null ? null : value.asNode();
    if (resultValue == null) {
      logger.trace(""String_Node_Str"" + bindingVar + ""String_Node_Str"");
    }
 else {
      boolean isDatatypeCanonicalization=false;
      Node canonResultValue=canonicalizer.convert(resultValue);
      if (!isDatatypeCanonicalization) {
        if (canonResultValue.isLiteral()) {
          String lex=canonResultValue.getLiteralLexicalForm();
          if (resultValue.isLiteral()) {
            RDFDatatype originalType=resultValue.getLiteralDatatype();
            if (originalType != null) {
              canonResultValue=Node.createLiteral(lex,originalType);
            }
          }
 else {
            throw new RuntimeException(""String_Node_Str"" + resultValue + ""String_Node_Str""+ canonResultValue);
          }
        }
      }
      result.add(bindingVar,canonResultValue);
    }
  }
  return result;
}",0.9879448909299656
9843,"public static SqlOp makeSelect(SqlOpJoin op){
  JoinContext context=collectJoins(op);
  SqlOpSelectBlock block=SqlOpSelectBlock.create();
  block.setSubOp(context.getOp());
  block.setSchema(op.getSchema());
  block.getProjection().add(context.getProjection());
  block.getConditions().addAll(context.getConditions());
  return block;
}","public static SqlOp makeSelect(SqlOpJoin op){
  JoinContext context=collectJoins(op);
  SqlOpSelectBlock block=contextToBlock(op.getSchema(),context);
  return block;
}",0.6507936507936508
9844,"public static SqlOp _makeSelect(SqlOp sqlOp){
  SqlOp result=MultiMethod.invokeStatic(SqlOpSelectBlockCollectorImpl.class,""String_Node_Str"",sqlOp);
  return result;
}","/** 
 * Turn an SqlOp into an OpSqlSelectBlock. Exception is SqlOpUnion, which does not need to be wrapped as such block.
 * @param sqlOp
 * @return
 */
public static SqlOp _makeSelect(SqlOp sqlOp){
  SqlOp result=MultiMethod.invokeStatic(SqlOpSelectBlockCollectorImpl.class,""String_Node_Str"",sqlOp);
  return result;
}",0.6845360824742268
9845,"public void serializeJoinU(SqlOp op,String aliasName,IndentedWriter writer){
  boolean isSubSelect=op instanceof SqlOpUnionN;
  if (isSubSelect) {
    writer.println(""String_Node_Str"");
    writer.incIndent();
  }
  serialize(op,writer);
  if (isSubSelect) {
    writer.decIndent();
    if (!writer.atLineStart()) {
      writer.println();
    }
    writer.print(""String_Node_Str"" + aliasName);
  }
}","public void serializeJoinU(SqlOp op,String aliasName,IndentedWriter writer){
  boolean isSubSelect=op instanceof SqlOpSelectBlock || op instanceof SqlOpUnionN;
  if (isSubSelect) {
    writer.println(""String_Node_Str"");
    writer.incIndent();
  }
  serialize(op,writer);
  if (isSubSelect) {
    writer.decIndent();
    if (!writer.atLineStart()) {
      writer.println();
    }
    writer.print(""String_Node_Str"" + aliasName);
  }
}",0.9592326139088728
9846,"/** 
 * Create the SPARQL and SQL models
 */
public static void initSparqlModel(TypeSystem typeSystem){
  S_Constant x;
  TypeMapper tm=TypeMapper.getInstance();
  String xxx=""String_Node_Str"";
  SqlTypeMapper stm=typeSystem.getSqlTypeMapper();
  stm.register(XSD.xstring.getURI(),new SqlDatatypeDefault(TypeToken.String,new NodeValueToObjectDefault()));
  stm.register(XSD.xboolean.getURI(),new SqlDatatypeDefault(TypeToken.Boolean,new NodeValueToObjectDefault()));
  CoercionSystemImpl3 cs=(CoercionSystemImpl3)typeSystem.getCoercionSystem();
  cs.registerCoercion(TypeToken.alloc(XSD.integer.toString()),TypeToken.Int,new SqlValueTransformerInteger());
  cs.registerCoercion(TypeToken.String,TypeToken.alloc(""String_Node_Str""),new SqlValueTransformerInteger());
  cs.registerCoercion(TypeToken.String,TypeToken.alloc(""String_Node_Str""),new SqlValueTransformerInteger());
  cs.registerCoercion(TypeToken.String,TypeToken.alloc(""String_Node_Str""),new SqlValueTransformerInteger());
  ExprBindingSubstitutor exprBindingSubstitutor=new ExprBindingSubstitutorImpl();
  ExprEvaluator exprTransformer=SqlTranslationUtils.createDefaultEvaluator();
  TypedExprTransformer typedExprTransformer=new TypedExprTransformerImpl(typeSystem);
  DatatypeToStringPostgres typeSerializer=new DatatypeToStringPostgres();
  SqlLiteralMapper sqlLiteralMapper=new SqlLiteralMapperDefault(typeSerializer);
  SqlExprSerializerSystem serializerSystem=new SqlExprSerializerSystemImpl(typeSerializer,sqlLiteralMapper);
{
    MethodSignature<TypeToken> sig=MethodSignature.create(false,TypeToken.Boolean,TypeToken.rdfTerm,TypeToken.rdfTerm);
    SqlExprEvaluator evaluator=new SqlExprEvaluator_Equals(typeSystem);
    SparqlFunction f=new SparqlFunctionImpl(""String_Node_Str"",sig,evaluator,null);
    typeSystem.registerSparqlFunction(f);
    SqlFunctionSerializer serializer=new SqlFunctionSerializerOp2(""String_Node_Str"");
    serializerSystem.addSerializer(""String_Node_Str"",serializer);
  }
{
    MethodSignature<TypeToken> sig=MethodSignature.create(false,TypeToken.Boolean,TypeToken.Boolean,TypeToken.Boolean);
    SqlExprEvaluator evaluator=new SqlExprEvaluator_LogicalAnd();
    SparqlFunction f=new SparqlFunctionImpl(""String_Node_Str"",sig,evaluator,null);
    typeSystem.registerSparqlFunction(f);
    SqlFunctionSerializer serializer=new SqlFunctionSerializerOp2(""String_Node_Str"");
    serializerSystem.addSerializer(""String_Node_Str"",serializer);
  }
{
    SqlFunctionSerializer serializer=new SqlFunctionSerializerDefault(""String_Node_Str"");
    serializerSystem.addSerializer(""String_Node_Str"",serializer);
  }
{
    MethodSignature<TypeToken> sig=MethodSignature.create(false,TypeToken.Boolean,TypeToken.Boolean,TypeToken.Boolean);
    SqlExprEvaluator evaluator=new SqlExprEvaluator_LogicalOr();
    SparqlFunction f=new SparqlFunctionImpl(""String_Node_Str"",sig,evaluator,null);
    typeSystem.registerSparqlFunction(f);
    SqlFunctionSerializer serializer=new SqlFunctionSerializerOp2(""String_Node_Str"");
    serializerSystem.addSerializer(""String_Node_Str"",serializer);
  }
{
    MethodSignature<TypeToken> sig=MethodSignature.create(false,TypeToken.Boolean,TypeToken.Boolean);
    SqlExprEvaluator evaluator=new SqlExprEvaluator_LogicalNot();
    SparqlFunction f=new SparqlFunctionImpl(""String_Node_Str"",sig,evaluator,null);
    typeSystem.registerSparqlFunction(f);
    SqlFunctionSerializer serializer=new SqlFunctionSerializerOp1(""String_Node_Str"");
    serializerSystem.addSerializer(""String_Node_Str"",serializer);
  }
{
  }
  Expr e0=ExprUtils.parse(""String_Node_Str"");
  Expr a=ExprUtils.parse(""String_Node_Str"");
  Expr b=ExprUtils.parse(""String_Node_Str"");
  Expr c=ExprUtils.parse(""String_Node_Str"");
  Expr d=ExprUtils.parse(""String_Node_Str"");
  Expr e=ExprUtils.parse(""String_Node_Str"");
  Map<Var,Expr> binding=new HashMap<Var,Expr>();
  binding.put(Var.alloc(""String_Node_Str""),a);
  binding.put(Var.alloc(""String_Node_Str""),b);
  binding.put(Var.alloc(""String_Node_Str""),c);
  binding.put(Var.alloc(""String_Node_Str""),d);
  binding.put(Var.alloc(""String_Node_Str""),e);
  Map<String,TypeToken> typeMap=new HashMap<String,TypeToken>();
  typeMap.put(""String_Node_Str"",TypeToken.String);
  typeMap.put(""String_Node_Str"",TypeToken.String);
  typeMap.put(""String_Node_Str"",TypeToken.Int);
  logger.debug(""String_Node_Str"" + e0);
  Expr e1=exprBindingSubstitutor.substitute(e0,binding);
  logger.debug(""String_Node_Str"" + e1);
  Expr e2=exprTransformer.transform(e1);
  logger.debug(""String_Node_Str"" + e2);
  ExprSqlRewrite e3=typedExprTransformer.rewrite(e2,typeMap);
  logger.debug(""String_Node_Str"" + e3);
  Expr et=e3.getExpr();
  if (et instanceof ExprSqlBridge) {
    ExprSqlBridge bridge=(ExprSqlBridge)et;
    SqlExpr ex=bridge.getSqlExpr();
    String e4=serializerSystem.serialize(ex);
    logger.debug(""String_Node_Str"" + e4);
  }
 else {
    logger.debug(""String_Node_Str"");
    logger.debug(""String_Node_Str"" + et);
    logger.debug(""String_Node_Str"" + e3.getProjection());
  }
}","/** 
 * Create the SPARQL and SQL models
 */
public static void initSparqlModel(TypeSystem typeSystem){
  S_Constant x;
  TypeMapper tm=TypeMapper.getInstance();
  String xxx=""String_Node_Str"";
  SqlTypeMapper stm=typeSystem.getSqlTypeMapper();
  stm.register(XSD.xstring.getURI(),new SqlDatatypeDefault(TypeToken.String,new NodeValueToObjectDefault()));
  stm.register(XSD.xboolean.getURI(),new SqlDatatypeDefault(TypeToken.Boolean,new NodeValueToObjectDefault()));
  CoercionSystemImpl3 cs=(CoercionSystemImpl3)typeSystem.getCoercionSystem();
  cs.registerCoercion(TypeToken.alloc(XSD.integer.toString()),TypeToken.Int,new SqlValueTransformerInteger());
  cs.registerCoercion(TypeToken.String,TypeToken.alloc(""String_Node_Str""),new SqlValueTransformerInteger());
  cs.registerCoercion(TypeToken.String,TypeToken.alloc(""String_Node_Str""),new SqlValueTransformerInteger());
  cs.registerCoercion(TypeToken.String,TypeToken.alloc(""String_Node_Str""),new SqlValueTransformerInteger());
  cs.registerCoercion(TypeToken.String,TypeToken.alloc(""String_Node_Str""),new SqlValueTransformerInteger());
  ExprBindingSubstitutor exprBindingSubstitutor=new ExprBindingSubstitutorImpl();
  ExprEvaluator exprTransformer=SqlTranslationUtils.createDefaultEvaluator();
  TypedExprTransformer typedExprTransformer=new TypedExprTransformerImpl(typeSystem);
  DatatypeToStringPostgres typeSerializer=new DatatypeToStringPostgres();
  SqlLiteralMapper sqlLiteralMapper=new SqlLiteralMapperDefault(typeSerializer);
  SqlExprSerializerSystem serializerSystem=new SqlExprSerializerSystemImpl(typeSerializer,sqlLiteralMapper);
{
    MethodSignature<TypeToken> sig=MethodSignature.create(false,TypeToken.Boolean,TypeToken.rdfTerm,TypeToken.rdfTerm);
    SqlExprEvaluator evaluator=new SqlExprEvaluator_Equals(typeSystem);
    SparqlFunction f=new SparqlFunctionImpl(""String_Node_Str"",sig,evaluator,null);
    typeSystem.registerSparqlFunction(f);
    SqlFunctionSerializer serializer=new SqlFunctionSerializerOp2(""String_Node_Str"");
    serializerSystem.addSerializer(""String_Node_Str"",serializer);
  }
{
    MethodSignature<TypeToken> sig=MethodSignature.create(false,TypeToken.Boolean,TypeToken.Boolean,TypeToken.Boolean);
    SqlExprEvaluator evaluator=new SqlExprEvaluator_LogicalAnd();
    SparqlFunction f=new SparqlFunctionImpl(""String_Node_Str"",sig,evaluator,null);
    typeSystem.registerSparqlFunction(f);
    SqlFunctionSerializer serializer=new SqlFunctionSerializerOp2(""String_Node_Str"");
    serializerSystem.addSerializer(""String_Node_Str"",serializer);
  }
{
    SqlFunctionSerializer serializer=new SqlFunctionSerializerDefault(""String_Node_Str"");
    serializerSystem.addSerializer(""String_Node_Str"",serializer);
  }
{
    MethodSignature<TypeToken> sig=MethodSignature.create(false,TypeToken.Boolean,TypeToken.Boolean,TypeToken.Boolean);
    SqlExprEvaluator evaluator=new SqlExprEvaluator_LogicalOr();
    SparqlFunction f=new SparqlFunctionImpl(""String_Node_Str"",sig,evaluator,null);
    typeSystem.registerSparqlFunction(f);
    SqlFunctionSerializer serializer=new SqlFunctionSerializerOp2(""String_Node_Str"");
    serializerSystem.addSerializer(""String_Node_Str"",serializer);
  }
{
    MethodSignature<TypeToken> sig=MethodSignature.create(false,TypeToken.Boolean,TypeToken.Boolean);
    SqlExprEvaluator evaluator=new SqlExprEvaluator_LogicalNot();
    SparqlFunction f=new SparqlFunctionImpl(""String_Node_Str"",sig,evaluator,null);
    typeSystem.registerSparqlFunction(f);
    SqlFunctionSerializer serializer=new SqlFunctionSerializerOp1(""String_Node_Str"");
    serializerSystem.addSerializer(""String_Node_Str"",serializer);
  }
{
  }
  Expr e0=ExprUtils.parse(""String_Node_Str"");
  Expr a=ExprUtils.parse(""String_Node_Str"");
  Expr b=ExprUtils.parse(""String_Node_Str"");
  Expr c=ExprUtils.parse(""String_Node_Str"");
  Expr d=ExprUtils.parse(""String_Node_Str"");
  Expr e=ExprUtils.parse(""String_Node_Str"");
  Map<Var,Expr> binding=new HashMap<Var,Expr>();
  binding.put(Var.alloc(""String_Node_Str""),a);
  binding.put(Var.alloc(""String_Node_Str""),b);
  binding.put(Var.alloc(""String_Node_Str""),c);
  binding.put(Var.alloc(""String_Node_Str""),d);
  binding.put(Var.alloc(""String_Node_Str""),e);
  Map<String,TypeToken> typeMap=new HashMap<String,TypeToken>();
  typeMap.put(""String_Node_Str"",TypeToken.String);
  typeMap.put(""String_Node_Str"",TypeToken.String);
  typeMap.put(""String_Node_Str"",TypeToken.Int);
  logger.debug(""String_Node_Str"" + e0);
  Expr e1=exprBindingSubstitutor.substitute(e0,binding);
  logger.debug(""String_Node_Str"" + e1);
  Expr e2=exprTransformer.transform(e1);
  logger.debug(""String_Node_Str"" + e2);
  ExprSqlRewrite e3=typedExprTransformer.rewrite(e2,typeMap);
  logger.debug(""String_Node_Str"" + e3);
  Expr et=e3.getExpr();
  if (et instanceof ExprSqlBridge) {
    ExprSqlBridge bridge=(ExprSqlBridge)et;
    SqlExpr ex=bridge.getSqlExpr();
    String e4=serializerSystem.serialize(ex);
    logger.debug(""String_Node_Str"" + e4);
  }
 else {
    logger.debug(""String_Node_Str"");
    logger.debug(""String_Node_Str"" + et);
    logger.debug(""String_Node_Str"" + e3.getProjection());
  }
}",0.9892111254082946
9847,"/** 
 * [    null,  h: int, i: string,   null ] [ a: int      null,      null, x: geo ] ?s = uri(concat(""http://..."", ?c1, ?c2)); ?s -> [c1: string, c2: int] with expr foo and restriction bar.
 */
public Mapping union(List<Mapping> rawMembers){
  List<Mapping> members=new ArrayList<Mapping>(rawMembers.size());
  for (  Mapping rawMember : rawMembers) {
    if (!rawMember.isEmpty()) {
      members.add(rawMember);
    }
  }
  if (members.isEmpty()) {
    Mapping result=createEmptyMapping();
    return result;
  }
  Generator aliasGen=Gensym.create(""String_Node_Str"");
  if (members.size() == 1) {
    logger.warn(""String_Node_Str"");
    Mapping result=members.get(0);
    return result;
  }
  Multimap<Var,RestrictedExpr> unionVarDefs=HashMultimap.create();
  List<Map<String,SqlExpr>> unionMemberProjections=new ArrayList<Map<String,SqlExpr>>();
  for (int i=0; i < members.size(); ++i) {
    Map<String,SqlExpr> tmp=new HashMap<String,SqlExpr>();
    unionMemberProjections.add(tmp);
  }
  Multimap<Var,Integer> varToMembers=HashMultimap.create();
  for (int i=0; i < members.size(); ++i) {
    Mapping mapping=members.get(i);
    for (    Var var : mapping.getVarDefinition().getMap().keySet()) {
      varToMembers.put(var,i);
    }
  }
  ExprCommonFactor factorizer=new ExprCommonFactor(aliasGen);
  Map<String,TypeToken> unionTypeMap=new HashMap<String,TypeToken>();
  for (  Entry<Var,Collection<Integer>> entry : varToMembers.asMap().entrySet()) {
    Var var=entry.getKey();
    Collection<Integer> memberIndexes=entry.getValue();
    Multimap<String,ArgExpr> cluster=HashMultimap.create();
    for (    int index : memberIndexes) {
      Mapping member=members.get(index);
      Collection<RestrictedExpr> exprsForVar=member.getVarDefinition().getDefinitions(var);
      for (      RestrictedExpr def : exprsForVar) {
        Map<String,TypeToken> typeMap=member.getSqlOp().getSchema().getTypeMap();
        Expr expr=def.getExpr();
        Expr datatypeNorm=exprNormalizer.normalize(expr,typeMap);
        String hash=datatypeNorm.toString();
        logger.debug(""String_Node_Str"" + expr + ""String_Node_Str""+ hash+ ""String_Node_Str"");
        cluster.put(hash,new ArgExpr(expr,index));
      }
    }
    for (    Entry<String,Collection<ArgExpr>> clusterEntry : cluster.asMap().entrySet()) {
      Collection<ArgExpr> argExprs=clusterEntry.getValue();
      List<Expr> exprs=new ArrayList<Expr>();
      Map<Integer,Integer> exprToOp=new HashMap<Integer,Integer>();
      int i=0;
      for (      ArgExpr argExpr : argExprs) {
        Expr expr=argExpr.getExpr();
        exprs.add(expr);
        exprToOp.put(i,argExpr.getIndex());
        ++i;
      }
      List<Map<Var,Expr>> tmpPartialProjections=new ArrayList<Map<Var,Expr>>();
      Expr common=factorizer.transform(exprs,tmpPartialProjections);
      List<Map<String,SqlExpr>> partialProjections=new ArrayList<Map<String,SqlExpr>>();
      for (int j=0; j < tmpPartialProjections.size(); ++j) {
        int memberIndex=exprToOp.get(j);
        Mapping member=members.get(memberIndex);
        Map<String,TypeToken> typeMap=member.getSqlOp().getSchema().getTypeMap();
        Map<Var,Expr> tmpMap=tmpPartialProjections.get(j);
        Map<String,SqlExpr> map=new HashMap<String,SqlExpr>();
        for (        Entry<Var,Expr> e : tmpMap.entrySet()) {
          String columnName=e.getKey().getVarName();
          Expr expr=e.getValue();
          ExprSqlRewrite exprRewrite=sqlTranslator.translate(expr,null,typeMap);
          SqlExpr sqlExpr=SqlTranslatorImpl2.asSqlExpr(exprRewrite);
          map.put(columnName,sqlExpr);
          unionTypeMap.put(columnName,sqlExpr.getDatatype());
        }
        partialProjections.add(map);
      }
      unionVarDefs.put(var,new RestrictedExpr(common));
      for (int j=0; j < partialProjections.size(); ++j) {
        int originalIndex=exprToOp.get(j);
        Map<String,SqlExpr> projection=unionMemberProjections.get(originalIndex);
        Map<String,SqlExpr> partialProjection=partialProjections.get(j);
        for (        Entry<String,SqlExpr> ppEntry : partialProjection.entrySet()) {
          projection.put(ppEntry.getKey(),ppEntry.getValue());
        }
      }
    }
  }
  List<String> unionColumnOrder=new ArrayList<String>(unionTypeMap.keySet());
  List<SqlOp> extended=new ArrayList<SqlOp>();
  for (int i=0; i < members.size(); ++i) {
    Mapping member=members.get(i);
    Map<String,SqlExpr> unionMemberProjection=unionMemberProjections.get(i);
    Set<String> names=new HashSet<String>(unionMemberProjection.keySet());
    Set<String> unboundColumns=Sets.difference(unionTypeMap.keySet(),names);
    for (    String columnName : unboundColumns) {
      TypeToken datatype=unionTypeMap.get(columnName);
      S_Constant nullValue=new S_Constant(datatype);
      unionMemberProjection.put(columnName,nullValue);
    }
    Projection finalMemberProjection=new Projection(unionColumnOrder,unionMemberProjection);
    SqlOpExtend extend=SqlOpExtend.create(member.getSqlOp(),finalMemberProjection);
    SqlOpProject opProject=SqlOpProject.create(extend,unionColumnOrder);
    extended.add(opProject);
  }
  SqlOpUnionN newUnion=SqlOpUnionN.create(extended);
  VarDefinition varDefinition=new VarDefinition(unionVarDefs);
  Mapping result=new Mapping(varDefinition,newUnion);
  logger.info(""String_Node_Str"" + result);
  return result;
}","/** 
 * [    null,  h: int, i: string,   null ] [ a: int      null,      null, x: geo ] ?s = uri(concat(""http://..."", ?c1, ?c2)); ?s -> [c1: string, c2: int] with expr foo and restriction bar.
 */
public Mapping union(List<Mapping> rawMembers){
  List<Mapping> members=new ArrayList<Mapping>(rawMembers.size());
  for (  Mapping rawMember : rawMembers) {
    if (!rawMember.isEmpty()) {
      members.add(rawMember);
    }
  }
  if (members.isEmpty()) {
    Mapping result=createEmptyMapping();
    return result;
  }
  Set<String> columnNameBlacklist=new HashSet<String>();
  for (  Mapping member : members) {
    List<String> memberColumnNames=member.getSqlOp().getSchema().getColumnNames();
    columnNameBlacklist.addAll(memberColumnNames);
  }
  Generator aliasGen=GeneratorBlacklist.create(""String_Node_Str"",columnNameBlacklist);
  if (members.size() == 1) {
    logger.warn(""String_Node_Str"");
    Mapping result=members.get(0);
    return result;
  }
  Multimap<Var,RestrictedExpr> unionVarDefs=HashMultimap.create();
  List<Map<String,SqlExpr>> unionMemberProjections=new ArrayList<Map<String,SqlExpr>>();
  for (int i=0; i < members.size(); ++i) {
    Map<String,SqlExpr> tmp=new HashMap<String,SqlExpr>();
    unionMemberProjections.add(tmp);
  }
  Multimap<Var,Integer> varToMembers=HashMultimap.create();
  for (int i=0; i < members.size(); ++i) {
    Mapping mapping=members.get(i);
    for (    Var var : mapping.getVarDefinition().getMap().keySet()) {
      varToMembers.put(var,i);
    }
  }
  ExprCommonFactor factorizer=new ExprCommonFactor(aliasGen);
  Map<String,TypeToken> unionTypeMap=new HashMap<String,TypeToken>();
  for (  Entry<Var,Collection<Integer>> entry : varToMembers.asMap().entrySet()) {
    Var var=entry.getKey();
    Collection<Integer> memberIndexes=entry.getValue();
    Multimap<String,ArgExpr> cluster=HashMultimap.create();
    for (    int index : memberIndexes) {
      Mapping member=members.get(index);
      Collection<RestrictedExpr> exprsForVar=member.getVarDefinition().getDefinitions(var);
      for (      RestrictedExpr def : exprsForVar) {
        Map<String,TypeToken> typeMap=member.getSqlOp().getSchema().getTypeMap();
        Expr expr=def.getExpr();
        Expr datatypeNorm=exprNormalizer.normalize(expr,typeMap);
        String hash=datatypeNorm.toString();
        logger.debug(""String_Node_Str"" + expr + ""String_Node_Str""+ hash+ ""String_Node_Str"");
        cluster.put(hash,new ArgExpr(expr,index));
      }
    }
    for (    Entry<String,Collection<ArgExpr>> clusterEntry : cluster.asMap().entrySet()) {
      Collection<ArgExpr> argExprs=clusterEntry.getValue();
      List<Expr> exprs=new ArrayList<Expr>();
      Map<Integer,Integer> exprToOp=new HashMap<Integer,Integer>();
      int i=0;
      for (      ArgExpr argExpr : argExprs) {
        Expr expr=argExpr.getExpr();
        exprs.add(expr);
        exprToOp.put(i,argExpr.getIndex());
        ++i;
      }
      List<Map<Var,Expr>> tmpPartialProjections=new ArrayList<Map<Var,Expr>>();
      Expr common=factorizer.transform(exprs,tmpPartialProjections);
      List<Map<String,SqlExpr>> partialProjections=new ArrayList<Map<String,SqlExpr>>();
      for (int j=0; j < tmpPartialProjections.size(); ++j) {
        int memberIndex=exprToOp.get(j);
        Mapping member=members.get(memberIndex);
        Map<String,TypeToken> typeMap=member.getSqlOp().getSchema().getTypeMap();
        Map<Var,Expr> tmpMap=tmpPartialProjections.get(j);
        Map<String,SqlExpr> map=new HashMap<String,SqlExpr>();
        for (        Entry<Var,Expr> e : tmpMap.entrySet()) {
          String columnName=e.getKey().getVarName();
          Expr expr=e.getValue();
          ExprSqlRewrite exprRewrite=sqlTranslator.translate(expr,null,typeMap);
          SqlExpr sqlExpr=SqlTranslatorImpl2.asSqlExpr(exprRewrite);
          map.put(columnName,sqlExpr);
          unionTypeMap.put(columnName,sqlExpr.getDatatype());
        }
        partialProjections.add(map);
      }
      unionVarDefs.put(var,new RestrictedExpr(common));
      for (int j=0; j < partialProjections.size(); ++j) {
        int originalIndex=exprToOp.get(j);
        Map<String,SqlExpr> projection=unionMemberProjections.get(originalIndex);
        Map<String,SqlExpr> partialProjection=partialProjections.get(j);
        for (        Entry<String,SqlExpr> ppEntry : partialProjection.entrySet()) {
          projection.put(ppEntry.getKey(),ppEntry.getValue());
        }
      }
    }
  }
  List<String> unionColumnOrder=new ArrayList<String>(unionTypeMap.keySet());
  List<SqlOp> extended=new ArrayList<SqlOp>();
  for (int i=0; i < members.size(); ++i) {
    Mapping member=members.get(i);
    Map<String,SqlExpr> unionMemberProjection=unionMemberProjections.get(i);
    Set<String> names=new HashSet<String>(unionMemberProjection.keySet());
    Set<String> unboundColumns=Sets.difference(unionTypeMap.keySet(),names);
    for (    String columnName : unboundColumns) {
      TypeToken datatype=unionTypeMap.get(columnName);
      S_Constant nullValue=new S_Constant(datatype);
      unionMemberProjection.put(columnName,nullValue);
    }
    Projection finalMemberProjection=new Projection(unionColumnOrder,unionMemberProjection);
    SqlOpExtend extend=SqlOpExtend.create(member.getSqlOp(),finalMemberProjection);
    SqlOpProject opProject=SqlOpProject.create(extend,unionColumnOrder);
    extended.add(opProject);
  }
  SqlOpUnionN newUnion=SqlOpUnionN.create(extended);
  VarDefinition varDefinition=new VarDefinition(unionVarDefs);
  Mapping result=new Mapping(varDefinition,newUnion);
  logger.info(""String_Node_Str"" + result);
  return result;
}",0.975481293134762
9848,"public Expr transform(ExprFunction expr){
  Expr result=expr;
  if (expr.isFunction()) {
    ExprFunction fn=expr.getFunction();
    ExprTransformer transformer=lookup(fn);
    if (transformer != null) {
      result=transformer.transform(expr);
    }
  }
  return result;
}","public Expr transform(ExprFunction expr){
  Expr result=expr;
  if (expr.isFunction()) {
    ExprFunction fn=expr.getFunction();
    ExprTransformer transformer=lookup(fn);
    if (transformer != null) {
      result=transformer.transform(expr);
    }
 else {
      System.err.println(""String_Node_Str"" + fn);
    }
  }
  return result;
}",0.8464052287581699
9849,"/** 
 * If there are multiple definitions for any of the specified variables, each definition results in a new mapping. The result is then a union of these mappings.
 * @param m
 */
public static List<Mapping> refactorToUnion(Mapping m,List<Var> tmpVars){
  List<Mapping> result=new ArrayList<Mapping>();
  VarDefinition varDef=m.getVarDefinition();
  List<Var> vars=new ArrayList<Var>(tmpVars.size());
  List<Collection<RestrictedExpr>> c=new ArrayList<Collection<RestrictedExpr>>(tmpVars.size());
  for (  Var var : tmpVars) {
    Collection<RestrictedExpr> defs=varDef.getDefinitions(var);
    if (defs.isEmpty()) {
      continue;
    }
    vars.add(var);
    c.add(defs);
  }
  Multimap<Var,RestrictedExpr> baseMap=HashMultimap.create(varDef.getMap());
  baseMap.keySet().removeAll(vars);
  CartesianProduct<RestrictedExpr> cart=CartesianProduct.create(c);
  for (  List<RestrictedExpr> item : cart) {
    Multimap<Var,RestrictedExpr> map=HashMultimap.create(varDef.getMap());
    for (int i=0; i < vars.size(); ++i) {
      Var var=vars.get(i);
      RestrictedExpr restExpr=item.get(i);
      map.put(var,restExpr);
    }
    VarDefinition newVd=new VarDefinition(map);
    Mapping newM=new Mapping(newVd,m.getSqlOp());
    result.add(newM);
  }
  return result;
}","/** 
 * If there are multiple definitions for any of the specified variables, each definition results in a new mapping. The result is then a union of these mappings.
 * @param m
 */
public static List<Mapping> refactorToUnion(Mapping m,List<Var> tmpVars){
  List<Mapping> result=new ArrayList<Mapping>();
  VarDefinition varDef=m.getVarDefinition();
  List<Var> vars=new ArrayList<Var>(tmpVars.size());
  List<Collection<RestrictedExpr>> c=new ArrayList<Collection<RestrictedExpr>>(tmpVars.size());
  if (tmpVars.isEmpty()) {
    result.add(m);
    return result;
  }
  for (  Var var : tmpVars) {
    Collection<RestrictedExpr> defs=varDef.getDefinitions(var);
    if (defs.isEmpty()) {
      continue;
    }
    vars.add(var);
    c.add(defs);
  }
  Multimap<Var,RestrictedExpr> baseMap=HashMultimap.create(varDef.getMap());
  baseMap.keySet().removeAll(vars);
  CartesianProduct<RestrictedExpr> cart=CartesianProduct.create(c);
  for (  List<RestrictedExpr> item : cart) {
    Multimap<Var,RestrictedExpr> map=HashMultimap.create(varDef.getMap());
    for (int i=0; i < vars.size(); ++i) {
      Var var=vars.get(i);
      RestrictedExpr restExpr=item.get(i);
      map.put(var,restExpr);
    }
    VarDefinition newVd=new VarDefinition(map);
    Mapping newM=new Mapping(newVd,m.getSqlOp());
    result.add(newM);
  }
  return result;
}",0.973573343546534
9850,"/** 
 * Eleminate self-joins from the conjunction In place operation
 * @param conjunction
 * @return
 */
public static void merge(ViewInstanceJoin conjunction){
  for (int i=0; i < conjunction.getViewInstances().size(); ++i) {
    ViewInstance a=conjunction.getViewInstances().get(i);
    for (int j=i + 1; j < conjunction.getViewInstances().size(); ++j) {
      ViewInstance b=conjunction.getViewInstances().get(j);
      ViewInstance view=merge(a,b);
      if (view != null) {
        a=view;
        conjunction.getViewInstances().set(i,view);
        conjunction.getViewInstances().remove(j);
        --j;
      }
    }
  }
}","/** 
 * Eleminate self-joins from the conjunction In place operation
 * @param conjunction
 * @return
 */
public static void merge(ViewInstanceJoin conjunction){
  ListMultimap<String,ViewInstance> nameToInstance=conjunction.getInstancesGroupedByParent();
  for (  Entry<String,Collection<ViewInstance>> entry : nameToInstance.asMap().entrySet()) {
    List<ViewInstance> list=(List<ViewInstance>)entry.getValue();
    eliminateSelfJoins(list);
  }
}",0.4314814814814814
9851,"public static ExprEvaluator createDefaultEvaluator(){
  ExprTransformerMap exprTransformer=new ExprTransformerMap();
  ExprEvaluatorPartial evaluator=new ExprEvaluatorPartial(FunctionRegistry.get(),exprTransformer);
  Map<String,ExprTransformer> transMap=exprTransformer.getTransformerMap();
  transMap.put(""String_Node_Str"",new ExprTransformerConcatNested());
  transMap.put(""String_Node_Str"",new ExprTransformerLang());
  transMap.put(""String_Node_Str"",new ExprTransformerRdfTermComparator(evaluator));
  transMap.put(""String_Node_Str"",new ExprTransformerRdfTermComparator(evaluator));
  transMap.put(""String_Node_Str"",new ExprTransformerLogicalAnd());
  return evaluator;
}","public static ExprEvaluator createDefaultEvaluator(){
  ExprTransformerMap exprTransformer=new ExprTransformerMap();
  ExprEvaluatorPartial evaluator=new ExprEvaluatorPartial(FunctionRegistry.get(),exprTransformer);
  Map<String,ExprTransformer> transMap=exprTransformer.getTransformerMap();
  transMap.put(""String_Node_Str"",new ExprTransformerConcatNested());
  transMap.put(""String_Node_Str"",new ExprTransformerLang());
  transMap.put(""String_Node_Str"",new ExprTransformerRdfTermComparator(evaluator));
  transMap.put(""String_Node_Str"",new ExprTransformerRdfTermComparator(evaluator));
  transMap.put(""String_Node_Str"",new ExprTransformerRdfTermComparator(evaluator));
  transMap.put(""String_Node_Str"",new ExprTransformerRdfTermComparator(evaluator));
  transMap.put(""String_Node_Str"",new ExprTransformerRdfTermComparator(evaluator));
  transMap.put(""String_Node_Str"",new ExprTransformerLogicalAnd());
  return evaluator;
}",0.8444722048719551
9852,"public ViewInstanceJoin(List<ViewInstance> viewBindings,RestrictionManagerImpl restrictions){
  super();
  this.viewInstances=viewBindings;
  this.restrictions=restrictions;
}","public ViewInstanceJoin(ListMultimap<String,ViewInstance> nameToInstances,RestrictionManagerImpl restrictions){
  super();
  this.nameToInstances=nameToInstances;
  this.restrictions=restrictions;
}",0.8364611260053619
9853,"@Override public String toString(){
  return ""String_Node_Str"" + viewInstances;
}","@Override public String toString(){
  return ""String_Node_Str"" + getViewInstances();
}",0.9580838323353292
9854,"public List<ViewInstance> getViewInstances(){
  return viewInstances;
}","public Collection<ViewInstance> getViewInstances(){
  return nameToInstances.values();
}",0.8176100628930818
9855,"public List<String> getViewNames(){
  List<String> result=new ArrayList<String>(viewInstances.size());
  for (  ViewInstance instance : viewInstances) {
    result.add(instance.getViewDefinition().getName());
  }
  return result;
}","public List<String> getViewNames(){
  Collection<ViewInstance> viewInstances=getViewInstances();
  List<String> result=new ArrayList<String>(viewInstances.size());
  for (  ViewInstance instance : viewInstances) {
    result.add(instance.getViewDefinition().getName());
  }
  return result;
}",0.8833652007648184
9856,"@Test public void creationTest() throws RecognitionException, SQLException, IOException {
  RdfViewSystemOld.initSparqlifyFunctions();
  DatatypeSystem datatypeSystem=SparqlifyUtils.createDefaultDatatypeSystem();
  SqlTranslator sqlTranslator=new SqlTranslatorImpl(datatypeSystem);
  DataSource dataSource=SparqlifyUtils.createTestDatabase();
  Connection conn=dataSource.getConnection();
  Map<String,String> typeAlias=MapReader.readFile(new File(""String_Node_Str""));
  SqlExprSerializer serExpr=null;
  SqlFunctionSerializer serFn=null;
  ViewDefinitionFactory vdf=SparqlifyUtils.createViewDefinitionFactory(conn,typeAlias);
  ViewDefinition personView=vdf.create(""String_Node_Str"");
  ViewDefinition deptView=vdf.create(""String_Node_Str"");
  ViewDefinition personToDeptView=vdf.create(""String_Node_Str"");
  ViewDefinition personAgeView=vdf.create(""String_Node_Str"");
  ViewDefinition personAndAgeView=vdf.create(""String_Node_Str"");
  CandidateViewSelector candidateViewSelector=new CandidateViewSelectorImpl();
  candidateViewSelector.addView(personView);
  candidateViewSelector.addView(deptView);
  candidateViewSelector.addView(personToDeptView);
  candidateViewSelector.addView(personAgeView);
  SparqlSqlRewriter rewriter=SparqlifyUtils.createTestRewriter(candidateViewSelector,datatypeSystem);
  QueryExecutionFactory qef=new QueryExecutionFactorySparqlifyDs(rewriter,dataSource);
{
    QueryExecution qe=qef.createQueryExecution(""String_Node_Str"");
    ResultSet rs=qe.execSelect();
    String rsStr=ResultSetFormatter.asText(rs);
    System.out.println(rsStr);
  }
}","@Test public void creationTest() throws RecognitionException, SQLException, IOException {
  RdfViewSystemOld.initSparqlifyFunctions();
  DatatypeSystem datatypeSystem=SparqlifyUtils.createDefaultDatatypeSystem();
  SqlTranslator sqlTranslator=new SqlTranslatorImpl(datatypeSystem);
  DataSource dataSource=SparqlifyUtils.createTestDatabase();
  Connection conn=dataSource.getConnection();
  Map<String,String> typeAlias=MapReader.readFile(new File(""String_Node_Str""));
  SqlExprSerializer serExpr=null;
  SqlFunctionSerializer serFn=null;
  ViewDefinitionFactory vdf=SparqlifyUtils.createViewDefinitionFactory(conn,typeAlias);
  ViewDefinition personView=vdf.create(""String_Node_Str"");
  ViewDefinition deptView=vdf.create(""String_Node_Str"");
  ViewDefinition personToDeptView=vdf.create(""String_Node_Str"");
  ViewDefinition personAgeView=vdf.create(""String_Node_Str"");
  ViewDefinition personAndAgeView=vdf.create(""String_Node_Str"");
  CandidateViewSelector candidateViewSelector=new CandidateViewSelectorImpl();
  candidateViewSelector.addView(deptView);
  candidateViewSelector.addView(personAndAgeView);
  SparqlSqlRewriter rewriter=SparqlifyUtils.createTestRewriter(candidateViewSelector,datatypeSystem);
  QueryExecutionFactory qef=new QueryExecutionFactorySparqlifyDs(rewriter,dataSource);
{
    QueryExecution qe=qef.createQueryExecution(""String_Node_Str"");
    ResultSet rs=qe.execSelect();
    String rsStr=ResultSetFormatter.asText(rs);
    System.out.println(rsStr);
  }
}",0.9356419470761188
9857,"/** 
 * [    null,  h: int, i: string,   null ] [ a: int      null,      null, x: geo ] ?s = uri(concat(""http://..."", ?c1, ?c2)); ?s -> [c1: string, c2: int] with expr foo and restriction bar.
 */
public Mapping union(List<Mapping> rawMembers){
  if (rawMembers.isEmpty()) {
    SqlOp empty=SqlOpEmpty.create();
    Mapping result=new Mapping(empty);
    return result;
  }
  List<Mapping> members=rawMembers;
  Generator aliasGen=Gensym.create(""String_Node_Str"");
  if (members.size() == 1) {
    logger.warn(""String_Node_Str"");
    Mapping result=members.get(0);
    return result;
  }
  Multimap<Var,RestrictedExpr> unionVarDefs=HashMultimap.create();
  List<Map<String,SqlExpr>> unionMemberProjections=new ArrayList<Map<String,SqlExpr>>();
  for (int i=0; i < members.size(); ++i) {
    Map<String,SqlExpr> tmp=new HashMap<String,SqlExpr>();
    unionMemberProjections.add(tmp);
  }
  Multimap<Var,Integer> varToMembers=HashMultimap.create();
  for (int i=0; i < members.size(); ++i) {
    Mapping mapping=members.get(i);
    for (    Var var : mapping.getVarDefinition().getMap().keySet()) {
      varToMembers.put(var,i);
    }
  }
  ExprCommonFactor factorizer=new ExprCommonFactor(aliasGen);
  Map<String,TypeToken> unionTypeMap=new HashMap<String,TypeToken>();
  for (  Entry<Var,Collection<Integer>> entry : varToMembers.asMap().entrySet()) {
    Var var=entry.getKey();
    Collection<Integer> memberIndexes=entry.getValue();
    Multimap<String,ArgExpr> cluster=HashMultimap.create();
    for (    int index : memberIndexes) {
      Mapping member=members.get(index);
      Collection<RestrictedExpr> exprsForVar=member.getVarDefinition().getDefinitions(var);
      for (      RestrictedExpr def : exprsForVar) {
        Map<String,TypeToken> columnToDatatype=member.getSqlOp().getSchema().getTypeMap();
        Expr datatypeNorm=exprNormalizer.normalize(def.getExpr(),columnToDatatype);
        String hash=datatypeNorm.toString();
        cluster.put(hash,new ArgExpr(def.getExpr(),index));
      }
    }
    for (    Entry<String,Collection<ArgExpr>> clusterEntry : cluster.asMap().entrySet()) {
      Collection<ArgExpr> argExprs=clusterEntry.getValue();
      List<Expr> exprs=new ArrayList<Expr>();
      Map<Integer,Integer> exprToOp=new HashMap<Integer,Integer>();
      int i=0;
      for (      ArgExpr argExpr : argExprs) {
        Expr expr=argExpr.getExpr();
        exprs.add(expr);
        exprToOp.put(i,argExpr.getIndex());
        ++i;
      }
      List<Map<Var,Expr>> tmpPartialProjections=new ArrayList<Map<Var,Expr>>();
      Expr common=factorizer.transform(exprs,tmpPartialProjections);
      List<Map<String,SqlExpr>> partialProjections=new ArrayList<Map<String,SqlExpr>>();
      for (int j=0; j < tmpPartialProjections.size(); ++j) {
        int memberIndex=exprToOp.get(j);
        Mapping member=members.get(memberIndex);
        Map<String,TypeToken> typeMap=member.getSqlOp().getSchema().getTypeMap();
        Map<Var,Expr> tmpMap=tmpPartialProjections.get(j);
        Map<String,SqlExpr> map=new HashMap<String,SqlExpr>();
        for (        Entry<Var,Expr> e : tmpMap.entrySet()) {
          String columnName=e.getKey().getVarName();
          Expr expr=e.getValue();
          SqlExpr sqlExpr=sqlTranslator.translate(expr,null,typeMap);
          map.put(columnName,sqlExpr);
          unionTypeMap.put(columnName,sqlExpr.getDatatype());
        }
        partialProjections.add(map);
      }
      unionVarDefs.put(var,new RestrictedExpr(common));
      for (int j=0; j < partialProjections.size(); ++j) {
        int originalIndex=exprToOp.get(j);
        Map<String,SqlExpr> projection=unionMemberProjections.get(originalIndex);
        Map<String,SqlExpr> partialProjection=partialProjections.get(j);
        for (        Entry<String,SqlExpr> ppEntry : partialProjection.entrySet()) {
          projection.put(ppEntry.getKey(),ppEntry.getValue());
        }
      }
    }
  }
  List<String> unionColumnOrder=new ArrayList<String>(unionTypeMap.keySet());
  List<SqlOp> extended=new ArrayList<SqlOp>();
  for (int i=0; i < members.size(); ++i) {
    Mapping member=members.get(i);
    Map<String,SqlExpr> unionMemberProjection=unionMemberProjections.get(i);
    Set<String> names=new HashSet<String>(unionMemberProjection.keySet());
    Set<String> unboundColumns=Sets.difference(unionTypeMap.keySet(),names);
    for (    String columnName : unboundColumns) {
      TypeToken datatype=unionTypeMap.get(columnName);
      S_Constant nullValue=new S_Constant(datatype,null);
      unionMemberProjection.put(columnName,nullValue);
    }
    Projection finalMemberProjection=new Projection(unionColumnOrder,unionMemberProjection);
    SqlOpExtend extend=SqlOpExtend.create(member.getSqlOp(),finalMemberProjection);
    SqlOpProject opProject=SqlOpProject.create(extend,unionColumnOrder);
    extended.add(opProject);
  }
  SqlOpUnionN newUnion=SqlOpUnionN.create(extended);
  VarDefinition varDefinition=new VarDefinition(unionVarDefs);
  Mapping result=new Mapping(varDefinition,newUnion);
  return result;
}","/** 
 * [    null,  h: int, i: string,   null ] [ a: int      null,      null, x: geo ] ?s = uri(concat(""http://..."", ?c1, ?c2)); ?s -> [c1: string, c2: int] with expr foo and restriction bar.
 */
public Mapping union(List<Mapping> rawMembers){
  if (rawMembers.isEmpty()) {
    Mapping result=createEmptyMapping();
    return result;
  }
  List<Mapping> members=rawMembers;
  Generator aliasGen=Gensym.create(""String_Node_Str"");
  if (members.size() == 1) {
    logger.warn(""String_Node_Str"");
    Mapping result=members.get(0);
    return result;
  }
  Multimap<Var,RestrictedExpr> unionVarDefs=HashMultimap.create();
  List<Map<String,SqlExpr>> unionMemberProjections=new ArrayList<Map<String,SqlExpr>>();
  for (int i=0; i < members.size(); ++i) {
    Map<String,SqlExpr> tmp=new HashMap<String,SqlExpr>();
    unionMemberProjections.add(tmp);
  }
  Multimap<Var,Integer> varToMembers=HashMultimap.create();
  for (int i=0; i < members.size(); ++i) {
    Mapping mapping=members.get(i);
    for (    Var var : mapping.getVarDefinition().getMap().keySet()) {
      varToMembers.put(var,i);
    }
  }
  ExprCommonFactor factorizer=new ExprCommonFactor(aliasGen);
  Map<String,TypeToken> unionTypeMap=new HashMap<String,TypeToken>();
  for (  Entry<Var,Collection<Integer>> entry : varToMembers.asMap().entrySet()) {
    Var var=entry.getKey();
    Collection<Integer> memberIndexes=entry.getValue();
    Multimap<String,ArgExpr> cluster=HashMultimap.create();
    for (    int index : memberIndexes) {
      Mapping member=members.get(index);
      Collection<RestrictedExpr> exprsForVar=member.getVarDefinition().getDefinitions(var);
      for (      RestrictedExpr def : exprsForVar) {
        Map<String,TypeToken> columnToDatatype=member.getSqlOp().getSchema().getTypeMap();
        Expr datatypeNorm=exprNormalizer.normalize(def.getExpr(),columnToDatatype);
        String hash=datatypeNorm.toString();
        cluster.put(hash,new ArgExpr(def.getExpr(),index));
      }
    }
    for (    Entry<String,Collection<ArgExpr>> clusterEntry : cluster.asMap().entrySet()) {
      Collection<ArgExpr> argExprs=clusterEntry.getValue();
      List<Expr> exprs=new ArrayList<Expr>();
      Map<Integer,Integer> exprToOp=new HashMap<Integer,Integer>();
      int i=0;
      for (      ArgExpr argExpr : argExprs) {
        Expr expr=argExpr.getExpr();
        exprs.add(expr);
        exprToOp.put(i,argExpr.getIndex());
        ++i;
      }
      List<Map<Var,Expr>> tmpPartialProjections=new ArrayList<Map<Var,Expr>>();
      Expr common=factorizer.transform(exprs,tmpPartialProjections);
      List<Map<String,SqlExpr>> partialProjections=new ArrayList<Map<String,SqlExpr>>();
      for (int j=0; j < tmpPartialProjections.size(); ++j) {
        int memberIndex=exprToOp.get(j);
        Mapping member=members.get(memberIndex);
        Map<String,TypeToken> typeMap=member.getSqlOp().getSchema().getTypeMap();
        Map<Var,Expr> tmpMap=tmpPartialProjections.get(j);
        Map<String,SqlExpr> map=new HashMap<String,SqlExpr>();
        for (        Entry<Var,Expr> e : tmpMap.entrySet()) {
          String columnName=e.getKey().getVarName();
          Expr expr=e.getValue();
          SqlExpr sqlExpr=sqlTranslator.translate(expr,null,typeMap);
          map.put(columnName,sqlExpr);
          unionTypeMap.put(columnName,sqlExpr.getDatatype());
        }
        partialProjections.add(map);
      }
      unionVarDefs.put(var,new RestrictedExpr(common));
      for (int j=0; j < partialProjections.size(); ++j) {
        int originalIndex=exprToOp.get(j);
        Map<String,SqlExpr> projection=unionMemberProjections.get(originalIndex);
        Map<String,SqlExpr> partialProjection=partialProjections.get(j);
        for (        Entry<String,SqlExpr> ppEntry : partialProjection.entrySet()) {
          projection.put(ppEntry.getKey(),ppEntry.getValue());
        }
      }
    }
  }
  List<String> unionColumnOrder=new ArrayList<String>(unionTypeMap.keySet());
  List<SqlOp> extended=new ArrayList<SqlOp>();
  for (int i=0; i < members.size(); ++i) {
    Mapping member=members.get(i);
    Map<String,SqlExpr> unionMemberProjection=unionMemberProjections.get(i);
    Set<String> names=new HashSet<String>(unionMemberProjection.keySet());
    Set<String> unboundColumns=Sets.difference(unionTypeMap.keySet(),names);
    for (    String columnName : unboundColumns) {
      TypeToken datatype=unionTypeMap.get(columnName);
      S_Constant nullValue=new S_Constant(datatype,null);
      unionMemberProjection.put(columnName,nullValue);
    }
    Projection finalMemberProjection=new Projection(unionColumnOrder,unionMemberProjection);
    SqlOpExtend extend=SqlOpExtend.create(member.getSqlOp(),finalMemberProjection);
    SqlOpProject opProject=SqlOpProject.create(extend,unionColumnOrder);
    extended.add(opProject);
  }
  SqlOpUnionN newUnion=SqlOpUnionN.create(extended);
  VarDefinition varDefinition=new VarDefinition(unionVarDefs);
  Mapping result=new Mapping(varDefinition,newUnion);
  return result;
}",0.9897827596468604
9858,"@Override public Mapping rewrite(Op op){
  Mapping result;
  if (op instanceof OpViewInstanceJoin) {
    result=rewrite((OpViewInstanceJoin)op);
  }
 else   if (op instanceof OpDisjunction) {
    result=rewrite((OpDisjunction)op);
  }
 else   if (op instanceof OpFilterIndexed) {
    result=rewrite((OpFilterIndexed)op);
  }
 else   if (op instanceof OpProject) {
    result=rewrite((OpProject)op);
  }
 else   if (op instanceof OpJoin) {
    result=rewrite((OpJoin)op);
  }
 else   if (op instanceof OpLeftJoin) {
    result=rewrite((OpLeftJoin)op);
  }
 else   if (op instanceof OpConditional) {
    result=rewrite((OpConditional)op);
  }
 else   if (op instanceof OpSlice) {
    result=rewrite((OpSlice)op);
  }
 else   if (op instanceof OpDistinct) {
    result=rewrite((OpDistinct)op);
  }
 else   if (op instanceof OpGroup) {
    result=rewrite((OpGroup)op);
  }
 else   if (op instanceof OpExtend) {
    result=rewrite((OpExtend)op);
  }
 else   if (op instanceof OpAssign) {
    result=rewrite((OpAssign)op);
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + op.getClass() + ""String_Node_Str""+ op);
  }
  return result;
}","@Override public Mapping rewrite(Op op){
  Mapping result;
  if (op instanceof OpViewInstanceJoin) {
    result=rewrite((OpViewInstanceJoin)op);
  }
 else   if (op instanceof OpDisjunction) {
    result=rewrite((OpDisjunction)op);
  }
 else   if (op instanceof OpFilterIndexed) {
    result=rewrite((OpFilterIndexed)op);
  }
 else   if (op instanceof OpProject) {
    result=rewrite((OpProject)op);
  }
 else   if (op instanceof OpJoin) {
    result=rewrite((OpJoin)op);
  }
 else   if (op instanceof OpLeftJoin) {
    result=rewrite((OpLeftJoin)op);
  }
 else   if (op instanceof OpSequence) {
    result=rewrite((OpSequence)op);
  }
 else   if (op instanceof OpConditional) {
    result=rewrite((OpConditional)op);
  }
 else   if (op instanceof OpSlice) {
    result=rewrite((OpSlice)op);
  }
 else   if (op instanceof OpDistinct) {
    result=rewrite((OpDistinct)op);
  }
 else   if (op instanceof OpGroup) {
    result=rewrite((OpGroup)op);
  }
 else   if (op instanceof OpExtend) {
    result=rewrite((OpExtend)op);
  }
 else   if (op instanceof OpAssign) {
    result=rewrite((OpAssign)op);
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + op.getClass() + ""String_Node_Str""+ op);
  }
  return result;
}",0.9661590524534688
9859,"public static Op optimize(Op op,RestrictionManagerImpl cnf){
  if (op instanceof OpNull) {
    return op;
  }
  Op result=MultiMethod.invokeStatic(FilterPlacementOptimizer2.class,""String_Node_Str"",op,cnf);
  return result;
}","public static Op optimize(Op op,RestrictionManagerImpl cnf){
  Op result=MultiMethod.invokeStatic(FilterPlacementOptimizer2.class,""String_Node_Str"",op,cnf);
  return result;
}",0.8771929824561403
9860,"public static RestrictionManagerImpl filterByVars(RestrictionManagerImpl cnf,Op op){
  Set<Clause> clauses=cnf.getClausesForVars(GetVarsMentioned.getVarsMentioned(op));
  return new RestrictionManagerImpl(new NestedNormalForm(clauses));
}","public static RestrictionManagerImpl filterByVars(RestrictionManagerImpl cnf,Op op){
  Set<Var> vars=GetVarsMentioned.getVarsMentioned(op);
  Set<Clause> clauses=cnf.getClausesForVars(vars);
  return new RestrictionManagerImpl(new NestedNormalForm(clauses));
}",0.8072289156626506
9861,"public Set<Clause> getClausesForVars(Collection<Var> vars){
  Set<Clause> result=new HashSet<Clause>();
  for (  Var var : vars) {
    Set<Clause> tmp=cnf.getClausesByVar(var);
    if (tmp != null) {
      result.addAll(tmp);
    }
  }
  return result;
}","/** 
 * Returns all clauses having any of the given variables
 * @param vars
 * @return
 */
public Set<Clause> getClausesForVars(Collection<Var> vars){
  Set<Clause> result=new HashSet<Clause>();
  for (  Var var : vars) {
    Set<Clause> tmp=cnf.getClausesByVar(var);
    if (tmp != null) {
      result.addAll(tmp);
    }
  }
  return result;
}",0.8466666666666667
9862,"public static Map<String,String> readFile(File file) throws IOException {
  Map<String,String> result=new HashMap<String,String>();
  BufferedReader reader=new BufferedReader(new InputStreamReader(new FileInputStream(file)));
  try {
    String line=null;
    while ((line=reader.readLine()) != null) {
      line=line.trim();
      if (line.isEmpty() || line.startsWith(""String_Node_Str"")) {
        continue;
      }
      String[] parts=line.split(""String_Node_Str"",2);
      if (parts.length != 2) {
        logger.debug(""String_Node_Str"" + parts[0]);
        continue;
      }
      result.put(parts[0],parts[1]);
    }
  }
  finally {
    reader.close();
  }
  return result;
}","@Deprecated public static Map<String,String> readFile(File file) throws IOException {
  return read(file);
}",0.225031605562579
9863,"public static DatatypeSystemCustom createDefaultDatatypeSystem() throws IOException {
  Map<String,String> typeNameToClass=MapReader.readFile(new File(""String_Node_Str""));
  Map<String,String> typeNameToUri=MapReader.readFile(new File(""String_Node_Str""));
  Map<String,String> typeHierarchy=MapReader.readFile(new File(""String_Node_Str""));
  DatatypeSystemCustom result=DatatypeSystemCustom.create(typeNameToClass,typeNameToUri,typeHierarchy,SparqlifyUtils.logger);
  initDatatypeSystem(result);
  return result;
}","public static DatatypeSystemCustom createDefaultDatatypeSystem() throws IOException {
  Map<String,String> typeNameToClass=readMapFromResource(""String_Node_Str"");
  Map<String,String> typeNameToUri=readMapFromResource(""String_Node_Str"");
  Map<String,String> typeHierarchy=readMapFromResource(""String_Node_Str"");
  DatatypeSystemCustom result=DatatypeSystemCustom.create(typeNameToClass,typeNameToUri,typeHierarchy,SparqlifyUtils.logger);
  initDatatypeSystem(result);
  return result;
}",0.3936063936063936
9864,"@Override public boolean isConstant(){
  for (  Expr expr : super.getArgs()) {
    if (!expr.isConstant()) {
      return false;
    }
  }
  return true;
}","@Override public boolean isConstant(){
  return false;
}",0.5308056872037915
9865,"/** 
 * Creates a mapping from a view instance: - For every binding variable, that maps to multiple things (contants + variables), we need to equate all these things being mapped to Schematically, we need to transform the binding to variable definitions from the original structure (query view definition) q    v   d / dx1 ?x /    \ dxn ?s   \    / dy1 ?y \ dyn to conceptually a CNF: (dx1 = dy1 OR ... OR dx1 = dyn) AND ... AND (dxn = dy1 OR ... OR dxn = dyn) However, as equals is transitive and symmetric, it is sufficient to just pick the set of definitions for one view variable.
 * @param generator
 * @param viewInstance
 * @return
 */
public Mapping createMapping(ViewInstance viewInstance){
  Set<Var> queryVars=viewInstance.getBinding().getQueryVars();
  Multimap<Var,RestrictedExpr> newVarDefMap=HashMultimap.create();
  List<SqlExpr> ands=null;
  for (  Var queryVar : queryVars) {
    Node constant=viewInstance.getBinding().getConstant(queryVar);
    if (constant != null) {
      NodeValue nv=NodeValue.makeNode(constant);
      newVarDefMap.put(queryVar,new RestrictedExpr(nv));
      continue;
    }
    VarDefKey ors=joinDefinitionsOnEquals(queryVar,viewInstance,exprTransformer,sqlTranslator);
    if (ors == null) {
      return createEmptyMapping(viewInstance);
    }
    newVarDefMap.putAll(queryVar,ors.definitionExprs);
    SqlExpr or=SqlExprUtils.orifyBalanced(ors.constraintExpr);
    if (or == null || or.equals(S_Constant.TRUE)) {
      continue;
    }
    if (ands == null) {
      ands=new ArrayList<SqlExpr>();
    }
    if (or.equals(S_Constant.FALSE)) {
      continue;
    }
 else {
      ands.add(or);
    }
  }
  VarDefinition varDefinition=new VarDefinition(newVarDefMap);
  Mapping result=null;
  SqlOp op=viewInstance.getViewDefinition().getMapping().getSqlOp();
  if (ands == null) {
    result=new Mapping(varDefinition,op);
  }
 else   if (ands.isEmpty()) {
    result=createEmptyMapping(viewInstance);
  }
 else {
    SqlOp filterOp=SqlOpFilter.create(op,ands);
    result=new Mapping(varDefinition,filterOp);
  }
  return result;
}","/** 
 * Creates a mapping from a view instance: - For every binding variable, that maps to multiple things (contants + variables), we need to equate all these things being mapped to Schematically, we need to transform the binding to variable definitions from the original structure (query view definition) q    v   d / dx1 ?x /    \ dxn ?s   \    / dy1 ?y \ dyn to conceptually a CNF: (dx1 = dy1 OR ... OR dx1 = dyn) AND ... AND (dxn = dy1 OR ... OR dxn = dyn) However, as equals is transitive and symmetric, it is sufficient to just pick the set of definitions for one view variable.
 * @param generator
 * @param viewInstance
 * @return
 */
public Mapping createMapping(ViewInstance viewInstance){
  Set<Var> queryVars=viewInstance.getBinding().getQueryVars();
  Multimap<Var,RestrictedExpr> newVarDefMap=HashMultimap.create();
  List<SqlExpr> ands=null;
  for (  Var queryVar : queryVars) {
    Node constant=viewInstance.getBinding().getConstant(queryVar);
    if (constant != null) {
      NodeValue nv=NodeValue.makeNode(constant);
      newVarDefMap.put(queryVar,new RestrictedExpr(nv));
      continue;
    }
    VarDefKey ors=joinDefinitionsOnEquals(queryVar,viewInstance,exprTransformer,sqlTranslator);
    if (ors == null) {
      return createEmptyMapping(viewInstance);
    }
    newVarDefMap.putAll(queryVar,ors.definitionExprs);
    SqlExpr or=SqlExprUtils.orifyBalanced(ors.constraintExpr);
    if (or == null || or.equals(S_Constant.TRUE)) {
      continue;
    }
    if (ands == null) {
      ands=new ArrayList<SqlExpr>();
    }
    if (or.equals(S_Constant.FALSE)) {
      continue;
    }
 else {
      ands.add(or);
    }
  }
  VarDefinition tmpVarDefinition=new VarDefinition(newVarDefMap);
  VarDefinition varDefinition=tmpVarDefinition.copyExpandConstants();
  Mapping result=null;
  SqlOp op=viewInstance.getViewDefinition().getMapping().getSqlOp();
  if (ands == null) {
    result=new Mapping(varDefinition,op);
  }
 else   if (ands.isEmpty()) {
    result=createEmptyMapping(viewInstance);
  }
 else {
    SqlOp filterOp=SqlOpFilter.create(op,ands);
    result=new Mapping(varDefinition,filterOp);
  }
  return result;
}",0.9822401136632726
9866,"@Override public Mapping select(Mapping a,ExprList exprs){
  Map<String,TypeToken> typeMap=a.getSqlOp().getSchema().getTypeMap();
  List<SqlExpr> sqlExprs=new ArrayList<SqlExpr>();
  for (  Expr expr : exprs) {
    SqlExpr sqlExpr=createSqlCondition(expr,a.getVarDefinition(),typeMap,sqlTranslator);
    if (sqlExpr.equals(S_Constant.TRUE)) {
      continue;
    }
    sqlExprs.add(sqlExpr);
  }
  SqlOp op=SqlOpFilter.createIfNeeded(a.getSqlOp(),sqlExprs);
  Mapping result=new Mapping(a.getVarDefinition(),op);
  return result;
}","@Override public Mapping select(Mapping a,ExprList exprs){
  Map<String,TypeToken> typeMap=a.getSqlOp().getSchema().getTypeMap();
  List<SqlExpr> sqlExprs=new ArrayList<SqlExpr>();
  for (  Expr expr : exprs) {
    SqlExpr sqlExpr=createSqlCondition(expr,a.getVarDefinition(),typeMap,exprTransformer,sqlTranslator);
    if (sqlExpr.equals(S_Constant.TRUE)) {
      continue;
    }
    sqlExprs.add(sqlExpr);
  }
  SqlOp op=SqlOpFilter.createIfNeeded(a.getSqlOp(),sqlExprs);
  Mapping result=new Mapping(a.getVarDefinition(),op);
  return result;
}",0.9851576994434136
9867,"/** 
 * [    null,  h: int, i: string,   null ] [ a: int      null,      null, x: geo ] ?s = uri(concat(""http://..."", ?c1, ?c2)); ?s -> [c1: string, c2: int] with expr foo and restriction bar.
 */
public Mapping union(List<Mapping> members){
  if (members.size() == 1) {
    logger.warn(""String_Node_Str"");
    Mapping result=members.get(0);
  }
  Multimap<Var,RestrictedExpr> unionVarDefs=HashMultimap.create();
  List<Map<String,SqlExpr>> unionMemberProjections=new ArrayList<Map<String,SqlExpr>>();
  for (int i=0; i < members.size(); ++i) {
    Map<String,SqlExpr> tmp=new HashMap<String,SqlExpr>();
    unionMemberProjections.add(tmp);
  }
  Multimap<Var,Integer> varToMembers=HashMultimap.create();
  for (int i=0; i < members.size(); ++i) {
    Mapping mapping=members.get(i);
    for (    Var var : mapping.getVarDefinition().getMap().keySet()) {
      varToMembers.put(var,i);
    }
  }
  Generator aliasGen=Gensym.create(""String_Node_Str"");
  ExprCommonFactor factorizer=new ExprCommonFactor(aliasGen);
  Map<String,TypeToken> unionTypeMap=new HashMap<String,TypeToken>();
  for (  Entry<Var,Collection<Integer>> entry : varToMembers.asMap().entrySet()) {
    Var var=entry.getKey();
    Collection<Integer> memberIndexes=entry.getValue();
    Multimap<Expr,ArgExpr> cluster=HashMultimap.create();
    for (    int index : memberIndexes) {
      Mapping member=members.get(index);
      Collection<RestrictedExpr> exprsForVar=member.getVarDefinition().getDefinitions(var);
      for (      RestrictedExpr def : exprsForVar) {
        Map<String,TypeToken> columnToDatatype=member.getSqlOp().getSchema().getTypeMap();
        Expr datatypeNorm=exprNormalizer.normalize(def.getExpr(),columnToDatatype);
        cluster.put(datatypeNorm,new ArgExpr(def.getExpr(),index));
      }
    }
    for (    Entry<Expr,Collection<ArgExpr>> clusterEntry : cluster.asMap().entrySet()) {
      Collection<ArgExpr> argExprs=clusterEntry.getValue();
      List<Expr> exprs=new ArrayList<Expr>();
      Map<Integer,Integer> exprToOp=new HashMap<Integer,Integer>();
      int i=0;
      for (      ArgExpr argExpr : argExprs) {
        exprs.add(argExpr.getExpr());
        exprToOp.put(i,argExpr.getIndex());
        ++i;
      }
      List<Map<Var,Expr>> tmpPartialProjections=new ArrayList<Map<Var,Expr>>();
      Expr common=factorizer.transform(exprs,tmpPartialProjections);
      List<Map<String,SqlExpr>> partialProjections=new ArrayList<Map<String,SqlExpr>>();
      for (int j=0; j < tmpPartialProjections.size(); ++j) {
        int memberIndex=exprToOp.get(j);
        Mapping member=members.get(memberIndex);
        Map<Var,Expr> tmpMap=tmpPartialProjections.get(j);
        Map<String,SqlExpr> map=new HashMap<String,SqlExpr>();
        for (        Entry<Var,Expr> e : tmpMap.entrySet()) {
          Expr expr=e.getValue();
          Map<String,TypeToken> typeMap=member.getSqlOp().getSchema().getTypeMap();
          SqlExpr sqlExpr=sqlTranslator.translate(expr,null,typeMap);
          map.put(e.getKey().getVarName(),sqlExpr);
        }
        partialProjections.add(map);
      }
      unionVarDefs.put(var,new RestrictedExpr(common));
      for (int j=0; j < partialProjections.size(); ++j) {
        int originalIndex=exprToOp.get(j);
        Map<String,SqlExpr> projection=unionMemberProjections.get(originalIndex);
        Map<String,SqlExpr> partialProjection=partialProjections.get(j);
        for (        Entry<String,SqlExpr> ppEntry : partialProjection.entrySet()) {
          projection.put(ppEntry.getKey(),ppEntry.getValue());
        }
      }
    }
  }
  for (int i=0; i < unionMemberProjections.size(); ++i) {
    Mapping member=members.get(i);
    Map<String,TypeToken> typeMap=member.getSqlOp().getSchema().getTypeMap();
    Map<String,SqlExpr> projection=unionMemberProjections.get(i);
    for (    Entry<String,SqlExpr> entry : projection.entrySet()) {
      SqlExpr expr=entry.getValue();
      unionTypeMap.put(entry.getKey(),expr.getDatatype());
    }
  }
  List<String> unionColumnOrder=new ArrayList<String>(unionTypeMap.keySet());
  List<SqlOp> extended=new ArrayList<SqlOp>();
  for (int i=0; i < members.size(); ++i) {
    Mapping member=members.get(i);
    Map<String,SqlExpr> unionMemberProjection=unionMemberProjections.get(i);
    Set<String> names=new HashSet<String>(unionMemberProjection.keySet());
    Set<String> unboundColumns=Sets.difference(unionTypeMap.keySet(),names);
    for (    String columnName : unboundColumns) {
      TypeToken datatype=unionTypeMap.get(columnName);
      S_Constant nullValue=new S_Constant(datatype,null);
      unionMemberProjection.put(columnName,nullValue);
    }
    Projection finalMemberProjection=new Projection(unionColumnOrder,unionMemberProjection);
    SqlOpExtend extend=SqlOpExtend.create(member.getSqlOp(),finalMemberProjection);
    SqlOpProject opProject=SqlOpProject.create(extend,unionColumnOrder);
    extended.add(opProject);
  }
  SqlOpUnionN newUnion=SqlOpUnionN.create(extended);
  VarDefinition varDefinition=new VarDefinition(unionVarDefs);
  Mapping result=new Mapping(varDefinition,newUnion);
  return result;
}","/** 
 * [    null,  h: int, i: string,   null ] [ a: int      null,      null, x: geo ] ?s = uri(concat(""http://..."", ?c1, ?c2)); ?s -> [c1: string, c2: int] with expr foo and restriction bar.
 */
public Mapping union(List<Mapping> members){
  if (members.size() == 1) {
    logger.warn(""String_Node_Str"");
    Mapping result=members.get(0);
  }
  Multimap<Var,RestrictedExpr> unionVarDefs=HashMultimap.create();
  List<Map<String,SqlExpr>> unionMemberProjections=new ArrayList<Map<String,SqlExpr>>();
  for (int i=0; i < members.size(); ++i) {
    Map<String,SqlExpr> tmp=new HashMap<String,SqlExpr>();
    unionMemberProjections.add(tmp);
  }
  Multimap<Var,Integer> varToMembers=HashMultimap.create();
  for (int i=0; i < members.size(); ++i) {
    Mapping mapping=members.get(i);
    for (    Var var : mapping.getVarDefinition().getMap().keySet()) {
      varToMembers.put(var,i);
    }
  }
  Generator aliasGen=Gensym.create(""String_Node_Str"");
  ExprCommonFactor factorizer=new ExprCommonFactor(aliasGen);
  Map<String,TypeToken> unionTypeMap=new HashMap<String,TypeToken>();
  for (  Entry<Var,Collection<Integer>> entry : varToMembers.asMap().entrySet()) {
    Var var=entry.getKey();
    Collection<Integer> memberIndexes=entry.getValue();
    Multimap<Expr,ArgExpr> cluster=HashMultimap.create();
    for (    int index : memberIndexes) {
      Mapping member=members.get(index);
      Collection<RestrictedExpr> exprsForVar=member.getVarDefinition().getDefinitions(var);
      for (      RestrictedExpr def : exprsForVar) {
        Map<String,TypeToken> columnToDatatype=member.getSqlOp().getSchema().getTypeMap();
        Expr datatypeNorm=exprNormalizer.normalize(def.getExpr(),columnToDatatype);
        cluster.put(datatypeNorm,new ArgExpr(def.getExpr(),index));
      }
    }
    for (    Entry<Expr,Collection<ArgExpr>> clusterEntry : cluster.asMap().entrySet()) {
      Collection<ArgExpr> argExprs=clusterEntry.getValue();
      List<Expr> exprs=new ArrayList<Expr>();
      Map<Integer,Integer> exprToOp=new HashMap<Integer,Integer>();
      int i=0;
      for (      ArgExpr argExpr : argExprs) {
        Expr expr=argExpr.getExpr();
        exprs.add(expr);
        exprToOp.put(i,argExpr.getIndex());
        ++i;
      }
      List<Map<Var,Expr>> tmpPartialProjections=new ArrayList<Map<Var,Expr>>();
      Expr common=factorizer.transform(exprs,tmpPartialProjections);
      List<Map<String,SqlExpr>> partialProjections=new ArrayList<Map<String,SqlExpr>>();
      for (int j=0; j < tmpPartialProjections.size(); ++j) {
        int memberIndex=exprToOp.get(j);
        Mapping member=members.get(memberIndex);
        Map<Var,Expr> tmpMap=tmpPartialProjections.get(j);
        Map<String,SqlExpr> map=new HashMap<String,SqlExpr>();
        for (        Entry<Var,Expr> e : tmpMap.entrySet()) {
          Expr expr=e.getValue();
          Map<String,TypeToken> typeMap=member.getSqlOp().getSchema().getTypeMap();
          SqlExpr sqlExpr=sqlTranslator.translate(expr,null,typeMap);
          map.put(e.getKey().getVarName(),sqlExpr);
        }
        partialProjections.add(map);
      }
      unionVarDefs.put(var,new RestrictedExpr(common));
      for (int j=0; j < partialProjections.size(); ++j) {
        int originalIndex=exprToOp.get(j);
        Map<String,SqlExpr> projection=unionMemberProjections.get(originalIndex);
        Map<String,SqlExpr> partialProjection=partialProjections.get(j);
        for (        Entry<String,SqlExpr> ppEntry : partialProjection.entrySet()) {
          projection.put(ppEntry.getKey(),ppEntry.getValue());
        }
      }
    }
  }
  for (int i=0; i < unionMemberProjections.size(); ++i) {
    Mapping member=members.get(i);
    Map<String,TypeToken> typeMap=member.getSqlOp().getSchema().getTypeMap();
    Map<String,SqlExpr> projection=unionMemberProjections.get(i);
    for (    Entry<String,SqlExpr> entry : projection.entrySet()) {
      SqlExpr expr=entry.getValue();
      unionTypeMap.put(entry.getKey(),expr.getDatatype());
    }
  }
  List<String> unionColumnOrder=new ArrayList<String>(unionTypeMap.keySet());
  List<SqlOp> extended=new ArrayList<SqlOp>();
  for (int i=0; i < members.size(); ++i) {
    Mapping member=members.get(i);
    Map<String,SqlExpr> unionMemberProjection=unionMemberProjections.get(i);
    Set<String> names=new HashSet<String>(unionMemberProjection.keySet());
    Set<String> unboundColumns=Sets.difference(unionTypeMap.keySet(),names);
    for (    String columnName : unboundColumns) {
      TypeToken datatype=unionTypeMap.get(columnName);
      S_Constant nullValue=new S_Constant(datatype,null);
      unionMemberProjection.put(columnName,nullValue);
    }
    Projection finalMemberProjection=new Projection(unionColumnOrder,unionMemberProjection);
    SqlOpExtend extend=SqlOpExtend.create(member.getSqlOp(),finalMemberProjection);
    SqlOpProject opProject=SqlOpProject.create(extend,unionColumnOrder);
    extended.add(opProject);
  }
  SqlOpUnionN newUnion=SqlOpUnionN.create(extended);
  VarDefinition varDefinition=new VarDefinition(unionVarDefs);
  Mapping result=new Mapping(varDefinition,newUnion);
  return result;
}",0.9943458763891596
9868,"/** 
 * Creates an SQL condidion given a (SPARQL query filter) condition and a set of variable definitions. The resulting expression takes alternatives into account: Given for example: ?s -> {sa1, ..., san} ?o -> {so1} ?o must hold independently of ?s
 */
public static SqlExpr createSqlCondition(Expr condition,VarDefinition varDef,Map<String,TypeToken> typeMap,SqlTranslator sqlTranslator){
}","/** 
 * Creates an SQL condidion given a (SPARQL query filter) condition and a set of variable definitions. The resulting expression takes alternatives into account: Given for example: ?s -> {sa1, ..., san} ?o -> {so1} ?o must hold independently of ?s
 */
public static SqlExpr createSqlCondition(Expr condition,VarDefinition varDef,Map<String,TypeToken> typeMap,ExprEvaluator exprTransformer,SqlTranslator sqlTranslator){
}",0.9633251833740832
9869,"@Override public Mapping slice(Mapping a,Long limit,Long offset){
  SqlOpSlice opSlice=SqlOpSlice.create(a.getSqlOp(),limit,offset);
  Mapping result=new Mapping(a.getVarDefinition(),opSlice);
  return result;
}","@Override public Mapping slice(Mapping a,Long limit,Long offset){
  SqlOpSlice opSlice=SqlOpSlice.create(a.getSqlOp(),offset,limit);
  Mapping result=new Mapping(a.getVarDefinition(),opSlice);
  return result;
}",0.966824644549763
9870,"public static Op surroundWithFilterIfNeccessary(Op op,RestrictionManagerImpl cnf){
  if (cnf.getCnf().isEmpty()) {
    return op;
  }
 else {
    Op result=new OpFilterIndexed(op,cnf);
    return result;
  }
}","public static Op surroundWithFilterIfNeccessary(Op op,RestrictionManagerImpl cnf){
  Op result;
  if (cnf.isUnsatisfiable()) {
    result=new OpFilterIndexed(op,new RestrictionManagerImpl(new NestedNormalForm(new HashSet<Clause>(Collections.singleton(new Clause(new HashSet<Expr>(Collections.singleton(NodeValue.FALSE))))))));
  }
 else   if (cnf.getCnf().isEmpty()) {
    result=op;
  }
 else {
    result=new OpFilterIndexed(op,cnf);
  }
  return result;
}",0.5577211394302849
9871,"public static Op optimize(Op op,RestrictionManagerImpl cnf){
  if (op instanceof OpNull) {
    return op;
  }
  return (Op)MultiMethod.invokeStatic(FilterPlacementOptimizer2.class,""String_Node_Str"",op,cnf);
}","public static Op optimize(Op op,RestrictionManagerImpl cnf){
  if (op instanceof OpNull) {
    return op;
  }
  Op result=MultiMethod.invokeStatic(FilterPlacementOptimizer2.class,""String_Node_Str"",op,cnf);
  return result;
}",0.9120370370370372
9872,"@Test public void creationTest() throws RecognitionException, SQLException, IOException {
  RdfViewSystemOld.initSparqlifyFunctions();
  DatatypeSystem datatypeSystem=SparqlifyUtils.createDefaultDatatypeSystem();
  SqlTranslator sqlTranslator=new SqlTranslatorImpl(datatypeSystem);
  DataSource dataSource=SparqlifyUtils.createTestDatabase();
  Connection conn=dataSource.getConnection();
  Map<String,String> typeAlias=MapReader.readFile(new File(""String_Node_Str""));
  ViewDefinitionFactory vdf=SparqlifyUtils.createViewDefinitionFactory(conn,typeAlias);
  ViewDefinition personView=vdf.create(""String_Node_Str"");
  ViewDefinition deptView=vdf.create(""String_Node_Str"");
  ViewDefinition personToDeptView=vdf.create(""String_Node_Str"");
  CandidateViewSelector candidateViewSelector=new CandidateViewSelectorImpl();
  candidateViewSelector.addView(personView);
  candidateViewSelector.addView(deptView);
  candidateViewSelector.addView(personToDeptView);
  SparqlSqlRewriter rewriter=SparqlifyUtils.createTestRewriter(candidateViewSelector,datatypeSystem);
  QueryExecutionFactory qef=new QueryExecutionFactorySparqlifyDs(rewriter,dataSource);
{
    QueryExecution qe=qef.createQueryExecution(""String_Node_Str"");
    ResultSet rs=qe.execSelect();
    String rsStr=ResultSetFormatter.asText(rs);
    System.out.println(rsStr);
  }
{
    QueryExecution qe=qef.createQueryExecution(""String_Node_Str"");
    ResultSet rs=qe.execSelect();
    String rsStr=ResultSetFormatter.asText(rs);
    System.out.println(rsStr);
  }
}","@Test public void creationTest() throws RecognitionException, SQLException, IOException {
  RdfViewSystemOld.initSparqlifyFunctions();
  DatatypeSystem datatypeSystem=SparqlifyUtils.createDefaultDatatypeSystem();
  SqlTranslator sqlTranslator=new SqlTranslatorImpl(datatypeSystem);
  DataSource dataSource=SparqlifyUtils.createTestDatabase();
  Connection conn=dataSource.getConnection();
  Map<String,String> typeAlias=MapReader.readFile(new File(""String_Node_Str""));
  ViewDefinitionFactory vdf=SparqlifyUtils.createViewDefinitionFactory(conn,typeAlias);
  ViewDefinition personView=vdf.create(""String_Node_Str"");
  ViewDefinition deptView=vdf.create(""String_Node_Str"");
  ViewDefinition personToDeptView=vdf.create(""String_Node_Str"");
  CandidateViewSelector candidateViewSelector=new CandidateViewSelectorImpl();
  candidateViewSelector.addView(personView);
  candidateViewSelector.addView(deptView);
  candidateViewSelector.addView(personToDeptView);
  SparqlSqlRewriter rewriter=SparqlifyUtils.createTestRewriter(candidateViewSelector,datatypeSystem);
  QueryExecutionFactory qef=new QueryExecutionFactorySparqlifyDs(rewriter,dataSource);
{
    QueryExecution qe=qef.createQueryExecution(""String_Node_Str"");
    ResultSet rs=qe.execSelect();
    String rsStr=ResultSetFormatter.asText(rs);
    System.out.println(rsStr);
  }
}",0.9347368421052632
9873,"/** 
 * In place projection
 * @param columnNames
 */
public void project(List<String> columnNames){
  this.names.retainAll(columnNames);
  this.nameToExpr.keySet().retainAll(columnNames);
}","/** 
 * In place projection
 * @param columnNames
 */
public void project(List<String> columnNames){
  this.names=columnNames;
  this.nameToExpr.keySet().retainAll(columnNames);
}",0.964769647696477
9874,"/** 
 * [    null,  h: int, i: string,   null ] [ a: int      null,      null, x: geo ] ?s = uri(concat(""http://..."", ?c1, ?c2)); ?s -> [c1: string, c2: int] with expr foo and restriction bar.
 */
public Mapping union(List<Mapping> members){
  if (members.size() == 1) {
    logger.warn(""String_Node_Str"");
    Mapping result=members.get(0);
  }
  Multimap<Var,RestrictedExpr> unionVarDefs=HashMultimap.create();
  List<Map<String,SqlExpr>> unionMemberProjections=new ArrayList<Map<String,SqlExpr>>();
  for (int i=0; i < members.size(); ++i) {
    Map<String,SqlExpr> tmp=new HashMap<String,SqlExpr>();
    unionMemberProjections.add(tmp);
  }
  Multimap<Var,Integer> varToMembers=HashMultimap.create();
  for (int i=0; i < members.size(); ++i) {
    Mapping mapping=members.get(i);
    for (    Var var : mapping.getVarDefinition().getMap().keySet()) {
      varToMembers.put(var,i);
    }
  }
  Generator aliasGen=Gensym.create(""String_Node_Str"");
  ExprCommonFactor factorizer=new ExprCommonFactor(aliasGen);
  Map<String,TypeToken> unionTypeMap=new HashMap<String,TypeToken>();
  for (  Entry<Var,Collection<Integer>> entry : varToMembers.asMap().entrySet()) {
    Var var=entry.getKey();
    Collection<Integer> memberIndexes=entry.getValue();
    Multimap<Expr,ArgExpr> cluster=HashMultimap.create();
    for (    int index : memberIndexes) {
      Mapping member=members.get(index);
      Collection<RestrictedExpr> exprsForVar=member.getVarDefinition().getDefinitions(var);
      for (      RestrictedExpr def : exprsForVar) {
        Map<String,TypeToken> columnToDatatype=member.getSqlOp().getSchema().getTypeMap();
        Expr datatypeNorm=exprNormalizer.normalize(def.getExpr(),columnToDatatype);
        cluster.put(datatypeNorm,new ArgExpr(def.getExpr(),index));
      }
    }
    for (    Entry<Expr,Collection<ArgExpr>> clusterEntry : cluster.asMap().entrySet()) {
      Collection<ArgExpr> argExprs=clusterEntry.getValue();
      List<Expr> exprs=new ArrayList<Expr>();
      Map<Integer,Integer> exprToOp=new HashMap<Integer,Integer>();
      int i=0;
      for (      ArgExpr argExpr : argExprs) {
        Expr expr=argExpr.getExpr();
        exprs.add(expr);
        exprToOp.put(i,argExpr.getIndex());
        ++i;
      }
      List<Map<Var,Expr>> tmpPartialProjections=new ArrayList<Map<Var,Expr>>();
      Expr common=factorizer.transform(exprs,tmpPartialProjections);
      List<Map<String,SqlExpr>> partialProjections=new ArrayList<Map<String,SqlExpr>>();
      for (int j=0; j < tmpPartialProjections.size(); ++j) {
        int memberIndex=exprToOp.get(j);
        Mapping member=members.get(memberIndex);
        Map<Var,Expr> tmpMap=tmpPartialProjections.get(j);
        Map<String,SqlExpr> map=new HashMap<String,SqlExpr>();
        for (        Entry<Var,Expr> e : tmpMap.entrySet()) {
          Expr expr=e.getValue();
          Map<String,TypeToken> typeMap=member.getSqlOp().getSchema().getTypeMap();
          SqlExpr sqlExpr=sqlTranslator.translate(expr,null,typeMap);
          map.put(e.getKey().getVarName(),sqlExpr);
        }
        partialProjections.add(map);
      }
      unionVarDefs.put(var,new RestrictedExpr(common));
      for (int j=0; j < partialProjections.size(); ++j) {
        int originalIndex=exprToOp.get(j);
        Map<String,SqlExpr> projection=unionMemberProjections.get(originalIndex);
        Map<String,SqlExpr> partialProjection=partialProjections.get(j);
        for (        Entry<String,SqlExpr> ppEntry : partialProjection.entrySet()) {
          projection.put(ppEntry.getKey(),ppEntry.getValue());
        }
      }
    }
  }
  for (int i=0; i < unionMemberProjections.size(); ++i) {
    Mapping member=members.get(i);
    Map<String,TypeToken> typeMap=member.getSqlOp().getSchema().getTypeMap();
    Map<String,SqlExpr> projection=unionMemberProjections.get(i);
    for (    Entry<String,SqlExpr> entry : projection.entrySet()) {
      SqlExpr expr=entry.getValue();
      unionTypeMap.put(entry.getKey(),expr.getDatatype());
    }
  }
  List<String> unionColumnOrder=new ArrayList<String>(unionTypeMap.keySet());
  List<SqlOp> extended=new ArrayList<SqlOp>();
  for (int i=0; i < members.size(); ++i) {
    Mapping member=members.get(i);
    Map<String,SqlExpr> unionMemberProjection=unionMemberProjections.get(i);
    Set<String> names=new HashSet<String>(unionMemberProjection.keySet());
    Set<String> unboundColumns=Sets.difference(unionTypeMap.keySet(),names);
    for (    String columnName : unboundColumns) {
      TypeToken datatype=unionTypeMap.get(columnName);
      S_Constant nullValue=new S_Constant(datatype,null);
      unionMemberProjection.put(columnName,nullValue);
    }
    Projection finalMemberProjection=new Projection(unionColumnOrder,unionMemberProjection);
    SqlOpExtend extend=SqlOpExtend.create(member.getSqlOp(),finalMemberProjection);
    SqlOpProject opProject=SqlOpProject.create(extend,unionColumnOrder);
    extended.add(opProject);
  }
  SqlOpUnionN newUnion=SqlOpUnionN.create(extended);
  VarDefinition varDefinition=new VarDefinition(unionVarDefs);
  Mapping result=new Mapping(varDefinition,newUnion);
  return result;
}","/** 
 * [    null,  h: int, i: string,   null ] [ a: int      null,      null, x: geo ] ?s = uri(concat(""http://..."", ?c1, ?c2)); ?s -> [c1: string, c2: int] with expr foo and restriction bar.
 */
public Mapping union(List<Mapping> members){
  if (members.size() == 1) {
    logger.warn(""String_Node_Str"");
    Mapping result=members.get(0);
    return result;
  }
  Multimap<Var,RestrictedExpr> unionVarDefs=HashMultimap.create();
  List<Map<String,SqlExpr>> unionMemberProjections=new ArrayList<Map<String,SqlExpr>>();
  for (int i=0; i < members.size(); ++i) {
    Map<String,SqlExpr> tmp=new HashMap<String,SqlExpr>();
    unionMemberProjections.add(tmp);
  }
  Multimap<Var,Integer> varToMembers=HashMultimap.create();
  for (int i=0; i < members.size(); ++i) {
    Mapping mapping=members.get(i);
    for (    Var var : mapping.getVarDefinition().getMap().keySet()) {
      varToMembers.put(var,i);
    }
  }
  Generator aliasGen=Gensym.create(""String_Node_Str"");
  ExprCommonFactor factorizer=new ExprCommonFactor(aliasGen);
  Map<String,TypeToken> unionTypeMap=new HashMap<String,TypeToken>();
  for (  Entry<Var,Collection<Integer>> entry : varToMembers.asMap().entrySet()) {
    Var var=entry.getKey();
    Collection<Integer> memberIndexes=entry.getValue();
    Multimap<String,ArgExpr> cluster=HashMultimap.create();
    for (    int index : memberIndexes) {
      Mapping member=members.get(index);
      Collection<RestrictedExpr> exprsForVar=member.getVarDefinition().getDefinitions(var);
      for (      RestrictedExpr def : exprsForVar) {
        Map<String,TypeToken> columnToDatatype=member.getSqlOp().getSchema().getTypeMap();
        Expr datatypeNorm=exprNormalizer.normalize(def.getExpr(),columnToDatatype);
        String hash=datatypeNorm.toString();
        cluster.put(hash,new ArgExpr(def.getExpr(),index));
      }
    }
    for (    Entry<String,Collection<ArgExpr>> clusterEntry : cluster.asMap().entrySet()) {
      Collection<ArgExpr> argExprs=clusterEntry.getValue();
      List<Expr> exprs=new ArrayList<Expr>();
      Map<Integer,Integer> exprToOp=new HashMap<Integer,Integer>();
      int i=0;
      for (      ArgExpr argExpr : argExprs) {
        Expr expr=argExpr.getExpr();
        exprs.add(expr);
        exprToOp.put(i,argExpr.getIndex());
        ++i;
      }
      List<Map<Var,Expr>> tmpPartialProjections=new ArrayList<Map<Var,Expr>>();
      Expr common=factorizer.transform(exprs,tmpPartialProjections);
      List<Map<String,SqlExpr>> partialProjections=new ArrayList<Map<String,SqlExpr>>();
      for (int j=0; j < tmpPartialProjections.size(); ++j) {
        int memberIndex=exprToOp.get(j);
        Mapping member=members.get(memberIndex);
        Map<String,TypeToken> typeMap=member.getSqlOp().getSchema().getTypeMap();
        Map<Var,Expr> tmpMap=tmpPartialProjections.get(j);
        Map<String,SqlExpr> map=new HashMap<String,SqlExpr>();
        for (        Entry<Var,Expr> e : tmpMap.entrySet()) {
          String columnName=e.getKey().getVarName();
          Expr expr=e.getValue();
          SqlExpr sqlExpr=sqlTranslator.translate(expr,null,typeMap);
          map.put(columnName,sqlExpr);
          if (columnName.equals(""String_Node_Str"")) {
            System.out.println(""String_Node_Str"");
          }
          unionTypeMap.put(columnName,sqlExpr.getDatatype());
          System.out.println(""String_Node_Str"" + unionTypeMap);
        }
        partialProjections.add(map);
      }
      unionVarDefs.put(var,new RestrictedExpr(common));
      for (int j=0; j < partialProjections.size(); ++j) {
        int originalIndex=exprToOp.get(j);
        Map<String,SqlExpr> projection=unionMemberProjections.get(originalIndex);
        Map<String,SqlExpr> partialProjection=partialProjections.get(j);
        for (        Entry<String,SqlExpr> ppEntry : partialProjection.entrySet()) {
          projection.put(ppEntry.getKey(),ppEntry.getValue());
        }
      }
    }
  }
  List<String> unionColumnOrder=new ArrayList<String>(unionTypeMap.keySet());
  System.out.println(""String_Node_Str"" + unionTypeMap);
  List<SqlOp> extended=new ArrayList<SqlOp>();
  for (int i=0; i < members.size(); ++i) {
    Mapping member=members.get(i);
    Map<String,SqlExpr> unionMemberProjection=unionMemberProjections.get(i);
    Set<String> names=new HashSet<String>(unionMemberProjection.keySet());
    Set<String> unboundColumns=Sets.difference(unionTypeMap.keySet(),names);
    for (    String columnName : unboundColumns) {
      TypeToken datatype=unionTypeMap.get(columnName);
      S_Constant nullValue=new S_Constant(datatype,null);
      unionMemberProjection.put(columnName,nullValue);
    }
    Projection finalMemberProjection=new Projection(unionColumnOrder,unionMemberProjection);
    SqlOpExtend extend=SqlOpExtend.create(member.getSqlOp(),finalMemberProjection);
    SqlOpProject opProject=SqlOpProject.create(extend,unionColumnOrder);
    extended.add(opProject);
  }
  SqlOpUnionN newUnion=SqlOpUnionN.create(extended);
  for (  SqlOp m : newUnion.getSubOps()) {
    System.out.println(m.getSchema().getColumnNames());
  }
  VarDefinition varDefinition=new VarDefinition(unionVarDefs);
  Mapping result=new Mapping(varDefinition,newUnion);
  return result;
}",0.7949088805322534
9875,"@Override public SparqlSqlRewrite rewrite(Query query){
  Op opViewInstance=candidateViewSelector.getApplicableViews(query);
  logger.debug(""String_Node_Str"" + opViewInstance);
  List<Var> projectionOrder=null;
  if (query.isSelectType() && query.isQueryResultStar()) {
    projectionOrder=query.getProjectVars();
  }
 else {
    projectionOrder=query.getProjectVars();
  }
  Mapping mapping=opMappingRewriter.rewrite(opViewInstance);
  logger.debug(""String_Node_Str"" + mapping);
  SqlOp block=sqlOpSelectBlockCollector.transform(mapping.getSqlOp());
  String sqlQueryString=sqlOpSerializer.serialize(block);
  logger.info(sqlQueryString);
  SparqlSqlRewrite result=new SparqlSqlRewrite(sqlQueryString,mapping.getVarDefinition(),projectionOrder);
  return result;
}","@Override public SparqlSqlRewrite rewrite(Query query){
  Op opViewInstance=candidateViewSelector.getApplicableViews(query);
  logger.debug(""String_Node_Str"" + opViewInstance);
  List<Var> projectionOrder=null;
  if (query.isSelectType() && query.isQueryResultStar()) {
    projectionOrder=query.getProjectVars();
  }
 else {
    projectionOrder=query.getProjectVars();
  }
  Mapping mapping=opMappingRewriter.rewrite(opViewInstance);
  logger.debug(""String_Node_Str"" + toIndentedString(mapping.getVarDefinition()));
  SqlOp block=sqlOpSelectBlockCollector.transform(mapping.getSqlOp());
  String sqlQueryString=sqlOpSerializer.serialize(block);
  logger.info(""String_Node_Str"" + sqlQueryString);
  SparqlSqlRewrite result=new SparqlSqlRewrite(sqlQueryString,mapping.getVarDefinition(),projectionOrder);
  return result;
}",0.9640831758034026
9876,"public VarDefinition copyExpandConstants(){
  Multimap<Var,RestrictedExpr> resultMap=HashMultimap.create();
  for (  Entry<Var,RestrictedExpr> entry : varToExprs.entries()) {
    Var var=entry.getKey();
    RestrictedExpr restExpr=entry.getValue();
    Expr expr=restExpr.getExpr();
    Expr expandedExpr=ConstantExpander.transform(expr);
    RestrictedExpr finalExpr=new RestrictedExpr(expandedExpr,restExpr.getRestrictions());
    resultMap.put(var,finalExpr);
  }
  VarDefinition result=new VarDefinition(resultMap);
  return result;
}","public VarDefinition copyExpandConstants(){
  Multimap<Var,RestrictedExpr> resultMap=HashMultimap.create();
  for (  Entry<Var,RestrictedExpr> entry : varToExprs.entries()) {
    Var var=entry.getKey();
    RestrictedExpr restExpr=entry.getValue();
    Expr expr=restExpr.getExpr();
    Expr expandedExpr;
    if (expr.isConstant()) {
      expandedExpr=ConstantExpander._transform(expr.getConstant());
    }
 else {
      expandedExpr=expr;
    }
    RestrictedExpr finalExpr=new RestrictedExpr(expandedExpr,restExpr.getRestrictions());
    resultMap.put(var,finalExpr);
  }
  VarDefinition result=new VarDefinition(resultMap);
  return result;
}",0.8877637130801688
9877,"public DatatypeSystemDefault(){
  for (  SqlDatatype item : DatatypeSystemDefault.getDefaultDatatypes()) {
    nameToDatatype.put(item.getName(),item);
  }
  for (  Entry<SqlDatatype,SqlDatatype> entry : childToParent.entries()) {
    typeHierarchy.put(entry.getKey(),entry.getValue());
  }
}","public DatatypeSystemDefault(){
  for (  SqlDatatype item : DatatypeSystemDefault.getDefaultDatatypes()) {
    nameToDatatype.put(item.getName(),item);
    if (item.getXsd() != null) {
      nameToDatatype.put(item.getXsd().getURI(),item);
    }
  }
  for (  Entry<SqlDatatype,SqlDatatype> entry : childToParent.entries()) {
    typeHierarchy.put(entry.getKey(),entry.getValue());
  }
}",0.8613569321533924
9878,"public static void main(String[] args) throws Exception {
  PropertyConfigurator.configure(""String_Node_Str"");
  Connection conn=getConnection();
  RdfViewSystemOld system=configureSystem(conn);
  QueryExecutionFactory sparqler=new QueryExecutionFactorySparqlify(system,conn);
  String polygon=""String_Node_Str"";
  String prefixes=""String_Node_Str"";
  prefixes+=""String_Node_Str"";
  prefixes+=""String_Node_Str"" + OWL.getURI() + ""String_Node_Str"";
  prefixes+=""String_Node_Str"" + RDFS.getURI() + ""String_Node_Str"";
  String str=prefixes + ""String_Node_Str"";
  ResultSet rs=sparqler.createQueryExecution(str).execSelect();
  System.out.println(ResultSetFormatter.asText(rs));
}","public static void main(String[] args) throws Exception {
  PropertyConfigurator.configure(""String_Node_Str"");
  if (true) {
    String str=""String_Node_Str"";
    Query q=QueryFactory.create(str);
    Op op=Algebra.compile(q);
    Algebra.toQuadForm(op);
    System.out.println(op);
    return;
  }
  Connection conn=getConnection();
  RdfViewSystemOld system=configureSystem(conn);
  QueryExecutionFactory sparqler=new QueryExecutionFactorySparqlify(system,conn);
  String polygon=""String_Node_Str"";
  String prefixes=""String_Node_Str"";
  prefixes+=""String_Node_Str"";
  prefixes+=""String_Node_Str"" + OWL.getURI() + ""String_Node_Str"";
  prefixes+=""String_Node_Str"" + RDFS.getURI() + ""String_Node_Str"";
  String str=prefixes + ""String_Node_Str"";
  ResultSet rs=sparqler.createQueryExecution(str).execSelect();
  System.out.println(ResultSetFormatter.asText(rs));
}",0.8777633289986996
9879,"public static int hash(Expr expr,Map<String,SqlDatatype> columnToDatatype){
  return (Integer)MultiMethod.invokeStatic(ExprDatatypeHash.class,""String_Node_Str"",expr,columnToDatatype);
}","public static int hash(Expr expr,Map<String,SqlDatatype> columnToDatatype){
  if (expr == null) {
    return 7531902;
  }
  return (Integer)MultiMethod.invokeStatic(ExprDatatypeHash.class,""String_Node_Str"",expr,columnToDatatype);
}",0.8894230769230769
9880,"public static SqlNode union(ColRelGenerator generator,List<SqlNode> sqlNodes){
  if (sqlNodes.isEmpty()) {
    return new SqlNodeEmpty();
  }
  if (sqlNodes.size() == 1) {
    return sqlNodes.get(0);
  }
  Multimap<Var,TermDef> commons=HashMultimap.create();
  List<Multimap<Var,TermDef>> projections=new ArrayList<Multimap<Var,TermDef>>();
  for (int i=0; i < sqlNodes.size(); ++i) {
    Multimap<Var,TermDef> tmp=HashMultimap.create();
    projections.add(tmp);
  }
  Multimap<Var,Integer> varToSqlNode=HashMultimap.create();
  for (int i=0; i < sqlNodes.size(); ++i) {
    SqlNode sqlNode=sqlNodes.get(i);
    for (    Node var : sqlNode.getSparqlVarsMentioned()) {
      varToSqlNode.put((Var)var,i);
    }
  }
  Generator aliasGen=Gensym.create(""String_Node_Str"");
  ExprCommonFactor factorizer=new ExprCommonFactor(aliasGen);
  Map<String,SqlDatatype> allColumnsToDatatype=new HashMap<String,SqlDatatype>();
  for (  Entry<Var,Collection<Integer>> entry : varToSqlNode.asMap().entrySet()) {
    Var var=entry.getKey();
    Multimap<Integer,ArgExpr> cluster=HashMultimap.create();
    RestrictionSet restrictionsForVar=new RestrictionSet(false);
    for (    int index : entry.getValue()) {
      SqlNode sqlNode=sqlNodes.get(index);
      Collection<TermDef> exprsForVar=sqlNode.getSparqlVarToExprs().get(var);
      for (      TermDef def : exprsForVar) {
        restrictionsForVar.addAlternatives(def.getRestrictions());
        Map<String,SqlDatatype> columnToDatatype=SqlNodeUtil.getColumnToDatatype(sqlNode);
        Integer hash=ExprDatatypeHash.hash(def.getExpr(),columnToDatatype);
        cluster.put(hash,new ArgExpr(def.getExpr(),index));
      }
    }
    for (    Entry<Integer,Collection<ArgExpr>> clusterEntry : cluster.asMap().entrySet()) {
      Collection<ArgExpr> argExprs=clusterEntry.getValue();
      List<Expr> exprs=new ArrayList<Expr>();
      Map<Integer,Integer> exprToNode=new HashMap<Integer,Integer>();
      int i=0;
      for (      ArgExpr argExpr : argExprs) {
        exprs.add(argExpr.getExpr());
        exprToNode.put(i,argExpr.getIndex());
        ++i;
      }
      List<Map<Var,Expr>> partialProjections=new ArrayList<Map<Var,Expr>>();
      Expr common=factorizer.transform(exprs,partialProjections);
      commons.put(var,new TermDef(common,restrictionsForVar));
      for (int j=0; j < partialProjections.size(); ++j) {
        int originalIndex=exprToNode.get(j);
        Multimap<Var,TermDef> projection=projections.get(originalIndex);
        Map<Var,Expr> partialProjection=partialProjections.get(j);
        for (        Entry<Var,Expr> ppEntry : partialProjection.entrySet()) {
          projection.put(ppEntry.getKey(),new TermDef(ppEntry.getValue()));
        }
      }
    }
  }
  for (int i=0; i < projections.size(); ++i) {
    SqlNode tmp=sqlNodes.get(i);
    Multimap<Var,TermDef> projection=projections.get(i);
    NodeExprSubstitutor substitutor=createSubstitutor(tmp);
    Map<String,SqlExpr> subbedProj=new HashMap<String,SqlExpr>();
    for (    Entry<Var,TermDef> entry : projection.entries()) {
      Expr subbed=substitutor.transformMM(entry.getValue().getExpr());
      Expr pushed=PushDown.pushDownMM(subbed);
      if (!(pushed instanceof ExprSqlBridge)) {
        throw new RuntimeException(""String_Node_Str"");
      }
      SqlExpr sqlExpr=((ExprSqlBridge)pushed).getSqlExpr();
      subbedProj.put(entry.getKey().getName(),sqlExpr);
      allColumnsToDatatype.put(entry.getKey().getName(),sqlExpr.getDatatype());
    }
    tmp.getAliasToColumn().clear();
    tmp.getAliasToColumn().putAll(subbedProj);
    tmp.getSparqlVarToExprs().clear();
    tmp.getSparqlVarToExprs().putAll(commons);
  }
  for (  SqlNode sqlNode : sqlNodes) {
    Set<String> unboundColumns=Sets.difference(allColumnsToDatatype.keySet(),sqlNode.getAliasToColumn().keySet());
    for (    String columnName : unboundColumns) {
      SqlDatatype datatype=allColumnsToDatatype.get(columnName);
      sqlNode.getAliasToColumn().put(columnName,SqlExprValue.createNull(datatype));
    }
  }
  String unionAlias=generator.nextRelation();
  SqlNode result=new SqlUnionN(unionAlias,sqlNodes);
  result.getSparqlVarToExprs().putAll(commons);
  for (  Entry<String,SqlDatatype> entry : allColumnsToDatatype.entrySet()) {
    String columnName=entry.getKey();
    SqlDatatype datatype=entry.getValue();
    result.getAliasToColumn().put(columnName,new SqlExprColumn(unionAlias,columnName,datatype));
  }
  return result;
}","public static SqlNode union(ColRelGenerator generator,List<SqlNode> sqlNodes){
  if (sqlNodes.isEmpty()) {
    return new SqlNodeEmpty();
  }
  if (sqlNodes.size() == 1) {
    return sqlNodes.get(0);
  }
  Multimap<Var,TermDef> commons=HashMultimap.create();
  List<Multimap<Var,TermDef>> projections=new ArrayList<Multimap<Var,TermDef>>();
  for (int i=0; i < sqlNodes.size(); ++i) {
    Multimap<Var,TermDef> tmp=HashMultimap.create();
    projections.add(tmp);
  }
  Multimap<Var,Integer> varToSqlNode=HashMultimap.create();
  Generator aliasGen=Gensym.create(""String_Node_Str"");
  for (int i=0; i < sqlNodes.size(); ++i) {
    SqlNode sqlNode=sqlNodes.get(i);
    Set<Var> vars=new HashSet<Var>(sqlNode.getSparqlVarsMentioned());
    for (    Var var : vars) {
      List<TermDef> termDefs=new ArrayList<TermDef>(sqlNode.getSparqlVarToExprs().get(var));
      for (      TermDef termDef : termDefs) {
        Expr expr=termDef.getExpr();
        if (termDef.getExpr().isConstant()) {
          sqlNode.getSparqlVarToExprs().remove(var,termDef);
          NodeValue nv=ExprUtils.eval(expr);
          Object o=NodeValueUtils.getValue(nv);
          SqlExprValue sv=new SqlExprValue(o);
          String columnAlias=aliasGen.next();
          List<Expr> newArgs=new ArrayList<Expr>(expr.getFunction().getArgs());
          newArgs.set(1,new ExprVar(columnAlias));
          Expr newExpr=ExprCopy.getInstance().copy(expr,newArgs);
          TermDef newTermDef=new TermDef(newExpr);
          sqlNode.getSparqlVarToExprs().put(var,newTermDef);
          sqlNode.getAliasToColumn().put(columnAlias,sv);
          sqlNode.getSparqlVarToExprs().put(var,newTermDef);
        }
      }
    }
  }
  for (int i=0; i < sqlNodes.size(); ++i) {
    SqlNode sqlNode=sqlNodes.get(i);
    for (    Node var : sqlNode.getSparqlVarsMentioned()) {
      varToSqlNode.put((Var)var,i);
    }
  }
  ExprCommonFactor factorizer=new ExprCommonFactor(aliasGen);
  Map<String,SqlDatatype> allColumnsToDatatype=new HashMap<String,SqlDatatype>();
  for (  Entry<Var,Collection<Integer>> entry : varToSqlNode.asMap().entrySet()) {
    Var var=entry.getKey();
    Multimap<Integer,ArgExpr> cluster=HashMultimap.create();
    RestrictionSet restrictionsForVar=new RestrictionSet(false);
    for (    int index : entry.getValue()) {
      SqlNode sqlNode=sqlNodes.get(index);
      Collection<TermDef> exprsForVar=sqlNode.getSparqlVarToExprs().get(var);
      for (      TermDef def : exprsForVar) {
        restrictionsForVar.addAlternatives(def.getRestrictions());
        Map<String,SqlDatatype> columnToDatatype=SqlNodeUtil.getColumnToDatatype(sqlNode);
        Integer hash=ExprDatatypeHash.hash(def.getExpr(),columnToDatatype);
        cluster.put(hash,new ArgExpr(def.getExpr(),index));
      }
    }
    for (    Entry<Integer,Collection<ArgExpr>> clusterEntry : cluster.asMap().entrySet()) {
      Collection<ArgExpr> argExprs=clusterEntry.getValue();
      List<Expr> exprs=new ArrayList<Expr>();
      Map<Integer,Integer> exprToNode=new HashMap<Integer,Integer>();
      int i=0;
      for (      ArgExpr argExpr : argExprs) {
        exprs.add(argExpr.getExpr());
        exprToNode.put(i,argExpr.getIndex());
        ++i;
      }
      List<Map<Var,Expr>> partialProjections=new ArrayList<Map<Var,Expr>>();
      Expr common=factorizer.transform(exprs,partialProjections);
      commons.put(var,new TermDef(common,restrictionsForVar));
      for (int j=0; j < partialProjections.size(); ++j) {
        int originalIndex=exprToNode.get(j);
        Multimap<Var,TermDef> projection=projections.get(originalIndex);
        Map<Var,Expr> partialProjection=partialProjections.get(j);
        for (        Entry<Var,Expr> ppEntry : partialProjection.entrySet()) {
          projection.put(ppEntry.getKey(),new TermDef(ppEntry.getValue()));
        }
      }
    }
  }
  for (int i=0; i < projections.size(); ++i) {
    SqlNode tmp=sqlNodes.get(i);
    Multimap<Var,TermDef> projection=projections.get(i);
    NodeExprSubstitutor substitutor=createSubstitutor(tmp);
    Map<String,SqlExpr> subbedProj=new HashMap<String,SqlExpr>();
    for (    Entry<Var,TermDef> entry : projection.entries()) {
      Expr subbed=substitutor.transformMM(entry.getValue().getExpr());
      Expr pushed=PushDown.pushDownMM(subbed);
      if (!(pushed instanceof ExprSqlBridge)) {
        throw new RuntimeException(""String_Node_Str"");
      }
      SqlExpr sqlExpr=((ExprSqlBridge)pushed).getSqlExpr();
      subbedProj.put(entry.getKey().getName(),sqlExpr);
      allColumnsToDatatype.put(entry.getKey().getName(),sqlExpr.getDatatype());
    }
    tmp.getAliasToColumn().clear();
    tmp.getAliasToColumn().putAll(subbedProj);
    tmp.getSparqlVarToExprs().clear();
    tmp.getSparqlVarToExprs().putAll(commons);
  }
  for (  SqlNode sqlNode : sqlNodes) {
    Set<String> unboundColumns=Sets.difference(allColumnsToDatatype.keySet(),sqlNode.getAliasToColumn().keySet());
    for (    String columnName : unboundColumns) {
      SqlDatatype datatype=allColumnsToDatatype.get(columnName);
      sqlNode.getAliasToColumn().put(columnName,SqlExprValue.createNull(datatype));
    }
  }
  String unionAlias=generator.nextRelation();
  SqlNode result=new SqlUnionN(unionAlias,sqlNodes);
  result.getSparqlVarToExprs().putAll(commons);
  for (  Entry<String,SqlDatatype> entry : allColumnsToDatatype.entrySet()) {
    String columnName=entry.getKey();
    SqlDatatype datatype=entry.getValue();
    result.getAliasToColumn().put(columnName,new SqlExprColumn(unionAlias,columnName,datatype));
  }
  return result;
}",0.8759226012367843
9881,"public Map<Var,Type> deriveTypeConstraints(RdfView view){
  Map<Var,Type> result=new HashMap<Var,Type>();
  for (  Entry<Node,Expr> entry : view.getBinding().entrySet()) {
    Var var=(Var)entry.getKey();
    ExprFunction termCtor=(ExprFunction)entry.getValue();
    String functionIri=termCtor.getFunctionSymbol().getSymbol();
    if (functionIri.equals(SparqlifyConstants.rdfTermLabel)) {
      Expr arg=termCtor.getArg(1);
      if (arg.isConstant()) {
        Object o=PushDown.getValue(arg.getConstant());
        Number number=(Number)o;
switch (number.intValue()) {
case 1:
          result.put(var,Type.URI);
        break;
case 2:
case 3:
      result.put(var,Type.LITERAL);
    break;
}
}
}
 else if (functionIri.equals(SparqlifyConstants.uriLabel)) {
result.put(var,Type.URI);
}
 else if (functionIri.equals(SparqlifyConstants.plainLiteralLabel) || functionIri.equals(SparqlifyConstants.typedLiteralLabel)) {
result.put(var,Type.LITERAL);
}
}
return result;
}","public Map<Var,Type> deriveTypeConstraints(RdfView view){
  Map<Var,Type> result=new HashMap<Var,Type>();
  for (  Entry<Node,Expr> entry : view.getBinding().entrySet()) {
    Var var=(Var)entry.getKey();
    ExprFunction termCtor=(ExprFunction)entry.getValue();
    String functionIri=termCtor.getFunctionSymbol().getSymbol();
    if (functionIri.equals(SparqlifyConstants.rdfTermLabel)) {
      Expr arg=termCtor.getArg(1);
      if (arg.isConstant()) {
        Object o=NodeValueUtils.getValue(arg.getConstant());
        Number number=(Number)o;
switch (number.intValue()) {
case 1:
          result.put(var,Type.URI);
        break;
case 2:
case 3:
      result.put(var,Type.LITERAL);
    break;
}
}
}
 else if (functionIri.equals(SparqlifyConstants.uriLabel)) {
result.put(var,Type.URI);
}
 else if (functionIri.equals(SparqlifyConstants.plainLiteralLabel) || functionIri.equals(SparqlifyConstants.typedLiteralLabel)) {
result.put(var,Type.LITERAL);
}
}
return result;
}",0.9886947584789312
9882,"/** 
 * If a variable equals a (uri or string) constant, it means that the view must provide a prefix for that value.
 * @param a
 * @param b
 * @return
 */
public static VariableConstraint deriveIsPrefixOfConstraint(Expr a,Expr b){
  if (!(a.isVariable() && b.isConstant())) {
    return null;
  }
  Object value=PushDown.getValue(b.getConstant());
  return new VariableConstraint(a.getVarName(),new IsPrefixOfConstraint(value.toString()));
}","/** 
 * If a variable equals a (uri or string) constant, it means that the view must provide a prefix for that value.
 * @param a
 * @param b
 * @return
 */
public static VariableConstraint deriveIsPrefixOfConstraint(Expr a,Expr b){
  if (!(a.isVariable() && b.isConstant())) {
    return null;
  }
  Object value=NodeValueUtils.getValue(b.getConstant());
  return new VariableConstraint(a.getVarName(),new IsPrefixOfConstraint(value.toString()));
}",0.9753363228699552
9883,"@Override public boolean login() throws LoginException {
  log.debug(""String_Node_Str"");
  try {
    Callback[] callbacks=new Callback[]{new NameCallback(""String_Node_Str"")};
    callbackHandler.handle(callbacks);
    String username=((NameCallback)callbacks[0]).getName();
    if (username != null) {
      OrganizationService service=(OrganizationService)getContainer().getComponentInstanceOfType(OrganizationService.class);
      UserHandler uHandler=service.getUserHandler();
      User user=uHandler.findUserByName(username,UserStatus.ANY);
      if (user == null) {
        log.debug(""String_Node_Str"",username);
      }
 else       if (user instanceof UserImpl && !((UserImpl)user).isEnabled()) {
        HttpServletRequest request=getCurrentHttpServletRequest();
        if (request != null) {
          request.setAttribute(DISABLED_USER_NAME,username);
        }
        throw new LoginException(""String_Node_Str"" + username + ""String_Node_Str"");
      }
    }
 else {
      log.debug(""String_Node_Str"");
    }
    return true;
  }
 catch (  final Exception e) {
    log.warn(e.getMessage());
    throw new LoginException(e.getMessage());
  }
}","@Override public boolean login() throws LoginException {
  log.debug(""String_Node_Str"");
  try {
    Callback[] callbacks=new Callback[]{new NameCallback(""String_Node_Str"")};
    callbackHandler.handle(callbacks);
    String username=((NameCallback)callbacks[0]).getName();
    if (username != null) {
      OrganizationService service=(OrganizationService)getContainer().getComponentInstanceOfType(OrganizationService.class);
      try {
        begin(service);
        UserHandler uHandler=service.getUserHandler();
        User user=uHandler.findUserByName(username,UserStatus.ANY);
        if (user == null) {
          log.debug(""String_Node_Str"",username);
        }
 else         if (user instanceof UserImpl && !((UserImpl)user).isEnabled()) {
          HttpServletRequest request=getCurrentHttpServletRequest();
          if (request != null) {
            request.setAttribute(DISABLED_USER_NAME,username);
          }
          throw new LoginException(""String_Node_Str"" + username + ""String_Node_Str"");
        }
      }
  finally {
        end(service);
      }
    }
 else {
      log.debug(""String_Node_Str"");
    }
    return true;
  }
 catch (  final Exception e) {
    log.warn(e.getMessage());
    throw new LoginException(e.getMessage());
  }
}",0.9545078577336642
9884,"public void testLongAccessToken() throws Exception {
  User user1=new UserImpl(""String_Node_Str"");
  orgService.getUserHandler().createUser(user1,false);
  String longAccessToken=createLongString();
  socialNetworkService.updateOAuthInfo(getFacebookProvider(),user1.getUserName(),""String_Node_Str"",createFacebookAccessToken(longAccessToken));
  assertEquals(longAccessToken,socialNetworkService.getOAuthAccessToken(getFacebookProvider(),user1.getUserName()).getAccessToken());
  String shortAccessToken=""String_Node_Str"";
  socialNetworkService.updateOAuthInfo(getFacebookProvider(),user1.getUserName(),""String_Node_Str"",createFacebookAccessToken(shortAccessToken));
  assertEquals(shortAccessToken,socialNetworkService.getOAuthAccessToken(getFacebookProvider(),user1.getUserName()).getAccessToken());
  GoogleAccessTokenContext grc=createGoogleAccessToken(longAccessToken,longAccessToken,""String_Node_Str"");
  socialNetworkService.updateOAuthInfo(getGoogleProvider(),user1.getUserName(),""String_Node_Str"",grc);
  assertEquals(grc,socialNetworkService.getOAuthAccessToken(getGoogleProvider(),user1.getUserName()));
  socialNetworkService.removeOAuthAccessToken(getGoogleProvider(),user1.getUserName());
  assertNull(socialNetworkService.getOAuthAccessToken(getGoogleProvider(),user1.getUserName()));
  TwitterAccessTokenContext twitterToken=new TwitterAccessTokenContext(longAccessToken,longAccessToken);
  socialNetworkService.updateOAuthAccessToken(getTwitterProvider(),user1.getUserName(),twitterToken);
  assertEquals(twitterToken,socialNetworkService.getOAuthAccessToken(getTwitterProvider(),user1.getUserName()));
  twitterToken=new TwitterAccessTokenContext(shortAccessToken,shortAccessToken);
  socialNetworkService.updateOAuthAccessToken(getTwitterProvider(),user1.getUserName(),twitterToken);
  assertEquals(twitterToken,socialNetworkService.getOAuthAccessToken(getTwitterProvider(),user1.getUserName()));
}","public void testLongAccessToken() throws Exception {
  User user1=new UserImpl(""String_Node_Str"");
  orgService.getUserHandler().createUser(user1,false);
  String longAccessToken=createLongString();
  socialNetworkService.updateOAuthInfo(getFacebookProvider(),user1.getUserName(),""String_Node_Str"",createFacebookAccessToken(longAccessToken));
  assertEquals(longAccessToken,socialNetworkService.getOAuthAccessToken(getFacebookProvider(),user1.getUserName()).getAccessToken());
  String shortAccessToken=""String_Node_Str"";
  socialNetworkService.updateOAuthInfo(getFacebookProvider(),user1.getUserName(),""String_Node_Str"",createFacebookAccessToken(shortAccessToken));
  assertEquals(shortAccessToken,socialNetworkService.getOAuthAccessToken(getFacebookProvider(),user1.getUserName()).getAccessToken());
  GoogleAccessTokenContext grc=createGoogleAccessToken(longAccessToken,longAccessToken,""String_Node_Str"");
  socialNetworkService.updateOAuthInfo(getGoogleProvider(),user1.getUserName(),""String_Node_Str"",grc);
  assertEquals(grc,socialNetworkService.getOAuthAccessToken(getGoogleProvider(),user1.getUserName()));
  socialNetworkService.removeOAuthAccessToken(getGoogleProvider(),user1.getUserName());
  assertNull(socialNetworkService.getOAuthAccessToken(getGoogleProvider(),user1.getUserName()));
  TwitterAccessTokenContext twitterToken=new TwitterAccessTokenContext(longAccessToken,longAccessToken);
  socialNetworkService.updateOAuthAccessToken(getTwitterProvider(),user1.getUserName(),twitterToken);
  assertEquals(twitterToken,socialNetworkService.getOAuthAccessToken(getTwitterProvider(),user1.getUserName()));
  twitterToken=new TwitterAccessTokenContext(shortAccessToken,shortAccessToken);
  socialNetworkService.updateOAuthAccessToken(getTwitterProvider(),user1.getUserName(),twitterToken);
  assertEquals(twitterToken,socialNetworkService.getOAuthAccessToken(getTwitterProvider(),user1.getUserName()));
  orgService.getUserHandler().removeUser(user1.getUserName(),false);
}",0.9823212913143736
9885,"public void testPersistOAuthProviderUsernames() throws Exception {
  User user1=new UserImpl(""String_Node_Str"");
  User user2=new UserImpl(""String_Node_Str"");
  orgService.getUserHandler().createUser(user1,false);
  orgService.getUserHandler().createUser(user2,false);
  UserProfile userProfile1=orgService.getUserProfileHandler().createUserProfileInstance(user1.getUserName());
  userProfile1.setAttribute(OAuthConstants.PROFILE_FACEBOOK_USERNAME,""String_Node_Str"");
  userProfile1.setAttribute(OAuthConstants.PROFILE_GOOGLE_USERNAME,""String_Node_Str"");
  orgService.getUserProfileHandler().saveUserProfile(userProfile1,true);
  UserProfile userProfile2=orgService.getUserProfileHandler().createUserProfileInstance(user2.getUserName());
  userProfile2.setAttribute(OAuthConstants.PROFILE_FACEBOOK_USERNAME,""String_Node_Str"");
  userProfile2.setAttribute(OAuthConstants.PROFILE_GOOGLE_USERNAME,""String_Node_Str"");
  orgService.getUserProfileHandler().saveUserProfile(userProfile2,true);
  User foundUser=socialNetworkService.findUserByOAuthProviderUsername(getFacebookProvider(),""String_Node_Str"");
  assertNotNull(foundUser);
  assertEquals(foundUser.getUserName(),user1.getUserName());
  User foundUser2=socialNetworkService.findUserByOAuthProviderUsername(getFacebookProvider(),""String_Node_Str"");
  assertNotNull(foundUser2);
  assertEquals(foundUser2.getUserName(),user2.getUserName());
  User foundUser3=socialNetworkService.findUserByOAuthProviderUsername(getGoogleProvider(),""String_Node_Str"");
  assertNotNull(foundUser3);
  assertEquals(foundUser3.getUserName(),user2.getUserName());
  socialNetworkService.updateOAuthInfo(getFacebookProvider(),user1.getUserName(),""String_Node_Str"",createFacebookAccessToken(""String_Node_Str""));
  User foundUser4=socialNetworkService.findUserByOAuthProviderUsername(getFacebookProvider(),""String_Node_Str"");
  assertNotNull(foundUser4);
  assertEquals(foundUser4.getUserName(),user1.getUserName());
  try {
    socialNetworkService.updateOAuthInfo(getFacebookProvider(),user2.getUserName(),""String_Node_Str"",createFacebookAccessToken(""String_Node_Str""));
    fail(""String_Node_Str"");
  }
 catch (  OAuthException gtnOauthOAuthException) {
    assertEquals(OAuthExceptionCode.DUPLICATE_OAUTH_PROVIDER_USERNAME,gtnOauthOAuthException.getExceptionCode());
    assertEquals(OAuthConstants.PROFILE_FACEBOOK_USERNAME,gtnOauthOAuthException.getExceptionAttribute(OAuthConstants.EXCEPTION_OAUTH_PROVIDER_USERNAME_ATTRIBUTE_NAME));
    assertEquals(""String_Node_Str"",gtnOauthOAuthException.getExceptionAttribute(OAuthConstants.EXCEPTION_OAUTH_PROVIDER_USERNAME));
  }
catch (  Exception e) {
    throw new UndeclaredThrowableException(e);
  }
}","public void testPersistOAuthProviderUsernames() throws Exception {
  User user1=new UserImpl(""String_Node_Str"");
  User user2=new UserImpl(""String_Node_Str"");
  orgService.getUserHandler().createUser(user1,false);
  orgService.getUserHandler().createUser(user2,false);
  UserProfile userProfile1=orgService.getUserProfileHandler().createUserProfileInstance(user1.getUserName());
  userProfile1.setAttribute(OAuthConstants.PROFILE_FACEBOOK_USERNAME,""String_Node_Str"");
  userProfile1.setAttribute(OAuthConstants.PROFILE_GOOGLE_USERNAME,""String_Node_Str"");
  orgService.getUserProfileHandler().saveUserProfile(userProfile1,true);
  UserProfile userProfile2=orgService.getUserProfileHandler().createUserProfileInstance(user2.getUserName());
  userProfile2.setAttribute(OAuthConstants.PROFILE_FACEBOOK_USERNAME,""String_Node_Str"");
  userProfile2.setAttribute(OAuthConstants.PROFILE_GOOGLE_USERNAME,""String_Node_Str"");
  orgService.getUserProfileHandler().saveUserProfile(userProfile2,true);
  User foundUser=socialNetworkService.findUserByOAuthProviderUsername(getFacebookProvider(),""String_Node_Str"");
  assertNotNull(foundUser);
  assertEquals(foundUser.getUserName(),user1.getUserName());
  User foundUser2=socialNetworkService.findUserByOAuthProviderUsername(getFacebookProvider(),""String_Node_Str"");
  assertNotNull(foundUser2);
  assertEquals(foundUser2.getUserName(),user2.getUserName());
  User foundUser3=socialNetworkService.findUserByOAuthProviderUsername(getGoogleProvider(),""String_Node_Str"");
  assertNotNull(foundUser3);
  assertEquals(foundUser3.getUserName(),user2.getUserName());
  socialNetworkService.updateOAuthInfo(getFacebookProvider(),user1.getUserName(),""String_Node_Str"",createFacebookAccessToken(""String_Node_Str""));
  User foundUser4=socialNetworkService.findUserByOAuthProviderUsername(getFacebookProvider(),""String_Node_Str"");
  assertNotNull(foundUser4);
  assertEquals(foundUser4.getUserName(),user1.getUserName());
  try {
    socialNetworkService.updateOAuthInfo(getFacebookProvider(),user2.getUserName(),""String_Node_Str"",createFacebookAccessToken(""String_Node_Str""));
    fail(""String_Node_Str"");
  }
 catch (  OAuthException gtnOauthOAuthException) {
    assertEquals(OAuthExceptionCode.DUPLICATE_OAUTH_PROVIDER_USERNAME,gtnOauthOAuthException.getExceptionCode());
    assertEquals(OAuthConstants.PROFILE_FACEBOOK_USERNAME,gtnOauthOAuthException.getExceptionAttribute(OAuthConstants.EXCEPTION_OAUTH_PROVIDER_USERNAME_ATTRIBUTE_NAME));
    assertEquals(""String_Node_Str"",gtnOauthOAuthException.getExceptionAttribute(OAuthConstants.EXCEPTION_OAUTH_PROVIDER_USERNAME));
  }
catch (  Exception e) {
    throw new UndeclaredThrowableException(e);
  }
  orgService.getUserHandler().removeUser(user1.getUserName(),false);
  orgService.getUserHandler().removeUser(user2.getUserName(),false);
}",0.9748999636231356
9886,"public void testInvalidationOfAccessTokens() throws Exception {
  User user1=new UserImpl(""String_Node_Str"");
  orgService.getUserHandler().createUser(user1,false);
  socialNetworkService.updateOAuthInfo(getFacebookProvider(),user1.getUserName(),""String_Node_Str"",createFacebookAccessToken(""String_Node_Str""));
  assertEquals(""String_Node_Str"",socialNetworkService.getOAuthAccessToken(getFacebookProvider(),user1.getUserName()).getAccessToken());
  socialNetworkService.updateOAuthInfo(getFacebookProvider(),user1.getUserName(),""String_Node_Str"",createFacebookAccessToken(""String_Node_Str""));
  assertEquals(""String_Node_Str"",socialNetworkService.getOAuthAccessToken(getFacebookProvider(),user1.getUserName()).getAccessToken());
  UserProfile userProfile1=orgService.getUserProfileHandler().findUserProfileByName(user1.getUserName());
  userProfile1.setAttribute(getFacebookProvider().getUserNameAttrName(),""String_Node_Str"");
  orgService.getUserProfileHandler().saveUserProfile(userProfile1,true);
  assertNull(socialNetworkService.getOAuthAccessToken(getFacebookProvider(),user1.getUserName()));
  socialNetworkService.updateOAuthAccessToken(getFacebookProvider(),user1.getUserName(),createFacebookAccessToken(""String_Node_Str""));
  assertEquals(""String_Node_Str"",socialNetworkService.getOAuthAccessToken(getFacebookProvider(),user1.getUserName()).getAccessToken());
  userProfile1=orgService.getUserProfileHandler().findUserProfileByName(user1.getUserName());
  userProfile1.setAttribute(getFacebookProvider().getUserNameAttrName(),null);
  orgService.getUserProfileHandler().saveUserProfile(userProfile1,true);
  assertNull(socialNetworkService.getOAuthAccessToken(getFacebookProvider(),user1.getUserName()));
  TwitterAccessTokenContext twitterToken=new TwitterAccessTokenContext(""String_Node_Str"",""String_Node_Str"");
  socialNetworkService.updateOAuthInfo(getTwitterProvider(),user1.getUserName(),""String_Node_Str"",twitterToken);
  userProfile1=orgService.getUserProfileHandler().findUserProfileByName(user1.getUserName());
  userProfile1.setAttribute(getTwitterProvider().getUserNameAttrName(),""String_Node_Str"");
  orgService.getUserProfileHandler().saveUserProfile(userProfile1,true);
  assertNull(socialNetworkService.getOAuthAccessToken(getTwitterProvider(),user1.getUserName()));
  GoogleAccessTokenContext grc=createGoogleAccessToken(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  socialNetworkService.updateOAuthInfo(getGoogleProvider(),user1.getUserName(),""String_Node_Str"",grc);
  userProfile1=orgService.getUserProfileHandler().findUserProfileByName(user1.getUserName());
  userProfile1.setAttribute(getGoogleProvider().getUserNameAttrName(),""String_Node_Str"");
  orgService.getUserProfileHandler().saveUserProfile(userProfile1,true);
  assertNull(socialNetworkService.getOAuthAccessToken(getGoogleProvider(),user1.getUserName()));
}","public void testInvalidationOfAccessTokens() throws Exception {
  User user1=new UserImpl(""String_Node_Str"");
  orgService.getUserHandler().createUser(user1,false);
  socialNetworkService.updateOAuthInfo(getFacebookProvider(),user1.getUserName(),""String_Node_Str"",createFacebookAccessToken(""String_Node_Str""));
  assertEquals(""String_Node_Str"",socialNetworkService.getOAuthAccessToken(getFacebookProvider(),user1.getUserName()).getAccessToken());
  socialNetworkService.updateOAuthInfo(getFacebookProvider(),user1.getUserName(),""String_Node_Str"",createFacebookAccessToken(""String_Node_Str""));
  assertEquals(""String_Node_Str"",socialNetworkService.getOAuthAccessToken(getFacebookProvider(),user1.getUserName()).getAccessToken());
  UserProfile userProfile1=orgService.getUserProfileHandler().findUserProfileByName(user1.getUserName());
  userProfile1.setAttribute(getFacebookProvider().getUserNameAttrName(),""String_Node_Str"");
  orgService.getUserProfileHandler().saveUserProfile(userProfile1,true);
  assertNull(socialNetworkService.getOAuthAccessToken(getFacebookProvider(),user1.getUserName()));
  socialNetworkService.updateOAuthAccessToken(getFacebookProvider(),user1.getUserName(),createFacebookAccessToken(""String_Node_Str""));
  assertEquals(""String_Node_Str"",socialNetworkService.getOAuthAccessToken(getFacebookProvider(),user1.getUserName()).getAccessToken());
  userProfile1=orgService.getUserProfileHandler().findUserProfileByName(user1.getUserName());
  userProfile1.setAttribute(getFacebookProvider().getUserNameAttrName(),null);
  orgService.getUserProfileHandler().saveUserProfile(userProfile1,true);
  assertNull(socialNetworkService.getOAuthAccessToken(getFacebookProvider(),user1.getUserName()));
  TwitterAccessTokenContext twitterToken=new TwitterAccessTokenContext(""String_Node_Str"",""String_Node_Str"");
  socialNetworkService.updateOAuthInfo(getTwitterProvider(),user1.getUserName(),""String_Node_Str"",twitterToken);
  userProfile1=orgService.getUserProfileHandler().findUserProfileByName(user1.getUserName());
  userProfile1.setAttribute(getTwitterProvider().getUserNameAttrName(),""String_Node_Str"");
  orgService.getUserProfileHandler().saveUserProfile(userProfile1,true);
  assertNull(socialNetworkService.getOAuthAccessToken(getTwitterProvider(),user1.getUserName()));
  GoogleAccessTokenContext grc=createGoogleAccessToken(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  socialNetworkService.updateOAuthInfo(getGoogleProvider(),user1.getUserName(),""String_Node_Str"",grc);
  userProfile1=orgService.getUserProfileHandler().findUserProfileByName(user1.getUserName());
  userProfile1.setAttribute(getGoogleProvider().getUserNameAttrName(),""String_Node_Str"");
  orgService.getUserProfileHandler().saveUserProfile(userProfile1,true);
  assertNull(socialNetworkService.getOAuthAccessToken(getGoogleProvider(),user1.getUserName()));
  orgService.getUserHandler().removeUser(user1.getUserName(),false);
}",0.988089073019161
9887,"public void testAccessTokensWithMoreScopes() throws Exception {
  User user1=new UserImpl(""String_Node_Str"");
  orgService.getUserHandler().createUser(user1,false);
  GoogleAccessTokenContext googleToken=createGoogleAccessToken(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  socialNetworkService.updateOAuthAccessToken(getGoogleProvider(),user1.getUserName(),googleToken);
  assertEquals(googleToken,socialNetworkService.getOAuthAccessToken(getGoogleProvider(),user1.getUserName()));
  FacebookAccessTokenContext facebookToken=createFacebookAccessToken(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  socialNetworkService.updateOAuthAccessToken(getFacebookProvider(),user1.getUserName(),facebookToken);
  assertEquals(facebookToken,socialNetworkService.getOAuthAccessToken(getFacebookProvider(),user1.getUserName()));
}","public void testAccessTokensWithMoreScopes() throws Exception {
  User user1=new UserImpl(""String_Node_Str"");
  orgService.getUserHandler().createUser(user1,false);
  GoogleAccessTokenContext googleToken=createGoogleAccessToken(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  socialNetworkService.updateOAuthAccessToken(getGoogleProvider(),user1.getUserName(),googleToken);
  assertEquals(googleToken,socialNetworkService.getOAuthAccessToken(getGoogleProvider(),user1.getUserName()));
  FacebookAccessTokenContext facebookToken=createFacebookAccessToken(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  socialNetworkService.updateOAuthAccessToken(getFacebookProvider(),user1.getUserName(),facebookToken);
  assertEquals(facebookToken,socialNetworkService.getOAuthAccessToken(getFacebookProvider(),user1.getUserName()));
  orgService.getUserHandler().removeUser(user1.getUserName(),false);
}",0.9621087314662272
9888,"public void testPersistOAuthAccessTokens() throws Exception {
  User user1=new UserImpl(""String_Node_Str"");
  User user2=new UserImpl(""String_Node_Str"");
  orgService.getUserHandler().createUser(user1,false);
  orgService.getUserHandler().createUser(user2,false);
  socialNetworkService.updateOAuthAccessToken(getFacebookProvider(),user1.getUserName(),createFacebookAccessToken(""String_Node_Str""));
  socialNetworkService.updateOAuthAccessToken(getFacebookProvider(),user2.getUserName(),createFacebookAccessToken(""String_Node_Str""));
  GoogleAccessTokenContext googleToken=createGoogleAccessToken(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  socialNetworkService.updateOAuthAccessToken(getGoogleProvider(),user1.getUserName(),googleToken);
  TwitterAccessTokenContext twitterToken=new TwitterAccessTokenContext(""String_Node_Str"",""String_Node_Str"");
  socialNetworkService.updateOAuthAccessToken(getTwitterProvider(),user1.getUserName(),twitterToken);
  assertEquals(""String_Node_Str"",socialNetworkService.getOAuthAccessToken(getFacebookProvider(),user1.getUserName()).getAccessToken());
  assertEquals(""String_Node_Str"",socialNetworkService.getOAuthAccessToken(getFacebookProvider(),user2.getUserName()).getAccessToken());
  googleToken=createGoogleAccessToken(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(googleToken,socialNetworkService.getOAuthAccessToken(getGoogleProvider(),user1.getUserName()));
  assertNull(socialNetworkService.getOAuthAccessToken(getGoogleProvider(),user2.getUserName()));
  assertEquals(new TwitterAccessTokenContext(""String_Node_Str"",""String_Node_Str""),socialNetworkService.getOAuthAccessToken(getTwitterProvider(),user1.getUserName()));
  assertNull(socialNetworkService.getOAuthAccessToken(getTwitterProvider(),user2.getUserName()));
  UserProfile userProfile1=orgService.getUserProfileHandler().findUserProfileByName(""String_Node_Str"");
  UserProfile userProfile2=orgService.getUserProfileHandler().findUserProfileByName(""String_Node_Str"");
  String encodedAccessToken1=userProfile1.getAttribute(OAuthConstants.PROFILE_FACEBOOK_ACCESS_TOKEN + ""String_Node_Str"");
  String encodedAccessToken2=userProfile2.getAttribute(OAuthConstants.PROFILE_FACEBOOK_ACCESS_TOKEN + ""String_Node_Str"");
  assertFalse(""String_Node_Str"".equals(encodedAccessToken1));
  assertFalse(""String_Node_Str"".equals(encodedAccessToken2));
  assertTrue(codec.encode(""String_Node_Str"").equals(encodedAccessToken1));
  assertTrue(codec.encode(""String_Node_Str"").equals(encodedAccessToken2));
  socialNetworkService.removeOAuthAccessToken(getFacebookProvider(),user1.getUserName());
  socialNetworkService.removeOAuthAccessToken(getGoogleProvider(),user1.getUserName());
  socialNetworkService.removeOAuthAccessToken(getTwitterProvider(),user1.getUserName());
  assertNull(socialNetworkService.getOAuthAccessToken(getFacebookProvider(),user1.getUserName()));
  assertNull(socialNetworkService.getOAuthAccessToken(getGoogleProvider(),user1.getUserName()));
  assertNull(socialNetworkService.getOAuthAccessToken(getTwitterProvider(),user1.getUserName()));
  assertNotNull(socialNetworkService.getOAuthAccessToken(getFacebookProvider(),user2.getUserName()));
}","public void testPersistOAuthAccessTokens() throws Exception {
  User user1=new UserImpl(""String_Node_Str"");
  User user2=new UserImpl(""String_Node_Str"");
  orgService.getUserHandler().createUser(user1,false);
  orgService.getUserHandler().createUser(user2,false);
  socialNetworkService.updateOAuthAccessToken(getFacebookProvider(),user1.getUserName(),createFacebookAccessToken(""String_Node_Str""));
  socialNetworkService.updateOAuthAccessToken(getFacebookProvider(),user2.getUserName(),createFacebookAccessToken(""String_Node_Str""));
  GoogleAccessTokenContext googleToken=createGoogleAccessToken(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  socialNetworkService.updateOAuthAccessToken(getGoogleProvider(),user1.getUserName(),googleToken);
  TwitterAccessTokenContext twitterToken=new TwitterAccessTokenContext(""String_Node_Str"",""String_Node_Str"");
  socialNetworkService.updateOAuthAccessToken(getTwitterProvider(),user1.getUserName(),twitterToken);
  assertEquals(""String_Node_Str"",socialNetworkService.getOAuthAccessToken(getFacebookProvider(),user1.getUserName()).getAccessToken());
  assertEquals(""String_Node_Str"",socialNetworkService.getOAuthAccessToken(getFacebookProvider(),user2.getUserName()).getAccessToken());
  googleToken=createGoogleAccessToken(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(googleToken,socialNetworkService.getOAuthAccessToken(getGoogleProvider(),user1.getUserName()));
  assertNull(socialNetworkService.getOAuthAccessToken(getGoogleProvider(),user2.getUserName()));
  assertEquals(new TwitterAccessTokenContext(""String_Node_Str"",""String_Node_Str""),socialNetworkService.getOAuthAccessToken(getTwitterProvider(),user1.getUserName()));
  assertNull(socialNetworkService.getOAuthAccessToken(getTwitterProvider(),user2.getUserName()));
  UserProfile userProfile1=orgService.getUserProfileHandler().findUserProfileByName(""String_Node_Str"");
  UserProfile userProfile2=orgService.getUserProfileHandler().findUserProfileByName(""String_Node_Str"");
  String encodedAccessToken1=userProfile1.getAttribute(OAuthConstants.PROFILE_FACEBOOK_ACCESS_TOKEN + ""String_Node_Str"");
  String encodedAccessToken2=userProfile2.getAttribute(OAuthConstants.PROFILE_FACEBOOK_ACCESS_TOKEN + ""String_Node_Str"");
  assertFalse(""String_Node_Str"".equals(encodedAccessToken1));
  assertFalse(""String_Node_Str"".equals(encodedAccessToken2));
  assertTrue(codec.encode(""String_Node_Str"").equals(encodedAccessToken1));
  assertTrue(codec.encode(""String_Node_Str"").equals(encodedAccessToken2));
  socialNetworkService.removeOAuthAccessToken(getFacebookProvider(),user1.getUserName());
  socialNetworkService.removeOAuthAccessToken(getGoogleProvider(),user1.getUserName());
  socialNetworkService.removeOAuthAccessToken(getTwitterProvider(),user1.getUserName());
  assertNull(socialNetworkService.getOAuthAccessToken(getFacebookProvider(),user1.getUserName()));
  assertNull(socialNetworkService.getOAuthAccessToken(getGoogleProvider(),user1.getUserName()));
  assertNull(socialNetworkService.getOAuthAccessToken(getTwitterProvider(),user1.getUserName()));
  assertNotNull(socialNetworkService.getOAuthAccessToken(getFacebookProvider(),user2.getUserName()));
  orgService.getUserHandler().removeUser(user1.getUserName(),false);
  orgService.getUserHandler().removeUser(user2.getUserName(),false);
}",0.978847332924586
9889,"public void savePage(UIEditInlineWorkspace editInlineWS,Event<?> event) throws Exception {
  UIWorkingWorkspace uiWorkingWS=editInlineWS.getParent();
  UIPortalToolPanel uiToolPanel=uiWorkingWS.findFirstComponentOfType(UIPortalToolPanel.class);
  UIPortalComposer composer=uiWorkingWS.findFirstComponentOfType(UIPortalComposer.class);
  UIPortalApplication uiPortalApp=Util.getUIPortalApplication();
  UIPortal uiPortal=uiPortalApp.getCurrentSite();
  DataStorage dataService=uiWorkingWS.getApplicationComponent(DataStorage.class);
  PageService pageService=uiWorkingWS.getApplicationComponent(PageService.class);
  UIPage uiPage=uiToolPanel.findFirstComponentOfType(UIPage.class);
  Page page=(Page)PortalDataMapper.buildModelObject(uiPage);
  String pageId=page.getPageId();
  PageKey pageKey=PageKey.parse(pageId);
  PageState pageState=PageUtils.toPageState(page);
  PageContext pageContext=new PageContext(pageKey,pageState);
  pageService.savePage(pageContext);
  dataService.save(page);
  composer.setEditted(false);
  uiToolPanel.setUIComponent(null);
  uiPortalApp.refreshCachedUI();
  if (PortalProperties.SESSION_ALWAYS.equals(uiPortal.getSessionAlive())) {
    uiPortalApp.setSessionOpen(true);
  }
 else {
    uiPortalApp.setSessionOpen(false);
  }
  uiPortalApp.setModeState(UIPortalApplication.NORMAL_MODE);
  uiWorkingWS.setRenderedChild(UIPortalApplication.UI_VIEWING_WS_ID);
  Util.getPortalRequestContext().ignoreAJAXUpdateOnPortlets(true);
  UserNode currentNode=uiPortal.getSelectedUserNode();
  PageNodeEvent<UIPortalApplication> pnevent=new PageNodeEvent<UIPortalApplication>(uiPortalApp,PageNodeEvent.CHANGE_NODE,currentNode.getNavigation().getKey(),currentNode.getURI());
  uiPortalApp.broadcast(pnevent,Event.Phase.PROCESS);
  Util.updatePortalMode();
}","public void savePage(UIEditInlineWorkspace editInlineWS,Event<?> event) throws Exception {
  UIWorkingWorkspace uiWorkingWS=editInlineWS.getParent();
  UIPortalToolPanel uiToolPanel=uiWorkingWS.findFirstComponentOfType(UIPortalToolPanel.class);
  UIPortalComposer composer=uiWorkingWS.findFirstComponentOfType(UIPortalComposer.class);
  UIPortalApplication uiPortalApp=Util.getUIPortalApplication();
  UIPortal uiPortal=uiPortalApp.getCurrentSite();
  DataStorage dataService=uiWorkingWS.getApplicationComponent(DataStorage.class);
  PageService pageService=uiWorkingWS.getApplicationComponent(PageService.class);
  UIPage uiPage;
  if (!UIPage.isFullPreview()) {
    uiPage=uiToolPanel.findFirstComponentOfType(UIPage.class);
  }
 else {
    uiPage=uiWorkingWS.findFirstComponentOfType(UIPage.class);
  }
  Page page=(Page)PortalDataMapper.buildModelObject(uiPage);
  String pageId=page.getPageId();
  PageKey pageKey=PageKey.parse(pageId);
  PageState pageState=PageUtils.toPageState(page);
  PageContext pageContext=new PageContext(pageKey,pageState);
  pageService.savePage(pageContext);
  dataService.save(page);
  composer.setEditted(false);
  uiToolPanel.setUIComponent(null);
  uiPortalApp.refreshCachedUI();
  if (PortalProperties.SESSION_ALWAYS.equals(uiPortal.getSessionAlive())) {
    uiPortalApp.setSessionOpen(true);
  }
 else {
    uiPortalApp.setSessionOpen(false);
  }
  uiPortalApp.setModeState(UIPortalApplication.NORMAL_MODE);
  uiWorkingWS.setRenderedChild(UIPortalApplication.UI_VIEWING_WS_ID);
  Util.getPortalRequestContext().ignoreAJAXUpdateOnPortlets(true);
  UserNode currentNode=uiPortal.getSelectedUserNode();
  PageNodeEvent<UIPortalApplication> pnevent=new PageNodeEvent<UIPortalApplication>(uiPortalApp,PageNodeEvent.CHANGE_NODE,currentNode.getNavigation().getKey(),currentNode.getURI());
  uiPortalApp.broadcast(pnevent,Event.Phase.PROCESS);
  Util.updatePortalMode();
}",0.9663226507332972
9890,"public void doFilter(ServletRequest request,ServletResponse response,FilterChain chain) throws ServletException {
  ConversationState state=ConversationState.getCurrent();
  try {
    if (state != null && !state.getIdentity().getUserId().equals(IdentityConstants.ANONIM)) {
      if (log.isDebugEnabled())       log.debug(""String_Node_Str"");
      if (state.getAttribute(USER_PROFILE) == null) {
        OrganizationService orgService=(OrganizationService)getContainer().getComponentInstanceOfType(OrganizationService.class);
        begin(orgService);
        User user=orgService.getUserHandler().findUserByName(state.getIdentity().getUserId(),UserStatus.DISABLED);
        end(orgService);
        state.setAttribute(USER_PROFILE,user);
      }
    }
    chain.doFilter(request,response);
  }
 catch (  Exception e) {
    log.warn(""String_Node_Str"",e);
  }
}","public void doFilter(ServletRequest request,ServletResponse response,FilterChain chain) throws ServletException {
  ConversationState state=ConversationState.getCurrent();
  try {
    if (state != null && !state.getIdentity().getUserId().equals(IdentityConstants.ANONIM)) {
      if (log.isDebugEnabled())       log.debug(""String_Node_Str"");
      if (state.getAttribute(USER_PROFILE) == null) {
        OrganizationService orgService=(OrganizationService)getContainer().getComponentInstanceOfType(OrganizationService.class);
        begin(orgService);
        User user=orgService.getUserHandler().findUserByName(state.getIdentity().getUserId(),UserStatus.BOTH);
        end(orgService);
        state.setAttribute(USER_PROFILE,user);
      }
    }
    chain.doFilter(request,response);
  }
 catch (  Exception e) {
    log.warn(""String_Node_Str"",e);
  }
}",0.9941792782305006
9891,"@Override public boolean login() throws LoginException {
  log.debug(""String_Node_Str"");
  try {
    Callback[] callbacks=new Callback[]{new NameCallback(""String_Node_Str"")};
    callbackHandler.handle(callbacks);
    String username=((NameCallback)callbacks[0]).getName();
    if (username != null) {
      OrganizationService service=(OrganizationService)getContainer().getComponentInstanceOfType(OrganizationService.class);
      UserHandler uHandler=service.getUserHandler();
      User user=uHandler.findUserByName(username,UserStatus.DISABLED);
      if (user == null) {
        log.debug(""String_Node_Str"",username);
      }
 else       if (user instanceof UserImpl && !((UserImpl)user).isEnabled()) {
        HttpServletRequest request=getCurrentHttpServletRequest();
        if (request != null) {
          request.setAttribute(DISABLED_USER_NAME,username);
        }
        throw new LoginException(""String_Node_Str"" + username + ""String_Node_Str"");
      }
    }
 else {
      log.debug(""String_Node_Str"");
    }
    return true;
  }
 catch (  final Exception e) {
    log.warn(e.getMessage());
    throw new LoginException(e.getMessage());
  }
}","@Override public boolean login() throws LoginException {
  log.debug(""String_Node_Str"");
  try {
    Callback[] callbacks=new Callback[]{new NameCallback(""String_Node_Str"")};
    callbackHandler.handle(callbacks);
    String username=((NameCallback)callbacks[0]).getName();
    if (username != null) {
      OrganizationService service=(OrganizationService)getContainer().getComponentInstanceOfType(OrganizationService.class);
      UserHandler uHandler=service.getUserHandler();
      User user=uHandler.findUserByName(username,UserStatus.BOTH);
      if (user == null) {
        log.debug(""String_Node_Str"",username);
      }
 else       if (user instanceof UserImpl && !((UserImpl)user).isEnabled()) {
        HttpServletRequest request=getCurrentHttpServletRequest();
        if (request != null) {
          request.setAttribute(DISABLED_USER_NAME,username);
        }
        throw new LoginException(""String_Node_Str"" + username + ""String_Node_Str"");
      }
    }
 else {
      log.debug(""String_Node_Str"");
    }
    return true;
  }
 catch (  final Exception e) {
    log.warn(e.getMessage());
    throw new LoginException(e.getMessage());
  }
}",0.7441659464131374
9892,"public void setSharedLayout(String type){
  setProperty(PortalProperties.SHARED_LAYOUT,PortalProperties.SHARED_LAYOUT_ALL);
}","public void setSharedLayout(String type){
  if (type.equals(PortalProperties.SHARED_LAYOUT_ADMINS)) {
    setProperty(PortalProperties.SHARED_LAYOUT,PortalProperties.SHARED_LAYOUT_ADMINS);
  }
 else {
    setProperty(PortalProperties.SHARED_LAYOUT,PortalProperties.SHARED_LAYOUT_ALL);
  }
}",0.5927710843373494
9893,"public void setSharedLayout(String type){
  setProperty(PortalProperties.SHARED_LAYOUT,type);
}","public void setSharedLayout(String type){
  if (type.equals(PortalProperties.SHARED_LAYOUT_ADMINS)) {
    setProperty(PortalProperties.SHARED_LAYOUT,PortalProperties.SHARED_LAYOUT_ADMINS);
  }
 else {
    setProperty(PortalProperties.SHARED_LAYOUT,PortalProperties.SHARED_LAYOUT_ALL);
  }
}",0.4727272727272727
9894,"private void handleErrorResponse(ErrorResponse response) throws Exception {
  throw (Exception)response.getCause();
}","private void handleErrorResponse(ErrorResponse response) throws Exception {
  throw new Exception(response.getCause());
}",0.9663865546218487
9895,"public UIComponent setId(String id){
  if (id == null) {
    this.id=Integer.toString(hashCode());
  }
 else {
    this.id=id;
  }
  return this;
}","public UIComponent setId(String id){
  if (id == null) {
    this.id=Integer.toString(Math.abs(hashCode()));
  }
 else {
    this.id=id;
  }
  return this;
}",0.9671052631578948
9896,"private static void insertColumn(UIColumnContainer selectedColumn,boolean isInsertAfter) throws Exception {
  UIContainer uiParent=selectedColumn.getParent();
  UIColumnContainer uiNewColumn=uiParent.addChild(UIColumnContainer.class,null,null);
  uiNewColumn.setTemplate(selectedColumn.getTemplate());
  uiNewColumn.setFactoryId(selectedColumn.getFactoryId());
  uiNewColumn.setId(String.valueOf(uiNewColumn.hashCode()));
  List<UIComponent> listColumn=uiParent.getChildren();
  int position=listColumn.indexOf(selectedColumn);
  if (isInsertAfter) {
    position+=1;
  }
  Collections.rotate(listColumn.subList(position,listColumn.size()),1);
}","private static void insertColumn(UIColumnContainer selectedColumn,boolean isInsertAfter) throws Exception {
  UIContainer uiParent=selectedColumn.getParent();
  UIColumnContainer uiNewColumn=uiParent.addChild(UIColumnContainer.class,null,null);
  uiNewColumn.setTemplate(selectedColumn.getTemplate());
  uiNewColumn.setFactoryId(selectedColumn.getFactoryId());
  uiNewColumn.setId(String.valueOf(Math.abs(uiNewColumn.hashCode())));
  List<UIComponent> listColumn=uiParent.getChildren();
  int position=listColumn.indexOf(selectedColumn);
  if (isInsertAfter) {
    position+=1;
  }
  Collections.rotate(listColumn.subList(position,listColumn.size()),1);
}",0.9923076923076924
9897,"@Override public void execute(Event<UITabContainer> event) throws Exception {
  UITabContainer container=event.getSource();
  PortalRequestContext pcontext=(PortalRequestContext)event.getRequestContext();
  if (container == null) {
    return;
  }
  List<UIComponent> children=container.getChildren();
  for (  UIComponent child : children) {
    if (child.isRendered() && child instanceof UIContainer) {
      UIContainer newTabContainer=container.addChild(UIContainer.class,null,null);
      newTabContainer.setTemplate(child.getTemplate());
      child.setRendered(false);
      newTabContainer.setRendered(true);
      newTabContainer.setId(String.valueOf(newTabContainer.hashCode()));
      pcontext.addUIComponentToUpdateByAjax(container);
      pcontext.ignoreAJAXUpdateOnPortlets(true);
      pcontext.getJavascriptManager().require(""String_Node_Str"",""String_Node_Str"").addScripts(""String_Node_Str"");
      return;
    }
  }
}","@Override public void execute(Event<UITabContainer> event) throws Exception {
  UITabContainer container=event.getSource();
  PortalRequestContext pcontext=(PortalRequestContext)event.getRequestContext();
  if (container == null) {
    return;
  }
  List<UIComponent> children=container.getChildren();
  for (  UIComponent child : children) {
    if (child.isRendered() && child instanceof UIContainer) {
      UIContainer newTabContainer=container.addChild(UIContainer.class,null,null);
      newTabContainer.setTemplate(child.getTemplate());
      child.setRendered(false);
      newTabContainer.setRendered(true);
      newTabContainer.setId(String.valueOf(Math.abs(newTabContainer.hashCode())));
      pcontext.addUIComponentToUpdateByAjax(container);
      pcontext.ignoreAJAXUpdateOnPortlets(true);
      pcontext.getJavascriptManager().require(""String_Node_Str"",""String_Node_Str"").addScripts(""String_Node_Str"");
      return;
    }
  }
}",0.9946751863684772
9898,"public void setProperty(String name,String value){
  if (name == null || properties == null)   throw new NullPointerException();
  if (value == null)   properties.remove(name);
 else   properties.setProperty(name,value);
}","public void setProperty(String name,String value){
  if (name == null || properties == null)   throw new NullPointerException();
  properties.setProperty(name,value);
}",0.8615384615384616
9899,"public void setProperty(String name,String value){
  if (name == null || properties == null)   throw new NullPointerException();
  if (value == null)   properties.remove(name);
 else   properties.setProperty(name,value);
}","public void setProperty(String name,String value){
  if (name == null || properties == null)   throw new NullPointerException();
  properties.setProperty(name,value);
}",0.8615384615384616
9900,"public void removeProperty(String name){
  if (name == null || properties == null)   throw new NullPointerException();
  properties.remove(name);
}","public void removeProperty(String name){
  if (name == null)   throw new NullPointerException();
  properties.setProperty(name,null);
}",0.8581560283687943
9901,"public ArrayList<PortalRedirect> getPortalRedirects(){
  return portalRedirects;
}","public ArrayList<PortalRedirect> getPortalRedirects(){
  if (portalRedirects == null) {
    portalRedirects=new ArrayList<PortalRedirect>();
  }
  return portalRedirects;
}",0.6456692913385826
9902,"@Override public String getRedirectPath(String origin,String redirect,String originRequestPath){
  try {
    if (mapper != null) {
      if (originRequestPath == null || originRequestPath.isEmpty()) {
        originRequestPath=""String_Node_Str"";
      }
      PortalConfig pConfig=dataStorage.getPortalConfig(origin);
      if (pConfig == null) {
        log.warn(""String_Node_Str"" + origin + ""String_Node_Str"");
        return null;
      }
      PortalRedirect pRedirect=null;
      for (      PortalRedirect portalRedirect : pConfig.getPortalRedirects()) {
        if (portalRedirect.getRedirectSite().equals(redirect)) {
          pRedirect=portalRedirect;
          break;
        }
      }
      if (pRedirect != null) {
        String redirectPath=mapper.getRedirectPath(origin,redirect,originRequestPath,pRedirect.getMappings());
        if (redirectPath != null && redirectPath.equals(""String_Node_Str"")) {
          return ""String_Node_Str"";
        }
 else {
          return redirectPath;
        }
      }
 else {
        log.debug(""String_Node_Str"" + origin + ""String_Node_Str""+ redirect+ ""String_Node_Str"");
        return null;
      }
    }
 else {
      log.debug(""String_Node_Str"");
      return null;
    }
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    return null;
  }
}","@Override public String getRedirectPath(String origin,String redirect,String originRequestPath){
  try {
    if (mapper != null) {
      if (originRequestPath == null || originRequestPath.isEmpty()) {
        originRequestPath=""String_Node_Str"";
      }
      PortalConfig pConfig=dataStorage.getPortalConfig(origin);
      if (pConfig == null || pConfig.getPortalRedirects() == null) {
        log.warn(""String_Node_Str"" + origin + ""String_Node_Str"");
        return null;
      }
      PortalRedirect pRedirect=null;
      for (      PortalRedirect portalRedirect : pConfig.getPortalRedirects()) {
        if (portalRedirect.getRedirectSite().equals(redirect)) {
          pRedirect=portalRedirect;
          break;
        }
      }
      if (pRedirect != null) {
        String redirectPath=mapper.getRedirectPath(origin,redirect,originRequestPath,pRedirect.getMappings());
        if (redirectPath != null && redirectPath.equals(""String_Node_Str"")) {
          return ""String_Node_Str"";
        }
 else {
          return redirectPath;
        }
      }
 else {
        log.debug(""String_Node_Str"" + origin + ""String_Node_Str""+ redirect+ ""String_Node_Str"");
        return null;
      }
    }
 else {
      log.debug(""String_Node_Str"");
      return null;
    }
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    return null;
  }
}",0.985007496251874
9903,"/** 
 * Create and configure cacheManager, which will be used to create infinispan caches.
 * @param configStream stream with infinispan configuration
 * @return cacheManager
 * @throws Exception
 */
private static EmbeddedCacheManager getSharedCacheManager(InputStream configStream) throws Exception {
  if (cacheManager == null) {
    EmbeddedCacheManager cacheManager=new DefaultCacheManager(configStream,false);
    GlobalConfiguration globalConfigFromXml=cacheManager.getCacheManagerConfiguration();
    ConfigurationBuilderHolder builderHolder=new ConfigurationBuilderHolder();
    builderHolder.getGlobalConfigurationBuilder().read(globalConfigFromXml);
    Configuration configFromXml=cacheManager.getDefaultCacheConfiguration();
    ConfigurationBuilder configBuilder=builderHolder.getDefaultConfigurationBuilder().read(configFromXml);
    TransactionManagerLookup tmLookup=configFromXml.transaction().transactionManagerLookup();
    if (tmLookup == null) {
      tmLookup=getTransactionManagerLookup();
      configBuilder.transaction().transactionManagerLookup(tmLookup);
    }
    log.debug(""String_Node_Str"" + tmLookup);
    cacheManager=new DefaultCacheManager(builderHolder,true);
    PicketLinkIDMServiceImpl.cacheManager=cacheManager;
  }
  return cacheManager;
}","/** 
 * Create and configure cacheManager, which will be used to create infinispan caches.
 * @param configStream stream with infinispan configuration
 * @return cacheManager
 * @throws Exception
 */
private static EmbeddedCacheManager getSharedCacheManager(InputStream configStream) throws Exception {
  if (cacheManager == null) {
    EmbeddedCacheManager cacheManager=new DefaultCacheManager(configStream,false);
    GlobalConfiguration globalConfigFromXml=cacheManager.getCacheManagerConfiguration();
    GlobalConfigurationBuilder globalConfigBuilder=new GlobalConfigurationBuilder();
    globalConfigBuilder.read(globalConfigFromXml);
    Configuration configFromXml=cacheManager.getDefaultCacheConfiguration();
    ConfigurationBuilder configBuilder=new ConfigurationBuilder().read(configFromXml);
    TransactionManagerLookup tmLookup=configFromXml.transaction().transactionManagerLookup();
    if (tmLookup == null) {
      tmLookup=getTransactionManagerLookup();
      configBuilder.transaction().transactionManagerLookup(tmLookup);
    }
    log.debug(""String_Node_Str"" + tmLookup);
    cacheManager=new DefaultCacheManager(globalConfigBuilder.build(),configBuilder.build(),true);
    PicketLinkIDMServiceImpl.cacheManager=cacheManager;
  }
  return cacheManager;
}",0.8278560250391236
9904,"public WSRPSessionLifeCycle(){
  try {
    ExoContainer container=ExoContainerContext.getCurrentContainer();
    RepositoryService repoService=(RepositoryService)container.getComponentInstanceOfType(RepositoryService.class);
    repository=repoService.getRepository(REPOSITORY_NAME);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  provider=SessionProvider.createSystemProvider();
}","public WSRPSessionLifeCycle(){
  try {
    ExoContainer container=ExoContainerContext.getCurrentContainer();
    RepositoryService repoService=(RepositoryService)container.getComponentInstanceOfType(RepositoryService.class);
    repository=repoService.getRepository(REPOSITORY_NAME);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.9326287978863936
9905,"public boolean isExpired(){
  return false;
}","public boolean isExpired(){
  return System.currentTimeMillis() > getExpirationTimeMillis();
}",0.6187050359712231
9906,"public GadgetToken saveToken(BasicOAuthStoreTokenIndex tokenKey,TokenInfo tokenInfo){
  Map<String,GadgetTokenEntry> tokens=getGadgetTokens();
  GadgetTokenEntry entry=null;
  for (  GadgetTokenEntry item : tokens.values()) {
    BasicOAuthStoreTokenIndex key=item.getKey();
    if (tokenKey.equals(key)) {
      entry=item;
    }
  }
  if (entry == null) {
    entry=createGadgetToken();
    tokens.put(""String_Node_Str"" + System.currentTimeMillis(),entry);
  }
  entry.setGadgetUri(tokenKey.getGadgetUri());
  entry.setModuleId(tokenKey.getModuleId());
  entry.setServiceName(tokenKey.getServiceName());
  entry.setTokenName(tokenKey.getTokenName());
  entry.setUserId(tokenKey.getUserId());
  entry.setAccessToken(tokenInfo.getAccessToken());
  entry.setTokenSecret(tokenInfo.getTokenSecret());
  entry.setSessionHandle(tokenInfo.getSessionHandle() == null ? ""String_Node_Str"" : tokenInfo.getSessionHandle());
  entry.setTokenExpireMillis(tokenInfo.getTokenExpireMillis());
  return entry.getToken();
}","public GadgetToken saveToken(BasicOAuthStoreTokenIndex tokenKey,TokenInfo tokenInfo,long expirationTime){
  Map<String,GadgetTokenEntry> tokens=getGadgetTokens();
  GadgetTokenEntry entry=null;
  for (  GadgetTokenEntry item : tokens.values()) {
    BasicOAuthStoreTokenIndex key=item.getKey();
    if (tokenKey.equals(key)) {
      entry=item;
    }
  }
  if (entry == null) {
    entry=createGadgetToken();
    tokens.put(""String_Node_Str"" + System.currentTimeMillis(),entry);
  }
  entry.setGadgetUri(tokenKey.getGadgetUri());
  entry.setModuleId(tokenKey.getModuleId());
  entry.setServiceName(tokenKey.getServiceName());
  entry.setTokenName(tokenKey.getTokenName());
  entry.setUserId(tokenKey.getUserId());
  entry.setAccessToken(tokenInfo.getAccessToken());
  entry.setTokenSecret(tokenInfo.getTokenSecret());
  entry.setSessionHandle(tokenInfo.getSessionHandle() == null ? ""String_Node_Str"" : tokenInfo.getSessionHandle());
  entry.setTokenExpireMillis(expirationTime);
  return entry.getToken();
}",0.9711729622266402
9907,"public GadgetToken removeToken(BasicOAuthStoreTokenIndex tokenKey){
  Map<String,GadgetTokenEntry> tokens=getGadgetTokens();
  for (  GadgetTokenEntry tokenEntry : tokens.values()) {
    BasicOAuthStoreTokenIndex key=tokenEntry.getKey();
    if (tokenKey.equals(key)) {
      tokenEntry.remove();
      return tokenEntry.getToken();
    }
  }
  return null;
}","public GadgetToken removeToken(BasicOAuthStoreTokenIndex tokenKey){
  Map<String,GadgetTokenEntry> tokens=getGadgetTokens();
  for (  GadgetTokenEntry tokenEntry : tokens.values()) {
    BasicOAuthStoreTokenIndex key=tokenEntry.getKey();
    if (tokenKey.equals(key)) {
      GadgetToken token=tokenEntry.getToken();
      tokenEntry.remove();
      return token;
    }
  }
  return null;
}",0.9158878504672896
9908,"public GadgetToken getToken(){
  return new GadgetToken(getAccessToken(),getTokenSecret(),getServiceName(),getTokenExpireMillis());
}","public GadgetToken getToken(){
  return new GadgetToken(getAccessToken(),getTokenSecret(),getSessionHandle(),getTokenExpireMillis());
}",0.9477611940298508
9909,"@Override public BasicOAuthStoreTokenIndex[] getAllTokens(){
  return new TokenTask<BasicOAuthStoreTokenIndex[]>(){
    @Override protected BasicOAuthStoreTokenIndex[] execute(){
      GadgetTokenContainer container=getGadgetTokenContainer();
      Collection<GadgetTokenEntry> tokens=container.getGadgetTokens().values();
      BasicOAuthStoreTokenIndex[] gadgetTokens=new BasicOAuthStoreTokenIndex[9];
      int count=0;
      for (      GadgetTokenEntry tokenEntry : tokens) {
        gadgetTokens[count++]=tokenEntry.getKey();
      }
      return gadgetTokens;
    }
  }
.executeWith(chromatticLifeCycle);
}","@Override public BasicOAuthStoreTokenIndex[] getAllTokens(){
  return new TokenTask<BasicOAuthStoreTokenIndex[]>(){
    @Override protected BasicOAuthStoreTokenIndex[] execute(){
      GadgetTokenContainer container=getGadgetTokenContainer();
      Collection<GadgetTokenEntry> tokenEntries=container.getGadgetTokens().values();
      List<BasicOAuthStoreTokenIndex> tokenHolder=new ArrayList<BasicOAuthStoreTokenIndex>();
      for (      GadgetTokenEntry tokenEntry : tokenEntries) {
        tokenHolder.add(tokenEntry.getKey());
      }
      return tokenHolder.toArray(new BasicOAuthStoreTokenIndex[tokenHolder.size()]);
    }
  }
.executeWith(chromatticLifeCycle);
}",0.568978955572876
9910,"public Reader getScript(ResourceId resourceId,Locale locale){
  ScriptResource resource=getResource(resourceId);
  if (resource != null) {
    List<Module> modules=new ArrayList<Module>(resource.getModules());
    Collections.sort(modules,MODULE_COMPARATOR);
    ArrayList<Reader> readers=new ArrayList<Reader>(modules.size() * 2);
    boolean isModule=FetchMode.ON_LOAD.equals(resource.getFetchMode());
    if (isModule) {
      StringBuilder strBuild=new StringBuilder();
      strBuild.append(""String_Node_Str"");
      strBuild.append(resourceId.getScope()).append(""String_Node_Str"").append(resourceId.getName());
      strBuild.append(""String_Node_Str"");
      for (      ResourceId dependId : resource.getDependencies()) {
        strBuild.append(""String_Node_Str"");
        strBuild.append(dependId.getScope()).append(""String_Node_Str"").append(dependId.getName());
        strBuild.append(""String_Node_Str"");
      }
      strBuild.append(""String_Node_Str"");
      readers.add(new StringReader(strBuild.toString()));
    }
    for (    Module js : modules) {
      if (!js.isRemote()) {
        Reader jScript=getJavascript(resource,js.getName(),locale);
        if (jScript != null) {
          readers.add(new StringReader(""String_Node_Str"" + js.getName() + ""String_Node_Str""));
          readers.add(jScript);
          readers.add(new StringReader(""String_Node_Str"" + js.getName() + ""String_Node_Str""));
        }
      }
    }
    if (isModule) {
      readers.add(new StringReader(""String_Node_Str""));
    }
    return new CompositeReader(readers);
  }
  return null;
}","public Reader getScript(ResourceId resourceId,Locale locale){
  ScriptResource resource=getResource(resourceId);
  if (resource != null) {
    List<Module> modules=new ArrayList<Module>(resource.getModules());
    Collections.sort(modules,MODULE_COMPARATOR);
    ArrayList<Reader> readers=new ArrayList<Reader>(modules.size() * 2);
    boolean isModule=FetchMode.ON_LOAD.equals(resource.getFetchMode());
    if (isModule) {
      StringBuilder strBuild=new StringBuilder();
      strBuild.append(""String_Node_Str"");
      strBuild.append(resourceId.getScope()).append(""String_Node_Str"").append(resourceId.getName());
      strBuild.append(""String_Node_Str"");
      for (      ResourceId dependId : resource.getDependencies()) {
        strBuild.append(""String_Node_Str"");
        strBuild.append(dependId.getScope()).append(""String_Node_Str"").append(dependId.getName());
        strBuild.append(""String_Node_Str"");
      }
      if (resource.getDependencies().size() > 0) {
        strBuild.deleteCharAt(strBuild.length() - 1);
      }
      strBuild.append(""String_Node_Str"");
      readers.add(new StringReader(strBuild.toString()));
    }
    for (    Module js : modules) {
      if (!js.isRemote()) {
        Reader jScript=getJavascript(resource,js.getName(),locale);
        if (jScript != null) {
          readers.add(new StringReader(""String_Node_Str"" + js.getName() + ""String_Node_Str""));
          readers.add(jScript);
          readers.add(new StringReader(""String_Node_Str"" + js.getName() + ""String_Node_Str""));
        }
      }
    }
    if (isModule) {
      readers.add(new StringReader(""String_Node_Str""));
    }
    return new CompositeReader(readers);
  }
  return null;
}",0.9654961832061068
9911,"public UIFormInputIconSelector(String name,String bindingField) throws Exception {
  super(name,bindingField,String.class);
  setComponentConfig(UIFormInputIconSelector.class,null);
  addChild(UIDropDownControl.class,null,null);
  this.setValues(paramDefault);
  selectType=""String_Node_Str"";
}","public UIFormInputIconSelector(String name,String bindingField) throws Exception {
  super(name,bindingField,String.class);
  setComponentConfig(UIFormInputIconSelector.class,null);
  addChild(UIDropDownControl.class,""String_Node_Str"",null);
  this.setValues(paramDefault);
  selectType=""String_Node_Str"";
}",0.9650582362728786
9912,"public void execute(Event<UIFormInputIconSelector> event) throws Exception {
  UIFormInputIconSelector uiIconSelector=event.getSource();
  String iconName=event.getRequestContext().getRequestParameter(OBJECTID);
  if (iconName.equals(""String_Node_Str"")) {
    uiIconSelector.setSelectedIcon(""String_Node_Str"");
    for (    IconSet set : uiIconSelector.getListIconSet()) {
      if (set.getName().equals(""String_Node_Str"")) {
        uiIconSelector.setSelectedIconSet(set);
      }
    }
    UIForm uiForm=uiIconSelector.getAncestorOfType(UIForm.class);
    event.getRequestContext().addUIComponentToUpdateByAjax(uiForm);
    return;
  }
  uiIconSelector.setSelectedIcon(iconName);
  UIForm uiForm=uiIconSelector.getAncestorOfType(UIForm.class);
  event.getRequestContext().addUIComponentToUpdateByAjax(uiForm);
}","public void execute(Event<UIDropDownControl> event) throws Exception {
  UIDropDownControl uiDropDown=event.getSource();
  event.getRequestContext().addUIComponentToUpdateByAjax(uiDropDown);
}",0.3164179104477612
9913,"private void parseDesc(Element element,ScriptResourceDescriptor desc){
  for (  Element localeElt : XMLTools.getChildren(element,""String_Node_Str"")) {
    String localeValue=XMLTools.asString(localeElt);
    Locale locale=I18N.parseTagIdentifier(localeValue);
    desc.supportedLocales.add(locale);
  }
  for (  Element moduleElt : XMLTools.getChildren(element,""String_Node_Str"")) {
    String moduleName=XMLTools.asString(XMLTools.getUniqueChild(moduleElt,""String_Node_Str"",true));
    Javascript script;
    String modulePath=XMLTools.asString(XMLTools.getUniqueChild(moduleElt,""String_Node_Str"",false));
    if (modulePath != null) {
      String resourceBundle=null;
      Element bundleElt=XMLTools.getUniqueChild(moduleElt,""String_Node_Str"",false);
      if (bundleElt != null) {
        resourceBundle=XMLTools.asString(bundleElt);
      }
      script=new Javascript.Local(desc.id,moduleName,contextPath,modulePath,resourceBundle,0);
    }
 else {
      String moduleURI=XMLTools.asString(XMLTools.getUniqueChild(moduleElt,""String_Node_Str"",true));
      script=new Javascript.Remote(desc.id,moduleName,contextPath,moduleURI,0);
    }
    desc.modules.add(script);
  }
  for (  Element moduleElt : XMLTools.getChildren(element,""String_Node_Str"")) {
    String dependencyName=XMLTools.asString(XMLTools.getUniqueChild(moduleElt,""String_Node_Str"",true));
    ResourceId resourceId=new ResourceId(ResourceScope.SHARED,dependencyName);
    DependencyDescriptor dependency=new DependencyDescriptor(resourceId);
    desc.dependencies.add(dependency);
  }
}","private void parseDesc(Element element,ScriptResourceDescriptor desc){
  for (  Element localeElt : XMLTools.getChildren(element,""String_Node_Str"")) {
    String localeValue=XMLTools.asString(localeElt);
    Locale locale=I18N.parseTagIdentifier(localeValue);
    desc.supportedLocales.add(locale);
  }
  for (  Element moduleElt : XMLTools.getChildren(element,""String_Node_Str"")) {
    String moduleName=XMLTools.asString(XMLTools.getUniqueChild(moduleElt,""String_Node_Str"",true));
    Javascript script;
    Element path=XMLTools.getUniqueChild(moduleElt,""String_Node_Str"",false);
    if (path != null) {
      String resourceBundle=null;
      Element bundleElt=XMLTools.getUniqueChild(moduleElt,""String_Node_Str"",false);
      if (bundleElt != null) {
        resourceBundle=XMLTools.asString(bundleElt);
      }
      String modulePath=XMLTools.asString(path);
      script=new Javascript.Local(desc.id,moduleName,contextPath,modulePath,resourceBundle,0);
    }
 else {
      String moduleURI=XMLTools.asString(XMLTools.getUniqueChild(moduleElt,""String_Node_Str"",true));
      script=new Javascript.Remote(desc.id,moduleName,contextPath,moduleURI,0);
    }
    desc.modules.add(script);
  }
  for (  Element moduleElt : XMLTools.getChildren(element,""String_Node_Str"")) {
    String dependencyName=XMLTools.asString(XMLTools.getUniqueChild(moduleElt,""String_Node_Str"",true));
    ResourceId resourceId=new ResourceId(ResourceScope.SHARED,dependencyName);
    DependencyDescriptor dependency=new DependencyDescriptor(resourceId);
    desc.dependencies.add(dependency);
  }
}",0.968421052631579
9914,"public Map<String,FetchMode> resolveURLs(ControllerContext controllerContext,Map<ResourceId,FetchMode> ids,boolean merge,boolean minified,Locale locale) throws IOException {
  Map<String,FetchMode> urls=new LinkedHashMap<String,FetchMode>();
  StringBuilder buffer=new StringBuilder();
  URIWriter writer=new URIWriter(buffer);
  Map<ScriptResource,FetchMode> resources=scripts.resolve(ids);
  for (  Map.Entry<ScriptResource,FetchMode> entry : resources.entrySet()) {
    ScriptResource resource=entry.getKey();
    if (!resource.isEmpty()) {
      controllerContext.renderURL(resource.getParameters(minified,locale),writer);
      urls.put(buffer.toString(),entry.getValue());
      buffer.setLength(0);
      writer.reset(buffer);
    }
  }
  return urls;
}","public Map<String,FetchMode> resolveURLs(ControllerContext controllerContext,Map<ResourceId,FetchMode> ids,boolean merge,boolean minified,Locale locale) throws IOException {
  Map<String,FetchMode> urls=new LinkedHashMap<String,FetchMode>();
  StringBuilder buffer=new StringBuilder();
  URIWriter writer=new URIWriter(buffer);
  Map<ScriptResource,FetchMode> resources=scripts.resolve(ids);
  for (  Map.Entry<ScriptResource,FetchMode> entry : resources.entrySet()) {
    ScriptResource resource=entry.getKey();
    if (!resource.isEmpty()) {
      FetchMode mode=entry.getValue();
      for (      Module module : resource.getModules()) {
        if (module instanceof Module.Remote) {
          urls.put(((Module.Remote)module).getURI(),mode);
        }
      }
      controllerContext.renderURL(resource.getParameters(minified,locale),writer);
      urls.put(buffer.toString(),mode);
      buffer.setLength(0);
      writer.reset(buffer);
    }
  }
  return urls;
}",0.8606130711393869
9915,"protected String trimmedValueOrNullIfBypassed(String value,UIFormInput uiInput,boolean exceptionOnMissingMandatory,boolean trimValue) throws Exception {
  if (value != null) {
    String tmp=value.trim();
    if (trimValue) {
      value=tmp;
    }
    value=tmp.isEmpty() ? null : value;
  }
  if (exceptionOnMissingMandatory && value == null) {
    throw createMessageException(""String_Node_Str"",uiInput);
  }
  return value;
}","protected String trimmedValueOrNullIfBypassed(String value,UIFormInput uiInput,boolean exceptionOnMissingMandatory,boolean trimValue) throws Exception {
  if (value != null) {
    String tmp=value.trim();
    if (trimValue) {
      value=tmp;
    }
    value=tmp.isEmpty() ? null : value;
  }
  if (exceptionOnMissingMandatory && value == null) {
    throw createMessageException(value,uiInput,""String_Node_Str"");
  }
  return value;
}",0.9745370370370372
9916,"protected MessageException createMessageException(String value,UIFormInput uiInput) throws Exception {
  return new MessageException(new ApplicationMessage(getMessageLocalizationKey(),getMessageArgs(value,uiInput),ApplicationMessage.WARNING));
}","protected MessageException createMessageException(String value,UIFormInput uiInput,String localizationKey) throws Exception {
  return new MessageException(new ApplicationMessage(localizationKey,getMessageArgs(value,uiInput),ApplicationMessage.WARNING));
}",0.9261477045908184
9917,"public void addMessage(String messageKey,Object[] args,int type){
  messages.add(new ApplicationMessage(messageKey,args,type));
}","public void addMessage(String messageKey,Object[] args){
  messages.add(new ApplicationMessage(messageKey,args,AbstractApplicationMessage.WARNING));
}",0.8530465949820788
9918,"public CompoundApplicationMessage(AbstractApplicationMessage initialMessage){
  if (initialMessage != null) {
    messages.add(initialMessage);
  }
}","public CompoundApplicationMessage(AbstractApplicationMessage initialMessage){
  if (initialMessage != null) {
    messages.add(initialMessage);
  }
  setType(AbstractApplicationMessage.WARNING);
}",0.863768115942029
9919,"public String renderURL(ContainerURL containerURL,URLFormat format){
  Map<String,String[]> queryParameters=url.getQueryParameters();
  if (queryParameters != null) {
    queryParameters.clear();
  }
  String type;
  if (containerURL instanceof RenderURL) {
    type=Constants.PORTAL_RENDER;
  }
 else   if (containerURL instanceof ResourceURL) {
    type=Constants.PORTAL_SERVE_RESOURCE;
  }
 else   if (containerURL instanceof ActionURL) {
    type=Constants.PORTAL_PROCESS_ACTION;
  }
 else {
    throw new Error(""String_Node_Str"");
  }
  if (!type.equals(Constants.PORTAL_RENDER)) {
    url.setQueryParameterValue(Constants.TYPE_PARAMETER,type);
  }
  if (format != null && format.getWantSecure() != null) {
    url.setQueryParameterValue(Constants.SECURE_PARAMETER,format.getWantSecure().toString());
  }
  if (containerURL instanceof ActionURL) {
    ActionURL actionURL=(ActionURL)containerURL;
    StateString state=actionURL.getInteractionState();
    if (state != null && !state.getStringValue().equals(StateString.JBPNS_PREFIX)) {
      url.setQueryParameterValue(INTERACTION_STATE_PARAM_NAME,state.getStringValue());
    }
    state=actionURL.getNavigationalState();
    if (state != null && !state.getStringValue().equals(StateString.JBPNS_PREFIX)) {
      url.setQueryParameterValue(NAVIGATIONAL_STATE_PARAM_NAME,state.getStringValue());
    }
    WindowState windowState=actionURL.getWindowState();
    if (windowState != null) {
      url.setQueryParameterValue(Constants.WINDOW_STATE_PARAMETER,windowState.toString());
    }
    Mode mode=actionURL.getMode();
    if (mode != null) {
      url.setQueryParameterValue(Constants.PORTLET_MODE_PARAMETER,mode.toString());
    }
  }
 else   if (containerURL instanceof ResourceURL) {
    ResourceURL resourceURL=(ResourceURL)containerURL;
    url.setQueryParameterValue(Constants.RESOURCE_ID_PARAMETER,resourceURL.getResourceId());
    CacheLevel cachability=resourceURL.getCacheability();
    if (cachability != null) {
      url.setQueryParameterValue(Constants.CACHELEVEL_PARAMETER,cachability.name());
    }
    StateString resourceState=resourceURL.getResourceState();
    if (resourceState != null && !resourceState.getStringValue().equals(StateString.JBPNS_PREFIX)) {
      url.setQueryParameterValue(RESOURCE_STATE_PARAM_NAME,resourceState.getStringValue());
    }
    resourceState=resourceURL.getNavigationalState();
    if (resourceState != null && !resourceState.getStringValue().equals(StateString.JBPNS_PREFIX)) {
      url.setQueryParameterValue(NAVIGATIONAL_STATE_PARAM_NAME,resourceState.getStringValue());
    }
    WindowState windowState=resourceURL.getWindowState();
    if (windowState != null) {
      url.setQueryParameterValue(Constants.WINDOW_STATE_PARAMETER,windowState.toString());
    }
    Mode mode=resourceURL.getMode();
    if (mode != null) {
      url.setQueryParameterValue(Constants.PORTLET_MODE_PARAMETER,mode.toString());
    }
  }
 else {
    RenderURL renderURL=(RenderURL)containerURL;
    WindowState windowState=renderURL.getWindowState();
    if (windowState != null) {
      url.setQueryParameterValue(Constants.WINDOW_STATE_PARAMETER,windowState.toString());
    }
    Mode mode=renderURL.getMode();
    if (mode != null) {
      url.setQueryParameterValue(Constants.PORTLET_MODE_PARAMETER,mode.toString());
    }
    Map<String,String[]> publicNSChanges=renderURL.getPublicNavigationalStateChanges();
    if (ParameterValidation.existsAndIsNotEmpty(publicNSChanges)) {
      for (      String key : publicNSChanges.keySet()) {
        String[] values=publicNSChanges.get(key);
        if (values != null && values.length > 0) {
          for (          String value : values) {
            url.setQueryParameterValue(key,value);
          }
        }
 else {
          url.setQueryParameterValue(""String_Node_Str"",key);
        }
      }
    }
    StateString state=renderURL.getNavigationalState();
    if (state != null && !state.getStringValue().equals(StateString.JBPNS_PREFIX)) {
      url.setQueryParameterValue(NAVIGATIONAL_STATE_PARAM_NAME,state.getStringValue());
    }
  }
  Map<String,String> props=containerURL.getProperties();
  String lang=props.get(""String_Node_Str"");
  if (lang != null) {
    if (lang.length() == 0) {
      url.setLocale(null);
    }
 else {
      try {
        Locale locale=I18N.parseJavaIdentifier(lang);
        url.setLocale(locale);
      }
 catch (      IllegalArgumentException e) {
        log.debug(""String_Node_Str"" + lang,e);
      }
    }
  }
  url.setAjax(""String_Node_Str"".equals(props.get(""String_Node_Str"")));
  url.setConfirm(props.get(""String_Node_Str""));
  return url.toString();
}","public String renderURL(ContainerURL containerURL,URLFormat format){
  Map<String,String[]> queryParameters=url.getQueryParameters();
  if (queryParameters != null) {
    queryParameters.clear();
  }
  String type;
  if (containerURL instanceof RenderURL) {
    type=Constants.PORTAL_RENDER;
  }
 else   if (containerURL instanceof ResourceURL) {
    type=Constants.PORTAL_SERVE_RESOURCE;
  }
 else   if (containerURL instanceof ActionURL) {
    type=Constants.PORTAL_PROCESS_ACTION;
  }
 else {
    throw new Error(""String_Node_Str"");
  }
  if (!type.equals(Constants.PORTAL_RENDER)) {
    url.setQueryParameterValue(Constants.TYPE_PARAMETER,type);
  }
  if (format != null && format.getWantSecure() != null) {
    url.setQueryParameterValue(Constants.SECURE_PARAMETER,format.getWantSecure().toString());
  }
  if (containerURL instanceof ActionURL) {
    ActionURL actionURL=(ActionURL)containerURL;
    StateString state=actionURL.getInteractionState();
    if (state != null && !state.getStringValue().equals(StateString.JBPNS_PREFIX)) {
      url.setQueryParameterValue(INTERACTION_STATE_PARAM_NAME,state.getStringValue());
    }
    state=actionURL.getNavigationalState();
    if (state != null && !state.getStringValue().equals(StateString.JBPNS_PREFIX)) {
      url.setQueryParameterValue(NAVIGATIONAL_STATE_PARAM_NAME,state.getStringValue());
    }
    WindowState windowState=actionURL.getWindowState();
    if (windowState != null) {
      url.setQueryParameterValue(Constants.WINDOW_STATE_PARAMETER,windowState.toString());
    }
    Mode mode=actionURL.getMode();
    if (mode != null) {
      url.setQueryParameterValue(Constants.PORTLET_MODE_PARAMETER,mode.toString());
    }
  }
 else   if (containerURL instanceof ResourceURL) {
    ResourceURL resourceURL=(ResourceURL)containerURL;
    url.setQueryParameterValue(Constants.RESOURCE_ID_PARAMETER,resourceURL.getResourceId());
    CacheLevel cachability=resourceURL.getCacheability();
    if (cachability != null) {
      url.setQueryParameterValue(Constants.CACHELEVEL_PARAMETER,cachability.name());
    }
    StateString resourceState=resourceURL.getResourceState();
    if (resourceState != null && !resourceState.getStringValue().equals(StateString.JBPNS_PREFIX)) {
      url.setQueryParameterValue(RESOURCE_STATE_PARAM_NAME,resourceState.getStringValue());
    }
    resourceState=resourceURL.getNavigationalState();
    if (resourceState != null && !resourceState.getStringValue().equals(StateString.JBPNS_PREFIX)) {
      url.setQueryParameterValue(NAVIGATIONAL_STATE_PARAM_NAME,resourceState.getStringValue());
    }
    WindowState windowState=resourceURL.getWindowState();
    if (windowState != null) {
      url.setQueryParameterValue(Constants.WINDOW_STATE_PARAMETER,windowState.toString());
    }
    Mode mode=resourceURL.getMode();
    if (mode != null) {
      url.setQueryParameterValue(Constants.PORTLET_MODE_PARAMETER,mode.toString());
    }
  }
 else {
    RenderURL renderURL=(RenderURL)containerURL;
    WindowState windowState=renderURL.getWindowState();
    if (windowState != null) {
      url.setQueryParameterValue(Constants.WINDOW_STATE_PARAMETER,windowState.toString());
    }
    Mode mode=renderURL.getMode();
    if (mode != null) {
      url.setQueryParameterValue(Constants.PORTLET_MODE_PARAMETER,mode.toString());
    }
    Map<String,String[]> publicNSChanges=renderURL.getPublicNavigationalStateChanges();
    if (ParameterValidation.existsAndIsNotEmpty(publicNSChanges)) {
      for (      String key : publicNSChanges.keySet()) {
        String[] values=publicNSChanges.get(key);
        if (values != null && values.length > 0) {
          for (          String value : values) {
            url.setQueryParameterValue(key,value);
          }
        }
 else {
          url.setQueryParameterValue(""String_Node_Str"",key);
        }
      }
    }
    StateString state=renderURL.getNavigationalState();
    if (state != null && !state.getStringValue().equals(StateString.JBPNS_PREFIX)) {
      url.setQueryParameterValue(NAVIGATIONAL_STATE_PARAM_NAME,state.getStringValue());
    }
  }
  Map<String,String> props=containerURL.getProperties();
  String lang=props.get(""String_Node_Str"");
  if (lang != null) {
    if (lang.length() == 0) {
      url.setLocale(null);
    }
 else {
      try {
        Locale locale=I18N.parseJavaIdentifier(lang);
        url.setLocale(locale);
      }
 catch (      IllegalArgumentException e) {
        log.debug(""String_Node_Str"" + lang,e);
      }
    }
  }
  url.setAjax(""String_Node_Str"".equals(props.get(""String_Node_Str"")));
  url.setConfirm(props.get(""String_Node_Str""));
  MimeType mimeType=Boolean.TRUE.equals(format.getWantEscapeXML()) ? MimeType.XHTML : MimeType.PLAIN;
  url.setMimeType(mimeType);
  return url.toString();
}",0.9860978456966996
9920,"public static ParentChildPair searchParentChildPairUnderNode(PageNode rootNode,String uri){
  if (uri.equals(rootNode.getUri())) {
    return new ParentChildPair(null,rootNode);
  }
  List<PageNode> nodes=rootNode.getNodes();
  if (nodes == null) {
    return null;
  }
  for (  PageNode node : nodes) {
    ParentChildPair parentChildPair=searchParentChildPairUnderNode(node,uri);
    if (parentChildPair != null) {
      parentChildPair.setParentNode(node);
      return parentChildPair;
    }
  }
  return null;
}","public static ParentChildPair searchParentChildPairUnderNode(PageNode rootNode,String uri){
  if (uri.equals(rootNode.getUri())) {
    return new ParentChildPair(null,rootNode);
  }
  List<PageNode> nodes=rootNode.getNodes();
  if (nodes == null) {
    return null;
  }
  for (  PageNode node : nodes) {
    ParentChildPair parentChildPair=searchParentChildPairUnderNode(node,uri);
    if (parentChildPair != null) {
      if (parentChildPair.getParentNode() == null) {
        parentChildPair.setParentNode(rootNode);
      }
      return parentChildPair;
    }
  }
  return null;
}",0.8516833484986351
9921,"public String getDescription(){
  return mType.getDescription();
}","public String getDescription(){
  return (mType.getDescription() != null ? mType.getDescription() : ""String_Node_Str"");
}",0.7058823529411765
9922,"public void execute(Event<UIPageNodeForm2> event) throws Exception {
  UIPageNodeForm2 uiPageNodeForm=event.getSource();
  UIGroupNavigationManagement uiGroupNavigation=uiPageNodeForm.getAncestorOfType(UIGroupNavigationManagement.class);
  PageNavigation selectedNavigation=uiGroupNavigation.getSelectedNavigation();
  UIPopupWindow uiNavigationPopup=uiGroupNavigation.getChild(UIPopupWindow.class);
  UINavigationManagement pageManager=uiPageNodeForm.createUIComponent(UINavigationManagement.class,null,null);
  pageManager.setOwner(selectedNavigation.getOwnerId());
  UINavigationNodeSelector selector=pageManager.getChild(UINavigationNodeSelector.class);
  ArrayList<PageNavigation> navis=new ArrayList<PageNavigation>();
  navis.add(selectedNavigation);
  selector.initNavigations(navis);
  if (uiPageNodeForm.getSelectedParent() instanceof PageNode) {
    PageNode selectedParent=(PageNode)uiPageNodeForm.getSelectedParent();
    selector.selectPageNodeByUri(selectedParent.getUri());
  }
  uiNavigationPopup.setUIComponent(pageManager);
  uiNavigationPopup.setWindowSize(400,400);
  uiNavigationPopup.setRendered(true);
  event.getRequestContext().addUIComponentToUpdateByAjax(uiNavigationPopup.getParent());
}","public void execute(Event<UIPageNodeForm2> event) throws Exception {
  UIPageNodeForm2 uiPageNodeForm=event.getSource();
  UIGroupNavigationManagement uiGroupNavigation=uiPageNodeForm.getAncestorOfType(UIGroupNavigationManagement.class);
  PageNavigation selectedNavigation=uiGroupNavigation.getSelectedNavigation();
  UIPopupWindow uiNavigationPopup=uiGroupNavigation.getChild(UIPopupWindow.class);
  UINavigationManagement pageManager=uiPageNodeForm.createUIComponent(UINavigationManagement.class,null,null);
  pageManager.setOwner(selectedNavigation.getOwnerId());
  UINavigationNodeSelector selector=pageManager.getChild(UINavigationNodeSelector.class);
  if (uiPageNodeForm.getSelectedParent() instanceof PageNode) {
    PageNode selectedParent=(PageNode)uiPageNodeForm.getSelectedParent();
    selector.selectPageNodeByUri(selectedParent.getUri());
  }
  uiNavigationPopup.setUIComponent(pageManager);
  uiNavigationPopup.setWindowSize(400,400);
  uiNavigationPopup.setRendered(true);
  event.getRequestContext().addUIComponentToUpdateByAjax(uiNavigationPopup.getParent());
}",0.9412276882890728
9923,"public void execute(Event<UIPageNodeForm2> event) throws Exception {
  UIPageNodeForm2 uiPageNodeForm=event.getSource();
  UISiteManagement uiSiteManagement=uiPageNodeForm.getAncestorOfType(UISiteManagement.class);
  PageNavigation selectedNavigation=uiSiteManagement.getOriginalSelectedNavigation();
  UIPopupWindow uiNavigationPopup=uiSiteManagement.getChild(UIPopupWindow.class);
  UINavigationManagement pageManager=uiPageNodeForm.createUIComponent(UINavigationManagement.class,null,null);
  pageManager.setOwner(selectedNavigation.getOwnerId());
  UINavigationNodeSelector selector=pageManager.getChild(UINavigationNodeSelector.class);
  ArrayList<PageNavigation> navis=new ArrayList<PageNavigation>();
  navis.add(selectedNavigation);
  selector.initNavigations(navis);
  uiNavigationPopup.setUIComponent(pageManager);
  uiNavigationPopup.setWindowSize(400,400);
  event.getRequestContext().addUIComponentToUpdateByAjax(uiNavigationPopup.getParent());
}","public void execute(Event<UIPageNodeForm2> event) throws Exception {
  UIPageNodeForm2 uiPageNodeForm=event.getSource();
  UISiteManagement uiSiteManagement=uiPageNodeForm.getAncestorOfType(UISiteManagement.class);
  PageNavigation selectedNavigation=uiSiteManagement.getOriginalSelectedNavigation();
  UIPopupWindow uiNavigationPopup=uiSiteManagement.getChild(UIPopupWindow.class);
  UINavigationManagement pageManager=uiPageNodeForm.createUIComponent(UINavigationManagement.class,null,null);
  pageManager.setOwner(selectedNavigation.getOwnerId());
  UINavigationNodeSelector selector=pageManager.getChild(UINavigationNodeSelector.class);
  uiNavigationPopup.setUIComponent(pageManager);
  uiNavigationPopup.setWindowSize(400,400);
  event.getRequestContext().addUIComponentToUpdateByAjax(uiNavigationPopup.getParent());
}",0.9242849130678632
9924,"private boolean isInPublicationDate(){
  if (startPublicationDate != null && endPublicationDate != null) {
    Date currentDate=new Date();
    return currentDate.compareTo(startPublicationDate) >= 0 && currentDate.compareTo(endPublicationDate) <= 0;
  }
 else   return startPublicationDate == null && endPublicationDate == null;
}","private boolean isInPublicationDate(){
  Date currentDate=new Date();
  boolean case1=(startPublicationDate != null) && (endPublicationDate != null) && (currentDate.compareTo(startPublicationDate) >= 0 && currentDate.compareTo(endPublicationDate) <= 0);
  boolean case2=(startPublicationDate == null) && (endPublicationDate != null) && (currentDate.compareTo(endPublicationDate) <= 0);
  boolean case3=(startPublicationDate != null) && (endPublicationDate == null) && (currentDate.compareTo(startPublicationDate) >= 0);
  boolean case4=(startPublicationDate == null) && (endPublicationDate == null);
  return case1 || case2 || case3|| case4;
}",0.4209445585215606
9925,"@Override public Reader read(){
  return new StringReader(sb.toString());
}","@Override public Reader read(){
  return new CharSequenceReader(sb);
}",0.8275862068965517
9926,"public Resource resolve(String path){
  if (path.startsWith(""String_Node_Str"" + portalContainerName + ""String_Node_Str"") && path.endsWith(""String_Node_Str"")) {
    final StringBuffer sb=new StringBuffer();
    String encoded=path.substring((""String_Node_Str"" + portalContainerName + ""String_Node_Str"").length());
    String blah[]=encoded.split(""String_Node_Str"");
    int len=(blah.length >> 1) << 1;
    for (int i=0; i < len; i+=2) {
      String name=Codec.decode(blah[i]);
      String module=Codec.decode(blah[i + 1]);
      SkinKey key=new SkinKey(module,name);
      SkinConfig skin=skins.get(key);
      if (skin != null) {
        sb.append(""String_Node_Str"").append(skin.getCSSPath()).append(""String_Node_Str"").append(""String_Node_Str"");
      }
    }
    return new Resource(path){
      @Override public Reader read(){
        return new StringReader(sb.toString());
      }
    }
;
  }
 else {
    return null;
  }
}","public Resource resolve(String path){
  if (path == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (path.startsWith(prefix) && path.endsWith(""String_Node_Str"")) {
    final StringBuilder sb=new StringBuilder();
    String encoded=path.substring(prefix.length());
    String blah[]=encoded.split(""String_Node_Str"");
    int len=(blah.length >> 1) << 1;
    for (int i=0; i < len; i+=2) {
      String name=Codec.decode(blah[i]);
      String module=Codec.decode(blah[i + 1]);
      SkinKey key=new SkinKey(module,name);
      SkinConfig skin=skins.get(key);
      if (skin != null) {
        sb.append(""String_Node_Str"").append(skin.getCSSPath()).append(""String_Node_Str"").append(""String_Node_Str"");
      }
    }
    return new Resource(path){
      @Override public Reader read(){
        return new CharSequenceReader(sb);
      }
    }
;
  }
 else {
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"");
    }
    return null;
  }
}",0.7552521008403361
9927,"public CompositeResourceResolver(String portalContainerName,Map<SkinKey,SkinConfig> skins){
  this.portalContainerName=portalContainerName;
  this.skins=skins;
}","public CompositeResourceResolver(String portalContainerName,Map<SkinKey,SkinConfig> skins){
  this.portalContainerName=portalContainerName;
  this.skins=skins;
  this.prefix=""String_Node_Str"" + portalContainerName + ""String_Node_Str"";
}",0.8110831234256927
9928,"public Resource resolve(String path){
  for (  ResourceResolver resolver : resolvers) {
    Resource res=resolver.resolve(path);
    if (res != null) {
      return res;
    }
  }
  int i1=path.indexOf(""String_Node_Str"",2);
  String targetedContextPath=path.substring(0,i1);
  SimpleResourceContext context=contexts.get(targetedContextPath);
  return context.getResource(path.substring(i1));
}","public Resource resolve(String path){
  if (path == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  for (  ResourceResolver resolver : resolvers) {
    Resource res=resolver.resolve(path);
    if (res != null) {
      return res;
    }
  }
  int i1=path.indexOf(""String_Node_Str"",2);
  String targetedContextPath=path.substring(0,i1);
  SimpleResourceContext context=contexts.get(targetedContextPath);
  if (context == null) {
    log.warn(""String_Node_Str"" + targetedContextPath + ""String_Node_Str""+ path);
    return null;
  }
 else {
    return context.getResource(path.substring(i1));
  }
}",0.751984126984127
9929,"/** 
 * Returns a reader for the provided path or null if the resource cannot be resolved.
 * @param path the path
 * @return a reader 
 */
Resource resolve(String path);","/** 
 * Returns a   {@link org.exoplatform.portal.resource.Resource} for the provided path or null if the resource cannot be resolved.
 * @param path the path
 * @return a reader
 * @throws NullPointerException if the path argument is null
 * @throws IllegalStateException when
 */
Resource resolve(String path) throws NullPointerException ;",0.2661448140900195
9930,"@OneToMany(type=RelationshipType.PATH) @MappedBy(""String_Node_Str"") public abstract List<RegistrationMapping> getRegistrations();",@OneToMany public abstract List<RegistrationMapping> getRegistrations();,0.7164179104477612
9931,"@ManyToOne(type=RelationshipType.PATH) @MappedBy(""String_Node_Str"") public abstract ConsumerMapping getConsumer();",@ManyToOne public abstract ConsumerMapping getConsumer();,0.6666666666666666
9932,"private static List<PageNode> findPath(PageNavigation nav,String[] pathNodes){
  List<PageNode> nodes=new ArrayList<PageNode>(4);
  if (pathNodes.length == 0) {
    nodes.add(nav.getNodes().get(0));
    return nodes;
  }
  PageNode startNode=nav.getNode(pathNodes[0]);
  if (startNode == null) {
    return nodes;
  }
  nodes.add(startNode);
  for (int i=1; i < pathNodes.length; i++) {
    if (startNode == null) {
      break;
    }
 else {
      nodes.add(startNode);
      startNode=startNode.getChild(pathNodes[i]);
    }
  }
  return nodes;
}","private static List<PageNode> findPath(PageNavigation nav,String[] pathNodes){
  List<PageNode> nodes=new ArrayList<PageNode>(4);
  if (pathNodes.length == 0) {
    nodes.add(nav.getNodes().get(0));
    return nodes;
  }
  PageNode startNode=nav.getNode(pathNodes[0]);
  if (startNode == null) {
    return nodes;
  }
  nodes.add(startNode);
  for (int i=1; i < pathNodes.length; i++) {
    startNode=startNode.getChild(pathNodes[i]);
    if (startNode == null) {
      break;
    }
 else {
      nodes.add(startNode);
    }
  }
  return nodes;
}",0.9104204753199268
9933,"/** 
 * Refresh the UIPage under UIPortal 
 * @throws Exception
 */
public void refreshUIPage() throws Exception {
  if (selectedNode_ == null) {
    selectedNode_=navigation.getNodes().get(0);
  }
  UIPageBody uiPageBody=findFirstComponentOfType(UIPageBody.class);
  if (uiPageBody == null) {
    return;
  }
  if (uiPageBody.getMaximizedUIComponent() != null) {
    UIPortlet currentPortlet=(UIPortlet)uiPageBody.getMaximizedUIComponent();
    currentPortlet.setCurrentWindowState(WindowState.NORMAL);
    uiPageBody.setMaximizedUIComponent(null);
  }
  uiPageBody.setPageBody(selectedNode_,this);
  Locale locale=Util.getUIPortalApplication().getLocale();
  refreshNavigation(locale);
}","/** 
 * Refresh the UIPage under UIPortal 
 * @throws Exception
 */
public void refreshUIPage() throws Exception {
  if (selectedNode_ == null) {
    selectedNode_=navigation.getNodes().get(0);
  }
  UIPageBody uiPageBody=findFirstComponentOfType(UIPageBody.class);
  if (uiPageBody == null) {
    return;
  }
  if (uiPageBody.getMaximizedUIComponent() != null) {
    UIPortlet currentPortlet=(UIPortlet)uiPageBody.getMaximizedUIComponent();
    currentPortlet.setCurrentWindowState(WindowState.NORMAL);
    uiPageBody.setMaximizedUIComponent(null);
  }
  uiPageBody.setPageBody(selectedNode_,this);
  Locale locale=Util.getUIPortalApplication().getLocale();
  localizePageNavigation(navigation,locale);
}",0.9784791965566716
9934,"/** 
 * PageNode won't be processed in following cases: Case 1: Node 's visibility is SYSTEM and the user is not superuser or he is superuser but acceptNonDisplayNode = false Case 2: Node 's visibility is not SYSTEM but the node is not display and the acceptNonDisplayedNode = false Case 3: Node has non null pageReference but the associated Page does not exist
 * @param startNode
 * @param userName
 * @param userService
 * @return
 * @throws Exception
 */
private static PageNode filterNodeNavigation(PageNode startNode,String userName,boolean acceptNonDisplayedNode,UserPortalConfigService userService,UserACL userACL) throws Exception {
  Visibility nodeVisibility=startNode.getVisibility();
  String pageReference=startNode.getPageReference();
  boolean doNothingCase_1=nodeVisibility == Visibility.SYSTEM && (!userACL.getSuperUser().equals(userName) || !acceptNonDisplayedNode);
  boolean doNothingCase_2=nodeVisibility != Visibility.SYSTEM && !startNode.isDisplay() && !acceptNonDisplayedNode;
  boolean doNothingCase_3=(pageReference != null) && (userService.getPage(pageReference,userName) == null);
  if (doNothingCase_1 || doNothingCase_2 || doNothingCase_3) {
    return null;
  }
  PageNode cloneStartNode=startNode.clone();
  ArrayList<PageNode> filteredChildren=new ArrayList<PageNode>();
  List<PageNode> children=startNode.getChildren();
  if (children != null) {
    for (    PageNode child : children) {
      PageNode filteredChildNode=filterNodeNavigation(child,userName,acceptNonDisplayedNode,userService,userACL);
      if (filteredChildNode != null) {
        filteredChildren.add(filteredChildNode);
      }
    }
  }
  if (filteredChildren.size() == 0 && cloneStartNode.getPageReference() == null) {
    return null;
  }
  cloneStartNode.setChildren(filteredChildren);
  return cloneStartNode;
}","/** 
 * PageNode won't be processed in following cases: Case 1: Node 's visibility is SYSTEM and the user is not superuser or he is superuser but acceptNonDisplayNode = false Case 2: Node 's visibility is not SYSTEM but the node is not display and the acceptNonDisplayedNode = false Case 3: Node has non null pageReference but the associated Page does not exist
 * @param startNode
 * @param userName
 * @param userService
 * @return
 * @throws Exception
 */
private static PageNode filterNodeNavigation(PageNode startNode,String userName,boolean acceptNonDisplayedNode,UserPortalConfigService userService,UserACL userACL) throws Exception {
  Visibility nodeVisibility=startNode.getVisibility();
  String pageReference=startNode.getPageReference();
  boolean doNothingCase_1=nodeVisibility == Visibility.SYSTEM && (!userACL.getSuperUser().equals(userName) || !acceptNonDisplayedNode);
  boolean doNothingCase_2=nodeVisibility != Visibility.SYSTEM && !startNode.isDisplay() && !acceptNonDisplayedNode;
  boolean doNothingCase_3=(pageReference != null) && (userService.getPage(pageReference,userName) == null);
  if (doNothingCase_1 || doNothingCase_2 || doNothingCase_3) {
    return null;
  }
  PageNode cloneStartNode=startNode.clone();
  ArrayList<PageNode> filteredChildren=new ArrayList<PageNode>();
  List<PageNode> children=startNode.getChildren();
  if (children != null) {
    for (    PageNode child : children) {
      PageNode filteredChildNode=filterNodeNavigation(child,userName,acceptNonDisplayedNode,userService,userACL);
      if (filteredChildNode != null) {
        filteredChildren.add(filteredChildNode);
      }
    }
  }
  if (!acceptNonDisplayedNode && filteredChildren.size() == 0 && cloneStartNode.getPageReference() == null) {
    return null;
  }
  cloneStartNode.setChildren(filteredChildren);
  return cloneStartNode;
}",0.969763007354944
9935,"@Override protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  resp.setContentType(""String_Node_Str"");
  HttpSession session=req.getSession();
  Credentials credentials=(Credentials)session.getAttribute(InitiateLoginServlet.CREDENTIALS);
  session.setAttribute(""String_Node_Str"",req.getAttribute(""String_Node_Str""));
  if (credentials == null) {
    String token=getTokenCookie(req);
    PortalContainer pContainer=PortalContainer.getInstance();
    ServletContext context=pContainer.getPortalContext();
    if (token != null) {
      AbstractTokenService tokenService=AbstractTokenService.getInstance(CookieTokenService.class);
      credentials=tokenService.validateToken(token,false);
      if (credentials == null) {
        Cookie cookie=new Cookie(InitiateLoginServlet.COOKIE_NAME,""String_Node_Str"");
        cookie.setPath(req.getContextPath());
        cookie.setMaxAge(0);
        resp.addCookie(cookie);
        context.getRequestDispatcher(""String_Node_Str"").include(req,resp);
        return;
      }
    }
 else {
      context.getRequestDispatcher(""String_Node_Str"").include(req,resp);
      return;
    }
  }
 else {
    req.getSession().removeAttribute(InitiateLoginServlet.CREDENTIALS);
  }
  String token=null;
  for (  Cookie cookie : req.getCookies()) {
    if (InitiateLoginServlet.COOKIE_NAME.equals(cookie.getName())) {
      String rememberme=req.getParameter(COOKIE_NAME);
      if (rememberme != null) {
        token=cookie.getValue();
        break;
      }
    }
  }
  if (token == null) {
    TransientTokenService tokenService=AbstractTokenService.getInstance(TransientTokenService.class);
    token=tokenService.createToken(credentials);
  }
  sendAuth(resp,credentials.getUsername(),token);
}","@Override protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  resp.setContentType(""String_Node_Str"");
  HttpSession session=req.getSession();
  Credentials credentials=(Credentials)session.getAttribute(InitiateLoginServlet.CREDENTIALS);
  if (credentials == null) {
    PortalContainer pContainer=PortalContainer.getInstance();
    ServletContext context=pContainer.getPortalContext();
    String token=getRememberMeTokenCookie(req);
    if (token != null) {
      AbstractTokenService tokenService=AbstractTokenService.getInstance(CookieTokenService.class);
      credentials=tokenService.validateToken(token,false);
      if (credentials == null) {
        log.debug(""String_Node_Str"" + token + ""String_Node_Str""+ ""String_Node_Str"");
        Cookie cookie=new Cookie(InitiateLoginServlet.COOKIE_NAME,""String_Node_Str"");
        cookie.setPath(req.getContextPath());
        cookie.setMaxAge(0);
        resp.addCookie(cookie);
        context.getRequestDispatcher(""String_Node_Str"").include(req,resp);
      }
 else {
        log.debug(""String_Node_Str"" + token + ""String_Node_Str""+ ""String_Node_Str"");
        sendAuth(resp,credentials.getUsername(),token);
      }
    }
 else {
      log.debug(""String_Node_Str"");
      context.getRequestDispatcher(""String_Node_Str"").include(req,resp);
    }
  }
 else {
    TransientTokenService tokenService=AbstractTokenService.getInstance(TransientTokenService.class);
    String token=tokenService.createToken(credentials);
    req.getSession().removeAttribute(InitiateLoginServlet.CREDENTIALS);
    log.debug(""String_Node_Str"");
    sendAuth(resp,credentials.getUsername(),token);
  }
}",0.6795277857759862
9936,"protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  String username=req.getParameter(""String_Node_Str"");
  String password=req.getParameter(""String_Node_Str"");
  if (username == null) {
    resp.sendError(HttpServletResponse.SC_BAD_REQUEST,""String_Node_Str"");
  }
  if (password == null) {
    resp.sendError(HttpServletResponse.SC_BAD_REQUEST,""String_Node_Str"");
  }
  Credentials credentials=new Credentials(username,password);
  req.getSession().setAttribute(InitiateLoginServlet.CREDENTIALS,credentials);
  String uri=req.getParameter(""String_Node_Str"");
  if (uri == null || uri.length() == 0) {
    uri=req.getContextPath() + ""String_Node_Str"";
  }
  String rememberme=req.getParameter(""String_Node_Str"");
  if (""String_Node_Str"".equals(rememberme)) {
    boolean isRemember=""String_Node_Str"".equals(req.getParameter(InitiateLoginServlet.COOKIE_NAME));
    if (isRemember) {
      AbstractTokenService tokenService=AbstractTokenService.getInstance(CookieTokenService.class);
      String cookieToken=tokenService.createToken(credentials);
      Cookie cookie=new Cookie(InitiateLoginServlet.COOKIE_NAME,cookieToken);
      cookie.setPath(req.getContextPath());
      cookie.setMaxAge((int)tokenService.getValidityTime() / 1000);
      resp.addCookie(cookie);
    }
  }
  resp.sendRedirect(uri);
}","protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  String username=req.getParameter(""String_Node_Str"");
  String password=req.getParameter(""String_Node_Str"");
  if (username == null) {
    log.error(""String_Node_Str"");
    resp.sendError(HttpServletResponse.SC_BAD_REQUEST,""String_Node_Str"");
  }
  if (password == null) {
    log.error(""String_Node_Str"");
    resp.sendError(HttpServletResponse.SC_BAD_REQUEST,""String_Node_Str"");
  }
  log.debug(""String_Node_Str"");
  Credentials credentials=new Credentials(username,password);
  req.getSession().setAttribute(InitiateLoginServlet.CREDENTIALS,credentials);
  String uri=req.getParameter(""String_Node_Str"");
  if (uri == null || uri.length() == 0) {
    uri=req.getContextPath() + ""String_Node_Str"";
    log.debug(""String_Node_Str"" + uri + ""String_Node_Str"");
  }
 else {
    log.debug(""String_Node_Str"" + uri);
  }
  String rememberme=req.getParameter(""String_Node_Str"");
  if (""String_Node_Str"".equals(rememberme)) {
    boolean isRemember=""String_Node_Str"".equals(req.getParameter(InitiateLoginServlet.COOKIE_NAME));
    if (isRemember) {
      AbstractTokenService tokenService=AbstractTokenService.getInstance(CookieTokenService.class);
      String cookieToken=tokenService.createToken(credentials);
      log.debug(""String_Node_Str"" + cookieToken + ""String_Node_Str""+ ""String_Node_Str"");
      Cookie cookie=new Cookie(InitiateLoginServlet.COOKIE_NAME,cookieToken);
      cookie.setPath(req.getContextPath());
      cookie.setMaxAge((int)tokenService.getValidityTime() / 1000);
      resp.addCookie(cookie);
    }
  }
  resp.sendRedirect(uri);
}",0.9004300363876944
9937,"private <K extends Serializable,V>V create(POMSession session,CacheableDataTask<K,V> task) throws Exception {
  return super.execute(session,task);
}","private <K extends Serializable,V>V create(POMSession session,CacheableDataTask<K,V> task) throws Exception {
  K key=task.getKey();
  session.scheduleForEviction(key);
  return super.execute(session,task);
}",0.834733893557423
9938,"public List<PageNavigation> getNavigations() throws Exception {
  WebuiRequestContext context=WebuiRequestContext.getCurrentInstance();
  List<PageNavigation> result=new ArrayList<PageNavigation>();
  if (context.getRemoteUser() != null) {
    result.add(PageNavigationUtils.filter(getSelectedNavigation(),context.getRemoteUser()));
  }
 else {
    for (    PageNavigation nav : Util.getUIPortal().getNavigations()) {
      if (!showUserNavigation && nav.getOwnerType().equals(""String_Node_Str""))       continue;
      result.add(PageNavigationUtils.filter(nav,null));
    }
  }
  return result;
}","public List<PageNavigation> getNavigations() throws Exception {
  WebuiRequestContext context=WebuiRequestContext.getCurrentInstance();
  List<PageNavigation> result=new ArrayList<PageNavigation>();
  if (context.getRemoteUser() != null) {
    result.add(PageNavigationUtils.filter(getSelectedNavigation(),context.getRemoteUser()));
  }
 else {
    for (    PageNavigation nav : Util.getUIPortalApplication().getNavigations()) {
      if (!showUserNavigation && nav.getOwnerType().equals(""String_Node_Str""))       continue;
      result.add(PageNavigationUtils.filter(nav,null));
    }
  }
  return result;
}",0.9908713692946058
9939,"private Component toComponentConfig(ComponentConfig annotation,Class<?> clazz) throws Exception {
  Component config=new Component();
  if (annotation.id().length() > 0) {
    config.setId(annotation.id());
  }
  Class<?> type=annotation.type() == void.class ? clazz : annotation.type();
  config.setType(type.getName());
  if (annotation.template().length() > 0) {
    config.setTemplate(annotation.template());
  }
  if (annotation.lifecycle() != void.class) {
    config.setLifecycle(annotation.lifecycle().getName());
  }
  if (annotation.decorator().length() > 0) {
    config.setDecorator(annotation.decorator());
  }
  config.setInitParams(toInitParams(annotation.initParams()));
  EventConfig[] eventAnnotations=annotation.events();
  List<Event> events;
  if (eventAnnotations.length != 0) {
    events=new ArrayList<Event>();
    for (    EventConfig eventAnnotation : eventAnnotations) {
      events.add(toEventConfig(eventAnnotation));
    }
  }
 else {
    events=Collections.emptyList();
  }
  config.setEvents(events);
  EventInterceptorConfig[] eventInterceptorAnnotations=annotation.eventInterceptors();
  List<EventInterceptor> eventInterceptors;
  if (eventInterceptorAnnotations.length != 0) {
    eventInterceptors=new ArrayList<EventInterceptor>();
    for (    EventInterceptorConfig eventAnnotation : eventInterceptorAnnotations) {
      eventInterceptors.add(toEventInterceptorConfig(eventAnnotation));
    }
  }
 else {
    eventInterceptors=Collections.emptyList();
  }
  config.setEventInterceptors(eventInterceptors);
  ValidatorConfig[] validatorAnnotations=annotation.validators();
  List<Validator> validators;
  if (validatorAnnotations.length != 0) {
    validators=new ArrayList<Validator>();
    for (    ValidatorConfig ele : validatorAnnotations) {
      validators.add(toValidator(ele));
    }
  }
 else {
    validators=Collections.emptyList();
  }
  config.setValidators(validators);
  return config;
}","private Component toComponentConfig(ComponentConfig annotation,Class<?> clazz) throws Exception {
  Component config=new Component();
  if (annotation.id().length() > 0) {
    config.setId(annotation.id());
  }
  Class<?> type=annotation.type() == void.class ? clazz : annotation.type();
  config.setType(type.getName());
  if (annotation.template().length() > 0) {
    config.setTemplate(annotation.template());
  }
  if (annotation.lifecycle() != void.class) {
    config.setLifecycle(annotation.lifecycle().getName());
  }
  if (annotation.decorator().length() > 0) {
    config.setDecorator(annotation.decorator());
  }
  config.setInitParams(toInitParams(annotation.initParams()));
  EventConfig[] eventAnnotations=annotation.events();
  ArrayList<Event> events;
  if (eventAnnotations.length != 0) {
    events=new ArrayList<Event>();
    for (    EventConfig eventAnnotation : eventAnnotations) {
      events.add(toEventConfig(eventAnnotation));
    }
  }
 else {
    events=new ArrayList<Event>();
  }
  config.setEvents(events);
  EventInterceptorConfig[] eventInterceptorAnnotations=annotation.eventInterceptors();
  ArrayList<EventInterceptor> eventInterceptors;
  if (eventInterceptorAnnotations.length != 0) {
    eventInterceptors=new ArrayList<EventInterceptor>();
    for (    EventInterceptorConfig eventAnnotation : eventInterceptorAnnotations) {
      eventInterceptors.add(toEventInterceptorConfig(eventAnnotation));
    }
  }
 else {
    eventInterceptors=new ArrayList<EventInterceptor>();
  }
  config.setEventInterceptors(eventInterceptors);
  ValidatorConfig[] validatorAnnotations=annotation.validators();
  ArrayList<Validator> validators;
  if (validatorAnnotations.length != 0) {
    validators=new ArrayList<Validator>();
    for (    ValidatorConfig ele : validatorAnnotations) {
      validators.add(toValidator(ele));
    }
  }
 else {
    validators=new ArrayList<Validator>();
  }
  config.setValidators(validators);
  return config;
}",0.9685823754789272
9940,"public void execute(Event<UIWsrpConsumerOverview> event){
  UIApplication uiApp=event.getRequestContext().getUIApplication();
  try {
    UIWsrpConsumerOverview consumerOverview=event.getSource();
    WSRPConsumer consumer=consumerOverview.getConsumerFromEvent(event);
    if (consumer != null) {
      ConsumerRegistry registry=consumerOverview.getConsumerRegistry();
      RefreshResult result=consumer.refresh(true);
      if (result.hasIssues()) {
        RegistrationInfo expected=new RegistrationInfo(consumer.getProducerInfo().getRegistrationInfo());
        expected.refresh(result.getServiceDescription(),consumer.getProducerId(),true,true,true);
        consumerOverview.setExpectedRegistrationInfo(expected);
        registry.deactivateConsumerWith(consumer.getProducerId());
        uiApp.addMessage(new ApplicationMessage(""String_Node_Str"",null,ApplicationMessage.ERROR));
      }
 else {
        if (consumer.isActive()) {
          registry.activateConsumerWith(consumer.getProducerId());
        }
 else {
          registry.deactivateConsumerWith(consumer.getProducerId());
        }
        uiApp.addMessage(new ApplicationMessage(""String_Node_Str"",null,ApplicationMessage.INFO));
      }
      consumerOverview.refreshGrid(event);
    }
  }
 catch (  Exception e) {
    uiApp.addMessage(new ApplicationMessage(""String_Node_Str"" + e.getCause(),null,ApplicationMessage.ERROR));
    e.printStackTrace();
  }
}","public void execute(Event<UIWsrpConsumerOverview> event){
  UIApplication uiApp=event.getRequestContext().getUIApplication();
  try {
    UIWsrpConsumerOverview consumerOverview=event.getSource();
    WSRPConsumer consumer=consumerOverview.getConsumerFromEvent(event);
    if (consumer != null) {
      ConsumerRegistry registry=consumerOverview.getConsumerRegistry();
      RefreshResult result=consumer.refresh(true);
      if (result.hasIssues()) {
        RegistrationInfo expected=new RegistrationInfo(consumer.getProducerInfo().getRegistrationInfo());
        expected.refresh(result.getServiceDescription(),consumer.getProducerId(),true,true,true);
        consumerOverview.setExpectedRegistrationInfo(expected);
        registry.deactivateConsumerWith(consumer.getProducerId());
        uiApp.addMessage(new ApplicationMessage(""String_Node_Str"",null,ApplicationMessage.ERROR));
      }
 else {
        if (consumer.isActive()) {
          registry.activateConsumerWith(consumer.getProducerId());
        }
 else {
          registry.deactivateConsumerWith(consumer.getProducerId());
        }
        uiApp.addMessage(new ApplicationMessage(""String_Node_Str"",null,ApplicationMessage.INFO));
      }
      consumerOverview.refreshGrid(event);
    }
  }
 catch (  Exception e) {
    uiApp.addMessage(new ApplicationMessage(""String_Node_Str"",new String[]{e.getCause().toString()},ApplicationMessage.ERROR));
    e.printStackTrace();
  }
}",0.9881450488145048
9941,"public UIWsrpRegistrationDetails(String name,UIWsrpProducerEditor parent) throws Exception {
  super(name);
  policy=new UIFormStringInput(POLICY_CLASS,POLICY_CLASS,null);
  addUIFormInput(policy);
  validator=new UIFormStringInput(VALIDATOR_CLASS,VALIDATOR_CLASS,null);
  addUIFormInput(validator);
  registrationProperties=addChild(UIGrid.class,REGISTRATION_PROPERTIES,REGISTRATION_PROPERTIES);
  ValueRenderer<LocalizedString> renderer=new ValueRenderer<LocalizedString>(){
    @Override public String render(    LocalizedString value){
      return value.getValue();
    }
  }
;
  registrationProperties.registerRendererFor(renderer,LocalizedString.class);
  registrationProperties.configure(""String_Node_Str"",FIELDS,SELECT_ACTIONS);
  registrationProperties.getUIPageIterator().setId(REGISTRATION_PROPERTIES_ITERATOR);
  registrationProperties.getUIPageIterator().setRendered(false);
  addChild(registrationProperties.getUIPageIterator());
  init(parent.getService().getConfiguration().getRegistrationRequirements());
  UIPopupWindow popup=addChild(UIPopupWindow.class,null,null);
  popup.setWindowSize(400,300);
  UIWsrpProducerPropertyEditor propertyForm=createUIComponent(UIWsrpProducerPropertyEditor.class,null,""String_Node_Str"");
  popup.setUIComponent(propertyForm);
  popup.setRendered(false);
}","public UIWsrpRegistrationDetails(String name,UIWsrpProducerEditor parent) throws Exception {
  super(name);
  policy=new UIFormStringInput(POLICY_CLASS,POLICY_CLASS,null);
  addUIFormInput(policy);
  validator=new UIFormStringInput(VALIDATOR_CLASS,VALIDATOR_CLASS,null);
  addUIFormInput(validator);
  registrationProperties=parent.getRegistrationProperties();
  ValueRenderer<LocalizedString> renderer=new ValueRenderer<LocalizedString>(){
    @Override public String render(    LocalizedString value){
      return value.getValue();
    }
  }
;
  registrationProperties.registerRendererFor(renderer,LocalizedString.class);
  registrationProperties.configure(""String_Node_Str"",FIELDS,SELECT_ACTIONS);
  registrationProperties.getUIPageIterator().setId(REGISTRATION_PROPERTIES_ITERATOR);
  registrationProperties.getUIPageIterator().setRendered(false);
  addChild(registrationProperties.getUIPageIterator());
  init(parent.getService().getConfiguration().getRegistrationRequirements());
  UIPopupWindow popup=addChild(UIPopupWindow.class,null,null);
  popup.setWindowSize(400,300);
  UIWsrpProducerPropertyEditor propertyForm=createUIComponent(UIWsrpProducerPropertyEditor.class,null,""String_Node_Str"");
  popup.setUIComponent(propertyForm);
  popup.setRendered(false);
}",0.9604344453064392
9942,"@Override public void processRender(WebuiApplication app,WebuiRequestContext context) throws Exception {
  if (hasEditPermissionOnNavigation() || hasEditPermissionOnPage()) {
    super.processRender(app,context);
  }
}","@Override public void processRender(WebuiApplication app,WebuiRequestContext context) throws Exception {
  if (hasEditPermissionOnNavigation() || hasEditPermissionOnPage() || hasEditPermissionOnPortal()) {
    super.processRender(app,context);
  }
}",0.9336188436830836
9943,"public UIWsrpProducerEditor() throws Exception {
  configService=Util.getUIPortalApplication().getApplicationComponent(ProducerConfigurationService.class);
  regReqForDesc=new UIFormCheckBoxInput(REG_REQUIRED_FOR_DESCRIPTION,REG_REQUIRED_FOR_DESCRIPTION,null);
  addUIFormInput(regReqForDesc);
  strictMode=new UIFormCheckBoxInput(STRICT_MODE,STRICT_MODE,null);
  addUIFormInput(strictMode);
  regRequired=new UIFormCheckBoxInput<Boolean>(REQUIRES_REGISTRATION,REQUIRES_REGISTRATION,null);
  regRequired.setOnChange(""String_Node_Str"");
  addUIFormInput(regRequired);
  setActions(new String[]{});
  registrationDetails=new UIWsrpRegistrationDetails(REGISTRATION_DETAILS,this);
  addUIFormInput(registrationDetails);
  init();
}","public UIWsrpProducerEditor() throws Exception {
  configService=Util.getUIPortalApplication().getApplicationComponent(ProducerConfigurationService.class);
  regReqForDesc=new UIFormCheckBoxInput(REG_REQUIRED_FOR_DESCRIPTION,REG_REQUIRED_FOR_DESCRIPTION,null);
  addUIFormInput(regReqForDesc);
  strictMode=new UIFormCheckBoxInput(STRICT_MODE,STRICT_MODE,null);
  addUIFormInput(strictMode);
  regRequired=new UIFormCheckBoxInput<Boolean>(REQUIRES_REGISTRATION,REQUIRES_REGISTRATION,null);
  regRequired.setOnChange(""String_Node_Str"");
  addUIFormInput(regRequired);
  setActions(new String[]{});
  registrationDetails=addChild(UIWsrpRegistrationDetails.class,null,null);
  init();
}",0.9333333333333332
9944,"public UIWsrpRegistrationDetails(String name,UIWsrpProducerEditor parent) throws Exception {
  super(name);
  policy=new UIFormStringInput(POLICY_CLASS,POLICY_CLASS,null);
  addUIFormInput(policy);
  validator=new UIFormStringInput(VALIDATOR_CLASS,VALIDATOR_CLASS,null);
  addUIFormInput(validator);
  addChild(parent.getRegistrationProperties());
  registrationProperties=getChildById(REGISTRATION_PROPERTIES);
  ValueRenderer<LocalizedString> renderer=new ValueRenderer<LocalizedString>(){
    @Override public String render(    LocalizedString value){
      return value.getValue();
    }
  }
;
  registrationProperties.registerRendererFor(renderer,LocalizedString.class);
  registrationProperties.configure(""String_Node_Str"",FIELDS,SELECT_ACTIONS);
  registrationProperties.getUIPageIterator().setId(REGISTRATION_PROPERTIES_ITERATOR);
  registrationProperties.getUIPageIterator().setRendered(false);
  addChild(registrationProperties.getUIPageIterator());
  init(parent.getService().getConfiguration().getRegistrationRequirements());
  UIPopupWindow popup=addChild(UIPopupWindow.class,null,null);
  popup.setWindowSize(400,300);
  UIWsrpProducerPropertyEditor propertyForm=createUIComponent(UIWsrpProducerPropertyEditor.class,null,""String_Node_Str"");
  popup.setUIComponent(propertyForm);
  popup.setRendered(false);
}","public UIWsrpRegistrationDetails() throws Exception {
  policy=new UIFormStringInput(POLICY_CLASS,POLICY_CLASS,null);
  addUIFormInput(policy);
  validator=new UIFormStringInput(VALIDATOR_CLASS,VALIDATOR_CLASS,null);
  addUIFormInput(validator);
  registrationProperties=addChild(UIGrid.class,REGISTRATION_PROPERTIES,REGISTRATION_PROPERTIES);
  ValueRenderer<LocalizedString> renderer=new ValueRenderer<LocalizedString>(){
    @Override public String render(    LocalizedString value){
      return value.getValue();
    }
  }
;
  registrationProperties.registerRendererFor(renderer,LocalizedString.class);
  registrationProperties.configure(""String_Node_Str"",FIELDS,SELECT_ACTIONS);
  registrationProperties.getUIPageIterator().setId(REGISTRATION_PROPERTIES_ITERATOR);
  registrationProperties.getUIPageIterator().setRendered(false);
  addChild(registrationProperties.getUIPageIterator());
  init(getService().getConfiguration().getRegistrationRequirements());
  UIPopupWindow popup=addChild(UIPopupWindow.class,null,null);
  popup.setWindowSize(400,300);
  UIWsrpProducerPropertyEditor propertyForm=createUIComponent(UIWsrpProducerPropertyEditor.class,null,""String_Node_Str"");
  popup.setUIComponent(propertyForm);
  popup.setRendered(false);
}",0.9236760124610592
9945,"private void init() throws Exception {
  ProducerConfiguration configuration=configService.getConfiguration();
  ProducerRegistrationRequirements registrationRequirements=configuration.getRegistrationRequirements();
  getUIFormCheckBoxInput(REG_REQUIRED_FOR_DESCRIPTION).setValue(registrationRequirements.isRegistrationRequiredForFullDescription());
  getUIFormCheckBoxInput(STRICT_MODE).setValue(configuration.isUsingStrictMode());
  boolean registrationRequired=registrationRequirements.isRegistrationRequired();
  getUIFormCheckBoxInput(REQUIRES_REGISTRATION).setValue(registrationRequired);
  if (registrationDetails != null) {
    removeChild(registrationDetails.getClass());
  }
  if (registrationRequired) {
    registrationDetails=new UIWSRPFormInputSet(REGISTRATION_DETAILS);
    UIFormInputBase<String> policyInput=new UIFormStringInput(POLICY_CLASS,POLICY_CLASS,null);
    addUIFormInput(policyInput);
    RegistrationPolicy policy=registrationRequirements.getPolicy();
    String policyClassName=policy.getClass().getName();
    policyInput.setValue(policyClassName);
    if (ProducerRegistrationRequirements.DEFAULT_POLICY_CLASS_NAME.equals(policyClassName)) {
      UIFormInputBase<String> validatorInput=new UIFormStringInput(VALIDATOR_CLASS,VALIDATOR_CLASS,null);
      registrationDetails.addUIFormInput(validatorInput);
      DefaultRegistrationPolicy defaultPolicy=(DefaultRegistrationPolicy)policy;
      validatorInput.setValue(defaultPolicy.getValidator().getClass().getName());
    }
    Map<QName,RegistrationPropertyDescription> regProps=configuration.getRegistrationRequirements().getRegistrationProperties();
    UIGrid uiGrid=registrationDetails.addChild(UIGrid.class,""String_Node_Str"",null);
    uiGrid.configure(""String_Node_Str"",FIELDS,SELECT_ACTIONS);
    uiGrid.getUIPageIterator().setId(""String_Node_Str"");
    addChild(uiGrid.getUIPageIterator());
    uiGrid.getUIPageIterator().setRendered(false);
    LazyPageList propertyList=createPageList(getPropertyList(regProps));
    uiGrid.getUIPageIterator().setPageList(propertyList);
    addUIFormInput(registrationDetails);
    registrationDetails.setRendered(true);
  }
}","private void init() throws Exception {
  ProducerConfiguration configuration=configService.getConfiguration();
  ProducerRegistrationRequirements registrationRequirements=configuration.getRegistrationRequirements();
  regReqForDesc.setValue(registrationRequirements.isRegistrationRequiredForFullDescription());
  strictMode.setValue(configuration.isUsingStrictMode());
  boolean registrationRequired=registrationRequirements.isRegistrationRequired();
  regRequired.setValue(registrationRequired);
  if (registrationRequired) {
    registrationDetails.setRendered(true);
    RegistrationPolicy policy=registrationRequirements.getPolicy();
    String policyClassName=policy.getClass().getName();
    this.policy.setValue(policyClassName);
    if (ProducerRegistrationRequirements.DEFAULT_POLICY_CLASS_NAME.equals(policyClassName)) {
      DefaultRegistrationPolicy defaultPolicy=(DefaultRegistrationPolicy)policy;
      validator.setValue(defaultPolicy.getValidator().getClass().getName());
      validator.setRendered(true);
    }
 else {
      validator.setRendered(false);
    }
    Map<QName,RegistrationPropertyDescription> regProps=configuration.getRegistrationRequirements().getRegistrationProperties();
    registrationProperties.getUIPageIterator().setPageList(createPageList(getPropertyList(regProps)));
  }
 else {
    registrationDetails.setRendered(false);
  }
}",0.3079104054437199
9946,"public void execute(Event<UIWsrpProducerOverview> event) throws Exception {
  UIWsrpProducerOverview wsrpProducerOverview=event.getSource();
  UIPopupWindow popup=wsrpProducerOverview.getChild(UIPopupWindow.class);
  UIWsrpProducerPropertyEditor editor=(UIWsrpProducerPropertyEditor)popup.getUIComponent();
  editor.setRegistrationPropertyDescription(null);
  popup.setRendered(true);
  popup.setShow(true);
  popup.setShowCloseButton(true);
}","public void execute(Event<UIFormCheckBoxInput> event) throws Exception {
  UIFormCheckBoxInput source=event.getSource();
  UIWsrpProducerEditor parent=source.getAncestorOfType(UIWsrpProducerEditor.class);
  parent.init();
  event.getRequestContext().addUIComponentToUpdateByAjax(parent);
}",0.1885245901639344
9947,"public UIWsrpProducerEditor() throws Exception {
  addUIFormInput(new UIFormCheckBoxInput(REG_REQUIRED_FOR_DESCRIPTION,REG_REQUIRED_FOR_DESCRIPTION,null));
  addUIFormInput(new UIFormCheckBoxInput(STRICT_MODE,STRICT_MODE,null));
  addUIFormInput(new UIFormCheckBoxInput(REQUIRES_REGISTRATION,REQUIRES_REGISTRATION,null));
  UIPopupWindow popup=addChild(UIPopupWindow.class,null,null);
  popup.setWindowSize(400,300);
  UIWsrpProducerPropertyEditor propertyForm=createUIComponent(UIWsrpProducerPropertyEditor.class,null,""String_Node_Str"");
  popup.setUIComponent(propertyForm);
  popup.setRendered(false);
}","public UIWsrpProducerEditor() throws Exception {
  configService=Util.getUIPortalApplication().getApplicationComponent(ProducerConfigurationService.class);
  regReqForDesc=new UIFormCheckBoxInput(REG_REQUIRED_FOR_DESCRIPTION,REG_REQUIRED_FOR_DESCRIPTION,null);
  addUIFormInput(regReqForDesc);
  strictMode=new UIFormCheckBoxInput(STRICT_MODE,STRICT_MODE,null);
  addUIFormInput(strictMode);
  regRequired=new UIFormCheckBoxInput<Boolean>(REQUIRES_REGISTRATION,REQUIRES_REGISTRATION,null);
  regRequired.setOnChange(""String_Node_Str"");
  addUIFormInput(regRequired);
  setActions(new String[]{});
  registrationDetails=new UIWSRPFormInputSet(REGISTRATION_DETAILS);
  addUIFormInput(registrationDetails);
  policy=new UIFormStringInput(POLICY_CLASS,POLICY_CLASS,null);
  registrationDetails.addUIFormInput(policy);
  validator=new UIFormStringInput(VALIDATOR_CLASS,VALIDATOR_CLASS,null);
  registrationDetails.addUIFormInput(validator);
  registrationProperties=registrationDetails.addChild(UIGrid.class,REGISTRATION_PROPERTIES,null);
  registrationProperties.configure(""String_Node_Str"",FIELDS,SELECT_ACTIONS);
  registrationProperties.getUIPageIterator().setId(REGISTRATION_PROPERTIES_ITERATOR);
  registrationDetails.addChild(registrationProperties.getUIPageIterator());
  registrationProperties.getUIPageIterator().setRendered(false);
  init();
  UIPopupWindow popup=addChild(UIPopupWindow.class,null,null);
  popup.setWindowSize(400,300);
  UIWsrpProducerPropertyEditor propertyForm=createUIComponent(UIWsrpProducerPropertyEditor.class,null,""String_Node_Str"");
  popup.setUIComponent(propertyForm);
  popup.setRendered(false);
}",0.5272564789991063
9948,"public UIWsrpProducerOverview() throws Exception {
  producerForm=createUIComponent(UIWsrpProducerEditor.class,null,""String_Node_Str"");
  producerForm.setConfigService(getProducerConfigurationService());
  addChild(producerForm);
}","public UIWsrpProducerOverview() throws Exception {
  producerForm=createUIComponent(UIWsrpProducerEditor.class,null,""String_Node_Str"");
  addChild(producerForm);
}",0.8274111675126904
9949,"private void init() throws Exception {
  ProducerConfiguration configuration=configService.getConfiguration();
  ProducerRegistrationRequirements registrationRequirements=configuration.getRegistrationRequirements();
  regReqForDesc.setValue(registrationRequirements.isRegistrationRequiredForFullDescription());
  strictMode.setValue(configuration.isUsingStrictMode());
  boolean registrationRequired=registrationRequirements.isRegistrationRequired();
  regRequired.setValue(registrationRequired);
  if (registrationRequired) {
    registrationDetails.setRendered(true);
    RegistrationPolicy policy=registrationRequirements.getPolicy();
    String policyClassName=policy.getClass().getName();
    this.policy.setValue(policyClassName);
    if (ProducerRegistrationRequirements.DEFAULT_POLICY_CLASS_NAME.equals(policyClassName)) {
      DefaultRegistrationPolicy defaultPolicy=(DefaultRegistrationPolicy)policy;
      validator.setValue(defaultPolicy.getValidator().getClass().getName());
      validator.setRendered(true);
    }
 else {
      validator.setRendered(false);
    }
    Map<QName,RegistrationPropertyDescription> regProps=configuration.getRegistrationRequirements().getRegistrationProperties();
    registrationProperties.getUIPageIterator().setPageList(createPageList(getPropertyList(regProps)));
  }
 else {
    registrationDetails.setRendered(false);
  }
}","private void init() throws Exception {
  ProducerConfiguration configuration=configService.getConfiguration();
  ProducerRegistrationRequirements registrationRequirements=configuration.getRegistrationRequirements();
  regReqForDesc.setValue(registrationRequirements.isRegistrationRequiredForFullDescription());
  strictMode.setValue(configuration.isUsingStrictMode());
  boolean registrationRequired=registrationRequirements.isRegistrationRequired();
  regRequired.setValue(registrationRequired);
  if (registrationRequired) {
    registrationDetails.setRendered(true);
    RegistrationPolicy policy=registrationRequirements.getPolicy();
    String policyClassName=policy.getClass().getName();
    this.policy.setValue(policyClassName);
    if (ProducerRegistrationRequirements.DEFAULT_POLICY_CLASS_NAME.equals(policyClassName)) {
      DefaultRegistrationPolicy defaultPolicy=(DefaultRegistrationPolicy)policy;
      validator.setValue(defaultPolicy.getValidator().getClass().getName());
      validator.setRendered(true);
    }
 else {
      validator.setRendered(false);
    }
  }
 else {
    registrationDetails.setRendered(false);
  }
}",0.8687350835322196
9950,"public UIWsrpProducerEditor() throws Exception {
  configService=Util.getUIPortalApplication().getApplicationComponent(ProducerConfigurationService.class);
  regReqForDesc=new UIFormCheckBoxInput(REG_REQUIRED_FOR_DESCRIPTION,REG_REQUIRED_FOR_DESCRIPTION,null);
  addUIFormInput(regReqForDesc);
  strictMode=new UIFormCheckBoxInput(STRICT_MODE,STRICT_MODE,null);
  addUIFormInput(strictMode);
  regRequired=new UIFormCheckBoxInput<Boolean>(REQUIRES_REGISTRATION,REQUIRES_REGISTRATION,null);
  regRequired.setOnChange(""String_Node_Str"");
  addUIFormInput(regRequired);
  setActions(new String[]{});
  registrationDetails=new UIWSRPFormInputSet(REGISTRATION_DETAILS);
  addUIFormInput(registrationDetails);
  policy=new UIFormStringInput(POLICY_CLASS,POLICY_CLASS,null);
  registrationDetails.addUIFormInput(policy);
  validator=new UIFormStringInput(VALIDATOR_CLASS,VALIDATOR_CLASS,null);
  registrationDetails.addUIFormInput(validator);
  registrationProperties=registrationDetails.addChild(UIGrid.class,REGISTRATION_PROPERTIES,null);
  registrationProperties.configure(""String_Node_Str"",FIELDS,SELECT_ACTIONS);
  registrationProperties.getUIPageIterator().setId(REGISTRATION_PROPERTIES_ITERATOR);
  registrationDetails.addChild(registrationProperties.getUIPageIterator());
  registrationProperties.getUIPageIterator().setRendered(false);
  init();
  UIPopupWindow popup=addChild(UIPopupWindow.class,null,null);
  popup.setWindowSize(400,300);
  UIWsrpProducerPropertyEditor propertyForm=createUIComponent(UIWsrpProducerPropertyEditor.class,null,""String_Node_Str"");
  popup.setUIComponent(propertyForm);
  popup.setRendered(false);
}","public UIWsrpProducerEditor() throws Exception {
  configService=Util.getUIPortalApplication().getApplicationComponent(ProducerConfigurationService.class);
  regReqForDesc=new UIFormCheckBoxInput(REG_REQUIRED_FOR_DESCRIPTION,REG_REQUIRED_FOR_DESCRIPTION,null);
  addUIFormInput(regReqForDesc);
  strictMode=new UIFormCheckBoxInput(STRICT_MODE,STRICT_MODE,null);
  addUIFormInput(strictMode);
  regRequired=new UIFormCheckBoxInput<Boolean>(REQUIRES_REGISTRATION,REQUIRES_REGISTRATION,null);
  regRequired.setOnChange(""String_Node_Str"");
  addUIFormInput(regRequired);
  setActions(new String[]{});
  registrationDetails=new UIWSRPFormInputSet(REGISTRATION_DETAILS);
  addUIFormInput(registrationDetails);
  policy=new UIFormStringInput(POLICY_CLASS,POLICY_CLASS,null);
  registrationDetails.addUIFormInput(policy);
  validator=new UIFormStringInput(VALIDATOR_CLASS,VALIDATOR_CLASS,null);
  registrationDetails.addUIFormInput(validator);
  init();
}",0.7305157037611477
9951,"private void handle(ServletContext scontext,URL gadgetsURL){
  ChromatticLifeCycle lifeCycle=gadgetRegistryService.getChromatticLifeCycle();
  SessionContext context=lifeCycle.openContext();
  InputStream in;
  try {
    in=gadgetsURL.openStream();
    DocumentBuilder db=DocumentBuilderFactory.newInstance().newDocumentBuilder();
    Document docXML=db.parse(in);
    NodeList nodeList=docXML.getElementsByTagName(""String_Node_Str"");
    for (int i=0; i < nodeList.getLength(); i++) {
      Element gadgetElement=(Element)nodeList.item(i);
      String gadgetName=gadgetElement.getAttribute(""String_Node_Str"");
      log.info(""String_Node_Str"" + gadgetName);
      Element pathElt=XMLTools.getUniqueChild(gadgetElement,""String_Node_Str"",false);
      if (pathElt != null) {
        String path=XMLTools.asString(pathElt,true);
        ServletLocalImporter importer=new ServletLocalImporter(gadgetName,gadgetRegistryService.getRegistry(),path,scontext,true);
        importer.doImport();
      }
 else {
        Element urlElt=XMLTools.getUniqueChild(gadgetElement,""String_Node_Str"",false);
        if (urlElt != null) {
          String url=XMLTools.asString(urlElt,true);
          ServletLocalImporter importer=new ServletLocalImporter(gadgetName,gadgetRegistryService.getRegistry(),url,scontext,false);
          importer.doImport();
        }
      }
    }
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + gadgetsURL,e);
  }
 finally {
    lifeCycle.closeContext(true);
  }
}","private void handle(ServletContext scontext,URL gadgetsURL){
  ChromatticLifeCycle lifeCycle=gadgetRegistryService.getChromatticLifeCycle();
  SessionContext context=lifeCycle.openContext();
  InputStream in;
  try {
    in=gadgetsURL.openStream();
    DocumentBuilder db=DocumentBuilderFactory.newInstance().newDocumentBuilder();
    Document docXML=db.parse(in);
    NodeList nodeList=docXML.getElementsByTagName(""String_Node_Str"");
    for (int i=0; i < nodeList.getLength(); i++) {
      Element gadgetElement=(Element)nodeList.item(i);
      String gadgetName=gadgetElement.getAttribute(""String_Node_Str"");
      log.info(""String_Node_Str"" + gadgetName);
      Element pathElt=XMLTools.getUniqueChild(gadgetElement,""String_Node_Str"",false);
      if (pathElt != null) {
        String path=XMLTools.asString(pathElt,true);
        ServletLocalImporter importer=new ServletLocalImporter(gadgetName,gadgetRegistryService.getRegistry(),path,scontext,true);
        importer.doImport();
      }
 else {
        Element urlElt=XMLTools.getUniqueChild(gadgetElement,""String_Node_Str"",false);
        if (urlElt != null) {
          String url=XMLTools.asString(urlElt,true);
          ServletLocalImporter importer=new ServletLocalImporter(gadgetName,gadgetRegistryService.getRegistry(),url,scontext,false);
          importer.doImport();
        }
      }
    }
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + gadgetsURL,e);
  }
 finally {
    lifeCycle.closeContext(context,true);
  }
}",0.9973297730307076
9952,"public void saveSource(Gadget gadget,Source source) throws Exception {
  if (gadget == null) {
    throw new NullPointerException();
  }
  if (source == null) {
    throw new NullPointerException();
  }
  GadgetDefinition def=gadgetRegistryService.getRegistry().getGadget(gadget.getName());
  if (def == null) {
    throw new IllegalStateException(""String_Node_Str"" + gadget.getName());
  }
  GadgetData data=def.getData();
  if (data instanceof LocalGadgetData) {
    LocalGadgetData localData=(LocalGadgetData)data;
    localData.setSource(source.getTextContent());
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}","public void saveSource(Gadget gadget,Source source) throws Exception {
  if (gadget == null) {
    throw new NullPointerException();
  }
  if (source == null) {
    throw new NullPointerException();
  }
  GadgetRegistry registry=gadgetRegistryService.getRegistry();
  GadgetDefinition def=registry.getGadget(gadget.getName());
  GadgetData data=def.getData();
  if (data instanceof LocalGadgetData) {
    GadgetSpec spec=new GadgetSpec(Uri.parse(""String_Node_Str""),source.getTextContent());
    ModulePrefs prefs=spec.getModulePrefs();
    String description=prefs.getDescription();
    String thumbnail=prefs.getThumbnail().toString();
    String title=getGadgetTitle(prefs,gadget.getName());
    String referenceURL=prefs.getTitleUrl().toString();
    def.setDescription(description);
    def.setThumbnail(thumbnail);
    def.setTitle(title);
    def.setReferenceURL(referenceURL);
    LocalGadgetData localData=(LocalGadgetData)data;
    localData.setSource(source.getTextContent());
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}",0.3210310486233158
9953,"/** 
 * Rebuild UIPortal with updated UserPortalConfig
 * @param uiPortal
 * @param portalConfig
 * @throws Exception
 */
private void rebuildUIPortal(UIPortal uiPortal,UserPortalConfig portalConfig,boolean showMaxWindow) throws Exception {
  PageNode backupSelectedNode=uiPortal.getSelectedNode();
  PageNavigation backupSelectedNavigation=uiPortal.getSelectedNavigation();
  List<PageNode> backupSelectedPaths=uiPortal.getSelectedPaths();
  uiPortal.getChildren().clear();
  PortalDataMapper.toUIPortal(uiPortal,portalConfig);
  uiPortal.setSelectedNode(backupSelectedNode);
  uiPortal.setSelectedNavigation(backupSelectedNavigation);
  uiPortal.setSelectedPaths(backupSelectedPaths);
  UIPageBody uiPageBody=uiPortal.findFirstComponentOfType(UIPageBody.class);
  UIPage uiPage=(UIPage)uiPageBody.getUIComponent();
  uiPage.setShowMaxWindow(showMaxWindow);
  if (showMaxWindow) {
    uiPortal.setMaximizedUIComponent(uiPage);
  }
 else {
    UIComponent uiPortalMaxComponent=uiPortal.getMaximizedUIComponent();
    if (uiPortalMaxComponent instanceof UIPage) {
      uiPortal.setMaximizedUIComponent(null);
    }
    UIComponent pageBodyMaxComponent=uiPageBody.getMaximizedUIComponent();
    if (pageBodyMaxComponent instanceof UIPage) {
      uiPageBody.setMaximizedUIComponent(null);
    }
  }
}","/** 
 * Rebuild UIPortal with updated UserPortalConfig
 * @param uiPortal
 * @param portalConfig
 * @throws Exception
 */
private void rebuildUIPortal(UIPortal uiPortal,UserPortalConfig portalConfig) throws Exception {
  PageNode backupSelectedNode=uiPortal.getSelectedNode();
  PageNavigation backupSelectedNavigation=uiPortal.getSelectedNavigation();
  List<PageNode> backupSelectedPaths=uiPortal.getSelectedPaths();
  uiPortal.getChildren().clear();
  PortalDataMapper.toUIPortal(uiPortal,portalConfig);
  uiPortal.setSelectedNode(backupSelectedNode);
  uiPortal.setSelectedNavigation(backupSelectedNavigation);
  uiPortal.setSelectedPaths(backupSelectedPaths);
}",0.6778625954198473
9954,"/** 
 * Update the layout of UIPortal if both ownerType and ownerId of navigation are changed
 * @param uiPortal
 * @param formerNav
 * @param newNav
 * @param uiPortalApp
 * @throws Exception
 */
private void updateLayout(UIPortal uiPortal,PageNavigation formerNav,PageNavigation newNav,UIPortalApplication uiPortalApp) throws Exception {
  if (formerNav == null || newNav == null) {
    return;
  }
  String newOwnerType=newNav.getOwnerType();
  String newOwnerId=newNav.getOwnerId();
  String formerOwnerType=formerNav.getOwnerType();
  String formerOwnerId=formerNav.getOwnerId();
  if (newOwnerId.equals(formerOwnerId) && formerOwnerType.equals(newOwnerType)) {
    return;
  }
  DataStorage storage=uiPortalApp.getApplicationComponent(DataStorage.class);
  PortalConfig pConfig=storage.getPortalConfig(newOwnerType,newOwnerId);
  Container container=pConfig.getPortalLayout();
  if (container != null) {
    boolean showMaxWindow=false;
    try {
      PageNode selectedNode=uiPortal.getSelectedNode();
      Page displayedPage=storage.getPage(selectedNode.getPageReference());
      showMaxWindow=displayedPage.isShowMaxWindow();
    }
 catch (    Exception ex) {
    }
    UserPortalConfig portalConfig=uiPortalApp.getUserPortalConfig();
    portalConfig.setPortal(pConfig);
    rebuildUIPortal(uiPortal,portalConfig,showMaxWindow);
  }
}","/** 
 * Update the layout of UIPortal if both ownerType and ownerId of navigation are changed
 * @param uiPortal
 * @param formerNav
 * @param newNav
 * @param uiPortalApp
 * @throws Exception
 */
private void updateLayout(UIPortal uiPortal,PageNavigation formerNav,PageNavigation newNav,UIPortalApplication uiPortalApp) throws Exception {
  if (formerNav == null || newNav == null) {
    return;
  }
  String newOwnerType=newNav.getOwnerType();
  String newOwnerId=newNav.getOwnerId();
  String formerOwnerType=formerNav.getOwnerType();
  String formerOwnerId=formerNav.getOwnerId();
  if (newOwnerId.equals(formerOwnerId) && formerOwnerType.equals(newOwnerType)) {
    return;
  }
  DataStorage storage=uiPortalApp.getApplicationComponent(DataStorage.class);
  PortalConfig pConfig=storage.getPortalConfig(newOwnerType,newOwnerId);
  Container container=pConfig.getPortalLayout();
  if (container != null) {
    UserPortalConfig portalConfig=uiPortalApp.getUserPortalConfig();
    portalConfig.setPortal(pConfig);
    rebuildUIPortal(uiPortal,portalConfig);
  }
}",0.8834508502695977
9955,"public void setPageBody(PageNode pageNode,UIPortal uiPortal) throws Exception {
  WebuiRequestContext context=Util.getPortalRequestContext();
  ExoContainer appContainer=context.getApplication().getApplicationServiceContainer();
  UserPortalConfigService userPortalConfigService=(UserPortalConfigService)appContainer.getComponentInstanceOfType(UserPortalConfigService.class);
  Page page=null;
  UIPage uiPage=null;
  if (pageNode != null) {
    try {
      if (pageNode.getPageReference() != null) {
        page=userPortalConfigService.getPage(pageNode.getPageReference(),context.getRemoteUser());
      }
    }
 catch (    Exception e) {
      UIPortalApplication uiApp=getAncestorOfType(UIPortalApplication.class);
      uiApp.addMessage(new ApplicationMessage(e.getMessage(),new Object[]{}));
    }
  }
  uiPortal.setMaximizedUIComponent(null);
  if (page != null) {
    if (Page.DESKTOP_PAGE.equals(page.getFactoryId())) {
      uiPage=createUIComponent(context,UIDesktopPage.class,null,null);
    }
 else {
      uiPage=createUIComponent(context,UIPage.class,null,null);
    }
    PortalDataMapper.toUIPage(uiPage,page);
    if (uiPage.isShowMaxWindow())     uiPortal.setMaximizedUIComponent(uiPage);
  }
  setUIComponent(uiPage);
}","public void setPageBody(PageNode pageNode,UIPortal uiPortal) throws Exception {
  WebuiRequestContext context=Util.getPortalRequestContext();
  ExoContainer appContainer=context.getApplication().getApplicationServiceContainer();
  UserPortalConfigService userPortalConfigService=(UserPortalConfigService)appContainer.getComponentInstanceOfType(UserPortalConfigService.class);
  Page page=null;
  UIPage uiPage=null;
  if (pageNode != null) {
    try {
      if (pageNode.getPageReference() != null) {
        page=userPortalConfigService.getPage(pageNode.getPageReference(),context.getRemoteUser());
      }
    }
 catch (    Exception e) {
      UIPortalApplication uiApp=getAncestorOfType(UIPortalApplication.class);
      uiApp.addMessage(new ApplicationMessage(e.getMessage(),new Object[]{}));
    }
  }
  uiPortal.setMaximizedUIComponent(null);
  if (page != null) {
    if (Page.DESKTOP_PAGE.equals(page.getFactoryId())) {
      uiPage=createUIComponent(context,UIDesktopPage.class,null,null);
    }
 else {
      uiPage=createUIComponent(context,UIPage.class,null,null);
    }
    PortalDataMapper.toUIPage(uiPage,page);
    if (uiPage.isShowMaxWindow()) {
      uiPortal.setMaximizedUIComponent(uiPage);
    }
 else {
      UIComponent maximizedComponent=uiPortal.getMaximizedUIComponent();
      if (maximizedComponent != null && maximizedComponent instanceof UIPage) {
        uiPortal.setMaximizedUIComponent(null);
      }
      UIComponent maximizedComponentInPageBody=this.getMaximizedUIComponent();
      if (maximizedComponentInPageBody != null && maximizedComponentInPageBody instanceof UIPage) {
        this.setMaximizedUIComponent(null);
      }
    }
  }
  setUIComponent(uiPage);
}",0.8273283480625425
9956,"public void setNavigation(List<PageNavigation> navs) throws Exception {
  navigations=navs;
  selectedPaths_=new ArrayList<PageNode>();
  if (navigations == null || navigations.size() < 1)   return;
  PageNavigation pNav=null;
  for (  PageNavigation nav : navs) {
    if (nav.getNodes() != null && nav.getNodes().size() > 0) {
      pNav=nav;
      break;
    }
  }
  if (pNav == null)   return;
  selectedNode_=pNav.getNodes().get(0);
  selectedPaths_.add(selectedNode_);
  UIPageBody uiPageBody=findFirstComponentOfType(UIPageBody.class);
  if (uiPageBody == null)   return;
  uiPageBody.setPageBody(selectedNode_,this);
  UIPortalApplication uiApp=Util.getUIPortalApplication();
  refreshNavigation(uiApp.getLocale());
}","public void setNavigation(List<PageNavigation> navs) throws Exception {
  navigations=navs;
  selectedPaths_=new ArrayList<PageNode>();
  if (navigations == null || navigations.size() < 1)   return;
  PageNavigation pNav=null;
  for (  PageNavigation nav : navs) {
    if (nav.getNodes() != null && nav.getNodes().size() > 0) {
      pNav=nav;
      break;
    }
  }
  if (pNav == null)   return;
  if (selectedNode_ == null) {
    selectedNode_=pNav.getNodes().get(0);
    selectedPaths_.add(selectedNode_);
  }
  UIPageBody uiPageBody=findFirstComponentOfType(UIPageBody.class);
  if (uiPageBody == null)   return;
  uiPageBody.setPageBody(selectedNode_,this);
  UIPortalApplication uiApp=Util.getUIPortalApplication();
  refreshNavigation(uiApp.getLocale());
}",0.9737726967047748
9957,"/** 
 * Rebuild UIPortal with updated UserPortalConfig
 * @param uiPortal
 * @param portalConfig
 * @throws Exception
 */
private void rebuildUIPortal(UIPortal uiPortal,UserPortalConfig portalConfig,boolean showMaxWindow) throws Exception {
  PageNode backupSelectedNode=uiPortal.getSelectedNode();
  PageNavigation backupSelectedNavigation=uiPortal.getSelectedNavigation();
  List<PageNode> backupSelectedPaths=uiPortal.getSelectedPaths();
  uiPortal.getChildren().clear();
  PortalDataMapper.toUIPortal(uiPortal,portalConfig);
  uiPortal.setSelectedNode(backupSelectedNode);
  uiPortal.setSelectedNavigation(backupSelectedNavigation);
  uiPortal.setSelectedPaths(backupSelectedPaths);
  UIPageBody uiPageBody=uiPortal.findFirstComponentOfType(UIPageBody.class);
  UIPage uiPage=(UIPage)uiPageBody.getUIComponent();
  uiPage.setShowMaxWindow(showMaxWindow);
  if (showMaxWindow) {
    uiPortal.setMaximizedUIComponent(uiPage);
  }
 else {
    UIComponent showedMaxComponent=uiPortal.getMaximizedUIComponent();
    if (showedMaxComponent instanceof UIPage) {
      uiPortal.setMaximizedUIComponent(null);
    }
  }
}","/** 
 * Rebuild UIPortal with updated UserPortalConfig
 * @param uiPortal
 * @param portalConfig
 * @throws Exception
 */
private void rebuildUIPortal(UIPortal uiPortal,UserPortalConfig portalConfig,boolean showMaxWindow) throws Exception {
  PageNode backupSelectedNode=uiPortal.getSelectedNode();
  PageNavigation backupSelectedNavigation=uiPortal.getSelectedNavigation();
  List<PageNode> backupSelectedPaths=uiPortal.getSelectedPaths();
  uiPortal.getChildren().clear();
  PortalDataMapper.toUIPortal(uiPortal,portalConfig);
  uiPortal.setSelectedNode(backupSelectedNode);
  uiPortal.setSelectedNavigation(backupSelectedNavigation);
  uiPortal.setSelectedPaths(backupSelectedPaths);
  UIPageBody uiPageBody=uiPortal.findFirstComponentOfType(UIPageBody.class);
  UIPage uiPage=(UIPage)uiPageBody.getUIComponent();
  uiPage.setShowMaxWindow(showMaxWindow);
  if (showMaxWindow) {
    uiPortal.setMaximizedUIComponent(uiPage);
  }
 else {
    UIComponent uiPortalMaxComponent=uiPortal.getMaximizedUIComponent();
    if (uiPortalMaxComponent instanceof UIPage) {
      uiPortal.setMaximizedUIComponent(null);
    }
    UIComponent pageBodyMaxComponent=uiPageBody.getMaximizedUIComponent();
    if (pageBodyMaxComponent instanceof UIPage) {
      uiPageBody.setMaximizedUIComponent(null);
    }
  }
}",0.9142857142857144
9958,"private String scriptRemovingComponent(String componentId,String componentType){
  StringBuffer buffer=new StringBuffer();
  buffer.append(""String_Node_Str"");
  buffer.append(componentType);
  buffer.append(""String_Node_Str"");
  buffer.append(componentId);
  buffer.append(""String_Node_Str"");
  return buffer.toString();
}","private String scriptRemovingComponent(String componentId,String prefix){
  StringBuffer buffer=new StringBuffer();
  buffer.append(""String_Node_Str"");
  buffer.append(prefix);
  buffer.append(componentId);
  buffer.append(""String_Node_Str"");
  return buffer.toString();
}",0.4781144781144781
9959,"/** 
 * Returns the top ancestor( of type org.exoplatform.portal.webui.container.UIContainer but not of type UIPortal) of a given container
 */
private static org.exoplatform.portal.webui.container.UIContainer getTopBlockContainer(org.exoplatform.portal.webui.container.UIContainer container){
  if (container instanceof UIPortal) {
    return null;
  }
  org.exoplatform.portal.webui.container.UIContainer topAncestor=container;
  org.exoplatform.portal.webui.container.UIContainer intermediateCont;
  try {
    intermediateCont=topAncestor.getParent();
    while (intermediateCont != null && !(intermediateCont instanceof UIPortal)) {
      topAncestor=intermediateCont;
      intermediateCont=topAncestor.getParent();
    }
  }
 catch (  ClassCastException ex) {
  }
  return topAncestor;
}","/** 
 * Returns the top ancestor( of type org.exoplatform.portal.webui.container.UIContainer but not of type UIPortal or UIPage) of a given container
 */
private static org.exoplatform.portal.webui.container.UIContainer getTopBlockContainer(org.exoplatform.portal.webui.container.UIContainer container){
  if (container instanceof UIPortal || container instanceof UIPage) {
    return null;
  }
  org.exoplatform.portal.webui.container.UIContainer topAncestor=container;
  org.exoplatform.portal.webui.container.UIContainer intermediateCont;
  try {
    intermediateCont=topAncestor.getParent();
    while (intermediateCont != null && !(intermediateCont instanceof UIPortal) && !(intermediateCont instanceof UIPage)) {
      topAncestor=intermediateCont;
      intermediateCont=topAncestor.getParent();
    }
  }
 catch (  ClassCastException ex) {
  }
  return topAncestor;
}",0.9508393285371702
9960,"/** 
 * <p>Execute the task with a session. The method attempts first to get a current session and if no such session is found then a session will be created for the scope of the method.</p>
 * @param task the task to execute
 * @throws Exception any exception thrown by the task
 */
private <T extends POMTask>T execute(T task) throws Exception {
  POMSession session=POMSessionManager.getSession();
  if (session == null) {
    session=pomMgr.openSession();
    try {
      executor.execute(session,task);
    }
  finally {
      pomMgr.closeSession(true);
    }
  }
 else {
    session.execute(task);
  }
  return task;
}","/** 
 * <p>Execute the task with a session. The method attempts first to get a current session and if no such session is found then a session will be created for the scope of the method.</p>
 * @param task the task to execute
 * @throws Exception any exception thrown by the task
 */
private <T extends POMTask>T execute(T task) throws Exception {
  POMSession session=POMSessionManager.getSession();
  if (session == null) {
    session=pomMgr.openSession();
    try {
      executor.execute(session,task);
    }
  finally {
      pomMgr.closeSession(true);
    }
  }
 else {
    executor.execute(session,task);
  }
  return task;
}",0.9817024661893397
9961,"private <K extends Serializable,V>void read(POMSession session,CacheableDataTask<K,V> task) throws Exception {
  K key=task.getKey();
  Object o=cache.get(key);
  V v=null;
  if (o != null) {
    Class<V> type=task.getValueType();
    if (type.isInstance(o)) {
      v=type.cast(o);
    }
  }
  if (v != null) {
    task.setValue(v);
  }
 else {
    next.execute(session,task);
    v=task.getValue();
    if (v != null) {
      cache.put(key,v);
    }
  }
}","private <K extends Serializable,V>void read(POMSession session,CacheableDataTask<K,V> task) throws Exception {
  K key=task.getKey();
  Object o=cache.get(key);
  V v=null;
  if (o != null) {
    Class<V> type=task.getValueType();
    if (type.isInstance(o)) {
      v=type.cast(o);
    }
  }
  if (v != null) {
    task.setValue(v);
  }
 else {
    readCount.incrementAndGet();
    super.execute(session,task);
    v=task.getValue();
    if (v != null) {
      cache.put(key,v);
    }
  }
}",0.9535864978902954
9962,"private <K extends Serializable,V>void create(POMSession session,CacheableDataTask<K,V> task) throws Exception {
  next.execute(session,task);
}","private <K extends Serializable,V>void create(POMSession session,CacheableDataTask<K,V> task) throws Exception {
  super.execute(session,task);
}",0.9757785467128028
9963,"public void execute(POMSession session,POMTask task) throws Exception {
  if (task instanceof CacheableDataTask) {
    if (!session.isModified()) {
      CacheableDataTask<?,?> loadTask=(CacheableDataTask<?,?>)task;
switch (loadTask.getAccessMode()) {
case READ:
        read(session,loadTask);
      break;
case CREATE:
    create(session,loadTask);
  break;
case WRITE:
write(session,loadTask);
break;
case DESTROY:
remove(session,loadTask);
break;
default :
throw new UnsupportedOperationException();
}
}
}
 else {
next.execute(session,task);
}
}","public void execute(POMSession session,POMTask task) throws Exception {
  if (task instanceof CacheableDataTask) {
    if (!session.isModified()) {
      CacheableDataTask<?,?> loadTask=(CacheableDataTask<?,?>)task;
switch (loadTask.getAccessMode()) {
case READ:
        read(session,loadTask);
      break;
case CREATE:
    create(session,loadTask);
  break;
case WRITE:
write(session,loadTask);
break;
case DESTROY:
remove(session,loadTask);
break;
default :
throw new UnsupportedOperationException();
}
}
 else {
super.execute(session,task);
}
}
 else {
super.execute(session,task);
}
}",0.9560632688927944
9964,"private <K extends Serializable,V>void write(POMSession session,CacheableDataTask<K,V> task) throws Exception {
  K key=task.getKey();
  cache.remove(key);
  next.execute(session,task);
}","private <K extends Serializable,V>void write(POMSession session,CacheableDataTask<K,V> task) throws Exception {
  K key=task.getKey();
  cache.remove(key);
  super.execute(session,task);
}",0.9813333333333332
9965,"public DataCache(CacheService cacheService,TaskExecutor next){
  this.next=next;
  this.cache=cacheService.getCacheInstance(DataCache.class.getSimpleName());
}","public DataCache(CacheService cacheService,TaskExecutor next){
  super(next);
  this.cache=cacheService.getCacheInstance(DataCache.class.getSimpleName());
}",0.9523809523809524
9966,"private <K extends Serializable,V>void remove(POMSession session,CacheableDataTask<K,V> task) throws Exception {
  K key=task.getKey();
  cache.remove(key);
  next.execute(session,task);
}","private <K extends Serializable,V>void remove(POMSession session,CacheableDataTask<K,V> task) throws Exception {
  K key=task.getKey();
  cache.remove(key);
  super.execute(session,task);
}",0.9814323607427056
9967,"@Override public boolean equals(Object obj){
  if (obj instanceof OwnerKey) {
    OwnerKey that=(OwnerKey)obj;
    return type.equals(that.type) && id.equals(that.id);
  }
  return false;
}","@Override public boolean equals(Object obj){
  if (obj == this) {
    return true;
  }
  if (getClass().isInstance(obj)) {
    OwnerKey that=(OwnerKey)obj;
    return type.equals(that.type) && id.equals(that.id);
  }
  return false;
}",0.8368794326241135
9968,"@Override protected void setUp() throws Exception {
  Listener listener=new Listener(){
    @Override public void onEvent(    Event event) throws Exception {
      events.add(event);
    }
  }
;
  PortalContainer container=PortalContainer.getInstance();
  userPortalConfigSer_=(UserPortalConfigService)container.getComponentInstanceOfType(UserPortalConfigService.class);
  orgService_=(OrganizationService)container.getComponentInstanceOfType(OrganizationService.class);
  idmService=(JBossIDMService)container.getComponentInstanceOfType(JBossIDMService.class);
  mgr=(POMSessionManager)container.getComponentInstanceOfType(POMSessionManager.class);
  authenticator=(Authenticator)container.getComponentInstanceOfType(Authenticator.class);
  listenerService=(ListenerService)container.getComponentInstanceOfType(ListenerService.class);
  events=new LinkedList<Event>();
  storage_=(DataStorage)container.getComponentInstanceOfType(DataStorage.class);
  if (!registered) {
    listenerService.addListener(UserPortalConfigService.CREATE_PAGE_EVENT,listener);
    listenerService.addListener(UserPortalConfigService.REMOVE_PAGE_EVENT,listener);
    listenerService.addListener(UserPortalConfigService.UPDATE_PAGE_EVENT,listener);
    listenerService.addListener(UserPortalConfigService.CREATE_NAVIGATION_EVENT,listener);
    listenerService.addListener(UserPortalConfigService.REMOVE_NAVIGATION_EVENT,listener);
    listenerService.addListener(UserPortalConfigService.UPDATE_NAVIGATION_EVENT,listener);
  }
}","@Override protected void setUp() throws Exception {
  Listener listener=new Listener(){
    @Override public void onEvent(    Event event) throws Exception {
      events.add(event);
    }
  }
;
  PortalContainer container=PortalContainer.getInstance();
  userPortalConfigSer_=(UserPortalConfigService)container.getComponentInstanceOfType(UserPortalConfigService.class);
  orgService_=(OrganizationService)container.getComponentInstanceOfType(OrganizationService.class);
  idmService=(JBossIDMService)container.getComponentInstanceOfType(JBossIDMService.class);
  mgr=(POMSessionManager)container.getComponentInstanceOfType(POMSessionManager.class);
  authenticator=(Authenticator)container.getComponentInstanceOfType(Authenticator.class);
  listenerService=(ListenerService)container.getComponentInstanceOfType(ListenerService.class);
  events=new LinkedList<Event>();
  storage_=(DataStorage)container.getComponentInstanceOfType(DataStorage.class);
  mopStorage=(POMDataStorage)container.getComponentInstanceOfType(POMDataStorage.class);
  if (!registered) {
    listenerService.addListener(UserPortalConfigService.CREATE_PAGE_EVENT,listener);
    listenerService.addListener(UserPortalConfigService.REMOVE_PAGE_EVENT,listener);
    listenerService.addListener(UserPortalConfigService.UPDATE_PAGE_EVENT,listener);
    listenerService.addListener(UserPortalConfigService.CREATE_NAVIGATION_EVENT,listener);
    listenerService.addListener(UserPortalConfigService.REMOVE_NAVIGATION_EVENT,listener);
    listenerService.addListener(UserPortalConfigService.UPDATE_NAVIGATION_EVENT,listener);
  }
}",0.9712810584059374
9969,"@FlexCompatibility(minVersion=""String_Node_Str"") public Integer getSwfVersion(){
  if (swfVersion != null) {
    return swfVersion;
  }
  Artifact global=getGlobalArtifact();
  if (AIR_GLOBAL.equals(global.getArtifactId())) {
    String airVersion=global.getVersion();
    if (VersionUtils.isMinVersionOK(airVersion,""String_Node_Str""))     return 13;
    if (VersionUtils.isMinVersionOK(airVersion,""String_Node_Str""))     return 12;
    if (VersionUtils.isMinVersionOK(airVersion,""String_Node_Str""))     return 11;
    if (VersionUtils.isMinVersionOK(airVersion,""String_Node_Str""))     return 10;
    getLog().warn(""String_Node_Str"" + global);
  }
 else   if (PLAYER_GLOBAL.equals(global.getArtifactId())) {
    String playerVersion=global.getVersion();
    if (VersionUtils.isMinVersionOK(playerVersion,""String_Node_Str""))     return 16;
    if (VersionUtils.isMinVersionOK(playerVersion,""String_Node_Str""))     return 15;
    if (VersionUtils.isMinVersionOK(playerVersion,""String_Node_Str""))     return 14;
    if (VersionUtils.isMinVersionOK(playerVersion,""String_Node_Str""))     return 13;
    if (VersionUtils.isMinVersionOK(playerVersion,""String_Node_Str""))     return 12;
    if (VersionUtils.isMinVersionOK(playerVersion,""String_Node_Str""))     return 11;
    if (VersionUtils.isMinVersionOK(playerVersion,""String_Node_Str""))     return 10;
    if (VersionUtils.isMinVersionOK(playerVersion,""String_Node_Str""))     return 9;
    getLog().warn(""String_Node_Str"" + global);
  }
  return null;
}","@FlexCompatibility(minVersion=""String_Node_Str"") public Integer getSwfVersion(){
  if (swfVersion != null) {
    return swfVersion;
  }
  Artifact global=getGlobalArtifact();
  if (PLAYER_GLOBAL.equals(global.getArtifactId())) {
    String playerVersion=global.getVersion();
    if (VersionUtils.isMinVersionOK(playerVersion,""String_Node_Str""))     return 16;
    if (VersionUtils.isMinVersionOK(playerVersion,""String_Node_Str""))     return 15;
    if (VersionUtils.isMinVersionOK(playerVersion,""String_Node_Str""))     return 14;
    if (VersionUtils.isMinVersionOK(playerVersion,""String_Node_Str""))     return 13;
    if (VersionUtils.isMinVersionOK(playerVersion,""String_Node_Str""))     return 12;
    if (VersionUtils.isMinVersionOK(playerVersion,""String_Node_Str""))     return 11;
    if (VersionUtils.isMinVersionOK(playerVersion,""String_Node_Str""))     return 10;
    if (VersionUtils.isMinVersionOK(playerVersion,""String_Node_Str""))     return 9;
    getLog().warn(""String_Node_Str"" + global);
  }
  return null;
}",0.5680285600952003
9970,"@SuppressWarnings(""String_Node_Str"") public boolean getIsAirProject(){
  return getDependency(groupId(FLEX_GROUP_ID),artifactId(AIR_GLOBAL),type(SWC)) != null;
}","@SuppressWarnings(""String_Node_Str"") public boolean getIsAirProject(){
  return (getDependency(groupId(AIR_GROUP_ID),artifactId(AIR_GLOBAL),type(SWC)) != null) || (getDependency(groupId(FLEX_GROUP_ID),artifactId(AIR_GLOBAL),type(SWC)) != null);
}",0.7911547911547911
9971,"private void copyFolderTemplate(String path) throws MojoExecutionException {
  File source=new File(path);
  if (!source.isAbsolute()) {
    source=new File(project.getBasedir(),path);
  }
  if (!source.exists() || !source.isDirectory()) {
    throw new MojoExecutionException(""String_Node_Str"" + source);
  }
  try {
    FileUtils.copyDirectory(source,templateOutputDirectory);
  }
 catch (  IOException e) {
    throw new MojoExecutionException(""String_Node_Str"" + templateOutputDirectory,e);
  }
}","private void copyFolderTemplate(String path) throws MojoExecutionException {
  File source=new File(path);
  if (!source.isAbsolute()) {
    source=new File(project.getBasedir(),path);
  }
  if (!source.exists() || !source.isDirectory()) {
    throw new MojoExecutionException(""String_Node_Str"" + source);
  }
  try {
    FileUtils.copyDirectoryStructure(source,templateOutputDirectory);
  }
 catch (  IOException e) {
    throw new MojoExecutionException(""String_Node_Str"" + templateOutputDirectory,e);
  }
}",0.9910802775024776
9972,"public IIncludeFile[] getIncludeFile(){
  List<IIncludeFile> files=new ArrayList<IIncludeFile>();
  List<FileSet> patterns=new ArrayList<FileSet>();
  if (includeFiles == null && includeNamespaces == null && includeSources == null && includeClasses == null) {
    patterns.addAll(resources);
  }
 else   if (includeFiles == null) {
    return null;
  }
 else {
    patterns.addAll(includeFiles.getPatterns());
    for (    final String path : includeFiles.getIncludes()) {
      final File file=PathUtil.file(path,getResourcesTargetDirectories());
      files.add(new IIncludeFile(){
        public String name(){
          return path.replace('\\','/');
        }
        public String path(){
          return file.getAbsolutePath();
        }
      }
);
    }
  }
  for (  FileSet pattern : patterns) {
    final DirectoryScanner scan=scan(pattern);
    if (scan == null) {
      continue;
    }
    for (    final String file : scan.getIncludedFiles()) {
      files.add(new IIncludeFile(){
        public String name(){
          return file.replace('\\','/');
        }
        public String path(){
          return PathUtil.file(file,scan.getBasedir()).getAbsolutePath();
        }
      }
);
    }
  }
  return files.toArray(new IIncludeFile[0]);
}","public IIncludeFile[] getIncludeFile(){
  List<IIncludeFile> files=new ArrayList<IIncludeFile>();
  List<FileSet> patterns=new ArrayList<FileSet>();
  if (includeFiles == null && includeNamespaces == null && includeSources == null && includeClasses == null) {
    patterns.addAll(resources);
  }
 else   if (includeFiles == null) {
    return null;
  }
 else {
    patterns.addAll(includeFiles.getPatterns());
    for (    final String path : includeFiles.getIncludes()) {
      final File file=PathUtil.file(path,getResourcesTargetDirectories());
      if (file == null) {
        throw new IllegalStateException(""String_Node_Str"" + path + ""String_Node_Str"");
      }
      files.add(new IIncludeFile(){
        public String name(){
          return path.replace('\\','/');
        }
        public String path(){
          return file.getAbsolutePath();
        }
      }
);
    }
  }
  for (  FileSet pattern : patterns) {
    final DirectoryScanner scan=scan(pattern);
    if (scan == null) {
      continue;
    }
    for (    final String file : scan.getIncludedFiles()) {
      files.add(new IIncludeFile(){
        public String name(){
          return file.replace('\\','/');
        }
        public String path(){
          return PathUtil.file(file,scan.getBasedir()).getAbsolutePath();
        }
      }
);
    }
  }
  return files.toArray(new IIncludeFile[0]);
}",0.9540796963946868
9973,"@SuppressWarnings(""String_Node_Str"") public List<String> getTheme(){
  List<File> themes=new ArrayList<File>();
  Set<Artifact> themeDependencies=getDependencies(anyOf(type(SWC),type(CSS)),scope(THEME));
  themes.addAll(asList(MavenUtils.getFiles(themeDependencies)));
  if (this.themes != null) {
    themes.addAll(asList(files(this.themes,getResourcesTargetDirectories())));
  }
  if (themes.isEmpty()) {
    getLog().warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    configureThemeSparkCss(themes);
    configureThemeHaloSwc(themes);
  }
  return pathsList(themes);
}","@SuppressWarnings(""String_Node_Str"") public List<String> getTheme(){
  List<File> themes=new ArrayList<File>();
  Set<Artifact> themeDependencies=getDependencies(anyOf(type(SWC),type(CSS)),scope(FlexScopes.THEME));
  themes.addAll(asList(MavenUtils.getFiles(themeDependencies)));
  if (this.themes != null) {
    themes.addAll(asList(files(this.themes,getResourcesTargetDirectories())));
  }
  if (themes.isEmpty()) {
    getLog().warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    configureThemeSparkCss(themes);
    configureThemeHaloSwc(themes);
  }
  return pathsList(themes);
}",0.990748528174937
9974,"public Boolean getUseNetwork(){
  return userNetwork;
}","public Boolean getUseNetwork(){
  return useNetwork;
}",0.9908256880733946
9975,"@SuppressWarnings(""String_Node_Str"") public List<String> getTheme(){
  List<String> themes=new ArrayList<String>();
  if (this.themes != null) {
    themes.addAll(PathUtil.pathsList(this.themes));
  }
  themes.addAll(PathUtil.pathsList(MavenUtils.getFiles(getDependencies(anyOf(type(SWC),type(CSS)),scope(THEME)))));
  return themes;
}","@SuppressWarnings(""String_Node_Str"") public List<String> getTheme(){
  List<String> themes=new ArrayList<String>();
  if (this.themes != null) {
    themes.addAll(pathsList(files(this.themes,getResourcesTargetDirectories())));
  }
  themes.addAll(PathUtil.pathsList(MavenUtils.getFiles(getDependencies(anyOf(type(SWC),type(CSS)),scope(THEME)))));
  return themes;
}",0.8714285714285714
9976,"public void execute() throws MojoExecutionException, MojoFailureException {
  if (!PathUtil.existAny(getSourcePath())) {
    getLog().warn(""String_Node_Str"" + Arrays.toString(getSourcePath()));
    return;
  }
  executeCompiler(new MxmlcConfigurationHolder(this,getSourceFile()),true);
  if (getLocalesRuntime() != null) {
    List<Result> results=new ArrayList<Result>();
    for (    String locale : getLocalesRuntime()) {
      MxmlcMojo cfg=this.clone();
      configureResourceBundle(locale,cfg);
      results.add(executeCompiler(new MxmlcConfigurationHolder(cfg,null),fullSynchronization));
    }
    wait(results);
  }
  if (modules != null) {
    List<Result> results=new ArrayList<Result>();
    for (    Module module : modules) {
      File moduleSource=SourceFileResolver.resolveSourceFile(project.getCompileSourceRoots(),module.getSourceFile());
      String classifier=FilenameUtils.getBaseName(moduleSource.getName()).toLowerCase();
      String moduleFinalName;
      if (module.getFinalName() != null) {
        moduleFinalName=module.getFinalName();
      }
 else {
        moduleFinalName=project.getBuild().getFinalName() + ""String_Node_Str"" + classifier;
      }
      File moduleOutputDir;
      if (module.getDestinationPath() != null) {
        moduleOutputDir=new File(project.getBuild().getDirectory(),module.getDestinationPath());
      }
 else {
        moduleOutputDir=new File(project.getBuild().getDirectory());
      }
      List<String> loadExterns=new ArrayList<String>();
      loadExterns.add(getLinkReport());
      if (getLoadExterns() != null) {
        loadExterns.addAll(Arrays.asList(getLoadExterns()));
      }
      MxmlcMojo cfg=this.clone();
      cfg.classifier=classifier;
      cfg.targetDirectory=moduleOutputDir;
      cfg.finalName=moduleFinalName;
      if (module.isOptimize()) {
        cfg.getCache().put(""String_Node_Str"",loadExterns.toArray(new String[1]));
      }
      results.add(executeCompiler(new MxmlcConfigurationHolder(cfg,moduleSource),fullSynchronization));
    }
    wait(results);
  }
}","public void execute() throws MojoExecutionException, MojoFailureException {
  if (!PathUtil.existAny(getSourcePath())) {
    getLog().warn(""String_Node_Str"" + Arrays.toString(getSourcePath()));
    return;
  }
  executeCompiler(new MxmlcConfigurationHolder(this,getSourceFile()),true);
  if (getLocalesRuntime() != null) {
    List<Result> results=new ArrayList<Result>();
    for (    String locale : getLocalesRuntime()) {
      MxmlcMojo cfg=this.clone();
      configureResourceBundle(locale,cfg);
      results.add(executeCompiler(new MxmlcConfigurationHolder(cfg,null),fullSynchronization));
    }
    wait(results);
  }
  if (modules != null) {
    List<Result> results=new ArrayList<Result>();
    for (    Module module : modules) {
      if (module.isOptimize() == null) {
        module.setOptimize(modulesLoadExterns);
      }
      File moduleSource=SourceFileResolver.resolveSourceFile(project.getCompileSourceRoots(),module.getSourceFile());
      String classifier=FilenameUtils.getBaseName(moduleSource.getName()).toLowerCase();
      String moduleFinalName;
      if (module.getFinalName() != null) {
        moduleFinalName=module.getFinalName();
      }
 else {
        moduleFinalName=project.getBuild().getFinalName() + ""String_Node_Str"" + classifier;
      }
      File moduleOutputDir;
      if (module.getDestinationPath() != null) {
        moduleOutputDir=new File(project.getBuild().getDirectory(),module.getDestinationPath());
      }
 else {
        moduleOutputDir=new File(project.getBuild().getDirectory());
      }
      List<String> loadExterns=new ArrayList<String>();
      loadExterns.add(getLinkReport());
      if (getLoadExterns() != null) {
        loadExterns.addAll(Arrays.asList(getLoadExterns()));
      }
      MxmlcMojo cfg=this.clone();
      cfg.classifier=classifier;
      cfg.targetDirectory=moduleOutputDir;
      cfg.finalName=moduleFinalName;
      if (module.isOptimize()) {
        cfg.getCache().put(""String_Node_Str"",loadExterns.toArray(new String[1]));
      }
      results.add(executeCompiler(new MxmlcConfigurationHolder(cfg,moduleSource),fullSynchronization));
    }
    wait(results);
  }
}",0.9769869513641756
9977,"public void setOptimize(boolean optimize){
  this.optimize=optimize;
}","public void setOptimize(Boolean optimize){
  this.optimize=optimize;
}",0.9857142857142858
9978,"public boolean isOptimize(){
  return optimize;
}","public Boolean isOptimize(){
  return optimize;
}",0.979591836734694
9979,"public String getCompatibilityVersion(){
  return compatibilityVersion;
}","public String getCompatibilityVersion(){
  if (compatibilityVersion == null) {
    return null;
  }
  String[] versionStringParts=compatibilityVersion.split(""String_Node_Str"");
  if (versionStringParts.length != 3) {
    throw new MavenRuntimeException(""String_Node_Str"" + compatibilityVersion + ""String_Node_Str"");
  }
 else {
    try {
      for (int i=0; i < 3; i++) {
        Integer.parseInt(versionStringParts[i]);
      }
    }
 catch (    NumberFormatException e) {
      throw new MavenRuntimeException(""String_Node_Str"",e);
    }
  }
  return compatibilityVersion;
}",0.1941448382126348
9980,"public void execute() throws MojoExecutionException, MojoFailureException {
  if (!PathUtil.existAny(getSourcePath())) {
    getLog().warn(""String_Node_Str"" + Arrays.toString(getSourcePath()));
    return;
  }
  executeCompiler(new MxmlcConfigurationHolder(this,getSourceFile()),true);
  if (getLocalesRuntime() != null) {
    List<Result> results=new ArrayList<Result>();
    for (    String locale : getLocalesRuntime()) {
      MxmlcMojo cfg=this.clone();
      configureResourceBundle(locale,cfg);
      results.add(executeCompiler(new MxmlcConfigurationHolder(cfg,null),fullSynchronization));
    }
    wait(results);
  }
  if (modules != null) {
    List<Result> results=new ArrayList<Result>();
    for (    Module module : modules) {
      if (module.isOptimize() == null) {
        module.setOptimize(modulesLoadExterns);
      }
      File moduleSource=SourceFileResolver.resolveSourceFile(project.getCompileSourceRoots(),module.getSourceFile());
      String classifier=FilenameUtils.getBaseName(moduleSource.getName()).toLowerCase();
      String moduleFinalName;
      if (module.getFinalName() != null) {
        moduleFinalName=module.getFinalName();
      }
 else {
        moduleFinalName=project.getBuild().getFinalName() + ""String_Node_Str"" + classifier;
      }
      File moduleOutputDir;
      if (module.getDestinationPath() != null) {
        moduleOutputDir=new File(project.getBuild().getDirectory(),module.getDestinationPath());
      }
 else {
        moduleOutputDir=new File(project.getBuild().getDirectory());
      }
      List<String> loadExterns=new ArrayList<String>();
      loadExterns.add(getLinkReport());
      if (getLoadExterns() != null) {
        loadExterns.addAll(Arrays.asList(getLoadExterns()));
      }
      MxmlcMojo cfg=this.clone();
      cfg.classifier=classifier;
      cfg.targetDirectory=moduleOutputDir;
      cfg.finalName=moduleFinalName;
      if (module.isOptimize()) {
        cfg.getCache().put(""String_Node_Str"",loadExterns.toArray(new String[1]));
      }
      results.add(executeCompiler(new MxmlcConfigurationHolder(cfg,moduleSource),fullSynchronization));
    }
    wait(results);
  }
}","public void execute() throws MojoExecutionException, MojoFailureException {
  if (!PathUtil.existAny(getSourcePath())) {
    getLog().warn(""String_Node_Str"" + Arrays.toString(getSourcePath()));
    return;
  }
  executeCompiler(new MxmlcConfigurationHolder(this,getSourceFile()),true);
  if (!file(getOutput()).exists()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (getLocalesRuntime() != null) {
    List<Result> results=new ArrayList<Result>();
    for (    String locale : getLocalesRuntime()) {
      MxmlcMojo cfg=this.clone();
      configureResourceBundle(locale,cfg);
      results.add(executeCompiler(new MxmlcConfigurationHolder(cfg,null),fullSynchronization));
    }
    wait(results);
  }
  if (modules != null) {
    List<Result> results=new ArrayList<Result>();
    for (    Module module : modules) {
      if (module.isOptimize() == null) {
        module.setOptimize(modulesLoadExterns);
      }
      File moduleSource=SourceFileResolver.resolveSourceFile(project.getCompileSourceRoots(),module.getSourceFile());
      String classifier=FilenameUtils.getBaseName(moduleSource.getName()).toLowerCase();
      String moduleFinalName;
      if (module.getFinalName() != null) {
        moduleFinalName=module.getFinalName();
      }
 else {
        moduleFinalName=project.getBuild().getFinalName() + ""String_Node_Str"" + classifier;
      }
      File moduleOutputDir;
      if (module.getDestinationPath() != null) {
        moduleOutputDir=new File(project.getBuild().getDirectory(),module.getDestinationPath());
      }
 else {
        moduleOutputDir=new File(project.getBuild().getDirectory());
      }
      List<String> loadExterns=new ArrayList<String>();
      loadExterns.add(getLinkReport());
      if (getLoadExterns() != null) {
        loadExterns.addAll(Arrays.asList(getLoadExterns()));
      }
      MxmlcMojo cfg=this.clone();
      cfg.classifier=classifier;
      cfg.targetDirectory=moduleOutputDir;
      cfg.finalName=moduleFinalName;
      if (module.isOptimize()) {
        cfg.getCache().put(""String_Node_Str"",loadExterns.toArray(new String[1]));
      }
      results.add(executeCompiler(new MxmlcConfigurationHolder(cfg,moduleSource),fullSynchronization));
    }
    wait(results);
  }
}",0.9779995463823996
9981,"public String[] getLanguage(){
  if (this.metadata != null && this.metadata.getLanguage() != null) {
    return this.metadata.getLanguage();
  }
  return getLocale();
}","public String[] getLanguage(){
  if (this.metadata != null && this.metadata.getLanguage() != null) {
    return this.metadata.getLanguage();
  }
  if (getLocale() == null || getLocale().length == 0) {
    return null;
  }
  return getLocale();
}",0.7796610169491526
9982,"@SuppressWarnings(""String_Node_Str"") public File[] getLibraryPath(){
  if (SWC.equals(getProjectType())) {
    return MavenUtils.getFiles(getDependencies(type(SWC),scope(MERGED),not(GLOBAL_MATCHER)),getCompiledResouceBundles());
  }
 else {
    return MavenUtils.getFiles(getDependencies(type(SWC),anyOf(scope(MERGED),scope(COMPILE),scope(null)),not(GLOBAL_MATCHER)),getCompiledResouceBundles());
  }
}","@SuppressWarnings(""String_Node_Str"") private File[] getLibraryPath(boolean includeResourceBundle){
  Collection<Artifact> resourceBundle=includeResourceBundle ? getCompiledResouceBundles() : Collections.EMPTY_LIST;
  if (SWC.equals(getProjectType())) {
    return MavenUtils.getFiles(getDependencies(type(SWC),scope(MERGED),not(GLOBAL_MATCHER)),resourceBundle);
  }
 else {
    return MavenUtils.getFiles(getDependencies(type(SWC),anyOf(scope(MERGED),scope(COMPILE),scope(null)),not(GLOBAL_MATCHER)),resourceBundle);
  }
}",0.7424242424242424
9983,"@SuppressWarnings(""String_Node_Str"") protected void configureResourceBundle(String locale,AbstractFlexCompilerMojo<?,?> cfg){
  cfg.localesCompiled=new String[]{locale};
  cfg.localesRuntime=null;
  cfg.classifier=locale;
  cfg.includeResourceBundles=getResourceBundleListContent();
  cfg.getCache().put(""String_Node_Str"",MavenUtils.getFiles(getDependencies(type(SWC))));
  cfg.getCache().put(""String_Node_Str"",MavenUtils.getFiles(cfg.getCompiledResouceBundles()));
}","@SuppressWarnings(""String_Node_Str"") protected void configureResourceBundle(String locale,AbstractFlexCompilerMojo<?,?> cfg){
  cfg.localesCompiled=new String[]{locale};
  cfg.localesRuntime=null;
  if (locale.contains(""String_Node_Str"")) {
    cfg.classifier=locale.split(""String_Node_Str"")[0];
  }
 else {
    cfg.classifier=locale;
  }
  cfg.includeResourceBundles=getResourceBundleListContent();
  cfg.getCache().put(""String_Node_Str"",MavenUtils.getFiles(getDependencies(type(SWC))));
  cfg.getCache().put(""String_Node_Str"",MavenUtils.getFiles(cfg.getCompiledResouceBundles()));
}",0.8867745004757374
9984,"protected void adaptResourceBundle(final Artifact baseRbSwc,Artifact desiredRbSwc){
  getLog().debug(""String_Node_Str"" + baseRbSwc.getArtifactId() + ""String_Node_Str""+ baseRbSwc.getClassifier()+ ""String_Node_Str""+ desiredRbSwc.getClassifier());
  File dest;
  try {
    UnArchiver unzip=archiverManager.getUnArchiver(""String_Node_Str"");
    unzip.setSourceFile(baseRbSwc.getFile());
    dest=FileUtils.createTempFile(baseRbSwc.getArtifactId(),desiredRbSwc.getClassifier(),getOutputDirectory());
    unzip.extract(""String_Node_Str"" + baseRbSwc.getClassifier(),dest);
  }
 catch (  Exception e) {
    throw new MavenRuntimeException(""String_Node_Str"",e);
  }
  File resourceBundleBaseDir=new File(dest,""String_Node_Str"" + baseRbSwc.getClassifier());
  List<String> bundles=new ArrayList<String>();
  for (  String bundle : resourceBundleBaseDir.list()) {
    bundles.add(bundle.replace(""String_Node_Str"",""String_Node_Str""));
  }
  ICompcConfiguration cfg=mock(ICompcConfiguration.class,RETURNS_NULL);
  ICompilerConfiguration compilerCfg=mock(ICompilerConfiguration.class,RETURNS_NULL);
  when(cfg.getLoadConfig()).thenReturn(getLoadConfig());
  when(cfg.getCompilerConfiguration()).thenReturn(compilerCfg);
  when(compilerCfg.getTheme()).thenReturn(Collections.EMPTY_LIST);
  when(compilerCfg.getFontsConfiguration()).thenReturn(getFontsConfiguration());
  when(compilerCfg.getLocale()).thenReturn(new String[]{desiredRbSwc.getClassifier()});
  when(compilerCfg.getSourcePath()).thenReturn(new File[]{resourceBundleBaseDir});
  when(cfg.getIncludeResourceBundles()).thenReturn(bundles);
  String output=PathUtil.getCanonicalPath(baseRbSwc.getFile()).replace(baseRbSwc.getClassifier(),desiredRbSwc.getClassifier());
  when(cfg.getOutput()).thenReturn(output);
  when(compilerCfg.getExternalLibraryPath()).thenReturn(this.getExternalLibraryPath());
  when(compilerCfg.getLibraryPath()).thenReturn(this.getLibraryPath());
  try {
    checkResult(compiler.compileSwc(cfg,true));
  }
 catch (  Exception e) {
    throw new MavenRuntimeException(""String_Node_Str"",e);
  }
  desiredRbSwc.setFile(new File(output));
  desiredRbSwc.setResolved(true);
}","@SuppressWarnings(""String_Node_Str"") protected void adaptResourceBundle(final Artifact baseRbSwc,Artifact desiredRbSwc){
  getLog().debug(""String_Node_Str"" + baseRbSwc.getArtifactId() + ""String_Node_Str""+ baseRbSwc.getClassifier()+ ""String_Node_Str""+ desiredRbSwc.getClassifier());
  File dest;
  try {
    UnArchiver unzip=archiverManager.getUnArchiver(""String_Node_Str"");
    unzip.setSourceFile(baseRbSwc.getFile());
    dest=FileUtils.createTempFile(baseRbSwc.getArtifactId(),desiredRbSwc.getClassifier(),getOutputDirectory());
    unzip.extract(""String_Node_Str"" + baseRbSwc.getClassifier(),dest);
  }
 catch (  Exception e) {
    throw new MavenRuntimeException(""String_Node_Str"",e);
  }
  File resourceBundleBaseDir=new File(dest,""String_Node_Str"" + baseRbSwc.getClassifier());
  List<String> bundles=new ArrayList<String>();
  for (  String bundle : resourceBundleBaseDir.list()) {
    bundles.add(bundle.replace(""String_Node_Str"",""String_Node_Str""));
  }
  ICompcConfiguration cfg=mock(ICompcConfiguration.class,RETURNS_NULL);
  when(cfg.getLoadConfig()).thenReturn(getLoadConfig());
  when(cfg.getIncludeResourceBundles()).thenReturn(bundles);
  String output=PathUtil.getCanonicalPath(baseRbSwc.getFile()).replace(baseRbSwc.getClassifier(),desiredRbSwc.getClassifier());
  when(cfg.getOutput()).thenReturn(output);
  ICompilerConfiguration compilerCfg=mock(ICompilerConfiguration.class,RETURNS_NULL);
  when(compilerCfg.getTheme()).thenReturn(Collections.EMPTY_LIST);
  when(compilerCfg.getFontsConfiguration()).thenReturn(getFontsConfiguration());
  when(compilerCfg.getLocale()).thenReturn(new String[]{desiredRbSwc.getClassifier()});
  when(compilerCfg.getSourcePath()).thenReturn(new File[]{resourceBundleBaseDir});
  when(compilerCfg.getExternalLibraryPath()).thenReturn(this.getExternalLibraryPath());
  when(compilerCfg.getLibraryPath()).thenReturn(this.getLibraryPath(false));
  when(cfg.getCompilerConfiguration()).thenReturn(compilerCfg);
  try {
    checkResult(compiler.compileSwc(cfg,true));
  }
 catch (  Exception e) {
    throw new MavenRuntimeException(""String_Node_Str"",e);
  }
  desiredRbSwc.setFile(new File(output));
  desiredRbSwc.setResolved(true);
}",0.8261673601479427
9985,"/** 
 * Resolve a resource file in a maven project resources folders
 * @param project maven project
 * @param fileName sugested name on pom
 * @return source file or null if source not found
 * @throws MojoFailureException
 */
@SuppressWarnings(""String_Node_Str"") public static File resolveResourceFile(MavenProject project,String fileName) throws MojoFailureException {
  File file=new File(fileName);
  if (file.exists()) {
    return file;
  }
  if (file.isAbsolute()) {
    throw new MojoFailureException(""String_Node_Str"" + fileName + ""String_Node_Str"");
  }
  List<Resource> resources=project.getBuild().getResources();
  for (  Resource resourceFolder : resources) {
    File resource=new File(resourceFolder.getDirectory(),fileName);
    if (resource.exists()) {
      return resource;
    }
  }
  throw new MojoFailureException(""String_Node_Str"" + fileName + ""String_Node_Str"");
}","/** 
 * Resolve a resource file in a maven project resources folders
 * @param project maven project
 * @param fileName sugested name on pom
 * @return source file or null if source not found
 * @throws MojoFailureException
 */
public static File resolveResourceFile(MavenProject project,String fileName) throws MojoFailureException {
  File file=new File(fileName);
  if (file.exists()) {
    return file;
  }
  if (file.isAbsolute()) {
    throw new MojoFailureException(""String_Node_Str"" + fileName + ""String_Node_Str"");
  }
  List<Resource> resources=project.getBuild().getResources();
  for (  Resource resourceFolder : resources) {
    File resource=new File(resourceFolder.getDirectory(),fileName);
    if (resource.exists()) {
      return resource;
    }
  }
  throw new MojoFailureException(""String_Node_Str"" + fileName + ""String_Node_Str"");
}",0.3889845094664372
9986,"public final Result doCompile(MxmlcConfigurationHolder cfg,boolean synchronize) throws Exception {
  try {
    return compiler.compileSwf(cfg,synchronize);
  }
  finally {
    if (isUpdateSecuritySandbox()) {
      truster.updateSecuritySandbox(PathUtil.getCanonicalFile(cfg.getConfiguration().getOutput()));
    }
  }
}","public final Result doCompile(MxmlcConfigurationHolder cfg,boolean synchronize) throws Exception {
  if (isUpdateSecuritySandbox()) {
    truster.updateSecuritySandbox(PathUtil.getCanonicalFile(cfg.getConfiguration().getOutput()).getParentFile());
    truster.updateSecuritySandbox(PathUtil.getCanonicalFile(cfg.getConfiguration().getOutput()));
  }
  return compiler.compileSwf(cfg,synchronize);
}",0.4289693593314763
9987,"/** 
 * Retrieves flash player trust folder, based on: http://livedocs.adobe.com/flex/3/html/help.html?content=05B_Security_03.html #140756
 */
public File getTrustDir(){
  String trustPath;
  String home=System.getProperty(""String_Node_Str"");
  if (MavenUtils.isWindows()) {
    String appData=System.getenv(""String_Node_Str"");
    if (appData == null) {
      if (MavenUtils.isWindowsVista()) {
        appData=home + ""String_Node_Str"";
      }
 else {
        appData=home + ""String_Node_Str"";
      }
    }
    if (MavenUtils.isWindowsVista()) {
      trustPath=appData + ""String_Node_Str"";
    }
 else {
      trustPath=appData + ""String_Node_Str"";
    }
  }
 else   if (MavenUtils.isUnixBased()) {
    trustPath=home + ""String_Node_Str"";
  }
 else   if (MavenUtils.isMac()) {
    trustPath=home + ""String_Node_Str"";
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + MavenUtils.osString());
  }
  File trustDir=new File(trustPath);
  if (!trustDir.exists()) {
    trustDir.mkdirs();
  }
  return trustDir;
}","/** 
 * Retrieves flash player trust folder, based on: http://livedocs.adobe.com/flex/3/html/help.html?content=05B_Security_03.html #140756
 */
public File getTrustDir(){
  String trustPath;
  String home=System.getProperty(""String_Node_Str"");
  if (MavenUtils.isWindows()) {
    String appData=System.getenv(""String_Node_Str"");
    if (appData == null) {
      if (MavenUtils.isWindowsVista()) {
        appData=home + ""String_Node_Str"";
      }
 else {
        appData=home + ""String_Node_Str"";
      }
    }
    trustPath=appData + ""String_Node_Str"";
  }
 else   if (MavenUtils.isUnixBased()) {
    trustPath=home + ""String_Node_Str"";
  }
 else   if (MavenUtils.isMac()) {
    trustPath=home + ""String_Node_Str"";
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + MavenUtils.osString());
  }
  File trustDir=new File(trustPath);
  if (!trustDir.exists()) {
    trustDir.mkdirs();
  }
  return trustDir;
}",0.9459183673469388
9988,"public final Result doCompile(MxmlcConfigurationHolder cfg,boolean synchronize) throws Exception {
  if (isUpdateSecuritySandbox()) {
    truster.updateSecuritySandbox(PathUtil.getCanonicalFile(cfg.getConfiguration().getOutput()).getParentFile());
    truster.updateSecuritySandbox(PathUtil.getCanonicalFile(cfg.getConfiguration().getOutput()));
  }
  return compiler.compileSwf(cfg,synchronize);
}","public final Result doCompile(MxmlcConfigurationHolder cfg,boolean synchronize) throws Exception {
  if (isUpdateSecuritySandbox()) {
    truster.updateSecuritySandbox(PathUtil.getCanonicalFile(cfg.getConfiguration().getOutput()));
  }
  return compiler.compileSwf(cfg,synchronize);
}",0.6979472140762464
9989,"private void performRuntimeLocalesCopy(MavenProject artifactProject) throws MojoExecutionException {
  List<Artifact> deps=getRuntimeLocalesDependencies(artifactProject);
  if (deps.isEmpty()) {
    return;
  }
  String runtimeLocaleOutputPath=getRuntimeLocaleOutputPath(artifactProject);
  for (  Artifact artifact : deps) {
    try {
      resolver.resolve(artifact,remoteRepositories,localRepository);
    }
 catch (    AbstractArtifactResolutionException e) {
      throw new MojoExecutionException(""String_Node_Str"" + artifact,e);
    }
    copy(artifact.getFile(),resolveRuntimeLocaleDestination(runtimeLocaleOutputPath,artifact));
  }
}","private void performRuntimeLocalesCopy(MavenProject artifactProject) throws MojoExecutionException {
  List<Artifact> deps=getRuntimeLocalesDependencies(artifactProject);
  if (deps.isEmpty()) {
    return;
  }
  String runtimeLocaleOutputPath=getRuntimeLocaleOutputPath(artifactProject);
  for (  Artifact artifact : deps) {
    artifact=replaceWithResolvedArtifact(artifact);
    copy(artifact.getFile(),resolveRuntimeLocaleDestination(runtimeLocaleOutputPath,artifact));
  }
}",0.7843137254901961
9990,"private void performRslCopy(MavenProject artifactProject) throws MojoExecutionException {
  List<Artifact> rslDeps=getRSLDependencies(artifactProject);
  if (rslDeps.isEmpty()) {
    return;
  }
  String[] rslUrls=getRslUrls(artifactProject);
  for (  Artifact rslArtifact : rslDeps) {
    String extension;
    if (RSL.equals(rslArtifact.getScope())) {
      extension=SWF;
    }
 else {
      extension=SWZ;
    }
    rslArtifact=artifactFactory.createArtifactWithClassifier(rslArtifact.getGroupId(),rslArtifact.getArtifactId(),rslArtifact.getVersion(),extension,null);
    try {
      resolver.resolve(rslArtifact,remoteRepositories,localRepository);
    }
 catch (    AbstractArtifactResolutionException e) {
      throw new MojoExecutionException(""String_Node_Str"" + rslArtifact,e);
    }
    File[] destFiles=resolveRslDestination(rslUrls,rslArtifact,extension);
    File sourceFile=rslArtifact.getFile();
    for (    File destFile : destFiles) {
      copy(sourceFile,destFile);
    }
  }
}","private void performRslCopy(MavenProject artifactProject) throws MojoExecutionException {
  List<Artifact> rslDeps=getRSLDependencies(artifactProject);
  if (rslDeps.isEmpty()) {
    return;
  }
  String[] rslUrls=getRslUrls(artifactProject);
  for (  Artifact rslArtifact : rslDeps) {
    String extension;
    if (RSL.equals(rslArtifact.getScope())) {
      extension=SWF;
    }
 else {
      extension=SWZ;
    }
    rslArtifact=artifactFactory.createArtifactWithClassifier(rslArtifact.getGroupId(),rslArtifact.getArtifactId(),rslArtifact.getVersion(),extension,null);
    rslArtifact=replaceWithResolvedArtifact(rslArtifact);
    File[] destFiles=resolveRslDestination(rslUrls,rslArtifact,extension);
    File sourceFile=rslArtifact.getFile();
    for (    File destFile : destFiles) {
      copy(sourceFile,destFile);
    }
  }
}",0.8602620087336245
9991,"/** 
 * Get dependency artifacts for given scope
 * @param scope for which to get artifacts
 * @return List of artifacts
 * @throws MojoExecutionException
 */
protected List<Artifact> getDependencyArtifacts(String... scopes) throws MojoExecutionException {
  if (scopes == null)   return null;
  if (scopes.length == 0) {
    return new ArrayList<Artifact>();
  }
  List<String> scopesList=Arrays.asList(scopes);
  List<Artifact> artifacts=new ArrayList<Artifact>();
  for (  Artifact artifact : getDependencyArtifacts()) {
    if (""String_Node_Str"".equals(artifact.getType()) && scopesList.contains(artifact.getScope())) {
      artifacts.add(artifact);
    }
  }
  return artifacts;
}","/** 
 * Get dependency artifacts for given scope
 * @param scopes for which to get artifacts
 * @return List of artifacts
 * @throws MojoExecutionException
 */
protected List<Artifact> getDependencyArtifacts(String... scopes) throws MojoExecutionException {
  if (scopes == null)   return null;
  if (scopes.length == 0) {
    return new ArrayList<Artifact>();
  }
  List<String> scopesList=Arrays.asList(scopes);
  List<Artifact> artifacts=new ArrayList<Artifact>();
  for (  Artifact artifact : getDependencyArtifacts()) {
    if (FlexExtension.SWC.equals(artifact.getType()) && scopesList.contains(artifact.getScope())) {
      artifacts.add(artifact);
    }
  }
  return artifacts;
}",0.9759650400582666
9992,"/** 
 * Get resource bundles for the given locale
 * @param requestedLocales the locale for which you want bundles, null for all locales
 * @return Array of resource bundle files
 * @throws MojoExecutionException
 */
protected File[] getResourcesBundles(String... requestedLocales) throws MojoExecutionException {
  if (requestedLocales == null) {
    return new File[0];
  }
  List<File> resourceBundles=new ArrayList<File>();
  for (  Artifact resourceBundleBeacon : getDependencyArtifacts()) {
    if (!RB_SWC.equals(resourceBundleBeacon.getType())) {
      continue;
    }
    for (    String requestLocale : requestedLocales) {
      Artifact resolvedResourceBundle=artifactFactory.createArtifactWithClassifier(resourceBundleBeacon.getGroupId(),resourceBundleBeacon.getArtifactId(),resourceBundleBeacon.getVersion(),resourceBundleBeacon.getType(),requestLocale);
      MavenUtils.resolveArtifact(resolvedResourceBundle,resolver,localRepository,remoteRepositories);
      resourceBundles.add(resolvedResourceBundle.getFile());
    }
  }
  getLog().debug(""String_Node_Str"" + requestedLocales + ""String_Node_Str""+ resourceBundles);
  return resourceBundles.toArray(new File[resourceBundles.size()]);
}","/** 
 * Get resource bundles for the given locale
 * @param requestedLocales the locale for which you want bundles, null for all locales
 * @return Array of resource bundle files
 * @throws MojoExecutionException
 */
protected File[] getResourcesBundles(String... requestedLocales) throws MojoExecutionException {
  if (requestedLocales == null) {
    return new File[0];
  }
  List<File> resourceBundles=new ArrayList<File>();
  for (  Artifact resourceBundleBeacon : getDependencyArtifacts()) {
    if (!RB_SWC.equals(resourceBundleBeacon.getType())) {
      continue;
    }
    for (    String requestLocale : requestedLocales) {
      Artifact resolvedResourceBundle=artifactFactory.createArtifactWithClassifier(resourceBundleBeacon.getGroupId(),resourceBundleBeacon.getArtifactId(),resourceBundleBeacon.getVersion(),resourceBundleBeacon.getType(),requestLocale);
      resolvedResourceBundle=MavenUtils.resolveArtifact(project,resolvedResourceBundle,resolver,localRepository,remoteRepositories);
      resourceBundles.add(resolvedResourceBundle.getFile());
    }
  }
  getLog().debug(""String_Node_Str"" + requestedLocales + ""String_Node_Str""+ resourceBundles);
  return resourceBundles.toArray(new File[resourceBundles.size()]);
}",0.9872794419368076
9993,"/** 
 * Setup builder configuration
 * @throws MojoExecutionException
 * @throws MojoFailureException
 */
protected void configure() throws MojoExecutionException, MojoFailureException {
  resolveDependencies();
  configuration.enableAccessibility(accessible);
  configuration.allowSourcePathOverlap(allowSourcePathOverlap);
  configuration.useActionScript3(as3);
  configuration.enableDebugging(isDebug(),debugPassword);
  configuration.useECMAScript(es);
  FDKConfigResolver sdkConfigResolver=new FDKConfigResolver(getDependencyArtifacts(),build,getCompilerVersion());
  if (fonts != null) {
    configureFontsAntiAliasing();
    enableFlashType();
    configuration.setMaximumCachedFonts(fonts.getMaxCachedFonts());
    configuration.setMaximumGlyphsPerFace(fonts.getMaxGlyphsPerFace());
    if (fonts.getLanguages() != null && !fonts.getLanguages().isEmpty()) {
      for (      String language : fonts.getLanguages().keySet()) {
        configuration.setFontLanguageRange(language,fonts.getLanguages().get(language));
      }
    }
  }
  if (fonts != null && fonts.getManagers() != null) {
    configuration.setFontManagers(fonts.getManagers());
  }
 else {
    String[] defaultFontManagers=sdkConfigResolver.getFontManagers();
    if (defaultFontManagers != null) {
      configuration.setFontManagers(defaultFontManagers);
    }
  }
  File fontsSnapshot=getFontsSnapshot();
  if (fontsSnapshot == null || !fontsSnapshot.exists()) {
    throw new MojoExecutionException(""String_Node_Str"" + fontsSnapshot);
  }
  configuration.setLocalFontSnapshot(fontsSnapshot);
  configuration.setActionScriptMetadata(keepAs3Metadatas);
  configuration.keepCompilerGeneratedActionScript(keepGeneratedActionscript);
  if (licenses != null) {
    for (    String licenseName : licenses.keySet()) {
      String key=licenses.get(licenseName);
      configuration.setLicense(licenseName,key);
    }
  }
  addDefines();
  if (compiledLocales == null && runtimeLocales == null && isApplication()) {
    setLocales(getDefaultLocale());
  }
 else   if (compiledLocales != null) {
    setLocales(compiledLocales);
  }
 else {
    setLocales();
  }
  configureNamespaces(sdkConfigResolver);
  configuration.optimize(optimize);
  if (this.warnings != null) {
    configureWarnings(configuration);
  }
  configuration.setSourcePath(sourcePaths);
  configuration.enableStrictChecking(strict);
  configuration.useNetwork(useNetwork);
  configuration.enableVerboseStacktraces(verboseStacktraces);
  if (contextRoot != null) {
    configuration.setContextRoot(contextRoot);
  }
  configuration.keepLinkReport(linkReport);
  configuration.keepConfigurationReport(configurationReport);
  configuration.setServiceConfiguration(services);
  if (loadExterns != null) {
    List<File> externsFiles=new ArrayList<File>();
    for (    MavenArtifact mvnArtifact : loadExterns) {
      Artifact artifact=artifactFactory.createArtifactWithClassifier(mvnArtifact.getGroupId(),mvnArtifact.getArtifactId(),mvnArtifact.getVersion(),""String_Node_Str"",""String_Node_Str"");
      MavenUtils.resolveArtifact(artifact,resolver,localRepository,remoteRepositories);
      externsFiles.add(artifact.getFile());
    }
    configuration.setExterns(externsFiles.toArray(new File[externsFiles.size()]));
  }
  if (rawMetadata != null) {
    configuration.setSWFMetaData(rawMetadata);
  }
  if (metadata != null) {
    if (metadata.getContributor() != null) {
      configuration.setSWFMetaData(Configuration.CONTRIBUTOR,metadata.getContributor());
    }
    if (metadata.getCreator() != null) {
      configuration.setSWFMetaData(Configuration.CREATOR,metadata.getCreator());
    }
    if (metadata.getDate() != null) {
      configuration.setSWFMetaData(Configuration.DATE,metadata.getDate());
    }
    if (metadata.getDescriptions() != null) {
      configuration.setSWFMetaData(Configuration.DESCRIPTION,metadata.getDescriptions());
    }
    if (metadata.getTitles() != null) {
      configuration.setSWFMetaData(Configuration.TITLE,metadata.getTitles());
    }
    if (metadata.getLanguage() != null) {
      configuration.setSWFMetaData(Configuration.LANGUAGE,metadata.getLanguage());
    }
  }
  setCompatibilityMode();
  configuration.setActionScriptFileEncoding(encoding);
  setTargetPlayer();
  if (defaultsCss != null)   configuration.setDefaultCSS(defaultsCss);
  configuration.setDefaultBackgroundColor(Integer.parseInt(defaultBackgroundColor,16));
  configuration.setDefaultFrameRate(defaultFrameRate);
  configuration.setDefaultScriptLimits(scriptMaxRecursionDepth,scriptMaxExecutionTime);
  configuration.setDefaultSize(defaultSizeWidth,defaultSizeHeight);
  if (externs != null && externs.length > 0) {
    configuration.setExterns(externs);
  }
  if (frames != null && frames.length > 0) {
    for (    FrameLabel frame : frames) {
      configuration.setFrameLabel(frame.getLabel(),frame.getClassNames());
    }
  }
  if (includes != null && includes.length > 0) {
    configuration.setIncludes(includes);
  }
  configuration.useHeadlessServer(headlessServer);
  configuration.keepAllTypeSelectors(keepAllTypeSelectors);
  configuration.useResourceBundleMetaData(useResourceBundleMetadata);
  if (configFile != null) {
    configuration.setConfiguration(configFile);
  }
  if (configuration instanceof OEMConfiguration) {
    OEMConfiguration oemConfig=(OEMConfiguration)configuration;
    List<String> commandLineArguments=new ArrayList<String>();
    if (!staticLinkRuntimeSharedLibraries) {
      commandLineArguments.add(""String_Node_Str"");
    }
    configureIncludeResourceBundles(oemConfig);
    if (configFile == null) {
      commandLineArguments.add(""String_Node_Str"");
    }
    if (includeLookupOnly) {
      commandLineArguments.add(""String_Node_Str"");
    }
    oemConfig.setConfiguration(commandLineArguments.toArray(new String[commandLineArguments.size()]));
  }
 else {
    throw new MojoFailureException(""String_Node_Str"");
  }
  verifyDigests();
}","/** 
 * Setup builder configuration
 * @throws MojoExecutionException
 * @throws MojoFailureException
 */
protected void configure() throws MojoExecutionException, MojoFailureException {
  resolveDependencies();
  configuration.enableAccessibility(accessible);
  configuration.allowSourcePathOverlap(allowSourcePathOverlap);
  configuration.useActionScript3(as3);
  configuration.enableDebugging(isDebug(),debugPassword);
  configuration.useECMAScript(es);
  FDKConfigResolver sdkConfigResolver=new FDKConfigResolver(getDependencyArtifacts(),build,getCompilerVersion());
  if (fonts != null) {
    configureFontsAntiAliasing();
    enableFlashType();
    configuration.setMaximumCachedFonts(fonts.getMaxCachedFonts());
    configuration.setMaximumGlyphsPerFace(fonts.getMaxGlyphsPerFace());
    if (fonts.getLanguages() != null && !fonts.getLanguages().isEmpty()) {
      for (      String language : fonts.getLanguages().keySet()) {
        configuration.setFontLanguageRange(language,fonts.getLanguages().get(language));
      }
    }
  }
  if (fonts != null && fonts.getManagers() != null) {
    configuration.setFontManagers(fonts.getManagers());
  }
 else {
    String[] defaultFontManagers=sdkConfigResolver.getFontManagers();
    if (defaultFontManagers != null) {
      configuration.setFontManagers(defaultFontManagers);
    }
  }
  File fontsSnapshot=getFontsSnapshot();
  if (fontsSnapshot == null || !fontsSnapshot.exists()) {
    throw new MojoExecutionException(""String_Node_Str"" + fontsSnapshot);
  }
  configuration.setLocalFontSnapshot(fontsSnapshot);
  configuration.setActionScriptMetadata(keepAs3Metadatas);
  configuration.keepCompilerGeneratedActionScript(keepGeneratedActionscript);
  if (licenses != null) {
    for (    String licenseName : licenses.keySet()) {
      String key=licenses.get(licenseName);
      configuration.setLicense(licenseName,key);
    }
  }
  addDefines();
  if (compiledLocales == null && runtimeLocales == null && isApplication()) {
    setLocales(getDefaultLocale());
  }
 else   if (compiledLocales != null) {
    setLocales(compiledLocales);
  }
 else {
    setLocales();
  }
  configureNamespaces(sdkConfigResolver);
  configuration.optimize(optimize);
  if (this.warnings != null) {
    configureWarnings(configuration);
  }
  configuration.setSourcePath(sourcePaths);
  configuration.enableStrictChecking(strict);
  configuration.useNetwork(useNetwork);
  configuration.enableVerboseStacktraces(verboseStacktraces);
  if (contextRoot != null) {
    configuration.setContextRoot(contextRoot);
  }
  configuration.keepLinkReport(linkReport);
  configuration.keepConfigurationReport(configurationReport);
  configuration.setServiceConfiguration(services);
  configureExterns();
  if (rawMetadata != null) {
    configuration.setSWFMetaData(rawMetadata);
  }
  if (metadata != null) {
    if (metadata.getContributor() != null) {
      configuration.setSWFMetaData(Configuration.CONTRIBUTOR,metadata.getContributor());
    }
    if (metadata.getCreator() != null) {
      configuration.setSWFMetaData(Configuration.CREATOR,metadata.getCreator());
    }
    if (metadata.getDate() != null) {
      configuration.setSWFMetaData(Configuration.DATE,metadata.getDate());
    }
    if (metadata.getDescriptions() != null) {
      configuration.setSWFMetaData(Configuration.DESCRIPTION,metadata.getDescriptions());
    }
    if (metadata.getTitles() != null) {
      configuration.setSWFMetaData(Configuration.TITLE,metadata.getTitles());
    }
    if (metadata.getLanguage() != null) {
      configuration.setSWFMetaData(Configuration.LANGUAGE,metadata.getLanguage());
    }
  }
  setCompatibilityMode();
  configuration.setActionScriptFileEncoding(encoding);
  setTargetPlayer();
  if (defaultsCss != null)   configuration.setDefaultCSS(defaultsCss);
  configuration.setDefaultBackgroundColor(Integer.parseInt(defaultBackgroundColor,16));
  configuration.setDefaultFrameRate(defaultFrameRate);
  configuration.setDefaultScriptLimits(scriptMaxRecursionDepth,scriptMaxExecutionTime);
  configuration.setDefaultSize(defaultSizeWidth,defaultSizeHeight);
  if (frames != null && frames.length > 0) {
    for (    FrameLabel frame : frames) {
      configuration.setFrameLabel(frame.getLabel(),frame.getClassNames());
    }
  }
  if (includes != null && includes.length > 0) {
    configuration.setIncludes(includes);
  }
  configuration.useHeadlessServer(headlessServer);
  configuration.keepAllTypeSelectors(keepAllTypeSelectors);
  configuration.useResourceBundleMetaData(useResourceBundleMetadata);
  if (configFile != null) {
    configuration.setConfiguration(configFile);
  }
  if (configuration instanceof OEMConfiguration) {
    OEMConfiguration oemConfig=(OEMConfiguration)configuration;
    List<String> commandLineArguments=new ArrayList<String>();
    if (!staticLinkRuntimeSharedLibraries) {
      commandLineArguments.add(""String_Node_Str"");
    }
    configureIncludeResourceBundles(oemConfig);
    if (configFile == null) {
      commandLineArguments.add(""String_Node_Str"");
    }
    if (includeLookupOnly) {
      commandLineArguments.add(""String_Node_Str"");
    }
    oemConfig.setConfiguration(commandLineArguments.toArray(new String[commandLineArguments.size()]));
  }
 else {
    throw new MojoFailureException(""String_Node_Str"");
  }
  verifyDigests();
}",0.9433090456726496
9994,"protected Collection<IdeDependency> getDependencies(IdeDependency[] ideDependencies) throws MojoExecutionException {
  List<IdeDependency> dependencies=new ArrayList<IdeDependency>(Arrays.asList(ideDependencies));
  List<IdeDependency> extraRbs=resolveResourceBundles(dependencies);
  for (  IdeDependency ideDependency : dependencies) {
    if (ideDependency.isReferencedProject()) {
      String template=IdeUtils.PROJECT_NAME_DEFAULT_TEMPLATE;
      String projectName=IdeUtils.getProjectName(template,ideDependency);
      ideDependency.setFile(new File(""String_Node_Str"" + projectName + ""String_Node_Str""+ projectName+ ""String_Node_Str""));
      ideDependency.setSourceAttachment(new File(""String_Node_Str"" + projectName + ""String_Node_Str""));
    }
 else {
      String ideDependencyScope=null;
      if (ideDependency.isSystemScoped()) {
        ideDependencyScope=Artifact.SCOPE_SYSTEM;
      }
 else       if (ideDependency.isTestDependency()) {
        ideDependencyScope=Artifact.SCOPE_TEST;
      }
 else       if (ideDependency.isProvided()) {
        ideDependencyScope=Artifact.SCOPE_PROVIDED;
      }
      Artifact art=artifactFactory.createArtifact(ideDependency.getGroupId(),ideDependency.getArtifactId(),ideDependency.getVersion(),ideDependencyScope,ideDependency.getType());
      MavenUtils.resolveArtifact(art,resolver,localRepository,remoteRepositories);
      if (useM2Home) {
        ideDependency.setFile(new File(ideDependency.getFile().getPath().replace(localRepository.getBasedir(),""String_Node_Str"")));
      }
 else {
        ideDependency.setFile(ideDependency.getFile().getAbsoluteFile());
      }
      if (Arrays.binarySearch(SDK_SOURCES,ideDependency.getArtifactId()) >= 0) {
        ideDependency.setSourceAttachment(new File(""String_Node_Str"" + ideDependency.getArtifactId() + ""String_Node_Str""));
      }
    }
  }
  Set<IdeDependency> result=new HashSet<IdeDependency>();
  result.addAll(dependencies);
  result.addAll(extraRbs);
  return result;
}","protected Collection<IdeDependency> getDependencies(IdeDependency[] ideDependencies) throws MojoExecutionException {
  List<IdeDependency> dependencies=new ArrayList<IdeDependency>(Arrays.asList(ideDependencies));
  List<IdeDependency> extraRbs=resolveResourceBundles(dependencies);
  for (  IdeDependency ideDependency : dependencies) {
    if (ideDependency.isReferencedProject()) {
      String template=IdeUtils.PROJECT_NAME_DEFAULT_TEMPLATE;
      String projectName=IdeUtils.getProjectName(template,ideDependency);
      ideDependency.setFile(new File(""String_Node_Str"" + projectName + ""String_Node_Str""+ projectName+ ""String_Node_Str""));
      ideDependency.setSourceAttachment(new File(""String_Node_Str"" + projectName + ""String_Node_Str""));
    }
 else {
      String ideDependencyScope=null;
      if (ideDependency.isSystemScoped()) {
        ideDependencyScope=Artifact.SCOPE_SYSTEM;
      }
 else       if (ideDependency.isTestDependency()) {
        ideDependencyScope=Artifact.SCOPE_TEST;
      }
 else       if (ideDependency.isProvided()) {
        ideDependencyScope=Artifact.SCOPE_PROVIDED;
      }
      Artifact art=artifactFactory.createArtifact(ideDependency.getGroupId(),ideDependency.getArtifactId(),ideDependency.getVersion(),ideDependencyScope,ideDependency.getType());
      art=MavenUtils.resolveArtifact(project,art,resolver,localRepository,remoteRepositories);
      if (useM2Home) {
        ideDependency.setFile(new File(ideDependency.getFile().getPath().replace(localRepository.getBasedir(),""String_Node_Str"")));
      }
 else {
        ideDependency.setFile(ideDependency.getFile().getAbsoluteFile());
      }
      if (Arrays.binarySearch(SDK_SOURCES,ideDependency.getArtifactId()) >= 0) {
        ideDependency.setSourceAttachment(new File(""String_Node_Str"" + ideDependency.getArtifactId() + ""String_Node_Str""));
      }
    }
  }
  Set<IdeDependency> result=new HashSet<IdeDependency>();
  result.addAll(dependencies);
  result.addAll(extraRbs);
  return result;
}",0.9969924812030077
9995,"private List<IdeDependency> resolveResourceBundles(List<IdeDependency> dependencies) throws MojoExecutionException {
  Collection<String> locales=getLocales();
  List<IdeDependency> extraRbs=new ArrayList<IdeDependency>();
  for (Iterator<IdeDependency> it=dependencies.iterator(); it.hasNext(); ) {
    IdeDependency dependency=it.next();
    if (""String_Node_Str"".equals(dependency.getArtifactId()) || ""String_Node_Str"".equals(dependency.getArtifactId())) {
      it.remove();
    }
 else     if (SWC.equals(dependency.getType())) {
      continue;
    }
 else     if (RB_SWC.equals(dependency.getType())) {
      for (      String locale : locales) {
        Artifact art=artifactFactory.createArtifactWithClassifier(dependency.getGroupId(),dependency.getArtifactId(),dependency.getVersion(),dependency.getType(),locale);
        MavenUtils.resolveArtifact(art,resolver,localRepository,remoteRepositories);
        IdeDependency dep=new IdeDependency(art.getGroupId(),art.getArtifactId(),art.getVersion(),art.getClassifier(),false,Artifact.SCOPE_TEST.equals(art.getScope()),false,false,false,art.getFile(),art.getType(),false,null,1);
        if (useM2Home) {
          dep.setFile(new File(dep.getFile().getPath().replace(localRepository.getBasedir(),""String_Node_Str"")));
        }
        extraRbs.add(dep);
      }
      it.remove();
    }
 else {
      it.remove();
    }
  }
  return extraRbs;
}","private List<IdeDependency> resolveResourceBundles(List<IdeDependency> dependencies) throws MojoExecutionException {
  Collection<String> locales=getLocales();
  List<IdeDependency> extraRbs=new ArrayList<IdeDependency>();
  for (Iterator<IdeDependency> it=dependencies.iterator(); it.hasNext(); ) {
    IdeDependency dependency=it.next();
    if (""String_Node_Str"".equals(dependency.getArtifactId()) || ""String_Node_Str"".equals(dependency.getArtifactId())) {
      it.remove();
    }
 else     if (SWC.equals(dependency.getType())) {
      continue;
    }
 else     if (RB_SWC.equals(dependency.getType())) {
      for (      String locale : locales) {
        Artifact art=artifactFactory.createArtifactWithClassifier(dependency.getGroupId(),dependency.getArtifactId(),dependency.getVersion(),dependency.getType(),locale);
        art=MavenUtils.resolveArtifact(project,art,resolver,localRepository,remoteRepositories);
        IdeDependency dep=new IdeDependency(art.getGroupId(),art.getArtifactId(),art.getVersion(),art.getClassifier(),false,Artifact.SCOPE_TEST.equals(art.getScope()),false,false,false,art.getFile(),art.getType(),false,null,1);
        if (useM2Home) {
          dep.setFile(new File(dep.getFile().getPath().replace(localRepository.getBasedir(),""String_Node_Str"")));
        }
        extraRbs.add(dep);
      }
      it.remove();
    }
 else {
      it.remove();
    }
  }
  return extraRbs;
}",0.9957446808510638
9996,"/** 
 * Use the resolver to resolve the given artifact in the local or remote repositories.
 * @param artifact Artifact to be resolved
 * @param resolver ArtifactResolver to use for resolving the artifact
 * @param localRepository ArtifactRepository
 * @param remoteRepositories List of remote artifact repositories
 * @throws MojoExecutionException thrown if an exception occured during artifact resolving
 */
@SuppressWarnings(""String_Node_Str"") public static void resolveArtifact(Artifact artifact,ArtifactResolver resolver,ArtifactRepository localRepository,List remoteRepositories) throws MojoExecutionException {
  try {
    resolver.resolve(artifact,remoteRepositories,localRepository);
  }
 catch (  AbstractArtifactResolutionException e) {
    throw new MojoExecutionException(e.getMessage(),e);
  }
}","/** 
 * Use the resolver to resolve the given artifact in the local or remote repositories.
 * @param project Active project
 * @param artifact Artifact to be resolved
 * @param resolver ArtifactResolver to use for resolving the artifact
 * @param localRepository ArtifactRepository
 * @param remoteRepositories List of remote artifact repositories
 * @throws MojoExecutionException thrown if an exception occured during artifact resolving
 * @return resolved artifact
 */
@SuppressWarnings(""String_Node_Str"") public static Artifact resolveArtifact(MavenProject project,Artifact artifact,ArtifactResolver resolver,ArtifactRepository localRepository,List remoteRepositories) throws MojoExecutionException {
  try {
    artifact=project.replaceWithActiveArtifact(artifact);
    if (!artifact.isResolved()) {
      resolver.resolve(artifact,remoteRepositories,localRepository);
    }
    return artifact;
  }
 catch (  AbstractArtifactResolutionException e) {
    throw new MojoExecutionException(e.getMessage(),e);
  }
}",0.8818380743982495
9997,"/** 
 * Get the file reference of an SWC artifact.<br> If the artifact file does not exist in the [build-dir]/libraries/[scope] directory, the artifact file is copied to that location.
 * @param a artifact for which to retrieve the file reference
 * @param scope scope of the library
 * @param build build for which to get the artifact
 * @return swc artifact file reference
 * @throws MojoExecutionException thrown if an IOException occurs while copying the file to the[build-dir]/libraries/[scope] directory
 */
public static File getArtifactFile(Artifact a,Build build) throws MojoExecutionException {
  File dest=new File(build.getOutputDirectory(),""String_Node_Str"" + a.getArtifactId() + ""String_Node_Str"");
  if (!dest.exists()) {
    try {
      FileUtils.copyFile(a.getFile(),dest);
    }
 catch (    IOException e) {
      throw new MojoExecutionException(e.getMessage(),e);
    }
  }
  return dest;
}","/** 
 * Get the file reference of an SWC artifact.<br> If the artifact file does not exist in the [build-dir]/libraries/[scope] directory, the artifact file is copied to that location.
 * @param a artifact for which to retrieve the file reference
 * @param build build for which to get the artifact
 * @return swc artifact file reference
 * @throws MojoExecutionException thrown if an IOException occurs while copying the file to the[build-dir]/libraries/[scope] directory
 */
public static File getArtifactFile(Artifact a,Build build) throws MojoExecutionException {
  File dest=new File(build.getOutputDirectory(),""String_Node_Str"" + a.getArtifactId() + ""String_Node_Str"");
  if (!dest.exists()) {
    try {
      FileUtils.copyFile(a.getFile(),dest);
    }
 catch (    IOException e) {
      throw new MojoExecutionException(e.getMessage(),e);
    }
  }
  return dest;
}",0.9792484576556366
9998,"public static boolean isMaxVersionOK(int[] fdkVersion,int[] maxVersion){
  int lenght=getSmaller(fdkVersion.length,maxVersion.length);
  for (int i=0; i < lenght; i++) {
    int max=maxVersion[i];
    int current=fdkVersion[i];
    if (current > max) {
      return false;
    }
  }
  return true;
}","public static boolean isMaxVersionOK(int[] fdkVersion,int[] maxVersion){
  return isVersionOK(maxVersion,fdkVersion);
}",0.4545454545454545
9999,"public static boolean isMinVersionOK(int[] fdkVersion,int[] minVersion){
  int lenght=getSmaller(fdkVersion.length,minVersion.length);
  for (int i=0; i < lenght; i++) {
    int min=minVersion[i];
    int current=fdkVersion[i];
    if (current < min) {
      return false;
    }
  }
  return true;
}","public static boolean isMinVersionOK(int[] fdkVersion,int[] minVersion){
  return isVersionOK(fdkVersion,minVersion);
}",0.5023923444976076
10000,"@Test public void testMaxVersion(){
  Assert.assertFalse(isMaxVersionOK(splitVersion(""String_Node_Str""),splitVersion(""String_Node_Str"")));
  Assert.assertFalse(isMaxVersionOK(splitVersion(""String_Node_Str""),splitVersion(""String_Node_Str"")));
  Assert.assertTrue(isMaxVersionOK(splitVersion(""String_Node_Str""),splitVersion(""String_Node_Str"")));
  Assert.assertTrue(isMaxVersionOK(splitVersion(""String_Node_Str""),splitVersion(""String_Node_Str"")));
  Assert.assertTrue(isMaxVersionOK(splitVersion(""String_Node_Str""),splitVersion(""String_Node_Str"")));
  Assert.assertFalse(isMaxVersionOK(splitVersion(""String_Node_Str""),splitVersion(""String_Node_Str"")));
}","@Test public void testMaxVersion(){
  Assert.assertFalse(isMaxVersionOK(splitVersion(""String_Node_Str""),splitVersion(""String_Node_Str"")));
  Assert.assertFalse(isMaxVersionOK(splitVersion(""String_Node_Str""),splitVersion(""String_Node_Str"")));
  Assert.assertTrue(isMaxVersionOK(splitVersion(""String_Node_Str""),splitVersion(""String_Node_Str"")));
  Assert.assertTrue(isMaxVersionOK(splitVersion(""String_Node_Str""),splitVersion(""String_Node_Str"")));
  Assert.assertTrue(isMaxVersionOK(splitVersion(""String_Node_Str""),splitVersion(""String_Node_Str"")));
  Assert.assertFalse(isMaxVersionOK(splitVersion(""String_Node_Str""),splitVersion(""String_Node_Str"")));
  Assert.assertFalse(isMaxVersionOK(splitVersion(""String_Node_Str""),splitVersion(""String_Node_Str"")));
  Assert.assertTrue(isMaxVersionOK(splitVersion(""String_Node_Str""),splitVersion(""String_Node_Str"")));
}",0.8641484426772698
