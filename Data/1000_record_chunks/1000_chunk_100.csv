record_number,buggy_code,fixed_code,code_similarity
99001,"public void updateFromStateLogString(String s){
  String[] parts=s.split(LOG_SEPERATOR,4);
  this.promisedPropNum=Integer.parseInt(parts[1]);
  this.acceptedPropNum=Integer.parseInt(parts[2]);
  this.acceptedValue=parts[3].equals(""String_Node_Str"") ? PaxosNode.noopMarker : Utility.stringToByteArray(parts[3]);
}","public void updateFromStateLogString(String s){
  String[] parts=s.split(LOG_SEPERATOR,4);
  this.promisedPropNum=Integer.parseInt(parts[1]);
  this.acceptedPropNum=Integer.parseInt(parts[2]);
}",0.766798418972332
99002,"public void proposeCommand(List<Integer> addrs,Integer instNum,byte[] payload,Integer backoff){
  PaxosState state=this.rounds.get(instNum);
  if (!state.decided) {
    int propNum=this.rounds.get(instNum).propNum;
    for (    Integer nodeAddr : addrs) {
      PaxosPacket prepare=PaxosPacket.makePrepareMessage(instNum,propNum,payload);
      noteOutput(""String_Node_Str"" + instNum + ""String_Node_Str""+ propNum+ ""String_Node_Str""+ nodeAddr+ ""String_Node_Str""+ (payload != null ? Utility.byteArrayToString(payload) : ""String_Node_Str""));
      RIOSend(nodeAddr,Protocol.PAXOS_PKT,prepare.pack());
    }
    try {
      Method m=Callback.getMethod(""String_Node_Str"",this,new String[]{List.class.getName(),Integer.class.getName(),byte[].class.getName(),Integer.class.getName()});
      Callback retry=new Callback(m,this,new Object[]{addrs,instNum,payload,backoff * 2 + r.nextInt() % RANDOM_BACKOFF_MAX});
      addTimeout(retry,backoff);
    }
 catch (    Exception e) {
      noteError(""String_Node_Str"" + instNum + ""String_Node_Str"");
      e.printStackTrace();
      fail();
    }
  }
 else {
    noteOutput(""String_Node_Str"" + instNum + ""String_Node_Str"");
    retryPaxosCommand(state.participants,state.instNum,state.value);
  }
}","public void proposeCommand(List<Integer> addrs,Integer instNum,byte[] payload,Integer backoff){
  PaxosState state=this.rounds.get(instNum);
  if (!state.decided) {
    int propNum=this.rounds.get(instNum).propNum;
    for (    Integer nodeAddr : addrs) {
      PaxosPacket prepare=PaxosPacket.makePrepareMessage(instNum,propNum,payload);
      noteOutput(""String_Node_Str"" + instNum + ""String_Node_Str""+ propNum+ ""String_Node_Str""+ nodeAddr+ ""String_Node_Str""+ (payload != null ? Utility.byteArrayToString(payload) : ""String_Node_Str""));
      RIOSend(nodeAddr,Protocol.PAXOS_PKT,prepare.pack());
    }
    try {
      Method m=Callback.getMethod(""String_Node_Str"",this,new String[]{List.class.getName(),Integer.class.getName(),byte[].class.getName(),Integer.class.getName()});
      Callback retry=new Callback(m,this,new Object[]{addrs,instNum,payload,backoff * 2 + r.nextInt() % RANDOM_BACKOFF_MAX});
      addTimeout(retry,backoff);
    }
 catch (    Exception e) {
      noteError(""String_Node_Str"" + instNum + ""String_Node_Str"");
      e.printStackTrace();
      fail();
    }
  }
 else   if (!Arrays.equals(state.value,state.decidedValue)) {
    noteOutput(""String_Node_Str"" + instNum + ""String_Node_Str"");
    retryPaxosCommand(state.participants,state.instNum,state.value);
  }
 else {
    noteOutput(""String_Node_Str"" + instNum + ""String_Node_Str"");
  }
}",0.9496347558631296
99003,"public void retryPaxosCommand(List<Integer> addrs,Integer instNum,byte[] payload){
  proposeCommand(addrs,instNum,payload);
}","public void retryPaxosCommand(List<Integer> addrs,Integer instNum,byte[] payload){
  replicateCommand(addrs,payload);
}",0.918032786885246
99004,"private void handleDecisionMessage(int instNum,byte[] payload){
  PaxosState state=this.rounds.get(instNum);
  if (state == null) {
    noteOutput(""String_Node_Str"" + instNum + ""String_Node_Str"");
    state=new PaxosState(instNum,payload,false);
    this.rounds.put(instNum,state);
  }
  state.value=payload;
  state.decided=true;
  if (instNum == highestExecutedNum + 1) {
    noteOutput(""String_Node_Str"" + instNum + ""String_Node_Str"");
    if (state.value != null) {
      handlePaxosCommand(state.instNum,state.value);
    }
 else {
      noteOutput(""String_Node_Str"" + instNum + ""String_Node_Str"");
    }
    state.executed=true;
    this.highestExecutedNum=instNum;
  }
 else {
    noteOutput(""String_Node_Str"" + instNum + ""String_Node_Str"");
    int gapLength=instNum - this.highestExecutedNum - 1;
    for (int i=0; i < gapLength; i++) {
      List<Integer> addrs=Arrays.asList(REPLICA_ADDRS);
      learnCommand(addrs,highestExecutedNum + i);
    }
  }
  logKnownCommands();
}","private void handleDecisionMessage(int instNum,byte[] payload){
  PaxosState state=this.rounds.get(instNum);
  if (state == null) {
    noteOutput(""String_Node_Str"" + instNum + ""String_Node_Str"");
    state=new PaxosState(instNum,payload,false);
    this.rounds.put(instNum,state);
  }
  state.decidedValue=payload;
  state.decided=true;
  if (instNum == highestExecutedNum + 1) {
    noteOutput(""String_Node_Str"" + instNum + ""String_Node_Str"");
    if (state.decidedValue != null) {
      handlePaxosCommand(state.instNum,state.decidedValue);
    }
 else {
      noteOutput(""String_Node_Str"" + instNum + ""String_Node_Str"");
    }
    state.executed=true;
    this.highestExecutedNum=instNum;
  }
 else {
    noteOutput(""String_Node_Str"" + instNum + ""String_Node_Str"");
    int gapLength=instNum - this.highestExecutedNum - 1;
    for (int i=0; i < gapLength; i++) {
      learnCommand(state.participants,highestExecutedNum + i);
    }
  }
  logKnownCommands();
}",0.9342915811088296
99005,"/** 
 * Called if we have decided to go ahead with posting onto this wall. We'll do the posting such that it is guaranteed to eventually succeed as long as this method is called until completion.
 * @throws IOException 
 */
public void commitWallPost(UUID txnId,String args) throws IOException {
  Object[] objArgs=parseArgs(args);
  @SuppressWarnings(""String_Node_Str"") List<String> nameList=(List<String>)objArgs[0];
  String message=(String)objArgs[1];
  List<File> oldTemps=Utility.getMatchingFiles(addr,WALL_POST_TEMP_PREFIX);
  for (  File f : oldTemps) {
    String txnIdString=txnId.toString();
    String fileTxnString=f.getName().substring(f.getName().indexOf(""String_Node_Str""));
    printOutput(""String_Node_Str"" + fileTxnString + ""String_Node_Str""+ txnIdString);
    if (!fileTxnString.equals(txnIdString)) {
      printOutput(""String_Node_Str"" + f.getName());
      this.getWriter(f.getName(),false).delete();
    }
  }
  for (  String name : nameList) {
    if (Utility.fileExists(this,MESSAGES_PREFIX + name)) {
      String tempFileName=getWallTempName(txnId,name);
      PersistentStorageReader tempReader=null;
      if (Utility.fileExists(this,tempFileName)) {
        tempReader=this.getReader(tempFileName);
      }
      if (tempReader != null && tempReader.ready()) {
        char[] buf=new char[MAX_FILE_SIZE];
        tempReader.read(buf,0,MAX_FILE_SIZE);
        PersistentStorageWriter postsFileWriter=this.getWriter(MESSAGES_PREFIX + name,false);
        postsFileWriter.write(buf);
      }
 else {
        assert(Utility.fileExists(this,MESSAGES_PREFIX + name));
        PersistentStorageReader masterFileReader=this.getReader(MESSAGES_PREFIX + name);
        char[] buf=new char[MAX_FILE_SIZE];
        int length=masterFileReader.read(buf,0,MAX_FILE_SIZE);
        String contents;
        if (length == -1) {
          contents=""String_Node_Str"";
        }
 else {
          contents=new String(buf,0,length);
        }
        contents+=message + '\n';
        PersistentStorageWriter tempWriter=this.getWriter(tempFileName,false);
        tempWriter.write(contents);
        PersistentStorageWriter masterWriter=this.getWriter(MESSAGES_PREFIX + name,false);
        masterWriter.write(contents);
      }
    }
  }
  if (addr == CLIENT_ID) {
    printOutput(""String_Node_Str"");
  }
}","/** 
 * Called if we have decided to go ahead with posting onto this wall. We'll do the posting such that it is guaranteed to eventually succeed as long as this method is called until completion.
 * @throws IOException 
 */
public void commitWallPost(UUID txnId,String args) throws IOException {
  Object[] objArgs=parseArgs(args);
  @SuppressWarnings(""String_Node_Str"") List<String> nameList=(List<String>)objArgs[0];
  String message=(String)objArgs[1];
  List<File> oldTemps=Utility.getMatchingFiles(addr,WALL_POST_TEMP_PREFIX);
  for (  File f : oldTemps) {
    String txnIdString=txnId.toString();
    String fileTxnString=f.getName().substring(f.getName().indexOf(""String_Node_Str"") + 2);
    printOutput(""String_Node_Str"" + fileTxnString + ""String_Node_Str""+ txnIdString);
    if (!fileTxnString.equals(txnIdString)) {
      printOutput(""String_Node_Str"" + f.getName());
      this.getWriter(f.getName(),false).delete();
    }
  }
  for (  String name : nameList) {
    if (Utility.fileExists(this,MESSAGES_PREFIX + name)) {
      String tempFileName=getWallTempName(txnId,name);
      PersistentStorageReader tempReader=null;
      if (Utility.fileExists(this,tempFileName)) {
        tempReader=this.getReader(tempFileName);
      }
      if (tempReader != null && tempReader.ready()) {
        char[] buf=new char[MAX_FILE_SIZE];
        tempReader.read(buf,0,MAX_FILE_SIZE);
        PersistentStorageWriter postsFileWriter=this.getWriter(MESSAGES_PREFIX + name,false);
        postsFileWriter.write(buf);
      }
 else {
        assert(Utility.fileExists(this,MESSAGES_PREFIX + name));
        PersistentStorageReader masterFileReader=this.getReader(MESSAGES_PREFIX + name);
        char[] buf=new char[MAX_FILE_SIZE];
        int length=masterFileReader.read(buf,0,MAX_FILE_SIZE);
        String contents;
        if (length == -1) {
          contents=""String_Node_Str"";
        }
 else {
          contents=new String(buf,0,length);
        }
        contents+=message + '\n';
        PersistentStorageWriter tempWriter=this.getWriter(tempFileName,false);
        tempWriter.write(contents);
        PersistentStorageWriter masterWriter=this.getWriter(MESSAGES_PREFIX + name,false);
        masterWriter.write(contents);
      }
    }
  }
  if (addr == CLIENT_ID) {
    printOutput(""String_Node_Str"");
  }
}",0.9991375592927986
99006,"/** 
 * Set failure/recovery/delay/drop rates based on command line options, default == 0% 
 */
public static double getFailureRate(){
  return .1 / 100.0;
}","/** 
 * Set failure/recovery/delay/drop rates based on command line options, default == 0% 
 */
public static double getFailureRate(){
  return .6 / 100.0;
}",0.9936305732484076
99007,"public TxnPacket receiveTxnDecisionRequest(TxnPacket pkt){
  if (!participantTxns.containsKey(pkt.getID())) {
    return null;
  }
  TxnState txnState=participantTxns.get(pkt.getID());
  if (txnState != null) {
    writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
    if (txnState.status == TxnState.TxnStatus.ABORTED) {
      writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
      return TxnPacket.getAbortPacket(this,txnState.txnID,txnState.request);
    }
 else     if (txnState.status == TxnState.TxnStatus.COMMITTED) {
      writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
      return TxnPacket.getCommitPacket(this,txnState.txnID,txnState.request,txnState.args);
    }
    writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str""+ txnState.status);
  }
 else {
    writeOutput(""String_Node_Str"" + pkt.getID() + ""String_Node_Str"");
  }
  return null;
}","public TxnPacket receiveTxnDecisionRequest(TxnPacket pkt){
  if (!participantTxns.containsKey(pkt.getID())) {
    return null;
  }
  TxnState txnState=participantTxns.get(pkt.getID());
  if (txnState != null) {
    writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
    if (txnState.status == TxnState.TxnStatus.ABORTED) {
      writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
      return TxnPacket.getAbortPacket(this,txnState.txnID,txnState.request);
    }
 else     if (txnState.status == TxnState.TxnStatus.COMMITTED) {
      writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
      return TxnPacket.getCommitPacket(this,txnState.txnID,txnState.request,txnState.args);
    }
 else     if (txnState.status == TxnState.TxnStatus.DONE) {
      if (txnState.wasCommitted) {
        writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
        return TxnPacket.getCommitPacket(this,txnState.txnID,txnState.request,txnState.args);
      }
 else {
        writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
        return TxnPacket.getAbortPacket(this,txnState.txnID,txnState.request);
      }
    }
    writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str""+ txnState.status);
  }
 else {
    writeOutput(""String_Node_Str"" + pkt.getID() + ""String_Node_Str"");
  }
  return null;
}",0.8043290043290043
99008,"@Override public void start(){
  super.start();
  this.coordinatorTxns=new HashMap<UUID,TxnState>();
  this.participantTxns=new HashMap<UUID,TxnState>();
  this.logFile=LOG_FILE + addr;
  this.txnLogger=new TxnLog(this.logFile,this);
  try {
    if (Utility.fileExists(this,this.logFile)) {
      writeOutput(""String_Node_Str"");
      PersistentStorageReader reader=getReader(this.logFile);
      while (reader.ready()) {
        String line=reader.readLine();
        writeOutput(""String_Node_Str"" + line);
        String[] parts=line.split(""String_Node_Str"",2);
        TxnLog.Record r=TxnLog.parseRecordType(parts[0]);
        String txnRecordData=parts[1];
        TxnState txnState;
switch (r) {
case START:
          txnState=TxnState.fromRecordString(txnRecordData);
        coordinatorTxns.put(txnState.txnID,txnState);
      break;
case COMMIT:
    txnState=TxnState.fromRecordString(txnRecordData);
  if (coordinatorTxns.containsKey(txnState.txnID)) {
    coordinatorTxns.get(txnState.txnID).status=TxnState.TxnStatus.COMMITTED;
  }
if (participantTxns.containsKey(txnState.txnID)) {
  participantTxns.get(txnState.txnID).status=TxnState.TxnStatus.COMMITTED;
}
break;
case ABORT:
txnState=TxnState.fromRecordString(txnRecordData);
if (coordinatorTxns.containsKey(txnState.txnID)) {
coordinatorTxns.get(txnState.txnID).status=TxnState.TxnStatus.ABORTED;
}
if (participantTxns.containsKey(txnState.txnID)) {
participantTxns.get(txnState.txnID).status=TxnState.TxnStatus.ABORTED;
}
break;
case ACCEPT:
txnState=TxnState.fromRecordString(txnRecordData);
txnState.status=TxnState.TxnStatus.WAITING;
participantTxns.put(txnState.txnID,txnState);
break;
case REJECT:
txnState=TxnState.fromRecordString(txnRecordData);
txnState.status=TxnState.TxnStatus.ABORTED;
participantTxns.put(txnState.txnID,txnState);
break;
case DONE:
txnState=TxnState.fromRecordString(txnRecordData);
participantTxns.get(txnState.txnID).status=TxnState.TxnStatus.DONE;
break;
}
}
for (TxnState txnState : coordinatorTxns.values()) {
if (txnState.status == TxnState.TxnStatus.UNKNOWN) {
txnLogger.logAbort(txnState);
writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
sendTxnAbort(null,txnState.txnID);
}
}
for (TxnState txnState : participantTxns.values()) {
if (txnState.status == TxnState.TxnStatus.WAITING) {
writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
sendDecisionRequest(txnState.txnID);
}
 else if (txnState.status == TxnState.TxnStatus.ABORTED) {
writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
recieveTxnAbort(TxnPacket.getAbortPacket(this,txnState.txnID,txnState.request));
}
 else if (txnState.status == TxnState.TxnStatus.COMMITTED) {
writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
recieveTxnCommit(TxnPacket.getCommitPacket(this,txnState.txnID,txnState.request,txnState.args));
}
}
}
}
 catch (IOException e) {
writeError(""String_Node_Str"");
e.printStackTrace();
fail();
}
}","@Override public void start(){
  super.start();
  this.coordinatorTxns=new HashMap<UUID,TxnState>();
  this.participantTxns=new HashMap<UUID,TxnState>();
  this.logFile=LOG_FILE + addr;
  this.txnLogger=new TxnLog(this.logFile,this);
  try {
    if (Utility.fileExists(this,this.logFile)) {
      writeOutput(""String_Node_Str"");
      PersistentStorageReader reader=getReader(this.logFile);
      while (reader.ready()) {
        String line=reader.readLine();
        writeOutput(""String_Node_Str"" + line);
        String[] parts=line.split(""String_Node_Str"",2);
        TxnLog.Record r=TxnLog.parseRecordType(parts[0]);
        String txnRecordData=parts[1];
        TxnState txnState;
switch (r) {
case START:
          txnState=TxnState.fromRecordString(txnRecordData);
        coordinatorTxns.put(txnState.txnID,txnState);
      break;
case COMMIT:
    txnState=TxnState.fromRecordString(txnRecordData);
  txnState.wasCommitted=true;
if (coordinatorTxns.containsKey(txnState.txnID)) {
  coordinatorTxns.get(txnState.txnID).status=TxnState.TxnStatus.COMMITTED;
}
if (participantTxns.containsKey(txnState.txnID)) {
participantTxns.get(txnState.txnID).status=TxnState.TxnStatus.COMMITTED;
}
break;
case ABORT:
txnState=TxnState.fromRecordString(txnRecordData);
if (coordinatorTxns.containsKey(txnState.txnID)) {
coordinatorTxns.get(txnState.txnID).status=TxnState.TxnStatus.ABORTED;
}
if (participantTxns.containsKey(txnState.txnID)) {
participantTxns.get(txnState.txnID).status=TxnState.TxnStatus.ABORTED;
}
break;
case ACCEPT:
txnState=TxnState.fromRecordString(txnRecordData);
txnState.status=TxnState.TxnStatus.WAITING;
participantTxns.put(txnState.txnID,txnState);
break;
case REJECT:
txnState=TxnState.fromRecordString(txnRecordData);
txnState.status=TxnState.TxnStatus.ABORTED;
participantTxns.put(txnState.txnID,txnState);
break;
case DONE:
txnState=TxnState.fromRecordString(txnRecordData);
participantTxns.get(txnState.txnID).status=TxnState.TxnStatus.DONE;
break;
}
}
for (TxnState txnState : coordinatorTxns.values()) {
if (txnState.status == TxnState.TxnStatus.UNKNOWN) {
txnLogger.logAbort(txnState);
writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
sendTxnAbort(null,txnState.txnID);
}
}
for (TxnState txnState : participantTxns.values()) {
if (txnState.status == TxnState.TxnStatus.WAITING) {
writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
sendDecisionRequest(txnState.txnID);
}
 else if (txnState.status == TxnState.TxnStatus.ABORTED) {
writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
recieveTxnAbort(TxnPacket.getAbortPacket(this,txnState.txnID,txnState.request));
}
 else if (txnState.status == TxnState.TxnStatus.COMMITTED) {
writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
recieveTxnCommit(TxnPacket.getCommitPacket(this,txnState.txnID,txnState.request,txnState.args));
}
}
}
}
 catch (IOException e) {
writeError(""String_Node_Str"");
e.printStackTrace();
fail();
}
}",0.9942606347062796
99009,"private void recieveTxnCommit(TxnPacket pkt){
  TxnState txnState=participantTxns.get(pkt.getID());
  txnLogger.logCommit(txnState);
  txnState.status=TxnState.TxnStatus.COMMITTED;
  String request=pkt.getRequest();
  try {
    writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
    Class<? extends TransactionNode> me=this.getClass();
    Method handler=me.getDeclaredMethod(COMMIT_PREFIX + request,java.util.UUID.class,java.lang.String.class);
    handler.invoke(this,txnState.txnID,pkt.getPayload());
    txnLogger.logDone(txnState);
    writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
  }
 catch (  NoSuchMethodException e) {
    writeError(""String_Node_Str"" + request);
    fail();
  }
catch (  IllegalArgumentException e) {
    writeError(""String_Node_Str"" + request + ""String_Node_Str"");
    fail();
  }
catch (  Exception e) {
    writeError(""String_Node_Str"" + request + ""String_Node_Str""+ e.getMessage());
    this.fail();
  }
}","private void recieveTxnCommit(TxnPacket pkt){
  TxnState txnState=participantTxns.get(pkt.getID());
  txnState.wasCommitted=true;
  txnLogger.logCommit(txnState);
  txnState.status=TxnState.TxnStatus.COMMITTED;
  String request=pkt.getRequest();
  try {
    writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
    Class<? extends TransactionNode> me=this.getClass();
    Method handler=me.getDeclaredMethod(COMMIT_PREFIX + request,java.util.UUID.class,java.lang.String.class);
    handler.invoke(this,txnState.txnID,pkt.getPayload());
    txnLogger.logDone(txnState);
    writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
  }
 catch (  NoSuchMethodException e) {
    writeError(""String_Node_Str"" + request);
    fail();
  }
catch (  IllegalArgumentException e) {
    writeError(""String_Node_Str"" + request + ""String_Node_Str"");
    fail();
  }
catch (  Exception e) {
    writeError(""String_Node_Str"" + request + ""String_Node_Str""+ e.getMessage());
    this.fail();
  }
}",0.9848790322580644
99010,"@Override public void start(){
  super.start();
  this.coordinatorTxns=new HashMap<UUID,TxnState>();
  this.participantTxns=new HashMap<UUID,TxnState>();
  this.logFile=LOG_FILE + addr;
  try {
    if (Utility.fileExists(this,this.logFile)) {
      writeOutput(""String_Node_Str"");
      PersistentStorageReader reader=getReader(this.logFile);
      while (reader.ready()) {
        String line=reader.readLine();
        writeOutput(""String_Node_Str"" + line);
        String[] parts=line.split(""String_Node_Str"",2);
        TxnLog.Record r=TxnLog.parseRecordType(parts[0]);
        String txnRecordData=parts[1];
        TxnState txnState;
switch (r) {
case START:
          txnState=TxnState.fromRecordString(txnRecordData);
        coordinatorTxns.put(txnState.txnID,txnState);
      break;
case COMMIT:
    txnState=TxnState.fromRecordString(txnRecordData);
  if (coordinatorTxns.containsKey(txnState.txnID)) {
    coordinatorTxns.get(txnState.txnID).status=TxnState.TxnStatus.COMMITTED;
  }
if (participantTxns.containsKey(txnState.txnID)) {
  participantTxns.get(txnState.txnID).status=TxnState.TxnStatus.COMMITTED;
}
break;
case ABORT:
txnState=TxnState.fromRecordString(txnRecordData);
if (coordinatorTxns.containsKey(txnState.txnID)) {
coordinatorTxns.get(txnState.txnID).status=TxnState.TxnStatus.ABORTED;
}
if (participantTxns.containsKey(txnState.txnID)) {
participantTxns.get(txnState.txnID).status=TxnState.TxnStatus.ABORTED;
}
break;
case ACCEPT:
txnState=TxnState.fromRecordString(txnRecordData);
txnState.status=TxnState.TxnStatus.WAITING;
participantTxns.put(txnState.txnID,txnState);
break;
case REJECT:
txnState=TxnState.fromRecordString(txnRecordData);
txnState.status=TxnState.TxnStatus.ABORTED;
participantTxns.put(txnState.txnID,txnState);
break;
case DONE:
txnState=TxnState.fromRecordString(txnRecordData);
participantTxns.get(txnState.txnID).status=TxnState.TxnStatus.DONE;
break;
}
}
for (TxnState txnState : coordinatorTxns.values()) {
if (txnState.status == TxnState.TxnStatus.UNKNOWN) {
txnLogger.logAbort(txnState);
writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
sendTxnAbort(null,txnState.txnID);
}
}
for (TxnState txnState : participantTxns.values()) {
if (txnState.status == TxnState.TxnStatus.WAITING) {
writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
sendDecisionRequest(txnState.txnID);
}
 else if (txnState.status == TxnState.TxnStatus.ABORTED) {
writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
recieveTxnAbort(TxnPacket.getAbortPacket(this,txnState.txnID,txnState.request));
}
 else if (txnState.status == TxnState.TxnStatus.COMMITTED) {
writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
recieveTxnCommit(TxnPacket.getCommitPacket(this,txnState.txnID,txnState.request,txnState.args));
}
}
}
}
 catch (IOException e) {
writeError(""String_Node_Str"");
e.printStackTrace();
fail();
}
this.txnLogger=new TxnLog(this.logFile,this);
}","@Override public void start(){
  super.start();
  this.coordinatorTxns=new HashMap<UUID,TxnState>();
  this.participantTxns=new HashMap<UUID,TxnState>();
  this.logFile=LOG_FILE + addr;
  this.txnLogger=new TxnLog(this.logFile,this);
  try {
    if (Utility.fileExists(this,this.logFile)) {
      writeOutput(""String_Node_Str"");
      PersistentStorageReader reader=getReader(this.logFile);
      while (reader.ready()) {
        String line=reader.readLine();
        writeOutput(""String_Node_Str"" + line);
        String[] parts=line.split(""String_Node_Str"",2);
        TxnLog.Record r=TxnLog.parseRecordType(parts[0]);
        String txnRecordData=parts[1];
        TxnState txnState;
switch (r) {
case START:
          txnState=TxnState.fromRecordString(txnRecordData);
        coordinatorTxns.put(txnState.txnID,txnState);
      break;
case COMMIT:
    txnState=TxnState.fromRecordString(txnRecordData);
  if (coordinatorTxns.containsKey(txnState.txnID)) {
    coordinatorTxns.get(txnState.txnID).status=TxnState.TxnStatus.COMMITTED;
  }
if (participantTxns.containsKey(txnState.txnID)) {
  participantTxns.get(txnState.txnID).status=TxnState.TxnStatus.COMMITTED;
}
break;
case ABORT:
txnState=TxnState.fromRecordString(txnRecordData);
if (coordinatorTxns.containsKey(txnState.txnID)) {
coordinatorTxns.get(txnState.txnID).status=TxnState.TxnStatus.ABORTED;
}
if (participantTxns.containsKey(txnState.txnID)) {
participantTxns.get(txnState.txnID).status=TxnState.TxnStatus.ABORTED;
}
break;
case ACCEPT:
txnState=TxnState.fromRecordString(txnRecordData);
txnState.status=TxnState.TxnStatus.WAITING;
participantTxns.put(txnState.txnID,txnState);
break;
case REJECT:
txnState=TxnState.fromRecordString(txnRecordData);
txnState.status=TxnState.TxnStatus.ABORTED;
participantTxns.put(txnState.txnID,txnState);
break;
case DONE:
txnState=TxnState.fromRecordString(txnRecordData);
participantTxns.get(txnState.txnID).status=TxnState.TxnStatus.DONE;
break;
}
}
for (TxnState txnState : coordinatorTxns.values()) {
if (txnState.status == TxnState.TxnStatus.UNKNOWN) {
txnLogger.logAbort(txnState);
writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
sendTxnAbort(null,txnState.txnID);
}
}
for (TxnState txnState : participantTxns.values()) {
if (txnState.status == TxnState.TxnStatus.WAITING) {
writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
sendDecisionRequest(txnState.txnID);
}
 else if (txnState.status == TxnState.TxnStatus.ABORTED) {
writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
recieveTxnAbort(TxnPacket.getAbortPacket(this,txnState.txnID,txnState.request));
}
 else if (txnState.status == TxnState.TxnStatus.COMMITTED) {
writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
recieveTxnCommit(TxnPacket.getCommitPacket(this,txnState.txnID,txnState.request,txnState.args));
}
}
}
}
 catch (IOException e) {
writeError(""String_Node_Str"");
e.printStackTrace();
fail();
}
}",0.9840677966101696
99011,"private void proposeCommand(List<Integer> addrs,int instNum,byte[] payload,int backoff){
  if (!this.rounds.get(instNum).decided) {
    int propNum=this.rounds.get(instNum).propNum;
    for (    Integer nodeAddr : addrs) {
      PaxosPacket prepare=PaxosPacket.makePrepareMessage(instNum,propNum,payload);
      noteOutput(""String_Node_Str"" + instNum + ""String_Node_Str""+ propNum+ ""String_Node_Str""+ nodeAddr+ ""String_Node_Str""+ (payload != null ? Utility.byteArrayToString(payload) : ""String_Node_Str""));
      RIOSend(nodeAddr,Protocol.PAXOS_PKT,prepare.pack());
    }
    try {
      Method m=Callback.getMethod(""String_Node_Str"",this,new String[]{List.class.getName(),Integer.class.getName(),byte[].class.getName(),Integer.class.getName()});
      Callback retry=new Callback(m,this,new Object[]{addrs,instNum,payload,backoff * 2 + r.nextInt() % RANDOM_BACKOFF_MAX});
      addTimeout(retry,backoff);
    }
 catch (    Exception e) {
      noteError(""String_Node_Str"" + instNum + ""String_Node_Str"");
      e.printStackTrace();
      fail();
    }
  }
 else {
    noteOutput(""String_Node_Str"" + instNum + ""String_Node_Str"");
  }
}","public void proposeCommand(List<Integer> addrs,Integer instNum,byte[] payload,Integer backoff){
  if (!this.rounds.get(instNum).decided) {
    int propNum=this.rounds.get(instNum).propNum;
    for (    Integer nodeAddr : addrs) {
      PaxosPacket prepare=PaxosPacket.makePrepareMessage(instNum,propNum,payload);
      noteOutput(""String_Node_Str"" + instNum + ""String_Node_Str""+ propNum+ ""String_Node_Str""+ nodeAddr+ ""String_Node_Str""+ (payload != null ? Utility.byteArrayToString(payload) : ""String_Node_Str""));
      RIOSend(nodeAddr,Protocol.PAXOS_PKT,prepare.pack());
    }
    try {
      Method m=Callback.getMethod(""String_Node_Str"",this,new String[]{List.class.getName(),Integer.class.getName(),byte[].class.getName(),Integer.class.getName()});
      Callback retry=new Callback(m,this,new Object[]{addrs,instNum,payload,backoff * 2 + r.nextInt() % RANDOM_BACKOFF_MAX});
      addTimeout(retry,backoff);
    }
 catch (    Exception e) {
      noteError(""String_Node_Str"" + instNum + ""String_Node_Str"");
      e.printStackTrace();
      fail();
    }
  }
 else {
    noteOutput(""String_Node_Str"" + instNum + ""String_Node_Str"");
  }
}",0.9863616366036076
99012,"@Override public void onReceive(Integer from,int protocol,byte[] msg){
  if (protocol == Protocol.DATA) {
    RIOLayer.RIODataReceive(from,msg);
  }
 else   if (protocol == Protocol.ACK) {
    RIOLayer.RIOAckReceive(from,msg);
  }
}","@Override public void onReceive(Integer from,int protocol,byte[] msg){
  if (protocol == Protocol.DATA) {
    RIOLayer.RIODataReceive(from,msg);
  }
 else   if (protocol == Protocol.ACK) {
    RIOLayer.RIOAckReceive(from,msg);
  }
 else   if (protocol == Protocol.SYNC) {
    RIOLayer.RIOSyncReceive(from,msg);
  }
}",0.8467153284671532
99013,"/** 
 * Constructing a new RIO packet.
 * @param type The type of packet. Either SYN, ACK, FIN, or DATA
 * @param seqNum The sequence number of the packet
 * @param payload The payload of the packet.
 */
public RIOPacket(int protocol,int seqNum,byte[] payload) throws IllegalArgumentException {
  if (!Protocol.isRIOProtocolValid(protocol) || payload.length > MAX_PAYLOAD_SIZE) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.protocol=protocol;
  this.seqNum=seqNum;
  this.payload=payload;
}","/** 
 * Constructing a new RIO packet.
 * @param type The type of packet. Either SYN, ACK, FIN, or DATA
 * @param seqNum The sequence number of the packet
 * @param payload The payload of the packet.
 */
public RIOPacket(int protocol,int seqNum,int sessionId,byte[] payload) throws IllegalArgumentException {
  if (!Protocol.isRIOProtocolValid(protocol) || payload.length > MAX_PAYLOAD_SIZE) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.protocol=protocol;
  this.seqNum=seqNum;
  this.sessionId=sessionId;
  this.payload=payload;
}",0.9385474860335196
99014,"/** 
 * Convert the RIOPacket packet object into a byte array for sending over the wire. Format: protocol = 1 byte sequence number = 4 bytes payload <= MAX_PAYLOAD_SIZE bytes
 * @return A byte[] for transporting over the wire. Null if failed to pack for some reason
 */
public byte[] pack(){
  try {
    ByteArrayOutputStream byteStream=new ByteArrayOutputStream();
    DataOutputStream out=new DataOutputStream(byteStream);
    out.writeByte(protocol);
    out.writeInt(seqNum);
    out.write(payload,0,payload.length);
    out.flush();
    out.close();
    return byteStream.toByteArray();
  }
 catch (  IOException e) {
    return null;
  }
}","/** 
 * Convert the RIOPacket packet object into a byte array for sending over the wire. Format: protocol = 1 byte sequence number = 4 bytes payload <= MAX_PAYLOAD_SIZE bytes
 * @return A byte[] for transporting over the wire. Null if failed to pack for some reason
 */
public byte[] pack(){
  try {
    ByteArrayOutputStream byteStream=new ByteArrayOutputStream();
    DataOutputStream out=new DataOutputStream(byteStream);
    out.writeByte(protocol);
    out.writeInt(seqNum);
    out.writeInt(sessionId);
    out.write(payload,0,payload.length);
    out.flush();
    out.close();
    return byteStream.toByteArray();
  }
 catch (  IOException e) {
    return null;
  }
}",0.978013646702047
99015,"@Override public void onRIOReceive(Integer from,int protocol,byte[] msg){
  if (protocol != Protocol.RIOTEST_PKT) {
    logError(""String_Node_Str"" + protocol);
    return;
  }
  Integer i=Integer.parseInt(Utility.byteArrayToString(msg));
  Integer receivedNum=receivedNums.get(from);
  if (i == receivedNum + 1) {
    correctReceive(from,i);
  }
 else {
    failure(from,i);
  }
}","@Override public void onRIOReceive(Integer from,int protocol,byte[] msg){
  if (protocol != Protocol.RIOTEST_PKT) {
    logError(""String_Node_Str"" + protocol);
    return;
  }
  Integer i=Integer.parseInt(Utility.byteArrayToString(msg));
  Integer receivedNum=receivedNums.get(from);
  if (i <= receivedNum) {
    failure(from,i);
  }
}",0.9189944134078212
99016,"/** 
 * Called when we have received a packet from the underlying layer out of order.
 * @param from The address of the sender
 * @param i The number of the packet received.
 */
public void failure(int from,int i){
  logError(""String_Node_Str"" + i + ""String_Node_Str""+ receivedNums.get(from)+ ""String_Node_Str""+ from);
  receivedNums.put(from,i);
  failed=true;
  fail();
}","/** 
 * Called when we have received a packet from the underlying layer out of order.
 * @param from The address of the sender
 * @param i The number of the packet received.
 */
public void failure(int from,int i){
  logError(""String_Node_Str"" + i + ""String_Node_Str""+ (receivedNums.get(from) + 1)+ ""String_Node_Str""+ from);
  receivedNums.put(from,i);
  failed=true;
  fail();
}",0.9920212765957448
99017,"public void acceptedFriendSuccess(String username){
  doingWork=false;
  printOutput(""String_Node_Str"" + username + ""String_Node_Str"");
}","public void acceptedFriendSuccess(Integer from,byte[] results,String username){
  doingWork=false;
  printOutput(""String_Node_Str"" + username + ""String_Node_Str"");
}",0.9072847682119204
99018,"public void userExists(Integer errorCode,String userName,Callback userExistsCallback,Callback userNoExistsCallback) throws SecurityException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {
  String[] failParamTypes={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  Method tryAgain=Callback.getMethod(""String_Node_Str"",this,failParamTypes);
  Object[] failParams={null,userName,userExistsCallback,userNoExistsCallback};
  Callback tryAgainCallback=new Callback(tryAgain,this,failParams);
  if (errorCode != null && errorCode.equals(FILE_NO_EXIST)) {
    printOutput(""String_Node_Str"");
    createUsersFile(null,userNoExistsCallback);
    return;
  }
  if (userDataLocations.keySet().size() > 0) {
    if (!userDataLocations.containsKey(userName)) {
      userNoExistsCallback.invoke();
    }
 else {
      userExistsCallback.invoke();
    }
    return;
  }
  String[] pTypes={Integer.class.getName(),byte[].class.getName(),String.class.getName(),Callback.class.getName(),Callback.class.getName()};
  Method checkForName=Callback.getMethod(""String_Node_Str"",this,pTypes);
  Object[] p={null,null,userName,userExistsCallback,userNoExistsCallback};
  Callback checkForNameCallback=new Callback(checkForName,this,p);
  get(ALL_USERS_LOCATION,ALL_USERS_FILE,checkForNameCallback,tryAgainCallback);
}","public void userExists(Integer errorCode,String userName,Callback userExistsCallback,Callback userNoExistsCallback) throws SecurityException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {
  String[] failParamTypes={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  Method tryAgain=Callback.getMethod(""String_Node_Str"",this,failParamTypes);
  Object[] failParams={null,userName,userExistsCallback,userNoExistsCallback};
  Callback tryAgainCallback=new Callback(tryAgain,this,failParams);
  if (errorCode != null && errorCode.equals(FILE_NO_EXIST)) {
    createUsersFile(null,userNoExistsCallback);
    return;
  }
  if (userDataLocations.keySet().size() > 0) {
    if (!userDataLocations.containsKey(userName)) {
      userNoExistsCallback.invoke();
    }
 else {
      userExistsCallback.invoke();
    }
    return;
  }
  String[] pTypes={Integer.class.getName(),byte[].class.getName(),String.class.getName(),Callback.class.getName(),Callback.class.getName()};
  Method checkForName=Callback.getMethod(""String_Node_Str"",this,pTypes);
  Object[] p={null,null,userName,userExistsCallback,userNoExistsCallback};
  Callback checkForNameCallback=new Callback(checkForName,this,p);
  get(ALL_USERS_LOCATION,ALL_USERS_FILE,checkForNameCallback,tryAgainCallback);
}",0.9867060561299852
99019,"public void getRequestList(Integer from,byte[] result,String username) throws SecurityException, ClassNotFoundException, NoSuchMethodException {
  String[] failParamTypes={""String_Node_Str"",""String_Node_Str""};
  Method tryAgain=Callback.getMethod(""String_Node_Str"",this,failParamTypes);
  Object[] failParams={null,username};
  Callback tryAgainCallback=new Callback(tryAgain,this,failParams);
  String[] goodParamTypes={""String_Node_Str"",""String_Node_Str""};
  Method continueMethod=Callback.getMethod(""String_Node_Str"",this,goodParamTypes);
  Object[] goodParams={null,username};
  Callback continuationCallback=new Callback(continueMethod,this,goodParams);
  String filename=REQUESTS_PREFIX + loggedInUser;
  get(userDataLocations.get(loggedInUser),filename,continuationCallback,tryAgainCallback);
}","public void getRequestList(Integer from,byte[] result,String username) throws SecurityException, ClassNotFoundException, NoSuchMethodException {
  String[] failParamTypes={""String_Node_Str"",""String_Node_Str""};
  Method tryAgain=Callback.getMethod(""String_Node_Str"",this,failParamTypes);
  Object[] failParams={null,username};
  Callback tryAgainCallback=new Callback(tryAgain,this,failParams);
  String[] goodParamTypes={Integer.class.getName(),byte[].class.getName(),""String_Node_Str""};
  Method continueMethod=Callback.getMethod(""String_Node_Str"",this,goodParamTypes);
  Object[] goodParams={null,null,username};
  Callback continuationCallback=new Callback(continueMethod,this,goodParams);
  String filename=REQUESTS_PREFIX + loggedInUser;
  get(userDataLocations.get(loggedInUser),filename,continuationCallback,tryAgainCallback);
}",0.8251833740831296
99020,"public void checkForNameInList(Integer errorCode,String userName,String filename,Integer serverId,Callback userExistsCallback,Callback userNoExistsCallback) throws SecurityException, ClassNotFoundException, NoSuchMethodException {
  String[] failParamTypes={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  Method tryAgain=Callback.getMethod(""String_Node_Str"",this,failParamTypes);
  Object[] failParams={null,userName,filename,null,userExistsCallback,userNoExistsCallback};
  Callback tryAgainCallback=new Callback(tryAgain,this,failParams);
  String[] pTypes={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  Method checkForName=Callback.getMethod(""String_Node_Str"",this,pTypes);
  Object[] p={null,userName,userExistsCallback,userNoExistsCallback};
  Callback checkForNameCallback=new Callback(checkForName,this,p);
  get(serverId,filename,checkForNameCallback,tryAgainCallback);
}","public void checkForNameInList(Integer errorCode,String userName,String filename,Integer serverId,Callback userExistsCallback,Callback userNoExistsCallback) throws SecurityException, ClassNotFoundException, NoSuchMethodException {
  String[] failParamTypes={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  Method tryAgain=Callback.getMethod(""String_Node_Str"",this,failParamTypes);
  Object[] failParams={null,userName,filename,null,userExistsCallback,userNoExistsCallback};
  Callback tryAgainCallback=new Callback(tryAgain,this,failParams);
  String[] pTypes={""String_Node_Str"",byte[].class.getName(),String.class.getName(),""String_Node_Str"",""String_Node_Str""};
  Method checkForName=Callback.getMethod(""String_Node_Str"",this,pTypes);
  Object[] p={null,null,userName,userExistsCallback,userNoExistsCallback};
  Callback checkForNameCallback=new Callback(checkForName,this,p);
  get(serverId,filename,checkForNameCallback,tryAgainCallback);
}",0.9661786976274608
99021,"public void removeFromRequestList(String fileContents,String username) throws SecurityException, ClassNotFoundException, NoSuchMethodException {
  Set<String> pendingRequests=new HashSet<String>();
  Scanner friendScanner=new Scanner(fileContents);
  while (friendScanner.hasNext()) {
    pendingRequests.add(friendScanner.next());
  }
  pendingRequests.remove(username);
  StringBuilder fixedFriendList=new StringBuilder();
  Iterator<String> listIterator=pendingRequests.iterator();
  while (listIterator.hasNext()) {
    fixedFriendList.append(listIterator.next() + ""String_Node_Str"");
  }
  String[] failParamTypes={Integer.class.getName(),String.class.getName()};
  Method tryAgain=Callback.getMethod(""String_Node_Str"",this,failParamTypes);
  Object[] failParams={null,username};
  Callback tryAgainCallback=new Callback(tryAgain,this,failParams);
  String[] goodParamTypes={""String_Node_Str""};
  Method continueMethod=Callback.getMethod(""String_Node_Str"",this,goodParamTypes);
  Object[] goodParams={username};
  Callback continuationCallback=new Callback(continueMethod,this,goodParams);
  String filename=REQUESTS_PREFIX + loggedInUser;
  String newFileContents=fixedFriendList.toString();
  put(userDataLocations.get(loggedInUser),filename,newFileContents,continuationCallback,tryAgainCallback);
}","public void removeFromRequestList(Integer from,byte[] contents,String username) throws SecurityException, ClassNotFoundException, NoSuchMethodException {
  String fileContents=Utility.byteArrayToString(contents);
  Set<String> pendingRequests=new HashSet<String>();
  Scanner friendScanner=new Scanner(fileContents);
  while (friendScanner.hasNext()) {
    pendingRequests.add(friendScanner.next());
  }
  pendingRequests.remove(username);
  StringBuilder fixedFriendList=new StringBuilder();
  Iterator<String> listIterator=pendingRequests.iterator();
  while (listIterator.hasNext()) {
    fixedFriendList.append(listIterator.next() + ""String_Node_Str"");
  }
  String[] failParamTypes={Integer.class.getName(),String.class.getName()};
  Method tryAgain=Callback.getMethod(""String_Node_Str"",this,failParamTypes);
  Object[] failParams={null,username};
  Callback tryAgainCallback=new Callback(tryAgain,this,failParams);
  String[] goodParamTypes={Integer.class.getName(),byte[].class.getName(),""String_Node_Str""};
  Method continueMethod=Callback.getMethod(""String_Node_Str"",this,goodParamTypes);
  Object[] goodParams={null,null,username};
  Callback continuationCallback=new Callback(continueMethod,this,goodParams);
  String filename=REQUESTS_PREFIX + loggedInUser;
  String newFileContents=fixedFriendList.toString();
  put(userDataLocations.get(loggedInUser),filename,newFileContents,continuationCallback,tryAgainCallback);
}",0.94702228717574
99022,"public void addToRequestsFile(Integer errorCode,String userName) throws SecurityException, ClassNotFoundException, NoSuchMethodException {
  if (errorCode != null && errorCode.equals(FILE_TOO_LARGE)) {
    printError(""String_Node_Str"" + userName + ""String_Node_Str"");
    doingWork=false;
    return;
  }
  if (errorCode != null && errorCode.equals(FILE_NO_EXIST)) {
    printError(""String_Node_Str"" + userName);
    doingWork=false;
    return;
  }
  String[] failParamTypes={""String_Node_Str"",""String_Node_Str""};
  Method tryAgain=Callback.getMethod(""String_Node_Str"",this,failParamTypes);
  Object[] failParams={null,userName};
  Callback tryAgainCallback=new Callback(tryAgain,this,failParams);
  String[] successParamTypes={Integer.class.getName(),byte[].class.getName(),String.class.getName()};
  Method showSuccess=Callback.getMethod(""String_Node_Str"",this,successParamTypes);
  Object[] successParams={null,null,userName};
  Callback successCallback=new Callback(showSuccess,this,successParams);
  String appendContents=""String_Node_Str"" + loggedInUser;
  String filename=REQUESTS_PREFIX + userName;
  append(userDataLocations.get(userName),filename,appendContents,successCallback,tryAgainCallback);
}","public void addToRequestsFile(Integer errorCode,String userName) throws SecurityException, ClassNotFoundException, NoSuchMethodException {
  if (errorCode != null && errorCode.equals(FILE_TOO_LARGE)) {
    printError(""String_Node_Str"" + userName + ""String_Node_Str"");
    doingWork=false;
    return;
  }
  if (!userDataLocations.containsKey(userName) || (errorCode != null && errorCode.equals(FILE_NO_EXIST))) {
    printError(""String_Node_Str"" + userName);
    doingWork=false;
    return;
  }
  String[] failParamTypes={""String_Node_Str"",""String_Node_Str""};
  Method tryAgain=Callback.getMethod(""String_Node_Str"",this,failParamTypes);
  Object[] failParams={null,userName};
  Callback tryAgainCallback=new Callback(tryAgain,this,failParams);
  String[] successParamTypes={Integer.class.getName(),byte[].class.getName(),String.class.getName()};
  Method showSuccess=Callback.getMethod(""String_Node_Str"",this,successParamTypes);
  Object[] successParams={null,null,userName};
  Callback successCallback=new Callback(showSuccess,this,successParams);
  String appendContents=""String_Node_Str"" + loggedInUser;
  String filename=REQUESTS_PREFIX + userName;
  append(userDataLocations.get(userName),filename,appendContents,successCallback,tryAgainCallback);
}",0.9813311688311688
99023,"public void showAllOfList(Integer errorCode,String filename,Integer serverId) throws SecurityException, ClassNotFoundException, NoSuchMethodException {
  String[] failParamTypes={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  Method tryAgain=Callback.getMethod(""String_Node_Str"",this,failParamTypes);
  Object[] failParams={null,filename,serverId};
  Callback tryAgainCallback=new Callback(tryAgain,this,failParams);
  String[] goodParamTypes={Integer.class.getName(),byte[].class.getName()};
  Method printResults=Callback.getMethod(""String_Node_Str"",this,goodParamTypes);
  Object[] goodParams={null};
  Callback printCallback=new Callback(printResults,this,goodParams);
  get(serverId,filename,printCallback,tryAgainCallback);
}","public void showAllOfList(Integer errorCode,String filename,Integer serverId) throws SecurityException, ClassNotFoundException, NoSuchMethodException {
  String[] failParamTypes={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  Method tryAgain=Callback.getMethod(""String_Node_Str"",this,failParamTypes);
  Object[] failParams={null,filename,serverId};
  Callback tryAgainCallback=new Callback(tryAgain,this,failParams);
  if (errorCode != null && errorCode == FILE_NO_EXIST) {
    printError(""String_Node_Str"");
    return;
  }
  String[] goodParamTypes={Integer.class.getName(),byte[].class.getName()};
  Method printResults=Callback.getMethod(""String_Node_Str"",this,goodParamTypes);
  Object[] goodParams={null,null};
  Callback printCallback=new Callback(printResults,this,goodParams);
  get(serverId,filename,printCallback,tryAgainCallback);
}",0.9292423293675642
99024,"public void sendDecisionRequest(UUID txnID){
  writeOutput(""String_Node_Str"" + txnID + ""String_Node_Str"");
  TxnState txnState=participantTxns.get(txnID);
  for (  Integer otherAddr : txnState.participants) {
    TxnPacket txnPkt=TxnPacket.getDecisionRequestPacket(this,txnID);
    Callback success=createCallback(""String_Node_Str"",new String[]{Byte[].class.getName()},null);
    makeRequest(Command.TXN,txnPkt.pack(),success,null,otherAddr,""String_Node_Str"");
    writeOutput(""String_Node_Str"" + txnID + ""String_Node_Str""+ otherAddr+ ""String_Node_Str"");
  }
  Callback decisionTimeout=createCallback(""String_Node_Str"",new String[]{UUID.class.getName()},new Object[]{txnID});
  addTimeout(decisionTimeout,DECISION_RESEND_TIMEOUT);
}","public void sendDecisionRequest(UUID txnID){
  writeOutput(""String_Node_Str"" + txnID + ""String_Node_Str"");
  TxnState txnState=participantTxns.get(txnID);
  for (  Integer otherAddr : txnState.participants) {
    TxnPacket txnPkt=TxnPacket.getDecisionRequestPacket(this,txnID);
    Callback success=createCallback(""String_Node_Str"",new String[]{byte[].class.getName()},null);
    makeRequest(Command.TXN,txnPkt.pack(),success,null,otherAddr,""String_Node_Str"");
    writeOutput(""String_Node_Str"" + txnID + ""String_Node_Str""+ otherAddr+ ""String_Node_Str"");
  }
  Callback decisionTimeout=createCallback(""String_Node_Str"",new String[]{UUID.class.getName()},new Object[]{txnID});
  addTimeout(decisionTimeout,DECISION_RESEND_TIMEOUT);
}",0.9986338797814208
99025,"@Override public void onCommand(String command){
  Scanner commandScanner=new Scanner(command);
  if (userDataLocations == null) {
    printError(""String_Node_Str"");
    return;
  }
  if (!commandScanner.hasNext()) {
    printError(""String_Node_Str"");
    return;
  }
  String commandName=commandScanner.next();
  if (commandName.equals(CREATE_COMMAND)) {
    if (!commandScanner.hasNext()) {
      printError(""String_Node_Str"");
      return;
    }
    String userName=commandScanner.next();
    if (commandScanner.hasNext()) {
      printError(""String_Node_Str"");
      return;
    }
    try {
      createNewUser(userName);
    }
 catch (    Exception e) {
      printError(""String_Node_Str"" + e.toString());
    }
  }
 else   if (commandName.equals(LOGIN_COMMAND)) {
    if (!commandScanner.hasNext()) {
      printError(""String_Node_Str"");
      return;
    }
    String userName=commandScanner.next();
    try {
      loginUser(userName);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (commandName.equals(LOGOUT_COMMAND)) {
    logoutUser();
  }
 else   if (commandName.equals(FRIEND_COMMAND)) {
    if (!commandScanner.hasNext()) {
      printError(""String_Node_Str"");
      return;
    }
    String userName=commandScanner.next();
    try {
      requestFriend(userName);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (commandName.equals(VIEW_REQUESTS_COMMAND)) {
    try {
      showRequests();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (commandName.equals(ACCEPT_COMMAND)) {
    if (!commandScanner.hasNext()) {
      printError(""String_Node_Str"");
      return;
    }
    String userName=commandScanner.next();
    try {
      acceptFriend(userName);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (commandName.equals(MESSAGE_COMMAND)) {
    if (!commandScanner.hasNext()) {
      printError(""String_Node_Str"");
      return;
    }
    int messageStart=command.indexOf(' ');
    String messageContent=command.substring(messageStart + 1);
    messageContent=loggedInUser + ""String_Node_Str"" + messageContent+ ""String_Node_Str"";
    try {
      postMessage(messageContent);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (commandName.equals(READ_COMMAND)) {
    try {
      readPosts();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (commandName.equals(SHOW_USERS_COMMAND)) {
    try {
      showUsers();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (commandName.equals(SHOW_FRIENDS_COMMAND)) {
    try {
      showFriends();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else {
    printError(""String_Node_Str"");
  }
}","@Override public void onCommand(String command){
  Scanner commandScanner=new Scanner(command);
  if (userDataLocations == null) {
    printError(""String_Node_Str"");
    return;
  }
  if (!commandScanner.hasNext()) {
    printError(""String_Node_Str"");
    return;
  }
  String commandName=commandScanner.next();
  if (commandName.equals(CREATE_COMMAND)) {
    if (!commandScanner.hasNext()) {
      printError(""String_Node_Str"");
      return;
    }
    String userName=commandScanner.next();
    if (commandScanner.hasNext()) {
      printError(""String_Node_Str"");
      return;
    }
    try {
      createNewUser(userName);
    }
 catch (    Exception e) {
      printError(""String_Node_Str"" + e.toString());
    }
  }
 else   if (commandName.equals(LOGIN_COMMAND)) {
    if (!commandScanner.hasNext()) {
      printError(""String_Node_Str"");
      return;
    }
    String userName=commandScanner.next();
    try {
      loginUser(userName);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (commandName.equals(LOGOUT_COMMAND)) {
    logoutUser();
  }
 else   if (commandName.equals(FRIEND_COMMAND)) {
    if (!commandScanner.hasNext()) {
      printError(""String_Node_Str"");
      return;
    }
    String userName=commandScanner.next();
    try {
      requestFriend(userName);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (commandName.equals(VIEW_REQUESTS_COMMAND)) {
    try {
      showRequests();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (commandName.equals(ACCEPT_COMMAND)) {
    if (!commandScanner.hasNext()) {
      printError(""String_Node_Str"");
      return;
    }
    String userName=commandScanner.next();
    try {
      acceptFriend(userName);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (commandName.equals(MESSAGE_COMMAND)) {
    if (!commandScanner.hasNext()) {
      printError(""String_Node_Str"");
      return;
    }
    int messageStart=command.indexOf(' ');
    String messageContent=command.substring(messageStart + 1);
    messageContent=loggedInUser + ""String_Node_Str"" + messageContent+ '\n';
    try {
      postMessage(messageContent);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (commandName.equals(READ_COMMAND)) {
    try {
      readPosts();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (commandName.equals(SHOW_USERS_COMMAND)) {
    try {
      showUsers();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (commandName.equals(SHOW_FRIENDS_COMMAND)) {
    try {
      showFriends();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else {
    printError(""String_Node_Str"");
  }
}",0.9962426194310252
99026,"/** 
 * Client-side handler for RPC Result packets. Logs a message to the console (unless this is a reply to a session id request) and calls the relevant callback (if it exists) dependent on whether status of the result is SUCCESS.
 * @param from
 * @param pkt
 */
private void handleRPCresult(Integer from,RPCResultPacket pkt){
  RPCRequest request=requestQueue.peek();
  if (request == null || pkt.getRequestID() != request.pckt.getRequestID()) {
    return;
  }
  Status status=pkt.getStatus();
  Command requestType=request.pckt.getRequest();
  if (requestType == Command.SESSION) {
    if (status == Status.SUCCESS) {
      serverSessionIDs.put(from,Integer.parseInt(Utility.byteArrayToString(pkt.getPayload())));
      requestQueue.poll();
    }
  }
 else {
    requestQueue.poll();
    Callback callback;
    if (status == Status.SUCCESS) {
      callback=request.success;
      logOutput(""String_Node_Str"" + requestType + ""String_Node_Str""+ request.serverAddr);
      String payload=Utility.byteArrayToString(pkt.getPayload());
      logOutput(payload);
      if (callback != null) {
        Object[] params=callback.getParams();
        params[0]=from;
        if (pkt != null && params.length >= 2) {
          params[1]=pkt.getPayload();
        }
      }
    }
 else {
      if (status == Status.CRASH) {
        serverSessionIDs.put(from,Integer.parseInt(Utility.byteArrayToString(pkt.getPayload())));
      }
      callback=request.failure;
      logError(""String_Node_Str"" + requestType + ""String_Node_Str""+ request.serverAddr+ ""String_Node_Str""+ request.filename+ ""String_Node_Str""+ status.getMsg());
      if (callback != null) {
        Object[] params=callback.getParams();
        params[0]=status.getCode();
      }
    }
    if (callback != null) {
      try {
        logOutput(""String_Node_Str"" + callback);
        callback.invoke();
      }
 catch (      Exception e) {
        System.out.println(e.getLocalizedMessage());
        e.printStackTrace();
      }
    }
  }
  sendNextRequest();
}","/** 
 * Client-side handler for RPC Result packets. Logs a message to the console (unless this is a reply to a session id request) and calls the relevant callback (if it exists) dependent on whether status of the result is SUCCESS.
 * @param from
 * @param pkt
 */
private void handleRPCresult(Integer from,RPCResultPacket pkt){
  RPCRequest request=requestQueue.peek();
  if (request == null || pkt.getRequestID() != request.pckt.getRequestID()) {
    return;
  }
  Status status=pkt.getStatus();
  Command requestType=request.pckt.getRequest();
  if (requestType == Command.SESSION) {
    if (status == Status.SUCCESS) {
      serverSessionIDs.put(from,Integer.parseInt(Utility.byteArrayToString(pkt.getPayload())));
      requestQueue.poll();
    }
  }
 else {
    requestQueue.poll();
    Callback callback;
    if (status == Status.SUCCESS) {
      callback=request.success;
      logOutput(""String_Node_Str"" + requestType + ""String_Node_Str""+ request.serverAddr);
      String payload=Utility.byteArrayToString(pkt.getPayload());
      logOutput(payload);
      if (callback != null) {
        Object[] params=callback.getParams();
        params[0]=from;
        if (pkt != null && params.length >= 2) {
          params[1]=pkt.getPayload();
        }
      }
    }
 else {
      if (status == Status.CRASH) {
        serverSessionIDs.put(from,Integer.parseInt(Utility.byteArrayToString(pkt.getPayload())));
      }
      callback=request.failure;
      logError(""String_Node_Str"" + requestType + ""String_Node_Str""+ request.serverAddr+ ""String_Node_Str""+ request.filename+ ""String_Node_Str""+ status.getMsg());
      if (callback != null) {
        Object[] params=callback.getParams();
        params[0]=status.getCode();
      }
    }
    if (callback != null) {
      try {
        logOutput(""String_Node_Str"" + callback.toString());
        Object[] params=callback.getParams();
        for (        Object param : params) {
          logOutput(""String_Node_Str"" + param.getClass().getName());
        }
        callback.invoke();
      }
 catch (      Exception e) {
        System.out.println(e.getLocalizedMessage());
        e.printStackTrace();
      }
    }
  }
  sendNextRequest();
}",0.9559032716927454
99027,"public void sendDecisionRequest(UUID txnID){
  writeOutput(""String_Node_Str"" + txnID + ""String_Node_Str"");
  TxnState txnState=participantTxns.get(txnID);
  for (  Integer otherAddr : txnState.participants) {
    TxnPacket txnPkt=TxnPacket.getDecisionRequestPacket(this,txnID);
    Callback success=createCallback(""String_Node_Str"",new String[]{byte[].class.getName()},new Object[]{null});
    makeRequest(Command.TXN,txnPkt.pack(),success,null,otherAddr,""String_Node_Str"");
    writeOutput(""String_Node_Str"" + txnID + ""String_Node_Str""+ otherAddr+ ""String_Node_Str"");
  }
  Callback decisionTimeout=createCallback(""String_Node_Str"",new String[]{UUID.class.getName()},new Object[]{txnID});
  addTimeout(decisionTimeout,DECISION_RESEND_TIMEOUT);
}","public void sendDecisionRequest(UUID txnID){
  writeOutput(""String_Node_Str"" + txnID + ""String_Node_Str"");
  TxnState txnState=participantTxns.get(txnID);
  for (  Integer otherAddr : txnState.participants) {
    TxnPacket txnPkt=TxnPacket.getDecisionRequestPacket(this,txnID);
    Callback success=createCallback(""String_Node_Str"",new String[]{Integer.class.getName(),byte[].class.getName()},new Object[]{null,null});
    makeRequest(Command.TXN,txnPkt.pack(),success,null,otherAddr,""String_Node_Str"");
    writeOutput(""String_Node_Str"" + txnID + ""String_Node_Str""+ otherAddr+ ""String_Node_Str"");
  }
  Callback decisionTimeout=createCallback(""String_Node_Str"",new String[]{UUID.class.getName()},new Object[]{txnID});
  addTimeout(decisionTimeout,DECISION_RESEND_TIMEOUT);
}",0.9809335963182118
99028,"public void receiveDecisionResponse(byte[] response){
  if (response != null && response.length > 0) {
    TxnPacket pkt=TxnPacket.unpack(response);
    writeOutput(""String_Node_Str"" + pkt.getID() + ""String_Node_Str"");
    if (pkt.getProtocol() == TxnProtocol.TXN_COMMIT) {
      recieveTxnCommit(pkt);
    }
 else     if (pkt.getProtocol() == TxnProtocol.TXN_ABORT) {
      recieveTxnAbort(pkt);
    }
  }
}","public void receiveDecisionResponse(Integer from,byte[] response){
  if (response != null && response.length > 0) {
    TxnPacket pkt=TxnPacket.unpack(response);
    writeOutput(""String_Node_Str"" + pkt.getID() + ""String_Node_Str"");
    if (pkt.getProtocol() == TxnProtocol.TXN_COMMIT) {
      recieveTxnCommit(pkt);
    }
 else     if (pkt.getProtocol() == TxnProtocol.TXN_ABORT) {
      recieveTxnAbort(pkt);
    }
  }
}",0.9843184559710496
99029,"protected Callback createCallback(String methodName,String[] parameterTypes,Object[] params){
  Method m;
  try {
    m=Callback.getMethod(methodName,this,parameterTypes);
  }
 catch (  Exception e) {
    writeError(""String_Node_Str"");
    e.printStackTrace();
    fail();
    return null;
  }
  return new Callback(m,this,params);
}","protected Callback createCallback(String methodName,String[] parameterTypes,Object[] params){
  Method m;
  try {
    m=Callback.getMethod(methodName,this,parameterTypes);
  }
 catch (  Exception e) {
    writeError(""String_Node_Str"" + methodName + ""String_Node_Str""+ Arrays.toString(parameterTypes)+ ""String_Node_Str"");
    e.printStackTrace();
    fail();
    return null;
  }
  return new Callback(m,this,params);
}",0.8868175765645806
99030,"private void sendTxnAbort(UUID txnID){
  writeOutput(""String_Node_Str"" + txnID + ""String_Node_Str"");
  for (  Integer addr : coordinatorTxns.get(txnID).getAcceptors()) {
    TxnPacket txnPkt=TxnPacket.getAbortPacket(this,txnID);
    makeRequest(Command.TXN,txnPkt.pack(),null,null,addr,""String_Node_Str"");
    writeOutput(""String_Node_Str"" + txnID + ""String_Node_Str""+ addr);
  }
}","public void sendTxnAbort(UUID txnID){
  writeOutput(""String_Node_Str"" + txnID + ""String_Node_Str"");
  for (  Integer addr : coordinatorTxns.get(txnID).getAcceptors()) {
    TxnPacket txnPkt=TxnPacket.getAbortPacket(this,txnID);
    makeRequest(Command.TXN,txnPkt.pack(),null,null,addr,""String_Node_Str"");
    writeOutput(""String_Node_Str"" + txnID + ""String_Node_Str""+ addr);
  }
}",0.985545335085414
99031,"public void sendDecisionRequest(UUID txnID){
  writeOutput(""String_Node_Str"" + txnID + ""String_Node_Str"");
  TxnState txnState=participantTxns.get(txnID);
  for (  Integer addr : txnState.participants) {
    TxnPacket txnPkt=TxnPacket.getDecisionRequestPacket(this,txnID);
    Callback success=createCallback(""String_Node_Str"",new String[]{""String_Node_Str""},null);
    makeRequest(Command.TXN,txnPkt.pack(),success,null,addr,""String_Node_Str"");
    writeOutput(""String_Node_Str"" + txnID + ""String_Node_Str""+ addr+ ""String_Node_Str"");
  }
  Callback decisionTimeout=createCallback(""String_Node_Str"",new String[]{""String_Node_Str""},new Object[]{txnID});
  addTimeout(decisionTimeout,DECISION_RESEND_TIMEOUT);
}","public void sendDecisionRequest(UUID txnID){
  writeOutput(""String_Node_Str"" + txnID + ""String_Node_Str"");
  TxnState txnState=participantTxns.get(txnID);
  for (  Integer addr : txnState.participants) {
    TxnPacket txnPkt=TxnPacket.getDecisionRequestPacket(this,txnID);
    Callback success=createCallback(""String_Node_Str"",new String[]{Byte[].class.getName()},null);
    makeRequest(Command.TXN,txnPkt.pack(),success,null,addr,""String_Node_Str"");
    writeOutput(""String_Node_Str"" + txnID + ""String_Node_Str""+ addr+ ""String_Node_Str"");
  }
  Callback decisionTimeout=createCallback(""String_Node_Str"",new String[]{UUID.class.getName()},new Object[]{txnID});
  addTimeout(decisionTimeout,DECISION_RESEND_TIMEOUT);
}",0.946704067321178
99032,"public void receiveProposalResponse(int from,byte[] response){
  TxnPacket pkt=TxnPacket.unpack(response);
  TxnState txnState=coordinatorTxns.get(pkt.getID());
  if (pkt.getProtocol() == TxnProtocol.TXN_ACCEPT) {
    writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str""+ from);
    txnState.accept(from);
  }
 else {
    writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str""+ from+ ""String_Node_Str""+ pkt.getPayload());
    txnState.reject(from);
  }
  if (txnState.allVotesIn()) {
    writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
    if (txnState.allAccepted()) {
      txnLogger.logCommit(txnState);
      sendTxnCommit(txnState.txnID);
    }
 else {
      txnLogger.logAbort(txnState);
      sendTxnAbort(txnState.txnID);
    }
  }
}","public void receiveProposalResponse(Integer from,Byte[] response){
  TxnPacket pkt=TxnPacket.unpack(response);
  TxnState txnState=coordinatorTxns.get(pkt.getID());
  if (pkt.getProtocol() == TxnProtocol.TXN_ACCEPT) {
    writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str""+ from);
    txnState.accept(from);
  }
 else {
    writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str""+ from+ ""String_Node_Str""+ pkt.getPayload());
    txnState.reject(from);
  }
  if (txnState.allVotesIn()) {
    writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
    if (txnState.allAccepted()) {
      txnLogger.logCommit(txnState);
      sendTxnCommit(txnState.txnID);
    }
 else {
      txnLogger.logAbort(txnState);
      sendTxnAbort(txnState.txnID);
    }
  }
}",0.9924050632911392
99033,"public void proposeTransaction(Set<Integer> participant_addrs,String request,String args){
  if (!participant_addrs.contains(this.addr)) {
    writeOutput(""String_Node_Str"" + addr + ""String_Node_Str"");
    participant_addrs.add(this.addr);
  }
  UUID txnID=UUID.randomUUID();
  TxnState txnState=new TxnState(txnID,participant_addrs,request,args);
  coordinatorTxns.put(txnID,txnState);
  for (  int addr : coordinatorTxns.get(txnID).participants) {
    TxnPacket txnPkt=TxnPacket.getPropositionPacket(this,txnID,participant_addrs,request,args);
    Callback success=createCallback(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},null);
    Callback failure=createCallback(""String_Node_Str"",new String[]{""String_Node_Str""},new Object[]{txnID});
    this.makeRequest(Command.TXN,txnPkt.pack(),success,failure,addr,""String_Node_Str"");
    writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str""+ addr);
  }
  txnLogger.logStart(txnState);
  Callback abortTimeout=createCallback(""String_Node_Str"",new String[]{""String_Node_Str""},new Object[]{txnID});
  addTimeout(abortTimeout,PROPOSAL_RESPONSE_TIMEOUT);
}","public void proposeTransaction(Set<Integer> participant_addrs,String request,String args){
  if (!participant_addrs.contains(this.addr)) {
    writeOutput(""String_Node_Str"" + addr + ""String_Node_Str"");
    participant_addrs.add(this.addr);
  }
  UUID txnID=UUID.randomUUID();
  TxnState txnState=new TxnState(txnID,participant_addrs,request,args);
  coordinatorTxns.put(txnID,txnState);
  for (  int addr : coordinatorTxns.get(txnID).participants) {
    TxnPacket txnPkt=TxnPacket.getPropositionPacket(this,txnID,participant_addrs,request,args);
    Callback success=createCallback(""String_Node_Str"",new String[]{Integer.class.getName(),Byte[].class.getName()},null);
    Callback failure=createCallback(""String_Node_Str"",new String[]{UUID.class.getName()},new Object[]{txnID});
    this.makeRequest(Command.TXN,txnPkt.pack(),success,failure,addr,""String_Node_Str"");
    writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str""+ addr);
  }
  txnLogger.logStart(txnState);
  Callback abortTimeout=createCallback(""String_Node_Str"",new String[]{UUID.class.getName()},new Object[]{txnID});
  addTimeout(abortTimeout,PROPOSAL_RESPONSE_TIMEOUT);
}",0.9321663019693656
99034,"private TxnPacket receiveTxnProposal(TxnPacket pkt){
  String request=pkt.getRequest();
  try {
    UUID txnID=pkt.getID();
    if (participantTxns.containsKey(txnID)) {
      writeError(""String_Node_Str"");
      fail();
    }
    writeOutput(""String_Node_Str"" + txnID + ""String_Node_Str"");
    TxnState txnState=new TxnState(txnID,pkt.getParticipants(),pkt.getRequest(),pkt.getPayload());
    participantTxns.put(txnID,txnState);
    Class<? extends TransactionNode> me=this.getClass();
    Method handler=me.getDeclaredMethod(PROPOSAL_PREFIX + request,java.lang.String.class,java.util.UUID.class);
    Boolean accept=(Boolean)handler.invoke(me,pkt.getPayload(),txnState.txnID);
    if (accept) {
      txnLogger.logAccept(txnState);
      txnState.status=TxnState.TxnStatus.WAITING;
      Callback decisionTimeout=createCallback(""String_Node_Str"",new String[]{""String_Node_Str""},new Object[]{pkt.getID()});
      addTimeout(decisionTimeout,DECISION_TIMEOUT);
      return TxnPacket.getAcceptPacket(this,pkt.getID());
    }
 else {
      txnLogger.logReject(txnState);
      txnState.status=TxnState.TxnStatus.ABORTED;
      recieveTxnAbort(pkt);
      return TxnPacket.getRejectPacket(this,pkt.getID(),""String_Node_Str"");
    }
  }
 catch (  NoSuchMethodException e) {
    writeError(""String_Node_Str"" + request);
    return TxnPacket.getRejectPacket(this,pkt.getID(),""String_Node_Str"");
  }
catch (  IllegalArgumentException e) {
    writeError(""String_Node_Str"" + request + ""String_Node_Str"");
    return TxnPacket.getRejectPacket(this,pkt.getID(),""String_Node_Str"");
  }
catch (  Exception e) {
    writeError(""String_Node_Str"" + request + ""String_Node_Str""+ e.getMessage());
    this.fail();
    return null;
  }
}","private TxnPacket receiveTxnProposal(TxnPacket pkt){
  String request=pkt.getRequest();
  try {
    UUID txnID=pkt.getID();
    if (participantTxns.containsKey(txnID)) {
      writeError(""String_Node_Str"");
      fail();
    }
    writeOutput(""String_Node_Str"" + txnID + ""String_Node_Str"");
    TxnState txnState=new TxnState(txnID,pkt.getParticipants(),pkt.getRequest(),pkt.getPayload());
    participantTxns.put(txnID,txnState);
    Class<? extends TransactionNode> me=this.getClass();
    Method handler=me.getDeclaredMethod(PROPOSAL_PREFIX + request,java.lang.String.class,java.util.UUID.class);
    Boolean accept=(Boolean)handler.invoke(me,pkt.getPayload(),txnState.txnID);
    if (accept) {
      txnLogger.logAccept(txnState);
      txnState.status=TxnState.TxnStatus.WAITING;
      Callback decisionTimeout=createCallback(""String_Node_Str"",new String[]{UUID.class.getName()},new Object[]{pkt.getID()});
      addTimeout(decisionTimeout,DECISION_TIMEOUT);
      return TxnPacket.getAcceptPacket(this,pkt.getID());
    }
 else {
      txnLogger.logReject(txnState);
      txnState.status=TxnState.TxnStatus.ABORTED;
      recieveTxnAbort(pkt);
      return TxnPacket.getRejectPacket(this,pkt.getID(),""String_Node_Str"");
    }
  }
 catch (  NoSuchMethodException e) {
    writeError(""String_Node_Str"" + request);
    return TxnPacket.getRejectPacket(this,pkt.getID(),""String_Node_Str"");
  }
catch (  IllegalArgumentException e) {
    writeError(""String_Node_Str"" + request + ""String_Node_Str"");
    return TxnPacket.getRejectPacket(this,pkt.getID(),""String_Node_Str"");
  }
catch (  Exception e) {
    writeError(""String_Node_Str"" + request + ""String_Node_Str""+ e.getMessage());
    this.fail();
    return null;
  }
}",0.9898344467034564
99035,"public void receiveDecisionResponse(byte[] response){
  if (response != null && response.length > 0) {
    TxnPacket pkt=TxnPacket.unpack(response);
    writeOutput(""String_Node_Str"" + pkt.getID() + ""String_Node_Str"");
    if (pkt.getProtocol() == TxnProtocol.TXN_COMMIT) {
      recieveTxnCommit(pkt);
    }
 else     if (pkt.getProtocol() == TxnProtocol.TXN_ABORT) {
      recieveTxnAbort(pkt);
    }
  }
}","public void receiveDecisionResponse(Byte[] response){
  if (response != null && response.length > 0) {
    TxnPacket pkt=TxnPacket.unpack(response);
    writeOutput(""String_Node_Str"" + pkt.getID() + ""String_Node_Str"");
    if (pkt.getProtocol() == TxnProtocol.TXN_COMMIT) {
      recieveTxnCommit(pkt);
    }
 else     if (pkt.getProtocol() == TxnProtocol.TXN_ABORT) {
      recieveTxnAbort(pkt);
    }
  }
}",0.9975490196078431
99036,"private TxnPacket receiveTxnProposal(TxnPacket pkt){
  String request=pkt.getRequest();
  try {
    UUID txnID=pkt.getID();
    if (participantTxns.containsKey(txnID)) {
      writeError(""String_Node_Str"");
      fail();
    }
    writeOutput(""String_Node_Str"" + txnID + ""String_Node_Str"");
    TxnState txnState=new TxnState(txnID,pkt.getParticipants(),pkt.getRequest(),pkt.getPayload());
    participantTxns.put(txnID,txnState);
    Class<? extends TransactionNode> me=this.getClass();
    Method handler=me.getDeclaredMethod(PROPOSAL_PREFIX + request,java.lang.String.class,java.util.UUID.class);
    Boolean accept=(Boolean)handler.invoke(me,pkt.getPayload(),txnState.txnID);
    if (accept) {
      txnLogger.logAccept(txnState);
      txnState.status=TxnState.TxnStatus.WAITING;
      Callback decisionTimeout=createCallback(""String_Node_Str"",new String[]{UUID.class.getName()},new Object[]{pkt.getID()});
      addTimeout(decisionTimeout,DECISION_TIMEOUT);
      return TxnPacket.getAcceptPacket(this,pkt.getID());
    }
 else {
      txnLogger.logReject(txnState);
      txnState.status=TxnState.TxnStatus.ABORTED;
      recieveTxnAbort(pkt);
      return TxnPacket.getRejectPacket(this,pkt.getID(),""String_Node_Str"");
    }
  }
 catch (  NoSuchMethodException e) {
    writeError(""String_Node_Str"" + request);
    return TxnPacket.getRejectPacket(this,pkt.getID(),""String_Node_Str"");
  }
catch (  IllegalArgumentException e) {
    writeError(""String_Node_Str"" + request + ""String_Node_Str"");
    return TxnPacket.getRejectPacket(this,pkt.getID(),""String_Node_Str"");
  }
catch (  Exception e) {
    writeError(""String_Node_Str"" + request + ""String_Node_Str""+ e.getMessage());
    this.fail();
    return null;
  }
}","private TxnPacket receiveTxnProposal(TxnPacket pkt){
  String request=pkt.getRequest();
  try {
    UUID txnID=pkt.getID();
    if (participantTxns.containsKey(txnID)) {
      writeError(""String_Node_Str"");
      fail();
    }
    writeOutput(""String_Node_Str"" + txnID + ""String_Node_Str"");
    TxnState txnState=new TxnState(txnID,pkt.getParticipants(),pkt.getRequest(),pkt.getPayload());
    participantTxns.put(txnID,txnState);
    Class<? extends TransactionNode> me=this.getClass();
    Method handler=me.getDeclaredMethod(PROPOSAL_PREFIX + request,java.util.UUID.class,java.lang.String.class);
    Boolean accept=(Boolean)handler.invoke(this,txnState.txnID,pkt.getPayload());
    if (accept) {
      txnLogger.logAccept(txnState);
      txnState.status=TxnState.TxnStatus.WAITING;
      Callback decisionTimeout=createCallback(""String_Node_Str"",new String[]{UUID.class.getName()},new Object[]{pkt.getID()});
      addTimeout(decisionTimeout,DECISION_TIMEOUT);
      return TxnPacket.getAcceptPacket(this,pkt.getID());
    }
 else {
      txnLogger.logReject(txnState);
      txnState.status=TxnState.TxnStatus.ABORTED;
      recieveTxnAbort(pkt);
      return TxnPacket.getRejectPacket(this,pkt.getID(),""String_Node_Str"");
    }
  }
 catch (  NoSuchMethodException e) {
    e.printStackTrace();
    writeError(""String_Node_Str"" + request);
    return TxnPacket.getRejectPacket(this,pkt.getID(),""String_Node_Str"");
  }
catch (  IllegalArgumentException e) {
    e.printStackTrace();
    writeError(""String_Node_Str"" + request + ""String_Node_Str"");
    return TxnPacket.getRejectPacket(this,pkt.getID(),""String_Node_Str"");
  }
catch (  Exception e) {
    e.printStackTrace();
    writeError(""String_Node_Str"" + request + ""String_Node_Str""+ e.getMessage());
    this.fail();
    return null;
  }
}",0.9287539029236446
99037,"private void recieveTxnCommit(TxnPacket pkt){
  TxnState txnState=participantTxns.get(pkt.getID());
  txnLogger.logCommit(txnState);
  txnState.status=TxnState.TxnStatus.COMMITTED;
  String request=pkt.getRequest();
  try {
    writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
    Class<? extends TransactionNode> me=this.getClass();
    Method handler=me.getDeclaredMethod(COMMIT_PREFIX + request,java.lang.String.class,java.util.UUID.class);
    handler.invoke(me,pkt.getPayload(),txnState.txnID);
    txnLogger.logDone(txnState);
  }
 catch (  NoSuchMethodException e) {
    writeError(""String_Node_Str"" + request);
    fail();
  }
catch (  IllegalArgumentException e) {
    writeError(""String_Node_Str"" + request + ""String_Node_Str"");
    fail();
  }
catch (  Exception e) {
    writeError(""String_Node_Str"" + request + ""String_Node_Str""+ e.getMessage());
    this.fail();
  }
}","private void recieveTxnCommit(TxnPacket pkt){
  TxnState txnState=participantTxns.get(pkt.getID());
  txnLogger.logCommit(txnState);
  txnState.status=TxnState.TxnStatus.COMMITTED;
  String request=pkt.getRequest();
  try {
    writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
    Class<? extends TransactionNode> me=this.getClass();
    Method handler=me.getDeclaredMethod(COMMIT_PREFIX + request,java.util.UUID.class,java.lang.String.class);
    handler.invoke(this,txnState.txnID,pkt.getPayload());
    txnLogger.logDone(txnState);
  }
 catch (  NoSuchMethodException e) {
    writeError(""String_Node_Str"" + request);
    fail();
  }
catch (  IllegalArgumentException e) {
    writeError(""String_Node_Str"" + request + ""String_Node_Str"");
    fail();
  }
catch (  Exception e) {
    writeError(""String_Node_Str"" + request + ""String_Node_Str""+ e.getMessage());
    this.fail();
  }
}",0.9335548172757476
99038,"private void recieveTxnAbort(TxnPacket pkt){
  TxnState txnState=participantTxns.get(pkt.getID());
  txnLogger.logAbort(txnState);
  txnState.status=TxnState.TxnStatus.ABORTED;
  String request=pkt.getRequest();
  try {
    writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
    Class<? extends TransactionNode> me=this.getClass();
    Method handler=me.getDeclaredMethod(ABORT_PREFIX + request,java.lang.String.class,java.util.UUID.class);
    handler.invoke(me,pkt.getPayload(),txnState.txnID);
    txnLogger.logDone(txnState);
  }
 catch (  NoSuchMethodException e) {
    writeError(""String_Node_Str"" + request);
    fail();
  }
catch (  IllegalArgumentException e) {
    writeError(""String_Node_Str"" + request + ""String_Node_Str"");
    fail();
  }
catch (  Exception e) {
    writeError(""String_Node_Str"" + request + ""String_Node_Str""+ e.getMessage());
    this.fail();
  }
}","private void recieveTxnAbort(TxnPacket pkt){
  TxnState txnState=participantTxns.get(pkt.getID());
  txnLogger.logAbort(txnState);
  txnState.status=TxnState.TxnStatus.ABORTED;
  String request=pkt.getRequest();
  try {
    writeOutput(""String_Node_Str"" + txnState.txnID + ""String_Node_Str"");
    Class<? extends TransactionNode> me=this.getClass();
    Method handler=me.getDeclaredMethod(ABORT_PREFIX + request,java.util.UUID.class,java.lang.String.class);
    handler.invoke(this,txnState.txnID,pkt.getPayload());
    txnLogger.logDone(txnState);
  }
 catch (  NoSuchMethodException e) {
    writeError(""String_Node_Str"" + request);
    fail();
  }
catch (  IllegalArgumentException e) {
    writeError(""String_Node_Str"" + request + ""String_Node_Str"");
    fail();
  }
catch (  Exception e) {
    writeError(""String_Node_Str"" + request + ""String_Node_Str""+ e.getMessage());
    this.fail();
  }
}",0.933184855233853
99039,"public void createNewUser(String userName) throws SecurityException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {
  doingWork=true;
  String[] paramTypes={""String_Node_Str"",""String_Node_Str""};
  Method createFiles=Callback.getMethod(""String_Node_Str"",this,paramTypes);
  Object[] params={null,userName};
  Callback userNoExistCallback=new Callback(createFiles,this,params);
  String[] noParamTypes={};
  Object[] noParams={};
  Method showWarning=Callback.getMethod(""String_Node_Str"",this,noParamTypes);
  Callback userExistsCallback=new Callback(showWarning,this,noParams);
  userExists(null,userName,userExistsCallback,userNoExistCallback);
}","public void createNewUser(String userName) throws SecurityException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {
  doingWork=true;
  String[] paramTypes={""String_Node_Str"",byte[].class.getName(),""String_Node_Str""};
  Method createFiles=Callback.getMethod(""String_Node_Str"",this,paramTypes);
  Object[] params={null,null,userName};
  Callback userNoExistCallback=new Callback(createFiles,this,params);
  String[] noParamTypes={Integer.class.getName(),byte[].class.getName()};
  Object[] noParams={null,null};
  Method showWarning=Callback.getMethod(""String_Node_Str"",this,noParamTypes);
  Callback userExistsCallback=new Callback(showWarning,this,noParams);
  userExists(null,userName,userExistsCallback,userNoExistCallback);
}",0.9290060851926978
99040,"public void userAlreadyExists(){
  doingWork=false;
  printError(""String_Node_Str"" + ""String_Node_Str"");
}","public void userAlreadyExists(Integer from,byte[] res){
  doingWork=false;
  printError(""String_Node_Str"" + ""String_Node_Str"");
}",0.902127659574468
99041,"public void addUserToList(Integer from,byte[] result,String userName) throws SecurityException, ClassNotFoundException, NoSuchMethodException {
  String[] failParamTypes={""String_Node_Str"",""String_Node_Str""};
  Method tryAgain=Callback.getMethod(""String_Node_Str"",this,failParamTypes);
  Object[] failParams={null,userName};
  Callback tryAgainCallback=new Callback(tryAgain,this,failParams);
  String[] successParamTypes={""String_Node_Str""};
  Method showSuccess=Callback.getMethod(""String_Node_Str"",this,successParamTypes);
  Object[] successParams={userName};
  Callback successCallback=new Callback(showSuccess,this,successParams);
  String appendContents=""String_Node_Str"" + userName;
  append(ALL_USERS_LOCATION,ALL_USERS_FILE,appendContents,successCallback,tryAgainCallback);
}","public void addUserToList(Integer from,byte[] result,String userName) throws SecurityException, ClassNotFoundException, NoSuchMethodException {
  String[] failParamTypes={""String_Node_Str"",""String_Node_Str""};
  Method tryAgain=Callback.getMethod(""String_Node_Str"",this,failParamTypes);
  Object[] failParams={null,userName};
  Callback tryAgainCallback=new Callback(tryAgain,this,failParams);
  String[] successParamTypes={Integer.class.getName(),byte[].class.getName(),""String_Node_Str""};
  Method showSuccess=Callback.getMethod(""String_Node_Str"",this,successParamTypes);
  Object[] successParams={null,null,userName};
  Callback successCallback=new Callback(showSuccess,this,successParams);
  String appendContents=""String_Node_Str"" + userName;
  append(ALL_USERS_LOCATION,ALL_USERS_FILE,appendContents,successCallback,tryAgainCallback);
}",0.832
99042,"public void userExists(Integer errorCode,String userName,Callback userExistsCallback,Callback userNoExistsCallback) throws SecurityException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {
  String[] failParamTypes={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  Method tryAgain=Callback.getMethod(""String_Node_Str"",this,failParamTypes);
  Object[] failParams={null,userName,userExistsCallback,userNoExistsCallback};
  Callback tryAgainCallback=new Callback(tryAgain,this,failParams);
  if (errorCode != null && errorCode.equals(FILE_NO_EXIST)) {
    printOutput(""String_Node_Str"");
    createUsersFile(null,userNoExistsCallback);
    return;
  }
  if (userDataLocations.keySet().size() > 0) {
    if (!userDataLocations.containsKey(userName)) {
      userNoExistsCallback.invoke();
    }
 else {
      userExistsCallback.invoke();
    }
    return;
  }
  String[] pTypes={Integer.class.getName(),byte[].class.getName(),String.class.getName(),Callback.class.getName(),Callback.class.getName()};
  Method checkForName=Callback.getMethod(""String_Node_Str"",this,pTypes);
  Object[] p={null,userName,userExistsCallback,userNoExistsCallback};
  Callback checkForNameCallback=new Callback(checkForName,this,p);
  get(ALL_USERS_LOCATION,ALL_USERS_FILE,checkForNameCallback,tryAgainCallback);
}","public void userExists(Integer errorCode,String userName,Callback userExistsCallback,Callback userNoExistsCallback) throws SecurityException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {
  String[] failParamTypes={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  Method tryAgain=Callback.getMethod(""String_Node_Str"",this,failParamTypes);
  Object[] failParams={null,userName,userExistsCallback,userNoExistsCallback};
  Callback tryAgainCallback=new Callback(tryAgain,this,failParams);
  if (errorCode != null && errorCode.equals(FILE_NO_EXIST)) {
    printOutput(""String_Node_Str"");
    createUsersFile(null,userNoExistsCallback);
    return;
  }
  if (userDataLocations.keySet().size() > 0) {
    if (!userDataLocations.containsKey(userName)) {
      userNoExistsCallback.invoke();
    }
 else {
      userExistsCallback.invoke();
    }
    return;
  }
  String[] pTypes={Integer.class.getName(),byte[].class.getName(),String.class.getName(),Callback.class.getName(),Callback.class.getName()};
  Method checkForName=Callback.getMethod(""String_Node_Str"",this,pTypes);
  Object[] p={null,null,userName,userExistsCallback,userNoExistsCallback};
  Callback checkForNameCallback=new Callback(checkForName,this,p);
  get(ALL_USERS_LOCATION,ALL_USERS_FILE,checkForNameCallback,tryAgainCallback);
}",0.9981745162468054
99043,"public void createPostsFile(Integer errorCode,String userName) throws SecurityException, ClassNotFoundException, NoSuchMethodException {
  if (!userDataLocations.containsKey(userName)) {
    userDataLocations.put(userName,nextServer);
    nextServer=(nextServer + 2) % (2 * NUM_SERVERS);
  }
  if (errorCode != null && errorCode.equals(FILE_EXISTS)) {
    createFriendsFile(null,null,userName);
    return;
  }
  String[] failParamTypes={""String_Node_Str"",""String_Node_Str""};
  Method tryAgain=Callback.getMethod(""String_Node_Str"",this,failParamTypes);
  Object[] failParams={null,userName};
  Callback tryAgainCallback=new Callback(tryAgain,this,failParams);
  String[] successParamTypes={Integer.class.getName(),byte[].class.getName(),String.class.getName()};
  Method makeFriendsFile=Callback.getMethod(""String_Node_Str"",this,successParamTypes);
  Object[] successParams={null,null,userName};
  Callback successCallback=new Callback(makeFriendsFile,this,successParams);
  String filename=MESSAGES_PREFIX + userName;
  create(userDataLocations.get(userName),filename,successCallback,tryAgainCallback);
}","public void createPostsFile(Integer errorCode,byte[] res,String userName) throws SecurityException, ClassNotFoundException, NoSuchMethodException {
  if (!userDataLocations.containsKey(userName)) {
    userDataLocations.put(userName,nextServer);
    nextServer=(nextServer + 2) % (2 * NUM_SERVERS);
  }
  if (errorCode != null && errorCode.equals(FILE_EXISTS)) {
    createFriendsFile(null,null,userName);
    return;
  }
  String[] failParamTypes={""String_Node_Str"",byte[].class.getName(),""String_Node_Str""};
  Method tryAgain=Callback.getMethod(""String_Node_Str"",this,failParamTypes);
  Object[] failParams={null,null,userName};
  Callback tryAgainCallback=new Callback(tryAgain,this,failParams);
  String[] successParamTypes={Integer.class.getName(),byte[].class.getName(),String.class.getName()};
  Method makeFriendsFile=Callback.getMethod(""String_Node_Str"",this,successParamTypes);
  Object[] successParams={null,null,userName};
  Callback successCallback=new Callback(makeFriendsFile,this,successParams);
  String filename=MESSAGES_PREFIX + userName;
  create(userDataLocations.get(userName),filename,successCallback,tryAgainCallback);
}",0.9826589595375722
99044,"public void noSuchUserReport(String username){
  doingWork=false;
  printError(""String_Node_Str"" + username);
}","public void noSuchUserReport(Integer from,byte[] results,String username){
  doingWork=false;
  printError(""String_Node_Str"" + username);
}",0.888
99045,"public void setLoggedInUser(String username){
  loggedInUser=username;
  printOutput(""String_Node_Str"" + username);
  doingWork=false;
}","public void setLoggedInUser(Integer from,byte[] results,String username){
  loggedInUser=username;
  printOutput(""String_Node_Str"" + username);
  doingWork=false;
}",0.9066666666666666
99046,"public void loginUser(String userName) throws SecurityException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {
  doingWork=true;
  if (loggedInUser != null) {
    printError(""String_Node_Str"" + loggedInUser);
    doingWork=false;
    return;
  }
  String[] noExistParamTypes={""String_Node_Str""};
  Method noExist=Callback.getMethod(""String_Node_Str"",this,noExistParamTypes);
  Object[] noExistParams={userName};
  Callback noExistCallback=new Callback(noExist,this,noExistParams);
  Method doesExist=Callback.getMethod(""String_Node_Str"",this,noExistParamTypes);
  Callback doesExistCallback=new Callback(doesExist,this,noExistParams);
  userExists(null,userName,doesExistCallback,noExistCallback);
}","public void loginUser(String userName) throws SecurityException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {
  doingWork=true;
  if (loggedInUser != null) {
    printError(""String_Node_Str"" + loggedInUser);
    doingWork=false;
    return;
  }
  String[] noExistParamTypes={""String_Node_Str"",byte[].class.getName(),""String_Node_Str""};
  Method noExist=Callback.getMethod(""String_Node_Str"",this,noExistParamTypes);
  Object[] noExistParams={null,null,userName};
  Callback noExistCallback=new Callback(noExist,this,noExistParams);
  Method doesExist=Callback.getMethod(""String_Node_Str"",this,noExistParamTypes);
  Callback doesExistCallback=new Callback(doesExist,this,noExistParams);
  userExists(null,userName,doesExistCallback,noExistCallback);
}",0.9672025723472668
99047,"public void createSuccess(String userName){
  doingWork=false;
  printOutput(""String_Node_Str"" + userName);
}","public void createSuccess(Integer from,byte[] res,String userName){
  doingWork=false;
  printOutput(""String_Node_Str"" + userName);
}",0.9008264462809916
99048,"public void showAllOfList(Integer errorCode,String filename,Integer serverId) throws SecurityException, ClassNotFoundException, NoSuchMethodException {
  String[] failParamTypes={""String_Node_Str"",""String_Node_Str""};
  Method tryAgain=Callback.getMethod(""String_Node_Str"",this,failParamTypes);
  Object[] failParams={null,filename};
  Callback tryAgainCallback=new Callback(tryAgain,this,failParams);
  String[] goodParamTypes={""String_Node_Str""};
  Method printResults=Callback.getMethod(""String_Node_Str"",this,goodParamTypes);
  Object[] goodParams={null};
  Callback printCallback=new Callback(printResults,this,goodParams);
  get(serverId,filename,printCallback,tryAgainCallback);
}","public void showAllOfList(Integer errorCode,String filename,Integer serverId) throws SecurityException, ClassNotFoundException, NoSuchMethodException {
  String[] failParamTypes={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  Method tryAgain=Callback.getMethod(""String_Node_Str"",this,failParamTypes);
  Object[] failParams={null,filename,serverId};
  Callback tryAgainCallback=new Callback(tryAgain,this,failParams);
  String[] goodParamTypes={""String_Node_Str""};
  Method printResults=Callback.getMethod(""String_Node_Str"",this,goodParamTypes);
  Object[] goodParams={null};
  Callback printCallback=new Callback(printResults,this,goodParams);
  get(serverId,filename,printCallback,tryAgainCallback);
}",0.980700500357398
99049,"public void logSequenceNumber(int seqNum){
  try {
    if (Utility.fileExists(n,log_file)) {
      PersistentStorageReader reader=n.getReader(log_file);
      char[] buf=new char[RIOPacket.MAX_PACKET_SIZE];
      reader.read(buf);
      String oldFileData=new String(buf);
      PersistentStorageWriter writer=n.getWriter(temp_log_file,false);
      writer.write(oldFileData);
      writer.close();
    }
    PersistentStorageWriter writer=n.getWriter(log_file,false);
    writer.write(seqNum);
    writer.close();
    writer=n.getWriter(temp_log_file,false);
    writer.delete();
    writer.close();
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + n.addr + ""String_Node_Str""+ seqNum+ ""String_Node_Str""+ log_file);
    e.printStackTrace();
  }
}","public void logSequenceNumber(int seqNum){
  debugPrint(""String_Node_Str"" + seqNum + ""String_Node_Str""+ log_file);
  boolean createdTemp=false;
  if (Utility.fileExists(n,log_file)) {
    int oldValue=getSequenceNumFromFile(log_file);
    if (oldValue != -1) {
      debugPrint(""String_Node_Str"" + oldValue + ""String_Node_Str""+ log_file);
      if (writeCurrentSequence(temp_log_file,oldValue)) {
        debugPrint(""String_Node_Str"" + seqNum + ""String_Node_Str""+ temp_log_file);
        createdTemp=true;
      }
    }
  }
  if (writeCurrentSequence(log_file,seqNum)) {
    debugPrint(""String_Node_Str"" + seqNum + ""String_Node_Str""+ log_file);
  }
  if (createdTemp) {
    deleteFile(temp_log_file);
  }
}",0.1543669600541638
99050,"public void setSequenceNumber(){
  lastSeqNum=-1;
  if (Utility.fileExists(n,temp_log_file)) {
    try {
      PersistentStorageReader reader=n.getReader(temp_log_file);
      if (!reader.ready()) {
        PersistentStorageWriter deleter=n.getWriter(temp_log_file,false);
        deleter.delete();
      }
 else {
        char[] buf=new char[RIOPacket.MAX_PACKET_SIZE];
        reader.read(buf);
        PersistentStorageWriter writer=n.getWriter(log_file,false);
        writer.write(buf);
        PersistentStorageWriter deleter=n.getWriter(temp_log_file,false);
        deleter.delete();
      }
    }
 catch (    IOException e) {
      System.err.println(""String_Node_Str"" + n.addr + ""String_Node_Str""+ log_file);
    }
  }
  if (Utility.fileExists(n,log_file)) {
    try {
      PersistentStorageReader r=n.getReader(log_file);
      if (r.ready()) {
        String num=r.readLine();
        if (!num.trim().isEmpty()) {
          lastSeqNum=Integer.parseInt(num.trim());
        }
      }
    }
 catch (    IOException e) {
      System.err.println(""String_Node_Str"" + n.addr + ""String_Node_Str""+ log_file+ ""String_Node_Str"");
      e.printStackTrace();
    }
catch (    NumberFormatException e) {
      System.err.println(""String_Node_Str"" + n.addr + ""String_Node_Str""+ log_file+ ""String_Node_Str"");
      e.printStackTrace();
    }
  }
}","public void setSequenceNumber(){
  debugPrint(""String_Node_Str"");
  lastSeqNum=-1;
  if (Utility.fileExists(n,temp_log_file)) {
    debugPrint(""String_Node_Str"" + temp_log_file + ""String_Node_Str"");
    int oldVal=getSequenceNumFromFile(temp_log_file);
    if (oldVal != -1) {
      if (writeCurrentSequence(log_file,oldVal)) {
        debugPrint(""String_Node_Str"" + oldVal + ""String_Node_Str""+ log_file);
      }
    }
    deleteFile(temp_log_file);
  }
  if (Utility.fileExists(n,log_file)) {
    debugPrint(""String_Node_Str"" + log_file + ""String_Node_Str"");
    lastSeqNum=getSequenceNumFromFile(log_file);
  }
 else {
    debugPrint(""String_Node_Str"" + log_file + ""String_Node_Str"");
  }
}",0.1147621383030897
99051,"/** 
 * Puts contents into the file.
 * @param filename
 * @param contents
 * @param id
 * @return NOT_EXIST status if the file does not exist. FAILURE status ifthe put fails in process.
 */
private RPCResultPacket put(String filename,String contents,int id){
  if (!Utility.fileExists(this,filename)) {
    logError(""String_Node_Str"" + this.addr + ""String_Node_Str""+ filename+ ""String_Node_Str"");
    return new RPCResultPacket(id,Status.NOT_EXIST,Utility.stringToByteArray(Status.NOT_EXIST.toString()));
  }
  try {
    PersistentStorageReader reader=getReader(filename);
    char[] buf=new char[MAX_FILE_SIZE];
    reader.read(buf);
    String oldFileData=new String(buf);
    PersistentStorageWriter writer=this.getWriter(TEMP_PUT_FILE,false);
    writer.write(filename + ""String_Node_Str"" + oldFileData);
    writer=this.getWriter(filename,false);
    writer.write(contents);
    writer=this.getWriter(filename,false);
    writer.delete();
    return new RPCResultPacket(id,Status.SUCCESS,Utility.stringToByteArray(""String_Node_Str"" + filename));
  }
 catch (  IOException e) {
    logError(""String_Node_Str"" + this.addr + ""String_Node_Str""+ filename+ ""String_Node_Str"");
    return new RPCResultPacket(id,Status.FAILURE,Utility.stringToByteArray(e.getMessage()));
  }
}","/** 
 * Puts contents into the file.
 * @param filename
 * @param contents
 * @param id
 * @return NOT_EXIST status if the file does not exist. FAILURE status ifthe put fails in process.
 */
private RPCResultPacket put(String filename,String contents,int id){
  if (!Utility.fileExists(this,filename)) {
    logError(""String_Node_Str"" + this.addr + ""String_Node_Str""+ filename+ ""String_Node_Str"");
    return new RPCResultPacket(id,Status.NOT_EXIST,Utility.stringToByteArray(Status.NOT_EXIST.toString()));
  }
  try {
    PersistentStorageReader reader=getReader(filename);
    char[] buf=new char[MAX_FILE_SIZE];
    reader.read(buf);
    String oldFileData=new String(buf);
    PersistentStorageWriter writer=this.getWriter(TEMP_PUT_FILE,false);
    writer.write(filename + ""String_Node_Str"" + oldFileData);
    writer=this.getWriter(filename,false);
    writer.write(contents);
    writer=this.getWriter(TEMP_PUT_FILE,false);
    writer.delete();
    return new RPCResultPacket(id,Status.SUCCESS,Utility.stringToByteArray(""String_Node_Str"" + filename));
  }
 catch (  IOException e) {
    logError(""String_Node_Str"" + this.addr + ""String_Node_Str""+ filename+ ""String_Node_Str"");
    return new RPCResultPacket(id,Status.FAILURE,Utility.stringToByteArray(e.getMessage()));
  }
}",0.9917808219178084
99052,"/** 
 * Client-side handler for RPC Result packets. Logs a message to the console (unless this is a reply to a session id request) and calls the relevant callback (if it exists) dependent on whether status of the result is SUCCESS.
 * @param from
 * @param pkt
 */
private void handleRPCresult(Integer from,RPCResultPacket pkt){
  RPCRequest request=requestQueue.peek();
  if (pkt.getRequestID() != request.getPacket().getRequestID()) {
    return;
  }
  Status status=pkt.getStatus();
  Command requestType=request.getPacket().getRequest();
  if (requestType == Command.SESSION) {
    if (status == Status.SUCCESS) {
      serverSessionID=Integer.parseInt(Utility.byteArrayToString(pkt.getPayload()));
      requestQueue.poll();
    }
  }
 else {
    requestQueue.poll();
    Callback callback;
    if (status == Status.SUCCESS) {
      callback=request.getSuccess();
      logOutput(""String_Node_Str"" + this.addr + ""String_Node_Str""+ requestType+ ""String_Node_Str""+ request.getServerAddr()+ ""String_Node_Str""+ request.getFilename());
      if (requestType == Command.GET) {
        logOutput(Utility.byteArrayToString(pkt.getPayload()));
      }
    }
 else {
      if (status == Status.CRASH) {
        serverSessionID=Integer.parseInt(Utility.byteArrayToString(pkt.getPayload()));
      }
      callback=request.getFailure();
      logError(""String_Node_Str"" + this.addr + ""String_Node_Str""+ requestType+ ""String_Node_Str""+ request.getServerAddr()+ ""String_Node_Str""+ request.getFilename()+ ""String_Node_Str""+ status.toString());
    }
    if (callback != null) {
      try {
        callback.invoke();
      }
 catch (      IllegalAccessException e) {
        e.printStackTrace();
      }
catch (      InvocationTargetException e) {
        e.printStackTrace();
      }
    }
  }
  sendNextRequest();
}","/** 
 * Client-side handler for RPC Result packets. Logs a message to the console (unless this is a reply to a session id request) and calls the relevant callback (if it exists) dependent on whether status of the result is SUCCESS.
 * @param from
 * @param pkt
 */
private void handleRPCresult(Integer from,RPCResultPacket pkt){
  RPCRequest request=requestQueue.peek();
  if (request == null || pkt.getRequestID() != request.getPacket().getRequestID()) {
    return;
  }
  Status status=pkt.getStatus();
  Command requestType=request.getPacket().getRequest();
  if (requestType == Command.SESSION) {
    if (status == Status.SUCCESS) {
      serverSessionID=Integer.parseInt(Utility.byteArrayToString(pkt.getPayload()));
      requestQueue.poll();
    }
  }
 else {
    requestQueue.poll();
    Callback callback;
    if (status == Status.SUCCESS) {
      callback=request.getSuccess();
      logOutput(""String_Node_Str"" + this.addr + ""String_Node_Str""+ requestType+ ""String_Node_Str""+ request.getServerAddr()+ ""String_Node_Str""+ request.getFilename());
      if (requestType == Command.GET) {
        logOutput(Utility.byteArrayToString(pkt.getPayload()));
      }
    }
 else {
      if (status == Status.CRASH) {
        serverSessionID=Integer.parseInt(Utility.byteArrayToString(pkt.getPayload()));
      }
      callback=request.getFailure();
      logError(""String_Node_Str"" + this.addr + ""String_Node_Str""+ requestType+ ""String_Node_Str""+ request.getServerAddr()+ ""String_Node_Str""+ request.getFilename()+ ""String_Node_Str""+ status.toString());
    }
    if (callback != null) {
      try {
        callback.invoke();
      }
 catch (      IllegalAccessException e) {
        e.printStackTrace();
      }
catch (      InvocationTargetException e) {
        e.printStackTrace();
      }
    }
  }
  sendNextRequest();
}",0.9947701624002202
99053,"OutChannel(ReliableInOrderMsgLayer parent,int destAddr){
  lastSeqNumSent=-1;
  unACKedPackets=new HashMap<Integer,RIOPacket>();
  this.parent=parent;
  this.destAddr=destAddr;
}","OutChannel(ReliableInOrderMsgLayer parent,int destAddr){
  lastSeqNumSent=-1;
  unACKedPackets=new HashMap<Integer,RIOPacket>();
  attemptsMade=new HashMap<Integer,Integer>();
  this.parent=parent;
  this.destAddr=destAddr;
}",0.8833746898263027
99054,"public void addException(AppliedRule exception){
  if (exceptions.contains(exception) && !this.hasException(exception.getId())) {
    exceptions.add(exception);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}","public void addException(AppliedRule exception){
  if (!exceptions.contains(exception) && !this.hasException(exception.getId())) {
    exceptions.add(exception);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.9978213507625272
99055,"@Override public void initUi() throws Exception {
  Log.i(this,""String_Node_Str"");
  jframe=new JFrameAppliedRules();
  loadSelectBoxes();
  fillRuleTypeComboBox();
  if (getAction().equals(SoftwareUnitController.ACTION_NEW)) {
    jframe.jButtonSave.setText(""String_Node_Str"");
    jframe.setTitle(""String_Node_Str"");
  }
 else   if (getAction().equals(SoftwareUnitController.ACTION_EDIT)) {
    jframe.jButtonSave.setText(""String_Node_Str"");
    jframe.setTitle(""String_Node_Str"");
    if (appliedRuleId != -1L) {
      JTableException table=jframe.jTableException;
      JTableTableModel tablemodel=(JTableTableModel)table.getModel();
      ArrayList<Long> exceptions=defineDomainService.getAppliedRuleExceptions(getLayerID(),appliedRuleId);
      for (      long exception_id : exceptions) {
        DataHelper datahelper=new DataHelper();
        datahelper.setId(exception_id);
      }
    }
  }
  jframe.jButtonAddExceptionRow.addActionListener(this);
  jframe.jButtonRemoveExceptionRow.addActionListener(this);
  jframe.jButtonSave.addActionListener(this);
  jframe.jButtonCancel.addActionListener(this);
  jframe.addKeyListener(this);
  UiDialogs.showOnScreen(0,jframe);
  jframe.setVisible(true);
}","@Override public void initUi() throws Exception {
  Log.i(this,""String_Node_Str"");
  jframe=new JFrameAppliedRules();
  loadSelectBoxes();
  fillRuleTypeComboBox();
  if (getAction().equals(SoftwareUnitController.ACTION_NEW)) {
    jframe.jButtonSave.setText(""String_Node_Str"");
    jframe.setTitle(""String_Node_Str"");
  }
 else   if (getAction().equals(SoftwareUnitController.ACTION_EDIT)) {
    jframe.jButtonSave.setText(""String_Node_Str"");
    jframe.setTitle(""String_Node_Str"");
    if (appliedRuleId != -1L) {
      JTableException table=jframe.jTableException;
      JTableTableModel tablemodel=(JTableTableModel)table.getModel();
      ArrayList<Long> exceptionIds=defineDomainService.getExceptionIdsByAppliedRule(appliedRuleId);
      for (      long exception_id : exceptionIds) {
        DataHelper datahelper=new DataHelper();
        datahelper.setId(exception_id);
      }
    }
  }
  jframe.jButtonAddExceptionRow.addActionListener(this);
  jframe.jButtonRemoveExceptionRow.addActionListener(this);
  jframe.jButtonSave.addActionListener(this);
  jframe.jButtonCancel.addActionListener(this);
  jframe.addKeyListener(this);
  UiDialogs.showOnScreen(0,jframe);
  jframe.setVisible(true);
}",0.9323931978432186
99056,"@Test public void testShouldRetrieveMBean() throws Exception {
  MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();
  ObjectName name=new ObjectName(""String_Node_Str"");
  StatControllerMBean statController=MBeanServerInvocationHandler.newProxyInstance(mbs,name,StatControllerMBean.class,false);
  assertNotNull(statController);
  assertEquals(0,statController.getActiveConnectionCount());
  statController.startRecording();
  Connection connection=dataSource.getConnection();
  assertEquals(1,statController.getActiveConnectionCount());
  connection.close();
  assertEquals(0,statController.getActiveConnectionCount());
}","@Test public void testShouldRetrieveMBean() throws Exception {
  MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();
  ObjectName name=new ObjectName(""String_Node_Str"");
  StatControllerMBean statController=MBeanServerInvocationHandler.newProxyInstance(mbs,name,StatControllerMBean.class,false);
  assertNotNull(statController);
  statController.startRecording();
  statController.resetConnectionCounts();
  long activeConnectionCount=statController.getActiveConnectionCount();
  System.out.println(""String_Node_Str"" + activeConnectionCount);
  Connection connection=dataSource.getConnection();
  assertEquals(activeConnectionCount + 1,statController.getActiveConnectionCount());
  connection.close();
  assertEquals(activeConnectionCount,statController.getActiveConnectionCount());
}",0.6526019690576652
99057,"/** 
 * @param lastConnectionTiming in nano second.
 */
public void setLastConnectionTiming(long lastConnectionTiming){
  this.lastConnectionTiming=lastConnectionTiming;
  averageConnectionTiming=(averageConnectionTiming * totalConnectionUsed.get() + lastConnectionTiming) / totalConnectionUsed.get() + 1;
}","/** 
 * @param lastConnectionTiming in nano second.
 */
public void setLastConnectionTiming(long lastConnectionTiming){
  this.lastConnectionTiming=lastConnectionTiming;
  averageConnectionTiming=(averageConnectionTiming * totalConnectionUsed.get() + lastConnectionTiming) / (totalConnectionUsed.get() + 1);
}",0.9967532467532468
99058,"public Map<String,Long> getSlowestQueries(){
  return Collections.unmodifiableMap(queryRecorder.slowestQueries);
}","@Override public Map<String,Long> getSlowestQueries(){
  return Collections.unmodifiableMap(queryRecorder.slowestQueries);
}",0.957983193277311
99059,"@Override public void resetConnectionCounts(){
  activeConnectionCount.set(0);
  totalConnectionUsed.set(0);
}","@Override public void resetConnectionCounts(){
  totalConnectionUsed.set(0);
  lastConnectionTiming=0;
  averageConnectionTiming=0;
}",0.6419753086419753
99060,"public long getLastConnectionTiming(){
  return lastConnectionTiming;
}","@Override public long getLastConnectionTiming(){
  return lastConnectionTiming;
}",0.9342105263157896
99061,"private Object proceed(ProceedingJoinPoint pjp,String sql) throws Throwable {
  controller.newQuery();
  return pjp.proceed();
}","private Object proceed(ProceedingJoinPoint pjp,String sql) throws Throwable {
  controller.newQuery();
  long delay=System.nanoTime();
  Object proceed=pjp.proceed();
  controller.recordQueryTime(sql,System.nanoTime() - delay);
  return proceed;
}",0.5813333333333334
99062,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.time_input);
  Intent sender=getIntent();
  hourImage=(ImageView)findViewById(R.id.time_input_hour_image);
  minLeftImage=(ImageView)findViewById(R.id.time_input_left_min_image);
  minRightImage=(ImageView)findViewById(R.id.time_input_right_min_image);
  secLeftImage=(ImageView)findViewById(R.id.time_input_left_sec_image);
  secRightImage=(ImageView)findViewById(R.id.time_input_right_sec_image);
  ImageView hourUpImage=(ImageView)findViewById(R.id.time_input_hour_plus_image);
  hourUpImage.setOnClickListener(this);
  ImageView hourDownImage=(ImageView)findViewById(R.id.time_input_hour_minus_image);
  hourDownImage.setOnClickListener(this);
  ImageView minUpImage=(ImageView)findViewById(R.id.time_input_min_plus_image);
  minUpImage.setOnClickListener(this);
  ImageView minDownImage=(ImageView)findViewById(R.id.time_input_min_minus_image);
  minDownImage.setOnClickListener(this);
  ImageView secUpImage=(ImageView)findViewById(R.id.time_input_sec_plus_image);
  secUpImage.setOnClickListener(this);
  ImageView secDownImage=(ImageView)findViewById(R.id.time_input_sec_minus_image);
  secDownImage.setOnClickListener(this);
  try {
    hour=Integer.parseInt(sender.getExtras().getString(""String_Node_Str""));
    min=Integer.parseInt(sender.getExtras().getString(""String_Node_Str""));
    sec=Integer.parseInt(sender.getExtras().getString(""String_Node_Str""));
    posi=sender.getExtras().getInt(""String_Node_Str"");
    this.setHourImage();
    this.setMinImage();
    this.setSecImage();
  }
 catch (  NullPointerException e) {
  }
  Button button=(Button)findViewById(R.id.time_input_button);
  button.setOnClickListener(this);
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.time_input);
  Intent sender=getIntent();
  hourImage=(ImageView)findViewById(R.id.time_input_hour_image);
  minLeftImage=(ImageView)findViewById(R.id.time_input_left_min_image);
  minRightImage=(ImageView)findViewById(R.id.time_input_right_min_image);
  secLeftImage=(ImageView)findViewById(R.id.time_input_left_sec_image);
  secRightImage=(ImageView)findViewById(R.id.time_input_right_sec_image);
  mGestureDetector=new GestureDetector(this);
  mGestureDetector.setIsLongpressEnabled(true);
  ImageView hourUpImage=(ImageView)findViewById(R.id.time_input_hour_plus_image);
  hourUpImage.setOnClickListener(this);
  hourUpImage.setOnTouchListener(this);
  ImageView hourDownImage=(ImageView)findViewById(R.id.time_input_hour_minus_image);
  hourDownImage.setOnClickListener(this);
  hourDownImage.setOnTouchListener(this);
  ImageView minUpImage=(ImageView)findViewById(R.id.time_input_min_plus_image);
  minUpImage.setOnClickListener(this);
  minUpImage.setOnTouchListener(this);
  ImageView minDownImage=(ImageView)findViewById(R.id.time_input_min_minus_image);
  minDownImage.setOnClickListener(this);
  minDownImage.setOnTouchListener(this);
  ImageView secUpImage=(ImageView)findViewById(R.id.time_input_sec_plus_image);
  secUpImage.setOnClickListener(this);
  secUpImage.setOnTouchListener(this);
  ImageView secDownImage=(ImageView)findViewById(R.id.time_input_sec_minus_image);
  secDownImage.setOnClickListener(this);
  secDownImage.setOnTouchListener(this);
  try {
    hour=Integer.parseInt(sender.getExtras().getString(""String_Node_Str""));
    min=Integer.parseInt(sender.getExtras().getString(""String_Node_Str""));
    sec=Integer.parseInt(sender.getExtras().getString(""String_Node_Str""));
    posi=sender.getExtras().getInt(""String_Node_Str"");
    this.setHourImage();
    this.setMinImage();
    this.setSecImage();
  }
 catch (  NullPointerException e) {
  }
  Button button=(Button)findViewById(R.id.time_input_button);
  button.setOnClickListener(this);
}",0.9129082426127528
99063,"private void restartTimer(int posi){
  status=Status.STARTED;
  this.pausedTime=System.currentTimeMillis() - this.pauseTime;
  handler.post(countdown);
}","private void restartTimer(int posi){
  status=Status.STARTED;
  this.pausedTime=System.currentTimeMillis() - this.pauseTime;
  handler.post(Countdown);
}",0.9934640522875816
99064,"private void startTimer(int posi){
  try {
    status=Status.STARTED;
    startTime=System.currentTimeMillis();
    TimeUnits time=timerModel.get(posi);
    countdownTime=time.getMillisFromHour(0);
    handler.post(countdown);
  }
 catch (  IndexOutOfBoundsException e) {
    this.stopTimer();
  }
}","private void startTimer(int posi){
  try {
    status=Status.STARTED;
    startTime=System.currentTimeMillis();
    TimeUnits time=timerModel.get(posi);
    countdownTime=time.getMillisFromHour(0);
    handler.post(Countdown);
  }
 catch (  IndexOutOfBoundsException e) {
    this.stopTimer();
  }
}",0.9966555183946488
99065,"private void stopTimer(){
  status=Status.STOPPED;
  handler.removeCallbacks(countdown);
  this.clearTimer();
  this.posi=0;
}","private void stopTimer(){
  status=Status.STOPPED;
  handler.removeCallbacks(Countdown);
  this.clearTimer();
  this.posi=0;
}",0.992063492063492
99066,"private void pauseTimer(){
  status=Status.PAUSED;
  this.pauseTime=System.currentTimeMillis();
  handler.removeCallbacks(countdown);
}","private void pauseTimer(){
  status=Status.PAUSED;
  this.pauseTime=System.currentTimeMillis();
  handler.removeCallbacks(Countdown);
}",0.9925925925925926
99067,"private void initiate(Bundle savedInstanceState){
  if (savedInstanceState != null) {
    this.getController().selectRoutine(savedInstanceState.getString(""String_Node_Str""));
  }
}","private void initiate(Bundle savedInstanceState){
  Log.d(TAG,""String_Node_Str"");
  if (savedInstanceState != null) {
    this.getController().selectRoutine(savedInstanceState.getString(""String_Node_Str""));
  }
}",0.9183673469387756
99068,"@Override public void onPause(){
  super.onPause();
  SharedPreferences settings=getSharedPreferences(PREFS_NAME,0);
  SharedPreferences.Editor editor=settings.edit();
  editor.putString(getString(R.string.selected_routine_key),this.getController().getSelectedRoutine());
  editor.commit();
}","@Override public void onPause(){
  super.onPause();
  this.setPreference();
}",0.3848238482384823
99069,"@Override public void onActivityResult(int requestCode,int resultCode,Intent data){
  super.onActivityResult(requestCode,resultCode,data);
  if (resultCode == RESULT_OK) {
    getController().handleInput(requestCode,data);
  }
}","@Override public void onActivityResult(int requestCode,int resultCode,Intent data){
  super.onActivityResult(requestCode,resultCode,data);
  if (resultCode == RESULT_OK) {
    getController().handleInput(requestCode,data);
    this.setPreference();
  }
}",0.946058091286307
99070,"@Override public void onResume(){
  super.onResume();
  SharedPreferences settings=getSharedPreferences(PREFS_NAME,0);
  String selectedRoutine=settings.getString(getString(R.string.selected_routine_key),null);
  if (selectedRoutine != null) {
    this.getController().selectRoutine(selectedRoutine);
  }
}","@Override public void onResume(){
  super.onResume();
  Log.d(TAG,""String_Node_Str"");
  SharedPreferences settings=getSharedPreferences(PREFS_NAME,0);
  String selectedRoutine=settings.getString(getString(R.string.selected_routine_key),null);
  if (selectedRoutine != null) {
    this.getController().selectRoutine(selectedRoutine);
  }
}",0.9503105590062112
99071,"/** 
 * Initiate of routine spinner object. Generate the default if no routine was stored in the database.
 */
private void loadRoutineSpinner(){
  List<String> list=storeController.getRoutines();
  if (list.size() < 1) {
    list.add(getActivity().getString(R.string.default_routine_name));
  }
  ((InteractiveListView)listView).populateSpinner(list);
}","/** 
 * Initiate of routine spinner object. Generate the default if no routine was stored in the database.
 */
private void loadRoutineSpinner(){
  Log.d(TAG,""String_Node_Str"");
  List<String> list=storeController.getRoutines();
  if (list.size() < 1) {
    list.add(getActivity().getString(R.string.default_routine_name));
  }
  ((InteractiveListView)listView).populateSpinner(list);
}",0.9567567567567568
99072,"public void handleInput(int requestCode,Intent data){
  if (requestCode == CountdownTimerController.TIME_ADD_CODE || requestCode == CountdownTimerController.TIME_EDIT_CODE) {
    TimeUnits units=new TimeUnits();
    units.add(data.getStringExtra(""String_Node_Str""));
    units.add(data.getStringExtra(""String_Node_Str""));
    units.add(data.getStringExtra(""String_Node_Str""));
switch (requestCode) {
case (CountdownTimerController.TIME_ADD_CODE):
      this.addTime(units);
    break;
case (CountdownTimerController.TIME_EDIT_CODE):
  this.editTime(data.getExtras().getInt(""String_Node_Str""),units);
break;
}
this.saveRoutine(this.getSelectedRoutine());
}
 else {
String text=data.getStringExtra(""String_Node_Str"");
if (text == null || text.length() < 1) {
Toast.makeText(this.getActivity().getApplicationContext(),this.getActivity().getString(R.string.no_text_warning),Toast.LENGTH_SHORT).show();
}
switch (requestCode) {
case (CountdownTimerController.TEXT_ADD_CODE):
this.addRoutine(text);
this.loadListView(text);
break;
case (CountdownTimerController.TEXT_EDIT_CODE):
String originalText=data.getStringExtra(""String_Node_Str"");
this.editRoutine(originalText,text);
this.loadListView(text);
break;
}
}
}","/** 
 * Handle both time and text input from external activity
 * @param requestCode
 * @param data
 */
public void handleInput(int requestCode,Intent data){
  if (requestCode == CountdownTimerController.TIME_ADD_CODE || requestCode == CountdownTimerController.TIME_EDIT_CODE) {
    TimeUnits units=new TimeUnits();
    units.add(data.getStringExtra(""String_Node_Str""));
    units.add(data.getStringExtra(""String_Node_Str""));
    units.add(data.getStringExtra(""String_Node_Str""));
switch (requestCode) {
case (CountdownTimerController.TIME_ADD_CODE):
      this.addTime(units);
    break;
case (CountdownTimerController.TIME_EDIT_CODE):
  this.editTime(data.getExtras().getInt(""String_Node_Str""),units);
break;
}
this.saveRoutine(this.getSelectedRoutine());
}
 else {
String text=data.getStringExtra(""String_Node_Str"");
if (text == null || text.length() < 1) {
Toast.makeText(this.getActivity().getApplicationContext(),this.getActivity().getString(R.string.no_text_warning),Toast.LENGTH_SHORT).show();
}
switch (requestCode) {
case (CountdownTimerController.TEXT_ADD_CODE):
this.addRoutine(text);
this.loadListView(text);
Log.d(TAG,""String_Node_Str"");
break;
case (CountdownTimerController.TEXT_EDIT_CODE):
String originalText=data.getStringExtra(""String_Node_Str"");
this.editRoutine(originalText,text);
this.loadListView(text);
break;
}
}
}",0.9474097331240188
99073,"/** 
 * Given the name of the intentional select routine item, reload the routine spinner,  select the routine item, and load the routine time units from the listview.
 * @param text name of the intentional selection routine.
 */
private void loadListView(String text){
  this.loadRoutineSpinner();
  this.selectRoutine(text);
  this.loadRoutine();
}","/** 
 * Given the name of the intentional select routine item, reload the routine spinner,  select the routine item, and load the routine time units from the listview.
 * @param text name of the intentional selection routine.
 */
private void loadListView(String text){
  Log.d(TAG,""String_Node_Str"" + text);
  this.loadRoutineSpinner();
  this.selectRoutine(text);
  this.loadRoutine();
}",0.9472259810554804
99074,"public void selectRoutine(String text){
  ((InteractiveListView)listView).selectSpinner(text);
}","public void selectRoutine(String text){
  Log.d(TAG,""String_Node_Str"" + text);
  ((InteractiveListView)listView).selectSpinner(text);
}",0.8311688311688312
99075,"/** 
 * Save the routine in the database, given the name of the routine.
 * @param name Routine name.
 */
private void addRoutine(String name){
  storeController.storeRoutine(name);
}","/** 
 * Save the routine in the database, given the name of the routine.
 * @param name Routine name.
 */
private void addRoutine(String name){
  Log.d(TAG,""String_Node_Str"");
  storeController.storeRoutine(name);
}",0.9195979899497488
99076,"/** 
 * Determine the currently selected item from the routine spinner, and update the routine list, given the routine selected.
 */
private void loadRoutine(){
  this.loadRoutine(this.getSelectedRoutine());
}","/** 
 * Determine the currently selected item from the routine spinner, and update the routine list, given the routine selected.
 */
private void loadRoutine(){
  Log.d(TAG,""String_Node_Str"");
  this.loadRoutine(this.getSelectedRoutine());
}",0.9288888888888888
99077,"public String getSelectedRoutine(){
  return ((InteractiveListView)listView).getSelectedRoutine();
}","public String getSelectedRoutine(){
  Log.d(TAG,""String_Node_Str"");
  return ((InteractiveListView)listView).getSelectedRoutine();
}",0.8620689655172413
99078,"/** 
 * Store the routine given the name of the routine, and return the store ID of the routine. If the given name already exist, it return the ID of the  stored routine.
 * @param routineName name of the routine.
 * @return ID of the routine, given the name.
 */
public long storeRoutine(String routineName) throws ClassCastException {
  RoutineSQL storedRoutine=this.retrieveStoredRoutine(routineName);
  if (storedRoutine == null) {
    Log.d(""String_Node_Str"",""String_Node_Str"");
    RoutineSQL routine=new RoutineSQL(null,routineName);
    routineDao.insert(routine);
    return routine.getId();
  }
  return storedRoutine.getId();
}","/** 
 * Store the routine given the name of the routine, and return the store ID of the routine. If the given name already exist, it return the ID of the  stored routine.
 * @param routineName name of the routine.
 * @return ID of the routine, given the name.
 */
public long storeRoutine(String routineName) throws ClassCastException {
  RoutineSQL storedRoutine=this.retrieveStoredRoutine(routineName);
  if (storedRoutine == null) {
    RoutineSQL routine=new RoutineSQL(null,routineName);
    routineDao.insert(routine);
    return routine.getId();
  }
  return storedRoutine.getId();
}",0.9609120521172638
99079,"public CountdownTimerModel retrieveTimerModel(String routineName){
  Log.d(""String_Node_Str"",""String_Node_Str"" + routineName);
  RoutineSQL storedRoutine=this.retrieveStoredRoutine(routineName);
  CountdownTimerModel model=new CountdownTimerModel();
  if (storedRoutine != null) {
    List<TimeUnitSQL> storedUnits=this.retrieveStoredTimeUnits(storedRoutine.getId());
    for (    TimeUnitSQL unit : storedUnits) {
      Log.d(""String_Node_Str"",""String_Node_Str"" + unit.getTimeunit());
      model.add(new TimeUnits(unit.getTimeunit()));
    }
  }
  return model;
}","public CountdownTimerModel retrieveTimerModel(String routineName){
  RoutineSQL storedRoutine=this.retrieveStoredRoutine(routineName);
  CountdownTimerModel model=new CountdownTimerModel();
  if (storedRoutine != null) {
    List<TimeUnitSQL> storedUnits=this.retrieveStoredTimeUnits(storedRoutine.getId());
    for (    TimeUnitSQL unit : storedUnits) {
      Log.d(""String_Node_Str"",""String_Node_Str"" + unit.getTimeunit());
      model.add(new TimeUnits(unit.getTimeunit()));
    }
  }
  return model;
}",0.22803738317757
99080,"/** 
 * Store the count down timer routine (CountdownTimerModel) with the given  routine name.
 * @param model A given routine count down timer model.
 * @param routineName Name of the routine.
 */
public void storeTimerModel(CountdownTimerModel model,String routineName){
  long routineId=this.storeRoutine(routineName);
  Log.d(""String_Node_Str"",routineName + ""String_Node_Str"" + routineId);
  this.deleteTimeUnitsByRoutineId(routineId);
  for (int i=model.size() - 1; i >= 0; i--) {
    this.storeTimeUnit(model.get(i).toString(),i,routineId);
  }
}","/** 
 * Store the count down timer routine (CountdownTimerModel) with the given  routine name.
 * @param model A given routine count down timer model.
 * @param routineName Name of the routine.
 */
public void storeTimerModel(CountdownTimerModel model,String routineName){
  long routineId=this.storeRoutine(routineName);
  this.deleteTimeUnitsByRoutineId(routineId);
  for (int i=model.size() - 1; i >= 0; i--) {
    this.storeTimeUnit(model.get(i).toString(),i,routineId);
  }
}",0.9302325581395348
99081,"private long storeTimeUnit(String unitString,int order,long routineId){
  Log.d(""String_Node_Str"",""String_Node_Str"" + unitString + ""String_Node_Str""+ order+ ""String_Node_Str""+ routineId);
  TimeUnitSQL storedTimeUnit=this.retrieveStoredTimeUnits(routineId,order);
  if (storedTimeUnit == null) {
    TimeUnitSQL unit=new TimeUnitSQL(null,unitString,order,routineId);
    unitDao.insert(unit);
    Log.d(""String_Node_Str"",""String_Node_Str"" + unit.getId());
    return unit.getId();
  }
 else {
    storedTimeUnit.setTimeunit(unitString);
    unitDao.update(storedTimeUnit);
    Log.d(""String_Node_Str"",""String_Node_Str"" + storedTimeUnit.getId());
    return storedTimeUnit.getId();
  }
}","private long storeTimeUnit(String unitString,int order,long routineId){
  TimeUnitSQL storedTimeUnit=this.retrieveStoredTimeUnits(routineId,order);
  if (storedTimeUnit == null) {
    TimeUnitSQL unit=new TimeUnitSQL(null,unitString,order,routineId);
    unitDao.insert(unit);
    return unit.getId();
  }
 else {
    storedTimeUnit.setTimeunit(unitString);
    unitDao.update(storedTimeUnit);
    return storedTimeUnit.getId();
  }
}",0.7642857142857142
99082,"/** 
 * Return a list of stored routine given the routine name. (The design  should only have one routine with a given name).
 * @param routineName
 * @return
 */
private RoutineSQL retrieveStoredRoutine(String routineName){
  Log.d(""String_Node_Str"",""String_Node_Str"" + routineName);
  return routineDao.queryBuilder().where(com.hook38.sporttimer.model.sql.RoutineSQLDao.Properties.Name.eq(routineName)).unique();
}","/** 
 * Return a list of stored routine given the routine name. (The design  should only have one routine with a given name).
 * @param routineName
 * @return
 */
private RoutineSQL retrieveStoredRoutine(String routineName){
  return routineDao.queryBuilder().where(com.hook38.sporttimer.model.sql.RoutineSQLDao.Properties.Name.eq(routineName)).unique();
}",0.922279792746114
99083,"/** 
 * Return the selected spinner
 * @return Name of the selected spinner
 */
public String getSelectedRoutine(){
  return routine_spinner.getSelectedItem().toString();
}","/** 
 * Return the selected spinner
 * @return Name of the selected spinner
 */
public String getSelectedRoutine(){
  try {
    return routine_spinner.getSelectedItem().toString();
  }
 catch (  IndexOutOfBoundsException e) {
    return routine_spinner.getItemAtPosition(0).toString();
  }
}",0.7429805615550756
99084,"protected void mongoDB2Graph() throws Exception {
  pc=Lookup.getDefault().lookup(ProjectController.class);
  pc.newProject();
  workspace=pc.getCurrentWorkspace();
  graphModel=Lookup.getDefault().lookup(GraphController.class).getModel();
  undirectedGraph=graphModel.getUndirectedGraph();
  BasicDBList friends=(BasicDBList)this.fb_profile.get(""String_Node_Str"");
  nodes=new Node[friends.size() * 2];
  friendHash=new HashMap<Long,Integer>();
  Iterator itr=friends.iterator();
  BasicDBObject friend=new BasicDBObject();
  int idx=0;
  while (itr.hasNext()) {
    friend=(BasicDBObject)itr.next();
    long uid=Long.valueOf(friend.get(""String_Node_Str"").toString());
    String name=friend.get(""String_Node_Str"").toString();
    friendHash.put(new Long(uid),new Integer(idx));
    String suid=""String_Node_Str"" + uid;
    Node n0=graphModel.factory().newNode(suid);
    n0.getNodeData().setLabel(name);
    undirectedGraph.addNode(n0);
    nodes[idx]=n0;
    idx++;
  }
  friendHash.put(new Long(userUid),idx);
  Node nego=graphModel.factory().newNode(""String_Node_Str"" + userUid);
  nego.getNodeData().setLabel(userName);
  undirectedGraph.addNode(nego);
  nodes[idx]=nego;
  idx++;
  System.out.println(friend);
  System.out.println(friend.get(""String_Node_Str""));
  System.out.println(friends.size());
  BasicDBList edges=(BasicDBList)this.fb_profile.get(""String_Node_Str"");
  System.out.println(edges.toArray()[0].getClass().getName());
  itr=edges.iterator();
  BasicDBObject edge;
  while (itr.hasNext()) {
    edge=(BasicDBObject)itr.next();
    long node1=Long.valueOf(edge.get(""String_Node_Str"").toString());
    long node2=Long.valueOf(edge.get(""String_Node_Str"").toString());
    if (node2 > node1) {
      int idx1=(Integer)friendHash.get(node1);
      int idx2=(Integer)friendHash.get(node2);
      Edge e1=graphModel.factory().newEdge(nodes[idx1],nodes[idx2]);
      undirectedGraph.addEdge(e1);
    }
  }
  for (int i1=0; i1 < friends.size(); i1++) {
    Edge e2=graphModel.factory().newEdge(nodes[i1],nego);
    undirectedGraph.addEdge(e2);
  }
  System.out.println(edges.size());
}","protected void mongoDB2Graph() throws Exception {
  pc=Lookup.getDefault().lookup(ProjectController.class);
  pc.newProject();
  workspace=pc.getCurrentWorkspace();
  graphModel=Lookup.getDefault().lookup(GraphController.class).getModel();
  undirectedGraph=graphModel.getUndirectedGraph();
  BasicDBList friends=(BasicDBList)this.fb_profile.get(""String_Node_Str"");
  nodes=new Node[friends.size() * 2];
  friendHash=new HashMap<Long,Integer>();
  Iterator itr=friends.iterator();
  BasicDBObject friend=new BasicDBObject();
  int idx=0;
  while (itr.hasNext()) {
    friend=(BasicDBObject)itr.next();
    long uid=Long.valueOf(friend.get(""String_Node_Str"").toString());
    String name=friend.get(""String_Node_Str"").toString();
    friendHash.put(new Long(uid),new Integer(idx));
    String suid=""String_Node_Str"" + uid;
    Node n0=graphModel.factory().newNode(suid);
    n0.getNodeData().setLabel(name);
    undirectedGraph.addNode(n0);
    nodes[idx]=n0;
    idx++;
  }
  friendHash.put(new Long(userUid),idx);
  Node nego=graphModel.factory().newNode(""String_Node_Str"" + userUid);
  nego.getNodeData().setLabel(userName);
  undirectedGraph.addNode(nego);
  nodes[idx]=nego;
  idx++;
  System.out.println(friend);
  System.out.println(friend.get(""String_Node_Str""));
  System.out.println(friends.size());
  BasicDBList edges=(BasicDBList)this.fb_profile.get(""String_Node_Str"");
  if (edges.size() > 0)   System.out.println(edges.toArray()[0].getClass().getName());
  itr=edges.iterator();
  BasicDBObject edge;
  while (itr.hasNext()) {
    edge=(BasicDBObject)itr.next();
    long node1=Long.valueOf(edge.get(""String_Node_Str"").toString());
    long node2=Long.valueOf(edge.get(""String_Node_Str"").toString());
    if (node2 > node1) {
      int idx1=(Integer)friendHash.get(node1);
      int idx2=(Integer)friendHash.get(node2);
      Edge e1=graphModel.factory().newEdge(nodes[idx1],nodes[idx2]);
      undirectedGraph.addEdge(e1);
    }
  }
  for (int i1=0; i1 < friends.size(); i1++) {
    Edge e2=graphModel.factory().newEdge(nodes[i1],nego);
    undirectedGraph.addEdge(e2);
  }
  System.out.println(edges.size());
}",0.9943235572374646
99085,"@Override protected void generateResult(){
  AttributeModel attributeModel=Lookup.getDefault().lookup(AttributeController.class).getModel();
  PreviewModel model=Lookup.getDefault().lookup(PreviewController.class).getModel();
  FilterController filterController=Lookup.getDefault().lookup(FilterController.class);
  RankingController rankingController=Lookup.getDefault().lookup(RankingController.class);
  int totalNodes=undirectedGraph.getNodeCount();
  System.out.println(""String_Node_Str"" + totalNodes);
  System.out.println(""String_Node_Str"" + undirectedGraph.getEdgeCount());
  Degree degree=new Degree();
  degree.execute(graphModel,attributeModel);
  System.out.println(""String_Node_Str"" + degree.getAverageDegree());
  AttributeColumn degreeColumn=attributeModel.getNodeTable().getColumn(""String_Node_Str"");
  int[] degreeArray;
  degreeArray=new int[undirectedGraph.getNodeCount()];
  int i1=0;
  for (  Node n : graphModel.getGraph().getNodes()) {
    int val=Integer.valueOf(n.getNodeData().getAttributes().getValue(Ranking.DEGREE_RANKING).toString());
    degreeArray[i1++]=val;
  }
  reportStatistics(degreeArray);
  int degreeFilterRange=0;
  if (totalNodes > 1000)   degreeFilterRange=6;
 else   if (totalNodes > 800)   degreeFilterRange=5;
 else   if (totalNodes > 600)   degreeFilterRange=4;
 else   if (totalNodes > 400)   degreeFilterRange=3;
 else   if (totalNodes > 200)   degreeFilterRange=2;
 else   if (totalNodes > 100)   degreeFilterRange=1;
 else   if (totalNodes > 50)   degreeFilterRange=0;
  System.out.println(""String_Node_Str"" + totalNodes + ""String_Node_Str""+ degreeFilterRange);
  System.out.println(""String_Node_Str"");
  DegreeRangeFilter degreeFilter=new DegreeRangeFilter();
  degreeFilter.init(undirectedGraph);
  degreeFilter.setRange(new Range(degreeFilterRange,Integer.MAX_VALUE));
  Query query=filterController.createQuery(degreeFilter);
  GraphView view=filterController.filter(query);
  graphModel.setVisibleView(view);
  UndirectedGraph graphVisible=graphModel.getUndirectedGraphVisible();
  System.out.println(""String_Node_Str"" + graphVisible.getNodeCount());
  System.out.println(""String_Node_Str"" + graphVisible.getEdgeCount() + ""String_Node_Str"");
  ForceAtlas2 fa2Layout=new ForceAtlas2(new ForceAtlas2Builder());
  fa2Layout.setGraphModel(graphModel);
  fa2Layout.resetPropertiesValues();
  fa2Layout.setEdgeWeightInfluence(1.0);
  fa2Layout.setGravity(1.0);
  fa2Layout.setScalingRatio(2.0);
  fa2Layout.setBarnesHutTheta(1.2);
  fa2Layout.setJitterTolerance(0.1);
  fa2Layout.initAlgo();
  int cnt=0;
  for (int i=0; i < 250 && fa2Layout.canAlgo(); i++) {
    fa2Layout.goAlgo();
    cnt++;
  }
  System.out.println(""String_Node_Str"" + cnt + ""String_Node_Str"");
  fa2Layout.endAlgo();
  GraphDistance distance=new GraphDistance();
  distance.setDirected(false);
  distance.execute(graphModel,attributeModel);
  System.out.println(""String_Node_Str"");
  AttributeColumn centralityColumn=attributeModel.getNodeTable().getColumn(GraphDistance.BETWEENNESS);
  double maxVal=0;
  double secondMax=0;
  double thirdMax=0;
  double extremVal=0;
  Node nMax=null;
  Node nSecond=null;
  int numNode=graphModel.getGraph().getNodeCount();
  for (  Node n : graphModel.getGraph().getNodes()) {
    double val=Double.valueOf(n.getNodeData().getAttributes().getValue(GraphDistance.BETWEENNESS).toString());
    if (val > maxVal) {
      thirdMax=secondMax;
      secondMax=maxVal;
      nSecond=nMax;
      maxVal=val;
      nMax=n;
    }
 else     if (val > secondMax) {
      thirdMax=secondMax;
      secondMax=val;
      nSecond=n;
    }
 else     if (val > thirdMax) {
      thirdMax=val;
    }
  }
  System.out.println(numNode + ""String_Node_Str"" + maxVal+ ""String_Node_Str""+ secondMax+ ""String_Node_Str""+ thirdMax);
  nMax.getNodeData().getAttributes().setValue(GraphDistance.BETWEENNESS,thirdMax * 1.5);
  nSecond.getNodeData().getAttributes().setValue(GraphDistance.BETWEENNESS,thirdMax * 1.2);
  Ranking centralityRanking=rankingController.getModel().getRanking(Ranking.NODE_ELEMENT,centralityColumn.getId());
  AbstractSizeTransformer sizeTransformer=(AbstractSizeTransformer)rankingController.getModel().getTransformer(Ranking.NODE_ELEMENT,Transformer.RENDERABLE_SIZE);
  sizeTransformer.setMinSize(6);
  sizeTransformer.setMaxSize(30);
  rankingController.transform(centralityRanking,sizeTransformer);
  System.out.println(""String_Node_Str"");
  model.getProperties().putValue(PreviewProperty.SHOW_NODE_LABELS,Boolean.TRUE);
  model.getProperties().putValue(PreviewProperty.EDGE_COLOR,new EdgeColor(Color.GRAY));
  model.getProperties().putValue(PreviewProperty.EDGE_THICKNESS,new Float(0.1f));
  model.getProperties().putValue(PreviewProperty.NODE_LABEL_FONT,model.getProperties().getFontValue(PreviewProperty.NODE_LABEL_FONT).deriveFont(8));
  PartitionController partitionController=Lookup.getDefault().lookup(PartitionController.class);
  Modularity modularity=new Modularity();
  modularity.execute(graphModel,attributeModel);
  AttributeColumn modColumn=attributeModel.getNodeTable().getColumn(Modularity.MODULARITY_CLASS);
  Partition p2=partitionController.buildPartition(modColumn,undirectedGraph);
  System.out.println(p2.getPartsCount() + ""String_Node_Str"");
  NodeColorTransformer nodeColorTransformer2=new NodeColorTransformer();
  Map<Object,Color> color_map=nodeColorTransformer2.getMap();
  setColorsAndSaveLabelsToMongo(p2,color_map);
  partitionController.transform(p2,nodeColorTransformer2);
}","@Override protected void generateResult(){
  AttributeModel attributeModel=Lookup.getDefault().lookup(AttributeController.class).getModel();
  PreviewModel model=Lookup.getDefault().lookup(PreviewController.class).getModel();
  FilterController filterController=Lookup.getDefault().lookup(FilterController.class);
  RankingController rankingController=Lookup.getDefault().lookup(RankingController.class);
  int totalNodes=undirectedGraph.getNodeCount();
  System.out.println(""String_Node_Str"" + totalNodes);
  System.out.println(""String_Node_Str"" + undirectedGraph.getEdgeCount());
  Degree degree=new Degree();
  degree.execute(graphModel,attributeModel);
  System.out.println(""String_Node_Str"" + degree.getAverageDegree());
  AttributeColumn degreeColumn=attributeModel.getNodeTable().getColumn(""String_Node_Str"");
  int[] degreeArray;
  degreeArray=new int[undirectedGraph.getNodeCount()];
  int i1=0;
  for (  Node n : graphModel.getGraph().getNodes()) {
    int val=Integer.valueOf(n.getNodeData().getAttributes().getValue(Ranking.DEGREE_RANKING).toString());
    degreeArray[i1++]=val;
  }
  reportStatistics(degreeArray);
  int degreeFilterRange=0;
  if (totalNodes > 1000)   degreeFilterRange=6;
 else   if (totalNodes > 800)   degreeFilterRange=5;
 else   if (totalNodes > 600)   degreeFilterRange=4;
 else   if (totalNodes > 400)   degreeFilterRange=3;
 else   if (totalNodes > 200)   degreeFilterRange=2;
 else   if (totalNodes > 100)   degreeFilterRange=1;
 else   if (totalNodes > 50)   degreeFilterRange=0;
  System.out.println(""String_Node_Str"" + totalNodes + ""String_Node_Str""+ degreeFilterRange);
  System.out.println(""String_Node_Str"");
  DegreeRangeFilter degreeFilter=new DegreeRangeFilter();
  degreeFilter.init(undirectedGraph);
  degreeFilter.setRange(new Range(degreeFilterRange,Integer.MAX_VALUE));
  Query query=filterController.createQuery(degreeFilter);
  GraphView view=filterController.filter(query);
  graphModel.setVisibleView(view);
  UndirectedGraph graphVisible=graphModel.getUndirectedGraphVisible();
  System.out.println(""String_Node_Str"" + graphVisible.getNodeCount());
  System.out.println(""String_Node_Str"" + graphVisible.getEdgeCount() + ""String_Node_Str"");
  ForceAtlas2 fa2Layout=new ForceAtlas2(new ForceAtlas2Builder());
  fa2Layout.setGraphModel(graphModel);
  fa2Layout.resetPropertiesValues();
  fa2Layout.setEdgeWeightInfluence(1.0);
  fa2Layout.setGravity(1.0);
  fa2Layout.setScalingRatio(2.0);
  fa2Layout.setBarnesHutTheta(1.2);
  fa2Layout.setJitterTolerance(0.1);
  fa2Layout.initAlgo();
  int cnt=0;
  for (int i=0; i < 250 && fa2Layout.canAlgo(); i++) {
    fa2Layout.goAlgo();
    cnt++;
  }
  System.out.println(""String_Node_Str"" + cnt + ""String_Node_Str"");
  fa2Layout.endAlgo();
  GraphDistance distance=new GraphDistance();
  distance.setDirected(false);
  distance.execute(graphModel,attributeModel);
  System.out.println(""String_Node_Str"");
  AttributeColumn centralityColumn=attributeModel.getNodeTable().getColumn(GraphDistance.BETWEENNESS);
  double maxVal=0;
  double secondMax=0;
  double thirdMax=0;
  double extremVal=0;
  Node nMax=null;
  Node nSecond=null;
  int numNode=graphModel.getGraph().getNodeCount();
  if (numNode > 20) {
    for (    Node n : graphModel.getGraph().getNodes()) {
      double val=Double.valueOf(n.getNodeData().getAttributes().getValue(GraphDistance.BETWEENNESS).toString());
      if (val > maxVal) {
        thirdMax=secondMax;
        secondMax=maxVal;
        nSecond=nMax;
        maxVal=val;
        nMax=n;
      }
 else       if (val > secondMax) {
        thirdMax=secondMax;
        secondMax=val;
        nSecond=n;
      }
 else       if (val > thirdMax) {
        thirdMax=val;
      }
    }
    System.out.println(numNode + ""String_Node_Str"" + maxVal+ ""String_Node_Str""+ secondMax+ ""String_Node_Str""+ thirdMax);
    nMax.getNodeData().getAttributes().setValue(GraphDistance.BETWEENNESS,thirdMax * 1.5);
    nSecond.getNodeData().getAttributes().setValue(GraphDistance.BETWEENNESS,thirdMax * 1.2);
  }
  Ranking centralityRanking=rankingController.getModel().getRanking(Ranking.NODE_ELEMENT,centralityColumn.getId());
  AbstractSizeTransformer sizeTransformer=(AbstractSizeTransformer)rankingController.getModel().getTransformer(Ranking.NODE_ELEMENT,Transformer.RENDERABLE_SIZE);
  sizeTransformer.setMinSize(6);
  sizeTransformer.setMaxSize(30);
  rankingController.transform(centralityRanking,sizeTransformer);
  System.out.println(""String_Node_Str"");
  model.getProperties().putValue(PreviewProperty.SHOW_NODE_LABELS,Boolean.TRUE);
  model.getProperties().putValue(PreviewProperty.EDGE_COLOR,new EdgeColor(Color.GRAY));
  model.getProperties().putValue(PreviewProperty.EDGE_THICKNESS,new Float(0.1f));
  model.getProperties().putValue(PreviewProperty.NODE_LABEL_FONT,model.getProperties().getFontValue(PreviewProperty.NODE_LABEL_FONT).deriveFont(8));
  PartitionController partitionController=Lookup.getDefault().lookup(PartitionController.class);
  Modularity modularity=new Modularity();
  modularity.execute(graphModel,attributeModel);
  AttributeColumn modColumn=attributeModel.getNodeTable().getColumn(Modularity.MODULARITY_CLASS);
  Partition p2=partitionController.buildPartition(modColumn,undirectedGraph);
  System.out.println(p2.getPartsCount() + ""String_Node_Str"");
  NodeColorTransformer nodeColorTransformer2=new NodeColorTransformer();
  Map<Object,Color> color_map=nodeColorTransformer2.getMap();
  setColorsAndSaveLabelsToMongo(p2,color_map);
  partitionController.transform(p2,nodeColorTransformer2);
}",0.992909090909091
99086,"private void genGraph(){
  AttributeModel attributeModel=Lookup.getDefault().lookup(AttributeController.class).getModel();
  PreviewModel model=Lookup.getDefault().lookup(PreviewController.class).getModel();
  FilterController filterController=Lookup.getDefault().lookup(FilterController.class);
  RankingController rankingController=Lookup.getDefault().lookup(RankingController.class);
  System.out.println(""String_Node_Str"" + undirectedGraph.getNodeCount());
  System.out.println(""String_Node_Str"" + undirectedGraph.getEdgeCount());
  Degree degree=new Degree();
  degree.execute(graphModel,attributeModel);
  System.out.println(""String_Node_Str"" + degree.getAverageDegree());
  AttributeColumn degreeColumn=attributeModel.getNodeTable().getColumn(""String_Node_Str"");
  int[] degreeArray;
  degreeArray=new int[undirectedGraph.getNodeCount()];
  int i1=0;
  for (  Node n : graphModel.getGraph().getNodes()) {
    int val=Integer.valueOf(n.getNodeData().getAttributes().getValue(Ranking.DEGREE_RANKING).toString());
    degreeArray[i1++]=val;
  }
  reportStatistics(degreeArray);
  System.out.println(""String_Node_Str"");
  DegreeRangeFilter degreeFilter=new DegreeRangeFilter();
  degreeFilter.init(undirectedGraph);
  degreeFilter.setRange(new Range(4,Integer.MAX_VALUE));
  Query query=filterController.createQuery(degreeFilter);
  GraphView view=filterController.filter(query);
  graphModel.setVisibleView(view);
  UndirectedGraph graphVisible=graphModel.getUndirectedGraphVisible();
  System.out.println(""String_Node_Str"" + graphVisible.getNodeCount());
  System.out.println(""String_Node_Str"" + graphVisible.getEdgeCount() + ""String_Node_Str"");
  GraphView tview=graphModel.newView();
  UndirectedGraph tgraph=graphModel.getUndirectedGraph(tview);
  KCoreBuilder.KCoreFilter kCoreFilter=new KCoreBuilder.KCoreFilter();
  int k=1;
  while (tgraph.getNodeCount() > 0) {
    kCoreFilter.setK(k);
    kCoreFilter.filter(tgraph);
    System.out.println(""String_Node_Str"" + k + ""String_Node_Str""+ tgraph.getNodeCount());
    System.out.println(""String_Node_Str"" + tgraph.getEdgeCount());
    k++;
  }
  int kCore=k - 1;
  BasicDBObject mongo_query_kcore=new BasicDBObject(""String_Node_Str"",this.fb_profile.get(""String_Node_Str""));
  BasicDBObject updateCmd=new BasicDBObject(""String_Node_Str"",new BasicDBObject(""String_Node_Str"",kCore));
  this.fb_profiles.update(mongo_query_kcore,updateCmd);
  graphModel.setVisibleView(view);
  ForceAtlas2 fa2Layout=new ForceAtlas2(new ForceAtlas2Builder());
  fa2Layout.setGraphModel(graphModel);
  fa2Layout.resetPropertiesValues();
  fa2Layout.setEdgeWeightInfluence(1.0);
  fa2Layout.setGravity(1.0);
  fa2Layout.setScalingRatio(2.0);
  fa2Layout.setBarnesHutTheta(1.2);
  fa2Layout.setJitterTolerance(0.1);
  fa2Layout.initAlgo();
  int cnt=0;
  for (int i=0; i < 250 && fa2Layout.canAlgo(); i++) {
    fa2Layout.goAlgo();
    cnt++;
  }
  System.out.println(""String_Node_Str"" + cnt + ""String_Node_Str"");
  fa2Layout.endAlgo();
  GraphDistance distance=new GraphDistance();
  distance.setDirected(false);
  distance.execute(graphModel,attributeModel);
  System.out.println(""String_Node_Str"");
  AttributeColumn centralityColumn=attributeModel.getNodeTable().getColumn(GraphDistance.BETWEENNESS);
  double maxVal=0;
  double secondMax=0;
  double thirdMax=0;
  double extremVal=0;
  Node nMax=null;
  Node nSecond=null;
  int numNode=graphModel.getGraph().getNodeCount();
  for (  Node n : graphModel.getGraph().getNodes()) {
    double val=Double.valueOf(n.getNodeData().getAttributes().getValue(GraphDistance.BETWEENNESS).toString());
    if (val > maxVal) {
      thirdMax=secondMax;
      secondMax=maxVal;
      nSecond=nMax;
      maxVal=val;
      nMax=n;
    }
 else     if (val > secondMax) {
      thirdMax=secondMax;
      secondMax=val;
      nSecond=n;
    }
 else     if (val > thirdMax) {
      thirdMax=val;
    }
  }
  System.out.println(numNode + ""String_Node_Str"" + maxVal+ ""String_Node_Str""+ secondMax+ ""String_Node_Str""+ thirdMax);
  nMax.getNodeData().getAttributes().setValue(GraphDistance.BETWEENNESS,thirdMax * 1.5);
  nSecond.getNodeData().getAttributes().setValue(GraphDistance.BETWEENNESS,thirdMax * 1.2);
  Ranking centralityRanking=rankingController.getModel().getRanking(Ranking.NODE_ELEMENT,centralityColumn.getId());
  AbstractSizeTransformer sizeTransformer=(AbstractSizeTransformer)rankingController.getModel().getTransformer(Ranking.NODE_ELEMENT,Transformer.RENDERABLE_SIZE);
  sizeTransformer.setMinSize(6);
  sizeTransformer.setMaxSize(30);
  rankingController.transform(centralityRanking,sizeTransformer);
  System.out.println(""String_Node_Str"");
  model.getProperties().putValue(PreviewProperty.SHOW_NODE_LABELS,Boolean.TRUE);
  model.getProperties().putValue(PreviewProperty.EDGE_COLOR,new EdgeColor(Color.GRAY));
  model.getProperties().putValue(PreviewProperty.EDGE_THICKNESS,new Float(0.1f));
  model.getProperties().putValue(PreviewProperty.NODE_LABEL_FONT,model.getProperties().getFontValue(PreviewProperty.NODE_LABEL_FONT).deriveFont(8));
  PartitionController partitionController=Lookup.getDefault().lookup(PartitionController.class);
  Modularity modularity=new Modularity();
  modularity.execute(graphModel,attributeModel);
  AttributeColumn modColumn=attributeModel.getNodeTable().getColumn(Modularity.MODULARITY_CLASS);
  Partition p2=partitionController.buildPartition(modColumn,undirectedGraph);
  System.out.println(p2.getPartsCount() + ""String_Node_Str"");
  NodeColorTransformer nodeColorTransformer2=new NodeColorTransformer();
  int i=0;
  Map<Object,Color> color_map=nodeColorTransformer2.getMap();
  ArrayList<BasicDBObject> colors_for_mongo=new ArrayList<BasicDBObject>();
  for (  Part p : p2.getParts()) {
    Color color=Palette.colors[i];
    color_map.put(p.getValue(),color);
    BasicDBObject color_hash=new BasicDBObject();
    color_hash.put(""String_Node_Str"",color.getRed());
    color_hash.put(""String_Node_Str"",color.getGreen());
    color_hash.put(""String_Node_Str"",color.getBlue());
    colors_for_mongo.add(color_hash);
    ++i;
  }
  BasicDBObject mongo_query=new BasicDBObject(""String_Node_Str"",this.fb_profile.get(""String_Node_Str""));
  BasicDBObject updateCmd=new BasicDBObject(""String_Node_Str"",new BasicDBObject(""String_Node_Str"",colors_for_mongo));
  this.fb_profiles.update(mongo_query,updateCmd);
  partitionController.transform(p2,nodeColorTransformer2);
}","private void genGraph(){
  AttributeModel attributeModel=Lookup.getDefault().lookup(AttributeController.class).getModel();
  PreviewModel model=Lookup.getDefault().lookup(PreviewController.class).getModel();
  FilterController filterController=Lookup.getDefault().lookup(FilterController.class);
  RankingController rankingController=Lookup.getDefault().lookup(RankingController.class);
  System.out.println(""String_Node_Str"" + undirectedGraph.getNodeCount());
  System.out.println(""String_Node_Str"" + undirectedGraph.getEdgeCount());
  Degree degree=new Degree();
  degree.execute(graphModel,attributeModel);
  System.out.println(""String_Node_Str"" + degree.getAverageDegree());
  AttributeColumn degreeColumn=attributeModel.getNodeTable().getColumn(""String_Node_Str"");
  int[] degreeArray;
  degreeArray=new int[undirectedGraph.getNodeCount()];
  int i1=0;
  for (  Node n : graphModel.getGraph().getNodes()) {
    int val=Integer.valueOf(n.getNodeData().getAttributes().getValue(Ranking.DEGREE_RANKING).toString());
    degreeArray[i1++]=val;
  }
  reportStatistics(degreeArray);
  System.out.println(""String_Node_Str"");
  DegreeRangeFilter degreeFilter=new DegreeRangeFilter();
  degreeFilter.init(undirectedGraph);
  degreeFilter.setRange(new Range(4,Integer.MAX_VALUE));
  Query query=filterController.createQuery(degreeFilter);
  GraphView view=filterController.filter(query);
  graphModel.setVisibleView(view);
  UndirectedGraph graphVisible=graphModel.getUndirectedGraphVisible();
  System.out.println(""String_Node_Str"" + graphVisible.getNodeCount());
  System.out.println(""String_Node_Str"" + graphVisible.getEdgeCount() + ""String_Node_Str"");
  GraphView tview=graphModel.newView();
  UndirectedGraph tgraph=graphModel.getUndirectedGraph(tview);
  KCoreBuilder.KCoreFilter kCoreFilter=new KCoreBuilder.KCoreFilter();
  int k=1;
  while (tgraph.getNodeCount() > 0) {
    kCoreFilter.setK(k);
    kCoreFilter.filter(tgraph);
    System.out.println(""String_Node_Str"" + k + ""String_Node_Str""+ tgraph.getNodeCount());
    System.out.println(""String_Node_Str"" + tgraph.getEdgeCount());
    k++;
  }
  int kCore=k - 1;
  BasicDBObject mongo_query_kcore=new BasicDBObject(""String_Node_Str"",this.fb_profile.get(""String_Node_Str""));
  BasicDBObject updateCmd=new BasicDBObject(""String_Node_Str"",new BasicDBObject(""String_Node_Str"",kCore));
  this.fb_profiles.update(mongo_query_kcore,updateCmd);
  graphModel.setVisibleView(view);
  ForceAtlas2 fa2Layout=new ForceAtlas2(new ForceAtlas2Builder());
  fa2Layout.setGraphModel(graphModel);
  fa2Layout.resetPropertiesValues();
  fa2Layout.setEdgeWeightInfluence(1.0);
  fa2Layout.setGravity(1.0);
  fa2Layout.setScalingRatio(2.0);
  fa2Layout.setBarnesHutTheta(1.2);
  fa2Layout.setJitterTolerance(0.1);
  fa2Layout.initAlgo();
  int cnt=0;
  for (int i=0; i < 250 && fa2Layout.canAlgo(); i++) {
    fa2Layout.goAlgo();
    cnt++;
  }
  System.out.println(""String_Node_Str"" + cnt + ""String_Node_Str"");
  fa2Layout.endAlgo();
  GraphDistance distance=new GraphDistance();
  distance.setDirected(false);
  distance.execute(graphModel,attributeModel);
  System.out.println(""String_Node_Str"");
  AttributeColumn centralityColumn=attributeModel.getNodeTable().getColumn(GraphDistance.BETWEENNESS);
  double maxVal=0;
  double secondMax=0;
  double thirdMax=0;
  double extremVal=0;
  Node nMax=null;
  Node nSecond=null;
  int numNode=graphModel.getGraph().getNodeCount();
  for (  Node n : graphModel.getGraph().getNodes()) {
    double val=Double.valueOf(n.getNodeData().getAttributes().getValue(GraphDistance.BETWEENNESS).toString());
    if (val > maxVal) {
      thirdMax=secondMax;
      secondMax=maxVal;
      nSecond=nMax;
      maxVal=val;
      nMax=n;
    }
 else     if (val > secondMax) {
      thirdMax=secondMax;
      secondMax=val;
      nSecond=n;
    }
 else     if (val > thirdMax) {
      thirdMax=val;
    }
  }
  System.out.println(numNode + ""String_Node_Str"" + maxVal+ ""String_Node_Str""+ secondMax+ ""String_Node_Str""+ thirdMax);
  nMax.getNodeData().getAttributes().setValue(GraphDistance.BETWEENNESS,thirdMax * 1.5);
  nSecond.getNodeData().getAttributes().setValue(GraphDistance.BETWEENNESS,thirdMax * 1.2);
  Ranking centralityRanking=rankingController.getModel().getRanking(Ranking.NODE_ELEMENT,centralityColumn.getId());
  AbstractSizeTransformer sizeTransformer=(AbstractSizeTransformer)rankingController.getModel().getTransformer(Ranking.NODE_ELEMENT,Transformer.RENDERABLE_SIZE);
  sizeTransformer.setMinSize(6);
  sizeTransformer.setMaxSize(30);
  rankingController.transform(centralityRanking,sizeTransformer);
  System.out.println(""String_Node_Str"");
  model.getProperties().putValue(PreviewProperty.SHOW_NODE_LABELS,Boolean.TRUE);
  model.getProperties().putValue(PreviewProperty.EDGE_COLOR,new EdgeColor(Color.GRAY));
  model.getProperties().putValue(PreviewProperty.EDGE_THICKNESS,new Float(0.1f));
  model.getProperties().putValue(PreviewProperty.NODE_LABEL_FONT,model.getProperties().getFontValue(PreviewProperty.NODE_LABEL_FONT).deriveFont(8));
  PartitionController partitionController=Lookup.getDefault().lookup(PartitionController.class);
  Modularity modularity=new Modularity();
  modularity.execute(graphModel,attributeModel);
  AttributeColumn modColumn=attributeModel.getNodeTable().getColumn(Modularity.MODULARITY_CLASS);
  Partition p2=partitionController.buildPartition(modColumn,undirectedGraph);
  System.out.println(p2.getPartsCount() + ""String_Node_Str"");
  NodeColorTransformer nodeColorTransformer2=new NodeColorTransformer();
  int i=0;
  Map<Object,Color> color_map=nodeColorTransformer2.getMap();
  ArrayList<BasicDBObject> colors_for_mongo=new ArrayList<BasicDBObject>();
  for (  Part p : p2.getParts()) {
    Color color=Palette.colors[i];
    color_map.put(p.getValue(),color);
    BasicDBObject color_hash=new BasicDBObject();
    color_hash.put(""String_Node_Str"",color.getRed());
    color_hash.put(""String_Node_Str"",color.getGreen());
    color_hash.put(""String_Node_Str"",color.getBlue());
    colors_for_mongo.add(color_hash);
    ++i;
  }
  BasicDBObject mongo_query=new BasicDBObject(""String_Node_Str"",this.fb_profile.get(""String_Node_Str""));
  updateCmd=new BasicDBObject(""String_Node_Str"",new BasicDBObject(""String_Node_Str"",colors_for_mongo));
  this.fb_profiles.update(mongo_query,updateCmd);
  partitionController.transform(p2,nodeColorTransformer2);
}",0.9937264742785444
99087,"public void addQuestionResult(QuestionResult result){
  results.lastElement().addQuestionResult(result);
}","public void addQuestionResult(QuestionResult result){
  results.lastElement().setQuestionResult(result);
}",0.9716981132075472
99088,"@Override public void OnWordChange(int wordIndex,String word,long eventTime,long timeSinceLastChange,int relativePosition,int pxWidth){
  if (wordIndex == -1 && result.wordEvents.size() > 0 && result.wordEvents.lastElement().wordIndex == -1) {
    return;
  }
  WordEvent e=new WordEvent();
  e.wordIndex=wordIndex;
  if (result.wordEvents.size() > 0) {
    e.wordIndexDelta=wordIndex - result.wordEvents.lastElement().wordIndex;
    result.wordEvents.lastElement().timeSpent=timeSinceLastChange;
  }
  e.word=word;
  e.pxWidth=pxWidth;
  e.time=eventTime;
  e.tDelta=timeSinceLastChange;
  e.relativePosition=relativePosition;
  result.wordEvents.add(e);
}","@Override public void OnWordChange(int wordIndex,String word,long eventTime,long timeSinceLastChange,int relativePosition,int pxWidth){
  if (wordIndex == -1 && result.getNumWordEvents() > 0 && result.getLastWordEvent().wordIndex == -1) {
    return;
  }
  WordEvent e=new WordEvent();
  e.wordIndex=wordIndex;
  if (result.getNumWordEvents() > 0) {
    e.wordIndexDelta=wordIndex - result.getLastWordEvent().wordIndex;
    result.getLastWordEvent().timeSpent=timeSinceLastChange;
  }
  e.word=word;
  e.pxWidth=pxWidth;
  e.time=eventTime;
  e.tDelta=timeSinceLastChange;
  e.relativePosition=relativePosition;
  result.addWordEvent(e);
}",0.8148148148148148
99089,"@Override public void OnCharChange(int charIndex,String character,long eventTime,long timeSinceLastChange,int relativePosition){
  if (charIndex == -1 && result.charEvents.size() > 0 && result.charEvents.lastElement().charIndex == -1) {
    return;
  }
  CharEvent e=new CharEvent();
  e.charIndex=charIndex;
  if (result.charEvents.size() > 0) {
    e.charIndexDelta=charIndex - result.charEvents.lastElement().charIndex;
    result.charEvents.lastElement().timeSpent=timeSinceLastChange;
  }
  e.character=character;
  e.time=eventTime;
  e.tDelta=timeSinceLastChange;
  e.relativePosition=relativePosition;
  result.charEvents.add(e);
}","@Override public void OnCharChange(int charIndex,String character,long eventTime,long timeSinceLastChange,int relativePosition){
  if (charIndex == -1 && result.getNumCharEvents() > 0 && result.getLastCharEvent().charIndex == -1) {
    return;
  }
  CharEvent e=new CharEvent();
  e.charIndex=charIndex;
  if (result.getNumCharEvents() > 0) {
    e.charIndexDelta=charIndex - result.getLastCharEvent().charIndex;
    result.getLastCharEvent().timeSpent=timeSinceLastChange;
  }
  e.character=character;
  e.time=eventTime;
  e.tDelta=timeSinceLastChange;
  e.relativePosition=relativePosition;
  result.addCharEvent(e);
}",0.8095238095238095
99090,"@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  sentenceView.giveFingerPosition((int)(progress + seekBar.getX()));
  SeekEvent e=new SeekEvent();
  e.time=System.currentTimeMillis();
  if (result.seekEvents.size() > 0) {
    e.tDelta=e.time - result.seekEvents.lastElement().time;
  }
 else {
    e.tDelta=e.time - baseSeekTime;
  }
  int fingerXPos=progress - seekBarMargin;
  if (fingerXPos < 0) {
    e.relativePosition=SeekEvent.ANTE_SENTENTIUM;
  }
 else   if (fingerXPos >= seekBarMax - 2 * seekBarMargin) {
    e.relativePosition=SeekEvent.POST_SENTENTIUM;
  }
 else {
    e.relativePosition=SeekEvent.IN_SENTENTIUM;
  }
  e.x=fingerXPos;
  e.word=sentenceView.getWord();
  e.character=sentenceView.getChar();
  e.wordIndex=sentenceView.getWordIndex();
  e.charIndex=sentenceView.getCharIndex();
  if (result.seekEvents.size() > 0) {
    e.xDelta=e.x - result.seekEvents.lastElement().x;
    e.wordIndexDelta=e.wordIndex - result.seekEvents.lastElement().wordIndex;
    e.charIndexDelta=e.charIndex - result.seekEvents.lastElement().charIndex;
  }
  result.seekEvents.add(e);
}","@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  sentenceView.giveFingerPosition((int)(progress + seekBar.getX()));
  SeekEvent e=new SeekEvent();
  e.time=System.currentTimeMillis();
  if (result.getNumCharEvents() > 0) {
    e.tDelta=e.time - result.getLastSeekEvent().time;
  }
 else {
    e.tDelta=e.time - baseSeekTime;
  }
  int fingerXPos=progress - seekBarMargin;
  if (fingerXPos < 0) {
    e.relativePosition=SeekEvent.ANTE_SENTENTIUM;
  }
 else   if (fingerXPos >= seekBarMax - 2 * seekBarMargin) {
    e.relativePosition=SeekEvent.POST_SENTENTIUM;
  }
 else {
    e.relativePosition=SeekEvent.IN_SENTENTIUM;
  }
  e.x=fingerXPos;
  e.word=sentenceView.getWord();
  e.character=sentenceView.getChar();
  e.wordIndex=sentenceView.getWordIndex();
  e.charIndex=sentenceView.getCharIndex();
  if (result.getNumCharEvents() > 0) {
    e.xDelta=e.x - result.getLastSeekEvent().x;
    e.wordIndexDelta=e.wordIndex - result.getLastSeekEvent().wordIndex;
    e.charIndexDelta=e.charIndex - result.getLastSeekEvent().charIndex;
  }
  result.addSeekEvent(e);
}",0.9030520646319568
99091,"@Override public void onStopTrackingTouch(SeekBar seekBar){
  if (result.seekEvents.lastElement().x == seekBarMax - seekBarMargin) {
    main.addSentenceResult(result);
    if (!showQuestion()) {
      nextSentence();
    }
  }
}","@Override public void onStopTrackingTouch(SeekBar seekBar){
  if (result.getLastSeekEvent().x == seekBarMax - seekBarMargin) {
    main.addSentenceResult(result);
    if (!showQuestion()) {
      nextSentence();
    }
  }
}",0.9513274336283186
99092,"public void draw(Canvas canvas){
  if (this.isPlaying) {
    long elapsed=(System.currentTimeMillis() - last_tick);
    if (elapsed >= DURATION) {
      if (frame <= fcount) {
        last_tick=System.currentTimeMillis();
        frame++;
      }
 else {
        this.isPlaying=false;
      }
    }
    drawFrame(canvas);
    if (frame <= fcount)     view.repaint();
  }
}","public void draw(Canvas canvas){
  if (isPlaying) {
    long elapsed=(System.currentTimeMillis() - last_tick);
    if (elapsed >= DURATION) {
      if (frame <= fcount) {
        last_tick=System.currentTimeMillis();
        frame++;
      }
 else {
        isPlaying=false;
      }
    }
    drawFrame(canvas);
    if (frame <= fcount)     view.repaint();
  }
}",0.9863760217983653
99093,"private void changePicture(String pose,int frame_count){
  this.pose=pose;
  this.fcount=frame_count;
  this.frame=1;
  this.last_tick=0;
  this.isPlaying=true;
  view.repaint();
}","private void changePicture(String pose,int frame_count){
  this.pose=pose;
  this.fcount=frame_count;
  this.frame=1;
  this.last_tick=0;
  isPlaying=true;
  view.repaint();
}",0.9859154929577464
99094,"@Override public void onBackPressed(){
  if (view.running)   view.running=false;
  view.program=null;
  view.repaint();
  return;
}","@Override public void onBackPressed(){
  if (view.running)   view.running=false;
  Roberto.isPlaying=false;
  view.program=null;
  view.repaint();
  return;
}",0.9065743944636678
99095,"public void run(){
  long temp, clock=System.currentTimeMillis();
  boolean stopped=false;
  while (!stopped) {
    stopped=true;
    for (    Process p : processes) {
      if (p.isRunning()) {
        if (p.run()) {
          stopped=false;
        }
 else {
          notifyProcessStopped(p);
        }
      }
    }
    if (stopped)     break;
    try {
      Thread.sleep(200);
    }
 catch (    InterruptedException ix) {
      ;
    }
    temp=clock;
    clock=System.currentTimeMillis();
    updateTimers((int)(clock - temp));
  }
}","public void run(){
  long temp, clock=System.currentTimeMillis();
  boolean stopped=false;
  this.running=true;
  while (!stopped) {
    stopped=true;
    for (    Process p : processes) {
      if (p.isRunning()) {
        if (p.run()) {
          stopped=false;
        }
 else {
          notifyProcessStopped(p);
        }
      }
    }
    if (stopped)     break;
    try {
      Thread.sleep(200);
    }
 catch (    InterruptedException ix) {
      ;
    }
    temp=clock;
    clock=System.currentTimeMillis();
    updateTimers((int)(clock - temp));
  }
  this.running=false;
}",0.9599287622439892
99096,"/** 
 * Stop the interpreter thread
 */
public void stop(){
  for (  Process p : processes) {
    if (p.isRunning()) {
      p.stop();
    }
  }
  if (robot != null) {
    robot.allStop();
  }
  sleep(100);
}","/** 
 * Stop the interpreter thread
 */
public void stop(){
  for (  Process p : processes) {
    if (p.isRunning()) {
      p.stop();
    }
  }
  if (robot != null) {
    robot.allStop();
  }
  while (this.running) {
    sleep(50);
  }
}",0.8923766816143498
99097,"/** 
 * @see HttpServlet#doPost(HttpServletRequest request,HttpServletResponse response)
 */
protected void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  String firstName=request.getParameter(""String_Node_Str"");
  String lastName=request.getParameter(""String_Node_Str"");
  String email=request.getParameter(""String_Node_Str"");
  String address1=request.getParameter(""String_Node_Str"");
  String address2=request.getParameter(""String_Node_Str"");
  String zipcode=request.getParameter(""String_Node_Str"");
  String city=request.getParameter(""String_Node_Str"");
  String state=request.getParameter(""String_Node_Str"");
  Customer customer=new Customer(firstName,lastName,email,address1,address2,zipcode,city,state);
  request.setAttribute(""String_Node_Str"",customer);
  String url=""String_Node_Str"";
  RequestDispatcher dispatcher=getServletContext().getRequestDispatcher(url);
  dispatcher.forward(request,response);
}","/** 
 * @see HttpServlet#doPost(HttpServletRequest request,HttpServletResponse response)
 */
protected void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  String firstName=request.getParameter(""String_Node_Str"");
  String lastName=request.getParameter(""String_Node_Str"");
  String email=request.getParameter(""String_Node_Str"");
  String address1=request.getParameter(""String_Node_Str"");
  String address2=request.getParameter(""String_Node_Str"");
  String zipcode=request.getParameter(""String_Node_Str"");
  String city=request.getParameter(""String_Node_Str"");
  String state=request.getParameter(""String_Node_Str"");
  String password=request.getParameter(""String_Node_Str"");
  Customer customer=new Customer(firstName,lastName,email,password,address1,address2,zipcode,city,state);
  request.setAttribute(""String_Node_Str"",customer);
  String url=""String_Node_Str"";
  RequestDispatcher dispatcher=getServletContext().getRequestDispatcher(url);
  dispatcher.forward(request,response);
}",0.9662363455809336
99098,"@github.com ResultSet validate(String email,String password){
  ResultSet res=null;
  try {
    String query=""String_Node_Str"" + email + ""String_Node_Str""+ password+ ""String_Node_Str"";
    stmnt=CONN.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);
    res=stmnt.executeQuery(query);
  }
 catch (  SQLException ex) {
    handleSqlExceptions(ex);
  }
  return res;
}","public ResultSet validate(String email,String password){
  ResultSet res=null;
  try {
    String query=""String_Node_Str"" + email + ""String_Node_Str""+ password+ ""String_Node_Str"";
    stmnt=CONN.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);
    res=stmnt.executeQuery(query);
  }
 catch (  SQLException ex) {
    handleSqlExceptions(ex);
  }
  return res;
}",0.98343949044586
99099,"public void addQuantity(int quantity){
  quantity+=Math.abs(quantity);
}","public void addQuantity(int quantity){
  this.quantity+=Math.abs(quantity);
}",0.9664429530201344
99100,"@Override protected void onDestroy(){
  super.onDestroy();
  if (currentScene != null) {
    currentScene.onDestroy();
  }
  if (mainGame == this) {
    mainGame=null;
    this.gameObjectManager.destroy();
    this.touchEventManager.removeAll();
  }
}","@Override protected void onDestroy(){
  super.onDestroy();
  if (currentScene != null) {
    currentScene.onDestroy();
  }
  if (mainGame == this) {
    mainGame=null;
    isExited=false;
    this.gameObjectManager.destroy();
    this.touchEventManager.removeAll();
  }
}",0.9616858237547892
99101,"@Override protected void copyTo(GameObject gameObject){
  super.copyTo(gameObject);
  Node node=(Node)gameObject;
  if (hasAnimation) {
    node.animation=this.animation.clone();
  }
  node.hasAnimation=this.hasAnimation;
  node.childCount=this.childCount;
  node.children=new Node[this.childCount];
  for (int i=0; i < childCount; i++) {
    node.children[i]=this.children[i].instantiate();
  }
}","@Override protected void copyTo(GameObject gameObject){
  super.copyTo(gameObject);
  Node node=(Node)gameObject;
  node.hasAnimation=this.hasAnimation;
  if (hasAnimation) {
    node.animation=this.animation.clone();
  }
  node.childCount=this.childCount;
  node.children=new Node[this.childCount];
  for (int i=0; i < childCount; i++) {
    node.children[i]=this.children[i].instantiate();
  }
}",0.9017632241813602
99102,"public static AnimationPlayer getInstance(){
  return instance;
}","public static AnimationPlayer getInstance(){
  if (instance == null) {
    instance=new AnimationPlayer();
  }
  return instance;
}",0.6632653061224489
99103,"@Override protected final void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  instance=this;
  this.gameObjectManager=GameObjectManager.getInstance();
  this.animationPlayer=AnimationPlayer.getInstance();
  this.touchEventManager=TouchEventManager.getInstance();
  this.gameTime=GameTime.getInstance();
  if (mainGame == null) {
    Scene.setMainCamera(new Camera(""String_Node_Str""));
    Screen.w=getWindowManager().getDefaultDisplay().getWidth();
    Screen.h=getWindowManager().getDefaultDisplay().getHeight();
    this.gameObjectManager.setContext(this);
    this.gameObjectManager.initialize();
    mainGame=this;
  }
  this.onInitialize(savedInstanceState);
  this.glSurfaceView=new GLSurfaceView(this);
  this.glSurfaceView.setEGLContextClientVersion(2);
  this.glSurfaceView.setRenderer(new GLRenderer());
  this.setContentView(glSurfaceView);
}","@Override protected final void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  instance=this;
  this.gameObjectManager=GameObjectManager.getInstance();
  this.animationPlayer=AnimationPlayer.getInstance();
  this.touchEventManager=TouchEventManager.getInstance();
  this.gameTime=GameTime.getInstance();
  if (mainGame == null) {
    Scene.setMainCamera(new Camera(""String_Node_Str""));
    Screen.w=getWindowManager().getDefaultDisplay().getWidth();
    Screen.h=getWindowManager().getDefaultDisplay().getHeight();
    this.gameObjectManager.setContext(this);
    this.gameObjectManager.initialize();
    mainGame=this;
  }
  System.gc();
  this.onInitialize(savedInstanceState);
  this.glSurfaceView=new GLSurfaceView(this);
  this.glSurfaceView.setEGLContextClientVersion(2);
  this.glSurfaceView.setRenderer(new GLRenderer());
  this.setContentView(glSurfaceView);
}",0.991577765300393
99104,"@Override protected void onDestroy(){
  super.onDestroy();
  if (currentScene != null) {
    currentScene.onDestroy();
  }
  if (mainGame == this) {
    mainGame=null;
    isExited=false;
    this.gameObjectManager.destroy();
    this.touchEventManager.removeAll();
  }
}","@Override protected void onDestroy(){
  super.onDestroy();
  if (currentScene != null) {
    currentScene.onDestroy();
  }
  if (mainGame == this) {
    mainGame=null;
    isExited=false;
    this.gameObjectManager.destroy();
    this.touchEventManager.removeAll();
    this.touchEventManager.destroy();
    this.animationPlayer.destroy();
    this.animationPlayer=null;
    this.gameObjectManager=null;
    this.touchEventManager=null;
  }
  instance=null;
  System.gc();
}",0.72751677852349
99105,"public void destroy(){
  Log.e(""String_Node_Str"",""String_Node_Str"");
  assetFileNames.clear();
  texturesList.clear();
  scenePrefabs.clear();
  terrains.clear();
  isInitialized=false;
}","public void destroy(){
  Log.e(""String_Node_Str"",""String_Node_Str"");
  assetFileNames.clear();
  for (  Texture2D texture2d : texturesList.values()) {
    texture2d.destroy();
  }
  texturesList.clear();
  terrains.clear();
  getNormalQueue.clear();
  for (  ScenePrefab scenePrefab : scenePrefabs.values()) {
    scenePrefab.destroy();
  }
  scenePrefabs.clear();
  bitmapList.clear();
  isInitialized=false;
  instance=null;
}",0.4975609756097561
99106,"static GameObjectManager getInstance(){
  return instance;
}","static GameObjectManager getInstance(){
  if (instance == null) {
    instance=new GameObjectManager();
  }
  return instance;
}",0.6382978723404256
99107,"public static TouchEventManager getInstance(){
  return instance;
}","public static TouchEventManager getInstance(){
  if (instance == null) {
    instance=new TouchEventManager();
  }
  return instance;
}",0.6633663366336634
99108,"public void onDestroy(){
}","public void onDestroy(){
  sprites.clear();
  models.clear();
  terrains.clear();
  lights.clear();
  sprites=null;
  models=null;
  terrains=null;
  lights=null;
}",0.2736842105263158
99109,"public static FbxScene importScene(InputStream inputStream){
  String[] list=null;
  try {
    InputStreamReader isr=new InputStreamReader(inputStream);
    char[] buffer=new char[inputStream.available()];
    isr.read(buffer);
    list=new String(buffer).split(""String_Node_Str"");
  }
 catch (  IOException e) {
    Log.e(""String_Node_Str"",e.getMessage());
  }
  String line=""String_Node_Str"";
  index=0;
  int model_count=0;
  int geometry_count=0;
  int node_attribute_count=0;
  int anim_curve_count=0;
  int anim_curve_node_count=0;
  int deformer_count=0;
  int material_count=0;
  int texture_count=0;
  int video_count=0;
  int startFrame=0, endFrame=0;
  int keyframeLength=0;
  FbxTimeSpan timeSpan=new FbxTimeSpan();
  FbxTimeMode timeMode=null;
  int upAxis=1;
  int upAxisSign=1;
  int frontAxis=1;
  int frontAxisSign=1;
  while (!line.startsWith(""String_Node_Str"")) {
    line=list[index++].trim();
    if (line.startsWith(""String_Node_Str"")) {
      timeMode=new FbxTimeMode(getLastCommaAsInt(line));
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      timeSpan.setStart(getLastCommaAsLong(line));
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      timeSpan.setStop(getLastCommaAsLong(line));
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      upAxis=getLastCommaAsInt(line);
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      upAxisSign=getLastCommaAsInt(line);
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      frontAxis=getLastCommaAsInt(line);
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      frontAxisSign=getLastCommaAsInt(line);
    }
  }
  while (!line.startsWith(""String_Node_Str"")) {
    line=list[index++].trim();
    if (line.startsWith(""String_Node_Str"")) {
      line=line.split(""String_Node_Str"")[1];
      String attribute=list[index++];
      int count=Convert.toInt(attribute.split(""String_Node_Str"")[1].trim());
      if (line.equals(""String_Node_Str"")) {
        model_count=count;
      }
 else       if (line.equals(""String_Node_Str"")) {
        geometry_count=count;
      }
 else       if (line.equals(""String_Node_Str"")) {
        node_attribute_count=count;
      }
 else       if (line.equals(""String_Node_Str"")) {
        anim_curve_count=count;
      }
 else       if (line.equals(""String_Node_Str"")) {
        anim_curve_node_count=count;
      }
 else       if (line.equals(""String_Node_Str"")) {
        deformer_count=count;
      }
 else       if (line.equals(""String_Node_Str"")) {
        material_count=count;
      }
 else       if (line.equals(""String_Node_Str"")) {
        texture_count=count;
      }
 else       if (line.equals(""String_Node_Str"")) {
        video_count=count;
      }
    }
  }
  HashMap<Long,FbxObject> maps=new HashMap<Long,FbxObject>();
  int current_geometry_count=0;
  int current_node_attribute_count=0;
  int current_node_count=0;
  int current_deformer_count=0;
  int current_anim_curve_node_count=0;
  int current_anim_curve_count=0;
  int current_material_count=0;
  int current_texture_count=0;
  int current_video_count=0;
  while (!line.startsWith(""String_Node_Str"")) {
    line=list[index++].trim();
    if (current_geometry_count < geometry_count) {
      if (line.startsWith(""String_Node_Str"")) {
        current_geometry_count+=1;
        Object[] geoItems=getID_NameAndType(line.substring(10));
        long geometry_id=(Long)geoItems[0];
        FbxMesh mesh=new FbxMesh(geometry_id);
        while (true) {
          line=list[index++].trim();
          if (line.startsWith(""String_Node_Str"")) {
            int count=Convert.toInt(line.substring(11).split(""String_Node_Str"")[0]);
            mesh.setVertices(readFloatAttribute(list,count));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            int count=Convert.toInt(line.substring(21).split(""String_Node_Str"")[0]);
            mesh.setIndices(readIndicesAttribute(list,count));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            int count=Convert.toInt(line.substring(10).split(""String_Node_Str"")[0]);
            mesh.setNormals(readFloatAttribute(list,count));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            int count=Convert.toInt(line.substring(5).split(""String_Node_Str"")[0]);
            mesh.setUV(readFloatAttribute(list,count));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            int count=Convert.toInt(line.substring(10).split(""String_Node_Str"")[0]);
            mesh.setUVIndices(readUVIndicesAttribute(list,count));
            break;
          }
        }
        maps.put(geometry_id,mesh);
      }
    }
    if (current_node_attribute_count < node_attribute_count) {
      if (line.startsWith(""String_Node_Str"")) {
        current_node_attribute_count+=1;
        Object[] items=getID_NameAndType(line.substring(15));
        long node_attribute_id=(Long)items[0];
        int attributeType;
        FbxNodeAttribute nodeAttribute=null;
        if (items[2].equals(""String_Node_Str"")) {
          attributeType=FbxNodeAttribute.Null;
          nodeAttribute=new FbxNodeAttribute(node_attribute_id,attributeType);
        }
 else         if (items[2].equals(""String_Node_Str"")) {
          attributeType=FbxNodeAttribute.Mesh;
          nodeAttribute=new FbxNodeAttribute(node_attribute_id,attributeType);
        }
 else {
          int skeletonType=0;
          if (line.contains(""String_Node_Str"")) {
            skeletonType=FbxSkeleton.LimbNode;
          }
 else           if (line.contains(""String_Node_Str"") || line.contains(""String_Node_Str"")) {
            skeletonType=FbxSkeleton.Root;
          }
          nodeAttribute=new FbxSkeleton(node_attribute_id,skeletonType);
        }
        maps.put(node_attribute_id,nodeAttribute);
      }
    }
    if (current_node_count < model_count) {
      if (line.startsWith(""String_Node_Str"")) {
        current_node_count+=1;
        StringBuilder[] item=new StringBuilder[2];
        item[0]=new StringBuilder();
        item[1]=new StringBuilder();
        int inner_index=0;
        boolean begin=false;
        char temp=0;
        for (int i=0; i < line.length(); i++) {
          char c=line.charAt(i);
          if (temp == ':') {
            if (c == ' ') {
              begin=true;
              inner_index=0;
              continue;
            }
 else             if (c == ':') {
              begin=true;
              inner_index=1;
              continue;
            }
          }
          if (c == '""' || c == ',') {
            begin=false;
            if (inner_index == 1) {
              break;
            }
          }
          if (begin) {
            item[inner_index].append(c);
          }
          temp=c;
        }
        long nodeID=Convert.toLong(item[0].toString().trim());
        String nodeName=item[1].toString();
        FbxNode node=new FbxNode(nodeID);
        node.setName(nodeName);
        Vector3 lclT=new Vector3();
        Vector3 lclR=new Vector3();
        Vector3 lclS=new Vector3(1,1,1);
        while (!(line=list[index++]).contains(""String_Node_Str"")) {
          if (line.contains(""String_Node_Str"")) {
            lclT=new Vector3(splitCommaToFloatArray(line,3));
          }
 else           if (line.contains(""String_Node_Str"")) {
            lclR=new Vector3(splitCommaToFloatArray(line,3));
          }
 else           if (line.contains(""String_Node_Str"")) {
            lclS=new Vector3(splitCommaToFloatArray(line,3));
          }
        }
        node.setLclTranslation(lclT);
        node.setLclRotation(lclR);
        node.setLclScaling(lclS);
        maps.put(nodeID,node);
      }
    }
    if (current_deformer_count < deformer_count) {
      if (line.startsWith(""String_Node_Str"")) {
        current_deformer_count+=1;
        Object[] items=getID_NameAndType(line.substring(10));
        long deformer_id=(Long)items[0];
        if (items[2].equals(""String_Node_Str"")) {
          FbxSkin skin=new FbxSkin(deformer_id);
          maps.put(deformer_id,skin);
        }
 else {
          FbxCluster cluster=new FbxCluster(deformer_id);
          while (true) {
            line=list[index++].trim();
            if (line.startsWith(""String_Node_Str"")) {
              int count=Convert.toInt(line.substring(10).split(""String_Node_Str"")[0]);
              cluster.setIndices(readIntAttribute(list,count));
            }
 else             if (line.startsWith(""String_Node_Str"")) {
              int count=Convert.toInt(line.substring(10).split(""String_Node_Str"")[0]);
              cluster.setWeights(readFloatAttribute(list,count));
            }
 else             if (line.startsWith(""String_Node_Str"")) {
              int count=Convert.toInt(line.substring(12).split(""String_Node_Str"")[0]);
              cluster.setTransform(readFloatAttribute(list,count));
            }
 else             if (line.startsWith(""String_Node_Str"")) {
              int count=Convert.toInt(line.substring(16).split(""String_Node_Str"")[0]);
              cluster.setTransformLink(readFloatAttribute(list,count));
              break;
            }
          }
          maps.put(deformer_id,cluster);
        }
      }
    }
    if (current_material_count < material_count) {
      if (line.startsWith(""String_Node_Str"")) {
        current_material_count+=1;
        Object[] items=getID_NameAndType(line.substring(10));
        long material_id=(Long)items[0];
        String material_name=((String)items[1]).substring(10);
        FbxSurfacePhong material=new FbxSurfacePhong(material_id);
        material.setName(material_name);
        while (!line.contains(""String_Node_Str"")) {
          line=list[index++].trim();
          if (line.startsWith(""String_Node_Str"")) {
            material.getEmissive().set(new Vector3(splitCommaToFloatArray(line,3)));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.getAmbient().set(new Vector3(splitCommaToFloatArray(line,3)));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.getDiffuse().set(new Vector3(splitCommaToFloatArray(line,3)));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.getNormalMap().set(new Vector3(splitCommaToFloatArray(line,3)));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.getBump().set(new Vector3(splitCommaToFloatArray(line,3)));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.getTransparentColor().set(new Vector3(splitCommaToFloatArray(line,3)));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.getDisplacementColor().set(new Vector3(splitCommaToFloatArray(line,3)));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.getVectorDisplacementColor().set(new Vector3(splitCommaToFloatArray(line,3)));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.getSpecular().set(new Vector3(splitCommaToFloatArray(line,3)));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.getReflection().set(new Vector3(splitCommaToFloatArray(line,3)));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.setShinniness(splitCommaToFloat(line));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.setEmissiveFactor(splitCommaToFloat(line));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.setAmbientFactor(splitCommaToFloat(line));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.setDiffuseFactor(splitCommaToFloat(line));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.setBumpFactor(splitCommaToFloat(line));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.setTransparencyFactor(splitCommaToFloat(line));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.setDisplacementFactor(splitCommaToFloat(line));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.setVectorDisplacementFactor(splitCommaToFloat(line));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.setSpecularFactor(splitCommaToFloat(line));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.setReflectionFactor(splitCommaToFloat(line));
          }
        }
        maps.put(material_id,material);
      }
    }
    if (current_texture_count < texture_count) {
      if (line.startsWith(""String_Node_Str"")) {
        current_texture_count+=1;
        String[] t=line.substring(9).split(""String_Node_Str"");
        long texture_id=Convert.toLong(t[0]);
        String texture_name=t[1].split(""String_Node_Str"")[1].substring(9);
        FbxFileTexture texture=new FbxFileTexture(texture_id);
        texture.setName(texture_name);
        while (!line.contains(""String_Node_Str"")) {
          line=list[index++].trim();
        }
        line=list[index++].trim();
        while (!line.contains(""String_Node_Str"")) {
          line=list[index++].trim();
          String[] tmp=line.split(""String_Node_Str"");
          if (line.startsWith(""String_Node_Str"")) {
            String tt=tmp[tmp.length - 1];
            String fileName=tt;
            int indexOfSlash=tt.lastIndexOf(""String_Node_Str"");
            if (indexOfSlash > -1) {
              fileName=tt.substring(indexOfSlash + 1);
            }
            texture.setFileName(fileName);
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            String tt=tmp[tmp.length - 1];
            texture.setRelativeFileName(tt);
          }
 else           if (line.startsWith(""String_Node_Str"")) {
          }
        }
        maps.put(texture_id,texture);
      }
    }
    if (current_video_count < video_count) {
      if (line.startsWith(""String_Node_Str"")) {
        current_video_count+=1;
      }
    }
    if (current_anim_curve_node_count < anim_curve_node_count) {
      if (line.startsWith(""String_Node_Str"")) {
        current_anim_curve_node_count+=1;
        long anim_curve_node_id=Convert.toLong(line.substring(20).split(""String_Node_Str"")[0]);
        FbxAnimCurveNode animCurveNode=new FbxAnimCurveNode(anim_curve_node_id);
        maps.put(anim_curve_node_id,animCurveNode);
      }
    }
    if (current_anim_curve_count < anim_curve_count) {
      if (line.startsWith(""String_Node_Str"")) {
        current_anim_curve_count+=1;
        long anim_curve_id=Convert.toLong(line.substring(16).split(""String_Node_Str"")[0]);
        FbxAnimCurve animCurve=new FbxAnimCurve(anim_curve_id);
        long[] times=null;
        float[] values=null;
        while (true) {
          line=list[index++].trim();
          if (line.startsWith(""String_Node_Str"")) {
            int count=Convert.toInt(line.substring(10).split(""String_Node_Str"")[0]);
            times=readLongAttribute(list,count);
            if (times.length > 0) {
              int length=(int)((times[times.length - 1] - times[0]) / 1539538600L) + 1;
              if (length > keyframeLength) {
                keyframeLength=length;
                startFrame=(int)(times[0] / 1539538600L);
                endFrame=(int)(times[times.length - 1] / 1539538600L);
              }
            }
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            int count=Convert.toInt(line.substring(16).split(""String_Node_Str"")[0]);
            values=readFloatAttribute(list,count);
            break;
          }
        }
        animCurve.set(times,values);
        maps.put(anim_curve_id,animCurve);
      }
    }
  }
  ArrayList<FbxNode> rootnodes=new ArrayList<FbxNode>();
  while (!line.startsWith(""String_Node_Str"") && index < list.length) {
    line=list[index++].trim();
    if (line.endsWith(""String_Node_Str"")) {
      line=list[index++].trim();
      String attribute=line.substring(8);
      long root_node_id=Convert.toLong(attribute.substring(0,attribute.length() - 2));
      FbxNode node=(FbxNode)maps.get(root_node_id);
      rootnodes.add(node);
    }
 else     if (line.endsWith(""String_Node_Str"")) {
      line=list[index++].trim();
      String[] attribute=line.substring(8).split(""String_Node_Str"");
      long node_id=Convert.toLong(attribute[0]);
      long sub_deformer_id=Convert.toLong(attribute[1]);
      FbxNode associateModel=(FbxNode)maps.get(node_id);
      FbxCluster cluster=(FbxCluster)maps.get(sub_deformer_id);
      cluster.setAssociateModel(associateModel);
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      if (line.split(""String_Node_Str"")[1].startsWith(""String_Node_Str"")) {
        line=list[index++].trim();
        String[] attribute=line.substring(8).split(""String_Node_Str"");
        long child_node_id=Convert.toLong(attribute[0]);
        long parent_node_id=Convert.toLong(attribute[1]);
        FbxNode child_node=(FbxNode)maps.get(child_node_id);
        FbxNode parent_node=(FbxNode)maps.get(parent_node_id);
        parent_node.addChild(child_node);
        child_node.setParent(parent_node);
      }
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      line=list[index++].trim();
      String[] attribute=line.substring(8).split(""String_Node_Str"");
      long geometry_id=Convert.toLong(attribute[0]);
      long node_id=Convert.toLong(attribute[1]);
      FbxNode node=(FbxNode)maps.get(node_id);
      FbxGeometry geometry=(FbxGeometry)maps.get(geometry_id);
      node.setNodeAttribute(geometry);
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      String[] tmp0=line.split(""String_Node_Str"");
      if (tmp0[1].startsWith(""String_Node_Str"")) {
        line=list[index++].trim();
        String[] attribute=line.substring(8).split(""String_Node_Str"");
        long anim_curve_node_id=Convert.toLong(attribute[0]);
        long node_id=Convert.toLong(attribute[1]);
        FbxNode node=(FbxNode)maps.get(node_id);
        FbxAnimCurveNode animCurveNode=(FbxAnimCurveNode)maps.get(anim_curve_node_id);
        char type=tmp0[0].charAt(tmp0[0].length() - 1);
        if (type == 'T') {
          node.setLclTranslation(animCurveNode);
        }
 else         if (type == 'R') {
          node.setLclRotation(animCurveNode);
        }
 else {
          node.setLclScaling(animCurveNode);
        }
      }
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      line=list[index++].trim();
      String[] attribute=line.substring(8).split(""String_Node_Str"");
      long node_attribute_id=Convert.toLong(attribute[0]);
      long node_id=Convert.toLong(attribute[1]);
      FbxNode node=(FbxNode)maps.get(node_id);
      FbxNodeAttribute nodeAttribute=(FbxNodeAttribute)maps.get(node_attribute_id);
      node.setNodeAttribute(nodeAttribute);
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      line=list[index++].trim();
      String[] attribute=line.substring(8).split(""String_Node_Str"");
      long deformer_id=Convert.toLong(attribute[0]);
      long geometry_id=Convert.toLong(attribute[1]);
      FbxDeformer deformer=(FbxDeformer)maps.get(deformer_id);
      FbxGeometry geometry=(FbxGeometry)maps.get(geometry_id);
      geometry.addDeformer(deformer);
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      line=list[index++].trim();
      String[] first_line=line.substring(8).split(""String_Node_Str"");
      index+=2;
      line=list[index++].trim();
      String[] second_line=line.substring(8).split(""String_Node_Str"");
      index+=2;
      line=list[index++].trim();
      String[] third_line=line.substring(8).split(""String_Node_Str"");
      long anim_curve_node_id=Convert.toLong(first_line[1]);
      long x_id=Convert.toLong(first_line[0]);
      long y_id=Convert.toLong(second_line[0]);
      long z_id=Convert.toLong(third_line[0]);
      FbxAnimCurveNode animCurveNode=(FbxAnimCurveNode)maps.get(anim_curve_node_id);
      FbxAnimCurve animCurveX=(FbxAnimCurve)maps.get(x_id);
      FbxAnimCurve animCurveY=(FbxAnimCurve)maps.get(y_id);
      FbxAnimCurve animCurveZ=(FbxAnimCurve)maps.get(z_id);
      animCurveNode.set(animCurveX,animCurveY,animCurveZ);
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      line=list[index++].trim();
      String[] attribute=line.substring(8).split(""String_Node_Str"");
      long sub_deformer_id=Convert.toLong(attribute[0]);
      long deformer_id=Convert.toLong(attribute[1]);
      FbxCluster cluster=(FbxCluster)maps.get(sub_deformer_id);
      FbxSkin deformer=(FbxSkin)maps.get(deformer_id);
      deformer.addCluster(cluster);
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      line=list[index++].trim();
      String[] attribute=line.substring(8).split(""String_Node_Str"");
      long material_id=Convert.toLong(attribute[0]);
      long node_id=Convert.toLong(attribute[1]);
      FbxSurfaceMaterial material=(FbxSurfaceMaterial)maps.get(material_id);
      FbxNode node=(FbxNode)maps.get(node_id);
      node.setMaterial(material);
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      line=list[index++].trim();
      String[] attribute=line.substring(8).split(""String_Node_Str"");
      long texture_id=Convert.toLong(attribute[0]);
      long material_id=Convert.toLong(attribute[1]);
      String target=attribute[2].trim().split(""String_Node_Str"")[1];
      FbxTexture texture=(FbxTexture)maps.get(texture_id);
      FbxSurfacePhong material=(FbxSurfacePhong)maps.get(material_id);
      if (target.equalsIgnoreCase(""String_Node_Str"")) {
        material.setDiffuseTexture(texture);
      }
 else       if (target.equalsIgnoreCase(""String_Node_Str"")) {
      }
    }
  }
  FbxScene scene=new FbxScene();
  for (  FbxObject fbxObject : maps.values()) {
    if (fbxObject instanceof FbxGeometry) {
      scene.addGeometry((FbxGeometry)fbxObject);
    }
 else     if (fbxObject instanceof FbxNode) {
      scene.addNode((FbxNode)fbxObject);
    }
 else     if (fbxObject instanceof FbxSurfaceMaterial) {
      scene.addMaterial((FbxSurfaceMaterial)fbxObject);
    }
  }
  FbxNode sceneRootNode=scene.getRootnodes();
  for (  FbxNode rootnode : rootnodes) {
    sceneRootNode.addChild(rootnode);
  }
  FbxGlobalSetting globalSetting=scene.globalSetting();
  globalSetting.setTimeMode(timeMode);
  globalSetting.setTimeSpan(timeSpan);
  globalSetting.setFrontAxis(frontAxis);
  globalSetting.setFrontAxisSign(frontAxisSign);
  globalSetting.setUpAxis(upAxis);
  globalSetting.setUpAxisSign(upAxisSign);
  scene.setObjectDefinitions(model_count,geometry_count,node_attribute_count,anim_curve_count,anim_curve_node_count,deformer_count);
  scene.setKeyframe(startFrame,endFrame,keyframeLength);
  list=null;
  return scene;
}","public static FbxScene importScene(InputStream inputStream){
  String[] list=null;
  try {
    InputStreamReader isr=new InputStreamReader(inputStream);
    char[] buffer=new char[inputStream.available()];
    isr.read(buffer);
    list=new String(buffer).split(""String_Node_Str"");
    isr.close();
    isr=null;
  }
 catch (  IOException e) {
    Log.e(""String_Node_Str"",e.getMessage());
  }
  String line=""String_Node_Str"";
  index=0;
  int model_count=0;
  int geometry_count=0;
  int node_attribute_count=0;
  int anim_curve_count=0;
  int anim_curve_node_count=0;
  int deformer_count=0;
  int material_count=0;
  int texture_count=0;
  int video_count=0;
  int startFrame=0, endFrame=0;
  int keyframeLength=0;
  FbxTimeSpan timeSpan=new FbxTimeSpan();
  FbxTimeMode timeMode=null;
  int upAxis=1;
  int upAxisSign=1;
  int frontAxis=1;
  int frontAxisSign=1;
  while (!line.startsWith(""String_Node_Str"")) {
    line=list[index++].trim();
    if (line.startsWith(""String_Node_Str"")) {
      timeMode=new FbxTimeMode(getLastCommaAsInt(line));
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      timeSpan.setStart(getLastCommaAsLong(line));
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      timeSpan.setStop(getLastCommaAsLong(line));
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      upAxis=getLastCommaAsInt(line);
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      upAxisSign=getLastCommaAsInt(line);
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      frontAxis=getLastCommaAsInt(line);
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      frontAxisSign=getLastCommaAsInt(line);
    }
  }
  while (!line.startsWith(""String_Node_Str"")) {
    line=list[index++].trim();
    if (line.startsWith(""String_Node_Str"")) {
      line=line.split(""String_Node_Str"")[1];
      String attribute=list[index++];
      int count=Convert.toInt(attribute.split(""String_Node_Str"")[1].trim());
      if (line.equals(""String_Node_Str"")) {
        model_count=count;
      }
 else       if (line.equals(""String_Node_Str"")) {
        geometry_count=count;
      }
 else       if (line.equals(""String_Node_Str"")) {
        node_attribute_count=count;
      }
 else       if (line.equals(""String_Node_Str"")) {
        anim_curve_count=count;
      }
 else       if (line.equals(""String_Node_Str"")) {
        anim_curve_node_count=count;
      }
 else       if (line.equals(""String_Node_Str"")) {
        deformer_count=count;
      }
 else       if (line.equals(""String_Node_Str"")) {
        material_count=count;
      }
 else       if (line.equals(""String_Node_Str"")) {
        texture_count=count;
      }
 else       if (line.equals(""String_Node_Str"")) {
        video_count=count;
      }
    }
  }
  HashMap<Long,FbxObject> maps=new HashMap<Long,FbxObject>();
  int current_geometry_count=0;
  int current_node_attribute_count=0;
  int current_node_count=0;
  int current_deformer_count=0;
  int current_anim_curve_node_count=0;
  int current_anim_curve_count=0;
  int current_material_count=0;
  int current_texture_count=0;
  int current_video_count=0;
  while (!line.startsWith(""String_Node_Str"")) {
    line=list[index++].trim();
    if (current_geometry_count < geometry_count) {
      if (line.startsWith(""String_Node_Str"")) {
        current_geometry_count+=1;
        Object[] geoItems=getID_NameAndType(line.substring(10));
        long geometry_id=(Long)geoItems[0];
        FbxMesh mesh=new FbxMesh(geometry_id);
        while (true) {
          line=list[index++].trim();
          if (line.startsWith(""String_Node_Str"")) {
            int count=Convert.toInt(line.substring(11).split(""String_Node_Str"")[0]);
            mesh.setVertices(readFloatAttribute(list,count));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            int count=Convert.toInt(line.substring(21).split(""String_Node_Str"")[0]);
            mesh.setIndices(readIndicesAttribute(list,count));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            int count=Convert.toInt(line.substring(10).split(""String_Node_Str"")[0]);
            mesh.setNormals(readFloatAttribute(list,count));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            int count=Convert.toInt(line.substring(5).split(""String_Node_Str"")[0]);
            mesh.setUV(readFloatAttribute(list,count));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            int count=Convert.toInt(line.substring(10).split(""String_Node_Str"")[0]);
            mesh.setUVIndices(readUVIndicesAttribute(list,count));
            break;
          }
        }
        maps.put(geometry_id,mesh);
      }
    }
    if (current_node_attribute_count < node_attribute_count) {
      if (line.startsWith(""String_Node_Str"")) {
        current_node_attribute_count+=1;
        Object[] items=getID_NameAndType(line.substring(15));
        long node_attribute_id=(Long)items[0];
        int attributeType;
        FbxNodeAttribute nodeAttribute=null;
        if (items[2].equals(""String_Node_Str"")) {
          attributeType=FbxNodeAttribute.Null;
          nodeAttribute=new FbxNodeAttribute(node_attribute_id,attributeType);
        }
 else         if (items[2].equals(""String_Node_Str"")) {
          attributeType=FbxNodeAttribute.Mesh;
          nodeAttribute=new FbxNodeAttribute(node_attribute_id,attributeType);
        }
 else {
          int skeletonType=0;
          if (line.contains(""String_Node_Str"")) {
            skeletonType=FbxSkeleton.LimbNode;
          }
 else           if (line.contains(""String_Node_Str"") || line.contains(""String_Node_Str"")) {
            skeletonType=FbxSkeleton.Root;
          }
          nodeAttribute=new FbxSkeleton(node_attribute_id,skeletonType);
        }
        maps.put(node_attribute_id,nodeAttribute);
      }
    }
    if (current_node_count < model_count) {
      if (line.startsWith(""String_Node_Str"")) {
        current_node_count+=1;
        StringBuilder[] item=new StringBuilder[2];
        item[0]=new StringBuilder();
        item[1]=new StringBuilder();
        int inner_index=0;
        boolean begin=false;
        char temp=0;
        for (int i=0; i < line.length(); i++) {
          char c=line.charAt(i);
          if (temp == ':') {
            if (c == ' ') {
              begin=true;
              inner_index=0;
              continue;
            }
 else             if (c == ':') {
              begin=true;
              inner_index=1;
              continue;
            }
          }
          if (c == '""' || c == ',') {
            begin=false;
            if (inner_index == 1) {
              break;
            }
          }
          if (begin) {
            item[inner_index].append(c);
          }
          temp=c;
        }
        long nodeID=Convert.toLong(item[0].toString().trim());
        String nodeName=item[1].toString();
        FbxNode node=new FbxNode(nodeID);
        node.setName(nodeName);
        Vector3 lclT=new Vector3();
        Vector3 lclR=new Vector3();
        Vector3 lclS=new Vector3(1,1,1);
        while (!(line=list[index++]).contains(""String_Node_Str"")) {
          if (line.contains(""String_Node_Str"")) {
            lclT=new Vector3(splitCommaToFloatArray(line,3));
          }
 else           if (line.contains(""String_Node_Str"")) {
            lclR=new Vector3(splitCommaToFloatArray(line,3));
          }
 else           if (line.contains(""String_Node_Str"")) {
            lclS=new Vector3(splitCommaToFloatArray(line,3));
          }
        }
        node.setLclTranslation(lclT);
        node.setLclRotation(lclR);
        node.setLclScaling(lclS);
        maps.put(nodeID,node);
      }
    }
    if (current_deformer_count < deformer_count) {
      if (line.startsWith(""String_Node_Str"")) {
        current_deformer_count+=1;
        Object[] items=getID_NameAndType(line.substring(10));
        long deformer_id=(Long)items[0];
        if (items[2].equals(""String_Node_Str"")) {
          FbxSkin skin=new FbxSkin(deformer_id);
          maps.put(deformer_id,skin);
        }
 else {
          FbxCluster cluster=new FbxCluster(deformer_id);
          while (true) {
            line=list[index++].trim();
            if (line.startsWith(""String_Node_Str"")) {
              int count=Convert.toInt(line.substring(10).split(""String_Node_Str"")[0]);
              cluster.setIndices(readIntAttribute(list,count));
            }
 else             if (line.startsWith(""String_Node_Str"")) {
              int count=Convert.toInt(line.substring(10).split(""String_Node_Str"")[0]);
              cluster.setWeights(readFloatAttribute(list,count));
            }
 else             if (line.startsWith(""String_Node_Str"")) {
              int count=Convert.toInt(line.substring(12).split(""String_Node_Str"")[0]);
              cluster.setTransform(readFloatAttribute(list,count));
            }
 else             if (line.startsWith(""String_Node_Str"")) {
              int count=Convert.toInt(line.substring(16).split(""String_Node_Str"")[0]);
              cluster.setTransformLink(readFloatAttribute(list,count));
              break;
            }
          }
          maps.put(deformer_id,cluster);
        }
      }
    }
    if (current_material_count < material_count) {
      if (line.startsWith(""String_Node_Str"")) {
        current_material_count+=1;
        Object[] items=getID_NameAndType(line.substring(10));
        long material_id=(Long)items[0];
        String material_name=((String)items[1]).substring(10);
        FbxSurfacePhong material=new FbxSurfacePhong(material_id);
        material.setName(material_name);
        while (!line.contains(""String_Node_Str"")) {
          line=list[index++].trim();
          if (line.startsWith(""String_Node_Str"")) {
            material.getEmissive().set(new Vector3(splitCommaToFloatArray(line,3)));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.getAmbient().set(new Vector3(splitCommaToFloatArray(line,3)));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.getDiffuse().set(new Vector3(splitCommaToFloatArray(line,3)));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.getNormalMap().set(new Vector3(splitCommaToFloatArray(line,3)));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.getBump().set(new Vector3(splitCommaToFloatArray(line,3)));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.getTransparentColor().set(new Vector3(splitCommaToFloatArray(line,3)));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.getDisplacementColor().set(new Vector3(splitCommaToFloatArray(line,3)));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.getVectorDisplacementColor().set(new Vector3(splitCommaToFloatArray(line,3)));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.getSpecular().set(new Vector3(splitCommaToFloatArray(line,3)));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.getReflection().set(new Vector3(splitCommaToFloatArray(line,3)));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.setShinniness(splitCommaToFloat(line));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.setEmissiveFactor(splitCommaToFloat(line));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.setAmbientFactor(splitCommaToFloat(line));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.setDiffuseFactor(splitCommaToFloat(line));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.setBumpFactor(splitCommaToFloat(line));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.setTransparencyFactor(splitCommaToFloat(line));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.setDisplacementFactor(splitCommaToFloat(line));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.setVectorDisplacementFactor(splitCommaToFloat(line));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.setSpecularFactor(splitCommaToFloat(line));
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            material.setReflectionFactor(splitCommaToFloat(line));
          }
        }
        maps.put(material_id,material);
      }
    }
    if (current_texture_count < texture_count) {
      if (line.startsWith(""String_Node_Str"")) {
        current_texture_count+=1;
        String[] t=line.substring(9).split(""String_Node_Str"");
        long texture_id=Convert.toLong(t[0]);
        String texture_name=t[1].split(""String_Node_Str"")[1].substring(9);
        FbxFileTexture texture=new FbxFileTexture(texture_id);
        texture.setName(texture_name);
        while (!line.contains(""String_Node_Str"")) {
          line=list[index++].trim();
        }
        line=list[index++].trim();
        while (!line.contains(""String_Node_Str"")) {
          line=list[index++].trim();
          String[] tmp=line.split(""String_Node_Str"");
          if (line.startsWith(""String_Node_Str"")) {
            String tt=tmp[tmp.length - 1];
            String fileName=tt;
            int indexOfSlash=tt.lastIndexOf(""String_Node_Str"");
            if (indexOfSlash > -1) {
              fileName=tt.substring(indexOfSlash + 1);
            }
            texture.setFileName(fileName);
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            String tt=tmp[tmp.length - 1];
            texture.setRelativeFileName(tt);
          }
 else           if (line.startsWith(""String_Node_Str"")) {
          }
        }
        maps.put(texture_id,texture);
      }
    }
    if (current_video_count < video_count) {
      if (line.startsWith(""String_Node_Str"")) {
        current_video_count+=1;
      }
    }
    if (current_anim_curve_node_count < anim_curve_node_count) {
      if (line.startsWith(""String_Node_Str"")) {
        current_anim_curve_node_count+=1;
        long anim_curve_node_id=Convert.toLong(line.substring(20).split(""String_Node_Str"")[0]);
        FbxAnimCurveNode animCurveNode=new FbxAnimCurveNode(anim_curve_node_id);
        maps.put(anim_curve_node_id,animCurveNode);
      }
    }
    if (current_anim_curve_count < anim_curve_count) {
      if (line.startsWith(""String_Node_Str"")) {
        current_anim_curve_count+=1;
        long anim_curve_id=Convert.toLong(line.substring(16).split(""String_Node_Str"")[0]);
        FbxAnimCurve animCurve=new FbxAnimCurve(anim_curve_id);
        long[] times=null;
        float[] values=null;
        while (true) {
          line=list[index++].trim();
          if (line.startsWith(""String_Node_Str"")) {
            int count=Convert.toInt(line.substring(10).split(""String_Node_Str"")[0]);
            times=readLongAttribute(list,count);
            if (times.length > 0) {
              int length=(int)((times[times.length - 1] - times[0]) / 1539538600L) + 1;
              if (length > keyframeLength) {
                keyframeLength=length;
                startFrame=(int)(times[0] / 1539538600L);
                endFrame=(int)(times[times.length - 1] / 1539538600L);
              }
            }
          }
 else           if (line.startsWith(""String_Node_Str"")) {
            int count=Convert.toInt(line.substring(16).split(""String_Node_Str"")[0]);
            values=readFloatAttribute(list,count);
            break;
          }
        }
        animCurve.set(times,values);
        maps.put(anim_curve_id,animCurve);
      }
    }
  }
  ArrayList<FbxNode> rootnodes=new ArrayList<FbxNode>();
  while (!line.startsWith(""String_Node_Str"") && index < list.length) {
    line=list[index++].trim();
    if (line.endsWith(""String_Node_Str"")) {
      line=list[index++].trim();
      String attribute=line.substring(8);
      long root_node_id=Convert.toLong(attribute.substring(0,attribute.length() - 2));
      FbxNode node=(FbxNode)maps.get(root_node_id);
      rootnodes.add(node);
    }
 else     if (line.endsWith(""String_Node_Str"")) {
      line=list[index++].trim();
      String[] attribute=line.substring(8).split(""String_Node_Str"");
      long node_id=Convert.toLong(attribute[0]);
      long sub_deformer_id=Convert.toLong(attribute[1]);
      FbxNode associateModel=(FbxNode)maps.get(node_id);
      FbxCluster cluster=(FbxCluster)maps.get(sub_deformer_id);
      cluster.setAssociateModel(associateModel);
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      if (line.split(""String_Node_Str"")[1].startsWith(""String_Node_Str"")) {
        line=list[index++].trim();
        String[] attribute=line.substring(8).split(""String_Node_Str"");
        long child_node_id=Convert.toLong(attribute[0]);
        long parent_node_id=Convert.toLong(attribute[1]);
        FbxNode child_node=(FbxNode)maps.get(child_node_id);
        FbxNode parent_node=(FbxNode)maps.get(parent_node_id);
        parent_node.addChild(child_node);
        child_node.setParent(parent_node);
      }
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      line=list[index++].trim();
      String[] attribute=line.substring(8).split(""String_Node_Str"");
      long geometry_id=Convert.toLong(attribute[0]);
      long node_id=Convert.toLong(attribute[1]);
      FbxNode node=(FbxNode)maps.get(node_id);
      FbxGeometry geometry=(FbxGeometry)maps.get(geometry_id);
      node.setNodeAttribute(geometry);
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      String[] tmp0=line.split(""String_Node_Str"");
      if (tmp0[1].startsWith(""String_Node_Str"")) {
        line=list[index++].trim();
        String[] attribute=line.substring(8).split(""String_Node_Str"");
        long anim_curve_node_id=Convert.toLong(attribute[0]);
        long node_id=Convert.toLong(attribute[1]);
        FbxNode node=(FbxNode)maps.get(node_id);
        FbxAnimCurveNode animCurveNode=(FbxAnimCurveNode)maps.get(anim_curve_node_id);
        char type=tmp0[0].charAt(tmp0[0].length() - 1);
        if (type == 'T') {
          node.setLclTranslation(animCurveNode);
        }
 else         if (type == 'R') {
          node.setLclRotation(animCurveNode);
        }
 else {
          node.setLclScaling(animCurveNode);
        }
      }
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      line=list[index++].trim();
      String[] attribute=line.substring(8).split(""String_Node_Str"");
      long node_attribute_id=Convert.toLong(attribute[0]);
      long node_id=Convert.toLong(attribute[1]);
      FbxNode node=(FbxNode)maps.get(node_id);
      FbxNodeAttribute nodeAttribute=(FbxNodeAttribute)maps.get(node_attribute_id);
      node.setNodeAttribute(nodeAttribute);
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      line=list[index++].trim();
      String[] attribute=line.substring(8).split(""String_Node_Str"");
      long deformer_id=Convert.toLong(attribute[0]);
      long geometry_id=Convert.toLong(attribute[1]);
      FbxDeformer deformer=(FbxDeformer)maps.get(deformer_id);
      FbxGeometry geometry=(FbxGeometry)maps.get(geometry_id);
      geometry.addDeformer(deformer);
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      line=list[index++].trim();
      String[] first_line=line.substring(8).split(""String_Node_Str"");
      index+=2;
      line=list[index++].trim();
      String[] second_line=line.substring(8).split(""String_Node_Str"");
      index+=2;
      line=list[index++].trim();
      String[] third_line=line.substring(8).split(""String_Node_Str"");
      long anim_curve_node_id=Convert.toLong(first_line[1]);
      long x_id=Convert.toLong(first_line[0]);
      long y_id=Convert.toLong(second_line[0]);
      long z_id=Convert.toLong(third_line[0]);
      FbxAnimCurveNode animCurveNode=(FbxAnimCurveNode)maps.get(anim_curve_node_id);
      FbxAnimCurve animCurveX=(FbxAnimCurve)maps.get(x_id);
      FbxAnimCurve animCurveY=(FbxAnimCurve)maps.get(y_id);
      FbxAnimCurve animCurveZ=(FbxAnimCurve)maps.get(z_id);
      animCurveNode.set(animCurveX,animCurveY,animCurveZ);
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      line=list[index++].trim();
      String[] attribute=line.substring(8).split(""String_Node_Str"");
      long sub_deformer_id=Convert.toLong(attribute[0]);
      long deformer_id=Convert.toLong(attribute[1]);
      FbxCluster cluster=(FbxCluster)maps.get(sub_deformer_id);
      FbxSkin deformer=(FbxSkin)maps.get(deformer_id);
      deformer.addCluster(cluster);
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      line=list[index++].trim();
      String[] attribute=line.substring(8).split(""String_Node_Str"");
      long material_id=Convert.toLong(attribute[0]);
      long node_id=Convert.toLong(attribute[1]);
      FbxSurfaceMaterial material=(FbxSurfaceMaterial)maps.get(material_id);
      FbxNode node=(FbxNode)maps.get(node_id);
      node.setMaterial(material);
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      line=list[index++].trim();
      String[] attribute=line.substring(8).split(""String_Node_Str"");
      long texture_id=Convert.toLong(attribute[0]);
      long material_id=Convert.toLong(attribute[1]);
      String target=attribute[2].trim().split(""String_Node_Str"")[1];
      FbxTexture texture=(FbxTexture)maps.get(texture_id);
      FbxSurfacePhong material=(FbxSurfacePhong)maps.get(material_id);
      if (target.equalsIgnoreCase(""String_Node_Str"")) {
        material.setDiffuseTexture(texture);
      }
 else       if (target.equalsIgnoreCase(""String_Node_Str"")) {
      }
    }
  }
  FbxScene scene=new FbxScene();
  for (  FbxObject fbxObject : maps.values()) {
    if (fbxObject instanceof FbxGeometry) {
      scene.addGeometry((FbxGeometry)fbxObject);
    }
 else     if (fbxObject instanceof FbxNode) {
      scene.addNode((FbxNode)fbxObject);
    }
 else     if (fbxObject instanceof FbxSurfaceMaterial) {
      scene.addMaterial((FbxSurfaceMaterial)fbxObject);
    }
  }
  FbxNode sceneRootNode=scene.getRootnodes();
  for (  FbxNode rootnode : rootnodes) {
    sceneRootNode.addChild(rootnode);
  }
  FbxGlobalSetting globalSetting=scene.globalSetting();
  globalSetting.setTimeMode(timeMode);
  globalSetting.setTimeSpan(timeSpan);
  globalSetting.setFrontAxis(frontAxis);
  globalSetting.setFrontAxisSign(frontAxisSign);
  globalSetting.setUpAxis(upAxis);
  globalSetting.setUpAxisSign(upAxisSign);
  scene.setObjectDefinitions(model_count,geometry_count,node_attribute_count,anim_curve_count,anim_curve_node_count,deformer_count);
  scene.setKeyframe(startFrame,endFrame,keyframeLength);
  list=null;
  return scene;
}",0.9993235428895628
99110,"private void collision(SphereCollider b){
  indx[0]=getClosetPlaneIndex(b);
  indx[1]=indx[0] - 1;
  indx[2]=indx[0] + 1;
  if (indx[1] < 0) {
    indx[1]=getPlaneCount() - 1;
  }
  if (indx[2] == getPlaneCount()) {
    indx[2]=0;
  }
  Log.e(""String_Node_Str"",indx[0] + ""String_Node_Str"" + indx[1]+ ""String_Node_Str""+ indx[2]);
  Color3 color=new Color3(1,0,0);
  for (int i=0; i < indx.length; i++) {
    Vector3[] plane=getCorner(indx[i]);
    Vector3 c1=Vector3.add(Vector3.add(plane[0],plane[1]),Vector3.add(plane[2],plane[3]));
    Vector3 center=new Vector3(c1.x / 4f,c1.y / 4f,c1.z / 4f);
    Debug.drawLine(plane[0],plane[1],color);
    Debug.drawLine(plane[1],plane[2],color);
    Debug.drawLine(plane[2],plane[3],color);
    Debug.drawLine(plane[3],plane[0],color);
    boolean isOverlap=Collider.intersect(b,center,plane[0],plane[3],plane[2],plane[1]);
    Log.e(""String_Node_Str"",center.toString());
    if (isOverlap) {
      Log.e(""String_Node_Str"",b.getName());
      Vector3 v1=Vector3.subtract(plane[2],plane[0]);
      Vector3 v2=Vector3.subtract(plane[3],plane[0]);
      Vector3 n=Vector3.cross(v1,v2);
      Vector3 forward=b.getForward();
      Vector3 reflect=Vector3.reflect(forward,n);
      b.setForward(reflect);
    }
  }
}","private void collision(SphereCollider b){
  indx[0]=getClosetPlaneIndex(b);
  indx[1]=indx[0] - 1;
  indx[2]=indx[0] + 1;
  if (indx[1] < 0) {
    indx[1]=getPlaneCount() - 1;
  }
  if (indx[2] == getPlaneCount()) {
    indx[2]=0;
  }
  Color3 color=new Color3(1,0,0);
  for (int i=0; i < indx.length; i++) {
    Vector3[] plane=getCorner(indx[i]);
    Vector3 c1=Vector3.add(Vector3.add(plane[0],plane[1]),Vector3.add(plane[2],plane[3]));
    Vector3 center=new Vector3(c1.x / 4f,c1.y / 4f,c1.z / 4f);
    Debug.drawLine(plane[0],plane[1],color);
    Debug.drawLine(plane[1],plane[2],color);
    Debug.drawLine(plane[2],plane[3],color);
    Debug.drawLine(plane[3],plane[0],color);
    boolean isOverlap=Collider.intersect(b,center,plane[0],plane[3],plane[2],plane[1]);
    if (isOverlap) {
      Log.e(""String_Node_Str"",b.getName());
      Vector3 v1=Vector3.subtract(plane[2],plane[0]);
      Vector3 v2=Vector3.subtract(plane[3],plane[0]);
      Vector3 n=Vector3.cross(v1,v2);
      Vector3 up=new Vector3(0,0,1);
      Vector3 ford=Vector3.cross(up,n);
      if (!b.isRoot()) {
        Vector3 forward=b.parent.getForward();
        Vector3 reflect=Vector3.reflect(forward,n);
        b.parent.setForward(ford);
      }
 else {
        Vector3 forward=b.getForward();
        Vector3 reflect=Vector3.reflect(forward,n);
        b.setForward(ford);
      }
    }
  }
}",0.364952380952381
99111,"public void update(){
  if (!isStarted) {
    isStarted=true;
  }
  PlaneCollider chkp=checkpoint.get(currentCheckPoint);
  SphereCollider sphr=vehicle.getCollider();
  vehicle.accelerate(1);
  if (Collider.intersect(chkp,sphr)) {
    currentCheckPoint++;
    if (currentCheckPoint >= checkpoint.size()) {
      currentCheckPoint-=checkpoint.size();
    }
  }
}","public void update(){
  if (!isStarted) {
    isStarted=true;
  }
  PlaneCollider chkp=checkpoint.get(currentCheckPoint);
  SphereCollider sphr=(SphereCollider)vehicle.getObject().getCollider();
  vehicle.accelerate(1);
  if (Collider.intersect(chkp,sphr)) {
    currentCheckPoint++;
    if (currentCheckPoint >= checkpoint.size()) {
      currentCheckPoint-=checkpoint.size();
    }
  }
}",0.9626666666666668
99112,"private void init(){
  terrain.setName(""String_Node_Str"");
  buffy.setName(""String_Node_Str"");
  terrain.setPosition(-1000,-1000,0);
  Animation buffyAnimation=buffy.getAnimation();
  buffyAnimation.getAnimationClip(""String_Node_Str"").set(0,30,PlaybackMode.LOOP);
  buffyAnimation.addAnimationClip(""String_Node_Str"",35,50,PlaybackMode.LOOP);
  buffyAnimation.play(""String_Node_Str"");
  camera.setPosition(0,-10,9);
  camera.rotate(-10,0,0);
  camera.setRange(2500);
  camera.setSky(skydome(""String_Node_Str""));
  buffy.addChild(camera);
  buffy.setScale(0.1f,0.1f,0.1f);
  berserkerDif=tex2D(""String_Node_Str"");
  buffyDif=buffy.asModel().getMaterial().getBaseTexture();
  vehicle=new Vehicle(buffy);
  SphereCollider buffyCollider=vehicle.getCollider();
  buffyCollider.setRadius(3);
  buffyCollider.translate(0,0.5f,2);
  terrain.attachCollider(buffyCollider);
  float ratio=(float)Screen.getWidth() / Screen.getHeight();
  float scalef=0.2f;
  controller.setScale(scalef,scalef * ratio);
  controller.setActive(false);
  controller.setOnTouchListener(new OnTouchListener(){
    public void onTouch(    Button button,    int action,    float x,    float y){
      if (!isEnd) {
        Vector2 center=button.getCenter();
        float dx=center.x - x;
        float dy=center.y - y;
        Vector2 dir=vec2(dx,dy).getNormalized();
        if (dir.y != 0.0f && !Float.isNaN(dir.y)) {
          vehicle.accelerate(0.03f * dir.y);
        }
        if (dir.x != 0.0f && !Float.isNaN(dir.x)) {
          vehicle.turn(dir.x);
        }
      }
    }
  }
);
  Scene.setMainCamera(camera);
  Vector2[] outside=new Vector2[14];
  outside[0]=new Vector2(514,190);
  outside[1]=new Vector2(791,10);
  outside[2]=new Vector2(800,-172);
  outside[3]=new Vector2(621,-409);
  outside[4]=new Vector2(80,-658);
  outside[5]=new Vector2(-218,-631);
  outside[6]=new Vector2(-569,-427);
  outside[7]=new Vector2(-815,-158);
  outside[8]=new Vector2(-780,95);
  outside[9]=new Vector2(-617,188);
  outside[10]=new Vector2(317,209);
  outside[11]=new Vector2(514,190);
  outside[12]=new Vector2(791,10);
  outside[13]=new Vector2(800,-172);
  Vector2[] inside=new Vector2[20];
  inside[0]=new Vector2(0,0);
  inside[1]=new Vector2(-370,2.7f);
  inside[2]=new Vector2(-504,-2.7f);
  inside[3]=new Vector2(-614,-110);
  inside[4]=new Vector2(-607,-191);
  inside[5]=new Vector2(-551,-288);
  inside[6]=new Vector2(-381,-374);
  inside[7]=new Vector2(-143,-485);
  inside[8]=new Vector2(-89,-483);
  inside[9]=new Vector2(110,-474);
  inside[10]=new Vector2(265,-364);
  inside[11]=new Vector2(512,-290);
  inside[12]=new Vector2(604,-183);
  inside[13]=new Vector2(604,-38);
  inside[14]=new Vector2(554,20);
  inside[15]=new Vector2(435,43);
  inside[16]=new Vector2(278,36);
  inside[17]=new Vector2(0,0);
  inside[18]=new Vector2(-370,2.7f);
  inside[19]=new Vector2(-504,-2.7f);
  trackOutside=CurveCollider.bSplineCurveCollider(0.25f,190,false,outside);
  trackOutside.attachCollider(buffyCollider);
  trackInside=CurveCollider.bSplineCurveCollider(0.25f,190,false,inside);
  trackInside.attachCollider(buffyCollider);
  checkpoint.add(collider(0.99f,0.01f,0,250,100,134,106,140));
  checkpoint.add(collider(0.88f,-0.473f,0,250,100,551,90,140));
  checkpoint.add(collider(0.23f,-0.973f,0,250,100,683,-55,140));
  checkpoint.add(collider(-0.836f,-0.548f,0,250,100,591,-327,140));
  checkpoint.add(collider(-0.956f,-0.293f,0,250,100,68,-574,140));
  checkpoint.add(collider(-0.852f,0.524f,0,250,100,-277,-521,140));
  checkpoint.add(collider(-0.319f,0.948f,0,250,100,-657,-236,140));
  checkpoint.add(collider(0.82f,0.572f,0,250,100,-652,8,140));
  checkpoint.add(collider(0.99f,0.948f,0,250,100,-404,95,140));
  checkpoint.add(collider(0.951f,0.31f,0,250,100,-71,96,140));
  endSprite=sprite(""String_Node_Str"");
  endSprite.setScale(0.25f,0.25f);
  layer1.addChild(terrain,buffy,trackOutside,trackInside);
  layer2.addChild(controller);
  for (int i=0; i < checkpoint.size(); i++) {
    layer1.addChild(checkpoint.get(i));
  }
  scene.addLayer(layer1);
  scene.addLayer(layer2);
}","private void init(){
  terrain.setName(""String_Node_Str"");
  buffy.setName(""String_Node_Str"");
  terrain.setPosition(-1000,-1000,0);
  Animation buffyAnimation=buffy.getAnimation();
  buffyAnimation.getAnimationClip(""String_Node_Str"").set(0,30,PlaybackMode.LOOP);
  buffyAnimation.addAnimationClip(""String_Node_Str"",35,50,PlaybackMode.LOOP);
  buffyAnimation.play(""String_Node_Str"");
  camera.setPosition(0,-10,9);
  camera.rotate(-10,0,0);
  camera.setRange(2500);
  camera.setSky(skydome(""String_Node_Str""));
  buffy.addChild(camera);
  buffy.setScale(0.1f,0.1f,0.1f);
  berserkerDif=tex2D(""String_Node_Str"");
  buffyDif=buffy.asModel().getMaterial().getBaseTexture();
  SphereCollider buffyCollider=collider(3);
  buffyCollider.translate(0,0.5f,2);
  buffy.setCollider(buffyCollider);
  vehicle=new Vehicle(buffy);
  terrain.attachCollider(buffyCollider);
  float ratio=(float)Screen.getWidth() / Screen.getHeight();
  float scalef=0.2f;
  controller.setScale(scalef,scalef * ratio);
  controller.setActive(false);
  controller.setOnTouchListener(new OnTouchListener(){
    public void onTouch(    Button button,    int action,    float x,    float y){
      if (!isEnd) {
        Vector2 center=button.getCenter();
        float dx=center.x - x;
        float dy=center.y - y;
        Vector2 dir=vec2(dx,dy).getNormalized();
        if (dir.y != 0.0f && !Float.isNaN(dir.y)) {
          vehicle.accelerate(0.03f * dir.y);
        }
        if (dir.x != 0.0f && !Float.isNaN(dir.x)) {
          vehicle.turn(dir.x);
        }
      }
    }
  }
);
  Scene.setMainCamera(camera);
  Vector2[] outside=new Vector2[14];
  outside[0]=new Vector2(514,190);
  outside[1]=new Vector2(791,10);
  outside[2]=new Vector2(800,-172);
  outside[3]=new Vector2(621,-409);
  outside[4]=new Vector2(80,-658);
  outside[5]=new Vector2(-218,-631);
  outside[6]=new Vector2(-569,-427);
  outside[7]=new Vector2(-815,-158);
  outside[8]=new Vector2(-780,95);
  outside[9]=new Vector2(-617,188);
  outside[10]=new Vector2(317,209);
  outside[11]=new Vector2(514,190);
  outside[12]=new Vector2(791,10);
  outside[13]=new Vector2(800,-172);
  Vector2[] inside=new Vector2[20];
  inside[0]=new Vector2(0,0);
  inside[1]=new Vector2(-370,2.7f);
  inside[2]=new Vector2(-504,-2.7f);
  inside[3]=new Vector2(-614,-110);
  inside[4]=new Vector2(-607,-191);
  inside[5]=new Vector2(-551,-288);
  inside[6]=new Vector2(-381,-374);
  inside[7]=new Vector2(-143,-485);
  inside[8]=new Vector2(-89,-483);
  inside[9]=new Vector2(110,-474);
  inside[10]=new Vector2(265,-364);
  inside[11]=new Vector2(512,-290);
  inside[12]=new Vector2(604,-183);
  inside[13]=new Vector2(604,-38);
  inside[14]=new Vector2(554,20);
  inside[15]=new Vector2(435,43);
  inside[16]=new Vector2(278,36);
  inside[17]=new Vector2(0,0);
  inside[18]=new Vector2(-370,2.7f);
  inside[19]=new Vector2(-504,-2.7f);
  trackOutside=CurveCollider.bSplineCurveCollider(0.25f,190,false,outside);
  trackOutside.attachCollider(buffyCollider);
  trackInside=CurveCollider.bSplineCurveCollider(0.25f,190,false,inside);
  trackInside.attachCollider(buffyCollider);
  checkpoint.add(collider(0.99f,0.01f,0,250,100,134,106,140));
  checkpoint.add(collider(0.88f,-0.473f,0,250,100,551,90,140));
  checkpoint.add(collider(0.23f,-0.973f,0,250,100,683,-55,140));
  checkpoint.add(collider(-0.836f,-0.548f,0,250,100,591,-327,140));
  checkpoint.add(collider(-0.956f,-0.293f,0,250,100,68,-574,140));
  checkpoint.add(collider(-0.852f,0.524f,0,250,100,-277,-521,140));
  checkpoint.add(collider(-0.319f,0.948f,0,250,100,-657,-236,140));
  checkpoint.add(collider(0.82f,0.572f,0,250,100,-652,8,140));
  checkpoint.add(collider(0.99f,0.948f,0,250,100,-404,95,140));
  checkpoint.add(collider(0.951f,0.31f,0,250,100,-71,96,140));
  endSprite=sprite(""String_Node_Str"");
  endSprite.setScale(0.25f,0.25f);
  layer1.addChild(terrain,buffy,trackOutside,trackInside);
  layer2.addChild(controller);
  for (int i=0; i < checkpoint.size(); i++) {
    layer1.addChild(checkpoint.get(i));
  }
  scene.addLayer(layer1);
  scene.addLayer(layer2);
}",0.9795767716535432
99113,"public void onUpdate(){
  vehicle.update();
  PlaneCollider chp=checkpoint.get(currentCheckpoint);
  SphereCollider spr=vehicle.getCollider();
  if (Collider.intersect(chp,spr)) {
    currentCheckpoint++;
    checkpointCount++;
    if (currentCheckpoint >= checkpoint.size()) {
      currentCheckpoint-=checkpoint.size();
    }
    if (checkpointCount > checkpoint.size()) {
      if (!isEnd) {
        layer2.addChild(endSprite);
        isEnd=true;
      }
    }
  }
  debuging();
}","public void onUpdate(){
  vehicle.update();
  PlaneCollider chp=checkpoint.get(currentCheckpoint);
  SphereCollider spr=(SphereCollider)buffy.getCollider();
  if (Collider.intersect(chp,spr)) {
    currentCheckpoint++;
    checkpointCount++;
    if (currentCheckpoint >= checkpoint.size()) {
      currentCheckpoint-=checkpoint.size();
    }
    if (checkpointCount > checkpoint.size()) {
      if (!isEnd) {
        layer2.addChild(endSprite);
        isEnd=true;
      }
    }
  }
  debuging();
}",0.9714867617107944
99114,"public Matrix4 getWorldMatrix(){
  if (isRoot()) {
    return local;
  }
  return world;
}","public Matrix4 getWorldMatrix(){
  if (parent == null) {
    return local;
  }
  return world;
}",0.8924731182795699
99115,"@Override public final boolean addChild(Group child){
  if (child.parent == null) {
    boolean b=super.addChild(child);
    if (b) {
      child.parent=this;
    }
    return b;
  }
  return false;
}","public final void addChild(Group... children){
  for (  Group child : children) {
    addChild(child);
  }
}",0.525974025974026
99116,"private void drawTerrain(Terrain terrain){
  Matrix4 tmm1=new Matrix4();
  tmm1.setTranslation(terrain.localTranslation);
  Matrix4 tmm=Matrix4.multiply(modelViewMatrix,tmm1);
  Matrix3 nm=new Matrix3();
  Matrix3.createNormalMatrix(nm,tmm);
  ArrayList<Light> ls=new ArrayList<Light>();
  ls.addAll(lights);
  ShaderProgram shaderProgram=Shader.DIFFUSE.getProgram(5);
  int program=shaderProgram.getProgramID();
  GLES20.glUseProgram(program);
  setLightUniform(program,ls);
  float[] tm=new float[16];
  projectionMatrix.copyTo(tm);
  GLES20.glUniformMatrix4fv(GLES20.glGetUniformLocation(program,""String_Node_Str""),1,false,tm,0);
  float[] tm1=new float[16];
  tmm.copyTo(tm1);
  GLES20.glUniformMatrix4fv(GLES20.glGetUniformLocation(program,""String_Node_Str""),1,false,tm1,0);
  float[] tm2=new float[9];
  nm.copyTo(tm2);
  GLES20.glUniformMatrix3fv(GLES20.glGetUniformLocation(program,""String_Node_Str""),1,false,tm2,0);
  GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
  GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,terrain.getBaseTexture().getTextureBuffer());
  GLES20.glUniform1i(GLES20.glGetUniformLocation(program,""String_Node_Str""),0);
  GLES20.glActiveTexture(GLES20.GL_TEXTURE1);
  GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,terrain.getNormalmap().getTextureBuffer());
  GLES20.glUniform1i(GLES20.glGetUniformLocation(program,""String_Node_Str""),1);
  GLES20.glActiveTexture(GLES20.GL_TEXTURE2);
  GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,terrain.getHeightmap().getTextureBuffer());
  GLES20.glUniform1i(GLES20.glGetUniformLocation(program,""String_Node_Str""),2);
  GLES20.glUniform3f(GLES20.glGetUniformLocation(program,""String_Node_Str""),terrain.getTerrainMaxHeight(),Plane.getInstance().getSegment(),terrain.getTerrainScale());
  int vh=GLES20.glGetAttribLocation(program,""String_Node_Str"");
  GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER,Terrain.getTerrainBuffer(0));
  GLES20.glEnableVertexAttribArray(vh);
  GLES20.glVertexAttribPointer(vh,2,GLES20.GL_FLOAT,false,0,0);
  GLES20.glBindBuffer(GLES20.GL_ELEMENT_ARRAY_BUFFER,Terrain.getTerrainBuffer(1));
  GLES20.glDrawElements(GLES20.GL_TRIANGLES,Plane.getInstance().getIndicesCount(),GLES20.GL_UNSIGNED_INT,0);
  GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER,0);
  GLES20.glBindBuffer(GLES20.GL_ELEMENT_ARRAY_BUFFER,0);
  GLES20.glDisableVertexAttribArray(vh);
  GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,0);
}","private void drawTerrain(Terrain terrain){
  Matrix4 tmm1=new Matrix4();
  tmm1.setTranslation(terrain.getWorldMatrix().getTranslation());
  Matrix4 tmm=Matrix4.multiply(modelViewMatrix,tmm1);
  Matrix3 nm=new Matrix3();
  Matrix3.createNormalMatrix(nm,tmm);
  ArrayList<Light> ls=new ArrayList<Light>();
  ls.addAll(lights);
  ShaderProgram shaderProgram=Shader.DIFFUSE.getProgram(5);
  int program=shaderProgram.getProgramID();
  GLES20.glUseProgram(program);
  setLightUniform(program,ls);
  float[] tm=new float[16];
  projectionMatrix.copyTo(tm);
  GLES20.glUniformMatrix4fv(GLES20.glGetUniformLocation(program,""String_Node_Str""),1,false,tm,0);
  float[] tm1=new float[16];
  tmm.copyTo(tm1);
  GLES20.glUniformMatrix4fv(GLES20.glGetUniformLocation(program,""String_Node_Str""),1,false,tm1,0);
  float[] tm2=new float[9];
  nm.copyTo(tm2);
  GLES20.glUniformMatrix3fv(GLES20.glGetUniformLocation(program,""String_Node_Str""),1,false,tm2,0);
  GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
  GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,terrain.getBaseTexture().getTextureBuffer());
  GLES20.glUniform1i(GLES20.glGetUniformLocation(program,""String_Node_Str""),0);
  GLES20.glActiveTexture(GLES20.GL_TEXTURE1);
  GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,terrain.getNormalmap().getTextureBuffer());
  GLES20.glUniform1i(GLES20.glGetUniformLocation(program,""String_Node_Str""),1);
  GLES20.glActiveTexture(GLES20.GL_TEXTURE2);
  GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,terrain.getHeightmap().getTextureBuffer());
  GLES20.glUniform1i(GLES20.glGetUniformLocation(program,""String_Node_Str""),2);
  GLES20.glUniform3f(GLES20.glGetUniformLocation(program,""String_Node_Str""),terrain.getTerrainMaxHeight(),Plane.getInstance().getSegment(),terrain.getTerrainScale());
  int vh=GLES20.glGetAttribLocation(program,""String_Node_Str"");
  GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER,Terrain.getTerrainBuffer(0));
  GLES20.glEnableVertexAttribArray(vh);
  GLES20.glVertexAttribPointer(vh,2,GLES20.GL_FLOAT,false,0,0);
  GLES20.glBindBuffer(GLES20.GL_ELEMENT_ARRAY_BUFFER,Terrain.getTerrainBuffer(1));
  GLES20.glDrawElements(GLES20.GL_TRIANGLES,Plane.getInstance().getIndicesCount(),GLES20.GL_UNSIGNED_INT,0);
  GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER,0);
  GLES20.glBindBuffer(GLES20.GL_ELEMENT_ARRAY_BUFFER,0);
  GLES20.glDisableVertexAttribArray(vh);
  GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,0);
}",0.9943169858977058
99117,"public void drawScene(){
  if (hasChangedProjection) {
    if (mainCamera.getProjectionType() == Camera.PERSPECTIVE) {
      Matrix4.createFrustum(projectionMatrix,-ratio,ratio,-1,1,1,mainCamera.getRange());
    }
 else {
      Matrix4.createOrtho(projectionMatrix,-ratio,ratio,-1,1,1,mainCamera.getRange());
    }
    hasChangedProjection=false;
  }
  if (hasChangedModelView) {
    Vector3 eye=mainCamera.getPosition();
    Vector3 forward=mainCamera.getForward();
    target.x=eye.x + (forward.x * 10);
    target.y=eye.y + (forward.y * 10);
    target.z=eye.z + (forward.z * 10);
    Vector3 up=mainCamera.getUp();
    Matrix4.createLookAt(modelViewMatrix,eye,target,up);
    hasChangedModelView=false;
  }
  Matrix4.multiply(modelViewProjectionMatrix,projectionMatrix,modelViewMatrix);
  for (int i=0; i < getLayerCount(); i++) {
    recursiveLayer(getLayer(i));
  }
  GLES20.glEnable(GLES20.GL_DEPTH_TEST);
  GLES20.glDisable(GLES20.GL_CULL_FACE);
  drawTerrains();
  GLES20.glEnable(GLES20.GL_CULL_FACE);
  for (int i=0; i < models.size(); i++) {
    drawModel(models.get(i));
  }
  for (int i=0; i < imageViews.size(); i++) {
    drawImageView(imageViews.get(i));
  }
  imageViews.clear();
  models.clear();
  terrains.clear();
  lights.clear();
  float end=(System.nanoTime() - start) / 1000000f;
  Log.d(""String_Node_Str"",(1000f / end) + ""String_Node_Str"");
  start=System.nanoTime();
}","public void drawScene(){
  if (hasChangedProjection) {
    if (mainCamera.getProjectionType() == Camera.PERSPECTIVE) {
      Matrix4.createFrustum(projectionMatrix,-ratio,ratio,-1,1,1,mainCamera.getRange());
    }
 else {
      Matrix4.createOrtho(projectionMatrix,-ratio,ratio,-1,1,1,mainCamera.getRange());
    }
    hasChangedProjection=false;
  }
  if (hasChangedModelView) {
    Matrix4 world=mainCamera.getWorldMatrix();
    Vector3 eye=world.getTranslation();
    Vector3 forward=world.getForward();
    target.x=eye.x + (forward.x * 10);
    target.y=eye.y + (forward.y * 10);
    target.z=eye.z + (forward.z * 10);
    Vector3 up=world.getUp();
    Matrix4.createLookAt(modelViewMatrix,eye,target,up);
    hasChangedModelView=false;
  }
  Matrix4.multiply(modelViewProjectionMatrix,projectionMatrix,modelViewMatrix);
  for (int i=0; i < getLayerCount(); i++) {
    recursiveLayer(getLayer(i));
  }
  GLES20.glEnable(GLES20.GL_DEPTH_TEST);
  GLES20.glDisable(GLES20.GL_CULL_FACE);
  drawTerrains();
  GLES20.glEnable(GLES20.GL_CULL_FACE);
  for (int i=0; i < models.size(); i++) {
    drawModel(models.get(i));
  }
  for (int i=0; i < imageViews.size(); i++) {
    drawImageView(imageViews.get(i));
  }
  imageViews.clear();
  models.clear();
  terrains.clear();
  lights.clear();
  float end=(System.nanoTime() - start) / 1000000f;
  Log.d(""String_Node_Str"",(1000f / end) + ""String_Node_Str"");
  start=System.nanoTime();
}",0.9607357622921824
99118,"private void setLightUniform(int program,ArrayList<Light> lights){
  int lightCount=lights.size();
  GLES20.glUniform1f(GLES20.glGetUniformLocation(program,""String_Node_Str""),lightCount);
  for (int i=0; i < lightCount; i++) {
    Light light=lights.get(i);
    int lt=light.getLightType();
    if (lt == Light.DIRECTIONAL_LIGHT) {
      Vector3 forward=light.getForward();
      lightPosTemp.set(-forward.x,-forward.y,-forward.z,0);
    }
 else {
      lightPosTemp.set(light.getPosition(),1);
    }
    Matrix4.multiply(lightPos4,modelViewMatrix,lightPosTemp);
    GLES20.glUniform4f(GLES20.glGetUniformLocation(program,""String_Node_Str"" + i + ""String_Node_Str""),lightPos4.x,lightPos4.y,lightPos4.z,lt);
    Color3 color=light.getColor();
    GLES20.glUniform4f(GLES20.glGetUniformLocation(program,""String_Node_Str"" + i + ""String_Node_Str""),color.r,color.g,color.b,1);
    GLES20.glUniform1f(GLES20.glGetUniformLocation(program,""String_Node_Str"" + i + ""String_Node_Str""),light.getRange());
    GLES20.glUniform1f(GLES20.glGetUniformLocation(program,""String_Node_Str"" + i + ""String_Node_Str""),light.getIntensity());
  }
}","private void setLightUniform(int program,ArrayList<Light> lights){
  int lightCount=lights.size();
  GLES20.glUniform1f(GLES20.glGetUniformLocation(program,""String_Node_Str""),lightCount);
  for (int i=0; i < lightCount; i++) {
    Light light=lights.get(i);
    Matrix4 world=light.getWorldMatrix();
    int lt=light.getLightType();
    if (lt == Light.DIRECTIONAL_LIGHT) {
      Vector3 forward=world.getForward();
      lightPosTemp.set(-forward.x,-forward.y,-forward.z,0);
    }
 else {
      lightPosTemp.set(world.getTranslation(),1);
    }
    Matrix4.multiply(lightPos4,modelViewMatrix,lightPosTemp);
    GLES20.glUniform4f(GLES20.glGetUniformLocation(program,""String_Node_Str"" + i + ""String_Node_Str""),lightPos4.x,lightPos4.y,lightPos4.z,lt);
    Color3 color=light.getColor();
    GLES20.glUniform4f(GLES20.glGetUniformLocation(program,""String_Node_Str"" + i + ""String_Node_Str""),color.r,color.g,color.b,1);
    GLES20.glUniform1f(GLES20.glGetUniformLocation(program,""String_Node_Str"" + i + ""String_Node_Str""),light.getRange());
    GLES20.glUniform1f(GLES20.glGetUniformLocation(program,""String_Node_Str"" + i + ""String_Node_Str""),light.getIntensity());
  }
}",0.9646133682830932
99119,"public void onInitialize(){
  long start=System.nanoTime();
  model1=GameObjectManager.loadModel(""String_Node_Str"");
  terrain=GameObjectManager.createTerrain(""String_Node_Str"",60,500);
  terrain.setBaseTexture(GameObjectManager.loadTexture2D(""String_Node_Str""));
  keyLight=new Light();
  keyLight.setForward(-1,-1,-1);
  keyLight.setIntensity(1);
  backLight=new Light();
  backLight.setIntensity(3);
  fillLight=new Light();
  fillLight.setForward(-1,0,-0.45f);
  fillLight.setIntensity(1.4f);
  pointLight=new Light(Light.POINT_LIGHT,50,1.2f);
  pointLight.setLightType(Light.POINT_LIGHT);
  pointLight.setPosition(250,250,80);
  camera=Scene.getMainCamera();
  camera.setPosition(350,350,100);
  camera.setLookAt(new Vector3(250,250,0));
  camera.setProjectionType(Camera.PERSPECTIVE);
  camera.setRange(1000);
  Animation animation1=model1.getAnimation();
  AnimationClip idle1=animation1.getAnimationClip(""String_Node_Str"");
  animation1.play(""String_Node_Str"");
  idle1.setPlaybackMode(PlaybackMode.LOOP);
  idle1.setStart(35);
  idle1.setEnd(50);
  model1.setPosition(250,250,40);
  addLayer(layer1);
  layer1.addChild(model1,camera,keyLight,fillLight,backLight,terrain);
  view1=GameObjectManager.createImageView(""String_Node_Str"");
  layer2.addChild(view1);
  float end=(System.nanoTime() - start) / 1000000f;
  log(""String_Node_Str"" + end + ""String_Node_Str"");
}","public void onInitialize(){
  long start=System.nanoTime();
  model1=GameObjectManager.loadModel(""String_Node_Str"");
  terrain=GameObjectManager.createTerrain(""String_Node_Str"",60,500);
  terrain.setBaseTexture(GameObjectManager.loadTexture2D(""String_Node_Str""));
  keyLight=new Light();
  keyLight.setForward(-1,-1,-1);
  keyLight.setIntensity(1);
  backLight=new Light();
  backLight.setIntensity(3);
  fillLight=new Light();
  fillLight.setForward(-1,0,-0.45f);
  fillLight.setIntensity(1.4f);
  pointLight1=new Light(Light.POINT_LIGHT,40,2f,1,0,0);
  pointLight1.setPosition(-100,0,30);
  pointLight2=new Light(Light.POINT_LIGHT,40,2f,0,0,1);
  pointLight2.setPosition(100,0,30);
  camera=Scene.getMainCamera();
  camera.setPosition(350,350,100);
  camera.setLookAt(new Vector3(250,250,0));
  camera.setProjectionType(Camera.PERSPECTIVE);
  camera.setRange(1000);
  Animation animation1=model1.getAnimation();
  AnimationClip idle1=animation1.getAnimationClip(""String_Node_Str"");
  animation1.play(""String_Node_Str"");
  idle1.setPlaybackMode(PlaybackMode.LOOP);
  idle1.setStart(35);
  idle1.setEnd(50);
  model1.setPosition(250,250,40);
  model1.addChild(pointLight1,pointLight2);
  addLayer(layer1);
  layer1.addChild(model1,camera,keyLight,fillLight,backLight,terrain);
  view1=GameObjectManager.createImageView(""String_Node_Str"");
  layer2.addChild(view1);
  float end=(System.nanoTime() - start) / 1000000f;
  log(""String_Node_Str"" + end + ""String_Node_Str"");
}",0.9479606188466948
99120,"public void start(){
  createTerrainBuffer();
}","public void start(){
  createTerrainBuffer();
  Quad.createBuffer();
}",0.8034188034188035
99121,"private void drawImageView(ImageView view){
}","private void drawImageView(ImageView view){
  ShaderProgram shaderProgram=Shader.AMBIENT.getProgram(2);
  int program=shaderProgram.getProgramID();
  Vector2 position=view.getPosition();
  Vector2 scale=view.getScale();
  Matrix4 transformM=new Matrix4();
  Matrix4 mvp=Matrix4.multiply(orthogonalMVP,transformM);
  GLES20.glUseProgram(program);
  int vh=GLES20.glGetAttribLocation(program,""String_Node_Str"");
  int uvh=GLES20.glGetAttribLocation(program,""String_Node_Str"");
  float[] mvpm=new float[16];
  mvp.copyTo(mvpm);
  GLES20.glUniformMatrix4fv(GLES20.glGetUniformLocation(program,""String_Node_Str""),1,false,mvpm,0);
  GLES20.glEnableVertexAttribArray(vh);
  GLES20.glVertexAttribPointer(vh,2,GLES20.GL_FLOAT,false,0,Quad.getVertexBuffer());
  GLES20.glEnableVertexAttribArray(uvh);
  GLES20.glVertexAttribPointer(uvh,2,GLES20.GL_FLOAT,false,0,Quad.getUVBuffer());
  GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
  GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,view.getImageSrc().getTextureBuffer());
  GLES20.glUniform1i(GLES20.glGetUniformLocation(program,""String_Node_Str""),0);
  GLES20.glDrawElements(GLES20.GL_TRIANGLES,6,GLES20.GL_UNSIGNED_BYTE,Quad.getIndicesBuffer());
}",0.073469387755102
99122,"public void drawScene(){
  if (hasChangedProjection) {
    if (mainCamera.getProjectionType() == Camera.PERSPECTIVE) {
      Matrix4.createFrustum(projectionMatrix,-ratio,ratio,-1,1,1,mainCamera.getRange());
    }
 else {
      Matrix4.createOrtho(projectionMatrix,-ratio,ratio,-1,1,1,mainCamera.getRange());
    }
    hasChangedProjection=false;
  }
  if (hasChangedModelView) {
    Matrix4 world=mainCamera.getWorldMatrix();
    Vector3 eye=world.getTranslation();
    Vector3 forward=world.getForward();
    target.x=eye.x + (forward.x * 10);
    target.y=eye.y + (forward.y * 10);
    target.z=eye.z + (forward.z * 10);
    Vector3 up=world.getUp();
    Matrix4.createLookAt(modelViewMatrix,eye,target,up);
    hasChangedModelView=false;
  }
  Matrix4.multiply(modelViewProjectionMatrix,projectionMatrix,modelViewMatrix);
  for (int i=0; i < getLayerCount(); i++) {
    recursiveLayer(getLayer(i));
  }
  GLES20.glEnable(GLES20.GL_DEPTH_TEST);
  GLES20.glDisable(GLES20.GL_CULL_FACE);
  drawTerrains();
  GLES20.glEnable(GLES20.GL_CULL_FACE);
  for (int i=0; i < models.size(); i++) {
    drawModel(models.get(i));
  }
  for (int i=0; i < imageViews.size(); i++) {
    drawImageView(imageViews.get(i));
  }
  imageViews.clear();
  models.clear();
  terrains.clear();
  lights.clear();
  float end=(System.nanoTime() - start) / 1000000f;
  Log.d(""String_Node_Str"",(1000f / end) + ""String_Node_Str"");
  start=System.nanoTime();
}","public void drawScene(){
  if (hasChangedProjection) {
    if (mainCamera.getProjectionType() == Camera.PERSPECTIVE) {
      Matrix4.createFrustum(projectionMatrix,-ratio,ratio,-1,1,1,mainCamera.getRange());
    }
 else {
      Matrix4.createOrtho(projectionMatrix,-ratio,ratio,-1,1,1,mainCamera.getRange());
    }
    hasChangedProjection=false;
  }
  if (hasChangedModelView) {
    Matrix4 world=mainCamera.getWorldMatrix();
    Vector3 eye=world.getTranslation();
    Vector3 forward=world.getForward();
    target.x=eye.x + (forward.x * 10);
    target.y=eye.y + (forward.y * 10);
    target.z=eye.z + (forward.z * 10);
    Vector3 up=world.getUp();
    Matrix4.createLookAt(modelViewMatrix,eye,target,up);
    hasChangedModelView=false;
  }
  Matrix4.multiply(modelViewProjectionMatrix,projectionMatrix,modelViewMatrix);
  for (int i=0; i < getLayerCount(); i++) {
    recursiveLayer(getLayer(i));
  }
  GLES20.glEnable(GLES20.GL_DEPTH_TEST);
  GLES20.glDisable(GLES20.GL_CULL_FACE);
  GLES20.glEnable(GLES20.GL_CULL_FACE);
  for (int i=0; i < models.size(); i++) {
  }
  GLES20.glEnable(GLES20.GL_BLEND);
  GLES20.glBlendFunc(GLES20.GL_ONE,GLES20.GL_ONE_MINUS_SRC_ALPHA);
  for (int i=0; i < imageViews.size(); i++) {
    drawImageView(imageViews.get(i));
  }
  GLES20.glDisable(GLES20.GL_BLEND);
  imageViews.clear();
  models.clear();
  terrains.clear();
  lights.clear();
  float end=(System.nanoTime() - start) / 1000000f;
  Log.d(""String_Node_Str"",(1000f / end) + ""String_Node_Str"");
  start=System.nanoTime();
}",0.936357481381178
99123,"public static void onSurfaceChanged(){
  ratio=(float)Screen.getWidth() / Screen.getHeight();
  hasChangedProjection=true;
  Matrix4.createOrtho(orthogonalProjection,-ratio,ratio,-1,1,1,10);
  Matrix4.multiply(orthogonalMVP,orthogonalProjection,orthogonalModelView);
}","public static void onSurfaceChanged(){
  ratio=(float)Screen.getWidth() / Screen.getHeight();
  hasChangedProjection=true;
  Matrix4.createOrtho(orthogonalProjection,0,1,1,0,1,10);
  Matrix4.createLookAt(orthogonalModelView,0,0,1,0,0,0,0,1,0);
  Matrix4.multiply(orthogonalMVP,orthogonalProjection,orthogonalModelView);
  Log.e(""String_Node_Str"",orthogonalModelView.toString());
}",0.7746913580246914
99124,"private static Texture2D createTerrainNormalMap(Terrain terrain){
  int segment=Plane.getInstance().getSegment();
  IntBuffer normalmapTextureBuffer=ByteBuffer.allocateDirect(segment * segment * 4).order(ByteOrder.nativeOrder()).asIntBuffer();
  int[] frameBuffer=new int[1];
  int[] depthRenderBuffer=new int[1];
  int[] renderTextureBuffer=new int[1];
  IntBuffer textureBuffer;
  glGenFramebuffers(1,frameBuffer,0);
  glGenRenderbuffers(1,depthRenderBuffer,0);
  glGenTextures(1,renderTextureBuffer,0);
  glBindTexture(GL_TEXTURE_2D,renderTextureBuffer[0]);
  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_CLAMP_TO_EDGE);
  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_CLAMP_TO_EDGE);
  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
  int[] buf=new int[segment * segment];
  textureBuffer=ByteBuffer.allocateDirect(buf.length * 4).order(ByteOrder.nativeOrder()).asIntBuffer();
  glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA,segment,segment,0,GL_RGBA,GL_UNSIGNED_BYTE,textureBuffer);
  glGenerateMipmap(GL_TEXTURE_2D);
  glBindRenderbuffer(GL_RENDERBUFFER,depthRenderBuffer[0]);
  glRenderbufferStorage(GL_RENDERBUFFER,GL_DEPTH_COMPONENT16,segment,segment);
  glFramebufferTexture2D(GL_FRAMEBUFFER,GL_COLOR_ATTACHMENT0,GL_TEXTURE_2D,renderTextureBuffer[0],0);
  glFramebufferRenderbuffer(GL_FRAMEBUFFER,GL_DEPTH_ATTACHMENT,GL_RENDERBUFFER,depthRenderBuffer[0]);
  float[] projection=new float[16];
  float[] modelView=new float[16];
  int scale=terrain.getTerrainScale();
  int height=terrain.getTerrainMaxHeight();
  Matrix.orthoM(projection,0,0,scale,-scale,0,1,height * 2);
  Matrix.setLookAtM(modelView,0,0,height * 2,0,0,0,0,0,0,-1);
  glViewport(0,0,segment,segment);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  ShaderProgram sprogram=Shader.AMBIENT.getProgram(7);
  int program=sprogram.getProgramID();
  glUseProgram(program);
  int vertex_handle=glGetAttribLocation(program,""String_Node_Str"");
  int modelview_handle=glGetUniformLocation(program,""String_Node_Str"");
  int projection_handle=glGetUniformLocation(program,""String_Node_Str"");
  int heightmap_handle=glGetUniformLocation(program,""String_Node_Str"");
  int terrainData_handle=glGetUniformLocation(program,""String_Node_Str"");
  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D,terrain.getHeightmap().getTextureBuffer());
  glUniform1i(heightmap_handle,0);
  glUniform3f(terrainData_handle,height,segment,scale);
  glUniformMatrix4fv(modelview_handle,1,false,modelView,0);
  glUniformMatrix4fv(projection_handle,1,false,projection,0);
  glBindBuffer(GL_ARRAY_BUFFER,instance.terrainBuffers[0]);
  glEnableVertexAttribArray(vertex_handle);
  glVertexAttribPointer(vertex_handle,2,GL_FLOAT,false,0,0);
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,instance.terrainBuffers[1]);
  glDrawElements(GL_TRIANGLES,Plane.getInstance().getIndicesCount(),GL_UNSIGNED_INT,0);
  glBindBuffer(GL_ARRAY_BUFFER,0);
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,0);
  glDisableVertexAttribArray(vertex_handle);
  glBindFramebuffer(GL_FRAMEBUFFER,0);
  glFramebufferTexture2D(GL_FRAMEBUFFER,GL_COLOR_ATTACHMENT0,GL_TEXTURE_2D,renderTextureBuffer[0],0);
  glFramebufferRenderbuffer(GL_FRAMEBUFFER,GL_DEPTH_ATTACHMENT,GL_RENDERBUFFER,depthRenderBuffer[0]);
  glReadPixels(0,0,segment,segment,GL_RGBA,GL_UNSIGNED_BYTE,normalmapTextureBuffer);
  glBindFramebuffer(GL_FRAMEBUFFER,0);
  int[] pixels=new int[normalmapTextureBuffer.capacity()];
  for (int i=0; i < normalmapTextureBuffer.capacity(); i++) {
    pixels[i]=normalmapTextureBuffer.get(i);
  }
  Bitmap bitmap=Bitmap.createBitmap(pixels,segment,segment,Config.RGB_565);
  Texture2D normalmap=new Texture2D(""String_Node_Str"",renderTextureBuffer[0],pixels,segment,segment);
  String key=""String_Node_Str"" + terrain.hashCode();
  instance.texturesList.put(key,normalmap);
  instance.bitmapList.put(key,bitmap);
  return normalmap;
}","private static Texture2D createTerrainNormalMap(Terrain terrain){
  int segment=Plane.getInstance().getSegment();
  IntBuffer normalmapTextureBuffer=ByteBuffer.allocateDirect(segment * segment * 4).order(ByteOrder.nativeOrder()).asIntBuffer();
  int[] frameBuffer=new int[1];
  int[] depthRenderBuffer=new int[1];
  int[] renderTextureBuffer=new int[1];
  IntBuffer textureBuffer;
  glGenFramebuffers(1,frameBuffer,0);
  glGenRenderbuffers(1,depthRenderBuffer,0);
  glGenTextures(1,renderTextureBuffer,0);
  glBindTexture(GL_TEXTURE_2D,renderTextureBuffer[0]);
  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_CLAMP_TO_EDGE);
  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_CLAMP_TO_EDGE);
  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
  int[] buf=new int[segment * segment];
  textureBuffer=ByteBuffer.allocateDirect(buf.length * 4).order(ByteOrder.nativeOrder()).asIntBuffer();
  glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA,segment,segment,0,GL_RGBA,GL_UNSIGNED_BYTE,textureBuffer);
  glGenerateMipmap(GL_TEXTURE_2D);
  glBindRenderbuffer(GL_RENDERBUFFER,depthRenderBuffer[0]);
  glRenderbufferStorage(GL_RENDERBUFFER,GL_DEPTH_COMPONENT16,segment,segment);
  glBindFramebuffer(GL_FRAMEBUFFER,frameBuffer[0]);
  glFramebufferTexture2D(GL_FRAMEBUFFER,GL_COLOR_ATTACHMENT0,GL_TEXTURE_2D,renderTextureBuffer[0],0);
  glFramebufferRenderbuffer(GL_FRAMEBUFFER,GL_DEPTH_ATTACHMENT,GL_RENDERBUFFER,depthRenderBuffer[0]);
  float[] projection=new float[16];
  float[] modelView=new float[16];
  float[] mvp=new float[16];
  int scale=terrain.getTerrainScale();
  int height=terrain.getTerrainMaxHeight();
  Matrix.orthoM(projection,0,0,segment,0,segment,1,10);
  Matrix.setLookAtM(modelView,0,0,0,1,0,0,0,0,1,0);
  Matrix.multiplyMM(mvp,0,projection,0,modelView,0);
  glViewport(0,0,segment,segment);
  glClearColor(0.3f,0.6f,0.9f,1);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  ShaderProgram sprogram=Shader.AMBIENT.getProgram(7);
  int program=sprogram.getProgramID();
  glUseProgram(program);
  int vertex_handle=glGetAttribLocation(program,""String_Node_Str"");
  int mvp_handle=glGetUniformLocation(program,""String_Node_Str"");
  int heightmap_handle=glGetUniformLocation(program,""String_Node_Str"");
  int terrainData_handle=glGetUniformLocation(program,""String_Node_Str"");
  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D,terrain.getHeightmap().getTextureBuffer());
  glUniform1i(heightmap_handle,0);
  glUniform3f(terrainData_handle,height,segment,scale);
  glUniformMatrix4fv(mvp_handle,1,false,mvp,0);
  glBindBuffer(GL_ARRAY_BUFFER,instance.terrainBuffers[0]);
  glEnableVertexAttribArray(vertex_handle);
  glVertexAttribPointer(vertex_handle,2,GL_FLOAT,false,0,0);
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,instance.terrainBuffers[1]);
  glDrawElements(GL_TRIANGLES,Plane.getInstance().getIndicesCount(),GL_UNSIGNED_INT,0);
  glBindBuffer(GL_ARRAY_BUFFER,0);
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,0);
  glDisableVertexAttribArray(vertex_handle);
  glBindFramebuffer(GL_FRAMEBUFFER,0);
  glBindFramebuffer(GL_FRAMEBUFFER,frameBuffer[0]);
  glFramebufferTexture2D(GL_FRAMEBUFFER,GL_COLOR_ATTACHMENT0,GL_TEXTURE_2D,renderTextureBuffer[0],0);
  glFramebufferRenderbuffer(GL_FRAMEBUFFER,GL_DEPTH_ATTACHMENT,GL_RENDERBUFFER,depthRenderBuffer[0]);
  glReadPixels(0,0,segment,segment,GL_RGBA,GL_UNSIGNED_BYTE,normalmapTextureBuffer);
  glBindFramebuffer(GL_FRAMEBUFFER,0);
  int[] pixels=new int[normalmapTextureBuffer.capacity()];
  for (int i=0; i < normalmapTextureBuffer.capacity(); i++) {
    pixels[i]=normalmapTextureBuffer.get(i);
  }
  Bitmap bitmap=Bitmap.createBitmap(pixels,segment,segment,Config.RGB_565);
  Texture2D normalmap=new Texture2D(""String_Node_Str"",renderTextureBuffer[0],pixels,segment,segment);
  String key=""String_Node_Str"" + terrain.hashCode();
  instance.texturesList.put(key,normalmap);
  instance.bitmapList.put(key,bitmap);
  return normalmap;
}",0.9186252211271164
99125,"private void drawTerrain(int program,Terrain terrain){
  tempTransformMatrix.setIdentity();
  tempTransformMatrix.setTranslation(terrain.localTranslation);
  Matrix4 transformMatrix=Matrix4.multiply(modelViewMatrix,tempTransformMatrix);
  Matrix3.createNormalMatrix(tempNormalMatrix,tempMV);
  float[] tm=new float[16];
  projectionMatrix.copyTo(tm);
  GLES20.glUniformMatrix4fv(GLES20.glGetUniformLocation(program,""String_Node_Str""),1,false,tm,0);
  transformMatrix.copyTo(tm);
  GLES20.glUniformMatrix4fv(GLES20.glGetUniformLocation(program,""String_Node_Str""),1,false,tm,0);
  tempNormalMatrix.copyTo(tm);
  GLES20.glUniformMatrix3fv(GLES20.glGetUniformLocation(program,""String_Node_Str""),1,false,tm,0);
  int vh=GLES20.glGetAttribLocation(program,""String_Node_Str"");
  GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER,Terrain.getTerrainBuffer(0));
  GLES20.glEnableVertexAttribArray(vh);
  GLES20.glVertexAttribPointer(vh,2,GLES20.GL_FLOAT,false,0,0);
  GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
  GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,terrain.getBaseTexture().getTextureBuffer());
  GLES20.glUniform1i(GLES20.glGetUniformLocation(program,""String_Node_Str""),0);
  GLES20.glActiveTexture(GLES20.GL_TEXTURE1);
  GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,terrain.getHeightmap().getTextureBuffer());
  GLES20.glUniform1i(GLES20.glGetUniformLocation(program,""String_Node_Str""),1);
  GLES20.glActiveTexture(GLES20.GL_TEXTURE2);
  GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,terrain.getNormalmap().getTextureBuffer());
  GLES20.glUniform1i(GLES20.glGetUniformLocation(program,""String_Node_Str""),2);
  GLES20.glUniform3f(GLES20.glGetUniformLocation(program,""String_Node_Str""),terrain.getTerrainMaxHeight(),Plane.getInstance().getSegment(),terrain.getTerrainScale());
  GLES20.glBindBuffer(GLES20.GL_ELEMENT_ARRAY_BUFFER,Terrain.getTerrainBuffer(1));
  GLES20.glDrawElements(GLES20.GL_TRIANGLES,Plane.getInstance().getIndicesCount(),GLES20.GL_UNSIGNED_INT,0);
  GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER,0);
  GLES20.glBindBuffer(GLES20.GL_ELEMENT_ARRAY_BUFFER,0);
  GLES20.glDisableVertexAttribArray(vh);
}","private void drawTerrain(int program,Terrain terrain){
  tempTransformMatrix.setIdentity();
  tempTransformMatrix.setTranslation(terrain.localTranslation);
  Matrix4 transformMatrix=Matrix4.multiply(modelViewMatrix,tempTransformMatrix);
  Matrix3.createNormalMatrix(tempNormalMatrix,tempMV);
  GLES20.glUseProgram(program);
  ArrayList<Light> ls=new ArrayList<Light>();
  ls.addAll(lights);
  setLightUniform(program,ls);
  float[] tm=new float[16];
  projectionMatrix.copyTo(tm);
  GLES20.glUniformMatrix4fv(GLES20.glGetUniformLocation(program,""String_Node_Str""),1,false,tm,0);
  float[] tm1=new float[16];
  transformMatrix.copyTo(tm1);
  GLES20.glUniformMatrix4fv(GLES20.glGetUniformLocation(program,""String_Node_Str""),1,false,tm1,0);
  float[] tm2=new float[9];
  tempNormalMatrix.copyTo(tm2);
  GLES20.glUniformMatrix3fv(GLES20.glGetUniformLocation(program,""String_Node_Str""),1,false,tm2,0);
  int vh=GLES20.glGetAttribLocation(program,""String_Node_Str"");
  GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER,Terrain.getTerrainBuffer(0));
  GLES20.glEnableVertexAttribArray(vh);
  GLES20.glVertexAttribPointer(vh,2,GLES20.GL_FLOAT,false,0,0);
  GLES20.glEnable(GLES20.GL_TEXTURE_2D);
  GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
  GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,terrain.getBaseTexture().getTextureBuffer());
  GLES20.glUniform1i(GLES20.glGetUniformLocation(program,""String_Node_Str""),0);
  GLES20.glActiveTexture(GLES20.GL_TEXTURE1);
  GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,terrain.getNormalmap().getTextureBuffer());
  GLES20.glUniform1i(GLES20.glGetUniformLocation(program,""String_Node_Str""),1);
  GLES20.glActiveTexture(GLES20.GL_TEXTURE2);
  GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,terrain.getHeightmap().getTextureBuffer());
  GLES20.glUniform1i(GLES20.glGetUniformLocation(program,""String_Node_Str""),2);
  GLES20.glUniform3f(GLES20.glGetUniformLocation(program,""String_Node_Str""),terrain.getTerrainMaxHeight(),Plane.getInstance().getSegment(),terrain.getTerrainScale());
  GLES20.glBindBuffer(GLES20.GL_ELEMENT_ARRAY_BUFFER,Terrain.getTerrainBuffer(1));
  GLES20.glDrawElements(GLES20.GL_TRIANGLES,Plane.getInstance().getIndicesCount(),GLES20.GL_UNSIGNED_INT,0);
  GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER,0);
  GLES20.glBindBuffer(GLES20.GL_ELEMENT_ARRAY_BUFFER,0);
  GLES20.glDisableVertexAttribArray(vh);
}",0.940884476534296
99126,"private void drawTerrains(){
  ShaderProgram shaderProgram=Shader.DIFFUSE.getProgram(5);
  int program=shaderProgram.getProgramID();
  GLES20.glUseProgram(program);
  setLightUniform(program,lights);
  for (int i=0; i < terrains.size(); i++) {
    drawTerrain(program,terrains.get(i));
  }
}","private void drawTerrains(){
  ShaderProgram shaderProgram=Shader.DIFFUSE.getProgram(5);
  int program=shaderProgram.getProgramID();
  for (int i=0; i < terrains.size(); i++) {
    drawTerrain(program,terrains.get(i));
  }
}",0.8699029126213592
99127,"private static String[] getDiffuseSrc06(){
  String vs=matrixUniform + lightAttribute + vertexAttribute+ iDifVarying+ uvVarying+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ heightMap+ normalMap+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ initialUVCoordVarying+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ initialIDif+ lightLoop+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  return new String[]{vs,fsWithTexture};
}","private static String[] getDiffuseSrc06(){
  String vs=matrixUniform + lightAttribute + iDifVarying+ uvVarying+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ heightMap+ normalMap+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ initialUVCoordVarying+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ initialIDif+ lightLoop+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  return new String[]{vs,fsWithTexture};
}",0.9741750358680056
99128,"public void onInitialize(){
  long start=System.nanoTime();
  model1=GameObjectManager.loadModel(""String_Node_Str"");
  model2=GameObjectManager.loadModel(""String_Node_Str"");
  float end=(System.nanoTime() - start) / 1000000f;
  log(""String_Node_Str"" + end + ""String_Node_Str"");
  skylight=new Light();
  skylight.setForward(0,-1,0);
  camera=Scene.getMainCamera();
  camera.setPosition(100,120,100);
  camera.setLookAt(new Vector3());
  camera.setProjectionType(Camera.PERSPECTIVE);
  camera.setRange(1000);
  addLayer(layer1);
  layer1.addChild(model1);
  layer1.addChild(model2);
  layer1.addChild(camera);
  layer1.addChild(skylight);
  model1.getAnimation().getAnimationClip(""String_Node_Str"").setPlaybackMode(PlaybackMode.LOOP);
  model1.getAnimation().getAnimationClip(""String_Node_Str"").setStart(35);
  model1.getAnimation().getAnimationClip(""String_Node_Str"").setEnd(50);
  model1.getAnimation().play(""String_Node_Str"");
  model2.setPosition(80,0,0);
  model2.getAnimation().getAnimationClip(""String_Node_Str"").setPlaybackMode(PlaybackMode.LOOP);
  model2.getAnimation().getAnimationClip(""String_Node_Str"").setEnd(200);
  model2.getAnimation().play(""String_Node_Str"");
  terrain=GameObjectManager.createTerrain(""String_Node_Str"",50,400);
  terrain.setBaseTexture(GameObjectManager.loadTexture2D(""String_Node_Str""));
  layer1.addChild(terrain);
  view1=GameObjectManager.createImageView(""String_Node_Str"");
  layer2.addChild(view1);
}","public void onInitialize(){
  long start=System.nanoTime();
  model1=GameObjectManager.loadModel(""String_Node_Str"");
  model2=GameObjectManager.loadModel(""String_Node_Str"");
  float end=(System.nanoTime() - start) / 1000000f;
  log(""String_Node_Str"" + end + ""String_Node_Str"");
  skylight=new Light();
  skylight.setForward(0,-1,0);
  camera=Scene.getMainCamera();
  camera.setPosition(100,120,100);
  camera.setLookAt(new Vector3());
  camera.setProjectionType(Camera.PERSPECTIVE);
  camera.setRange(1000);
  addLayer(layer1);
  layer1.addChild(model1);
  layer1.addChild(model2);
  layer1.addChild(camera);
  layer1.addChild(skylight);
  model1.getAnimation().getAnimationClip(""String_Node_Str"").setPlaybackMode(PlaybackMode.LOOP);
  model1.getAnimation().getAnimationClip(""String_Node_Str"").setStart(35);
  model1.getAnimation().getAnimationClip(""String_Node_Str"").setEnd(50);
  model1.getAnimation().play(""String_Node_Str"");
  model2.setPosition(80,0,0);
  model2.getAnimation().getAnimationClip(""String_Node_Str"").setPlaybackMode(PlaybackMode.LOOP);
  model2.getAnimation().getAnimationClip(""String_Node_Str"").setEnd(200);
  model2.getAnimation().play(""String_Node_Str"");
  terrain=GameObjectManager.createTerrain(""String_Node_Str"",50,100);
  terrain.setBaseTexture(GameObjectManager.loadTexture2D(""String_Node_Str""));
  layer1.addChild(terrain);
  view1=GameObjectManager.createImageView(""String_Node_Str"");
  layer2.addChild(view1);
}",0.9993060374739764
99129,"public ImageIcon loadIcon(){
  ImageIcon icon=null;
  try {
    int widgetType=-1;
    String stockId=""String_Node_Str"";
    int direction=1;
    String detail=null;
    int iconSize=com.sun.java.swing.plaf.gtk.GTKConstants.IconSize.SMALL_TOOLBAR.ordinal();
    UNIXToolkit utk=(UNIXToolkit)Toolkit.getDefaultToolkit();
    BufferedImage img=utk.getStockIcon(widgetType,stockId,iconSize,direction,detail);
    icon=new ImageIcon(img);
  }
 catch (  NoClassDefFoundError e) {
  }
catch (  Exception e) {
  }
 finally {
  }
  return icon;
}","public ImageIcon loadIcon(){
  ImageIcon icon=null;
  return icon;
}",0.2244224422442244
99130,"@Override public boolean hasFlag(char flag){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","@Override public boolean hasFlag(char flag){
  return channelmodes.containsKey(flag);
}",0.6051282051282051
99131,"@Override public void removeFlag(char flag){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","@Override public void removeFlag(char flag){
  channelmodes.remove(flag);
}",0.6338797814207651
99132,"@Override public String flags(){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","@Override public String flags(){
  return StringUtils.joinIterable(channelmodes.keySet(),""String_Node_Str"");
}",0.6407766990291263
99133,"@Override public void addFlag(char flag){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","@Override public void addFlag(char flag,String param){
  channelmodes.put(flag,param);
}",0.5595854922279793
99134,"/** 
 * Sets the given flag.
 * @param flag The flag to set
 */
public void addFlag(char flag);","/** 
 * Sets the given flag.
 * @param flag The flag to set
 */
public void addFlag(char flag,String params);",0.931372549019608
99135,"private static void onPongCommand(Client client,String[] args){
  if (args.length == 0) {
    client.send(ERR_NEEDMOREPARAMS.format(client.getSafeNickname(),PONG,""String_Node_Str""));
    return;
  }
  client.updatePing(args[0]);
}","private static void onPongCommand(Client client,String[] args){
  if (args.length == 0) {
    client.send(ERR_NEEDMOREPARAMS.format(client.getSafeNickname(),PONG,""String_Node_Str""));
    return;
  }
  SharedData.logger.error(""String_Node_Str"" + Arrays.toString(args));
  client.updatePing(args[0]);
}",0.8679245283018868
99136,"private static void onOperCommand(Client client,String[] args){
  if (!client.registrationCompleted()) {
    return;
  }
  if (args.length < 2) {
    client.sendStandardFormat(Reply.ERR_NEEDMOREPARAMS.format(client.getSafeNickname(),OPER,""String_Node_Str""));
    return;
  }
  if (!matchesOLine(client.getHostname())) {
    client.sendStandardFormat(Reply.ERR_NOOPERHOST.format(client.getSafeNickname()));
    return;
  }
  try {
    if (!checkOperPassword(args[0],args[1])) {
      client.sendStandardFormat(Reply.ERR_PASSWDMISMATCH.format(client.getSafeNickname()));
      return;
    }
  }
 catch (  NoSuchAlgorithmException ex) {
    SharedData.logger.error(""String_Node_Str"",ex);
    client.sendNotice(getFirstConfigOption(HOST),client.getSafeNickname(),""String_Node_Str"");
    return;
  }
catch (  IncompleteConfigurationException ex) {
    client.sendNotice(getFirstConfigOption(HOST),client.getSafeNickname(),""String_Node_Str"" + args[0]);
    return;
  }
  client.sendStandardFormat(Reply.RPL_YOUREOPER.format(client.getSafeNickname()));
  client.addFlag(Mode.UMODE_OPER);
}","private static void onOperCommand(Client client,String[] args){
  if (!client.registrationCompleted()) {
    return;
  }
  if (args.length < 2) {
    client.sendStandardFormat(Reply.ERR_NEEDMOREPARAMS.format(client.getSafeNickname(),OPER,""String_Node_Str""));
    return;
  }
  if (!matchesOLine(client.getHostname())) {
    client.sendStandardFormat(Reply.ERR_NOOPERHOST.format(client.getSafeNickname()));
    return;
  }
  try {
    if (!checkOperPassword(args[0],args[1])) {
      client.sendStandardFormat(Reply.ERR_PASSWDMISMATCH.format(client.getSafeNickname()));
      return;
    }
  }
 catch (  NoSuchAlgorithmException ex) {
    SharedData.logger.error(""String_Node_Str"",ex);
    client.sendNotice(getFirstConfigOption(HOST),client.getSafeNickname(),""String_Node_Str"");
    return;
  }
catch (  IncompleteConfigurationException ex) {
    client.sendNotice(getFirstConfigOption(HOST),client.getSafeNickname(),""String_Node_Str"" + args[0]);
    return;
  }
  client.sendStandardFormat(Reply.RPL_YOUREOPER.format(client.getSafeNickname()));
  client.addFlag(Mode.UMODE_OPER,null);
}",0.9976947902259106
99137,"private static void onModeCommand(Client client,String[] args){
  if (!client.registrationCompleted()) {
    return;
  }
  if (args.length < 1 || args[0].length() < 1) {
    client.sendStandardFormat(Reply.ERR_NEEDMOREPARAMS.format(client.getSafeNickname(),MODE,""String_Node_Str""));
    return;
  }
  Flagable target=client;
  if (SharedData.isChanTypeSupported(args[0].charAt(0))) {
    target=SharedData.getChannel(args[0]);
    if (target == null) {
      client.sendStandardFormat(ERR_NOSUCHCHANNEL.format(client.getNickname(),args[0]));
      return;
    }
  }
  if (args.length == 1) {
    Mode.handleModeChange(Mode.NO_FLAG,client,client,true,args,0);
    return;
  }
  boolean adding=true;
  int argIndex=2;
  for (  char c : args[1].toCharArray()) {
    if (c == '+') {
      adding=true;
    }
 else     if (c == '-') {
      adding=false;
    }
 else {
      argIndex=Mode.handleModeChange(c,client,client,adding,args,argIndex);
    }
  }
}","private static void onModeCommand(Client client,String[] args){
  if (!client.registrationCompleted()) {
    return;
  }
  if (args.length < 1 || args[0].length() < 1) {
    client.sendStandardFormat(Reply.ERR_NEEDMOREPARAMS.format(client.getSafeNickname(),MODE,""String_Node_Str""));
    return;
  }
  Flagable target=client;
  if (SharedData.isChanTypeSupported(args[0].charAt(0))) {
    target=SharedData.getChannel(args[0]);
    if (target == null) {
      client.sendStandardFormat(ERR_NOSUCHCHANNEL.format(client.getNickname(),args[0]));
      return;
    }
  }
  if (args.length == 1) {
    Mode.handleModeChange(Mode.NO_FLAG,client,target,true,args,0);
    return;
  }
  boolean adding=true;
  int argIndex=2;
  for (  char c : args[1].toCharArray()) {
    if (c == '+') {
      adding=true;
    }
 else     if (c == '-') {
      adding=false;
    }
 else {
      argIndex=Mode.handleModeChange(c,client,client,adding,args,argIndex);
    }
  }
}",0.9947423764458464
99138,"private static void processUmodeInvisible(Flagable target,boolean adding){
  if (adding) {
    target.addFlag(UMODE_INVISIBLE);
  }
 else {
    target.removeFlag(UMODE_INVISIBLE);
  }
}","private static void processUmodeInvisible(Flagable target,boolean adding){
  if (adding) {
    target.addFlag(UMODE_INVISIBLE,null);
  }
 else {
    target.removeFlag(UMODE_INVISIBLE);
  }
}",0.9866666666666668
99139,"public static int handleModeChange(char mode,Client user,Flagable target,boolean adding,String[] args,int argIndex){
  if (target instanceof Client) {
    if (user != target && (!user.hasFlag(UMODE_OPER) || !SharedData.operCanSetModes)) {
      user.sendStandardFormat(Reply.ERR_USERSDONTMATCH.format(user.getNickname()));
      return argIndex;
    }
    if (mode == UMODE_OPER)     processUmodeOper(user,target,adding);
 else     if (mode == UMODE_INVISIBLE)     processUmodeInvisible(target,adding);
 else     if (mode == UMODE_REGISTERED)     processUmodeRegistered(user,target,adding);
 else     if (mode == NO_FLAG)     user.sendStandardFormat(Reply.RPL_UMODEIS.format(user.getNickname(),user.flags()));
 else {
      user.sendStandardFormat(Reply.ERR_UMODEUNKNOWNFLAG.format(user.getNickname(),mode));
    }
  }
 else   if (target instanceof Channel) {
    Channel chan=(Channel)target;
    if (!user.isInChannel(chan.getName()) && (!user.hasFlag(UMODE_OPER) || !SharedData.operCanSetModes)) {
      user.sendStandardFormat(Reply.ERR_NOTONCHANNEL.format(user.getNickname(),chan.getName()));
      return argIndex;
    }
  }
 else {
    SharedData.logger.error(""String_Node_Str"" + target + ""String_Node_Str"");
    for (    StackTraceElement trace : Thread.currentThread().getStackTrace()) {
      SharedData.logger.error(trace.toString());
    }
  }
  return argIndex;
}","public static int handleModeChange(char mode,Client user,Flagable target,boolean adding,String[] args,int argIndex){
  if (target instanceof Client) {
    if (user != target && (!user.hasFlag(UMODE_OPER) || !SharedData.operCanSetModes)) {
      user.sendStandardFormat(Reply.ERR_USERSDONTMATCH.format(user.getNickname()));
      return argIndex;
    }
    if (mode == UMODE_OPER)     processUmodeOper(user,target,adding);
 else     if (mode == UMODE_INVISIBLE)     processUmodeInvisible(target,adding);
 else     if (mode == UMODE_REGISTERED)     processUmodeRegistered(user,target,adding);
 else     if (mode == NO_FLAG)     user.sendStandardFormat(Reply.RPL_UMODEIS.format(user.getNickname(),user.flags()));
 else {
      user.sendStandardFormat(Reply.ERR_UMODEUNKNOWNFLAG.format(user.getNickname(),mode));
    }
  }
 else   if (target instanceof Channel) {
    Channel chan=(Channel)target;
    if (!user.isInChannel(chan.getName()) && (!user.hasFlag(UMODE_OPER) || !SharedData.operCanSetModes)) {
      user.sendStandardFormat(Reply.ERR_NOTONCHANNEL.format(user.getNickname(),chan.getName()));
      return argIndex;
    }
    if (mode == NO_FLAG)     user.sendStandardFormat(Reply.RPL_CHANNELMODEIS.format(user.getNickname(),chan.getName(),chan.flags(),chan.flagParams()));
  }
 else {
    SharedData.logger.error(""String_Node_Str"" + target + ""String_Node_Str"");
    for (    StackTraceElement trace : Thread.currentThread().getStackTrace()) {
      SharedData.logger.error(trace.toString());
    }
  }
  return argIndex;
}",0.9476584022038568
99140,"public String flags(){
  StringBuilder builder=new StringBuilder();
  for (  Character character : flags) {
    builder.append(character);
  }
  return builder.toString();
}","public String flags(){
  return StringUtils.joinIterable(flags.keySet(),""String_Node_Str"");
}",0.4586466165413533
99141,"public boolean hasFlag(char flag){
  return flags.contains(flag);
}","public boolean hasFlag(char flag){
  return flags.containsKey(flag);
}",0.978102189781022
99142,"@Override public void onInput(String input){
  SharedData.logger.trace(String.format(""String_Node_Str"",this,input));
  String[] fields=input.split(""String_Node_Str"",2);
  String[] toLastArg=(fields.length > 1) ? fields[1].split(""String_Node_Str"") : new String[0];
  String[] otherArgs=(toLastArg.length > 0) ? toLastArg[0].trim().split(""String_Node_Str"") : new String[0];
  String[] argsTotal=new String[otherArgs.length + ((toLastArg.length > 1) ? 1 : 0)];
  System.arraycopy(otherArgs,0,argsTotal,0,otherArgs.length);
  if (toLastArg.length > 1) {
    argsTotal[argsTotal.length - 1]=toLastArg[1];
  }
  SharedData.onClientCommand(this,fields[0],argsTotal);
}","@Override public void onInput(String input){
  SharedData.logger.debug(String.format(""String_Node_Str"" + this + ""String_Node_Str""+ input));
  String[] fields=input.split(""String_Node_Str"",2);
  String[] args;
  if (fields.length >= 2 && fields[1].trim().startsWith(""String_Node_Str"")) {
    args=new String[]{fields[1].trim().substring(1)};
  }
 else {
    String[] toLastArg=(fields.length > 1) ? fields[1].split(""String_Node_Str"") : new String[0];
    String[] otherArgs=(toLastArg.length > 0) ? toLastArg[0].trim().split(""String_Node_Str"") : new String[0];
    args=new String[otherArgs.length + ((toLastArg.length > 1) ? 1 : 0)];
    System.arraycopy(otherArgs,0,args,0,otherArgs.length);
    if (toLastArg.length > 1) {
      args[args.length - 1]=toLastArg[1];
    }
  }
  SharedData.onClientCommand(this,fields[0],args);
}",0.8093959731543624
99143,"public void addFlag(char flag){
  flags.add(flag);
  onModeChange();
}","public void addFlag(char flag,String mode){
  flags.put(flag,mode);
  onModeChange();
}",0.8535031847133758
99144,"public void onRegistrationComplete(){
  welcomeSent=true;
  addFlag(Mode.UMODE_INVISIBLE);
  sendStandardFormat(Reply.RPL_WELCOME.format(nickname,getHostmask()));
  sendStandardFormat(Reply.RPL_YOURHOST.format(nickname));
  sendStandardFormat(Reply.RPL_CREATED.format(nickname));
  sendStandardFormat(Reply.RPL_MYINFO.format(nickname));
  sendStandardFormat(Reply.RPL_ISUPPORT.format(nickname));
  sendStandardFormat(Reply.RPL_MOTDSTART.format(nickname));
  if (SharedData.motd != null) {
    for (    String part : SharedData.motd.split(""String_Node_Str"")) {
      sendStandardFormat(Reply.RPL_MOTD.format(nickname,part));
    }
  }
  sendStandardFormat(Reply.RPL_ENDOFMOTD.format(nickname));
}","public void onRegistrationComplete(){
  welcomeSent=true;
  addFlag(Mode.UMODE_INVISIBLE,null);
  sendStandardFormat(Reply.RPL_WELCOME.format(nickname,getHostmask()));
  sendStandardFormat(Reply.RPL_YOURHOST.format(nickname));
  sendStandardFormat(Reply.RPL_CREATED.format(nickname));
  sendStandardFormat(Reply.RPL_MYINFO.format(nickname));
  sendStandardFormat(Reply.RPL_ISUPPORT.format(nickname));
  sendStandardFormat(Reply.RPL_MOTDSTART.format(nickname));
  if (SharedData.motd != null) {
    for (    String part : SharedData.motd.split(""String_Node_Str"")) {
      sendStandardFormat(Reply.RPL_MOTD.format(nickname,part));
    }
  }
  sendStandardFormat(Reply.RPL_ENDOFMOTD.format(nickname));
}",0.996415770609319
99145,"/** 
 * Sends a message to the client
 * @param line The message to send
 */
public void send(String line){
  try {
    SharedData.logger.trace(String.format(""String_Node_Str"",socket.getInetAddress(),line));
    writer.write(String.format(""String_Node_Str"",line));
    writer.flush();
  }
 catch (  IOException ioe) {
    if (closed) {
      return;
    }
    SharedData.logger.error(String.format(""String_Node_Str"",socket.getInetAddress()),ioe);
    disconnect(ioe.getMessage());
  }
}","/** 
 * Sends a message to the client
 * @param line The message to send
 */
public void send(String line){
  try {
    SharedData.logger.debug(""String_Node_Str"" + this + ""String_Node_Str""+ line);
    writer.write(String.format(""String_Node_Str"",line));
    writer.flush();
  }
 catch (  IOException ioe) {
    if (closed) {
      return;
    }
    SharedData.logger.error(String.format(""String_Node_Str"",socket.getInetAddress()),ioe);
    disconnect(ioe.getMessage());
  }
}",0.9094693028095734
99146,"public Universe toUniverse(){
  System.out.println(Arrays.toString(universe.board));
  return universe;
}","public Universe toUniverse(){
  Universe universe=new Universe(rows,cols,board);
  System.out.println(Arrays.toString(universe.board));
  return universe;
}",0.8045977011494253
99147,"public RLEDecoder(String specification){
  xFillCounter=0;
  yFillCounter=0;
  StringTokenizer lineTokenizer=new StringTokenizer(specification,""String_Node_Str"");
  String headerline=""String_Node_Str"";
  while (!headerline.contains(""String_Node_Str"") || !headerline.contains(""String_Node_Str"")) {
    headerline=lineTokenizer.nextToken();
  }
  StringTokenizer headerlineTokenizer=new StringTokenizer(headerline,""String_Node_Str"");
  int cols=Integer.parseInt(headerlineTokenizer.nextToken().replaceAll(""String_Node_Str"",""String_Node_Str""));
  int rows=Integer.parseInt(headerlineTokenizer.nextToken().replaceAll(""String_Node_Str"",""String_Node_Str""));
  int[][] board=new int[rows][cols];
  String pattern=""String_Node_Str"";
  while (lineTokenizer.hasMoreTokens()) {
    pattern+=lineTokenizer.nextToken();
  }
  pattern.replaceAll(""String_Node_Str"",""String_Node_Str"");
  int characters=pattern.length();
  String repeatDigitBuffer=""String_Node_Str"";
  int repeatCounter=0;
  commandType CT=commandType.NORMAL;
  for (int c=0; c < characters; c++) {
    char newChar=pattern.charAt(c);
    if (CT == commandType.NORMAL) {
      if (Character.isDigit(newChar)) {
        repeatDigitBuffer+=newChar;
        CT=commandType.REPEAT;
      }
 else       if (newChar == 'o') {
        setCell(true);
      }
 else       if (newChar == 'b') {
        setCell(false);
      }
 else       if (newChar == '$' || newChar == '!') {
        setDeadUntilNewline();
      }
    }
 else     if (CT == commandType.REPEAT) {
      if (Character.isDigit(newChar)) {
        repeatDigitBuffer+=newChar;
      }
 else       if (newChar == 'o') {
        repeatCounter=Integer.parseInt(repeatDigitBuffer);
        for (int r=0; r < repeatCounter; r++) {
          setCell(true);
        }
        CT=commandType.NORMAL;
      }
 else       if (newChar == 'b') {
        repeatCounter=Integer.parseInt(repeatDigitBuffer);
        for (int r=0; r < repeatCounter; r++) {
          setCell(false);
        }
        CT=commandType.NORMAL;
      }
    }
  }
}","public RLEDecoder(String specification){
  xFillCounter=0;
  yFillCounter=0;
  StringTokenizer lineTokenizer=new StringTokenizer(specification,""String_Node_Str"");
  String headerline=""String_Node_Str"";
  while (!headerline.contains(""String_Node_Str"") || !headerline.contains(""String_Node_Str"")) {
    headerline=lineTokenizer.nextToken();
  }
  StringTokenizer headerlineTokenizer=new StringTokenizer(headerline,""String_Node_Str"");
  cols=Integer.parseInt(headerlineTokenizer.nextToken().replaceAll(""String_Node_Str"",""String_Node_Str""));
  rows=Integer.parseInt(headerlineTokenizer.nextToken().replaceAll(""String_Node_Str"",""String_Node_Str""));
  board=new int[rows][cols];
  String pattern=""String_Node_Str"";
  while (lineTokenizer.hasMoreTokens()) {
    pattern+=lineTokenizer.nextToken();
  }
  pattern.replaceAll(""String_Node_Str"",""String_Node_Str"");
  int characters=pattern.length();
  String repeatDigitBuffer=""String_Node_Str"";
  int repeatCounter=0;
  commandType CT=commandType.NORMAL;
  for (int c=0; c < characters; c++) {
    char newChar=pattern.charAt(c);
    if (CT == commandType.NORMAL) {
      if (Character.isDigit(newChar)) {
        repeatDigitBuffer+=newChar;
        CT=commandType.REPEAT;
      }
 else       if (newChar == 'o') {
        setCell(true);
      }
 else       if (newChar == 'b') {
        setCell(false);
      }
 else       if (newChar == '$' || newChar == '!') {
        setDeadUntilNewline();
      }
    }
 else     if (CT == commandType.REPEAT) {
      if (Character.isDigit(newChar)) {
        repeatDigitBuffer+=newChar;
      }
 else       if (newChar == 'o') {
        repeatCounter=Integer.parseInt(repeatDigitBuffer);
        repeatDigitBuffer=""String_Node_Str"";
        for (int r=0; r < repeatCounter; r++) {
          setCell(true);
        }
        CT=commandType.NORMAL;
      }
 else       if (newChar == 'b') {
        repeatCounter=Integer.parseInt(repeatDigitBuffer);
        repeatDigitBuffer=""String_Node_Str"";
        for (int r=0; r < repeatCounter; r++) {
          setCell(false);
        }
        CT=commandType.NORMAL;
      }
    }
  }
}",0.9743961352657003
99148,"private void setDeadUntilNewline(){
  while (xFillCounter < universe.cols) {
    universe.board[xFillCounter][yFillCounter]=0;
    xFillCounter++;
  }
  yFillCounter++;
}","private void setDeadUntilNewline(){
  while (xFillCounter < cols) {
    board[yFillCounter][xFillCounter]=0;
    xFillCounter++;
  }
  xFillCounter=0;
  yFillCounter++;
}",0.8823529411764706
99149,"private void setCell(boolean state){
  int mark;
  if (state)   mark=1;
 else   mark=0;
  universe.board[xFillCounter][yFillCounter]=mark;
  xFillCounter++;
  if (xFillCounter >= universe.cols) {
    xFillCounter=0;
    yFillCounter++;
  }
}","private void setCell(boolean state){
  int mark;
  if (state)   mark=1;
 else   mark=0;
  board[yFillCounter][xFillCounter]=mark;
  xFillCounter++;
}",0.7538461538461538
99150,"public RaySpace(Universe u){
  universe=u;
  tiles=new SpaceTile[u.rows][u.cols];
  for (int i=0; i < u.rows; i++) {
    for (int j=0; j < u.cols; j++) {
      SpaceVector p0=planeMapping(i,j);
      SpaceVector pA=planeMapping(i,j);
      SpaceVector pB=planeMapping(i,j);
      tiles[i][j]=new SpaceTile(p0,pA,pB);
    }
  }
}","public RaySpace(Universe u){
  universe=u;
  tiles=new SpaceTile[u.rows][u.cols];
  for (int i=0; i < u.rows; i++) {
    for (int j=0; j < u.cols; j++) {
      SpaceVector p0=planeMapping(i,j);
      SpaceVector pA=planeMapping(i + 1,j);
      SpaceVector pB=planeMapping(i,j + 1);
      tiles[i][j]=new SpaceTile(p0,pA,pB);
    }
  }
}",0.9879518072289156
99151,"public RayPixel castRay(SpaceVector cameraAt,SpaceVector cameraDir){
  float closest_t=Float.POSITIVE_INFINITY;
  RayPixel hit=new RayPixel();
  float t;
  boolean inside;
  for (int i=0; i < universe.rows; i++) {
    for (int j=0; j < universe.rows; j++) {
      t=intersection_t(cameraAt,cameraDir,tiles[i][j]);
      System.out.println(t + ""String_Node_Str"" + i+ ""String_Node_Str""+ j);
      if (t < 0)       break;
 else       if (t > closest_t)       break;
      inside=inTile(cameraAt.plus(cameraDir.scale(t)),tiles[i][j]);
      if (!inside)       break;
 else {
        closest_t=t;
        hit=new RayPixel(i,j);
      }
    }
  }
  return hit;
}","public RayPixel castRay(SpaceVector cameraAt,SpaceVector cameraDir){
  float closest_t=Float.POSITIVE_INFINITY;
  RayPixel hit=new RayPixel();
  float t;
  boolean inside;
  for (int i=0; i < universe.rows; i++) {
    for (int j=0; j < universe.cols; j++) {
      System.out.println(j);
      t=intersection_t(cameraAt,cameraDir,tiles[i][j]);
      System.out.println(j);
      System.out.println(t + ""String_Node_Str"" + i+ ""String_Node_Str""+ j);
      if (t < 0)       break;
 else       if (t > closest_t)       break;
      inside=inTile(cameraAt.plus(cameraDir.scale(t)),tiles[i][j]);
      if (!inside)       break;
 else {
        closest_t=t;
        hit=new RayPixel(i,j);
      }
    }
  }
  return hit;
}",0.9532846715328468
99152,"public String perform(HttpServletRequest request){
  List<String> errors=new ArrayList<String>();
  request.setAttribute(""String_Node_Str"",errors);
  HttpSession session=request.getSession();
  User curUser=(User)session.getAttribute(""String_Node_Str"");
  if (curUser == null) {
    return ""String_Node_Str"";
  }
  try {
    int routeID;
    FavRouteForm form=formBeanFactory.create(request);
    errors.addAll(form.getValidationErrors());
    if (errors.size() != 0) {
      return ""String_Node_Str"";
    }
    routeID=Integer.parseInt(form.getRouteID());
    if (form.getAction().equals(""String_Node_Str"")) {
      favRouteDAO.delete(routeID);
    }
 else {
      FavRoute fav=new FavRoute();
      fav.setBid(routeID);
      fav.setUid(curUser.getId());
      if (favRouteDAO.hasFav(fav.getUid(),fav.getBid())) {
        errors.add(""String_Node_Str"");
        return ""String_Node_Str"";
      }
      favRouteDAO.createAutoIncrement(fav);
    }
    return ""String_Node_Str"";
  }
 catch (  RollbackException e) {
    errors.add(e.getMessage());
    return ""String_Node_Str"";
  }
catch (  NumberFormatException e) {
    errors.add(e.getMessage());
    return ""String_Node_Str"";
  }
catch (  FormBeanException e) {
    errors.add(e.getMessage());
    return ""String_Node_Str"";
  }
}","public String perform(HttpServletRequest request){
  List<String> errors=new ArrayList<String>();
  request.setAttribute(""String_Node_Str"",errors);
  HttpSession session=request.getSession();
  User curUser=(User)session.getAttribute(""String_Node_Str"");
  if (curUser == null) {
    return ""String_Node_Str"";
  }
  try {
    int routeID;
    FavRouteForm form=formBeanFactory.create(request);
    errors.addAll(form.getValidationErrors());
    if (errors.size() != 0) {
      return ""String_Node_Str"";
    }
    routeID=Integer.parseInt(form.getRouteID());
    if (form.getAction().equals(""String_Node_Str"")) {
      if (favRouteDAO.deleteByPair(curUser.getId(),routeID) == false) {
        errors.add(""String_Node_Str"");
        return ""String_Node_Str"";
      }
    }
 else {
      FavRoute fav=new FavRoute();
      fav.setBid(routeID);
      fav.setUid(curUser.getId());
      if (favRouteDAO.hasFav(fav.getUid(),fav.getBid())) {
        errors.add(""String_Node_Str"");
        return ""String_Node_Str"";
      }
      favRouteDAO.createAutoIncrement(fav);
    }
    return ""String_Node_Str"";
  }
 catch (  RollbackException e) {
    errors.add(e.getMessage());
    return ""String_Node_Str"";
  }
catch (  NumberFormatException e) {
    errors.add(e.getMessage());
    return ""String_Node_Str"";
  }
catch (  FormBeanException e) {
    errors.add(e.getMessage());
    return ""String_Node_Str"";
  }
}",0.9544776119402985
99153,"public String perform(HttpServletRequest request){
  int curStop=0;
  List<String> errors=new ArrayList<String>();
  request.setAttribute(""String_Node_Str"",errors);
  List<FeedEntry> nearReports=new ArrayList<FeedEntry>();
  request.setAttribute(""String_Node_Str"",nearReports);
  request.setAttribute(""String_Node_Str"",curStop);
  try {
    String routeIDStr=request.getParameter(""String_Node_Str"");
    int routeID=1;
    if (routeIDStr != null) {
      routeID=Integer.parseInt(routeIDStr);
    }
    request.setAttribute(""String_Node_Str"",routeID);
    List<Stop> stopList=new ArrayList<Stop>();
    request.setAttribute(""String_Node_Str"",stopList);
    Route[] routeList=routeDAO.getRoutes();
    request.setAttribute(""String_Node_Str"",routeList);
    System.out.println(routeList.length);
    if (routeList != null && routeList.length > 0) {
      RouteStop[] rsList=routeStopDAO.readByBID(routeID);
      for (      RouteStop rs : rsList) {
        stopList.add(stopDAO.read(rs.getSid()));
      }
    }
    if (request.getParameterMap().containsKey(""String_Node_Str"") && request.getParameterMap().containsKey(""String_Node_Str"")) {
      int stopID=Integer.parseInt(request.getParameter(""String_Node_Str""));
      Stop s=stopDAO.read(stopID);
      Report[] near=reportDAO.readByDistance(routeID,s.getLatitude(),s.getLongitude(),MAX_DIST);
      for (      Report r : near) {
        nearReports.add(new FeedEntry(userDAO.read(r.getUid()),r,routeDAO.read(r.getBid())));
      }
      curStop=stopID;
    }
 else     if (request.getParameterMap().containsKey(""String_Node_Str"") && request.getParameterMap().size() == 1) {
    }
 else {
      LookupForm form=formBeanFactory.create(request);
      request.setAttribute(""String_Node_Str"",form);
      if (!form.isPresent()) {
        return ""String_Node_Str"";
      }
      RouteStop[] rsList=routeStopDAO.readByBID(routeID);
      float minDist=Float.MAX_VALUE;
      int minStopID=1;
      for (      RouteStop rs : rsList) {
        Stop s=stopDAO.read(rs.getSid());
        float dist=ReportDAO.distFrom(s.getLatitude(),s.getLongitude(),Float.parseFloat(form.getGeolat()),Float.parseFloat(form.getGeolong()));
        if (minDist > dist) {
          minDist=dist;
          minStopID=s.getId();
        }
      }
      Stop s=stopDAO.read(minStopID);
      curStop=s.getId();
      Report[] near=reportDAO.readByDistance(routeID,s.getLatitude(),s.getLongitude(),MAX_DIST);
      for (      Report r : near) {
        nearReports.add(new FeedEntry(userDAO.read(r.getUid()),r,routeDAO.read(r.getBid())));
      }
    }
    request.setAttribute(""String_Node_Str"",curStop);
    Collections.sort(nearReports,new Comparator<FeedEntry>(){
      public int compare(      FeedEntry item1,      FeedEntry item2){
        return item2.report.getTimestamp().compareTo(item1.report.getTimestamp());
      }
    }
);
    return (""String_Node_Str"");
  }
 catch (  RollbackException e) {
    errors.add(e.getMessage());
    return ""String_Node_Str"";
  }
catch (  FormBeanException e) {
    errors.add(e.getMessage());
    return ""String_Node_Str"";
  }
}","public String perform(HttpServletRequest request){
  int curStop=0;
  List<String> errors=new ArrayList<String>();
  request.setAttribute(""String_Node_Str"",errors);
  List<FeedEntry> nearReports=new ArrayList<FeedEntry>();
  request.setAttribute(""String_Node_Str"",nearReports);
  request.setAttribute(""String_Node_Str"",curStop);
  try {
    String routeIDStr=request.getParameter(""String_Node_Str"");
    int routeID=1;
    if (routeIDStr != null) {
      routeID=Integer.parseInt(routeIDStr);
    }
    request.setAttribute(""String_Node_Str"",routeID);
    List<Stop> stopList=new ArrayList<Stop>();
    request.setAttribute(""String_Node_Str"",stopList);
    Route[] routeList=routeDAO.getRoutes();
    request.setAttribute(""String_Node_Str"",routeList);
    if (routeList != null && routeList.length > 0) {
      RouteStop[] rsList=routeStopDAO.readByBID(routeID);
      for (      RouteStop rs : rsList) {
        stopList.add(stopDAO.read(rs.getSid()));
      }
    }
    if (request.getParameterMap().containsKey(""String_Node_Str"") && request.getParameterMap().containsKey(""String_Node_Str"")) {
      int stopID=Integer.parseInt(request.getParameter(""String_Node_Str""));
      Stop s=stopDAO.read(stopID);
      Report[] near=reportDAO.readByDistance(routeID,s.getLatitude(),s.getLongitude(),MAX_DIST);
      for (      Report r : near) {
        nearReports.add(new FeedEntry(userDAO.read(r.getUid()),r,routeDAO.read(r.getBid())));
      }
      curStop=stopID;
    }
 else     if (request.getParameterMap().containsKey(""String_Node_Str"") && request.getParameterMap().size() == 1) {
    }
 else {
      LookupForm form=formBeanFactory.create(request);
      request.setAttribute(""String_Node_Str"",form);
      if (!form.isPresent()) {
        return ""String_Node_Str"";
      }
      RouteStop[] rsList=routeStopDAO.readByBID(routeID);
      float minDist=Float.MAX_VALUE;
      int minStopID=1;
      for (      RouteStop rs : rsList) {
        Stop s=stopDAO.read(rs.getSid());
        float dist=ReportDAO.distFrom(s.getLatitude(),s.getLongitude(),Float.parseFloat(form.getGeolat()),Float.parseFloat(form.getGeolong()));
        if (minDist > dist) {
          minDist=dist;
          minStopID=s.getId();
        }
      }
      Stop s=stopDAO.read(minStopID);
      curStop=s.getId();
      Report[] near=reportDAO.readByDistance(routeID,s.getLatitude(),s.getLongitude(),MAX_DIST);
      for (      Report r : near) {
        nearReports.add(new FeedEntry(userDAO.read(r.getUid()),r,routeDAO.read(r.getBid())));
      }
    }
    request.setAttribute(""String_Node_Str"",curStop);
    Collections.sort(nearReports,new Comparator<FeedEntry>(){
      public int compare(      FeedEntry item1,      FeedEntry item2){
        return item2.report.getTimestamp().compareTo(item1.report.getTimestamp());
      }
    }
);
    return (""String_Node_Str"");
  }
 catch (  RollbackException e) {
    errors.add(e.getMessage());
    return ""String_Node_Str"";
  }
catch (  FormBeanException e) {
    errors.add(e.getMessage());
    return ""String_Node_Str"";
  }
}",0.9931662870159452
99154,"public List<String> getValidationErrors(){
  List<String> errors=new ArrayList<String>();
  if (action == null) {
    errors.add(""String_Node_Str"");
    return errors;
  }
  if (!action.equals(""String_Node_Str"") && !action.equals(""String_Node_Str"") && !action.equals(""String_Node_Str"")) {
    errors.add(""String_Node_Str"");
    return errors;
  }
  if (action.equals(""String_Node_Str"") || action.equals(""String_Node_Str"")) {
    if (reportID == null || reportID.length() == 0) {
      errors.add(""String_Node_Str"");
      return errors;
    }
    if (reportID.matches(""String_Node_Str"")) {
      errors.add(""String_Node_Str"");
    }
    if (!checkInt(reportID,errors)) {
      return errors;
    }
  }
 else {
    if (routeID == null || routeID.length() == 0) {
      errors.add(""String_Node_Str"");
      return errors;
    }
    if (!checkInt(routeID,errors)) {
      return errors;
    }
    if (!checkCoordinate(geolong,errors)) {
      return errors;
    }
    if (!checkCoordinate(geolat,errors)) {
      return errors;
    }
    if (!checkCoordinate(geoaccu,errors)) {
      return errors;
    }
    if (Float.parseFloat(geoaccu) > MAX_ACCU) {
      errors.add(""String_Node_Str"" + MAX_ACCU + ""String_Node_Str"");
      return errors;
    }
    if (comment != null && comment.matches(""String_Node_Str"")) {
      errors.add(""String_Node_Str"");
    }
  }
  return errors;
}","public List<String> getValidationErrors(){
  List<String> errors=new ArrayList<String>();
  if (action == null) {
    errors.add(""String_Node_Str"");
    return errors;
  }
  if (!action.equals(""String_Node_Str"") && !action.equals(""String_Node_Str"") && !action.equals(""String_Node_Str"")) {
    errors.add(""String_Node_Str"");
    return errors;
  }
  if (action.equals(""String_Node_Str"") || action.equals(""String_Node_Str"")) {
    if (reportID == null || reportID.length() == 0) {
      errors.add(""String_Node_Str"");
      return errors;
    }
    if (reportID.matches(""String_Node_Str"")) {
      errors.add(""String_Node_Str"");
    }
    if (!checkInt(reportID,errors)) {
      return errors;
    }
  }
 else {
    if (routeID == null || routeID.length() == 0) {
      errors.add(""String_Node_Str"");
      return errors;
    }
    if (!checkInt(routeID,errors)) {
      return errors;
    }
    if (!checkCoordinate(geolong,errors)) {
      return errors;
    }
    if (!checkCoordinate(geolat,errors)) {
      return errors;
    }
    if (!checkCoordinate(geoaccu,errors)) {
      return errors;
    }
    if (Float.parseFloat(geoaccu) > MAX_ACCU) {
      errors.add(""String_Node_Str"" + MAX_ACCU + ""String_Node_Str"");
      return errors;
    }
    if (comment != null && comment.matches(""String_Node_Str"")) {
      errors.add(""String_Node_Str"");
      return errors;
    }
    if (comment.length() > 140) {
      errors.add(""String_Node_Str"");
      return errors;
    }
  }
  return errors;
}",0.9417915650052284
99155,"public void showDialog(){
  setLocationRelativeTo(MainWindow.getMainWindow());
  setVisible(true);
}","public void showDialog(){
  pack();
  setLocationRelativeTo(MainWindow.getMainWindow());
  setVisible(true);
}",0.9523809523809524
99156,"public void onGameStageChanged(GameState gameState){
  if (gameState == GameState.FINISHED) {
    roundManager.setRound(roundManager.getRound() + 1);
  }
}","public void onGameStageChanged(GameState gameState){
  if (isFinishedOnce && gameState == GameState.WAIT_START_TIMER)   roundManager.setRound(roundManager.getRound() + 1);
 else   if (gameState == GameState.FINISHED)   isFinishedOnce=true;
}",0.4797979797979798
99157,"public void noOneAnswered(){
  answerStateManager.setAnswerState(AnswerState.NOBODY_ANSWERED);
  gameStateManager.setGameState(GameState.FINISHED);
  priceManager.setPrice(priceManager.getPrice() + 1);
}","public void noOneAnswered(){
  answerStateManager.setAnswerState(AnswerState.NOBODY_ANSWERED);
  priceManager.setPrice(priceManager.getPrice() + 1);
  gameStateManager.setGameState(GameState.FINISHED);
}",0.7339901477832512
99158,"private MaxRoundController(){
  roundManager.addListener(this);
}","private MaxRoundController(){
  gameStateManager.addListener(this);
}",0.8955223880597015
99159,"public void setFalseStart(){
  answerStateManager.setAnswerState(AnswerState.ONE_ANSWERED);
  gameStateManager.setGameState(GameState.RUNNING);
}","public void setFalseStart(){
  answerStateManager.setAnswerState(AnswerState.ONE_ANSWERED);
}",0.7815126050420168
99160,"public void answer(boolean isCorrect){
  if (isCorrect) {
switch (answerSideManager.getAnswerSide()) {
case LEFT:
      scoreManager.increaseLeftScore(priceManager.getPrice());
    break;
case RIGHT:
  scoreManager.increaseRightScore(priceManager.getPrice());
break;
}
priceManager.setPrice(1);
answerStateManager.setAnswerState(AnswerState.NOBODY_ANSWERED);
gameStateManager.setGameState(GameState.FINISHED);
setChanged();
notifyObservers();
}
 else {
switch (answerStateManager.getAnswerState()) {
case NOBODY_ANSWERED:
answerStateManager.setAnswerState(AnswerState.ONE_ANSWERED);
gameStateManager.setGameState(GameState.RUNNING);
break;
case ONE_ANSWERED:
noOneAnswered();
break;
}
}
}","public void answer(boolean isCorrect){
  if (isCorrect) {
switch (answerSideManager.getAnswerSide()) {
case LEFT:
      scoreManager.increaseLeftScore(priceManager.getPrice());
    break;
case RIGHT:
  scoreManager.increaseRightScore(priceManager.getPrice());
break;
}
priceManager.setPrice(1);
answerStateManager.setAnswerState(AnswerState.NOBODY_ANSWERED);
setChanged();
notifyObservers();
}
 else {
switch (answerStateManager.getAnswerState()) {
case NOBODY_ANSWERED:
answerStateManager.setAnswerState(AnswerState.ONE_ANSWERED);
break;
case ONE_ANSWERED:
noOneAnswered();
break;
}
}
}",0.9207843137254902
99161,"public void noOneAnswered(){
  answerStateManager.setAnswerState(AnswerState.NOBODY_ANSWERED);
  priceManager.setPrice(priceManager.getPrice() + 1);
  gameStateManager.setGameState(GameState.FINISHED);
}","public void noOneAnswered(){
  answerStateManager.setAnswerState(AnswerState.NOBODY_ANSWERED);
  priceManager.setPrice(priceManager.getPrice() + 1);
}",0.8498583569405099
99162,"public void actionPerformed(ActionEvent e){
  int time=timeManager.getTime();
  timeManager.setTime(time + TIMER_DELAY);
  if (!warnPlayed && time > WARN_TIME) {
    soundManager.playWarnSound();
    warnPlayed=true;
  }
  if (time > OVER_TIME) {
    soundManager.playOverSound();
    gameStateManager.setGameState(GameState.FINISHED);
    timeManager.setTime(OVER_TIME);
    scoreManager.noOneAnswered();
  }
}","public void actionPerformed(ActionEvent e){
  int time=timeManager.getTime();
  timeManager.setTime(time + TIMER_DELAY);
  if (!warnPlayed && time > WARN_TIME) {
    soundManager.playWarnSound();
    warnPlayed=true;
  }
  if (time > OVER_TIME) {
    soundManager.playOverSound();
    StateManager.getInstance().setState(new EndRound());
    Timer.getInstance().stop();
    timeManager.setTime(OVER_TIME);
  }
}",0.8467153284671532
99163,"public Timer(){
  timer=new javax.swing.Timer(TIMER_DELAY,new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      int time=timeManager.getTime();
      timeManager.setTime(time + TIMER_DELAY);
      if (!warnPlayed && time > WARN_TIME) {
        soundManager.playWarnSound();
        warnPlayed=true;
      }
      if (time > OVER_TIME) {
        soundManager.playOverSound();
        gameStateManager.setGameState(GameState.FINISHED);
        timeManager.setTime(OVER_TIME);
        scoreManager.noOneAnswered();
      }
    }
  }
);
}","public Timer(){
  timer=new javax.swing.Timer(TIMER_DELAY,new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      int time=timeManager.getTime();
      timeManager.setTime(time + TIMER_DELAY);
      if (!warnPlayed && time > WARN_TIME) {
        soundManager.playWarnSound();
        warnPlayed=true;
      }
      if (time > OVER_TIME) {
        soundManager.playOverSound();
        StateManager.getInstance().setState(new EndRound());
        Timer.getInstance().stop();
        timeManager.setTime(OVER_TIME);
      }
    }
  }
);
}",0.8803571428571428
99164,"public BrainPanelTest() throws HeadlessException {
  super();
  new Initializer();
  setDefaultCloseOperation(EXIT_ON_CLOSE);
  JLayeredPane layeredPane=new JLayeredPane();
  setLayeredPane(layeredPane);
  final BrainPanel brainPanel=new BrainPanel(this);
  layeredPane.add(brainPanel,JLayeredPane.DEFAULT_LAYER);
  layeredPane.addComponentListener(new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
      Component component=e.getComponent();
      brainPanel.setSize(component.getSize());
      brainPanel.validate();
    }
  }
);
  pack();
  Point centerPoint=GraphicsEnvironment.getLocalGraphicsEnvironment().getCenterPoint();
  setLocation(centerPoint.x - getWidth() / 2,centerPoint.y - getHeight() / 2);
  setVisible(true);
  setSize(800,600);
  KeyboardFocusManager.getCurrentKeyboardFocusManager().addKeyEventDispatcher(new KeyboardDispatcher());
  Toolkit.getDefaultToolkit().addAWTEventListener(new org.i4qwee.chgk.trainer.new_brain.actionlisteners.MouseListener(),AWTEvent.MOUSE_EVENT_MASK);
}","public BrainPanelTest() throws HeadlessException {
  super();
  setDefaultCloseOperation(EXIT_ON_CLOSE);
  JLayeredPane layeredPane=new JLayeredPane();
  setLayeredPane(layeredPane);
  final BrainPanel brainPanel=new BrainPanel(this);
  layeredPane.add(brainPanel,JLayeredPane.DEFAULT_LAYER);
  layeredPane.addComponentListener(new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
      Component component=e.getComponent();
      brainPanel.setSize(component.getSize());
      brainPanel.validate();
    }
  }
);
  pack();
  Point centerPoint=GraphicsEnvironment.getLocalGraphicsEnvironment().getCenterPoint();
  setLocation(centerPoint.x - getWidth() / 2,centerPoint.y - getHeight() / 2);
  setVisible(true);
  setSize(800,600);
  KeyboardFocusManager.getCurrentKeyboardFocusManager().addKeyEventDispatcher(new KeyboardDispatcher());
  Toolkit.getDefaultToolkit().addAWTEventListener(new org.i4qwee.chgk.trainer.new_brain.actionlisteners.MouseListener(),AWTEvent.MOUSE_EVENT_MASK);
}",0.9898305084745764
99165,"public void onRoundChanged(int round,int maxRound){
  if (round > maxRound) {
    String leftName=namesManager.getLeftName();
    if (leftName == null || leftName.equals(""String_Node_Str""))     leftName=""String_Node_Str"";
    String rightName=namesManager.getRightName();
    if (rightName == null || rightName.equals(""String_Node_Str""))     rightName=""String_Node_Str"";
    if (scoreManager.getLeftScore() > scoreManager.getRightScore())     JOptionPane.showMessageDialog(JOptionPane.getRootFrame(),leftName + ""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE);
 else     if (scoreManager.getLeftScore() < scoreManager.getRightScore())     JOptionPane.showMessageDialog(JOptionPane.getRootFrame(),rightName + ""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE);
 else     JOptionPane.showMessageDialog(JOptionPane.getRootFrame(),""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE);
    ScoreManagerSingleton.getInstance().newGame();
  }
}","public void onRoundChanged(int round,int maxRound){
  if (maxRound != 0 && round > maxRound) {
    String leftName=namesManager.getLeftName();
    if (leftName == null || leftName.equals(""String_Node_Str""))     leftName=""String_Node_Str"";
    String rightName=namesManager.getRightName();
    if (rightName == null || rightName.equals(""String_Node_Str""))     rightName=""String_Node_Str"";
    if (scoreManager.getLeftScore() > scoreManager.getRightScore())     JOptionPane.showMessageDialog(JOptionPane.getRootFrame(),leftName + ""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE);
 else     if (scoreManager.getLeftScore() < scoreManager.getRightScore())     JOptionPane.showMessageDialog(JOptionPane.getRootFrame(),rightName + ""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE);
 else     JOptionPane.showMessageDialog(JOptionPane.getRootFrame(),""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE);
    ScoreManagerSingleton.getInstance().newGame();
  }
}",0.9913397860417728
99166,"public void onRoundChanged(int round,int maxRound){
  if (round > maxRound) {
    if (scoreManager.getLeftScore() > scoreManager.getRightScore())     JOptionPane.showMessageDialog(JOptionPane.getRootFrame(),namesManager.getLeftName() + ""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE);
 else     if (scoreManager.getLeftScore() < scoreManager.getRightScore())     JOptionPane.showMessageDialog(JOptionPane.getRootFrame(),namesManager.getRightName() + ""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE);
 else     JOptionPane.showMessageDialog(JOptionPane.getRootFrame(),""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE);
    ScoreManagerSingleton.getInstance().newGame();
  }
}","public void onRoundChanged(int round,int maxRound){
  if (round > maxRound) {
    String leftName=namesManager.getLeftName();
    if (leftName == null || leftName.equals(""String_Node_Str""))     leftName=""String_Node_Str"";
    String rightName=namesManager.getRightName();
    if (rightName == null || rightName.equals(""String_Node_Str""))     rightName=""String_Node_Str"";
    if (scoreManager.getLeftScore() > scoreManager.getRightScore())     JOptionPane.showMessageDialog(JOptionPane.getRootFrame(),leftName + ""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE);
 else     if (scoreManager.getLeftScore() < scoreManager.getRightScore())     JOptionPane.showMessageDialog(JOptionPane.getRootFrame(),rightName + ""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE);
 else     JOptionPane.showMessageDialog(JOptionPane.getRootFrame(),""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE);
    ScoreManagerSingleton.getInstance().newGame();
  }
}",0.7850799289520426
99167,"public void update(Observable o,Object arg){
  if (arg != null) {
    if (arg instanceof AnswerSide) {
switch ((AnswerSide)arg) {
case LEFT:
        selectSingleScorePanel(true);
      break;
case RIGHT:
    selectSingleScorePanel(false);
  break;
}
}
 else if (arg instanceof GameState) {
if (arg == GameState.FINISHED || arg == GameState.RUNNING) removeSelection();
}
 else if (arg instanceof NamesChangedEvent) {
setNames(((NamesChangedEvent)arg).getLeftName(),((NamesChangedEvent)arg).getRightName());
}
}
 else {
switch (ScoreManagerSingleton.getInstance().getAnswerSide()) {
case LEFT:
leftScorePanel.setScore(ScoreManagerSingleton.getInstance().getLeftScore());
break;
case RIGHT:
rightScorePanel.setScore(ScoreManagerSingleton.getInstance().getRightScore());
break;
}
}
}","public void update(Observable o,Object arg){
  if (arg != null) {
    if (arg instanceof AnswerSide) {
switch ((AnswerSide)arg) {
case LEFT:
        selectSingleScorePanel(true);
      break;
case RIGHT:
    selectSingleScorePanel(false);
  break;
}
}
 else if (arg instanceof GameState) {
if (arg == GameState.FINISHED || arg == GameState.RUNNING) removeSelection();
}
 else if (arg instanceof NamesChangedEvent) {
setNames(((NamesChangedEvent)arg).getLeftName(),((NamesChangedEvent)arg).getRightName());
}
}
 else {
leftScorePanel.setScore(ScoreManagerSingleton.getInstance().getLeftScore());
rightScorePanel.setScore(ScoreManagerSingleton.getInstance().getRightScore());
}
}",0.7884615384615384
99168,"public NewGameDialog(JFrame owner){
  super(owner);
  setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);
  this.owner=owner;
  JPanel mainPanel=new JPanel();
  mainPanel.setBorder(DefaultUIProvider.getDefaultEmptyBorder());
  BoxLayout boxLayout=new BoxLayout(mainPanel,BoxLayout.Y_AXIS);
  mainPanel.setLayout(boxLayout);
  JPanel namesPanel=new JPanel(new GridLayout(2,2));
  namesPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE,60));
  mainPanel.add(namesPanel);
  namesPanel.add(new JLabel(""String_Node_Str""));
  final JTextField leftNameTextField=new JTextField();
  namesPanel.add(leftNameTextField);
  namesPanel.add(new JLabel(""String_Node_Str""));
  final JTextField rightNameTextField=new JTextField();
  namesPanel.add(rightNameTextField);
  JPanel buttonsPanel=new JPanel();
  mainPanel.add(buttonsPanel);
  BoxLayout buttonsBoxLayout=new BoxLayout(buttonsPanel,BoxLayout.X_AXIS);
  buttonsPanel.setLayout(buttonsBoxLayout);
  JButton okButton=new JButton(""String_Node_Str"");
  okButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      setVisible(false);
      ScoreManagerSingleton.getInstance().setNames(leftNameTextField.getText(),rightNameTextField.getText());
      ScoreManagerSingleton.getInstance().newGame();
    }
  }
);
  buttonsPanel.add(Box.createHorizontalGlue());
  buttonsPanel.add(okButton);
  JButton cancelButton=new JButton(""String_Node_Str"");
  cancelButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      setVisible(false);
    }
  }
);
  buttonsPanel.add(Box.createHorizontalStrut(10));
  buttonsPanel.add(cancelButton);
  setContentPane(mainPanel);
  setSize(300,130);
  setResizable(false);
}","public NewGameDialog(JFrame owner){
  super(owner);
  setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);
  this.owner=owner;
  JPanel mainPanel=new JPanel();
  mainPanel.setBorder(DefaultUIProvider.getDefaultEmptyBorder());
  BoxLayout boxLayout=new BoxLayout(mainPanel,BoxLayout.Y_AXIS);
  mainPanel.setLayout(boxLayout);
  JPanel namesPanel=new JPanel(new GridLayout(2,2));
  namesPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE,60));
  mainPanel.add(namesPanel);
  namesPanel.add(new JLabel(""String_Node_Str""));
  final JTextField leftNameTextField=new JTextField();
  namesPanel.add(leftNameTextField);
  namesPanel.add(new JLabel(""String_Node_Str""));
  final JTextField rightNameTextField=new JTextField();
  namesPanel.add(rightNameTextField);
  JPanel buttonsPanel=new JPanel();
  mainPanel.add(buttonsPanel);
  BoxLayout buttonsBoxLayout=new BoxLayout(buttonsPanel,BoxLayout.X_AXIS);
  buttonsPanel.setLayout(buttonsBoxLayout);
  JButton okButton=new JButton(""String_Node_Str"");
  okButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      setVisible(false);
      ScoreManagerSingleton.getInstance().setNames(leftNameTextField.getText(),rightNameTextField.getText());
      ScoreManagerSingleton.getInstance().newGame();
    }
  }
);
  buttonsPanel.add(Box.createHorizontalGlue());
  buttonsPanel.add(okButton);
  JButton cancelButton=new JButton(""String_Node_Str"");
  cancelButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      setVisible(false);
    }
  }
);
  buttonsPanel.add(Box.createHorizontalStrut(5));
  buttonsPanel.add(cancelButton);
  setContentPane(mainPanel);
  setSize(300,130);
  setResizable(false);
}",0.9991316931982632
99169,"public void newGame(){
  GameStateSingleton.getInstance().setGameState(GameState.INIT);
  GameStateSingleton.getInstance().resetRoundsCount();
  leftScore=rightScore=0;
  setChanged();
  notifyObservers();
}","public void newGame(){
  GameStateSingleton.getInstance().setGameState(GameState.INIT);
  GameStateSingleton.getInstance().resetRoundsCount();
  leftScore=rightScore=0;
  price=1;
  setChanged();
  notifyObservers();
}",0.9741176470588236
99170,"private void calculateShortestPaths(){
  for (  V j : this.vertices) {
    for (    V i : this.vertices) {
      if (!i.equals(j)) {
        for (        V k : this.vertices) {
          if (!k.equals(j)) {
            Double new_value=this.d.get(i).get(j) + this.d.get(j).get(k);
            if (new_value < this.d.get(i).get(k)) {
              this.d.get(i).put(k,new_value);
              this.t.get(i).put(k,j);
            }
          }
        }
        if (this.d.get(i).get(j) < 0)         throw new NegativeCircleFoundException();
      }
    }
  }
}","private void calculateShortestPaths(){
  for (  V j : this.vertices) {
    for (    V i : this.vertices) {
      if (!i.equals(j)) {
        for (        V k : this.vertices) {
          if (!k.equals(j)) {
            Double new_value=this.d.get(i).get(j) + this.d.get(j).get(k);
            if (new_value < this.d.get(i).get(k)) {
              this.d.get(i).put(k,new_value);
              this.t.get(i).put(k,j);
            }
          }
        }
        if (this.d.get(i).get(i) < 0) {
          throw new NegativeCircleFoundException();
        }
      }
    }
  }
}",0.9629629629629628
99171,"public static void main(String[] args){
  DataReader reader=new DataReader();
  Graph graph=new Graph();
  reader.fill(graph);
  System.out.println(""String_Node_Str"" + graph.nodes.size());
  System.out.println(""String_Node_Str"" + graph.edges.size());
  ClusteringPhase cp=new ClusteringPhase();
  ArrayList<ArrayList<Integer>> results=cp.doCluster(graph,1);
  System.out.print(results.size());
}","public static void main(String[] args){
  DataReader reader=new DataReader();
  Graph graph=new Graph();
  reader.fill(graph);
  System.out.println(""String_Node_Str"" + graph.nodes.size());
  System.out.println(""String_Node_Str"" + graph.edges.size());
  ClusteringPhase cp=new ClusteringPhase();
  ArrayList<ArrayList<Integer>> results=cp.doCluster(graph,1);
  System.out.println(results.size());
  System.out.println(""String_Node_Str"" + graph.nodes.size());
  System.out.println(""String_Node_Str"" + graph.edges.size());
  MiningPhase.doMining(graph,results);
  System.out.println(""String_Node_Str"" + graph.nodes.size());
  System.out.println(""String_Node_Str"" + graph.edges.size());
}",0.732159406858202
99172,"public void fill(Graph graph){
  Map<Integer,Edge> edges=new HashMap<Integer,Edge>();
  Map<Integer,Node> nodes=new HashMap<Integer,Node>();
  try {
    FileInputStream fstream=new FileInputStream(""String_Node_Str"");
    DataInputStream in=new DataInputStream(fstream);
    BufferedReader br=new BufferedReader(new InputStreamReader(in));
    String strLine;
    br.readLine();
    br.readLine();
    br.readLine();
    br.readLine();
    while ((strLine=br.readLine()) != null) {
      int id1=Integer.parseInt(strLine.split(""String_Node_Str"")[0]);
      int id2=Integer.parseInt(strLine.split(""String_Node_Str"")[1]);
      int edgeId=edges.size();
      Edge e=new Edge(id1,id2,edgeId);
      edges.put(edgeId,e);
      if (!nodes.containsKey(id1)) {
        Node n=new Node(id1);
        n.addEdge(edgeId);
        nodes.put(id1,n);
      }
 else {
        if (!nodes.get(id1).containsEdge(edgeId))         nodes.get(id1).addEdge(edgeId);
      }
      if (!nodes.containsKey(id2)) {
        Node n=new Node(id2);
        n.addEdge(edgeId);
        nodes.put(id2,n);
      }
 else {
        if (!nodes.get(id2).containsEdge(edgeId))         nodes.get(id2).addEdge(edgeId);
      }
    }
    in.close();
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
  }
  graph.edges=edges;
  graph.nodes=nodes;
}","public void fill(Graph graph){
  Map<Integer,Edge> edges=new HashMap<Integer,Edge>();
  Map<Integer,Node> nodes=new HashMap<Integer,Node>();
  try {
    FileInputStream fstream=new FileInputStream(""String_Node_Str"");
    DataInputStream in=new DataInputStream(fstream);
    BufferedReader br=new BufferedReader(new InputStreamReader(in));
    String strLine;
    br.readLine();
    br.readLine();
    br.readLine();
    br.readLine();
    while ((strLine=br.readLine()) != null) {
      int id1=Integer.parseInt(strLine.split(""String_Node_Str"")[0]);
      int id2=Integer.parseInt(strLine.split(""String_Node_Str"")[1]);
      int edgeId=edges.size();
      Edge e=new Edge(id1,id2,edgeId);
      edges.put(edgeId,e);
      if (!nodes.containsKey(id1)) {
        Node n=new Node(id1);
        n.addEdge(edgeId);
        nodes.put(id1,n);
      }
 else {
        if (!nodes.get(id1).containsEdge(edgeId))         nodes.get(id1).addEdge(edgeId);
      }
      if (!nodes.containsKey(id2)) {
        Node n=new Node(id2);
        nodes.put(id2,n);
      }
 else {
      }
    }
    in.close();
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
  }
  graph.edges=edges;
  graph.nodes=nodes;
}",0.954421503700818
99173,"static void doMining(Graph g,ArrayList<ArrayList<Integer>> sets){
  for (  ArrayList<Integer> W : sets) {
    counter.clear();
    for (    Integer v : W) {
      Node n=g.nodes.get(v);
      for (int i=0; i < n.edgeIds.size(); i++) {
        Integer eid=n.edgeIds.get(i);
        Object obj=counter.get(eid);
        if (obj == null) {
          counter.put(eid,new Integer(1));
        }
 else {
          int tmp=((Integer)obj).intValue() + 1;
          counter.put(eid,new Integer(tmp));
        }
      }
    }
    Trie T=new Trie();
    for (    Integer v : W) {
      ArrayList<Integer> L=new ArrayList<Integer>();
      Node n=g.nodes.get(v);
      for (int i=0; i < n.edgeIds.size(); i++) {
        Integer eid=n.edgeIds.get(i);
        if (counter.get(eid) > 1) {
          L.add(eid);
        }
      }
      Collections.sort(L,new MiningPhase.MyCountComparator());
      T.insert(L,v);
    }
    ArrayList<Pattern> P=new ArrayList<Pattern>();
    T.findPatterns(P);
    Collections.sort(P,new MiningPhase.MyPatternComparator());
    for (    Pattern p : P) {
      VirtualNode v=new VirtualNode(g.nodes.size() + 1);
      for (      Integer outlink : p.outlinkList) {
        v.edgeIds.add(outlink);
      }
      g.nodes.put(v.id,v);
      for (      Integer target : v.edgeIds) {
        for (        Integer source : p.vertexList) {
          Node n=g.nodes.get(source);
          for (int i=0; i < n.edgeIds.size(); i++) {
            Integer eid=n.edgeIds.get(i);
            if (eid == target) {
              n.edgeIds.remove(i);
              break;
            }
          }
        }
      }
      for (      Integer source : p.vertexList) {
        Node n=g.nodes.get(source);
        n.edgeIds.add(v.id);
      }
    }
  }
}","static void doMining(Graph g,ArrayList<ArrayList<Integer>> sets){
  for (  ArrayList<Integer> W : sets) {
    System.out.println(""String_Node_Str"" + W.size());
    counter.clear();
    for (    Integer v : W) {
      Node n=g.nodes.get(v);
      for (int i=0; i < n.edgeIds.size(); i++) {
        Integer eid=n.edgeIds.get(i);
        Integer targetID=g.edges.get(eid).getOtherNodeId(v);
        Object obj=counter.get(targetID);
        if (obj == null) {
          counter.put(targetID,new Integer(1));
        }
 else {
          int tmp=((Integer)obj).intValue() + 1;
          counter.put(targetID,new Integer(tmp));
        }
      }
    }
    Trie T=new Trie();
    for (    Integer v : W) {
      ArrayList<Integer> L=new ArrayList<Integer>();
      Node n=g.nodes.get(v);
      for (int i=0; i < n.edgeIds.size(); i++) {
        Integer eid=n.edgeIds.get(i);
        Integer targetID=g.edges.get(eid).getOtherNodeId(v);
        if (counter.get(targetID) > 1) {
          L.add(targetID);
        }
      }
      Collections.sort(L,new MiningPhase.MyCountComparator());
      T.insert(L,v);
    }
    ArrayList<Pattern> P=new ArrayList<Pattern>();
    T.findPatterns(P);
    Collections.sort(P,new MiningPhase.MyPatternComparator());
    while (P.size() > 0) {
      Pattern p=P.get(0);
      VirtualNode v=new VirtualNode(g.nodes.size() + 1);
      for (      Integer outlink : p.outlinkList) {
        Edge e=new Edge(v.id,outlink,g.edges.size() + 1);
        g.edges.put(e.id,e);
        v.edgeIds.add(e.id);
      }
      g.nodes.put(v.id,v);
      for (      Integer outlink : v.edgeIds) {
        Integer target=g.edges.get(outlink).getOtherNodeId(v.id);
        for (        Integer source : p.vertexList) {
          Node n=g.nodes.get(source);
          for (int i=0; i < n.edgeIds.size(); i++) {
            Integer eid=n.edgeIds.get(i);
            Integer targetID=g.edges.get(eid).getOtherNodeId(source);
            if (targetID == target) {
              n.edgeIds.remove(i);
              g.edges.remove(eid);
              break;
            }
          }
        }
      }
      for (      Integer source : p.vertexList) {
        Node n=g.nodes.get(source);
        Edge e=new Edge(source,v.id,g.edges.size() + 1);
        g.edges.put(e.id,e);
        n.edgeIds.add(e.id);
      }
      Pattern.recompute(P);
      Collections.sort(P,new MiningPhase.MyPatternComparator());
    }
  }
}",0.8091346153846154
99174,"public Pattern(AbstractSet<Integer> ls,int leng){
  outlinkList=new ArrayList<Integer>();
  vertexList=new ArrayList<Integer>();
  for (  int x : ls) {
    vertexList.add(x);
  }
  length=leng;
}","Pattern(AbstractSet<Integer> ls,int leng){
  outlinkList=new ArrayList<Integer>();
  vertexList=new ArrayList<Integer>();
  for (  int x : ls) {
    vertexList.add(x);
  }
  length=leng;
}",0.9817232375979112
99175,"public int getSavings(){
  return (length - 1) * (getFrequency() - 1) - 1;
}","int getSavings(){
  return (length - 1) * (getFrequency() - 1) - 1;
}",0.9517241379310344
99176,"public int getFrequency(){
  return vertexList.size();
}","int getFrequency(){
  return vertexList.size();
}",0.9333333333333332
99177,"protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.character_layout);
  brain.setSelf((Player)getIntent().getExtras().getSerializable(StartScreenController.SELF));
  brain.setCharacter((Character)getIntent().getExtras().getSerializable(""String_Node_Str""));
  ((Button)findViewById(R.id.healthMinus)).setOnClickListener(this);
  ((Button)findViewById(R.id.healthPlus)).setOnClickListener(this);
  ((Button)findViewById(R.id.strengthMinus)).setOnClickListener(this);
  ((Button)findViewById(R.id.strengthPlus)).setOnClickListener(this);
  ((Button)findViewById(R.id.defensePlus)).setOnClickListener(this);
  ((Button)findViewById(R.id.defenseMinus)).setOnClickListener(this);
  ((Button)findViewById(R.id.accuracyMinus)).setOnClickListener(this);
  ((Button)findViewById(R.id.accuracyPlus)).setOnClickListener(this);
  ((Button)findViewById(R.id.evasionMinus)).setOnClickListener(this);
  ((Button)findViewById(R.id.evasionPlus)).setOnClickListener(this);
  health=brain.getCharacter().getHealth();
  strength=brain.getCharacter().getStrength();
  defense=brain.getCharacter().getDefense();
  accuracy=brain.getCharacter().getAccuracy();
  evasion=brain.getCharacter().getEvasion();
  this.getHealthDisplay().setText(""String_Node_Str"" + health);
  this.getStrengthDisplay().setText(""String_Node_Str"" + strength);
  this.getDefenseDisplay().setText(""String_Node_Str"" + defense);
  this.getAccuracyDisplay().setText(""String_Node_Str"" + accuracy);
  this.getEvasionDisplay().setText(""String_Node_Str"" + evasion);
}","protected void onCreate(Bundle savedInstanceState){
  System.out.println(""String_Node_Str"");
  super.onCreate(savedInstanceState);
  setContentView(R.layout.character_layout);
  brain.setSelf((Player)getIntent().getExtras().getSerializable(StartScreenController.SELF));
  brain.setCharacter((Character)getIntent().getExtras().getSerializable(""String_Node_Str""));
  ((Button)findViewById(R.id.healthMinus)).setOnClickListener(this);
  ((Button)findViewById(R.id.healthPlus)).setOnClickListener(this);
  ((Button)findViewById(R.id.strengthMinus)).setOnClickListener(this);
  ((Button)findViewById(R.id.strengthPlus)).setOnClickListener(this);
  ((Button)findViewById(R.id.defensePlus)).setOnClickListener(this);
  ((Button)findViewById(R.id.defenseMinus)).setOnClickListener(this);
  ((Button)findViewById(R.id.accuracyMinus)).setOnClickListener(this);
  ((Button)findViewById(R.id.accuracyPlus)).setOnClickListener(this);
  ((Button)findViewById(R.id.evasionMinus)).setOnClickListener(this);
  ((Button)findViewById(R.id.evasionPlus)).setOnClickListener(this);
  health=brain.getCharacter().getHealth();
  strength=brain.getCharacter().getStrength();
  defense=brain.getCharacter().getDefense();
  accuracy=brain.getCharacter().getAccuracy();
  evasion=brain.getCharacter().getEvasion();
  this.getHealthDisplay().setText(""String_Node_Str"" + health);
  this.getStrengthDisplay().setText(""String_Node_Str"" + strength);
  this.getDefenseDisplay().setText(""String_Node_Str"" + defense);
  this.getAccuracyDisplay().setText(""String_Node_Str"" + accuracy);
  this.getEvasionDisplay().setText(""String_Node_Str"" + evasion);
}",0.9871433051113202
99178,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.home);
  p=(Player)getIntent().getExtras().getSerializable(StartScreenController.SELF);
  c=(Character)getIntent().getExtras().getSerializable(""String_Node_Str"");
  ((Button)findViewById(R.id.character_button)).setOnClickListener(this);
  ((Button)findViewById(R.id.items_button)).setOnClickListener(this);
  ((Button)findViewById(R.id.battle_button)).setOnClickListener(this);
  ((Button)findViewById(R.id.logout_button)).setOnClickListener(this);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.home);
  p=(Player)getIntent().getExtras().getSerializable(StartScreenController.SELF);
  character=(Character)getIntent().getExtras().getSerializable(""String_Node_Str"");
  ((Button)findViewById(R.id.character_button)).setOnClickListener(this);
  ((Button)findViewById(R.id.items_button)).setOnClickListener(this);
  ((Button)findViewById(R.id.battle_button)).setOnClickListener(this);
  ((Button)findViewById(R.id.logout_button)).setOnClickListener(this);
}",0.993103448275862
99179,"public void onClick(View v){
  if (v.getId() == R.id.character_button) {
    Intent c=new Intent(HomeScreenController.this,CharacterController.class);
    c.putExtra(""String_Node_Str"",p);
    c.putExtra(""String_Node_Str"",c);
    startActivity(c);
  }
 else   if (v.getId() == R.id.items_button) {
    Intent b=new Intent(HomeScreenController.this,ItemController.class);
    b.putExtra(""String_Node_Str"",p);
    b.putExtra(""String_Node_Str"",c);
    startActivity(b);
  }
 else   if (v.getId() == R.id.battle_button) {
    Intent a=new Intent(HomeScreenController.this,PreBattleController.class);
    a.putExtra(""String_Node_Str"",p);
    a.putExtra(""String_Node_Str"",c);
    startActivity(a);
  }
 else   if (v.getId() == R.id.logout_button) {
    Intent d=new Intent(HomeScreenController.this,StartScreenController.class);
    startActivity(d);
  }
}","public void onClick(View v){
  if (v.getId() == R.id.character_button) {
    Intent c=new Intent(HomeScreenController.this,CharacterController.class);
    c.putExtra(""String_Node_Str"",p);
    c.putExtra(""String_Node_Str"",character);
    startActivity(c);
  }
 else   if (v.getId() == R.id.items_button) {
    Intent b=new Intent(HomeScreenController.this,ItemController.class);
    b.putExtra(""String_Node_Str"",p);
    b.putExtra(""String_Node_Str"",character);
    startActivity(b);
  }
 else   if (v.getId() == R.id.battle_button) {
    Intent a=new Intent(HomeScreenController.this,PreBattleController.class);
    a.putExtra(""String_Node_Str"",p);
    a.putExtra(""String_Node_Str"",character);
    startActivity(a);
  }
 else   if (v.getId() == R.id.logout_button) {
    Intent d=new Intent(HomeScreenController.this,StartScreenController.class);
    startActivity(d);
  }
}",0.9860627177700348
99180,"private void itemDialog(final ListView v,final String item,final String what){
  AlertDialog.Builder builder=new AlertDialog.Builder(this);
  builder.setMessage(""String_Node_Str"" + item + ""String_Node_Str""+ what).setTitle(""String_Node_Str"").setCancelable(true).setPositiveButton(""String_Node_Str"" + what,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      if (what.contains(""String_Node_Str"")) {
        int num;
        if (alitems.containsKey(item) && alitems.get(item).intValue() > 1)         num=alitems.get(item).intValue();
 else         num=alitems.remove(item).intValue();
        if (albackpackItems.containsKey(item)) {
          if (alitems.containsKey(item) && alitems.get(item).intValue() > 1) {
            alitems.put(item,alitems.remove(item).intValue() - 1);
          }
          albackpackItems.put(item,albackpackItems.get(item).intValue() + 1);
        }
 else         albackpackItems.put(item,1);
        v.invalidate();
        setUpListView(backpackListView,albackpackItems,""String_Node_Str"");
        setUpListView(storageListView,alitems,""String_Node_Str"");
      }
 else {
        int num;
        if (albackpackItems.containsKey(item) && albackpackItems.get(item).intValue() > 1)         num=albackpackItems.get(item).intValue();
 else         num=albackpackItems.remove(item).intValue();
        if (alitems.containsKey(item)) {
          if (albackpackItems.containsKey(item) && albackpackItems.get(item).intValue() > 1) {
            albackpackItems.put(item,albackpackItems.remove(item).intValue() - 1);
          }
          alitems.put(item,alitems.get(item).intValue() + 1);
        }
 else         alitems.put(item,1);
        setUpListView(backpackListView,albackpackItems,""String_Node_Str"");
        setUpListView(storageListView,alitems,""String_Node_Str"");
      }
    }
  }
).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      dialog.cancel();
    }
  }
);
  AlertDialog alert=builder.create();
  alert.show();
}","private void itemDialog(final ListView v,final String item,final String what){
  AlertDialog.Builder builder=new AlertDialog.Builder(this);
  builder.setMessage(""String_Node_Str"" + item + ""String_Node_Str""+ what).setTitle(""String_Node_Str"").setCancelable(true).setPositiveButton(""String_Node_Str"" + what,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      if (what.contains(""String_Node_Str"")) {
        if (alitems.containsKey(item) && alitems.get(item).intValue() > 1) {
          alitems.put(item,alitems.remove(item).intValue() - 1);
        }
 else {
          alitems.remove(item);
        }
        if (albackpackItems.containsKey(item))         albackpackItems.put(item,albackpackItems.get(item).intValue() + 1);
 else         albackpackItems.put(item,1);
        v.invalidate();
        setUpListView(backpackListView,albackpackItems,""String_Node_Str"");
        setUpListView(storageListView,alitems,""String_Node_Str"");
      }
 else {
        if (albackpackItems.containsKey(item) && albackpackItems.get(item).intValue() > 1) {
          albackpackItems.put(item,albackpackItems.remove(item).intValue() - 1);
        }
 else {
          albackpackItems.remove(item);
        }
        if (alitems.containsKey(item))         alitems.put(item,alitems.get(item).intValue() + 1);
 else         alitems.put(item,1);
        setUpListView(backpackListView,albackpackItems,""String_Node_Str"");
        setUpListView(storageListView,alitems,""String_Node_Str"");
      }
    }
  }
).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      dialog.cancel();
    }
  }
);
  AlertDialog alert=builder.create();
  alert.show();
}",0.4106404958677686
99181,"private void setUpListView(final ListView v,final HashMap<String,Number> map,final String what){
  ArrayAdapter<String> adapter;
  adapter=new ArrayAdapter<String>(this,R.layout.itemrow,new ArrayList<String>());
  v.setAdapter(adapter);
  v.setOnItemClickListener(new OnItemClickListener(){
    public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){
      Toast.makeText(ItemController.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
      Object[] keys=map.keySet().toArray();
      itemDialog(v,(String)keys[position],what);
    }
  }
);
  if (map.size() > 0) {
    Object[] keys=map.keySet().toArray();
    Toast.makeText(this,keys.length + ""String_Node_Str"" + map.size(),Toast.LENGTH_LONG).show();
    for (int i=0; i < map.size(); i++) {
      adapter.add(""String_Node_Str"" + map.get((String)keys[i]) + ""String_Node_Str""+ (String)keys[i]);
    }
    v.invalidate();
  }
}","private void setUpListView(final ListView v,final HashMap<String,Number> map,final String what){
  ArrayAdapter<String> adapter;
  adapter=new ArrayAdapter<String>(this,R.layout.itemrow,new ArrayList<String>());
  v.setAdapter(adapter);
  v.setOnItemClickListener(new OnItemClickListener(){
    public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){
      Object[] keys=map.keySet().toArray();
      itemDialog(v,(String)keys[position],what);
    }
  }
);
  if (map.size() > 0) {
    Object[] keys=map.keySet().toArray();
    for (int i=0; i < map.size(); i++) {
      adapter.add(""String_Node_Str"" + map.get((String)keys[i]) + ""String_Node_Str""+ (String)keys[i]);
    }
    v.invalidate();
  }
}",0.7980652962515115
99182,"public void onItemClick(AdapterView<?> parent,View view,int position,long id){
  Toast.makeText(ItemController.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
  Object[] keys=map.keySet().toArray();
  itemDialog(v,(String)keys[position],what);
}","public void onItemClick(AdapterView<?> parent,View view,int position,long id){
  Object[] keys=map.keySet().toArray();
  itemDialog(v,(String)keys[position],what);
}",0.8009708737864077
99183,"public static EnchantmentSet getPossibleSet(int mel,Item item){
  Enchantment[] se=getPossible(mel,item);
  EnchantmentPower[] sp=getPower(se,mel);
  EnchantmentSet output=new EnchantmentSet(se,sp);
  return output;
}","public static EnchantmentSet getPossibleSet(int mel,Item item){
  Enchantment[] se=getPossible(mel,item);
  EnchantmentPower[] sp=getPower(se,mel);
  EnchantmentSet output=new EnchantmentSet(mel,0,se,sp);
  return output;
}",0.9863636363636364
99184,"public static boolean isConflicting(Enchantment enca,Enchantment encb){
  if (enca == encb) {
    return true;
  }
  if (enca.getType() == encb.getType()) {
    if (enca.getType() == EnchantmentType.GENERAL) {
      return false;
    }
 else {
      return true;
    }
  }
  return false;
}","/** 
 * Checks if 2 enchantments conflict with each other
 * @param enca The first Enchantment
 * @param encb The second Enchantment
 * @return TRUE if the enchantments conflict
 */
public static boolean isConflicting(Enchantment enca,Enchantment encb){
  if (enca == encb) {
    return true;
  }
  if (enca.getType() == encb.getType()) {
    if (enca.getType() == EnchantmentType.GENERAL) {
      return false;
    }
 else {
      return true;
    }
  }
  return false;
}",0.7611548556430446
99185,"public static EnchantmentSet removeConflict(EnchantmentSet possible,Enchantment enchantment){
  int length=possible.enchantments.length;
  boolean[] valid=new boolean[length];
  int inh=0;
  for (int c=0; c < length; c++) {
    if (isConflicting(possible.enchantments[c],enchantment)) {
      valid[c]=false;
    }
 else {
      valid[c]=true;
      inh++;
    }
  }
  Enchantment[] oute=new Enchantment[inh];
  EnchantmentPower[] outp=new EnchantmentPower[inh];
  int outh=0;
  for (int c=0; c < length; c++) {
    if (valid[c]) {
      oute[outh]=possible.enchantments[c];
      outp[outh]=possible.power[c];
      outh++;
    }
  }
  EnchantmentSet output=new EnchantmentSet(oute,outp);
  return output;
}","/** 
 * Removes enchantments that conflict with a enchantment from a array.
 * @param possible The array of enchantments
 * @param enchantment The enchantment to check against
 * @return A array that contains the non-conflicting enchantments
 */
public static Enchantment[] removeConflict(Enchantment[] possible,Enchantment enchantment){
  int length=possible.length;
  boolean[] valid=new boolean[length];
  int inh=0;
  for (int c=0; c < length; c++) {
    if (isConflicting(possible[c],enchantment)) {
      valid[c]=false;
    }
 else {
      valid[c]=true;
      inh++;
    }
  }
  Enchantment[] oute=new Enchantment[inh];
  int outh=0;
  for (int c=0; c < length; c++) {
    if (valid[c]) {
      oute[outh]=possible[c];
      outh++;
    }
  }
  return oute;
}",0.6847457627118644
99186,"/** 
 * Shows login page.
 * @param context the specified context
 * @throws Exception exception
 */
@RequestProcessing(value=""String_Node_Str"",method=HTTPRequestMethod.GET) public void showLogin(final HTTPRequestContext context) throws Exception {
  final HttpServletRequest request=context.getRequest();
  String destinationURL=request.getParameter(Common.GOTO);
  if (Strings.isEmptyOrNull(destinationURL)) {
    destinationURL=Latkes.getServePath() + Common.ADMIN_INDEX_URI;
  }
  final HttpServletResponse response=context.getResponse();
  userMgmtService.tryLogInWithCookie(request,response);
  if (null != userService.getCurrentUser(request)) {
    response.sendRedirect(destinationURL);
    return;
  }
  renderPage(context,""String_Node_Str"",destinationURL);
}","/** 
 * Shows login page.
 * @param context the specified context
 * @throws Exception exception
 */
@RequestProcessing(value=""String_Node_Str"",method=HTTPRequestMethod.GET) public void showLogin(final HTTPRequestContext context) throws Exception {
  final HttpServletRequest request=context.getRequest();
  String destinationURL=request.getParameter(Common.GOTO);
  if (Strings.isEmptyOrNull(destinationURL)) {
    destinationURL=Latkes.getServePath() + Common.ADMIN_INDEX_URI;
  }
  final HttpServletResponse response=context.getResponse();
  userMgmtService.tryLogInWithCookie(request,response);
  if (null != userService.getCurrentUser(request)) {
    response.sendRedirect(destinationURL);
    return;
  }
  renderPage(context,""String_Node_Str"",destinationURL,request);
}",0.9948186528497408
99187,"/** 
 * Shows forgotten password page.
 * @param context the specified context
 * @throws Exception exception
 */
@RequestProcessing(value=""String_Node_Str"",method=HTTPRequestMethod.GET) public void showForgot(final HTTPRequestContext context) throws Exception {
  final HttpServletRequest request=context.getRequest();
  String destinationURL=request.getParameter(Common.GOTO);
  if (Strings.isEmptyOrNull(destinationURL)) {
    destinationURL=Latkes.getServePath() + Common.ADMIN_INDEX_URI;
  }
  renderPage(context,""String_Node_Str"",destinationURL);
}","/** 
 * Shows forgotten password page.
 * @param context the specified context
 * @throws Exception exception
 */
@RequestProcessing(value=""String_Node_Str"",method=HTTPRequestMethod.GET) public void showForgot(final HTTPRequestContext context) throws Exception {
  final HttpServletRequest request=context.getRequest();
  String destinationURL=request.getParameter(Common.GOTO);
  if (Strings.isEmptyOrNull(destinationURL)) {
    destinationURL=Latkes.getServePath() + Common.ADMIN_INDEX_URI;
  }
  renderPage(context,""String_Node_Str"",destinationURL,request);
}",0.992831541218638
99188,"/** 
 * Send the random password to the given address and update the ever one.
 * @param user the user relative to the given email below
 * @param userEmail the given email
 * @param jsonObject return code and message object
 * @throws JSONException the JSONException
 * @throws ServiceException the ServiceException
 * @throws IOException the IOException
 */
private void sendRandomPwd(final JSONObject user,final String userEmail,final JSONObject jsonObject) throws JSONException, ServiceException, IOException {
  final JSONObject preference=preferenceQueryService.getPreference();
  final String randomPwd=new Randoms().nextString();
  final String blogTitle=preference.getString(Preference.BLOG_TITLE);
  final String adminEmail=preference.getString(Preference.ADMIN_EMAIL);
  final String mailSubject=langPropsService.get(""String_Node_Str"");
  final String mailBody=langPropsService.get(""String_Node_Str"") + randomPwd;
  final MailService.Message message=new MailService.Message();
  user.put(User.USER_PASSWORD,randomPwd);
  userMgmtService.updateUser(user);
  message.setFrom(adminEmail);
  message.addRecipient(userEmail);
  message.setSubject(mailSubject);
  message.setHtmlBody(mailBody);
  mailService.send(message);
  jsonObject.put(""String_Node_Str"",true);
  jsonObject.put(""String_Node_Str"",Latkes.getServePath() + ""String_Node_Str"");
  jsonObject.put(Keys.MSG,langPropsService.get(""String_Node_Str""));
  LOGGER.log(Level.DEBUG,""String_Node_Str"",new Object[]{mailSubject,mailBody,userEmail});
}","/** 
 * Send the random password to the given address and update the ever one.
 * @param user       the user relative to the given email below
 * @param userEmail  the given email
 * @param jsonObject return code and message object
 * @throws JSONException    the JSONException
 * @throws ServiceException the ServiceException
 * @throws IOException      the IOException
 */
private void sendRandomPwd(final JSONObject user,final String userEmail,final JSONObject jsonObject) throws JSONException, ServiceException, IOException {
  final JSONObject preference=preferenceQueryService.getPreference();
  final String randomPwd=new Randoms().nextString();
  final String blogTitle=preference.getString(Preference.BLOG_TITLE);
  final String adminEmail=preference.getString(Preference.ADMIN_EMAIL);
  final String mailSubject=langPropsService.get(""String_Node_Str"");
  final String mailBody=langPropsService.get(""String_Node_Str"") + randomPwd;
  final MailService.Message message=new MailService.Message();
  user.put(User.USER_PASSWORD,randomPwd);
  userMgmtService.updateUser(user);
  message.setFrom(adminEmail);
  message.addRecipient(userEmail);
  message.setSubject(mailSubject);
  message.setHtmlBody(mailBody);
  mailService.send(message);
  jsonObject.put(""String_Node_Str"",true);
  jsonObject.put(""String_Node_Str"",Latkes.getServePath() + ""String_Node_Str"");
  jsonObject.put(Keys.MSG,langPropsService.get(""String_Node_Str""));
  LOGGER.log(Level.DEBUG,""String_Node_Str"",new Object[]{mailSubject,mailBody,userEmail});
}",0.9950544015825916
99189,"/** 
 * Logins. <p> Renders the response with a json object, for example, <pre> { ""isLoggedIn"": boolean, ""msg"": """" // optional, exists if isLoggedIn equals to false } </pre> </p>
 * @param context the specified context
 */
@RequestProcessing(value={""String_Node_Str""},method=HTTPRequestMethod.POST) public void login(final HTTPRequestContext context){
  final HttpServletRequest request=context.getRequest();
  final JSONRenderer renderer=new JSONRenderer();
  context.setRenderer(renderer);
  final JSONObject jsonObject=new JSONObject();
  renderer.setJSONObject(jsonObject);
  try {
    jsonObject.put(Common.IS_LOGGED_IN,false);
    final String loginFailLabel=langPropsService.get(""String_Node_Str"");
    jsonObject.put(Keys.MSG,loginFailLabel);
    final JSONObject requestJSONObject=Requests.parseRequestJSONObject(request,context.getResponse());
    final String userEmail=requestJSONObject.getString(User.USER_EMAIL);
    final String userPwd=requestJSONObject.getString(User.USER_PASSWORD);
    if (Strings.isEmptyOrNull(userEmail) || Strings.isEmptyOrNull(userPwd)) {
      return;
    }
    LOGGER.log(Level.INFO,""String_Node_Str"",userEmail);
    final JSONObject user=userQueryService.getUserByEmail(userEmail);
    if (null == user) {
      LOGGER.log(Level.WARN,""String_Node_Str"",userEmail);
      return;
    }
    if (MD5.hash(userPwd).equals(user.getString(User.USER_PASSWORD))) {
      Sessions.login(request,context.getResponse(),user);
      LOGGER.log(Level.INFO,""String_Node_Str"",userEmail);
      jsonObject.put(Common.IS_LOGGED_IN,true);
      if (Role.VISITOR_ROLE.equals(user.optString(User.USER_ROLE))) {
        jsonObject.put(""String_Node_Str"",Latkes.getServePath());
      }
 else {
        jsonObject.put(""String_Node_Str"",Latkes.getServePath() + Common.ADMIN_INDEX_URI);
      }
      jsonObject.remove(Keys.MSG);
      return;
    }
    LOGGER.log(Level.WARN,""String_Node_Str"",userPwd);
  }
 catch (  final Exception e) {
    LOGGER.log(Level.ERROR,e.getMessage(),e);
  }
}","/** 
 * Logins. <p/> <p> Renders the response with a json object, for example, <pre> { ""isLoggedIn"": boolean, ""msg"": """" // optional, exists if isLoggedIn equals to false } </pre> </p>
 * @param context the specified context
 */
@RequestProcessing(value={""String_Node_Str""},method=HTTPRequestMethod.POST) public void login(final HTTPRequestContext context){
  final HttpServletRequest request=context.getRequest();
  final JSONRenderer renderer=new JSONRenderer();
  context.setRenderer(renderer);
  final JSONObject jsonObject=new JSONObject();
  renderer.setJSONObject(jsonObject);
  try {
    jsonObject.put(Common.IS_LOGGED_IN,false);
    final String loginFailLabel=langPropsService.get(""String_Node_Str"");
    jsonObject.put(Keys.MSG,loginFailLabel);
    final JSONObject requestJSONObject=Requests.parseRequestJSONObject(request,context.getResponse());
    final String userEmail=requestJSONObject.getString(User.USER_EMAIL);
    final String userPwd=requestJSONObject.getString(User.USER_PASSWORD);
    if (Strings.isEmptyOrNull(userEmail) || Strings.isEmptyOrNull(userPwd)) {
      return;
    }
    LOGGER.log(Level.INFO,""String_Node_Str"",userEmail);
    final JSONObject user=userQueryService.getUserByEmail(userEmail);
    if (null == user) {
      LOGGER.log(Level.WARN,""String_Node_Str"",userEmail);
      return;
    }
    if (MD5.hash(userPwd).equals(user.getString(User.USER_PASSWORD))) {
      Sessions.login(request,context.getResponse(),user);
      LOGGER.log(Level.INFO,""String_Node_Str"",userEmail);
      jsonObject.put(Common.IS_LOGGED_IN,true);
      if (Role.VISITOR_ROLE.equals(user.optString(User.USER_ROLE))) {
        jsonObject.put(""String_Node_Str"",Latkes.getServePath());
      }
 else {
        jsonObject.put(""String_Node_Str"",Latkes.getServePath() + Common.ADMIN_INDEX_URI);
      }
      jsonObject.remove(Keys.MSG);
      return;
    }
    LOGGER.log(Level.WARN,""String_Node_Str"",userPwd);
  }
 catch (  final Exception e) {
    LOGGER.log(Level.ERROR,e.getMessage(),e);
  }
}",0.9987559094302064
99190,"/** 
 * reset forgotten password. <p> Renders the response with a json object, for example, <pre> { ""isLoggedIn"": boolean, ""msg"": """" // optional, exists if isLoggedIn equals to false } </pre> </p>
 * @param context the specified context
 */
@RequestProcessing(value={""String_Node_Str""},method=HTTPRequestMethod.POST) public void forgot(final HTTPRequestContext context){
  final HttpServletRequest request=context.getRequest();
  final JSONRenderer renderer=new JSONRenderer();
  context.setRenderer(renderer);
  final JSONObject jsonObject=new JSONObject();
  renderer.setJSONObject(jsonObject);
  try {
    jsonObject.put(""String_Node_Str"",false);
    jsonObject.put(Keys.MSG,langPropsService.get(""String_Node_Str""));
    final JSONObject requestJSONObject=Requests.parseRequestJSONObject(request,context.getResponse());
    final String userEmail=requestJSONObject.getString(User.USER_EMAIL);
    if (Strings.isEmptyOrNull(userEmail)) {
      LOGGER.log(Level.WARN,""String_Node_Str"");
      return;
    }
    LOGGER.log(Level.INFO,""String_Node_Str"",userEmail);
    final JSONObject user=userQueryService.getUserByEmail(userEmail);
    if (null == user) {
      LOGGER.log(Level.WARN,""String_Node_Str"",userEmail);
      jsonObject.put(Keys.MSG,langPropsService.get(""String_Node_Str""));
      return;
    }
    if (isPwdExpired()) {
      LOGGER.log(Level.WARN,""String_Node_Str"",userEmail);
      jsonObject.put(Keys.MSG,langPropsService.get(""String_Node_Str""));
      return;
    }
    sendRandomPwd(user,userEmail,jsonObject);
  }
 catch (  final Exception e) {
    LOGGER.log(Level.ERROR,e.getMessage(),e);
  }
}","/** 
 * reset forgotten password. <p/> <p> Renders the response with a json object, for example, <pre> { ""isLoggedIn"": boolean, ""msg"": """" // optional, exists if isLoggedIn equals to false } </pre> </p>
 * @param context the specified context
 */
@RequestProcessing(value={""String_Node_Str""},method=HTTPRequestMethod.POST) public void forgot(final HTTPRequestContext context){
  final HttpServletRequest request=context.getRequest();
  final JSONRenderer renderer=new JSONRenderer();
  context.setRenderer(renderer);
  final JSONObject jsonObject=new JSONObject();
  renderer.setJSONObject(jsonObject);
  try {
    jsonObject.put(""String_Node_Str"",false);
    jsonObject.put(Keys.MSG,langPropsService.get(""String_Node_Str""));
    final JSONObject requestJSONObject=Requests.parseRequestJSONObject(request,context.getResponse());
    final String userEmail=requestJSONObject.getString(User.USER_EMAIL);
    if (Strings.isEmptyOrNull(userEmail)) {
      LOGGER.log(Level.WARN,""String_Node_Str"");
      return;
    }
    LOGGER.log(Level.INFO,""String_Node_Str"",userEmail);
    final JSONObject user=userQueryService.getUserByEmail(userEmail);
    if (null == user) {
      LOGGER.log(Level.WARN,""String_Node_Str"",userEmail);
      jsonObject.put(Keys.MSG,langPropsService.get(""String_Node_Str""));
      return;
    }
    sendResetUrl(userEmail,jsonObject);
  }
 catch (  final Exception e) {
    LOGGER.log(Level.ERROR,e.getMessage(),e);
  }
}",0.8805237315875614
99191,"/** 
 * Render a page template with the destination URL.
 * @param context the context
 * @param pageTemplate the page template
 * @param destinationURL the destination URL
 * @throws JSONException the JSONException
 * @throws ServiceException the ServiceException
 */
private void renderPage(final HTTPRequestContext context,final String pageTemplate,final String destinationURL) throws JSONException, ServiceException {
  final AbstractFreeMarkerRenderer renderer=new ConsoleRenderer();
  renderer.setTemplateName(pageTemplate);
  context.setRenderer(renderer);
  final Map<String,Object> dataModel=renderer.getDataModel();
  final Map<String,String> langs=langPropsService.getAll(Latkes.getLocale());
  final JSONObject preference=preferenceQueryService.getPreference();
  dataModel.putAll(langs);
  dataModel.put(Common.GOTO,destinationURL);
  dataModel.put(Common.YEAR,String.valueOf(Calendar.getInstance().get(Calendar.YEAR)));
  dataModel.put(Common.VERSION,SoloServletListener.VERSION);
  dataModel.put(Common.STATIC_RESOURCE_VERSION,Latkes.getStaticResourceVersion());
  dataModel.put(Preference.BLOG_TITLE,preference.getString(Preference.BLOG_TITLE));
  Keys.fillRuntime(dataModel);
  filler.fillMinified(dataModel);
}","/** 
 * Render a page template with the destination URL.
 * @param context        the context
 * @param pageTemplate   the page template
 * @param destinationURL the destination URL
 * @param request        for reset password page
 * @throws JSONException    the JSONException
 * @throws ServiceException the ServiceException
 */
private void renderPage(final HTTPRequestContext context,final String pageTemplate,final String destinationURL,final HttpServletRequest request) throws JSONException, ServiceException {
  final AbstractFreeMarkerRenderer renderer=new ConsoleRenderer();
  renderer.setTemplateName(pageTemplate);
  context.setRenderer(renderer);
  final Map<String,Object> dataModel=renderer.getDataModel();
  final Map<String,String> langs=langPropsService.getAll(Latkes.getLocale());
  final JSONObject preference=preferenceQueryService.getPreference();
  dataModel.putAll(langs);
  dataModel.put(Common.GOTO,destinationURL);
  dataModel.put(Common.YEAR,String.valueOf(Calendar.getInstance().get(Calendar.YEAR)));
  dataModel.put(Common.VERSION,SoloServletListener.VERSION);
  dataModel.put(Common.STATIC_RESOURCE_VERSION,Latkes.getStaticResourceVersion());
  dataModel.put(Preference.BLOG_TITLE,preference.getString(Preference.BLOG_TITLE));
  final String token=request.getParameter(""String_Node_Str"");
  final String email=request.getParameter(""String_Node_Str"");
  final JSONObject tokenObj=optionQueryService.getOptionById(token);
  if (tokenObj == null) {
    dataModel.put(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    dataModel.put(""String_Node_Str"",""String_Node_Str"");
    dataModel.put(""String_Node_Str"",email);
  }
  final String from=request.getParameter(""String_Node_Str"");
  if (""String_Node_Str"".equals(from)) {
    dataModel.put(""String_Node_Str"",langPropsService.get(""String_Node_Str""));
  }
 else   if (""String_Node_Str"".equals(from)) {
    dataModel.put(""String_Node_Str"",langPropsService.get(""String_Node_Str""));
  }
 else {
    dataModel.put(""String_Node_Str"",""String_Node_Str"");
  }
  Keys.fillRuntime(dataModel);
  filler.fillMinified(dataModel);
}",0.7397590361445783
99192,"/** 
 * Checks upgrade.
 * @param context the specified context
 */
@RequestProcessing(value=""String_Node_Str"",method=HTTPRequestMethod.GET) public void upgrade(final HTTPRequestContext context){
  final TextHTMLRenderer renderer=new TextHTMLRenderer();
  context.setRenderer(renderer);
  try {
    final JSONObject preference=preferenceRepository.get(Preference.PREFERENCE);
    if (null == preference) {
      LOGGER.log(Level.INFO,""String_Node_Str"");
      renderer.setContent(""String_Node_Str"");
      return;
    }
    renderer.setContent(""String_Node_Str"");
    final String version=preference.getString(Preference.VERSION);
    if (SoloServletListener.VERSION.equals(version)) {
      return;
    }
    if (""String_Node_Str"".equals(version)) {
      v046ToV050();
    }
 else {
      final String msg=""String_Node_Str"";
      LOGGER.warning(msg);
      notifyUserByEmail();
      responseConflict();
    }
  }
 catch (  final Exception e) {
    LOGGER.log(Level.SEVERE,e.getMessage(),e);
    renderer.setContent(""String_Node_Str"" + e.getMessage() + ""String_Node_Str""+ ""String_Node_Str"");
  }
}","/** 
 * Checks upgrade.
 * @param context the specified context
 */
@RequestProcessing(value=""String_Node_Str"",method=HTTPRequestMethod.GET) public void upgrade(final HTTPRequestContext context){
  final TextHTMLRenderer renderer=new TextHTMLRenderer();
  context.setRenderer(renderer);
  try {
    final JSONObject preference=preferenceRepository.get(Preference.PREFERENCE);
    if (null == preference) {
      LOGGER.log(Level.INFO,""String_Node_Str"");
      renderer.setContent(""String_Node_Str"");
      return;
    }
    renderer.setContent(""String_Node_Str"");
    final String version=preference.getString(Preference.VERSION);
    if (SoloServletListener.VERSION.equals(version)) {
      return;
    }
    if (""String_Node_Str"".equals(version)) {
      v046ToV050();
    }
 else {
      LOGGER.log(Level.WARNING,""String_Node_Str"",version);
      if (!sent) {
        notifyUserByEmail();
        sent=true;
      }
      renderer.setContent(langPropsService.get(""String_Node_Str""));
    }
  }
 catch (  final Exception e) {
    LOGGER.log(Level.SEVERE,e.getMessage(),e);
    renderer.setContent(""String_Node_Str"" + e.getMessage() + ""String_Node_Str""+ ""String_Node_Str"");
  }
}",0.9017543859649124
99193,"/** 
 * Send an email to the user who upgrades B3log Solo with a discontinuous version.
 * @throws ServiceException ServiceException
 * @throws JSONException JSONException
 * @throws IOException IOException
 */
private void notifyUserByEmail() throws ServiceException, JSONException, IOException {
  final String adminEmail=preferenceQueryService.getPreference().getString(Preference.ADMIN_EMAIL);
  final MailService.Message message=new MailService.Message();
  message.setFrom(adminEmail);
  message.addRecipient(adminEmail);
  message.setSubject(""String_Node_Str"");
  message.setHtmlBody(""String_Node_Str"" + ""String_Node_Str"");
  MAIL_SVC.send(message);
  LOGGER.warning(""String_Node_Str"");
}","/** 
 * Send an email to the user who upgrades B3log Solo with a discontinuous version.
 * @throws ServiceException ServiceException
 * @throws JSONException JSONException
 * @throws IOException IOException
 */
private void notifyUserByEmail() throws ServiceException, JSONException, IOException {
  final String adminEmail=preferenceQueryService.getPreference().getString(Preference.ADMIN_EMAIL);
  final MailService.Message message=new MailService.Message();
  message.setFrom(adminEmail);
  message.addRecipient(adminEmail);
  message.setSubject(langPropsService.get(""String_Node_Str""));
  message.setHtmlBody(langPropsService.get(""String_Node_Str""));
  MAIL_SVC.send(message);
  LOGGER.info(""String_Node_Str"");
}",0.9468462083628632
99194,"@Override public void run(){
  running=true;
  Rect viewportRect=new Rect(0,0,0,0);
  while (running) {
    while (cache.getState() != CacheState.START_UPDATE)     try {
      Thread.sleep(Integer.MAX_VALUE);
    }
 catch (    InterruptedException e) {
    }
    if (!running)     return;
    long start=System.currentTimeMillis();
    boolean cont=false;
synchronized (cache) {
      if (cache.getState() == CacheState.START_UPDATE) {
        cache.setState(CacheState.IN_UPDATE);
        cache.bitmapRef=null;
        cont=true;
      }
    }
    if (cont) {
synchronized (viewport) {
        viewportRect.set(viewport.window);
      }
synchronized (cache) {
        if (cache.getState() == CacheState.IN_UPDATE)         cache.window.set(calculateCacheWindow(viewportRect));
 else         cont=false;
      }
      if (cont) {
        try {
          Bitmap bitmap=fillCache(cache.window);
synchronized (cache) {
            if (cache.getState() == CacheState.IN_UPDATE) {
              cache.bitmapRef=bitmap;
              cache.setState(CacheState.READY);
            }
 else {
              Log.w(TAG,""String_Node_Str"");
            }
          }
          long done=System.currentTimeMillis();
          if (DEBUG)           Log.d(TAG,String.format(""String_Node_Str"",done - start));
        }
 catch (        OutOfMemoryError e) {
synchronized (cache) {
            fillCacheOutOfMemoryError(e);
            if (cache.getState() == CacheState.IN_UPDATE) {
              cache.setState(CacheState.START_UPDATE);
            }
          }
        }
      }
    }
  }
}","@Override public void run(){
  running=true;
  Rect viewportRect=new Rect(0,0,0,0);
  while (running) {
    while (running && cache.getState() != CacheState.START_UPDATE)     try {
      Thread.sleep(Integer.MAX_VALUE);
    }
 catch (    InterruptedException e) {
    }
    if (!running)     return;
    long start=System.currentTimeMillis();
    boolean cont=false;
synchronized (cache) {
      if (cache.getState() == CacheState.START_UPDATE) {
        cache.setState(CacheState.IN_UPDATE);
        cache.bitmapRef=null;
        cont=true;
      }
    }
    if (cont) {
synchronized (viewport) {
        viewportRect.set(viewport.window);
      }
synchronized (cache) {
        if (cache.getState() == CacheState.IN_UPDATE)         cache.window.set(calculateCacheWindow(viewportRect));
 else         cont=false;
      }
      if (cont) {
        try {
          Bitmap bitmap=fillCache(cache.window);
synchronized (cache) {
            if (cache.getState() == CacheState.IN_UPDATE) {
              cache.bitmapRef=bitmap;
              cache.setState(CacheState.READY);
            }
 else {
              Log.w(TAG,""String_Node_Str"");
            }
          }
          long done=System.currentTimeMillis();
          if (DEBUG)           Log.d(TAG,String.format(""String_Node_Str"",done - start));
        }
 catch (        OutOfMemoryError e) {
synchronized (cache) {
            fillCacheOutOfMemoryError(e);
            if (cache.getState() == CacheState.IN_UPDATE) {
              cache.setState(CacheState.START_UPDATE);
            }
          }
        }
      }
    }
  }
}",0.9965156794425089
99195,"public void setSuspend(boolean suspend){
synchronized (cache) {
    if (suspend)     cache.state=CacheState.SUSPEND;
 else     cache.state=CacheState.INITIALIZED;
  }
}","public void setSuspend(boolean suspend){
synchronized (cache) {
    if (suspend)     cache.state=CacheState.SUSPEND;
 else     if (cache.state == CacheState.SUSPEND)     cache.state=CacheState.INITIALIZED;
  }
}",0.8865435356200527
99196,"@Override public void run(){
  Rect viewportRect=new Rect(0,0,0,0);
  while (true) {
    while (cache.state != CacheState.START_UPDATE)     try {
      Thread.sleep(10);
    }
 catch (    InterruptedException e) {
    }
    boolean cont=false;
synchronized (cache) {
      if (cache.state == CacheState.START_UPDATE) {
        cache.state=CacheState.IN_UPDATE;
        cache.bitmapRef=null;
        cont=true;
      }
    }
    if (cont) {
synchronized (viewport) {
        viewportRect.set(viewport.origin);
      }
      cache.setOriginRect(viewportRect);
      Bitmap bitmap=cache.decoder.decodeRegion(cache.origin,cache.options);
      cache.bitmapRef=new WeakReference<Bitmap>(bitmap);
      cache.state=CacheState.READY;
    }
  }
}","@Override public void run(){
  running=true;
  Rect viewportRect=new Rect(0,0,0,0);
  while (running) {
    while (cache.state != CacheState.START_UPDATE)     try {
      Thread.sleep(5);
      if (!running)       return;
    }
 catch (    InterruptedException e) {
    }
    long start=System.currentTimeMillis();
    boolean cont=false;
synchronized (cache) {
      if (cache.state == CacheState.START_UPDATE) {
        cache.state=CacheState.IN_UPDATE;
        cache.bitmapRef=null;
        cont=true;
      }
    }
    if (cont) {
synchronized (viewport) {
        viewportRect.set(viewport.origin);
      }
      cache.setOriginRect(viewportRect);
      try {
        Bitmap bitmap=cache.decoder.decodeRegion(cache.origin,cache.options);
        cache.bitmapRef=new NotWeakReference<Bitmap>(bitmap);
        cache.state=CacheState.READY;
        long done=System.currentTimeMillis();
        if (DEBUG)         Log.d(TAG,String.format(""String_Node_Str"",done - start));
      }
 catch (      OutOfMemoryError e) {
        if (cache.percent > 0)         cache.percent-=1;
        cache.state=CacheState.START_UPDATE;
        Log.e(TAG,String.format(""String_Node_Str"",cache.percent));
      }
    }
  }
}",0.7541152263374485
99197,"@Override public void surfaceDestroyed(SurfaceHolder holder){
  boolean retry=true;
  drawThread.setRunning(false);
  while (retry) {
    try {
      drawThread.join();
      retry=false;
    }
 catch (    InterruptedException e) {
    }
  }
}","@Override public void surfaceDestroyed(SurfaceHolder holder){
  scene.stop();
  drawThread.setRunning(false);
  boolean retry=true;
  while (retry) {
    try {
      drawThread.join();
      retry=false;
    }
 catch (    InterruptedException e) {
    }
  }
}",0.896414342629482
99198,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  scene.update();
  scene.draw(canvas);
  if (DEBUG) {
    long now=System.currentTimeMillis();
    double n=((double)now) / 1000L;
    double s=((double)startTime) / 1000L;
    double fps=1L / (n - s);
    startTime=System.currentTimeMillis();
  }
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  scene.update();
  scene.draw(canvas);
}",0.5195402298850574
99199,"@Override public void surfaceCreated(SurfaceHolder holder){
  drawThread=new DrawThread(holder);
  drawThread.setRunning(true);
  drawThread.start();
}","@Override public void surfaceCreated(SurfaceHolder holder){
  drawThread=new DrawThread(holder);
  drawThread.setName(""String_Node_Str"");
  drawThread.setRunning(true);
  drawThread.start();
  scene.start();
}",0.8388888888888889
99200,"/** 
 * Figure out the originRect based on the viewportRect 
 */
private void setOriginRect(Rect viewportRect){
  int vw=viewportRect.width();
  int vh=viewportRect.height();
  calcMargin(viewportRect.width(),viewportRect.height());
  int mw=margin.x;
  int mh=margin.y;
  if (vw + mw > width)   mw=Math.max(0,width - vw);
  if (vh + mh > height)   mh=Math.max(0,height - vh);
  int left=viewportRect.left - (mw >> 1);
  int right=viewportRect.right + (mw >> 1);
  if (left < 0) {
    right=right - left;
    left=0;
  }
  if (right > width) {
    left=left - (right - width);
    right=width;
  }
  int top=viewportRect.top - (mh >> 1);
  int bottom=viewportRect.bottom + (mh >> 1);
  if (top < 0) {
    bottom=bottom - top;
    top=0;
  }
  if (bottom > height) {
    top=top - (bottom - height);
    bottom=height;
  }
  originRect.set(left,top,right,bottom);
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + originRect.toShortString());
}","/** 
 * Figure out the originRect based on the viewportRect 
 */
private void setOriginRect(Rect viewportRect){
  int vw=viewportRect.width();
  int vh=viewportRect.height();
  calcMargin(vw,vh);
  int mw=margin.x;
  int mh=margin.y;
  if (vw + mw > width)   mw=Math.max(0,width - vw);
  if (vh + mh > height)   mh=Math.max(0,height - vh);
  int left=viewportRect.left - (mw >> 1);
  int right=viewportRect.right + (mw >> 1);
  if (left < 0) {
    right=right - left;
    left=0;
  }
  if (right > width) {
    left=left - (right - width);
    right=width;
  }
  int top=viewportRect.top - (mh >> 1);
  int bottom=viewportRect.bottom + (mh >> 1);
  if (top < 0) {
    bottom=bottom - top;
    top=0;
  }
  if (bottom > height) {
    top=top - (bottom - height);
    bottom=height;
  }
  originRect.set(left,top,right,bottom);
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + originRect.toShortString());
}",0.977705274605764
99201,"private static Feature getFeatureByType(JSONObject geometry,JSONObject properties) throws JSONException {
  Feature feature=null;
  String featureType=geometry.getString(""String_Node_Str"");
  if (featureType.equals(""String_Node_Str"")) {
    feature=new PointFeature();
    PointFeature pointFeature=(PointFeature)feature;
    JSONArray coords=geometry.getJSONArray(""String_Node_Str"");
    double lat=coords.getDouble(1);
    double lon=coords.getDouble(0);
    pointFeature.setLocation(new Location((float)lat,(float)lon));
  }
  if (featureType.equals(""String_Node_Str"")) {
    PApplet.println(""String_Node_Str"");
  }
  if (featureType.equals(""String_Node_Str"")) {
    feature=new ShapeFeature(FeatureType.LINES);
    ShapeFeature linesFeature=(ShapeFeature)feature;
    JSONArray coordinates=geometry.getJSONArray(""String_Node_Str"");
    populateLinesFeature(linesFeature,coordinates);
  }
  if (featureType.equals(""String_Node_Str"")) {
    feature=new MultiFeature();
    MultiFeature multiFeature=(MultiFeature)feature;
    JSONArray lines=geometry.getJSONArray(""String_Node_Str"");
    for (int i=0; i < lines.length(); i++) {
      JSONArray coordinates=lines.getJSONArray(i).getJSONArray(0);
      ShapeFeature linesFeature=new ShapeFeature(FeatureType.LINES);
      populateLinesFeature(linesFeature,coordinates);
      multiFeature.addFeature(linesFeature);
    }
  }
  if (featureType.equals(""String_Node_Str"")) {
    feature=new ShapeFeature(FeatureType.POLYGON);
    ShapeFeature polygonFeature=(ShapeFeature)feature;
    JSONArray coordinates=geometry.getJSONArray(""String_Node_Str"").getJSONArray(0);
    populatePolygonFeature(polygonFeature,coordinates);
  }
  if (featureType.equals(""String_Node_Str"")) {
    feature=new MultiFeature();
    MultiFeature multiFeature=(MultiFeature)feature;
    JSONArray polygons=geometry.getJSONArray(""String_Node_Str"");
    for (int i=0; i < polygons.length(); i++) {
      JSONArray coordinates=polygons.getJSONArray(i).getJSONArray(0);
      ShapeFeature polygonFeature=new ShapeFeature(FeatureType.POLYGON);
      populatePolygonFeature(polygonFeature,coordinates);
      multiFeature.addFeature(polygonFeature);
    }
  }
  if (feature != null && properties != null && properties.length() > 0) {
    setProperties(feature,properties);
  }
  return feature;
}","private static Feature getFeatureByType(JSONObject geometry,JSONObject properties) throws JSONException {
  Feature feature=null;
  String featureType=geometry.getString(""String_Node_Str"");
  if (featureType.equals(""String_Node_Str"")) {
    feature=new PointFeature();
    PointFeature pointFeature=(PointFeature)feature;
    JSONArray coords=geometry.getJSONArray(""String_Node_Str"");
    double lat=coords.getDouble(1);
    double lon=coords.getDouble(0);
    pointFeature.setLocation(new Location((float)lat,(float)lon));
  }
  if (featureType.equals(""String_Node_Str"")) {
    PApplet.println(""String_Node_Str"");
  }
  if (featureType.equals(""String_Node_Str"")) {
    feature=new ShapeFeature(FeatureType.LINES);
    ShapeFeature linesFeature=(ShapeFeature)feature;
    JSONArray coordinates=geometry.getJSONArray(""String_Node_Str"");
    populateLinesFeature(linesFeature,coordinates);
  }
  if (featureType.equals(""String_Node_Str"")) {
    feature=new MultiFeature();
    MultiFeature multiFeature=(MultiFeature)feature;
    JSONArray lines=geometry.getJSONArray(""String_Node_Str"");
    for (int i=0; i < lines.length(); i++) {
      JSONArray coordinates=lines.getJSONArray(i);
      ShapeFeature linesFeature=new ShapeFeature(FeatureType.LINES);
      populateLinesFeature(linesFeature,coordinates);
      multiFeature.addFeature(linesFeature);
    }
  }
  if (featureType.equals(""String_Node_Str"")) {
    feature=new ShapeFeature(FeatureType.POLYGON);
    ShapeFeature polygonFeature=(ShapeFeature)feature;
    JSONArray coordinates=geometry.getJSONArray(""String_Node_Str"").getJSONArray(0);
    populatePolygonFeature(polygonFeature,coordinates);
  }
  if (featureType.equals(""String_Node_Str"")) {
    feature=new MultiFeature();
    MultiFeature multiFeature=(MultiFeature)feature;
    JSONArray polygons=geometry.getJSONArray(""String_Node_Str"");
    for (int i=0; i < polygons.length(); i++) {
      JSONArray coordinates=polygons.getJSONArray(i).getJSONArray(0);
      ShapeFeature polygonFeature=new ShapeFeature(FeatureType.POLYGON);
      populatePolygonFeature(polygonFeature,coordinates);
      multiFeature.addFeature(polygonFeature);
    }
  }
  if (feature != null && properties != null && properties.length() > 0) {
    setProperties(feature,properties);
  }
  return feature;
}",0.9965277777777778
99202,"public void setup(){
  size(600,400,GLConstants.GLGRAPHICS);
  map=new UnfoldingMap(this,0,0,400,400,new StamenMapProvider.WaterColor());
  map.zoomAndPanTo(new Location(52.5f,13.4f),10);
  MapUtils.createDefaultEventDispatcher(this,map);
}","public void setup(){
  size(600,400,GLConstants.GLGRAPHICS);
  map=new UnfoldingMap(this,0,0,400,400,new StamenMapProvider.WaterColor());
  map.zoomAndPanTo(new Location(51.507222,-0.1275),10);
  MapUtils.createDefaultEventDispatcher(this,map);
}",0.9588477366255144
99203,"public void draw(){
  background(0);
  map.draw();
  int x=415;
  int y=20;
  for (  MapSnapshot mapSnapshot : mapSnapshots) {
    mapSnapshot.draw(x,y,80,80);
    x+=90;
    if (x > width - 90) {
      x=410;
      y+=90;
    }
  }
}","public void draw(){
  background(0);
  map.draw();
  int x=415;
  int y=20;
  for (  MapSnapshot mapSnapshot : mapSnapshots) {
    mapSnapshot.draw(x,y,80,80);
    x+=90;
    if (x > width - 90) {
      x=415;
      y+=90;
    }
  }
}",0.9957264957264956
99204,"public void setup(){
  size(800,600,GLConstants.GLGRAPHICS);
  smooth();
  font=createFont(""String_Node_Str"",14);
  map=new UnfoldingMap(this,""String_Node_Str"",0,0,600,600);
  map.zoomToLevel(3);
  MapUtils.createDefaultEventDispatcher(this,map);
}","public void setup(){
  size(800,600,GLConstants.GLGRAPHICS);
  smooth();
  font=createFont(""String_Node_Str"",14);
  map=new UnfoldingMap(this,""String_Node_Str"",0,0,600,600);
  map.setTweening(true);
  map.zoomToLevel(3);
  MapUtils.createDefaultEventDispatcher(this,map);
}",0.9520153550863724
99205,"/** 
 * Updates the integrators for tweening. Must be called before   {@link AbstractMapDisplay#draw()} .
 */
public void updateMap(){
  if (tweening) {
    scaleIntegrator.update();
    mapDisplay.innerScale=scaleIntegrator.value;
    mapDisplay.calculateInnerMatrix();
  }
}","/** 
 * Updates the integrators for tweening. Must be called before   {@link AbstractMapDisplay#draw()} .
 */
public void updateMap(){
  if (tweening) {
    scaleIntegrator.update();
    mapDisplay.innerScale=scaleIntegrator.value;
    txIntegrator.update();
    mapDisplay.innerOffsetX=txIntegrator.value;
    tyIntegrator.update();
    mapDisplay.innerOffsetY=tyIntegrator.value;
    mapDisplay.calculateInnerMatrix();
  }
}",0.7863247863247863
99206,"public void setTweening(boolean tweening){
  this.tweening=tweening;
}","public void setTweening(boolean tweening){
  if (tweening == this.tweening)   return;
  this.tweening=tweening;
  if (tweening) {
    scaleIntegrator.set(mapDisplay.innerScale);
    scaleIntegrator.target(mapDisplay.innerScale);
    txIntegrator.set(mapDisplay.innerOffsetX);
    txIntegrator.target(mapDisplay.innerOffsetX);
    tyIntegrator.set(mapDisplay.innerOffsetY);
    tyIntegrator.target(mapDisplay.innerOffsetY);
  }
 else {
    mapDisplay.innerScale=scaleIntegrator.target;
    mapDisplay.innerOffsetX=txIntegrator.target;
    mapDisplay.innerOffsetY=tyIntegrator.target;
  }
}",0.2127659574468085
99207,"protected void setInnerOffset(float x,float y){
  mapDisplay.innerOffsetX=x;
  mapDisplay.innerOffsetY=y;
  mapDisplay.calculateInnerMatrix();
}","protected void setInnerOffset(float x,float y){
  if (tweening) {
    txIntegrator.target(x);
    tyIntegrator.target(y);
  }
 else {
    mapDisplay.innerOffsetX=x;
    mapDisplay.innerOffsetY=y;
    mapDisplay.calculateInnerMatrix();
  }
}",0.75
99208,"/** 
 * Switches the tweening.
 */
public void switchTweening(){
  this.tweening=!this.tweening;
}","/** 
 * Switches the tweening flag.
 */
public void switchTweening(){
  setTweening(!tweening);
}",0.8205128205128205
99209,"protected void setInnerScale(float scale){
  mapDisplay.innerScale=scale;
  mapDisplay.innerScale=PApplet.constrain(mapDisplay.innerScale,minScale,maxScale);
  scaleIntegrator.target(scale);
  mapDisplay.calculateInnerMatrix();
}","protected void setInnerScale(float scale){
  scale=PApplet.constrain(scale,minScale,maxScale);
  if (tweening) {
    scaleIntegrator.target(scale);
  }
 else {
    mapDisplay.innerScale=scale;
    mapDisplay.calculateInnerMatrix();
  }
}",0.3905579399141631
99210,"protected void addInnerOffset(float dx,float dy){
  mapDisplay.innerOffsetX+=dx;
  mapDisplay.innerOffsetY+=dy;
  mapDisplay.calculateInnerMatrix();
}","protected void addInnerOffset(float dx,float dy){
  if (tweening) {
    txIntegrator.target(txIntegrator.target + dx);
    tyIntegrator.target(tyIntegrator.target + dy);
  }
 else {
    mapDisplay.innerOffsetX+=dx;
    mapDisplay.innerOffsetY+=dy;
    mapDisplay.calculateInnerMatrix();
  }
}",0.6787330316742082
99211,"protected void innerScale(float scale){
  mapDisplay.innerScale*=scale;
  mapDisplay.innerScale=PApplet.constrain(mapDisplay.innerScale,minScale,maxScale);
  mapDisplay.calculateInnerMatrix();
}","protected void innerScale(float scale){
  scale=PApplet.constrain(mapDisplay.innerScale * scale,minScale,maxScale);
  if (tweening) {
    scaleIntegrator.target(scale);
  }
 else {
    mapDisplay.innerScale=scale;
    mapDisplay.calculateInnerMatrix();
  }
}",0.6415929203539823
99212,"public void set(float v){
  value=v;
}","public void set(double v){
  value=(float)v;
}",0.8095238095238095
99213,"public void target(float t){
  targeting=true;
  target=t;
}","public void target(double d){
  target((float)d);
}",0.6486486486486487
99214,"public void updateTuioCursor(TuioCursor tcur){
  int x=tcur.getScreenX(p.width);
  int y=tcur.getScreenY(p.height);
  for (  Map map : maps) {
    if (map.isHit(x,y)) {
      if (tuioCursor1 != null && tuioCursor2 != null) {
        boolean zoom=true;
        boolean rotate=true;
        PVector transCenter=new PVector();
        if (tuioCursor2.getCursorID() == tcur.getCursorID()) {
          transCenter.x=tuioCursor1.getScreenX(p.width);
          transCenter.y=tuioCursor1.getScreenY(p.height);
        }
 else {
          transCenter.x=tuioCursor2.getScreenX(p.width);
          transCenter.y=tuioCursor2.getScreenY(p.height);
        }
        if (zoom) {
          map.mapDisplay.setInnerTransformationCenter(transCenter);
          float newDist=getDistance(tuioCursor1,tuioCursor2);
          float scaleDelta=newDist / oldDist;
          oldDist=newDist;
          map.zoom(scaleDelta);
        }
        if (rotate) {
          map.mapDisplay.setTransformationCenter(transCenter);
          float newAngle=getAngleBetween(tuioCursor1,tuioCursor2);
          float angle=newAngle - oldAngle;
          oldAngle=newAngle;
          map.rotate(angle);
        }
      }
 else       if (tuioCursor1 != null) {
        Location fromLocation=map.mapDisplay.getLocationFromScreenPosition(oldX,oldY);
        Location toLocation=map.mapDisplay.getLocationFromScreenPosition(x,y);
        PanMapEvent panMapEvent=new PanMapEvent(this,map.getId(),PanMapEvent.PAN_BY);
        panMapEvent.setFromLocation(fromLocation);
        panMapEvent.setToLocation(toLocation);
        eventDispatcher.fireMapEvent(panMapEvent);
        oldX=x;
        oldY=y;
      }
    }
  }
}","public void updateTuioCursor(TuioCursor tcur){
  int x=tcur.getScreenX(p.width);
  int y=tcur.getScreenY(p.height);
  for (  Map map : maps) {
    if (map.isHit(x,y)) {
      if (tuioCursor1 != null && tuioCursor2 != null) {
        boolean zoom=true;
        boolean rotate=true;
        PVector transCenter=new PVector();
        if (tuioCursor2.getCursorID() == tcur.getCursorID()) {
          transCenter.x=tuioCursor1.getScreenX(p.width);
          transCenter.y=tuioCursor1.getScreenY(p.height);
        }
 else {
          transCenter.x=tuioCursor2.getScreenX(p.width);
          transCenter.y=tuioCursor2.getScreenY(p.height);
        }
        if (zoom) {
          map.mapDisplay.setInnerTransformationCenter(transCenter);
          float newDist=getDistance(tuioCursor1,tuioCursor2);
          float scaleDelta=newDist / oldDist;
          oldDist=newDist;
          map.zoom(scaleDelta);
        }
        if (rotate) {
          map.mapDisplay.setTransformationCenter(transCenter);
          float newAngle=getAngleBetween(tuioCursor1,tuioCursor2);
          float angle=newAngle - oldAngle;
          oldAngle=newAngle;
          map.rotate(angle);
        }
      }
 else       if (tuioCursor1 != null) {
        if (tuioCursor1.getCursorID() == tcur.getCursorID()) {
          Location fromLocation=map.mapDisplay.getLocationFromScreenPosition(oldX,oldY);
          Location toLocation=map.mapDisplay.getLocationFromScreenPosition(x,y);
          PanMapEvent panMapEvent=new PanMapEvent(this,map.getId(),PanMapEvent.PAN_BY);
          panMapEvent.setFromLocation(fromLocation);
          panMapEvent.setToLocation(toLocation);
          eventDispatcher.fireMapEvent(panMapEvent);
          oldX=x;
          oldY=y;
        }
      }
    }
  }
}",0.9740751529274688
99215,"protected Vector getVisibleKeys(PGraphics pg){
  int zoomLevel=Map.getZoomLevelFromScale((float)innerScale);
  float[] innerTL=getInnerObjectFromObjectPosition(0,0);
  float[] innerTR=getInnerObjectFromObjectPosition(getWidth(),0);
  float[] innerBR=getInnerObjectFromObjectPosition(getWidth(),getHeight());
  float[] innerBL=getInnerObjectFromObjectPosition(0,getHeight());
  Coordinate coordTL=getCoordinateFromInnerPosition(innerTL[0],innerTL[1]).zoomTo(zoomLevel);
  Coordinate coordTR=getCoordinateFromInnerPosition(innerTR[0],innerTR[1]).zoomTo(zoomLevel);
  Coordinate coordBR=getCoordinateFromInnerPosition(innerBR[0],innerBR[1]).zoomTo(zoomLevel);
  Coordinate coordBL=getCoordinateFromInnerPosition(innerBL[0],innerBL[1]).zoomTo(zoomLevel);
  int minCol=(int)PApplet.min(new float[]{coordTL.column,coordTR.column,coordBR.column,coordBL.column});
  int maxCol=(int)PApplet.max(new float[]{coordTL.column,coordTR.column,coordBR.column,coordBL.column});
  int minRow=(int)PApplet.min(new float[]{coordTL.row,coordTR.row,coordBR.row,coordBL.row});
  int maxRow=(int)PApplet.max(new float[]{coordTL.row,coordTR.row,coordBR.row,coordBL.row});
  minCol-=grid_padding;
  minRow-=grid_padding;
  maxCol+=grid_padding;
  maxRow+=grid_padding;
  int numberTiles=(int)Map.getScaleFromZoom(zoomLevel);
  minCol=PApplet.constrain(minCol,0,numberTiles);
  maxCol=PApplet.constrain(maxCol,0,numberTiles);
  minRow=PApplet.constrain(minRow,0,numberTiles);
  maxRow=PApplet.constrain(maxRow,0,numberTiles);
  Vector visibleKeys=new Vector();
  for (int col=minCol; col <= maxCol; col++) {
    for (int row=minRow; row <= maxRow; row++) {
      Coordinate coord=provider.sourceCoordinate(new Coordinate(row,col,zoomLevel));
      coord.roundValues();
      visibleKeys.add(coord);
      if (!images.containsKey(coord)) {
        grabTile(coord);
        boolean gotParent=false;
        for (int i=(int)coord.zoom; i > 0; i--) {
          Coordinate zoomed=coord.zoomTo(i).container();
          zoomed.roundValues();
          if (images.containsKey(zoomed)) {
            visibleKeys.add(zoomed);
            gotParent=true;
            break;
          }
        }
        if (!gotParent) {
          Coordinate zoomed=coord.zoomBy(1).container();
          Coordinate[] kids={zoomed,zoomed.right(),zoomed.down(),zoomed.right().down()};
          for (int i=0; i < kids.length; i++) {
            zoomed=kids[i];
            zoomed.row=PApplet.round(zoomed.row);
            zoomed.column=PApplet.round(zoomed.column);
            zoomed.zoom=PApplet.round(zoomed.zoom);
            if (images.containsKey(zoomed)) {
              visibleKeys.add(zoomed);
            }
          }
        }
      }
    }
  }
  Collections.sort(visibleKeys,zoomComparator);
  queue.retainAll(visibleKeys);
  queueSorter.setCenter(new Coordinate((minRow + maxRow) / 2.0f,(minCol + maxCol) / 2.0f,zoomLevel));
  Collections.sort(queue,queueSorter);
  processQueue();
  return visibleKeys;
}","protected Vector getVisibleKeys(PGraphics pg){
  Vector visibleKeys=new Vector();
  int minCol, maxCol, minRow, maxRow;
  int zoomLevel=Map.getZoomLevelFromScale((float)innerScale);
synchronized (this) {
    float[] innerTL=getInnerObjectFromObjectPosition(0,0);
    float[] innerTR=getInnerObjectFromObjectPosition(getWidth(),0);
    float[] innerBR=getInnerObjectFromObjectPosition(getWidth(),getHeight());
    float[] innerBL=getInnerObjectFromObjectPosition(0,getHeight());
    Coordinate coordTL=getCoordinateFromInnerPosition(innerTL[0],innerTL[1]).zoomTo(zoomLevel);
    Coordinate coordTR=getCoordinateFromInnerPosition(innerTR[0],innerTR[1]).zoomTo(zoomLevel);
    Coordinate coordBR=getCoordinateFromInnerPosition(innerBR[0],innerBR[1]).zoomTo(zoomLevel);
    Coordinate coordBL=getCoordinateFromInnerPosition(innerBL[0],innerBL[1]).zoomTo(zoomLevel);
    minCol=(int)PApplet.min(new float[]{coordTL.column,coordTR.column,coordBR.column,coordBL.column});
    maxCol=(int)PApplet.max(new float[]{coordTL.column,coordTR.column,coordBR.column,coordBL.column});
    minRow=(int)PApplet.min(new float[]{coordTL.row,coordTR.row,coordBR.row,coordBL.row});
    maxRow=(int)PApplet.max(new float[]{coordTL.row,coordTR.row,coordBR.row,coordBL.row});
  }
  minCol-=grid_padding;
  minRow-=grid_padding;
  maxCol+=grid_padding;
  maxRow+=grid_padding;
  int numberTiles=(int)Map.getScaleFromZoom(zoomLevel);
  minCol=PApplet.constrain(minCol,0,numberTiles);
  maxCol=PApplet.constrain(maxCol,0,numberTiles);
  minRow=PApplet.constrain(minRow,0,numberTiles);
  maxRow=PApplet.constrain(maxRow,0,numberTiles);
  for (int col=minCol; col <= maxCol; col++) {
    for (int row=minRow; row <= maxRow; row++) {
      Coordinate coord=provider.sourceCoordinate(new Coordinate(row,col,zoomLevel));
      coord.roundValues();
      visibleKeys.add(coord);
      if (!images.containsKey(coord)) {
        grabTile(coord);
        boolean gotParent=false;
        for (int i=(int)coord.zoom; i > 0; i--) {
          Coordinate zoomed=coord.zoomTo(i).container();
          zoomed.roundValues();
          if (images.containsKey(zoomed)) {
            visibleKeys.add(zoomed);
            gotParent=true;
            break;
          }
        }
        if (!gotParent) {
          Coordinate zoomed=coord.zoomBy(1).container();
          Coordinate[] kids={zoomed,zoomed.right(),zoomed.down(),zoomed.right().down()};
          for (int i=0; i < kids.length; i++) {
            zoomed=kids[i];
            zoomed.row=PApplet.round(zoomed.row);
            zoomed.column=PApplet.round(zoomed.column);
            zoomed.zoom=PApplet.round(zoomed.zoom);
            if (images.containsKey(zoomed)) {
              visibleKeys.add(zoomed);
            }
          }
        }
      }
    }
  }
  Collections.sort(visibleKeys,zoomComparator);
  queue.retainAll(visibleKeys);
  queueSorter.setCenter(new Coordinate((minRow + maxRow) / 2.0f,(minCol + maxCol) / 2.0f,zoomLevel));
  Collections.sort(queue,queueSorter);
  processQueue();
  return visibleKeys;
}",0.9723517654896736
99216,"public void calculateInnerMatrix(){
  PMatrix3D invMatrix=new PMatrix3D();
  invMatrix.apply(innerMatrix);
  invMatrix.invert();
  float originalCenterX=invMatrix.multX(innerTransformationCenter.x,innerTransformationCenter.y);
  float originalCenterY=invMatrix.multY(innerTransformationCenter.x,innerTransformationCenter.y);
  innerMatrix=new PMatrix3D();
  innerMatrix.translate(innerTransformationCenter.x,innerTransformationCenter.y);
  innerMatrix.scale(innerScale);
  innerMatrix.rotateZ(innerAngle);
  innerMatrix.translate(-originalCenterX,-originalCenterY);
}","public void calculateInnerMatrix(){
synchronized (this) {
    PMatrix3D invMatrix=new PMatrix3D();
    invMatrix.apply(innerMatrix);
    invMatrix.invert();
    float originalCenterX=invMatrix.multX(innerTransformationCenter.x,innerTransformationCenter.y);
    float originalCenterY=invMatrix.multY(innerTransformationCenter.x,innerTransformationCenter.y);
    innerMatrix=new PMatrix3D();
    innerMatrix.translate(innerTransformationCenter.x,innerTransformationCenter.y);
    innerMatrix.scale(innerScale);
    innerMatrix.rotateZ(innerAngle);
    innerMatrix.translate(-originalCenterX,-originalCenterY);
  }
}",0.9610169491525424
99217,"public float[] getInnerObjectFromLocation(Location location){
  PMatrix3D m=new PMatrix3D();
  Coordinate coord=provider.locationCoordinate(location).zoomTo(0);
  float[] out=new float[3];
  m.mult(new float[]{coord.column * TILE_WIDTH,coord.row * TILE_HEIGHT,0},out);
  return out;
}","public float[] getInnerObjectFromLocation(Location location){
  Coordinate coord=provider.locationCoordinate(location).zoomTo(0);
  return new float[]{coord.column * TILE_WIDTH,coord.row * TILE_HEIGHT,0};
}",0.8163265306122449
99218,"public void keyPressed(){
  if (key == '+') {
    float[] xy=map.mapDisplay.getScreenFromObjectPosition(map.mapDisplay.getWidth() / 2,map.mapDisplay.getHeight() / 2);
    PVector transCenter=new PVector(xy[0],xy[1]);
    map.mapDisplay.setInnerTransformationCenter(transCenter);
    map.zoomLevelIn();
  }
  if (key == '-') {
    map.zoomLevelOut();
  }
  if (key == '*') {
    map.zoomIn();
  }
  if (key == '_') {
    map.zoomOut();
  }
  if (key == 'c') {
    map.panTo(berlinLocation);
  }
  if (key == 'i') {
    PVector m=new PVector(mouseX,mouseY);
    map.mapDisplay.setTransformationCenter(m);
  }
  if (key == 'r') {
    map.rotate(PI / 20);
  }
  if (key == 'l') {
    map.rotate(-PI / 20);
  }
  if (key == 'o') {
    map.move(100,100);
  }
  if (key == CODED) {
    if (keyCode == RIGHT) {
      map.panRight();
    }
    if (keyCode == LEFT) {
      map.panLeft();
    }
    if (keyCode == DOWN) {
      map.panDown();
    }
    if (keyCode == UP) {
      map.panUp();
    }
  }
  if (key == '1') {
    map.zoomToLevel(1);
  }
  if (key == '2') {
    map.zoomToLevel(2);
  }
  if (key == '3') {
    map.zoomToLevel(3);
  }
  if (key == '4') {
    map.zoomToLevel(4);
  }
}","public void keyPressed(){
  if (key == '+') {
    float[] xy=map.mapDisplay.getScreenFromObjectPosition(map.mapDisplay.getWidth() / 2,map.mapDisplay.getHeight() / 2);
    PVector transCenter=new PVector(xy[0],xy[1]);
    map.mapDisplay.setInnerTransformationCenter(transCenter);
    map.zoomLevelIn();
  }
  if (key == '-') {
    map.zoomLevelOut();
  }
  if (key == '*') {
    map.zoomIn();
  }
  if (key == '_') {
    map.zoomOut();
  }
  if (key == 'c') {
    map.panTo(berlinLocation);
  }
  if (key == 'i') {
    PVector m=new PVector(mouseX,mouseY);
    map.mapDisplay.setTransformationCenter(m);
  }
  if (key == 'r') {
    map.rotate(PI / 20);
  }
  if (key == 'l') {
    map.rotate(-PI / 20);
  }
  if (key == 'R') {
    map.innerRotate(PI / 20);
  }
  if (key == 'L') {
    map.innerRotate(-PI / 20);
  }
  if (key == 'o') {
    map.move(100,100);
  }
  if (key == CODED) {
    if (keyCode == RIGHT) {
      map.panRight();
    }
    if (keyCode == LEFT) {
      map.panLeft();
    }
    if (keyCode == DOWN) {
      map.panDown();
    }
    if (keyCode == UP) {
      map.panUp();
    }
  }
  if (key == '1') {
    map.zoomToLevel(1);
  }
  if (key == '2') {
    map.zoomToLevel(2);
  }
  if (key == '3') {
    map.zoomToLevel(3);
  }
  if (key == '4') {
    map.zoomToLevel(4);
  }
}",0.9560661023780732
99219,"public void setup(){
  size(800,600,GLConstants.GLGRAPHICS);
  map=new Map(this,""String_Node_Str"",0,0,800,600);
  map.setTweening(false);
  debugDisplay=new DebugDisplay(this,map.mapDisplay,0,0,250,200);
  addMouseWheelListener(new java.awt.event.MouseWheelListener(){
    public void mouseWheelMoved(    java.awt.event.MouseWheelEvent evt){
      mouseWheel(evt.getWheelRotation());
    }
  }
);
}","public void setup(){
  size(800,600,GLConstants.GLGRAPHICS);
  map=new Map(this,""String_Node_Str"",50,50,700,500);
  map.setTweening(false);
  debugDisplay=new DebugDisplay(this,map.mapDisplay,0,0,250,200);
  addMouseWheelListener(new java.awt.event.MouseWheelListener(){
    public void mouseWheelMoved(    java.awt.event.MouseWheelEvent evt){
      mouseWheel(evt.getWheelRotation());
    }
  }
);
}",0.974937343358396
99220,"public void draw(){
  background(0);
  map.draw();
  debugDisplay.draw();
  Location location=map.mapDisplay.getLocationFromScreenPosition(mouseX,mouseY);
  fill(215,0,0);
  text(location + ""String_Node_Str"",mouseX,mouseY);
  float[] xy=map.mapDisplay.getScreenPositionFromLocation(berlinLocation);
  ellipse(xy[0],xy[1],10,10);
}","public void draw(){
  background(0);
  map.draw();
  debugDisplay.draw();
  noFill();
  strokeWeight(4);
  stroke(0,0,250,150);
  float[] tl=map.mapDisplay.getScreenFromObjectPosition(0,0);
  float[] tr=map.mapDisplay.getScreenFromObjectPosition(map.mapDisplay.getWidth(),0);
  float[] br=map.mapDisplay.getScreenFromObjectPosition(map.mapDisplay.getWidth(),map.mapDisplay.getHeight());
  float[] bl=map.mapDisplay.getScreenFromObjectPosition(0,map.mapDisplay.getHeight());
  beginShape();
  vertex(tl[0],tl[1]);
  vertex(tr[0],tr[1]);
  vertex(br[0],br[1]);
  vertex(bl[0],bl[1]);
  endShape(CLOSE);
  noStroke();
  Location location=map.mapDisplay.getLocationFromScreenPosition(mouseX,mouseY);
  fill(215,0,0);
  text(location + ""String_Node_Str"",mouseX,mouseY);
  float[] xy=map.mapDisplay.getScreenPositionFromLocation(berlinLocation);
  ellipse(xy[0],xy[1],10,10);
}",0.5495420482930891
99221,"/** 
 * Rotates the map by given angle. Whole map will be rotated, not only the inner display.
 * @param angle The angle to rotate the map by.
 */
public void rotate(float angle){
  outerRotate(angle);
}","/** 
 * Rotates the map by given angle. Whole map will be rotated, not only the inner display.
 * @param angle The angle to rotate the map by.
 */
public void rotate(float angle){
  innerRotate(angle);
}",0.9852216748768472
99222,"public void rotateTo(float angle){
  setOuterRotate(angle);
}","public void rotateTo(float angle){
  setInnerRotate(angle);
}",0.9508196721311476
99223,"protected void innerRotate(float angle){
  mapDisplay.innerAngle+=angle;
  mapDisplay.calculateInnerMatrix();
}","public void innerRotate(float angle){
  mapDisplay.innerAngle+=angle;
  mapDisplay.calculateInnerMatrix();
}",0.9497716894977168
99224,"protected Vector getVisibleKeys(PGraphics pg){
  float minX=pg.screenX(0,0);
  float minY=pg.screenY(0,0);
  float maxX=pg.screenX(TILE_WIDTH,TILE_HEIGHT);
  float maxY=pg.screenY(TILE_WIDTH,TILE_HEIGHT);
  int zoomLevel=Map.getZoomLevelFromScale((float)innerScale);
  int cols=(int)Map.getScaleFromZoom(zoomLevel);
  int rows=(int)Map.getScaleFromZoom(zoomLevel);
  float screenMinX=0;
  float screenMinY=0;
  float screenMaxX=width - TILE_WIDTH;
  float screenMaxY=height - TILE_HEIGHT;
  if (minX > maxX) {
    float t=minX;
    minX=maxX;
    maxX=t;
  }
  if (minY > maxY) {
    float t=minY;
    minY=maxY;
    maxY=t;
  }
  int minCol=(int)PApplet.floor(cols * (screenMinX - minX) / (maxX - minX));
  int maxCol=(int)PApplet.ceil(cols * (screenMaxX - minX) / (maxX - minX));
  int minRow=(int)PApplet.floor(rows * (screenMinY - minY) / (maxY - minY));
  int maxRow=(int)PApplet.ceil(rows * (screenMaxY - minY) / (maxY - minY));
  minCol-=grid_padding;
  minRow-=grid_padding;
  maxCol+=grid_padding;
  maxRow+=grid_padding;
  minCol=PApplet.constrain(minCol,0,cols);
  maxCol=PApplet.constrain(maxCol,0,cols);
  minRow=PApplet.constrain(minRow,0,rows);
  maxRow=PApplet.constrain(maxRow,0,rows);
  Vector visibleKeys=new Vector();
  for (int col=minCol; col <= maxCol; col++) {
    for (int row=minRow; row <= maxRow; row++) {
      Coordinate coord=provider.sourceCoordinate(new Coordinate(row,col,zoomLevel));
      coord.roundValues();
      visibleKeys.add(coord);
      if (!images.containsKey(coord)) {
        grabTile(coord);
        boolean gotParent=false;
        for (int i=(int)coord.zoom; i > 0; i--) {
          Coordinate zoomed=coord.zoomTo(i).container();
          zoomed.roundValues();
          if (images.containsKey(zoomed)) {
            visibleKeys.add(zoomed);
            gotParent=true;
            break;
          }
        }
        if (!gotParent) {
          Coordinate zoomed=coord.zoomBy(1).container();
          Coordinate[] kids={zoomed,zoomed.right(),zoomed.down(),zoomed.right().down()};
          for (int i=0; i < kids.length; i++) {
            zoomed=kids[i];
            zoomed.row=PApplet.round(zoomed.row);
            zoomed.column=PApplet.round(zoomed.column);
            zoomed.zoom=PApplet.round(zoomed.zoom);
            if (images.containsKey(zoomed)) {
              visibleKeys.add(zoomed);
            }
          }
        }
      }
    }
  }
  Collections.sort(visibleKeys,zoomComparator);
  queue.retainAll(visibleKeys);
  queueSorter.setCenter(new Coordinate((minRow + maxRow) / 2.0f,(minCol + maxCol) / 2.0f,zoomLevel));
  Collections.sort(queue,queueSorter);
  processQueue();
  return visibleKeys;
}","protected Vector getVisibleKeys(PGraphics pg){
  int zoomLevel=Map.getZoomLevelFromScale((float)innerScale);
  float[] innerTL=getInnerObjectFromObjectPosition(0,0);
  float[] innerTR=getInnerObjectFromObjectPosition(getWidth(),0);
  float[] innerBR=getInnerObjectFromObjectPosition(getWidth(),getHeight());
  float[] innerBL=getInnerObjectFromObjectPosition(0,getHeight());
  Coordinate coordTL=getCoordinateFromInnerPosition(innerTL[0],innerTL[1]).zoomTo(zoomLevel);
  Coordinate coordTR=getCoordinateFromInnerPosition(innerTR[0],innerTR[1]).zoomTo(zoomLevel);
  Coordinate coordBR=getCoordinateFromInnerPosition(innerBR[0],innerBR[1]).zoomTo(zoomLevel);
  Coordinate coordBL=getCoordinateFromInnerPosition(innerBL[0],innerBL[1]).zoomTo(zoomLevel);
  int minCol=(int)PApplet.min(new float[]{coordTL.column,coordTR.column,coordBR.column,coordBL.column});
  int maxCol=(int)PApplet.max(new float[]{coordTL.column,coordTR.column,coordBR.column,coordBL.column});
  int minRow=(int)PApplet.min(new float[]{coordTL.row,coordTR.row,coordBR.row,coordBL.row});
  int maxRow=(int)PApplet.max(new float[]{coordTL.row,coordTR.row,coordBR.row,coordBL.row});
  minCol-=grid_padding;
  minRow-=grid_padding;
  maxCol+=grid_padding;
  maxRow+=grid_padding;
  int numberTiles=(int)Map.getScaleFromZoom(zoomLevel);
  minCol=PApplet.constrain(minCol,0,numberTiles);
  maxCol=PApplet.constrain(maxCol,0,numberTiles);
  minRow=PApplet.constrain(minRow,0,numberTiles);
  maxRow=PApplet.constrain(maxRow,0,numberTiles);
  Vector visibleKeys=new Vector();
  for (int col=minCol; col <= maxCol; col++) {
    for (int row=minRow; row <= maxRow; row++) {
      Coordinate coord=provider.sourceCoordinate(new Coordinate(row,col,zoomLevel));
      coord.roundValues();
      visibleKeys.add(coord);
      if (!images.containsKey(coord)) {
        grabTile(coord);
        boolean gotParent=false;
        for (int i=(int)coord.zoom; i > 0; i--) {
          Coordinate zoomed=coord.zoomTo(i).container();
          zoomed.roundValues();
          if (images.containsKey(zoomed)) {
            visibleKeys.add(zoomed);
            gotParent=true;
            break;
          }
        }
        if (!gotParent) {
          Coordinate zoomed=coord.zoomBy(1).container();
          Coordinate[] kids={zoomed,zoomed.right(),zoomed.down(),zoomed.right().down()};
          for (int i=0; i < kids.length; i++) {
            zoomed=kids[i];
            zoomed.row=PApplet.round(zoomed.row);
            zoomed.column=PApplet.round(zoomed.column);
            zoomed.zoom=PApplet.round(zoomed.zoom);
            if (images.containsKey(zoomed)) {
              visibleKeys.add(zoomed);
            }
          }
        }
      }
    }
  }
  Collections.sort(visibleKeys,zoomComparator);
  queue.retainAll(visibleKeys);
  queueSorter.setCenter(new Coordinate((minRow + maxRow) / 2.0f,(minCol + maxCol) / 2.0f,zoomLevel));
  Collections.sort(queue,queueSorter);
  processQueue();
  return visibleKeys;
}",0.6866572036905607
99225,"public Location getLocationFromInnerObjectPosition(float x,float y){
  PMatrix3D m=new PMatrix3D();
  float tl[]=new float[3];
  m.mult(new float[]{0,0,0},tl);
  float br[]=new float[3];
  m.mult(new float[]{TILE_WIDTH,TILE_HEIGHT,0},br);
  float col=(x - tl[0]) / (br[0] - tl[0]);
  float row=(y - tl[1]) / (br[1] - tl[1]);
  Coordinate coord=new Coordinate(row,col,0);
  return provider.coordinateLocation(coord);
}","public Location getLocationFromInnerObjectPosition(float x,float y){
  Coordinate coord=getCoordinateFromInnerPosition(x,y);
  return provider.coordinateLocation(coord);
}",0.5136054421768708
99226,"public MarkerManager(Map map,List<E> markers){
  this.map=map;
  this.markers=markers;
}","public MarkerManager(Map map,List<E> markers){
  this.map=map;
  addMarkers(markers);
}",0.8685714285714285
99227,"public void addMarkers(List<E> markers){
  this.markers.addAll(markers);
}","public void addMarkers(List<E> markers){
  if (this.markers == null) {
    this.markers=new ArrayList<E>();
  }
  this.markers.addAll(markers);
}",0.6757990867579908
99228,"public boolean addMarker(E marker){
  if (markers == null) {
    markers=new ArrayList<E>();
  }
  if (markers.contains(marker))   return false;
  markers.add(marker);
  return true;
}","public boolean addMarker(E marker){
  if (markers == null) {
    this.markers=new ArrayList<E>();
  }
  if (markers.contains(marker))   return false;
  markers.add(marker);
  return true;
}",0.9865951742627346
99229,"public void drawOuter(){
  for (  Marker marker : markers) {
    PGraphics pg=map.mapDisplay.getPG();
    float[] xy=map.mapDisplay.getObjectFromLocation(marker.getLocation());
    float x=xy[0];
    float y=xy[1];
    marker.drawOuter(pg,x,y);
  }
}","public void drawOuter(){
  for (  Marker marker : markers) {
    PGraphics pg=map.mapDisplay.getOuterPG();
    float[] xy=map.mapDisplay.getObjectFromLocation(marker.getLocation());
    float x=xy[0];
    float y=xy[1];
    marker.drawOuter(pg,x,y);
  }
}",0.99009900990099
99230,"public Location getLocation(int x,int y){
  return mapDisplay.pointLocation(x,y);
}","public Location getLocation(float x,float y){
  return mapDisplay.pointLocation(x,y);
}",0.9294117647058824
99231,"public void mouseDragged(){
  for (  Map map : maps) {
    if (map.isHit(mouseX,mouseY)) {
      log.debug(""String_Node_Str"" + map.getId());
      Location newLocation=map.getLocation(mouseX,mouseY);
      Location oldLocation=map.getLocation(pmouseX,pmouseY);
      oldLocation.sub(newLocation);
      oldLocation.add(map.getCenter());
      PanMapEvent panMapEvent=new PanMapEvent(this,map.getId());
      panMapEvent.setLocation(oldLocation);
      panMapEvent.setTweening(false);
      eventDispatcher.fireMapEvent(panMapEvent);
    }
  }
}","public void mouseDragged(){
  for (  Map map : maps) {
    if (map.isHit(mouseX,mouseY)) {
      log.debug(""String_Node_Str"" + map.getId());
      PVector center=map.getScreenCenter();
      PVector mouse=new PVector(mouseX,mouseY);
      PVector pmouse=new PVector(pmouseX,pmouseY);
      pmouse.sub(mouse);
      pmouse.add(center);
      Location newCenter=map.getLocation(pmouse.x,pmouse.y);
      PanMapEvent panMapEvent=new PanMapEvent(this,map.getId());
      panMapEvent.setLocation(newCenter);
      panMapEvent.setTweening(false);
      eventDispatcher.fireMapEvent(panMapEvent);
    }
  }
}",0.5816593886462882
99232,"public void keyPressed(){
  rotateCenter=new PVector(mouseX,mouseY);
  if (key == 'r') {
    map.rotate(-0.1f,rotateCenter);
  }
 else   if (key == 'l') {
    map.rotate(0.1f,rotateCenter);
  }
}","public void keyPressed(){
  rotateCenter=new PVector(mouseX,mouseY);
  if (key == 'r') {
    map.rotate(-PI / 8,rotateCenter);
  }
 else   if (key == 'l') {
    map.rotate(PI / 8,rotateCenter);
  }
}",0.949238578680203
99233,"public void mouseClicked(){
}","public void mouseClicked(){
  rotateCenter=new PVector(mouseX,mouseY);
}",0.5742574257425742
99234,"public void keyPressed(){
  if (key == 'r') {
    map.rotate(-0.1f);
  }
 else   if (key == 'l') {
    map.rotate(0.1f);
  }
}","public void keyPressed(){
  if (key == 'r') {
    map.rotate(-PI / 8);
  }
 else   if (key == 'l') {
    map.rotate(PI / 8);
  }
}",0.921875
99235,"public void rotate(float diffAngle){
  rotate(diffAngle,new PVector(width / 2,height / 2));
}","public void rotate(float diffAngle){
  rotate(diffAngle,new PVector(width / 2 + x,height / 2 + y));
}",0.9587628865979382
99236,"public Location getCenter(){
  return mapDisplay.pointLocation(mapDisplay.width / 2 + x,mapDisplay.height / 2 + y);
}","public Location getCenter(){
  return mapDisplay.getCenter();
}",0.6222222222222222
99237,"public void rotateTo(float angle){
  rotateTo(angle,new PVector(width / 2,height / 2));
}","public void rotateTo(float angle){
  rotateTo(angle,new PVector(width / 2 + x,height / 2 + y));
}",0.956989247311828
99238,"public Location getLocation(int mouseX,int mouseY){
  log.debug(""String_Node_Str"" + id + ""String_Node_Str"");
  return mapDisplay.pointLocation(mouseX,mouseY);
}","public Location getLocation(int mouseX,int mouseY){
  return mapDisplay.pointLocation(mouseX,mouseY);
}",0.7832699619771863
99239,"public void keyPressed(char key,int keyCode){
  for (  Map map : maps) {
    if (map.isActive()) {
      log.debug(""String_Node_Str"" + key + ""String_Node_Str"");
      ZoomMapEvent zoomMapEvent=new ZoomMapEvent(this,map.getId());
      if (key == '+') {
        zoomMapEvent.setSubType(ZoomMapEvent.ZOOM_BY);
        zoomMapEvent.setZoomLevelDelta(1);
      }
 else       if (key == '-') {
        zoomMapEvent.setSubType(ZoomMapEvent.ZOOM_BY);
        zoomMapEvent.setZoomLevelDelta(-1);
      }
      eventDispatcher.fireMapEvent(zoomMapEvent);
    }
  }
}","public void keyPressed(char key,int keyCode){
  for (  Map map : maps) {
    if (map.isActive()) {
      log.debug(""String_Node_Str"" + key + ""String_Node_Str"");
      ZoomMapEvent zoomMapEvent=new ZoomMapEvent(this,map.getId());
      if (key == '+') {
        zoomMapEvent.setSubType(ZoomMapEvent.ZOOM_BY);
        zoomMapEvent.setZoomLevelDelta(1);
        eventDispatcher.fireMapEvent(zoomMapEvent);
      }
 else       if (key == '-') {
        zoomMapEvent.setSubType(ZoomMapEvent.ZOOM_BY);
        zoomMapEvent.setZoomLevelDelta(-1);
        eventDispatcher.fireMapEvent(zoomMapEvent);
      }
    }
  }
}",0.9434931506849316
99240,"/** 
 * Equals_other object.
 */
@Test public void equals_otherObject(){
  Assert.assertNotEquals(this.groupPrincipal,new String());
}","/** 
 * Equals_other object.
 */
@Test public void equals_otherObject(){
  Assert.assertNotEquals(this.groupPrincipal,""String_Node_Str"");
}",0.9377289377289376
99241,"/** 
 * Equals_other object.
 */
@Test public void equals_otherObject(){
  Assert.assertNotEquals(this.rolePrincipal,new String());
}","/** 
 * Equals_other object.
 */
@Test public void equals_otherObject(){
  Assert.assertNotEquals(this.rolePrincipal,""String_Node_Str"");
}",0.9372693726937268
99242,"/** 
 * Equals_other object.
 */
@Test public void equals_otherObject(){
  Assert.assertNotEquals(this.userPrincipal,new String());
}","/** 
 * Equals_other object.
 */
@Test public void equals_otherObject(){
  Assert.assertNotEquals(this.userPrincipal,""String_Node_Str"");
}",0.9372693726937268
99243,"/** 
 * Test role format sid.
 * @throws LoginException the login exception
 */
@Test public void testRoleFormatSid() throws LoginException {
  final Subject subject=new Subject();
  final UsernamePasswordCallbackHandler callbackHandler=new UsernamePasswordCallbackHandler(WindowsAccountImpl.getCurrentUsername(),""String_Node_Str"");
  final Map<String,String> options=new HashMap<>();
  options.put(""String_Node_Str"",""String_Node_Str"");
  options.put(""String_Node_Str"",""String_Node_Str"");
  this.loginModule.initialize(subject,callbackHandler,null,options);
  Assert.assertTrue(this.loginModule.login());
  Assert.assertTrue(this.loginModule.commit());
  Assert.assertEquals(2,subject.getPrincipals().size());
  Assert.assertTrue(subject.getPrincipals().contains(new GroupPrincipal(""String_Node_Str"")));
  for (  final Principal principal : subject.getPrincipals()) {
    if (principal instanceof GroupPrincipal) {
      int size=0;
      Enumeration<? extends Principal> groupPrincipal=((GroupPrincipal)principal).members();
      while (groupPrincipal.hasMoreElements()) {
        groupPrincipal.nextElement().getName().startsWith(""String_Node_Str"");
        size++;
      }
      Assert.assertEquals(2,size);
    }
 else {
      Assert.assertTrue(principal.getName().equals(WindowsAccountImpl.getCurrentUsername()));
    }
  }
}","/** 
 * Test role format sid.
 * @throws LoginException the login exception
 */
@Test public void testRoleFormatSid() throws LoginException {
  final Subject subject=new Subject();
  final UsernamePasswordCallbackHandler callbackHandler=new UsernamePasswordCallbackHandler(WindowsAccountImpl.getCurrentUsername(),""String_Node_Str"");
  final Map<String,String> options=new HashMap<>();
  options.put(""String_Node_Str"",""String_Node_Str"");
  options.put(""String_Node_Str"",""String_Node_Str"");
  this.loginModule.initialize(subject,callbackHandler,null,options);
  Assert.assertTrue(this.loginModule.login());
  Assert.assertTrue(this.loginModule.commit());
  Assert.assertEquals(2,subject.getPrincipals().size());
  Assert.assertTrue(subject.getPrincipals().contains(new GroupPrincipal(""String_Node_Str"")));
  for (  final Principal principal : subject.getPrincipals()) {
    if (principal instanceof GroupPrincipal) {
      int size=0;
      Enumeration<? extends Principal> groupPrincipal=((GroupPrincipal)principal).members();
      while (groupPrincipal.hasMoreElements()) {
        if (groupPrincipal.nextElement().getName().startsWith(""String_Node_Str"")) {
          size++;
        }
      }
      Assert.assertEquals(2,size);
    }
 else {
      Assert.assertTrue(principal.getName().equals(WindowsAccountImpl.getCurrentUsername()));
    }
  }
}",0.9917910447761196
99244,"@Override public IWindowsSecurityContext acceptSecurityToken(final String connectionId,final byte[] token,final String securityPackage){
  if (token == null || token.length == 0) {
    this.continueContexts.asMap().remove(connectionId);
    throw new Win32Exception(WinError.SEC_E_INVALID_TOKEN);
  }
  final IWindowsCredentialsHandle serverCredential=new WindowsCredentialsHandleImpl(null,Sspi.SECPKG_CRED_INBOUND,securityPackage);
  serverCredential.initialize();
  WindowsSecurityContextImpl sc;
  int rc;
  int tokenSize=Sspi.MAX_TOKEN_SIZE;
  CtxtHandle continueContext;
  SecBufferDesc pbServerToken;
  SecBufferDesc pbClientToken;
  final IntByReference pfClientContextAttr=new IntByReference();
  final CtxtHandle phNewServerContext=new CtxtHandle();
  do {
    pbServerToken=new SecBufferDesc(Sspi.SECBUFFER_TOKEN,tokenSize);
    pbClientToken=new SecBufferDesc(Sspi.SECBUFFER_TOKEN,token);
    continueContext=this.continueContexts.asMap().get(connectionId);
    rc=Secur32.INSTANCE.AcceptSecurityContext(serverCredential.getHandle(),continueContext,pbClientToken,Sspi.ISC_REQ_CONNECTION,Sspi.SECURITY_NATIVE_DREP,phNewServerContext,pbServerToken,pfClientContextAttr,null);
    sc=new WindowsSecurityContextImpl();
    sc.setCredentialsHandle(serverCredential.getHandle());
    sc.setSecurityPackage(securityPackage);
    sc.setSecurityContext(phNewServerContext);
switch (rc) {
case WinError.SEC_E_BUFFER_TOO_SMALL:
      tokenSize+=Sspi.MAX_TOKEN_SIZE;
    sc.dispose();
  WindowsSecurityContextImpl.dispose(continueContext);
break;
case WinError.SEC_E_OK:
this.continueContexts.asMap().remove(connectionId);
if (pbServerToken.pBuffers != null && pbServerToken.cBuffers == 1 && pbServerToken.pBuffers[0].cbBuffer > 0) {
sc.setToken(pbServerToken.getBytes().clone());
}
sc.setContinue(false);
break;
case WinError.SEC_I_CONTINUE_NEEDED:
this.continueContexts.put(connectionId,phNewServerContext);
sc.setToken(pbServerToken.getBytes().clone());
sc.setContinue(true);
break;
default :
sc.dispose();
WindowsSecurityContextImpl.dispose(continueContext);
this.continueContexts.asMap().remove(connectionId);
throw new Win32Exception(rc);
}
}
 while (rc == WinError.SEC_E_BUFFER_TOO_SMALL);
return sc;
}","@Override public IWindowsSecurityContext acceptSecurityToken(final String connectionId,final byte[] token,final String securityPackage){
  if (token == null || token.length == 0) {
    this.continueContexts.asMap().remove(connectionId);
    throw new Win32Exception(WinError.SEC_E_INVALID_TOKEN);
  }
  final IWindowsCredentialsHandle serverCredential=new WindowsCredentialsHandleImpl(null,Sspi.SECPKG_CRED_INBOUND,securityPackage);
  serverCredential.initialize();
  WindowsSecurityContextImpl sc;
  int rc;
  int tokenSize=Sspi.MAX_TOKEN_SIZE;
  CtxtHandle continueContext;
  SecBufferDesc pbServerToken;
  SecBufferDesc pbClientToken;
  final IntByReference pfClientContextAttr=new IntByReference();
  final CtxtHandle phNewServerContext=new CtxtHandle();
  do {
    pbServerToken=new SecBufferDesc(Sspi.SECBUFFER_TOKEN,tokenSize);
    pbClientToken=new SecBufferDesc(Sspi.SECBUFFER_TOKEN,token);
    continueContext=this.continueContexts.asMap().get(connectionId);
    rc=Secur32.INSTANCE.AcceptSecurityContext(serverCredential.getHandle(),continueContext,pbClientToken,Sspi.ISC_REQ_CONNECTION,Sspi.SECURITY_NATIVE_DREP,phNewServerContext,pbServerToken,pfClientContextAttr,null);
    sc=new WindowsSecurityContextImpl();
    sc.setCredentialsHandle(serverCredential.getHandle());
    sc.setSecurityPackage(securityPackage);
    sc.setSecurityContext(phNewServerContext);
switch (rc) {
case WinError.SEC_E_BUFFER_TOO_SMALL:
      tokenSize+=Sspi.MAX_TOKEN_SIZE;
    sc.dispose();
  WindowsSecurityContextImpl.dispose(continueContext);
break;
case WinError.SEC_E_OK:
this.continueContexts.asMap().remove(connectionId);
if (pbServerToken.pBuffers != null && pbServerToken.cBuffers == 1 && pbServerToken.pBuffers[0].cbBuffer > 0) {
sc.setToken(pbServerToken.getBytes() == null ? null : pbServerToken.getBytes().clone());
}
sc.setContinue(false);
break;
case WinError.SEC_I_CONTINUE_NEEDED:
this.continueContexts.put(connectionId,phNewServerContext);
sc.setToken(pbServerToken.getBytes() == null ? null : pbServerToken.getBytes().clone());
sc.setContinue(true);
break;
default :
sc.dispose();
WindowsSecurityContextImpl.dispose(continueContext);
this.continueContexts.asMap().remove(connectionId);
throw new Win32Exception(rc);
}
}
 while (rc == WinError.SEC_E_BUFFER_TOO_SMALL);
return sc;
}",0.9813250333481548
99245,"private boolean negotiate(final Request request,final Response response,final AuthorizationHeader authorizationHeader){
  final String securityPackage=authorizationHeader.getSecurityPackage();
  final String connectionId=NtlmServletRequest.getConnectionId(request);
  this.log.debug(""String_Node_Str"",securityPackage,connectionId);
  final boolean ntlmPost=authorizationHeader.isNtlmType1PostAuthorizationHeader();
  if (ntlmPost) {
    this.auth.resetSecurityToken(connectionId);
  }
  IWindowsSecurityContext securityContext;
  try {
    final byte[] tokenBuffer=authorizationHeader.getTokenBytes();
    this.log.debug(""String_Node_Str"",Integer.valueOf(tokenBuffer.length));
    securityContext=this.auth.acceptSecurityToken(connectionId,tokenBuffer,securityPackage);
    this.log.debug(""String_Node_Str"",Boolean.valueOf(securityContext.isContinue()));
    final byte[] continueTokenBytes=securityContext.getToken();
    if (continueTokenBytes != null && continueTokenBytes.length > 0) {
      final String continueToken=BaseEncoding.base64().encode(continueTokenBytes);
      this.log.debug(""String_Node_Str"",continueToken);
      response.addHeader(""String_Node_Str"",securityPackage + ""String_Node_Str"" + continueToken);
    }
    if (securityContext.isContinue() || ntlmPost) {
      response.setHeader(""String_Node_Str"",""String_Node_Str"");
      response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
      response.flushBuffer();
      return false;
    }
  }
 catch (  IOException e) {
    this.log.warn(""String_Node_Str"",e.getMessage());
    this.log.trace(""String_Node_Str"",e);
    sendUnauthorized(response);
    return false;
  }
  final IWindowsIdentity windowsIdentity=securityContext.getIdentity();
  if (!this.allowGuestLogin && windowsIdentity.isGuest()) {
    this.log.warn(""String_Node_Str"",windowsIdentity.getFqn());
    sendUnauthorized(response);
    return false;
  }
  try {
    this.log.debug(""String_Node_Str"",windowsIdentity.getFqn(),windowsIdentity.getSidString());
    final GenericWindowsPrincipal windowsPrincipal=new GenericWindowsPrincipal(windowsIdentity,this.context.getRealm(),this.principalFormat,this.roleFormat);
    this.log.debug(""String_Node_Str"",windowsPrincipal.getRolesString());
    final HttpSession session=request.getSession(true);
    this.log.debug(""String_Node_Str"",session.getId());
    register(request,response,windowsPrincipal,securityPackage,windowsPrincipal.getName(),null);
    this.log.info(""String_Node_Str"",windowsPrincipal.getName());
  }
  finally {
    windowsIdentity.dispose();
  }
  return true;
}","private boolean negotiate(final Request request,final Response response,final AuthorizationHeader authorizationHeader){
  final String securityPackage=authorizationHeader.getSecurityPackage();
  final String connectionId=NtlmServletRequest.getConnectionId(request);
  this.log.debug(""String_Node_Str"",securityPackage,connectionId);
  final boolean ntlmPost=authorizationHeader.isNtlmType1PostAuthorizationHeader();
  if (ntlmPost) {
    this.auth.resetSecurityToken(connectionId);
  }
  IWindowsSecurityContext securityContext;
  try {
    final byte[] tokenBuffer=authorizationHeader.getTokenBytes();
    this.log.debug(""String_Node_Str"",Integer.valueOf(tokenBuffer.length));
    securityContext=this.auth.acceptSecurityToken(connectionId,tokenBuffer,securityPackage);
    this.log.debug(""String_Node_Str"",Boolean.valueOf(securityContext.isContinue()));
    final byte[] continueTokenBytes=securityContext.getToken();
    if (continueTokenBytes != null && continueTokenBytes.length > 0) {
      final String continueToken=BaseEncoding.base64().encode(continueTokenBytes);
      this.log.debug(""String_Node_Str"",continueToken);
      response.addHeader(""String_Node_Str"",securityPackage + ""String_Node_Str"" + continueToken);
    }
    if (securityContext.isContinue() || ntlmPost) {
      response.setHeader(""String_Node_Str"",""String_Node_Str"");
      response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
      response.flushBuffer();
      return false;
    }
  }
 catch (  IOException e) {
    this.log.warn(""String_Node_Str"",e.getMessage());
    this.log.trace(""String_Node_Str"",e);
    sendUnauthorized(response);
    return false;
  }
  final IWindowsIdentity windowsIdentity=securityContext.getIdentity();
  if (!this.allowGuestLogin && windowsIdentity.isGuest()) {
    this.log.warn(""String_Node_Str"",windowsIdentity.getFqn());
    sendUnauthorized(response);
    return false;
  }
  try {
    this.log.debug(""String_Node_Str"",windowsIdentity.getFqn(),windowsIdentity.getSidString());
    final GenericWindowsPrincipal windowsPrincipal=new GenericWindowsPrincipal(windowsIdentity,this.context.getRealm(),this.principalFormat,this.roleFormat);
    this.log.debug(""String_Node_Str"",windowsPrincipal.getRolesString());
    final HttpSession session=request.getSession(true);
    this.log.debug(""String_Node_Str"",session == null ? ""String_Node_Str"" : session.getId());
    register(request,response,windowsPrincipal,securityPackage,windowsPrincipal.getName(),null);
    this.log.info(""String_Node_Str"",windowsPrincipal.getName());
  }
  finally {
    windowsIdentity.dispose();
  }
  return true;
}",0.9926527455529776
99246,"private boolean post(final Request request,final Response response){
  final String username=request.getParameter(""String_Node_Str"");
  final String password=request.getParameter(""String_Node_Str"");
  this.log.debug(""String_Node_Str"",username);
  IWindowsIdentity windowsIdentity;
  try {
    windowsIdentity=this.auth.logonUser(username,password);
  }
 catch (  Exception e) {
    this.log.error(e.getMessage());
    this.log.trace(""String_Node_Str"",e);
    return false;
  }
  if (!this.allowGuestLogin && windowsIdentity.isGuest()) {
    this.log.warn(""String_Node_Str"",windowsIdentity.getFqn());
    return false;
  }
  try {
    this.log.debug(""String_Node_Str"",username,windowsIdentity.getSidString());
    final GenericWindowsPrincipal windowsPrincipal=new GenericWindowsPrincipal(windowsIdentity,this.context.getRealm(),this.principalFormat,this.roleFormat);
    this.log.debug(""String_Node_Str"",windowsPrincipal.getRolesString());
    final HttpSession session=request.getSession(true);
    this.log.debug(""String_Node_Str"",session.getId());
    register(request,response,windowsPrincipal,""String_Node_Str"",windowsPrincipal.getName(),null);
    this.log.info(""String_Node_Str"",windowsPrincipal.getName());
  }
  finally {
    windowsIdentity.dispose();
  }
  return true;
}","private boolean post(final Request request,final Response response){
  final String username=request.getParameter(""String_Node_Str"");
  final String password=request.getParameter(""String_Node_Str"");
  this.log.debug(""String_Node_Str"",username);
  IWindowsIdentity windowsIdentity;
  try {
    windowsIdentity=this.auth.logonUser(username,password);
  }
 catch (  Exception e) {
    this.log.error(e.getMessage());
    this.log.trace(""String_Node_Str"",e);
    return false;
  }
  if (!this.allowGuestLogin && windowsIdentity.isGuest()) {
    this.log.warn(""String_Node_Str"",windowsIdentity.getFqn());
    return false;
  }
  try {
    this.log.debug(""String_Node_Str"",username,windowsIdentity.getSidString());
    final GenericWindowsPrincipal windowsPrincipal=new GenericWindowsPrincipal(windowsIdentity,this.context.getRealm(),this.principalFormat,this.roleFormat);
    this.log.debug(""String_Node_Str"",windowsPrincipal.getRolesString());
    final HttpSession session=request.getSession(true);
    this.log.debug(""String_Node_Str"",session == null ? ""String_Node_Str"" : session.getId());
    register(request,response,windowsPrincipal,""String_Node_Str"",windowsPrincipal.getName(),null);
    this.log.info(""String_Node_Str"",windowsPrincipal.getName());
  }
  finally {
    windowsIdentity.dispose();
  }
  return true;
}",0.9853958493466564
99247,"@Override public boolean authenticate(final Request request,final Response response,final LoginConfig loginConfig){
  Principal principal=request.getUserPrincipal();
  final AuthorizationHeader authorizationHeader=new AuthorizationHeader(request);
  final boolean ntlmPost=authorizationHeader.isNtlmType1PostAuthorizationHeader();
  this.log.debug(""String_Node_Str"",request.getMethod(),request.getRequestURI(),Integer.valueOf(request.getContentLength()));
  this.log.debug(""String_Node_Str"",authorizationHeader,Boolean.valueOf(ntlmPost));
  if (principal != null && !ntlmPost) {
    this.log.debug(""String_Node_Str"",principal.getName());
    return true;
  }
  if (!authorizationHeader.isNull()) {
    final String securityPackage=authorizationHeader.getSecurityPackage();
    final String connectionId=NtlmServletRequest.getConnectionId(request);
    this.log.debug(""String_Node_Str"",securityPackage,connectionId);
    if (ntlmPost) {
      this.auth.resetSecurityToken(connectionId);
    }
    IWindowsSecurityContext securityContext;
    try {
      byte[] tokenBuffer=authorizationHeader.getTokenBytes();
      this.log.debug(""String_Node_Str"",Integer.valueOf(tokenBuffer.length));
      securityContext=this.auth.acceptSecurityToken(connectionId,tokenBuffer,securityPackage);
      this.log.debug(""String_Node_Str"",Boolean.valueOf(securityContext.isContinue()));
      final byte[] continueTokenBytes=securityContext.getToken();
      if (continueTokenBytes != null && continueTokenBytes.length > 0) {
        final String continueToken=BaseEncoding.base64().encode(continueTokenBytes);
        this.log.debug(""String_Node_Str"",continueToken);
        response.addHeader(""String_Node_Str"",securityPackage + ""String_Node_Str"" + continueToken);
      }
      if (securityContext.isContinue() || ntlmPost) {
        response.setHeader(""String_Node_Str"",""String_Node_Str"");
        response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
        response.flushBuffer();
        return false;
      }
    }
 catch (    IOException e) {
      this.log.warn(""String_Node_Str"",e.getMessage());
      this.log.trace(""String_Node_Str"",e);
      sendUnauthorized(response);
      return false;
    }
    if (this.context == null || this.context.getRealm() == null) {
      this.log.warn(""String_Node_Str"");
      sendError(response,HttpServletResponse.SC_SERVICE_UNAVAILABLE);
      return false;
    }
    final IWindowsIdentity windowsIdentity=securityContext.getIdentity();
    if (!this.allowGuestLogin && windowsIdentity.isGuest()) {
      this.log.warn(""String_Node_Str"",windowsIdentity.getFqn());
      sendUnauthorized(response);
      return false;
    }
    try {
      this.log.debug(""String_Node_Str"",windowsIdentity.getFqn(),windowsIdentity.getSidString());
      final GenericWindowsPrincipal windowsPrincipal=new GenericWindowsPrincipal(windowsIdentity,this.context.getRealm(),this.principalFormat,this.roleFormat);
      this.log.debug(""String_Node_Str"",windowsPrincipal.getRolesString());
      principal=windowsPrincipal;
      final HttpSession session=request.getSession(true);
      this.log.debug(""String_Node_Str"",session.getId());
      register(request,response,principal,securityPackage,principal.getName(),null);
      this.log.info(""String_Node_Str"",principal.getName());
    }
  finally {
      windowsIdentity.dispose();
    }
    return true;
  }
  this.log.debug(""String_Node_Str"");
  sendUnauthorized(response);
  return false;
}","@Override public boolean authenticate(final Request request,final Response response,final LoginConfig loginConfig){
  Principal principal=request.getUserPrincipal();
  final AuthorizationHeader authorizationHeader=new AuthorizationHeader(request);
  final boolean ntlmPost=authorizationHeader.isNtlmType1PostAuthorizationHeader();
  this.log.debug(""String_Node_Str"",request.getMethod(),request.getRequestURI(),Integer.valueOf(request.getContentLength()));
  this.log.debug(""String_Node_Str"",authorizationHeader,Boolean.valueOf(ntlmPost));
  if (principal != null && !ntlmPost) {
    this.log.debug(""String_Node_Str"",principal.getName());
    return true;
  }
  if (!authorizationHeader.isNull()) {
    final String securityPackage=authorizationHeader.getSecurityPackage();
    final String connectionId=NtlmServletRequest.getConnectionId(request);
    this.log.debug(""String_Node_Str"",securityPackage,connectionId);
    if (ntlmPost) {
      this.auth.resetSecurityToken(connectionId);
    }
    IWindowsSecurityContext securityContext;
    try {
      byte[] tokenBuffer=authorizationHeader.getTokenBytes();
      this.log.debug(""String_Node_Str"",Integer.valueOf(tokenBuffer.length));
      securityContext=this.auth.acceptSecurityToken(connectionId,tokenBuffer,securityPackage);
      this.log.debug(""String_Node_Str"",Boolean.valueOf(securityContext.isContinue()));
      final byte[] continueTokenBytes=securityContext.getToken();
      if (continueTokenBytes != null && continueTokenBytes.length > 0) {
        final String continueToken=BaseEncoding.base64().encode(continueTokenBytes);
        this.log.debug(""String_Node_Str"",continueToken);
        response.addHeader(""String_Node_Str"",securityPackage + ""String_Node_Str"" + continueToken);
      }
      if (securityContext.isContinue() || ntlmPost) {
        response.setHeader(""String_Node_Str"",""String_Node_Str"");
        response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
        response.flushBuffer();
        return false;
      }
    }
 catch (    IOException e) {
      this.log.warn(""String_Node_Str"",e.getMessage());
      this.log.trace(""String_Node_Str"",e);
      sendUnauthorized(response);
      return false;
    }
    if (this.context == null || this.context.getRealm() == null) {
      this.log.warn(""String_Node_Str"");
      sendError(response,HttpServletResponse.SC_SERVICE_UNAVAILABLE);
      return false;
    }
    final IWindowsIdentity windowsIdentity=securityContext.getIdentity();
    if (!this.allowGuestLogin && windowsIdentity.isGuest()) {
      this.log.warn(""String_Node_Str"",windowsIdentity.getFqn());
      sendUnauthorized(response);
      return false;
    }
    try {
      this.log.debug(""String_Node_Str"",windowsIdentity.getFqn(),windowsIdentity.getSidString());
      final GenericWindowsPrincipal windowsPrincipal=new GenericWindowsPrincipal(windowsIdentity,this.context.getRealm(),this.principalFormat,this.roleFormat);
      this.log.debug(""String_Node_Str"",windowsPrincipal.getRolesString());
      principal=windowsPrincipal;
      final HttpSession session=request.getSession(true);
      this.log.debug(""String_Node_Str"",session == null ? ""String_Node_Str"" : session.getId());
      register(request,response,principal,securityPackage,principal.getName(),null);
      this.log.info(""String_Node_Str"",principal.getName());
    }
  finally {
      windowsIdentity.dispose();
    }
    return true;
  }
  this.log.debug(""String_Node_Str"");
  sendUnauthorized(response);
  return false;
}",0.9945339470655926
99248,"public void testLogin() throws LoginException {
  Subject subject=new Subject();
  UsernamePasswordCallbackHandler callbackHandler=new UsernamePasswordCallbackHandler(WindowsAccountImpl.getCurrentUsername(),""String_Node_Str"");
  Map<String,String> options=new HashMap<String,String>();
  options.put(""String_Node_Str"",""String_Node_Str"");
  _loginModule.initialize(subject,callbackHandler,null,options);
  assertTrue(_loginModule.login());
  assertEquals(0,subject.getPrincipals().size());
  assertTrue(_loginModule.commit());
  assertEquals(3,subject.getPrincipals().size());
  assertTrue(subject.getPrincipals().contains(""String_Node_Str""));
  assertTrue(subject.getPrincipals().contains(""String_Node_Str""));
  assertTrue(subject.getPrincipals().contains(WindowsAccountImpl.getCurrentUsername()));
  assertTrue(_loginModule.logout());
  assertTrue(subject.getPrincipals().size() == 0);
}","public void testLogin() throws LoginException {
  Subject subject=new Subject();
  UsernamePasswordCallbackHandler callbackHandler=new UsernamePasswordCallbackHandler(WindowsAccountImpl.getCurrentUsername(),""String_Node_Str"");
  Map<String,String> options=new HashMap<String,String>();
  options.put(""String_Node_Str"",""String_Node_Str"");
  _loginModule.initialize(subject,callbackHandler,null,options);
  assertTrue(_loginModule.login());
  assertEquals(0,subject.getPrincipals().size());
  assertTrue(_loginModule.commit());
  assertEquals(3,subject.getPrincipals().size());
  assertTrue(subject.getPrincipals().contains(new RolePrincipal(""String_Node_Str"")));
  assertTrue(subject.getPrincipals().contains(new RolePrincipal(""String_Node_Str"")));
  assertTrue(subject.getPrincipals().contains(new UserPrincipal(WindowsAccountImpl.getCurrentUsername())));
  assertTrue(_loginModule.logout());
  assertTrue(subject.getPrincipals().size() == 0);
}",0.9689034369885434
99249,"public void testGuestLogin() throws LoginException {
  Subject subject=new Subject();
  UsernamePasswordCallbackHandler callbackHandler=new UsernamePasswordCallbackHandler(""String_Node_Str"",""String_Node_Str"");
  Map<String,String> options=new HashMap<String,String>();
  options.put(""String_Node_Str"",""String_Node_Str"");
  _loginModule.initialize(subject,callbackHandler,null,options);
  assertTrue(_loginModule.getAllowGuestLogin());
  assertTrue(_loginModule.login());
  assertEquals(0,subject.getPrincipals().size());
  assertTrue(_loginModule.commit());
  assertEquals(3,subject.getPrincipals().size());
  assertTrue(subject.getPrincipals().contains(""String_Node_Str""));
  assertTrue(subject.getPrincipals().contains(""String_Node_Str""));
  _loginModule.setAllowGuestLogin(false);
  try {
    assertTrue(_loginModule.login());
    fail(""String_Node_Str"");
  }
 catch (  Exception e) {
    assertTrue(e instanceof LoginException);
  }
}","public void testGuestLogin() throws LoginException {
  Subject subject=new Subject();
  UsernamePasswordCallbackHandler callbackHandler=new UsernamePasswordCallbackHandler(""String_Node_Str"",""String_Node_Str"");
  Map<String,String> options=new HashMap<String,String>();
  options.put(""String_Node_Str"",""String_Node_Str"");
  _loginModule.initialize(subject,callbackHandler,null,options);
  assertTrue(_loginModule.getAllowGuestLogin());
  assertTrue(_loginModule.login());
  assertEquals(0,subject.getPrincipals().size());
  assertTrue(_loginModule.commit());
  assertEquals(3,subject.getPrincipals().size());
  assertTrue(subject.getPrincipals().contains(new RolePrincipal(""String_Node_Str"")));
  assertTrue(subject.getPrincipals().contains(new RolePrincipal(""String_Node_Str"")));
  _loginModule.setAllowGuestLogin(false);
  try {
    assertTrue(_loginModule.login());
    fail(""String_Node_Str"");
  }
 catch (  Exception e) {
    assertTrue(e instanceof LoginException);
  }
}",0.980146290491118
99250,"@Override public boolean equals(Object o){
  if (this == o) {
    return true;
  }
  if (o instanceof String) {
    return getName().equals(o);
  }
  if (o instanceof RolePrincipal) {
    return getName().equals(((RolePrincipal)o).getName());
  }
  return false;
}","@Override public boolean equals(Object o){
  if (this == o) {
    return true;
  }
  if (o instanceof RolePrincipal) {
    return getName().equals(((RolePrincipal)o).getName());
  }
  return false;
}",0.8596112311015118
99251,"@Override public boolean equals(Object o){
  if (this == o) {
    return true;
  }
  if (o instanceof String) {
    return getName().equals(o);
  }
  if (o instanceof UserPrincipal) {
    return getName().equals(((UserPrincipal)o).getName());
  }
  return false;
}","@Override public boolean equals(Object o){
  if (this == o) {
    return true;
  }
  if (o instanceof UserPrincipal) {
    return getName().equals(((UserPrincipal)o).getName());
  }
  return false;
}",0.8596112311015118
99252,"public void testIsSerializable() throws IOException, ClassNotFoundException {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  ObjectOutputStream oos=new ObjectOutputStream(out);
  oos.writeObject(_windowsPrincipal);
  oos.close();
  assertTrue(out.toByteArray().length > 0);
  InputStream in=new ByteArrayInputStream(out.toByteArray());
  ObjectInputStream ois=new ObjectInputStream(in);
  Object o=ois.readObject();
  WindowsPrincipal copy=(WindowsPrincipal)o;
  assertEquals(_windowsPrincipal.getName(),copy.getName());
  assertEquals(_windowsPrincipal.getRolesString(),copy.getRolesString());
  assertEquals(_windowsPrincipal.getSidString(),copy.getSidString());
  assertEquals(_windowsPrincipal.getSid(),copy.getSid());
}","public void testIsSerializable() throws IOException, ClassNotFoundException {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  ObjectOutputStream oos=new ObjectOutputStream(out);
  oos.writeObject(_windowsPrincipal);
  oos.close();
  assertTrue(out.toByteArray().length > 0);
  InputStream in=new ByteArrayInputStream(out.toByteArray());
  ObjectInputStream ois=new ObjectInputStream(in);
  Object o=ois.readObject();
  WindowsPrincipal copy=(WindowsPrincipal)o;
  assertEquals(_windowsPrincipal.getName(),copy.getName());
  assertEquals(_windowsPrincipal.getRolesString(),copy.getRolesString());
  assertEquals(_windowsPrincipal.getSidString(),copy.getSidString());
  assertEquals(Arrays.equals(_windowsPrincipal.getSid(),copy.getSid()),true);
}",0.9865951742627346
99253,"public void testIsSerializable() throws IOException, ClassNotFoundException {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  ObjectOutputStream oos=new ObjectOutputStream(out);
  oos.writeObject(_windowsPrincipal);
  oos.close();
  assertTrue(out.toByteArray().length > 0);
  InputStream in=new ByteArrayInputStream(out.toByteArray());
  ObjectInputStream ois=new ObjectInputStream(in);
  Object o=ois.readObject();
  WindowsPrincipal copy=(WindowsPrincipal)o;
  assertEquals(_windowsPrincipal.getName(),copy.getName());
  assertEquals(_windowsPrincipal.getRolesString(),copy.getRolesString());
  assertEquals(_windowsPrincipal.getSidString(),copy.getSidString());
  assertEquals(_windowsPrincipal.getSid(),copy.getSid());
}","public void testIsSerializable() throws IOException, ClassNotFoundException {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  ObjectOutputStream oos=new ObjectOutputStream(out);
  oos.writeObject(_windowsPrincipal);
  oos.close();
  assertTrue(out.toByteArray().length > 0);
  InputStream in=new ByteArrayInputStream(out.toByteArray());
  ObjectInputStream ois=new ObjectInputStream(in);
  Object o=ois.readObject();
  WindowsPrincipal copy=(WindowsPrincipal)o;
  assertEquals(_windowsPrincipal.getName(),copy.getName());
  assertEquals(_windowsPrincipal.getRolesString(),copy.getRolesString());
  assertEquals(_windowsPrincipal.getSidString(),copy.getSidString());
  assertEquals(Arrays.equals(_windowsPrincipal.getSid(),copy.getSid()),true);
}",0.9865951742627346
99254,"/** 
 * Return output format (list of fields), given input format   {@code format}. Intermediaries should call   {@code modifyOutputFormat(format)} on nestedprocessor first, then make appropriate changes to it if they add/remove fields.
 * @param format input format
 * @return output format
 * @see CDXFieldConstants
 */
public FieldSplitFormat modifyOutputFormat(FieldSplitFormat format);","/** 
 * Return output format (list of fields), given input format   {@code format}. Intermediaries should call   {@code modifyOutputFormat(format)} on nestedprocessor first, then make appropriate changes to it if they add/remove fields.
 * @param format input format
 * @return output format
 */
public FieldSplitFormat modifyOutputFormat(FieldSplitFormat format);",0.9655172413793104
99255,"/** 
 * Return name of this exclusion context.
 * @return
 */
public String getCollectionContextName();","/** 
 * Return name of this exclusion context.
 * @return the name of this exclusion context
 */
public String getCollectionContextName();",0.8547717842323651
99256,"private static String getDaysInMonthBound(int year,int month){
  Calendar cal=Calendar.getInstance(TimeZone.getTimeZone(""String_Node_Str""));
  cal.set(Calendar.YEAR,year);
  cal.set(Calendar.MONTH,month);
  return new Integer(cal.getActualMaximum(Calendar.DAY_OF_MONTH)).toString();
}","private static String getDaysInMonthBound(int year,int month){
  Calendar cal=Calendar.getInstance(TimeZone.getTimeZone(""String_Node_Str""));
  cal.set(Calendar.YEAR,year);
  cal.set(Calendar.MONTH,month);
  cal.set(Calendar.DAY_OF_MONTH,1);
  return new Integer(cal.getActualMaximum(Calendar.DAY_OF_MONTH)).toString();
}",0.8112582781456954
99257,"@SuppressWarnings(""String_Node_Str"") public String[] nameToUrls(String name) throws IOException {
  ArrayList<String> urls=new ArrayList<String>();
  String prefix=name + delimiter;
  Iterator<String> itr=flatFile.getRecordIterator(prefix);
  while (itr.hasNext()) {
    String line=itr.next();
    if (line.startsWith(prefix)) {
      urls.add(line.substring(prefix.length()));
    }
 else {
      break;
    }
  }
  if (urls.size() == 0 && name.indexOf(""String_Node_Str"") == -1 && !name.endsWith(""String_Node_Str"")) {
    prefix=name + ""String_Node_Str"" + delimiter;
    itr=flatFile.getRecordIterator(prefix + ""String_Node_Str"");
    while (itr.hasNext()) {
      String line=itr.next();
      if (line.startsWith(prefix)) {
        urls.add(line.substring(prefix.length()));
      }
 else {
        break;
      }
    }
  }
  if (itr instanceof CloseableIterator) {
    CloseableIterator<String> citr=(CloseableIterator<String>)itr;
    citr.close();
  }
  if (urls.size() == 0) {
    LOGGER.info(""String_Node_Str"" + name + ""String_Node_Str""+ path);
  }
  String[] a=new String[urls.size()];
  for (int i=0; i < urls.size(); i++) {
    a[i]=urls.get(i);
  }
  return a;
}","@SuppressWarnings(""String_Node_Str"") public String[] nameToUrls(String name) throws IOException {
  ArrayList<String> urls=new ArrayList<String>();
  String prefix=name + delimiter;
  Iterator<String> itr=flatFile.getRecordIterator(prefix);
  while (itr.hasNext()) {
    String line=itr.next();
    if (line.startsWith(prefix)) {
      urls.add(line.substring(prefix.length()));
    }
 else {
      break;
    }
  }
  if (urls.size() == 0 && name.indexOf(""String_Node_Str"") == -1 && !name.endsWith(""String_Node_Str"")) {
    prefix=name + ""String_Node_Str"" + delimiter;
    itr=flatFile.getRecordIterator(prefix + ""String_Node_Str"");
    while (itr.hasNext()) {
      String line=itr.next();
      if (line.startsWith(prefix)) {
        urls.add(line.substring(prefix.length()));
      }
 else {
        break;
      }
    }
  }
 else   if (name.indexOf(""String_Node_Str"") == -1 && name.endsWith(""String_Node_Str"")) {
    prefix=name.substring(0,name.length() - 1) + delimiter;
    itr=flatFile.getRecordIterator(prefix + ""String_Node_Str"");
    while (itr.hasNext()) {
      String line=itr.next();
      if (line.startsWith(prefix)) {
        urls.add(line.substring(prefix.length()));
      }
 else {
        break;
      }
    }
  }
  if (itr instanceof CloseableIterator) {
    CloseableIterator<String> citr=(CloseableIterator<String>)itr;
    citr.close();
  }
  if (urls.size() == 0) {
    LOGGER.info(""String_Node_Str"" + name + ""String_Node_Str""+ path);
  }
  String[] a=new String[urls.size()];
  for (int i=0; i < urls.size(); i++) {
    a[i]=urls.get(i);
  }
  return a;
}",0.8520667150108775
99258,"/** 
 * Returns true if this Canonicalizer returns SURTs, false is URLs
 * @return
 */
public boolean isSurtForm();","/** 
 * Returns true if this Canonicalizer returns SURTs, false is URLs
 * @return <b>true</b> if SURTs are returned <b>false</b> otherwise.
 */
public boolean isSurtForm();",0.7986111111111112
99259,"/** 
 * Does this policy effectively allow everything? (No  disallows or timing (crawl-delay) directives?)
 * @return
 */
public boolean allowsAll(){
  return agentsToDirectives.isEmpty();
}","/** 
 * Does this policy effectively allow everything? (No  disallows or timing (crawl-delay) directives?)
 * @return <b>true</b> if the map containing user-agents to directives is empty, <b>false</b> otherwise.
 */
public boolean allowsAll(){
  return agentsToDirectives.isEmpty();
}",0.8016877637130801
99260,"public int filterObject(CaptureSearchResult r){
  if (!notifiedSeen) {
    if (filterGroup != null) {
      filterGroup.setSawAdministrative();
    }
    notifiedSeen=true;
  }
  String surt;
  try {
    String url=canonicalizer.urlStringToKey(r.getOriginalUrl());
    surt=SURT.fromPlain(url);
  }
 catch (  URIException e) {
    return FILTER_EXCLUDE;
  }
  if (lastChecked != null) {
    if (lastChecked.equals(surt)) {
      if (lastCheckedExcluded) {
        return ObjectFilter.FILTER_EXCLUDE;
      }
 else {
        return ObjectFilter.FILTER_INCLUDE;
      }
    }
  }
  lastChecked=surt;
  lastCheckedExcluded=isExcluded(surt);
  if (lastCheckedExcluded) {
    return ObjectFilter.FILTER_EXCLUDE;
  }
 else {
    if (!notifiedPassed) {
      if (filterGroup != null) {
        filterGroup.setPassedAdministrative();
      }
      notifiedPassed=true;
    }
    return ObjectFilter.FILTER_INCLUDE;
  }
}","@Override public int filterObject(CaptureSearchResult r){
  if (!notifiedSeen) {
    if (filterGroup != null) {
      filterGroup.setSawAdministrative();
    }
    notifiedSeen=true;
  }
  String surt;
  try {
    String url=canonicalizer.urlStringToKey(r.getOriginalUrl());
    surt=SURT.fromPlain(url);
  }
 catch (  URIException e) {
    return FILTER_EXCLUDE;
  }
  if (lastChecked != null) {
    if (lastChecked.equals(surt)) {
      if (lastCheckedExcluded) {
        return ObjectFilter.FILTER_EXCLUDE;
      }
 else {
        return ObjectFilter.FILTER_INCLUDE;
      }
    }
  }
  lastChecked=surt;
  lastCheckedExcluded=isExcluded(surt);
  if (lastCheckedExcluded) {
    return ObjectFilter.FILTER_EXCLUDE;
  }
 else {
    if (!notifiedPassed) {
      if (filterGroup != null) {
        filterGroup.setPassedAdministrative();
      }
      notifiedPassed=true;
    }
    return ObjectFilter.FILTER_INCLUDE;
  }
}",0.9945474372955287
99261,"/** 
 * @param map where each String key is a SURT that is blocked.
 */
public StaticListExclusionFilter(TreeSet<String> exclusions,UrlCanonicalizer canonicalizer){
  this.exclusions=exclusions;
  this.canonicalizer=canonicalizer;
}","/** 
 * @param exclusions
 * @param canonicalizer
 */
public StaticListExclusionFilter(TreeSet<String> exclusions,UrlCanonicalizer canonicalizer){
  this.exclusions=exclusions;
  this.canonicalizer=canonicalizer;
}",0.8116591928251121
99262,"/** 
 * Given a date, create a new datespec + flags which represent the same options as requested by the WaybackRequest
 * @param timestamp the 14-digit timestamp to use
 * @return a String representing the flags on the WaybackRequest for thespecified date
 */
public static String getDateSpec(WaybackRequest wbRequest,String datespec){
  int dateLen=0;
  if (datespec != null) {
    dateLen=datespec.length();
  }
  StringBuilder sb=new StringBuilder(dateLen + 10);
  if (dateLen > 0) {
    sb.append(datespec);
  }
  if (wbRequest.isCSSContext()) {
    sb.append(ArchivalUrlRequestParser.CSS_CONTEXT);
    sb.append(ArchivalUrlRequestParser.FLAG_DELIM);
    dateLen++;
  }
  if (wbRequest.isJSContext()) {
    sb.append(ArchivalUrlRequestParser.JS_CONTEXT);
    sb.append(ArchivalUrlRequestParser.FLAG_DELIM);
    dateLen++;
  }
  if (wbRequest.isIMGContext()) {
    sb.append(ArchivalUrlRequestParser.IMG_CONTEXT);
    sb.append(ArchivalUrlRequestParser.FLAG_DELIM);
    dateLen++;
  }
  if (wbRequest.isObjectEmbedContext()) {
    sb.append(ArchivalUrlRequestParser.OBJECT_EMBED_WRAPPED_CONTEXT);
    sb.append(ArchivalUrlRequestParser.FLAG_DELIM);
    dateLen++;
  }
  if (wbRequest.isIdentityContext()) {
    sb.append(ArchivalUrlRequestParser.IDENTITY_CONTEXT);
    sb.append(ArchivalUrlRequestParser.FLAG_DELIM);
    dateLen++;
  }
  if (wbRequest.isIFrameWrapperContext()) {
    sb.append(ArchivalUrlRequestParser.IFRAME_WRAPPED_CONTEXT);
    sb.append(ArchivalUrlRequestParser.FLAG_DELIM);
    dateLen++;
  }
  if (wbRequest.isFrameWrapperContext()) {
    sb.append(ArchivalUrlRequestParser.FRAME_WRAPPED_CONTEXT);
    sb.append(ArchivalUrlRequestParser.FLAG_DELIM);
    dateLen++;
  }
  return sb.toString();
}","/** 
 * Given a date, create a new datespec + flags which represent the same options as requested by the WaybackRequest
 * @param wbRequest
 * @param datespec The date specification prefix.
 * @return a String representing the flags on the WaybackRequest for thespecified date
 */
public static String getDateSpec(WaybackRequest wbRequest,String datespec){
  int dateLen=0;
  if (datespec != null) {
    dateLen=datespec.length();
  }
  StringBuilder sb=new StringBuilder(dateLen + 10);
  if (dateLen > 0) {
    sb.append(datespec);
  }
  if (wbRequest.isCSSContext()) {
    sb.append(ArchivalUrlRequestParser.CSS_CONTEXT);
    sb.append(ArchivalUrlRequestParser.FLAG_DELIM);
    dateLen++;
  }
  if (wbRequest.isJSContext()) {
    sb.append(ArchivalUrlRequestParser.JS_CONTEXT);
    sb.append(ArchivalUrlRequestParser.FLAG_DELIM);
    dateLen++;
  }
  if (wbRequest.isIMGContext()) {
    sb.append(ArchivalUrlRequestParser.IMG_CONTEXT);
    sb.append(ArchivalUrlRequestParser.FLAG_DELIM);
    dateLen++;
  }
  if (wbRequest.isObjectEmbedContext()) {
    sb.append(ArchivalUrlRequestParser.OBJECT_EMBED_WRAPPED_CONTEXT);
    sb.append(ArchivalUrlRequestParser.FLAG_DELIM);
    dateLen++;
  }
  if (wbRequest.isIdentityContext()) {
    sb.append(ArchivalUrlRequestParser.IDENTITY_CONTEXT);
    sb.append(ArchivalUrlRequestParser.FLAG_DELIM);
    dateLen++;
  }
  if (wbRequest.isIFrameWrapperContext()) {
    sb.append(ArchivalUrlRequestParser.IFRAME_WRAPPED_CONTEXT);
    sb.append(ArchivalUrlRequestParser.FLAG_DELIM);
    dateLen++;
  }
  if (wbRequest.isFrameWrapperContext()) {
    sb.append(ArchivalUrlRequestParser.FRAME_WRAPPED_CONTEXT);
    sb.append(ArchivalUrlRequestParser.FLAG_DELIM);
    dateLen++;
  }
  return sb.toString();
}",0.972848064702484
99263,"public String makeReplayURI(String datespec,String url){
  String suffix=datespec + context + ""String_Node_Str""+ url;
  String prefix=converter.getReplayURIPrefix();
  if (prefix == null) {
    return suffix;
  }
 else {
    if (url.startsWith(prefix)) {
      return url;
    }
    return prefix + suffix;
  }
}","@Override public String makeReplayURI(String datespec,String url){
  String suffix=datespec + context + ""String_Node_Str""+ url;
  String prefix=converter.getReplayURIPrefix();
  if (prefix == null) {
    return suffix;
  }
 else {
    if (url.startsWith(prefix)) {
      return url;
    }
    return prefix + suffix;
  }
}",0.9842271293375394
99264,"/** 
 * @param converter ArchivalUrlResultURIConverter to wrap
 * @param context flags indicating the context of URLs created by thisobject
 */
public ArchivalUrlSpecialContextResultURIConverter(String context){
  this.context=context;
}","/** 
 * @param context flags indicating the context of URLs created by thisobject
 */
public ArchivalUrlSpecialContextResultURIConverter(String context){
  this.context=context;
}",0.8605769230769231
99265,"public ResultURIConverter getContextConverter(String flags){
  if (flags == null) {
    return converter;
  }
  return new ArchivalUrlSpecialContextResultURIConverter(flags);
}","@Override public ResultURIConverter getContextConverter(String flags){
  if (flags == null) {
    return converter;
  }
  return new ArchivalUrlSpecialContextResultURIConverter(flags);
}",0.9723756906077348
99266,"/** 
 * @param endJsp the path to the JSP to execute and include at the startof the document
 */
public void setStartJsp(String startJsp){
  this.startJsp=startJsp;
}","/** 
 * @param startJsp The path to the JSP to execute and include at the startof the document
 */
public void setStartJsp(String startJsp){
  this.startJsp=startJsp;
}",0.9700598802395208
99267,"public void handleParseStart(ParseContext pContext) throws IOException {
  ReplayParseContext context=(ReplayParseContext)pContext;
  String policy=context.getJspExec().getUiResults().getResult().getOraclePolicy();
  if (policy != null) {
    context.setOraclePolicy(policy);
  }
  if (startJsp != null) {
    OutputStream out=context.getOutputStream();
    String tmp=null;
    try {
      tmp=context.getJspExec().jspToString(startJsp);
    }
 catch (    ServletException e) {
      e.printStackTrace();
    }
    if (tmp != null) {
      String charset=context.getOutputCharset();
      out.write(tmp.getBytes(charset));
    }
  }
}","/** 
 * @param pContext
 * @throws IOException
 */
@Override public void handleParseStart(ParseContext pContext) throws IOException {
  ReplayParseContext context=(ReplayParseContext)pContext;
  String policy=context.getJspExec().getUiResults().getResult().getOraclePolicy();
  if (policy != null) {
    context.setOraclePolicy(policy);
  }
  if (startJsp != null) {
    OutputStream out=context.getOutputStream();
    String tmp=null;
    try {
      tmp=context.getJspExec().jspToString(startJsp);
    }
 catch (    ServletException e) {
      e.printStackTrace();
    }
    if (tmp != null) {
      String charset=context.getOutputCharset();
      out.write(tmp.getBytes(charset));
    }
  }
}",0.9541697971450036
99268,"public void handleParseComplete(ParseContext pContext) throws IOException {
  if (endJsp != null && pContext.isInHTML()) {
    ReplayParseContext context=(ReplayParseContext)pContext;
    OutputStream out=context.getOutputStream();
    String tmp=null;
    try {
      tmp=context.getJspExec().jspToString(endJsp);
    }
 catch (    ServletException e) {
      e.printStackTrace();
    }
    if (tmp != null) {
      String charset=context.getOutputCharset();
      out.write(tmp.getBytes(charset));
    }
  }
}","/** 
 * @param pContext
 * @throws IOException
 */
@Override public void handleParseComplete(ParseContext pContext) throws IOException {
  if (endJsp != null && pContext.isInHTML()) {
    ReplayParseContext context=(ReplayParseContext)pContext;
    OutputStream out=context.getOutputStream();
    String tmp=null;
    try {
      tmp=context.getJspExec().jspToString(endJsp);
    }
 catch (    ServletException e) {
      e.printStackTrace();
    }
    if (tmp != null) {
      String charset=context.getOutputCharset();
      out.write(tmp.getBytes(charset));
    }
  }
}",0.943674976915974
99269,"public void handleNode(ParseContext pContext,Node node) throws IOException {
  ReplayParseContext context=(ReplayParseContext)pContext;
  if (NodeUtils.isRemarkNode(node)) {
    RemarkNode remarkNode=(RemarkNode)node;
    remarkNode.setText(jsBlockTrans.transform(context,remarkNode.getText()));
    emit(context,null,node,null);
  }
 else   if (NodeUtils.isTextNode(node)) {
    TextNode textNode=(TextNode)node;
    if (context.isInCSS()) {
      handleCSSTextNode(context,textNode);
    }
 else     if (context.isInScriptText()) {
      handleJSTextNode(context,textNode);
    }
    emit(context,null,textNode,null);
  }
 else   if (NodeUtils.isTagNode(node)) {
    TagNode tagNode=(TagNode)node;
    if (tagNode.isEndTag()) {
      if (tagNode.getTagName().equals(""String_Node_Str"")) {
        context.putData(FERRET_IN_HEAD,null);
      }
      if (checkAllowTag(pContext,tagNode)) {
        emit(context,null,tagNode,null);
      }
    }
 else     if (tagNode.getTagName().startsWith(""String_Node_Str"")) {
      String text=tagNode.getText();
      int s=""String_Node_Str"".length();
      int e=text.endsWith(""String_Node_Str"") ? text.length() - 2 : text.length();
      if (context.isInCSS()) {
        TextNode textNode=new TextNode(text.substring(s,e));
        handleCSSTextNode(context,textNode);
        emit(context,""String_Node_Str"",textNode,""String_Node_Str"");
      }
 else       if (context.isInScriptText()) {
        TextNode textNode=new TextNode(text.substring(s,e));
        handleJSTextNode(context,textNode);
        emit(context,""String_Node_Str"",textNode,""String_Node_Str"");
      }
 else {
        emit(context,null,tagNode,null);
      }
    }
 else {
      context.setInHTML(true);
      handleOpenTagNode(context,tagNode);
    }
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}","/** 
 * @param pContext
 * @param node
 * @throws IOException
 */
@Override public void handleNode(ParseContext pContext,Node node) throws IOException {
  ReplayParseContext context=(ReplayParseContext)pContext;
  if (NodeUtils.isRemarkNode(node)) {
    RemarkNode remarkNode=(RemarkNode)node;
    remarkNode.setText(jsBlockTrans.transform(context,remarkNode.getText()));
    emit(context,null,node,null);
  }
 else   if (NodeUtils.isTextNode(node)) {
    TextNode textNode=(TextNode)node;
    if (context.isInCSS()) {
      handleCSSTextNode(context,textNode);
    }
 else     if (context.isInScriptText()) {
      handleJSTextNode(context,textNode);
    }
    emit(context,null,textNode,null);
  }
 else   if (NodeUtils.isTagNode(node)) {
    TagNode tagNode=(TagNode)node;
    if (tagNode.isEndTag()) {
      if (tagNode.getTagName().equals(""String_Node_Str"")) {
        context.putData(FERRET_IN_HEAD,null);
      }
      if (checkAllowTag(pContext,tagNode)) {
        emit(context,null,tagNode,null);
      }
    }
 else     if (tagNode.getTagName().startsWith(""String_Node_Str"")) {
      String text=tagNode.getText();
      int s=""String_Node_Str"".length();
      int e=text.endsWith(""String_Node_Str"") ? text.length() - 2 : text.length();
      if (context.isInCSS()) {
        TextNode textNode=new TextNode(text.substring(s,e));
        handleCSSTextNode(context,textNode);
        emit(context,""String_Node_Str"",textNode,""String_Node_Str"");
      }
 else       if (context.isInScriptText()) {
        TextNode textNode=new TextNode(text.substring(s,e));
        handleJSTextNode(context,textNode);
        emit(context,""String_Node_Str"",textNode,""String_Node_Str"");
      }
 else {
        emit(context,null,tagNode,null);
      }
    }
 else {
      context.setInHTML(true);
      handleOpenTagNode(context,tagNode);
    }
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}",0.97971169247197
99270,"/** 
 * build rewrite rule set from textual description in   {@code p}. rule set is a collection of a sub-tree for each element, stored in   {@code rules}Map.   {@code rules} maps tag name to a tree of {@code TransformAttr}.   {@code TransformAttr}tree is in essence a linked list of   {@code TransformAttr} grouped by attribute name. In eachgroup,  {@code TransformAttr}s are sorted by their <em>specificity</em>. Within the same specificity, the   {@code TransformAttr} added last comes on top (so that rules added through{@configProperties} override default rules.). As the order of keys in a single {@code Properties}is unspecified, there's no guarantee later line overrides former lines with the same key.
 * @param p Properties with rewrite rules.
 */
protected void loadRulesFromProperties(Properties p){
  for (  String key : p.stringPropertyNames()) {
    Matcher m=RE_TAG_ATTR_TYPE.matcher(key);
    if (m.matches()) {
      String tagName=m.group(1);
      String testAttrName=m.group(2);
      String testAttrValue=m.group(3);
      String attrNameMatch=m.group(4);
      String transformerName=p.getProperty(key);
      StringTransformer transformer=transformers.get(transformerName);
      if (transformer == null) {
        LOGGER.warning(""String_Node_Str"" + transformerName + ""String_Node_Str""+ key+ ""String_Node_Str"");
        continue;
      }
      TransformAttr t;
      if (testAttrName != null) {
        t=new TransformAttrIfAttrValue(attrNameMatch,transformer,testAttrName,testAttrValue);
      }
 else {
        t=new TransformAttr(attrNameMatch,transformer);
      }
      TransformAttr ta=rules.get(tagName);
      TransformAttr pta=null;
      while (true) {
        if (ta == null) {
          if (pta == null) {
            rules.put(tagName,t);
          }
 else {
            pta.next=t;
          }
          break;
        }
        if (ta.attrName.equals(t.attrName)) {
          TransformAttr palt=null;
          while (true) {
            if (t.compareTo(ta) >= 0) {
              t.alt=ta;
              t.next=ta.next;
              ta.next=null;
              if (palt == null) {
                if (pta == null) {
                  rules.put(tagName,t);
                }
 else {
                  pta.next=t;
                }
              }
 else {
                palt.next=t;
              }
              break;
            }
            palt=ta;
            ta=ta.alt;
            if (ta == null) {
              palt.alt=t;
              break;
            }
          }
          break;
        }
        pta=ta;
        ta=ta.next;
      }
      continue;
    }
    LOGGER.warning(""String_Node_Str"" + key + ""String_Node_Str"");
  }
}","/** 
 * build rewrite rule set from textual description in   {@code p}. rule set is a collection of a sub-tree for each element, stored in   {@code rules}Map.   {@code rules} maps tag name to a tree of {@code TransformAttr}.   {@code TransformAttr}tree is in essence a linked list of   {@code TransformAttr} grouped by attribute name. In eachgroup,  {@code TransformAttr}s are sorted by their <em>specificity</em>. Within the same specificity, the   {@code TransformAttr} added last comes on top (so that rules added through{@code Properties} override default rules.). As the order of keys in a single {@code Properties}is unspecified, there's no guarantee later line overrides former lines with the same key.
 * @param p Properties with rewrite rules.
 */
protected void loadRulesFromProperties(Properties p){
  for (  String key : p.stringPropertyNames()) {
    Matcher m=RE_TAG_ATTR_TYPE.matcher(key);
    if (m.matches()) {
      String tagName=m.group(1);
      String testAttrName=m.group(2);
      String testAttrValue=m.group(3);
      String attrNameMatch=m.group(4);
      String transformerName=p.getProperty(key);
      StringTransformer transformer=transformers.get(transformerName);
      if (transformer == null) {
        LOGGER.warning(""String_Node_Str"" + transformerName + ""String_Node_Str""+ key+ ""String_Node_Str"");
        continue;
      }
      TransformAttr t;
      if (testAttrName != null) {
        t=new TransformAttrIfAttrValue(attrNameMatch,transformer,testAttrName,testAttrValue);
      }
 else {
        t=new TransformAttr(attrNameMatch,transformer);
      }
      TransformAttr ta=rules.get(tagName);
      TransformAttr pta=null;
      while (true) {
        if (ta == null) {
          if (pta == null) {
            rules.put(tagName,t);
          }
 else {
            pta.next=t;
          }
          break;
        }
        if (ta.attrName.equals(t.attrName)) {
          TransformAttr palt=null;
          while (true) {
            if (t.compareTo(ta) >= 0) {
              t.alt=ta;
              t.next=ta.next;
              ta.next=null;
              if (palt == null) {
                if (pta == null) {
                  rules.put(tagName,t);
                }
 else {
                  pta.next=t;
                }
              }
 else {
                palt.next=t;
              }
              break;
            }
            palt=ta;
            ta=ta.alt;
            if (ta == null) {
              palt.alt=t;
              break;
            }
          }
          break;
        }
        pta=ta;
        ta=ta.next;
      }
      continue;
    }
    LOGGER.warning(""String_Node_Str"" + key + ""String_Node_Str"");
  }
}",0.9986957331842744
99271,"/** 
 * @param prefix
 * @return an absolute String URL that will point to the root of theserver that is handling the request. 
 * @deprecated use AccessPoint.get*Prefix
 */
public String getServerPrefix(){
  if (accessPoint == null) {
    return ""String_Node_Str"";
  }
  return accessPoint.getQueryPrefix();
}","/** 
 * @return an absolute String URL that will point to the root of theserver that is handling the request. 
 * @deprecated use AccessPoint.get*Prefix
 */
public String getServerPrefix(){
  if (accessPoint == null) {
    return ""String_Node_Str"";
  }
  return accessPoint.getQueryPrefix();
}",0.9718076285240465
99272,"/** 
 * @return
 * @deprecated
 */
public Set<String> keySet(){
  return filters.keySet();
}","/** 
 * @return A set containing all the keys in the request filter HashMap.
 * @deprecated
 */
public Set<String> keySet(){
  return filters.keySet();
}",0.7510204081632653
99273,"/** 
 * @return
 */
public String getHostPort(){
  return dprp.getHostPort();
}","/** 
 * @return The host port used.
 */
public String getHostPort(){
  return dprp.getHostPort();
}",0.8876404494382022
99274,"protected RequestParser[] getRequestParsers(){
  RequestParser[] theParsers={dprp,new OpenSearchRequestParser(this),new FormRequestParser(this)};
  return theParsers;
}","/** 
 * @return An array of all available {@link RequestParser}s.
 */
@Override protected RequestParser[] getRequestParsers(){
  RequestParser[] theParsers={dprp,new OpenSearchRequestParser(this),new FormRequestParser(this)};
  return theParsers;
}",0.8076923076923077
99275,"/** 
 * @param hostPort
 */
public void setHostPort(String hostPort){
  dprp.setHostPort(hostPort);
}","/** 
 * @param hostPort The host port to use.
 */
public void setHostPort(String hostPort){
  dprp.setHostPort(hostPort);
}",0.9017857142857144
99276,"public void setHosts(List<String> hosts){
  this.hosts=new HashMap<String,Object>();
  for (  String host : hosts) {
    this.hosts.put(host,null);
  }
}","/** 
 * @param hosts
 */
public void setHosts(List<String> hosts){
  this.hosts=new HashMap<String,Object>();
  for (  String host : hosts) {
    this.hosts.put(host,null);
  }
}",0.9244712990936556
99277,"public void setJspHandler(String jspHandler){
  this.jspHandler=jspHandler;
}","/** 
 * @param jspHandler The JSP handler to use.
 */
public void setJspHandler(String jspHandler){
  this.jspHandler=jspHandler;
}",0.7403846153846154
99278,"public String getJspHandler(){
  return jspHandler;
}","/** 
 * @return The JSP handler being used.
 */
public String getJspHandler(){
  return jspHandler;
}",0.6883116883116883
99279,"/** 
 * @param exception
 * @param wbRequest
 * @return
 */
private String getCustomHandler(WaybackException exception,WaybackRequest wbRequest){
  if ((exception instanceof ResourceNotInArchiveException) && wbRequest.isReplayRequest()) {
    String url=wbRequest.getRequestUrl();
    String host=UrlOperations.urlToHost(url);
    if (hosts.containsKey(host)) {
      return jspHandler;
    }
  }
  return null;
}","private String getCustomHandler(WaybackException exception,WaybackRequest wbRequest){
  if ((exception instanceof ResourceNotInArchiveException) && wbRequest.isReplayRequest()) {
    String url=wbRequest.getRequestUrl();
    String host=UrlOperations.urlToHost(url);
    if (hosts.containsKey(host)) {
      return jspHandler;
    }
  }
  return null;
}",0.9216710182767625
99280,"public List<String> getHosts(){
  return null;
}","/** 
 * @return This method currently always returns <b>null</b>.
 */
public List<String> getHosts(){
  return null;
}",0.5783132530120482
99281,"/** 
 * @param list
 * @return
 */
private static List<Partition<CaptureSearchResult>> splitToDays(Partition<CaptureSearchResult> month){
  CaptureSearchResultPartitionMap map=new CaptureSearchResultPartitionMap();
  Partitioner<CaptureSearchResult> partitioner=new Partitioner<CaptureSearchResult>(map);
  PartitionSize daySize=Partitioner.daySize;
  List<Partition<CaptureSearchResult>> days=partitioner.getRange(daySize,month.getStart(),month.getEnd());
  partitioner.populate(days,month.iterator());
  return days;
}","/** 
 * @param list
 * @return The input lis split into day intervals.
 */
private static List<Partition<CaptureSearchResult>> splitToDays(Partition<CaptureSearchResult> month){
  CaptureSearchResultPartitionMap map=new CaptureSearchResultPartitionMap();
  Partitioner<CaptureSearchResult> partitioner=new Partitioner<CaptureSearchResult>(map);
  PartitionSize daySize=Partitioner.daySize;
  List<Partition<CaptureSearchResult>> days=partitioner.getRange(daySize,month.getStart(),month.getEnd());
  partitioner.populate(days,month.iterator());
  return days;
}",0.9629629629629628
99282,"/** 
 * @param resource
 * @param result
 * @param uriConverter
 * @param filter 
 * @return
 */
public static Map<String,String> processHeaders(Resource resource,CaptureSearchResult result,ResultURIConverter uriConverter,HttpHeaderProcessor filter){
  HashMap<String,String> output=new HashMap<String,String>();
  Map<String,String> headers=resource.getHttpHeaders();
  if (headers != null) {
    Iterator<String> itr=headers.keySet().iterator();
    while (itr.hasNext()) {
      String key=itr.next();
      String value=headers.get(key);
      value=(value == null) ? ""String_Node_Str"" : value;
      filter.filter(output,key,value,uriConverter,result);
    }
  }
  return output;
}","/** 
 * @param resource
 * @param result
 * @param uriConverter
 * @param filter 
 * @return A HashMap containing the HTTP headers extracted from the Resource.
 */
public static Map<String,String> processHeaders(Resource resource,CaptureSearchResult result,ResultURIConverter uriConverter,HttpHeaderProcessor filter){
  HashMap<String,String> output=new HashMap<String,String>();
  Map<String,String> headers=resource.getHttpHeaders();
  if (headers != null) {
    Iterator<String> itr=headers.keySet().iterator();
    while (itr.hasNext()) {
      String key=itr.next();
      String value=headers.get(key);
      value=(value == null) ? ""String_Node_Str"" : value;
      filter.filter(output,key,value,uriConverter,result);
    }
  }
  return output;
}",0.9534398888116749
99283,"/** 
 * @param httpHeaderProcessor
 */
public ReplayRendererDecorator(ReplayRenderer decorated){
  this.decorated=decorated;
}","/** 
 * @param decorated
 */
public ReplayRendererDecorator(ReplayRenderer decorated){
  this.decorated=decorated;
}",0.9256198347107438
99284,"public abstract void renderResource(HttpServletRequest httpRequest,HttpServletResponse httpResponse,WaybackRequest wbRequest,CaptureSearchResult result,Resource resource,ResultURIConverter uriConverter,CaptureSearchResults results) throws ServletException, IOException, WaybackException ;","@Override public abstract void renderResource(HttpServletRequest httpRequest,HttpServletResponse httpResponse,WaybackRequest wbRequest,CaptureSearchResult result,Resource resource,ResultURIConverter uriConverter,CaptureSearchResults results) throws ServletException, IOException, WaybackException ;",0.9829351535836176
99285,"public void testTransform() throws Exception {
  final String input=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  st.transform(rc,input);
  assertEquals(4,rc.got.size());
  assertEquals(""String_Node_Str"",rc.got.get(0));
  assertEquals(""String_Node_Str"",rc.got.get(1));
  assertEquals(""String_Node_Str"",rc.got.get(2));
  assertEquals(""String_Node_Str"",rc.got.get(3));
}","public void testTransform() throws Exception {
  final String input=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  st.transform(rc,input);
  assertEquals(4,rc.got.size());
  assertTrue(rc.got.contains(""String_Node_Str""));
  assertTrue(rc.got.contains(""String_Node_Str""));
  assertTrue(rc.got.contains(""String_Node_Str""));
  assertTrue(rc.got.contains(""String_Node_Str""));
}",0.596529284164859
99286,"public void testRewriteHttpsOnly() throws Exception {
  rc.setRewriteHttpsOnly(true);
  final String input=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  st.transform(rc,input);
  assertEquals(2,rc.got.size());
  assertEquals(""String_Node_Str"",rc.got.get(0));
  assertEquals(""String_Node_Str"",rc.got.get(1));
}","public void testRewriteHttpsOnly() throws Exception {
  rc.setRewriteHttpsOnly(true);
  final String input=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  st.transform(rc,input);
  assertEquals(2,rc.got.size());
  assertTrue(rc.got.contains(""String_Node_Str""));
  assertTrue(rc.got.contains(""String_Node_Str""));
}",0.8176100628930818
99287,"/** 
 * {@code rewriteHttpsOnly} property is used to limit URL rewriteto HTTPS ones (intended for proxy mode). That should affect how StringTransformer picks up URLs in text for translation.
 * @throws Exception
 */
public void testRewriteHttpsOnly() throws Exception {
  rc.setRewriteHttpsOnly(true);
  final String input=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  jst.transform(rc,input);
  assertEquals(2,rc.got.size());
  assertEquals(""String_Node_Str"",rc.got.get(0));
  assertEquals(""String_Node_Str"",rc.got.get(1));
}","/** 
 * {@code rewriteHttpsOnly} property is used to limit URL rewriteto HTTPS ones (intended for proxy mode). That should affect how StringTransformer picks up URLs in text for translation.
 * @throws Exception
 */
public void testRewriteHttpsOnly() throws Exception {
  rc.setRewriteHttpsOnly(true);
  final String input=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  jst.transform(rc,input);
  assertEquals(2,rc.got.size());
  assertTrue(rc.got.contains(""String_Node_Str""));
  assertTrue(rc.got.contains(""String_Node_Str""));
}",0.8706896551724138
99288,"@Override protected void updatePage(TextDocument page,HttpServletRequest httpRequest,HttpServletResponse httpResponse,WaybackRequest wbRequest,CaptureSearchResult result,Resource resource,ResultURIConverter uriConverter,CaptureSearchResults results) throws ServletException, IOException {
  page.resolveCSSUrls();
  List<String> jspInserts=getJspInserts();
  StringBuilder toInsert=new StringBuilder(300);
  if (jspInserts != null) {
    Iterator<String> itr=jspInserts.iterator();
    while (itr.hasNext()) {
      toInsert.append(page.includeJspString(itr.next(),httpRequest,httpResponse,wbRequest,results,result,resource));
    }
  }
  page.insertAtStartOfDocument(toInsert.toString());
}","@Override protected void updatePage(TextDocument page,HttpServletRequest httpRequest,HttpServletResponse httpResponse,WaybackRequest wbRequest,CaptureSearchResult result,Resource resource,ResultURIConverter uriConverter,CaptureSearchResults results) throws ServletException, IOException {
  page.resolveCSSUrls();
  List<String> jspInserts=getJspInserts();
  StringBuilder toInsert=new StringBuilder(300);
  if (jspInserts != null) {
    Iterator<String> itr=jspInserts.iterator();
    while (itr.hasNext()) {
      toInsert.append(page.includeJspString(itr.next(),httpRequest,httpResponse,wbRequest,results,result,resource));
    }
  }
  page.insertAtEndOfDocument(toInsert.toString());
}",0.9942028985507246
99289,"/** 
 * test basic behavior with simple input. expectations: <ul> <li>reads <em>decoded (uncompressed)</em> contents from archive record.</li> <li>calls HttpServletResponse.setHeader() for Content-Type, Content-Length and   {@link TextReplayRenderer#getGuessedCharsetHeader()}.</li> <li>calls HttpServletResponse.setCharsetEncoding() with value ""utf-8""</li> </ul>
 * @throws Exception
 */
public void testBasicBehavior() throws Exception {
  final String payload=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  final byte[] payloadBytes=payload.getBytes(""String_Node_Str"");
  Resource payloadResource=createTestHtmlResource(payloadBytes);
  response.setStatus(200);
  response.setCharacterEncoding(""String_Node_Str"");
  response.setHeader(EasyMock.eq(""String_Node_Str""),EasyMock.<String>notNull());
  response.setHeader(cut.getGuessedCharsetHeader(),""String_Node_Str"");
  response.setHeader(""String_Node_Str"",""String_Node_Str"");
  response.setHeader(EasyMock.matches(""String_Node_Str""),EasyMock.<String>notNull());
  EasyMock.expectLastCall().anyTimes();
  final String ts=result.getCaptureTimestamp();
  final String url1=result.getOriginalUrl() + ""String_Node_Str"";
  EasyMock.expect(uriConverter.makeReplayURI(ts,url1)).andReturn(""String_Node_Str"" + ts + ""String_Node_Str""+ url1);
  final String url2=result.getOriginalUrl() + ""String_Node_Str"";
  EasyMock.expect(uriConverter.makeReplayURI(ts,url2)).andReturn(""String_Node_Str"" + ts + ""String_Node_Str""+ url2);
  final String url3=result.getOriginalUrl() + ""String_Node_Str"";
  EasyMock.expect(uriConverter.makeReplayURI(ts,url3)).andReturn(""String_Node_Str"" + ts + ""String_Node_Str""+ url3);
  EasyMock.expect(uriConverter.makeReplayURI(ts,""String_Node_Str"")).andReturn(""String_Node_Str"");
  EasyMock.replay(response,uriConverter);
  cut.renderResource(null,response,wbRequest,result,payloadResource,payloadResource,uriConverter,null);
  EasyMock.verify(response,uriConverter);
  final String expected=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String out=servletOutput.getString();
  assertEquals(""String_Node_Str"",expected,out);
}","/** 
 * test basic behavior with simple input. expectations: <ul> <li>reads <em>decoded (uncompressed)</em> contents from archive record.</li> <li>calls HttpServletResponse.setHeader() for Content-Type, Content-Length and   {@link TextReplayRenderer#getGuessedCharsetHeader()}.</li> <li>calls HttpServletResponse.setCharsetEncoding() with value ""utf-8""</li> </ul>
 * @throws Exception
 */
public void testBasicBehavior() throws Exception {
  final String payload=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  final byte[] payloadBytes=payload.getBytes(""String_Node_Str"");
  Resource payloadResource=createTestHtmlResource(payloadBytes);
  response.setStatus(200);
  response.setCharacterEncoding(""String_Node_Str"");
  response.setHeader(EasyMock.eq(""String_Node_Str""),EasyMock.<String>notNull());
  response.setHeader(cut.getGuessedCharsetHeader(),""String_Node_Str"");
  response.setHeader(""String_Node_Str"",""String_Node_Str"");
  response.setHeader(EasyMock.matches(""String_Node_Str""),EasyMock.<String>notNull());
  EasyMock.expectLastCall().anyTimes();
  final String ts=result.getCaptureTimestamp();
  final String url1=result.getOriginalUrl() + ""String_Node_Str"";
  EasyMock.expect(uriConverter.makeReplayURI(ts,url1)).andReturn(""String_Node_Str"" + ts + ""String_Node_Str""+ url1);
  final String url2=result.getOriginalUrl() + ""String_Node_Str"";
  EasyMock.expect(uriConverter.makeReplayURI(ts,url2)).andReturn(""String_Node_Str"" + ts + ""String_Node_Str""+ url2);
  final String url3=result.getOriginalUrl() + ""String_Node_Str"";
  EasyMock.expect(uriConverter.makeReplayURI(ts,url3)).andReturn(""String_Node_Str"" + ts + ""String_Node_Str""+ url3);
  EasyMock.expect(uriConverter.makeReplayURI(ts,""String_Node_Str"")).andReturn(""String_Node_Str"");
  EasyMock.replay(response,uriConverter);
  cut.renderResource(null,response,wbRequest,result,payloadResource,payloadResource,uriConverter,null);
  EasyMock.verify(response,uriConverter);
  final String expected=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String out=servletOutput.getString();
  Assert.assertTrue(out.startsWith(expected));
}",0.9847917125854088
99290,"public boolean doWork() throws IOException {
  boolean worked=false;
  String name=queue.dequeue();
  if (name != null) {
    worked=true;
    String[] pathsOrUrls=null;
    try {
      pathsOrUrls=db.nameToUrls(name);
    }
 catch (    IOException e) {
      LOGGER.severe(""String_Node_Str"" + name + ""String_Node_Str""+ e.getLocalizedMessage());
      return false;
    }
    try {
      if (pathsOrUrls != null) {
        for (        String pathOrUrl : pathsOrUrls) {
          LOGGER.info(""String_Node_Str"" + name + ""String_Node_Str""+ pathOrUrl);
          CloseableIterator<CaptureSearchResult> itr=indexFile(pathOrUrl);
          target.addSearchResults(name,itr);
          itr.close();
          break;
        }
      }
    }
 catch (    IOException e) {
      LOGGER.severe(""String_Node_Str"" + name + ""String_Node_Str"");
      e.printStackTrace();
    }
  }
  return worked;
}","public boolean doWork() throws IOException {
  boolean worked=false;
  String name=queue.dequeue();
  if (name != null) {
    worked=true;
    String[] pathsOrUrls=null;
    try {
      pathsOrUrls=db.nameToUrls(name);
    }
 catch (    IOException e) {
      LOGGER.severe(""String_Node_Str"" + name + ""String_Node_Str""+ e.getLocalizedMessage());
      return false;
    }
    try {
      if (pathsOrUrls != null) {
        for (        String pathOrUrl : pathsOrUrls) {
          LOGGER.info(""String_Node_Str"" + name + ""String_Node_Str""+ pathOrUrl);
          CloseableIterator<CaptureSearchResult> itr=indexFile(pathOrUrl);
          target.addSearchResults(name,itr);
          itr.close();
          break;
        }
      }
    }
 catch (    Exception e) {
      LOGGER.severe(""String_Node_Str"" + name + ""String_Node_Str"");
      e.printStackTrace();
    }
  }
  return worked;
}",0.998868778280543
99291,"public ReplayRenderer getRenderer(WaybackRequest wbRequest,CaptureSearchResult result,Resource resource){
  ReplayRenderer r=decorated.getRenderer(wbRequest,result,resource);
  return getDecoratedRenderer(r);
}","public ReplayRenderer getRenderer(WaybackRequest wbRequest,CaptureSearchResult result,Resource httpHeadersResource,Resource payloadResource){
  ReplayRenderer r=decorated.getRenderer(wbRequest,result,httpHeadersResource,payloadResource);
  return getDecoratedRenderer(r);
}",0.8612836438923396
99292,"@Override public void renderResource(HttpServletRequest httpRequest,HttpServletResponse httpResponse,WaybackRequest wbRequest,CaptureSearchResult result,Resource resource,ResultURIConverter uriConverter,CaptureSearchResults results) throws ServletException, IOException, WaybackException {
  String u=wbRequest.getRequestUrl();
  SimpleDateFormat httpformatterl=new SimpleDateFormat(""String_Node_Str"");
  TimeZone tzo=TimeZone.getTimeZone(""String_Node_Str"");
  httpformatterl.setTimeZone(tzo);
  SimpleDateFormat formatterk=new SimpleDateFormat(""String_Node_Str"");
  formatterk.setTimeZone(tzo);
  Properties apProps=wbRequest.getAccessPoint().getConfigs();
  Date closestDate=result.getCaptureDate();
  String uriPrefix=wbRequest.getAccessPoint().getReplayPrefix();
  String agguri=apProps.getProperty(""String_Node_Str"") + ""String_Node_Str"" + u;
  String timemap=""String_Node_Str"" + apProps.getProperty(""String_Node_Str"") + ""String_Node_Str""+ u+ ""String_Node_Str"";
  String timegate=""String_Node_Str"" + uriPrefix + ""String_Node_Str""+ u+ ""String_Node_Str"";
  Date f=results.getFirstResultDate();
  Date l=results.getLastResultDate();
  StringBuffer sb=new StringBuffer();
  httpResponse.setHeader(""String_Node_Str"",httpformatterl.format(result.getCaptureDate()));
  String memento=""String_Node_Str"" + uriPrefix + formatterk.format(closestDate)+ ""String_Node_Str""+ u+ ""String_Node_Str""+ httpformatterl.format(closestDate)+ ""String_Node_Str"";
  String mfl=null;
  if ((closestDate.equals(f)) && closestDate.equals(l)) {
    mfl=""String_Node_Str"" + uriPrefix + formatterk.format(f)+ ""String_Node_Str""+ u+ ""String_Node_Str""+ httpformatterl.format(f)+ ""String_Node_Str"";
  }
 else   if (closestDate.equals(f)) {
    mfl=""String_Node_Str"" + uriPrefix + formatterk.format(f)+ ""String_Node_Str""+ u+ ""String_Node_Str""+ httpformatterl.format(f)+ ""String_Node_Str"";
    mfl=mfl + ""String_Node_Str"" + uriPrefix+ formatterk.format(l)+ ""String_Node_Str""+ u+ ""String_Node_Str""+ httpformatterl.format(l)+ ""String_Node_Str"";
  }
 else   if (closestDate.equals(l)) {
    mfl=""String_Node_Str"" + uriPrefix + formatterk.format(l)+ ""String_Node_Str""+ u+ ""String_Node_Str""+ httpformatterl.format(l)+ ""String_Node_Str"";
    mfl=mfl + ""String_Node_Str"" + uriPrefix+ formatterk.format(f)+ ""String_Node_Str""+ u+ ""String_Node_Str""+ httpformatterl.format(f)+ ""String_Node_Str"";
  }
 else {
    mfl=memento;
    mfl=mfl + ""String_Node_Str"" + uriPrefix+ formatterk.format(l)+ ""String_Node_Str""+ u+ ""String_Node_Str""+ httpformatterl.format(l)+ ""String_Node_Str"";
    mfl=mfl + ""String_Node_Str"" + uriPrefix+ formatterk.format(f)+ ""String_Node_Str""+ u+ ""String_Node_Str""+ httpformatterl.format(f)+ ""String_Node_Str"";
  }
  sb=new StringBuffer(mfl);
  CaptureSearchResult closestleft=null;
  CaptureSearchResult closestright=null;
  long rclosestDistance=0;
  long lclosestDistance=0;
  CaptureSearchResult cur=null;
  long wantTime=closestDate.getTime();
  Iterator<CaptureSearchResult> itr=results.iterator();
  while (itr.hasNext()) {
    cur=itr.next();
    cur.getCaptureDate();
    long curDistance=cur.getCaptureDate().getTime() - wantTime;
    if (curDistance > 0) {
      if ((closestright == null) || (Math.abs(curDistance) < Math.abs(rclosestDistance))) {
        closestright=cur;
        rclosestDistance=Math.abs(curDistance);
      }
    }
    if (curDistance < 0) {
      if ((closestleft == null) || (Math.abs(curDistance) < Math.abs(lclosestDistance))) {
        closestleft=cur;
        lclosestDistance=Math.abs(curDistance);
      }
    }
  }
  if (closestleft != null) {
    if (!(closestleft.getCaptureDate().equals(f))) {
      sb.append(""String_Node_Str"" + uriPrefix + formatterk.format(closestleft.getCaptureDate())+ ""String_Node_Str""+ u+ ""String_Node_Str""+ httpformatterl.format(closestleft.getCaptureDate())+ ""String_Node_Str"");
    }
 else {
      int m_index=sb.lastIndexOf(""String_Node_Str"");
      sb.insert(m_index + 1,""String_Node_Str"");
    }
  }
  if (closestright != null) {
    if (!(closestright.getCaptureDate().equals(l))) {
      sb.append(""String_Node_Str"" + uriPrefix + formatterk.format(closestright.getCaptureDate())+ ""String_Node_Str""+ u+ ""String_Node_Str""+ httpformatterl.format(closestright.getCaptureDate())+ ""String_Node_Str"");
    }
 else {
      int m_index=sb.lastIndexOf(""String_Node_Str"");
      sb.insert(m_index + 1,""String_Node_Str"");
    }
  }
  String origlink=""String_Node_Str"" + u + ""String_Node_Str"";
  httpResponse.setHeader(""String_Node_Str"",""String_Node_Str"" + agguri + ""String_Node_Str""+ origlink+ sb.toString()+ timemap+ timegate);
  decorated.renderResource(httpRequest,httpResponse,wbRequest,result,resource,uriConverter,results);
}","@Override public void renderResource(HttpServletRequest httpRequest,HttpServletResponse httpResponse,WaybackRequest wbRequest,CaptureSearchResult result,Resource resource,ResultURIConverter uriConverter,CaptureSearchResults results) throws ServletException, IOException, WaybackException {
  this.renderResource(httpRequest,httpResponse,wbRequest,result,resource,resource,uriConverter,results);
}",0.1322542439794709
99293,"@Override public void renderResource(HttpServletRequest httpRequest,HttpServletResponse httpResponse,WaybackRequest wbRequest,CaptureSearchResult result,Resource resource,ResultURIConverter uriConverter,CaptureSearchResults results) throws ServletException, IOException, WaybackException {
  MementoUtils.addMementoHeaders(httpResponse,results,wbRequest);
  decorated.renderResource(httpRequest,httpResponse,wbRequest,result,resource,uriConverter,results);
}","@Override public void renderResource(HttpServletRequest httpRequest,HttpServletResponse httpResponse,WaybackRequest wbRequest,CaptureSearchResult result,Resource httpHeadersResource,Resource payloadResource,ResultURIConverter uriConverter,CaptureSearchResults results) throws ServletException, IOException, WaybackException {
  MementoUtils.addMementoHeaders(httpResponse,results,wbRequest);
  decorated.renderResource(httpRequest,httpResponse,wbRequest,result,httpHeadersResource,payloadResource,uriConverter,results);
}",0.9315628192032688
99294,"private CaptureSearchResult genericResult(WARCRecord rec){
  CaptureSearchResult result=new CaptureSearchResult();
  result.setMimeType(DEFAULT_VALUE);
  result.setHttpCode(DEFAULT_VALUE);
  result.setRedirectUrl(DEFAULT_VALUE);
  ArchiveRecordHeader header=rec.getHeader();
  String file=transformWARCFilename(header.getReaderIdentifier());
  long offset=header.getOffset();
  result.setCaptureTimestamp(transformWARCDate(header.getDate()));
  result.setFile(file);
  result.setOffset(offset);
  result.setDigest(transformWARCDigest(header.getHeaderValue(WARCRecord.HEADER_KEY_PAYLOAD_DIGEST)));
  String origUrl=header.getUrl();
  if (origUrl == null) {
    String type=header.getHeaderValue(WARCConstants.HEADER_KEY_TYPE).toString();
    if (type.equals(WARCConstants.WARCRecordType.WARCINFO)) {
      String filename=header.getHeaderValue(WARCConstants.HEADER_KEY_FILENAME).toString();
      result.setOriginalUrl(""String_Node_Str"" + filename);
      result.setUrlKey(""String_Node_Str"" + filename);
    }
 else {
      result.setOriginalUrl(DEFAULT_VALUE);
      result.setUrlKey(DEFAULT_VALUE);
    }
  }
 else {
    result.setOriginalUrl(origUrl);
    try {
      String urlKey=canonicalizer.urlStringToKey(origUrl);
      result.setUrlKey(urlKey);
    }
 catch (    URIException e) {
      String shortUrl=(origUrl.length() < 100) ? origUrl : origUrl.substring(0,100);
      LOGGER.warning(""String_Node_Str"" + shortUrl + ""String_Node_Str""+ file+ ""String_Node_Str""+ offset);
      result.setUrlKey(origUrl);
    }
  }
  return result;
}","private CaptureSearchResult genericResult(WARCRecord rec){
  CaptureSearchResult result=new CaptureSearchResult();
  result.setMimeType(DEFAULT_VALUE);
  result.setHttpCode(DEFAULT_VALUE);
  result.setRedirectUrl(DEFAULT_VALUE);
  ArchiveRecordHeader header=rec.getHeader();
  String file=transformWARCFilename(header.getReaderIdentifier());
  long offset=header.getOffset();
  result.setCaptureTimestamp(transformWARCDate(header.getDate()));
  result.setFile(file);
  result.setOffset(offset);
  result.setDigest(transformWARCDigest(header.getHeaderValue(WARCRecord.HEADER_KEY_PAYLOAD_DIGEST)));
  String origUrl=header.getUrl();
  if (origUrl == null) {
    String type=header.getHeaderValue(WARCConstants.HEADER_KEY_TYPE).toString();
    if (type.equals(WARCConstants.WARCRecordType.warcinfo)) {
      String filename=header.getHeaderValue(WARCConstants.HEADER_KEY_FILENAME).toString();
      result.setOriginalUrl(""String_Node_Str"" + filename);
      result.setUrlKey(""String_Node_Str"" + filename);
    }
 else {
      result.setOriginalUrl(DEFAULT_VALUE);
      result.setUrlKey(DEFAULT_VALUE);
    }
  }
 else {
    result.setOriginalUrl(origUrl);
    try {
      String urlKey=canonicalizer.urlStringToKey(origUrl);
      result.setUrlKey(urlKey);
    }
 catch (    URIException e) {
      String shortUrl=(origUrl.length() < 100) ? origUrl : origUrl.substring(0,100);
      LOGGER.warning(""String_Node_Str"" + shortUrl + ""String_Node_Str""+ file+ ""String_Node_Str""+ offset);
      result.setUrlKey(origUrl);
    }
  }
  return result;
}",0.9948119325551232
99295,"private CaptureSearchResult adaptInner(WARCRecord rec) throws IOException {
  ArchiveRecordHeader header=rec.getHeader();
  String type=header.getHeaderValue(WARCConstants.HEADER_KEY_TYPE).toString();
  CaptureSearchResult result=genericResult(rec);
  if (type.equals(WARCConstants.WARCRecordType.RESPONSE)) {
    String mime=annotater.transformHTTPMime(header.getMimetype());
    if (mime != null && mime.equals(""String_Node_Str"")) {
      rec.close();
      result.setDigest(transformWARCDigest(rec.getDigestStr()));
      result.setMimeType(mime);
    }
 else {
      result=adaptWARCHTTPResponse(result,rec);
    }
  }
 else   if (type.equals(WARCConstants.WARCRecordType.REVISIT)) {
    result.setMimeType(""String_Node_Str"");
  }
 else   if (type.equals(WARCConstants.WARCRecordType.REQUEST)) {
    if (processAll) {
      result.setMimeType(""String_Node_Str"");
    }
 else {
      result=null;
    }
  }
 else   if (type.equals(WARCConstants.WARCRecordType.METADATA)) {
    if (processAll) {
      result.setMimeType(""String_Node_Str"");
    }
 else {
      result=null;
    }
  }
 else   if (type.equals(WARCConstants.WARCRecordType.WARCINFO)) {
    result.setMimeType(WARC_FILEDESC_VERSION);
  }
 else {
    LOGGER.info(""String_Node_Str"" + type);
  }
  return result;
}","private CaptureSearchResult adaptInner(WARCRecord rec) throws IOException {
  ArchiveRecordHeader header=rec.getHeader();
  String typeStr=header.getHeaderValue(WARCConstants.HEADER_KEY_TYPE).toString();
  WARCRecordType type;
  try {
    type=WARCRecordType.valueOf(typeStr);
  }
 catch (  IllegalArgumentException e) {
    LOGGER.warning(""String_Node_Str"" + typeStr);
    return null;
  }
  CaptureSearchResult result=genericResult(rec);
switch (type) {
case response:
    String mime=annotater.transformHTTPMime(header.getMimetype());
  if (mime != null && mime.equals(""String_Node_Str"")) {
    rec.close();
    result.setDigest(transformWARCDigest(rec.getDigestStr()));
    result.setMimeType(mime);
  }
 else {
    result=adaptWARCHTTPResponse(result,rec);
  }
break;
case revisit:
result.setMimeType(""String_Node_Str"");
break;
case request:
if (processAll) {
result.setMimeType(""String_Node_Str"");
}
 else {
result=null;
}
break;
case metadata:
if (processAll) {
result.setMimeType(""String_Node_Str"");
}
 else {
result=null;
}
break;
case warcinfo:
result.setMimeType(WARC_FILEDESC_VERSION);
break;
default :
LOGGER.info(""String_Node_Str"" + type);
break;
}
return result;
}",0.5164969450101833
99296,"protected Resource getResource(CaptureSearchResult closest,Set<String> skipFiles) throws ResourceNotAvailableException, ConfigurationException {
  if ((skipFiles != null) && skipFiles.contains(closest.getFile())) {
    throw new ResourceNotAvailableException(""String_Node_Str"" + closest.getFile(),null);
  }
  return getCollection().getResourceStore().retrieveResource(closest);
}","protected Resource getResource(CaptureSearchResult closest,Set<String> skipFiles) throws ResourceNotAvailableException, ConfigurationException {
  if ((skipFiles != null) && skipFiles.contains(closest.getFile())) {
    throw new ResourceNotAvailableException(""String_Node_Str"" + closest.getFile());
  }
  return getCollection().getResourceStore().retrieveResource(closest);
}",0.9933774834437086
99297,"/** 
 * @param httpRequest HttpServletRequest which is being handled 
 * @param httpResponse HttpServletResponse which is being handled 
 * @return true if the request was actually handled
 * @throws ServletException per usual
 * @throws IOException per usual
 */
public boolean handleRequest(HttpServletRequest httpRequest,HttpServletResponse httpResponse) throws ServletException, IOException {
  WaybackRequest wbRequest=null;
  boolean handled=false;
  try {
    String inputPath=translateRequestPathQuery(httpRequest);
    Thread.currentThread().setName(""String_Node_Str"" + Thread.currentThread().getId() + ""String_Node_Str""+ getBeanName()+ ""String_Node_Str""+ inputPath);
    LOGGER.fine(""String_Node_Str"" + inputPath);
    wbRequest=getParser().parse(httpRequest,this);
    if (wbRequest != null) {
      handled=true;
      wbRequest.setAccessPoint(this);
      wbRequest.fixup(httpRequest);
      if (getAuthentication() != null) {
        if (!getAuthentication().isTrue(wbRequest)) {
          throw new AuthenticationControlException(""String_Node_Str"");
        }
      }
      if (getExclusionFactory() != null) {
        ExclusionFilter exclusionFilter=getExclusionFactory().get();
        if (exclusionFilter == null) {
          throw new AdministrativeAccessControlException(""String_Node_Str"");
        }
        wbRequest.setExclusionFilter(exclusionFilter);
      }
      wbRequest.setExactScheme(isExactSchemeMatch());
      if (wbRequest.isReplayRequest()) {
        if (bounceToReplayPrefix) {
          String suffix=translateRequestPathQuery(httpRequest);
          String replayUrl=replayPrefix + suffix;
          httpResponse.sendRedirect(replayUrl);
          return true;
        }
        handleReplay(wbRequest,httpRequest,httpResponse);
      }
 else {
        if (bounceToQueryPrefix) {
          String suffix=translateRequestPathQuery(httpRequest);
          String replayUrl=queryPrefix + suffix;
          httpResponse.sendRedirect(replayUrl);
          return true;
        }
        wbRequest.setExactHost(isExactHostMatch());
        handleQuery(wbRequest,httpRequest,httpResponse);
      }
    }
 else {
      handled=dispatchLocal(httpRequest,httpResponse);
    }
  }
 catch (  BetterRequestException e) {
    e.generateResponse(httpResponse);
    handled=true;
  }
catch (  WaybackException e) {
    if (wbRequest.isReplayRequest() && (getLiveWebPrefix() != null) && (getLiveWebPrefix().length() > 0)) {
      httpResponse.setHeader(""String_Node_Str"",e.getMessage() + e.getDetails());
      String liveUrl=getLiveWebPrefix() + wbRequest.getRequestUrl();
      httpResponse.sendRedirect(liveUrl);
    }
 else {
      logNotInArchive(e,wbRequest);
      httpResponse.setHeader(""String_Node_Str"",e.getMessage());
      getException().renderException(httpRequest,httpResponse,wbRequest,e,getUriConverter());
    }
  }
  return handled;
}","/** 
 * @param httpRequest HttpServletRequest which is being handled 
 * @param httpResponse HttpServletResponse which is being handled 
 * @return true if the request was actually handled
 * @throws ServletException per usual
 * @throws IOException per usual
 */
public boolean handleRequest(HttpServletRequest httpRequest,HttpServletResponse httpResponse) throws ServletException, IOException {
  WaybackRequest wbRequest=null;
  boolean handled=false;
  try {
    String inputPath=translateRequestPathQuery(httpRequest);
    Thread.currentThread().setName(""String_Node_Str"" + Thread.currentThread().getId() + ""String_Node_Str""+ getBeanName()+ ""String_Node_Str""+ inputPath);
    LOGGER.fine(""String_Node_Str"" + inputPath);
    wbRequest=getParser().parse(httpRequest,this);
    if (wbRequest != null) {
      handled=true;
      wbRequest.setAccessPoint(this);
      wbRequest.fixup(httpRequest);
      if (getAuthentication() != null) {
        if (!getAuthentication().isTrue(wbRequest)) {
          throw new AuthenticationControlException(""String_Node_Str"");
        }
      }
      if (getExclusionFactory() != null) {
        ExclusionFilter exclusionFilter=getExclusionFactory().get();
        if (exclusionFilter == null) {
          throw new AdministrativeAccessControlException(""String_Node_Str"");
        }
        wbRequest.setExclusionFilter(exclusionFilter);
      }
      wbRequest.setExactScheme(isExactSchemeMatch());
      if (wbRequest.isReplayRequest()) {
        if (bounceToReplayPrefix) {
          String suffix=translateRequestPathQuery(httpRequest);
          String replayUrl=replayPrefix + suffix;
          httpResponse.sendRedirect(replayUrl);
          return true;
        }
        handleReplay(wbRequest,httpRequest,httpResponse);
      }
 else {
        if (bounceToQueryPrefix) {
          String suffix=translateRequestPathQuery(httpRequest);
          String replayUrl=queryPrefix + suffix;
          httpResponse.sendRedirect(replayUrl);
          return true;
        }
        wbRequest.setExactHost(isExactHostMatch());
        handleQuery(wbRequest,httpRequest,httpResponse);
      }
    }
 else {
      handled=dispatchLocal(httpRequest,httpResponse);
    }
  }
 catch (  BetterRequestException e) {
    e.generateResponse(httpResponse);
    handled=true;
  }
catch (  WaybackException e) {
    if (wbRequest.isReplayRequest() && (getLiveWebPrefix() != null) && (getLiveWebPrefix().length() > 0)) {
      writeErrorHeader(httpResponse,""String_Node_Str"",e.getMessage());
      String liveUrl=getLiveWebPrefix() + wbRequest.getRequestUrl();
      httpResponse.sendRedirect(liveUrl);
    }
 else {
      logNotInArchive(e,wbRequest);
      writeErrorHeader(httpResponse,""String_Node_Str"",e.getMessage());
      getException().renderException(httpRequest,httpResponse,wbRequest,e,getUriConverter());
    }
  }
  return handled;
}",0.9834696363319994
99298,"public boolean handleRequest(HttpServletRequest httpRequest,HttpServletResponse httpResponse) throws ServletException, IOException {
  String urlString=translateRequestPathQuery(httpRequest);
  urlString=UrlOperations.fixupHTTPUrlWithOneSlash(urlString);
  boolean handled=true;
  WaybackRequest wbRequest=new WaybackRequest();
  wbRequest.setAccessPoint(inner);
  wbRequest.setLiveWebRequest(true);
  wbRequest.setRequestUrl(urlString);
  URL url=null;
  try {
    if (!urlString.startsWith(UrlOperations.HTTP_SCHEME) && !urlString.startsWith(UrlOperations.HTTPS_SCHEME)) {
      throw new ResourceNotInArchiveException(urlString);
    }
    Thread.currentThread().setName(""String_Node_Str"" + Thread.currentThread().getId() + ""String_Node_Str""+ getBeanName()+ ""String_Node_Str""+ urlString);
    try {
      url=new URL(urlString);
    }
 catch (    MalformedURLException e) {
      throw new BadQueryException(""String_Node_Str"" + urlString + ""String_Node_Str"");
    }
    CaptureSearchResult result=new CaptureSearchResult();
    result.setOriginalUrl(urlString);
    String canonUrl=urlString;
    if (inner.getSelfRedirectCanonicalizer() != null) {
      try {
        canonUrl=inner.getSelfRedirectCanonicalizer().urlStringToKey(urlString);
      }
 catch (      IOException io) {
        throw new BadQueryException(""String_Node_Str"" + urlString + ""String_Node_Str"");
      }
    }
    result.setUrlKey(canonUrl);
    if (adminFactory != null) {
      ExclusionFilter f=adminFactory.get();
      if (f == null) {
        LOGGER.severe(""String_Node_Str"");
        throw new AdministrativeAccessControlException(urlString + ""String_Node_Str"");
      }
      int ruling=f.filterObject(result);
      if (ruling == ExclusionFilter.FILTER_EXCLUDE) {
        throw new AdministrativeAccessControlException(urlString + ""String_Node_Str"");
      }
    }
    if (robotFactory != null) {
      int ruling=robotFactory.get().filterObject(result);
      if (ruling == ExclusionFilter.FILTER_EXCLUDE) {
        throw new RobotAccessControlException(urlString + ""String_Node_Str"");
      }
    }
    long start=System.currentTimeMillis();
    ArcResource r=(ArcResource)cache.getCachedResource(url,maxCacheMS,false);
    long elapsed=System.currentTimeMillis() - start;
    PerformanceLogger.noteElapsed(""String_Node_Str"",elapsed,urlString);
    ARCRecord ar=(ARCRecord)r.getArcRecord();
    int status=ar.getStatusCode();
    if ((status == 200) || ((status >= 300) && (status < 400))) {
      result.setCaptureTimestamp(ar.getMetaData().getDate());
      result.setMimeType(ar.getMetaData().getMimetype());
      CaptureSearchResults results=new CaptureSearchResults();
      results.addSearchResult(result);
      wbRequest.setReplayTimestamp(result.getCaptureTimestamp());
      inner.getReplay().getRenderer(wbRequest,result,r).renderResource(httpRequest,httpResponse,wbRequest,result,r,inner.getUriConverter(),results);
    }
 else {
      throw new LiveDocumentNotAvailableException(urlString);
    }
  }
 catch (  WaybackException e) {
    httpResponse.setHeader(""String_Node_Str"",e.getMessage());
    inner.getException().renderException(httpRequest,httpResponse,wbRequest,e,inner.getUriConverter());
  }
  return handled;
}","public boolean handleRequest(HttpServletRequest httpRequest,HttpServletResponse httpResponse) throws ServletException, IOException {
  String urlString=translateRequestPathQuery(httpRequest);
  urlString=UrlOperations.fixupHTTPUrlWithOneSlash(urlString);
  boolean handled=true;
  WaybackRequest wbRequest=new WaybackRequest();
  wbRequest.setAccessPoint(inner);
  wbRequest.setLiveWebRequest(true);
  wbRequest.setRequestUrl(urlString);
  URL url=null;
  try {
    if (!urlString.startsWith(UrlOperations.HTTP_SCHEME) && !urlString.startsWith(UrlOperations.HTTPS_SCHEME)) {
      throw new ResourceNotInArchiveException(urlString);
    }
    Thread.currentThread().setName(""String_Node_Str"" + Thread.currentThread().getId() + ""String_Node_Str""+ getBeanName()+ ""String_Node_Str""+ urlString);
    try {
      url=new URL(urlString);
    }
 catch (    MalformedURLException e) {
      throw new BadQueryException(""String_Node_Str"" + urlString + ""String_Node_Str"");
    }
    CaptureSearchResult result=new CaptureSearchResult();
    result.setOriginalUrl(urlString);
    String canonUrl=urlString;
    if (inner.getSelfRedirectCanonicalizer() != null) {
      try {
        canonUrl=inner.getSelfRedirectCanonicalizer().urlStringToKey(urlString);
      }
 catch (      IOException io) {
        throw new BadQueryException(""String_Node_Str"" + urlString + ""String_Node_Str"");
      }
    }
    result.setUrlKey(canonUrl);
    if (adminFactory != null) {
      ExclusionFilter f=adminFactory.get();
      if (f == null) {
        LOGGER.severe(""String_Node_Str"");
        throw new AdministrativeAccessControlException(urlString + ""String_Node_Str"");
      }
      int ruling=f.filterObject(result);
      if (ruling == ExclusionFilter.FILTER_EXCLUDE) {
        throw new AdministrativeAccessControlException(urlString + ""String_Node_Str"");
      }
    }
    if (robotFactory != null) {
      int ruling=robotFactory.get().filterObject(result);
      if (ruling == ExclusionFilter.FILTER_EXCLUDE) {
        throw new RobotAccessControlException(urlString + ""String_Node_Str"");
      }
    }
    long start=System.currentTimeMillis();
    ArcResource r=(ArcResource)cache.getCachedResource(url,maxCacheMS,false);
    long elapsed=System.currentTimeMillis() - start;
    PerformanceLogger.noteElapsed(""String_Node_Str"",elapsed,urlString);
    ARCRecord ar=(ARCRecord)r.getArcRecord();
    int status=ar.getStatusCode();
    if ((status == 200) || ((status >= 300) && (status < 400))) {
      result.setCaptureTimestamp(ar.getMetaData().getDate());
      result.setMimeType(ar.getMetaData().getMimetype());
      CaptureSearchResults results=new CaptureSearchResults();
      results.addSearchResult(result);
      wbRequest.setReplayTimestamp(result.getCaptureTimestamp());
      inner.getReplay().getRenderer(wbRequest,result,r).renderResource(httpRequest,httpResponse,wbRequest,result,r,inner.getUriConverter(),results);
    }
 else {
      throw new LiveDocumentNotAvailableException(urlString);
    }
  }
 catch (  WaybackException e) {
    inner.writeErrorHeader(httpResponse,""String_Node_Str"",e.getMessage());
    inner.getException().renderException(httpRequest,httpResponse,wbRequest,e,inner.getUriConverter());
  }
  return handled;
}",0.9930351338802044
99299,"@Override public boolean handleRequest(HttpServletRequest httpRequest,HttpServletResponse httpResponse) throws ServletException, IOException {
  String url=this.translateRequestPath(httpRequest);
  PrintWriter writer=httpResponse.getWriter();
  httpResponse.setContentType(""String_Node_Str"");
  writer.println(""String_Node_Str"");
  if (!url.endsWith(ROBOT_SUFFIX)) {
    writer.println(""String_Node_Str"" + url + ""String_Node_Str"");
  }
 else   if (robotsCache == null) {
    writer.println(""String_Node_Str"");
  }
 else {
    if (!url.startsWith(HTTP_PREFIX)) {
      url=HTTP_PREFIX + url;
    }
    RobotsContext context=robotsCache.forceUpdate(url,minUpdateTime);
    if (context == null) {
      writer.println(""String_Node_Str"");
    }
    boolean sameRobots=(context.current != null) && (context.getNewRobots() != null) && (context.current.equals(context.getNewRobots()));
    if (!sameRobots) {
      writer.println(""String_Node_Str"");
      writer.println(""String_Node_Str"");
      writer.println(""String_Node_Str"" + context.current + ""String_Node_Str"");
    }
 else {
      writer.println(""String_Node_Str"");
    }
    writer.println(""String_Node_Str"");
    writer.print(""String_Node_Str"");
    if (context.getNewRobots() == null) {
switch (context.getStatus()) {
case RobotsContext.LIVE_HOST_ERROR:
        writer.print(""String_Node_Str"");
      break;
case RobotsContext.LIVE_TIMEOUT_ERROR:
    writer.print(""String_Node_Str"");
  break;
default :
writer.print(""String_Node_Str"" + context.getStatus());
}
writer.print(""String_Node_Str"" + RedisRobotsCache.ROBOTS_TOKEN_ERROR + context.getStatus()+ ""String_Node_Str"");
}
 else {
writer.print(context.getNewRobots());
}
writer.println(""String_Node_Str"");
}
writer.println(""String_Node_Str"" + new Date().toString() + ""String_Node_Str"");
return true;
}","@Override public boolean handleRequest(HttpServletRequest httpRequest,HttpServletResponse httpResponse) throws ServletException, IOException {
  String url=this.translateRequestPath(httpRequest);
  PrintWriter writer=httpResponse.getWriter();
  httpResponse.setContentType(""String_Node_Str"");
  writer.println(""String_Node_Str"");
  if (!url.endsWith(ROBOT_SUFFIX)) {
    writer.println(""String_Node_Str"" + url + ""String_Node_Str"");
  }
 else   if (robotsCache == null) {
    writer.println(""String_Node_Str"");
  }
 else {
    if (!url.startsWith(HTTP_PREFIX)) {
      url=HTTP_PREFIX + url;
    }
    RobotsContext context=robotsCache.forceUpdate(url,minUpdateTime);
    if (context == null) {
      writer.println(""String_Node_Str"");
      return true;
    }
    boolean sameRobots=(context.current != null) && (context.getNewRobots() != null) && (context.current.equals(context.getNewRobots()));
    if (!sameRobots) {
      writer.println(""String_Node_Str"");
      writer.println(""String_Node_Str"");
      writer.println(""String_Node_Str"" + context.current + ""String_Node_Str"");
    }
 else {
      writer.println(""String_Node_Str"");
    }
    writer.println(""String_Node_Str"");
    writer.print(""String_Node_Str"");
    if (context.getNewRobots() == null) {
switch (context.getStatus()) {
case RobotsContext.LIVE_HOST_ERROR:
        writer.print(""String_Node_Str"");
      break;
case RobotsContext.LIVE_TIMEOUT_ERROR:
    writer.print(""String_Node_Str"");
  break;
default :
writer.print(""String_Node_Str"" + context.getStatus());
}
writer.print(""String_Node_Str"" + RedisRobotsCache.ROBOTS_TOKEN_ERROR + context.getStatus()+ ""String_Node_Str"");
}
 else {
writer.print(context.getNewRobots());
}
writer.println(""String_Node_Str"");
}
writer.println(""String_Node_Str"" + new Date().toString() + ""String_Node_Str"");
return true;
}",0.9947701624002202
99300,"private void asyncUpdateCheck(Jedis jedis,String url,String current,int refreshTime,int maxTime){
  long startTime=System.currentTimeMillis();
  long ttl=jedis.ttl(url);
  PerformanceLogger.noteElapsed(""String_Node_Str"",System.currentTimeMillis() - startTime,((maxTime == totalTTL) ? ""String_Node_Str"" + current.length() : current));
  redisConn.returnJedisInstance(jedis);
  jedis=null;
  if ((maxTime - ttl) >= refreshTime) {
    LOGGER.info(""String_Node_Str"" + (maxTime - ttl) + ""String_Node_Str""+ refreshTime);
synchronized (urlsToUpdate) {
      if (urlsToUpdate.contains(url)) {
        return;
      }
      urlsToUpdate.add(url);
    }
    updateService.submit(new CacheUpdateTask(url,current));
  }
}","private void asyncUpdateCheck(long ttl,String url,String current,int refreshTime,int maxTime){
  if ((maxTime - ttl) >= refreshTime) {
    LOGGER.info(""String_Node_Str"" + (maxTime - ttl) + ""String_Node_Str""+ refreshTime);
synchronized (urlsToUpdate) {
      if (urlsToUpdate.contains(url)) {
        return;
      }
      urlsToUpdate.add(url);
    }
    updateService.submit(new CacheUpdateTask(url,current));
  }
}",0.7253333333333334
99301,"public Resource getCachedResource(URL urlURL,long maxCacheMS,boolean bUseOlder) throws LiveDocumentNotAvailableException, LiveWebCacheUnavailableException, LiveWebTimeoutException, IOException {
  String robotsFile=null;
  Jedis jedis=null;
  String url=urlURL.toExternalForm();
  long startTime=0;
  try {
    jedis=redisConn.getJedisInstance();
    startTime=System.currentTimeMillis();
    robotsFile=jedis.get(url);
    PerformanceLogger.noteElapsed(""String_Node_Str"",System.currentTimeMillis() - startTime,((robotsFile == null) ? ""String_Node_Str"" : ""String_Node_Str"") + url);
  }
 catch (  JedisConnectionException jce) {
    LOGGER.severe(""String_Node_Str"" + jce);
    redisConn.returnBrokenJedis(jedis);
    jedis=null;
  }
  try {
    if (robotsFile == null) {
      redisConn.returnJedisInstance(jedis);
      jedis=null;
      RobotResponse robotResponse=doUpdate(url,null);
      if (!robotResponse.isValid()) {
        throw new LiveDocumentNotAvailableException(""String_Node_Str"");
      }
      robotsFile=robotResponse.contents;
    }
 else     if (robotsFile.startsWith(ROBOTS_TOKEN_ERROR)) {
      asyncUpdateCheck(jedis,url,robotsFile,notAvailRefreshTTL,notAvailTotalTTL);
      throw new LiveDocumentNotAvailableException(""String_Node_Str"" + robotsFile);
    }
 else {
      asyncUpdateCheck(jedis,url,robotsFile,refreshTTL,totalTTL);
      if (robotsFile.equals(ROBOTS_TOKEN_EMPTY)) {
        robotsFile=""String_Node_Str"";
      }
    }
  }
 catch (  JedisConnectionException jce) {
    LOGGER.severe(""String_Node_Str"" + jce);
    redisConn.returnBrokenJedis(jedis);
    jedis=null;
    if (robotsFile != null) {
      return new RobotsTxtResource(robotsFile);
    }
    throw new LiveWebCacheUnavailableException(jce.toString());
  }
 finally {
    redisConn.returnJedisInstance(jedis);
  }
  return new RobotsTxtResource(robotsFile);
}","public Resource getCachedResource(URL urlURL,long maxCacheMS,boolean bUseOlder) throws LiveDocumentNotAvailableException, LiveWebCacheUnavailableException, LiveWebTimeoutException, IOException {
  String robotsFile=null;
  Jedis jedis=null;
  String url=urlURL.toExternalForm();
  long startTime=0;
  try {
    jedis=redisConn.getJedisInstance();
    startTime=System.currentTimeMillis();
    robotsFile=jedis.get(url);
    PerformanceLogger.noteElapsed(""String_Node_Str"",System.currentTimeMillis() - startTime,((robotsFile == null) ? ""String_Node_Str"" : ""String_Node_Str"") + url);
  }
 catch (  JedisConnectionException jce) {
    LOGGER.severe(""String_Node_Str"" + jce);
    redisConn.returnBrokenJedis(jedis);
    jedis=null;
  }
  try {
    if (robotsFile == null) {
      redisConn.returnJedisInstance(jedis);
      jedis=null;
      RobotResponse robotResponse=doUpdate(url,null);
      if (!robotResponse.isValid()) {
        throw new LiveDocumentNotAvailableException(""String_Node_Str"");
      }
      robotsFile=robotResponse.contents;
    }
 else     if (robotsFile.startsWith(ROBOTS_TOKEN_ERROR)) {
      startTime=System.currentTimeMillis();
      long ttl=jedis.ttl(url);
      PerformanceLogger.noteElapsed(""String_Node_Str"",System.currentTimeMillis() - startTime,""String_Node_Str"" + robotsFile);
      redisConn.returnJedisInstance(jedis);
      jedis=null;
      asyncUpdateCheck(ttl,url,robotsFile,notAvailRefreshTTL,notAvailTotalTTL);
      throw new LiveDocumentNotAvailableException(""String_Node_Str"" + robotsFile);
    }
 else {
      startTime=System.currentTimeMillis();
      long ttl=jedis.ttl(url);
      PerformanceLogger.noteElapsed(""String_Node_Str"",System.currentTimeMillis() - startTime,""String_Node_Str"" + robotsFile.length());
      redisConn.returnJedisInstance(jedis);
      jedis=null;
      asyncUpdateCheck(ttl,url,robotsFile,refreshTTL,totalTTL);
      if (robotsFile.equals(ROBOTS_TOKEN_EMPTY)) {
        robotsFile=""String_Node_Str"";
      }
    }
  }
 catch (  JedisConnectionException jce) {
    LOGGER.severe(""String_Node_Str"" + jce);
    redisConn.returnBrokenJedis(jedis);
    jedis=null;
    if (robotsFile != null) {
      return new RobotsTxtResource(robotsFile);
    }
    throw new LiveWebCacheUnavailableException(jce.toString());
  }
 finally {
    redisConn.returnJedisInstance(jedis);
  }
  return new RobotsTxtResource(robotsFile);
}",0.8702613609606781
99302,"public int filterObject(CaptureSearchResult r){
  String captureDate=r.getCaptureTimestamp();
  return (endDate.substring(0,captureDate.length()).compareTo(captureDate) < 0) ? FILTER_ABORT : FILTER_INCLUDE;
}","public int filterObject(CaptureSearchResult r){
  String captureDate=r.getCaptureTimestamp();
  int captureDateLength=Math.min(captureDate.length(),endDate.length());
  return (endDate.substring(0,captureDateLength).compareTo(captureDate) < 0) ? FILTER_ABORT : FILTER_INCLUDE;
}",0.8189300411522634
99303,"public void processFile(String path){
  try {
    System.out.println(""String_Node_Str"" + path);
    ResourceProducer producer=ProducerUtils.getProducer(path);
    ResourceFactoryMapper mapper=new ExtractingResourceFactoryMapper();
    ExtractingResourceProducer exProducer=new ExtractingResourceProducer(producer,mapper);
    Resource resource=null;
    resource=exProducer.getNext();
    while (resource != null) {
      resource=exProducer.getNext();
      if (resource instanceof HTTPResponseResource) {
        String url=JSONUtils.extractSingle(resource.getMetaData().getTopMetaData(),""String_Node_Str"");
        HTTPResponseResource httpResp=(HTTPResponseResource)resource;
        HttpResponse response=httpResp.getHttpResponse();
        int status=response.getMessage().getStatus();
        if (url.endsWith(""String_Node_Str"")) {
          if (jedis != null) {
            if (jedis.exists(url)) {
              dupCount++;
              continue;
            }
          }
 else {
            if (urlDB.contains(url)) {
              dupCount++;
              continue;
            }
            urlDB.add(url);
          }
          String contents=IOUtils.toString(httpResp.getHttpResponse().getInner(),""String_Node_Str"");
          int size=contents.length();
          System.out.println(""String_Node_Str"" + status + ""String_Node_Str""+ url+ ""String_Node_Str""+ size);
          totalSize+=contents.length();
          totalFiles++;
          if (status == 200) {
            totalSuccessSize+=contents.length();
            totalSuccessFiles++;
            if (jedis != null) {
              jedis.setex(url,60 * 60 * 4,contents);
            }
          }
        }
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  ResourceParseException e) {
    e.printStackTrace();
  }
catch (  Exception e) {
    e.printStackTrace();
  }
}","public void processFile(String path){
  try {
    System.out.println(""String_Node_Str"" + path);
    ResourceProducer producer=ProducerUtils.getProducer(path);
    ResourceFactoryMapper mapper=new ExtractingResourceFactoryMapper();
    ExtractingResourceProducer exProducer=new ExtractingResourceProducer(producer,mapper);
    Resource resource=null;
    resource=exProducer.getNext();
    while (resource != null) {
      resource=exProducer.getNext();
      if (resource instanceof HTTPResponseResource) {
        String url=JSONUtils.extractSingle(resource.getMetaData().getTopMetaData(),""String_Node_Str"");
        HTTPResponseResource httpResp=(HTTPResponseResource)resource;
        HttpResponse response=httpResp.getHttpResponse();
        int status=response.getMessage().getStatus();
        if (url.endsWith(""String_Node_Str"")) {
          if (jedis != null) {
            if (jedis.exists(url)) {
              dupCount++;
              continue;
            }
          }
 else {
            if (urlDB.contains(url)) {
              dupCount++;
              continue;
            }
            urlDB.add(url);
          }
          String contents=IOUtils.toString(response.getInner(),""String_Node_Str"");
          String contentType=response.getHeaders().getValue(""String_Node_Str"");
          int size=contents.length();
          System.out.println(""String_Node_Str"" + status + ""String_Node_Str""+ url+ ""String_Node_Str""+ size+ ""String_Node_Str""+ contentType);
          totalSize+=contents.length();
          totalFiles++;
          if (status == 200) {
            totalSuccessSize+=contents.length();
            totalSuccessFiles++;
            if (jedis != null) {
              jedis.setex(url,60 * 60 * 4,contents);
            }
          }
        }
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  ResourceParseException e) {
    e.printStackTrace();
  }
catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9260801665799064
99304,"private RobotResponse loadRobotsUrl(String url){
  int status=200;
  try {
    HttpGet httpGet=new HttpGet(url);
    HttpResponse response=httpClient.execute(httpGet);
    String contents=null;
    if (response != null) {
      status=response.getStatusLine().getStatusCode();
    }
    if (status == 200) {
      contents=EntityUtils.toString(response.getEntity());
    }
 else {
      return new RobotResponse(status);
    }
    return new RobotResponse(contents);
  }
 catch (  Exception exc) {
    LOGGER.info(""String_Node_Str"" + exc + ""String_Node_Str""+ url+ ""String_Node_Str""+ status);
    return new RobotResponse(status);
  }
}","private RobotResponse loadRobotsUrl(String url){
  int status=200;
  try {
    HttpGet httpGet=new HttpGet(url);
    HttpResponse response=httpClient.execute(httpGet);
    String contents=null;
    if (response != null) {
      status=response.getStatusLine().getStatusCode();
    }
    if (status == 200) {
      contents=EntityUtils.toString(response.getEntity());
      return new RobotResponse(contents,status);
    }
 else {
      return new RobotResponse(null,status);
    }
  }
 catch (  Exception exc) {
    LOGGER.info(""String_Node_Str"" + exc + ""String_Node_Str""+ url+ ""String_Node_Str""+ status);
    return new RobotResponse(null,status);
  }
}",0.9231962761830876
99305,"RobotResponse(int status){
  this.status=status;
}","RobotResponse(String contents,int status){
  this.contents=contents;
  this.status=status;
}",0.704225352112676
99306,"public void processFile(String path){
  try {
    System.out.println(""String_Node_Str"" + path);
    ResourceProducer producer=ProducerUtils.getProducer(path);
    ResourceFactoryMapper mapper=new ExtractingResourceFactoryMapper();
    ExtractingResourceProducer exProducer=new ExtractingResourceProducer(producer,mapper);
    Resource resource=null;
    resource=exProducer.getNext();
    while (resource != null) {
      resource=exProducer.getNext();
      if (resource instanceof HTTPResponseResource) {
        String url=JSONUtils.extractSingle(resource.getMetaData().getTopMetaData(),""String_Node_Str"");
        HTTPResponseResource httpResp=(HTTPResponseResource)resource;
        HttpResponse response=httpResp.getHttpResponse();
        int status=response.getMessage().getStatus();
        if (url.endsWith(""String_Node_Str"")) {
          if (jedis != null) {
            if (jedis.exists(url)) {
              dupCount++;
              continue;
            }
          }
 else {
            if (urlDB.contains(url)) {
              dupCount++;
              continue;
            }
            urlDB.add(url);
          }
          String contents=IOUtils.toString(httpResp.getHttpResponse().getInner(),""String_Node_Str"");
          int size=contents.length();
          System.out.println(""String_Node_Str"" + status + ""String_Node_Str""+ url+ ""String_Node_Str""+ size);
          totalSize+=contents.length();
          totalFiles++;
          if (status == 200) {
            totalSuccessSize+=contents.length();
            totalSuccessFiles++;
            if (jedis != null) {
              jedis.setex(url,60 * 60 * 4,contents);
            }
          }
        }
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  ResourceParseException e) {
    e.printStackTrace();
  }
catch (  Exception e) {
    e.printStackTrace();
  }
}","public void processFile(String path){
  try {
    System.out.println(""String_Node_Str"" + path);
    ResourceProducer producer=ProducerUtils.getProducer(path);
    ResourceFactoryMapper mapper=new ExtractingResourceFactoryMapper();
    ExtractingResourceProducer exProducer=new ExtractingResourceProducer(producer,mapper);
    Resource resource=null;
    resource=exProducer.getNext();
    while (resource != null) {
      resource=exProducer.getNext();
      if (resource instanceof HTTPResponseResource) {
        String url=JSONUtils.extractSingle(resource.getMetaData().getTopMetaData(),""String_Node_Str"");
        HTTPResponseResource httpResp=(HTTPResponseResource)resource;
        HttpResponse response=httpResp.getHttpResponse();
        int status=response.getMessage().getStatus();
        if (url.endsWith(""String_Node_Str"")) {
          if (jedis != null) {
            if (jedis.exists(url)) {
              dupCount++;
              continue;
            }
          }
 else {
            if (urlDB.contains(url)) {
              dupCount++;
              continue;
            }
            urlDB.add(url);
          }
          String contents=IOUtils.toString(response.getInner(),""String_Node_Str"");
          String contentType=response.getHeaders().getValue(""String_Node_Str"");
          int size=contents.length();
          System.out.println(""String_Node_Str"" + status + ""String_Node_Str""+ url+ ""String_Node_Str""+ size+ ""String_Node_Str""+ contentType);
          totalSize+=contents.length();
          totalFiles++;
          if (status == 200) {
            totalSuccessSize+=contents.length();
            totalSuccessFiles++;
            if (jedis != null) {
              jedis.setex(url,60 * 60 * 4,contents);
            }
          }
        }
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  ResourceParseException e) {
    e.printStackTrace();
  }
catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9260801665799064
99307,"private RobotResponse loadRobotsUrl(String url){
  int status=200;
  try {
    HttpGet httpGet=new HttpGet(url);
    HttpResponse response=httpClient.execute(httpGet);
    String contents=null;
    if (response != null) {
      status=response.getStatusLine().getStatusCode();
    }
    if (status == 200) {
      contents=EntityUtils.toString(response.getEntity());
    }
 else {
      return new RobotResponse(status);
    }
    return new RobotResponse(contents);
  }
 catch (  Exception exc) {
    LOGGER.info(""String_Node_Str"" + exc + ""String_Node_Str""+ url+ ""String_Node_Str""+ status);
    return new RobotResponse(status);
  }
}","private RobotResponse loadRobotsUrl(String url){
  int status=200;
  try {
    HttpGet httpGet=new HttpGet(url);
    HttpResponse response=httpClient.execute(httpGet);
    String contents=null;
    if (response != null) {
      status=response.getStatusLine().getStatusCode();
    }
    if (status == 200) {
      contents=EntityUtils.toString(response.getEntity());
      return new RobotResponse(contents,status);
    }
 else {
      return new RobotResponse(null,status);
    }
  }
 catch (  Exception exc) {
    LOGGER.info(""String_Node_Str"" + exc + ""String_Node_Str""+ url+ ""String_Node_Str""+ status);
    return new RobotResponse(null,status);
  }
}",0.9231962761830876
99308,"RobotResponse(int status){
  this.status=status;
}","RobotResponse(String contents,int status){
  this.contents=contents;
  this.status=status;
}",0.704225352112676
99309,"public void processFile(String path){
  try {
    System.out.println(""String_Node_Str"" + path);
    ResourceProducer producer=ProducerUtils.getProducer(path);
    ResourceFactoryMapper mapper=new ExtractingResourceFactoryMapper();
    ExtractingResourceProducer exProducer=new ExtractingResourceProducer(producer,mapper);
    Resource resource=null;
    resource=exProducer.getNext();
    while (resource != null) {
      resource=exProducer.getNext();
      if (resource instanceof HTTPResponseResource) {
        String url=JSONUtils.extractSingle(resource.getMetaData().getTopMetaData(),""String_Node_Str"");
        HTTPResponseResource httpResp=(HTTPResponseResource)resource;
        HttpResponse response=httpResp.getHttpResponse();
        int status=response.getMessage().getStatus();
        if (url.endsWith(""String_Node_Str"")) {
          if (jedis != null) {
            if (jedis.exists(url)) {
              dupCount++;
              continue;
            }
          }
 else {
            if (urlDB.contains(url)) {
              dupCount++;
              continue;
            }
            urlDB.add(url);
          }
          String contents=IOUtils.toString(response.getInner(),""String_Node_Str"");
          String contentType=response.getHeaders().getValue(""String_Node_Str"");
          int size=contents.length();
          System.out.println(""String_Node_Str"" + status + ""String_Node_Str""+ url+ ""String_Node_Str""+ size+ ""String_Node_Str""+ contentType);
          totalSize+=contents.length();
          totalFiles++;
          if (status == 200) {
            totalSuccessSize+=contents.length();
            totalSuccessFiles++;
            if (jedis != null) {
              jedis.setex(url,60 * 60 * 4,contents);
            }
          }
        }
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  ResourceParseException e) {
    e.printStackTrace();
  }
catch (  Exception e) {
    e.printStackTrace();
  }
}","public void processFile(String path){
  try {
    System.out.println(""String_Node_Str"" + path);
    ResourceProducer producer=ProducerUtils.getProducer(path);
    ResourceFactoryMapper mapper=new ExtractingResourceFactoryMapper();
    ExtractingResourceProducer exProducer=new ExtractingResourceProducer(producer,mapper);
    Resource resource=null;
    resource=exProducer.getNext();
    while (resource != null) {
      resource=exProducer.getNext();
      if (resource instanceof HTTPResponseResource) {
        String url=JSONUtils.extractSingle(resource.getMetaData().getTopMetaData(),""String_Node_Str"");
        HTTPResponseResource httpResp=(HTTPResponseResource)resource;
        HttpResponse response=httpResp.getHttpResponse();
        int status=response.getMessage().getStatus();
        if (url.endsWith(""String_Node_Str"")) {
          if (jedis != null) {
            if (jedis.exists(url)) {
              dupCount++;
              continue;
            }
          }
 else {
            if (urlDB.contains(url)) {
              dupCount++;
              continue;
            }
            urlDB.add(url);
          }
          String contents=IOUtils.toString(httpResp.getHttpResponse().getInner(),""String_Node_Str"");
          int size=contents.length();
          System.out.println(""String_Node_Str"" + status + ""String_Node_Str""+ url+ ""String_Node_Str""+ size);
          totalSize+=contents.length();
          totalFiles++;
          if (status == 200) {
            totalSuccessSize+=contents.length();
            totalSuccessFiles++;
            if (jedis != null) {
              jedis.setex(url,60 * 60 * 4,contents);
            }
          }
        }
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  ResourceParseException e) {
    e.printStackTrace();
  }
catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9255596043727226
99310,"private RobotResponse loadRobotsUrl(String url){
  int status=200;
  try {
    HttpGet httpGet=new HttpGet(url);
    HttpResponse response=httpClient.execute(httpGet);
    String contents=null;
    if (response != null) {
      status=response.getStatusLine().getStatusCode();
    }
    if (status == 200) {
      contents=EntityUtils.toString(response.getEntity());
      return new RobotResponse(contents,status);
    }
 else {
      return new RobotResponse(null,status);
    }
  }
 catch (  Exception exc) {
    LOGGER.info(""String_Node_Str"" + exc + ""String_Node_Str""+ url+ ""String_Node_Str""+ status);
    return new RobotResponse(null,status);
  }
}","private RobotResponse loadRobotsUrl(String url){
  int status=200;
  try {
    HttpGet httpGet=new HttpGet(url);
    HttpResponse response=httpClient.execute(httpGet);
    String contents=null;
    if (response != null) {
      status=response.getStatusLine().getStatusCode();
    }
    if (status == 200) {
      contents=EntityUtils.toString(response.getEntity());
    }
 else {
      return new RobotResponse(status);
    }
    return new RobotResponse(contents);
  }
 catch (  Exception exc) {
    LOGGER.info(""String_Node_Str"" + exc + ""String_Node_Str""+ url+ ""String_Node_Str""+ status);
    return new RobotResponse(status);
  }
}",0.948021722265322
99311,"RobotResponse(String contents,int status){
  this.contents=contents;
  this.status=status;
}","RobotResponse(int status){
  this.status=status;
}",0.704225352112676
99312,"public WaybackRequest parse(HttpServletRequest httpRequest,AccessPoint wbContext) throws BadQueryException, BetterRequestException {
  WaybackRequest wbRequest=super.parse(httpRequest,wbContext);
  if (wbRequest != null) {
    String id=httpRequest.getHeader(""String_Node_Str"");
    if (id == null)     id=httpRequest.getRemoteAddr();
    if (wbRequest.isReplayRequest()) {
      String replayTimestamp=wbRequest.getReplayTimestamp();
      if (replayTimestamp != null) {
        BDBMap.addTimestampForId(httpRequest.getContextPath(),id,replayTimestamp);
      }
      throw new BetterRequestException(wbRequest.getRequestUrl());
    }
    String replayDateStr=BDBMap.getTimestampForId(httpRequest.getContextPath(),id);
    wbRequest.setReplayTimestamp(replayDateStr);
    wbRequest.setAnchorTimestamp(replayDateStr);
  }
  return wbRequest;
}","public WaybackRequest parse(HttpServletRequest httpRequest,AccessPoint wbContext) throws BadQueryException, BetterRequestException {
  WaybackRequest wbRequest=super.parse(httpRequest,wbContext);
  if (wbRequest != null) {
    String id=httpRequest.getHeader(""String_Node_Str"");
    if (id == null)     id=httpRequest.getRemoteAddr();
    if (wbRequest.isReplayRequest()) {
      String replayTimestamp=wbRequest.getReplayTimestamp();
      if (replayTimestamp != null) {
        BDBMap.addTimestampForId(httpRequest.getContextPath(),id,replayTimestamp);
        throw new BetterRequestException(wbRequest.getRequestUrl());
      }
    }
    String replayDateStr=BDBMap.getTimestampForId(httpRequest.getContextPath(),id);
    wbRequest.setReplayTimestamp(replayDateStr);
    wbRequest.setAnchorTimestamp(replayDateStr);
  }
  return wbRequest;
}",0.9917061611374408
99313,"/** 
 * Attempt to extract the hostname component of an absolute URL argument.
 * @param url the url String from which to extract the hostname
 * @return the hostname within the URL, or the url argument if the host cannot be found.
 */
public static String urlToHost(String url){
  String lcUrl=url.toLowerCase();
  if (lcUrl.startsWith(""String_Node_Str"")) {
    return lcUrl.substring(4);
  }
  for (  String scheme : ALL_SCHEMES) {
    if (lcUrl.startsWith(scheme)) {
      int authorityIdx=scheme.length();
      Matcher m=HOST_REGEX_SIMPLE.matcher(lcUrl.substring(authorityIdx));
      if (m.find()) {
        return m.group(1);
      }
    }
  }
  return url;
}","/** 
 * Attempt to extract the hostname component of an absolute URL argument.
 * @param url the url String from which to extract the hostname
 * @return the hostname within the URL, or the url argument if the host cannot be found.
 */
public static String urlToHost(String url){
  String lcUrl=url.toLowerCase();
  if (lcUrl.startsWith(DNS_SCHEME)) {
    return lcUrl.substring(DNS_SCHEME.length());
  }
  for (  String scheme : ALL_SCHEMES) {
    if (lcUrl.startsWith(scheme)) {
      int authorityIdx=scheme.length();
      Matcher m=HOST_REGEX_SIMPLE.matcher(lcUrl.substring(authorityIdx));
      if (m.find()) {
        return m.group(1);
      }
    }
  }
  return url;
}",0.9233060312732688
99314,"/** 
 * Extract userinfo from the absolute URL argument, that is, ""username@"", or ""username:password@"" if present.
 * @param url the URL from which to extract the userinfo
 * @return the userinfo found, not including the ""@"", or null if no userinfois found
 */
public static String urlToUserInfo(String url){
  String lcUrl=url.toLowerCase();
  if (lcUrl.startsWith(""String_Node_Str"")) {
    return null;
  }
  for (  String scheme : ALL_SCHEMES) {
    if (lcUrl.startsWith(scheme)) {
      int authorityIdx=scheme.length();
      Matcher m=USERINFO_REGEX_SIMPLE.matcher(lcUrl.substring(authorityIdx));
      if (m.find()) {
        return m.group(1);
      }
    }
  }
  return null;
}","/** 
 * Extract userinfo from the absolute URL argument, that is, ""username@"", or ""username:password@"" if present.
 * @param url the URL from which to extract the userinfo
 * @return the userinfo found, not including the ""@"", or null if no userinfois found
 */
public static String urlToUserInfo(String url){
  String lcUrl=url.toLowerCase();
  if (lcUrl.startsWith(DNS_SCHEME)) {
    return null;
  }
  for (  String scheme : ALL_SCHEMES) {
    if (lcUrl.startsWith(scheme)) {
      int authorityIdx=scheme.length();
      Matcher m=USERINFO_REGEX_SIMPLE.matcher(lcUrl.substring(authorityIdx));
      if (m.find()) {
        return m.group(1);
      }
    }
  }
  return null;
}",0.9816849816849816
99315,"/** 
 * Test method for 'org.archive.wayback.cdx.CDXRecord.urlStringToKey(String)'
 */
public void testUrlStringToKey(){
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  String sid1=""String_Node_Str"";
  String sid2=""String_Node_Str"";
  String sid3=""String_Node_Str"";
  String sid4=""String_Node_Str"";
  String sid5=""String_Node_Str"";
  String sid6=""String_Node_Str"";
  String fore=""String_Node_Str"";
  String aft=""String_Node_Str"";
  String want=""String_Node_Str"";
  checkCanonicalization(fore + sid1 + aft,want);
  checkCanonicalization(fore + sid2 + aft,want);
  checkCanonicalization(fore + sid3 + aft,want);
  checkCanonicalization(fore + sid4 + aft,want);
  checkCanonicalization(fore + sid5 + aft,want);
  checkCanonicalization(fore + sid6 + aft,want);
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  String origHost=""String_Node_Str"";
  String massagedHost=""String_Node_Str"";
  String path=""String_Node_Str"";
  for (  String scheme : UrlOperations.ALL_SCHEMES) {
    int defaultPort=UrlOperations.schemeToDefaultPort(scheme);
    int nonDefaultPort=19991;
    String origDefault=scheme + origHost + ""String_Node_Str""+ defaultPort+ path;
    String canonDefault=massagedHost + path;
    String origNonDefault=scheme + origHost + ""String_Node_Str""+ nonDefaultPort+ path;
    String canonNonDefault=massagedHost + ""String_Node_Str"" + nonDefaultPort+ path;
    checkCanonicalization(origDefault,canonDefault);
    checkCanonicalization(origNonDefault,canonNonDefault);
  }
}","/** 
 * Test method for 'org.archive.wayback.cdx.CDXRecord.urlStringToKey(String)'
 */
public void testUrlStringToKey(){
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  String sid1=""String_Node_Str"";
  String sid2=""String_Node_Str"";
  String sid3=""String_Node_Str"";
  String sid4=""String_Node_Str"";
  String sid5=""String_Node_Str"";
  String sid6=""String_Node_Str"";
  String fore=""String_Node_Str"";
  String aft=""String_Node_Str"";
  String want=""String_Node_Str"";
  checkCanonicalization(fore + sid1 + aft,want);
  checkCanonicalization(fore + sid2 + aft,want);
  checkCanonicalization(fore + sid3 + aft,want);
  checkCanonicalization(fore + sid4 + aft,want);
  checkCanonicalization(fore + sid5 + aft,want);
  checkCanonicalization(fore + sid6 + aft,want);
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  checkCanonicalization(""String_Node_Str"",""String_Node_Str"");
  String origHost=""String_Node_Str"";
  String massagedHost=""String_Node_Str"";
  String path=""String_Node_Str"";
  for (  String scheme : UrlOperations.ALL_SCHEMES) {
    int defaultPort=UrlOperations.schemeToDefaultPort(scheme);
    int nonDefaultPort=19991;
    String origDefault=scheme + origHost + ""String_Node_Str""+ defaultPort+ path;
    String canonDefault=massagedHost + path;
    String origNonDefault=scheme + origHost + ""String_Node_Str""+ nonDefaultPort+ path;
    String canonNonDefault=massagedHost + ""String_Node_Str"" + nonDefaultPort+ path;
    checkCanonicalization(origDefault,canonDefault);
    checkCanonicalization(origNonDefault,canonNonDefault);
  }
}",0.9921638018200202
99316,"public void testStripDefaultPort(){
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
}","public void testStripDefaultPort(){
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
  assertSDP(""String_Node_Str"",""String_Node_Str"");
}",0.9793729372937292
99317,"public void testUrlToUserInfo(){
  assertEquals(null,UrlOperations.urlToUserInfo(""String_Node_Str""));
  assertEquals(null,UrlOperations.urlToUserInfo(""String_Node_Str""));
  assertEquals(null,UrlOperations.urlToUserInfo(""String_Node_Str""));
  assertEquals(null,UrlOperations.urlToUserInfo(""String_Node_Str""));
  assertEquals(null,UrlOperations.urlToUserInfo(""String_Node_Str""));
  assertEquals(null,UrlOperations.urlToUserInfo(""String_Node_Str""));
  assertEquals(null,UrlOperations.urlToUserInfo(""String_Node_Str""));
  assertEquals(null,UrlOperations.urlToUserInfo(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToUserInfo(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToUserInfo(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToUserInfo(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToUserInfo(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToUserInfo(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
}","public void testUrlToUserInfo(){
  assertEquals(null,UrlOperations.urlToUserInfo(""String_Node_Str""));
  assertEquals(null,UrlOperations.urlToUserInfo(""String_Node_Str""));
  assertEquals(null,UrlOperations.urlToUserInfo(""String_Node_Str""));
  assertEquals(null,UrlOperations.urlToUserInfo(""String_Node_Str""));
  assertEquals(null,UrlOperations.urlToUserInfo(""String_Node_Str""));
  assertEquals(null,UrlOperations.urlToUserInfo(""String_Node_Str""));
  assertEquals(null,UrlOperations.urlToUserInfo(""String_Node_Str""));
  assertEquals(null,UrlOperations.urlToUserInfo(""String_Node_Str""));
  assertEquals(null,UrlOperations.urlToUserInfo(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToUserInfo(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToUserInfo(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToUserInfo(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToUserInfo(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToUserInfo(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
}",0.9709228824273072
99318,"public static String urlToHost(String url){
  if (url.startsWith(""String_Node_Str"")) {
    return url.substring(4);
  }
  for (  String scheme : ALL_SCHEMES) {
    if (url.startsWith(scheme)) {
      int hostIdx=scheme.length();
      Matcher m=AUTHORITY_REGEX_SIMPLE.matcher(url.substring(hostIdx));
      if (m.find()) {
        return m.group(0);
      }
    }
  }
  return url;
}","public static String urlToHost(String url){
  String lcUrl=url.toLowerCase();
  if (lcUrl.startsWith(""String_Node_Str"")) {
    return lcUrl.substring(4);
  }
  for (  String scheme : ALL_SCHEMES) {
    if (lcUrl.startsWith(scheme)) {
      int authorityIdx=scheme.length();
      Matcher m=HOST_REGEX_SIMPLE.matcher(lcUrl.substring(authorityIdx));
      if (m.find()) {
        return m.group(1);
      }
    }
  }
  return url;
}",0.8954489544895449
99319,"public void testUrlToHost(){
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
}","public void testUrlToHost(){
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
  assertEquals(""String_Node_Str"",UrlOperations.urlToHost(""String_Node_Str""));
}",0.8376844494892168
99320,"public StringPrefixIterator(Iterator<String> inner,String prefix){
  this.prefix=prefix;
  this.inner=inner;
}","public StringPrefixIterator(Iterator<String> inner,String prefix){
  this.prefix=prefix;
  this.inner=inner;
  if (inner instanceof ZiplinesChunkIterator) {
    truncated=((ZiplinesChunkIterator)inner).isTruncated();
  }
}",0.6626506024096386
99321,"/** 
 * @return a BufferedReader of the underlying compressed data in this block
 * @throws IOException for usual reasons
 */
public BufferedReader readBlock() throws IOException {
  URL u=new URL(urlOrPath);
  URLConnection uc=u.openConnection();
  StringBuilder sb=new StringBuilder(16);
  sb.append(BYTES_HEADER).append(offset).append(BYTES_MINUS);
  sb.append((offset + BLOCK_SIZE) - 1);
  uc.setRequestProperty(RANGE_HEADER,sb.toString());
  return new BufferedReader(new InputStreamReader(new GZIPInputStream(uc.getInputStream())));
}","/** 
 * @return a BufferedReader of the underlying compressed data in this block
 * @throws IOException for usual reasons
 */
public BufferedReader readBlock() throws IOException {
  StringBuilder sb=new StringBuilder(16);
  sb.append(BYTES_HEADER).append(offset).append(BYTES_MINUS);
  sb.append((offset + BLOCK_SIZE) - 1);
  LOGGER.trace(""String_Node_Str"" + urlOrPath + ""String_Node_Str""+ sb.toString()+ ""String_Node_Str"");
  URL u=new URL(urlOrPath);
  URLConnection uc=u.openConnection();
  uc.setRequestProperty(RANGE_HEADER,sb.toString());
  return new BufferedReader(new InputStreamReader(new GZIPInputStream(uc.getInputStream())));
}",0.8010160880609652
99322,"/** 
 * @param blocks which should be fetched and unzipped, one after another
 */
public ZiplinesChunkIterator(List<ZiplinedBlock> blocks){
  blockItr=blocks.iterator();
}","/** 
 * @param blocks which should be fetched and unzipped, one after another
 */
public ZiplinesChunkIterator(List<ZiplinedBlock> blocks){
  LOGGER.info(""String_Node_Str"" + blocks.size() + ""String_Node_Str"");
  blockItr=blocks.iterator();
}",0.8300970873786407
99323,"public Iterator<String> getStringPrefixIterator(String prefix) throws ResourceIndexNotAvailableException, IOException {
  CloseableIterator<String> itr=chunkIndex.getRecordIteratorLT(prefix);
  ArrayList<ZiplinedBlock> blocks=new ArrayList<ZiplinedBlock>();
  boolean first=true;
  while (itr.hasNext()) {
    String blockDescriptor=itr.next();
    String parts[]=blockDescriptor.split(""String_Node_Str"");
    if (parts.length != 3) {
      throw new ResourceIndexNotAvailableException(""String_Node_Str"" + blockDescriptor + ""String_Node_Str"");
    }
    String prefCmp=prefix;
    String blockCmp=parts[0];
    if (first) {
      first=false;
    }
 else     if (!blockCmp.startsWith(prefCmp)) {
      break;
    }
    String url=chunkMap.get(parts[1]);
    long offset=Long.parseLong(parts[2]);
    blocks.add(new ZiplinedBlock(url,offset));
  }
  itr.close();
  return new StringPrefixIterator(new ZiplinesChunkIterator(blocks),prefix);
}","public Iterator<String> getStringPrefixIterator(String prefix) throws ResourceIndexNotAvailableException, IOException {
  ArrayList<ZiplinedBlock> blocks=new ArrayList<ZiplinedBlock>();
  boolean first=true;
  int numBlocks=0;
  boolean truncated=false;
  CloseableIterator<String> itr=null;
  try {
    itr=chunkIndex.getRecordIteratorLT(prefix);
    while (itr.hasNext()) {
      if (numBlocks >= maxBlocks) {
        truncated=true;
        break;
      }
      String blockDescriptor=itr.next();
      numBlocks++;
      String parts[]=blockDescriptor.split(""String_Node_Str"");
      if (parts.length != 3) {
        throw new ResourceIndexNotAvailableException(""String_Node_Str"" + blockDescriptor + ""String_Node_Str"");
      }
      String prefCmp=prefix;
      String blockCmp=parts[0];
      if (first) {
        first=false;
      }
 else       if (!blockCmp.startsWith(prefCmp)) {
        break;
      }
      String url=chunkMap.get(parts[1]);
      long offset=Long.parseLong(parts[2]);
      blocks.add(new ZiplinedBlock(url,offset));
    }
  }
  finally {
    if (itr != null) {
      itr.close();
    }
  }
  ZiplinesChunkIterator zci=new ZiplinesChunkIterator(blocks);
  zci.setTruncated(truncated);
  return new StringPrefixIterator(zci,prefix);
}",0.7181116659101225
99324,"/** 
 * Determine the correct ResultsPartitioner to use given the SearchResults search range, and use that to break the SearchResults into partitions.
 * @param results
 * @param wbRequest 
 * @return ArrayList of ResultsPartition objects
 */
public static ArrayList<ResultsPartition> get(SearchResults results,WaybackRequest wbRequest){
  String rsd=results.getFilter(WaybackConstants.REQUEST_START_DATE);
  String red=results.getFilter(WaybackConstants.REQUEST_END_DATE);
  Date startDate=new Date();
  Date endDate=new Date();
  try {
    startDate=ArchiveUtils.parse14DigitDate(rsd);
    endDate=ArchiveUtils.parse14DigitDate(red);
  }
 catch (  ParseException e) {
    e.printStackTrace();
  }
  long msSpanned=endDate.getTime() - startDate.getTime();
  int secsSpanned=(int)Math.ceil(msSpanned / 1000);
  ResultsPartitioner partitioner=null;
  for (int i=0; i < partitioners.length; i++) {
    partitioner=partitioners[i];
    if (partitioner.maxSecondsSpanned() >= secsSpanned) {
      break;
    }
  }
  ArrayList<ResultsPartition> partitions=new ArrayList<ResultsPartition>();
  Calendar startCal=partitioner.dateStrToCalendar(rsd);
  Calendar lastCal=partitioner.dateStrToCalendar(red);
  partitioner.alignStart(startCal);
  Calendar endCal=partitioner.incrementPartition(startCal,1);
  while (true) {
    String startDateStr=ArchiveUtils.get14DigitDate(startCal.getTime());
    String endDateStr=ArchiveUtils.get14DigitDate(endCal.getTime());
    String title=partitioner.rangeToTitle(startCal,endCal,wbRequest);
    ResultsPartition partition=new ResultsPartition(startDateStr,endDateStr,title);
    partition.filter(results);
    partitions.add(partition);
    if (endCal.after(lastCal)) {
      break;
    }
    startCal=endCal;
    endCal=partitioner.incrementPartition(startCal,1);
  }
  return partitions;
}","/** 
 * Determine the correct ResultsPartitioner to use given the SearchResults search range, and use that to break the SearchResults into partitions.
 * @param results
 * @param wbRequest 
 * @return ArrayList of ResultsPartition objects
 */
public static ArrayList<ResultsPartition> get(SearchResults results,WaybackRequest wbRequest){
  String rsd=results.getFilter(WaybackConstants.REQUEST_START_DATE);
  String red=results.getFilter(WaybackConstants.REQUEST_END_DATE);
  Date startDate=Timestamp.parseBefore(rsd).getDate();
  Date endDate=Timestamp.parseAfter(red).getDate();
  long msSpanned=endDate.getTime() - startDate.getTime();
  int secsSpanned=(int)Math.ceil(msSpanned / 1000);
  ResultsPartitioner partitioner=null;
  for (int i=0; i < partitioners.length; i++) {
    partitioner=partitioners[i];
    if (partitioner.maxSecondsSpanned() >= secsSpanned) {
      break;
    }
  }
  ArrayList<ResultsPartition> partitions=new ArrayList<ResultsPartition>();
  Calendar startCal=partitioner.dateStrToCalendar(rsd);
  Calendar lastCal=partitioner.dateStrToCalendar(red);
  partitioner.alignStart(startCal);
  Calendar endCal=partitioner.incrementPartition(startCal,1);
  while (true) {
    String startDateStr=ArchiveUtils.get14DigitDate(startCal.getTime());
    String endDateStr=ArchiveUtils.get14DigitDate(endCal.getTime());
    String title=partitioner.rangeToTitle(startCal,endCal,wbRequest);
    ResultsPartition partition=new ResultsPartition(startDateStr,endDateStr,title);
    partition.filter(results);
    partitions.add(partition);
    if (endCal.after(lastCal)) {
      break;
    }
    startCal=endCal;
    endCal=partitioner.incrementPartition(startCal,1);
  }
  return partitions;
}",0.91671388101983
99325,"/** 
 * @param context
 * @return singleton BDBMap for the context
 */
public static BDBMap getContextMap(String context){
  if (context == null)   context=""String_Node_Str"";
  if (context.startsWith(""String_Node_Str"")) {
    context=context.substring(1);
  }
  BDBMap map=null;
synchronized (Timestamp.class) {
    if (!bdbMaps.containsKey(context)) {
      bdbMaps.put(context,new BDBMap(context,BDB_DIR));
    }
    map=(BDBMap)bdbMaps.get(context);
  }
  return map;
}","/** 
 * @param context
 * @return singleton BDBMap for the context
 */
public static BDBMap getContextMap(String context){
  if (context == null)   context=""String_Node_Str"";
  if (context.startsWith(""String_Node_Str"")) {
    context=context.substring(1);
  }
  BDBMap map=null;
synchronized (Timestamp.class) {
    if (!bdbMaps.containsKey(context)) {
      File bdbDir=new File(BDB_DIR,context);
      bdbMaps.put(context,new BDBMap(context,bdbDir.getAbsolutePath()));
    }
    map=(BDBMap)bdbMaps.get(context);
  }
  return map;
}",0.8687872763419483
99326,"/** 
 * add BASE tag and javascript to a page that will rewrite embedded URLs  to point back into the WM
 * @param page
 * @param result
 * @param uriConverter
 */
private void markUpPage(StringBuffer page,SearchResult result,ReplayResultURIConverter uriConverter){
  insertBaseTag(page,result);
  insertJavascript(page,result,uriConverter);
}","/** 
 * add BASE tag and javascript to a page that will rewrite embedded URLs  to point back into the WM, also attempt to fix up URL attributes in some tags that must be correct at page load (FRAME, META, LINK, SCRIPT)
 * @param page
 * @param result
 * @param uriConverter
 */
private void markUpPage(StringBuffer page,SearchResult result,ReplayResultURIConverter uriConverter){
  String wmPrefix=uriConverter.getReplayUriPrefix();
  String pageUrl=result.get(WaybackConstants.RESULT_URL);
  String pageTS=result.get(WaybackConstants.RESULT_CAPTURE_DATE);
  TagMagix.markupTagRE(page,wmPrefix,pageUrl,pageTS,""String_Node_Str"",""String_Node_Str"");
  TagMagix.markupTagRE(page,wmPrefix,pageUrl,pageTS,""String_Node_Str"",""String_Node_Str"");
  TagMagix.markupTagRE(page,wmPrefix,pageUrl,pageTS,""String_Node_Str"",""String_Node_Str"");
  TagMagix.markupTagRE(page,wmPrefix,pageUrl,pageTS,""String_Node_Str"",""String_Node_Str"");
  insertBaseTag(page,result);
  insertJavascript(page,result,uriConverter);
}",0.5130890052356021
99327,"public void renderResource(HttpServletRequest httpRequest,HttpServletResponse httpResponse,WaybackRequest wbRequest,SearchResult result,Resource resource,ReplayResultURIConverter uriConverter) throws ServletException, IOException {
  if (resource == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (result == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!wbRequest.get(WaybackConstants.REQUEST_EXACT_DATE).equals(result.get(WaybackConstants.RESULT_CAPTURE_DATE))) {
    String betterURI=uriConverter.makeReplayURI(result);
    redirectToBetterUrl(httpResponse,betterURI);
  }
 else {
    if (isRawReplayResult(result)) {
      super.renderResource(httpRequest,httpResponse,wbRequest,result,resource,uriConverter);
    }
 else {
      resource.parseHeaders();
      copyRecordHttpHeader(httpResponse,resource,uriConverter,result,false);
      byte[] bbuffer=new byte[4 * 1024];
      StringBuffer sbuffer=new StringBuffer();
      for (int r=-1; (r=resource.read(bbuffer,0,bbuffer.length)) != -1; ) {
        String chunk=new String(bbuffer);
        sbuffer.append(chunk.substring(0,r));
      }
      markUpPage(sbuffer,result,uriConverter);
      httpResponse.setHeader(""String_Node_Str"",""String_Node_Str"" + sbuffer.length());
      ServletOutputStream out=httpResponse.getOutputStream();
      out.print(new String(sbuffer));
    }
  }
}","public void renderResource(HttpServletRequest httpRequest,HttpServletResponse httpResponse,WaybackRequest wbRequest,SearchResult result,Resource resource,ReplayResultURIConverter uriConverter) throws ServletException, IOException {
  if (resource == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (result == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!wbRequest.get(WaybackConstants.REQUEST_EXACT_DATE).equals(result.get(WaybackConstants.RESULT_CAPTURE_DATE))) {
    String betterURI=uriConverter.makeReplayURI(result);
    redirectToBetterUrl(httpResponse,betterURI);
  }
 else {
    if (isRawReplayResult(result)) {
      super.renderResource(httpRequest,httpResponse,wbRequest,result,resource,uriConverter);
    }
 else {
      resource.parseHeaders();
      copyRecordHttpHeader(httpResponse,resource,uriConverter,result,false);
      byte[] bbuffer=new byte[4 * 1024];
      StringBuffer sbuffer=new StringBuffer();
      for (int r=-1; (r=resource.read(bbuffer,0,bbuffer.length)) != -1; ) {
        sbuffer.append(new String(bbuffer,0,r));
      }
      markUpPage(sbuffer,result,uriConverter);
      httpResponse.setHeader(""String_Node_Str"",""String_Node_Str"" + sbuffer.length());
      ServletOutputStream out=httpResponse.getOutputStream();
      out.print(new String(sbuffer));
    }
  }
}",0.9742846794639624
99328,"/** 
 * Constructor -- chew search result summaries into format easier for JSPs to digest.
 * @param httpRequest 
 * @param wbRequest 
 * @param results
 * @param uriConverter 
 * @throws ParseException 
 */
public UIQueryResults(HttpServletRequest httpRequest,WaybackRequest wbRequest,SearchResults results,ReplayResultURIConverter uriConverter) throws ParseException {
  this.searchUrl=wbRequest.get(WaybackConstants.RESULT_URL);
  this.startTimestamp=Timestamp.parseBefore(results.getFilter(WaybackConstants.REQUEST_START_DATE));
  this.endTimestamp=Timestamp.parseBefore(results.getFilter(WaybackConstants.REQUEST_END_DATE));
  this.firstResultTimestamp=Timestamp.parseBefore(results.getFirstResultDate());
  this.lastResultTimestamp=Timestamp.parseBefore(results.getLastResultDate());
  this.resultsReturned=Integer.parseInt(results.getFilter(WaybackConstants.RESULTS_NUM_RETURNED));
  this.resultsMatching=Integer.parseInt(results.getFilter(WaybackConstants.RESULTS_NUM_RESULTS));
  this.resultsPerPage=Integer.parseInt(results.getFilter(WaybackConstants.RESULTS_REQUESTED));
  this.firstResult=Integer.parseInt(results.getFilter(WaybackConstants.RESULTS_FIRST_RETURNED));
  this.lastResult=(firstResult + resultsReturned);
  numPages=Math.round((int)Math.ceil(resultsMatching / resultsPerPage)) + 1;
  curPage=Math.round((int)Math.floor(firstResult / resultsPerPage)) + 1;
  this.results=results;
  this.uriConverter=uriConverter;
  this.wbRequest=wbRequest;
  this.httpRequest=httpRequest;
}","/** 
 * Constructor -- chew search result summaries into format easier for JSPs to digest.
 * @param httpRequest 
 * @param wbRequest 
 * @param results
 * @param uriConverter 
 * @throws ParseException 
 */
public UIQueryResults(HttpServletRequest httpRequest,WaybackRequest wbRequest,SearchResults results,ReplayResultURIConverter uriConverter) throws ParseException {
  this.searchUrl=wbRequest.get(WaybackConstants.RESULT_URL);
  this.startTimestamp=Timestamp.parseBefore(results.getFilter(WaybackConstants.REQUEST_START_DATE));
  this.endTimestamp=Timestamp.parseBefore(results.getFilter(WaybackConstants.REQUEST_END_DATE));
  this.firstResultTimestamp=Timestamp.parseBefore(results.getFirstResultDate());
  this.lastResultTimestamp=Timestamp.parseBefore(results.getLastResultDate());
  this.resultsReturned=Integer.parseInt(results.getFilter(WaybackConstants.RESULTS_NUM_RETURNED));
  this.resultsMatching=Integer.parseInt(results.getFilter(WaybackConstants.RESULTS_NUM_RESULTS));
  this.resultsPerPage=Integer.parseInt(results.getFilter(WaybackConstants.RESULTS_REQUESTED));
  this.firstResult=Integer.parseInt(results.getFilter(WaybackConstants.RESULTS_FIRST_RETURNED)) + 1;
  this.lastResult=((firstResult - 1) + resultsReturned);
  numPages=Math.round((int)Math.ceil(resultsMatching / resultsPerPage));
  curPage=Math.round((int)Math.floor((firstResult - 1) / resultsPerPage)) + 1;
  this.results=results;
  this.uriConverter=uriConverter;
  this.wbRequest=wbRequest;
  this.httpRequest=httpRequest;
}",0.9933554817275748
99329,"/** 
 * The pre-defined Stormpath access control settings are defined here.
 * @param http the  {@link HttpSecurity} to be modified
 * @throws Exception if an error occurs
 */
@Override public void init(HttpSecurity http) throws Exception {
  ApplicationContext context=http.getSharedObject(ApplicationContext.class);
  context.getAutowireCapableBeanFactory().autowireBean(this);
  if (stormpathEnabled && stormpathSpringSecurityAutoload) {
    stormpathSecurityConfigurerAdapter.init(http);
  }
}","/** 
 * The pre-defined Stormpath access control settings are defined here.
 * @param http the  {@link HttpSecurity} to be modified
 * @throws Exception if an error occurs
 */
@Override public void init(HttpSecurity http) throws Exception {
  ApplicationContext context=http.getSharedObject(ApplicationContext.class);
  context.getAutowireCapableBeanFactory().autowireBean(this);
  if (stormpathEnabled && (stormpathSpringSecurityAutoload || manuallyConfigured)) {
    stormpathSecurityConfigurerAdapter.init(http);
  }
}",0.9292730844793712
99330,"/** 
 * Extend WebSecurityConfigurerAdapter and configure the   {@code HttpSecurity} object usingthe  {@link com.stormpath.spring.config.StormpathWebSecurityConfigurer#stormpath stormpath()} utility method.For example: <pre> import static com.stormpath.spring.config.StormpathWebSecurityConfigurer.stormpath;
 * @Configuration public class SecurityConfig extends WebSecurityConfigurerAdapter {
 * @Override public void configure(HttpSecurity http) throws Exception { http .apply(stormpath()) //other http config here } } </pre>
 * @return the StormpathWebSecurityConfigurer object
 */
public static AbstractHttpConfigurer<?,HttpSecurity> stormpath(){
  return new StormpathWebSecurityConfigurer();
}","/** 
 * Extend WebSecurityConfigurerAdapter and configure the   {@code HttpSecurity} object usingthe  {@link com.stormpath.spring.config.StormpathWebSecurityConfigurer#stormpath stormpath()} utility method.For example: <pre> import static com.stormpath.spring.config.StormpathWebSecurityConfigurer.stormpath;
 * @Configuration public class SecurityConfig extends WebSecurityConfigurerAdapter {
 * @Override public void configure(HttpSecurity http) throws Exception { http .apply(stormpath()) //other http config here } } </pre>
 * @return the StormpathWebSecurityConfigurer object
 */
public static AbstractHttpConfigurer<?,HttpSecurity> stormpath(){
  return new StormpathWebSecurityConfigurer(true);
}",0.9971469329529244
99331,"public AuthenticationProvider stormpathAuthenticationProvider(){
  StormpathAuthenticationProvider provider;
  if (oktaEnabled) {
    provider=new OktaAuthenticationProvider(application);
  }
 else {
    provider=new StormpathAuthenticationProvider(application);
  }
  provider.setGroupGrantedAuthorityResolver(stormpathGroupGrantedAuthorityResolver());
  provider.setGroupPermissionResolver(stormpathGroupPermissionResolver());
  provider.setAccountGrantedAuthorityResolver(stormpathAccountGrantedAuthorityResolver());
  provider.setAccountPermissionResolver(stormpathAccountPermissionResolver());
  provider.setAuthenticationTokenFactory(stormpathAuthenticationTokenFactory());
  return provider;
}","public AuthenticationProvider stormpathAuthenticationProvider(){
  StormpathAuthenticationProvider provider;
  if (oktaEnabled) {
    provider=new OktaAuthenticationProvider(application,client);
  }
 else {
    provider=new StormpathAuthenticationProvider(application);
  }
  provider.setGroupGrantedAuthorityResolver(stormpathGroupGrantedAuthorityResolver());
  provider.setGroupPermissionResolver(stormpathGroupPermissionResolver());
  provider.setAccountGrantedAuthorityResolver(stormpathAccountGrantedAuthorityResolver());
  provider.setAccountPermissionResolver(stormpathAccountPermissionResolver());
  provider.setAuthenticationTokenFactory(stormpathAuthenticationTokenFactory());
  return provider;
}",0.9950248756218906
99332,"public OktaAuthenticationProvider(Application application){
  super(application);
  this.application=application;
}","public OktaAuthenticationProvider(Application application,Client client){
  super(application);
  this.application=application;
  this.client=client;
}",0.8646616541353384
99333,"@Override public Authentication authenticate(Authentication authentication) throws AuthenticationException {
  Account account;
  Authentication returnToken=null;
  try {
    if (authentication instanceof ProviderAuthenticationToken) {
      returnToken=authentication;
    }
 else     if (authentication instanceof JwtProviderAuthenticationToken) {
      return authentication;
    }
 else {
      AuthenticationRequest request=createAuthenticationRequest(authentication);
      try {
        AccessTokenResult result=(AccessTokenResult)application.authenticateAccount(request);
        account=result.getAccount();
        User userDetails=new User(account.getHref(),""String_Node_Str"",getGrantedAuthorities(account));
        returnToken=new JwtProviderAuthenticationToken(userDetails,result.getTokenResponse().getAccessToken(),result.getTokenResponse().getRefreshToken(),result);
      }
  finally {
        request.clear();
      }
    }
  }
 catch (  ResourceException e) {
    String msg=Strings.clean(e.getMessage());
    if (msg == null) {
      msg=Strings.clean(e.getDeveloperMessage());
    }
    if (msg == null) {
      msg=""String_Node_Str"";
    }
    throw new AuthenticationServiceException(msg,e);
  }
  return returnToken;
}","@Override public Authentication authenticate(Authentication authentication) throws AuthenticationException {
  Account account;
  Authentication returnToken=null;
  try {
    if (authentication instanceof ProviderAuthenticationToken) {
      returnToken=authentication;
    }
 else     if (authentication instanceof JwtProviderAuthenticationToken) {
      OktaAuthNAuthenticator authNAuthenticator=client.instantiate(OktaAuthNAuthenticator.class);
      authNAuthenticator.assertValidAccessToken(((JwtProviderAuthenticationToken)authentication).getAccessToken());
      return authentication;
    }
 else {
      AuthenticationRequest request=createAuthenticationRequest(authentication);
      try {
        AccessTokenResult result=(AccessTokenResult)application.authenticateAccount(request);
        account=result.getAccount();
        User userDetails=new User(account.getHref(),""String_Node_Str"",getGrantedAuthorities(account));
        returnToken=new JwtProviderAuthenticationToken(userDetails,result.getTokenResponse().getAccessToken(),result.getTokenResponse().getRefreshToken(),result);
      }
  finally {
        request.clear();
      }
    }
  }
 catch (  ResourceException e) {
    String msg=Strings.clean(e.getMessage());
    if (msg == null) {
      msg=Strings.clean(e.getDeveloperMessage());
    }
    if (msg == null) {
      msg=""String_Node_Str"";
    }
    throw new AuthenticationServiceException(msg,e);
  }
  return returnToken;
}",0.9206819866567828
99334,"@Override public AuthenticationResult authenticateAccount(AuthenticationRequest request) throws ResourceException {
  return new OktaAuthNAuthenticator(getDataStore()).authenticate((DefaultUsernamePasswordRequest)request);
}","@Override public AuthenticationResult authenticateAccount(AuthenticationRequest request) throws ResourceException {
  return new DefaultOktaAuthNAuthenticator(getDataStore()).authenticate((DefaultUsernamePasswordRequest)request);
}",0.9846153846153848
99335,"@Override public IdSiteAuthenticator forApplication(Application application){
  if (application instanceof OAuthApplication) {
    return ((OAuthApplication)application).createIdSiteAuthenticator();
  }
  try {
    Method dataStoreMethod=AbstractResource.class.getDeclaredMethod(""String_Node_Str"");
    dataStoreMethod.setAccessible(true);
    InternalDataStore internalDataStore=(InternalDataStore)dataStoreMethod.invoke(application);
    return new DefaultIdSiteAuthenticator(application,internalDataStore);
  }
 catch (  NoSuchMethodException e) {
    throw new UnsupportedOperationException(""String_Node_Str"",e);
  }
catch (  IllegalAccessException e) {
    throw new UnsupportedOperationException(""String_Node_Str"",e);
  }
catch (  InvocationTargetException e) {
    throw new UnsupportedOperationException(""String_Node_Str"",e);
  }
}","@Override public IdSiteAuthenticator forApplication(Application application){
  return ((OAuthApplication)application).createIdSiteAuthenticator();
}",0.3016194331983806
99336,"@Override protected void doConfigure(RegisterController controller,Config config){
  controller.setClient(config.getClient());
  controller.setAuthenticationResultSaver(config.getAuthenticationResultSaver());
  controller.setLoginUri(config.getLoginConfig().getUri());
  controller.setVerifyViewName(config.getVerifyConfig().getView());
  controller.setAutoLogin(config.isRegisterAutoLoginEnabled());
  controller.setPreRegisterHandler(config.getRegisterPreHandler());
  controller.setPostRegisterHandler(config.getRegisterPostHandler());
  controller.setAccountStoreResolver(config.getAccountStoreResolver());
}","@Override protected void doConfigure(RegisterController controller,Config config){
  controller.setClient(config.getClient());
  controller.setAuthenticationResultSaver(config.getAuthenticationResultSaver());
  controller.setLoginUri(config.getLoginConfig().getUri());
  controller.setVerifyViewName(config.getVerifyConfig().getView());
  controller.setAutoLogin(config.isRegisterAutoLoginEnabled());
  controller.setPreRegisterHandler(config.getRegisterPreHandler());
  controller.setPostRegisterHandler(config.getRegisterPostHandler());
  controller.setAccountStoreResolver(config.getAccountStoreResolver());
  controller.setApplicationResolver(config.getApplicationResolver());
}",0.945904173106646
99337,"public Controller stormpathRegisterController(){
  if (idSiteEnabled) {
    return createIdSiteController(idSiteRegisterUri);
  }
  RegisterController c=configure(new RegisterController(),stormpathRegisterConfig());
  c.setClient(client);
  c.setAuthenticationResultSaver(stormpathAuthenticationResultSaver());
  c.setLoginUri(stormpathLoginConfig().getUri());
  c.setVerifyViewName(stormpathVerifyConfig().getView());
  c.setAutoLogin(registerAutoLogin);
  c.setPreRegisterHandler(registerPreHandler);
  c.setPostRegisterHandler(registerPostHandler);
  c.setAccountStoreResolver(stormpathAccountStoreResolver());
  return init(c);
}","public Controller stormpathRegisterController(){
  if (idSiteEnabled) {
    return createIdSiteController(idSiteRegisterUri);
  }
  RegisterController c=configure(new RegisterController(),stormpathRegisterConfig());
  c.setClient(client);
  c.setAuthenticationResultSaver(stormpathAuthenticationResultSaver());
  c.setLoginUri(stormpathLoginConfig().getUri());
  c.setVerifyViewName(stormpathVerifyConfig().getView());
  c.setAutoLogin(registerAutoLogin);
  c.setPreRegisterHandler(registerPreHandler);
  c.setPostRegisterHandler(registerPostHandler);
  c.setAccountStoreResolver(stormpathAccountStoreResolver());
  c.setApplicationResolver(stormpathApplicationResolver());
  return init(c);
}",0.9547511312217196
99338,"@Override protected ViewModel onValidSubmit(HttpServletRequest req,HttpServletResponse resp,Form form) throws Exception {
  Account account=client.instantiate(Account.class);
  String value=form.getFieldValue(""String_Node_Str"");
  if (value != null) {
    account.setEmail(value);
  }
  value=form.getFieldValue(""String_Node_Str"");
  if (value != null) {
    account.setUsername(value);
  }
  value=form.getFieldValue(""String_Node_Str"");
  if (value != null) {
    account.setPassword(value);
  }
  value=form.getFieldValue(""String_Node_Str"");
  account.setGivenName(value != null ? value : ""String_Node_Str"");
  value=form.getFieldValue(""String_Node_Str"");
  if (value != null) {
    account.setMiddleName(value);
  }
  value=form.getFieldValue(""String_Node_Str"");
  account.setSurname(value != null ? value : ""String_Node_Str"");
  account.getCustomData().putAll(getCustomData(req,form));
  Application app=ApplicationResolver.INSTANCE.getApplication(req);
  if (preRegisterHandler != null) {
    if (!preRegisterHandler.handle(req,resp,account)) {
      return null;
    }
  }
  AccountStore accountStore=accountStoreResolver.getAccountStore(req,resp);
  if (accountStore == null) {
    account=app.createAccount(account);
  }
 else {
    final Account[] accountHolder=new Account[]{account};
    accountStore.accept(new AccountStoreVisitorAdapter(){
      @Override public void visit(      Directory directory){
        Account createdAccount=directory.createAccount(accountHolder[0]);
        accountHolder[0]=createdAccount;
      }
      @Override public void visit(      Organization organization){
        Account createdAccount=organization.createAccount(accountHolder[0]);
        accountHolder[0]=createdAccount;
      }
    }
);
    account=accountHolder[0];
  }
  publishRequestEvent(new DefaultRegisteredAccountRequestEvent(req,resp,account));
  if (postRegisterHandler != null) {
    if (!postRegisterHandler.handle(req,resp,account)) {
      return null;
    }
  }
  AccountStatus status=account.getStatus();
  if (isJsonPreferred(req,resp)) {
    return new DefaultViewModel(STORMPATH_JSON_VIEW_NAME,java.util.Collections.singletonMap(""String_Node_Str"",accountModelFactory.toMap(account,Collections.EMPTY_LIST)));
  }
  if (status == AccountStatus.ENABLED) {
    if (autoLogin) {
      final AuthenticationResult result=new TransientAuthenticationResult(account);
      this.authenticationResultSaver.set(req,resp,result);
    }
 else {
      return new DefaultViewModel(loginUri + ""String_Node_Str"").setRedirect(true);
    }
  }
 else   if (status == AccountStatus.UNVERIFIED) {
    return new DefaultViewModel(loginUri + ""String_Node_Str"").setRedirect(true);
  }
  return new DefaultViewModel(nextUri).setRedirect(true);
}","@Override protected ViewModel onValidSubmit(HttpServletRequest req,HttpServletResponse resp,Form form) throws Exception {
  Account account=client.instantiate(Account.class);
  String value=form.getFieldValue(""String_Node_Str"");
  if (value != null) {
    account.setEmail(value);
  }
  value=form.getFieldValue(""String_Node_Str"");
  if (value != null) {
    account.setUsername(value);
  }
  value=form.getFieldValue(""String_Node_Str"");
  if (value != null) {
    account.setPassword(value);
  }
  value=form.getFieldValue(""String_Node_Str"");
  account.setGivenName(value != null ? value : ""String_Node_Str"");
  value=form.getFieldValue(""String_Node_Str"");
  if (value != null) {
    account.setMiddleName(value);
  }
  value=form.getFieldValue(""String_Node_Str"");
  account.setSurname(value != null ? value : ""String_Node_Str"");
  account.getCustomData().putAll(getCustomData(req,form));
  Application app=ApplicationResolver.INSTANCE.getApplication(req);
  if (preRegisterHandler != null) {
    if (!preRegisterHandler.handle(req,resp,account)) {
      return null;
    }
  }
  AccountStore accountStore=accountStoreResolver.getAccountStore(req,resp);
  if (accountStore == null) {
    account=app.createAccount(account);
  }
 else {
    final Account[] accountHolder=new Account[]{account};
    accountStore.accept(new AccountStoreVisitorAdapter(){
      @Override public void visit(      Directory directory){
        Account createdAccount=directory.createAccount(accountHolder[0]);
        accountHolder[0]=createdAccount;
      }
      @Override public void visit(      Organization organization){
        Account createdAccount=organization.createAccount(accountHolder[0]);
        accountHolder[0]=createdAccount;
      }
    }
);
    account=accountHolder[0];
  }
  publishRequestEvent(new DefaultRegisteredAccountRequestEvent(req,resp,account));
  if (postRegisterHandler != null) {
    if (!postRegisterHandler.handle(req,resp,account)) {
      return null;
    }
  }
  AccountStatus status=account.getStatus();
  if (isJsonPreferred(req,resp)) {
    return new DefaultViewModel(STORMPATH_JSON_VIEW_NAME,java.util.Collections.singletonMap(""String_Node_Str"",accountModelFactory.toMap(account,Collections.EMPTY_LIST)));
  }
  if (status == AccountStatus.ENABLED) {
    if (autoLogin) {
      final AuthenticationResult result=new TransientAuthenticationResult(account);
      this.authenticationResultSaver.set(req,resp,result);
    }
 else {
      return new DefaultViewModel(loginUri + ""String_Node_Str"").setRedirect(true);
    }
  }
 else   if (status == AccountStatus.UNVERIFIED) {
    invalidateAccountCache(account);
    return new DefaultViewModel(loginUri + ""String_Node_Str"").setRedirect(true);
  }
  return new DefaultViewModel(nextUri).setRedirect(true);
}",0.9932958869360392
99339,"@Override protected ViewModel onValidSubmit(HttpServletRequest req,HttpServletResponse resp,Form form) throws Exception {
  Account account=client.instantiate(Account.class);
  String value=form.getFieldValue(""String_Node_Str"");
  if (value != null) {
    account.setEmail(value);
  }
  value=form.getFieldValue(""String_Node_Str"");
  if (value != null) {
    account.setUsername(value);
  }
  value=form.getFieldValue(""String_Node_Str"");
  if (value != null) {
    account.setPassword(value);
  }
  value=form.getFieldValue(""String_Node_Str"");
  account.setGivenName(value != null ? value : ""String_Node_Str"");
  value=form.getFieldValue(""String_Node_Str"");
  if (value != null) {
    account.setMiddleName(value);
  }
  value=form.getFieldValue(""String_Node_Str"");
  account.setSurname(value != null ? value : ""String_Node_Str"");
  account.getCustomData().putAll(getCustomData(req,form));
  Application app=ApplicationResolver.INSTANCE.getApplication(req);
  if (preRegisterHandler != null) {
    if (!preRegisterHandler.handle(req,resp,account)) {
      return null;
    }
  }
  AccountStore accountStore=accountStoreResolver.getAccountStore(req,resp);
  if (accountStore == null) {
    account=app.createAccount(account);
  }
 else {
    final Account[] accountHolder=new Account[]{account};
    accountStore.accept(new AccountStoreVisitorAdapter(){
      @Override public void visit(      Directory directory){
        Account createdAccount=directory.createAccount(accountHolder[0]);
        accountHolder[0]=createdAccount;
      }
      @Override public void visit(      Organization organization){
        Account createdAccount=organization.createAccount(accountHolder[0]);
        accountHolder[0]=createdAccount;
      }
    }
);
    account=accountHolder[0];
  }
  publishRequestEvent(new DefaultRegisteredAccountRequestEvent(req,resp,account));
  if (postRegisterHandler != null) {
    if (!postRegisterHandler.handle(req,resp,account)) {
      return null;
    }
  }
  AccountStatus status=account.getStatus();
  if (isJsonPreferred(req,resp)) {
    return new DefaultViewModel(STORMPATH_JSON_VIEW_NAME,java.util.Collections.singletonMap(""String_Node_Str"",accountModelFactory.toMap(account,Collections.EMPTY_LIST)));
  }
  if (status == AccountStatus.ENABLED) {
    if (autoLogin) {
      final AuthenticationResult result=new TransientAuthenticationResult(account);
      this.authenticationResultSaver.set(req,resp,result);
    }
 else {
      return new DefaultViewModel(loginUri + ""String_Node_Str"").setRedirect(true);
    }
  }
 else   if (status == AccountStatus.UNVERIFIED) {
    return new DefaultViewModel(loginUri + ""String_Node_Str"").setRedirect(true);
  }
  return new DefaultViewModel(nextUri).setRedirect(true);
}","@Override protected ViewModel onValidSubmit(HttpServletRequest req,HttpServletResponse resp,Form form) throws Exception {
  Account account=client.instantiate(Account.class);
  String value=form.getFieldValue(""String_Node_Str"");
  if (value != null) {
    account.setEmail(value);
  }
  value=form.getFieldValue(""String_Node_Str"");
  if (value != null) {
    account.setUsername(value);
  }
  value=form.getFieldValue(""String_Node_Str"");
  if (value != null) {
    account.setPassword(value);
  }
  value=form.getFieldValue(""String_Node_Str"");
  account.setGivenName(value != null ? value : ""String_Node_Str"");
  value=form.getFieldValue(""String_Node_Str"");
  if (value != null) {
    account.setMiddleName(value);
  }
  value=form.getFieldValue(""String_Node_Str"");
  account.setSurname(value != null ? value : ""String_Node_Str"");
  account.getCustomData().putAll(getCustomData(req,form));
  Application app=ApplicationResolver.INSTANCE.getApplication(req);
  if (preRegisterHandler != null) {
    if (!preRegisterHandler.handle(req,resp,account)) {
      return null;
    }
  }
  AccountStore accountStore=accountStoreResolver.getAccountStore(req,resp);
  if (accountStore == null) {
    account=app.createAccount(account);
  }
 else {
    final Account[] accountHolder=new Account[]{account};
    accountStore.accept(new AccountStoreVisitorAdapter(){
      @Override public void visit(      Directory directory){
        Account createdAccount=directory.createAccount(accountHolder[0]);
        accountHolder[0]=createdAccount;
      }
      @Override public void visit(      Organization organization){
        Account createdAccount=organization.createAccount(accountHolder[0]);
        accountHolder[0]=createdAccount;
      }
    }
);
    account=accountHolder[0];
  }
  publishRequestEvent(new DefaultRegisteredAccountRequestEvent(req,resp,account));
  if (postRegisterHandler != null) {
    if (!postRegisterHandler.handle(req,resp,account)) {
      return null;
    }
  }
  AccountStatus status=account.getStatus();
  if (isJsonPreferred(req,resp)) {
    return new DefaultViewModel(STORMPATH_JSON_VIEW_NAME,java.util.Collections.singletonMap(""String_Node_Str"",accountModelFactory.toMap(account,Collections.EMPTY_LIST)));
  }
  if (status == AccountStatus.ENABLED) {
    if (autoLogin) {
      final AuthenticationResult result=new TransientAuthenticationResult(account);
      this.authenticationResultSaver.set(req,resp,result);
    }
 else {
      return new DefaultViewModel(loginUri + ""String_Node_Str"").setRedirect(true);
    }
  }
 else   if (status == AccountStatus.UNVERIFIED) {
    invalidateAccountCache(account);
    return new DefaultViewModel(loginUri + ""String_Node_Str"").setRedirect(true);
  }
  return new DefaultViewModel(nextUri).setRedirect(true);
}",0.9932958869360392
99340,"@Override protected ProviderAccountRequest getAccountProviderRequest(HttpServletRequest request){
  String providerId=ServletUtils.getCleanParam(request,""String_Node_Str"");
  String code=ServletUtils.getCleanParam(request,""String_Node_Str"");
  if (StringUtils.hasText(code)) {
    return Providers.OAUTH2.account().setProviderId(providerId).setCode(code).build();
  }
 else {
    String accessToken=ServletUtils.getCleanParam(request,""String_Node_Str"");
    return Providers.OAUTH2.account().setProviderId(providerId).setAccessToken(accessToken).build();
  }
}","@Override public ProviderAccountRequest getAccountProviderRequest(HttpServletRequest request){
  String providerId=ServletUtils.getCleanParam(request,""String_Node_Str"");
  String code=ServletUtils.getCleanParam(request,""String_Node_Str"");
  if (StringUtils.hasText(code)) {
    return Providers.OAUTH2.account().setProviderId(providerId).setCode(code).build();
  }
 else {
    String accessToken=ServletUtils.getCleanParam(request,""String_Node_Str"");
    return Providers.OAUTH2.account().setProviderId(providerId).setAccessToken(accessToken).build();
  }
}",0.9883616830796778
99341,"@SuppressWarnings(""String_Node_Str"") protected String getAuthorizeBaseUri(@SuppressWarnings(""String_Node_Str"") HttpServletRequest request,ApplicationWebConfig webConfig){
  String authorizeBaseUri=null;
  if (webConfig.getLogin().isEnabled()) {
    authorizeBaseUri=""String_Node_Str"" + webConfig.getDomainName();
  }
  return authorizeBaseUri;
}","@SuppressWarnings(""String_Node_Str"") protected String getAuthorizeBaseUri(@SuppressWarnings(""String_Node_Str"") HttpServletRequest request,ApplicationWebConfig webConfig){
  String authorizeBaseUri=null;
  if (webConfig.getStatus() == ApplicationWebConfigStatus.ENABLED && webConfig.getLogin().isEnabled()) {
    authorizeBaseUri=""String_Node_Str"" + webConfig.getDomainName();
  }
  return authorizeBaseUri;
}",0.900398406374502
99342,"@Override public RequestPostProcessor beforeMockMvcCreated(ConfigurableMockMvcBuilder<?> builder,WebApplicationContext context){
  String stormpathFilterBeanId=""String_Node_Str"";
  String springSecurityFilterBeanId=BeanIds.SPRING_SECURITY_FILTER_CHAIN;
  if (this.springSecurityFilter == null && context.containsBean(springSecurityFilterBeanId)) {
    this.springSecurityFilter=context.getBean(springSecurityFilterBeanId,Filter.class);
  }
  if (this.stormpathFilter == null && context.containsBean(stormpathFilterBeanId)) {
    this.stormpathFilter=context.getBean(stormpathFilterBeanId,Filter.class);
  }
  if (this.springSecurityFilter == null) {
    throw new IllegalStateException(""String_Node_Str"" + springSecurityFilterBeanId + ""String_Node_Str"");
  }
  if (this.stormpathFilter == null) {
    throw new IllegalStateException(""String_Node_Str"" + stormpathFilterBeanId + ""String_Node_Str"");
  }
  builder.addFilters(this.stormpathFilter);
  builder.addFilters(this.springSecurityFilter);
  context.getServletContext().setAttribute(StormpathFilter.class.getName(),this.stormpathFilter.getClass().getName());
  context.getServletContext().setAttribute(BeanIds.SPRING_SECURITY_FILTER_CHAIN,this.springSecurityFilter);
  return testSecurityContext();
}","@Override public RequestPostProcessor beforeMockMvcCreated(ConfigurableMockMvcBuilder<?> builder,WebApplicationContext context){
  String stormpathFilterBeanId=""String_Node_Str"";
  String springSecurityFilterBeanId=BeanIds.SPRING_SECURITY_FILTER_CHAIN;
  if (this.springSecurityFilter == null && context.containsBean(springSecurityFilterBeanId)) {
    this.springSecurityFilter=context.getBean(springSecurityFilterBeanId,Filter.class);
  }
  if (this.stormpathFilter == null && context.containsBean(stormpathFilterBeanId)) {
    this.stormpathFilter=context.getBean(stormpathFilterBeanId,Filter.class);
  }
  if (this.springSecurityFilter == null) {
    throw new IllegalStateException(""String_Node_Str"" + springSecurityFilterBeanId + ""String_Node_Str"");
  }
  if (this.stormpathFilter == null) {
    throw new IllegalStateException(""String_Node_Str"" + stormpathFilterBeanId + ""String_Node_Str"");
  }
  builder.addFilters(this.springSecurityFilter);
  builder.addFilters(this.stormpathFilter);
  context.getServletContext().setAttribute(StormpathFilter.class.getName(),this.stormpathFilter.getClass().getName());
  context.getServletContext().setAttribute(BeanIds.SPRING_SECURITY_FILTER_CHAIN,this.springSecurityFilter);
  return testSecurityContext();
}",0.9609250398724084
99343,"@Override protected void configure(AccessTokenController controller,Config config) throws Exception {
  AccessTokenAuthenticationRequestFactory accessTokenAuthenticationRequestFactory=config.getInstance(ACCESS_TOKEN_AUTHENTICATION_REQUEST_FACTORY);
  RefreshTokenAuthenticationRequestFactory refreshTokenAuthenticationRequestFactory=config.getInstance(REFRESH_TOKEN_AUTHENTICATION_REQUEST_FACTORY);
  RequestAuthorizer requestAuthorizer=config.getInstance(REQUEST_AUTHORIZER);
  AccessTokenResultFactory accessTokenResultFactory=config.getInstance(ACCESS_TOKEN_RESULT_FACTORY);
  RefreshTokenResultFactory refreshTokenResultFactory=config.getInstance(REFRESH_TOKEN_RESULT_FACTORY);
  Saver<AuthenticationResult> accountSaver=config.getInstance(ACCOUNT_SAVER);
  Publisher<RequestEvent> eventPublisher=config.getInstance(EVENT_PUBLISHER);
  BasicAuthenticationScheme basicAuthenticationScheme=config.getInstance(BASIC_AUTHENTICATION_REQUEST_FACTORY);
  GrantTypeValidator grantTypeValidator=config.getGrantTypeStatusValidator();
  controller.setEventPublisher(eventPublisher);
  controller.setAccessTokenAuthenticationRequestFactory(accessTokenAuthenticationRequestFactory);
  controller.setAccessTokenResultFactory(accessTokenResultFactory);
  controller.setRefreshTokenAuthenticationRequestFactory(refreshTokenAuthenticationRequestFactory);
  controller.setRefreshTokenResultFactory(refreshTokenResultFactory);
  controller.setAccountSaver(accountSaver);
  controller.setRequestAuthorizer(requestAuthorizer);
  controller.setBasicAuthenticationScheme(basicAuthenticationScheme);
  controller.setGrantTypeStatusValidator(grantTypeStatusValidator);
}","@Override protected void configure(AccessTokenController controller,Config config) throws Exception {
  AccessTokenAuthenticationRequestFactory accessTokenAuthenticationRequestFactory=config.getInstance(ACCESS_TOKEN_AUTHENTICATION_REQUEST_FACTORY);
  RefreshTokenAuthenticationRequestFactory refreshTokenAuthenticationRequestFactory=config.getInstance(REFRESH_TOKEN_AUTHENTICATION_REQUEST_FACTORY);
  RequestAuthorizer requestAuthorizer=config.getInstance(REQUEST_AUTHORIZER);
  AccessTokenResultFactory accessTokenResultFactory=config.getInstance(ACCESS_TOKEN_RESULT_FACTORY);
  RefreshTokenResultFactory refreshTokenResultFactory=config.getInstance(REFRESH_TOKEN_RESULT_FACTORY);
  Saver<AuthenticationResult> accountSaver=config.getInstance(ACCOUNT_SAVER);
  Publisher<RequestEvent> eventPublisher=config.getInstance(EVENT_PUBLISHER);
  BasicAuthenticationScheme basicAuthenticationScheme=config.getInstance(BASIC_AUTHENTICATION_REQUEST_FACTORY);
  GrantTypeValidator grantTypeValidator=config.getGrantTypeStatusValidator();
  controller.setEventPublisher(eventPublisher);
  controller.setAccessTokenAuthenticationRequestFactory(accessTokenAuthenticationRequestFactory);
  controller.setAccessTokenResultFactory(accessTokenResultFactory);
  controller.setRefreshTokenAuthenticationRequestFactory(refreshTokenAuthenticationRequestFactory);
  controller.setRefreshTokenResultFactory(refreshTokenResultFactory);
  controller.setAccountSaver(accountSaver);
  controller.setRequestAuthorizer(requestAuthorizer);
  controller.setBasicAuthenticationScheme(basicAuthenticationScheme);
  controller.setGrantTypeValidator(grantTypeValidator);
}",0.9963481436396836
99344,"/** 
 * @since 1.0.RC8.3
 */
private AccessTokenResult tokenAuthenticationRequest(HttpServletRequest request,HttpServletResponse response) throws Exception {
  OAuthGrantRequestAuthenticationResult authenticationResult;
  try {
    Application app=getApplication(request);
    OAuthPasswordGrantRequestAuthentication passwordGrantRequest=createPasswordGrantAuthenticationRequest(request);
    authenticationResult=Authenticators.OAUTH_PASSWORD_GRANT_REQUEST_AUTHENTICATOR.forApplication(app).authenticate(passwordGrantRequest);
  }
 catch (  ResourceException e) {
    log.debug(""String_Node_Str"",e.getMessage(),e);
    throw new OAuthException(OAuthErrorCode.INVALID_REQUEST,""String_Node_Str"",e);
  }
  return createAccessTokenResult(request,response,authenticationResult);
}","/** 
 * @since 1.0.RC8.3
 */
private AccessTokenResult tokenAuthenticationRequest(HttpServletRequest request,HttpServletResponse response) throws Exception {
  OAuthGrantRequestAuthenticationResult authenticationResult;
  try {
    Application app=getApplication(request);
    OAuthPasswordGrantRequestAuthentication passwordGrantRequest=createPasswordGrantAuthenticationRequest(request);
    authenticationResult=Authenticators.OAUTH_PASSWORD_GRANT_REQUEST_AUTHENTICATOR.forApplication(app).authenticate(passwordGrantRequest);
  }
 catch (  ResourceException e) {
    log.debug(""String_Node_Str"",e.getMessage(),e);
    throw convertToOAuthException(e,OAuthErrorCode.INVALID_REQUEST);
  }
  return createAccessTokenResult(request,response,authenticationResult);
}",0.8797920727745289
99345,"/** 
 * @since 1.1.0
 */
private AccessTokenResult stormpathSocialAuthenticationRequest(HttpServletRequest request,HttpServletResponse response){
  OAuthGrantRequestAuthenticationResult authenticationResult;
  try {
    Application app=getApplication(request);
    String providerId=request.getParameter(""String_Node_Str"");
    String accessToken=request.getParameter(""String_Node_Str"");
    String code=request.getParameter(""String_Node_Str"");
    OAuthStormpathSocialGrantRequestAuthentication grantRequestAuthentication=new DefaultOAuthStormpathSocialGrantRequestAuthentication(providerId,accessToken,code);
    authenticationResult=Authenticators.OAUTH_STORMPATH_SOCIAL_GRANT_REQUEST_AUTHENTICATOR.forApplication(app).authenticate(grantRequestAuthentication);
  }
 catch (  ResourceException e) {
    log.debug(""String_Node_Str"",e.getMessage(),e);
    throw new OAuthException(OAuthErrorCode.INVALID_CLIENT,""String_Node_Str"");
  }
  return createAccessTokenResult(request,response,authenticationResult);
}","/** 
 * @since 1.1.0
 */
private AccessTokenResult stormpathSocialAuthenticationRequest(HttpServletRequest request,HttpServletResponse response){
  OAuthGrantRequestAuthenticationResult authenticationResult;
  try {
    Application app=getApplication(request);
    String providerId=request.getParameter(""String_Node_Str"");
    String accessToken=request.getParameter(""String_Node_Str"");
    String code=request.getParameter(""String_Node_Str"");
    OAuthStormpathSocialGrantRequestAuthentication grantRequestAuthentication=new DefaultOAuthStormpathSocialGrantRequestAuthentication(providerId,accessToken,code);
    authenticationResult=Authenticators.OAUTH_STORMPATH_SOCIAL_GRANT_REQUEST_AUTHENTICATOR.forApplication(app).authenticate(grantRequestAuthentication);
  }
 catch (  ResourceException e) {
    log.debug(""String_Node_Str"",e.getMessage(),e);
    throw convertToOAuthException(e,OAuthErrorCode.INVALID_CLIENT);
  }
  return createAccessTokenResult(request,response,authenticationResult);
}",0.9078226208271052
99346,"/** 
 * @since 1.0.RC8.3
 */
private AccessTokenResult refreshTokenAuthenticationRequest(HttpServletRequest request,HttpServletResponse response) throws Exception {
  OAuthGrantRequestAuthenticationResult authenticationResult;
  try {
    Application app=getApplication(request);
    OAuthRefreshTokenRequestAuthentication refreshGrantRequest=createRefreshTokenAuthenticationRequest(request);
    authenticationResult=Authenticators.OAUTH_REFRESH_TOKEN_REQUEST_AUTHENTICATOR.forApplication(app).authenticate(refreshGrantRequest);
  }
 catch (  ResourceException e) {
    log.debug(""String_Node_Str"",e.getMessage(),e);
    throw new OAuthException(OAuthErrorCode.INVALID_GRANT,""String_Node_Str"");
  }
  return createRefreshTokenResult(request,response,authenticationResult);
}","/** 
 * @since 1.0.RC8.3
 */
private AccessTokenResult refreshTokenAuthenticationRequest(HttpServletRequest request,HttpServletResponse response) throws Exception {
  OAuthGrantRequestAuthenticationResult authenticationResult;
  try {
    Application app=getApplication(request);
    OAuthRefreshTokenRequestAuthentication refreshGrantRequest=createRefreshTokenAuthenticationRequest(request);
    authenticationResult=Authenticators.OAUTH_REFRESH_TOKEN_REQUEST_AUTHENTICATOR.forApplication(app).authenticate(refreshGrantRequest);
  }
 catch (  ResourceException e) {
    log.debug(""String_Node_Str"",e.getMessage(),e);
    throw convertToOAuthException(e,OAuthErrorCode.INVALID_GRANT);
  }
  return createRefreshTokenResult(request,response,authenticationResult);
}",0.8784925276153346
99347,"@Override protected ViewModel doPost(HttpServletRequest request,HttpServletResponse response) throws Exception {
  String json;
  AuthenticationRequest authcRequest=null;
  AccessTokenResult result=null;
  try {
    assertAuthorized(request,response);
    String grantType=null;
    try {
      grantType=request.getParameter(GRANT_TYPE_PARAM_NAME);
      Assert.hasText(grantType,""String_Node_Str"");
    }
 catch (    IllegalArgumentException e) {
      throw new OAuthException(OAuthErrorCode.INVALID_GRANT);
    }
    grantTypeValidator.validate(grantType);
switch (grantType) {
case PASSWORD_GRANT_TYPE:
      result=this.tokenAuthenticationRequest(request,response);
    break;
case REFRESH_TOKEN_GRANT_TYPE:
  result=this.refreshTokenAuthenticationRequest(request,response);
break;
case CLIENT_CREDENTIALS_GRANT_TYPE:
try {
result=this.clientCredentialsAuthenticationRequest(request,response);
}
 catch (HttpAuthenticationException e) {
log.warn(""String_Node_Str"",e);
throw new OAuthException(OAuthErrorCode.INVALID_CLIENT);
}
break;
case STORMPATH_SOCIAL_GRANT_TYPE:
try {
result=this.stormpathSocialAuthenticationRequest(request,response);
}
 catch (HttpAuthenticationException e) {
log.warn(""String_Node_Str"",e);
throw new OAuthException(OAuthErrorCode.INVALID_CLIENT);
}
break;
default :
throw new OAuthException(OAuthErrorCode.UNSUPPORTED_GRANT_TYPE,""String_Node_Str"" + grantType + ""String_Node_Str"");
}
saveResult(request,response,result);
json=result.getTokenResponse().toJson();
response.setStatus(HttpServletResponse.SC_OK);
SuccessfulAuthenticationRequestEvent e=createSuccessEvent(request,response,authcRequest,result);
publish(e);
}
 catch (OAuthException e) {
log.debug(""String_Node_Str"",e.getMessage());
json=e.toJson();
response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
if (e.getErrorCode().equals(OAuthErrorCode.INVALID_CLIENT)) {
response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
}
try {
FailedAuthenticationRequestEvent evt=new DefaultFailedAuthenticationRequestEvent(request,response,authcRequest,e);
publish(evt);
}
 catch (Throwable t) {
log.warn(""String_Node_Str"",t,e,t);
}
}
response.setContentType(MediaType.APPLICATION_JSON_VALUE);
response.setHeader(""String_Node_Str"",""String_Node_Str"");
response.setHeader(""String_Node_Str"",""String_Node_Str"");
response.setHeader(""String_Node_Str"",String.valueOf(json.length()));
response.getWriter().print(json);
response.getWriter().flush();
return null;
}","@Override protected ViewModel doPost(HttpServletRequest request,HttpServletResponse response) throws Exception {
  String json;
  AuthenticationRequest authcRequest=null;
  AccessTokenResult result;
  try {
    assertAuthorized(request,response);
    String grantType;
    try {
      grantType=request.getParameter(GRANT_TYPE_PARAM_NAME);
      Assert.hasText(grantType,""String_Node_Str"");
    }
 catch (    IllegalArgumentException e) {
      throw new OAuthException(OAuthErrorCode.INVALID_GRANT);
    }
    grantTypeValidator.validate(grantType);
switch (grantType) {
case PASSWORD_GRANT_TYPE:
      result=this.tokenAuthenticationRequest(request,response);
    break;
case REFRESH_TOKEN_GRANT_TYPE:
  result=this.refreshTokenAuthenticationRequest(request,response);
break;
case CLIENT_CREDENTIALS_GRANT_TYPE:
try {
result=this.clientCredentialsAuthenticationRequest(request,response);
}
 catch (HttpAuthenticationException e) {
log.warn(""String_Node_Str"",e);
throw new OAuthException(OAuthErrorCode.INVALID_CLIENT);
}
break;
case STORMPATH_SOCIAL_GRANT_TYPE:
try {
result=this.stormpathSocialAuthenticationRequest(request,response);
}
 catch (HttpAuthenticationException e) {
log.warn(""String_Node_Str"",e);
throw new OAuthException(OAuthErrorCode.INVALID_CLIENT);
}
break;
default :
throw new OAuthException(OAuthErrorCode.UNSUPPORTED_GRANT_TYPE,""String_Node_Str"" + grantType + ""String_Node_Str"");
}
saveResult(request,response,result);
json=result.getTokenResponse().toJson();
response.setStatus(HttpServletResponse.SC_OK);
SuccessfulAuthenticationRequestEvent e=createSuccessEvent(request,response,authcRequest,result);
publish(e);
}
 catch (OAuthException e) {
log.debug(""String_Node_Str"",e.getMessage());
json=e.toJson();
response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
if (e.getErrorCode().equals(OAuthErrorCode.INVALID_CLIENT)) {
response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
}
try {
FailedAuthenticationRequestEvent evt=new DefaultFailedAuthenticationRequestEvent(request,response,authcRequest,e);
publish(evt);
}
 catch (Throwable t) {
log.warn(""String_Node_Str"",t,e,t);
}
}
response.setContentType(MediaType.APPLICATION_JSON_VALUE);
response.setHeader(""String_Node_Str"",""String_Node_Str"");
response.setHeader(""String_Node_Str"",""String_Node_Str"");
response.setHeader(""String_Node_Str"",String.valueOf(json.length()));
response.getWriter().print(json);
response.getWriter().flush();
return null;
}",0.9979440789473684
99348,"/** 
 * @since 1.0.0
 */
private AccessTokenResult clientCredentialsAuthenticationRequest(HttpServletRequest request,HttpServletResponse response){
  DefaultBasicApiAuthenticationRequest authenticationRequest=new DefaultBasicApiAuthenticationRequest(new DefaultHttpServletRequestWrapper(request));
  OAuthGrantRequestAuthenticationResult authenticationResult;
  try {
    Application app=getApplication(request);
    OAuthClientCredentialsGrantRequestAuthentication clientCredentialsGrantRequestAuthentication=OAuthRequests.OAUTH_CLIENT_CREDENTIALS_GRANT_REQUEST.builder().setApiKeyId(authenticationRequest.getPrincipals()).setApiKeySecret(authenticationRequest.getCredentials()).build();
    authenticationResult=Authenticators.OAUTH_CLIENT_CREDENTIALS_GRANT_REQUEST_AUTHENTICATOR.forApplication(app).authenticate(clientCredentialsGrantRequestAuthentication);
  }
 catch (  ResourceException e) {
    log.debug(""String_Node_Str"",e.getMessage(),e);
    throw new OAuthException(OAuthErrorCode.INVALID_CLIENT,""String_Node_Str"");
  }
  return createAccessTokenResult(request,response,authenticationResult);
}","/** 
 * @since 1.0.0
 */
private AccessTokenResult clientCredentialsAuthenticationRequest(HttpServletRequest request,HttpServletResponse response){
  DefaultBasicApiAuthenticationRequest authenticationRequest=new DefaultBasicApiAuthenticationRequest(new DefaultHttpServletRequestWrapper(request));
  OAuthGrantRequestAuthenticationResult authenticationResult;
  try {
    Application app=getApplication(request);
    OAuthClientCredentialsGrantRequestAuthentication clientCredentialsGrantRequestAuthentication=OAuthRequests.OAUTH_CLIENT_CREDENTIALS_GRANT_REQUEST.builder().setApiKeyId(authenticationRequest.getPrincipals()).setApiKeySecret(authenticationRequest.getCredentials()).build();
    authenticationResult=Authenticators.OAUTH_CLIENT_CREDENTIALS_GRANT_REQUEST_AUTHENTICATOR.forApplication(app).authenticate(clientCredentialsGrantRequestAuthentication);
  }
 catch (  ResourceException e) {
    log.debug(""String_Node_Str"",e.getMessage(),e);
    throw convertToOAuthException(e,OAuthErrorCode.INVALID_CLIENT);
  }
  return createAccessTokenResult(request,response,authenticationResult);
}",0.9159472966833258
99349,"/** 
 * @since 1.0.0
 */
private AccessTokenResult clientCredentialsAuthenticationRequest(HttpServletRequest request,HttpServletResponse response){
  DefaultBasicApiAuthenticationRequest authenticationRequest=new DefaultBasicApiAuthenticationRequest(new DefaultHttpServletRequestWrapper(request));
  OAuthGrantRequestAuthenticationResult authenticationResult;
  try {
    Application app=getApplication(request);
    OAuthClientCredentialsGrantRequestAuthentication clientCredentialsGrantRequestAuthentication=OAuthRequests.OAUTH_CLIENT_CREDENTIALS_GRANT_REQUEST.builder().setApiKeyId(authenticationRequest.getPrincipals()).setApiKeySecret(authenticationRequest.getCredentials()).build();
    authenticationResult=Authenticators.OAUTH_CLIENT_CREDENTIALS_GRANT_REQUEST_AUTHENTICATOR.forApplication(app).authenticate(clientCredentialsGrantRequestAuthentication);
  }
 catch (  ResourceException e) {
    log.debug(""String_Node_Str"",e.getMessage(),e);
    throw new OAuthException(OAuthErrorCode.INVALID_GRANT,""String_Node_Str"");
  }
  return createAccessTokenResult(request,response,authenticationResult);
}","/** 
 * @since 1.0.0
 */
private AccessTokenResult clientCredentialsAuthenticationRequest(HttpServletRequest request,HttpServletResponse response){
  DefaultBasicApiAuthenticationRequest authenticationRequest=new DefaultBasicApiAuthenticationRequest(new DefaultHttpServletRequestWrapper(request));
  OAuthGrantRequestAuthenticationResult authenticationResult;
  try {
    Application app=getApplication(request);
    OAuthClientCredentialsGrantRequestAuthentication clientCredentialsGrantRequestAuthentication=OAuthRequests.OAUTH_CLIENT_CREDENTIALS_GRANT_REQUEST.builder().setApiKeyId(authenticationRequest.getPrincipals()).setApiKeySecret(authenticationRequest.getCredentials()).build();
    authenticationResult=Authenticators.OAUTH_CLIENT_CREDENTIALS_GRANT_REQUEST_AUTHENTICATOR.forApplication(app).authenticate(clientCredentialsGrantRequestAuthentication);
  }
 catch (  ResourceException e) {
    log.debug(""String_Node_Str"",e.getMessage(),e);
    throw new OAuthException(OAuthErrorCode.INVALID_CLIENT,""String_Node_Str"");
  }
  return createAccessTokenResult(request,response,authenticationResult);
}",0.9968340117593848
99350,"/** 
 * @since 1.0.0
 */
private AccessTokenResult clientCredentialsAuthenticationRequest(HttpServletRequest request,HttpServletResponse response){
  DefaultBasicApiAuthenticationRequest authenticationRequest=new DefaultBasicApiAuthenticationRequest(new DefaultHttpServletRequestWrapper(request));
  OAuthGrantRequestAuthenticationResult authenticationResult;
  try {
    Application app=getApplication(request);
    OAuthClientCredentialsGrantRequestAuthentication clientCredentialsGrantRequestAuthentication=OAuthRequests.OAUTH_CLIENT_CREDENTIALS_GRANT_REQUEST.builder().setApiKeyId(authenticationRequest.getPrincipals()).setApiKeySecret(authenticationRequest.getCredentials()).build();
    authenticationResult=Authenticators.OAUTH_CLIENT_CREDENTIALS_GRANT_REQUEST_AUTHENTICATOR.forApplication(app).authenticate(clientCredentialsGrantRequestAuthentication);
  }
 catch (  ResourceException e) {
    log.debug(""String_Node_Str"",e.getMessage(),e);
    throw convertToOAuthException(e,OAuthErrorCode.INVALID_CLIENT);
  }
  return createAccessTokenResult(request,response,authenticationResult);
}","/** 
 * @since 1.0.0
 */
private AccessTokenResult clientCredentialsAuthenticationRequest(HttpServletRequest request,HttpServletResponse response){
  DefaultBasicApiAuthenticationRequest authenticationRequest=new DefaultBasicApiAuthenticationRequest(new DefaultHttpServletRequestWrapper(request));
  OAuthGrantRequestAuthenticationResult authenticationResult;
  try {
    Application app=getApplication(request);
    OAuthClientCredentialsGrantRequestAuthentication clientCredentialsGrantRequestAuthentication=OAuthRequests.OAUTH_CLIENT_CREDENTIALS_GRANT_REQUEST.builder().setApiKeyId(authenticationRequest.getPrincipals()).setApiKeySecret(authenticationRequest.getCredentials()).build();
    authenticationResult=Authenticators.OAUTH_CLIENT_CREDENTIALS_GRANT_REQUEST_AUTHENTICATOR.forApplication(app).authenticate(clientCredentialsGrantRequestAuthentication);
  }
 catch (  ResourceException e) {
    log.debug(""String_Node_Str"",e.getMessage(),e);
    throw new OAuthException(OAuthErrorCode.INVALID_GRANT,""String_Node_Str"");
  }
  return createAccessTokenResult(request,response,authenticationResult);
}",0.9818181818181818
99351,"@Override protected void configure(AccessTokenController c,Config config) throws Exception {
  AccessTokenAuthenticationRequestFactory accessTokenAuthenticationRequestFactory=config.getInstance(ACCESS_TOKEN_AUTHENTICATION_REQUEST_FACTORY);
  RefreshTokenAuthenticationRequestFactory refreshTokenAuthenticationRequestFactory=config.getInstance(REFRESH_TOKEN_AUTHENTICATION_REQUEST_FACTORY);
  RequestAuthorizer requestAuthorizer=config.getInstance(REQUEST_AUTHORIZER);
  AccessTokenResultFactory accessTokenResultFactory=config.getInstance(ACCESS_TOKEN_RESULT_FACTORY);
  RefreshTokenResultFactory refreshTokenResultFactory=config.getInstance(REFRESH_TOKEN_RESULT_FACTORY);
  Saver<AuthenticationResult> accountSaver=config.getInstance(ACCOUNT_SAVER);
  Publisher<RequestEvent> eventPublisher=config.getInstance(EVENT_PUBLISHER);
  BasicAuthenticationScheme basicAuthenticationScheme=config.getInstance(BASIC_AUTHENTICATION_REQUEST_FACTORY);
  c.setEventPublisher(eventPublisher);
  c.setAccessTokenAuthenticationRequestFactory(accessTokenAuthenticationRequestFactory);
  c.setAccessTokenResultFactory(accessTokenResultFactory);
  c.setRefreshTokenAuthenticationRequestFactory(refreshTokenAuthenticationRequestFactory);
  c.setRefreshTokenResultFactory(refreshTokenResultFactory);
  c.setAccountSaver(accountSaver);
  c.setRequestAuthorizer(requestAuthorizer);
  c.setBasicAuthenticationScheme(basicAuthenticationScheme);
}","@Override protected void configure(AccessTokenController c,Config config) throws Exception {
  AccessTokenAuthenticationRequestFactory accessTokenAuthenticationRequestFactory=config.getInstance(ACCESS_TOKEN_AUTHENTICATION_REQUEST_FACTORY);
  RefreshTokenAuthenticationRequestFactory refreshTokenAuthenticationRequestFactory=config.getInstance(REFRESH_TOKEN_AUTHENTICATION_REQUEST_FACTORY);
  RequestAuthorizer requestAuthorizer=config.getInstance(REQUEST_AUTHORIZER);
  AccessTokenResultFactory accessTokenResultFactory=config.getInstance(ACCESS_TOKEN_RESULT_FACTORY);
  RefreshTokenResultFactory refreshTokenResultFactory=config.getInstance(REFRESH_TOKEN_RESULT_FACTORY);
  Saver<AuthenticationResult> accountSaver=config.getInstance(ACCOUNT_SAVER);
  Publisher<RequestEvent> eventPublisher=config.getInstance(EVENT_PUBLISHER);
  BasicAuthenticationScheme basicAuthenticationScheme=config.getInstance(BASIC_AUTHENTICATION_REQUEST_FACTORY);
  GrantTypeStatusValidator grantTypeStatusValidator=config.getGrantTypeStatusValidator();
  c.setEventPublisher(eventPublisher);
  c.setAccessTokenAuthenticationRequestFactory(accessTokenAuthenticationRequestFactory);
  c.setAccessTokenResultFactory(accessTokenResultFactory);
  c.setRefreshTokenAuthenticationRequestFactory(refreshTokenAuthenticationRequestFactory);
  c.setRefreshTokenResultFactory(refreshTokenResultFactory);
  c.setAccountSaver(accountSaver);
  c.setRequestAuthorizer(requestAuthorizer);
  c.setBasicAuthenticationScheme(basicAuthenticationScheme);
  c.setGrantTypeStatusValidator(grantTypeStatusValidator);
}",0.9502171734046108
99352,"public OAuthException(OAuthErrorCode code,String message,Exception cause){
  super(message != null ? message : (code != null ? code.getValue() : ""String_Node_Str""),cause);
  Assert.notNull(code,""String_Node_Str"");
  this.errorCode=code;
  this.message=message;
}","public OAuthException(OAuthErrorCode code,String message,Exception cause){
  super(message != null ? message : (code != null ? code.getValue() : ""String_Node_Str""),cause);
  Assert.notNull(code,""String_Node_Str"");
  this.errorCode=code;
}",0.952
99353,"@Override protected ViewModel doPost(HttpServletRequest request,HttpServletResponse response) throws Exception {
  String json;
  AuthenticationRequest authcRequest=null;
  AccessTokenResult result=null;
  try {
    assertAuthorized(request,response);
    String grantType=null;
    try {
      grantType=request.getParameter(GRANT_TYPE_PARAM_NAME);
      Assert.hasText(grantType,""String_Node_Str"");
    }
 catch (    IllegalArgumentException e) {
      throw new OAuthException(OAuthErrorCode.INVALID_GRANT);
    }
    grantTypeStatusValidator.validate(grantType);
switch (grantType) {
case PASSWORD_GRANT_TYPE:
      result=this.tokenAuthenticationRequest(request,response);
    break;
case REFRESH_TOKEN_GRANT_TYPE:
  result=this.refreshTokenAuthenticationRequest(request,response);
break;
case CLIENT_CREDENTIALS_GRANT_TYPE:
try {
result=this.clientCredentialsAuthenticationRequest(request,response);
}
 catch (HttpAuthenticationException e) {
log.warn(""String_Node_Str"",e);
throw new OAuthException(OAuthErrorCode.INVALID_CLIENT);
}
break;
case STORMPATH_SOCIAL_GRANT_TYPE:
try {
result=this.stormpathSocialAuthenticationRequest(request,response);
}
 catch (HttpAuthenticationException e) {
log.warn(""String_Node_Str"",e);
throw new OAuthException(OAuthErrorCode.INVALID_CLIENT);
}
break;
default :
throw new OAuthException(OAuthErrorCode.UNSUPPORTED_GRANT_TYPE);
}
saveResult(request,response,result);
json=result.getTokenResponse().toJson();
response.setStatus(HttpServletResponse.SC_OK);
SuccessfulAuthenticationRequestEvent e=createSuccessEvent(request,response,authcRequest,result);
publish(e);
}
 catch (OAuthException e) {
log.debug(""String_Node_Str"",e);
json=e.toJson();
response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
if (e.getErrorCode().equals(OAuthErrorCode.INVALID_CLIENT)) {
response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
}
try {
FailedAuthenticationRequestEvent evt=new DefaultFailedAuthenticationRequestEvent(request,response,authcRequest,e);
publish(evt);
}
 catch (Throwable t) {
log.warn(""String_Node_Str"",t,e,t);
}
}
response.setContentType(MediaType.APPLICATION_JSON_VALUE);
response.setHeader(""String_Node_Str"",""String_Node_Str"");
response.setHeader(""String_Node_Str"",""String_Node_Str"");
response.setHeader(""String_Node_Str"",String.valueOf(json.length()));
response.getWriter().print(json);
response.getWriter().flush();
return null;
}","@Override protected ViewModel doPost(HttpServletRequest request,HttpServletResponse response) throws Exception {
  String json;
  AuthenticationRequest authcRequest=null;
  AccessTokenResult result=null;
  try {
    assertAuthorized(request,response);
    String grantType=null;
    try {
      grantType=request.getParameter(GRANT_TYPE_PARAM_NAME);
      Assert.hasText(grantType,""String_Node_Str"");
    }
 catch (    IllegalArgumentException e) {
      throw new OAuthException(OAuthErrorCode.INVALID_GRANT);
    }
    grantTypeStatusValidator.validate(grantType);
switch (grantType) {
case PASSWORD_GRANT_TYPE:
      result=this.tokenAuthenticationRequest(request,response);
    break;
case REFRESH_TOKEN_GRANT_TYPE:
  result=this.refreshTokenAuthenticationRequest(request,response);
break;
case CLIENT_CREDENTIALS_GRANT_TYPE:
try {
result=this.clientCredentialsAuthenticationRequest(request,response);
}
 catch (HttpAuthenticationException e) {
log.warn(""String_Node_Str"",e);
throw new OAuthException(OAuthErrorCode.INVALID_CLIENT);
}
break;
case STORMPATH_SOCIAL_GRANT_TYPE:
try {
result=this.stormpathSocialAuthenticationRequest(request,response);
}
 catch (HttpAuthenticationException e) {
log.warn(""String_Node_Str"",e);
throw new OAuthException(OAuthErrorCode.INVALID_CLIENT);
}
break;
default :
throw new OAuthException(OAuthErrorCode.UNSUPPORTED_GRANT_TYPE);
}
saveResult(request,response,result);
json=result.getTokenResponse().toJson();
response.setStatus(HttpServletResponse.SC_OK);
SuccessfulAuthenticationRequestEvent e=createSuccessEvent(request,response,authcRequest,result);
publish(e);
}
 catch (OAuthException e) {
log.debug(""String_Node_Str"" + e.getMessage());
json=e.toJson();
response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
if (e.getErrorCode().equals(OAuthErrorCode.INVALID_CLIENT)) {
response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
}
try {
FailedAuthenticationRequestEvent evt=new DefaultFailedAuthenticationRequestEvent(request,response,authcRequest,e);
publish(evt);
}
 catch (Throwable t) {
log.warn(""String_Node_Str"",t,e,t);
}
}
response.setContentType(MediaType.APPLICATION_JSON_VALUE);
response.setHeader(""String_Node_Str"",""String_Node_Str"");
response.setHeader(""String_Node_Str"",""String_Node_Str"");
response.setHeader(""String_Node_Str"",String.valueOf(json.length()));
response.getWriter().print(json);
response.getWriter().flush();
return null;
}",0.9960209424083768
99354,"@Override protected MeFilter createInstance(ServletContext servletContext,Config config) throws Exception {
  MeController c=new MeController();
  c.setUri(config.getMeUrl());
  c.setProduces(config.getProducedMediaTypes());
  c.setExpands(config.getMeExpandedProperties());
  c.setObjectMapper(config.getObjectMapper());
  c.setLoginPageRedirector(new DefaultLoginPageRedirector(config.getLoginConfig().getUri()));
  c.setApplicationResolver(config.getApplicationResolver());
  c.init();
  MeFilter filter=new MeFilter();
  filter.setProducedMediaTypes(config.getProducedMediaTypes());
  filter.setController(c);
  return filter;
}","@Override protected MeFilter createInstance(ServletContext servletContext,Config config) throws Exception {
  MeController c=new MeController();
  c.setUri(config.getMeUrl());
  c.setProduces(config.getProducedMediaTypes());
  c.setExpandsResolver(new DefaultExpandsResolver(config.getMeExpandedProperties()));
  c.setObjectMapper(config.getObjectMapper());
  c.setLoginPageRedirector(new DefaultLoginPageRedirector(config.getLoginConfig().getUri()));
  c.setApplicationResolver(config.getApplicationResolver());
  c.init();
  MeFilter filter=new MeFilter();
  filter.setProducedMediaTypes(config.getProducedMediaTypes());
  filter.setController(c);
  return filter;
}",0.9523076923076924
99355,"@Override protected ViewModel doGet(HttpServletRequest request,HttpServletResponse response) throws Exception {
  Account account=AccountResolver.INSTANCE.getAccount(request);
  response.setHeader(""String_Node_Str"",""String_Node_Str"");
  response.setHeader(""String_Node_Str"",""String_Node_Str"");
  response.setContentType(MediaType.APPLICATION_JSON_VALUE);
  if (account == null) {
    if (isHtmlPreferred(request,response)) {
      loginPageRedirector.redirectToLoginPage(request,response);
    }
    if (isJsonPreferred(request,response)) {
      Application application=applicationResolver.getApplication(request.getServletContext());
      String bearerRealm=String.format(""String_Node_Str"",application.getName());
      response.addHeader(""String_Node_Str"",bearerRealm);
      response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
    }
    return null;
  }
  objectMapper.writeValue(response.getOutputStream(),java.util.Collections.singletonMap(""String_Node_Str"",accountModelFactory.toMap(account,expands)));
  return null;
}","@Override protected ViewModel doGet(HttpServletRequest request,HttpServletResponse response) throws Exception {
  Account account=AccountResolver.INSTANCE.getAccount(request);
  response.setHeader(""String_Node_Str"",""String_Node_Str"");
  response.setHeader(""String_Node_Str"",""String_Node_Str"");
  response.setContentType(MediaType.APPLICATION_JSON_VALUE);
  if (account == null) {
    if (isHtmlPreferred(request,response)) {
      loginPageRedirector.redirectToLoginPage(request,response);
    }
    if (isJsonPreferred(request,response)) {
      Application application=applicationResolver.getApplication(request.getServletContext());
      String bearerRealm=String.format(""String_Node_Str"",application.getName());
      response.addHeader(""String_Node_Str"",bearerRealm);
      response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
    }
    return null;
  }
  objectMapper.writeValue(response.getOutputStream(),java.util.Collections.singletonMap(""String_Node_Str"",accountModelFactory.toMap(account,expandsResolver.getExpands())));
  return null;
}",0.9899280575539569
99356,"public Controller stormpathMeController(){
  List<String> expandedAccountAttributes=new ArrayList<>();
  getPropertiesStartingWith((ConfigurableEnvironment)environment,""String_Node_Str"");
  Pattern pattern=Pattern.compile(""String_Node_Str"");
  for (  String key : getPropertiesStartingWith((ConfigurableEnvironment)environment,""String_Node_Str"").keySet()) {
    Matcher matcher=pattern.matcher(key);
    if (matcher.find()) {
      if (environment.getProperty(key,Boolean.class,false)) {
        expandedAccountAttributes.add(matcher.group(1));
      }
    }
  }
  MeController controller=new MeController();
  controller.setExpands(expandedAccountAttributes);
  controller.setObjectMapper(objectMapper);
  controller.setProduces(stormpathProducedMediaTypes());
  controller.setUri(meUri);
  controller.setLoginPageRedirector(new DefaultLoginPageRedirector(stormpathLoginConfig().getUri()));
  controller.setApplicationResolver(stormpathApplicationResolver());
  init(controller);
  return controller;
}","public Controller stormpathMeController(){
  MeController controller=new MeController();
  controller.setExpandsResolver(stormpathMeExpandsResolver());
  controller.setObjectMapper(objectMapper);
  controller.setProduces(stormpathProducedMediaTypes());
  controller.setUri(meUri);
  controller.setLoginPageRedirector(new DefaultLoginPageRedirector(stormpathLoginConfig().getUri()));
  controller.setApplicationResolver(stormpathApplicationResolver());
  init(controller);
  return controller;
}",0.6172344689378757
99357,"/** 
 * Returns the   {@link WebConfiguration} associated with this application.
 * @return the {@link WebConfiguration} associated with this application.
 * @since 1.1.0
 */
WebConfiguration getWebConfiguration();","/** 
 * Returns the   {@link WebConfiguration} associated with this application.
 * @return the {@link WebConfiguration} associated with this application.
 * @since 1.2.0
 */
WebConfiguration getWebConfiguration();",0.9953271028037384
99358,"protected <T,P>T getParentAwareObjectProperty(String name,Class<T> type,Class<P> parentType){
  Object value=getProperty(name);
  if (value == null) {
    return null;
  }
  if (type.isAssignableFrom(value.getClass())) {
    return (T)value;
  }
  if (value instanceof Map) {
    writeLock.lock();
    try {
      Constructor<T> propertyConstructor=Classes.getConstructor(type,String.class,Map.class,parentType);
      @SuppressWarnings(""String_Node_Str"") T instance=propertyConstructor.newInstance(name,new Enlistment((Map<String,Object>)value),this);
      getProperties().put(name,instance);
      return instance;
    }
 catch (    Exception e) {
      throw new IllegalArgumentException(""String_Node_Str"",e);
    }
 finally {
      writeLock.unlock();
    }
  }
  String msg=""String_Node_Str"" + name + ""String_Node_Str""+ type.getTypeName()+ ""String_Node_Str""+ value.getClass().getName();
  msg+=(isPrintableProperty(name) ? ""String_Node_Str"" + value : ""String_Node_Str"");
  throw new IllegalArgumentException(msg);
}","protected <T,P>T getParentAwareObjectProperty(String name,Class<T> type,Class<P> parentType){
  Object value=getProperty(name);
  if (value == null) {
    return null;
  }
  if (type.isAssignableFrom(value.getClass())) {
    return (T)value;
  }
  if (value instanceof Map) {
    writeLock.lock();
    try {
      Constructor<T> propertyConstructor=Classes.getConstructor(type,String.class,Map.class,parentType);
      @SuppressWarnings(""String_Node_Str"") T instance=propertyConstructor.newInstance(name,new Enlistment((Map<String,Object>)value),this);
      getProperties().put(name,instance);
      return instance;
    }
 catch (    Exception e) {
      throw new IllegalArgumentException(""String_Node_Str"",e);
    }
 finally {
      writeLock.unlock();
    }
  }
  String msg=""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str""+ value.getClass().getName();
  msg+=(isPrintableProperty(name) ? ""String_Node_Str"" + value : ""String_Node_Str"");
  throw new IllegalArgumentException(msg);
}",0.990108803165183
99359,WebConfigurationStatus getStatus();,"/** 
 * Returns the webConfiguration's status. Users won't be able to use the applications' api if the webConfiguration is disabled.
 * @return the webConfiguration's status.
 */
WebConfigurationStatus getStatus();",0.2811244979919678
99360,void setStatus(WebConfigurationStatus status);,"/** 
 * Sets the webConfiguration's status. Users won't be able to use the applications' api if the webConfiguration is disabled.
 * @param status the webConfiguration's status.
 */
void setStatus(WebConfigurationStatus status);",0.3357664233576642
99361,String getDomainName();,"/** 
 * Returns the WebConfiguration's Domain name, this is automatically generated by Stormpath (using the   {@link #getDnsLabel() value}and is guaranteed to be unique across all   {@link com.stormpath.sdk.tenant.Tenant tenants} in Stormpath.
 * @return the WebConfiguration's Domain name value or {@code null} if one hasn't been generated for {@code this}resource.
 */
String getDomainName();",0.1103117505995203
99362,"private static String toScopeString(List<String> scopeList){
  String scope=scopeList.toString();
  scope=scope.replaceAll(""String_Node_Str"",""String_Node_Str"");
  scope=scope.replaceAll(""String_Node_Str"",""String_Node_Str"");
  return scope;
}","private static String toScopeString(List<String> scopeList){
  if (scopeList == null) {
    return null;
  }
  String scope=scopeList.toString();
  scope=scope.replaceAll(""String_Node_Str"",""String_Node_Str"");
  scope=scope.replaceAll(""String_Node_Str"",""String_Node_Str"");
  return scope;
}",0.909433962264151
99363,"public View stormpathJacksonView(){
  JacksonView view=new JacksonView();
  view.setObjectMapper(stormpathObjectMapper());
  return view;
}","public View stormpathJacksonView(){
  JacksonView view=new JacksonView();
  view.setObjectMapper(objectMapper);
  return view;
}",0.9588014981273408
99364,"public Controller stormpathMeController(){
  List<String> expandedAccountAttributes=new ArrayList<>();
  getPropertiesStartingWith((ConfigurableEnvironment)environment,""String_Node_Str"");
  Pattern pattern=Pattern.compile(""String_Node_Str"");
  for (  String key : getPropertiesStartingWith((ConfigurableEnvironment)environment,""String_Node_Str"").keySet()) {
    Matcher matcher=pattern.matcher(key);
    if (matcher.find()) {
      if (environment.getProperty(key,Boolean.class,false)) {
        expandedAccountAttributes.add(matcher.group(1));
      }
    }
  }
  MeController controller=new MeController();
  controller.setExpands(expandedAccountAttributes);
  controller.setObjectMapper(stormpathObjectMapper());
  controller.setProduces(stormpathProducedMediaTypes());
  controller.setUri(meUri);
  controller.setLoginPageRedirector(new DefaultLoginPageRedirector(stormpathLoginConfig().getUri()));
  controller.setApplicationResolver(stormpathApplicationResolver());
  init(controller);
  return controller;
}","public Controller stormpathMeController(){
  List<String> expandedAccountAttributes=new ArrayList<>();
  getPropertiesStartingWith((ConfigurableEnvironment)environment,""String_Node_Str"");
  Pattern pattern=Pattern.compile(""String_Node_Str"");
  for (  String key : getPropertiesStartingWith((ConfigurableEnvironment)environment,""String_Node_Str"").keySet()) {
    Matcher matcher=pattern.matcher(key);
    if (matcher.find()) {
      if (environment.getProperty(key,Boolean.class,false)) {
        expandedAccountAttributes.add(matcher.group(1));
      }
    }
  }
  MeController controller=new MeController();
  controller.setExpands(expandedAccountAttributes);
  controller.setObjectMapper(objectMapper);
  controller.setProduces(stormpathProducedMediaTypes());
  controller.setUri(meUri);
  controller.setLoginPageRedirector(new DefaultLoginPageRedirector(stormpathLoginConfig().getUri()));
  controller.setApplicationResolver(stormpathApplicationResolver());
  init(controller);
  return controller;
}",0.993554784333168
99365,"public org.springframework.web.servlet.View stormpathJsonView(){
  MappingJackson2JsonView jsonView=new MappingJackson2JsonView(stormpathObjectMapper());
  jsonView.setDisableCaching(false);
  return jsonView;
}","public org.springframework.web.servlet.View stormpathJsonView(){
  MappingJackson2JsonView jsonView=new MappingJackson2JsonView(objectMapper);
  jsonView.setDisableCaching(false);
  return jsonView;
}",0.9683698296836984
99366,"protected boolean isHtmlPreferred(HttpServletRequest request,HttpServletResponse response){
  try {
    return MediaType.TEXT_HTML.equals(contentNegotiationResolver.getContentType(request,response,produces));
  }
 catch (  UnresolvedMediaTypeException e) {
    log.info(""String_Node_Str"",e.getMessage());
    return false;
  }
}","protected boolean isHtmlPreferred(HttpServletRequest request,HttpServletResponse response){
  try {
    return MediaType.TEXT_HTML.equals(contentNegotiationResolver.getContentType(request,response,produces));
  }
 catch (  UnresolvedMediaTypeException e) {
    log.debug(""String_Node_Str"",e.getMessage());
    return false;
  }
}",0.9863013698630136
99367,"protected boolean isJsonPreferred(HttpServletRequest request,HttpServletResponse response){
  try {
    return MediaType.APPLICATION_JSON.equals(contentNegotiationResolver.getContentType(request,response,produces));
  }
 catch (  UnresolvedMediaTypeException e) {
    log.info(""String_Node_Str"",e.getMessage());
    return false;
  }
}","protected boolean isJsonPreferred(HttpServletRequest request,HttpServletResponse response){
  try {
    return MediaType.APPLICATION_JSON.equals(contentNegotiationResolver.getContentType(request,response,produces));
  }
 catch (  UnresolvedMediaTypeException e) {
    log.debug(""String_Node_Str"",e.getMessage());
    return false;
  }
}",0.9865871833084948
99368,"@Override public String getStatusMessage(HttpServletRequest request,String status){
  EnumSet<LoginStatus> validStatus=EnumSet.allOf(LoginStatus.class);
  if (validStatus.contains(LoginStatus.valueOf(status.toUpperCase()))) {
    return messageSource.getMessage(""String_Node_Str"" + status,request.getLocale(),verifyEmailUri);
  }
 else {
    return ""String_Node_Str"";
  }
}","@Override public String getStatusMessage(HttpServletRequest request,String status){
  EnumSet<LoginStatus> validStatus=EnumSet.allOf(LoginStatus.class);
  try {
    if (validStatus.contains(LoginStatus.valueOf(status.toUpperCase()))) {
      return messageSource.getMessage(""String_Node_Str"" + status,request.getLocale(),verifyEmailUri);
    }
  }
 catch (  IllegalArgumentException e) {
  }
  return ""String_Node_Str"";
}",0.9193954659949622
99369,"@Override protected FilterChainManager createInstance(ServletContext servletContext) throws Exception {
  DefaultFilterChainManager mgr=new DefaultFilterChainManager(servletContext);
  for (  DefaultFilter defaultFilter : DefaultFilter.values()) {
    Object o=defaultFilter.getFactoryClass();
    if (o == null) {
      o=defaultFilter.getFilterClass();
    }
    mgr.addFilter(defaultFilter.name(),o);
  }
  Config config=getConfig();
  for (  String key : config.keySet()) {
    if (key.startsWith(FILTER_CONFIG_PREFIX)) {
      String instanceName=key.substring(FILTER_CONFIG_PREFIX.length());
      int i=instanceName.indexOf('.');
      if (i >= 0) {
        continue;
      }
      String className=config.getInstance(key);
      Object instance=Classes.newInstance(className);
      mgr.addFilter(instanceName,instance);
    }
  }
  return new DefaultFilterChainManagerConfigurer(mgr,servletContext,config).configure();
}","@Override protected FilterChainManager createInstance(ServletContext servletContext) throws Exception {
  DefaultFilterChainManager mgr=new DefaultFilterChainManager(servletContext);
  for (  DefaultFilter defaultFilter : DefaultFilter.values()) {
    Object o=defaultFilter.getFactoryClass();
    if (o == null) {
      o=defaultFilter.getFilterClass();
    }
    mgr.addFilter(defaultFilter.name(),o);
  }
  Config config=getConfig();
  for (  String key : config.keySet()) {
    if (key.startsWith(FILTER_CONFIG_PREFIX)) {
      String instanceName=key.substring(FILTER_CONFIG_PREFIX.length());
      int i=instanceName.indexOf('.');
      if (i >= 0) {
        continue;
      }
      String className=config.get(key);
      Object instance=Classes.newInstance(className);
      mgr.addFilter(instanceName,instance);
    }
  }
  return new DefaultFilterChainManagerConfigurer(mgr,servletContext,config).configure();
}",0.9956756756756756
99370,"@Override public Authentication attemptAuthentication(HttpServletRequest request,HttpServletResponse response) throws AuthenticationException {
  if (postOnly && !request.getMethod().equals(""String_Node_Str"")) {
    throw new AuthenticationServiceException(""String_Node_Str"" + request.getMethod());
  }
  if (supportedMediaTypes == null) {
    throw new AuthenticationServiceException(""String_Node_Str"");
  }
  MediaType mediaType;
  try {
    mediaType=ContentNegotiationResolver.INSTANCE.getContentType(request,response,supportedMediaTypes);
  }
 catch (  UnresolvedMediaTypeException umt) {
    throw new AuthenticationServiceException(""String_Node_Str"" + umt.getMessage(),umt);
  }
  if (!MediaType.APPLICATION_JSON.equals(mediaType) || request.getContentType().contains(MediaType.APPLICATION_FORM_URLENCODED_VALUE)) {
    return super.attemptAuthentication(request,response);
  }
  UsernamePasswordAuthenticationToken authRequest=getUserNamePasswordAuthenticationToken(request);
  setDetails(request,authRequest);
  return getAuthenticationManager().authenticate(authRequest);
}","@Override public Authentication attemptAuthentication(HttpServletRequest request,HttpServletResponse response) throws AuthenticationException {
  if (postOnly && !request.getMethod().equals(""String_Node_Str"")) {
    throw new AuthenticationServiceException(""String_Node_Str"" + request.getMethod());
  }
  if (supportedMediaTypes == null) {
    throw new AuthenticationServiceException(""String_Node_Str"");
  }
  MediaType mediaType;
  try {
    mediaType=ContentNegotiationResolver.INSTANCE.getContentType(request,response,supportedMediaTypes);
  }
 catch (  UnresolvedMediaTypeException umt) {
    throw new AuthenticationServiceException(""String_Node_Str"" + umt.getMessage(),umt);
  }
  System.out.println(""String_Node_Str"" + mediaType);
  System.out.println(""String_Node_Str"" + request.getContentType());
  if (!MediaType.APPLICATION_JSON.equals(mediaType) || request.getHeader(""String_Node_Str"").contains(MediaType.APPLICATION_FORM_URLENCODED_VALUE) || request.getContentType().contains(MediaType.APPLICATION_FORM_URLENCODED_VALUE)) {
    return super.attemptAuthentication(request,response);
  }
  UsernamePasswordAuthenticationToken authRequest=getUserNamePasswordAuthenticationToken(request);
  setDetails(request,authRequest);
  return getAuthenticationManager().authenticate(authRequest);
}",0.8996220075598488
99371,"@Override protected ViewModel onValidSubmit(HttpServletRequest request,HttpServletResponse response,Form form) throws Exception {
  String password=form.getFieldValue(""String_Node_Str"");
  Application application=(Application)request.getAttribute(Application.class.getName());
  String sptoken=form.getFieldValue(""String_Node_Str"");
  if (isJsonPreferred(request,response)) {
    Map<String,Object> model=new HashMap<String,Object>();
    try {
      Account account=application.resetPassword(sptoken,password);
      if (autoLogin) {
        final AuthenticationResult result=new TransientAuthenticationResult(account);
        this.authenticationResultSaver.set(request,response,result);
        model.put(""String_Node_Str"",accountModelFactory.toMap(account,Collections.EMPTY_LIST));
      }
 else {
        return new DefaultViewModel(""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      model=errorModelFactory.toError(request,e).toMap();
      response.setStatus(errorModelFactory.toError(request,e).getStatus());
    }
    return new DefaultViewModel(""String_Node_Str"",model);
  }
  Account account=application.resetPassword(sptoken,password);
  String next;
  if (autoLogin) {
    final AuthenticationResult result=new TransientAuthenticationResult(account);
    this.authenticationResultSaver.set(request,response,result);
    next=loginNextUri;
  }
 else {
    next=this.nextUri;
  }
  return new DefaultViewModel(next).setRedirect(true);
}","@Override protected ViewModel onValidSubmit(HttpServletRequest request,HttpServletResponse response,Form form) throws Exception {
  String password=form.getFieldValue(""String_Node_Str"");
  Application application=(Application)request.getAttribute(Application.class.getName());
  String sptoken=form.getFieldValue(""String_Node_Str"");
  if (isJsonPreferred(request,response)) {
    Map<String,Object> model=new HashMap<String,Object>();
    try {
      Account account=application.resetPassword(sptoken,password);
      if (autoLogin) {
        final AuthenticationResult result=new TransientAuthenticationResult(account);
        this.authenticationResultSaver.set(request,response,result);
        model.put(""String_Node_Str"",accountModelFactory.toMap(account,Collections.EMPTY_LIST));
      }
 else {
        return new DefaultViewModel(""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      model=errorModelFactory.toError(request,e).toMap();
      response.setStatus(errorModelFactory.toError(request,e).getStatus());
    }
    return new DefaultViewModel(""String_Node_Str"",model);
  }
  String next;
  try {
    Account account=application.resetPassword(sptoken,password);
    if (autoLogin) {
      final AuthenticationResult result=new TransientAuthenticationResult(account);
      this.authenticationResultSaver.set(request,response,result);
      next=loginNextUri;
    }
 else {
      next=this.nextUri;
    }
  }
 catch (  Exception e) {
    next=errorUri;
  }
  return new DefaultViewModel(next).setRedirect(true);
}",0.8307794803464357
99372,"@Override protected ViewModel doGet(HttpServletRequest request,HttpServletResponse response) throws Exception {
  String sptoken=Strings.clean(fieldValueResolver.getValue(request,""String_Node_Str""));
  if (isJsonPreferred(request,response)) {
    Map<String,Object> model=new HashMap<String,Object>(1);
    if (sptoken == null) {
      model.put(""String_Node_Str"",HttpServletResponse.SC_BAD_REQUEST);
      model.put(""String_Node_Str"",i18n(request,""String_Node_Str""));
      response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
    }
 else {
      try {
        Application application=(Application)request.getAttribute(Application.class.getName());
        application.verifyPasswordResetToken(sptoken);
        return new DefaultViewModel(""String_Node_Str"");
      }
 catch (      Exception e) {
        model=errorModelFactory.toError(request,e).toMap();
        response.setStatus(errorModelFactory.toError(request,e).getStatus());
      }
    }
    return new DefaultViewModel(""String_Node_Str"",model);
  }
  if (sptoken == null) {
    return new DefaultViewModel(forgotPasswordUri).setRedirect(true);
  }
 else {
    try {
      Application application=(Application)request.getAttribute(Application.class.getName());
      application.verifyPasswordResetToken(sptoken);
    }
 catch (    ResourceException re) {
      return new DefaultViewModel(errorUri).setRedirect(true);
    }
    return super.doGet(request,response);
  }
}","@Override protected ViewModel doGet(HttpServletRequest request,HttpServletResponse response) throws Exception {
  String sptoken=Strings.clean(request.getParameter(""String_Node_Str""));
  if (isJsonPreferred(request,response)) {
    Map<String,Object> model=new HashMap<String,Object>(1);
    if (sptoken == null) {
      model.put(""String_Node_Str"",HttpServletResponse.SC_BAD_REQUEST);
      model.put(""String_Node_Str"",i18n(request,""String_Node_Str""));
      response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
    }
 else {
      try {
        Application application=(Application)request.getAttribute(Application.class.getName());
        application.verifyPasswordResetToken(sptoken);
        return new DefaultViewModel(""String_Node_Str"");
      }
 catch (      Exception e) {
        model=errorModelFactory.toError(request,e).toMap();
        response.setStatus(errorModelFactory.toError(request,e).getStatus());
      }
    }
    return new DefaultViewModel(""String_Node_Str"",model);
  }
  if (sptoken == null) {
    return new DefaultViewModel(forgotPasswordUri).setRedirect(true);
  }
 else {
    try {
      Application application=(Application)request.getAttribute(Application.class.getName());
      application.verifyPasswordResetToken(sptoken);
    }
 catch (    ResourceException re) {
      return new DefaultViewModel(errorUri).setRedirect(true);
    }
    return super.doGet(request,response);
  }
}",0.9849597761455056
99373,"@Override protected List<Field> createFields(HttpServletRequest request,boolean retainPassword){
  List<Field> fields=new ArrayList<Field>(3);
  String value=Strings.clean(request.getParameter(""String_Node_Str""));
  if (value != null) {
    DefaultField field=new DefaultField();
    field.setName(""String_Node_Str"");
    field.setType(""String_Node_Str"");
    field.setValue(value);
    fields.add(field);
  }
  String[] fieldNames=new String[]{""String_Node_Str"",""String_Node_Str""};
  for (  String fieldName : fieldNames) {
    DefaultField field=new DefaultField();
    field.setName(fieldName);
    field.setName(fieldName);
    field.setLabel(""String_Node_Str"" + fieldName + ""String_Node_Str"");
    field.setPlaceholder(""String_Node_Str"" + fieldName + ""String_Node_Str"");
    field.setRequired(true);
    field.setType(""String_Node_Str"");
    String val=fieldValueResolver.getValue(request,fieldName);
    field.setValue(retainPassword && val != null ? val : ""String_Node_Str"");
    fields.add(field);
  }
  return fields;
}","@Override protected List<Field> createFields(HttpServletRequest request,boolean retainPassword){
  List<Field> fields=new ArrayList<Field>(3);
  String value=Strings.clean(request.getParameter(""String_Node_Str""));
  if (value != null) {
    DefaultField field=new DefaultField();
    field.setName(""String_Node_Str"");
    field.setType(""String_Node_Str"");
    field.setValue(value);
    fields.add(field);
  }
  String[] fieldNames=new String[]{""String_Node_Str"",""String_Node_Str""};
  for (  String fieldName : fieldNames) {
    DefaultField field=new DefaultField();
    field.setName(fieldName);
    field.setLabel(i18n(request,""String_Node_Str"" + fieldName + ""String_Node_Str""));
    field.setPlaceholder(i18n(request,""String_Node_Str"" + fieldName + ""String_Node_Str""));
    field.setRequired(true);
    field.setType(""String_Node_Str"");
    String val=fieldValueResolver.getValue(request,fieldName);
    field.setValue(retainPassword && val != null ? val : ""String_Node_Str"");
    fields.add(field);
  }
  return fields;
}",0.8588120740019474
99374,"@Override protected ViewModel onValidSubmit(HttpServletRequest request,HttpServletResponse response,Form form) throws Exception {
  String password=form.getFieldValue(""String_Node_Str"");
  Application application=(Application)request.getAttribute(Application.class.getName());
  String sptoken=form.getFieldValue(""String_Node_Str"");
  if (isJsonPreferred(request,response)) {
    Map<String,Object> model=new HashMap<String,Object>();
    try {
      Account account=application.resetPassword(sptoken,password);
      if (autoLogin) {
        model.put(""String_Node_Str"",""String_Node_Str"");
        model.put(""String_Node_Str"",accountModelFactory.toMap(account,Collections.EMPTY_LIST));
      }
 else {
        model.put(""String_Node_Str"",""String_Node_Str"");
        model.put(""String_Node_Str"",""String_Node_Str"");
      }
    }
 catch (    ResourceException re) {
      model=errorMap.toErrorMap(re.getStormpathError());
    }
catch (    Exception e) {
      Map<String,Object> exceptionErrorMap=new HashMap<String,Object>();
      exceptionErrorMap.put(""String_Node_Str"",e.getMessage());
      exceptionErrorMap.put(""String_Node_Str"",400);
      DefaultError error=new DefaultError(exceptionErrorMap);
      model=errorMap.toErrorMap(error);
    }
    return new DefaultViewModel(""String_Node_Str"",model);
  }
  application.resetPassword(sptoken,password);
  String next;
  if (autoLogin) {
    next=loginNextUri;
  }
 else {
    next=this.nextUri;
  }
  return new DefaultViewModel(next).setRedirect(true);
}","@Override protected ViewModel onValidSubmit(HttpServletRequest request,HttpServletResponse response,Form form) throws Exception {
  String password=form.getFieldValue(""String_Node_Str"");
  Application application=(Application)request.getAttribute(Application.class.getName());
  String sptoken=form.getFieldValue(""String_Node_Str"");
  if (isJsonPreferred(request,response)) {
    Map<String,Object> model=new HashMap<String,Object>();
    try {
      Account account=application.resetPassword(sptoken,password);
      if (autoLogin) {
        model.put(""String_Node_Str"",accountModelFactory.toMap(account,Collections.EMPTY_LIST));
      }
 else {
        return new DefaultViewModel(""String_Node_Str"");
      }
    }
 catch (    ResourceException re) {
      model=errorMapModelFactory.toErrorMap(re.getStormpathError());
    }
catch (    Exception e) {
      Map<String,Object> exceptionErrorMap=new HashMap<String,Object>();
      exceptionErrorMap.put(""String_Node_Str"",e.getMessage());
      exceptionErrorMap.put(""String_Node_Str"",400);
      DefaultError error=new DefaultError(exceptionErrorMap);
      model=errorMapModelFactory.toErrorMap(error);
    }
    return new DefaultViewModel(""String_Node_Str"",model);
  }
  application.resetPassword(sptoken,password);
  String next;
  if (autoLogin) {
    next=loginNextUri;
  }
 else {
    next=this.nextUri;
  }
  return new DefaultViewModel(next).setRedirect(true);
}",0.9352419904567144
99375,"public ChangePasswordController(Config config){
  super(config.getChangePasswordControllerConfig(),config.getProducesMediaTypes());
  this.forgotPasswordUri=config.getForgotPasswordControllerConfig().getUri();
  this.loginUri=config.getLoginControllerConfig().getUri();
  this.loginNextUri=config.getLoginControllerConfig().getNextUri();
  this.errorUri=config.getChangePasswordControllerConfig().getErrorUri();
  this.autoLogin=config.getChangePasswordControllerConfig().isAutoLogin();
  this.accountModelFactory=new DefaultAccountModelFactory();
  this.errorMap=new DefaultErrorMapModelFactory();
  Assert.hasText(forgotPasswordUri,""String_Node_Str"");
  Assert.hasText(loginUri,""String_Node_Str"");
  Assert.hasText(loginNextUri,""String_Node_Str"");
  Assert.hasText(errorUri,""String_Node_Str"");
}","public ChangePasswordController(Config config){
  super(config.getChangePasswordControllerConfig(),config.getProducesMediaTypes());
  this.forgotPasswordUri=config.getForgotPasswordControllerConfig().getUri();
  this.loginUri=config.getLoginControllerConfig().getUri();
  this.loginNextUri=config.getLoginControllerConfig().getNextUri();
  this.errorUri=config.getChangePasswordControllerConfig().getErrorUri();
  this.autoLogin=config.getChangePasswordControllerConfig().isAutoLogin();
  this.accountModelFactory=new DefaultAccountModelFactory();
  this.errorMapModelFactory=new DefaultErrorMapModelFactory();
  Assert.hasText(forgotPasswordUri,""String_Node_Str"");
  Assert.hasText(loginUri,""String_Node_Str"");
  Assert.hasText(loginNextUri,""String_Node_Str"");
  Assert.hasText(errorUri,""String_Node_Str"");
}",0.9925280199252802
99376,"@Override protected ViewModel doGet(HttpServletRequest request,HttpServletResponse response) throws Exception {
  String sptoken=Strings.clean(request.getParameter(""String_Node_Str""));
  if (isJsonPreferred(request,response)) {
    Map<String,Object> model=new HashMap<String,Object>(1);
    if (sptoken == null) {
      model.put(""String_Node_Str"",""String_Node_Str"");
      model.put(""String_Node_Str"",i18n(request,""String_Node_Str""));
    }
 else {
      try {
        Application application=(Application)request.getAttribute(Application.class.getName());
        application.verifyPasswordResetToken(sptoken);
        model.put(""String_Node_Str"",""String_Node_Str"");
        model.put(""String_Node_Str"",""String_Node_Str"");
      }
 catch (      ResourceException re) {
        model=errorMap.toErrorMap(re.getStormpathError());
      }
    }
    return new DefaultViewModel(""String_Node_Str"",model);
  }
  if (sptoken == null) {
    return new DefaultViewModel(forgotPasswordUri).setRedirect(true);
  }
 else {
    try {
      Application application=(Application)request.getAttribute(Application.class.getName());
      application.verifyPasswordResetToken(sptoken);
    }
 catch (    ResourceException re) {
      return new DefaultViewModel(errorUri).setRedirect(true);
    }
    return super.doGet(request,response);
  }
}","@Override protected ViewModel doGet(HttpServletRequest request,HttpServletResponse response) throws Exception {
  String sptoken=Strings.clean(request.getParameter(""String_Node_Str""));
  if (isJsonPreferred(request,response)) {
    Map<String,Object> model=new HashMap<String,Object>(1);
    if (sptoken == null) {
      model.put(""String_Node_Str"",""String_Node_Str"");
      model.put(""String_Node_Str"",i18n(request,""String_Node_Str""));
    }
 else {
      try {
        Application application=(Application)request.getAttribute(Application.class.getName());
        application.verifyPasswordResetToken(sptoken);
        return new DefaultViewModel(""String_Node_Str"");
      }
 catch (      ResourceException re) {
        model=errorMapModelFactory.toErrorMap(re.getStormpathError());
      }
    }
    return new DefaultViewModel(""String_Node_Str"",model);
  }
  if (sptoken == null) {
    return new DefaultViewModel(forgotPasswordUri).setRedirect(true);
  }
 else {
    try {
      Application application=(Application)request.getAttribute(Application.class.getName());
      application.verifyPasswordResetToken(sptoken);
    }
 catch (    ResourceException re) {
      return new DefaultViewModel(errorUri).setRedirect(true);
    }
    return super.doGet(request,response);
  }
}",0.9525631216526396
99377,"protected ViewModel onValidSubmit(HttpServletRequest request,HttpServletResponse response,Form form){
  Application application=(Application)request.getAttribute(Application.class.getName());
  String email=form.getFieldValue(""String_Node_Str"");
  Map<String,Object> model=new HashMap<String,Object>();
  try {
    request.setAttribute(""String_Node_Str"",form);
    AccountStore accountStore=accountStoreResolver.getAccountStore(request,response);
    if (accountStore != null) {
      application.sendPasswordResetEmail(email,accountStore);
    }
 else {
      application.sendPasswordResetEmail(email);
    }
  }
 catch (  ResourceException e) {
    if (isJsonPreferred(request,response)) {
      model.put(""String_Node_Str"",200);
      model.put(""String_Node_Str"",""String_Node_Str"");
      return new DefaultViewModel(""String_Node_Str"",model);
    }
    if (e.getCode() != 404) {
      throw e;
    }
  }
  if (isJsonPreferred(request,response)) {
    model.put(""String_Node_Str"",200);
    model.put(""String_Node_Str"",""String_Node_Str"");
    return new DefaultViewModel(""String_Node_Str"",model);
  }
  return new DefaultViewModel(nextUri).setRedirect(true);
}","protected ViewModel onValidSubmit(HttpServletRequest request,HttpServletResponse response,Form form){
  Application application=(Application)request.getAttribute(Application.class.getName());
  String email=form.getFieldValue(""String_Node_Str"");
  Map<String,Object> model=new HashMap<String,Object>();
  try {
    request.setAttribute(""String_Node_Str"",form);
    AccountStore accountStore=accountStoreResolver.getAccountStore(request,response);
    if (accountStore != null) {
      application.sendPasswordResetEmail(email,accountStore);
    }
 else {
      application.sendPasswordResetEmail(email);
    }
  }
 catch (  ResourceException e) {
    if (isJsonPreferred(request,response)) {
      return new DefaultViewModel(""String_Node_Str"");
    }
  }
  if (isJsonPreferred(request,response)) {
    return new DefaultViewModel(""String_Node_Str"");
  }
  return new DefaultViewModel(nextUri).setRedirect(true);
}",0.7460240963855421
99378,"@Override protected String getErrorMessage(HttpServletRequest request,String key){
  String defaultMessage=messageSource.getMessage(getDefaultMessageKey(),new Object[]{},request.getLocale());
  return messageSource.getMessage(key,getMessageParams(),defaultMessage,request.getLocale());
}","@Override protected String getErrorMessage(HttpServletRequest request,String key){
  return messageSource.getMessage(getDefaultMessageKey(),request.getLocale(),getMessageParams());
}",0.7633262260127932
99379,"public ErrorModel toError(HttpServletRequest request,Exception e){
  if (!hasError(request,e)) {
    return null;
  }
  String errorMsg=getErrorMessage(request,getDefaultMessageKey());
  int status=400;
  if (e.getCause() instanceof ResourceException) {
    return translateResourceException(request,(ResourceException)e.getCause());
  }
 else   if (e instanceof ResourceException) {
    return translateResourceException(request,(ResourceException)e);
  }
 else   if (e instanceof ValidationException) {
    errorMsg=e.getMessage();
  }
  return ErrorModel.builder().setStatus(status).setMessage(errorMsg).build();
}","public ErrorModel toError(HttpServletRequest request,Exception e){
  if (!hasError(request,e)) {
    return null;
  }
  String errorMsg=getErrorMessage(request,getDefaultMessageKey(),""String_Node_Str"");
  int status=400;
  if (e.getCause() instanceof ResourceException) {
    return translateResourceException(request,(ResourceException)e.getCause());
  }
 else   if (e instanceof ResourceException) {
    return translateResourceException(request,(ResourceException)e);
  }
 else   if (e instanceof ValidationException) {
    errorMsg=e.getMessage();
  }
  return ErrorModel.builder().setStatus(status).setMessage(errorMsg).build();
}",0.9856230031948882
99380,"private ErrorModel translateResourceException(HttpServletRequest request,ResourceException e){
  return new ErrorModel.Builder().setStatus(e.getStormpathError().getStatus()).setMessage(getErrorMessage(request,""String_Node_Str"" + e.getStormpathError().getCode())).build();
}","private ErrorModel translateResourceException(HttpServletRequest request,ResourceException e){
  return new ErrorModel.Builder().setStatus(e.getStormpathError().getStatus()).setMessage(getErrorMessage(request,""String_Node_Str"" + e.getStormpathError().getCode(),e.getStormpathError().getMessage())).build();
}",0.9397590361445785
99381,"protected String getErrorMessage(HttpServletRequest request,String key){
  String message=messageSource.getMessage(key,request.getLocale(),getMessageParams());
  if (message.startsWith(""String_Node_Str"") && message.endsWith(""String_Node_Str"")) {
    return messageSource.getMessage(getDefaultMessageKey(),request.getLocale(),getMessageParams());
  }
  return message;
}","protected String getErrorMessage(HttpServletRequest request,String key,String defaultMessage){
  return messageSource.getMessage(key,defaultMessage,request.getLocale(),getMessageParams());
}",0.5509838998211091
99382,"public com.stormpath.sdk.servlet.i18n.MessageSource stormpathMessageSource(){
  final MessageSource springMessageSource=stormpathSpringMessageSource();
  return new com.stormpath.sdk.servlet.i18n.MessageSource(){
    @Override public String getMessage(    String key,    Locale locale){
      return getMessage(key,locale,new Object[0]);
    }
    @Override public String getMessage(    String key,    String defaultMessage,    Locale locale){
      try {
        return springMessageSource.getMessage(key,new Object[0],locale);
      }
 catch (      NoSuchMessageException e) {
        return defaultMessage;
      }
    }
    @Override public String getMessage(    String key,    Locale locale,    Object... args){
      try {
        return springMessageSource.getMessage(key,args,locale);
      }
 catch (      NoSuchMessageException e) {
        return '!' + key + '!';
      }
    }
  }
;
}","public com.stormpath.sdk.servlet.i18n.MessageSource stormpathMessageSource(){
  final MessageSource springMessageSource=stormpathSpringMessageSource();
  return new com.stormpath.sdk.servlet.i18n.MessageSource(){
    @Override public String getMessage(    String key,    Locale locale){
      return getMessage(key,locale,new Object[0]);
    }
    @Override public String getMessage(    String key,    String defaultMessage,    Locale locale,    Object... args){
      try {
        return springMessageSource.getMessage(key,args,locale);
      }
 catch (      NoSuchMessageException e) {
        log.warn(""String_Node_Str"",e);
        return defaultMessage;
      }
    }
    @Override public String getMessage(    String key,    String defaultMessage,    Locale locale){
      try {
        return springMessageSource.getMessage(key,new Object[0],locale);
      }
 catch (      NoSuchMessageException e) {
        log.warn(""String_Node_Str"",e);
        return defaultMessage;
      }
    }
    @Override public String getMessage(    String key,    Locale locale,    Object... args){
      try {
        return springMessageSource.getMessage(key,args,locale);
      }
 catch (      NoSuchMessageException e) {
        log.warn(""String_Node_Str"",e);
        return '!' + key + '!';
      }
    }
  }
;
}",0.7530695770804912
99383,"@Override public String getMessage(String key,Locale locale,Object... args){
  try {
    return springMessageSource.getMessage(key,args,locale);
  }
 catch (  NoSuchMessageException e) {
    return '!' + key + '!';
  }
}","@Override public String getMessage(String key,Locale locale,Object... args){
  try {
    return springMessageSource.getMessage(key,args,locale);
  }
 catch (  NoSuchMessageException e) {
    log.warn(""String_Node_Str"",e);
    return '!' + key + '!';
  }
}",0.9263157894736842
99384,"@Override protected boolean hasError(HttpServletRequest request,Exception e){
  if (e instanceof AuthenticationServiceException) {
    if (e.getMessage() != null && e.getMessage().contains(UNSUCCESSFUL_LOGIN_STORMPATH_ERROR)) {
      return true;
    }
  }
  return false;
}","@Override protected boolean hasError(HttpServletRequest request,Exception e){
  if (e instanceof AuthenticationServiceException) {
    if (e.getMessage() != null && e.getMessage().contains(UNSUCCESSFUL_LOGIN_BACKEND_ERROR)) {
      return true;
    }
  }
  return false;
}",0.956043956043956
99385,"@Override public void onAuthenticationFailure(HttpServletRequest request,HttpServletResponse response,AuthenticationException exception) throws IOException, ServletException {
  try {
    request.getSession().setAttribute(SPRING_SECURITY_AUTHENTICATION_FAILED_KEY,errorModelFactory.toError(request,exception));
    this.delegate.onAuthenticationFailure(request,response,exception);
  }
  finally {
    FailedAuthenticationRequestEvent event=createFailureEvent(request,response,exception);
    publisher.publish(event);
  }
}","@Override public void onAuthenticationFailure(HttpServletRequest request,HttpServletResponse response,AuthenticationException exception) throws IOException, ServletException {
  try {
    request.getSession().setAttribute(FormController.SPRING_SECURITY_AUTHENTICATION_FAILED_KEY,errorModelFactory.toError(request,exception));
    this.delegate.onAuthenticationFailure(request,response,exception);
  }
  finally {
    FailedAuthenticationRequestEvent event=createFailureEvent(request,response,exception);
    publisher.publish(event);
  }
}",0.9858889934148636
99386,"@Bean @ConditionalOnMissingBean public CsrfTokenManager stormpathCsrfTokenManager(){
  return new DisabledCsrfTokenManager(csrfTokenName);
}","@Bean @ConditionalOnMissingBean public CsrfTokenManager stormpathCsrfTokenManager(){
  return super.stormpathCsrfTokenManager();
}",0.8740740740740741
99387,"public AuthenticationFailureHandler stormpathAuthenticationFailureHandler(){
  String loginFailureUri=loginUri + ""String_Node_Str"";
  SimpleUrlAuthenticationFailureHandler handler=new SimpleUrlAuthenticationFailureHandler(loginFailureUri);
  handler.setAllowSessionCreation(false);
  return new StormpathAuthenticationFailureHandler(handler,stormpathRequestEventPublisher);
}","public AuthenticationFailureHandler stormpathAuthenticationFailureHandler(){
  String loginFailureUri=loginUri + ""String_Node_Str"";
  SimpleUrlAuthenticationFailureHandler handler=new SimpleUrlAuthenticationFailureHandler(loginFailureUri);
  handler.setAllowSessionCreation(false);
  return new StormpathAuthenticationFailureHandler(handler,stormpathRequestEventPublisher,stormpathLoginErrorModelFactory());
}",0.9566326530612244
99388,"@Override public List<String> toErrors(HttpServletRequest request,Form form,Exception exception){
  String query=Strings.clean(request.getQueryString());
  if (query != null && query.contains(""String_Node_Str"")) {
    return Collections.singletonList(getInvalidLoginMessage(request));
  }
  return null;
}","@Override public List<String> toErrors(HttpServletRequest request,Form form,Exception exception){
  if (exception instanceof AuthenticationServiceException) {
    if (exception.getMessage() != null && exception.getMessage().contains(UNSUCCESSFUL_LOGIN_STORMPATH_ERROR)) {
      return Collections.singletonList(getInvalidLoginMessage(request));
    }
  }
  return null;
}",0.4201183431952662
99389,"@Override public void onAuthenticationFailure(HttpServletRequest request,HttpServletResponse response,AuthenticationException exception) throws IOException, ServletException {
  try {
    this.delegate.onAuthenticationFailure(request,response,exception);
  }
  finally {
    FailedAuthenticationRequestEvent event=createFailureEvent(request,response,exception);
    publisher.publish(event);
  }
}","@Override public void onAuthenticationFailure(HttpServletRequest request,HttpServletResponse response,AuthenticationException exception) throws IOException, ServletException {
  try {
    request.getSession().setAttribute(SPRING_SECURITY_AUTHENTICATION_FAILED_KEY,errorModelFactory.toErrors(request,null,exception));
    this.delegate.onAuthenticationFailure(request,response,exception);
  }
  finally {
    FailedAuthenticationRequestEvent event=createFailureEvent(request,response,exception);
    publisher.publish(event);
  }
}",0.8565264293419633
99390,"public StormpathAuthenticationFailureHandler(AuthenticationFailureHandler delegate,Publisher<RequestEvent> publisher){
  Assert.notNull(delegate,""String_Node_Str"");
  Assert.notNull(publisher,""String_Node_Str"");
  this.delegate=delegate;
  this.publisher=publisher;
}","public StormpathAuthenticationFailureHandler(AuthenticationFailureHandler delegate,Publisher<RequestEvent> publisher,ErrorModelFactory errorModelFactory){
  Assert.notNull(delegate,""String_Node_Str"");
  Assert.notNull(publisher,""String_Node_Str"");
  Assert.notNull(errorModelFactory,""String_Node_Str"");
  this.delegate=delegate;
  this.publisher=publisher;
  this.errorModelFactory=errorModelFactory;
}",0.7982062780269058
99391,"private String getInvalidLoginMessage(HttpServletRequest request){
  Config config=getConfig(request);
  MessageSource messageSource=null;
  try {
    messageSource=config.getInstance(MESSAGE_SOURCE);
  }
 catch (  ServletException se) {
    messageSource=new DefaultMessageSource();
  }
  return messageSource.getMessage(INVALID_LOGIN_MESSAGE,request.getLocale());
}","private String getInvalidLoginMessage(HttpServletRequest request){
  MessageSource messageSource=null;
  try {
    Config config=getConfig(request);
    messageSource=config.getInstance(MESSAGE_SOURCE);
  }
 catch (  ServletException se) {
    messageSource=new DefaultMessageSource();
  }
catch (  IllegalArgumentException iae) {
    messageSource=new DefaultMessageSource();
  }
  return messageSource.getMessage(INVALID_LOGIN_MESSAGE,request.getLocale());
}",0.781136638452237
99392,"protected AuthenticationRequest createAuthenticationRequest(Authentication authentication){
  String username=(String)authentication.getPrincipal();
  String password=(String)authentication.getCredentials();
  return UsernamePasswordRequest.builder().setUsernameOrEmail(username).setPassword(password).build();
}","protected AuthenticationRequest createAuthenticationRequest(Authentication authentication){
  String username=(String)authentication.getPrincipal();
  String password=(String)authentication.getCredentials();
  if (!Strings.hasText(username)) {
    throw new AuthenticationServiceException(""String_Node_Str"");
  }
  return UsernamePasswordRequest.builder().setUsernameOrEmail(username).setPassword(password).build();
}",0.8559670781893004
99393,"public AuthorizationHeaderAccountResolver(HttpAuthenticator authenticator){
  Assert.notNull(authenticator,""String_Node_Str"");
  this.httpAuthenticator=authenticator;
}","public AuthorizationHeaderAccountResolver(HttpAuthenticator authenticator,String idSiteResultURI){
  Assert.notNull(authenticator,""String_Node_Str"");
  Assert.notNull(authenticator,""String_Node_Str"");
  this.httpAuthenticator=authenticator;
  this.idSiteResultURI=idSiteResultURI;
}",0.7466666666666667
99394,"@Override public Account get(HttpServletRequest request,HttpServletResponse response){
  String authzHeaderValue=request.getHeader(""String_Node_Str"");
  if (authzHeaderValue != null) {
    try {
      HttpAuthenticationResult result=httpAuthenticator.authenticate(request,response);
      return result.getAuthenticationResult().getAccount();
    }
 catch (    HttpAuthenticationException e) {
      if (log.isDebugEnabled()) {
        String msg=""String_Node_Str"" + e.getMessage();
        msg+=""String_Node_Str"";
        log.debug(msg,e);
      }
      request.setAttribute(HttpAuthenticationException.class.getName(),e);
    }
  }
  return null;
}","@Override public Account get(HttpServletRequest request,HttpServletResponse response){
  String authzHeaderValue=request.getHeader(""String_Node_Str"");
  if (authzHeaderValue != null) {
    if (request.getRequestURI().contains(idSiteResultURI)) {
      JwtWrapper jwtWrapper=new JwtWrapper(request.getParameter(""String_Node_Str""));
      Map jsonPayload=jwtWrapper.getJsonPayloadAsMap();
      IdSiteResultStatus resultStatus=IdSiteResultStatus.valueOf((String)jsonPayload.get(STATUS));
      if (resultStatus.equals(IdSiteResultStatus.LOGOUT)) {
        return null;
      }
    }
    try {
      HttpAuthenticationResult result=httpAuthenticator.authenticate(request,response);
      return result.getAuthenticationResult().getAccount();
    }
 catch (    HttpAuthenticationException e) {
      if (log.isDebugEnabled()) {
        String msg=""String_Node_Str"" + e.getMessage();
        msg+=""String_Node_Str"";
        log.debug(msg,e);
      }
      request.setAttribute(HttpAuthenticationException.class.getName(),e);
    }
  }
  return null;
}",0.7665094339622641
99395,"@Override protected Resolver<Account> createInstance(ServletContext servletContext) throws Exception {
  Config config=ConfigResolver.INSTANCE.getConfig(servletContext);
  HttpAuthenticator httpAuthenticator=config.getInstance(HTTP_AUTHENTICATOR);
  return new AuthorizationHeaderAccountResolver(httpAuthenticator);
}","@Override protected Resolver<Account> createInstance(ServletContext servletContext) throws Exception {
  Config config=ConfigResolver.INSTANCE.getConfig(servletContext);
  HttpAuthenticator httpAuthenticator=config.getInstance(HTTP_AUTHENTICATOR);
  return new AuthorizationHeaderAccountResolver(httpAuthenticator,ID_SITE_RESULT_URI);
}",0.9709035222052068
99396,"public void filter(HttpServletRequest request,HttpServletResponse response,FilterChain chain) throws IOException, ServletException {
  final boolean debug=logger.isDebugEnabled();
  String accessToken=tokenExtractor.getAccessToken(request);
  if (accessToken == null) {
    if (stateless && isAuthenticated()) {
      if (debug) {
        logger.debug(""String_Node_Str"");
      }
      SecurityContextHolder.clearContext();
    }
    if (debug) {
      logger.debug(""String_Node_Str"");
    }
  }
 else {
    Account account=AccountResolver.INSTANCE.getAccount(request);
    Authentication authentication=new ProviderAuthenticationToken(account);
    authentication=authenticationProvider.authenticate(authentication);
    SecurityContextHolder.clearContext();
    SecurityContextHolder.getContext().setAuthentication(authentication);
  }
  chain.doFilter(request,response);
}","public void filter(HttpServletRequest request,HttpServletResponse response,FilterChain chain) throws IOException, ServletException {
  final boolean debug=logger.isDebugEnabled();
  String accessToken=tokenExtractor.getAccessToken(request);
  if (accessToken == null) {
    if (stateless && isAuthenticated()) {
      if (debug) {
        logger.debug(""String_Node_Str"");
      }
      SecurityContextHolder.clearContext();
    }
    if (debug) {
      logger.debug(""String_Node_Str"");
    }
  }
 else {
    Account account=AccountResolver.INSTANCE.getAccount(request);
    if (account != null) {
      Authentication authentication=new ProviderAuthenticationToken(account);
      authentication=authenticationProvider.authenticate(authentication);
      SecurityContextHolder.clearContext();
      SecurityContextHolder.getContext().setAuthentication(authentication);
    }
  }
  chain.doFilter(request,response);
}",0.977107761027359
99397,"public Resolver<Account> stormpathAuthorizationHeaderAccountResolver(){
  return new AuthorizationHeaderAccountResolver(stormpathAuthorizationHeaderAuthenticator());
}","public Resolver<Account> stormpathAuthorizationHeaderAccountResolver(){
  return new AuthorizationHeaderAccountResolver(stormpathAuthorizationHeaderAuthenticator(),idSiteResultUri);
}",0.9542857142857144
99398,"/** 
 * Only users who have a Custom Data entry in their Stormpath Account or Group containing something like <code>""springSecurityPermissions"":[""say:*""]</code> or <code>""springSecurityGrantedAuthorities"":[""say:hello""]</code> will be allowed to execute this method.
 */
@PreAuthorize(""String_Node_Str"" + MY_GROUP + ""String_Node_Str"") public String sayHello(Account account){
  return ""String_Node_Str"" + account.getGivenName() + ""String_Node_Str"";
}","/** 
 * Only users who have a Custom Data entry in their Stormpath Account or Group containing something like <code>""springSecurityPermissions"":[""say:*""]</code> or <code>""springSecurityPermissions"":[""say:hello""]</code> will be allowed to execute this method.
 */
@PreAuthorize(""String_Node_Str"" + MY_GROUP + ""String_Node_Str"") public String sayHello(Account account){
  return ""String_Node_Str"" + account.getGivenName() + ""String_Node_Str"";
}",0.9696969696969696
99399,"@Override public ResourceDataResult filter(ResourceDataRequest request,FilterChain chain){
  if (request.getAction() == ResourceAction.DELETE) {
    return chain.filter(request);
  }
  Class clazz=request.getResourceClass();
  if (!ApiKey.class.isAssignableFrom(clazz) || ApiKeyList.class.isAssignableFrom(clazz)) {
    return chain.filter(request);
  }
  QueryString query=request.getUri().getQuery();
  boolean isQueryEmpty=Collections.isEmpty(query);
  boolean addEncryptionCriteria=isQueryEmpty || !query.containsKey(ENCRYPT_SECRET);
  boolean addEncryptionMetadata=addEncryptionCriteria || Boolean.parseBoolean(query.get(ENCRYPT_SECRET));
  if (addEncryptionCriteria) {
    DefaultApiKeyCriteria criteria=new DefaultApiKeyCriteria();
    criteria.add(new DefaultEqualsExpressionFactory(ENCRYPT_SECRET).eq(Boolean.TRUE));
    criteria.add(new DefaultEqualsExpressionFactory(ENCRYPTION_KEY_SIZE).eq(DEFAULT_ENCRYPTION_SIZE));
    criteria.add(new DefaultEqualsExpressionFactory(ENCRYPTION_KEY_ITERATIONS).eq(DEFAULT_ENCRYPTION_ITERATIONS));
    criteria.add(new DefaultEqualsExpressionFactory(ENCRYPTION_KEY_SALT).eq(saltGenerator.generate()));
    QueryString encryptionQueryParams=queryStringFactory.createQueryString(criteria);
    if (query == null) {
      CanonicalUri uri=new DefaultCanonicalUri(request.getUri().getAbsolutePath(),encryptionQueryParams);
      request=new DefaultResourceDataRequest(request.getAction(),uri,request.getResourceClass(),request.getData());
    }
 else {
      query.putAll(encryptionQueryParams);
    }
  }
  ResourceDataResult result=chain.filter(request);
  if (addEncryptionMetadata) {
    query=request.getUri().getQuery();
    Map<String,Object> encryptionMetadata=new LinkedHashMap<String,Object>();
    String salt=query.get(ENCRYPTION_KEY_SALT);
    Integer size=query.containsKey(ENCRYPTION_KEY_SIZE) ? Integer.valueOf(query.get(ENCRYPTION_KEY_SIZE)) : DEFAULT_ENCRYPTION_SIZE;
    Integer iterations=query.containsKey(ENCRYPTION_KEY_ITERATIONS) ? Integer.valueOf(query.get(ENCRYPTION_KEY_ITERATIONS)) : DEFAULT_ENCRYPTION_ITERATIONS;
    encryptionMetadata.put(ENCRYPTION_KEY_SALT,salt);
    encryptionMetadata.put(ENCRYPTION_KEY_SIZE,size);
    encryptionMetadata.put(ENCRYPTION_KEY_ITERATIONS,iterations);
    Map<String,Object> data=result.getData();
    data.put(ENCRYPTION_METADATA,encryptionMetadata);
  }
  return result;
}","@Override public ResourceDataResult filter(ResourceDataRequest request,FilterChain chain){
  if (request.getAction() == ResourceAction.DELETE) {
    return chain.filter(request);
  }
  Class clazz=request.getResourceClass();
  boolean isCollection=false;
  if (!(ApiKey.class.isAssignableFrom(clazz) || (isCollection=ApiKeyList.class.isAssignableFrom(clazz)))) {
    return chain.filter(request);
  }
  QueryString query=request.getUri().getQuery();
  boolean isQueryEmpty=Collections.isEmpty(query);
  boolean addEncryptionCriteria=isQueryEmpty || !query.containsKey(ENCRYPT_SECRET);
  boolean addEncryptionMetadata=addEncryptionCriteria || Boolean.parseBoolean(query.get(ENCRYPT_SECRET));
  if (addEncryptionCriteria) {
    DefaultApiKeyCriteria criteria=new DefaultApiKeyCriteria();
    criteria.add(new DefaultEqualsExpressionFactory(ENCRYPT_SECRET).eq(Boolean.TRUE));
    criteria.add(new DefaultEqualsExpressionFactory(ENCRYPTION_KEY_SIZE).eq(DEFAULT_ENCRYPTION_SIZE));
    criteria.add(new DefaultEqualsExpressionFactory(ENCRYPTION_KEY_ITERATIONS).eq(DEFAULT_ENCRYPTION_ITERATIONS));
    criteria.add(new DefaultEqualsExpressionFactory(ENCRYPTION_KEY_SALT).eq(saltGenerator.generate()));
    QueryString encryptionQueryParams=queryStringFactory.createQueryString(criteria);
    if (query == null) {
      CanonicalUri uri=new DefaultCanonicalUri(request.getUri().getAbsolutePath(),encryptionQueryParams);
      request=new DefaultResourceDataRequest(request.getAction(),uri,request.getResourceClass(),request.getData());
    }
 else {
      query.putAll(encryptionQueryParams);
    }
  }
  ResourceDataResult result=chain.filter(request);
  if (addEncryptionMetadata) {
    query=request.getUri().getQuery();
    Map<String,Object> encryptionMetadata=new LinkedHashMap<String,Object>();
    String salt=query.get(ENCRYPTION_KEY_SALT);
    Integer size=query.containsKey(ENCRYPTION_KEY_SIZE) ? Integer.valueOf(query.get(ENCRYPTION_KEY_SIZE)) : DEFAULT_ENCRYPTION_SIZE;
    Integer iterations=query.containsKey(ENCRYPTION_KEY_ITERATIONS) ? Integer.valueOf(query.get(ENCRYPTION_KEY_ITERATIONS)) : DEFAULT_ENCRYPTION_ITERATIONS;
    encryptionMetadata.put(ENCRYPTION_KEY_SALT,salt);
    encryptionMetadata.put(ENCRYPTION_KEY_SIZE,size);
    encryptionMetadata.put(ENCRYPTION_KEY_ITERATIONS,iterations);
    Map<String,Object> data=result.getData();
    if (DefaultApiKeyList.isCollectionResource(data)) {
      @SuppressWarnings(""String_Node_Str"") Collection<Map<String,Object>> items=(Collection<Map<String,Object>>)data.get(DefaultApiKeyList.ITEMS_PROPERTY_NAME);
      for (      Map<String,Object> item : items) {
        item.put(ENCRYPTION_METADATA,encryptionMetadata);
      }
    }
 else {
      data.put(ENCRYPTION_METADATA,encryptionMetadata);
    }
  }
  return result;
}",0.908246225319396
99400,"@Override public ResourceDataResult filter(ResourceDataRequest request,FilterChain chain){
  ResourceDataResult result=chain.filter(request);
  if (request.getAction() == ResourceAction.DELETE) {
    return result;
  }
  Class<? extends Resource> clazz=result.getResourceClass();
  if (!(ApiKey.class.isAssignableFrom(clazz) || ApiKeyList.class.isAssignableFrom(clazz))) {
    return result;
  }
  Map<String,Object> data=result.getData();
  if (!data.containsKey(ENCRYPTION_METADATA)) {
    return result;
  }
  @SuppressWarnings(""String_Node_Str"") Map<String,Object> metadata=(Map<String,Object>)data.get(ENCRYPTION_METADATA);
  byte[] base64Salt=((String)metadata.get(ENCRYPTION_KEY_SALT)).getBytes();
  Integer iterations=(Integer)metadata.get(ENCRYPTION_KEY_ITERATIONS);
  Integer size=(Integer)metadata.get(ENCRYPTION_KEY_SIZE);
  EncryptionService service=new ApiKeySecretEncryptionService.Builder().setPassword(clientApiKey.getSecret().toCharArray()).setKeySize(size).setIterations(iterations).setBase64Salt(base64Salt).build();
  String encryptedSecret=(String)data.get(SECRET_PROPERTY_NAME);
  Map<String,Object> clonedData=new LinkedHashMap<String,Object>();
  for (  Map.Entry<String,Object> entry : data.entrySet()) {
    String key=entry.getKey();
    if (key.equals(ENCRYPTION_METADATA)) {
      continue;
    }
    if (key.equals(SECRET_PROPERTY_NAME)) {
      clonedData.put(key,service.decryptBase64String(encryptedSecret));
      continue;
    }
    clonedData.put(key,entry.getValue());
  }
  return new DefaultResourceDataResult(result.getAction(),result.getUri(),clazz,clonedData);
}","@Override public ResourceDataResult filter(ResourceDataRequest request,FilterChain chain){
  ResourceDataResult result=chain.filter(request);
  if (request.getAction() == ResourceAction.DELETE) {
    return result;
  }
  Class<? extends Resource> clazz=result.getResourceClass();
  if (!(ApiKey.class.isAssignableFrom(clazz) || ApiKeyList.class.isAssignableFrom(clazz))) {
    return result;
  }
  Map<String,Object> data=result.getData();
  if (DefaultApiKeyList.isCollectionResource(data)) {
    @SuppressWarnings(""String_Node_Str"") Collection<Map<String,Object>> items=(Collection<Map<String,Object>>)data.get(DefaultApiKeyList.ITEMS_PROPERTY_NAME);
    if (items.isEmpty()) {
      return result;
    }
    List<Map<String,Object>> clonedItems=new ArrayList<Map<String,Object>>(items.size());
    for (    Map<String,Object> item : items) {
      clonedItems.add(clone(item));
    }
    data.put(DefaultApiKeyList.ITEMS_PROPERTY_NAME,clonedItems);
    return result;
  }
  return new DefaultResourceDataResult(result.getAction(),result.getUri(),clazz,clone(data));
}",0.5555140186915888
99401,"/** 
 * Returns   {@code true} if the specified data map represents a materialized collection resource data set, {@code false} otherwise.
 * @param props the data properties to test
 * @return {@code true} if the specified data map represents a materialized collection resource data set, {@code false} otherwise.
 * @since 1.0.RC4.3
 */
public static boolean isCollectionResource(Map<String,?> props){
  return isMaterialized(props) && (props.get(""String_Node_Str"") instanceof Iterable);
}","/** 
 * Returns   {@code true} if the specified data map represents a materialized collection resource data set, {@code false} otherwise.
 * @param props the data properties to test
 * @return {@code true} if the specified data map represents a materialized collection resource data set, {@code false} otherwise.
 * @since 1.0.RC4.3
 */
public static boolean isCollectionResource(Map<String,?> props){
  return isMaterialized(props) && (props.get(ITEMS_PROPERTY_NAME) instanceof Iterable);
}",0.9693877551020408
99402,"/** 
 * Returns   {@code true} if the specified data map represents a materialized instance resource data set, {@code false} otherwise.
 * @param props the data properties to test
 * @return {@code true} if the specified data map represents a materialized instance resource data set, {@code false} otherwise.
 * @since 1.0.RC4.3
 */
public static boolean isInstanceResource(Map<String,?> props){
  return isMaterialized(props) && !props.containsKey(""String_Node_Str"");
}","/** 
 * Returns   {@code true} if the specified data map represents a materialized instance resource data set, {@code false} otherwise.
 * @param props the data properties to test
 * @return {@code true} if the specified data map represents a materialized instance resource data set, {@code false} otherwise.
 * @since 1.0.RC4.3
 */
public static boolean isInstanceResource(Map<String,?> props){
  return isMaterialized(props) && !props.containsKey(AbstractCollectionResource.ITEMS_PROPERTY_NAME);
}",0.9411764705882352
99403,"@SuppressWarnings(""String_Node_Str"") private <T extends Resource,R extends Resource>R save(String href,final T resource,Class<? extends R> returnType,QueryString qs){
  Assert.hasText(href,""String_Node_Str"");
  Assert.notNull(resource,""String_Node_Str"");
  Assert.notNull(returnType,""String_Node_Str"");
  Assert.isInstanceOf(AbstractResource.class,resource);
  Assert.isTrue(!CollectionResource.class.isAssignableFrom(resource.getClass()),""String_Node_Str"");
  SanitizedQuery sanitized=QuerySanitizer.sanitize(href,qs);
  href=sanitized.getHrefWithoutQuery();
  href=ensureFullyQualified(href);
  final AbstractResource abstractResource=(AbstractResource)resource;
  LinkedHashMap<String,Object> props=toMap(abstractResource,true);
  String bodyString=mapMarshaller.marshal(props);
  StringInputStream body=new StringInputStream(bodyString);
  long length=body.available();
  QueryString filteredQs=queryStringFilterProcessor.process(returnType,qs);
  Request request=new DefaultRequest(HttpMethod.POST,href,filteredQs,null,body,length);
  Response response=execute(request);
  Map<String,Object> responseBody=getBody(response);
  int httpStatus=response.getHttpStatus();
  if (ProviderAccountResult.class.isAssignableFrom(returnType) && (httpStatus == 200 || httpStatus == 201)) {
    if (httpStatus == 200) {
      responseBody.put(""String_Node_Str"",false);
    }
 else {
      responseBody.put(""String_Node_Str"",true);
    }
  }
  Map<String,?> returnResponseBody=filterResourceData(returnType,filteredQs,responseBody);
  if (Collections.isEmpty(responseBody)) {
    return null;
  }
  boolean emailVerification=resource instanceof EmailVerificationToken && returnType.equals(Account.class);
  if (emailVerification && isCachingEnabled()) {
    String accountHref=(String)responseBody.get(HREF_PROP_NAME);
    if (Strings.hasText(accountHref)) {
      Cache<String,?> cache=getCache(Account.class);
      cache.remove(accountHref);
    }
  }
  boolean doNotCache=(resource instanceof PasswordResetToken && PasswordResetToken.class.isAssignableFrom(returnType)) || emailVerification;
  if (isCacheUpdateEnabled(returnType) && !doNotCache) {
    if (Strings.hasText((String)returnResponseBody.get(HREF_PROP_NAME))) {
      if (!returnType.isAssignableFrom(ProviderAccountResult.class)) {
        cache(returnType,responseBody,filteredQs);
      }
    }
  }
  if (resource instanceof AbstractExtendableInstanceResource && isCacheUpdateEnabled(CustomData.class)) {
    cacheNestedCustomData(href,props);
  }
  if (isMaterialized(returnResponseBody)) {
    returnResponseBody=toEnlistment(returnResponseBody);
  }
  if (returnType.equals(abstractResource.getClass())) {
    abstractResource.setProperties((Map<String,Object>)returnResponseBody);
  }
  return resourceFactory.instantiate(returnType,returnResponseBody);
}","@SuppressWarnings(""String_Node_Str"") private <T extends Resource,R extends Resource>R save(String href,final T resource,Class<? extends R> returnType,QueryString qs){
  Assert.hasText(href,""String_Node_Str"");
  Assert.notNull(resource,""String_Node_Str"");
  Assert.notNull(returnType,""String_Node_Str"");
  Assert.isInstanceOf(AbstractResource.class,resource);
  Assert.isTrue(!CollectionResource.class.isAssignableFrom(resource.getClass()),""String_Node_Str"");
  SanitizedQuery sanitized=QuerySanitizer.sanitize(href,qs);
  qs=sanitized.getQuery();
  href=sanitized.getHrefWithoutQuery();
  href=ensureFullyQualified(href);
  final AbstractResource abstractResource=(AbstractResource)resource;
  LinkedHashMap<String,Object> props=toMap(abstractResource,true);
  String bodyString=mapMarshaller.marshal(props);
  StringInputStream body=new StringInputStream(bodyString);
  long length=body.available();
  QueryString filteredQs=queryStringFilterProcessor.process(returnType,qs);
  Request request=new DefaultRequest(HttpMethod.POST,href,filteredQs,null,body,length);
  Response response=execute(request);
  Map<String,Object> responseBody=getBody(response);
  int httpStatus=response.getHttpStatus();
  if (ProviderAccountResult.class.isAssignableFrom(returnType) && (httpStatus == 200 || httpStatus == 201)) {
    if (httpStatus == 200) {
      responseBody.put(""String_Node_Str"",false);
    }
 else {
      responseBody.put(""String_Node_Str"",true);
    }
  }
  Map<String,?> returnResponseBody=filterResourceData(returnType,filteredQs,responseBody);
  if (Collections.isEmpty(responseBody)) {
    return null;
  }
  boolean emailVerification=resource instanceof EmailVerificationToken && returnType.equals(Account.class);
  if (emailVerification && isCachingEnabled()) {
    String accountHref=(String)responseBody.get(HREF_PROP_NAME);
    if (Strings.hasText(accountHref)) {
      Cache<String,?> cache=getCache(Account.class);
      cache.remove(accountHref);
    }
  }
  boolean doNotCache=(resource instanceof PasswordResetToken && PasswordResetToken.class.isAssignableFrom(returnType)) || emailVerification;
  if (isCacheUpdateEnabled(returnType) && !doNotCache) {
    if (Strings.hasText((String)returnResponseBody.get(HREF_PROP_NAME))) {
      if (!returnType.isAssignableFrom(ProviderAccountResult.class)) {
        cache(returnType,responseBody,filteredQs);
      }
    }
  }
  if (resource instanceof AbstractExtendableInstanceResource && isCacheUpdateEnabled(CustomData.class)) {
    cacheNestedCustomData(href,props);
  }
  if (isMaterialized(returnResponseBody)) {
    returnResponseBody=toEnlistment(returnResponseBody);
  }
  if (returnType.equals(abstractResource.getClass())) {
    abstractResource.setProperties((Map<String,Object>)returnResponseBody);
  }
  return resourceFactory.instantiate(returnType,returnResponseBody);
}",0.9952322090764611
99404,"public JwtWrapper(String jwt){
  if (!Strings.hasText(jwt)) {
    throw new InvalidJwtException(InvalidJwtException.MISSING_JWT_ERROR);
  }
  StringTokenizer tokenizer=new StringTokenizer(jwt,JwtConstants.JWT_TOKENS_SEPARATOR);
  if (tokenizer.countTokens() != 3) {
    throw new InvalidJwtException(InvalidJwtException.INVALID_JWT_VALUE_FORMAT_ERROR);
  }
  this.base64JwtHeader=tokenizer.nextToken();
  this.base64JsonPayload=tokenizer.nextToken();
  this.base64JwtSignature=tokenizer.nextToken();
  this.mapMarshaller=new JacksonMapMarshaller();
}","public JwtWrapper(String jwt){
  if (!Strings.hasText(jwt)) {
    throw new InvalidJwtException(InvalidJwtException.JWT_REQUIRED_ERROR);
  }
  StringTokenizer tokenizer=new StringTokenizer(jwt,JwtConstants.JWT_TOKENS_SEPARATOR);
  if (tokenizer.countTokens() != 3) {
    throw new InvalidJwtException(InvalidJwtException.JWT_INVALID_VALUE_ERROR);
  }
  this.base64JwtHeader=tokenizer.nextToken();
  this.base64JsonPayload=tokenizer.nextToken();
  this.base64JwtSignature=tokenizer.nextToken();
  this.mapMarshaller=new JacksonMapMarshaller();
}",0.9707495429616088
99405,"@Override public boolean hasNonce(String nonce){
  Assert.hasText(nonce);
  if (defaultDataStore.isCachingEnabled()) {
    return false;
  }
  Cache<String,Map<String,?>> cache=defaultDataStore.getCache(Nonce.class);
  Map<String,?> values=cache.get(nonce);
  return values != null;
}","@Override public boolean hasNonce(String nonce){
  Assert.hasText(nonce);
  if (!defaultDataStore.isCachingEnabled()) {
    return false;
  }
  Cache<String,Map<String,?>> cache=defaultDataStore.getCache(Nonce.class);
  Map<String,?> values=cache.get(nonce);
  return values != null;
}",0.9982425307557118
99406,"@Override public void putNonce(String nonce){
  Assert.hasText(nonce);
  if (defaultDataStore.isCachingEnabled()) {
    return;
  }
  Cache<String,Map<String,?>> cache=defaultDataStore.getCache(Nonce.class);
  DefaultNonce defaultNonce=new DefaultNonce(nonce);
  cache.put(defaultNonce.getValue(),defaultNonce.getProperties());
}","@Override public void putNonce(String nonce){
  Assert.hasText(nonce);
  if (!defaultDataStore.isCachingEnabled()) {
    return;
  }
  Cache<String,Map<String,?>> cache=defaultDataStore.getCache(Nonce.class);
  DefaultNonce defaultNonce=new DefaultNonce(nonce);
  cache.put(defaultNonce.getValue(),defaultNonce.getProperties());
}",0.9984825493171472
99407,"@Override public AccountResult resolve(){
  nonceStore=nonceStore == null ? new DefaultNonceStore((DefaultDataStore)dataStore) : nonceStore;
  JwtWrapper jwtWrapper=new JwtWrapper(jwtResponse);
  Map jsonPayload=jwtWrapper.getJsonPayloadAsMap();
  String apiKeyId=getRequiredValue(jsonPayload,AUDIENCE_PARAM_NAME);
  getJwtSignatureValidator(apiKeyId).validate(jwtWrapper);
  Number expire=getRequiredValue(jsonPayload,EXPIRE_PARAM_NAME);
  verifyJwtIsNotExpired(expire.longValue());
  String responseNonce=getRequiredValue(jsonPayload,RESPONSE_NONCE_PARAMETER);
  if (nonceStore.hasNonce(responseNonce)) {
    throw new InvalidJwtException(InvalidJwtException.ALREADY_USED_JWT_ERROR);
  }
  nonceStore.putNonce(responseNonce);
  String issuer=getRequiredValue(jsonPayload,ISSUER_PARAM_NAME);
  String accountHref=getRequiredValue(jsonPayload,SUBJECT_PARAM_NAME);
  Boolean isNewAccount=getRequiredValue(jsonPayload,IS_NEW_SUBJECT_PARAM_NAME);
  String state=getOptionalValue(jsonPayload,STATE_PARAM_NAME);
  Map<String,Object> account=new HashMap<String,Object>();
  account.put(DefaultAccountResult.HREF_PROP_NAME,accountHref);
  Map<String,Object> properties=new LinkedHashMap<String,Object>();
  properties.put(DefaultAccountResult.ACCOUNT.getName(),account);
  properties.put(DefaultAccountResult.NEW_ACCOUNT.getName(),isNewAccount);
  properties.put(DefaultAccountResult.STATE.getName(),state);
  return new DefaultAccountResult(dataStore,properties);
}","@Override public AccountResult resolve(){
  JwtWrapper jwtWrapper=new JwtWrapper(jwtResponse);
  Map jsonPayload=jwtWrapper.getJsonPayloadAsMap();
  String apiKeyId=getRequiredValue(jsonPayload,AUDIENCE_PARAM_NAME);
  getJwtSignatureValidator(apiKeyId).validate(jwtWrapper);
  Number expire=getRequiredValue(jsonPayload,EXPIRE_PARAM_NAME);
  verifyJwtIsNotExpired(expire.longValue());
  String responseNonce=getRequiredValue(jsonPayload,RESPONSE_NONCE_PARAMETER);
  if (nonceStore.hasNonce(responseNonce)) {
    throw new InvalidJwtException(InvalidJwtException.ALREADY_USED_JWT_ERROR);
  }
  nonceStore.putNonce(responseNonce);
  String issuer=getRequiredValue(jsonPayload,ISSUER_PARAM_NAME);
  String accountHref=getRequiredValue(jsonPayload,SUBJECT_PARAM_NAME);
  Boolean isNewAccount=getRequiredValue(jsonPayload,IS_NEW_SUBJECT_PARAM_NAME);
  String state=getOptionalValue(jsonPayload,STATE_PARAM_NAME);
  Map<String,Object> account=new HashMap<String,Object>();
  account.put(DefaultAccountResult.HREF_PROP_NAME,accountHref);
  Map<String,Object> properties=new LinkedHashMap<String,Object>();
  properties.put(DefaultAccountResult.ACCOUNT.getName(),account);
  properties.put(DefaultAccountResult.NEW_ACCOUNT.getName(),isNewAccount);
  properties.put(DefaultAccountResult.STATE.getName(),state);
  return new DefaultAccountResult(dataStore,properties);
}",0.9648811635331678
99408,"public DefaultSsoAccountResolver(InternalDataStore dataStore,Application application,Object httpRequest){
  Assert.notNull(dataStore,""String_Node_Str"");
  Assert.notNull(application,""String_Node_Str"");
  Assert.notNull(httpRequest,""String_Node_Str"");
  this.dataStore=dataStore;
  this.application=application;
  this.jwtResponse=getJwtResponse(httpRequest);
}","public DefaultSsoAccountResolver(InternalDataStore dataStore,Application application,Object httpRequest){
  Assert.notNull(dataStore,""String_Node_Str"");
  Assert.notNull(application,""String_Node_Str"");
  Assert.notNull(httpRequest,""String_Node_Str"");
  this.dataStore=dataStore;
  this.application=application;
  this.jwtResponse=getJwtResponse(httpRequest);
  this.nonceStore=new DefaultNonceStore((DefaultDataStore)dataStore);
}",0.9113924050632912
99409,"private String getJwtResponse(Object httpRequest){
  String jwtResponse;
  if (HttpRequest.class.isAssignableFrom(httpRequest.getClass())) {
    jwtResponse=((HttpRequest)httpRequest).getParameter(JWR_RESPONSE_PARAM_NAME);
  }
 else {
    if (HTTP_SERVLET_REQUEST_WRAPPER_CLASS == null) {
      throw new RuntimeException(""String_Node_Str"" + httpRequest.getClass().getName());
    }
    Constructor<? extends HttpServletRequestWrapper> ctor=Classes.getConstructor(HTTP_SERVLET_REQUEST_WRAPPER_CLASS,Object.class);
    HttpServletRequestWrapper httpServletRequestWrapper=Classes.instantiate(ctor,httpRequest);
    jwtResponse=httpServletRequestWrapper.getParameter(JWR_RESPONSE_PARAM_NAME);
  }
  return jwtResponse;
}","private String getJwtResponse(Object httpRequest){
  String jwtResponse;
  if (HttpRequest.class.isAssignableFrom(httpRequest.getClass())) {
    jwtResponse=((HttpRequest)httpRequest).getParameter(JWR_RESPONSE_PARAM_NAME);
  }
 else {
    if (HTTP_SERVLET_REQUEST_WRAPPER_CLASS == null) {
      throw new RuntimeException(""String_Node_Str"" + httpRequest.getClass().getName());
    }
    Constructor<? extends HttpServletRequestWrapper> ctor=Classes.getConstructor(HTTP_SERVLET_REQUEST_WRAPPER_CLASS,Object.class);
    HttpServletRequestWrapper httpServletRequestWrapper=Classes.instantiate(ctor,httpRequest);
    jwtResponse=httpServletRequestWrapper.getParameter(JWR_RESPONSE_PARAM_NAME);
  }
  if (!Strings.hasText(jwtResponse)) {
    throw new InvalidJwtException(InvalidJwtException.JWT_REQUIRED_ERROR);
  }
  return jwtResponse;
}",0.9149484536082474
99410,"/** 
 * Creates a new   {@link ApiAuthenticationRequestBuilder ApiAuthenticationRequestBuilder}. The builder can be used to customize an   {@code Api} authentication.
 * @return a new {@link ApiAuthenticationRequestBuilder}.
 * @throws IllegalArgumentException - If {@code httpRequest} is null.
 * @see Application#authenticateOauth(Object)
 * @since 1.0.RC
 */
ApiAuthenticationRequestBuilder authenticate(Object httpRequest);","/** 
 * Creates a new   {@link ApiAuthenticationRequestBuilder ApiAuthenticationRequestBuilder}. The builder can be used to customize an   {@code Api} authentication.
 * @return a new {@link ApiAuthenticationRequestBuilder}.
 * @throws IllegalArgumentException - If {@code httpRequest} is null or not supported.
 * @see Application#authenticateOauth(Object)
 * @since 1.0.RC
 */
ApiAuthenticationRequestBuilder authenticate(Object httpRequest);",0.9804822043628014
99411,"/** 
 * Creates a new   {@link com.stormpath.sdk.oauth.authc.OauthAuthenticationRequestBuilder OauthAuthenticationRequestBuilder}. The builder can be used to customize an   {@code Api} authentication via Oauth.<pre> <b>application.authenticateOauth(httpServletRequest)</b> .execute() </pre>
 * @return a new {@link OauthAuthenticationRequestBuilder}.
 * @throws IllegalStateException    - If {@code com.stormpath.sdk.impl.oauth.authc.DefaultOauthAuthenticationRequestBuilder} class couldn't be found in the classpath.
 * @throws IllegalArgumentException - If {@code httpServletRequest} is null.
 * @see Application#authenticate(Object)
 * @since 1.0.RC
 */
OauthAuthenticationRequestBuilder authenticateOauth(Object httpRequest);","/** 
 * Creates a new   {@link com.stormpath.sdk.oauth.authc.OauthAuthenticationRequestBuilder OauthAuthenticationRequestBuilder}. The builder can be used to customize an   {@code Api} authentication via Oauth.Per the <a href=""http://tools.ietf.org/html/rfc6749#section-2.3>OAuth 2.0</a> support the HTTP Basic authentication scheme for authenticating clients, while other methods like passing the  {@code client_id} and  {@code client_password} in the requestbody is not supported. In version 1.0 only the <a href=""http://tools.ietf.org/html/rfc6749#section-4.4"">Client Credentials</a> grant type is supported. To get an  {@code access_token} the  client makes a request to the token endpoint by adding the following parameters using the ""application/x-www-form-urlencoded""{@code grant_type} - Required. Value MUST be set to ""client_credentials"".{@code scope} - Optional. The scope of the access request.<pre> POST /token HTTP/1.1 Host: server.example.com Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW Content-Type: application/x-www-form-urlencoded grant_type=client_credentials </pre> <pre> <b>application.authenticateOauth(httpServletRequest)</b> .execute() </pre>
 * @return a new {@link OauthAuthenticationRequestBuilder}.
 * @throws IllegalStateException    - If {@code com.stormpath.sdk.impl.oauth.authc.DefaultOauthAuthenticationRequestBuilder} class couldn't be found in the classpath.
 * @throws IllegalArgumentException - If {@code httpServletRequest} is null.
 * @see Application#authenticate(Object)
 * @since 1.0.RC
 */
OauthAuthenticationRequestBuilder authenticateOauth(Object httpRequest);",0.6230769230769231
99412,"@Override public String getHeader(String name){
  for (  Map.Entry<String,String[]> entry : httpRequest.getHeaders().entrySet()) {
    if (entry.getKey().equalsIgnoreCase(name)) {
      return entry.getValue()[0];
    }
  }
  return null;
}","@Override public String getHeader(String name){
  return httpRequest.getHeader(name);
}",0.5076452599388379
99413,"public DefaultHttpRequest(Map<String,String[]> headers,HttpMethod method,InputStream body,Map<String,String[]> parameters,String queryParameters){
  this.headers=headers;
  this.method=method;
  this.body=body;
  this.parameters=parameters;
  this.queryParameters=queryParameters;
  Assert.notNull(method,""String_Node_Str"");
  Assert.state(method != HttpMethod.GET || body == null);
}","public DefaultHttpRequest(Map<String,String[]> headers,HttpMethod method,Map<String,String[]> parameters,String queryParameters){
  this.headers=headers;
  this.method=method;
  this.parameters=parameters;
  this.queryParameters=queryParameters;
  Assert.notNull(method,""String_Node_Str"");
}",0.8622222222222222
99414,"@Override public HttpRequest build(){
  return new DefaultHttpRequest(headers,method,body,parameters,queryParameters);
}","@Override public HttpRequest build(){
  return new DefaultHttpRequest(headers,method,parameters,queryParameters);
}",0.9787234042553192
99415,"public AccessTokenOauthException(Error error){
  super(error);
}","public AccessTokenOauthException(Error error,String oauthError){
  super(error,oauthError);
}",0.8152866242038217
99416,"/** 
 * The   {@link TokenResponse} obtained as a result of a successful authentication request execution.
 * @return the {@link TokenResponse} obtained as a result of a successful authentication request execution.
 */
TokenResponse getTokenResponse();","/** 
 * The   {@link com.stormpath.sdk.oauth.authz.TokenResponse} obtained as a result of a successful authentication request execution.
 * @return the {@link com.stormpath.sdk.oauth.authz.TokenResponse} obtained as a result of a successful authentication request execution.
 */
TokenResponse getTokenResponse();",0.8936170212765957
99417,"/** 
 * Specifies the   {@link ScopeFactory} to be used for this authentication request.
 * @param scopeFactory the {@link ScopeFactory} to be used for this authentication request.
 * @return this instance for method chaining.
 */
public BasicOauthAuthenticationRequestBuilder using(ScopeFactory scopeFactory);","/** 
 * Specifies the   {@link ScopeFactory} to be used for this authentication request.If not provided an empty scope will be returned.
 * @param scopeFactory the {@link ScopeFactory} to be used for this authentication request.
 * @return this instance for method chaining.
 */
public BasicOauthAuthenticationRequestBuilder using(ScopeFactory scopeFactory);",0.9281437125748504
99418,"/** 
 * Specifies the <a href=""http://en.wikipedia.org/wiki/Time_to_live"">time to live</a> of this authentication request in seconds.
 * @param ttl the time to live (in seconds) of this authentication request.
 * @return this instance for method chaining.
 */
public BasicOauthAuthenticationRequestBuilder withTtl(long ttl);","/** 
 * Specifies the <a href=""http://en.wikipedia.org/wiki/Time_to_live"">time to live</a> of this authentication request in seconds. If not provided the default ttl (3600 seconds) will be used.
 * @param ttl the time to live (in seconds) of this authentication request.
 * @return this instance for method chaining.
 */
public BasicOauthAuthenticationRequestBuilder withTtl(long ttl);",0.913963328631876
99419,"/** 
 * Utility function for creating a new BufferedEntity and wrapping any errors as an AmazonClientException.
 * @param entity The HTTP entity to wrap with a buffered HTTP entity.
 * @return A new BufferedHttpEntity wrapping the specified entity.
 */
private HttpEntity newBufferedHttpEntity(HttpEntity entity){
  try {
    return new BufferedHttpEntity(entity);
  }
 catch (  IOException e) {
    throw new RestException(""String_Node_Str"" + e.getMessage(),e);
  }
}","/** 
 * Utility function for creating a new BufferedEntity and wrapping any errors as a RestException.
 * @param entity The HTTP entity to wrap with a buffered HTTP entity.
 * @return A new BufferedHttpEntity wrapping the specified entity.
 */
private HttpEntity newBufferedHttpEntity(HttpEntity entity){
  try {
    return new BufferedHttpEntity(entity);
  }
 catch (  IOException e) {
    throw new RestException(""String_Node_Str"" + e.getMessage(),e);
  }
}",0.9816612729234088
99420,"@SuppressWarnings(""String_Node_Str"") private DataStore createDataStore(Object requestExecutor,Object secondCtorArg){
  String requestExecutorInterfaceClassName=""String_Node_Str"";
  Class requestExecutorInterfaceClass;
  try {
    requestExecutorInterfaceClass=ClassUtils.forName(requestExecutorInterfaceClassName);
  }
 catch (  Throwable t) {
    throw new RuntimeException(""String_Node_Str"" + requestExecutorInterfaceClassName + ""String_Node_Str"",t);
  }
  String className=""String_Node_Str"";
  Class dataStoreClass;
  try {
    dataStoreClass=ClassUtils.forName(className);
  }
 catch (  Throwable t) {
    throw new RuntimeException(""String_Node_Str"" + className + ""String_Node_Str""+ ""String_Node_Str"",t);
  }
  Constructor ctor=ClassUtils.getConstructor(dataStoreClass,requestExecutorInterfaceClass,secondCtorArg.getClass());
  try {
    return (DataStore)ctor.newInstance(requestExecutor,secondCtorArg);
  }
 catch (  Throwable t) {
    throw new RuntimeException(""String_Node_Str"" + className,t);
  }
}","@SuppressWarnings(""String_Node_Str"") private DataStore createDataStore(Object requestExecutor,Object secondCtorArg){
  String requestExecutorInterfaceClassName=""String_Node_Str"";
  Class requestExecutorInterfaceClass;
  try {
    requestExecutorInterfaceClass=ClassUtils.forName(requestExecutorInterfaceClassName);
  }
 catch (  Throwable t) {
    throw new RuntimeException(""String_Node_Str"" + requestExecutorInterfaceClassName + ""String_Node_Str"",t);
  }
  String className=""String_Node_Str"";
  Class dataStoreClass;
  try {
    dataStoreClass=ClassUtils.forName(className);
  }
 catch (  Throwable t) {
    throw new RuntimeException(""String_Node_Str"" + className + ""String_Node_Str""+ ""String_Node_Str"",t);
  }
  Class secondCtorArgClass=secondCtorArg.getClass();
  if (Integer.class.equals(secondCtorArgClass)) {
    secondCtorArgClass=int.class;
  }
  Constructor ctor=ClassUtils.getConstructor(dataStoreClass,requestExecutorInterfaceClass,secondCtorArgClass);
  try {
    return (DataStore)ctor.newInstance(requestExecutor,secondCtorArg);
  }
 catch (  Throwable t) {
    throw new RuntimeException(""String_Node_Str"" + className,t);
  }
}",0.927078495123084
99421,"public Object getProperty(String name){
  readLock.lock();
  try {
    if (!HREF_PROP_NAME.equals(name)) {
      if (!isMaterialized()) {
        materialize();
      }
    }
    return this.properties.get(name);
  }
  finally {
    readLock.unlock();
  }
}","public Object getProperty(String name){
  if (!HREF_PROP_NAME.equals(name)) {
    if (!isMaterialized()) {
      materialize();
    }
  }
  readLock.lock();
  try {
    return this.properties.get(name);
  }
  finally {
    readLock.unlock();
  }
}",0.5674603174603174
99422,"/** 
 * Constructor
 * @param usbDevice           the UsbDevice
 * @param usbDeviceConnection the UsbDeviceConnection
 * @param usbInterface        the UsbInterface
 * @param usbEndpoint         the UsbEndpoint
 */
public MidiOutputDevice(@NonNull UsbDevice usbDevice,@NonNull UsbDeviceConnection usbDeviceConnection,@NonNull UsbInterface usbInterface,@NonNull UsbEndpoint usbEndpoint){
  this.usbDevice=usbDevice;
  this.usbDeviceConnection=usbDeviceConnection;
  this.usbInterface=usbInterface;
  waiterThread=new WaiterThread();
  outputEndpoint=usbEndpoint;
  this.usbDeviceConnection.claimInterface(this.usbInterface,true);
  waiterThread.setName(""String_Node_Str"" + usbDevice.getDeviceName() + ""String_Node_Str"");
  waiterThread.start();
}","/** 
 * Constructor
 * @param usbDevice the UsbDevice
 * @param usbDeviceConnection the UsbDeviceConnection
 * @param usbInterface the UsbInterface
 * @param usbEndpoint the UsbEndpoint
 */
public MidiOutputDevice(@NonNull UsbDevice usbDevice,@NonNull UsbDeviceConnection usbDeviceConnection,@NonNull UsbInterface usbInterface,@NonNull UsbEndpoint usbEndpoint){
  this.usbDevice=usbDevice;
  this.usbDeviceConnection=usbDeviceConnection;
  this.usbInterface=usbInterface;
  waiterThread=new WaiterThread();
  outputEndpoint=usbEndpoint;
  this.usbDeviceConnection.claimInterface(this.usbInterface,true);
  waiterThread.setName(""String_Node_Str"" + usbDevice.getDeviceName() + ""String_Node_Str"");
  waiterThread.start();
  for (int i=0; i < BUFFER_POOL_SIZE; i++) {
    bufferPool.addLast(new byte[4]);
  }
}",0.9284332688588008
99423,"@Override public void run(){
  byte[] dequedDataBuffer;
  int dequedDataBufferLength;
  int queueSize;
  final int maxPacketSize=outputEndpoint.getMaxPacketSize();
  byte[] endpointBuffer=new byte[maxPacketSize];
  int endpointBufferLength;
  int bufferPosition;
  int usbRequestFailCount;
  int bytesWritten;
  while (!stopFlag) {
    dequedDataBuffer=null;
synchronized (queue) {
      queueSize=queue.size();
      if (queueSize > 0) {
        dequedDataBuffer=queue.poll();
      }
    }
    if (suspendFlag) {
      try {
        sleep(500);
      }
 catch (      InterruptedException e) {
      }
      continue;
    }
    if (dequedDataBuffer != null) {
      dequedDataBufferLength=dequedDataBuffer.length;
synchronized (usbDeviceConnection) {
        for (bufferPosition=0; bufferPosition < dequedDataBufferLength; bufferPosition+=maxPacketSize) {
          endpointBufferLength=dequedDataBufferLength - bufferPosition;
          if (endpointBufferLength > maxPacketSize) {
            endpointBufferLength=maxPacketSize;
          }
          usbRequestFailCount=0;
          while (true) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
              bytesWritten=usbDeviceConnection.bulkTransfer(outputEndpoint,dequedDataBuffer,bufferPosition,endpointBufferLength,10);
            }
 else {
              if (bufferPosition > 0) {
                System.arraycopy(dequedDataBuffer,bufferPosition,endpointBuffer,0,endpointBufferLength);
                bytesWritten=usbDeviceConnection.bulkTransfer(outputEndpoint,endpointBuffer,endpointBufferLength,10);
              }
 else {
                bytesWritten=usbDeviceConnection.bulkTransfer(outputEndpoint,dequedDataBuffer,endpointBufferLength,10);
              }
            }
            if (bytesWritten < 0) {
              usbRequestFailCount++;
            }
 else {
              break;
            }
            if (usbRequestFailCount > 10) {
              stopFlag=true;
              break;
            }
          }
          if (stopFlag) {
            break;
          }
        }
      }
    }
    if (queueSize == 0 && !interrupted()) {
      try {
        sleep(500);
      }
 catch (      InterruptedException e) {
      }
    }
  }
}","@Override public void run(){
  byte[] dequedDataBuffer;
  int dequedDataBufferLength;
  int queueSize;
  final int maxPacketSize=outputEndpoint.getMaxPacketSize();
  byte[] endpointBuffer=new byte[maxPacketSize];
  int endpointBufferLength;
  int bufferPosition;
  int usbRequestFailCount;
  int bytesWritten;
  while (!stopFlag) {
    dequedDataBuffer=null;
synchronized (queue) {
      queueSize=queue.size();
      if (queueSize > 0) {
        dequedDataBuffer=queue.poll();
      }
    }
    if (suspendFlag) {
      try {
        sleep(500);
      }
 catch (      InterruptedException e) {
      }
      continue;
    }
    if (dequedDataBuffer != null) {
      dequedDataBufferLength=dequedDataBuffer.length;
synchronized (usbDeviceConnection) {
        for (bufferPosition=0; bufferPosition < dequedDataBufferLength; bufferPosition+=maxPacketSize) {
          endpointBufferLength=dequedDataBufferLength - bufferPosition;
          if (endpointBufferLength > maxPacketSize) {
            endpointBufferLength=maxPacketSize;
          }
          usbRequestFailCount=0;
          while (true) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
              bytesWritten=usbDeviceConnection.bulkTransfer(outputEndpoint,dequedDataBuffer,bufferPosition,endpointBufferLength,10);
            }
 else {
              if (bufferPosition > 0) {
                System.arraycopy(dequedDataBuffer,bufferPosition,endpointBuffer,0,endpointBufferLength);
                bytesWritten=usbDeviceConnection.bulkTransfer(outputEndpoint,endpointBuffer,endpointBufferLength,10);
              }
 else {
                bytesWritten=usbDeviceConnection.bulkTransfer(outputEndpoint,dequedDataBuffer,endpointBufferLength,10);
              }
            }
            if (bytesWritten < 0) {
              usbRequestFailCount++;
            }
 else {
              break;
            }
            if (usbRequestFailCount > 10) {
              stopFlag=true;
              break;
            }
          }
          if (stopFlag) {
            break;
          }
        }
      }
      if (dequedDataBuffer.length == 4) {
synchronized (queue) {
          bufferPool.addLast(dequedDataBuffer);
        }
      }
    }
    if (queueSize == 0 && !interrupted()) {
      try {
        sleep(500);
      }
 catch (      InterruptedException e) {
      }
    }
  }
}",0.9716634220203332
99424,"/** 
 * SysEx Code Index Number : 0x4, 0x5, 0x6, 0x7
 * @param cable           the cable ID 0-15
 * @param systemExclusive : start with 'F0', and end with 'F7'
 */
public void sendMidiSystemExclusive(int cable,@NonNull byte[] systemExclusive){
  ByteArrayOutputStream transferDataStream=new ByteArrayOutputStream();
  for (int sysexIndex=0; sysexIndex < systemExclusive.length; sysexIndex+=3) {
    if ((sysexIndex + 3 < systemExclusive.length)) {
      transferDataStream.write((((cable & 0xf) << 4) | 0x4));
      transferDataStream.write(systemExclusive[sysexIndex] & 0xff);
      transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
      transferDataStream.write(systemExclusive[sysexIndex + 2] & 0xff);
    }
 else {
switch (systemExclusive.length % 3) {
case 1:
        transferDataStream.write((((cable & 0xf) << 4) | 0x5));
      transferDataStream.write(systemExclusive[sysexIndex] & 0xff);
    transferDataStream.write(0);
  transferDataStream.write(0);
break;
case 2:
transferDataStream.write((((cable & 0xf) << 4) | 0x6));
transferDataStream.write(systemExclusive[sysexIndex] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
transferDataStream.write(0);
break;
case 0:
transferDataStream.write((((cable & 0xf) << 4) | 0x7));
transferDataStream.write(systemExclusive[sysexIndex] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 2] & 0xff);
break;
default :
break;
}
}
}
byte[] buffer=transferDataStream.toByteArray();
Handler handler=waiterThread.getHandler();
handler.sendMessage(Message.obtain(handler,0,buffer));
}","/** 
 * SysEx Code Index Number : 0x4, 0x5, 0x6, 0x7
 * @param cable           the cable ID 0-15
 * @param systemExclusive : start with 'F0', and end with 'F7'
 */
public void sendMidiSystemExclusive(int cable,@NonNull byte[] systemExclusive){
  if (systemExclusive.length > 3) {
    sysexTransferDataStream.reset();
    for (int sysexIndex=0; sysexIndex < systemExclusive.length; sysexIndex+=3) {
      if ((sysexIndex + 3 < systemExclusive.length)) {
        sysexTransferDataStream.write((((cable & 0xf) << 4) | 0x4));
        sysexTransferDataStream.write(systemExclusive[sysexIndex] & 0xff);
        sysexTransferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
        sysexTransferDataStream.write(systemExclusive[sysexIndex + 2] & 0xff);
      }
 else {
switch (systemExclusive.length % 3) {
case 1:
          sysexTransferDataStream.write((((cable & 0xf) << 4) | 0x5));
        sysexTransferDataStream.write(systemExclusive[sysexIndex] & 0xff);
      sysexTransferDataStream.write(0);
    sysexTransferDataStream.write(0);
  break;
case 2:
sysexTransferDataStream.write((((cable & 0xf) << 4) | 0x6));
sysexTransferDataStream.write(systemExclusive[sysexIndex] & 0xff);
sysexTransferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
sysexTransferDataStream.write(0);
break;
case 0:
sysexTransferDataStream.write((((cable & 0xf) << 4) | 0x7));
sysexTransferDataStream.write(systemExclusive[sysexIndex] & 0xff);
sysexTransferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
sysexTransferDataStream.write(systemExclusive[sysexIndex + 2] & 0xff);
break;
default :
break;
}
}
}
synchronized (waiterThread.queue) {
waiterThread.queue.add(sysexTransferDataStream.toByteArray());
}
waiterThread.interrupt();
}
 else {
switch (systemExclusive.length) {
case 1:
sendMidiMessage(0x5,cable & 0xf,systemExclusive[0],0,0);
break;
case 2:
sendMidiMessage(0x6,cable & 0xf,systemExclusive[0],systemExclusive[1],0);
break;
case 3:
sendMidiMessage(0x7,cable & 0xf,systemExclusive[0],systemExclusive[1],systemExclusive[2]);
break;
}
}
}",0.8076819042466865
99425,"@Override public void run(){
  final UsbDeviceConnection deviceConnection=usbDeviceConnection;
  final UsbEndpoint usbEndpoint=inputEndpoint;
  final int maxPacketSize=inputEndpoint.getMaxPacketSize();
  final MidiInputDevice sender=MidiInputDevice.this;
  final OnMidiInputEventListener midiEventListener=MidiInputDevice.this.midiEventListener;
  final byte[] bulkReadBuffer=new byte[maxPacketSize];
  byte[] readBuffer=new byte[maxPacketSize * 2];
  int readBufferSize=0;
  byte[] read=new byte[maxPacketSize * 2];
  int length;
  int cable;
  int codeIndexNumber;
  int byte1;
  int byte2;
  int byte3;
  int i;
  int readSize;
  int unreadSize;
  final int RPN_STATUS_NONE=0;
  final int RPN_STATUS_RPN=1;
  final int RPN_STATUS_NRPN=2;
  int rpnNrpnFunction;
  int rpnNrpnValueMsb;
  int rpnNrpnValueLsb;
  int rpnStatus=RPN_STATUS_NONE;
  int rpnFunctionMsb=0x7f;
  int rpnFunctionLsb=0x7f;
  int nrpnFunctionMsb=0x7f;
  int nrpnFunctionLsb=0x7f;
  SparseIntArray rpnCacheMsb=new SparseIntArray();
  SparseIntArray rpnCacheLsb=new SparseIntArray();
  SparseIntArray nrpnCacheMsb=new SparseIntArray();
  SparseIntArray nrpnCacheLsb=new SparseIntArray();
  ReusableByteArrayOutputStream[] systemExclusive=new ReusableByteArrayOutputStream[16];
  for (i=0; i < 16; i++) {
    systemExclusive[i]=new ReusableByteArrayOutputStream();
  }
  while (!stopFlag) {
    length=deviceConnection.bulkTransfer(usbEndpoint,bulkReadBuffer,maxPacketSize,10);
synchronized (suspendSignal) {
      if (suspendFlag) {
        try {
          suspendSignal.wait(100);
        }
 catch (        InterruptedException e) {
        }
        continue;
      }
    }
    if (length <= 0) {
      continue;
    }
    System.arraycopy(bulkReadBuffer,0,readBuffer,readBufferSize,length);
    readBufferSize+=length;
    if (readBufferSize < 4) {
      continue;
    }
    readSize=readBufferSize / 4 * 4;
    System.arraycopy(readBuffer,0,read,0,readSize);
    unreadSize=readBufferSize - readSize;
    if (unreadSize > 0) {
      System.arraycopy(readBuffer,readSize,readBuffer,0,unreadSize);
      readBufferSize=unreadSize;
    }
 else {
      readBufferSize=0;
    }
    for (i=0; i < readSize; i+=4) {
      cable=(read[i] >> 4) & 0xf;
      codeIndexNumber=read[i] & 0xf;
      byte1=read[i + 1] & 0xff;
      byte2=read[i + 2] & 0xff;
      byte3=read[i + 3] & 0xff;
switch (codeIndexNumber) {
case 0:
        if (midiEventListener != null) {
          midiEventListener.onMidiMiscellaneousFunctionCodes(sender,cable,byte1,byte2,byte3);
        }
      break;
case 1:
    if (midiEventListener != null) {
      midiEventListener.onMidiCableEvents(sender,cable,byte1,byte2,byte3);
    }
  break;
case 2:
if (midiEventListener != null) {
  byte[] bytes=new byte[]{(byte)byte1,(byte)byte2};
  midiEventListener.onMidiSystemCommonMessage(sender,cable,bytes);
}
break;
case 3:
if (midiEventListener != null) {
byte[] bytes=new byte[]{(byte)byte1,(byte)byte2,(byte)byte3};
midiEventListener.onMidiSystemCommonMessage(sender,cable,bytes);
}
break;
case 4:
synchronized (systemExclusive[cable]) {
systemExclusive[cable].write(byte1);
systemExclusive[cable].write(byte2);
systemExclusive[cable].write(byte3);
}
break;
case 5:
synchronized (systemExclusive[cable]) {
systemExclusive[cable].write(byte1);
if (midiEventListener != null) {
midiEventListener.onMidiSystemExclusive(sender,cable,systemExclusive[cable].toByteArray());
}
systemExclusive[cable].reset();
}
break;
case 6:
synchronized (systemExclusive[cable]) {
systemExclusive[cable].write(byte1);
systemExclusive[cable].write(byte2);
if (midiEventListener != null) {
midiEventListener.onMidiSystemExclusive(sender,cable,systemExclusive[cable].toByteArray());
}
systemExclusive[cable].reset();
}
break;
case 7:
synchronized (systemExclusive[cable]) {
systemExclusive[cable].write(byte1);
systemExclusive[cable].write(byte2);
systemExclusive[cable].write(byte3);
if (midiEventListener != null) {
midiEventListener.onMidiSystemExclusive(sender,cable,systemExclusive[cable].toByteArray());
}
systemExclusive[cable].reset();
}
break;
case 8:
if (midiEventListener != null) {
midiEventListener.onMidiNoteOff(sender,cable,byte1 & 0xf,byte2,byte3);
}
break;
case 9:
if (midiEventListener != null) {
if (byte3 == 0x00) {
midiEventListener.onMidiNoteOff(sender,cable,byte1 & 0xf,byte2,byte3);
}
 else {
midiEventListener.onMidiNoteOn(sender,cable,byte1 & 0xf,byte2,byte3);
}
}
break;
case 10:
if (midiEventListener != null) {
midiEventListener.onMidiPolyphonicAftertouch(sender,cable,byte1 & 0xf,byte2,byte3);
}
break;
case 11:
if (midiEventListener != null) {
midiEventListener.onMidiControlChange(sender,cable,byte1 & 0xf,byte2,byte3);
}
switch (byte2) {
case 6:
{
rpnNrpnValueMsb=byte3 & 0x7f;
if (rpnStatus == RPN_STATUS_RPN) {
rpnNrpnFunction=((rpnFunctionMsb & 0x7f) << 7) | (rpnFunctionLsb & 0x7f);
rpnCacheMsb.put(rpnNrpnFunction,rpnNrpnValueMsb);
rpnNrpnValueLsb=rpnCacheLsb.get(rpnNrpnFunction,0);
if (midiEventListener != null) {
midiEventListener.onMidiRPNReceived(sender,cable,byte1 & 0xf,rpnNrpnFunction,(rpnNrpnValueMsb << 7 | rpnNrpnValueLsb));
midiEventListener.onMidiRPNReceived(sender,cable,byte1 & 0xf,rpnNrpnFunction,rpnNrpnValueMsb,rpnNrpnValueLsb);
}
}
 else if (rpnStatus == RPN_STATUS_NRPN) {
rpnNrpnFunction=((nrpnFunctionMsb & 0x7f) << 7) | (nrpnFunctionLsb & 0x7f);
nrpnCacheMsb.put(rpnNrpnFunction,rpnNrpnValueMsb);
rpnNrpnValueLsb=nrpnCacheLsb.get(rpnNrpnFunction,0);
if (midiEventListener != null) {
midiEventListener.onMidiNRPNReceived(sender,cable,byte1 & 0xf,rpnNrpnFunction,(rpnNrpnValueMsb << 7 | rpnNrpnValueLsb));
midiEventListener.onMidiNRPNReceived(sender,cable,byte1 & 0xf,rpnNrpnFunction,rpnNrpnValueMsb,rpnNrpnValueLsb);
}
}
break;
}
case 38:
{
rpnNrpnValueLsb=byte3 & 0x7f;
if (rpnStatus == RPN_STATUS_RPN) {
rpnNrpnFunction=((rpnFunctionMsb & 0x7f) << 7) | (rpnFunctionLsb & 0x7f);
rpnNrpnValueMsb=rpnCacheMsb.get(rpnNrpnFunction,0);
rpnCacheLsb.put(rpnNrpnFunction,rpnNrpnValueLsb);
if (midiEventListener != null) {
midiEventListener.onMidiRPNReceived(sender,cable,byte1 & 0xf,rpnNrpnFunction,(rpnNrpnValueMsb << 7 | rpnNrpnValueLsb));
midiEventListener.onMidiRPNReceived(sender,cable,byte1 & 0xf,rpnNrpnFunction,rpnNrpnValueMsb,rpnNrpnValueLsb);
}
}
 else if (rpnStatus == RPN_STATUS_NRPN) {
rpnNrpnFunction=((nrpnFunctionMsb & 0x7f) << 7) | (nrpnFunctionLsb & 0x7f);
rpnNrpnValueMsb=nrpnCacheMsb.get(rpnNrpnFunction,0);
nrpnCacheLsb.put(rpnNrpnFunction,rpnNrpnValueLsb);
if (midiEventListener != null) {
midiEventListener.onMidiNRPNReceived(sender,cable,byte1 & 0xf,rpnNrpnFunction,(rpnNrpnValueMsb << 7 | rpnNrpnValueLsb));
midiEventListener.onMidiNRPNReceived(sender,cable,byte1 & 0xf,rpnNrpnFunction,rpnNrpnValueMsb,rpnNrpnValueLsb);
}
}
break;
}
case 98:
{
nrpnFunctionLsb=byte3 & 0x7f;
rpnStatus=RPN_STATUS_NRPN;
break;
}
case 99:
{
nrpnFunctionMsb=byte3 & 0x7f;
rpnStatus=RPN_STATUS_NRPN;
break;
}
case 100:
{
rpnFunctionLsb=byte3 & 0x7f;
if (rpnFunctionMsb == 0x7f && rpnFunctionLsb == 0x7f) {
rpnStatus=RPN_STATUS_NONE;
}
 else {
rpnStatus=RPN_STATUS_RPN;
}
break;
}
case 101:
{
rpnFunctionMsb=byte3 & 0x7f;
if (rpnFunctionMsb == 0x7f && rpnFunctionLsb == 0x7f) {
rpnStatus=RPN_STATUS_NONE;
}
 else {
rpnStatus=RPN_STATUS_RPN;
}
break;
}
default :
break;
}
break;
case 12:
if (midiEventListener != null) {
midiEventListener.onMidiProgramChange(sender,cable,byte1 & 0xf,byte2);
}
break;
case 13:
if (midiEventListener != null) {
midiEventListener.onMidiChannelAftertouch(sender,cable,byte1 & 0xf,byte2);
}
break;
case 14:
if (midiEventListener != null) {
midiEventListener.onMidiPitchWheel(sender,cable,byte1 & 0xf,byte2 | (byte3 << 7));
}
break;
case 15:
if (midiEventListener != null) {
midiEventListener.onMidiSingleByte(sender,cable,byte1);
}
break;
default :
break;
}
}
}
}","@Override public void run(){
  final UsbDeviceConnection deviceConnection=usbDeviceConnection;
  final UsbEndpoint usbEndpoint=inputEndpoint;
  final int maxPacketSize=inputEndpoint.getMaxPacketSize();
  final MidiInputDevice sender=MidiInputDevice.this;
  final OnMidiInputEventListener midiEventListener=MidiInputDevice.this.midiEventListener;
  final byte[] bulkReadBuffer=new byte[maxPacketSize];
  byte[] readBuffer=new byte[maxPacketSize * 2];
  int readBufferSize=0;
  byte[] read=new byte[maxPacketSize * 2];
  int length;
  int cable;
  int codeIndexNumber;
  int byte1;
  int byte2;
  int byte3;
  int i;
  int readSize;
  int unreadSize;
  final int RPN_STATUS_NONE=0;
  final int RPN_STATUS_RPN=1;
  final int RPN_STATUS_NRPN=2;
  int rpnNrpnFunction;
  int rpnNrpnValueMsb;
  int rpnNrpnValueLsb;
  int rpnStatus=RPN_STATUS_NONE;
  int rpnFunctionMsb=0x7f;
  int rpnFunctionLsb=0x7f;
  int nrpnFunctionMsb=0x7f;
  int nrpnFunctionLsb=0x7f;
  SparseIntArray rpnCacheMsb=new SparseIntArray();
  SparseIntArray rpnCacheLsb=new SparseIntArray();
  SparseIntArray nrpnCacheMsb=new SparseIntArray();
  SparseIntArray nrpnCacheLsb=new SparseIntArray();
  ReusableByteArrayOutputStream[] systemExclusive=new ReusableByteArrayOutputStream[16];
  for (i=0; i < 16; i++) {
    systemExclusive[i]=new ReusableByteArrayOutputStream();
  }
  while (!stopFlag) {
    length=deviceConnection.bulkTransfer(usbEndpoint,bulkReadBuffer,maxPacketSize,10);
synchronized (suspendSignal) {
      if (suspendFlag) {
        try {
          suspendSignal.wait(100);
        }
 catch (        InterruptedException e) {
        }
        continue;
      }
    }
    if (length <= 0) {
      continue;
    }
    System.arraycopy(bulkReadBuffer,0,readBuffer,readBufferSize,length);
    readBufferSize+=length;
    if (readBufferSize < 4) {
      continue;
    }
    readSize=readBufferSize / 4 * 4;
    System.arraycopy(readBuffer,0,read,0,readSize);
    unreadSize=readBufferSize - readSize;
    if (unreadSize > 0) {
      System.arraycopy(readBuffer,readSize,readBuffer,0,unreadSize);
      readBufferSize=unreadSize;
    }
 else {
      readBufferSize=0;
    }
    for (i=0; i < readSize; i+=4) {
      cable=(read[i] >> 4) & 0xf;
      codeIndexNumber=read[i] & 0xf;
      byte1=read[i + 1] & 0xff;
      byte2=read[i + 2] & 0xff;
      byte3=read[i + 3] & 0xff;
switch (codeIndexNumber) {
case 0:
        if (midiEventListener != null) {
          midiEventListener.onMidiMiscellaneousFunctionCodes(sender,cable,byte1,byte2,byte3);
        }
      break;
case 1:
    if (midiEventListener != null) {
      midiEventListener.onMidiCableEvents(sender,cable,byte1,byte2,byte3);
    }
  break;
case 2:
if (midiEventListener != null) {
switch (byte1) {
case 0xf1:
    midiEventListener.onMidiTimeCodeQuarterFrame(sender,cable,byte2 & 0x7f);
  break;
case 0xf3:
midiEventListener.onMidiSongSelect(sender,cable,byte2 & 0x7f);
break;
}
byte[] bytes=new byte[]{(byte)byte1,(byte)byte2};
midiEventListener.onMidiSystemCommonMessage(sender,cable,bytes);
}
break;
case 3:
if (midiEventListener != null) {
switch (byte1) {
case 0xf2:
midiEventListener.onMidiSongPositionPointer(sender,cable,(byte2 & 0x7f) | ((byte3 & 0x7f) << 7));
break;
}
byte[] bytes=new byte[]{(byte)byte1,(byte)byte2,(byte)byte3};
midiEventListener.onMidiSystemCommonMessage(sender,cable,bytes);
}
break;
case 4:
synchronized (systemExclusive[cable]) {
systemExclusive[cable].write(byte1);
systemExclusive[cable].write(byte2);
systemExclusive[cable].write(byte3);
}
break;
case 5:
synchronized (systemExclusive[cable]) {
systemExclusive[cable].write(byte1);
if (midiEventListener != null) {
byte[] sysexBytes=systemExclusive[cable].toByteArray();
if (sysexBytes.length == 1) {
switch (sysexBytes[0] & 0xff) {
case 0xf6:
midiEventListener.onMidiTuneRequest(sender,cable);
break;
case 0xf8:
midiEventListener.onMidiTimingClock(sender,cable);
break;
case 0xfa:
midiEventListener.onMidiStart(sender,cable);
break;
case 0xfb:
midiEventListener.onMidiContinue(sender,cable);
break;
case 0xfc:
midiEventListener.onMidiStop(sender,cable);
break;
case 0xfe:
midiEventListener.onMidiActiveSensing(sender,cable);
break;
case 0xff:
midiEventListener.onMidiReset(sender,cable);
break;
}
}
midiEventListener.onMidiSystemExclusive(sender,cable,sysexBytes);
}
systemExclusive[cable].reset();
}
break;
case 6:
synchronized (systemExclusive[cable]) {
systemExclusive[cable].write(byte1);
systemExclusive[cable].write(byte2);
if (midiEventListener != null) {
midiEventListener.onMidiSystemExclusive(sender,cable,systemExclusive[cable].toByteArray());
}
systemExclusive[cable].reset();
}
break;
case 7:
synchronized (systemExclusive[cable]) {
systemExclusive[cable].write(byte1);
systemExclusive[cable].write(byte2);
systemExclusive[cable].write(byte3);
if (midiEventListener != null) {
midiEventListener.onMidiSystemExclusive(sender,cable,systemExclusive[cable].toByteArray());
}
systemExclusive[cable].reset();
}
break;
case 8:
if (midiEventListener != null) {
midiEventListener.onMidiNoteOff(sender,cable,byte1 & 0xf,byte2,byte3);
}
break;
case 9:
if (midiEventListener != null) {
if (byte3 == 0x00) {
midiEventListener.onMidiNoteOff(sender,cable,byte1 & 0xf,byte2,byte3);
}
 else {
midiEventListener.onMidiNoteOn(sender,cable,byte1 & 0xf,byte2,byte3);
}
}
break;
case 10:
if (midiEventListener != null) {
midiEventListener.onMidiPolyphonicAftertouch(sender,cable,byte1 & 0xf,byte2,byte3);
}
break;
case 11:
if (midiEventListener != null) {
midiEventListener.onMidiControlChange(sender,cable,byte1 & 0xf,byte2,byte3);
}
switch (byte2) {
case 6:
{
rpnNrpnValueMsb=byte3 & 0x7f;
if (rpnStatus == RPN_STATUS_RPN) {
rpnNrpnFunction=((rpnFunctionMsb & 0x7f) << 7) | (rpnFunctionLsb & 0x7f);
rpnCacheMsb.put(rpnNrpnFunction,rpnNrpnValueMsb);
rpnNrpnValueLsb=rpnCacheLsb.get(rpnNrpnFunction,0);
if (midiEventListener != null) {
midiEventListener.onMidiRPNReceived(sender,cable,byte1 & 0xf,rpnNrpnFunction,(rpnNrpnValueMsb << 7 | rpnNrpnValueLsb));
midiEventListener.onMidiRPNReceived(sender,cable,byte1 & 0xf,rpnNrpnFunction,rpnNrpnValueMsb,rpnNrpnValueLsb);
}
}
 else if (rpnStatus == RPN_STATUS_NRPN) {
rpnNrpnFunction=((nrpnFunctionMsb & 0x7f) << 7) | (nrpnFunctionLsb & 0x7f);
nrpnCacheMsb.put(rpnNrpnFunction,rpnNrpnValueMsb);
rpnNrpnValueLsb=nrpnCacheLsb.get(rpnNrpnFunction,0);
if (midiEventListener != null) {
midiEventListener.onMidiNRPNReceived(sender,cable,byte1 & 0xf,rpnNrpnFunction,(rpnNrpnValueMsb << 7 | rpnNrpnValueLsb));
midiEventListener.onMidiNRPNReceived(sender,cable,byte1 & 0xf,rpnNrpnFunction,rpnNrpnValueMsb,rpnNrpnValueLsb);
}
}
break;
}
case 38:
{
rpnNrpnValueLsb=byte3 & 0x7f;
if (rpnStatus == RPN_STATUS_RPN) {
rpnNrpnFunction=((rpnFunctionMsb & 0x7f) << 7) | (rpnFunctionLsb & 0x7f);
rpnNrpnValueMsb=rpnCacheMsb.get(rpnNrpnFunction,0);
rpnCacheLsb.put(rpnNrpnFunction,rpnNrpnValueLsb);
if (midiEventListener != null) {
midiEventListener.onMidiRPNReceived(sender,cable,byte1 & 0xf,rpnNrpnFunction,(rpnNrpnValueMsb << 7 | rpnNrpnValueLsb));
midiEventListener.onMidiRPNReceived(sender,cable,byte1 & 0xf,rpnNrpnFunction,rpnNrpnValueMsb,rpnNrpnValueLsb);
}
}
 else if (rpnStatus == RPN_STATUS_NRPN) {
rpnNrpnFunction=((nrpnFunctionMsb & 0x7f) << 7) | (nrpnFunctionLsb & 0x7f);
rpnNrpnValueMsb=nrpnCacheMsb.get(rpnNrpnFunction,0);
nrpnCacheLsb.put(rpnNrpnFunction,rpnNrpnValueLsb);
if (midiEventListener != null) {
midiEventListener.onMidiNRPNReceived(sender,cable,byte1 & 0xf,rpnNrpnFunction,(rpnNrpnValueMsb << 7 | rpnNrpnValueLsb));
midiEventListener.onMidiNRPNReceived(sender,cable,byte1 & 0xf,rpnNrpnFunction,rpnNrpnValueMsb,rpnNrpnValueLsb);
}
}
break;
}
case 98:
{
nrpnFunctionLsb=byte3 & 0x7f;
rpnStatus=RPN_STATUS_NRPN;
break;
}
case 99:
{
nrpnFunctionMsb=byte3 & 0x7f;
rpnStatus=RPN_STATUS_NRPN;
break;
}
case 100:
{
rpnFunctionLsb=byte3 & 0x7f;
if (rpnFunctionMsb == 0x7f && rpnFunctionLsb == 0x7f) {
rpnStatus=RPN_STATUS_NONE;
}
 else {
rpnStatus=RPN_STATUS_RPN;
}
break;
}
case 101:
{
rpnFunctionMsb=byte3 & 0x7f;
if (rpnFunctionMsb == 0x7f && rpnFunctionLsb == 0x7f) {
rpnStatus=RPN_STATUS_NONE;
}
 else {
rpnStatus=RPN_STATUS_RPN;
}
break;
}
default :
break;
}
break;
case 12:
if (midiEventListener != null) {
midiEventListener.onMidiProgramChange(sender,cable,byte1 & 0xf,byte2);
}
break;
case 13:
if (midiEventListener != null) {
midiEventListener.onMidiChannelAftertouch(sender,cable,byte1 & 0xf,byte2);
}
break;
case 14:
if (midiEventListener != null) {
midiEventListener.onMidiPitchWheel(sender,cable,byte1 & 0xf,byte2 | (byte3 << 7));
}
break;
case 15:
if (midiEventListener != null) {
switch (byte1) {
case 0xf6:
midiEventListener.onMidiTuneRequest(sender,cable);
break;
case 0xf8:
midiEventListener.onMidiTimingClock(sender,cable);
break;
case 0xfa:
midiEventListener.onMidiStart(sender,cable);
break;
case 0xfb:
midiEventListener.onMidiContinue(sender,cable);
break;
case 0xfc:
midiEventListener.onMidiStop(sender,cable);
break;
case 0xfe:
midiEventListener.onMidiActiveSensing(sender,cable);
break;
case 0xff:
midiEventListener.onMidiReset(sender,cable);
break;
}
midiEventListener.onMidiSingleByte(sender,cable,byte1);
}
break;
default :
break;
}
}
}
}",0.912041698750222
99426,"/** 
 * Constructor
 * @param usbManager the UsbManager
 * @param deviceAttachedListener the OnMidiDeviceAttachedListener
 * @param deviceDetachedHandler the OnMidiDeviceDetachedListener
 */
MidiDeviceConnectionWatchThread(@NonNull UsbManager usbManager,@NonNull OnMidiDeviceAttachedListener deviceAttachedListener,@NonNull Handler deviceDetachedHandler){
  this.usbManager=usbManager;
  this.deviceAttachedListener=deviceAttachedListener;
  this.deviceDetachedHandler=deviceDetachedHandler;
  connectedDevices=new HashSet<UsbDevice>();
  stopFlag=false;
  deviceFilters=DeviceFilter.getDeviceFilters(context);
}","/** 
 * Constructor
 * @param usbManager the UsbManager
 * @param deviceAttachedListener the OnMidiDeviceAttachedListener
 * @param deviceDetachedHandler the OnMidiDeviceDetachedListener
 */
MidiDeviceConnectionWatchThread(@NonNull UsbManager usbManager,@NonNull OnMidiDeviceAttachedListener deviceAttachedListener,@NonNull Handler deviceDetachedHandler){
  this.usbManager=usbManager;
  this.deviceAttachedListener=deviceAttachedListener;
  this.deviceDetachedHandler=deviceDetachedHandler;
  connectedDevices=new HashSet<>();
  stopFlag=false;
  deviceFilters=DeviceFilter.getDeviceFilters(context);
}",0.9925925925925926
99427,"/** 
 * stops the watching thread <br /> <br /> Note: Takes one second until the thread stops. The device attached / detached events will be noticed until the thread will completely stops.
 */
public void stop(){
  thread.stopFlag=true;
  thread.interrupt();
  while (thread.isAlive()) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
    }
  }
}","/** 
 * Stops the watching thread <br /> <br /> Note: Takes one second until the thread stops. The device attached / detached events will be noticed until the thread will completely stops.
 */
public void stop(){
  thread.stopFlag=true;
  thread.interrupt();
  while (thread.isAlive()) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
    }
  }
}",0.9973544973544972
99428,"@Override public boolean handleMessage(Message message){
  UsbDevice detachedDevice=(UsbDevice)message.obj;
  deviceDetachedListener.onDeviceDetached(detachedDevice);
  AsyncTask<UsbDevice,Void,Void> task=new AsyncTask<UsbDevice,Void,Void>(){
    @Override protected Void doInBackground(    UsbDevice... params){
      if (params == null || params.length < 1) {
        return null;
      }
      UsbDevice usbDevice=params[0];
      Set<MidiInputDevice> inputDevices=midiInputDevices.get(usbDevice);
      if (inputDevices != null && inputDevices.size() > 0) {
        for (        MidiInputDevice inputDevice : inputDevices) {
          if (inputDevice != null) {
            inputDevice.stop();
            deviceDetachedListener.onMidiInputDeviceDetached(inputDevice);
          }
        }
        midiInputDevices.remove(usbDevice);
      }
      Set<MidiOutputDevice> outputDevices=midiOutputDevices.get(usbDevice);
      if (outputDevices != null) {
        for (        MidiOutputDevice outputDevice : outputDevices) {
          if (outputDevice != null) {
            outputDevice.stop();
            deviceDetachedListener.onMidiOutputDeviceDetached(outputDevice);
          }
        }
        midiOutputDevices.remove(usbDevice);
      }
      UsbDeviceConnection deviceConnection=deviceConnections.get(usbDevice);
      if (deviceConnection != null) {
        deviceConnection.close();
        deviceConnections.remove(usbDevice);
      }
      Log.d(Constants.TAG,""String_Node_Str"" + usbDevice.getDeviceName() + ""String_Node_Str"");
      return null;
    }
  }
;
  task.execute(detachedDevice);
  return true;
}","@Override public boolean handleMessage(Message message){
  AsyncTask<UsbDevice,Void,Void> task=new AsyncTask<UsbDevice,Void,Void>(){
    @Override protected Void doInBackground(    UsbDevice... params){
      if (params == null || params.length < 1) {
        return null;
      }
      UsbDevice usbDevice=params[0];
      onDeviceDetached(usbDevice);
      return null;
    }
  }
;
  UsbDevice detachedDevice=(UsbDevice)message.obj;
  task.execute(detachedDevice);
  return true;
}",0.3157894736842105
99429,"@Override protected Void doInBackground(UsbDevice... params){
  if (params == null || params.length < 1) {
    return null;
  }
  UsbDevice usbDevice=params[0];
  Set<MidiInputDevice> inputDevices=midiInputDevices.get(usbDevice);
  if (inputDevices != null && inputDevices.size() > 0) {
    for (    MidiInputDevice inputDevice : inputDevices) {
      if (inputDevice != null) {
        inputDevice.stop();
        deviceDetachedListener.onMidiInputDeviceDetached(inputDevice);
      }
    }
    midiInputDevices.remove(usbDevice);
  }
  Set<MidiOutputDevice> outputDevices=midiOutputDevices.get(usbDevice);
  if (outputDevices != null) {
    for (    MidiOutputDevice outputDevice : outputDevices) {
      if (outputDevice != null) {
        outputDevice.stop();
        deviceDetachedListener.onMidiOutputDeviceDetached(outputDevice);
      }
    }
    midiOutputDevices.remove(usbDevice);
  }
  UsbDeviceConnection deviceConnection=deviceConnections.get(usbDevice);
  if (deviceConnection != null) {
    deviceConnection.close();
    deviceConnections.remove(usbDevice);
  }
  Log.d(Constants.TAG,""String_Node_Str"" + usbDevice.getDeviceName() + ""String_Node_Str"");
  return null;
}","@Override protected Void doInBackground(UsbDevice... params){
  if (params == null || params.length < 1) {
    return null;
  }
  UsbDevice usbDevice=params[0];
  onDeviceDetached(usbDevice);
  return null;
}",0.257183908045977
99430,"@Override public void run(){
  super.run();
  while (stopFlag == false) {
    checkConnectedDevices();
synchronized (deviceGrantQueue) {
      if (!deviceGrantQueue.isEmpty() && !isGranting) {
        isGranting=true;
        grantingDevice=deviceGrantQueue.remove();
        PendingIntent permissionIntent=PendingIntent.getBroadcast(context,0,new Intent(UsbMidiGrantedReceiver.USB_PERMISSION_GRANTED_ACTION),0);
        context.registerReceiver(new UsbMidiGrantedReceiver(grantingDevice,deviceAttachedListener),new IntentFilter(UsbMidiGrantedReceiver.USB_PERMISSION_GRANTED_ACTION));
        usbManager.requestPermission(grantingDevice,permissionIntent);
      }
    }
    try {
      sleep(1000);
    }
 catch (    InterruptedException e) {
    }
  }
  for (  UsbDevice device : grantedDevices) {
    Message message=deviceDetachedHandler.obtainMessage();
    message.obj=device;
    deviceDetachedHandler.sendMessage(message);
  }
  grantedDevices.clear();
}","@Override public void run(){
  super.run();
  while (stopFlag == false) {
    checkConnectedDevices();
synchronized (deviceGrantQueue) {
      if (!deviceGrantQueue.isEmpty() && !isGranting) {
        isGranting=true;
        grantingDevice=deviceGrantQueue.remove();
        PendingIntent permissionIntent=PendingIntent.getBroadcast(context,0,new Intent(UsbMidiGrantedReceiver.USB_PERMISSION_GRANTED_ACTION),0);
        context.registerReceiver(new UsbMidiGrantedReceiver(grantingDevice,deviceAttachedListener),new IntentFilter(UsbMidiGrantedReceiver.USB_PERMISSION_GRANTED_ACTION));
        usbManager.requestPermission(grantingDevice,permissionIntent);
      }
    }
    try {
      sleep(1000);
    }
 catch (    InterruptedException e) {
    }
  }
  for (  UsbDevice device : grantedDevices) {
    onDeviceDetached(device);
  }
  grantedDevices.clear();
}",0.899505766062603
99431,"public void checkConnectedDevicesImmediately(){
  thread.checkConnectedDevices();
}","/** 
 * Checks the connected USB MIDI devices
 */
public void checkConnectedDevicesImmediately(){
  thread.checkConnectedDevices();
}",0.7685185185185185
99432,"@Override public void onReceive(Context receiverContext,Intent intent){
  String action=intent.getAction();
  if (USB_PERMISSION_GRANTED_ACTION.equals(action)) {
    boolean granted=intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED,false);
    if (granted) {
      grantedDevices.add(device);
      deviceAttachedListener.onDeviceAttached(device);
      UsbDeviceConnection deviceConnection=usbManager.openDevice(device);
      if (deviceConnection == null) {
        return;
      }
      deviceConnections.put(device,deviceConnection);
      List<DeviceFilter> deviceFilters=DeviceFilter.getDeviceFilters(context.getApplicationContext());
      Set<MidiInputDevice> foundInputDevices=UsbMidiDeviceUtils.findMidiInputDevices(device,deviceConnection,deviceFilters);
      for (      MidiInputDevice midiInputDevice : foundInputDevices) {
        try {
          Set<MidiInputDevice> inputDevices=midiInputDevices.get(device);
          if (inputDevices == null) {
            inputDevices=new HashSet<MidiInputDevice>();
          }
          inputDevices.add(midiInputDevice);
          midiInputDevices.put(device,inputDevices);
          deviceAttachedListener.onMidiInputDeviceAttached(midiInputDevice);
        }
 catch (        IllegalArgumentException iae) {
          Log.d(Constants.TAG,""String_Node_Str"",iae);
        }
      }
      Set<MidiOutputDevice> foundOutputDevices=UsbMidiDeviceUtils.findMidiOutputDevices(device,deviceConnection,deviceFilters);
      for (      MidiOutputDevice midiOutputDevice : foundOutputDevices) {
        try {
          Set<MidiOutputDevice> outputDevices=midiOutputDevices.get(device);
          if (outputDevices == null) {
            outputDevices=new HashSet<MidiOutputDevice>();
          }
          outputDevices.add(midiOutputDevice);
          midiOutputDevices.put(device,outputDevices);
          deviceAttachedListener.onMidiOutputDeviceAttached(midiOutputDevice);
        }
 catch (        IllegalArgumentException iae) {
          Log.d(Constants.TAG,""String_Node_Str"",iae);
        }
      }
      Log.d(Constants.TAG,""String_Node_Str"" + device.getDeviceName() + ""String_Node_Str"");
    }
    isGranting=false;
    grantingDevice=null;
  }
  context.unregisterReceiver(this);
}","@Override public void onReceive(Context receiverContext,Intent intent){
  String action=intent.getAction();
  if (USB_PERMISSION_GRANTED_ACTION.equals(action)) {
    boolean granted=intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED,false);
    if (granted) {
      grantedDevices.add(device);
      deviceAttachedListener.onDeviceAttached(device);
      UsbDeviceConnection deviceConnection=usbManager.openDevice(device);
      if (deviceConnection == null) {
        return;
      }
      deviceConnections.put(device,deviceConnection);
      List<DeviceFilter> deviceFilters=DeviceFilter.getDeviceFilters(context.getApplicationContext());
      Set<MidiInputDevice> foundInputDevices=UsbMidiDeviceUtils.findMidiInputDevices(device,deviceConnection,deviceFilters);
      for (      MidiInputDevice midiInputDevice : foundInputDevices) {
        try {
          Set<MidiInputDevice> inputDevices=midiInputDevices.get(device);
          if (inputDevices == null) {
            inputDevices=new HashSet<>();
          }
          inputDevices.add(midiInputDevice);
          midiInputDevices.put(device,inputDevices);
          deviceAttachedListener.onMidiInputDeviceAttached(midiInputDevice);
        }
 catch (        IllegalArgumentException iae) {
          Log.d(Constants.TAG,""String_Node_Str"",iae);
        }
      }
      Set<MidiOutputDevice> foundOutputDevices=UsbMidiDeviceUtils.findMidiOutputDevices(device,deviceConnection,deviceFilters);
      for (      MidiOutputDevice midiOutputDevice : foundOutputDevices) {
        try {
          Set<MidiOutputDevice> outputDevices=midiOutputDevices.get(device);
          if (outputDevices == null) {
            outputDevices=new HashSet<>();
          }
          outputDevices.add(midiOutputDevice);
          midiOutputDevices.put(device,outputDevices);
          deviceAttachedListener.onMidiOutputDeviceAttached(midiOutputDevice);
        }
 catch (        IllegalArgumentException iae) {
          Log.d(Constants.TAG,""String_Node_Str"",iae);
        }
      }
      Log.d(Constants.TAG,""String_Node_Str"" + device.getDeviceName() + ""String_Node_Str"");
    }
    isGranting=false;
    grantingDevice=null;
  }
  context.unregisterReceiver(this);
}",0.9930539995518708
99433,"/** 
 * Constructor
 * @param context the Context
 * @param usbManager the UsbManager
 * @param deviceAttachedListener the OnMidiDeviceAttachedListener
 */
public MidiDeviceConnectionWatcher(@NonNull Context context,@NonNull UsbManager usbManager,@NonNull OnMidiDeviceAttachedListener deviceAttachedListener,@NonNull final OnMidiDeviceDetachedListener deviceDetachedListener){
  this.context=context;
  this.usbManager=usbManager;
  deviceGrantQueue=new LinkedList<UsbDevice>();
  isGranting=false;
  grantingDevice=null;
  grantedDevices=new HashSet<UsbDevice>();
  deviceDetachedHandler=new Handler(new Handler.Callback(){
    @Override public boolean handleMessage(    Message message){
      UsbDevice detachedDevice=(UsbDevice)message.obj;
      deviceDetachedListener.onDeviceDetached(detachedDevice);
      AsyncTask<UsbDevice,Void,Void> task=new AsyncTask<UsbDevice,Void,Void>(){
        @Override protected Void doInBackground(        UsbDevice... params){
          if (params == null || params.length < 1) {
            return null;
          }
          UsbDevice usbDevice=params[0];
          Set<MidiInputDevice> inputDevices=midiInputDevices.get(usbDevice);
          if (inputDevices != null && inputDevices.size() > 0) {
            for (            MidiInputDevice inputDevice : inputDevices) {
              if (inputDevice != null) {
                inputDevice.stop();
                deviceDetachedListener.onMidiInputDeviceDetached(inputDevice);
              }
            }
            midiInputDevices.remove(usbDevice);
          }
          Set<MidiOutputDevice> outputDevices=midiOutputDevices.get(usbDevice);
          if (outputDevices != null) {
            for (            MidiOutputDevice outputDevice : outputDevices) {
              if (outputDevice != null) {
                outputDevice.stop();
                deviceDetachedListener.onMidiOutputDeviceDetached(outputDevice);
              }
            }
            midiOutputDevices.remove(usbDevice);
          }
          UsbDeviceConnection deviceConnection=deviceConnections.get(usbDevice);
          if (deviceConnection != null) {
            deviceConnection.close();
            deviceConnections.remove(usbDevice);
          }
          Log.d(Constants.TAG,""String_Node_Str"" + usbDevice.getDeviceName() + ""String_Node_Str"");
          return null;
        }
      }
;
      task.execute(detachedDevice);
      return true;
    }
  }
);
  thread=new MidiDeviceConnectionWatchThread(usbManager,deviceAttachedListener,deviceDetachedHandler);
  thread.setName(""String_Node_Str"");
  thread.start();
}","/** 
 * Constructor
 * @param context the Context
 * @param usbManager the UsbManager
 * @param deviceAttachedListener the OnMidiDeviceAttachedListener
 */
public MidiDeviceConnectionWatcher(@NonNull Context context,@NonNull UsbManager usbManager,@NonNull OnMidiDeviceAttachedListener deviceAttachedListener,@NonNull final OnMidiDeviceDetachedListener deviceDetachedListener){
  this.context=context;
  this.usbManager=usbManager;
  isGranting=false;
  grantingDevice=null;
  this.deviceDetachedListener=deviceDetachedListener;
  deviceDetachedHandler=new Handler(new Handler.Callback(){
    @Override public boolean handleMessage(    Message message){
      AsyncTask<UsbDevice,Void,Void> task=new AsyncTask<UsbDevice,Void,Void>(){
        @Override protected Void doInBackground(        UsbDevice... params){
          if (params == null || params.length < 1) {
            return null;
          }
          UsbDevice usbDevice=params[0];
          onDeviceDetached(usbDevice);
          return null;
        }
      }
;
      UsbDevice detachedDevice=(UsbDevice)message.obj;
      task.execute(detachedDevice);
      return true;
    }
  }
);
  thread=new MidiDeviceConnectionWatchThread(usbManager,deviceAttachedListener,deviceDetachedHandler);
  thread.setName(""String_Node_Str"");
  thread.start();
}",0.5814549180327869
99434,"@Override public void onMidiSingleByte(@NonNull MidiInputDevice sender,int cable,int byte1){
  if (receiver != null) {
    try {
      final SysexMessage message=new SysexMessage();
      message.setMessage(new byte[]{(byte)(byte1 & 0xff)},1);
      receiver.send(message,-1);
    }
 catch (    final InvalidMidiDataException e) {
      Log.d(Constants.TAG,""String_Node_Str"",e);
    }
  }
}","@Override public void onMidiSingleByte(@NonNull MidiInputDevice sender,int cable,int byte1){
  if (receiver != null) {
    try {
      final ShortMessage message=new ShortMessage();
      message.setMessage(new byte[]{(byte)(byte1 & 0xff)},1);
      receiver.send(message,-1);
    }
 catch (    final InvalidMidiDataException e) {
      Log.d(Constants.TAG,""String_Node_Str"",e);
    }
  }
}",0.9794871794871794
99435,"@Override public void onMidiSingleByte(@NonNull MidiInputDevice sender,int cable,int byte1){
  if (receiver != null) {
    try {
      final SysexMessage message=new SysexMessage();
      message.setMessage(new byte[]{(byte)(byte1 & 0xff)},1);
      receiver.send(message,-1);
    }
 catch (    final InvalidMidiDataException e) {
      Log.d(Constants.TAG,""String_Node_Str"",e);
    }
  }
}","@Override public void onMidiSingleByte(@NonNull MidiInputDevice sender,int cable,int byte1){
  if (receiver != null) {
    try {
      final ShortMessage message=new ShortMessage();
      message.setMessage(new byte[]{(byte)(byte1 & 0xff)},1);
      receiver.send(message,-1);
    }
 catch (    final InvalidMidiDataException e) {
      Log.d(Constants.TAG,""String_Node_Str"",e);
    }
  }
}",0.9794871794871794
99436,"@Override public void onDestroy(){
  super.onDestroy();
  if (deviceConnectionWatcher != null) {
    deviceConnectionWatcher.stop();
  }
  deviceConnectionWatcher=null;
  if (midiInputDevice != null) {
    midiInputDevice.stop();
    midiInputDevice=null;
  }
  midiOutputDevice=null;
  deviceConnection=null;
  Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
}","@Override public void onDestroy(){
  super.onDestroy();
  if (deviceConnectionWatcher != null) {
    deviceConnectionWatcher.stop();
  }
  deviceConnectionWatcher=null;
  midiInputDevice=null;
  midiOutputDevice=null;
  deviceConnection=null;
  Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
}",0.8856729377713459
99437,"/** 
 * Get connected USB MIDI devices.
 * @return connected UsbDevice set
 */
@NonNull public final Set<UsbDevice> getConnectedUsbDevices(){
  if (deviceConnectionWatcher != null) {
    deviceConnectionWatcher.checkConnectedDevicesImmediately();
  }
  if (deviceConnections != null) {
    return Collections.unmodifiableSet(deviceConnections.keySet());
  }
  return Collections.unmodifiableSet(new HashSet<UsbDevice>());
}","/** 
 * Get connected USB MIDI devices.
 * @return connected UsbDevice set
 */
@NonNull public final Set<UsbDevice> getConnectedUsbDevices(){
  if (deviceConnectionWatcher != null) {
    deviceConnectionWatcher.checkConnectedDevicesImmediately();
  }
  if (connectedUsbDevices != null) {
    return Collections.unmodifiableSet(connectedUsbDevices);
  }
  return Collections.unmodifiableSet(new HashSet<UsbDevice>());
}",0.906064209274673
99438,"@Override public void onDeviceDetached(@NonNull UsbDevice usbDevice){
}","@Override public void onDeviceDetached(@NonNull UsbDevice usbDevice){
  connectedUsbDevices.remove(usbDevice);
  UsbMidiDriver.this.onDeviceDetached(usbDevice);
}",0.6094420600858369
99439,"@Override public void onDeviceAttached(@NonNull UsbDevice usbDevice){
}","@Override public void onDeviceAttached(@NonNull UsbDevice usbDevice){
  connectedUsbDevices.add(usbDevice);
  UsbMidiDriver.this.onDeviceAttached(usbDevice);
}",0.6173913043478261
99440,"/** 
 * Stops using UsbMidiDriver. Shutdown the USB device communicating thread. The all connected devices will be closed.
 */
public final void close(){
  if (!isOpen) {
    return;
  }
  isOpen=false;
  deviceConnectionWatcher.stop();
  deviceConnectionWatcher=null;
  if (midiInputDevices != null) {
    midiInputDevices.clear();
  }
  midiInputDevices=null;
  if (midiOutputDevices != null) {
    midiOutputDevices.clear();
  }
  midiOutputDevices=null;
  deviceConnections=null;
}","/** 
 * Stops using UsbMidiDriver. Shutdown the USB device communicating thread. The all connected devices will be closed.
 */
public final void close(){
  if (!isOpen) {
    return;
  }
  isOpen=false;
  deviceConnectionWatcher.stop();
  deviceConnectionWatcher=null;
  if (midiInputDevices != null) {
    midiInputDevices.clear();
  }
  midiInputDevices=null;
  if (midiOutputDevices != null) {
    midiOutputDevices.clear();
  }
  midiOutputDevices=null;
  if (connectedUsbDevices != null) {
    connectedUsbDevices.clear();
  }
  connectedUsbDevices=null;
}",0.8814531548757171
99441,"/** 
 * Starts using UsbMidiDriver. Starts the USB device watching and communicating thread.
 */
public final void open(){
  if (isOpen) {
    return;
  }
  isOpen=true;
  deviceConnections=new HashMap<UsbDevice,UsbDeviceConnection>();
  midiInputDevices=new HashSet<MidiInputDevice>();
  midiOutputDevices=new HashSet<MidiOutputDevice>();
  UsbManager usbManager=(UsbManager)context.getApplicationContext().getSystemService(Context.USB_SERVICE);
  deviceAttachedListener=new OnMidiDeviceAttachedListenerImpl();
  deviceDetachedListener=new OnMidiDeviceDetachedListenerImpl();
  deviceConnectionWatcher=new MidiDeviceConnectionWatcher(context.getApplicationContext(),usbManager,deviceAttachedListener,deviceDetachedListener);
}","/** 
 * Starts using UsbMidiDriver. Starts the USB device watching and communicating thread.
 */
public final void open(){
  if (isOpen) {
    return;
  }
  isOpen=true;
  connectedUsbDevices=new HashSet<>();
  midiInputDevices=new HashSet<>();
  midiOutputDevices=new HashSet<>();
  UsbManager usbManager=(UsbManager)context.getApplicationContext().getSystemService(Context.USB_SERVICE);
  deviceAttachedListener=new OnMidiDeviceAttachedListenerImpl();
  deviceDetachedListener=new OnMidiDeviceDetachedListenerImpl();
  deviceConnectionWatcher=new MidiDeviceConnectionWatcher(context.getApplicationContext(),usbManager,deviceAttachedListener,deviceDetachedListener);
}",0.9283667621776504
99442,"/** 
 * Get connected USB MIDI devices.
 * @return connected UsbDevice set
 */
@NonNull public final Set<UsbDevice> getConnectedUsbDevices(){
  if (deviceConnectionWatcher != null) {
    deviceConnectionWatcher.checkConnectedDevicesImmediately();
  }
  if (deviceConnections != null) {
    return Collections.unmodifiableSet(deviceConnections.keySet());
  }
  return Collections.unmodifiableSet(new HashSet<UsbDevice>());
}","/** 
 * Get connected USB MIDI devices.
 * @return connected UsbDevice set
 */
@NonNull public final Set<UsbDevice> getConnectedUsbDevices(){
  if (deviceConnectionWatcher != null) {
    deviceConnectionWatcher.checkConnectedDevicesImmediately();
  }
  if (connectedUsbDevices != null) {
    return Collections.unmodifiableSet(connectedUsbDevices);
  }
  return Collections.unmodifiableSet(new HashSet<UsbDevice>());
}",0.906064209274673
99443,"/** 
 * Get MIDI output device, if available.
 * @param usbDevice the UsbDevice
 * @return {@link Set<MidiOutputDevice>}
 */
@NonNull public final Set<MidiOutputDevice> getMidiOutputDevices(@NonNull UsbDevice usbDevice){
  if (deviceConnectionWatcher != null) {
    deviceConnectionWatcher.checkConnectedDevicesImmediately();
  }
  return Collections.unmodifiableSet(midiOutputDevices);
}","/** 
 * Get the all MIDI output devices.
 * @return {@link Set<MidiOutputDevice>}
 */
@NonNull public final Set<MidiOutputDevice> getMidiOutputDevices(){
  if (deviceConnectionWatcher != null) {
    deviceConnectionWatcher.checkConnectedDevicesImmediately();
  }
  return Collections.unmodifiableSet(midiOutputDevices);
}",0.8801128349788434
99444,"@Override public void onDeviceDetached(@NonNull UsbDevice usbDevice){
}","@Override public void onDeviceDetached(@NonNull UsbDevice usbDevice){
  connectedUsbDevices.remove(usbDevice);
  UsbMidiDriver.this.onDeviceDetached(usbDevice);
}",0.6094420600858369
99445,"@Override public void onDeviceAttached(@NonNull UsbDevice usbDevice){
}","@Override public void onDeviceAttached(@NonNull UsbDevice usbDevice){
  connectedUsbDevices.add(usbDevice);
  UsbMidiDriver.this.onDeviceAttached(usbDevice);
}",0.6173913043478261
99446,"/** 
 * Stops using UsbMidiDriver. Shutdown the USB device communicating thread. The all connected devices will be closed.
 */
public final void close(){
  if (!isOpen) {
    return;
  }
  isOpen=false;
  deviceConnectionWatcher.stop();
  deviceConnectionWatcher=null;
  if (midiInputDevices != null) {
    midiInputDevices.clear();
  }
  midiInputDevices=null;
  if (midiOutputDevices != null) {
    midiOutputDevices.clear();
  }
  midiOutputDevices=null;
  deviceConnections=null;
}","/** 
 * Stops using UsbMidiDriver. Shutdown the USB device communicating thread. The all connected devices will be closed.
 */
public final void close(){
  if (!isOpen) {
    return;
  }
  isOpen=false;
  deviceConnectionWatcher.stop();
  deviceConnectionWatcher=null;
  if (midiInputDevices != null) {
    midiInputDevices.clear();
  }
  midiInputDevices=null;
  if (midiOutputDevices != null) {
    midiOutputDevices.clear();
  }
  midiOutputDevices=null;
  if (connectedUsbDevices != null) {
    connectedUsbDevices.clear();
  }
  connectedUsbDevices=null;
}",0.8814531548757171
99447,"/** 
 * Starts using UsbMidiDriver. Starts the USB device watching and communicating thread.
 */
public final void open(){
  if (isOpen) {
    return;
  }
  isOpen=true;
  deviceConnections=new HashMap<UsbDevice,UsbDeviceConnection>();
  midiInputDevices=new HashSet<MidiInputDevice>();
  midiOutputDevices=new HashSet<MidiOutputDevice>();
  UsbManager usbManager=(UsbManager)context.getApplicationContext().getSystemService(Context.USB_SERVICE);
  deviceAttachedListener=new OnMidiDeviceAttachedListenerImpl();
  deviceDetachedListener=new OnMidiDeviceDetachedListenerImpl();
  deviceConnectionWatcher=new MidiDeviceConnectionWatcher(context.getApplicationContext(),usbManager,deviceAttachedListener,deviceDetachedListener);
}","/** 
 * Starts using UsbMidiDriver. Starts the USB device watching and communicating thread.
 */
public final void open(){
  if (isOpen) {
    return;
  }
  isOpen=true;
  connectedUsbDevices=new HashSet<>();
  midiInputDevices=new HashSet<>();
  midiOutputDevices=new HashSet<>();
  UsbManager usbManager=(UsbManager)context.getApplicationContext().getSystemService(Context.USB_SERVICE);
  deviceAttachedListener=new OnMidiDeviceAttachedListenerImpl();
  deviceDetachedListener=new OnMidiDeviceDetachedListenerImpl();
  deviceConnectionWatcher=new MidiDeviceConnectionWatcher(context.getApplicationContext(),usbManager,deviceAttachedListener,deviceDetachedListener);
}",0.9283667621776504
99448,"/** 
 * NRPN message This method is just the utility method, do not need to be implemented necessarily by subclass.
 * @param sender the Object which the event sent
 * @param cable the cable ID 0-15
 * @param channel the MIDI channel number 0-15
 * @param function 14bits
 * @param valueMSB higher 7bits
 * @param valueLSB lower 7bits. -1 if value has no LSB. If you know the function's parameter value have LSB, you must ignore when valueLSB < 0.
 */
@Override public void onMidiNRPNReceived(@NonNull MidiInputDevice sender,int cable,int channel,int function,int valueMSB,int valueLSB){
}","@Override public void onMidiNRPNReceived(@NonNull MidiInputDevice sender,int cable,int channel,int function,int value){
}",0.3408450704225352
99449,"/** 
 * RPN message This method is just the utility method, do not need to be implemented necessarily by subclass.
 * @param sender the Object which the event sent
 * @param cable the cable ID 0-15
 * @param channel the MIDI channel number 0-15
 * @param function 14bits
 * @param valueMSB higher 7bits
 * @param valueLSB lower 7bits. -1 if value has no LSB. If you know the function's parameter value have LSB, you must ignore when valueLSB < 0.
 */
@Override public void onMidiRPNReceived(@NonNull MidiInputDevice sender,int cable,int channel,int function,int valueMSB,int valueLSB){
}","@Override public void onMidiRPNReceived(@NonNull MidiInputDevice sender,int cable,int channel,int function,int value){
}",0.3394625176803394
99450,"/** 
 * NRPN message This method is just the utility method, do not need to be implemented necessarily by subclass.
 * @param sender the Object which the event sent
 * @param cable the cable ID 0-15
 * @param channel the MIDI channel number 0-15
 * @param function 14bits
 * @param valueMSB higher 7bits
 * @param valueLSB lower 7bits. -1 if value has no LSB. If you know the function's parameter value have LSB, you must ignore when valueLSB < 0.
 */
@Override public void onMidiNRPNReceived(@NonNull MidiInputDevice sender,int cable,int channel,int function,int valueMSB,int valueLSB){
}","@Override public void onMidiNRPNReceived(@NonNull MidiInputDevice sender,int cable,int channel,int function,int value){
}",0.3408450704225352
99451,"/** 
 * RPN message This method is just the utility method, do not need to be implemented necessarily by subclass.
 * @param sender the Object which the event sent
 * @param cable the cable ID 0-15
 * @param channel the MIDI channel number 0-15
 * @param function 14bits
 * @param valueMSB higher 7bits
 * @param valueLSB lower 7bits. -1 if value has no LSB. If you know the function's parameter value have LSB, you must ignore when valueLSB < 0.
 */
@Override public void onMidiRPNReceived(@NonNull MidiInputDevice sender,int cable,int channel,int function,int valueMSB,int valueLSB){
}","@Override public void onMidiRPNReceived(@NonNull MidiInputDevice sender,int cable,int channel,int function,int value){
}",0.3394625176803394
99452,"@Override public void onMidiNRPNReceived(@NonNull MidiInputDevice sender,int cable,int channel,int function,int valueMSB,int valueLSB){
  List<AbstractMidiFragment> midiFragments=getMidiFragments();
  for (  AbstractMidiFragment fragment : midiFragments) {
    fragment.onMidiNRPNReceived(sender,cable,channel,function,valueMSB,valueLSB);
  }
}","@Override public void onMidiNRPNReceived(@NonNull MidiInputDevice sender,int cable,int channel,int function,int value){
  List<AbstractMidiFragment> midiFragments=getMidiFragments();
  for (  AbstractMidiFragment fragment : midiFragments) {
    fragment.onMidiNRPNReceived(sender,cable,channel,function,value);
  }
}",0.9575757575757576
99453,"@Override public void onMidiRPNReceived(@NonNull MidiInputDevice sender,int cable,int channel,int function,int valueMSB,int valueLSB){
  List<AbstractMidiFragment> midiFragments=getMidiFragments();
  for (  AbstractMidiFragment fragment : midiFragments) {
    fragment.onMidiRPNReceived(sender,cable,channel,function,valueMSB,valueLSB);
  }
}","@Override public void onMidiRPNReceived(@NonNull MidiInputDevice sender,int cable,int channel,int function,int value){
  List<AbstractMidiFragment> midiFragments=getMidiFragments();
  for (  AbstractMidiFragment fragment : midiFragments) {
    fragment.onMidiRPNReceived(sender,cable,channel,function,value);
  }
}",0.9573170731707316
99454,"@Override public void run(){
  final UsbDeviceConnection deviceConnection=usbDeviceConnection;
  final UsbEndpoint usbEndpoint=inputEndpoint;
  final MidiInputDevice sender=MidiInputDevice.this;
  final int maxPacketSize=inputEndpoint.getMaxPacketSize();
  final byte[] bulkReadBuffer=new byte[maxPacketSize];
  byte[] readBuffer=new byte[maxPacketSize * 2];
  int readBufferSize=0;
  byte[] read=new byte[maxPacketSize * 2];
  int length;
  int cable;
  int codeIndexNumber;
  int byte1;
  int byte2;
  int byte3;
  int i;
  @SuppressWarnings(""String_Node_Str"") ReusableByteArrayOutputStream[] systemExclusive=new ReusableByteArrayOutputStream[16];
  for (i=0; i < 16; i++) {
    systemExclusive[i]=new ReusableByteArrayOutputStream();
  }
  while (!stopFlag) {
    length=deviceConnection.bulkTransfer(usbEndpoint,bulkReadBuffer,maxPacketSize,0);
synchronized (suspendSignal) {
      if (suspendFlag) {
        try {
          suspendSignal.wait(100);
        }
 catch (        InterruptedException e) {
        }
        continue;
      }
    }
    if (length <= 0) {
      continue;
    }
    System.arraycopy(bulkReadBuffer,0,readBuffer,readBufferSize,length);
    readBufferSize+=length;
    if (readBufferSize < 4) {
      continue;
    }
    final int readSize=readBufferSize / 4 * 4;
    System.arraycopy(readBuffer,0,read,0,readSize);
    final int unreadSize=readBufferSize - readSize;
    if (unreadSize > 0) {
      System.arraycopy(readBuffer,readSize,readBuffer,0,unreadSize);
      readBufferSize=unreadSize;
    }
 else {
      readBufferSize=0;
    }
    for (i=0; i < readSize; i+=4) {
      cable=(read[i] >> 4) & 0xf;
      codeIndexNumber=read[i] & 0xf;
      byte1=read[i + 1] & 0xff;
      byte2=read[i + 2] & 0xff;
      byte3=read[i + 3] & 0xff;
switch (codeIndexNumber) {
case 0:
        if (midiEventListener != null) {
          midiEventListener.onMidiMiscellaneousFunctionCodes(sender,cable,byte1,byte2,byte3);
        }
      break;
case 1:
    if (midiEventListener != null) {
      midiEventListener.onMidiCableEvents(sender,cable,byte1,byte2,byte3);
    }
  break;
case 2:
if (midiEventListener != null) {
  byte[] bytes=new byte[]{(byte)byte1,(byte)byte2};
  midiEventListener.onMidiSystemCommonMessage(sender,cable,bytes);
}
break;
case 3:
if (midiEventListener != null) {
byte[] bytes=new byte[]{(byte)byte1,(byte)byte2,(byte)byte3};
midiEventListener.onMidiSystemCommonMessage(sender,cable,bytes);
}
break;
case 4:
synchronized (systemExclusive[cable]) {
systemExclusive[cable].write(byte1);
systemExclusive[cable].write(byte2);
systemExclusive[cable].write(byte3);
}
break;
case 5:
synchronized (systemExclusive[cable]) {
systemExclusive[cable].write(byte1);
if (midiEventListener != null) {
midiEventListener.onMidiSystemExclusive(sender,cable,systemExclusive[cable].toByteArray());
}
systemExclusive[cable].reset();
}
break;
case 6:
synchronized (systemExclusive[cable]) {
systemExclusive[cable].write(byte1);
systemExclusive[cable].write(byte2);
if (midiEventListener != null) {
midiEventListener.onMidiSystemExclusive(sender,cable,systemExclusive[cable].toByteArray());
}
systemExclusive[cable].reset();
}
break;
case 7:
synchronized (systemExclusive[cable]) {
systemExclusive[cable].write(byte1);
systemExclusive[cable].write(byte2);
systemExclusive[cable].write(byte3);
if (midiEventListener != null) {
midiEventListener.onMidiSystemExclusive(sender,cable,systemExclusive[cable].toByteArray());
}
systemExclusive[cable].reset();
}
break;
case 8:
if (midiEventListener != null) {
midiEventListener.onMidiNoteOff(sender,cable,byte1 & 0xf,byte2,byte3);
}
break;
case 9:
if (midiEventListener != null) {
if (byte3 == 0x00) {
midiEventListener.onMidiNoteOff(sender,cable,byte1 & 0xf,byte2,byte3);
}
 else {
midiEventListener.onMidiNoteOn(sender,cable,byte1 & 0xf,byte2,byte3);
}
}
break;
case 10:
if (midiEventListener != null) {
midiEventListener.onMidiPolyphonicAftertouch(sender,cable,byte1 & 0xf,byte2,byte3);
}
break;
case 11:
if (midiEventListener != null) {
midiEventListener.onMidiControlChange(sender,cable,byte1 & 0xf,byte2,byte3);
}
processRpnMessages(cable,byte1,byte2,byte3,sender);
break;
case 12:
if (midiEventListener != null) {
midiEventListener.onMidiProgramChange(sender,cable,byte1 & 0xf,byte2);
}
break;
case 13:
if (midiEventListener != null) {
midiEventListener.onMidiChannelAftertouch(sender,cable,byte1 & 0xf,byte2);
}
break;
case 14:
if (midiEventListener != null) {
midiEventListener.onMidiPitchWheel(sender,cable,byte1 & 0xf,byte2 | (byte3 << 7));
}
break;
case 15:
if (midiEventListener != null) {
midiEventListener.onMidiSingleByte(sender,cable,byte1);
}
break;
default :
break;
}
}
}
}","@Override public void run(){
  final UsbDeviceConnection deviceConnection=usbDeviceConnection;
  final UsbEndpoint usbEndpoint=inputEndpoint;
  final int maxPacketSize=inputEndpoint.getMaxPacketSize();
  final MidiInputDevice sender=MidiInputDevice.this;
  final OnMidiInputEventListener midiEventListener=MidiInputDevice.this.midiEventListener;
  final byte[] bulkReadBuffer=new byte[maxPacketSize];
  byte[] readBuffer=new byte[maxPacketSize * 2];
  int readBufferSize=0;
  byte[] read=new byte[maxPacketSize * 2];
  int length;
  int cable;
  int codeIndexNumber;
  int byte1;
  int byte2;
  int byte3;
  int i;
  int readSize;
  int unreadSize;
  final int RPN_STATUS_NONE=0;
  final int RPN_STATUS_RPN=1;
  final int RPN_STATUS_NRPN=2;
  int rpnNrpnFunction;
  int rpnNrpnValueMsb;
  int rpnNrpnValueLsb;
  int rpnStatus=RPN_STATUS_NONE;
  int rpnFunctionMsb=0x7f;
  int rpnFunctionLsb=0x7f;
  int nrpnFunctionMsb=0x7f;
  int nrpnFunctionLsb=0x7f;
  SparseIntArray rpnCacheMsb=new SparseIntArray();
  SparseIntArray rpnCacheLsb=new SparseIntArray();
  SparseIntArray nrpnCacheMsb=new SparseIntArray();
  SparseIntArray nrpnCacheLsb=new SparseIntArray();
  ReusableByteArrayOutputStream[] systemExclusive=new ReusableByteArrayOutputStream[16];
  for (i=0; i < 16; i++) {
    systemExclusive[i]=new ReusableByteArrayOutputStream();
  }
  while (!stopFlag) {
    length=deviceConnection.bulkTransfer(usbEndpoint,bulkReadBuffer,maxPacketSize,10);
synchronized (suspendSignal) {
      if (suspendFlag) {
        try {
          suspendSignal.wait(100);
        }
 catch (        InterruptedException e) {
        }
        continue;
      }
    }
    if (length <= 0) {
      continue;
    }
    System.arraycopy(bulkReadBuffer,0,readBuffer,readBufferSize,length);
    readBufferSize+=length;
    if (readBufferSize < 4) {
      continue;
    }
    readSize=readBufferSize / 4 * 4;
    System.arraycopy(readBuffer,0,read,0,readSize);
    unreadSize=readBufferSize - readSize;
    if (unreadSize > 0) {
      System.arraycopy(readBuffer,readSize,readBuffer,0,unreadSize);
      readBufferSize=unreadSize;
    }
 else {
      readBufferSize=0;
    }
    for (i=0; i < readSize; i+=4) {
      cable=(read[i] >> 4) & 0xf;
      codeIndexNumber=read[i] & 0xf;
      byte1=read[i + 1] & 0xff;
      byte2=read[i + 2] & 0xff;
      byte3=read[i + 3] & 0xff;
switch (codeIndexNumber) {
case 0:
        if (midiEventListener != null) {
          midiEventListener.onMidiMiscellaneousFunctionCodes(sender,cable,byte1,byte2,byte3);
        }
      break;
case 1:
    if (midiEventListener != null) {
      midiEventListener.onMidiCableEvents(sender,cable,byte1,byte2,byte3);
    }
  break;
case 2:
if (midiEventListener != null) {
  byte[] bytes=new byte[]{(byte)byte1,(byte)byte2};
  midiEventListener.onMidiSystemCommonMessage(sender,cable,bytes);
}
break;
case 3:
if (midiEventListener != null) {
byte[] bytes=new byte[]{(byte)byte1,(byte)byte2,(byte)byte3};
midiEventListener.onMidiSystemCommonMessage(sender,cable,bytes);
}
break;
case 4:
synchronized (systemExclusive[cable]) {
systemExclusive[cable].write(byte1);
systemExclusive[cable].write(byte2);
systemExclusive[cable].write(byte3);
}
break;
case 5:
synchronized (systemExclusive[cable]) {
systemExclusive[cable].write(byte1);
if (midiEventListener != null) {
midiEventListener.onMidiSystemExclusive(sender,cable,systemExclusive[cable].toByteArray());
}
systemExclusive[cable].reset();
}
break;
case 6:
synchronized (systemExclusive[cable]) {
systemExclusive[cable].write(byte1);
systemExclusive[cable].write(byte2);
if (midiEventListener != null) {
midiEventListener.onMidiSystemExclusive(sender,cable,systemExclusive[cable].toByteArray());
}
systemExclusive[cable].reset();
}
break;
case 7:
synchronized (systemExclusive[cable]) {
systemExclusive[cable].write(byte1);
systemExclusive[cable].write(byte2);
systemExclusive[cable].write(byte3);
if (midiEventListener != null) {
midiEventListener.onMidiSystemExclusive(sender,cable,systemExclusive[cable].toByteArray());
}
systemExclusive[cable].reset();
}
break;
case 8:
if (midiEventListener != null) {
midiEventListener.onMidiNoteOff(sender,cable,byte1 & 0xf,byte2,byte3);
}
break;
case 9:
if (midiEventListener != null) {
if (byte3 == 0x00) {
midiEventListener.onMidiNoteOff(sender,cable,byte1 & 0xf,byte2,byte3);
}
 else {
midiEventListener.onMidiNoteOn(sender,cable,byte1 & 0xf,byte2,byte3);
}
}
break;
case 10:
if (midiEventListener != null) {
midiEventListener.onMidiPolyphonicAftertouch(sender,cable,byte1 & 0xf,byte2,byte3);
}
break;
case 11:
if (midiEventListener != null) {
midiEventListener.onMidiControlChange(sender,cable,byte1 & 0xf,byte2,byte3);
}
switch (byte2) {
case 6:
{
rpnNrpnValueMsb=byte3 & 0x7f;
if (rpnStatus == RPN_STATUS_RPN) {
rpnNrpnFunction=((rpnFunctionMsb & 0x7f) << 7) | (rpnFunctionLsb & 0x7f);
rpnCacheMsb.put(rpnNrpnFunction,rpnNrpnValueMsb);
rpnNrpnValueLsb=rpnCacheLsb.get(rpnNrpnFunction,0);
if (midiEventListener != null) {
midiEventListener.onMidiRPNReceived(sender,cable,byte1 & 0xf,rpnNrpnFunction,(rpnNrpnValueMsb << 7 | rpnNrpnValueLsb));
midiEventListener.onMidiRPNReceived(sender,cable,byte1 & 0xf,rpnNrpnFunction,rpnNrpnValueMsb,rpnNrpnValueLsb);
}
}
 else if (rpnStatus == RPN_STATUS_NRPN) {
rpnNrpnFunction=((nrpnFunctionMsb & 0x7f) << 7) | (nrpnFunctionLsb & 0x7f);
nrpnCacheMsb.put(rpnNrpnFunction,rpnNrpnValueMsb);
rpnNrpnValueLsb=nrpnCacheLsb.get(rpnNrpnFunction,0);
if (midiEventListener != null) {
midiEventListener.onMidiNRPNReceived(sender,cable,byte1 & 0xf,rpnNrpnFunction,(rpnNrpnValueMsb << 7 | rpnNrpnValueLsb));
midiEventListener.onMidiNRPNReceived(sender,cable,byte1 & 0xf,rpnNrpnFunction,rpnNrpnValueMsb,rpnNrpnValueLsb);
}
}
break;
}
case 38:
{
rpnNrpnValueLsb=byte3 & 0x7f;
if (rpnStatus == RPN_STATUS_RPN) {
rpnNrpnFunction=((rpnFunctionMsb & 0x7f) << 7) | (rpnFunctionLsb & 0x7f);
rpnNrpnValueMsb=rpnCacheMsb.get(rpnNrpnFunction,0);
rpnCacheLsb.put(rpnNrpnFunction,rpnNrpnValueLsb);
if (midiEventListener != null) {
midiEventListener.onMidiRPNReceived(sender,cable,byte1 & 0xf,rpnNrpnFunction,(rpnNrpnValueMsb << 7 | rpnNrpnValueLsb));
midiEventListener.onMidiRPNReceived(sender,cable,byte1 & 0xf,rpnNrpnFunction,rpnNrpnValueMsb,rpnNrpnValueLsb);
}
}
 else if (rpnStatus == RPN_STATUS_NRPN) {
rpnNrpnFunction=((nrpnFunctionMsb & 0x7f) << 7) | (nrpnFunctionLsb & 0x7f);
rpnNrpnValueMsb=nrpnCacheMsb.get(rpnNrpnFunction,0);
nrpnCacheLsb.put(rpnNrpnFunction,rpnNrpnValueLsb);
if (midiEventListener != null) {
midiEventListener.onMidiNRPNReceived(sender,cable,byte1 & 0xf,rpnNrpnFunction,(rpnNrpnValueMsb << 7 | rpnNrpnValueLsb));
midiEventListener.onMidiNRPNReceived(sender,cable,byte1 & 0xf,rpnNrpnFunction,rpnNrpnValueMsb,rpnNrpnValueLsb);
}
}
break;
}
case 98:
{
nrpnFunctionLsb=byte3 & 0x7f;
rpnStatus=RPN_STATUS_NRPN;
break;
}
case 99:
{
nrpnFunctionMsb=byte3 & 0x7f;
rpnStatus=RPN_STATUS_NRPN;
break;
}
case 100:
{
rpnFunctionLsb=byte3 & 0x7f;
if (rpnFunctionMsb == 0x7f && rpnFunctionLsb == 0x7f) {
rpnStatus=RPN_STATUS_NONE;
}
 else {
rpnStatus=RPN_STATUS_RPN;
}
break;
}
case 101:
{
rpnFunctionMsb=byte3 & 0x7f;
if (rpnFunctionMsb == 0x7f && rpnFunctionLsb == 0x7f) {
rpnStatus=RPN_STATUS_NONE;
}
 else {
rpnStatus=RPN_STATUS_RPN;
}
break;
}
default :
break;
}
break;
case 12:
if (midiEventListener != null) {
midiEventListener.onMidiProgramChange(sender,cable,byte1 & 0xf,byte2);
}
break;
case 13:
if (midiEventListener != null) {
midiEventListener.onMidiChannelAftertouch(sender,cable,byte1 & 0xf,byte2);
}
break;
case 14:
if (midiEventListener != null) {
midiEventListener.onMidiPitchWheel(sender,cable,byte1 & 0xf,byte2 | (byte3 << 7));
}
break;
case 15:
if (midiEventListener != null) {
midiEventListener.onMidiSingleByte(sender,cable,byte1);
}
break;
default :
break;
}
}
}
}",0.727565651683583
99455,"/** 
 * constructor
 * @param usbManager
 * @param deviceAttachedListener
 * @param deviceDetachedHandler
 */
MidiDeviceConnectionWatchThread(UsbManager usbManager,OnMidiDeviceAttachedListener deviceAttachedListener,Handler deviceDetachedHandler){
  this.usbManager=usbManager;
  this.deviceAttachedListener=deviceAttachedListener;
  this.deviceDetachedHandler=deviceDetachedHandler;
  connectedDeviceNameSet=new HashSet<String>();
  removedDeviceNames=new HashSet<String>();
  stopFlag=false;
  deviceFilters=DeviceFilter.getDeviceFilters(context);
}","/** 
 * constructor
 * @param usbManager
 * @param deviceAttachedListener
 * @param deviceDetachedHandler
 */
MidiDeviceConnectionWatchThread(UsbManager usbManager,OnMidiDeviceAttachedListener deviceAttachedListener,Handler deviceDetachedHandler){
  this.usbManager=usbManager;
  this.deviceAttachedListener=deviceAttachedListener;
  this.deviceDetachedHandler=deviceDetachedHandler;
  connectedDevices=new HashSet<UsbDevice>();
  stopFlag=false;
  deviceFilters=DeviceFilter.getDeviceFilters(context);
}",0.7924170616113744
99456,"@Override public void run(){
  super.run();
  while (stopFlag == false) {
    checkConnectedDevices();
synchronized (deviceGrantQueue) {
      if (!deviceGrantQueue.isEmpty() && !isGranting) {
        isGranting=true;
        UsbDevice device=deviceGrantQueue.remove();
        PendingIntent permissionIntent=PendingIntent.getBroadcast(context,0,new Intent(UsbMidiGrantedReceiver.USB_PERMISSION_GRANTED_ACTION),0);
        usbMidiGrantedReceiver=new UsbMidiGrantedReceiver(device.getDeviceName(),device,deviceAttachedListener);
        context.registerReceiver(usbMidiGrantedReceiver,new IntentFilter(UsbMidiGrantedReceiver.USB_PERMISSION_GRANTED_ACTION));
        usbManager.requestPermission(device,permissionIntent);
      }
    }
    try {
      sleep(1000);
    }
 catch (    InterruptedException e) {
    }
  }
}","@Override public void run(){
  super.run();
  while (stopFlag == false) {
    checkConnectedDevices();
synchronized (deviceGrantQueue) {
      if (!deviceGrantQueue.isEmpty() && !isGranting) {
        isGranting=true;
        grantingDevice=deviceGrantQueue.remove();
        PendingIntent permissionIntent=PendingIntent.getBroadcast(context,0,new Intent(UsbMidiGrantedReceiver.USB_PERMISSION_GRANTED_ACTION),0);
        usbMidiGrantedReceiver=new UsbMidiGrantedReceiver(grantingDevice,deviceAttachedListener);
        context.registerReceiver(usbMidiGrantedReceiver,new IntentFilter(UsbMidiGrantedReceiver.USB_PERMISSION_GRANTED_ACTION));
        usbManager.requestPermission(grantingDevice,permissionIntent);
      }
    }
    try {
      sleep(1000);
    }
 catch (    InterruptedException e) {
    }
  }
}",0.9637369391518132
99457,"/** 
 * checks Attached/Detached devices
 */
synchronized void checkConnectedDevices(){
  HashMap<String,UsbDevice> deviceMap=usbManager.getDeviceList();
  for (  String deviceName : deviceMap.keySet()) {
    if (removedDeviceNames.contains(deviceName)) {
      continue;
    }
    if (!connectedDeviceNameSet.contains(deviceName)) {
      connectedDeviceNameSet.add(deviceName);
      UsbDevice device=deviceMap.get(deviceName);
      Set<UsbInterface> midiInterfaces=UsbMidiDeviceUtils.findAllMidiInterfaces(device,deviceFilters);
      if (midiInterfaces.size() > 0) {
synchronized (deviceGrantQueue) {
          deviceGrantQueue.add(device);
        }
      }
    }
  }
  for (  String deviceName : connectedDeviceNameSet) {
    if (!deviceMap.containsKey(deviceName)) {
      removedDeviceNames.add(deviceName);
      UsbDevice device=grantedDeviceMap.remove(deviceName);
      Log.d(Constants.TAG,""String_Node_Str"" + deviceName + ""String_Node_Str""+ device+ ""String_Node_Str"");
      if (device != null) {
        Message message=deviceDetachedHandler.obtainMessage();
        message.obj=device;
        deviceDetachedHandler.sendMessage(message);
      }
    }
  }
  connectedDeviceNameSet.removeAll(removedDeviceNames);
}","/** 
 * checks Attached/Detached devices
 */
synchronized void checkConnectedDevices(){
  HashMap<String,UsbDevice> deviceMap=usbManager.getDeviceList();
  for (  UsbDevice device : deviceMap.values()) {
    if (deviceGrantQueue.contains(device) || connectedDevices.contains(device)) {
      continue;
    }
    Set<UsbInterface> midiInterfaces=UsbMidiDeviceUtils.findAllMidiInterfaces(device,deviceFilters);
    if (midiInterfaces.size() > 0) {
      Log.d(Constants.TAG,""String_Node_Str"" + device.getDeviceName() + ""String_Node_Str""+ device);
synchronized (deviceGrantQueue) {
        deviceGrantQueue.add(device);
      }
    }
  }
  for (  UsbDevice device : connectedDevices) {
    if (!deviceMap.containsValue(device)) {
      if (device.equals(grantingDevice)) {
        grantingDevice=null;
        continue;
      }
      grantedDevices.remove(device);
      Log.d(Constants.TAG,""String_Node_Str"" + device.getDeviceName() + ""String_Node_Str""+ device);
      Message message=deviceDetachedHandler.obtainMessage();
      message.obj=device;
      deviceDetachedHandler.sendMessage(message);
    }
  }
  connectedDevices.clear();
  connectedDevices.addAll(deviceMap.values());
}",0.4600082884376295
99458,"@Override public void onReceive(Context receiverContext,Intent intent){
  String action=intent.getAction();
  if (USB_PERMISSION_GRANTED_ACTION.equals(action)) {
    boolean granted=intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED,false);
    if (granted) {
      if (deviceAttachedListener != null && device != null) {
        grantedDeviceMap.put(deviceName,device);
        deviceAttachedListener.onDeviceAttached(device);
      }
    }
 else {
      notifyDeviceGranted();
    }
  }
}","@Override public void onReceive(Context receiverContext,Intent intent){
  String action=intent.getAction();
  if (USB_PERMISSION_GRANTED_ACTION.equals(action)) {
    boolean granted=intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED,false);
    if (granted) {
      if (deviceAttachedListener != null && device != null) {
        grantedDevices.add(device);
        deviceAttachedListener.onDeviceAttached(device);
      }
      isGranting=false;
      grantingDevice=null;
    }
 else {
      notifyDeviceGranted();
    }
  }
}",0.7891682785299806
99459,"/** 
 * constructor
 * @param context
 * @param usbManager
 * @param deviceAttachedListener
 * @param deviceDetachedListener
 */
public MidiDeviceConnectionWatcher(Context context,UsbManager usbManager,OnMidiDeviceAttachedListener deviceAttachedListener,final OnMidiDeviceDetachedListener deviceDetachedListener){
  this.context=context;
  deviceGrantQueue=new LinkedList<UsbDevice>();
  isGranting=false;
  grantedDeviceMap=new HashMap<String,UsbDevice>();
  deviceDetachedHandler=new Handler(new Handler.Callback(){
    @Override public boolean handleMessage(    Message message){
      UsbDevice detachedDevice=(UsbDevice)message.obj;
      deviceDetachedListener.onDeviceDetached(detachedDevice);
      return true;
    }
  }
);
  thread=new MidiDeviceConnectionWatchThread(usbManager,deviceAttachedListener,deviceDetachedHandler);
  thread.setName(""String_Node_Str"");
  thread.start();
}","/** 
 * constructor
 * @param context
 * @param usbManager
 * @param deviceAttachedListener
 * @param deviceDetachedListener
 */
public MidiDeviceConnectionWatcher(Context context,UsbManager usbManager,OnMidiDeviceAttachedListener deviceAttachedListener,final OnMidiDeviceDetachedListener deviceDetachedListener){
  this.context=context;
  deviceGrantQueue=new LinkedList<UsbDevice>();
  isGranting=false;
  grantingDevice=null;
  grantedDevices=new HashSet<UsbDevice>();
  deviceDetachedHandler=new Handler(new Handler.Callback(){
    @Override public boolean handleMessage(    Message message){
      UsbDevice detachedDevice=(UsbDevice)message.obj;
      deviceDetachedListener.onDeviceDetached(detachedDevice);
      return true;
    }
  }
);
  thread=new MidiDeviceConnectionWatchThread(usbManager,deviceAttachedListener,deviceDetachedHandler);
  thread.setName(""String_Node_Str"");
  thread.start();
}",0.9688542825361512
99460,"/** 
 * @param device
 * @param deviceAttachedListener
 */
public UsbMidiGrantedReceiver(String deviceName,UsbDevice device,OnMidiDeviceAttachedListener deviceAttachedListener){
  this.deviceName=deviceName;
  this.device=device;
  this.deviceAttachedListener=deviceAttachedListener;
}","/** 
 * @param device
 * @param deviceAttachedListener
 */
public UsbMidiGrantedReceiver(UsbDevice device,OnMidiDeviceAttachedListener deviceAttachedListener){
  this.device=device;
  this.deviceAttachedListener=deviceAttachedListener;
}",0.7854406130268199
99461,"/** 
 * Sends MIDI message to output device.
 * @param codeIndexNumber Code Index Number(CIN)
 * @param cable the cable ID 0-15
 * @param byte1 the first byte
 * @param byte2 the second byte
 * @param byte3 the third byte
 */
private void sendMidiMessage(int codeIndexNumber,int cable,int byte1,int byte2,int byte3){
  byte[] writeBuffer=new byte[4];
  writeBuffer[0]=(byte)(((cable & 0xf) << 4) | (codeIndexNumber & 0xf));
  writeBuffer[1]=(byte)byte1;
  writeBuffer[2]=(byte)byte2;
  writeBuffer[3]=(byte)byte3;
  Handler handler=waiterThread.getHandler();
  handler.sendMessage(Message.obtain(handler,0,writeBuffer));
}","/** 
 * Send a MIDI message with 3 bytes raw MIDI data
 * @param cable the cable ID 0-15
 * @param byte1 the first byte
 * @param byte2 the second byte: ignored when 1 byte message
 * @param byte3 the third byte: ignored when 1-2 byte message
 */
public void sendMidiMessage(int cable,int byte1,int byte2,int byte3){
  int codeIndexNumber=0;
switch (byte1 & 0xf0) {
case 0x80:
    codeIndexNumber=0x8;
  break;
case 0x90:
codeIndexNumber=0x9;
break;
case 0xa0:
codeIndexNumber=0xa;
break;
case 0xb0:
codeIndexNumber=0xb;
break;
case 0xc0:
codeIndexNumber=0xc;
break;
case 0xd0:
codeIndexNumber=0xd;
break;
case 0xe0:
codeIndexNumber=0xe;
break;
case 0xf0:
switch (byte1) {
case 0xf0:
if (byte2 == 0xf7) {
codeIndexNumber=0x6;
}
 else if (byte3 == 0xf7) {
codeIndexNumber=0x7;
}
 else {
return;
}
break;
case 0xf7:
return;
case 0xf4:
case 0xf5:
case 0xf9:
case 0xfd:
return;
case 0xf6:
case 0xf8:
case 0xfa:
case 0xfb:
case 0xfc:
case 0xfe:
case 0xff:
codeIndexNumber=0x5;
break;
case 0xf1:
case 0xf3:
codeIndexNumber=0x2;
break;
case 0xf2:
codeIndexNumber=0x3;
break;
default :
break;
}
break;
default :
return;
}
sendMidiMessage(codeIndexNumber,cable,byte1,byte2,byte3);
}",0.2596100278551532
99462,"/** 
 * Get UsbDevice's manufacturer name
 * @param usbDevice the UsbDevice
 * @param usbDeviceConnection the UsbDeviceConnection
 * @return the manufacturer name
 */
@Nullable public static String getManufacturerName(@NonNull UsbDevice usbDevice,@NonNull UsbDeviceConnection usbDeviceConnection){
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    return usbDevice.getManufacturerName();
  }
 else   if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {
    byte[] rawDescriptors=usbDeviceConnection.getRawDescriptors();
    try {
      byte[] buffer=new byte[255];
      int indexOfManufacturerName=rawDescriptors[14] & 0xff;
      int manufacturerNameLength=usbDeviceConnection.controlTransfer(UsbConstants.USB_DIR_IN,USB_REQUEST_GET_DESCRIPTOR,(USB_DATA_TYPE_STRING << 8) | indexOfManufacturerName,0,buffer,255,0);
      return new String(buffer,2,manufacturerNameLength - 2,""String_Node_Str"");
    }
 catch (    UnsupportedEncodingException e) {
      e.printStackTrace();
    }
  }
  return null;
}","/** 
 * Get UsbDevice's manufacturer name
 * @param usbDevice the UsbDevice
 * @param usbDeviceConnection the UsbDeviceConnection
 * @return the manufacturer name
 */
@SuppressLint(""String_Node_Str"") @Nullable public static String getManufacturerName(@NonNull UsbDevice usbDevice,@NonNull UsbDeviceConnection usbDeviceConnection){
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    return usbDevice.getManufacturerName();
  }
 else   if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {
    byte[] rawDescriptors=usbDeviceConnection.getRawDescriptors();
    try {
      byte[] buffer=new byte[255];
      int indexOfManufacturerName=rawDescriptors[14] & 0xff;
      int manufacturerNameLength=usbDeviceConnection.controlTransfer(UsbConstants.USB_DIR_IN,USB_REQUEST_GET_DESCRIPTOR,(USB_DATA_TYPE_STRING << 8) | indexOfManufacturerName,0,buffer,255,0);
      return new String(buffer,2,manufacturerNameLength - 2,""String_Node_Str"");
    }
 catch (    UnsupportedEncodingException e) {
      e.printStackTrace();
    }
  }
  return null;
}",0.984263233190272
99463,"/** 
 * Get UsbDevice's product name
 * @param usbDevice the UsbDevice
 * @param usbDeviceConnection the UsbDeviceConnection
 * @return the product name
 */
@Nullable public static String getProductName(@NonNull UsbDevice usbDevice,@NonNull UsbDeviceConnection usbDeviceConnection){
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    return usbDevice.getProductName();
  }
 else   if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {
    byte[] rawDescriptors=usbDeviceConnection.getRawDescriptors();
    try {
      byte[] buffer=new byte[255];
      int indexOfProductName=rawDescriptors[15] & 0xff;
      int productNameLength=usbDeviceConnection.controlTransfer(UsbConstants.USB_DIR_IN,USB_REQUEST_GET_DESCRIPTOR,(USB_DATA_TYPE_STRING << 8) | indexOfProductName,0,buffer,255,0);
      return new String(buffer,2,productNameLength - 2,""String_Node_Str"");
    }
 catch (    UnsupportedEncodingException e) {
      e.printStackTrace();
    }
  }
  return null;
}","/** 
 * Get UsbDevice's product name
 * @param usbDevice the UsbDevice
 * @param usbDeviceConnection the UsbDeviceConnection
 * @return the product name
 */
@SuppressLint(""String_Node_Str"") @Nullable public static String getProductName(@NonNull UsbDevice usbDevice,@NonNull UsbDeviceConnection usbDeviceConnection){
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    return usbDevice.getProductName();
  }
 else   if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {
    byte[] rawDescriptors=usbDeviceConnection.getRawDescriptors();
    try {
      byte[] buffer=new byte[255];
      int indexOfProductName=rawDescriptors[15] & 0xff;
      int productNameLength=usbDeviceConnection.controlTransfer(UsbConstants.USB_DIR_IN,USB_REQUEST_GET_DESCRIPTOR,(USB_DATA_TYPE_STRING << 8) | indexOfProductName,0,buffer,255,0);
      return new String(buffer,2,productNameLength - 2,""String_Node_Str"");
    }
 catch (    UnsupportedEncodingException e) {
      e.printStackTrace();
    }
  }
  return null;
}",0.9836390679226574
99464,"/** 
 * stops the watching thread
 */
public void stop(){
  usbDeviceConnection.releaseInterface(usbInterface);
  resume();
  waiterThread.stopFlag=true;
  while (waiterThread.isAlive()) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
    }
  }
}","/** 
 * stops the watching thread
 */
public void stop(){
  usbDeviceConnection.releaseInterface(usbInterface);
  waiterThread.stopFlag=true;
  resume();
  while (waiterThread.isAlive()) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
    }
  }
}",0.956989247311828
99465,"/** 
 * constructor
 * @param usbDevice
 * @param usbDeviceConnection
 * @param usbInterface
 * @param midiEventListener
 * @throws IllegalArgumentException endpoint not found.
 */
public MidiInputDevice(UsbDevice usbDevice,UsbDeviceConnection usbDeviceConnection,UsbInterface usbInterface,UsbEndpoint usbEndpoint,OnMidiInputEventListener midiEventListener) throws IllegalArgumentException {
  this.usbDevice=usbDevice;
  this.usbDeviceConnection=usbDeviceConnection;
  this.usbInterface=usbInterface;
  this.midiEventListener=midiEventListener;
  waiterThread=new WaiterThread();
  inputEndpoint=usbEndpoint;
  if (inputEndpoint == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  usbDeviceConnection.claimInterface(usbInterface,true);
  waiterThread.setPriority(8);
  waiterThread.start();
}","/** 
 * constructor
 * @param usbDevice
 * @param usbDeviceConnection
 * @param usbInterface
 * @param midiEventListener
 * @throws IllegalArgumentException endpoint not found.
 */
public MidiInputDevice(UsbDevice usbDevice,UsbDeviceConnection usbDeviceConnection,UsbInterface usbInterface,UsbEndpoint usbEndpoint,OnMidiInputEventListener midiEventListener) throws IllegalArgumentException {
  this.usbDevice=usbDevice;
  this.usbDeviceConnection=usbDeviceConnection;
  this.usbInterface=usbInterface;
  this.midiEventListener=midiEventListener;
  waiterThread=new WaiterThread();
  inputEndpoint=usbEndpoint;
  if (inputEndpoint == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  usbDeviceConnection.claimInterface(usbInterface,true);
  waiterThread.setPriority(8);
  waiterThread.setName(""String_Node_Str"" + usbDevice.getDeviceName() + ""String_Node_Str"");
  waiterThread.start();
}",0.942608695652174
99466,"/** 
 * constructor
 * @param usbDevice
 * @param usbDeviceConnection
 * @param usbInterface
 * @param usbEndpoint
 */
public MidiOutputDevice(UsbDevice usbDevice,UsbDeviceConnection usbDeviceConnection,UsbInterface usbInterface,UsbEndpoint usbEndpoint){
  this.usbDevice=usbDevice;
  this.usbDeviceConnection=usbDeviceConnection;
  this.usbInterface=usbInterface;
  waiterThread=new WaiterThread();
  outputEndpoint=usbEndpoint;
  if (outputEndpoint == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.usbDeviceConnection.claimInterface(this.usbInterface,true);
  waiterThread.start();
}","/** 
 * constructor
 * @param usbDevice
 * @param usbDeviceConnection
 * @param usbInterface
 * @param usbEndpoint
 */
public MidiOutputDevice(UsbDevice usbDevice,UsbDeviceConnection usbDeviceConnection,UsbInterface usbInterface,UsbEndpoint usbEndpoint){
  this.usbDevice=usbDevice;
  this.usbDeviceConnection=usbDeviceConnection;
  this.usbInterface=usbInterface;
  waiterThread=new WaiterThread();
  outputEndpoint=usbEndpoint;
  if (outputEndpoint == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.usbDeviceConnection.claimInterface(this.usbInterface,true);
  waiterThread.setName(""String_Node_Str"" + usbDevice.getDeviceName() + ""String_Node_Str"");
  waiterThread.start();
}",0.9252830188679244
99467,"@Override public void run(){
  byte[] dequedDataBuffer;
  int queueSize=0;
  final int maxPacketSize=outputEndpoint.getMaxPacketSize();
  byte[] endpointBuffer=new byte[maxPacketSize];
  int endpointBufferLength=0;
  int bufferPosition;
  int dequedDataBufferLength;
  while (stopFlag == false) {
    dequedDataBuffer=null;
synchronized (queue) {
      queueSize=queue.size();
      if (queueSize > 0) {
        dequedDataBuffer=queue.poll();
      }
    }
    if (suspendFlag) {
      try {
        sleep(500);
      }
 catch (      InterruptedException e) {
      }
      continue;
    }
    if (dequedDataBuffer != null) {
      dequedDataBufferLength=dequedDataBuffer.length;
synchronized (usbDeviceConnection) {
        if (usbRequest == null) {
          usbRequest=new UsbRequest();
          usbRequest.initialize(usbDeviceConnection,outputEndpoint);
        }
        for (bufferPosition=0; bufferPosition < dequedDataBufferLength; bufferPosition+=maxPacketSize) {
          if (bufferPosition + maxPacketSize > dequedDataBufferLength) {
            endpointBufferLength=dequedDataBufferLength % maxPacketSize;
          }
 else {
            endpointBufferLength=maxPacketSize;
          }
          System.arraycopy(dequedDataBuffer,bufferPosition,endpointBuffer,0,endpointBufferLength);
          while (usbRequest.queue(ByteBuffer.wrap(endpointBuffer),endpointBufferLength) == false) {
          }
          while (usbRequest.equals(usbDeviceConnection.requestWait()) == false) {
          }
        }
      }
    }
    if (queueSize == 0 && !interrupted()) {
      try {
        sleep(500);
      }
 catch (      InterruptedException e) {
      }
    }
  }
  if (usbRequest != null) {
    usbRequest.close();
  }
}","@Override public void run(){
  byte[] dequedDataBuffer;
  int queueSize=0;
  final int maxPacketSize=outputEndpoint.getMaxPacketSize();
  byte[] endpointBuffer=new byte[maxPacketSize];
  int endpointBufferLength=0;
  int bufferPosition;
  int dequedDataBufferLength;
  int usbRequestFailCount;
  while (stopFlag == false) {
    dequedDataBuffer=null;
synchronized (queue) {
      queueSize=queue.size();
      if (queueSize > 0) {
        dequedDataBuffer=queue.poll();
      }
    }
    if (suspendFlag) {
      try {
        sleep(500);
      }
 catch (      InterruptedException e) {
      }
      continue;
    }
    if (dequedDataBuffer != null) {
      dequedDataBufferLength=dequedDataBuffer.length;
synchronized (usbDeviceConnection) {
        if (usbRequest == null) {
          usbRequest=new UsbRequest();
          usbRequest.initialize(usbDeviceConnection,outputEndpoint);
        }
        for (bufferPosition=0; bufferPosition < dequedDataBufferLength; bufferPosition+=maxPacketSize) {
          if (bufferPosition + maxPacketSize > dequedDataBufferLength) {
            endpointBufferLength=dequedDataBufferLength % maxPacketSize;
          }
 else {
            endpointBufferLength=maxPacketSize;
          }
          System.arraycopy(dequedDataBuffer,bufferPosition,endpointBuffer,0,endpointBufferLength);
          usbRequestFailCount=0;
          while (usbRequest.queue(ByteBuffer.wrap(endpointBuffer),endpointBufferLength) == false) {
            usbRequestFailCount++;
            if (usbRequestFailCount > 10) {
              stopFlag=true;
              break;
            }
          }
          if (stopFlag) {
            break;
          }
          usbRequestFailCount=0;
          while (usbRequest.equals(usbDeviceConnection.requestWait()) == false) {
            usbRequestFailCount++;
            if (usbRequestFailCount > 10) {
              stopFlag=true;
              break;
            }
          }
        }
      }
    }
    if (queueSize == 0 && !interrupted()) {
      try {
        sleep(500);
      }
 catch (      InterruptedException e) {
      }
    }
  }
  if (usbRequest != null) {
    usbRequest.close();
  }
}",0.8879753340184995
99468,"/** 
 * constructor
 * @param handler
 */
WaiterThread(){
  stopFlag=false;
  suspendFlag=false;
}","/** 
 * constructor
 */
WaiterThread(){
  stopFlag=false;
  suspendFlag=false;
}",0.898876404494382
99469,"/** 
 * stop to use this device.
 */
public void stop(){
  usbDeviceConnection.releaseInterface(usbInterface);
  resume();
  waiterThread.stopFlag=true;
  waiterThread.interrupt();
  while (waiterThread.isAlive()) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
    }
  }
}","/** 
 * stop to use this device.
 */
public void stop(){
  usbDeviceConnection.releaseInterface(usbInterface);
  resume();
  waiterThread.stopFlag=true;
  while (waiterThread.isAlive()) {
    try {
      waiterThread.interrupt();
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
    }
  }
}",0.8636363636363636
99470,"@Override public void run(){
  while (true) {
    if (stopFlag) {
      if (usbRequest != null) {
        usbRequest.close();
      }
      return;
    }
    while (true) {
      byte[] writeBuffer=null;
synchronized (queue) {
        writeBuffer=queue.poll();
      }
      if (writeBuffer == null) {
        break;
      }
synchronized (usbDeviceConnection) {
        if (usbRequest == null) {
          usbRequest=new UsbRequest();
          usbRequest.initialize(usbDeviceConnection,outputEndpoint);
        }
        while (usbRequest.queue(ByteBuffer.wrap(writeBuffer),4) == false) {
          try {
            Thread.sleep(1);
          }
 catch (          InterruptedException e) {
          }
        }
        while (usbRequest.equals(usbDeviceConnection.requestWait()) == false) {
          try {
            Thread.sleep(1);
          }
 catch (          InterruptedException e) {
          }
        }
      }
    }
  }
}","@Override public void run(){
  while (true) {
    if (stopFlag) {
      if (usbRequest != null) {
        usbRequest.close();
      }
      return;
    }
    while (true) {
      byte[] writeBuffer=null;
synchronized (queue) {
        writeBuffer=queue.poll();
      }
      if (writeBuffer == null) {
        break;
      }
synchronized (usbDeviceConnection) {
        if (usbRequest == null) {
          usbRequest=new UsbRequest();
          usbRequest.initialize(usbDeviceConnection,outputEndpoint);
        }
        while (usbRequest.queue(ByteBuffer.wrap(writeBuffer),writeBuffer.length) == false) {
          try {
            Thread.sleep(1);
          }
 catch (          InterruptedException e) {
          }
        }
        while (usbRequest.equals(usbDeviceConnection.requestWait()) == false) {
          try {
            Thread.sleep(1);
          }
 catch (          InterruptedException e) {
          }
        }
      }
    }
  }
}",0.9899311075781664
99471,"@Override public Object clone(){
  byte[] result=new byte[data.length];
  System.arraycopy(data,0,result,0,result.length);
  return new SysexMessage(result);
}","@Override public Object clone(){
  return new SysexMessage(getData());
}",0.5627705627705628
99472,"public byte[] getData(){
  byte[] returnedArray=new byte[data.length - 1];
  System.arraycopy(data,1,returnedArray,0,(data.length - 1));
  return returnedArray;
}","public byte[] getData(){
  byte[] result=new byte[data.length];
  System.arraycopy(data,0,result,0,result.length);
  return result;
}",0.8
99473,"@Override public void run(){
  while (true) {
    if (stopFlag) {
      if (usbRequest != null) {
        usbRequest.close();
      }
      return;
    }
    while (true) {
      byte[] writeBuffer=null;
synchronized (queue) {
        writeBuffer=queue.poll();
      }
      if (writeBuffer == null) {
        break;
      }
synchronized (usbDeviceConnection) {
        if (usbRequest == null) {
          usbRequest=new UsbRequest();
          usbRequest.initialize(usbDeviceConnection,outputEndpoint);
        }
        while (usbRequest.queue(ByteBuffer.wrap(writeBuffer),4) == false) {
          try {
            Thread.sleep(1);
          }
 catch (          InterruptedException e) {
          }
        }
        while (usbRequest.equals(usbDeviceConnection.requestWait()) == false) {
          try {
            Thread.sleep(1);
          }
 catch (          InterruptedException e) {
          }
        }
      }
    }
  }
}","@Override public void run(){
  while (true) {
    if (stopFlag) {
      if (usbRequest != null) {
        usbRequest.close();
      }
      return;
    }
    while (true) {
      byte[] writeBuffer=null;
synchronized (queue) {
        writeBuffer=queue.poll();
      }
      if (writeBuffer == null) {
        break;
      }
synchronized (usbDeviceConnection) {
        if (usbRequest == null) {
          usbRequest=new UsbRequest();
          usbRequest.initialize(usbDeviceConnection,outputEndpoint);
        }
        while (usbRequest.queue(ByteBuffer.wrap(writeBuffer),writeBuffer.length) == false) {
          try {
            Thread.sleep(1);
          }
 catch (          InterruptedException e) {
          }
        }
        while (usbRequest.equals(usbDeviceConnection.requestWait()) == false) {
          try {
            Thread.sleep(1);
          }
 catch (          InterruptedException e) {
          }
        }
      }
    }
  }
}",0.9899311075781664
99474,"@Override public Object clone(){
  byte[] result=new byte[data.length];
  System.arraycopy(data,0,result,0,result.length);
  return new SysexMessage(result);
}","@Override public Object clone(){
  return new SysexMessage(getData());
}",0.5627705627705628
99475,"public byte[] getData(){
  byte[] returnedArray=new byte[data.length - 1];
  System.arraycopy(data,1,returnedArray,0,(data.length - 1));
  return returnedArray;
}","public byte[] getData(){
  byte[] result=new byte[data.length];
  System.arraycopy(data,0,result,0,result.length);
  return result;
}",0.8
99476,"/** 
 * Merge the specified   {@link Sequencer}'s   {@link Track}s into one   {@link Track}
 * @param sequencer
 * @param recordEnable
 * @return merged {@link Sequence}
 * @throws InvalidMidiDataException
 */
public static Track mergeSequenceToTrack(Sequencer sequencer,Map<Track,Set<Integer>> recordEnable) throws InvalidMidiDataException {
  Sequence sourceSequence=sequencer.getSequence();
  Track mergedTrack=new Track();
  Track[] tracks=sourceSequence.getTracks();
  boolean hasSoloTrack=false;
  for (int trackIndex=0; trackIndex < tracks.length; trackIndex++) {
    if (sequencer.getTrackSolo(trackIndex)) {
      hasSoloTrack=true;
    }
  }
  for (int trackIndex=0; trackIndex < tracks.length; trackIndex++) {
    if (sequencer.getTrackMute(trackIndex)) {
      continue;
    }
    if (hasSoloTrack && sequencer.getTrackSolo(trackIndex) == false) {
      continue;
    }
    if (sequencer.isRecording() && (recordEnable.get(tracks[trackIndex]) != null && recordEnable.get(tracks[trackIndex]).size() > 0)) {
      continue;
    }
    mergedTrack.events.addAll(tracks[trackIndex].events);
  }
  sortEvents(mergedTrack);
  return mergedTrack;
}","/** 
 * Merge the specified   {@link Sequencer}'s   {@link Track}s into one   {@link Track}
 * @param sequencer
 * @param recordEnable
 * @return merged {@link Sequence}
 * @throws InvalidMidiDataException
 */
public static Track mergeSequenceToTrack(Sequencer sequencer,Map<Track,Set<Integer>> recordEnable) throws InvalidMidiDataException {
  Sequence sourceSequence=sequencer.getSequence();
  Track mergedTrack=new Track();
  Track[] tracks=sourceSequence.getTracks();
  boolean hasSoloTrack=false;
  for (int trackIndex=0; trackIndex < tracks.length; trackIndex++) {
    if (sequencer.getTrackSolo(trackIndex)) {
      hasSoloTrack=true;
      break;
    }
  }
  for (int trackIndex=0; trackIndex < tracks.length; trackIndex++) {
    if (sequencer.getTrackMute(trackIndex)) {
      continue;
    }
    if (hasSoloTrack && sequencer.getTrackSolo(trackIndex) == false) {
      continue;
    }
    if (sequencer.isRecording() && (recordEnable.get(tracks[trackIndex]) != null && recordEnable.get(tracks[trackIndex]).size() > 0)) {
      continue;
    }
    mergedTrack.events.addAll(tracks[trackIndex].events);
  }
  sortEvents(mergedTrack);
  return mergedTrack;
}",0.9943892965041
99477,"@Override public void send(MidiMessage message,long timeStamp){
  if (outputDevice == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (message instanceof MetaMessage) {
    final MetaMessage metaMessage=(MetaMessage)message;
    outputDevice.sendMidiSystemCommonMessage(cableId,metaMessage.getData());
  }
 else   if (message instanceof SysexMessage) {
    final SysexMessage sysexMessage=(SysexMessage)message;
    outputDevice.sendMidiSystemExclusive(cableId,sysexMessage.getData());
  }
 else   if (message instanceof ShortMessage) {
    final ShortMessage shortMessage=(ShortMessage)message;
switch (shortMessage.getCommand()) {
case ShortMessage.CHANNEL_PRESSURE:
      outputDevice.sendMidiChannelAftertouch(cableId,shortMessage.getChannel(),shortMessage.getData1());
    break;
case ShortMessage.CONTROL_CHANGE:
  outputDevice.sendMidiControlChange(cableId,shortMessage.getChannel(),shortMessage.getData1(),shortMessage.getData2());
break;
case ShortMessage.NOTE_OFF:
outputDevice.sendMidiNoteOff(cableId,shortMessage.getChannel(),shortMessage.getData1(),shortMessage.getData2());
break;
case ShortMessage.NOTE_ON:
outputDevice.sendMidiNoteOn(cableId,shortMessage.getChannel(),shortMessage.getData1(),shortMessage.getData2());
break;
case ShortMessage.PITCH_BEND:
outputDevice.sendMidiPitchWheel(cableId,shortMessage.getChannel(),shortMessage.getData1() | (shortMessage.getData2() << 7));
break;
case ShortMessage.POLY_PRESSURE:
outputDevice.sendMidiPolyphonicAftertouch(cableId,shortMessage.getChannel(),shortMessage.getData1(),shortMessage.getData2());
break;
case ShortMessage.PROGRAM_CHANGE:
outputDevice.sendMidiProgramChange(cableId,shortMessage.getChannel(),shortMessage.getData1());
break;
default :
}
}
}","@Override public void send(MidiMessage message,long timeStamp){
  if (outputDevice == null) {
    open();
  }
  if (message instanceof MetaMessage) {
    final MetaMessage metaMessage=(MetaMessage)message;
    outputDevice.sendMidiSystemCommonMessage(cableId,metaMessage.getData());
  }
 else   if (message instanceof SysexMessage) {
    final SysexMessage sysexMessage=(SysexMessage)message;
    outputDevice.sendMidiSystemExclusive(cableId,sysexMessage.getData());
  }
 else   if (message instanceof ShortMessage) {
    final ShortMessage shortMessage=(ShortMessage)message;
switch (shortMessage.getCommand()) {
case ShortMessage.CHANNEL_PRESSURE:
      outputDevice.sendMidiChannelAftertouch(cableId,shortMessage.getChannel(),shortMessage.getData1());
    break;
case ShortMessage.CONTROL_CHANGE:
  outputDevice.sendMidiControlChange(cableId,shortMessage.getChannel(),shortMessage.getData1(),shortMessage.getData2());
break;
case ShortMessage.NOTE_OFF:
outputDevice.sendMidiNoteOff(cableId,shortMessage.getChannel(),shortMessage.getData1(),shortMessage.getData2());
break;
case ShortMessage.NOTE_ON:
outputDevice.sendMidiNoteOn(cableId,shortMessage.getChannel(),shortMessage.getData1(),shortMessage.getData2());
break;
case ShortMessage.PITCH_BEND:
outputDevice.sendMidiPitchWheel(cableId,shortMessage.getChannel(),shortMessage.getData1() | (shortMessage.getData2() << 7));
break;
case ShortMessage.POLY_PRESSURE:
outputDevice.sendMidiPolyphonicAftertouch(cableId,shortMessage.getChannel(),shortMessage.getData1(),shortMessage.getData2());
break;
case ShortMessage.PROGRAM_CHANGE:
outputDevice.sendMidiProgramChange(cableId,shortMessage.getChannel(),shortMessage.getData1());
break;
default :
}
}
}",0.9849100406268136
99478,"@Override public boolean getTrackSolo(int track){
  return trackMute.get(track);
}","@Override public boolean getTrackSolo(int track){
  return trackSolo.get(track);
}",0.951219512195122
99479,"@Override public void setReceiver(Receiver receiver){
  this.receiver=receiver;
}","@Override public void setReceiver(Receiver receiver){
  this.receiver=receiver;
  if (inputDevice == null) {
    open();
  }
}",0.782608695652174
99480,"/** 
 * constructor
 * @param handler
 */
WaiterThread(Handler handler){
  stopFlag=false;
  this.receiveHandler=handler;
}","/** 
 * constructor
 */
WaiterThread(){
  stopFlag=false;
}",0.6483516483516484
99481,"@Override public void run(){
  while (true) {
    if (stopFlag) {
      return;
    }
    if (inputEndpoint == null) {
      continue;
    }
    int length=usbDeviceConnection.bulkTransfer(inputEndpoint,readBuffer,readBuffer.length,0);
    if (length > 0) {
      byte[] read=new byte[length];
      System.arraycopy(readBuffer,0,read,0,length);
      Log.d(Constants.TAG,""String_Node_Str"" + Arrays.toString(read));
      Message message=Message.obtain(receiveHandler);
      message.obj=read;
      if (!stopFlag) {
        receiveHandler.sendMessage(message);
      }
    }
  }
}","@Override public void run(){
  final UsbDeviceConnection deviceConnection=usbDeviceConnection;
  final UsbEndpoint usbEndpoint=inputEndpoint;
  final MidiInputDevice sender=MidiInputDevice.this;
  final OnMidiInputEventListener eventListener=midiEventListener;
  final byte[] bulkReadBuffer=new byte[BUFFER_LENGTH];
  byte[] readBuffer=new byte[BUFFER_LENGTH * 2];
  int readBufferSize=0;
  byte[] read=new byte[BUFFER_LENGTH * 2];
  ByteArrayOutputStream systemExclusive=null;
  while (!stopFlag) {
    int length=deviceConnection.bulkTransfer(usbEndpoint,bulkReadBuffer,BUFFER_LENGTH,0);
    if (length > 0) {
      System.arraycopy(bulkReadBuffer,0,readBuffer,readBufferSize,length);
      readBufferSize+=length;
      if (readBufferSize < 4) {
        continue;
      }
      final int readSize=readBufferSize / 4 * 4;
      System.arraycopy(readBuffer,0,read,0,readSize);
      int unreadSize=readBufferSize - readSize;
      if (unreadSize > 0) {
        System.arraycopy(readBuffer,readSize,readBuffer,0,unreadSize);
        readBufferSize=unreadSize;
      }
 else {
        readBufferSize=0;
      }
      int cable;
      int codeIndexNumber;
      int byte1;
      int byte2;
      int byte3;
      for (int i=0; i < readSize; i+=4) {
        cable=(read[i + 0] >> 4) & 0xf;
        codeIndexNumber=read[i + 0] & 0xf;
        byte1=read[i + 1] & 0xff;
        byte2=read[i + 2] & 0xff;
        byte3=read[i + 3] & 0xff;
switch (codeIndexNumber) {
case 0:
          eventListener.onMidiMiscellaneousFunctionCodes(sender,cable,byte1,byte2,byte3);
        break;
case 1:
      eventListener.onMidiCableEvents(sender,cable,byte1,byte2,byte3);
    break;
case 2:
{
    byte[] bytes=new byte[]{(byte)byte1,(byte)byte2};
    eventListener.onMidiSystemCommonMessage(sender,cable,bytes);
  }
break;
case 3:
{
byte[] bytes=new byte[]{(byte)byte1,(byte)byte2,(byte)byte3};
eventListener.onMidiSystemCommonMessage(sender,cable,bytes);
}
break;
case 4:
synchronized (this) {
if (systemExclusive == null) {
systemExclusive=new ByteArrayOutputStream();
}
}
synchronized (systemExclusive) {
systemExclusive.write(byte1);
systemExclusive.write(byte2);
systemExclusive.write(byte3);
}
break;
case 5:
if (systemExclusive == null) {
byte[] bytes=new byte[]{(byte)byte1};
eventListener.onMidiSystemCommonMessage(sender,cable,bytes);
}
 else {
synchronized (systemExclusive) {
systemExclusive.write(byte1);
eventListener.onMidiSystemExclusive(sender,cable,systemExclusive.toByteArray());
}
synchronized (this) {
systemExclusive=null;
}
}
break;
case 6:
if (systemExclusive != null) {
synchronized (systemExclusive) {
systemExclusive.write(byte1);
systemExclusive.write(byte2);
eventListener.onMidiSystemExclusive(sender,cable,systemExclusive.toByteArray());
}
synchronized (this) {
systemExclusive=null;
}
}
break;
case 7:
if (systemExclusive != null) {
synchronized (systemExclusive) {
systemExclusive.write(byte1);
systemExclusive.write(byte2);
systemExclusive.write(byte3);
eventListener.onMidiSystemExclusive(sender,cable,systemExclusive.toByteArray());
}
synchronized (this) {
systemExclusive=null;
}
}
break;
case 8:
eventListener.onMidiNoteOff(sender,cable,byte1 & 0xf,byte2,byte3);
break;
case 9:
if (byte3 == 0x00) {
eventListener.onMidiNoteOff(sender,cable,byte1 & 0xf,byte2,byte3);
}
 else {
eventListener.onMidiNoteOn(sender,cable,byte1 & 0xf,byte2,byte3);
}
break;
case 10:
eventListener.onMidiPolyphonicAftertouch(sender,cable,byte1 & 0xf,byte2,byte3);
break;
case 11:
eventListener.onMidiControlChange(sender,cable,byte1 & 0xf,byte2,byte3);
processRpnMessages(cable,byte1,byte2,byte3,sender);
break;
case 12:
eventListener.onMidiProgramChange(sender,cable,byte1 & 0xf,byte2);
break;
case 13:
eventListener.onMidiChannelAftertouch(sender,cable,byte1 & 0xf,byte2);
break;
case 14:
eventListener.onMidiPitchWheel(sender,cable,byte1 & 0xf,byte2 | (byte3 << 7));
break;
case 15:
eventListener.onMidiSingleByte(sender,cable,byte1);
break;
default :
break;
}
}
}
}
}",0.0532453245324532
99482,"/** 
 * constructor
 * @param usbDevice
 * @param usbDeviceConnection
 * @param usbInterface
 * @param midiEventListener
 * @throws IllegalArgumentException endpoint not found.
 */
public MidiInputDevice(UsbDevice usbDevice,UsbDeviceConnection usbDeviceConnection,UsbInterface usbInterface,UsbEndpoint usbEndpoint,OnMidiInputEventListener midiEventListener) throws IllegalArgumentException {
  this.usbDevice=usbDevice;
  this.usbDeviceConnection=usbDeviceConnection;
  this.usbInterface=usbInterface;
  waiterThread=new WaiterThread(new Handler(new MidiMessageCallback(this,midiEventListener)));
  inputEndpoint=usbEndpoint;
  if (inputEndpoint == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  usbDeviceConnection.claimInterface(usbInterface,true);
  waiterThread.start();
}","/** 
 * constructor
 * @param usbDevice
 * @param usbDeviceConnection
 * @param usbInterface
 * @param midiEventListener
 * @throws IllegalArgumentException endpoint not found.
 */
public MidiInputDevice(UsbDevice usbDevice,UsbDeviceConnection usbDeviceConnection,UsbInterface usbInterface,UsbEndpoint usbEndpoint,OnMidiInputEventListener midiEventListener) throws IllegalArgumentException {
  this.usbDevice=usbDevice;
  this.usbDeviceConnection=usbDeviceConnection;
  this.usbInterface=usbInterface;
  this.midiEventListener=midiEventListener;
  waiterThread=new WaiterThread();
  inputEndpoint=usbEndpoint;
  if (inputEndpoint == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  usbDeviceConnection.claimInterface(usbInterface,true);
  waiterThread.setPriority(8);
  waiterThread.start();
}",0.916615194564546
99483,"@Override public synchronized void onDeviceDetached(UsbDevice detachedDevice){
  if (midiInputDevices == null || midiOutputDevices == null || deviceConnections == null) {
    return;
  }
  Set<MidiInputDevice> inputDevices=midiInputDevices.get(detachedDevice);
  if (inputDevices != null && inputDevices.size() > 0) {
    for (    MidiInputDevice inputDevice : inputDevices) {
      if (inputDevice != null) {
        inputDevice.stop();
      }
    }
    midiInputDevices.remove(detachedDevice);
  }
  Set<MidiOutputDevice> outputDevices=midiOutputDevices.get(detachedDevice);
  if (outputDevices != null) {
    for (    MidiOutputDevice outputDevice : outputDevices) {
      if (outputDevice != null) {
        outputDevice.stop();
      }
    }
    midiOutputDevices.remove(detachedDevice);
  }
  UsbDeviceConnection deviceConnection=deviceConnections.get(detachedDevice);
  if (deviceConnection != null) {
    deviceConnection.close();
    deviceConnections.remove(detachedDevice);
  }
  Log.d(Constants.TAG,""String_Node_Str"" + detachedDevice.getDeviceName() + ""String_Node_Str"");
  Message message=new Message();
  message.obj=detachedDevice;
  deviceDetachedHandler.sendMessage(message);
}","@Override public synchronized void onDeviceDetached(UsbDevice detachedDevice){
  if (midiInputDevices == null || midiOutputDevices == null || deviceConnections == null) {
    return;
  }
  AsyncTask<UsbDevice,Void,Void> task=new AsyncTask<UsbDevice,Void,Void>(){
    @Override protected Void doInBackground(    UsbDevice... params){
      if (params == null || params.length < 1) {
        return null;
      }
      UsbDevice usbDevice=params[0];
      Set<MidiInputDevice> inputDevices=midiInputDevices.get(usbDevice);
      if (inputDevices != null && inputDevices.size() > 0) {
        for (        MidiInputDevice inputDevice : inputDevices) {
          if (inputDevice != null) {
            inputDevice.stop();
          }
        }
        midiInputDevices.remove(usbDevice);
      }
      Set<MidiOutputDevice> outputDevices=midiOutputDevices.get(usbDevice);
      if (outputDevices != null) {
        for (        MidiOutputDevice outputDevice : outputDevices) {
          if (outputDevice != null) {
            outputDevice.stop();
          }
        }
        midiOutputDevices.remove(usbDevice);
      }
      UsbDeviceConnection deviceConnection=deviceConnections.get(usbDevice);
      if (deviceConnection != null) {
        deviceConnection.close();
        deviceConnections.remove(usbDevice);
      }
      Log.d(Constants.TAG,""String_Node_Str"" + usbDevice.getDeviceName() + ""String_Node_Str"");
      Message message=Message.obtain(deviceDetachedHandler);
      message.obj=usbDevice;
      deviceDetachedHandler.sendMessage(message);
      return null;
    }
  }
;
  task.execute(detachedDevice);
}",0.7050461975835111
99484,"/** 
 * Get MIDI output device, if available.
 * @param usbDevice
 * @return {@link Set<MidiOutputDevice>}
 */
public final Set<MidiOutputDevice> getMidiOutputDevices(UsbDevice usbDevice){
  if (deviceConnectionWatcher != null) {
    deviceConnectionWatcher.checkConnectedDevicesImmediately();
  }
  if (midiOutputDevices != null) {
    return Collections.unmodifiableSet(midiOutputDevices.get(usbDevice));
  }
  return Collections.unmodifiableSet(new HashSet<MidiOutputDevice>());
}","/** 
 * Get MIDI output device, if available.
 * @param usbDevice
 * @return {@link Set<MidiOutputDevice>}
 */
public final Set<MidiOutputDevice> getMidiOutputDevices(UsbDevice usbDevice){
  if (deviceConnectionWatcher != null) {
    deviceConnectionWatcher.checkConnectedDevicesImmediately();
  }
  if (midiOutputDevices != null && midiOutputDevices.get(usbDevice) != null) {
    return Collections.unmodifiableSet(midiOutputDevices.get(usbDevice));
  }
  return Collections.unmodifiableSet(new HashSet<MidiOutputDevice>());
}",0.8712871287128713
99485,"@Override public synchronized void onDeviceDetached(final UsbDevice detachedDevice){
  if (midiInputDevice != null) {
    midiInputDevice.stop();
    midiInputDevice=null;
  }
  if (midiOutputDevice != null) {
    midiOutputDevice.stop();
    midiOutputDevice=null;
  }
  if (deviceConnection != null) {
    deviceConnection.close();
    deviceConnection=null;
  }
  device=null;
  Log.d(Constants.TAG,""String_Node_Str"" + detachedDevice.getDeviceName() + ""String_Node_Str"");
  Message message=new Message();
  message.obj=detachedDevice;
  deviceDetachedHandler.sendMessage(message);
}","@Override public synchronized void onDeviceDetached(final UsbDevice detachedDevice){
  AsyncTask<UsbDevice,Void,Void> task=new AsyncTask<UsbDevice,Void,Void>(){
    @Override protected Void doInBackground(    UsbDevice... params){
      if (params == null || params.length < 1) {
        return null;
      }
      UsbDevice usbDevice=params[0];
      if (midiInputDevice != null) {
        midiInputDevice.stop();
        midiInputDevice=null;
      }
      if (midiOutputDevice != null) {
        midiOutputDevice.stop();
        midiOutputDevice=null;
      }
      if (deviceConnection != null) {
        deviceConnection.close();
        deviceConnection=null;
      }
      device=null;
      Log.d(Constants.TAG,""String_Node_Str"" + usbDevice.getDeviceName() + ""String_Node_Str"");
      Message message=Message.obtain(deviceDetachedHandler);
      message.obj=usbDevice;
      deviceDetachedHandler.sendMessage(message);
      return null;
    }
  }
;
  task.execute(detachedDevice);
}",0.649746192893401
99486,"/** 
 * stops the watching thread
 */
public void stop(){
  waiterThread.stopFlag=true;
  while (waiterThread.isAlive()) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
    }
  }
  usbDeviceConnection.releaseInterface(usbInterface);
}","/** 
 * stops the watching thread
 */
public void stop(){
  usbDeviceConnection.releaseInterface(usbInterface);
  waiterThread.stopFlag=true;
  while (waiterThread.isAlive()) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
    }
  }
}",0.7940074906367042
99487,"@Override public void run(){
  while (true) {
    if (stopFlag) {
      return;
    }
    if (inputEndpoint == null) {
      continue;
    }
    int length=usbDeviceConnection.bulkTransfer(inputEndpoint,readBuffer,readBuffer.length,0);
    if (length > 0) {
      byte[] read=new byte[length];
      System.arraycopy(readBuffer,0,read,0,length);
      Log.d(Constants.TAG,""String_Node_Str"" + Arrays.toString(read));
      Message message=new Message();
      message.obj=read;
      if (!stopFlag) {
        receiveHandler.sendMessage(message);
      }
    }
  }
}","@Override public void run(){
  while (true) {
    if (stopFlag) {
      return;
    }
    if (inputEndpoint == null) {
      continue;
    }
    int length=usbDeviceConnection.bulkTransfer(inputEndpoint,readBuffer,readBuffer.length,0);
    if (length > 0) {
      byte[] read=new byte[length];
      System.arraycopy(readBuffer,0,read,0,length);
      Log.d(Constants.TAG,""String_Node_Str"" + Arrays.toString(read));
      Message message=Message.obtain(receiveHandler);
      message.obj=read;
      if (!stopFlag) {
        receiveHandler.sendMessage(message);
      }
    }
  }
}",0.9764192139737992
99488,"/** 
 * SysEx Code Index Number : 0x4, 0x5, 0x6, 0x7
 * @param cable 0-15
 * @param systemExclusive : start with 'F0', and end with 'F7'
 */
@SuppressWarnings(""String_Node_Str"") public void sendMidiSystemExclusive(int cable,byte[] systemExclusive){
  ByteArrayOutputStream transferDataStream=new ByteArrayOutputStream();
  for (int sysexIndex=0; sysexIndex < systemExclusive.length; sysexIndex+=3) {
    if ((sysexIndex + 3 < systemExclusive.length)) {
      transferDataStream.write((((cable & 0xf) << 4) | 0x4));
      transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
      transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
      transferDataStream.write(systemExclusive[sysexIndex + 2] & 0xff);
    }
 else {
switch (systemExclusive.length % 3) {
case 1:
        transferDataStream.write((((cable & 0xf) << 4) | 0x5));
      transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
    transferDataStream.write(0);
  transferDataStream.write(0);
break;
case 2:
transferDataStream.write((((cable & 0xf) << 4) | 0x6));
transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
transferDataStream.write(0);
break;
case 0:
transferDataStream.write((((cable & 0xf) << 4) | 0x7));
transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 2] & 0xff);
break;
}
}
}
byte[] buffer=transferDataStream.toByteArray();
synchronized (deviceConnection) {
if (usbRequest == null) {
usbRequest=new UsbRequest();
usbRequest.initialize(deviceConnection,outputEndpoint);
}
while (usbRequest.queue(ByteBuffer.wrap(buffer),buffer.length) == false) {
try {
Thread.sleep(1);
}
 catch (InterruptedException e) {
}
}
}
Log.d(Constants.TAG,""String_Node_Str"" + buffer.length + ""String_Node_Str""+ buffer.length+ ""String_Node_Str"");
}","/** 
 * SysEx Code Index Number : 0x4, 0x5, 0x6, 0x7
 * @param cable 0-15
 * @param systemExclusive : start with 'F0', and end with 'F7'
 */
@SuppressWarnings(""String_Node_Str"") public void sendMidiSystemExclusive(int cable,byte[] systemExclusive){
  ByteArrayOutputStream transferDataStream=new ByteArrayOutputStream();
  for (int sysexIndex=0; sysexIndex < systemExclusive.length; sysexIndex+=3) {
    if ((sysexIndex + 3 < systemExclusive.length)) {
      transferDataStream.write((((cable & 0xf) << 4) | 0x4));
      transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
      transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
      transferDataStream.write(systemExclusive[sysexIndex + 2] & 0xff);
    }
 else {
switch (systemExclusive.length % 3) {
case 1:
        transferDataStream.write((((cable & 0xf) << 4) | 0x5));
      transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
    transferDataStream.write(0);
  transferDataStream.write(0);
break;
case 2:
transferDataStream.write((((cable & 0xf) << 4) | 0x6));
transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
transferDataStream.write(0);
break;
case 0:
transferDataStream.write((((cable & 0xf) << 4) | 0x7));
transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 2] & 0xff);
break;
}
}
}
byte[] buffer=transferDataStream.toByteArray();
synchronized (deviceConnection) {
if (usbRequest == null) {
usbRequest=new UsbRequest();
usbRequest.initialize(deviceConnection,outputEndpoint);
}
while (usbRequest.queue(ByteBuffer.wrap(buffer),buffer.length) == false) {
try {
Thread.sleep(1);
}
 catch (InterruptedException e) {
}
}
while (usbRequest.equals(deviceConnection.requestWait()) == false) {
try {
Thread.sleep(1);
}
 catch (InterruptedException e) {
}
}
}
Log.d(Constants.TAG,""String_Node_Str"" + buffer.length + ""String_Node_Str""+ buffer.length+ ""String_Node_Str"");
}",0.9672781358453147
99489,"/** 
 * Sends MIDI message to output device.
 * @param codeIndexNumber
 * @param cable
 * @param byte1
 * @param byte2
 * @param byte3
 */
private void sendMidiMessage(int codeIndexNumber,int cable,int byte1,int byte2,int byte3){
  byte[] writeBuffer=new byte[4];
  writeBuffer[0]=(byte)(((cable & 0xf) << 4) | (codeIndexNumber & 0xf));
  writeBuffer[1]=(byte)byte1;
  writeBuffer[2]=(byte)byte2;
  writeBuffer[3]=(byte)byte3;
synchronized (deviceConnection) {
    if (usbRequest == null) {
      usbRequest=new UsbRequest();
      usbRequest.initialize(deviceConnection,outputEndpoint);
    }
    while (usbRequest.queue(ByteBuffer.wrap(writeBuffer),4) == false) {
      try {
        Thread.sleep(1);
      }
 catch (      InterruptedException e) {
      }
    }
  }
  Log.d(Constants.TAG,""String_Node_Str"" + Arrays.toString(writeBuffer));
}","/** 
 * Sends MIDI message to output device.
 * @param codeIndexNumber
 * @param cable
 * @param byte1
 * @param byte2
 * @param byte3
 */
private void sendMidiMessage(int codeIndexNumber,int cable,int byte1,int byte2,int byte3){
  byte[] writeBuffer=new byte[4];
  writeBuffer[0]=(byte)(((cable & 0xf) << 4) | (codeIndexNumber & 0xf));
  writeBuffer[1]=(byte)byte1;
  writeBuffer[2]=(byte)byte2;
  writeBuffer[3]=(byte)byte3;
synchronized (deviceConnection) {
    if (usbRequest == null) {
      usbRequest=new UsbRequest();
      usbRequest.initialize(deviceConnection,outputEndpoint);
    }
    while (usbRequest.queue(ByteBuffer.wrap(writeBuffer),4) == false) {
      try {
        Thread.sleep(1);
      }
 catch (      InterruptedException e) {
      }
    }
    while (usbRequest.equals(deviceConnection.requestWait()) == false) {
      try {
        Thread.sleep(1);
      }
 catch (      InterruptedException e) {
      }
    }
  }
  Log.d(Constants.TAG,""String_Node_Str"" + Arrays.toString(writeBuffer));
}",0.907427341227126
99490,"/** 
 * constructor
 * @param usbDevice
 * @param usbDeviceConnection
 * @param usbInterface
 */
public MidiOutputDevice(UsbDevice usbDevice,UsbDeviceConnection usbDeviceConnection,UsbInterface usbInterface,UsbEndpoint usbEndpoint){
  this.usbDevice=usbDevice;
  this.deviceConnection=usbDeviceConnection;
  this.usbInterface=usbInterface;
  outputEndpoint=usbEndpoint;
  if (outputEndpoint == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Log.i(Constants.TAG,""String_Node_Str"" + deviceConnection + ""String_Node_Str""+ usbInterface);
  deviceConnection.claimInterface(this.usbInterface,true);
  usbRequest=new UsbRequest();
  usbRequest.initialize(deviceConnection,outputEndpoint);
}","/** 
 * constructor
 * @param usbDevice
 * @param usbDeviceConnection
 * @param usbInterface
 */
public MidiOutputDevice(UsbDevice usbDevice,UsbDeviceConnection usbDeviceConnection,UsbInterface usbInterface,UsbEndpoint usbEndpoint){
  this.usbDevice=usbDevice;
  this.deviceConnection=usbDeviceConnection;
  this.usbInterface=usbInterface;
  outputEndpoint=usbEndpoint;
  if (outputEndpoint == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Log.i(Constants.TAG,""String_Node_Str"" + deviceConnection + ""String_Node_Str""+ usbInterface);
  deviceConnection.claimInterface(this.usbInterface,true);
}",0.9330323551542512
99491,"/** 
 * SysEx Code Index Number : 0x4, 0x5, 0x6, 0x7
 * @param cable 0-15
 * @param systemExclusive : start with 'F0', and end with 'F7'
 */
@SuppressWarnings(""String_Node_Str"") public void sendMidiSystemExclusive(int cable,byte[] systemExclusive){
  ByteArrayOutputStream transferDataStream=new ByteArrayOutputStream();
  for (int sysexIndex=0; sysexIndex < systemExclusive.length; sysexIndex+=3) {
    if ((sysexIndex + 3 < systemExclusive.length)) {
      transferDataStream.write((((cable & 0xf) << 4) | 0x4));
      transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
      transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
      transferDataStream.write(systemExclusive[sysexIndex + 2] & 0xff);
    }
 else {
switch (systemExclusive.length % 3) {
case 1:
        transferDataStream.write((((cable & 0xf) << 4) | 0x5));
      transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
    transferDataStream.write(0);
  transferDataStream.write(0);
break;
case 2:
transferDataStream.write((((cable & 0xf) << 4) | 0x6));
transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
transferDataStream.write(0);
break;
case 0:
transferDataStream.write((((cable & 0xf) << 4) | 0x7));
transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 2] & 0xff);
break;
}
}
}
byte[] buffer=transferDataStream.toByteArray();
synchronized (deviceConnection) {
while (usbRequest.queue(ByteBuffer.wrap(buffer),buffer.length) == false) {
try {
Thread.sleep(1);
}
 catch (InterruptedException e) {
}
}
}
Log.d(Constants.TAG,""String_Node_Str"" + buffer.length + ""String_Node_Str""+ buffer.length+ ""String_Node_Str"");
}","/** 
 * SysEx Code Index Number : 0x4, 0x5, 0x6, 0x7
 * @param cable 0-15
 * @param systemExclusive : start with 'F0', and end with 'F7'
 */
@SuppressWarnings(""String_Node_Str"") public void sendMidiSystemExclusive(int cable,byte[] systemExclusive){
  ByteArrayOutputStream transferDataStream=new ByteArrayOutputStream();
  for (int sysexIndex=0; sysexIndex < systemExclusive.length; sysexIndex+=3) {
    if ((sysexIndex + 3 < systemExclusive.length)) {
      transferDataStream.write((((cable & 0xf) << 4) | 0x4));
      transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
      transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
      transferDataStream.write(systemExclusive[sysexIndex + 2] & 0xff);
    }
 else {
switch (systemExclusive.length % 3) {
case 1:
        transferDataStream.write((((cable & 0xf) << 4) | 0x5));
      transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
    transferDataStream.write(0);
  transferDataStream.write(0);
break;
case 2:
transferDataStream.write((((cable & 0xf) << 4) | 0x6));
transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
transferDataStream.write(0);
break;
case 0:
transferDataStream.write((((cable & 0xf) << 4) | 0x7));
transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 2] & 0xff);
break;
}
}
}
byte[] buffer=transferDataStream.toByteArray();
synchronized (deviceConnection) {
if (usbRequest == null) {
usbRequest=new UsbRequest();
usbRequest.initialize(deviceConnection,outputEndpoint);
}
while (usbRequest.queue(ByteBuffer.wrap(buffer),buffer.length) == false) {
try {
Thread.sleep(1);
}
 catch (InterruptedException e) {
}
}
}
Log.d(Constants.TAG,""String_Node_Str"" + buffer.length + ""String_Node_Str""+ buffer.length+ ""String_Node_Str"");
}",0.9701768276590128
99492,"/** 
 * stop to use this device.
 */
public void stop(){
  deviceConnection.releaseInterface(usbInterface);
}","/** 
 * stop to use this device.
 */
public void stop(){
  if (usbRequest != null) {
    usbRequest.close();
  }
  deviceConnection.releaseInterface(usbInterface);
}",0.7956204379562044
99493,"/** 
 * Sends MIDI message to output device.
 * @param codeIndexNumber
 * @param cable
 * @param byte1
 * @param byte2
 * @param byte3
 */
private void sendMidiMessage(int codeIndexNumber,int cable,int byte1,int byte2,int byte3){
  byte[] writeBuffer=new byte[4];
  writeBuffer[0]=(byte)(((cable & 0xf) << 4) | (codeIndexNumber & 0xf));
  writeBuffer[1]=(byte)byte1;
  writeBuffer[2]=(byte)byte2;
  writeBuffer[3]=(byte)byte3;
synchronized (deviceConnection) {
    while (usbRequest.queue(ByteBuffer.wrap(writeBuffer),4) == false) {
      try {
        Thread.sleep(1);
      }
 catch (      InterruptedException e) {
      }
    }
  }
  Log.d(Constants.TAG,""String_Node_Str"" + Arrays.toString(writeBuffer));
}","/** 
 * Sends MIDI message to output device.
 * @param codeIndexNumber
 * @param cable
 * @param byte1
 * @param byte2
 * @param byte3
 */
private void sendMidiMessage(int codeIndexNumber,int cable,int byte1,int byte2,int byte3){
  byte[] writeBuffer=new byte[4];
  writeBuffer[0]=(byte)(((cable & 0xf) << 4) | (codeIndexNumber & 0xf));
  writeBuffer[1]=(byte)byte1;
  writeBuffer[2]=(byte)byte2;
  writeBuffer[3]=(byte)byte3;
synchronized (deviceConnection) {
    if (usbRequest == null) {
      usbRequest=new UsbRequest();
      usbRequest.initialize(deviceConnection,outputEndpoint);
    }
    while (usbRequest.queue(ByteBuffer.wrap(writeBuffer),4) == false) {
      try {
        Thread.sleep(1);
      }
 catch (      InterruptedException e) {
      }
    }
  }
  Log.d(Constants.TAG,""String_Node_Str"" + Arrays.toString(writeBuffer));
}",0.9143593045717964
99494,"/** 
 * SysEx Code Index Number : 0x4, 0x5, 0x6, 0x7
 * @param cable 0-15
 * @param systemExclusive : start with 'F0', and end with 'F7'
 */
@SuppressWarnings(""String_Node_Str"") public void sendMidiSystemExclusive(int cable,byte[] systemExclusive){
  ByteArrayOutputStream transferDataStream=new ByteArrayOutputStream();
  for (int sysexIndex=0; sysexIndex < systemExclusive.length; sysexIndex+=3) {
    if ((sysexIndex + 3 < systemExclusive.length)) {
      transferDataStream.write((((cable & 0xf) << 4) | 0x4));
      transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
      transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
      transferDataStream.write(systemExclusive[sysexIndex + 2] & 0xff);
    }
 else {
switch (systemExclusive.length % 3) {
case 1:
        transferDataStream.write((((cable & 0xf) << 4) | 0x5));
      transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
    transferDataStream.write(0);
  transferDataStream.write(0);
break;
case 2:
transferDataStream.write((((cable & 0xf) << 4) | 0x6));
transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
transferDataStream.write(0);
break;
case 0:
transferDataStream.write((((cable & 0xf) << 4) | 0x7));
transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 2] & 0xff);
break;
}
}
}
byte[] buffer=transferDataStream.toByteArray();
synchronized (deviceConnection) {
if (usbRequest == null) {
usbRequest=new UsbRequest();
usbRequest.initialize(deviceConnection,outputEndpoint);
}
while (usbRequest.queue(ByteBuffer.wrap(buffer),buffer.length) == false) {
try {
Thread.sleep(1);
}
 catch (InterruptedException e) {
}
}
}
Log.d(Constants.TAG,""String_Node_Str"" + buffer.length + ""String_Node_Str""+ buffer.length+ ""String_Node_Str"");
}","/** 
 * SysEx Code Index Number : 0x4, 0x5, 0x6, 0x7
 * @param cable 0-15
 * @param systemExclusive : start with 'F0', and end with 'F7'
 */
@SuppressWarnings(""String_Node_Str"") public void sendMidiSystemExclusive(int cable,byte[] systemExclusive){
  ByteArrayOutputStream transferDataStream=new ByteArrayOutputStream();
  for (int sysexIndex=0; sysexIndex < systemExclusive.length; sysexIndex+=3) {
    if ((sysexIndex + 3 < systemExclusive.length)) {
      transferDataStream.write((((cable & 0xf) << 4) | 0x4));
      transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
      transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
      transferDataStream.write(systemExclusive[sysexIndex + 2] & 0xff);
    }
 else {
switch (systemExclusive.length % 3) {
case 1:
        transferDataStream.write((((cable & 0xf) << 4) | 0x5));
      transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
    transferDataStream.write(0);
  transferDataStream.write(0);
break;
case 2:
transferDataStream.write((((cable & 0xf) << 4) | 0x6));
transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
transferDataStream.write(0);
break;
case 0:
transferDataStream.write((((cable & 0xf) << 4) | 0x7));
transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 2] & 0xff);
break;
}
}
}
byte[] buffer=transferDataStream.toByteArray();
synchronized (deviceConnection) {
if (usbRequest == null) {
usbRequest=new UsbRequest();
usbRequest.initialize(deviceConnection,outputEndpoint);
}
while (usbRequest.queue(ByteBuffer.wrap(buffer),buffer.length) == false) {
try {
Thread.sleep(1);
}
 catch (InterruptedException e) {
}
}
while (usbRequest.equals(deviceConnection.requestWait()) == false) {
try {
Thread.sleep(1);
}
 catch (InterruptedException e) {
}
}
}
Log.d(Constants.TAG,""String_Node_Str"" + buffer.length + ""String_Node_Str""+ buffer.length+ ""String_Node_Str"");
}",0.9672781358453147
99495,"/** 
 * Sends MIDI message to output device.
 * @param codeIndexNumber
 * @param cable
 * @param byte1
 * @param byte2
 * @param byte3
 */
private void sendMidiMessage(int codeIndexNumber,int cable,int byte1,int byte2,int byte3){
  byte[] writeBuffer=new byte[4];
  writeBuffer[0]=(byte)(((cable & 0xf) << 4) | (codeIndexNumber & 0xf));
  writeBuffer[1]=(byte)byte1;
  writeBuffer[2]=(byte)byte2;
  writeBuffer[3]=(byte)byte3;
synchronized (deviceConnection) {
    if (usbRequest == null) {
      usbRequest=new UsbRequest();
      usbRequest.initialize(deviceConnection,outputEndpoint);
    }
    while (usbRequest.queue(ByteBuffer.wrap(writeBuffer),4) == false) {
      try {
        Thread.sleep(1);
      }
 catch (      InterruptedException e) {
      }
    }
  }
  Log.d(Constants.TAG,""String_Node_Str"" + Arrays.toString(writeBuffer));
}","/** 
 * Sends MIDI message to output device.
 * @param codeIndexNumber
 * @param cable
 * @param byte1
 * @param byte2
 * @param byte3
 */
private void sendMidiMessage(int codeIndexNumber,int cable,int byte1,int byte2,int byte3){
  byte[] writeBuffer=new byte[4];
  writeBuffer[0]=(byte)(((cable & 0xf) << 4) | (codeIndexNumber & 0xf));
  writeBuffer[1]=(byte)byte1;
  writeBuffer[2]=(byte)byte2;
  writeBuffer[3]=(byte)byte3;
synchronized (deviceConnection) {
    if (usbRequest == null) {
      usbRequest=new UsbRequest();
      usbRequest.initialize(deviceConnection,outputEndpoint);
    }
    while (usbRequest.queue(ByteBuffer.wrap(writeBuffer),4) == false) {
      try {
        Thread.sleep(1);
      }
 catch (      InterruptedException e) {
      }
    }
    while (usbRequest.equals(deviceConnection.requestWait()) == false) {
      try {
        Thread.sleep(1);
      }
 catch (      InterruptedException e) {
      }
    }
  }
  Log.d(Constants.TAG,""String_Node_Str"" + Arrays.toString(writeBuffer));
}",0.907427341227126
99496,"@Override public void run(){
  while (true) {
    if (stopFlag) {
      return;
    }
    if (inputEndpoint == null) {
      continue;
    }
    int length=usbDeviceConnection.bulkTransfer(inputEndpoint,readBuffer,readBuffer.length,1);
    if (length > 0) {
      byte[] read=new byte[length];
      System.arraycopy(readBuffer,0,read,0,length);
      Log.d(Constants.TAG,""String_Node_Str"" + Arrays.toString(read));
      Message message=new Message();
      message.obj=read;
      if (!stopFlag) {
        receiveHandler.sendMessage(message);
      }
    }
  }
}","@Override public void run(){
  while (true) {
    if (stopFlag) {
      return;
    }
    if (inputEndpoint == null) {
      continue;
    }
    int length=usbDeviceConnection.bulkTransfer(inputEndpoint,readBuffer,readBuffer.length,0);
    if (length > 0) {
      byte[] read=new byte[length];
      System.arraycopy(readBuffer,0,read,0,length);
      Log.d(Constants.TAG,""String_Node_Str"" + Arrays.toString(read));
      Message message=new Message();
      message.obj=read;
      if (!stopFlag) {
        receiveHandler.sendMessage(message);
      }
    }
  }
}",0.99822695035461
99497,"/** 
 * SysEx Code Index Number : 0x4, 0x5, 0x6, 0x7
 * @param cable 0-15
 * @param systemExclusive : start with 'F0', and end with 'F7'
 */
@SuppressWarnings(""String_Node_Str"") public void sendMidiSystemExclusive(int cable,byte[] systemExclusive){
  ByteArrayOutputStream transferDataStream=new ByteArrayOutputStream();
  for (int sysexIndex=0; sysexIndex < systemExclusive.length; sysexIndex+=3) {
    if ((sysexIndex + 3 < systemExclusive.length)) {
      transferDataStream.write((((cable & 0xf) << 4) | 0x4));
      transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
      transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
      transferDataStream.write(systemExclusive[sysexIndex + 2] & 0xff);
    }
 else {
switch (systemExclusive.length % 3) {
case 1:
        transferDataStream.write((((cable & 0xf) << 4) | 0x5));
      transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
    transferDataStream.write(0);
  transferDataStream.write(0);
break;
case 2:
transferDataStream.write((((cable & 0xf) << 4) | 0x6));
transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
transferDataStream.write(0);
break;
case 0:
transferDataStream.write((((cable & 0xf) << 4) | 0x7));
transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 2] & 0xff);
break;
}
}
}
byte[] buffer=transferDataStream.toByteArray();
synchronized (deviceConnection) {
if (usbRequest == null) {
usbRequest=new UsbRequest();
usbRequest.initialize(deviceConnection,outputEndpoint);
}
while (usbRequest.queue(ByteBuffer.wrap(buffer),buffer.length) == false) {
try {
Thread.sleep(1);
}
 catch (InterruptedException e) {
}
}
}
Log.d(Constants.TAG,""String_Node_Str"" + buffer.length + ""String_Node_Str""+ buffer.length+ ""String_Node_Str"");
}","/** 
 * SysEx Code Index Number : 0x4, 0x5, 0x6, 0x7
 * @param cable 0-15
 * @param systemExclusive : start with 'F0', and end with 'F7'
 */
@SuppressWarnings(""String_Node_Str"") public void sendMidiSystemExclusive(int cable,byte[] systemExclusive){
  ByteArrayOutputStream transferDataStream=new ByteArrayOutputStream();
  for (int sysexIndex=0; sysexIndex < systemExclusive.length; sysexIndex+=3) {
    if ((sysexIndex + 3 < systemExclusive.length)) {
      transferDataStream.write((((cable & 0xf) << 4) | 0x4));
      transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
      transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
      transferDataStream.write(systemExclusive[sysexIndex + 2] & 0xff);
    }
 else {
switch (systemExclusive.length % 3) {
case 1:
        transferDataStream.write((((cable & 0xf) << 4) | 0x5));
      transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
    transferDataStream.write(0);
  transferDataStream.write(0);
break;
case 2:
transferDataStream.write((((cable & 0xf) << 4) | 0x6));
transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
transferDataStream.write(0);
break;
case 0:
transferDataStream.write((((cable & 0xf) << 4) | 0x7));
transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 2] & 0xff);
break;
}
}
}
byte[] buffer=transferDataStream.toByteArray();
synchronized (deviceConnection) {
if (usbRequest == null) {
usbRequest=new UsbRequest();
usbRequest.initialize(deviceConnection,outputEndpoint);
}
while (usbRequest.queue(ByteBuffer.wrap(buffer),buffer.length) == false) {
try {
Thread.sleep(1);
}
 catch (InterruptedException e) {
}
}
while (usbRequest.equals(deviceConnection.requestWait()) == false) {
try {
Thread.sleep(1);
}
 catch (InterruptedException e) {
}
}
}
Log.d(Constants.TAG,""String_Node_Str"" + buffer.length + ""String_Node_Str""+ buffer.length+ ""String_Node_Str"");
}",0.9672781358453147
99498,"/** 
 * Sends MIDI message to output device.
 * @param codeIndexNumber
 * @param cable
 * @param byte1
 * @param byte2
 * @param byte3
 */
private void sendMidiMessage(int codeIndexNumber,int cable,int byte1,int byte2,int byte3){
  byte[] writeBuffer=new byte[4];
  writeBuffer[0]=(byte)(((cable & 0xf) << 4) | (codeIndexNumber & 0xf));
  writeBuffer[1]=(byte)byte1;
  writeBuffer[2]=(byte)byte2;
  writeBuffer[3]=(byte)byte3;
synchronized (deviceConnection) {
    if (usbRequest == null) {
      usbRequest=new UsbRequest();
      usbRequest.initialize(deviceConnection,outputEndpoint);
    }
    while (usbRequest.queue(ByteBuffer.wrap(writeBuffer),4) == false) {
      try {
        Thread.sleep(1);
      }
 catch (      InterruptedException e) {
      }
    }
  }
  Log.d(Constants.TAG,""String_Node_Str"" + Arrays.toString(writeBuffer));
}","/** 
 * Sends MIDI message to output device.
 * @param codeIndexNumber
 * @param cable
 * @param byte1
 * @param byte2
 * @param byte3
 */
private void sendMidiMessage(int codeIndexNumber,int cable,int byte1,int byte2,int byte3){
  byte[] writeBuffer=new byte[4];
  writeBuffer[0]=(byte)(((cable & 0xf) << 4) | (codeIndexNumber & 0xf));
  writeBuffer[1]=(byte)byte1;
  writeBuffer[2]=(byte)byte2;
  writeBuffer[3]=(byte)byte3;
synchronized (deviceConnection) {
    if (usbRequest == null) {
      usbRequest=new UsbRequest();
      usbRequest.initialize(deviceConnection,outputEndpoint);
    }
    while (usbRequest.queue(ByteBuffer.wrap(writeBuffer),4) == false) {
      try {
        Thread.sleep(1);
      }
 catch (      InterruptedException e) {
      }
    }
    while (usbRequest.equals(deviceConnection.requestWait()) == false) {
      try {
        Thread.sleep(1);
      }
 catch (      InterruptedException e) {
      }
    }
  }
  Log.d(Constants.TAG,""String_Node_Str"" + Arrays.toString(writeBuffer));
}",0.907427341227126
99499,"/** 
 * SysEx Code Index Number : 0x4, 0x5, 0x6, 0x7
 * @param cable 0-15
 * @param systemExclusive : start with 'F0', and end with 'F7'
 */
public void sendMidiSystemExclusive(int cable,final byte[] systemExclusive){
  for (int sysexStartPosition=0; sysexStartPosition < systemExclusive.length; sysexStartPosition+=PARAM_BUFFER_SIZE_FOR_RAW_SYSEX) {
    int sysexTransferLength=0;
    if (sysexStartPosition + PARAM_BUFFER_SIZE_FOR_RAW_SYSEX > systemExclusive.length) {
      sysexTransferLength=systemExclusive.length - sysexStartPosition;
    }
 else {
      sysexTransferLength=PARAM_BUFFER_SIZE_FOR_RAW_SYSEX;
    }
    byte[] buffer=new byte[PARAM_BUFFER_SIZE];
    int bufferIndex=0;
    for (int sysexIndex=sysexStartPosition; sysexIndex < sysexStartPosition + sysexTransferLength; sysexIndex+=3, bufferIndex+=4) {
      if ((sysexIndex + 3 < systemExclusive.length) && (sysexIndex + 3 <= sysexStartPosition + sysexTransferLength)) {
        buffer[bufferIndex + 0]=(byte)(((cable & 0xf) << 4) | (0x4 & 0xf));
        buffer[bufferIndex + 1]=systemExclusive[sysexIndex + 0];
        buffer[bufferIndex + 2]=systemExclusive[sysexIndex + 1];
        buffer[bufferIndex + 3]=systemExclusive[sysexIndex + 2];
      }
 else {
switch (sysexStartPosition + sysexTransferLength - sysexIndex) {
case 1:
          buffer[bufferIndex + 0]=(byte)(((cable & 0xf) << 4) | (0x5 & 0xf));
        buffer[bufferIndex + 1]=systemExclusive[sysexIndex + 0];
      buffer[bufferIndex + 2]=0;
    buffer[bufferIndex + 3]=0;
  break;
case 2:
buffer[bufferIndex + 0]=(byte)(((cable & 0xf) << 4) | (0x6 & 0xf));
buffer[bufferIndex + 1]=systemExclusive[sysexIndex + 0];
buffer[bufferIndex + 2]=systemExclusive[sysexIndex + 1];
buffer[bufferIndex + 3]=0;
break;
case 3:
buffer[bufferIndex + 0]=(byte)(((cable & 0xf) << 4) | (0x7 & 0xf));
buffer[bufferIndex + 1]=systemExclusive[sysexIndex + 0];
buffer[bufferIndex + 2]=systemExclusive[sysexIndex + 1];
buffer[bufferIndex + 3]=systemExclusive[sysexIndex + 2];
break;
default :
break;
}
}
}
deviceConnection.bulkTransfer(outputEndpoint,buffer,buffer.length,0);
}
}","/** 
 * SysEx Code Index Number : 0x4, 0x5, 0x6, 0x7
 * @param cable 0-15
 * @param systemExclusive : start with 'F0', and end with 'F7'
 */
public void sendMidiSystemExclusive(int cable,final byte[] systemExclusive){
  ByteArrayOutputStream transferDataStream=new ByteArrayOutputStream();
  for (int sysexIndex=0; sysexIndex < systemExclusive.length; sysexIndex+=3) {
    if ((sysexIndex + 3 < systemExclusive.length)) {
      transferDataStream.write((((cable & 0xf) << 4) | 0x4));
      transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
      transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
      transferDataStream.write(systemExclusive[sysexIndex + 2] & 0xff);
    }
 else {
switch (systemExclusive.length % 3) {
case 1:
        transferDataStream.write((((cable & 0xf) << 4) | 0x5));
      transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
    transferDataStream.write(0);
  transferDataStream.write(0);
break;
case 2:
transferDataStream.write((((cable & 0xf) << 4) | 0x6));
transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
transferDataStream.write(0);
break;
case 0:
transferDataStream.write((((cable & 0xf) << 4) | 0x7));
transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 2] & 0xff);
break;
}
}
}
byte[] buffer=transferDataStream.toByteArray();
int transferedBytes=deviceConnection.bulkTransfer(outputEndpoint,buffer,buffer.length,0);
Log.d(Constants.TAG,""String_Node_Str"" + transferedBytes + ""String_Node_Str""+ buffer.length+ ""String_Node_Str"");
}",0.2735132302855645
99500,"/** 
 * Sends MIDI message to output device.
 * @param codeIndexNumber
 * @param cable
 * @param byte1
 * @param byte2
 * @param byte3
 */
private void sendMidiMessage(int codeIndexNumber,int cable,int byte1,int byte2,int byte3){
  byte[] writeBuffer=new byte[outputEndpoint.getMaxPacketSize()];
  writeBuffer[0]=(byte)(((cable & 0xf) << 4) | (codeIndexNumber & 0xf));
  writeBuffer[1]=(byte)byte1;
  writeBuffer[2]=(byte)byte2;
  writeBuffer[3]=(byte)byte3;
  deviceConnection.bulkTransfer(outputEndpoint,writeBuffer,writeBuffer.length,0);
  Log.d(Constants.TAG,""String_Node_Str"" + Arrays.toString(writeBuffer));
}","/** 
 * Sends MIDI message to output device.
 * @param codeIndexNumber
 * @param cable
 * @param byte1
 * @param byte2
 * @param byte3
 */
private void sendMidiMessage(int codeIndexNumber,int cable,int byte1,int byte2,int byte3){
  byte[] writeBuffer=new byte[4];
  writeBuffer[0]=(byte)(((cable & 0xf) << 4) | (codeIndexNumber & 0xf));
  writeBuffer[1]=(byte)byte1;
  writeBuffer[2]=(byte)byte2;
  writeBuffer[3]=(byte)byte3;
  deviceConnection.bulkTransfer(outputEndpoint,writeBuffer,writeBuffer.length,0);
  Log.d(Constants.TAG,""String_Node_Str"" + Arrays.toString(writeBuffer));
}",0.9716193656093488
99501,"/** 
 * constructor
 * @param usbDevice
 * @param usbDeviceConnection
 * @param usbInterface
 */
public MidiOutputDevice(UsbDevice usbDevice,UsbDeviceConnection usbDeviceConnection,UsbInterface usbInterface,UsbEndpoint usbEndpoint){
  this.usbDevice=usbDevice;
  this.deviceConnection=usbDeviceConnection;
  this.usbInterface=usbInterface;
  outputEndpoint=usbEndpoint;
  if (outputEndpoint == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Log.i(Constants.TAG,""String_Node_Str"" + deviceConnection + ""String_Node_Str""+ usbInterface);
  deviceConnection.claimInterface(this.usbInterface,true);
  usbRequest=new UsbRequest();
  usbRequest.initialize(deviceConnection,outputEndpoint);
}","/** 
 * constructor
 * @param usbDevice
 * @param usbDeviceConnection
 * @param usbInterface
 */
public MidiOutputDevice(UsbDevice usbDevice,UsbDeviceConnection usbDeviceConnection,UsbInterface usbInterface,UsbEndpoint usbEndpoint){
  this.usbDevice=usbDevice;
  this.deviceConnection=usbDeviceConnection;
  this.usbInterface=usbInterface;
  outputEndpoint=usbEndpoint;
  if (outputEndpoint == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Log.i(Constants.TAG,""String_Node_Str"" + deviceConnection + ""String_Node_Str""+ usbInterface);
  deviceConnection.claimInterface(this.usbInterface,true);
}",0.9330323551542512
99502,"/** 
 * SysEx Code Index Number : 0x4, 0x5, 0x6, 0x7
 * @param cable 0-15
 * @param systemExclusive : start with 'F0', and end with 'F7'
 */
@SuppressWarnings(""String_Node_Str"") public void sendMidiSystemExclusive(int cable,byte[] systemExclusive){
  ByteArrayOutputStream transferDataStream=new ByteArrayOutputStream();
  for (int sysexIndex=0; sysexIndex < systemExclusive.length; sysexIndex+=3) {
    if ((sysexIndex + 3 < systemExclusive.length)) {
      transferDataStream.write((((cable & 0xf) << 4) | 0x4));
      transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
      transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
      transferDataStream.write(systemExclusive[sysexIndex + 2] & 0xff);
    }
 else {
switch (systemExclusive.length % 3) {
case 1:
        transferDataStream.write((((cable & 0xf) << 4) | 0x5));
      transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
    transferDataStream.write(0);
  transferDataStream.write(0);
break;
case 2:
transferDataStream.write((((cable & 0xf) << 4) | 0x6));
transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
transferDataStream.write(0);
break;
case 0:
transferDataStream.write((((cable & 0xf) << 4) | 0x7));
transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 2] & 0xff);
break;
}
}
}
byte[] buffer=transferDataStream.toByteArray();
synchronized (deviceConnection) {
while (usbRequest.queue(ByteBuffer.wrap(buffer),buffer.length) == false) {
try {
Thread.sleep(1);
}
 catch (InterruptedException e) {
}
}
}
Log.d(Constants.TAG,""String_Node_Str"" + buffer.length + ""String_Node_Str""+ buffer.length+ ""String_Node_Str"");
}","/** 
 * SysEx Code Index Number : 0x4, 0x5, 0x6, 0x7
 * @param cable 0-15
 * @param systemExclusive : start with 'F0', and end with 'F7'
 */
@SuppressWarnings(""String_Node_Str"") public void sendMidiSystemExclusive(int cable,byte[] systemExclusive){
  ByteArrayOutputStream transferDataStream=new ByteArrayOutputStream();
  for (int sysexIndex=0; sysexIndex < systemExclusive.length; sysexIndex+=3) {
    if ((sysexIndex + 3 < systemExclusive.length)) {
      transferDataStream.write((((cable & 0xf) << 4) | 0x4));
      transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
      transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
      transferDataStream.write(systemExclusive[sysexIndex + 2] & 0xff);
    }
 else {
switch (systemExclusive.length % 3) {
case 1:
        transferDataStream.write((((cable & 0xf) << 4) | 0x5));
      transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
    transferDataStream.write(0);
  transferDataStream.write(0);
break;
case 2:
transferDataStream.write((((cable & 0xf) << 4) | 0x6));
transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
transferDataStream.write(0);
break;
case 0:
transferDataStream.write((((cable & 0xf) << 4) | 0x7));
transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 2] & 0xff);
break;
}
}
}
byte[] buffer=transferDataStream.toByteArray();
synchronized (deviceConnection) {
if (usbRequest == null) {
usbRequest=new UsbRequest();
usbRequest.initialize(deviceConnection,outputEndpoint);
}
while (usbRequest.queue(ByteBuffer.wrap(buffer),buffer.length) == false) {
try {
Thread.sleep(1);
}
 catch (InterruptedException e) {
}
}
}
Log.d(Constants.TAG,""String_Node_Str"" + buffer.length + ""String_Node_Str""+ buffer.length+ ""String_Node_Str"");
}",0.9701768276590128
99503,"/** 
 * stop to use this device.
 */
public void stop(){
  deviceConnection.releaseInterface(usbInterface);
}","/** 
 * stop to use this device.
 */
public void stop(){
  if (usbRequest != null) {
    usbRequest.close();
  }
  deviceConnection.releaseInterface(usbInterface);
}",0.7956204379562044
99504,"/** 
 * Sends MIDI message to output device.
 * @param codeIndexNumber
 * @param cable
 * @param byte1
 * @param byte2
 * @param byte3
 */
private void sendMidiMessage(int codeIndexNumber,int cable,int byte1,int byte2,int byte3){
  byte[] writeBuffer=new byte[4];
  writeBuffer[0]=(byte)(((cable & 0xf) << 4) | (codeIndexNumber & 0xf));
  writeBuffer[1]=(byte)byte1;
  writeBuffer[2]=(byte)byte2;
  writeBuffer[3]=(byte)byte3;
synchronized (deviceConnection) {
    while (usbRequest.queue(ByteBuffer.wrap(writeBuffer),4) == false) {
      try {
        Thread.sleep(1);
      }
 catch (      InterruptedException e) {
      }
    }
  }
  Log.d(Constants.TAG,""String_Node_Str"" + Arrays.toString(writeBuffer));
}","/** 
 * Sends MIDI message to output device.
 * @param codeIndexNumber
 * @param cable
 * @param byte1
 * @param byte2
 * @param byte3
 */
private void sendMidiMessage(int codeIndexNumber,int cable,int byte1,int byte2,int byte3){
  byte[] writeBuffer=new byte[4];
  writeBuffer[0]=(byte)(((cable & 0xf) << 4) | (codeIndexNumber & 0xf));
  writeBuffer[1]=(byte)byte1;
  writeBuffer[2]=(byte)byte2;
  writeBuffer[3]=(byte)byte3;
synchronized (deviceConnection) {
    if (usbRequest == null) {
      usbRequest=new UsbRequest();
      usbRequest.initialize(deviceConnection,outputEndpoint);
    }
    while (usbRequest.queue(ByteBuffer.wrap(writeBuffer),4) == false) {
      try {
        Thread.sleep(1);
      }
 catch (      InterruptedException e) {
      }
    }
  }
  Log.d(Constants.TAG,""String_Node_Str"" + Arrays.toString(writeBuffer));
}",0.9143593045717964
99505,"@Override public void run(){
  while (true) {
    if (stopFlag) {
      return;
    }
    if (inputEndpoint == null) {
      continue;
    }
    int length=usbDeviceConnection.bulkTransfer(inputEndpoint,readBuffer,readBuffer.length,1);
    if (length > 0) {
      byte[] read=new byte[length];
      System.arraycopy(readBuffer,0,read,0,length);
      Log.d(Constants.TAG,""String_Node_Str"" + Arrays.toString(read));
      Message message=new Message();
      message.obj=read;
      if (!stopFlag) {
        receiveHandler.sendMessage(message);
      }
    }
  }
}","@Override public void run(){
  while (true) {
    if (stopFlag) {
      return;
    }
    if (inputEndpoint == null) {
      continue;
    }
    int length=usbDeviceConnection.bulkTransfer(inputEndpoint,readBuffer,readBuffer.length,0);
    if (length > 0) {
      byte[] read=new byte[length];
      System.arraycopy(readBuffer,0,read,0,length);
      Log.d(Constants.TAG,""String_Node_Str"" + Arrays.toString(read));
      Message message=new Message();
      message.obj=read;
      if (!stopFlag) {
        receiveHandler.sendMessage(message);
      }
    }
  }
}",0.99822695035461
99506,"@Override public boolean handleMessage(final Message msg){
  if (midiEventListener == null) {
    return false;
  }
  byte[] read=(byte[])msg.obj;
  int cable;
  int codeIndexNumber;
  int byte1;
  int byte2;
  int byte3;
  for (int i=0; i < read.length; i+=4) {
    cable=(read[i + 0] >> 4) & 0xf;
    codeIndexNumber=read[i + 0] & 0xf;
    byte1=read[i + 1] & 0xff;
    byte2=read[i + 2] & 0xff;
    byte3=read[i + 3] & 0xff;
switch (codeIndexNumber) {
case 0:
      midiEventListener.onMidiMiscellaneousFunctionCodes(sender,cable,byte1,byte2,byte3);
    break;
case 1:
  midiEventListener.onMidiCableEvents(sender,cable,byte1,byte2,byte3);
break;
case 2:
{
byte[] bytes=new byte[]{(byte)byte1,(byte)byte2};
midiEventListener.onMidiSystemCommonMessage(sender,cable,bytes);
}
break;
case 3:
{
byte[] bytes=new byte[]{(byte)byte1,(byte)byte2,(byte)byte3};
midiEventListener.onMidiSystemCommonMessage(sender,cable,bytes);
}
break;
case 4:
synchronized (this) {
systemExclusive=new ByteArrayOutputStream();
}
synchronized (systemExclusive) {
systemExclusive.write(byte1);
systemExclusive.write(byte2);
systemExclusive.write(byte3);
}
break;
case 5:
if (systemExclusive == null) {
byte[] bytes=new byte[]{(byte)byte1};
midiEventListener.onMidiSystemCommonMessage(sender,cable,bytes);
}
 else {
synchronized (systemExclusive) {
systemExclusive.write(byte1);
midiEventListener.onMidiSystemExclusive(sender,cable,systemExclusive.toByteArray());
}
synchronized (this) {
systemExclusive=null;
}
}
break;
case 6:
if (systemExclusive != null) {
synchronized (systemExclusive) {
systemExclusive.write(byte1);
systemExclusive.write(byte2);
midiEventListener.onMidiSystemExclusive(sender,cable,systemExclusive.toByteArray());
}
synchronized (this) {
systemExclusive=null;
}
}
break;
case 7:
if (systemExclusive != null) {
synchronized (systemExclusive) {
systemExclusive.write(byte1);
systemExclusive.write(byte2);
systemExclusive.write(byte3);
midiEventListener.onMidiSystemExclusive(sender,cable,systemExclusive.toByteArray());
}
synchronized (this) {
systemExclusive=null;
}
}
break;
case 8:
midiEventListener.onMidiNoteOff(sender,cable,byte1 & 0xf,byte2,byte3);
break;
case 9:
midiEventListener.onMidiNoteOn(sender,cable,byte1 & 0xf,byte2,byte3);
break;
case 10:
midiEventListener.onMidiPolyphonicAftertouch(sender,cable,byte1 & 0xf,byte2,byte3);
break;
case 11:
midiEventListener.onMidiControlChange(sender,cable,byte1 & 0xf,byte2,byte3);
break;
case 12:
midiEventListener.onMidiProgramChange(sender,cable,byte1 & 0xf,byte2);
break;
case 13:
midiEventListener.onMidiChannelAftertouch(sender,cable,byte1 & 0xf,byte2);
break;
case 14:
midiEventListener.onMidiPitchWheel(sender,cable,byte1 & 0xf,byte2 | (byte3 << 8));
break;
case 15:
midiEventListener.onMidiSingleByte(sender,cable,byte1);
break;
default :
break;
}
}
return false;
}","@Override public boolean handleMessage(final Message msg){
  if (midiEventListener == null) {
    return false;
  }
  byte[] read=(byte[])msg.obj;
  int cable;
  int codeIndexNumber;
  int byte1;
  int byte2;
  int byte3;
  for (int i=0; i < read.length; i+=4) {
    cable=(read[i + 0] >> 4) & 0xf;
    codeIndexNumber=read[i + 0] & 0xf;
    byte1=read[i + 1] & 0xff;
    byte2=read[i + 2] & 0xff;
    byte3=read[i + 3] & 0xff;
switch (codeIndexNumber) {
case 0:
      midiEventListener.onMidiMiscellaneousFunctionCodes(sender,cable,byte1,byte2,byte3);
    break;
case 1:
  midiEventListener.onMidiCableEvents(sender,cable,byte1,byte2,byte3);
break;
case 2:
{
byte[] bytes=new byte[]{(byte)byte1,(byte)byte2};
midiEventListener.onMidiSystemCommonMessage(sender,cable,bytes);
}
break;
case 3:
{
byte[] bytes=new byte[]{(byte)byte1,(byte)byte2,(byte)byte3};
midiEventListener.onMidiSystemCommonMessage(sender,cable,bytes);
}
break;
case 4:
synchronized (this) {
if (systemExclusive == null) {
systemExclusive=new ByteArrayOutputStream();
}
}
synchronized (systemExclusive) {
systemExclusive.write(byte1);
systemExclusive.write(byte2);
systemExclusive.write(byte3);
}
break;
case 5:
if (systemExclusive == null) {
byte[] bytes=new byte[]{(byte)byte1};
midiEventListener.onMidiSystemCommonMessage(sender,cable,bytes);
}
 else {
synchronized (systemExclusive) {
systemExclusive.write(byte1);
midiEventListener.onMidiSystemExclusive(sender,cable,systemExclusive.toByteArray());
}
synchronized (this) {
systemExclusive=null;
}
}
break;
case 6:
if (systemExclusive != null) {
synchronized (systemExclusive) {
systemExclusive.write(byte1);
systemExclusive.write(byte2);
midiEventListener.onMidiSystemExclusive(sender,cable,systemExclusive.toByteArray());
}
synchronized (this) {
systemExclusive=null;
}
}
break;
case 7:
if (systemExclusive != null) {
synchronized (systemExclusive) {
systemExclusive.write(byte1);
systemExclusive.write(byte2);
systemExclusive.write(byte3);
midiEventListener.onMidiSystemExclusive(sender,cable,systemExclusive.toByteArray());
}
synchronized (this) {
systemExclusive=null;
}
}
break;
case 8:
midiEventListener.onMidiNoteOff(sender,cable,byte1 & 0xf,byte2,byte3);
break;
case 9:
midiEventListener.onMidiNoteOn(sender,cable,byte1 & 0xf,byte2,byte3);
break;
case 10:
midiEventListener.onMidiPolyphonicAftertouch(sender,cable,byte1 & 0xf,byte2,byte3);
break;
case 11:
midiEventListener.onMidiControlChange(sender,cable,byte1 & 0xf,byte2,byte3);
break;
case 12:
midiEventListener.onMidiProgramChange(sender,cable,byte1 & 0xf,byte2);
break;
case 13:
midiEventListener.onMidiChannelAftertouch(sender,cable,byte1 & 0xf,byte2);
break;
case 14:
midiEventListener.onMidiPitchWheel(sender,cable,byte1 & 0xf,byte2 | (byte3 << 8));
break;
case 15:
midiEventListener.onMidiSingleByte(sender,cable,byte1);
break;
default :
break;
}
}
return false;
}",0.9889064976228208
99507,"/** 
 * constructor
 * @param usbDevice
 * @param usbDeviceConnection
 * @param usbInterface
 */
public MidiOutputDevice(UsbDevice usbDevice,UsbDeviceConnection usbDeviceConnection,UsbInterface usbInterface,UsbEndpoint usbEndpoint){
  this.usbDevice=usbDevice;
  this.deviceConnection=usbDeviceConnection;
  this.usbInterface=usbInterface;
  outputEndpoint=usbEndpoint;
  if (outputEndpoint == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Log.i(Constants.TAG,""String_Node_Str"" + deviceConnection + ""String_Node_Str""+ usbInterface);
  deviceConnection.claimInterface(this.usbInterface,true);
  usbRequest=new UsbRequest();
  usbRequest.initialize(deviceConnection,outputEndpoint);
}","/** 
 * constructor
 * @param usbDevice
 * @param usbDeviceConnection
 * @param usbInterface
 */
public MidiOutputDevice(UsbDevice usbDevice,UsbDeviceConnection usbDeviceConnection,UsbInterface usbInterface,UsbEndpoint usbEndpoint){
  this.usbDevice=usbDevice;
  this.deviceConnection=usbDeviceConnection;
  this.usbInterface=usbInterface;
  outputEndpoint=usbEndpoint;
  if (outputEndpoint == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Log.i(Constants.TAG,""String_Node_Str"" + deviceConnection + ""String_Node_Str""+ usbInterface);
  deviceConnection.claimInterface(this.usbInterface,true);
}",0.9330323551542512
99508,"/** 
 * SysEx Code Index Number : 0x4, 0x5, 0x6, 0x7
 * @param cable 0-15
 * @param systemExclusive : start with 'F0', and end with 'F7'
 */
@SuppressWarnings(""String_Node_Str"") public void sendMidiSystemExclusive(int cable,byte[] systemExclusive){
  ByteArrayOutputStream transferDataStream=new ByteArrayOutputStream();
  for (int sysexIndex=0; sysexIndex < systemExclusive.length; sysexIndex+=3) {
    if ((sysexIndex + 3 < systemExclusive.length)) {
      transferDataStream.write((((cable & 0xf) << 4) | 0x4));
      transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
      transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
      transferDataStream.write(systemExclusive[sysexIndex + 2] & 0xff);
    }
 else {
switch (systemExclusive.length % 3) {
case 1:
        transferDataStream.write((((cable & 0xf) << 4) | 0x5));
      transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
    transferDataStream.write(0);
  transferDataStream.write(0);
break;
case 2:
transferDataStream.write((((cable & 0xf) << 4) | 0x6));
transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
transferDataStream.write(0);
break;
case 0:
transferDataStream.write((((cable & 0xf) << 4) | 0x7));
transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 2] & 0xff);
break;
}
}
}
byte[] buffer=transferDataStream.toByteArray();
synchronized (deviceConnection) {
while (usbRequest.queue(ByteBuffer.wrap(buffer),buffer.length) == false) {
try {
Thread.sleep(1);
}
 catch (InterruptedException e) {
}
}
}
Log.d(Constants.TAG,""String_Node_Str"" + buffer.length + ""String_Node_Str""+ buffer.length+ ""String_Node_Str"");
}","/** 
 * SysEx Code Index Number : 0x4, 0x5, 0x6, 0x7
 * @param cable 0-15
 * @param systemExclusive : start with 'F0', and end with 'F7'
 */
@SuppressWarnings(""String_Node_Str"") public void sendMidiSystemExclusive(int cable,byte[] systemExclusive){
  ByteArrayOutputStream transferDataStream=new ByteArrayOutputStream();
  for (int sysexIndex=0; sysexIndex < systemExclusive.length; sysexIndex+=3) {
    if ((sysexIndex + 3 < systemExclusive.length)) {
      transferDataStream.write((((cable & 0xf) << 4) | 0x4));
      transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
      transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
      transferDataStream.write(systemExclusive[sysexIndex + 2] & 0xff);
    }
 else {
switch (systemExclusive.length % 3) {
case 1:
        transferDataStream.write((((cable & 0xf) << 4) | 0x5));
      transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
    transferDataStream.write(0);
  transferDataStream.write(0);
break;
case 2:
transferDataStream.write((((cable & 0xf) << 4) | 0x6));
transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
transferDataStream.write(0);
break;
case 0:
transferDataStream.write((((cable & 0xf) << 4) | 0x7));
transferDataStream.write(systemExclusive[sysexIndex + 0] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 1] & 0xff);
transferDataStream.write(systemExclusive[sysexIndex + 2] & 0xff);
break;
}
}
}
byte[] buffer=transferDataStream.toByteArray();
synchronized (deviceConnection) {
if (usbRequest == null) {
usbRequest=new UsbRequest();
usbRequest.initialize(deviceConnection,outputEndpoint);
}
while (usbRequest.queue(ByteBuffer.wrap(buffer),buffer.length) == false) {
try {
Thread.sleep(1);
}
 catch (InterruptedException e) {
}
}
}
Log.d(Constants.TAG,""String_Node_Str"" + buffer.length + ""String_Node_Str""+ buffer.length+ ""String_Node_Str"");
}",0.9701768276590128
99509,"/** 
 * stop to use this device.
 */
public void stop(){
  deviceConnection.releaseInterface(usbInterface);
}","/** 
 * stop to use this device.
 */
public void stop(){
  if (usbRequest != null) {
    usbRequest.close();
  }
  deviceConnection.releaseInterface(usbInterface);
}",0.7956204379562044
99510,"/** 
 * Sends MIDI message to output device.
 * @param codeIndexNumber
 * @param cable
 * @param byte1
 * @param byte2
 * @param byte3
 */
private void sendMidiMessage(int codeIndexNumber,int cable,int byte1,int byte2,int byte3){
  byte[] writeBuffer=new byte[4];
  writeBuffer[0]=(byte)(((cable & 0xf) << 4) | (codeIndexNumber & 0xf));
  writeBuffer[1]=(byte)byte1;
  writeBuffer[2]=(byte)byte2;
  writeBuffer[3]=(byte)byte3;
synchronized (deviceConnection) {
    while (usbRequest.queue(ByteBuffer.wrap(writeBuffer),4) == false) {
      try {
        Thread.sleep(1);
      }
 catch (      InterruptedException e) {
      }
    }
  }
  Log.d(Constants.TAG,""String_Node_Str"" + Arrays.toString(writeBuffer));
}","/** 
 * Sends MIDI message to output device.
 * @param codeIndexNumber
 * @param cable
 * @param byte1
 * @param byte2
 * @param byte3
 */
private void sendMidiMessage(int codeIndexNumber,int cable,int byte1,int byte2,int byte3){
  byte[] writeBuffer=new byte[4];
  writeBuffer[0]=(byte)(((cable & 0xf) << 4) | (codeIndexNumber & 0xf));
  writeBuffer[1]=(byte)byte1;
  writeBuffer[2]=(byte)byte2;
  writeBuffer[3]=(byte)byte3;
synchronized (deviceConnection) {
    if (usbRequest == null) {
      usbRequest=new UsbRequest();
      usbRequest.initialize(deviceConnection,outputEndpoint);
    }
    while (usbRequest.queue(ByteBuffer.wrap(writeBuffer),4) == false) {
      try {
        Thread.sleep(1);
      }
 catch (      InterruptedException e) {
      }
    }
  }
  Log.d(Constants.TAG,""String_Node_Str"" + Arrays.toString(writeBuffer));
}",0.9143593045717964
99511,"@Override public void run(){
  while (true) {
    if (stopFlag) {
      return;
    }
    if (inputEndpoint == null) {
      continue;
    }
    int length=usbDeviceConnection.bulkTransfer(inputEndpoint,readBuffer,readBuffer.length,1);
    if (length > 0) {
      byte[] read=new byte[length];
      System.arraycopy(readBuffer,0,read,0,length);
      Log.d(Constants.TAG,""String_Node_Str"" + Arrays.toString(read));
      Message message=new Message();
      message.obj=read;
      if (!stopFlag) {
        receiveHandler.sendMessage(message);
      }
    }
  }
}","@Override public void run(){
  while (true) {
    if (stopFlag) {
      return;
    }
    if (inputEndpoint == null) {
      continue;
    }
    int length=usbDeviceConnection.bulkTransfer(inputEndpoint,readBuffer,readBuffer.length,0);
    if (length > 0) {
      byte[] read=new byte[length];
      System.arraycopy(readBuffer,0,read,0,length);
      Log.d(Constants.TAG,""String_Node_Str"" + Arrays.toString(read));
      Message message=new Message();
      message.obj=read;
      if (!stopFlag) {
        receiveHandler.sendMessage(message);
      }
    }
  }
}",0.99822695035461
99512,"@BeforeClass public static void oneTimeSetup(){
  RedmineManager mgr=IntegrationTestHelper.createRedmineManager();
  userManager=mgr.getUserManager();
  try {
    createNonAdminUser();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","@BeforeClass public static void oneTimeSetup(){
  mgr=IntegrationTestHelper.createRedmineManager();
  userManager=mgr.getUserManager();
  try {
    createNonAdminUser();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.969574036511156
99513,"@BeforeClass public static void oneTimeSetUp(){
  TestConfig testConfig=new TestConfig();
  logger.info(""String_Node_Str"" + testConfig.getURI());
  RedmineManager mgr=IntegrationTestHelper.createRedmineManager();
  issueManager=mgr.getIssueManager();
  projectManager=mgr.getProjectManager();
  Project junitTestProject=ProjectFactory.create(""String_Node_Str"",""String_Node_Str"" + Calendar.getInstance().getTimeInMillis());
  try {
    Project createdProject=projectManager.createProject(junitTestProject);
    projectKey=createdProject.getIdentifier();
    projectId=createdProject.getId();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    Assert.fail(""String_Node_Str"" + e.getMessage());
  }
}","@BeforeClass public static void oneTimeSetUp(){
  TestConfig testConfig=new TestConfig();
  logger.info(""String_Node_Str"" + testConfig.getURI());
  mgr=IntegrationTestHelper.createRedmineManager();
  issueManager=mgr.getIssueManager();
  projectManager=mgr.getProjectManager();
  Project junitTestProject=ProjectFactory.create(""String_Node_Str"",""String_Node_Str"" + Calendar.getInstance().getTimeInMillis());
  try {
    Project createdProject=projectManager.createProject(junitTestProject);
    projectKey=createdProject.getIdentifier();
    projectId=createdProject.getId();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    Assert.fail(""String_Node_Str"" + e.getMessage());
  }
}",0.9894291754756872
99514,"public static void writeIssue(Issue issue,final JSONWriter writer) throws JSONException {
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getId());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getSubject());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getParentId());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getEstimatedHours());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getSpentHours());
  if (issue.getAssignee() != null)   JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getAssignee().getId());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getPriorityId());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getDoneRatio());
  if (issue.getProject() != null)   JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getProject().getIdentifier());
  if (issue.getAuthor() != null)   JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getAuthor().getId());
  addShort2(writer,""String_Node_Str"",issue.getStartDate());
  addIfNotNullShort2(writer,""String_Node_Str"",issue.getDueDate());
  if (issue.getTracker() != null)   JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getTracker().getId());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getDescription());
  addIfNotNullFull(writer,""String_Node_Str"",issue.getCreatedOn());
  addIfNotNullFull(writer,""String_Node_Str"",issue.getUpdatedOn());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getStatusId());
  if (issue.getTargetVersion() != null)   JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getTargetVersion().getId());
  if (issue.getCategory() != null)   JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getCategory().getId());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getNotes());
  writeCustomFields(writer,issue.getCustomFields());
  Collection<Watcher> issueWatchers=issue.getWatchers();
  if (issueWatchers != null && !issueWatchers.isEmpty()) {
    writeWatchers(writer,issueWatchers);
  }
  final List<Attachment> uploads=new ArrayList<Attachment>();
  for (  Attachment attachment : issue.getAttachments()) {
    if (attachment.getToken() != null) {
      uploads.add(attachment);
    }
  }
  JsonOutput.addArrayIfNotEmpty(writer,""String_Node_Str"",uploads,UPLOAD_WRITER);
}","public static void writeIssue(Issue issue,final JSONWriter writer) throws JSONException {
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getId());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getSubject());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getParentId());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getEstimatedHours());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getSpentHours());
  if (issue.getAssignee() != null)   JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getAssignee().getId());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getPriorityId());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getDoneRatio());
  if (issue.getProject() != null) {
    if (issue.getProject().getId() != null) {
      JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getProject().getId());
    }
 else {
      JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getProject().getIdentifier());
    }
  }
  if (issue.getAuthor() != null)   JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getAuthor().getId());
  addShort2(writer,""String_Node_Str"",issue.getStartDate());
  addIfNotNullShort2(writer,""String_Node_Str"",issue.getDueDate());
  if (issue.getTracker() != null)   JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getTracker().getId());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getDescription());
  addIfNotNullFull(writer,""String_Node_Str"",issue.getCreatedOn());
  addIfNotNullFull(writer,""String_Node_Str"",issue.getUpdatedOn());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getStatusId());
  if (issue.getTargetVersion() != null)   JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getTargetVersion().getId());
  if (issue.getCategory() != null)   JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getCategory().getId());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",issue.getNotes());
  writeCustomFields(writer,issue.getCustomFields());
  Collection<Watcher> issueWatchers=issue.getWatchers();
  if (issueWatchers != null && !issueWatchers.isEmpty()) {
    writeWatchers(writer,issueWatchers);
  }
  final List<Attachment> uploads=new ArrayList<Attachment>();
  for (  Attachment attachment : issue.getAttachments()) {
    if (attachment.getToken() != null) {
      uploads.add(attachment);
    }
  }
  JsonOutput.addArrayIfNotEmpty(writer,""String_Node_Str"",uploads,UPLOAD_WRITER);
}",0.9611814345991562
99515,"@AfterClass public static void oneTimeTearDown(){
  IntegrationTestHelper.deleteProject(mgr,projectKey);
}","@AfterClass public static void oneTimeTearDown(){
  IntegrationTestHelper.deleteProject(mgr,projectKey);
  IntegrationTestHelper.deleteProject(mgr,projectKey2);
}",0.7910447761194029
99516,"@BeforeClass public static void oneTimeSetup(){
  mgr=IntegrationTestHelper.createRedmineManager();
  userManager=mgr.getUserManager();
  issueManager=mgr.getIssueManager();
  projectManager=mgr.getProjectManager();
  projectKey=IntegrationTestHelper.createProject(mgr);
}","@BeforeClass public static void oneTimeSetup(){
  mgr=IntegrationTestHelper.createRedmineManager();
  userManager=mgr.getUserManager();
  issueManager=mgr.getIssueManager();
  projectManager=mgr.getProjectManager();
  projectKey=IntegrationTestHelper.createProject(mgr);
  projectKey2=IntegrationTestHelper.createProject(mgr);
}",0.9066666666666666
99517,"public static void writeUser(User user,final JSONWriter writer) throws JSONException {
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",user.getId());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",user.getLogin());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",user.getPassword());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",user.getFirstName());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",user.getLastName());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",user.getFullName());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",user.getMail());
  addIfNotNullFull(writer,""String_Node_Str"",user.getCreatedOn());
  addIfNotNullFull(writer,""String_Node_Str"",user.getLastLoginOn());
  writeCustomFields(writer,user.getCustomFields());
}","public static void writeUser(User user,final JSONWriter writer) throws JSONException {
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",user.getId());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",user.getLogin());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",user.getPassword());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",user.getFirstName());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",user.getLastName());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",user.getFullName());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",user.getMail());
  JsonOutput.addIfNotNull(writer,""String_Node_Str"",user.getAuthSourceId());
  addIfNotNullFull(writer,""String_Node_Str"",user.getCreatedOn());
  addIfNotNullFull(writer,""String_Node_Str"",user.getLastLoginOn());
  writeCustomFields(writer,user.getCustomFields());
}",0.9527363184079602
99518,"public static User parseUser(JSONObject content) throws JSONException {
  final User result=new User();
  result.setId(JsonInput.getIntOrNull(content,""String_Node_Str""));
  result.setLogin(JsonInput.getStringOrNull(content,""String_Node_Str""));
  result.setPassword(JsonInput.getStringOrNull(content,""String_Node_Str""));
  result.setFirstName(JsonInput.getStringOrNull(content,""String_Node_Str""));
  result.setLastName(JsonInput.getStringOrNull(content,""String_Node_Str""));
  result.setMail(JsonInput.getStringOrNull(content,""String_Node_Str""));
  result.setCreatedOn(getDateOrNull(content,""String_Node_Str""));
  result.setLastLoginOn(getDateOrNull(content,""String_Node_Str""));
  result.setApiKey(JsonInput.getStringOrNull(content,""String_Node_Str""));
  result.setCustomFields(JsonInput.getListOrEmpty(content,""String_Node_Str"",CUSTOM_FIELD_PARSER));
  final String name=JsonInput.getStringOrNull(content,""String_Node_Str"");
  if (name != null)   result.setFullName(name);
  result.setMemberships(JsonInput.getListOrEmpty(content,""String_Node_Str"",MEMBERSHIP_PARSER));
  result.setGroups(JsonInput.getListOrEmpty(content,""String_Node_Str"",GROUP_PARSER));
  for (  Membership m : result.getMemberships())   m.setUser(result);
  return result;
}","public static User parseUser(JSONObject content) throws JSONException {
  final User result=new User();
  result.setId(JsonInput.getIntOrNull(content,""String_Node_Str""));
  result.setLogin(JsonInput.getStringOrNull(content,""String_Node_Str""));
  result.setPassword(JsonInput.getStringOrNull(content,""String_Node_Str""));
  result.setFirstName(JsonInput.getStringOrNull(content,""String_Node_Str""));
  result.setLastName(JsonInput.getStringOrNull(content,""String_Node_Str""));
  result.setMail(JsonInput.getStringOrNull(content,""String_Node_Str""));
  result.setAuthSourceId(JsonInput.getIntOrNull(content,""String_Node_Str""));
  result.setCreatedOn(getDateOrNull(content,""String_Node_Str""));
  result.setLastLoginOn(getDateOrNull(content,""String_Node_Str""));
  result.setApiKey(JsonInput.getStringOrNull(content,""String_Node_Str""));
  result.setCustomFields(JsonInput.getListOrEmpty(content,""String_Node_Str"",CUSTOM_FIELD_PARSER));
  final String name=JsonInput.getStringOrNull(content,""String_Node_Str"");
  if (name != null)   result.setFullName(name);
  result.setMemberships(JsonInput.getListOrEmpty(content,""String_Node_Str"",MEMBERSHIP_PARSER));
  result.setGroups(JsonInput.getListOrEmpty(content,""String_Node_Str"",GROUP_PARSER));
  for (  Membership m : result.getMemberships())   m.setUser(result);
  return result;
}",0.9699336196798126
99519,"@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (o == null || getClass() != o.getClass())   return false;
  CustomField that=(CustomField)o;
  if (id != that.id)   return false;
  if (name != null ? !name.equals(that.name) : that.name != null)   return false;
  if (value != null ? !value.equals(that.value) : that.value != null)   return false;
  if (values != null ? !values.equals(that.value) : that.values != null)   return false;
  return true;
}","@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (o == null || getClass() != o.getClass())   return false;
  CustomField that=(CustomField)o;
  if (id != that.id)   return false;
  if (name != null ? !name.equals(that.name) : that.name != null)   return false;
  if (value != null ? !value.equals(that.value) : that.value != null)   return false;
  if (values != null ? !values.equals(that.values) : that.values != null)   return false;
  return true;
}",0.998965873836608
99520,"@Override public <R>R sendRequest(HttpRequest request,ContentHandler<HttpResponse,R> handler) throws RedmineException {
  logger.debug(request.getRequestLine().toString());
  request.addHeader(""String_Node_Str"",""String_Node_Str"");
  final HttpClient httpclient=client;
  try {
    final HttpResponse httpResponse=httpclient.execute((HttpUriRequest)request);
    try {
      return handler.processContent(httpResponse);
    }
  finally {
      EntityUtils.consume(httpResponse.getEntity());
    }
  }
 catch (  ClientProtocolException e1) {
    throw new RedmineFormatException(e1);
  }
catch (  IOException e1) {
    throw new RedmineTransportException(""String_Node_Str"" + request.getRequestLine().getUri() + ""String_Node_Str""+ e1.toString(),e1);
  }
}","@Override public <R>R sendRequest(HttpRequest request,ContentHandler<HttpResponse,R> handler) throws RedmineException {
  logger.debug(request.getRequestLine().toString());
  request.addHeader(""String_Node_Str"",""String_Node_Str"");
  final HttpClient httpclient=client;
  try {
    final HttpResponse httpResponse=httpclient.execute((HttpUriRequest)request);
    try {
      return handler.processContent(httpResponse);
    }
  finally {
      EntityUtils.consume(httpResponse.getEntity());
    }
  }
 catch (  ClientProtocolException e1) {
    throw new RedmineFormatException(e1);
  }
catch (  IOException e1) {
    throw new RedmineTransportException(""String_Node_Str"" + getMessageURI(request) + ""String_Node_Str""+ e1.toString(),e1);
  }
}",0.9658405894172808
99521,"/** 
 * @param responseBody  sample parameter:<pre> &lt;?xml version=""1.0"" encoding=""UTF-8""?> &lt;errors> &lt;error>Name can't be blank&lt;/error> &lt;error>Identifier has already been taken&lt;/error> &lt;/errors> </pre>
 */
public static List<String> parseErrors(String responseBody){
  List<String> errors=new ArrayList<String>();
  String lines[]=responseBody.split(""String_Node_Str"");
  int lineToStartWith=2;
  int lastLine=lines.length - 1;
  String openTag=""String_Node_Str"";
  String closeTag=""String_Node_Str"";
  for (int i=lineToStartWith; i < lastLine; i++) {
    int begin=lines[i].indexOf(openTag) + openTag.length();
    int end=lines[i].indexOf(closeTag);
    if (begin >= 0 && end >= 0) {
      errors.add(lines[i].substring(begin,end));
    }
  }
  return errors;
}","/** 
 * @param responseBody  sample parameter:<pre> &lt;?xml version=""1.0"" encoding=""UTF-8""?> &lt;errors> &lt;error>Name can't be blank&lt;/error> &lt;error>Identifier has already been taken&lt;/error> &lt;/errors> </pre>
 */
public static List<String> parseErrors(String responseBody){
  List<String> errors=new ArrayList<String>();
  String lines[]=responseBody.split(""String_Node_Str"");
  int lineToStartWith=0;
  int lastLine=lines.length - 1;
  if (lines.length > 1) {
    lineToStartWith=2;
    lastLine=lines.length - 1;
  }
  String openTag=""String_Node_Str"";
  String closeTag=""String_Node_Str"";
  for (int i=lineToStartWith; i <= lastLine; i++) {
    int begin=lines[i].indexOf(openTag) + openTag.length();
    int end=lines[i].indexOf(closeTag);
    if (begin >= 0 && end >= 0) {
      errors.add(lines[i].substring(begin,end));
    }
  }
  return errors;
}",0.9448818897637796
99522,"public URI getUpdateURI(Class zz,String id,NameValuePair... param){
  String query=urls.get(zz) + ""String_Node_Str"" + id+ XML_URL_POSTFIX;
  return createURI(query,param);
}","public URI getUpdateURI(Class<?> zz,String id,NameValuePair... param){
  String query=getClassUrl(zz) + ""String_Node_Str"" + id+ XML_URL_POSTFIX;
  return createURI(query,param);
}",0.9545454545454546
99523,"public URIConfigurator(String host){
  this.host=host;
}","public URIConfigurator(String host){
  if (host == null || host.isEmpty()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    this.baseURL=new URL(host);
  }
 catch (  MalformedURLException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + host,e);
  }
}",0.2457142857142857
99524,"public URI getRetrieveObjectsListURI(Class className,List<NameValuePair> param){
  String query=urls.get(className) + XML_URL_POSTFIX;
  return createURI(query,param);
}","public URI getRetrieveObjectsListURI(Class<?> className,List<NameValuePair> param){
  String query=getClassUrl(className) + XML_URL_POSTFIX;
  return createURI(query,param);
}",0.9534883720930232
99525,"/** 
 * @param query e.g. ""/issues.xml""
 * @return URI with auth parameter ""key"" if not in ""basic auth mode.
 */
public URI createURI(String query,List<NameValuePair> params){
  if (apiAccessKey != null) {
    params.add(new BasicNameValuePair(""String_Node_Str"",apiAccessKey));
  }
  URI uri;
  try {
    URL url=new URL(host);
    String path=url.getPath();
    if (!query.isEmpty()) {
      path+=""String_Node_Str"" + query;
    }
    uri=URIUtils.createURI(url.getProtocol(),url.getHost(),url.getPort(),path,URLEncodedUtils.format(params,""String_Node_Str""),null);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return uri;
}","/** 
 * @param query e.g. ""/issues.xml""
 * @return URI with auth parameter ""key"" if not in ""basic auth mode.
 */
public URI createURI(String query,List<NameValuePair> params){
  if (apiAccessKey != null) {
    params=new ArrayList<NameValuePair>(params);
    params.add(new BasicNameValuePair(""String_Node_Str"",apiAccessKey));
  }
  URI uri;
  try {
    URL url=baseURL;
    String path=url.getPath();
    if (!query.isEmpty()) {
      path+=""String_Node_Str"" + query;
    }
    uri=URIUtils.createURI(url.getProtocol(),url.getHost(),url.getPort(),path,URLEncodedUtils.format(params,""String_Node_Str""),null);
  }
 catch (  URISyntaxException e) {
    throw new RuntimeException(e);
  }
  return uri;
}",0.9466666666666668
99526,"public URI getCreateURI(Class zz){
  String query=urls.get(zz) + XML_URL_POSTFIX;
  return createURI(query);
}","public URI getCreateURI(Class<?> zz){
  String query=getClassUrl(zz) + XML_URL_POSTFIX;
  return createURI(query);
}",0.9292035398230089
99527,"public URI getRetrieveObjectURI(Class className,Integer id,List<NameValuePair> param){
  String query=urls.get(className) + ""String_Node_Str"" + id+ XML_URL_POSTFIX;
  return createURI(query,param);
}","public URI getRetrieveObjectURI(Class<?> className,Integer id,List<NameValuePair> param){
  String query=getClassUrl(className) + ""String_Node_Str"" + id+ XML_URL_POSTFIX;
  return createURI(query,param);
}",0.9455445544554456
99528,"/** 
 * Downloads the content of an   {@link org.redmine.ta.beans.Attachment} from the Redmine server.
 * @param issueAttachment the {@link org.redmine.ta.beans.Attachment}
 * @return the content of the attachment as a byte[] array
 * @throws IOException thrown in case the download fails
 */
public byte[] downloadAttachmentContent(Attachment issueAttachment) throws IOException {
  byte[] result=null;
  URL url=new URL(issueAttachment.getContentURL());
  BufferedReader inputReader=null;
  try {
    inputReader=new BufferedReader(new InputStreamReader(url.openStream()));
    StringBuilder contentBuilder=new StringBuilder();
    String line;
    while ((line=inputReader.readLine()) != null) {
      contentBuilder.append(line);
    }
    result=contentBuilder.toString().getBytes();
  }
  finally {
    if (inputReader != null) {
      inputReader.close();
    }
  }
  return result;
}","/** 
 * Downloads the content of an   {@link org.redmine.ta.beans.Attachment} from the Redmine server.
 * @param issueAttachment the {@link org.redmine.ta.beans.Attachment}
 * @return the content of the attachment as a byte[] array
 * @throws RedmineCommunicationException thrown in case the download fails
 */
public byte[] downloadAttachmentContent(Attachment issueAttachment) throws RedmineCommunicationException {
  try {
    final URL url=new URL(issueAttachment.getContentURL());
    final InputStream is=url.openStream();
    try {
      final ByteArrayOutputStream baos=new ByteArrayOutputStream();
      final byte[] buffer=new byte[65536];
      int read;
      while ((read=is.read(buffer)) != -1)       baos.write(buffer,0,read);
      return baos.toByteArray();
    }
  finally {
      is.close();
    }
  }
 catch (  IOException e) {
    throw new RedmineTransportException(e);
  }
}",0.3031319910514541
99529,"/** 
 * append, if the value is not NULL
 */
private static void appendIfNotNull(StringBuilder b,String tag,Object value){
  if (value != null) {
    b.append(""String_Node_Str"" + tag + ""String_Node_Str"");
    if (value instanceof Date) {
      b.append(sdf.format(value));
    }
 else     if (value instanceof String) {
      b.append(encodeXML((String)value));
    }
 else {
      b.append(value);
    }
    b.append(""String_Node_Str"" + tag + ""String_Node_Str"");
  }
}","/** 
 * append, if the value is not NULL
 */
private static void appendIfNotNull(StringBuilder b,String tag,Object value){
  if (value != null) {
    b.append(""String_Node_Str"" + tag + ""String_Node_Str"");
    if (value instanceof Date) {
      b.append(RedmineDateUtils.formatShortDate((Date)value));
    }
 else     if (value instanceof String) {
      b.append(encodeXML((String)value));
    }
 else {
      b.append(encodeXML(value.toString()));
    }
    b.append(""String_Node_Str"" + tag + ""String_Node_Str"");
  }
}",0.9190283400809716
99530,"public User getCurrentUser() throws IOException, AuthenticationException, RedmineException {
  URI uri=createURI(""String_Node_Str"");
  HttpGet http=new HttpGet(uri);
  Response response=sendRequest(http);
  return RedmineXMLParser.parseUserFromXML(response.getBody());
}","/** 
 * @return the current user logged into Redmine
 * @throws IOException
 * @throws AuthenticationException
 * @throws RedmineException
 * @throws NotFoundException
 */
public User getCurrentUser() throws IOException, AuthenticationException, RedmineException, NotFoundException {
  URI uri=createURI(""String_Node_Str"");
  HttpGet http=new HttpGet(uri);
  Response response=sendRequest(http);
  if (response.getCode() == HttpStatus.SC_NOT_FOUND) {
    throw new NotFoundException(""String_Node_Str"");
  }
  return RedmineXMLParser.parseUserFromXML(response.getBody());
}",0.6413301662707839
99531,"@Test public void testGetCurrentUser() throws IOException, AuthenticationException, RedmineException {
  User currentUser=mgr.getCurrentUser();
  Assert.assertEquals(getOurUser().getId(),currentUser.getId());
  Assert.assertEquals(getOurUser().getLogin(),currentUser.getLogin());
}","@Test public void testGetCurrentUser() throws IOException, AuthenticationException, RedmineException, NotFoundException {
  User currentUser=mgr.getCurrentUser();
  Assert.assertEquals(getOurUser().getId(),currentUser.getId());
  Assert.assertEquals(getOurUser().getLogin(),currentUser.getLogin());
}",0.9672977624784854
99532,"@SuppressWarnings(""String_Node_Str"") public static <T>List<T> parseObjectsFromXML(Class<T> classs,String body){
  verifyStartsAsXML(body);
  String configFile=fromRedmineMap.get(classs);
  Unmarshaller unmarshaller=getUnmarshaller(configFile,ArrayList.class);
  List<T> list=null;
  StringReader reader=null;
  try {
    reader=new StringReader(body);
    list=(ArrayList<T>)unmarshaller.unmarshal(reader);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    if (reader != null) {
      reader.close();
    }
  }
  return list;
}","@SuppressWarnings(""String_Node_Str"") public static <T>List<T> parseObjectsFromXML(Class<T> classs,String body){
  verifyStartsAsXML(body);
  StringBuilder builder=new StringBuilder(body);
  removeBadTags(builder);
  String configFile=fromRedmineMap.get(classs);
  Unmarshaller unmarshaller=getUnmarshaller(configFile,ArrayList.class);
  List<T> list=null;
  StringReader reader=null;
  try {
    reader=new StringReader(builder.toString());
    list=(ArrayList<T>)unmarshaller.unmarshal(reader);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    if (reader != null) {
      reader.close();
    }
  }
  return list;
}",0.9201009251471826
99533,"public static <T>T parseObjectFromXML(Class<T> classs,String xml){
  verifyStartsAsXML(xml);
  StringBuilder b=new StringBuilder(xml);
  removeBadTags(b);
  String configFile=fromRedmineMap.get(classs);
  Unmarshaller unmarshaller=getUnmarshaller(configFile,classs);
  T obj=null;
  StringReader reader=null;
  try {
    reader=new StringReader(b.toString());
    obj=(T)unmarshaller.unmarshal(reader);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    if (reader != null) {
      reader.close();
    }
  }
  return obj;
}","public static <T>T parseObjectFromXML(Class<T> classs,String xml){
  verifyStartsAsXML(xml);
  StringBuilder builder=new StringBuilder(xml);
  removeBadTags(builder);
  String configFile=fromRedmineMap.get(classs);
  Unmarshaller unmarshaller=getUnmarshaller(configFile,classs);
  T obj=null;
  StringReader reader=null;
  try {
    reader=new StringReader(builder.toString());
    obj=(T)unmarshaller.unmarshal(reader);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    if (reader != null) {
      reader.close();
    }
  }
  return obj;
}",0.983754512635379
99534,"@Before public void setup() throws Exception {
  String str=MyIOUtils.getResourceAsString(REDMINE_1_1_FILE_1_ISSUES_XML_FILE_NAME);
  this.issuesList=RedmineXMLParser.parseIssuesFromXML(str);
  RedmineIssuesMap loader=new RedmineIssuesMap(issuesList);
  issuesMap=loader.getIssuesMap();
}","@Before public void setup() throws Exception {
  String str=MyIOUtils.getResourceAsString(REDMINE_1_1_FILE_1_ISSUES_XML_FILE_NAME);
  this.issuesList=RedmineXMLParser.parseObjectsFromXML(Issue.class,str);
  RedmineIssuesMap loader=new RedmineIssuesMap(issuesList);
  issuesMap=loader.getIssuesMap();
}",0.9609507640067912
99535,"private List<Issue> loadRedmine11IssuesXml() throws IOException {
  String xml=MyIOUtils.getResourceAsString(REDMINE_1_1_ISSUES_XML);
  return RedmineXMLParser.parseIssuesFromXML(xml);
}","private List<Issue> loadRedmine11IssuesXml() throws IOException {
  String xml=MyIOUtils.getResourceAsString(REDMINE_1_1_ISSUES_XML);
  return RedmineXMLParser.parseObjectsFromXML(Issue.class,xml);
}",0.9454545454545454
99536,"@Test public void testParseIssuesFromEmptyXML(){
  try {
    String str=MyIOUtils.getResourceAsString(FILE_EMPTY_ISSUES_XML);
    List<Issue> issues=RedmineXMLParser.parseIssuesFromXML(str);
    Assert.assertTrue(issues.isEmpty());
  }
 catch (  Exception e) {
    e.printStackTrace();
    Assert.fail(""String_Node_Str"" + e);
  }
}","@Test public void testParseIssuesFromEmptyXML(){
  try {
    String str=MyIOUtils.getResourceAsString(FILE_EMPTY_ISSUES_XML);
    List<Issue> issues=RedmineXMLParser.parseObjectsFromXML(Issue.class,str);
    Assert.assertTrue(issues.isEmpty());
  }
 catch (  Exception e) {
    e.printStackTrace();
    Assert.fail(""String_Node_Str"" + e);
  }
}",0.965925925925926
99537,"@Test public void testParseInvalidPage(){
  try {
    String text=MyIOUtils.getResourceAsString(""String_Node_Str"");
    RedmineXMLParser.parseIssuesFromXML(text);
    Assert.fail(""String_Node_Str"");
  }
 catch (  IOException e) {
    Assert.fail(e.getMessage());
  }
catch (  RuntimeException e) {
    System.out.println(""String_Node_Str"");
  }
}","@Test public void testParseInvalidPage(){
  try {
    String text=MyIOUtils.getResourceAsString(""String_Node_Str"");
    RedmineXMLParser.parseObjectsFromXML(Issue.class,text);
    Assert.fail(""String_Node_Str"");
  }
 catch (  IOException e) {
    Assert.fail(e.getMessage());
  }
catch (  RuntimeException e) {
    System.out.println(""String_Node_Str"");
  }
}",0.9673758865248226
99538,"@Test @Ignore public void testParseIssueNonUnicodeSymbols(){
  try {
    String xml=MyIOUtils.getResourceAsString(""String_Node_Str"");
    String nonLatinSymbols=""String_Node_Str"";
    List<Issue> issues=RedmineXMLParser.parseIssuesFromXML(xml);
    Assert.assertTrue(issues.size() == 1);
    Issue issue=issues.get(0);
    Assert.assertEquals(nonLatinSymbols,issue.getSubject());
  }
 catch (  Exception e) {
    Assert.fail(e.getMessage());
  }
}","@Test @Ignore public void testParseIssueNonUnicodeSymbols(){
  try {
    String xml=MyIOUtils.getResourceAsString(""String_Node_Str"");
    String nonLatinSymbols=""String_Node_Str"";
    List<Issue> issues=RedmineXMLParser.parseObjectsFromXML(Issue.class,xml);
    Assert.assertTrue(issues.size() == 1);
    Issue issue=issues.get(0);
    Assert.assertEquals(nonLatinSymbols,issue.getSubject());
  }
 catch (  Exception e) {
    Assert.fail(e.getMessage());
  }
}",0.9746416758544652
99539,"@Test public void testLoadRelation(){
  try {
    IssueRelation relation=createTwoRelatedIssues();
    Issue issue=mgr.getIssueById(relation.getIssueId(),INCLUDE.relations);
    Issue issueTarget=mgr.getIssueById(relation.getIssueToId(),INCLUDE.relations);
    assertEquals(1,issue.getRelations().size());
    assertEquals(1,issueTarget.getRelations().size());
    IssueRelation relation1=issue.getRelations().get(0);
    assertEquals(issue.getId(),relation1.getIssueId());
    assertEquals(issueTarget.getId(),relation1.getIssueToId());
    assertEquals((Integer)0,relation1.getDelay());
    IssueRelation reverseRelation=issueTarget.getRelations().get(0);
    assertEquals(relation1,reverseRelation);
  }
 catch (  Exception e) {
    fail(e.toString());
  }
}","@Test public void testLoadRelation(){
  try {
    IssueRelation relation=createTwoRelatedIssues();
    Issue issue=mgr.getIssueById(relation.getIssueId(),INCLUDE.relations);
    Issue issueTarget=mgr.getIssueById(relation.getIssueToId(),INCLUDE.relations);
    assertEquals(1,issue.getRelations().size());
    assertEquals(1,issueTarget.getRelations().size());
    IssueRelation relation1=issue.getRelations().get(0);
    assertEquals(issue.getId(),relation1.getIssueToId());
    assertEquals(""String_Node_Str"",relation1.getType());
    assertEquals((Integer)0,relation1.getDelay());
    IssueRelation reverseRelation=issueTarget.getRelations().get(0);
    assertEquals(relation1,reverseRelation);
  }
 catch (  Exception e) {
    fail(e.toString());
  }
}",0.9492419248516808
99540,"public IssueRelation createRelation(String projectKey,Integer issueId,Integer issueToId,String type) throws IOException, AuthenticationException, NotFoundException, RedmineException {
  URI uri=createURI(""String_Node_Str"" + issueId + ""String_Node_Str"");
  HttpPost http=new HttpPost(uri);
  http.getParams().setParameter(""String_Node_Str"",issueToId.toString());
  http.getParams().setParameter(""String_Node_Str"",type);
  Response response=sendRequest(http);
  IssueRelation relation=RedmineXMLParser.parseRelationFromXML(response.getBody());
  return relation;
}","public IssueRelation createRelation(String projectKey,Integer issueId,Integer issueToId,String type) throws IOException, AuthenticationException, NotFoundException, RedmineException {
  URI uri=createURI(""String_Node_Str"" + issueId + ""String_Node_Str"");
  HttpPost http=new HttpPost(uri);
  IssueRelation toCreate=new IssueRelation();
  toCreate.setIssueId(issueId);
  toCreate.setIssueToId(issueToId);
  toCreate.setType(type);
  String xml=RedmineXMLGenerator.toXML(toCreate);
  setEntity((HttpEntityEnclosingRequest)http,xml);
  Response response=sendRequest(http);
  IssueRelation relation=RedmineXMLParser.parseRelationFromXML(response.getBody());
  return relation;
}",0.7157894736842105
99541,"public static String toXML(User o){
  StringBuilder b=new StringBuilder(XML_PREFIX + ""String_Node_Str"");
  appendIfNotNull(b,""String_Node_Str"",o.getId());
  appendIfNotNull(b,""String_Node_Str"",o.getLogin());
  appendIfNotNull(b,""String_Node_Str"",o.getPassword());
  appendIfNotNull(b,""String_Node_Str"",o.getFirstName());
  appendIfNotNull(b,""String_Node_Str"",o.getLastName());
  appendIfNotNull(b,""String_Node_Str"",o.getMail());
  b.append(""String_Node_Str"");
  return b.toString();
}","public static String toXML(IssueRelation o){
  StringBuilder b=new StringBuilder(XML_PREFIX + ""String_Node_Str"");
  appendIfNotNull(b,""String_Node_Str"",o.getIssueToId());
  appendIfNotNull(b,""String_Node_Str"",o.getType());
  b.append(""String_Node_Str"");
  return b.toString();
}",0.6666666666666666
99542,"/** 
 * Redmine 1.1 / Chiliproject 1.2 - specific version
 */
private <T>List<T> getObjectsListV11(Class<T> objectClass,Map<String,NameValuePair> params) throws IOException, AuthenticationException, NotFoundException, RedmineException {
  List<T> objects=new ArrayList<T>();
  int limit=25;
  params.put(""String_Node_Str"",new BasicNameValuePair(""String_Node_Str"",String.valueOf(limit)));
  int offset=0;
  int totalObjectsFoundOnServer;
  do {
    params.put(""String_Node_Str"",new BasicNameValuePair(""String_Node_Str"",String.valueOf(offset)));
    List<NameValuePair> paramsList=new ArrayList<NameValuePair>(params.values());
    String query=urls.get(objectClass) + URL_POSTFIX;
    URI uri=createURI(query,paramsList);
    HttpGet http=new HttpGet(uri);
    Response response=sendRequest(http);
    if (response.getCode() == HttpStatus.SC_NOT_FOUND) {
      throw new NotFoundException(""String_Node_Str"" + response.getBody());
    }
    String body=response.getBody();
    totalObjectsFoundOnServer=RedmineXMLParser.parseObjectsTotalCount(body);
    List<T> foundItems=RedmineXMLParser.parseObjectsFromXML(objectClass,body);
    if (foundItems.size() == 0) {
      break;
    }
    objects.addAll(foundItems);
    offset+=foundItems.size();
  }
 while (offset < totalObjectsFoundOnServer);
  return objects;
}","/** 
 * Redmine 1.1 / Chiliproject 1.2 - specific version
 */
private <T>List<T> getObjectsListV11(Class<T> objectClass,Map<String,NameValuePair> params) throws IOException, AuthenticationException, NotFoundException, RedmineException {
  List<T> objects=new ArrayList<T>();
  int limit=25;
  params.put(""String_Node_Str"",new BasicNameValuePair(""String_Node_Str"",String.valueOf(limit)));
  int offset=0;
  int totalObjectsFoundOnServer;
  do {
    params.put(""String_Node_Str"",new BasicNameValuePair(""String_Node_Str"",String.valueOf(offset)));
    List<NameValuePair> paramsList=new ArrayList<NameValuePair>(params.values());
    String query=urls.get(objectClass) + URL_POSTFIX;
    URI uri=createURI(query,paramsList);
    debug(""String_Node_Str"" + uri);
    HttpGet http=new HttpGet(uri);
    Response response=sendRequest(http);
    if (response.getCode() == HttpStatus.SC_NOT_FOUND) {
      throw new NotFoundException(""String_Node_Str"" + response.getBody());
    }
    String body=response.getBody();
    totalObjectsFoundOnServer=RedmineXMLParser.parseObjectsTotalCount(body);
    List<T> foundItems=RedmineXMLParser.parseObjectsFromXML(objectClass,body);
    if (foundItems.size() == 0) {
      break;
    }
    objects.addAll(foundItems);
    offset+=foundItems.size();
  }
 while (offset < totalObjectsFoundOnServer);
  return objects;
}",0.9864559819413092
99543,"/** 
 * @param query e.g. ""/issues.xml""
 * @return URI with auth parameter ""key"" if not in ""basic auth mode.
 */
private URI createURI(String query,List<NameValuePair> params){
  if (!useBasicAuth) {
    params.add(new BasicNameValuePair(""String_Node_Str"",apiAccessKey));
  }
  URI uri;
  try {
    URL url=new URL(host);
    uri=URIUtils.createURI(url.getProtocol(),url.getHost(),url.getPort(),query,URLEncodedUtils.format(params,""String_Node_Str""),null);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return uri;
}","/** 
 * @param query e.g. ""/issues.xml""
 * @return URI with auth parameter ""key"" if not in ""basic auth mode.
 */
private URI createURI(String query,List<NameValuePair> params){
  if (!useBasicAuth) {
    params.add(new BasicNameValuePair(""String_Node_Str"",apiAccessKey));
  }
  URI uri;
  try {
    URL url=new URL(host);
    String path=url.getPath();
    if (!query.isEmpty()) {
      path+=""String_Node_Str"" + query;
    }
    uri=URIUtils.createURI(url.getProtocol(),url.getHost(),url.getPort(),path,URLEncodedUtils.format(params,""String_Node_Str""),null);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return uri;
}",0.8994082840236687
99544,"public static void testShortDate(Date expectedDate,int year,int month,int day){
  testLongDate(expectedDate,year,month,day,0,0,0,""String_Node_Str"");
}","public static void testShortDate(int year,int month,int day,Date expectedDate){
  testLongDate(year,month,day,0,0,0,""String_Node_Str"",expectedDate);
}",0.7933333333333333
99545,"public static void testLongDate(Date expectedDate,int year,int month,int day,int hour,int min,int sec,String timeZone){
  Calendar c=Calendar.getInstance();
  c.set(Calendar.YEAR,year);
  c.set(Calendar.MONTH,month);
  c.set(Calendar.DAY_OF_MONTH,day);
  c.set(Calendar.HOUR_OF_DAY,hour);
  c.set(Calendar.MINUTE,min);
  c.set(Calendar.SECOND,sec);
  c.set(Calendar.MILLISECOND,0);
  if (timeZone.length() > 0) {
    c.setTimeZone(TimeZone.getTimeZone(timeZone));
  }
  Date expectedTime=c.getTime();
  assertEquals(""String_Node_Str"",expectedTime,expectedDate);
}","public static void testLongDate(int year,int month,int day,int hour,int min,int sec,String timeZone,Date expectedDate){
  Calendar c=Calendar.getInstance();
  c.set(Calendar.YEAR,year);
  c.set(Calendar.MONTH,month);
  c.set(Calendar.DAY_OF_MONTH,day);
  c.set(Calendar.HOUR_OF_DAY,hour);
  c.set(Calendar.MINUTE,min);
  c.set(Calendar.SECOND,sec);
  c.set(Calendar.MILLISECOND,0);
  if (timeZone.length() > 0) {
    c.setTimeZone(TimeZone.getTimeZone(timeZone));
  }
  Date actualDate=c.getTime();
  assertEquals(""String_Node_Str"",actualDate,expectedDate);
}",0.839572192513369
99546,"@Test public void testCountIssues(){
  try {
    String xml=MyIOUtils.getResourceAsString(REDMINE_1_1_ISSUES_XML);
    List<Issue> issues=RedmineXMLParser.parseIssuesFromXML(xml);
    assertEquals(26,issues.size());
  }
 catch (  Exception e) {
    fail(e.getMessage());
  }
}","@Test public void testCountIssues(){
  try {
    List<Issue> issues=loadRedmine11IssuesXml();
    assertEquals(26,issues.size());
  }
 catch (  Exception e) {
    fail(e.getMessage());
  }
}",0.7854077253218884
99547,"@Test public void testParseDescription(){
  try {
    String xml=MyIOUtils.getResourceAsString(REDMINE_1_1_ISSUES_XML);
    List<Issue> issues=RedmineXMLParser.parseIssuesFromXML(xml);
    Issue issue65=RedmineTestUtils.findIssueInList(issues,65);
    assertTrue(issue65.getDescription().startsWith(""String_Node_Str""));
    assertTrue(issue65.getDescription().endsWith(""String_Node_Str""));
  }
 catch (  Exception e) {
    fail(e.getMessage());
  }
}","@Test public void testParseDescription(){
  try {
    List<Issue> issues=loadRedmine11IssuesXml();
    Issue issue65=RedmineTestUtils.findIssueInList(issues,65);
    assertTrue(issue65.getDescription().startsWith(""String_Node_Str""));
    assertTrue(issue65.getDescription().endsWith(""String_Node_Str""));
  }
 catch (  Exception e) {
    fail(e.getMessage());
  }
}",0.8034398034398035
99548,"@Test public void testNullEstimatedTime(){
  String str;
  try {
    str=MyIOUtils.getResourceAsString(REDMINE_1_1_ISSUES_XML);
    List<Issue> issues=RedmineXMLParser.parseIssuesFromXML(str);
    Integer issueID=52;
    Issue issue52=RedmineTestUtils.findIssueInList(issues,issueID);
    assertNotNull(issue52);
    assertNull(""String_Node_Str"",issue52.getEstimatedHours());
  }
 catch (  IOException e) {
    fail(e.getMessage());
  }
}","@Test public void testNullEstimatedTime(){
  try {
    List<Issue> issues=loadRedmine11IssuesXml();
    Integer issueID=52;
    Issue issue52=RedmineTestUtils.findIssueInList(issues,issueID);
    assertNotNull(issue52);
    assertNull(""String_Node_Str"",issue52.getEstimatedHours());
  }
 catch (  IOException e) {
    fail(e.getMessage());
  }
}",0.789272030651341
99549,"@Test public void testParseIssues() throws IOException {
  String xml=MyIOUtils.getResourceAsString(""String_Node_Str"");
  List<Issue> objects=RedmineXMLParser.parseIssuesFromXML(xml);
  Integer issueId=68;
  Issue issue68=RedmineTestUtils.findIssueInList(objects,issueId);
  assertNotNull(issue68);
  assertEquals(issueId,issue68.getId());
  Integer statusId=1;
  assertEquals(statusId,issue68.getStatusId());
  assertEquals(""String_Node_Str"",issue68.getStatusName());
  User author=issue68.getAuthor();
  assertNotNull(author);
  Integer userId=1;
  assertEquals(userId,author.getId());
}","@Test public void testParseIssues() throws IOException {
  List<Issue> objects=loadRedmine11IssuesXml();
  Integer issueId=68;
  Issue issue68=RedmineTestUtils.findIssueInList(objects,issueId);
  assertNotNull(issue68);
  assertEquals(issueId,issue68.getId());
  Integer statusId=1;
  assertEquals(statusId,issue68.getStatusId());
  assertEquals(""String_Node_Str"",issue68.getStatusName());
  User author=issue68.getAuthor();
  assertNotNull(author);
  Integer userId=1;
  assertEquals(userId,author.getId());
}",0.2111010009099181
99550,"@Test public void testParseTimeEntries() throws IOException {
  String xml=MyIOUtils.getResourceAsString(""String_Node_Str"");
  List<TimeEntry> objects=RedmineXMLParser.parseTimeEntries(xml);
  for (  TimeEntry timeEntry : objects) {
    System.out.println(timeEntry);
  }
  Integer objId=2;
  TimeEntry obj2=RedmineTestUtils.findTimeEntry(objects,objId);
  assertNotNull(obj2);
  Integer expectedIssueId=44;
  String expectedProjectName=""String_Node_Str"";
  Integer expectedProjectId=1;
  String expectedUserName=""String_Node_Str"";
  Integer expectedUserId=1;
  String expectedActivityName=""String_Node_Str"";
  Integer expectedActivityId=8;
  Float expectedHours=2f;
  assertEquals(objId,obj2.getId());
  assertEquals(expectedIssueId,obj2.getIssueId());
  assertEquals(expectedProjectName,obj2.getProjectName());
  assertEquals(expectedProjectId,obj2.getProjectId());
  assertEquals(expectedUserName,obj2.getUserName());
  assertEquals(expectedUserId,obj2.getUserId());
  assertEquals(expectedActivityName,obj2.getActivityName());
  assertEquals(expectedActivityId,obj2.getActivityId());
  assertEquals(expectedHours,obj2.getHours());
  assertEquals(""String_Node_Str"",obj2.getComment());
  MyIOUtils.testLongDate(obj2.getCreatedOn(),2011,Calendar.JANUARY,31,11,10,40,""String_Node_Str"");
  MyIOUtils.testLongDate(obj2.getUpdatedOn(),2011,Calendar.JANUARY,31,11,12,32,""String_Node_Str"");
  MyIOUtils.testShortDate(obj2.getSpentOn(),2011,Calendar.JANUARY,30);
}","@Test public void testParseTimeEntries() throws IOException {
  String xml=MyIOUtils.getResourceAsString(""String_Node_Str"");
  List<TimeEntry> objects=RedmineXMLParser.parseTimeEntries(xml);
  for (  TimeEntry timeEntry : objects) {
    System.out.println(timeEntry);
  }
  Integer objId=2;
  TimeEntry obj2=RedmineTestUtils.findTimeEntry(objects,objId);
  assertNotNull(obj2);
  Integer expectedIssueId=44;
  String expectedProjectName=""String_Node_Str"";
  Integer expectedProjectId=1;
  String expectedUserName=""String_Node_Str"";
  Integer expectedUserId=1;
  String expectedActivityName=""String_Node_Str"";
  Integer expectedActivityId=8;
  Float expectedHours=2f;
  assertEquals(objId,obj2.getId());
  assertEquals(expectedIssueId,obj2.getIssueId());
  assertEquals(expectedProjectName,obj2.getProjectName());
  assertEquals(expectedProjectId,obj2.getProjectId());
  assertEquals(expectedUserName,obj2.getUserName());
  assertEquals(expectedUserId,obj2.getUserId());
  assertEquals(expectedActivityName,obj2.getActivityName());
  assertEquals(expectedActivityId,obj2.getActivityId());
  assertEquals(expectedHours,obj2.getHours());
  assertEquals(""String_Node_Str"",obj2.getComment());
  MyIOUtils.testLongDate(2011,Calendar.JANUARY,31,11,10,40,""String_Node_Str"",obj2.getCreatedOn());
  MyIOUtils.testLongDate(2011,Calendar.JANUARY,31,11,12,32,""String_Node_Str"",obj2.getUpdatedOn());
  MyIOUtils.testShortDate(2011,Calendar.JANUARY,30,obj2.getSpentOn());
}",0.9602194787379972
99551,"public static void main(String[] args){
  RedmineManager mgr=new RedmineManager(redmineHost,login,password);
  try {
    tryCreateRelation(mgr);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public static void main(String[] args){
  RedmineManager mgr=new RedmineManager(redmineHost,login,password);
  try {
    tryGetAllIssues(mgr);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9359605911330048
99552,"@Test public void testCreateIssue(){
  try {
    Issue issueToCreate=new Issue();
    issueToCreate.setSubject(""String_Node_Str"");
    Calendar startCal=Calendar.getInstance();
    startCal.clear(Calendar.HOUR_OF_DAY);
    startCal.clear(Calendar.MINUTE);
    startCal.clear(Calendar.SECOND);
    startCal.clear(Calendar.MILLISECOND);
    startCal.add(Calendar.DATE,5);
    issueToCreate.setStartDate(startCal.getTime());
    Calendar due=Calendar.getInstance();
    due.add(Calendar.MONTH,1);
    issueToCreate.setDueDate(due.getTime());
    User assignee=getOurUser();
    issueToCreate.setAssignee(assignee);
    String description=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
    issueToCreate.setDescription(description);
    float estimatedHours=44;
    issueToCreate.setEstimatedHours(estimatedHours);
    float spentHours=12.5f;
    issueToCreate.setSpentHours(spentHours);
    Issue newIssue=mgr.createIssue(projectKey,issueToCreate);
    assertNotNull(""String_Node_Str"",newIssue);
    assertNotNull(""String_Node_Str"",newIssue.getId());
    Calendar returnedStartCal=Calendar.getInstance();
    returnedStartCal.setTime(newIssue.getStartDate());
    assertEquals(startCal.get(Calendar.YEAR),returnedStartCal.get(Calendar.YEAR));
    assertEquals(startCal.get(Calendar.MONTH),returnedStartCal.get(Calendar.MONTH));
    assertEquals(startCal.get(Calendar.DAY_OF_MONTH),returnedStartCal.get(Calendar.DAY_OF_MONTH));
    Calendar returnedDueCal=Calendar.getInstance();
    returnedDueCal.setTime(newIssue.getDueDate());
    assertEquals(due.get(Calendar.YEAR),returnedDueCal.get(Calendar.YEAR));
    assertEquals(due.get(Calendar.MONTH),returnedDueCal.get(Calendar.MONTH));
    assertEquals(due.get(Calendar.DAY_OF_MONTH),returnedDueCal.get(Calendar.DAY_OF_MONTH));
    User actualAssignee=newIssue.getAssignee();
    assertNotNull(""String_Node_Str"",actualAssignee);
    assertEquals(""String_Node_Str"",assignee.getId(),actualAssignee.getId());
    Integer EXPECTED_AUTHOR_ID=getOurUser().getId();
    assertEquals(EXPECTED_AUTHOR_ID,newIssue.getAuthor().getId());
    assertEquals((Float)estimatedHours,newIssue.getEstimatedHours());
    assertEquals((Float)spentHours,newIssue.getSpentHours());
    String regexpStripExtra=""String_Node_Str"";
    description=description.replaceAll(regexpStripExtra,""String_Node_Str"");
    String actualDescription=newIssue.getDescription();
    actualDescription=actualDescription.replaceAll(regexpStripExtra,""String_Node_Str"");
    assertEquals(description,actualDescription);
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail();
  }
}","@Test public void testCreateIssue(){
  try {
    Issue issueToCreate=new Issue();
    issueToCreate.setSubject(""String_Node_Str"");
    Calendar startCal=Calendar.getInstance();
    startCal.clear(Calendar.HOUR_OF_DAY);
    startCal.clear(Calendar.MINUTE);
    startCal.clear(Calendar.SECOND);
    startCal.clear(Calendar.MILLISECOND);
    startCal.add(Calendar.DATE,5);
    issueToCreate.setStartDate(startCal.getTime());
    Calendar due=Calendar.getInstance();
    due.add(Calendar.MONTH,1);
    issueToCreate.setDueDate(due.getTime());
    User assignee=getOurUser();
    issueToCreate.setAssignee(assignee);
    String description=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
    issueToCreate.setDescription(description);
    float estimatedHours=44;
    issueToCreate.setEstimatedHours(estimatedHours);
    Issue newIssue=mgr.createIssue(projectKey,issueToCreate);
    assertNotNull(""String_Node_Str"",newIssue);
    assertNotNull(""String_Node_Str"",newIssue.getId());
    Calendar returnedStartCal=Calendar.getInstance();
    returnedStartCal.setTime(newIssue.getStartDate());
    assertEquals(startCal.get(Calendar.YEAR),returnedStartCal.get(Calendar.YEAR));
    assertEquals(startCal.get(Calendar.MONTH),returnedStartCal.get(Calendar.MONTH));
    assertEquals(startCal.get(Calendar.DAY_OF_MONTH),returnedStartCal.get(Calendar.DAY_OF_MONTH));
    Calendar returnedDueCal=Calendar.getInstance();
    returnedDueCal.setTime(newIssue.getDueDate());
    assertEquals(due.get(Calendar.YEAR),returnedDueCal.get(Calendar.YEAR));
    assertEquals(due.get(Calendar.MONTH),returnedDueCal.get(Calendar.MONTH));
    assertEquals(due.get(Calendar.DAY_OF_MONTH),returnedDueCal.get(Calendar.DAY_OF_MONTH));
    User actualAssignee=newIssue.getAssignee();
    assertNotNull(""String_Node_Str"",actualAssignee);
    assertEquals(""String_Node_Str"",assignee.getId(),actualAssignee.getId());
    Integer EXPECTED_AUTHOR_ID=getOurUser().getId();
    assertEquals(EXPECTED_AUTHOR_ID,newIssue.getAuthor().getId());
    assertEquals((Float)estimatedHours,newIssue.getEstimatedHours());
    String regexpStripExtra=""String_Node_Str"";
    description=description.replaceAll(regexpStripExtra,""String_Node_Str"");
    String actualDescription=newIssue.getDescription();
    actualDescription=actualDescription.replaceAll(regexpStripExtra,""String_Node_Str"");
    assertEquals(description,actualDescription);
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail();
  }
}",0.9733675281120536
99553,"@Test public void testWrongCredentialsOnCreateIssue() throws RuntimeException {
  RedmineManager redmineMgrEmpty=new RedmineManager(Config.getHost(),null);
  Issue issue=new Issue();
  issue.setSubject(""String_Node_Str"");
  try {
    redmineMgrEmpty.createIssue(projectKey,issue);
    fail(""String_Node_Str"");
  }
 catch (  AuthenticationException e) {
    System.out.println(""String_Node_Str"");
  }
catch (  Exception e) {
    fail(""String_Node_Str"" + e);
  }
  RedmineManager redmineMgrInvalidKey=new RedmineManager(Config.getHost(),""String_Node_Str"");
  try {
    redmineMgrInvalidKey.createIssue(projectKey,issue);
    fail(""String_Node_Str"");
  }
 catch (  AuthenticationException e) {
    System.out.println(""String_Node_Str"");
  }
catch (  Exception e) {
    fail(""String_Node_Str"" + e);
  }
}","@Test public void testWrongCredentialsOnCreateIssue() throws RuntimeException {
  RedmineManager redmineMgrEmpty=new RedmineManager(Config.getURI(),null);
  Issue issue=new Issue();
  issue.setSubject(""String_Node_Str"");
  try {
    redmineMgrEmpty.createIssue(projectKey,issue);
    fail(""String_Node_Str"");
  }
 catch (  AuthenticationException e) {
    System.out.println(""String_Node_Str"");
  }
catch (  Exception e) {
    fail(""String_Node_Str"" + e);
  }
  RedmineManager redmineMgrInvalidKey=new RedmineManager(Config.getURI(),""String_Node_Str"");
  try {
    redmineMgrInvalidKey.createIssue(projectKey,issue);
    fail(""String_Node_Str"");
  }
 catch (  AuthenticationException e) {
    System.out.println(""String_Node_Str"");
  }
catch (  Exception e) {
    fail(""String_Node_Str"" + e);
  }
}",0.9912390488110138
99554,"@BeforeClass public static void oneTimeSetUp(){
  System.out.println(""String_Node_Str"" + Config.getHost());
  mgr=new RedmineManager(Config.getHost(),Config.getLogin(),Config.getPassword());
  Project junitTestProject=new Project();
  junitTestProject.setName(""String_Node_Str"");
  junitTestProject.setIdentifier(""String_Node_Str"" + Calendar.getInstance().getTimeInMillis());
  try {
    Project createdProject=mgr.createProject(junitTestProject);
    projectKey=createdProject.getIdentifier();
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(""String_Node_Str"" + e.getMessage());
  }
}","@BeforeClass public static void oneTimeSetUp(){
  System.out.println(""String_Node_Str"" + Config.getURI());
  mgr=new RedmineManager(Config.getURI(),Config.getLogin(),Config.getPassword());
  Project junitTestProject=new Project();
  junitTestProject.setName(""String_Node_Str"");
  junitTestProject.setIdentifier(""String_Node_Str"" + Calendar.getInstance().getTimeInMillis());
  try {
    Project createdProject=mgr.createProject(junitTestProject);
    projectKey=createdProject.getIdentifier();
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(""String_Node_Str"" + e.getMessage());
  }
}",0.988313856427379
99555,"/** 
 * append, if the value is not NULL
 */
private static final void append(StringBuilder b,String tag,Object value){
  if (value != null) {
    b.append(""String_Node_Str"" + tag + ""String_Node_Str"");
    if (value instanceof Date) {
      b.append(sdf.format(value));
    }
    if (value instanceof String) {
      b.append(encodeXML((String)value));
    }
 else {
      b.append(value);
    }
    b.append(""String_Node_Str"" + tag + ""String_Node_Str"");
  }
}","/** 
 * append, if the value is not NULL
 */
private static final void append(StringBuilder b,String tag,Object value){
  if (value != null) {
    b.append(""String_Node_Str"" + tag + ""String_Node_Str"");
    if (value instanceof Date) {
      b.append(sdf.format(value));
    }
 else     if (value instanceof String) {
      b.append(encodeXML((String)value));
    }
 else {
      b.append(value);
    }
    b.append(""String_Node_Str"" + tag + ""String_Node_Str"");
  }
}",0.9935205183585312
99556,"private static void tryGetIssues(RedmineManager mgr) throws IOException, AuthenticationException, NotFoundException, URISyntaxException, RedmineException {
  List<Issue> issues=mgr.getIssues(projectKey,queryId);
  for (  Issue issue : issues) {
    System.out.println(issue.toString());
  }
}","private static void tryGetIssues(RedmineManager mgr) throws Exception {
  List<Issue> issues=mgr.getIssues(projectKey,queryId);
  for (  Issue issue : issues) {
    System.out.println(issue.toString());
  }
}",0.832
99557,"public static void main(String[] args){
  RedmineManager mgr=new RedmineManager(redmineHost,apiAccessKey);
  try {
    tryGetIssues(mgr);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public static void main(String[] args){
  RedmineManager mgr=new RedmineManager(redmineHost,apiAccessKey);
  try {
    generateXMLForTimeEntry();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9154228855721394
99558,"@Test public void testParseIssueNonUnicodeSymbols(){
  try {
    String xml=MyIOUtils.getResourceAsString(""String_Node_Str"");
    String nonLatinSymbols=""String_Node_Str"";
    List<Issue> issues=RedmineXMLParser.parseIssuesFromXML(xml);
    assertTrue(issues.size() == 1);
    Issue issue=issues.get(0);
    assertEquals(nonLatinSymbols,issue.getSubject());
  }
 catch (  Exception e) {
    fail(e.getMessage());
  }
}","@Test @Ignore public void testParseIssueNonUnicodeSymbols(){
  try {
    String xml=MyIOUtils.getResourceAsString(""String_Node_Str"");
    String nonLatinSymbols=""String_Node_Str"";
    List<Issue> issues=RedmineXMLParser.parseIssuesFromXML(xml);
    assertTrue(issues.size() == 1);
    Issue issue=issues.get(0);
    assertEquals(nonLatinSymbols,issue.getSubject());
  }
 catch (  Exception e) {
    fail(e.getMessage());
  }
}",0.990521327014218
99559,"private <T extends Identifiable>void updateObject(Class<T> classs,T obj) throws IOException, AuthenticationException, NotFoundException, RedmineException {
  Map<String,NameValuePair> params=new HashMap<String,NameValuePair>();
  addAuthParameters(params);
  List<NameValuePair> paramsList=new ArrayList<NameValuePair>(params.values());
  URI uri=getUpdateURI(obj.getClass(),Integer.toString(obj.getId()),paramsList);
  HttpPut http=new HttpPut(uri);
  String xml=RedmineXMLParser.convertObjectToXML(obj);
  setEntity((HttpEntityEnclosingRequest)http,xml);
  Response response=sendRequest(http);
  if (response.getCode() == HttpStatus.SC_NOT_FOUND) {
    throw new NotFoundException(""String_Node_Str"" + response.getBody());
  }
}","private <T extends Identifiable>void updateObject(Class<T> classs,T obj) throws IOException, AuthenticationException, NotFoundException, RedmineException {
  Map<String,NameValuePair> params=new HashMap<String,NameValuePair>();
  addAuthParameters(params);
  List<NameValuePair> paramsList=new ArrayList<NameValuePair>(params.values());
  URI uri=getUpdateURI(obj.getClass(),Integer.toString(obj.getId()),paramsList);
  HttpPut http=new HttpPut(uri);
  String xml=RedmineXMLGenerator.toXML(obj);
  setEntity((HttpEntityEnclosingRequest)http,xml);
  Response response=sendRequest(http);
  if (response.getCode() == HttpStatus.SC_NOT_FOUND) {
    throw new NotFoundException(""String_Node_Str"" + response.getBody());
  }
}",0.9806629834254144
99560,"/** 
 * Sample usage: <p> <pre>  {@code Project project = new Project(); Long timeStamp = Calendar.getInstance().getTimeInMillis(); String key = &quot;projkey&quot; + timeStamp; String name = &quot;project number &quot; + timeStamp; String description = &quot;some description for the project&quot;; project.setIdentifier(key); project.setName(name); project.setDescription(description); Project createdProject = mgr.createProject(project);}</pre>
 * @param project project to create on the server
 * @return the newly created Project object.
 * @throws IOException
 * @throws AuthenticationException invalid or no API access key is used with the server, which requires authorization. Check the constructor arguments.
 * @throws RedmineException 
 */
public Project createProject(Project project) throws IOException, AuthenticationException, RedmineException {
  String query=buildCreateProjectURI();
  query+=""String_Node_Str"";
  HttpPost httpPost=new HttpPost(query);
  String createProjectXML=RedmineXMLParser.convertObjectToXML(project);
  setEntity(httpPost,createProjectXML);
  Response response=sendRequest(httpPost);
  Project createdProject=RedmineXMLParser.parseProjectFromXML(response.getBody());
  return createdProject;
}","/** 
 * Sample usage: <p> <pre>  {@code Project project = new Project(); Long timeStamp = Calendar.getInstance().getTimeInMillis(); String key = &quot;projkey&quot; + timeStamp; String name = &quot;project number &quot; + timeStamp; String description = &quot;some description for the project&quot;; project.setIdentifier(key); project.setName(name); project.setDescription(description); Project createdProject = mgr.createProject(project);}</pre>
 * @param project project to create on the server
 * @return the newly created Project object.
 * @throws IOException
 * @throws AuthenticationException invalid or no API access key is used with the server, which requires authorization. Check the constructor arguments.
 * @throws RedmineException 
 */
public Project createProject(Project project) throws IOException, AuthenticationException, RedmineException {
  String query=buildCreateProjectURI();
  query+=""String_Node_Str"";
  HttpPost httpPost=new HttpPost(query);
  String createProjectXML=RedmineXMLGenerator.toXML(project);
  setEntity(httpPost,createProjectXML);
  Response response=sendRequest(httpPost);
  Project createdProject=RedmineXMLParser.parseProjectFromXML(response.getBody());
  return createdProject;
}",0.9886086248982912
99561,"/** 
 * @param issue the Issue to update on the server. issue.getId() is used for identification.
 * @throws IOException
 * @throws AuthenticationException invalid or no API access key is used with the server, which requires authorization. Check the constructor arguments.
 * @throws NotFoundException the issue with the required ID is not found
 * @throws RedmineException 
 */
public void updateIssue(Issue issue) throws IOException, AuthenticationException, NotFoundException, RedmineException {
  String query=getUpdateIssueURI(issue.getId());
  HttpPut httpRequest=new HttpPut(query);
  String NO_PROJECT_KEY=null;
  String xmlBody=getIssueXML(NO_PROJECT_KEY,issue);
  setEntity(httpRequest,xmlBody);
  Response response=sendRequest(httpRequest);
  if (response.getCode() == HttpStatus.SC_NOT_FOUND) {
    throw new NotFoundException(""String_Node_Str"" + issue.getId() + ""String_Node_Str"");
  }
}","/** 
 * @param issue the Issue to update on the server. issue.getId() is used for identification.
 * @throws IOException
 * @throws AuthenticationException invalid or no API access key is used with the server, which requires authorization. Check the constructor arguments.
 * @throws NotFoundException the issue with the required ID is not found
 * @throws RedmineException 
 */
public void updateIssue(Issue issue) throws IOException, AuthenticationException, NotFoundException, RedmineException {
  String query=getUpdateIssueURI(issue.getId());
  HttpPut httpRequest=new HttpPut(query);
  String NO_PROJECT_KEY=null;
  String xmlBody=RedmineXMLGenerator.toXML(NO_PROJECT_KEY,issue);
  setEntity(httpRequest,xmlBody);
  Response response=sendRequest(httpRequest);
  if (response.getCode() == HttpStatus.SC_NOT_FOUND) {
    throw new NotFoundException(""String_Node_Str"" + issue.getId() + ""String_Node_Str"");
  }
}",0.9834619625137816
99562,"/** 
 * Sample usage: <p> <pre>  {@code Issue issueToCreate = new Issue(); issueToCreate.setSubject(""This is the summary line 123""); Issue newIssue = mgr.createIssue(PROJECT_KEY, issueToCreate);}<p>
 * @param projectKey The project ""identifier"". This is a string key like ""project-ABC"", NOT a database numeric ID.
 * @param issue the Issue object to create on the server.
 * @return the newly created Issue.
 * @throws IOException
 * @throws AuthenticationException invalid or no API access key is used with the server, which requires authorization. Check the constructor arguments.
 * @throws NotFoundException the project with the given projectKey is not found
 * @throws RedmineException 
 */
public Issue createIssue(String projectKey,Issue issue) throws IOException, AuthenticationException, NotFoundException, RedmineException {
  String query=getCreateIssueURI();
  HttpPost http=new HttpPost(query);
  String xmlBody=getIssueXML(projectKey,issue);
  setEntity(http,xmlBody);
  Response response=sendRequest(http);
  if (response.getCode() == HttpStatus.SC_NOT_FOUND) {
    throw new NotFoundException(""String_Node_Str"" + projectKey + ""String_Node_Str"");
  }
  Issue newIssue=RedmineXMLParser.parseIssueFromXML(response.getBody());
  return newIssue;
}","/** 
 * Sample usage: <p> <pre>  {@code Issue issueToCreate = new Issue(); issueToCreate.setSubject(""This is the summary line 123""); Issue newIssue = mgr.createIssue(PROJECT_KEY, issueToCreate);}<p>
 * @param projectKey The project ""identifier"". This is a string key like ""project-ABC"", NOT a database numeric ID.
 * @param issue the Issue object to create on the server.
 * @return the newly created Issue.
 * @throws IOException
 * @throws AuthenticationException invalid or no API access key is used with the server, which requires authorization. Check the constructor arguments.
 * @throws NotFoundException the project with the given projectKey is not found
 * @throws RedmineException 
 */
public Issue createIssue(String projectKey,Issue issue) throws IOException, AuthenticationException, NotFoundException, RedmineException {
  String query=getCreateIssueURI();
  HttpPost http=new HttpPost(query);
  String xmlBody=RedmineXMLGenerator.toXML(projectKey,issue);
  setEntity(http,xmlBody);
  Response response=sendRequest(http);
  if (response.getCode() == HttpStatus.SC_NOT_FOUND) {
    throw new NotFoundException(""String_Node_Str"" + projectKey + ""String_Node_Str"");
  }
  Issue newIssue=RedmineXMLParser.parseIssueFromXML(response.getBody());
  return newIssue;
}",0.9881516587677726
99563,"private <T>T createObject(Class<T> classs,T obj) throws IOException, AuthenticationException, NotFoundException, RedmineException {
  Map<String,NameValuePair> params=new HashMap<String,NameValuePair>();
  addAuthParameters(params);
  List<NameValuePair> paramsList=new ArrayList<NameValuePair>(params.values());
  URI uri=getCreateURI(obj.getClass(),paramsList);
  HttpPost http=new HttpPost(uri);
  String xml=RedmineXMLParser.convertObjectToXML(obj);
  setEntity((HttpEntityEnclosingRequest)http,xml);
  Response response=sendRequest(http);
  if (response.getCode() == HttpStatus.SC_NOT_FOUND) {
    throw new NotFoundException(""String_Node_Str"" + response.getBody());
  }
  return RedmineXMLParser.parseObjectFromXML(classs,response.getBody());
}","private <T>T createObject(Class<T> classs,T obj) throws IOException, AuthenticationException, NotFoundException, RedmineException {
  Map<String,NameValuePair> params=new HashMap<String,NameValuePair>();
  addAuthParameters(params);
  List<NameValuePair> paramsList=new ArrayList<NameValuePair>(params.values());
  URI uri=getCreateURI(obj.getClass(),paramsList);
  HttpPost http=new HttpPost(uri);
  String xml=RedmineXMLGenerator.toXML(obj);
  setEntity((HttpEntityEnclosingRequest)http,xml);
  Response response=sendRequest(http);
  if (response.getCode() == HttpStatus.SC_NOT_FOUND) {
    throw new NotFoundException(""String_Node_Str"" + response.getBody());
  }
  return RedmineXMLParser.parseObjectFromXML(classs,response.getBody());
}",0.9812080536912752
99564,"@Override public int hashCode(){
  final int prime=31;
  int result=1;
  result=prime * result + ((assignee == null) ? 0 : assignee.hashCode());
  result=prime * result + ((author == null) ? 0 : author.hashCode());
  result=prime * result + ((createdOn == null) ? 0 : createdOn.hashCode());
  result=prime * result + ((description == null) ? 0 : description.hashCode());
  result=prime * result + ((doneRatio == null) ? 0 : doneRatio.hashCode());
  result=prime * result + ((dueDate == null) ? 0 : dueDate.hashCode());
  result=prime * result + ((estimatedHours == null) ? 0 : estimatedHours.hashCode());
  result=prime * result + ((id == null) ? 0 : id.hashCode());
  result=prime * result + ((parentId == null) ? 0 : parentId.hashCode());
  result=prime * result + ((priorityText == null) ? 0 : priorityText.hashCode());
  result=prime * result + ((project == null) ? 0 : project.hashCode());
  result=prime * result + ((startDate == null) ? 0 : startDate.hashCode());
  result=prime * result + ((subject == null) ? 0 : subject.hashCode());
  result=prime * result + ((tracker == null) ? 0 : tracker.hashCode());
  result=prime * result + ((updatedOn == null) ? 0 : updatedOn.hashCode());
  return result;
}","@Override public int hashCode(){
  final int prime=31;
  int result=1;
  result=prime * result + ((assignee == null) ? 0 : assignee.hashCode());
  result=prime * result + ((author == null) ? 0 : author.hashCode());
  result=prime * result + ((createdOn == null) ? 0 : createdOn.hashCode());
  result=prime * result + ((description == null) ? 0 : description.hashCode());
  result=prime * result + ((doneRatio == null) ? 0 : doneRatio.hashCode());
  result=prime * result + ((dueDate == null) ? 0 : dueDate.hashCode());
  result=prime * result + ((estimatedHours == null) ? 0 : estimatedHours.hashCode());
  result=prime * result + ((id == null) ? 0 : id.hashCode());
  result=prime * result + ((parentId == null) ? 0 : parentId.hashCode());
  result=prime * result + ((priorityText == null) ? 0 : priorityText.hashCode());
  result=prime * result + ((project == null) ? 0 : project.hashCode());
  result=prime * result + ((startDate == null) ? 0 : startDate.hashCode());
  result=prime * result + ((statusId == null) ? 0 : statusId.hashCode());
  result=prime * result + ((statusName == null) ? 0 : statusName.hashCode());
  result=prime * result + ((subject == null) ? 0 : subject.hashCode());
  result=prime * result + ((tracker == null) ? 0 : tracker.hashCode());
  result=prime * result + ((updatedOn == null) ? 0 : updatedOn.hashCode());
  return result;
}",0.9408560311284048
99565,"@Override public boolean equals(Object obj){
  if (this == obj) {
    return true;
  }
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  Issue other=(Issue)obj;
  if (assignee == null) {
    if (other.assignee != null) {
      return false;
    }
  }
 else   if (!assignee.equals(other.assignee)) {
    return false;
  }
  if (author == null) {
    if (other.author != null) {
      return false;
    }
  }
 else   if (!author.equals(other.author)) {
    return false;
  }
  if (createdOn == null) {
    if (other.createdOn != null) {
      return false;
    }
  }
 else   if (!createdOn.equals(other.createdOn)) {
    return false;
  }
  if (description == null) {
    if (other.description != null) {
      return false;
    }
  }
 else   if (!description.equals(other.description)) {
    return false;
  }
  if (doneRatio == null) {
    if (other.doneRatio != null) {
      return false;
    }
  }
 else   if (!doneRatio.equals(other.doneRatio)) {
    return false;
  }
  if (dueDate == null) {
    if (other.dueDate != null) {
      return false;
    }
  }
 else   if (!dueDate.equals(other.dueDate)) {
    return false;
  }
  if (estimatedHours == null) {
    if (other.estimatedHours != null) {
      return false;
    }
  }
 else   if (!estimatedHours.equals(other.estimatedHours)) {
    return false;
  }
  if (id == null) {
    if (other.id != null) {
      return false;
    }
  }
 else   if (!id.equals(other.id)) {
    return false;
  }
  if (parentId == null) {
    if (other.parentId != null) {
      return false;
    }
  }
 else   if (!parentId.equals(other.parentId)) {
    return false;
  }
  if (priorityText == null) {
    if (other.priorityText != null) {
      return false;
    }
  }
 else   if (!priorityText.equals(other.priorityText)) {
    return false;
  }
  if (project == null) {
    if (other.project != null) {
      return false;
    }
  }
 else   if (!project.equals(other.project)) {
    return false;
  }
  if (startDate == null) {
    if (other.startDate != null) {
      return false;
    }
  }
 else   if (!startDate.equals(other.startDate)) {
    return false;
  }
  if (subject == null) {
    if (other.subject != null) {
      return false;
    }
  }
 else   if (!subject.equals(other.subject)) {
    return false;
  }
  if (tracker == null) {
    if (other.tracker != null) {
      return false;
    }
  }
 else   if (!tracker.equals(other.tracker)) {
    return false;
  }
  if (updatedOn == null) {
    if (other.updatedOn != null) {
      return false;
    }
  }
 else   if (!updatedOn.equals(other.updatedOn)) {
    return false;
  }
  return true;
}","@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  Issue other=(Issue)obj;
  if (assignee == null) {
    if (other.assignee != null)     return false;
  }
 else   if (!assignee.equals(other.assignee))   return false;
  if (author == null) {
    if (other.author != null)     return false;
  }
 else   if (!author.equals(other.author))   return false;
  if (createdOn == null) {
    if (other.createdOn != null)     return false;
  }
 else   if (!createdOn.equals(other.createdOn))   return false;
  if (description == null) {
    if (other.description != null)     return false;
  }
 else   if (!description.equals(other.description))   return false;
  if (doneRatio == null) {
    if (other.doneRatio != null)     return false;
  }
 else   if (!doneRatio.equals(other.doneRatio))   return false;
  if (dueDate == null) {
    if (other.dueDate != null)     return false;
  }
 else   if (!dueDate.equals(other.dueDate))   return false;
  if (estimatedHours == null) {
    if (other.estimatedHours != null)     return false;
  }
 else   if (!estimatedHours.equals(other.estimatedHours))   return false;
  if (id == null) {
    if (other.id != null)     return false;
  }
 else   if (!id.equals(other.id))   return false;
  if (parentId == null) {
    if (other.parentId != null)     return false;
  }
 else   if (!parentId.equals(other.parentId))   return false;
  if (priorityText == null) {
    if (other.priorityText != null)     return false;
  }
 else   if (!priorityText.equals(other.priorityText))   return false;
  if (project == null) {
    if (other.project != null)     return false;
  }
 else   if (!project.equals(other.project))   return false;
  if (startDate == null) {
    if (other.startDate != null)     return false;
  }
 else   if (!startDate.equals(other.startDate))   return false;
  if (statusId == null) {
    if (other.statusId != null)     return false;
  }
 else   if (!statusId.equals(other.statusId))   return false;
  if (statusName == null) {
    if (other.statusName != null)     return false;
  }
 else   if (!statusName.equals(other.statusName))   return false;
  if (subject == null) {
    if (other.subject != null)     return false;
  }
 else   if (!subject.equals(other.subject))   return false;
  if (tracker == null) {
    if (other.tracker != null)     return false;
  }
 else   if (!tracker.equals(other.tracker))   return false;
  if (updatedOn == null) {
    if (other.updatedOn != null)     return false;
  }
 else   if (!updatedOn.equals(other.updatedOn))   return false;
  return true;
}",0.3489249339871746
99566,"public TimeEntry getTimeEntry(Integer id) throws IOException, AuthenticationException, NotFoundException, RedmineException {
  return getObject(TimeEntry.class,id);
}","/** 
 * @param id the database Id of the TimeEntry record
 * @return
 * @throws IOException
 * @throws AuthenticationException
 * @throws NotFoundException
 * @throws RedmineException
 */
public TimeEntry getTimeEntry(Integer id) throws IOException, AuthenticationException, NotFoundException, RedmineException {
  return getObject(TimeEntry.class,id);
}",0.6384615384615384
99567,"@Test public void testProjectsAllPagesLoaded() throws IOException, AuthenticationException, NotFoundException, URISyntaxException {
  int NUM=27;
  List<Project> projects=createProjects(NUM);
  List<Project> loadedProjects=mgr.getProjects();
  assertTrue(loadedProjects.size() > NUM);
  deleteProjects(projects);
}","@Test public void testProjectsAllPagesLoaded() throws IOException, AuthenticationException, NotFoundException, URISyntaxException, RedmineException {
  int NUM=27;
  List<Project> projects=createProjects(NUM);
  List<Project> loadedProjects=mgr.getProjects();
  assertTrue(loadedProjects.size() > NUM);
  deleteProjects(projects);
}",0.9721362229102168
99568,"private void deleteProjects(List<Project> projects) throws IOException, AuthenticationException, NotFoundException {
  for (  Project p : projects) {
    mgr.deleteProject(p.getIdentifier());
  }
}","private void deleteProjects(List<Project> projects) throws IOException, AuthenticationException, NotFoundException, RedmineException {
  for (  Project p : projects) {
    mgr.deleteProject(p.getIdentifier());
  }
}",0.9563106796116504
99569,"@Test public void testCreateProject() throws IOException, AuthenticationException, NotFoundException {
  Project projectToCreate=generateRandomProject();
  String key=null;
  try {
    Project createdProject=mgr.createProject(projectToCreate);
    key=createdProject.getIdentifier();
    assertNotNull(""String_Node_Str"",createdProject);
    assertEquals(projectToCreate.getIdentifier(),createdProject.getIdentifier());
    assertEquals(projectToCreate.getName(),createdProject.getName());
    assertEquals(projectToCreate.getDescription(),createdProject.getDescription());
    List<Tracker> trackers=createdProject.getTrackers();
    assertNotNull(""String_Node_Str"",trackers);
    assertTrue(""String_Node_Str"",!(trackers.isEmpty()));
  }
 catch (  Exception e) {
    fail(e.getMessage());
  }
 finally {
    if (key != null) {
      mgr.deleteProject(key);
    }
  }
}","@Test public void testCreateProject() throws IOException, AuthenticationException, NotFoundException, RedmineException {
  Project projectToCreate=generateRandomProject();
  String key=null;
  try {
    Project createdProject=mgr.createProject(projectToCreate);
    key=createdProject.getIdentifier();
    assertNotNull(""String_Node_Str"",createdProject);
    assertEquals(projectToCreate.getIdentifier(),createdProject.getIdentifier());
    assertEquals(projectToCreate.getName(),createdProject.getName());
    assertEquals(projectToCreate.getDescription(),createdProject.getDescription());
    List<Tracker> trackers=createdProject.getTrackers();
    assertNotNull(""String_Node_Str"",trackers);
    assertTrue(""String_Node_Str"",!(trackers.isEmpty()));
  }
 catch (  Exception e) {
    fail(e.getMessage());
  }
 finally {
    if (key != null) {
      mgr.deleteProject(key);
    }
  }
}",0.9897377423033068
99570,"@Test public void testGetUserById() throws IOException, AuthenticationException, NotFoundException {
  User loadedUser=mgr.getUserById(getOurUser().getId());
  assertEquals(getOurUser().getId(),loadedUser.getId());
  assertEquals(getOurUser().getLogin(),loadedUser.getLogin());
}","@Test public void testGetUserById() throws IOException, AuthenticationException, NotFoundException, RedmineException {
  User loadedUser=mgr.getUserById(getOurUser().getId());
  assertEquals(getOurUser().getId(),loadedUser.getId());
  assertEquals(getOurUser().getLogin(),loadedUser.getLogin());
}",0.96875
99571,"private List<Project> createProjects(int num) throws IOException, AuthenticationException, NotFoundException {
  List<Project> projects=new ArrayList<Project>(num);
  for (int i=0; i < num; i++) {
    Project projectToCreate=generateRandomProject();
    Project p=mgr.createProject(projectToCreate);
    projects.add(p);
  }
  return projects;
}","private List<Project> createProjects(int num) throws IOException, AuthenticationException, NotFoundException, RedmineException {
  List<Project> projects=new ArrayList<Project>(num);
  for (int i=0; i < num; i++) {
    Project projectToCreate=generateRandomProject();
    Project p=mgr.createProject(projectToCreate);
    projects.add(p);
  }
  return projects;
}",0.9745762711864406
99572,"@Test public void testGetCurrentUser() throws IOException, AuthenticationException {
  User currentUser=mgr.getCurrentUser();
  assertEquals(getOurUser().getId(),currentUser.getId());
  assertEquals(getOurUser().getLogin(),currentUser.getLogin());
}","@Test public void testGetCurrentUser() throws IOException, AuthenticationException, RedmineException {
  User currentUser=mgr.getCurrentUser();
  assertEquals(getOurUser().getId(),currentUser.getId());
  assertEquals(getOurUser().getLogin(),currentUser.getLogin());
}",0.9651162790697676
99573,"@Test public void testCreateGetUpdateDeleteProject() throws IOException, AuthenticationException, NotFoundException {
  Project projectToCreate=generateRandomProject();
  String key=null;
  try {
    projectToCreate.setIdentifier(""String_Node_Str"" + new Date().getTime());
    System.out.println(""String_Node_Str"" + projectToCreate.getIdentifier());
    Project createdProject=mgr.createProject(projectToCreate);
    key=createdProject.getIdentifier();
    String newDescr=""String_Node_Str"";
    String newName=""String_Node_Str"";
    createdProject.setName(newName);
    createdProject.setDescription(newDescr);
    mgr.updateProject(createdProject);
    Project updatedProject=mgr.getProjectByIdentifier(key);
    assertNotNull(updatedProject);
    assertEquals(createdProject.getIdentifier(),updatedProject.getIdentifier());
    assertEquals(newName,updatedProject.getName());
    assertEquals(newDescr,updatedProject.getDescription());
    List<Tracker> trackers=updatedProject.getTrackers();
    assertNotNull(""String_Node_Str"",trackers);
    assertTrue(""String_Node_Str"",!(trackers.isEmpty()));
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
 finally {
    if (key != null) {
      mgr.deleteProject(key);
    }
  }
}","@Test public void testCreateGetUpdateDeleteProject() throws IOException, AuthenticationException, NotFoundException, RedmineException {
  Project projectToCreate=generateRandomProject();
  String key=null;
  try {
    projectToCreate.setIdentifier(""String_Node_Str"" + new Date().getTime());
    System.out.println(""String_Node_Str"" + projectToCreate.getIdentifier());
    Project createdProject=mgr.createProject(projectToCreate);
    key=createdProject.getIdentifier();
    String newDescr=""String_Node_Str"";
    String newName=""String_Node_Str"";
    createdProject.setName(newName);
    createdProject.setDescription(newDescr);
    mgr.updateProject(createdProject);
    Project updatedProject=mgr.getProjectByIdentifier(key);
    assertNotNull(updatedProject);
    assertEquals(createdProject.getIdentifier(),updatedProject.getIdentifier());
    assertEquals(newName,updatedProject.getName());
    assertEquals(newDescr,updatedProject.getDescription());
    List<Tracker> trackers=updatedProject.getTrackers();
    assertNotNull(""String_Node_Str"",trackers);
    assertTrue(""String_Node_Str"",!(trackers.isEmpty()));
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
 finally {
    if (key != null) {
      mgr.deleteProject(key);
    }
  }
}",0.9929022082018928
99574,"private void createIssues(int num) throws IOException, AuthenticationException, NotFoundException {
  for (int i=0; i < num; i++) {
    Issue issueToCreate=new Issue();
    issueToCreate.setSubject(""String_Node_Str"" + i + ""String_Node_Str""+ new Date());
    mgr.createIssue(projectKey,issueToCreate);
  }
}","private void createIssues(int num) throws IOException, AuthenticationException, NotFoundException, RedmineException {
  for (int i=0; i < num; i++) {
    Issue issueToCreate=new Issue();
    issueToCreate.setSubject(""String_Node_Str"" + i + ""String_Node_Str""+ new Date());
    mgr.createIssue(projectKey,issueToCreate);
  }
}",0.9714285714285714
99575,"public User getCurrentUser() throws IOException, AuthenticationException {
  String query=getURLCurrentUser();
  HttpGet http=new HttpGet(query);
  Response response=sendRequest(http);
  return RedmineXMLParser.parseUserFromXML(response.getBody());
}","public User getCurrentUser() throws IOException, AuthenticationException, RedmineException {
  String query=getURLCurrentUser();
  HttpGet http=new HttpGet(query);
  Response response=sendRequest(http);
  return RedmineXMLParser.parseUserFromXML(response.getBody());
}",0.9652509652509652
99576,"public User getUserById(Integer userId) throws IOException, AuthenticationException, NotFoundException {
  String query=getURLUserById(userId);
  HttpGet http=new HttpGet(query);
  Response response=sendRequest(http);
  if (response.getCode() == HttpStatus.SC_NOT_FOUND) {
    throw new NotFoundException(""String_Node_Str"" + userId + ""String_Node_Str"");
  }
  return RedmineXMLParser.parseUserFromXML(response.getBody());
}","public User getUserById(Integer userId) throws IOException, AuthenticationException, NotFoundException, RedmineException {
  String query=getURLUserById(userId);
  HttpGet http=new HttpGet(query);
  Response response=sendRequest(http);
  if (response.getCode() == HttpStatus.SC_NOT_FOUND) {
    throw new NotFoundException(""String_Node_Str"" + userId + ""String_Node_Str"");
  }
  return RedmineXMLParser.parseUserFromXML(response.getBody());
}",0.9791666666666666
99577,"/** 
 * Sample usage: <p> <pre>  {@code Project project = new Project(); Long timeStamp = Calendar.getInstance().getTimeInMillis(); String key = &quot;projkey&quot; + timeStamp; String name = &quot;project number &quot; + timeStamp; String description = &quot;some description for the project&quot;; project.setIdentifier(key); project.setName(name); project.setDescription(description); Project createdProject = mgr.createProject(project);}</pre>
 * @param project project to create on the server
 * @return the newly created Project object.
 * @throws IOException
 * @throws AuthenticationException invalid or no API access key is used with the server, which requires authorization. Check the constructor arguments.
 */
public Project createProject(Project project) throws IOException, AuthenticationException {
  String query=buildCreateProjectURI();
  query+=""String_Node_Str"";
  HttpPost httpPost=new HttpPost(query);
  String createProjectXML=RedmineXMLParser.convertObjectToXML(project);
  setEntity(httpPost,createProjectXML);
  Response response=sendRequest(httpPost);
  Project createdProject=RedmineXMLParser.parseProjectFromXML(response.getBody());
  return createdProject;
}","/** 
 * Sample usage: <p> <pre>  {@code Project project = new Project(); Long timeStamp = Calendar.getInstance().getTimeInMillis(); String key = &quot;projkey&quot; + timeStamp; String name = &quot;project number &quot; + timeStamp; String description = &quot;some description for the project&quot;; project.setIdentifier(key); project.setName(name); project.setDescription(description); Project createdProject = mgr.createProject(project);}</pre>
 * @param project project to create on the server
 * @return the newly created Project object.
 * @throws IOException
 * @throws AuthenticationException invalid or no API access key is used with the server, which requires authorization. Check the constructor arguments.
 * @throws RedmineException 
 */
public Project createProject(Project project) throws IOException, AuthenticationException, RedmineException {
  String query=buildCreateProjectURI();
  query+=""String_Node_Str"";
  HttpPost httpPost=new HttpPost(query);
  String createProjectXML=RedmineXMLParser.convertObjectToXML(project);
  setEntity(httpPost,createProjectXML);
  Response response=sendRequest(httpPost);
  Project createdProject=RedmineXMLParser.parseProjectFromXML(response.getBody());
  return createdProject;
}",0.9805865344898802
99578,"/** 
 * @param issue the Issue to update on the server. issue.getId() is used for identification.
 * @throws IOException
 * @throws AuthenticationException invalid or no API access key is used with the server, which requires authorization. Check the constructor arguments.
 * @throws NotFoundException the issue with the required ID is not found
 */
public void updateIssue(Issue issue) throws IOException, AuthenticationException, NotFoundException {
  String query=getUpdateIssueURI(issue.getId());
  HttpPut httpRequest=new HttpPut(query);
  String NO_PROJECT_KEY=null;
  String xmlBody=getIssueXML(NO_PROJECT_KEY,issue);
  setEntity(httpRequest,xmlBody);
  Response response=sendRequest(httpRequest);
  if (response.getCode() == HttpStatus.SC_NOT_FOUND) {
    throw new NotFoundException(""String_Node_Str"" + issue.getId() + ""String_Node_Str"");
  }
}","/** 
 * @param issue the Issue to update on the server. issue.getId() is used for identification.
 * @throws IOException
 * @throws AuthenticationException invalid or no API access key is used with the server, which requires authorization. Check the constructor arguments.
 * @throws NotFoundException the issue with the required ID is not found
 * @throws RedmineException 
 */
public void updateIssue(Issue issue) throws IOException, AuthenticationException, NotFoundException, RedmineException {
  String query=getUpdateIssueURI(issue.getId());
  HttpPut httpRequest=new HttpPut(query);
  String NO_PROJECT_KEY=null;
  String xmlBody=getIssueXML(NO_PROJECT_KEY,issue);
  setEntity(httpRequest,xmlBody);
  Response response=sendRequest(httpRequest);
  if (response.getCode() == HttpStatus.SC_NOT_FOUND) {
    throw new NotFoundException(""String_Node_Str"" + issue.getId() + ""String_Node_Str"");
  }
}",0.973188819167142
99579,"private String getIssueXML(String projectKey,Issue issue){
  String xml=""String_Node_Str"";
  if (projectKey != null) {
    xml+=""String_Node_Str"" + projectKey + ""String_Node_Str"";
  }
  if (issue.getParentId() != null) {
    xml+=""String_Node_Str"" + issue.getParentId() + ""String_Node_Str"";
  }
  xml+=""String_Node_Str"" + issue.getSubject() + ""String_Node_Str"";
  if (issue.getTracker() != null) {
    xml+=""String_Node_Str"" + issue.getTracker().getId() + ""String_Node_Str"";
  }
  if (issue.getStartDate() != null) {
    String strDate=sdf.format(issue.getStartDate());
    xml+=""String_Node_Str"" + strDate + ""String_Node_Str"";
  }
  if (issue.getDueDate() != null) {
    String strDate=sdf.format(issue.getDueDate());
    xml+=""String_Node_Str"" + strDate + ""String_Node_Str"";
  }
  User ass=issue.getAssignee();
  if (ass != null) {
    xml+=""String_Node_Str"" + ass.getId() + ""String_Node_Str"";
  }
  if (issue.getEstimatedHours() != null) {
    xml+=""String_Node_Str"" + issue.getEstimatedHours() + ""String_Node_Str"";
  }
  if (issue.getDescription() != null) {
    xml+=""String_Node_Str"" + issue.getDescription() + ""String_Node_Str"";
  }
  xml+=""String_Node_Str"";
  return xml;
}","private String getIssueXML(String projectKey,Issue issue){
  String xml=""String_Node_Str"";
  if (projectKey != null) {
    xml+=""String_Node_Str"" + projectKey + ""String_Node_Str"";
  }
  if (issue.getParentId() != null) {
    xml+=""String_Node_Str"" + issue.getParentId() + ""String_Node_Str"";
  }
  if (issue.getSubject() != null) {
    xml+=""String_Node_Str"" + issue.getSubject() + ""String_Node_Str"";
  }
  if (issue.getTracker() != null) {
    xml+=""String_Node_Str"" + issue.getTracker().getId() + ""String_Node_Str"";
  }
  if (issue.getStartDate() != null) {
    String strDate=sdf.format(issue.getStartDate());
    xml+=""String_Node_Str"" + strDate + ""String_Node_Str"";
  }
  if (issue.getDueDate() != null) {
    String strDate=sdf.format(issue.getDueDate());
    xml+=""String_Node_Str"" + strDate + ""String_Node_Str"";
  }
  User ass=issue.getAssignee();
  if (ass != null) {
    xml+=""String_Node_Str"" + ass.getId() + ""String_Node_Str"";
  }
  if (issue.getEstimatedHours() != null) {
    xml+=""String_Node_Str"" + issue.getEstimatedHours() + ""String_Node_Str"";
  }
  if (issue.getDescription() != null) {
    xml+=""String_Node_Str"" + issue.getDescription() + ""String_Node_Str"";
  }
  xml+=""String_Node_Str"";
  return xml;
}",0.9450915141430948
99580,"/** 
 * @param projectKey string key like ""project-ABC"", NOT a database numeric ID
 * @return Redmine's project
 * @throws AuthenticationException invalid or no API access key is used with the server, which requires authorization. Check the constructor arguments.
 * @throws NotFoundException the project with the given key is not found
 */
public Project getProjectByIdentifier(String projectKey) throws IOException, AuthenticationException, NotFoundException {
  String query=getURLProjectByKey(projectKey);
  query+=""String_Node_Str"";
  HttpGet http=new HttpGet(query);
  Response response=sendRequest(http);
  if (response.getCode() == HttpStatus.SC_NOT_FOUND) {
    throw new NotFoundException(""String_Node_Str"" + projectKey + ""String_Node_Str"");
  }
  Project projectFromServer=RedmineXMLParser.parseProjectFromXML(response.getBody());
  return projectFromServer;
}","/** 
 * @param projectKey string key like ""project-ABC"", NOT a database numeric ID
 * @return Redmine's project
 * @throws AuthenticationException invalid or no API access key is used with the server, which requires authorization. Check the constructor arguments.
 * @throws NotFoundException the project with the given key is not found
 * @throws RedmineException 
 */
public Project getProjectByIdentifier(String projectKey) throws IOException, AuthenticationException, NotFoundException, RedmineException {
  String query=getURLProjectByKey(projectKey);
  query+=""String_Node_Str"";
  HttpGet http=new HttpGet(query);
  Response response=sendRequest(http);
  if (response.getCode() == HttpStatus.SC_NOT_FOUND) {
    throw new NotFoundException(""String_Node_Str"" + projectKey + ""String_Node_Str"");
  }
  Project projectFromServer=RedmineXMLParser.parseProjectFromXML(response.getBody());
  return projectFromServer;
}",0.9737283398546674
99581,"/** 
 * Load the list of users on the server.
 * @return list of User objects
 * @throws AuthenticationException invalid or no API access key is used with the server, which requires authorization. Check the constructor arguments.
 * @throws URISyntaxException 
 * @throws NotFoundException 
 */
public List<User> getUsers() throws IOException, AuthenticationException, NotFoundException, URISyntaxException {
  Map<String,NameValuePair> params=new HashMap<String,NameValuePair>();
  return getObjectsListV104(User.class,params);
}","/** 
 * Load the list of users on the server.
 * @return list of User objects
 * @throws AuthenticationException invalid or no API access key is used with the server, which requires authorization. Check the constructor arguments.
 * @throws URISyntaxException 
 * @throws NotFoundException 
 * @throws RedmineException 
 */
public List<User> getUsers() throws IOException, AuthenticationException, NotFoundException, URISyntaxException, RedmineException {
  Map<String,NameValuePair> params=new HashMap<String,NameValuePair>();
  return getObjectsListV104(User.class,params);
}",0.957542908762421
99582,"/** 
 * Sample usage: <p> <pre>  {@code Issue issueToCreate = new Issue(); issueToCreate.setSubject(""This is the summary line 123""); Issue newIssue = mgr.createIssue(PROJECT_KEY, issueToCreate);}<p>
 * @param projectKey The project ""identifier"". This is a string key like ""project-ABC"", NOT a database numeric ID.
 * @param issue the Issue object to create on the server.
 * @return the newly created Issue.
 * @throws IOException
 * @throws AuthenticationException invalid or no API access key is used with the server, which requires authorization. Check the constructor arguments.
 * @throws NotFoundException the project with the given projectKey is not found
 */
public Issue createIssue(String projectKey,Issue issue) throws IOException, AuthenticationException, NotFoundException {
  String query=getCreateIssueURI();
  HttpPost http=new HttpPost(query);
  String xmlBody=getIssueXML(projectKey,issue);
  setEntity(http,xmlBody);
  Response response=sendRequest(http);
  if (response.getCode() == HttpStatus.SC_NOT_FOUND) {
    throw new NotFoundException(""String_Node_Str"" + projectKey + ""String_Node_Str"");
  }
  Issue newIssue=RedmineXMLParser.parseIssueFromXML(response.getBody());
  return newIssue;
}","/** 
 * Sample usage: <p> <pre>  {@code Issue issueToCreate = new Issue(); issueToCreate.setSubject(""This is the summary line 123""); Issue newIssue = mgr.createIssue(PROJECT_KEY, issueToCreate);}<p>
 * @param projectKey The project ""identifier"". This is a string key like ""project-ABC"", NOT a database numeric ID.
 * @param issue the Issue object to create on the server.
 * @return the newly created Issue.
 * @throws IOException
 * @throws AuthenticationException invalid or no API access key is used with the server, which requires authorization. Check the constructor arguments.
 * @throws NotFoundException the project with the given projectKey is not found
 * @throws RedmineException 
 */
public Issue createIssue(String projectKey,Issue issue) throws IOException, AuthenticationException, NotFoundException, RedmineException {
  String query=getCreateIssueURI();
  HttpPost http=new HttpPost(query);
  String xmlBody=getIssueXML(projectKey,issue);
  setEntity(http,xmlBody);
  Response response=sendRequest(http);
  if (response.getCode() == HttpStatus.SC_NOT_FOUND) {
    throw new NotFoundException(""String_Node_Str"" + projectKey + ""String_Node_Str"");
  }
  Issue newIssue=RedmineXMLParser.parseIssueFromXML(response.getBody());
  return newIssue;
}",0.98097936058276
99583,"/** 
 * Load the list of projects available to the user, which is represented by the API access key.
 * @return list of Project objects
 * @throws AuthenticationException invalid or no API access key is used with the server, which requires authorization. Check the constructor arguments.
 * @throws NotFoundException 
 */
public List<Project> getProjects() throws IOException, AuthenticationException {
  Map<String,NameValuePair> params=new HashMap<String,NameValuePair>();
  try {
    return getObjectsListV104(Project.class,params);
  }
 catch (  NotFoundException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","/** 
 * Load the list of projects available to the user, which is represented by the API access key.
 * @return list of Project objects
 * @throws AuthenticationException invalid or no API access key is used with the server, which requires authorization. Check the constructor arguments.
 * @throws RedmineException 
 * @throws NotFoundException 
 */
public List<Project> getProjects() throws IOException, AuthenticationException, RedmineException {
  Map<String,NameValuePair> params=new HashMap<String,NameValuePair>();
  try {
    return getObjectsListV104(Project.class,params);
  }
 catch (  NotFoundException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.963984674329502
99584,"/** 
 * There could be several issues with the same summary, so the method returns List. 
 * @param summaryField
 * @return empty list if not issues with this summary field exist, never NULL
 * @throws AuthenticationException invalid or no API access key is used with the server, which requires authorization. Check the constructor arguments.
 * @throws URISyntaxException 
 * @throws NotFoundException 
 */
public List<Issue> getIssuesBySummary(String projectKey,String summaryField) throws IOException, AuthenticationException, NotFoundException, URISyntaxException {
  Map<String,NameValuePair> params=new HashMap<String,NameValuePair>();
  params.put(""String_Node_Str"",new BasicNameValuePair(""String_Node_Str"",summaryField));
  if ((projectKey != null) && (!projectKey.isEmpty())) {
    params.put(""String_Node_Str"",new BasicNameValuePair(""String_Node_Str"",projectKey));
  }
  return getObjectsListV104(Issue.class,params);
}","/** 
 * There could be several issues with the same summary, so the method returns List. 
 * @param summaryField
 * @return empty list if not issues with this summary field exist, never NULL
 * @throws AuthenticationException invalid or no API access key is used with the server, which requires authorization. Check the constructor arguments.
 * @throws URISyntaxException 
 * @throws NotFoundException 
 * @throws RedmineException 
 */
public List<Issue> getIssuesBySummary(String projectKey,String summaryField) throws IOException, AuthenticationException, NotFoundException, URISyntaxException, RedmineException {
  Map<String,NameValuePair> params=new HashMap<String,NameValuePair>();
  params.put(""String_Node_Str"",new BasicNameValuePair(""String_Node_Str"",summaryField));
  if ((projectKey != null) && (!projectKey.isEmpty())) {
    params.put(""String_Node_Str"",new BasicNameValuePair(""String_Node_Str"",projectKey));
  }
  return getObjectsListV104(Issue.class,params);
}",0.9753280839895012
99585,"/** 
 * This method cannot return the updated object from Redmine because the server does not provide any XML in response.
 * @param user
 * @throws IOException
 * @throws AuthenticationException invalid or no API access key is used with the server, which requires authorization. Check the constructor arguments.
 */
public void updateUser(User user) throws IOException, AuthenticationException {
  String query=buildUpdateUserQuery(user.getId());
  HttpPut httpRequest=new HttpPut(query);
  String projectXML=RedmineXMLParser.convertObjectToXML(user);
  setEntity(httpRequest,projectXML);
  sendRequest(httpRequest);
}","/** 
 * This method cannot return the updated object from Redmine because the server does not provide any XML in response.
 * @param user
 * @throws IOException
 * @throws AuthenticationException invalid or no API access key is used with the server, which requires authorization. Check the constructor arguments.
 * @throws RedmineException 
 */
public void updateUser(User user) throws IOException, AuthenticationException, RedmineException {
  String query=buildUpdateUserQuery(user.getId());
  HttpPut httpRequest=new HttpPut(query);
  String projectXML=RedmineXMLParser.convertObjectToXML(user);
  setEntity(httpRequest,projectXML);
  sendRequest(httpRequest);
}",0.9634241245136188
99586,"private <T>List<T> getObjectsListV104(Class<T> objectClass,Map<String,NameValuePair> params) throws IOException, AuthenticationException, NotFoundException {
  List<T> objects=new ArrayList<T>();
  final int FIRST_REDMINE_PAGE=1;
  int pageNum=FIRST_REDMINE_PAGE;
  String firstPage=null;
  addPagingParameters(params);
  addAuthParameters(params);
  do {
    params.put(""String_Node_Str"",new BasicNameValuePair(""String_Node_Str"",String.valueOf(pageNum)));
    List<NameValuePair> paramsList=new ArrayList<NameValuePair>(params.values());
    URI uri;
    try {
      uri=URIUtils.createURI(getProtocol(),getHost(),getPort(),urls.get(objectClass),URLEncodedUtils.format(paramsList,CHARSET),null);
    }
 catch (    URISyntaxException e) {
      throw new RuntimeException(""String_Node_Str"" + e.getMessage());
    }
    HttpGet http=new HttpGet(uri);
    Response response=sendRequest(http);
    if (response.getCode() == HttpStatus.SC_NOT_FOUND) {
      throw new NotFoundException(""String_Node_Str"" + response.getBody());
    }
    String body=response.getBody();
    if (pageNum == FIRST_REDMINE_PAGE) {
      firstPage=body;
    }
 else {
      if (firstPage.equals(body)) {
        break;
      }
    }
    List<T> foundItems=RedmineXMLParser.parseObjectsFromXML(objectClass,body);
    if (foundItems.size() == 0) {
      break;
    }
    objects.addAll(foundItems);
    pageNum++;
  }
 while (true);
  return objects;
}","private <T>List<T> getObjectsListV104(Class<T> objectClass,Map<String,NameValuePair> params) throws IOException, AuthenticationException, NotFoundException, RedmineException {
  List<T> objects=new ArrayList<T>();
  final int FIRST_REDMINE_PAGE=1;
  int pageNum=FIRST_REDMINE_PAGE;
  String firstPage=null;
  addPagingParameters(params);
  addAuthParameters(params);
  do {
    params.put(""String_Node_Str"",new BasicNameValuePair(""String_Node_Str"",String.valueOf(pageNum)));
    List<NameValuePair> paramsList=new ArrayList<NameValuePair>(params.values());
    URI uri;
    try {
      uri=URIUtils.createURI(getProtocol(),getHost(),getPort(),urls.get(objectClass),URLEncodedUtils.format(paramsList,CHARSET),null);
    }
 catch (    URISyntaxException e) {
      throw new RuntimeException(""String_Node_Str"" + e.getMessage());
    }
    HttpGet http=new HttpGet(uri);
    Response response=sendRequest(http);
    if (response.getCode() == HttpStatus.SC_NOT_FOUND) {
      throw new NotFoundException(""String_Node_Str"" + response.getBody());
    }
    String body=response.getBody();
    if (pageNum == FIRST_REDMINE_PAGE) {
      firstPage=body;
    }
 else {
      if (firstPage.equals(body)) {
        break;
      }
    }
    List<T> foundItems=RedmineXMLParser.parseObjectsFromXML(objectClass,body);
    if (foundItems.size() == 0) {
      break;
    }
    objects.addAll(foundItems);
    pageNum++;
  }
 while (true);
  return objects;
}",0.9937194696441032
99587,"/** 
 * @param projectKey string key like ""project-ABC"", NOT a database numeric ID
 * @throws AuthenticationException invalid or no API access key is used with the server, which requires authorization. Check the constructor arguments.
 * @throws NotFoundException if the project with the given key is not found
 */
public void deleteProject(String projectKey) throws IOException, AuthenticationException, NotFoundException {
  String query=getURLProjectByKey(projectKey);
  HttpDelete http=new HttpDelete(query);
  Response response=sendRequest(http);
  if (response.getCode() == HttpStatus.SC_NOT_FOUND) {
    throw new NotFoundException(""String_Node_Str"" + projectKey + ""String_Node_Str"");
  }
}","/** 
 * @param projectKey string key like ""project-ABC"", NOT a database numeric ID
 * @throws AuthenticationException invalid or no API access key is used with the server, which requires authorization. Check the constructor arguments.
 * @throws NotFoundException if the project with the given key is not found
 * @throws RedmineException 
 */
public void deleteProject(String projectKey) throws IOException, AuthenticationException, NotFoundException, RedmineException {
  String query=getURLProjectByKey(projectKey);
  HttpDelete http=new HttpDelete(query);
  Response response=sendRequest(http);
  if (response.getCode() == HttpStatus.SC_NOT_FOUND) {
    throw new NotFoundException(""String_Node_Str"" + projectKey + ""String_Node_Str"");
  }
}",0.9673837612768912
99588,"/** 
 * @param project
 * @throws IOException
 * @throws AuthenticationException invalid or no API access key is used with the server, which requires authorization. Check the constructor arguments.
 */
public void updateProject(Project project) throws IOException, AuthenticationException {
  String query=buildUpdateProjectURI(project.getIdentifier());
  HttpPut httpRequest=new HttpPut(query);
  String projectXML=RedmineXMLParser.convertObjectToXML(project);
  setEntity(httpRequest,projectXML);
  sendRequest(httpRequest);
}","/** 
 * @param project
 * @throws IOException
 * @throws AuthenticationException invalid or no API access key is used with the server, which requires authorization. Check the constructor arguments.
 * @throws RedmineException 
 */
public void updateProject(Project project) throws IOException, AuthenticationException, RedmineException {
  String query=buildUpdateProjectURI(project.getIdentifier());
  HttpPut httpRequest=new HttpPut(query);
  String projectXML=RedmineXMLParser.convertObjectToXML(project);
  setEntity(httpRequest,projectXML);
  sendRequest(httpRequest);
}",0.957388939256573
99589,"public User createUser(User user) throws IOException, AuthenticationException {
  String query=buildCreateUserQuery();
  HttpPost httpPost=new HttpPost(query);
  String xml=RedmineXMLParser.convertObjectToXML(user);
  setEntity(httpPost,xml);
  Response response=sendRequest(httpPost);
  return RedmineXMLParser.parseUserFromXML(response.getBody());
}","public User createUser(User user) throws IOException, AuthenticationException, RedmineException {
  String query=buildCreateUserQuery();
  HttpPost httpPost=new HttpPost(query);
  String xml=RedmineXMLParser.convertObjectToXML(user);
  setEntity(httpPost,xml);
  Response response=sendRequest(httpPost);
  return RedmineXMLParser.parseUserFromXML(response.getBody());
}",0.975
99590,"private Response sendRequest(HttpRequest request) throws ClientProtocolException, IOException, AuthenticationException {
  System.out.println(request.getRequestLine());
  DefaultHttpClient httpclient=new DefaultHttpClient();
  wrapClient(httpclient);
  HttpResponse httpResponse=httpclient.execute((HttpUriRequest)request);
  System.out.println(httpResponse.getStatusLine());
  int responseCode=httpResponse.getStatusLine().getStatusCode();
  if (responseCode == HttpStatus.SC_UNAUTHORIZED) {
    throw new AuthenticationException(""String_Node_Str"" + apiAccessKey);
  }
  HttpEntity responseEntity=httpResponse.getEntity();
  String responseBody=EntityUtils.toString(responseEntity);
  Response r=new Response(responseCode,responseBody);
  httpclient.getConnectionManager().shutdown();
  return r;
}","private Response sendRequest(HttpRequest request) throws ClientProtocolException, IOException, AuthenticationException, RedmineException {
  System.out.println(request.getRequestLine());
  DefaultHttpClient httpclient=new DefaultHttpClient();
  wrapClient(httpclient);
  HttpResponse httpResponse=httpclient.execute((HttpUriRequest)request);
  System.out.println(httpResponse.getStatusLine());
  int responseCode=httpResponse.getStatusLine().getStatusCode();
  if (responseCode == HttpStatus.SC_UNAUTHORIZED) {
    throw new AuthenticationException(""String_Node_Str"");
  }
  HttpEntity responseEntity=httpResponse.getEntity();
  String responseBody=EntityUtils.toString(responseEntity);
  if (responseCode == HttpStatus.SC_UNPROCESSABLE_ENTITY) {
    List<String> errors=RedmineXMLParser.parseErrors(responseBody);
    throw new RedmineException(errors);
  }
  Response r=new Response(responseCode,responseBody);
  httpclient.getConnectionManager().shutdown();
  return r;
}",0.8697123519458545
99591,"/** 
 * @param id the Redmine issue ID
 * @return Issue object
 * @throws IOException
 * @throws AuthenticationException invalid or no API access key is used with the server, which requires authorization. Check the constructor arguments.
 * @throws NotFoundException the issue with the given id is not found on the server
 */
public Issue getIssueById(Integer id) throws IOException, AuthenticationException, NotFoundException {
  String query=getURLIssueById(id);
  HttpGet http=new HttpGet(query);
  Response response=sendRequest(http);
  if (response.getCode() == HttpStatus.SC_NOT_FOUND) {
    throw new NotFoundException(""String_Node_Str"" + id + ""String_Node_Str"");
  }
  Issue issue=RedmineXMLParser.parseIssueFromXML(response.getBody());
  return issue;
}","/** 
 * @param id the Redmine issue ID
 * @return Issue object
 * @throws IOException
 * @throws AuthenticationException invalid or no API access key is used with the server, which requires authorization. Check the constructor arguments.
 * @throws NotFoundException the issue with the given id is not found on the server
 * @throws RedmineException 
 */
public Issue getIssueById(Integer id) throws IOException, AuthenticationException, NotFoundException, RedmineException {
  String query=getURLIssueById(id);
  HttpGet http=new HttpGet(query);
  Response response=sendRequest(http);
  if (response.getCode() == HttpStatus.SC_NOT_FOUND) {
    throw new NotFoundException(""String_Node_Str"" + id + ""String_Node_Str"");
  }
  Issue issue=RedmineXMLParser.parseIssueFromXML(response.getBody());
  return issue;
}",0.9700827498408656
99592,"/** 
 * @param projectKey
 * @param queryId id of the saved query in Redmine. the query must be accessible to the user represented by the API access key (if the Redmine project requires authorization).  This parameter is <b>optional<b>, NULL can be provided to get all available issues.
 * @return list of Issue objects
 * @throws IOException
 * @throws AuthenticationException invalid or no API access key is used with the server, which requires authorization. Check the constructor arguments.
 * @see Issue
 */
public List<Issue> getIssues(String projectKey,Integer queryId) throws IOException, AuthenticationException, NotFoundException, URISyntaxException {
  Map<String,NameValuePair> params=new HashMap<String,NameValuePair>();
  if (queryId != null) {
    params.put(""String_Node_Str"",new BasicNameValuePair(""String_Node_Str"",String.valueOf(queryId)));
  }
  if ((projectKey != null) && (!projectKey.isEmpty())) {
    params.put(""String_Node_Str"",new BasicNameValuePair(""String_Node_Str"",projectKey));
  }
  List<Issue> issues=getObjectsListV104(Issue.class,params);
  return issues;
}","/** 
 * @param projectKey
 * @param queryId id of the saved query in Redmine. the query must be accessible to the user represented by the API access key (if the Redmine project requires authorization).  This parameter is <b>optional<b>, NULL can be provided to get all available issues.
 * @return list of Issue objects
 * @throws IOException
 * @throws AuthenticationException invalid or no API access key is used with the server, which requires authorization. Check the constructor arguments.
 * @throws RedmineException 
 * @see Issue
 */
public List<Issue> getIssues(String projectKey,Integer queryId) throws IOException, AuthenticationException, NotFoundException, URISyntaxException, RedmineException {
  Map<String,NameValuePair> params=new HashMap<String,NameValuePair>();
  if (queryId != null) {
    params.put(""String_Node_Str"",new BasicNameValuePair(""String_Node_Str"",String.valueOf(queryId)));
  }
  if ((projectKey != null) && (!projectKey.isEmpty())) {
    params.put(""String_Node_Str"",new BasicNameValuePair(""String_Node_Str"",projectKey));
  }
  List<Issue> issues=getObjectsListV104(Issue.class,params);
  return issues;
}",0.9789332138054684
99593,"@Test public void testDoneRatioIsLoaded(){
  Issue issue17319=issuesMap.get(17319);
  Integer expectedDoneRatio17319=60;
  assertEquals(""String_Node_Str"",expectedDoneRatio17319,issue17319.getDoneRatio());
  Issue issue17318=issuesMap.get(17318);
  Integer expectedDoneRatio17318=33;
  assertEquals(""String_Node_Str"",expectedDoneRatio17318,issue17318.getDoneRatio());
  Issue issue17481=issuesMap.get(17481);
  Integer expectedDoneRatio17481=0;
  assertEquals(""String_Node_Str"",expectedDoneRatio17481,issue17481.getDoneRatio());
}","@Test public void testDoneRatioIsLoaded(){
  Issue issue67=issuesMap.get(67);
  Integer expectedDoneRatio67=20;
  assertEquals(""String_Node_Str"",expectedDoneRatio67,issue67.getDoneRatio());
  Issue issue65=issuesMap.get(65);
  Integer expectedDoneRatio65=80;
  assertEquals(""String_Node_Str"",expectedDoneRatio65,issue65.getDoneRatio());
  Issue issue55=issuesMap.get(55);
  Integer expectedDoneRatio55=0;
  assertEquals(""String_Node_Str"",expectedDoneRatio55,issue55.getDoneRatio());
}",0.5330700888450148
99594,"@Test public void testProject1(){
  Issue issue17611=issuesMap.get(17611);
  Integer expectedProjectId=9579;
  String expectedProjectName=""String_Node_Str"";
  Project actualProect=issue17611.getProject();
  assertNotNull(""String_Node_Str"",actualProect);
  assertEquals(""String_Node_Str"",expectedProjectId,actualProect.getId());
  assertEquals(""String_Node_Str"",expectedProjectName,actualProect.getName());
}","@Test public void testProject1(){
  Issue issue67=issuesMap.get(67);
  Integer expectedProjectId=25;
  String expectedProjectName=""String_Node_Str"";
  Project actualProect=issue67.getProject();
  assertNotNull(""String_Node_Str"",actualProect);
  assertEquals(""String_Node_Str"",expectedProjectId,actualProect.getId());
  assertEquals(""String_Node_Str"",expectedProjectName,actualProect.getName());
}",0.6674968866749689
99595,"@Test public void testParentId(){
  Integer childId=18156;
  Integer parentIdExpected=18154;
  Issue child=issuesMap.get(childId);
  assertNotNull(""String_Node_Str"" + childId + ""String_Node_Str"",child);
  assertNotNull(""String_Node_Str"" + childId + ""String_Node_Str"",child.getParentId());
  Integer actualParentId=child.getParentId();
  assertEquals(""String_Node_Str"" + childId + ""String_Node_Str""+ parentIdExpected,parentIdExpected,actualParentId);
  Issue parent=issuesMap.get(actualParentId);
  assertNotNull(""String_Node_Str"" + parentIdExpected + ""String_Node_Str"",parent);
  assertEquals(""String_Node_Str"" + parentIdExpected + ""String_Node_Str"",parentIdExpected,parent.getId());
}","@Test public void testParentId(){
  Integer childId=67;
  Integer parentIdExpected=66;
  Issue child=issuesMap.get(childId);
  assertNotNull(""String_Node_Str"" + childId + ""String_Node_Str"",child);
  assertNotNull(""String_Node_Str"" + childId + ""String_Node_Str"",child.getParentId());
  Integer actualParentId=child.getParentId();
  assertEquals(""String_Node_Str"" + childId + ""String_Node_Str""+ parentIdExpected,parentIdExpected,actualParentId);
  Issue parent=issuesMap.get(actualParentId);
  assertNotNull(""String_Node_Str"" + parentIdExpected + ""String_Node_Str"",parent);
  assertEquals(""String_Node_Str"" + parentIdExpected + ""String_Node_Str"",parentIdExpected,parent.getId());
}",0.9912023460410556
99596,"@Before public void setup() throws Exception {
  String str=MyIOUtils.getResourceAsString(FILE_1_ISSUES_XML_FILE_NAME);
  this.issuesList=RedmineXMLParser.parseIssuesFromXML(str);
  RedmineIssuesMap loader=new RedmineIssuesMap(issuesList);
  issuesMap=loader.getIssuesMap();
}","@Before public void setup() throws Exception {
  String str=MyIOUtils.getResourceAsString(REDMINE_1_1_FILE_1_ISSUES_XML_FILE_NAME);
  this.issuesList=RedmineXMLParser.parseIssuesFromXML(str);
  RedmineIssuesMap loader=new RedmineIssuesMap(issuesList);
  issuesMap=loader.getIssuesMap();
}",0.9787234042553192
99597,"@Test public void testAssignee(){
  Issue issue=issuesMap.get(18156);
  String assigneeNameExpected=""String_Node_Str"";
  Integer assigneeIdExpected=19640;
  User assignee=issue.getAssignee();
  assertNotNull(""String_Node_Str"",assignee);
  assertEquals(""String_Node_Str"",assigneeNameExpected,assignee.getFullName());
  assertEquals(""String_Node_Str"",assigneeIdExpected,assignee.getId());
}","@Test public void testAssignee(){
  Issue issue=issuesMap.get(68);
  String assigneeNameExpected=""String_Node_Str"";
  Integer assigneeIdExpected=1;
  User assignee=issue.getAssignee();
  assertNotNull(""String_Node_Str"",assignee);
  assertEquals(""String_Node_Str"",assigneeNameExpected,assignee.getFullName());
  assertEquals(""String_Node_Str"",assigneeIdExpected,assignee.getId());
}",0.988296488946684
99598,"@Test public void testPriorityTextIsLoaded(){
  Issue issue=issuesMap.get(18156);
  assertEquals(""String_Node_Str"",""String_Node_Str"",issue.getPriorityText());
}","@Test public void testPriorityTextIsLoaded(){
  Issue issue=issuesMap.get(39);
  assertEquals(""String_Node_Str"",""String_Node_Str"",issue.getPriorityText());
}",0.9779179810725552
99599,"@Test public void testNullParentId(){
  Integer childId=17318;
  Issue child=issuesMap.get(childId);
  assertEquals(""String_Node_Str"" + childId + ""String_Node_Str"",null,child.getParentId());
}","@Test public void testNullParentId(){
  Integer childId=66;
  Issue child=issuesMap.get(childId);
  assertEquals(""String_Node_Str"" + childId + ""String_Node_Str"",null,child.getParentId());
}",0.9816272965879264
99600,"public static Issue parseIssueFromXML(String xml) throws RuntimeException {
  Unmarshaller unmarshaller=RedmineXMLParser.getUnmarshaller(RedmineXMLParser.MAPPING_ISSUES,Issue.class);
  Issue issue=null;
  StringReader reader=null;
  try {
    System.err.println(xml);
    reader=new StringReader(xml);
    issue=(Issue)unmarshaller.unmarshal(reader);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    if (reader != null) {
      reader.close();
    }
  }
  return issue;
}","public static Issue parseIssueFromXML(String xml) throws RuntimeException {
  verifyStartsAsXML(xml);
  Unmarshaller unmarshaller=RedmineXMLParser.getUnmarshaller(RedmineXMLParser.MAPPING_ISSUES,Issue.class);
  Issue issue=null;
  StringReader reader=null;
  try {
    System.err.println(xml);
    reader=new StringReader(xml);
    issue=(Issue)unmarshaller.unmarshal(reader);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    if (reader != null) {
      reader.close();
    }
  }
  return issue;
}",0.9744094488188976
99601,"public Issue createIssue(String projectKey,Issue issue) throws IOException, AuthenticationException {
  String query=getCreateIssueURI();
  HttpPost httpPost=new HttpPost(query);
  if (trialMode) {
  }
  String xmlBody=getIssueXML(projectKey,issue);
  setEntity(httpPost,xmlBody);
  return sendRequestExpectResponse(httpPost);
}","public Issue createIssue(String projectKey,Issue issue) throws IOException, AuthenticationException {
  String query=getCreateIssueURI();
  HttpPost httpPost=new HttpPost(query);
  String xmlBody=getIssueXML(projectKey,issue);
  setEntity(httpPost,xmlBody);
  return sendRequestExpectResponse(httpPost);
}",0.9636650868878356
99602,"/** 
 * sample: http://demo.redmine.org/projects/ace/issues.xml?query_id=302
 */
private URL buildGetIssuesByQueryURL(String projectKey,String queryId){
  String charset=""String_Node_Str"";
  URL url=null;
  try {
    String query=String.format(""String_Node_Str"",URLEncoder.encode(projectKey,charset),URLEncoder.encode(queryId,charset));
    if ((apiAccessKey != null) && (!apiAccessKey.isEmpty())) {
      query+=String.format(""String_Node_Str"",URLEncoder.encode(apiAccessKey,charset));
    }
    url=new URL(host + query);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return url;
}","/** 
 * sample: http://demo.redmine.org/projects/ace/issues.xml?query_id=302
 */
private URL buildGetIssuesByQueryURL(String projectKey,String queryId,int offsetIssuesNum){
  String charset=""String_Node_Str"";
  URL url=null;
  try {
    String query=String.format(""String_Node_Str"",URLEncoder.encode(projectKey,charset),URLEncoder.encode(queryId,charset));
    query+=""String_Node_Str"" + offsetIssuesNum;
    query+=""String_Node_Str"" + tasksPerPage;
    if ((apiAccessKey != null) && (!apiAccessKey.isEmpty())) {
      query+=String.format(""String_Node_Str"",URLEncoder.encode(apiAccessKey,charset));
    }
    url=new URL(host + query);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return url;
}",0.9148455162019592
99603,"public List<Issue> getIssues(String projectKey,String queryId) throws IOException, AuthenticationException {
  URL url=buildGetIssuesByQueryURL(projectKey,queryId);
  WebConnector c=new WebConnector();
  StringBuffer response=c.loadData(url);
  System.err.println(response);
  List<Issue> foundIssues=parseIssuesFromXML(response.toString());
  return foundIssues;
}","public List<Issue> getIssues(String projectKey,String queryId) throws IOException, AuthenticationException {
  WebConnector c=new WebConnector();
  List<Issue> allTasks=new ArrayList<Issue>();
  int offsetIssuesNum=0;
  int totalIssuesFoundOnServer=-1;
  int loaded=-1;
  do {
    URL url=buildGetIssuesByQueryURL(projectKey,queryId,offsetIssuesNum);
    StringBuffer responseXML=c.loadData(url);
    System.err.println(responseXML);
    totalIssuesFoundOnServer=parseIssuesTotalCount(responseXML.toString());
    List<Issue> foundIssues=parseIssuesFromXML(responseXML.toString());
    loaded=foundIssues.size();
    System.err.println(""String_Node_Str"" + totalIssuesFoundOnServer + ""String_Node_Str""+ loaded);
    allTasks.addAll(foundIssues);
    offsetIssuesNum+=loaded;
  }
 while (offsetIssuesNum < totalIssuesFoundOnServer);
  return allTasks;
}",0.4967105263157895
99604,"public static String getQueryId(){
  return properties.getProperty(""String_Node_Str"");
}","public static Integer getQueryId(){
  String s=properties.getProperty(""String_Node_Str"");
  return Integer.parseInt(s);
}",0.7655502392344498
99605,"@Test public void testGetIssues(){
  try {
    Issue issueToCreate=new Issue();
    issueToCreate.setSubject(""String_Node_Str"" + new Date());
    Issue newIssue=mgr.createIssue(PROJECT_KEY,issueToCreate);
    String queryIdIssuesCreatedLast2Days=Config.getQueryId();
    List<Issue> issues=mgr.getIssues(PROJECT_KEY,queryIdIssuesCreatedLast2Days);
    System.out.println(""String_Node_Str"" + issues.size() + ""String_Node_Str""+ queryIdIssuesCreatedLast2Days);
    assertTrue(issues.size() > 0);
    boolean found=false;
    for (    Issue issue : issues) {
      if (issue.getId().equals(newIssue.getId())) {
        found=true;
        break;
      }
    }
    if (!found) {
      fail(""String_Node_Str"" + queryIdIssuesCreatedLast2Days + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
}","@Test public void testGetIssues(){
  try {
    Issue issueToCreate=new Issue();
    issueToCreate.setSubject(""String_Node_Str"" + new Date());
    Issue newIssue=mgr.createIssue(PROJECT_KEY,issueToCreate);
    Integer queryIdIssuesCreatedLast2Days=Config.getQueryId();
    List<Issue> issues=mgr.getIssues(PROJECT_KEY,queryIdIssuesCreatedLast2Days);
    System.out.println(""String_Node_Str"" + issues.size() + ""String_Node_Str""+ queryIdIssuesCreatedLast2Days);
    assertTrue(issues.size() > 0);
    boolean found=false;
    for (    Issue issue : issues) {
      if (issue.getId().equals(newIssue.getId())) {
        found=true;
        break;
      }
    }
    if (!found) {
      fail(""String_Node_Str"" + queryIdIssuesCreatedLast2Days + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
}",0.9923394225103124
99606,"private List<Issue> getIssuesV104(String projectKey,String queryId) throws IOException, AuthenticationException {
  WebConnector c=new WebConnector();
  List<Issue> allTasks=new ArrayList<Issue>();
  int loaded=-1;
  int pageNum=1;
  int loadedOnPreviousStep;
  boolean readMore=false;
  do {
    loadedOnPreviousStep=loaded;
    URL url=buildGetIssuesByQueryURLRedmine104(projectKey,queryId,pageNum);
    StringBuffer responseXML=c.loadData(url);
    System.err.println(responseXML);
    List<Issue> foundIssues=parseIssuesFromXML(responseXML.toString());
    loaded=foundIssues.size();
    allTasks.addAll(foundIssues);
    readMore=false;
    if ((pageNum == 1) && loaded == tasksPerPage) {
      readMore=true;
    }
 else     if (loaded == loadedOnPreviousStep) {
      readMore=true;
    }
    pageNum++;
  }
 while (readMore);
  return allTasks;
}","private List<Issue> getIssuesV104(String projectKey,String queryId) throws IOException, AuthenticationException {
  WebConnector c=new WebConnector();
  List<Issue> allTasks=new ArrayList<Issue>();
  final int FIRST_REDMINE_PAGE=1;
  int pageNum=FIRST_REDMINE_PAGE;
  StringBuffer firstPage=null;
  do {
    URL url=buildGetIssuesByQueryURLRedmine104(projectKey,queryId,pageNum);
    StringBuffer responseXML=c.loadData(url);
    String responseXmlString=responseXML.toString();
    System.err.println(responseXmlString);
    if (pageNum == FIRST_REDMINE_PAGE) {
      firstPage=responseXML;
    }
 else {
      if (firstPage.toString().equals(responseXmlString)) {
        break;
      }
    }
    List<Issue> foundIssues=parseIssuesFromXML(responseXmlString);
    allTasks.addAll(foundIssues);
    pageNum++;
  }
 while (true);
  return allTasks;
}",0.5223004694835681
99607,"public List<Issue> getIssuesTrunk(String projectKey,String queryId) throws IOException, AuthenticationException {
  WebConnector c=new WebConnector();
  List<Issue> allTasks=new ArrayList<Issue>();
  int offsetIssuesNum=0;
  int totalIssuesFoundOnServer=UNKNOWN;
  int loaded=-1;
  do {
    URL url=buildGetIssuesByQueryURL(projectKey,queryId,offsetIssuesNum);
    StringBuffer responseXML=c.loadData(url);
    totalIssuesFoundOnServer=parseIssuesTotalCount(responseXML.toString());
    List<Issue> foundIssues=parseIssuesFromXML(responseXML.toString());
    loaded=foundIssues.size();
    allTasks.addAll(foundIssues);
    offsetIssuesNum+=loaded;
    if (totalIssuesFoundOnServer == UNKNOWN) {
      totalIssuesFoundOnServer=loaded;
    }
  }
 while (offsetIssuesNum < totalIssuesFoundOnServer);
  return allTasks;
}","private List<Issue> getIssuesTrunk(String projectKey,String queryId) throws IOException, AuthenticationException {
  WebConnector c=new WebConnector();
  List<Issue> allTasks=new ArrayList<Issue>();
  int offsetIssuesNum=0;
  int totalIssuesFoundOnServer=UNKNOWN;
  int loaded=-1;
  do {
    URL url=buildGetIssuesByQueryURL(projectKey,queryId,offsetIssuesNum);
    StringBuffer responseXML=c.loadData(url);
    totalIssuesFoundOnServer=parseIssuesTotalCount(responseXML.toString());
    List<Issue> foundIssues=parseIssuesFromXML(responseXML.toString());
    loaded=foundIssues.size();
    allTasks.addAll(foundIssues);
    offsetIssuesNum+=loaded;
    if (totalIssuesFoundOnServer == UNKNOWN) {
      totalIssuesFoundOnServer=loaded;
    }
  }
 while (offsetIssuesNum < totalIssuesFoundOnServer);
  return allTasks;
}",0.9932803909590716
99608,"public List<Issue> getIssuesV104(String projectKey,String queryId) throws IOException, AuthenticationException {
  WebConnector c=new WebConnector();
  List<Issue> allTasks=new ArrayList<Issue>();
  int loaded=-1;
  int pageNum=1;
  do {
    URL url=buildGetIssuesByQueryURLRedmine104(projectKey,queryId,pageNum);
    StringBuffer responseXML=c.loadData(url);
    System.err.println(responseXML);
    List<Issue> foundIssues=parseIssuesFromXML(responseXML.toString());
    loaded=foundIssues.size();
    allTasks.addAll(foundIssues);
    pageNum++;
  }
 while (loaded == 25);
  return allTasks;
}","private List<Issue> getIssuesV104(String projectKey,String queryId) throws IOException, AuthenticationException {
  WebConnector c=new WebConnector();
  List<Issue> allTasks=new ArrayList<Issue>();
  int loaded=-1;
  int pageNum=1;
  int loadedOnPreviousStep;
  do {
    loadedOnPreviousStep=loaded;
    URL url=buildGetIssuesByQueryURLRedmine104(projectKey,queryId,pageNum);
    StringBuffer responseXML=c.loadData(url);
    System.err.println(responseXML);
    List<Issue> foundIssues=parseIssuesFromXML(responseXML.toString());
    loaded=foundIssues.size();
    allTasks.addAll(foundIssues);
    pageNum++;
  }
 while (loaded >= loadedOnPreviousStep);
  return allTasks;
}",0.9213836477987422
99609,"public List<Issue> getIssues(String projectKey,String queryId) throws IOException, AuthenticationException {
  if (mode.equals(REDMINE_VERSION.TRUNK)) {
    return getIssuesTrunk(projectKey,queryId);
  }
 else   if (mode.equals(REDMINE_VERSION.V104)) {
    return getIssuesV104(projectKey,queryId);
  }
  throw new RuntimeException(""String_Node_Str"" + mode);
}","public List<Issue> getIssues(String projectKey,String queryId) throws IOException, AuthenticationException {
  return getIssuesV104(projectKey,queryId);
}",0.5992217898832685
99610,"private List<Issue> getIssuesV104(String projectKey,String queryId) throws IOException, AuthenticationException {
  WebConnector c=new WebConnector();
  List<Issue> allTasks=new ArrayList<Issue>();
  int loaded=-1;
  int pageNum=1;
  int loadedOnPreviousStep;
  boolean readMore=false;
  do {
    loadedOnPreviousStep=loaded;
    URL url=buildGetIssuesByQueryURLRedmine104(projectKey,queryId,pageNum);
    StringBuffer responseXML=c.loadData(url);
    System.err.println(responseXML);
    List<Issue> foundIssues=parseIssuesFromXML(responseXML.toString());
    loaded=foundIssues.size();
    allTasks.addAll(foundIssues);
    readMore=false;
    if ((pageNum == 1) && loaded == tasksPerPage) {
      readMore=true;
    }
 else     if (loaded == loadedOnPreviousStep) {
      readMore=true;
    }
    pageNum++;
  }
 while (readMore);
  return allTasks;
}","private List<Issue> getIssuesV104(String projectKey,String queryId) throws IOException, AuthenticationException {
  WebConnector c=new WebConnector();
  List<Issue> allTasks=new ArrayList<Issue>();
  final int FIRST_REDMINE_PAGE=1;
  int pageNum=FIRST_REDMINE_PAGE;
  StringBuffer firstPage=null;
  do {
    URL url=buildGetIssuesByQueryURLRedmine104(projectKey,queryId,pageNum);
    StringBuffer responseXML=c.loadData(url);
    String responseXmlString=responseXML.toString();
    System.err.println(responseXmlString);
    if (pageNum == FIRST_REDMINE_PAGE) {
      firstPage=responseXML;
    }
 else {
      if (firstPage.toString().equals(responseXmlString)) {
        break;
      }
    }
    List<Issue> foundIssues=parseIssuesFromXML(responseXmlString);
    allTasks.addAll(foundIssues);
    pageNum++;
  }
 while (true);
  return allTasks;
}",0.5223004694835681
99611,"public List<Issue> getIssuesTrunk(String projectKey,String queryId) throws IOException, AuthenticationException {
  WebConnector c=new WebConnector();
  List<Issue> allTasks=new ArrayList<Issue>();
  int offsetIssuesNum=0;
  int totalIssuesFoundOnServer=UNKNOWN;
  int loaded=-1;
  do {
    URL url=buildGetIssuesByQueryURL(projectKey,queryId,offsetIssuesNum);
    StringBuffer responseXML=c.loadData(url);
    totalIssuesFoundOnServer=parseIssuesTotalCount(responseXML.toString());
    List<Issue> foundIssues=parseIssuesFromXML(responseXML.toString());
    loaded=foundIssues.size();
    allTasks.addAll(foundIssues);
    offsetIssuesNum+=loaded;
    if (totalIssuesFoundOnServer == UNKNOWN) {
      totalIssuesFoundOnServer=loaded;
    }
  }
 while (offsetIssuesNum < totalIssuesFoundOnServer);
  return allTasks;
}","private List<Issue> getIssuesTrunk(String projectKey,String queryId) throws IOException, AuthenticationException {
  WebConnector c=new WebConnector();
  List<Issue> allTasks=new ArrayList<Issue>();
  int offsetIssuesNum=0;
  int totalIssuesFoundOnServer=UNKNOWN;
  int loaded=-1;
  do {
    URL url=buildGetIssuesByQueryURL(projectKey,queryId,offsetIssuesNum);
    StringBuffer responseXML=c.loadData(url);
    totalIssuesFoundOnServer=parseIssuesTotalCount(responseXML.toString());
    List<Issue> foundIssues=parseIssuesFromXML(responseXML.toString());
    loaded=foundIssues.size();
    allTasks.addAll(foundIssues);
    offsetIssuesNum+=loaded;
    if (totalIssuesFoundOnServer == UNKNOWN) {
      totalIssuesFoundOnServer=loaded;
    }
  }
 while (offsetIssuesNum < totalIssuesFoundOnServer);
  return allTasks;
}",0.9932803909590716
99612,"public List<Issue> getIssuesV104(String projectKey,String queryId) throws IOException, AuthenticationException {
  WebConnector c=new WebConnector();
  List<Issue> allTasks=new ArrayList<Issue>();
  int loaded=-1;
  int pageNum=1;
  do {
    URL url=buildGetIssuesByQueryURLRedmine104(projectKey,queryId,pageNum);
    StringBuffer responseXML=c.loadData(url);
    System.err.println(responseXML);
    List<Issue> foundIssues=parseIssuesFromXML(responseXML.toString());
    loaded=foundIssues.size();
    allTasks.addAll(foundIssues);
    pageNum++;
  }
 while (loaded == 25);
  return allTasks;
}","private List<Issue> getIssuesV104(String projectKey,String queryId) throws IOException, AuthenticationException {
  WebConnector c=new WebConnector();
  List<Issue> allTasks=new ArrayList<Issue>();
  int loaded=-1;
  int pageNum=1;
  int loadedOnPreviousStep;
  do {
    loadedOnPreviousStep=loaded;
    URL url=buildGetIssuesByQueryURLRedmine104(projectKey,queryId,pageNum);
    StringBuffer responseXML=c.loadData(url);
    System.err.println(responseXML);
    List<Issue> foundIssues=parseIssuesFromXML(responseXML.toString());
    loaded=foundIssues.size();
    allTasks.addAll(foundIssues);
    pageNum++;
  }
 while (loaded >= loadedOnPreviousStep);
  return allTasks;
}",0.9213836477987422
99613,"public List<Issue> getIssues(String projectKey,String queryId) throws IOException, AuthenticationException {
  if (mode.equals(REDMINE_VERSION.TRUNK)) {
    return getIssuesTrunk(projectKey,queryId);
  }
 else   if (mode.equals(REDMINE_VERSION.V104)) {
    return getIssuesV104(projectKey,queryId);
  }
  throw new RuntimeException(""String_Node_Str"" + mode);
}","public List<Issue> getIssues(String projectKey,String queryId) throws IOException, AuthenticationException {
  return getIssuesV104(projectKey,queryId);
}",0.5992217898832685
99614,"public Issue createIssue(String projectKey,Issue issue) throws IOException, AuthenticationException {
  String query=getCreateIssueURI();
  HttpPost httpPost=new HttpPost(query);
  if (trialMode) {
  }
  String xmlBody=getIssueXML(projectKey,issue);
  setEntity(httpPost,xmlBody);
  return sendRequestExpectResponse(httpPost);
}","public Issue createIssue(String projectKey,Issue issue) throws IOException, AuthenticationException {
  String query=getCreateIssueURI();
  HttpPost httpPost=new HttpPost(query);
  String xmlBody=getIssueXML(projectKey,issue);
  setEntity(httpPost,xmlBody);
  return sendRequestExpectResponse(httpPost);
}",0.9636650868878356
99615,"/** 
 * sample: http://demo.redmine.org/projects/ace/issues.xml?query_id=302
 */
private URL buildGetIssuesByQueryURL(String projectKey,String queryId){
  String charset=""String_Node_Str"";
  URL url=null;
  try {
    String query=String.format(""String_Node_Str"",URLEncoder.encode(projectKey,charset),URLEncoder.encode(queryId,charset));
    if ((apiAccessKey != null) && (!apiAccessKey.isEmpty())) {
      query+=String.format(""String_Node_Str"",URLEncoder.encode(apiAccessKey,charset));
    }
    url=new URL(host + query);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return url;
}","/** 
 * sample: http://demo.redmine.org/projects/ace/issues.xml?query_id=302
 */
private URL buildGetIssuesByQueryURL(String projectKey,String queryId,int offsetIssuesNum){
  String charset=""String_Node_Str"";
  URL url=null;
  try {
    String query=String.format(""String_Node_Str"",URLEncoder.encode(projectKey,charset),URLEncoder.encode(queryId,charset));
    query+=""String_Node_Str"" + offsetIssuesNum;
    query+=""String_Node_Str"" + tasksPerPage;
    if ((apiAccessKey != null) && (!apiAccessKey.isEmpty())) {
      query+=String.format(""String_Node_Str"",URLEncoder.encode(apiAccessKey,charset));
    }
    url=new URL(host + query);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return url;
}",0.9148455162019592
99616,"public List<Issue> getIssues(String projectKey,String queryId) throws IOException, AuthenticationException {
  URL url=buildGetIssuesByQueryURL(projectKey,queryId);
  WebConnector c=new WebConnector();
  StringBuffer response=c.loadData(url);
  System.err.println(response);
  List<Issue> foundIssues=parseIssuesFromXML(response.toString());
  return foundIssues;
}","public List<Issue> getIssues(String projectKey,String queryId) throws IOException, AuthenticationException {
  WebConnector c=new WebConnector();
  List<Issue> allTasks=new ArrayList<Issue>();
  int offsetIssuesNum=0;
  int totalIssuesFoundOnServer=-1;
  int loaded=-1;
  do {
    URL url=buildGetIssuesByQueryURL(projectKey,queryId,offsetIssuesNum);
    StringBuffer responseXML=c.loadData(url);
    System.err.println(responseXML);
    totalIssuesFoundOnServer=parseIssuesTotalCount(responseXML.toString());
    List<Issue> foundIssues=parseIssuesFromXML(responseXML.toString());
    loaded=foundIssues.size();
    System.err.println(""String_Node_Str"" + totalIssuesFoundOnServer + ""String_Node_Str""+ loaded);
    allTasks.addAll(foundIssues);
    offsetIssuesNum+=loaded;
  }
 while (offsetIssuesNum < totalIssuesFoundOnServer);
  return allTasks;
}",0.4967105263157895
99617,"private int decodeBytecodeInstruction(int index,int stackLen,byte[] stackWords) throws InvalidBytecodeException {
  int opcode=code[index] & 0xFF;
  Instruction i=simpleInstructions[opcode];
  if (i != null) {
    decoded.add(i);
    return index + 1;
  }
  boolean wide=false;
  while (true) {
    index++;
switch (opcode) {
case OP_nop:
      break;
case OP_bipush:
    i=ConstantInstruction.make(code[index]);
  index++;
break;
case OP_sipush:
i=ConstantInstruction.make(decodeShort(index));
index+=2;
break;
case OP_ldc:
i=makeConstantPoolLoad(code[index] & 0xFF);
index++;
break;
case OP_ldc_w:
i=makeConstantPoolLoad(decodeShort(index));
index+=2;
break;
case OP_ldc2_w:
i=makeConstantPoolLoad(decodeShort(index));
index+=2;
break;
case OP_iload:
case OP_lload:
case OP_fload:
case OP_dload:
case OP_aload:
i=LoadInstruction.make(indexedTypes[opcode - OP_iload],wide ? decodeUShort(index) : (code[index] & 0xFF));
index+=wide ? 2 : 1;
break;
case OP_istore:
case OP_lstore:
case OP_fstore:
case OP_dstore:
case OP_astore:
i=StoreInstruction.make(indexedTypes[opcode - OP_istore],wide ? decodeUShort(index) : (code[index] & 0xFF));
index+=wide ? 2 : 1;
break;
case OP_pop2:
i=PopInstruction.make(elemCount(stackWords,stackLen - 1));
break;
case OP_dup_x2:
i=DupInstruction.make(1,elemCount(stackWords,stackLen - 2));
break;
case OP_dup2:
i=DupInstruction.make(elemCount(stackWords,stackLen - 1),0);
break;
case OP_dup2_x1:
i=DupInstruction.make(elemCount(stackWords,stackLen - 1),1);
break;
case OP_dup2_x2:
i=DupInstruction.make(elemCount(stackWords,stackLen - 1),elemCount(stackWords,stackLen - 2));
break;
case OP_iinc:
{
int v=wide ? decodeUShort(index) : (code[index] & 0xFF);
int c=wide ? decodeShort(index + 2) : code[index + 1];
decoded.add(LoadInstruction.make(TYPE_int,v));
decoded.add(ConstantInstruction.make(c));
decoded.add(BinaryOpInstruction.make(TYPE_int,Operator.ADD));
i=StoreInstruction.make(TYPE_int,v);
index+=wide ? 4 : 2;
break;
}
case OP_ifeq:
case OP_ifne:
case OP_iflt:
case OP_ifle:
case OP_ifgt:
case OP_ifge:
decoded.add(makeZero);
i=ConditionalBranchInstruction.make(TYPE_int,ConditionalBranchInstruction.Operator.values()[opcode - OP_ifeq],(index - 1) + decodeShort(index));
index+=2;
break;
case OP_if_icmpeq:
case OP_if_icmpne:
case OP_if_icmplt:
case OP_if_icmple:
case OP_if_icmpgt:
case OP_if_icmpge:
i=ConditionalBranchInstruction.make((short)opcode,(index - 1) + decodeShort(index));
index+=2;
break;
case OP_if_acmpeq:
case OP_if_acmpne:
i=ConditionalBranchInstruction.make(TYPE_Object,ConditionalBranchInstruction.Operator.values()[opcode - OP_if_acmpeq],(index - 1) + decodeShort(index));
index+=2;
break;
case OP_goto:
i=GotoInstruction.make((index - 1) + decodeShort(index));
index+=2;
break;
case OP_jsr:
{
index+=2;
break;
}
case OP_jsr_w:
{
index+=4;
break;
}
case OP_ret:
int v=wide ? decodeUShort(index) : (code[index] & 0xFF);
i=GotoInstruction.make(-1 - v);
if (retInfo == null) {
throw new InvalidBytecodeException(""String_Node_Str"");
}
retInfo[index - (wide ? 2 : 1)]=new RetInfo(-1,v,stackLen,stackWords);
index+=wide ? 2 : 1;
break;
case OP_tableswitch:
{
int start=index - 1;
while ((index & 3) != 0) {
index++;
}
int def=start + decodeInt(index);
int low=decodeInt(index + 4);
int high=decodeInt(index + 8);
int[] t=new int[(high - low + 1) * 2];
for (int j=0; j < t.length; j+=2) {
t[j]=j / 2 + low;
t[j + 1]=start + decodeInt(index + 12 + j * 2);
}
i=SwitchInstruction.make(t,def);
index+=12 + (high - low + 1) * 4;
break;
}
case OP_lookupswitch:
{
int start=index - 1;
while ((index & 3) != 0) {
index++;
}
int def=start + decodeInt(index);
int n=decodeInt(index + 4);
int[] t=new int[n * 2];
for (int j=0; j < t.length; j+=2) {
t[j]=decodeInt(index + 8 + j * 4);
t[j + 1]=start + decodeInt(index + 12 + j * 4);
}
i=SwitchInstruction.make(t,def);
index+=8 + n * 8;
break;
}
case OP_getstatic:
case OP_getfield:
{
int f=decodeUShort(index);
i=GetInstruction.make(constantPool,f,opcode == OP_getstatic);
index+=2;
break;
}
case OP_putstatic:
case OP_putfield:
{
int f=decodeUShort(index);
i=PutInstruction.make(constantPool,f,opcode == OP_putstatic);
index+=2;
break;
}
case OP_invokevirtual:
case OP_invokespecial:
case OP_invokestatic:
{
int m=decodeUShort(index);
i=InvokeInstruction.make(constantPool,m,opcode);
index+=2;
break;
}
case OP_invokeinterface:
{
int m=decodeUShort(index);
i=InvokeInstruction.make(constantPool,m,opcode);
index+=4;
break;
}
case OP_invokedynamic:
{
int m=decodeUShort(index);
i=InvokeDynamicInstruction.make(constantPool,m,opcode);
index+=4;
break;
}
case OP_new:
i=NewInstruction.make(constantPool.getConstantPoolClassType(decodeUShort(index)),0);
index+=2;
break;
case OP_newarray:
i=NewInstruction.make(Util.makeArray(getPrimitiveType(code[index])),1);
index++;
break;
case OP_anewarray:
i=NewInstruction.make(Util.makeArray(constantPool.getConstantPoolClassType(decodeUShort(index))),1);
index+=2;
break;
case OP_checkcast:
i=CheckCastInstruction.make(constantPool.getConstantPoolClassType(decodeUShort(index)));
index+=2;
break;
case OP_instanceof:
i=InstanceofInstruction.make(constantPool.getConstantPoolClassType(decodeUShort(index)));
index+=2;
break;
case OP_wide:
wide=true;
opcode=code[index] & 0xFF;
continue;
case OP_multianewarray:
i=NewInstruction.make(constantPool.getConstantPoolClassType(decodeUShort(index)),code[index + 2] & 0xFF);
index+=3;
break;
case OP_ifnull:
case OP_ifnonnull:
decoded.add(ConstantInstruction.make(TYPE_Object,null));
i=ConditionalBranchInstruction.make(TYPE_Object,ConditionalBranchInstruction.Operator.values()[opcode - OP_ifnull],(index - 1) + decodeShort(index));
index+=2;
break;
case OP_goto_w:
i=GotoInstruction.make((index - 1) + decodeInt(index));
index+=4;
break;
default :
throw new InvalidBytecodeException(""String_Node_Str"" + opcode);
}
break;
}
if (i != null) {
decoded.add(i);
}
return index;
}","private int decodeBytecodeInstruction(int index,int stackLen,byte[] stackWords) throws InvalidBytecodeException {
  int opcode=code[index] & 0xFF;
  Instruction i=simpleInstructions[opcode];
  if (i != null) {
    decoded.add(i);
    return index + 1;
  }
  boolean wide=false;
  while (true) {
    index++;
switch (opcode) {
case OP_nop:
      break;
case OP_bipush:
    i=ConstantInstruction.make(code[index]);
  index++;
break;
case OP_sipush:
i=ConstantInstruction.make(decodeShort(index));
index+=2;
break;
case OP_ldc:
i=makeConstantPoolLoad(code[index] & 0xFF);
index++;
break;
case OP_ldc_w:
i=makeConstantPoolLoad(decodeShort(index));
index+=2;
break;
case OP_ldc2_w:
i=makeConstantPoolLoad(decodeShort(index));
index+=2;
break;
case OP_iload:
case OP_lload:
case OP_fload:
case OP_dload:
case OP_aload:
i=LoadInstruction.make(indexedTypes[opcode - OP_iload],wide ? decodeUShort(index) : (code[index] & 0xFF));
index+=wide ? 2 : 1;
break;
case OP_istore:
case OP_lstore:
case OP_fstore:
case OP_dstore:
case OP_astore:
i=StoreInstruction.make(indexedTypes[opcode - OP_istore],wide ? decodeUShort(index) : (code[index] & 0xFF));
index+=wide ? 2 : 1;
break;
case OP_pop2:
i=PopInstruction.make(elemCount(stackWords,stackLen - 1));
break;
case OP_dup_x2:
i=DupInstruction.make(1,elemCount(stackWords,stackLen - 2));
break;
case OP_dup2:
i=DupInstruction.make(elemCount(stackWords,stackLen - 1),0);
break;
case OP_dup2_x1:
i=DupInstruction.make(elemCount(stackWords,stackLen - 1),1);
break;
case OP_dup2_x2:
{
int twoDown=elemCount(stackWords,stackLen - 1);
i=DupInstruction.make(twoDown,elemCount(stackWords,stackLen - twoDown - 1));
break;
}
case OP_iinc:
{
int v=wide ? decodeUShort(index) : (code[index] & 0xFF);
int c=wide ? decodeShort(index + 2) : code[index + 1];
decoded.add(LoadInstruction.make(TYPE_int,v));
decoded.add(ConstantInstruction.make(c));
decoded.add(BinaryOpInstruction.make(TYPE_int,Operator.ADD));
i=StoreInstruction.make(TYPE_int,v);
index+=wide ? 4 : 2;
break;
}
case OP_ifeq:
case OP_ifne:
case OP_iflt:
case OP_ifle:
case OP_ifgt:
case OP_ifge:
decoded.add(makeZero);
i=ConditionalBranchInstruction.make(TYPE_int,ConditionalBranchInstruction.Operator.values()[opcode - OP_ifeq],(index - 1) + decodeShort(index));
index+=2;
break;
case OP_if_icmpeq:
case OP_if_icmpne:
case OP_if_icmplt:
case OP_if_icmple:
case OP_if_icmpgt:
case OP_if_icmpge:
i=ConditionalBranchInstruction.make((short)opcode,(index - 1) + decodeShort(index));
index+=2;
break;
case OP_if_acmpeq:
case OP_if_acmpne:
i=ConditionalBranchInstruction.make(TYPE_Object,ConditionalBranchInstruction.Operator.values()[opcode - OP_if_acmpeq],(index - 1) + decodeShort(index));
index+=2;
break;
case OP_goto:
i=GotoInstruction.make((index - 1) + decodeShort(index));
index+=2;
break;
case OP_jsr:
{
index+=2;
break;
}
case OP_jsr_w:
{
index+=4;
break;
}
case OP_ret:
int v=wide ? decodeUShort(index) : (code[index] & 0xFF);
i=GotoInstruction.make(-1 - v);
if (retInfo == null) {
throw new InvalidBytecodeException(""String_Node_Str"");
}
retInfo[index - (wide ? 2 : 1)]=new RetInfo(-1,v,stackLen,stackWords);
index+=wide ? 2 : 1;
break;
case OP_tableswitch:
{
int start=index - 1;
while ((index & 3) != 0) {
index++;
}
int def=start + decodeInt(index);
int low=decodeInt(index + 4);
int high=decodeInt(index + 8);
int[] t=new int[(high - low + 1) * 2];
for (int j=0; j < t.length; j+=2) {
t[j]=j / 2 + low;
t[j + 1]=start + decodeInt(index + 12 + j * 2);
}
i=SwitchInstruction.make(t,def);
index+=12 + (high - low + 1) * 4;
break;
}
case OP_lookupswitch:
{
int start=index - 1;
while ((index & 3) != 0) {
index++;
}
int def=start + decodeInt(index);
int n=decodeInt(index + 4);
int[] t=new int[n * 2];
for (int j=0; j < t.length; j+=2) {
t[j]=decodeInt(index + 8 + j * 4);
t[j + 1]=start + decodeInt(index + 12 + j * 4);
}
i=SwitchInstruction.make(t,def);
index+=8 + n * 8;
break;
}
case OP_getstatic:
case OP_getfield:
{
int f=decodeUShort(index);
i=GetInstruction.make(constantPool,f,opcode == OP_getstatic);
index+=2;
break;
}
case OP_putstatic:
case OP_putfield:
{
int f=decodeUShort(index);
i=PutInstruction.make(constantPool,f,opcode == OP_putstatic);
index+=2;
break;
}
case OP_invokevirtual:
case OP_invokespecial:
case OP_invokestatic:
{
int m=decodeUShort(index);
i=InvokeInstruction.make(constantPool,m,opcode);
index+=2;
break;
}
case OP_invokeinterface:
{
int m=decodeUShort(index);
i=InvokeInstruction.make(constantPool,m,opcode);
index+=4;
break;
}
case OP_invokedynamic:
{
int m=decodeUShort(index);
i=InvokeDynamicInstruction.make(constantPool,m,opcode);
index+=4;
break;
}
case OP_new:
i=NewInstruction.make(constantPool.getConstantPoolClassType(decodeUShort(index)),0);
index+=2;
break;
case OP_newarray:
i=NewInstruction.make(Util.makeArray(getPrimitiveType(code[index])),1);
index++;
break;
case OP_anewarray:
i=NewInstruction.make(Util.makeArray(constantPool.getConstantPoolClassType(decodeUShort(index))),1);
index+=2;
break;
case OP_checkcast:
i=CheckCastInstruction.make(constantPool.getConstantPoolClassType(decodeUShort(index)));
index+=2;
break;
case OP_instanceof:
i=InstanceofInstruction.make(constantPool.getConstantPoolClassType(decodeUShort(index)));
index+=2;
break;
case OP_wide:
wide=true;
opcode=code[index] & 0xFF;
continue;
case OP_multianewarray:
i=NewInstruction.make(constantPool.getConstantPoolClassType(decodeUShort(index)),code[index + 2] & 0xFF);
index+=3;
break;
case OP_ifnull:
case OP_ifnonnull:
decoded.add(ConstantInstruction.make(TYPE_Object,null));
i=ConditionalBranchInstruction.make(TYPE_Object,ConditionalBranchInstruction.Operator.values()[opcode - OP_ifnull],(index - 1) + decodeShort(index));
index+=2;
break;
case OP_goto_w:
i=GotoInstruction.make((index - 1) + decodeInt(index));
index+=4;
break;
default :
throw new InvalidBytecodeException(""String_Node_Str"" + opcode);
}
break;
}
if (i != null) {
decoded.add(i);
}
return index;
}",0.9907099633512316
99618,"@Override public IMethod getMethod(Selector selector){
  try {
    computeMethodMapIfNeeded();
  }
 catch (  InvalidClassFileException e1) {
    e1.printStackTrace();
    Assertions.UNREACHABLE();
  }
  IMethod result=methodMap.get(selector);
  if (result != null) {
    return result;
  }
  if (inheritCache != null) {
    result=inheritCache.get(selector);
    if (result != null) {
      return result;
    }
  }
  if (!selector.equals(MethodReference.clinitSelector) && !selector.equals(MethodReference.initSelector)) {
    IClass superclass=getSuperclass();
    if (superclass != null) {
      IMethod inherit=superclass.getMethod(selector);
      if (inherit != null) {
        if (inheritCache == null) {
          inheritCache=new BimodalMap<>(5);
        }
        inheritCache.put(selector,inherit);
        return inherit;
      }
    }
  }
  for (  IClass iface : getAllImplementedInterfaces()) {
    for (    IMethod m : iface.getDeclaredMethods()) {
      if (!m.isAbstract() && m.getSelector().equals(selector)) {
        if (inheritCache == null) {
          inheritCache=new BimodalMap<>(5);
        }
        inheritCache.put(selector,m);
        return m;
      }
    }
  }
  if (inheritCache == null) {
    inheritCache=new BimodalMap<>(5);
  }
  inheritCache.put(selector,null);
  return null;
}","@Override public IMethod getMethod(Selector selector){
  try {
    computeMethodMapIfNeeded();
  }
 catch (  InvalidClassFileException e1) {
    e1.printStackTrace();
    Assertions.UNREACHABLE();
  }
  IMethod result=methodMap.get(selector);
  if (result != null) {
    return result;
  }
  if (inheritCache != null) {
    result=inheritCache.get(selector);
    if (result != null) {
      return result;
    }
  }
  if (!selector.equals(MethodReference.clinitSelector) && !selector.getName().equals(MethodReference.initAtom)) {
    IClass superclass=getSuperclass();
    if (superclass != null) {
      IMethod inherit=superclass.getMethod(selector);
      if (inherit != null) {
        if (inheritCache == null) {
          inheritCache=new BimodalMap<>(5);
        }
        inheritCache.put(selector,inherit);
        return inherit;
      }
    }
  }
  for (  IClass iface : getAllImplementedInterfaces()) {
    for (    IMethod m : iface.getDeclaredMethods()) {
      if (!m.isAbstract() && m.getSelector().equals(selector)) {
        if (inheritCache == null) {
          inheritCache=new BimodalMap<>(5);
        }
        inheritCache.put(selector,m);
        return m;
      }
    }
  }
  if (inheritCache == null) {
    inheritCache=new BimodalMap<>(5);
  }
  inheritCache.put(selector,null);
  return null;
}",0.9916603487490524
99619,"public static void processCallingConstraintsInternal(AstSSAPropagationCallGraphBuilder builder,CGNode caller,SSAAbstractInvokeInstruction instruction,CGNode target,InstanceKey[][] constParams,PointerKey uniqueCatchKey){
  IRView sourceIR=builder.getCFAContextInterpreter().getIRView(caller);
  SymbolTable sourceST=sourceIR.getSymbolTable();
  IRView targetIR=builder.getCFAContextInterpreter().getIRView(target);
  SymbolTable targetST=targetIR.getSymbolTable();
  JSConstraintVisitor targetVisitor=null;
  int av=-1;
  for (int v=0; v <= targetST.getMaxValueNumber(); v++) {
    String[] vns=targetIR.getLocalNames(1,v);
    for (int n=0; vns != null && n < vns.length; n++) {
      if (""String_Node_Str"".equals(vns[n])) {
        av=v;
        targetVisitor=(JSConstraintVisitor)builder.makeVisitor(target);
        break;
      }
    }
  }
  int paramCount=targetST.getParameterValueNumbers().length;
  int argCount=instruction.getNumberOfParameters();
  int num_pseudoargs=2;
  for (int i=0; i < Math.min(paramCount,argCount); i++) {
    InstanceKey[] fn=new InstanceKey[]{builder.getInstanceKeyForConstant(JavaScriptTypes.String,""String_Node_Str"" + (i - num_pseudoargs))};
    PointerKey F=builder.getTargetPointerKey(target,i);
    if (constParams != null && constParams[i] != null) {
      for (int j=0; j < constParams[i].length; j++) {
        builder.getSystem().newConstraint(F,constParams[i][j]);
      }
      if (av != -1 && i >= num_pseudoargs) {
        targetVisitor.newFieldWrite(target,av,fn,constParams[i]);
      }
    }
 else {
      PointerKey A=builder.getPointerKeyForLocal(caller,instruction.getUse(i));
      builder.getSystem().newConstraint(F,(F instanceof FilteredPointerKey) ? builder.filterOperator : assignOperator,A);
      if (av != -1 && i >= num_pseudoargs) {
        targetVisitor.newFieldWrite(target,av,fn,F);
      }
    }
  }
  if (paramCount < argCount) {
    if (av != -1) {
      for (int i=paramCount; i < argCount; i++) {
        InstanceKey[] fn=new InstanceKey[]{builder.getInstanceKeyForConstant(JavaScriptTypes.String,""String_Node_Str"" + (i - num_pseudoargs))};
        if (constParams != null && constParams[i] != null && i >= num_pseudoargs) {
          targetVisitor.newFieldWrite(target,av,fn,constParams[i]);
        }
 else         if (i >= num_pseudoargs) {
          PointerKey A=builder.getPointerKeyForLocal(caller,instruction.getUse(i));
          targetVisitor.newFieldWrite(target,av,fn,A);
        }
      }
    }
  }
 else   if (argCount < paramCount) {
    int nullvn=sourceST.getNullConstant();
    DefUse sourceDU=builder.getCFAContextInterpreter().getDU(caller);
    InstanceKey[] nullkeys=builder.getInvariantContents(sourceST,sourceDU,caller,nullvn,builder);
    for (int i=argCount; i < paramCount; i++) {
      PointerKey F=builder.getPointerKeyForLocal(target,targetST.getParameter(i));
      for (int k=0; k < nullkeys.length; k++) {
        builder.getSystem().newConstraint(F,nullkeys[k]);
      }
    }
  }
  if (av != -1) {
    InstanceKey[] svn=new InstanceKey[]{builder.getInstanceKeyForConstant(JavaScriptTypes.Number,argCount - 1)};
    InstanceKey[] lnv=new InstanceKey[]{builder.getInstanceKeyForConstant(JavaScriptTypes.String,""String_Node_Str"")};
    targetVisitor.newFieldWrite(target,av,lnv,svn);
  }
  if (instruction.getDef(0) != -1) {
    PointerKey RF=builder.getPointerKeyForReturnValue(target);
    PointerKey RA=builder.getPointerKeyForLocal(caller,instruction.getDef(0));
    builder.getSystem().newConstraint(RA,assignOperator,RF);
  }
  PointerKey EF=builder.getPointerKeyForExceptionalReturnValue(target);
  if (SHORT_CIRCUIT_SINGLE_USES && uniqueCatchKey != null) {
    builder.getSystem().newConstraint(uniqueCatchKey,assignOperator,EF);
  }
 else {
    PointerKey EA=builder.getPointerKeyForLocal(caller,instruction.getDef(1));
    builder.getSystem().newConstraint(EA,assignOperator,EF);
  }
}","@SuppressWarnings(""String_Node_Str"") public static void processCallingConstraintsInternal(AstSSAPropagationCallGraphBuilder builder,CGNode caller,SSAAbstractInvokeInstruction instruction,CGNode target,InstanceKey[][] constParams,PointerKey uniqueCatchKey){
  IRView sourceIR=builder.getCFAContextInterpreter().getIRView(caller);
  SymbolTable sourceST=sourceIR.getSymbolTable();
  IRView targetIR=builder.getCFAContextInterpreter().getIRView(target);
  SymbolTable targetST=targetIR.getSymbolTable();
  JSConstraintVisitor targetVisitor=null;
  int av=-1;
  for (int v=0; v <= targetST.getMaxValueNumber(); v++) {
    String[] vns=targetIR.getLocalNames(1,v);
    for (int n=0; vns != null && n < vns.length; n++) {
      if (""String_Node_Str"".equals(vns[n])) {
        av=v;
        targetVisitor=(JSConstraintVisitor)builder.makeVisitor(target);
        break;
      }
    }
  }
  int paramCount=targetST.getParameterValueNumbers().length;
  int argCount=instruction.getNumberOfParameters();
  int num_pseudoargs=2;
  for (int i=0; i < Math.min(paramCount,argCount); i++) {
    InstanceKey[] fn=new InstanceKey[]{builder.getInstanceKeyForConstant(JavaScriptTypes.String,""String_Node_Str"" + (i - num_pseudoargs))};
    PointerKey F=builder.getTargetPointerKey(target,i);
    if (constParams != null && constParams[i] != null) {
      for (int j=0; j < constParams[i].length; j++) {
        builder.getSystem().newConstraint(F,constParams[i][j]);
      }
      if (av != -1 && i >= num_pseudoargs) {
        targetVisitor.newFieldWrite(target,av,fn,constParams[i]);
      }
    }
 else {
      PointerKey A=builder.getPointerKeyForLocal(caller,instruction.getUse(i));
      builder.getSystem().newConstraint(F,(F instanceof FilteredPointerKey) ? builder.filterOperator : assignOperator,A);
      if (av != -1 && i >= num_pseudoargs) {
        targetVisitor.newFieldWrite(target,av,fn,F);
      }
    }
  }
  if (paramCount < argCount) {
    if (av != -1) {
      for (int i=paramCount; i < argCount; i++) {
        InstanceKey[] fn=new InstanceKey[]{builder.getInstanceKeyForConstant(JavaScriptTypes.String,""String_Node_Str"" + (i - num_pseudoargs))};
        if (constParams != null && constParams[i] != null && i >= num_pseudoargs) {
          targetVisitor.newFieldWrite(target,av,fn,constParams[i]);
        }
 else         if (i >= num_pseudoargs) {
          PointerKey A=builder.getPointerKeyForLocal(caller,instruction.getUse(i));
          targetVisitor.newFieldWrite(target,av,fn,A);
        }
      }
    }
  }
 else   if (argCount < paramCount) {
    int nullvn=sourceST.getNullConstant();
    DefUse sourceDU=builder.getCFAContextInterpreter().getDU(caller);
    InstanceKey[] nullkeys=builder.getInvariantContents(sourceST,sourceDU,caller,nullvn,builder);
    for (int i=argCount; i < paramCount; i++) {
      PointerKey F=builder.getPointerKeyForLocal(target,targetST.getParameter(i));
      for (int k=0; k < nullkeys.length; k++) {
        builder.getSystem().newConstraint(F,nullkeys[k]);
      }
    }
  }
  if (av != -1) {
    InstanceKey[] svn=new InstanceKey[]{builder.getInstanceKeyForConstant(JavaScriptTypes.Number,argCount - 1)};
    InstanceKey[] lnv=new InstanceKey[]{builder.getInstanceKeyForConstant(JavaScriptTypes.String,""String_Node_Str"")};
    targetVisitor.newFieldWrite(target,av,lnv,svn);
  }
  if (instruction.getDef(0) != -1) {
    PointerKey RF=builder.getPointerKeyForReturnValue(target);
    PointerKey RA=builder.getPointerKeyForLocal(caller,instruction.getDef(0));
    builder.getSystem().newConstraint(RA,assignOperator,RF);
  }
  PointerKey EF=builder.getPointerKeyForExceptionalReturnValue(target);
  if (SHORT_CIRCUIT_SINGLE_USES && uniqueCatchKey != null) {
    builder.getSystem().newConstraint(uniqueCatchKey,assignOperator,EF);
  }
 else {
    PointerKey EA=builder.getPointerKeyForLocal(caller,instruction.getDef(1));
    builder.getSystem().newConstraint(EA,assignOperator,EF);
  }
}",0.9952776005105296
99620,"/** 
 * Return the Set of (ModuleEntry) source files found in a module.
 * @param M the module
 * @return the Set of source files in the module
 * @throws IOException
 */
private Set<ModuleEntry> getSourceFiles(Module M) throws IOException {
  if (DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + M);
  }
  HashSet<ModuleEntry> result=HashSetFactory.make();
  for (Iterator it=M.getEntries(); it.hasNext(); ) {
    ModuleEntry entry=(ModuleEntry)it.next();
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + entry);
    }
    if (entry.isSourceFile()) {
      if (DEBUG_LEVEL > 0) {
        System.err.println(""String_Node_Str"" + entry);
      }
      result.add(entry);
    }
 else     if (entry.isModuleFile()) {
      result.addAll(getSourceFiles(entry.asModule()));
    }
  }
  return result;
}","/** 
 * Return the Set of (ModuleEntry) source files found in a module.
 * @param M the module
 * @return the Set of source files in the module
 * @throws IOException
 */
@SuppressWarnings(""String_Node_Str"") private Set<ModuleEntry> getSourceFiles(Module M) throws IOException {
  if (DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + M);
  }
  HashSet<ModuleEntry> result=HashSetFactory.make();
  for (Iterator it=M.getEntries(); it.hasNext(); ) {
    ModuleEntry entry=(ModuleEntry)it.next();
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + entry);
    }
    if (entry.isSourceFile()) {
      if (DEBUG_LEVEL > 0) {
        System.err.println(""String_Node_Str"" + entry);
      }
      result.add(entry);
    }
 else     if (entry.isModuleFile()) {
      result.addAll(getSourceFiles(entry.asModule()));
    }
  }
  return result;
}",0.9782480893592004
99621,"@Override public IClass lookupClass(TypeName className){
  if (className == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (DEBUG_LEVEL > 1) {
    System.err.println(this + ""String_Node_Str"" + className);
  }
  if (className.isArrayType()) {
    return arrayClassLoader.lookupClass(className,this,cha);
  }
  IClassLoader parent=getParent();
  if (parent != null) {
    IClass result=parent.lookupClass(className);
    if (result != null) {
      return result;
    }
  }
  IClass result=loadedClasses.get(className);
  return result;
}","@SuppressWarnings(""String_Node_Str"") @Override public IClass lookupClass(TypeName className){
  if (className == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (DEBUG_LEVEL > 1) {
    System.err.println(this + ""String_Node_Str"" + className);
  }
  if (className.isArrayType()) {
    return arrayClassLoader.lookupClass(className,this,cha);
  }
  IClassLoader parent=getParent();
  if (parent != null) {
    IClass result=parent.lookupClass(className);
    if (result != null) {
      return result;
    }
  }
  IClass result=loadedClasses.get(className);
  return result;
}",0.9682947729220224
99622,"@Override public void removeAll(Collection<IClass> toRemove){
  if (toRemove == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (Iterator<IClass> it=toRemove.iterator(); it.hasNext(); ) {
    IClass klass=it.next();
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + klass.getName());
    }
    loadedClasses.remove(klass.getName());
    sourceMap.remove(klass.getName());
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public void removeAll(Collection<IClass> toRemove){
  if (toRemove == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (Iterator<IClass> it=toRemove.iterator(); it.hasNext(); ) {
    IClass klass=it.next();
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + klass.getName());
    }
    loadedClasses.remove(klass.getName());
    sourceMap.remove(klass.getName());
  }
}",0.9585666293393056
99623,"/** 
 * Return the Set of (ModuleEntry) class files found in a module.
 * @param M the module
 * @return the Set of class Files in the module
 * @throws IOException
 */
private Set<ModuleEntry> getClassFiles(Module M) throws IOException {
  if (DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + M);
  }
  HashSet<ModuleEntry> result=HashSetFactory.make();
  for (Iterator it=M.getEntries(); it.hasNext(); ) {
    ModuleEntry entry=(ModuleEntry)it.next();
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + entry);
    }
    if (entry.isClassFile()) {
      if (DEBUG_LEVEL > 0) {
        System.err.println(""String_Node_Str"" + entry);
      }
      result.add(entry);
    }
 else     if (entry.isModuleFile()) {
      Set<ModuleEntry> s=getClassFiles(entry.asModule());
      removeClassFiles(s,result);
      result.addAll(s);
    }
 else {
      if (DEBUG_LEVEL > 0) {
        System.err.println(""String_Node_Str"" + entry);
      }
    }
  }
  return result;
}","/** 
 * Return the Set of (ModuleEntry) class files found in a module.
 * @param M the module
 * @return the Set of class Files in the module
 * @throws IOException
 */
@SuppressWarnings(""String_Node_Str"") private Set<ModuleEntry> getClassFiles(Module M) throws IOException {
  if (DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + M);
  }
  HashSet<ModuleEntry> result=HashSetFactory.make();
  for (Iterator it=M.getEntries(); it.hasNext(); ) {
    ModuleEntry entry=(ModuleEntry)it.next();
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + entry);
    }
    if (entry.isClassFile()) {
      if (DEBUG_LEVEL > 0) {
        System.err.println(""String_Node_Str"" + entry);
      }
      result.add(entry);
    }
 else     if (entry.isModuleFile()) {
      Set<ModuleEntry> s=getClassFiles(entry.asModule());
      removeClassFiles(s,result);
      result.addAll(s);
    }
 else {
      if (DEBUG_LEVEL > 0) {
        System.err.println(""String_Node_Str"" + entry);
      }
    }
  }
  return result;
}",0.9817464232856438
99624,"/** 
 * @param loader class loader reference identifying this loader
 * @param parent parent loader for delegation
 * @param exclusions set of classes to exclude from loading
 */
public ClassLoaderImpl(ClassLoaderReference loader,ArrayClassLoader arrayClassLoader,IClassLoader parent,SetOfClasses exclusions,IClassHierarchy cha){
  if (loader == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.arrayClassLoader=arrayClassLoader;
  this.parent=parent;
  this.loader=loader;
  this.exclusions=exclusions;
  this.cha=cha;
  if (DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + loader);
  }
}","/** 
 * @param loader class loader reference identifying this loader
 * @param parent parent loader for delegation
 * @param exclusions set of classes to exclude from loading
 */
@SuppressWarnings(""String_Node_Str"") public ClassLoaderImpl(ClassLoaderReference loader,ArrayClassLoader arrayClassLoader,IClassLoader parent,SetOfClasses exclusions,IClassHierarchy cha){
  if (loader == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.arrayClassLoader=arrayClassLoader;
  this.parent=parent;
  this.loader=loader;
  this.exclusions=exclusions;
  this.cha=cha;
  if (DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + loader);
  }
}",0.9715165511932256
99625,"/** 
 * Initialize internal data structures
 * @throws IllegalArgumentException if modules is null
 */
@Override public void init(List<Module> modules) throws IOException {
  if (modules == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Set<ModuleEntry> classModuleEntries=HashSetFactory.make();
  Set<ModuleEntry> sourceModuleEntries=HashSetFactory.make();
  for (Iterator<Module> it=modules.iterator(); it.hasNext(); ) {
    Module archive=it.next();
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + archive);
    }
    if (OPTIMIZE_JAR_FILE_IO && archive instanceof JarFileModule) {
      getJarFileContents((JarFileModule)archive);
    }
    Set<ModuleEntry> classFiles=getClassFiles(archive);
    removeClassFiles(classFiles,classModuleEntries);
    Set<ModuleEntry> sourceFiles=getSourceFiles(archive);
    Map<String,Object> allClassAndSourceFileContents=null;
    if (OPTIMIZE_JAR_FILE_IO) {
    }
    loadAllClasses(classFiles,allClassAndSourceFileContents);
    loadAllSources(sourceFiles);
    for (Iterator<ModuleEntry> it2=classFiles.iterator(); it2.hasNext(); ) {
      ModuleEntry file=it2.next();
      classModuleEntries.add(file);
    }
    for (Iterator<ModuleEntry> it2=sourceFiles.iterator(); it2.hasNext(); ) {
      ModuleEntry file=it2.next();
      sourceModuleEntries.add(file);
    }
  }
}","/** 
 * Initialize internal data structures
 * @throws IllegalArgumentException if modules is null
 */
@SuppressWarnings(""String_Node_Str"") @Override public void init(List<Module> modules) throws IOException {
  if (modules == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Set<ModuleEntry> classModuleEntries=HashSetFactory.make();
  Set<ModuleEntry> sourceModuleEntries=HashSetFactory.make();
  for (Iterator<Module> it=modules.iterator(); it.hasNext(); ) {
    Module archive=it.next();
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + archive);
    }
    if (OPTIMIZE_JAR_FILE_IO && archive instanceof JarFileModule) {
      getJarFileContents((JarFileModule)archive);
    }
    Set<ModuleEntry> classFiles=getClassFiles(archive);
    removeClassFiles(classFiles,classModuleEntries);
    Set<ModuleEntry> sourceFiles=getSourceFiles(archive);
    Map<String,Object> allClassAndSourceFileContents=null;
    if (OPTIMIZE_JAR_FILE_IO) {
    }
    loadAllClasses(classFiles,allClassAndSourceFileContents);
    loadAllSources(sourceFiles);
    for (Iterator<ModuleEntry> it2=classFiles.iterator(); it2.hasNext(); ) {
      ModuleEntry file=it2.next();
      classModuleEntries.add(file);
    }
    for (Iterator<ModuleEntry> it2=sourceFiles.iterator(); it2.hasNext(); ) {
      ModuleEntry file=it2.next();
      sourceModuleEntries.add(file);
    }
  }
}",0.986628117094326
99626,"/** 
 * Set up mapping from type name to Module Entry
 */
protected void loadAllSources(Set<ModuleEntry> sourceModules){
  for (Iterator<ModuleEntry> it=sourceModules.iterator(); it.hasNext(); ) {
    ModuleEntry entry=it.next();
    String className=entry.getClassName().replace('.','/');
    className=className.replace(File.separatorChar,'/');
    className=""String_Node_Str"" + ((className.startsWith(""String_Node_Str"")) ? className.substring(1) : className);
    TypeName T=TypeName.string2TypeName(className);
    boolean success=false;
    if (loadedClasses.get(T) != null) {
      if (DEBUG_LEVEL > 0) {
        System.err.println(""String_Node_Str"" + T + ""String_Node_Str""+ entry.getName());
      }
      sourceMap.put(T,entry);
      success=true;
    }
 else {
      while (className.indexOf('/') > 0) {
        className=""String_Node_Str"" + className.substring(className.indexOf('/') + 1,className.length());
        TypeName T2=TypeName.string2TypeName(className);
        if (loadedClasses.get(T2) != null) {
          if (DEBUG_LEVEL > 0) {
            System.err.println(""String_Node_Str"" + T2 + ""String_Node_Str""+ entry.getName());
          }
          sourceMap.put(T2,entry);
          success=true;
          break;
        }
      }
    }
    if (success == false) {
      if (DEBUG_LEVEL > 0) {
        System.err.println(""String_Node_Str"" + T + ""String_Node_Str""+ entry.getName());
      }
      sourceMap.put(T,entry);
    }
  }
}","/** 
 * Set up mapping from type name to Module Entry
 */
@SuppressWarnings(""String_Node_Str"") protected void loadAllSources(Set<ModuleEntry> sourceModules){
  for (Iterator<ModuleEntry> it=sourceModules.iterator(); it.hasNext(); ) {
    ModuleEntry entry=it.next();
    String className=entry.getClassName().replace('.','/');
    className=className.replace(File.separatorChar,'/');
    className=""String_Node_Str"" + ((className.startsWith(""String_Node_Str"")) ? className.substring(1) : className);
    TypeName T=TypeName.string2TypeName(className);
    boolean success=false;
    if (loadedClasses.get(T) != null) {
      if (DEBUG_LEVEL > 0) {
        System.err.println(""String_Node_Str"" + T + ""String_Node_Str""+ entry.getName());
      }
      sourceMap.put(T,entry);
      success=true;
    }
 else {
      while (className.indexOf('/') > 0) {
        className=""String_Node_Str"" + className.substring(className.indexOf('/') + 1,className.length());
        TypeName T2=TypeName.string2TypeName(className);
        if (loadedClasses.get(T2) != null) {
          if (DEBUG_LEVEL > 0) {
            System.err.println(""String_Node_Str"" + T2 + ""String_Node_Str""+ entry.getName());
          }
          sourceMap.put(T2,entry);
          success=true;
          break;
        }
      }
    }
    if (success == false) {
      if (DEBUG_LEVEL > 0) {
        System.err.println(""String_Node_Str"" + T + ""String_Node_Str""+ entry.getName());
      }
      sourceMap.put(T,entry);
    }
  }
}",0.9874363327674024
99627,"/** 
 * Set up the set of classes loaded by this object.
 */
private void loadAllClasses(Collection<ModuleEntry> moduleEntries,Map<String,Object> fileContents){
  for (Iterator<ModuleEntry> it=moduleEntries.iterator(); it.hasNext(); ) {
    ModuleEntry entry=it.next();
    if (!entry.isClassFile()) {
      continue;
    }
    String className=entry.getClassName().replace('.','/');
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + className);
    }
    if (exclusions != null && exclusions.contains(className)) {
      if (DEBUG_LEVEL > 0) {
        System.err.println(""String_Node_Str"" + className);
      }
      continue;
    }
    ShrikeClassReaderHandle entryReader=new ShrikeClassReaderHandle(entry);
    className=""String_Node_Str"" + className;
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + className);
    }
    try {
      TypeName T=TypeName.string2TypeName(className);
      if (loadedClasses.get(T) != null) {
        Warnings.add(MultipleImplementationsWarning.create(className));
      }
 else       if (parent != null && parent.lookupClass(T) != null) {
        Warnings.add(MultipleImplementationsWarning.create(className));
      }
 else {
        ShrikeClassReaderHandle reader=entryReader;
        if (fileContents != null) {
          final Object contents=fileContents.get(entry.getName());
          if (contents != null) {
            reader=new ByteArrayReaderHandle(entry,(byte[])contents);
          }
        }
        ShrikeClass tmpKlass=new ShrikeClass(reader,this,cha);
        if (tmpKlass.getReference().getName().equals(T)) {
          loadedClasses.put(T,new ShrikeClass(entryReader,this,cha));
          if (DEBUG_LEVEL > 1) {
            System.err.println(""String_Node_Str"" + T + ""String_Node_Str"");
          }
        }
 else {
          Warnings.add(InvalidClassFile.create(className));
        }
      }
    }
 catch (    InvalidClassFileException e) {
      if (DEBUG_LEVEL > 0) {
        System.err.println(""String_Node_Str"" + className + ""String_Node_Str"");
      }
      Warnings.add(InvalidClassFile.create(className));
    }
  }
}","/** 
 * Set up the set of classes loaded by this object.
 */
@SuppressWarnings(""String_Node_Str"") private void loadAllClasses(Collection<ModuleEntry> moduleEntries,Map<String,Object> fileContents){
  for (Iterator<ModuleEntry> it=moduleEntries.iterator(); it.hasNext(); ) {
    ModuleEntry entry=it.next();
    if (!entry.isClassFile()) {
      continue;
    }
    String className=entry.getClassName().replace('.','/');
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + className);
    }
    if (exclusions != null && exclusions.contains(className)) {
      if (DEBUG_LEVEL > 0) {
        System.err.println(""String_Node_Str"" + className);
      }
      continue;
    }
    ShrikeClassReaderHandle entryReader=new ShrikeClassReaderHandle(entry);
    className=""String_Node_Str"" + className;
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + className);
    }
    try {
      TypeName T=TypeName.string2TypeName(className);
      if (loadedClasses.get(T) != null) {
        Warnings.add(MultipleImplementationsWarning.create(className));
      }
 else       if (parent != null && parent.lookupClass(T) != null) {
        Warnings.add(MultipleImplementationsWarning.create(className));
      }
 else {
        ShrikeClassReaderHandle reader=entryReader;
        if (fileContents != null) {
          final Object contents=fileContents.get(entry.getName());
          if (contents != null) {
            reader=new ByteArrayReaderHandle(entry,(byte[])contents);
          }
        }
        ShrikeClass tmpKlass=new ShrikeClass(reader,this,cha);
        if (tmpKlass.getReference().getName().equals(T)) {
          loadedClasses.put(T,new ShrikeClass(entryReader,this,cha));
          if (DEBUG_LEVEL > 1) {
            System.err.println(""String_Node_Str"" + T + ""String_Node_Str"");
          }
        }
 else {
          Warnings.add(InvalidClassFile.create(className));
        }
      }
    }
 catch (    InvalidClassFileException e) {
      if (DEBUG_LEVEL > 0) {
        System.err.println(""String_Node_Str"" + className + ""String_Node_Str"");
      }
      Warnings.add(InvalidClassFile.create(className));
    }
  }
}",0.9913853317811409
99628,"/** 
 * get the ""called"" (sic) nodes for a return site; i.e., the exit nodes that flow directly to this return site.
 * @see com.ibm.wala.dataflow.IFDS.ISupergraph#getCalledNodes(java.lang.Object)
 */
@Override public Iterator<T> getCalledNodes(T ret){
  if (DEBUG_LEVEL > 1) {
    System.err.println(getClass() + ""String_Node_Str"" + ret);
    System.err.println(""String_Node_Str"" + Iterator2Collection.toSet(new FilterIterator<Object>(getSuccNodes(ret),exitFilter)));
  }
  return new FilterIterator<T>(getSuccNodes(ret),exitFilter);
}","/** 
 * get the ""called"" (sic) nodes for a return site; i.e., the exit nodes that flow directly to this return site.
 * @see com.ibm.wala.dataflow.IFDS.ISupergraph#getCalledNodes(java.lang.Object)
 */
@SuppressWarnings(""String_Node_Str"") @Override public Iterator<T> getCalledNodes(T ret){
  if (DEBUG_LEVEL > 1) {
    System.err.println(getClass() + ""String_Node_Str"" + ret);
    System.err.println(""String_Node_Str"" + Iterator2Collection.toSet(new FilterIterator<Object>(getSuccNodes(ret),exitFilter)));
  }
  return new FilterIterator<T>(getSuccNodes(ret),exitFilter);
}",0.9666366095581606
99629,"/** 
 * Record that we've discovered a call edge <c,d1> -> <s_p, d2>
 * @param c global number identifying the call site node
 * @param d1 source fact at the call edge
 * @param d2 result fact (result of the call flow function)
 */
public void addCallEdge(int c,int d1,int d2){
  if (TabulationSolver.DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + c + ""String_Node_Str""+ d1+ ""String_Node_Str""+ d2);
  }
  if (d1 == d2) {
    BimodalMutableIntSet s=(BimodalMutableIntSet)identityEdges.get(d1);
    if (s == null) {
      s=new BimodalMutableIntSet();
      identityEdges.set(d1,s);
    }
    s.add(c);
  }
 else {
    IBinaryNaturalRelation R=edges.get(d2);
    if (R == null) {
      R=new BasicNaturalRelation(new byte[]{BasicNaturalRelation.TWO_LEVEL},BasicNaturalRelation.TWO_LEVEL);
      edges.set(d2,R);
    }
    R.add(c,d1);
  }
}","/** 
 * Record that we've discovered a call edge <c,d1> -> <s_p, d2>
 * @param c global number identifying the call site node
 * @param d1 source fact at the call edge
 * @param d2 result fact (result of the call flow function)
 */
@SuppressWarnings(""String_Node_Str"") public void addCallEdge(int c,int d1,int d2){
  if (TabulationSolver.DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + c + ""String_Node_Str""+ d1+ ""String_Node_Str""+ d2);
  }
  if (d1 == d2) {
    BimodalMutableIntSet s=(BimodalMutableIntSet)identityEdges.get(d1);
    if (s == null) {
      s=new BimodalMutableIntSet();
      identityEdges.set(d1,s);
    }
    s.add(c);
  }
 else {
    IBinaryNaturalRelation R=edges.get(d2);
    if (R == null) {
      R=new BasicNaturalRelation(new byte[]{BasicNaturalRelation.TWO_LEVEL},BasicNaturalRelation.TWO_LEVEL);
      edges.set(d2,R);
    }
    R.add(c,d1);
  }
}",0.97877223178428
99630,"/** 
 * @param c
 * @param d2
 * @return set of d1 s.t. {@literal <c, d1> -> <s_p, d2>} was recorded as call flow, or null if none found.
 */
public IntSet getCallFlowSources(int c,int d2){
  if (c < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + c);
  }
  if (d2 < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + d2);
  }
  IntSet s=identityEdges.get(d2);
  IBinaryNaturalRelation R=edges.get(d2);
  IntSet result=null;
  if (R == null) {
    if (s != null) {
      result=s.contains(c) ? SparseIntSet.singleton(d2) : null;
    }
  }
 else {
    if (s == null) {
      result=R.getRelated(c);
    }
 else {
      if (s.contains(c)) {
        if (R.getRelated(c) == null) {
          result=SparseIntSet.singleton(d2);
        }
 else {
          result=MutableSparseIntSet.make(R.getRelated(c));
          ((MutableSparseIntSet)result).add(d2);
        }
      }
 else {
        result=R.getRelated(c);
      }
    }
  }
  if (TabulationSolver.DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + c + ""String_Node_Str""+ d2+ ""String_Node_Str""+ result);
  }
  return result;
}","/** 
 * @param c
 * @param d2
 * @return set of d1 s.t. {@literal <c, d1> -> <s_p, d2>} was recorded as call flow, or null if none found.
 */
@SuppressWarnings(""String_Node_Str"") public IntSet getCallFlowSources(int c,int d2){
  if (c < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + c);
  }
  if (d2 < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + d2);
  }
  IntSet s=identityEdges.get(d2);
  IBinaryNaturalRelation R=edges.get(d2);
  IntSet result=null;
  if (R == null) {
    if (s != null) {
      result=s.contains(c) ? SparseIntSet.singleton(d2) : null;
    }
  }
 else {
    if (s == null) {
      result=R.getRelated(c);
    }
 else {
      if (s.contains(c)) {
        if (R.getRelated(c) == null) {
          result=SparseIntSet.singleton(d2);
        }
 else {
          result=MutableSparseIntSet.make(R.getRelated(c));
          ((MutableSparseIntSet)result).add(d2);
        }
      }
 else {
        result=R.getRelated(c);
      }
    }
  }
  if (TabulationSolver.DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + c + ""String_Node_Str""+ d2+ ""String_Node_Str""+ result);
  }
  return result;
}",0.98370761778952
99631,"/** 
 * @param d2
 * @return set of c s.t. {@literal <c, d1> -> <s_p, d2>} was recorded as call flow (for some d1), or null if none found.
 */
public IntSet getCallFlowSourceNodes(int d2){
  IntSet s=identityEdges.get(d2);
  IBinaryNaturalRelation R=edges.get(d2);
  IntSet result=null;
  if (R == null) {
    if (s != null) {
      result=s;
    }
  }
 else {
    if (s == null) {
      result=getDomain(R);
    }
 else {
      result=MutableSparseIntSet.make(s);
      ((MutableSparseIntSet)result).addAll(getDomain(R));
    }
  }
  if (TabulationSolver.DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + d2 + ""String_Node_Str""+ result);
  }
  return result;
}","/** 
 * @param d2
 * @return set of c s.t. {@literal <c, d1> -> <s_p, d2>} was recorded as call flow (for some d1), or null if none found.
 */
@SuppressWarnings(""String_Node_Str"") public IntSet getCallFlowSourceNodes(int d2){
  IntSet s=identityEdges.get(d2);
  IBinaryNaturalRelation R=edges.get(d2);
  IntSet result=null;
  if (R == null) {
    if (s != null) {
      result=s;
    }
  }
 else {
    if (s == null) {
      result=getDomain(R);
    }
 else {
      result=MutableSparseIntSet.make(s);
      ((MutableSparseIntSet)result).addAll(getDomain(R));
    }
  }
  if (TabulationSolver.DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + d2 + ""String_Node_Str""+ result);
  }
  return result;
}",0.9732465654374548
99632,"/** 
 * Record that in this procedure we've discovered a same-level realizable path from (s_p,0) to (n,d_j)
 * @param n local block number of the basic block n
 * @param j
 */
private void addZeroPathEdge(int n,int j){
  BitVectorIntSet z=(BitVectorIntSet)zeroPaths.get(j);
  if (z == null) {
    z=new BitVectorIntSet();
    zeroPaths.set(j,z);
  }
  z.add(n);
  if (altPaths != null) {
    IBinaryNaturalRelation R=altPaths.get(0);
    if (R == null) {
      R=new BasicNaturalRelation(new byte[]{BasicNaturalRelation.SIMPLE_SPACE_STINGY},BasicNaturalRelation.TWO_LEVEL);
      altPaths.set(0,R);
    }
    R.add(n,j);
  }
  if (TabulationSolver.DEBUG_LEVEL > 1) {
    System.err.println(""String_Node_Str"" + j + ""String_Node_Str""+ z);
  }
}","/** 
 * Record that in this procedure we've discovered a same-level realizable path from (s_p,0) to (n,d_j)
 * @param n local block number of the basic block n
 * @param j
 */
@SuppressWarnings(""String_Node_Str"") private void addZeroPathEdge(int n,int j){
  BitVectorIntSet z=(BitVectorIntSet)zeroPaths.get(j);
  if (z == null) {
    z=new BitVectorIntSet();
    zeroPaths.set(j,z);
  }
  z.add(n);
  if (altPaths != null) {
    IBinaryNaturalRelation R=altPaths.get(0);
    if (R == null) {
      R=new BasicNaturalRelation(new byte[]{BasicNaturalRelation.SIMPLE_SPACE_STINGY},BasicNaturalRelation.TWO_LEVEL);
      altPaths.set(0,R);
    }
    R.add(n,j);
  }
  if (TabulationSolver.DEBUG_LEVEL > 1) {
    System.err.println(""String_Node_Str"" + j + ""String_Node_Str""+ z);
  }
}",0.9756738987508218
99633,"/** 
 * Record that in this procedure we've discovered a same-level realizable path from (s_p,i) to (n,i)
 * @param n local block number of the basic block n
 */
private void addIdentityPathEdge(int i,int n){
  BitVectorIntSet s=(BitVectorIntSet)identityPaths.get(i);
  if (s == null) {
    s=new BitVectorIntSet();
    identityPaths.set(i,s);
  }
  s.add(n);
  if (altPaths != null) {
    IBinaryNaturalRelation R2=altPaths.get(i);
    if (R2 == null) {
      R2=new BasicNaturalRelation(new byte[]{BasicNaturalRelation.SIMPLE_SPACE_STINGY},BasicNaturalRelation.TWO_LEVEL);
      altPaths.set(i,R2);
    }
    R2.add(n,i);
  }
  if (TabulationSolver.DEBUG_LEVEL > 1) {
    System.err.println(""String_Node_Str"" + i + ""String_Node_Str""+ s);
  }
}","/** 
 * Record that in this procedure we've discovered a same-level realizable path from (s_p,i) to (n,i)
 * @param n local block number of the basic block n
 */
@SuppressWarnings(""String_Node_Str"") private void addIdentityPathEdge(int i,int n){
  BitVectorIntSet s=(BitVectorIntSet)identityPaths.get(i);
  if (s == null) {
    s=new BitVectorIntSet();
    identityPaths.set(i,s);
  }
  s.add(n);
  if (altPaths != null) {
    IBinaryNaturalRelation R2=altPaths.get(i);
    if (R2 == null) {
      R2=new BasicNaturalRelation(new byte[]{BasicNaturalRelation.SIMPLE_SPACE_STINGY},BasicNaturalRelation.TWO_LEVEL);
      altPaths.set(i,R2);
    }
    R2.add(n,i);
  }
  if (TabulationSolver.DEBUG_LEVEL > 1) {
    System.err.println(""String_Node_Str"" + i + ""String_Node_Str""+ s);
  }
}",0.9757694826457104
99634,"/** 
 * Record that in this procedure we've discovered a same-level realizable path from (s_p,d_i) to (n,d_j)
 * @param i
 * @param n local block number of the basic block n
 * @param j
 */
public void addPathEdge(int i,int n,int j){
  if (i == 0) {
    addZeroPathEdge(n,j);
  }
 else {
    if (i == j) {
      addIdentityPathEdge(i,n);
    }
 else {
      IBinaryNaturalRelation R=paths.get(j);
      if (R == null) {
        R=new BasicNaturalRelation(new byte[]{BasicNaturalRelation.SIMPLE_SPACE_STINGY},BasicNaturalRelation.TWO_LEVEL);
        paths.set(j,R);
      }
      R.add(n,i);
      if (altPaths != null) {
        IBinaryNaturalRelation R2=altPaths.get(i);
        if (R2 == null) {
          R2=new BasicNaturalRelation(new byte[]{BasicNaturalRelation.SIMPLE_SPACE_STINGY},BasicNaturalRelation.TWO_LEVEL);
          altPaths.set(i,R2);
        }
        R2.add(n,j);
      }
      if (TabulationSolver.DEBUG_LEVEL > 1) {
      }
    }
  }
}","/** 
 * Record that in this procedure we've discovered a same-level realizable path from (s_p,d_i) to (n,d_j)
 * @param i
 * @param n local block number of the basic block n
 * @param j
 */
@SuppressWarnings(""String_Node_Str"") public void addPathEdge(int i,int n,int j){
  if (i == 0) {
    addZeroPathEdge(n,j);
  }
 else {
    if (i == j) {
      addIdentityPathEdge(i,n);
    }
 else {
      IBinaryNaturalRelation R=paths.get(j);
      if (R == null) {
        R=new BasicNaturalRelation(new byte[]{BasicNaturalRelation.SIMPLE_SPACE_STINGY},BasicNaturalRelation.TWO_LEVEL);
        paths.set(j,R);
      }
      R.add(n,i);
      if (altPaths != null) {
        IBinaryNaturalRelation R2=altPaths.get(i);
        if (R2 == null) {
          R2=new BasicNaturalRelation(new byte[]{BasicNaturalRelation.SIMPLE_SPACE_STINGY},BasicNaturalRelation.TWO_LEVEL);
          altPaths.set(i,R2);
        }
        R2.add(n,j);
      }
      if (TabulationSolver.DEBUG_LEVEL > 1) {
      }
    }
  }
}",0.9810159055926116
99635,"/** 
 * Propagate information to a particular return site.
 * @param c the corresponding call site
 * @param entries entry nodes in the caller
 * @param retSite the return site
 * @param d4 a fact s.t. {@literal <c, d4> -> <callee, d2>} wasrecorded as call flow and  {@literal <callee, d2>} is thesource of the summary edge being applied
 * @param D5 facts to propagate to return site
 * @param edge the path edge ending at the exit site of the callee
 */
private void propToReturnSite(final T c,final T[] entries,final T retSite,final int d4,final IntSet D5,final PathEdge<T> edge){
  if (D5 != null) {
    D5.foreach(new IntSetAction(){
      @Override public void act(      final int d5){
        for (int i=0; i < entries.length; i++) {
          final T s_p=entries[i];
          if (DEBUG_LEVEL > 1) {
            System.err.println(""String_Node_Str"" + s_p);
          }
          IntSet D3=getInversePathEdges(s_p,c,d4);
          if (DEBUG_LEVEL > 1) {
            System.err.println(""String_Node_Str"" + D3);
          }
          if (D3 != null) {
            D3.foreach(new IntSetAction(){
              @Override public void act(              int d3){
                curPathEdge=PathEdge.createPathEdge(s_p,d3,c,d4);
                newSummaryEdge(curPathEdge,edge,retSite,d5);
                propagate(s_p,d3,retSite,d5);
              }
            }
);
          }
        }
      }
    }
);
  }
}","/** 
 * Propagate information to a particular return site.
 * @param c the corresponding call site
 * @param entries entry nodes in the caller
 * @param retSite the return site
 * @param d4 a fact s.t. {@literal <c, d4> -> <callee, d2>} wasrecorded as call flow and  {@literal <callee, d2>} is thesource of the summary edge being applied
 * @param D5 facts to propagate to return site
 * @param edge the path edge ending at the exit site of the callee
 */
private void propToReturnSite(final T c,final T[] entries,final T retSite,final int d4,final IntSet D5,final PathEdge<T> edge){
  if (D5 != null) {
    D5.foreach(new IntSetAction(){
      @SuppressWarnings(""String_Node_Str"") @Override public void act(      final int d5){
        for (int i=0; i < entries.length; i++) {
          final T s_p=entries[i];
          if (DEBUG_LEVEL > 1) {
            System.err.println(""String_Node_Str"" + s_p);
          }
          IntSet D3=getInversePathEdges(s_p,c,d4);
          if (DEBUG_LEVEL > 1) {
            System.err.println(""String_Node_Str"" + D3);
          }
          if (D3 != null) {
            D3.foreach(new IntSetAction(){
              @Override public void act(              int d3){
                curPathEdge=PathEdge.createPathEdge(s_p,d3,c,d4);
                newSummaryEdge(curPathEdge,edge,retSite,d5);
                propagate(s_p,d3,retSite,d5);
              }
            }
);
          }
        }
      }
    }
);
  }
}",0.9870764931889626
99636,"/** 
 * Propagate the fact <s_p,i> -> <n, j> has arisen as a path edge. Returns <code>true</code> iff the path edge was not previously observed.
 * @param s_p entry block
 * @param i dataflow fact on entry
 * @param n reached block
 * @param j dataflow fact reached
 */
protected boolean propagate(T s_p,int i,T n,int j){
}","/** 
 * Propagate the fact <s_p,i> -> <n, j> has arisen as a path edge. Returns <code>true</code> iff the path edge was not previously observed.
 * @param s_p entry block
 * @param i dataflow fact on entry
 * @param n reached block
 * @param j dataflow fact reached
 */
@SuppressWarnings(""String_Node_Str"") protected boolean propagate(T s_p,int i,T n,int j){
}",0.945827232796486
99637,"/** 
 * Handle lines [21 - 32] of the algorithm, propagating information from an exit node. Note that we've changed the way we record summary edges. Summary edges are now associated with a callee (s_p,exit), where the original algorithm used a call, return pair in the caller.
 */
protected void processExit(final PathEdge<T> edge){
}","/** 
 * Handle lines [21 - 32] of the algorithm, propagating information from an exit node. Note that we've changed the way we record summary edges. Summary edges are now associated with a callee (s_p,exit), where the original algorithm used a call, return pair in the caller.
 */
@SuppressWarnings(""String_Node_Str"") protected void processExit(final PathEdge<T> edge){
}",0.947517730496454
99638,"/** 
 * See POPL 95 paper for this algorithm, Figure 3
 * @throws CancelException
 */
private void forwardTabulateSLRPs() throws CancelException {
}","/** 
 * See POPL 95 paper for this algorithm, Figure 3
 * @throws CancelException
 */
@SuppressWarnings(""String_Node_Str"") private void forwardTabulateSLRPs() throws CancelException {
}",0.8888888888888888
99639,"/** 
 * @return f(call_d, exit_d);
 */
protected IntSet computeBinaryFlow(int call_d,int exit_d,IBinaryReturnFlowFunction f){
  if (DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + f);
  }
  IntSet result=f.getTargets(call_d,exit_d);
  return result;
}","/** 
 * @return f(call_d, exit_d);
 */
@SuppressWarnings(""String_Node_Str"") protected IntSet computeBinaryFlow(int call_d,int exit_d,IBinaryReturnFlowFunction f){
  if (DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + f);
  }
  IntSet result=f.getTargets(call_d,exit_d);
  return result;
}",0.9347442680776014
99640,"/** 
 * handle a particular callee for some call node.
 * @param edge the path edge being processed
 * @param callNodeNum the number of the call node in the supergraph
 * @param allReturnSites a set collecting return sites for the call. This set is mutated with the return sites for this callee.
 * @param calleeEntry the entry node of the callee in question
 */
protected void processParticularCallee(final PathEdge<T> edge,final int callNodeNum,Collection<T> allReturnSites,final T calleeEntry){
}","/** 
 * handle a particular callee for some call node.
 * @param edge the path edge being processed
 * @param callNodeNum the number of the call node in the supergraph
 * @param allReturnSites a set collecting return sites for the call. This set is mutated with the return sites for this callee.
 * @param calleeEntry the entry node of the callee in question
 */
@SuppressWarnings(""String_Node_Str"") protected void processParticularCallee(final PathEdge<T> edge,final int callNodeNum,Collection<T> allReturnSites,final T calleeEntry){
}",0.9642512077294686
99641,"/** 
 * Propagate information for an ""exit"" edge to the appropriate return sites [23] for each d5 s.t.   {@literal <s_p,d2> -> <returnSite(c),d5>} ..
 * @param edge the edge being processed
 * @param succ numbers of the nodes that are successors of edge.n (the return block in the callee) in the call graph.
 * @param c a call site of edge.s_p
 * @param D4 set of d1 s.t. {@literal <c, d1> -> <edge.s_p, edge.d2>} was recorded as call flow
 */
private void propagateToReturnSites(final PathEdge<T> edge,final T c,final IntSet D4){
  P proc=supergraph.getProcOf(c);
  final T[] entries=supergraph.getEntriesForProcedure(proc);
  for (Iterator<? extends T> retSites=supergraph.getReturnSites(c,supergraph.getProcOf(edge.target)); retSites.hasNext(); ) {
    final T retSite=retSites.next();
    if (DEBUG_LEVEL > 1) {
      System.err.println(""String_Node_Str"" + retSite + ""String_Node_Str""+ supergraph.getNumber(retSite));
    }
    if (!supergraph.hasEdge(edge.target,retSite)) {
      continue;
    }
    if (DEBUG_LEVEL > 1) {
      System.err.println(""String_Node_Str"" + retSite);
    }
    final IFlowFunction retf=flowFunctionMap.getReturnFlowFunction(c,edge.target,retSite);
    if (retf instanceof IBinaryReturnFlowFunction) {
      propagateToReturnSiteWithBinaryFlowFunction(edge,c,D4,entries,retSite,retf);
    }
 else {
      final IntSet D5=computeFlow(edge.d2,(IUnaryFlowFunction)retf);
      if (DEBUG_LEVEL > 1) {
        System.err.println(""String_Node_Str"" + D4);
        System.err.println(""String_Node_Str"" + D5);
      }
      IntSetAction action=new IntSetAction(){
        @Override public void act(        final int d4){
          propToReturnSite(c,entries,retSite,d4,D5,edge);
        }
      }
;
      D4.foreach(action);
    }
  }
}","/** 
 * Propagate information for an ""exit"" edge to the appropriate return sites [23] for each d5 s.t.   {@literal <s_p,d2> -> <returnSite(c),d5>} ..
 * @param edge the edge being processed
 * @param succ numbers of the nodes that are successors of edge.n (the return block in the callee) in the call graph.
 * @param c a call site of edge.s_p
 * @param D4 set of d1 s.t. {@literal <c, d1> -> <edge.s_p, edge.d2>} was recorded as call flow
 */
@SuppressWarnings(""String_Node_Str"") private void propagateToReturnSites(final PathEdge<T> edge,final T c,final IntSet D4){
  P proc=supergraph.getProcOf(c);
  final T[] entries=supergraph.getEntriesForProcedure(proc);
  for (Iterator<? extends T> retSites=supergraph.getReturnSites(c,supergraph.getProcOf(edge.target)); retSites.hasNext(); ) {
    final T retSite=retSites.next();
    if (DEBUG_LEVEL > 1) {
      System.err.println(""String_Node_Str"" + retSite + ""String_Node_Str""+ supergraph.getNumber(retSite));
    }
    if (!supergraph.hasEdge(edge.target,retSite)) {
      continue;
    }
    if (DEBUG_LEVEL > 1) {
      System.err.println(""String_Node_Str"" + retSite);
    }
    final IFlowFunction retf=flowFunctionMap.getReturnFlowFunction(c,edge.target,retSite);
    if (retf instanceof IBinaryReturnFlowFunction) {
      propagateToReturnSiteWithBinaryFlowFunction(edge,c,D4,entries,retSite,retf);
    }
 else {
      final IntSet D5=computeFlow(edge.d2,(IUnaryFlowFunction)retf);
      if (DEBUG_LEVEL > 1) {
        System.err.println(""String_Node_Str"" + D4);
        System.err.println(""String_Node_Str"" + D5);
      }
      IntSetAction action=new IntSetAction(){
        @Override public void act(        final int d4){
          propToReturnSite(c,entries,retSite,d4,D5,edge);
        }
      }
;
      D4.foreach(action);
    }
  }
}",0.9895921237693388
99642,"/** 
 * @return f(d1)
 */
protected IntSet computeFlow(int d1,IUnaryFlowFunction f){
  if (DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + f);
  }
  IntSet result=f.getTargets(d1);
  if (result == null) {
    return null;
  }
 else {
    return result;
  }
}","/** 
 * @return f(d1)
 */
@SuppressWarnings(""String_Node_Str"") protected IntSet computeFlow(int d1,IUnaryFlowFunction f){
  if (DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + f);
  }
  IntSet result=f.getTargets(d1);
  if (result == null) {
    return null;
  }
 else {
    return result;
  }
}",0.93631669535284
99643,"/** 
 * Handle lines [33-37] of the algorithm
 * @param edge
 */
private void processNormal(final PathEdge<T> edge){
  if (DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + edge);
  }
  for (Iterator<? extends T> it=supergraph.getSuccNodes(edge.target); it.hasNext(); ) {
    final T m=it.next();
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + m);
    }
    IUnaryFlowFunction f=flowFunctionMap.getNormalFlowFunction(edge.target,m);
    IntSet D3=computeFlow(edge.d2,f);
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + D3);
    }
    if (D3 != null) {
      D3.foreach(new IntSetAction(){
        @Override public void act(        int d3){
          newNormalExplodedEdge(edge,m,d3);
          propagate(edge.entry,edge.d1,m,d3);
        }
      }
);
    }
  }
}","/** 
 * Handle lines [33-37] of the algorithm
 * @param edge
 */
@SuppressWarnings(""String_Node_Str"") private void processNormal(final PathEdge<T> edge){
  if (DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + edge);
  }
  for (Iterator<? extends T> it=supergraph.getSuccNodes(edge.target); it.hasNext(); ) {
    final T m=it.next();
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + m);
    }
    IUnaryFlowFunction f=flowFunctionMap.getNormalFlowFunction(edge.target,m);
    IntSet D3=computeFlow(edge.d2,f);
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + D3);
    }
    if (D3 != null) {
      D3.foreach(new IntSetAction(){
        @Override public void act(        int d3){
          newNormalExplodedEdge(edge,m,d3);
          propagate(edge.entry,edge.d1,m,d3);
        }
      }
);
    }
  }
}",0.978015448603684
99644,"protected void addToWorkList(T s_p,int i,T n,int j){
  if (worklist == null) {
    worklist=makeWorklist();
  }
  worklist.insert(PathEdge.createPathEdge(s_p,i,n,j));
  if (DEBUG_LEVEL >= 3) {
    System.err.println(""String_Node_Str"" + worklist);
  }
}","@SuppressWarnings(""String_Node_Str"") protected void addToWorkList(T s_p,int i,T n,int j){
  if (worklist == null) {
    worklist=makeWorklist();
  }
  worklist.insert(PathEdge.createPathEdge(s_p,i,n,j));
  if (DEBUG_LEVEL >= 3) {
    System.err.println(""String_Node_Str"" + worklist);
  }
}",0.9316081330868762
99645,"/** 
 * Handle lines [14 - 19] of the algorithm, propagating information into and across a call site.
 */
protected void processCall(final PathEdge<T> edge){
}","/** 
 * Handle lines [14 - 19] of the algorithm, propagating information into and across a call site.
 */
@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) protected void processCall(final PathEdge<T> edge){
}",0.848
99646,"protected boolean addAllToP2Set(Map<PointerKeyAndState,MutableIntSet> p2setMap,PointerKeyAndState pkAndState,IntSet vals,IFlowLabel label){
  final PointerKey pk=pkAndState.getPointerKey();
  if (pk instanceof FilteredPointerKey) {
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + pk);
    }
    final TypeFilter typeFilter=((FilteredPointerKey)pk).getTypeFilter();
    vals=updateValsForFilter(vals,typeFilter);
  }
  if (label instanceof IFlowLabelWithFilter) {
    TypeFilter typeFilter=((IFlowLabelWithFilter)label).getFilter();
    if (typeFilter != null) {
      vals=updateValsForFilter(vals,typeFilter);
    }
  }
  boolean added=findOrCreate(p2setMap,pkAndState).addAll(vals);
  if (DEBUG && added) {
    System.err.println(""String_Node_Str"" + pkAndState + ""String_Node_Str"");
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(vals)) {
      System.err.println(ikAndState);
    }
    System.err.println(""String_Node_Str"");
  }
  return added;
}","@SuppressWarnings(""String_Node_Str"") protected boolean addAllToP2Set(Map<PointerKeyAndState,MutableIntSet> p2setMap,PointerKeyAndState pkAndState,IntSet vals,IFlowLabel label){
  final PointerKey pk=pkAndState.getPointerKey();
  if (pk instanceof FilteredPointerKey) {
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + pk);
    }
    final TypeFilter typeFilter=((FilteredPointerKey)pk).getTypeFilter();
    vals=updateValsForFilter(vals,typeFilter);
  }
  if (label instanceof IFlowLabelWithFilter) {
    TypeFilter typeFilter=((IFlowLabelWithFilter)label).getFilter();
    if (typeFilter != null) {
      vals=updateValsForFilter(vals,typeFilter);
    }
  }
  boolean added=findOrCreate(p2setMap,pkAndState).addAll(vals);
  if (DEBUG && added) {
    System.err.println(""String_Node_Str"" + pkAndState + ""String_Node_Str"");
    for (    InstanceKeyAndState ikAndState : makeOrdinalSet(vals)) {
      System.err.println(ikAndState);
    }
    System.err.println(""String_Node_Str"");
  }
  return added;
}",0.9814163736815672
99647,"private void populate(CGNode n){
  if (ALWAYS_BUILD_IR || n.getMethod().isSynthetic()) {
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    IR ir=n.getIR();
    if (ir == null) {
      return;
    }
    SSAInstruction[] statements=ir.getInstructions();
    SSAMemoryAccessVisitor v=new SSAMemoryAccessVisitor(n);
    for (int i=0; i < statements.length; i++) {
      SSAInstruction s=statements[i];
      if (s != null) {
        v.setInstructionIndex(i);
        s.visit(v);
      }
    }
  }
 else {
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    ShrikeCTMethod sm=(ShrikeCTMethod)n.getMethod();
    MemoryAccessVisitor v=new MemoryAccessVisitor(n.getMethod().getReference().getDeclaringClass().getClassLoader(),n);
    try {
      IInstruction[] statements=sm.getInstructions();
      if (statements == null) {
        return;
      }
      if (DEBUG) {
        for (int i=0; i < statements.length; i++) {
          System.err.println(i + ""String_Node_Str"" + statements[i]);
        }
      }
      for (int i=0; i < statements.length; i++) {
        IInstruction s=statements[i];
        if (s != null) {
          v.setInstructionIndex(i);
          s.visit(v);
        }
      }
    }
 catch (    InvalidClassFileException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
}","@SuppressWarnings(""String_Node_Str"") private void populate(CGNode n){
  if (ALWAYS_BUILD_IR || n.getMethod().isSynthetic()) {
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    IR ir=n.getIR();
    if (ir == null) {
      return;
    }
    SSAInstruction[] statements=ir.getInstructions();
    SSAMemoryAccessVisitor v=new SSAMemoryAccessVisitor(n);
    for (int i=0; i < statements.length; i++) {
      SSAInstruction s=statements[i];
      if (s != null) {
        v.setInstructionIndex(i);
        s.visit(v);
      }
    }
  }
 else {
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    ShrikeCTMethod sm=(ShrikeCTMethod)n.getMethod();
    MemoryAccessVisitor v=new MemoryAccessVisitor(n.getMethod().getReference().getDeclaringClass().getClassLoader(),n);
    try {
      IInstruction[] statements=sm.getInstructions();
      if (statements == null) {
        return;
      }
      if (DEBUG) {
        for (int i=0; i < statements.length; i++) {
          System.err.println(i + ""String_Node_Str"" + statements[i]);
        }
      }
      for (int i=0; i < statements.length; i++) {
        IInstruction s=statements[i];
        if (s != null) {
          v.setInstructionIndex(i);
          s.visit(v);
        }
      }
    }
 catch (    InvalidClassFileException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
}",0.9864815491413956
99648,"/** 
 * Add a module file to the scope for a loader. The classes in the added jar file will override classes added to the scope so far.
 */
public void addToScopeHead(ClassLoaderReference loader,Module m){
  if (m == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  List<Module> s=MapUtil.findOrCreateList(moduleMap,loader);
  if (DEBUG_LEVEL > 0) {
    System.err.println((""String_Node_Str"" + m));
  }
  s.add(0,m);
}","/** 
 * Add a module file to the scope for a loader. The classes in the added jar file will override classes added to the scope so far.
 */
@SuppressWarnings(""String_Node_Str"") public void addToScopeHead(ClassLoaderReference loader,Module m){
  if (m == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  List<Module> s=MapUtil.findOrCreateList(moduleMap,loader);
  if (DEBUG_LEVEL > 0) {
    System.err.println((""String_Node_Str"" + m));
  }
  s.add(0,m);
}",0.9598262757871878
99649,"/** 
 * @param klass a class
 * @return an int set which represents the subset of S that correspond to subtypes of klass
 */
protected IntSet filterForClass(IntSet S,IClass klass){
  MutableIntSet filter=null;
  if (klass.getReference().equals(TypeReference.JavaLangObject)) {
    return S;
  }
 else {
    filter=getMutableInstanceKeysForClass(klass);
    boolean debug=false;
    if (DEBUG_FILTER) {
      String s=""String_Node_Str"" + klass;
      System.err.println(s);
      System.err.println(""String_Node_Str"" + filter);
    }
    filter.intersectWith(S);
    if (DEBUG_FILTER && debug) {
      System.err.println(""String_Node_Str"" + filter);
    }
  }
  return filter;
}","/** 
 * @param klass a class
 * @return an int set which represents the subset of S that correspond to subtypes of klass
 */
@SuppressWarnings(""String_Node_Str"") protected IntSet filterForClass(IntSet S,IClass klass){
  MutableIntSet filter=null;
  if (klass.getReference().equals(TypeReference.JavaLangObject)) {
    return S;
  }
 else {
    filter=getMutableInstanceKeysForClass(klass);
    boolean debug=false;
    if (DEBUG_FILTER) {
      String s=""String_Node_Str"" + klass;
      System.err.println(s);
      System.err.println(""String_Node_Str"" + filter);
    }
    filter.intersectWith(S);
    if (DEBUG_FILTER && debug) {
      System.err.println(""String_Node_Str"" + filter);
    }
  }
  return filter;
}",0.9734004313443566
99650,"/** 
 * If key is unified, returns the representative
 * @param key
 * @return the dataflow variable that tracks the points-to set for key
 */
public PointsToSetVariable findOrCreatePointsToSet(PointerKey key){
  if (key == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (pointsToMap.isImplicit(key)) {
    System.err.println(""String_Node_Str"");
    System.err.println(key);
    Assertions.UNREACHABLE();
  }
  PointsToSetVariable result=pointsToMap.getPointsToSet(key);
  if (result == null) {
    result=new PointsToSetVariable(key);
    pointsToMap.put(key,result);
  }
 else {
    if (!pointsToMap.isUnified(key) && key instanceof FilteredPointerKey) {
      PointerKey pk=result.getPointerKey();
      if (!(pk instanceof FilteredPointerKey)) {
        result.setPointerKey(key);
        pk=key;
      }
      FilteredPointerKey fpk=(FilteredPointerKey)pk;
      if (fpk == null) {
        Assertions.UNREACHABLE(""String_Node_Str"");
      }
      if (key == null) {
        Assertions.UNREACHABLE(""String_Node_Str"");
      }
      if (fpk.getTypeFilter() == null) {
        Assertions.UNREACHABLE(""String_Node_Str"");
      }
      if (!fpk.getTypeFilter().equals(((FilteredPointerKey)key).getTypeFilter())) {
        Assertions.UNREACHABLE(""String_Node_Str"" + ((FilteredPointerKey)key).getTypeFilter() + ""String_Node_Str""+ key+ ""String_Node_Str""+ fpk.getTypeFilter());
      }
    }
  }
  return result;
}","/** 
 * If key is unified, returns the representative
 * @param key
 * @return the dataflow variable that tracks the points-to set for key
 */
public PointsToSetVariable findOrCreatePointsToSet(PointerKey key){
}",0.2568140520896426
99651,"protected void processCallingConstraints(CGNode caller,SSAAbstractInvokeInstruction instruction,CGNode target,InstanceKey[][] constParams,PointerKey uniqueCatchKey){
  int nUses=instruction.getNumberOfParameters();
  int nExpected=target.getMethod().getNumberOfParameters();
  if (nUses != nExpected) {
    return;
  }
  for (int i=0; i < instruction.getNumberOfParameters(); i++) {
    if (target.getMethod().getParameterType(i).isReferenceType()) {
      PointerKey formal=getTargetPointerKey(target,i);
      if (constParams != null && constParams[i] != null) {
        InstanceKey[] ik=constParams[i];
        for (int j=0; j < ik.length; j++) {
          system.newConstraint(formal,ik[j]);
        }
      }
 else {
        if (instruction.getUse(i) < 0) {
          Assertions.UNREACHABLE(""String_Node_Str"" + instruction + ""String_Node_Str""+ caller);
        }
        PointerKey actual=getPointerKeyForLocal(caller,instruction.getUse(i));
        if (formal instanceof FilteredPointerKey) {
          system.newConstraint(formal,filterOperator,actual);
        }
 else {
          system.newConstraint(formal,assignOperator,actual);
        }
      }
    }
  }
  if (instruction.hasDef() && instruction.getDeclaredResultType().isReferenceType()) {
    PointerKey result=getPointerKeyForLocal(caller,instruction.getDef());
    PointerKey ret=getPointerKeyForReturnValue(target);
    system.newConstraint(result,assignOperator,ret);
  }
  PointerKey e=getPointerKeyForLocal(caller,instruction.getException());
  PointerKey er=getPointerKeyForExceptionalReturnValue(target);
  if (SHORT_CIRCUIT_SINGLE_USES && uniqueCatchKey != null) {
    system.newConstraint(uniqueCatchKey,assignOperator,er);
  }
 else {
    system.newConstraint(e,assignOperator,er);
  }
}","@SuppressWarnings(""String_Node_Str"") protected void processCallingConstraints(CGNode caller,SSAAbstractInvokeInstruction instruction,CGNode target,InstanceKey[][] constParams,PointerKey uniqueCatchKey){
  int nUses=instruction.getNumberOfParameters();
  int nExpected=target.getMethod().getNumberOfParameters();
  if (nUses != nExpected) {
    return;
  }
  for (int i=0; i < instruction.getNumberOfParameters(); i++) {
    if (target.getMethod().getParameterType(i).isReferenceType()) {
      PointerKey formal=getTargetPointerKey(target,i);
      if (constParams != null && constParams[i] != null) {
        InstanceKey[] ik=constParams[i];
        for (int j=0; j < ik.length; j++) {
          system.newConstraint(formal,ik[j]);
        }
      }
 else {
        if (instruction.getUse(i) < 0) {
          Assertions.UNREACHABLE(""String_Node_Str"" + instruction + ""String_Node_Str""+ caller);
        }
        PointerKey actual=getPointerKeyForLocal(caller,instruction.getUse(i));
        if (formal instanceof FilteredPointerKey) {
          system.newConstraint(formal,filterOperator,actual);
        }
 else {
          system.newConstraint(formal,assignOperator,actual);
        }
      }
    }
  }
  if (instruction.hasDef() && instruction.getDeclaredResultType().isReferenceType()) {
    PointerKey result=getPointerKeyForLocal(caller,instruction.getDef());
    PointerKey ret=getPointerKeyForReturnValue(target);
    system.newConstraint(result,assignOperator,ret);
  }
  PointerKey e=getPointerKeyForLocal(caller,instruction.getException());
  PointerKey er=getPointerKeyForExceptionalReturnValue(target);
  if (SHORT_CIRCUIT_SINGLE_USES && uniqueCatchKey != null) {
    system.newConstraint(uniqueCatchKey,assignOperator,er);
  }
 else {
    system.newConstraint(e,assignOperator,er);
  }
}",0.9896271376506868
99652,"/** 
 * Generate constraints which assign exception values into an exception pointer
 * @param node governing node
 * @param peis list of PEI instructions
 * @param exceptionVar PointerKey representing a pointer to an exception value
 * @param catchClasses the types ""caught"" by the exceptionVar
 */
private void addExceptionDefConstraints(IRView ir,DefUse du,CGNode node,List<ProgramCounter> peis,PointerKey exceptionVar,Set<IClass> catchClasses){
}","/** 
 * Generate constraints which assign exception values into an exception pointer
 * @param node governing node
 * @param peis list of PEI instructions
 * @param exceptionVar PointerKey representing a pointer to an exception value
 * @param catchClasses the types ""caught"" by the exceptionVar
 */
@SuppressWarnings(""String_Node_Str"") private void addExceptionDefConstraints(IRView ir,DefUse du,CGNode node,List<ProgramCounter> peis,PointerKey exceptionVar,Set<IClass> catchClasses){
}",0.96051227321238
99653,"@Override public byte evaluate(PointsToSetVariable lhs,PointsToSetVariable rhs){
  IntSetVariable receivers=rhs;
  IntSet value=receivers.getValue();
  if (value == null) {
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    return NOT_CHANGED;
  }
  if (DEBUG) {
    String S=""String_Node_Str"" + caller + ""String_Node_Str""+ site;
    System.err.println(S);
    if (DEBUG_LEVEL >= 2) {
      System.err.println((""String_Node_Str"" + value));
    }
  }
  IClass recvClass=getClassHierarchy().lookupClass(site.getDeclaredTarget().getDeclaringClass());
  if (recvClass == null) {
    return NOT_CHANGED;
  }
  value=filterForClass(value,recvClass);
  if (DEBUG_LEVEL >= 2) {
    System.err.println((""String_Node_Str"" + value));
  }
  IntSetAction action=new IntSetAction(){
    @Override public void act(    int ptr){
      if (DEBUG) {
        System.err.println((""String_Node_Str"" + ptr));
      }
      InstanceKey iKey=system.getInstanceKey(ptr);
      CGNode target=getTargetForCall(caller,site,iKey.getConcreteType(),new InstanceKey[]{iKey});
      if (target == null) {
        if (DEBUG) {
          System.err.println((""String_Node_Str"" + site + ""String_Node_Str""+ iKey));
        }
        return;
      }
      if (clone2Assign) {
        if (target.getMethod().getReference().equals(CloneInterpreter.CLONE)) {
          caller.addTarget(site,target);
          return;
        }
      }
      IntSet targets=getCallGraph().getPossibleTargetNumbers(caller,site);
      if (targets != null && targets.contains(target.getGraphNodeId())) {
        return;
      }
      processResolvedCall(caller,site,target);
      if (!haveAlreadyVisited(target)) {
        markDiscovered(target);
      }
    }
  }
;
  value.foreachExcluding(previousReceivers,action);
  previousReceivers.copySet(value);
  return NOT_CHANGED;
}","@SuppressWarnings(""String_Node_Str"") @Override public byte evaluate(PointsToSetVariable lhs,PointsToSetVariable rhs){
  IntSetVariable receivers=rhs;
  IntSet value=receivers.getValue();
  if (value == null) {
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    return NOT_CHANGED;
  }
  if (DEBUG) {
    String S=""String_Node_Str"" + caller + ""String_Node_Str""+ site;
    System.err.println(S);
    if (DEBUG_LEVEL >= 2) {
      System.err.println((""String_Node_Str"" + value));
    }
  }
  IClass recvClass=getClassHierarchy().lookupClass(site.getDeclaredTarget().getDeclaringClass());
  if (recvClass == null) {
    return NOT_CHANGED;
  }
  value=filterForClass(value,recvClass);
  if (DEBUG_LEVEL >= 2) {
    System.err.println((""String_Node_Str"" + value));
  }
  IntSetAction action=new IntSetAction(){
    @Override public void act(    int ptr){
      if (DEBUG) {
        System.err.println((""String_Node_Str"" + ptr));
      }
      InstanceKey iKey=system.getInstanceKey(ptr);
      CGNode target=getTargetForCall(caller,site,iKey.getConcreteType(),new InstanceKey[]{iKey});
      if (target == null) {
        if (DEBUG) {
          System.err.println((""String_Node_Str"" + site + ""String_Node_Str""+ iKey));
        }
        return;
      }
      if (clone2Assign) {
        if (target.getMethod().getReference().equals(CloneInterpreter.CLONE)) {
          caller.addTarget(site,target);
          return;
        }
      }
      IntSet targets=getCallGraph().getPossibleTargetNumbers(caller,site);
      if (targets != null && targets.contains(target.getGraphNodeId())) {
        return;
      }
      processResolvedCall(caller,site,target);
      if (!haveAlreadyVisited(target)) {
        markDiscovered(target);
      }
    }
  }
;
  value.foreachExcluding(previousReceivers,action);
  previousReceivers.copySet(value);
  return NOT_CHANGED;
}",0.9900403768506056
99654,"private void addEntryAndExitEdgesToCaller(CGNode n,T entryBlock,T exitBlock,CGNode caller){
}","@SuppressWarnings(""String_Node_Str"") private void addEntryAndExitEdgesToCaller(CGNode n,T entryBlock,T exitBlock,CGNode caller){
}",0.8340807174887892
99655,"/** 
 * Add an edge from the exit() block of a callee to a return site in the caller
 * @param callBlock the return site for a call
 * @param targetCFG the called method
 */
private void addEdgesFromCallToEntry(CGNode caller,T callBlock,CGNode target,ControlFlowGraph<SSAInstruction,? extends T> targetCFG){
}","/** 
 * Add an edge from the exit() block of a callee to a return site in the caller
 * @param callBlock the return site for a call
 * @param targetCFG the called method
 */
@SuppressWarnings(""String_Node_Str"") private void addEdgesFromCallToEntry(CGNode caller,T callBlock,CGNode target,ControlFlowGraph<SSAInstruction,? extends T> targetCFG){
}",0.9435114503816794
99656,"/** 
 * Add edges to the IPCFG for the incoming edges incident on a basic block bb.
 * @param n a call graph node
 * @param cfg the CFG for n
 * @param instrs the instructions for node n
 * @param bb a basic block in the CFG
 */
protected void addEdgesToNonEntryBlock(CGNode n,ControlFlowGraph<?,T> cfg,SSAInstruction[] instrs,T bb){
}","/** 
 * Add edges to the IPCFG for the incoming edges incident on a basic block bb.
 * @param n a call graph node
 * @param cfg the CFG for n
 * @param instrs the instructions for node n
 * @param bb a basic block in the CFG
 */
@SuppressWarnings(""String_Node_Str"") protected void addEdgesToNonEntryBlock(CGNode n,ControlFlowGraph<?,T> cfg,SSAInstruction[] instrs,T bb){
}",0.9476661951909476
99657,"/** 
 * If n is relevant and its cfg has not already been added, add nodes and edges for n
 * @param n
 */
private void addIntraproceduralNodesAndEdgesForCGNodeIfNeeded(CGNode n){
  if (!cgNodesVisited.contains(cg.getNumber(n)) && relevant.test(n)) {
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + n);
    }
    cgNodesVisited.add(cg.getNumber(n));
    ControlFlowGraph<SSAInstruction,T> cfg=getCFG(n);
    if (cfg != null) {
      addNodeForEachBasicBlock(cfg,n);
      SSAInstruction[] instrs=cfg.getInstructions();
      for (Iterator<T> bbs=cfg.iterator(); bbs.hasNext(); ) {
        T bb=bbs.next();
        if (bb != cfg.entry())         addEdgesToNonEntryBlock(n,cfg,instrs,bb);
      }
    }
  }
}","/** 
 * If n is relevant and its cfg has not already been added, add nodes and edges for n
 * @param n
 */
@SuppressWarnings(""String_Node_Str"") private void addIntraproceduralNodesAndEdgesForCGNodeIfNeeded(CGNode n){
  if (!cgNodesVisited.contains(cg.getNumber(n)) && relevant.test(n)) {
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + n);
    }
    cgNodesVisited.add(cg.getNumber(n));
    ControlFlowGraph<SSAInstruction,T> cfg=getCFG(n);
    if (cfg != null) {
      addNodeForEachBasicBlock(cfg,n);
      SSAInstruction[] instrs=cfg.getInstructions();
      for (Iterator<T> bbs=cfg.iterator(); bbs.hasNext(); ) {
        T bb=bbs.next();
        if (bb != cfg.entry())         addEdgesToNonEntryBlock(n,cfg,instrs,bb);
      }
    }
  }
}",0.9752839011356046
99658,"/** 
 * Add the incoming edges to the entry() block and the outgoing edges from the exit() block for a call graph node.
 * @param n a node in the call graph
 * @param bb the entry() block for n
 */
private void addInterproceduralEdgesForEntryAndExitBlocks(CGNode n,ControlFlowGraph<SSAInstruction,? extends T> cfg){
  T entryBlock=cfg.entry();
  T exitBlock=cfg.exit();
  if (DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + n);
  }
  for (Iterator callers=cg.getPredNodes(n); callers.hasNext(); ) {
    CGNode caller=(CGNode)callers.next();
    if (DEBUG_LEVEL > 1) {
      System.err.println(""String_Node_Str"" + caller);
    }
    if (relevant.test(caller)) {
      addEntryAndExitEdgesToCaller(n,entryBlock,exitBlock,caller);
    }
  }
}","/** 
 * Add the incoming edges to the entry() block and the outgoing edges from the exit() block for a call graph node.
 * @param n a node in the call graph
 * @param bb the entry() block for n
 */
@SuppressWarnings(""String_Node_Str"") private void addInterproceduralEdgesForEntryAndExitBlocks(CGNode n,ControlFlowGraph<SSAInstruction,? extends T> cfg){
  T entryBlock=cfg.entry();
  T exitBlock=cfg.exit();
  if (DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + n);
  }
  for (Iterator callers=cg.getPredNodes(n); callers.hasNext(); ) {
    CGNode caller=(CGNode)callers.next();
    if (DEBUG_LEVEL > 1) {
      System.err.println(""String_Node_Str"" + caller);
    }
    if (relevant.test(caller)) {
      addEntryAndExitEdgesToCaller(n,entryBlock,exitBlock,caller);
    }
  }
}",0.9760207388204796
99659,"/** 
 * Add a node to the IPCFG for each node in a CFG. side effect: populates the hasCallVector
 * @param cfg a control-flow graph
 */
private void addNodeForEachBasicBlock(ControlFlowGraph<? extends SSAInstruction,? extends T> cfg,CGNode N){
  for (Iterator<? extends T> bbs=cfg.iterator(); bbs.hasNext(); ) {
    T bb=bbs.next();
    if (DEBUG_LEVEL > 1) {
      System.err.println(""String_Node_Str"" + bb);
    }
    BasicBlockInContext<T> b=new BasicBlockInContext<T>(N,bb);
    addNodeForBasicBlockIfNeeded(b);
  }
}","/** 
 * Add a node to the IPCFG for each node in a CFG. side effect: populates the hasCallVector
 * @param cfg a control-flow graph
 */
@SuppressWarnings(""String_Node_Str"") private void addNodeForEachBasicBlock(ControlFlowGraph<? extends SSAInstruction,? extends T> cfg,CGNode N){
  for (Iterator<? extends T> bbs=cfg.iterator(); bbs.hasNext(); ) {
    T bb=bbs.next();
    if (DEBUG_LEVEL > 1) {
      System.err.println(""String_Node_Str"" + bb);
    }
    BasicBlockInContext<T> b=new BasicBlockInContext<T>(N,bb);
    addNodeForBasicBlockIfNeeded(b);
  }
}",0.9657089898053752
99660,"/** 
 * Add an edge from the exit() block of a callee to a return site in the caller
 * @param returnBlock the return site for a call
 * @param targetCFG the called method
 */
private void addEdgesFromExitToReturn(CGNode caller,T returnBlock,CGNode target,ControlFlowGraph<SSAInstruction,? extends T> targetCFG){
}","/** 
 * Add an edge from the exit() block of a callee to a return site in the caller
 * @param returnBlock the return site for a call
 * @param targetCFG the called method
 */
@SuppressWarnings(""String_Node_Str"") private void addEdgesFromExitToReturn(CGNode caller,T returnBlock,CGNode target,ControlFlowGraph<SSAInstruction,? extends T> targetCFG){
}",0.9443609022556392
99661,"/** 
 * add edges to callee entry for call block, and edges from callee exit to corresponding return blocks
 */
private void addCalleeEdgesForCall(CGNode n,BasicBlockInContext<T> callBlock){
  int num=g.getNumber(callBlock);
  if (!handledCalls.contains(num)) {
    handledCalls.add(num);
    ControlFlowGraph<SSAInstruction,T> cfg=getCFG(n);
    CallSiteReference site=getCallSiteForCallBlock(callBlock,cfg);
    if (DEBUG_LEVEL > 1) {
      System.err.println(""String_Node_Str"" + site);
    }
    boolean irrelevantTargets=false;
    for (Iterator ts=cg.getPossibleTargets(n,site).iterator(); ts.hasNext(); ) {
      CGNode tn=(CGNode)ts.next();
      if (!relevant.test(tn)) {
        if (DEBUG_LEVEL > 1) {
          System.err.println(""String_Node_Str"" + tn);
        }
        irrelevantTargets=true;
        continue;
      }
      if (DEBUG_LEVEL > 1) {
        System.err.println(""String_Node_Str"" + tn);
      }
      ControlFlowGraph<SSAInstruction,? extends T> tcfg=getCFG(tn);
      if (tcfg != null) {
        final T cbDelegate=callBlock.getDelegate();
        addEdgesFromCallToEntry(n,cbDelegate,tn,tcfg);
        for (Iterator<? extends T> returnBlocks=cfg.getSuccNodes(cbDelegate); returnBlocks.hasNext(); ) {
          T retBlock=returnBlocks.next();
          addEdgesFromExitToReturn(n,retBlock,tn,tcfg);
          if (irrelevantTargets) {
            g.addEdge(callBlock,new BasicBlockInContext<T>(n,retBlock));
          }
        }
      }
    }
  }
}","/** 
 * add edges to callee entry for call block, and edges from callee exit to corresponding return blocks
 */
@SuppressWarnings(""String_Node_Str"") private void addCalleeEdgesForCall(CGNode n,BasicBlockInContext<T> callBlock){
  int num=g.getNumber(callBlock);
  if (!handledCalls.contains(num)) {
    handledCalls.add(num);
    ControlFlowGraph<SSAInstruction,T> cfg=getCFG(n);
    CallSiteReference site=getCallSiteForCallBlock(callBlock,cfg);
    if (DEBUG_LEVEL > 1) {
      System.err.println(""String_Node_Str"" + site);
    }
    boolean irrelevantTargets=false;
    for (Iterator ts=cg.getPossibleTargets(n,site).iterator(); ts.hasNext(); ) {
      CGNode tn=(CGNode)ts.next();
      if (!relevant.test(tn)) {
        if (DEBUG_LEVEL > 1) {
          System.err.println(""String_Node_Str"" + tn);
        }
        irrelevantTargets=true;
        continue;
      }
      if (DEBUG_LEVEL > 1) {
        System.err.println(""String_Node_Str"" + tn);
      }
      ControlFlowGraph<SSAInstruction,? extends T> tcfg=getCFG(tn);
      if (tcfg != null) {
        final T cbDelegate=callBlock.getDelegate();
        addEdgesFromCallToEntry(n,cbDelegate,tn,tcfg);
        for (Iterator<? extends T> returnBlocks=cfg.getSuccNodes(cbDelegate); returnBlocks.hasNext(); ) {
          T retBlock=returnBlocks.next();
          addEdgesFromExitToReturn(n,retBlock,tn,tcfg);
          if (irrelevantTargets) {
            g.addEdge(callBlock,new BasicBlockInContext<T>(n,retBlock));
          }
        }
      }
    }
  }
}",0.9876212780194044
99662,"public SummarizedMethodWithNames(MethodReference ref,VolatileMethodSummary summary,IClass declaringClass) throws NullPointerException {
  super(ref,summary.getMethodSummary(),declaringClass);
  this.summary=summary.getMethodSummary();
  this.localNames=((VolatileMethodSummary)summary).getLocalNames();
  if (DEBUG && this.localNames.isEmpty()) {
    System.err.println(""String_Node_Str"" + ref);
  }
}","@SuppressWarnings(""String_Node_Str"") public SummarizedMethodWithNames(MethodReference ref,VolatileMethodSummary summary,IClass declaringClass) throws NullPointerException {
  super(ref,summary.getMethodSummary(),declaringClass);
  this.summary=summary.getMethodSummary();
  this.localNames=((VolatileMethodSummary)summary).getLocalNames();
  if (DEBUG && this.localNames.isEmpty()) {
    System.err.println(""String_Node_Str"" + ref);
  }
}",0.9558998808104888
99663,"public ExceptionHandler[][] getHandlers() throws InvalidClassFileException {
  if (handlers != null)   return handlers;
  TryItem[] tries=eMethod.codeItem.getTries();
  this.handlers=new ExceptionHandler[instructions().size()][];
  if (tries == null) {
    return handlers;
  }
  ArrayList<ArrayList<ExceptionHandler>> temp_array=new ArrayList<ArrayList<ExceptionHandler>>();
  for (int i=0; i < instructions().size(); i++) {
    temp_array.add(new ArrayList<ExceptionHandler>());
  }
  for (  TryItem tryItem : tries) {
    int startAddress=tryItem.getStartCodeAddress();
    int endAddress=tryItem.getStartCodeAddress() + tryItem.getTryLength();
    int startInst=getInstructionIndex(startAddress);
    int endInst;
    if (endAddress > getAddressFromIndex(instructions().size() - 1)) {
      endInst=instructions().size() - 1;
      if (endAddress != (getAddressFromIndex(endInst) + (eMethod.codeItem.getInstructions())[endInst].getSize(getAddressFromIndex(endInst))))       throw new RuntimeException(""String_Node_Str"" + endAddress + ""String_Node_Str"");
    }
 else {
      endInst=getInstructionIndex(endAddress) - 1;
    }
    int catchAllAddress=tryItem.encodedCatchHandler.getCatchAllHandlerAddress();
    if (catchAllAddress != -1) {
      for (int i=startInst; i <= endInst; i++) {
        temp_array.get(i).add(new ExceptionHandler(getInstructionIndex(catchAllAddress),null));
      }
    }
    for (int i=startInst; i <= endInst; i++) {
      for (      EncodedTypeAddrPair etaps : tryItem.encodedCatchHandler.handlers) {
        temp_array.get(i).add(new ExceptionHandler(getInstructionIndex(etaps.getHandlerAddress()),etaps.exceptionType.getTypeDescriptor()));
      }
    }
  }
  for (int i=0; i < instructions().size(); i++) {
    handlers[i]=(ExceptionHandler[])temp_array.get(i).toArray(new ExceptionHandler[temp_array.get(i).size()]);
  }
  return handlers;
}","public ExceptionHandler[][] getHandlers() throws InvalidClassFileException {
  if (handlers != null)   return handlers;
  TryItem[] tries=eMethod.codeItem.getTries();
  this.handlers=new ExceptionHandler[instructions().size()][];
  if (tries == null) {
    return handlers;
  }
  ArrayList<ArrayList<ExceptionHandler>> temp_array=new ArrayList<ArrayList<ExceptionHandler>>();
  for (int i=0; i < instructions().size(); i++) {
    temp_array.add(new ArrayList<ExceptionHandler>());
  }
  for (  TryItem tryItem : tries) {
    int startAddress=tryItem.getStartCodeAddress();
    int endAddress=tryItem.getStartCodeAddress() + tryItem.getTryLength();
    int startInst=getInstructionIndex(startAddress);
    int endInst;
    if (endAddress > getAddressFromIndex(instructions().size() - 1)) {
      endInst=instructions().size() - 1;
      if (endAddress != (getAddressFromIndex(endInst) + (eMethod.codeItem.getInstructions())[endInst].getSize(getAddressFromIndex(endInst))))       throw new RuntimeException(""String_Node_Str"" + endAddress + ""String_Node_Str"");
    }
 else {
      endInst=getInstructionIndex(endAddress) - 1;
    }
    for (int i=startInst; i <= endInst; i++) {
      for (      EncodedTypeAddrPair etaps : tryItem.encodedCatchHandler.handlers) {
        temp_array.get(i).add(new ExceptionHandler(getInstructionIndex(etaps.getHandlerAddress()),etaps.exceptionType.getTypeDescriptor()));
      }
    }
    int catchAllAddress=tryItem.encodedCatchHandler.getCatchAllHandlerAddress();
    if (catchAllAddress != -1) {
      for (int i=startInst; i <= endInst; i++) {
        temp_array.get(i).add(new ExceptionHandler(getInstructionIndex(catchAllAddress),null));
      }
    }
  }
  for (int i=0; i < instructions().size(); i++) {
    handlers[i]=(ExceptionHandler[])temp_array.get(i).toArray(new ExceptionHandler[temp_array.get(i).size()]);
  }
  return handlers;
}",0.7875399361022364
99664,"/** 
 * Get method of the Model in an other Signature. Generates a new Method that wraps the model so it can be called using the given Signature.  Flags control the behavior of that wrapper. Arguments to the wrapping function are ""connected through"" to the model based on their type only, so if there are multiple Arguments of the same type this may yield to unexpected connections. This method is called by the IntentCoentextInterpreter.
 * @see com.ibm.wala.dalvik.ipa.callgraph.propagation.cfa.IntentContextInterpreter
 * @see com.ibm.wala.dalvik.ipa.callgraph.propagation.cfa.IntentStarters
 * @param asMethod    The signature to generate
 * @param flags       Control the behavior of the wrapper, may be null
 * @param caller      The class of the caller; only needed depending on the flags
 * @param info        The IntentSterter used
 * @param callerNd    CGNoodle of the caller - may be null
 * @return A wrapper that calls the model
 */
public SummarizedMethod getMethodAs(MethodReference asMethod,TypeReference caller,IntentStarters.StartInfo info,CGNode callerNd) throws CancelException {
  Set<StarterFlags> flags=info.getFlags();
  if (!built) {
    getMethod();
  }
  if (asMethod == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (flags == null) {
    flags=Collections.emptySet();
  }
  final TypeSafeInstructionFactory instructionFactory=new TypeSafeInstructionFactory(getClassHierarchy());
  final ParameterAccessor acc=new ParameterAccessor(asMethod,true);
  final SSAValueManager pm=new SSAValueManager(acc);
  if (callerNd != null) {
    pm.breadCrumb=""String_Node_Str"" + caller + ""String_Node_Str""+ callerNd.getContext()+ ""String_Node_Str""+ this.getClass()+ ""String_Node_Str""+ this.getName();
  }
 else {
    pm.breadCrumb=""String_Node_Str"" + caller + ""String_Node_Str""+ this.getClass();
  }
  final VolatileMethodSummary redirect=new VolatileMethodSummary(new MethodSummary(asMethod));
  redirect.setStatic(false);
  final Instantiator instantiator=new Instantiator(redirect,instructionFactory,pm,this.cha,asMethod,this.scope);
  final Parameter self;
{
    self=acc.getThisAs(caller);
    pm.setAllocation(self,null);
  }
  final ParameterAccessor modelAcc=new ParameterAccessor(this.model);
  final List<Parameter> modelsActivities=modelAcc.allExtend(AndroidTypes.ActivityName,getClassHierarchy());
  final List<SSAValue> allActivities=new ArrayList<SSAValue>(modelsActivities.size());
  for (  Parameter activity : modelsActivities) {
    final TypeReference activityType=activity.getType();
    final Parameter inAsMethod=acc.firstOf(activityType);
    if (inAsMethod != null) {
      allActivities.add(inAsMethod);
    }
 else {
      final Atom fdName=activityType.getName().getClassName();
      final AndroidModelClass mClass=AndroidModelClass.getInstance(cha);
      if (AndroidEntryPointManager.MANAGER.doFlatComponents()) {
        if (mClass.getField(fdName) != null) {
          final IField field=mClass.getField(fdName);
          final int instPC=redirect.getNextProgramCounter();
          final SSAValue target=pm.getUnallocated(activityType,new SSAValue.WeaklyNamedKey(activityType.getName(),""String_Node_Str"" + fdName.toString()));
          final SSAInstruction getInst=instructionFactory.GetInstruction(instPC,target,field.getReference());
          redirect.addStatement(getInst);
          pm.setAllocation(target,getInst);
          allActivities.add(target);
        }
 else {
          final SSAValue newInstance=instantiator.createInstance(activityType,false,null,null);
          allActivities.add(newInstance);
          mClass.putField(fdName,activityType);
          final int instPC=redirect.getNextProgramCounter();
          final FieldReference fdRef=FieldReference.findOrCreate(mClass.getReference(),fdName,activityType);
          final SSAInstruction putInst=instructionFactory.PutInstruction(instPC,newInstance,fdRef);
          redirect.addStatement(putInst);
          System.out.println(""String_Node_Str"" + newInstance);
        }
      }
 else {
        final SSAValue newInstance=instantiator.createInstance(activityType,false,null,null);
        allActivities.add(newInstance);
      }
    }
  }
  assert(allActivities.size() == modelsActivities.size());
  final Set<SSAValue> defaults=new HashSet<SSAValue>();
{
    final SSAValue nullBundle=pm.getUnmanaged(AndroidTypes.Bundle,""String_Node_Str"");
    redirect.addConstant(nullBundle.getNumber(),new ConstantValue(null));
    nullBundle.setAssigned();
    defaults.add(nullBundle);
  }
{
    final TypeName intentArray=TypeName.findOrCreate(""String_Node_Str"");
    final SSAValue incoming=acc.firstOf(intentArray);
    if (incoming != null) {
      final VariableKey unpackedIntentKey=new WeaklyNamedKey(AndroidTypes.IntentName,""String_Node_Str"");
      final SSAValue unpackedIntent=pm.getUnallocated(AndroidTypes.Intent,unpackedIntentKey);
      final int pc=redirect.getNextProgramCounter();
      final SSAInstruction fetch=instructionFactory.ArrayLoadInstruction(pc,unpackedIntent,incoming,0);
      redirect.addStatement(fetch);
      pm.setAllocation(unpackedIntent,fetch);
      defaults.add(unpackedIntent);
    }
  }
  final SSAValue intent=acc.firstExtends(AndroidTypes.Intent,cha);
  final AndroidStartComponentTool tool=new AndroidStartComponentTool(getClassHierarchy(),asMethod,flags,caller,instructionFactory,acc,pm,redirect,self,info,callerNd);
  final AndroidTypes.AndroidContextType contextType;
  final SSAValue androidContext;
  androidContext=tool.fetchCallerContext();
  contextType=tool.typeOfCallerContext();
  try {
    if (intent != null) {
      tool.setIntent(intent,allActivities);
    }
 else     if (!info.isSystemService()) {
    }
{
      final List<SSAValue> redirectParams=acc.connectThrough(modelAcc,new HashSet<SSAValue>(allActivities),defaults,getClassHierarchy(),instantiator,false,null,null);
      final int callPC=redirect.getNextProgramCounter();
      final CallSiteReference site=CallSiteReference.make(callPC,this.model.getReference(),IInvokeInstruction.Dispatch.STATIC);
      final SSAAbstractInvokeInstruction invokation;
      final SSAValue exception=pm.getException();
      if (this.model.getReference().getReturnType().equals(TypeReference.Void)) {
        invokation=instructionFactory.InvokeInstruction(callPC,redirectParams,exception,site);
      }
 else {
        if (this instanceof SystemServiceModel) {
          final SSAValue svc=pm.getUnmanaged(TypeReference.JavaLangObject,""String_Node_Str"");
          invokation=instructionFactory.InvokeInstruction(callPC,svc,redirectParams,exception,site);
          redirect.addStatement(invokation);
          if (instructionFactory.isAssignableFrom(svc.getType(),svc.getValidIn().getReturnType())) {
            final int returnPC=redirect.getNextProgramCounter();
            final SSAInstruction returnInstruction=instructionFactory.ReturnInstruction(returnPC,svc);
            redirect.addStatement(returnInstruction);
          }
          final IClass declaringClass=this.cha.lookupClass(asMethod.getDeclaringClass());
          if (declaringClass == null) {
            throw new IllegalStateException(""String_Node_Str"" + asMethod.getDeclaringClass() + ""String_Node_Str""+ ""String_Node_Str""+ asMethod.toString());
          }
          redirect.setLocalNames(pm.makeLocalNames());
          SummarizedMethod override=new SummarizedMethodWithNames(mRef,redirect,declaringClass);
          return override;
        }
 else         if (this instanceof ExternalModel) {
          final SSAValue trash=pm.getUnmanaged(AndroidTypes.Intent,""String_Node_Str"");
          invokation=instructionFactory.InvokeInstruction(callPC,trash,redirectParams,exception,site);
        }
 else {
          throw new UnsupportedOperationException(""String_Node_Str"" + this.model.getClass());
        }
      }
      redirect.addStatement(invokation);
    }
    if (flags.contains(StarterFlags.CALL_ON_ACTIVITY_RESULT) && (!flags.contains(StarterFlags.CONTEXT_FREE))) {
      final List<SSAValue> resultCodes=new ArrayList<SSAValue>();
      final List<SSAValue> resultData=new ArrayList<SSAValue>();
      final SSAValue mResultCode;
      final SSAValue mResultData;
      tool.fetchResults(resultCodes,resultData,allActivities);
      if (resultCodes.size() == 0) {
        throw new IllegalStateException(""String_Node_Str"" + asMethod + ""String_Node_Str""+ caller+ ""String_Node_Str""+ this.model+ ""String_Node_Str"");
      }
      mResultCode=tool.addPhi(resultCodes);
      mResultData=tool.addPhi(resultData);
{
        final SSAValue outRequestCode=acc.firstOf(TypeReference.Int);
        final int callPC=redirect.getNextProgramCounter();
        final Selector mSel=Selector.make(""String_Node_Str"");
        final MethodReference mRef=MethodReference.findOrCreate(caller,mSel);
        final CallSiteReference site=CallSiteReference.make(callPC,mRef,IInvokeInstruction.Dispatch.VIRTUAL);
        final SSAValue exception=pm.getException();
        final List<SSAValue> params=new ArrayList<SSAValue>();
        params.add(self);
        params.add(outRequestCode);
        params.add(mResultCode);
        params.add(mResultData);
        final SSAInstruction invokation=instructionFactory.InvokeInstruction(callPC,params,exception,site);
        redirect.addStatement(invokation);
      }
    }
    final IClass declaringClass=this.cha.lookupClass(asMethod.getDeclaringClass());
    if (declaringClass == null) {
      throw new IllegalStateException(""String_Node_Str"" + asMethod.getDeclaringClass() + ""String_Node_Str""+ ""String_Node_Str""+ asMethod.toString());
    }
    redirect.setLocalNames(pm.makeLocalNames());
    SummarizedMethod override=new SummarizedMethodWithNames(mRef,redirect,declaringClass);
    return override;
  }
 catch (  Exception e) {
    e.printStackTrace();
    System.err.println(""String_Node_Str"");
    System.err.println(acc.dump());
    System.err.println(""String_Node_Str"" + pm);
    System.err.println(""String_Node_Str"" + self);
    System.err.println(""String_Node_Str"" + acc.dump());
    System.err.println(""String_Node_Str"" + contextType);
    System.err.println(""String_Node_Str"" + androidContext);
    System.err.println(""String_Node_Str"" + asMethod);
    System.err.println(""String_Node_Str"" + caller);
    System.err.println(""String_Node_Str"" + info);
    System.err.println(""String_Node_Str"" + callerNd);
    System.err.println(""String_Node_Str"" + this.getClass().toString());
    System.err.println(""String_Node_Str"" + this.name);
    throw new IllegalStateException(e);
  }
}","/** 
 * Get method of the Model in an other Signature. Generates a new Method that wraps the model so it can be called using the given Signature.  Flags control the behavior of that wrapper. Arguments to the wrapping function are ""connected through"" to the model based on their type only, so if there are multiple Arguments of the same type this may yield to unexpected connections. This method is called by the IntentCoentextInterpreter.
 * @see com.ibm.wala.dalvik.ipa.callgraph.propagation.cfa.IntentContextInterpreter
 * @see com.ibm.wala.dalvik.ipa.callgraph.propagation.cfa.IntentStarters
 * @param asMethod    The signature to generate
 * @param flags       Control the behavior of the wrapper, may be null
 * @param caller      The class of the caller; only needed depending on the flags
 * @param info        The IntentSterter used
 * @param callerNd    CGNoodle of the caller - may be null
 * @return A wrapper that calls the model
 */
public SummarizedMethod getMethodAs(MethodReference asMethod,TypeReference caller,IntentStarters.StartInfo info,CGNode callerNd) throws CancelException {
  Set<StarterFlags> flags=null;
  if (info != null) {
    flags=info.getFlags();
  }
  if (!built) {
    getMethod();
  }
  if (asMethod == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (flags == null) {
    flags=Collections.emptySet();
  }
  final TypeSafeInstructionFactory instructionFactory=new TypeSafeInstructionFactory(getClassHierarchy());
  final ParameterAccessor acc=new ParameterAccessor(asMethod,true);
  final SSAValueManager pm=new SSAValueManager(acc);
  if (callerNd != null) {
    pm.breadCrumb=""String_Node_Str"" + caller + ""String_Node_Str""+ callerNd.getContext()+ ""String_Node_Str""+ this.getClass()+ ""String_Node_Str""+ this.getName();
  }
 else {
    pm.breadCrumb=""String_Node_Str"" + caller + ""String_Node_Str""+ this.getClass();
  }
  final VolatileMethodSummary redirect=new VolatileMethodSummary(new MethodSummary(asMethod));
  redirect.setStatic(false);
  final Instantiator instantiator=new Instantiator(redirect,instructionFactory,pm,this.cha,asMethod,this.scope);
  final Parameter self;
{
    self=acc.getThisAs(caller);
    pm.setAllocation(self,null);
  }
  final ParameterAccessor modelAcc=new ParameterAccessor(this.model);
  final List<Parameter> modelsActivities=modelAcc.allExtend(AndroidTypes.ActivityName,getClassHierarchy());
  final List<SSAValue> allActivities=new ArrayList<SSAValue>(modelsActivities.size());
  for (  Parameter activity : modelsActivities) {
    final TypeReference activityType=activity.getType();
    final Parameter inAsMethod=acc.firstOf(activityType);
    if (inAsMethod != null) {
      allActivities.add(inAsMethod);
    }
 else {
      final Atom fdName=activityType.getName().getClassName();
      final AndroidModelClass mClass=AndroidModelClass.getInstance(cha);
      if (AndroidEntryPointManager.MANAGER.doFlatComponents()) {
        if (mClass.getField(fdName) != null) {
          final IField field=mClass.getField(fdName);
          final int instPC=redirect.getNextProgramCounter();
          final SSAValue target=pm.getUnallocated(activityType,new SSAValue.WeaklyNamedKey(activityType.getName(),""String_Node_Str"" + fdName.toString()));
          final SSAInstruction getInst=instructionFactory.GetInstruction(instPC,target,field.getReference());
          redirect.addStatement(getInst);
          pm.setAllocation(target,getInst);
          allActivities.add(target);
        }
 else {
          final SSAValue newInstance=instantiator.createInstance(activityType,false,null,null);
          allActivities.add(newInstance);
          mClass.putField(fdName,activityType);
          final int instPC=redirect.getNextProgramCounter();
          final FieldReference fdRef=FieldReference.findOrCreate(mClass.getReference(),fdName,activityType);
          final SSAInstruction putInst=instructionFactory.PutInstruction(instPC,newInstance,fdRef);
          redirect.addStatement(putInst);
          System.out.println(""String_Node_Str"" + newInstance);
        }
      }
 else {
        final SSAValue newInstance=instantiator.createInstance(activityType,false,null,null);
        allActivities.add(newInstance);
      }
    }
  }
  assert(allActivities.size() == modelsActivities.size());
  final Set<SSAValue> defaults=new HashSet<SSAValue>();
{
    final SSAValue nullBundle=pm.getUnmanaged(AndroidTypes.Bundle,""String_Node_Str"");
    redirect.addConstant(nullBundle.getNumber(),new ConstantValue(null));
    nullBundle.setAssigned();
    defaults.add(nullBundle);
  }
{
    final TypeName intentArray=TypeName.findOrCreate(""String_Node_Str"");
    final SSAValue incoming=acc.firstOf(intentArray);
    if (incoming != null) {
      final VariableKey unpackedIntentKey=new WeaklyNamedKey(AndroidTypes.IntentName,""String_Node_Str"");
      final SSAValue unpackedIntent=pm.getUnallocated(AndroidTypes.Intent,unpackedIntentKey);
      final int pc=redirect.getNextProgramCounter();
      final SSAInstruction fetch=instructionFactory.ArrayLoadInstruction(pc,unpackedIntent,incoming,0);
      redirect.addStatement(fetch);
      pm.setAllocation(unpackedIntent,fetch);
      defaults.add(unpackedIntent);
    }
  }
  final SSAValue intent=acc.firstExtends(AndroidTypes.Intent,cha);
  final AndroidStartComponentTool tool=new AndroidStartComponentTool(getClassHierarchy(),asMethod,flags,caller,instructionFactory,acc,pm,redirect,self,info,callerNd);
  final AndroidTypes.AndroidContextType contextType;
  final SSAValue androidContext;
  androidContext=tool.fetchCallerContext();
  contextType=tool.typeOfCallerContext();
  try {
    if (intent != null) {
      tool.setIntent(intent,allActivities);
    }
 else     if (!info.isSystemService()) {
    }
{
      final List<SSAValue> redirectParams=acc.connectThrough(modelAcc,new HashSet<SSAValue>(allActivities),defaults,getClassHierarchy(),instantiator,false,null,null);
      final int callPC=redirect.getNextProgramCounter();
      final CallSiteReference site=CallSiteReference.make(callPC,this.model.getReference(),IInvokeInstruction.Dispatch.STATIC);
      final SSAAbstractInvokeInstruction invokation;
      final SSAValue exception=pm.getException();
      if (this.model.getReference().getReturnType().equals(TypeReference.Void)) {
        invokation=instructionFactory.InvokeInstruction(callPC,redirectParams,exception,site);
      }
 else {
        if (this instanceof SystemServiceModel) {
          final SSAValue svc=pm.getUnmanaged(TypeReference.JavaLangObject,""String_Node_Str"");
          invokation=instructionFactory.InvokeInstruction(callPC,svc,redirectParams,exception,site);
          redirect.addStatement(invokation);
          if (instructionFactory.isAssignableFrom(svc.getType(),svc.getValidIn().getReturnType())) {
            final int returnPC=redirect.getNextProgramCounter();
            final SSAInstruction returnInstruction=instructionFactory.ReturnInstruction(returnPC,svc);
            redirect.addStatement(returnInstruction);
          }
          final IClass declaringClass=this.cha.lookupClass(asMethod.getDeclaringClass());
          if (declaringClass == null) {
            throw new IllegalStateException(""String_Node_Str"" + asMethod.getDeclaringClass() + ""String_Node_Str""+ ""String_Node_Str""+ asMethod.toString());
          }
          redirect.setLocalNames(pm.makeLocalNames());
          SummarizedMethod override=new SummarizedMethodWithNames(mRef,redirect,declaringClass);
          return override;
        }
 else         if (this instanceof ExternalModel) {
          final SSAValue trash=pm.getUnmanaged(AndroidTypes.Intent,""String_Node_Str"");
          invokation=instructionFactory.InvokeInstruction(callPC,trash,redirectParams,exception,site);
        }
 else {
          throw new UnsupportedOperationException(""String_Node_Str"" + this.model.getClass());
        }
      }
      redirect.addStatement(invokation);
    }
    if (flags.contains(StarterFlags.CALL_ON_ACTIVITY_RESULT) && (!flags.contains(StarterFlags.CONTEXT_FREE))) {
      final List<SSAValue> resultCodes=new ArrayList<SSAValue>();
      final List<SSAValue> resultData=new ArrayList<SSAValue>();
      final SSAValue mResultCode;
      final SSAValue mResultData;
      tool.fetchResults(resultCodes,resultData,allActivities);
      if (resultCodes.size() == 0) {
        throw new IllegalStateException(""String_Node_Str"" + asMethod + ""String_Node_Str""+ caller+ ""String_Node_Str""+ this.model+ ""String_Node_Str"");
      }
      mResultCode=tool.addPhi(resultCodes);
      mResultData=tool.addPhi(resultData);
{
        final SSAValue outRequestCode=acc.firstOf(TypeReference.Int);
        final int callPC=redirect.getNextProgramCounter();
        final Selector mSel=Selector.make(""String_Node_Str"");
        final MethodReference mRef=MethodReference.findOrCreate(caller,mSel);
        final CallSiteReference site=CallSiteReference.make(callPC,mRef,IInvokeInstruction.Dispatch.VIRTUAL);
        final SSAValue exception=pm.getException();
        final List<SSAValue> params=new ArrayList<SSAValue>();
        params.add(self);
        params.add(outRequestCode);
        params.add(mResultCode);
        params.add(mResultData);
        final SSAInstruction invokation=instructionFactory.InvokeInstruction(callPC,params,exception,site);
        redirect.addStatement(invokation);
      }
    }
    final IClass declaringClass=this.cha.lookupClass(asMethod.getDeclaringClass());
    if (declaringClass == null) {
      throw new IllegalStateException(""String_Node_Str"" + asMethod.getDeclaringClass() + ""String_Node_Str""+ ""String_Node_Str""+ asMethod.toString());
    }
    redirect.setLocalNames(pm.makeLocalNames());
    SummarizedMethod override=new SummarizedMethodWithNames(mRef,redirect,declaringClass);
    return override;
  }
 catch (  Exception e) {
    e.printStackTrace();
    System.err.println(""String_Node_Str"");
    System.err.println(acc.dump());
    System.err.println(""String_Node_Str"" + pm);
    System.err.println(""String_Node_Str"" + self);
    System.err.println(""String_Node_Str"" + acc.dump());
    System.err.println(""String_Node_Str"" + contextType);
    System.err.println(""String_Node_Str"" + androidContext);
    System.err.println(""String_Node_Str"" + asMethod);
    System.err.println(""String_Node_Str"" + caller);
    System.err.println(""String_Node_Str"" + info);
    System.err.println(""String_Node_Str"" + callerNd);
    System.err.println(""String_Node_Str"" + this.getClass().toString());
    System.err.println(""String_Node_Str"" + this.name);
    throw new IllegalStateException(e);
  }
}",0.9980145598941098
99665,"/** 
 * Fetches the context of the caller.
 * @return A new SSAValue representing the androidContext (may be null!).  // XXX 
 */
public SSAValue fetchCallerContext(){
  if (caller == null) {
    return null;
  }
  final IClass iCaller=cha.lookupClass(caller);
  final IClass iActivity=cha.lookupClass(AndroidTypes.Activity);
  final IClass iApp=cha.lookupClass(AndroidTypes.Application);
  final IClass iService=cha.lookupClass(AndroidTypes.Service);
  final SSAValue androidContext;
  if (caller.getName().equals(AndroidTypes.ContextWrapperName)) {
    this.callerContext=AndroidTypes.AndroidContextType.USELESS;
    return null;
  }
 else   if (caller.getName().equals(AndroidTypes.ContextImplName)) {
{
      androidContext=self;
      this.callerContext=AndroidTypes.AndroidContextType.CONTEXT_IMPL;
      return androidContext;
    }
  }
 else   if (cha.isAssignableFrom(iActivity,iCaller)) {
    androidContext=null;
    this.callerContext=AndroidTypes.AndroidContextType.ACTIVITY;
    return androidContext;
  }
 else   if (caller.equals(AndroidModelClass.ANDROID_MODEL_CLASS)) {
    this.callerContext=AndroidTypes.AndroidContextType.USELESS;
    return null;
  }
 else   if (caller.getName().equals(AndroidTypes.BridgeContextName)) {
    androidContext=self;
    this.callerContext=AndroidTypes.AndroidContextType.CONTEXT_BRIDGE;
    return androidContext;
  }
 else   if (cha.isAssignableFrom(iApp,iCaller)) {
    androidContext=self;
    this.callerContext=AndroidTypes.AndroidContextType.APPLICATION;
    return androidContext;
  }
 else   if (cha.isAssignableFrom(iService,iCaller)) {
    androidContext=self;
    this.callerContext=AndroidTypes.AndroidContextType.SERVICE;
    return androidContext;
  }
 else {
    throw new UnsupportedOperationException(""String_Node_Str"" + caller);
  }
}","/** 
 * Fetches the context of the caller.
 * @return A new SSAValue representing the androidContext (may be null!).  // XXX 
 */
public SSAValue fetchCallerContext(){
  if (caller == null) {
    return null;
  }
  final IClass iCaller=cha.lookupClass(caller);
  final IClass iActivity=cha.lookupClass(AndroidTypes.Activity);
  final IClass iApp=cha.lookupClass(AndroidTypes.Application);
  final IClass iService=cha.lookupClass(AndroidTypes.Service);
  final SSAValue androidContext;
  if (caller.getName().equals(AndroidTypes.ContextWrapperName)) {
    this.callerContext=AndroidTypes.AndroidContextType.USELESS;
    return null;
  }
 else   if (caller.getName().equals(AndroidTypes.ContextImplName)) {
{
      androidContext=self;
      this.callerContext=AndroidTypes.AndroidContextType.CONTEXT_IMPL;
      return androidContext;
    }
  }
 else   if (cha.isAssignableFrom(iActivity,iCaller)) {
    androidContext=null;
    this.callerContext=AndroidTypes.AndroidContextType.ACTIVITY;
    return androidContext;
  }
 else   if (caller.equals(AndroidModelClass.ANDROID_MODEL_CLASS)) {
    this.callerContext=AndroidTypes.AndroidContextType.USELESS;
    return null;
  }
 else   if (caller.getName().equals(AndroidTypes.BridgeContextName)) {
    androidContext=self;
    this.callerContext=AndroidTypes.AndroidContextType.CONTEXT_BRIDGE;
    return androidContext;
  }
 else   if (cha.isAssignableFrom(iApp,iCaller)) {
    androidContext=self;
    this.callerContext=AndroidTypes.AndroidContextType.APPLICATION;
    return androidContext;
  }
 else   if (cha.isAssignableFrom(iService,iCaller)) {
    androidContext=self;
    this.callerContext=AndroidTypes.AndroidContextType.SERVICE;
    return androidContext;
  }
 else {
    logger.debug(""String_Node_Str"" + caller);
    return null;
  }
}",0.9811111111111112
99666,"/** 
 * If the function associated with the node is handled by this class.
 * @throws IllegalArgumentException if the given node is null
 */
@Override public boolean understands(CGNode node){
  if (node == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final MethodReference target=node.getMethod().getReference();
{
    if (target.toString().contains(""String_Node_Str"")) {
      return true;
    }
  }
  return (intentStarters.isStarter(target));
}","/** 
 * If the function associated with the node is handled by this class.
 * @throws IllegalArgumentException if the given node is null
 */
@Override public boolean understands(CGNode node){
  if (node == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final MethodReference target=node.getMethod().getReference();
  return (intentStarters.isStarter(target));
}",0.8051044083526682
99667,"public SymbolicPropagator(DexCFG dexCFG,SSAInstruction[] instructions,SSA2LocalMap localMap,SSACFG cfg,SSAPiNodePolicy piNodePolicy){
  super(dexCFG);
  this.piNodePolicy=null;
  this.cfg=cfg;
  this.creators=new SSAInstruction[0];
  this.dexCFG=dexCFG;
  this.instructions=instructions;
  this.loader=dexCFG.getMethod().getDeclaringClass().getClassLoader().getReference();
  init(this.new NodeVisitor(cfg),this.new EdgeVisitor());
}","public SymbolicPropagator(DexCFG dexCFG,SSAInstruction[] instructions,SSA2LocalMap localMap,SSACFG cfg,SSAPiNodePolicy piNodePolicy){
  super(dexCFG);
  this.piNodePolicy=piNodePolicy;
  this.cfg=cfg;
  this.creators=new SSAInstruction[0];
  this.dexCFG=dexCFG;
  this.instructions=instructions;
  this.loader=dexCFG.getMethod().getDeclaringClass().getClassLoader().getReference();
  init(this.new NodeVisitor(cfg),this.new EdgeVisitor());
}",0.9816933638443937
99668,"@Override public void leave(){
  final Set<Tag> allowedTags=self.getAllowedSubTags();
  final Set<Intent> overrideTargets=new HashSet<Intent>();
  while (parserStack.peek() != self) {
    Tag current=parserStack.pop();
    if (allowedTags.contains(current)) {
      if (current == Tag.INTENT) {
        Object oIntent=attributesHistory.get(Tag.INTENT).peek();
        if (oIntent == null) {
          throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + attributesHistory.get(Attr.NAME));
        }
 else         if (oIntent instanceof Intent) {
          overrideTargets.add((Intent)oIntent);
        }
 else {
          throw new IllegalStateException(""String_Node_Str"" + oIntent.getClass().toString());
        }
      }
 else {
        throw new IllegalStateException(""String_Node_Str"");
      }
      current.getHandler().popAttributes();
    }
 else {
      throw new IllegalStateException(""String_Node_Str"" + self + ""String_Node_Str""+ current+ ""String_Node_Str""+ parserStack+ ""String_Node_Str""+ ""String_Node_Str""+ allowedTags);
    }
  }
  final String pack;
  if ((attributesHistory.get(Attr.PACKAGE) != null) && (!(attributesHistory.get(Attr.PACKAGE).isEmpty()))) {
    pack=(String)attributesHistory.get(Attr.PACKAGE).peek();
  }
 else {
    logger.warn(""String_Node_Str"",attributesHistory.get(Attr.PACKAGE).peek());
    pack=null;
  }
  final String name=(String)attributesHistory.get(Attr.NAME).peek();
  final Intent intent=AndroidSettingFactory.intent(pack,name,null);
  logger.info(""String_Node_Str"",intent);
  AndroidEntryPointManager.MANAGER.registerIntent(intent);
  for (  Intent ovr : overrideTargets) {
    logger.info(""String_Node_Str"",ovr,intent);
    AndroidEntryPointManager.MANAGER.setOverride(ovr,intent);
  }
}","@Override public void leave(){
  final Set<Tag> allowedTags=self.getAllowedSubTags();
  final Set<Intent> overrideTargets=new HashSet<Intent>();
  while (parserStack.peek() != self) {
    Tag current=parserStack.pop();
    if (allowedTags.contains(current)) {
      if (current == Tag.INTENT) {
        if (attributesHistory.get(Tag.INTENT).isEmpty())         continue;
        Object oIntent=attributesHistory.get(Tag.INTENT).peek();
        if (oIntent == null) {
          throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + attributesHistory.get(Attr.NAME));
        }
 else         if (oIntent instanceof Intent) {
          overrideTargets.add((Intent)oIntent);
        }
 else {
          throw new IllegalStateException(""String_Node_Str"" + oIntent.getClass().toString());
        }
      }
 else {
        throw new IllegalStateException(""String_Node_Str"");
      }
      current.getHandler().popAttributes();
    }
 else {
      throw new IllegalStateException(""String_Node_Str"" + self + ""String_Node_Str""+ current+ ""String_Node_Str""+ parserStack+ ""String_Node_Str""+ ""String_Node_Str""+ allowedTags);
    }
  }
  final String pack;
  if ((attributesHistory.get(Attr.PACKAGE) != null) && (!(attributesHistory.get(Attr.PACKAGE).isEmpty()))) {
    pack=(String)attributesHistory.get(Attr.PACKAGE).peek();
  }
 else {
    logger.warn(""String_Node_Str"",attributesHistory.get(Attr.PACKAGE).peek());
    pack=null;
  }
  final String name;
  if (self == Tag.ALIAS) {
    name=(String)attributesHistory.get(Attr.TARGET).peek();
  }
 else {
    name=(String)attributesHistory.get(Attr.NAME).peek();
  }
  final Intent intent=AndroidSettingFactory.intent(pack,name,null);
  logger.info(""String_Node_Str"",intent);
  AndroidEntryPointManager.MANAGER.registerIntent(intent);
  for (  Intent ovr : overrideTargets) {
    logger.info(""String_Node_Str"",ovr,intent);
    if (ovr.equals(intent)) {
      AndroidEntryPointManager.MANAGER.registerIntent(intent);
    }
 else {
      AndroidEntryPointManager.MANAGER.setOverride(ovr,intent);
    }
  }
}",0.9206182866125228
99669,"protected void processIf(CAstNode n,boolean isExpr,WalkContext c,CAstVisitor<WalkContext> visitor){
  WalkContext context=c;
  PreBasicBlock trueB=null, falseB=null;
  CAstNode l=n.getChild(0);
  visitor.visit(l,context,visitor);
  context.cfg().addInstruction(insts.ConditionalBranchInstruction(context.cfg().currentInstruction,translateConditionOpcode(CAstOperator.OP_EQ),null,c.getValue(l),context.currentScope().getConstantValue(new Integer(0)),-1));
  PreBasicBlock srcB=context.cfg().getCurrentBlock();
  context.cfg().newBlock(true);
  CAstNode r=n.getChild(1);
  visitor.visit(r,context,visitor);
  if (isExpr)   context.cfg().addInstruction(new AssignInstruction(context.cfg().currentInstruction,c.getValue(n),c.getValue(r)));
  if (n.getChildCount() == 3) {
    if (!context.cfg().isDeadBlock(context.cfg().getCurrentBlock())) {
      context.cfg().addInstruction(insts.GotoInstruction(context.cfg().currentInstruction,-1));
      trueB=context.cfg().getCurrentBlock();
      context.cfg().newBlock(false);
    }
    falseB=context.cfg().getCurrentBlock();
    CAstNode f=n.getChild(2);
    visitor.visit(f,context,visitor);
    if (isExpr)     context.cfg().addInstruction(new AssignInstruction(context.cfg().currentInstruction,c.getValue(n),c.getValue(f)));
  }
  context.cfg().newBlock(true);
  if (n.getChildCount() == 3) {
    if (trueB != null)     context.cfg().addEdge(trueB,context.cfg().getCurrentBlock());
    context.cfg().addEdge(srcB,falseB);
  }
 else {
    context.cfg().addEdge(srcB,context.cfg().getCurrentBlock());
  }
}","protected void processIf(CAstNode n,boolean isExpr,WalkContext c,CAstVisitor<WalkContext> visitor){
  WalkContext context=c;
  PreBasicBlock trueB=null, falseB=null;
  CAstNode l=n.getChild(0);
  visitor.visit(l,context,visitor);
  context.cfg().addInstruction(insts.ConditionalBranchInstruction(context.cfg().currentInstruction,translateConditionOpcode(CAstOperator.OP_EQ),null,c.getValue(l),context.currentScope().getConstantValue(new Integer(0)),-1));
  PreBasicBlock srcB=context.cfg().getCurrentBlock();
  context.cfg().newBlock(true);
  CAstNode r=n.getChild(1);
  visitor.visit(r,context,visitor);
  if (isExpr)   context.cfg().addInstruction(new AssignInstruction(context.cfg().currentInstruction,c.getValue(n),c.getValue(r)));
  if (n.getChildCount() == 3) {
    if (!context.cfg().isDeadBlock(context.cfg().getCurrentBlock())) {
      context.cfg().addInstruction(insts.GotoInstruction(context.cfg().currentInstruction,-1));
      trueB=context.cfg().getCurrentBlock();
      context.cfg().newBlock(false);
    }
    falseB=context.cfg().getCurrentBlock();
    CAstNode f=n.getChild(2);
    context.cfg().deadBlocks.remove(falseB);
    visitor.visit(f,context,visitor);
    if (isExpr)     context.cfg().addInstruction(new AssignInstruction(context.cfg().currentInstruction,c.getValue(n),c.getValue(f)));
  }
  context.cfg().newBlock(true);
  if (n.getChildCount() == 3) {
    if (trueB != null)     context.cfg().addEdge(trueB,context.cfg().getCurrentBlock());
    context.cfg().addEdge(srcB,falseB);
  }
 else {
    context.cfg().addEdge(srcB,context.cfg().getCurrentBlock());
  }
}",0.9856824689786828
99670,"public IntraproceduralNullPointerAnalysis(IR ir){
  if (ir == null || ir.isEmptyIR()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.ir=ir;
  final int maxVarNum=ir.getSymbolTable().getMaxValueNumber();
  final int[] paramValNum=ir.getParameterValueNumbers();
  final NullPointerFrameWork<ISSABasicBlock> problem=new NullPointerFrameWork<ISSABasicBlock>(ir.getControlFlowGraph(),ir);
  this.solver=new NullPointerSolver<ISSABasicBlock>(problem,maxVarNum,paramValNum,ir);
  try {
    this.solver.solve(NO_PROGRESS_MONITOR);
  }
 catch (  final CancelException e) {
  }
}","public IntraproceduralNullPointerAnalysis(IR ir){
  if (ir == null || ir.isEmptyIR()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.ir=ir;
  final int maxVarNum=ir.getSymbolTable().getMaxValueNumber();
  final int[] paramValNum=ir.getParameterValueNumbers();
  SSACFG cfg=ir.getControlFlowGraph();
  final NullPointerFrameWork<ISSABasicBlock> problem=new NullPointerFrameWork<ISSABasicBlock>(cfg,ir);
  this.solver=new NullPointerSolver<ISSABasicBlock>(problem,maxVarNum,paramValNum,ir,cfg.entry());
  try {
    this.solver.solve(NO_PROGRESS_MONITOR);
  }
 catch (  final CancelException e) {
  }
}",0.9359605911330048
99671,"public void addPhi(Integer dst,Integer src1,Integer src2){
  this.phis.add(dst);
  this.addEdge(src1,dst);
  this.addEdge(src2,dst);
}","public void addPhi(Integer dst){
  this.phis.add(dst);
}",0.5894736842105263
99672,"@Override public List<Pair<Integer,SSAInstruction>> getPis(SSAConditionalBranchInstruction cond,SSAInstruction def1,SSAInstruction def2,SymbolTable symbolTable){
  LinkedList<Pair<Integer,SSAInstruction>> result=new LinkedList<>();
  result.addAll(getPis(cond,def1,def2,symbolTable));
  return result;
}","@Override public List<Pair<Integer,SSAInstruction>> getPis(SSAConditionalBranchInstruction cond,SSAInstruction def1,SSAInstruction def2,SymbolTable symbolTable){
  LinkedList<Pair<Integer,SSAInstruction>> result=new LinkedList<>();
  result.addAll(p1.getPis(cond,def1,def2,symbolTable));
  result.addAll(p2.getPis(cond,def1,def2,symbolTable));
  return result;
}",0.8781954887218045
99673,"@Override public boolean hasNormalEdge(Block src,Block dst){
  boolean result=true;
  final SSAInstruction relevantInstruction=src.getLastInstruction();
  if (relevantInstruction != null && this.filter.alwaysThrowsException(relevantInstruction)) {
    result=false;
  }
  return result && this.cfg.getNormalSuccessors(src).contains(dst);
}","@Override public boolean hasNormalEdge(Block src,Block dst){
  boolean result=true;
  if (src.getLastInstructionIndex() >= 0) {
    final SSAInstruction relevantInstruction=src.getLastInstruction();
    if (relevantInstruction != null && this.filter.alwaysThrowsException(relevantInstruction)) {
      result=false;
    }
  }
  return result && this.cfg.getNormalSuccessors(src).contains(dst);
}",0.9237057220708448
99674,"/** 
 * @return true iff there's a unique catch block which catches all exceptions thrown by a certain call site.
 */
protected static boolean hasUniqueCatchBlock(SSAAbstractInvokeInstruction call,IR ir){
  ISSABasicBlock[] bb=ir.getBasicBlocksForCall(call.getCallSite());
  if (bb.length == 1) {
    Iterator it=ir.getControlFlowGraph().getExceptionalSuccessors(bb[0]).iterator();
    if (it.hasNext()) {
      it.next();
      return (!it.hasNext());
    }
  }
  return false;
}","/** 
 * @return true iff there's a unique catch block which catches all exceptions thrown by a certain call site.
 */
protected static boolean hasUniqueCatchBlock(SSAAbstractInvokeInstruction call,IR ir){
  ISSABasicBlock[] bb=ir.getBasicBlocksForCall(call.getCallSite());
  if (bb.length == 1) {
    Iterator<ISSABasicBlock> it=ir.getControlFlowGraph().getExceptionalSuccessors(bb[0]).iterator();
    if (it.hasNext()) {
      ISSABasicBlock sb=it.next();
      return (!it.hasNext() && (sb.isExitBlock() || ((sb instanceof ExceptionHandlerBasicBlock) && ((ExceptionHandlerBasicBlock)sb).getCatchInstruction() != null)));
    }
  }
  return false;
}",0.8495575221238938
99675,"/** 
 * @param pc the byte code index.
 * @return The index of the instruction of given byte code index
 */
public int getIndexFromPc(int pc){
  return pc2index.get(pc);
}","/** 
 * @param pc the byte code index.
 * @return The index of the instruction of given byte code index
 */
public int getIndexFromPc(int pc){
  if (!pc2index.containsKey(pc) && pc2index.containsKey(pc + 1)) {
    pc++;
  }
  return pc2index.get(pc);
}",0.7754137115839244
99676,"private void computeCasesAndLabels(){
  casesAndLabels=pad.getLabelsAndOffsets();
  for (int i=1; i < casesAndLabels.length; i+=2)   casesAndLabels[i]=method.getInstructionIndex(pc + casesAndLabels[i]);
  defaultLabel=method.getInstructionIndex(pc + pad.getDefaultOffset());
}","private void computeCasesAndLabels(){
  casesAndLabels=pad.getLabelsAndOffsets();
  for (int i=1; i < casesAndLabels.length; i+=2)   casesAndLabels[i]=pc + casesAndLabels[i];
  defaultLabel=pc + pad.getDefaultOffset();
}",0.6854838709677419
99677,"@Override public int[] getBranchTargets(){
  int[] r=new int[casesAndLabels.length / 2 + 1];
  r[0]=defaultLabel;
  for (int i=1; i < r.length; i++) {
    r[i]=casesAndLabels[(i - 1) * 2 + 1];
  }
  return r;
}","@Override public int[] getBranchTargets(){
  int[] r=new int[casesAndLabels.length / 2 + 1];
  r[0]=method.getInstructionIndex(defaultLabel);
  for (int i=1; i < r.length; i++) {
    r[i]=method.getInstructionIndex(casesAndLabels[(i - 1) * 2 + 1]);
  }
  return r;
}",0.8823529411764706
99678,"@Override public void performVerboseAction(){
  super.performVerboseAction();
  if (DEBUG_MEMORY) {
    DEBUG_MEM_COUNTER++;
    if (DEBUG_MEM_COUNTER % DEBUG_MEM_INTERVAL == 0) {
      DEBUG_MEM_COUNTER=0;
      ReferenceCleanser.clearSoftCaches();
      System.err.println(flowGraph.spaceReport());
      System.err.println(""String_Node_Str"");
      HeapTracer.traceHeap(Collections.singleton(this),true);
      System.err.println(""String_Node_Str"");
    }
  }
  if (getFixedPointSystem() instanceof VerboseAction) {
    ((VerboseAction)getFixedPointSystem()).performVerboseAction();
  }
  AbstractStatement s=workList.takeStatement();
  System.err.println(printRHSInstances(s));
  workList.insertStatement(s);
  System.err.println(""String_Node_Str"" + cg.getNumberOfNodes());
}","@Override public void performVerboseAction(){
  super.performVerboseAction();
  if (DEBUG_MEMORY) {
    DEBUG_MEM_COUNTER++;
    if (DEBUG_MEM_COUNTER % DEBUG_MEM_INTERVAL == 0) {
      DEBUG_MEM_COUNTER=0;
      ReferenceCleanser.clearSoftCaches();
      System.err.println(flowGraph.spaceReport());
      System.err.println(""String_Node_Str"");
      HeapTracer.traceHeap(Collections.singleton(this),true);
      System.err.println(""String_Node_Str"");
    }
  }
  if (getFixedPointSystem() instanceof VerboseAction) {
    ((VerboseAction)getFixedPointSystem()).performVerboseAction();
  }
  if (!workList.isEmpty()) {
    AbstractStatement s=workList.takeStatement();
    System.err.println(printRHSInstances(s));
    workList.insertStatement(s);
    System.err.println(""String_Node_Str"" + cg.getNumberOfNodes());
  }
}",0.9743589743589745
99679,"/** 
 * Given a calling node and a call site, return the set of parameters based on which this selector may choose  to specialize contexts.   {@inheritDoc}
 */
@Override public IntSet getRelevantParameters(CGNode caller,CallSiteReference site){
  IntSet ret;
  if (this.parent != null) {
    ret=this.parent.getRelevantParameters(caller,site);
  }
 else {
    ret=EmptyIntSet.instance;
  }
  final MethodReference target=site.getDeclaredTarget();
  if (intentStarters.isStarter(target)) {
    final StartInfo info=intentStarters.getInfo(target);
    final int[] relevant=info.getRelevant();
    if (relevant != null) {
      for (int i=0; i < relevant.length; ++i) {
        ret=IntSetUtil.add(ret,relevant[i]);
      }
    }
  }
 else   if (site.isSpecial() && target.getDeclaringClass().getName().equals(AndroidTypes.IntentName)) {
    final MethodReference mRef=site.getDeclaredTarget();
    final int numArgs=mRef.getNumberOfParameters();
switch (numArgs) {
case 0:
      return EmptyIntSet.instance;
case 1:
    return IntSetUtil.make(new int[]{0,1});
case 2:
  return IntSetUtil.make(new int[]{0,1,2});
case 3:
return IntSetUtil.make(new int[]{0,1,2,3});
case 4:
return IntSetUtil.make(new int[]{0,1,2,3,4});
default :
return IntSetUtil.make(new int[]{0,1,2,3,4,5});
}
}
 else if (site.isSpecial() && target.getDeclaringClass().getName().equals(AndroidTypes.IntentSenderName)) {
return IntSetUtil.make(new int[]{0,1});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0,1});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0,1});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0,2});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0,2});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0,2});
}
return ret;
}","/** 
 * Given a calling node and a call site, return the set of parameters based on which this selector may choose  to specialize contexts.   {@inheritDoc}
 */
@Override public IntSet getRelevantParameters(CGNode caller,CallSiteReference site){
  IntSet ret;
  if (this.parent != null) {
    ret=this.parent.getRelevantParameters(caller,site);
  }
 else {
    ret=EmptyIntSet.instance;
  }
  final MethodReference target=site.getDeclaredTarget();
  if (intentStarters.isStarter(target)) {
    final StartInfo info=intentStarters.getInfo(target);
    final int[] relevant=info.getRelevant();
    if (relevant != null) {
      for (int i=0; i < relevant.length; ++i) {
        ret=IntSetUtil.add(ret,relevant[i]);
      }
    }
    logger.debug(""String_Node_Str"",site,ret);
  }
 else   if (site.isSpecial() && target.getDeclaringClass().getName().equals(AndroidTypes.IntentName)) {
    final MethodReference mRef=site.getDeclaredTarget();
    final int numArgs=mRef.getNumberOfParameters();
switch (numArgs) {
case 0:
      return EmptyIntSet.instance;
case 1:
    return IntSetUtil.make(new int[]{0,1});
case 2:
  logger.debug(""String_Node_Str"",site.getDeclaredTarget().getSelector());
return IntSetUtil.make(new int[]{0,1,2});
case 3:
logger.debug(""String_Node_Str"",site.getDeclaredTarget().getSelector());
return IntSetUtil.make(new int[]{0,1,2,3});
case 4:
logger.debug(""String_Node_Str"",site.getDeclaredTarget().getSelector());
return IntSetUtil.make(new int[]{0,1,2,3,4});
default :
logger.debug(""String_Node_Str"",site.getDeclaredTarget().getSelector());
return IntSetUtil.make(new int[]{0,1,2,3,4,5});
}
}
 else if (site.isSpecial() && target.getDeclaringClass().getName().equals(AndroidTypes.IntentSenderName)) {
logger.warn(""String_Node_Str"",target);
if (target.getNumberOfParameters() == 0) {
return IntSetUtil.make(new int[]{0});
}
 else {
return IntSetUtil.make(new int[]{0,1});
}
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
logger.debug(""String_Node_Str"");
return IntSetUtil.make(new int[]{0,1});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0,1});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0,2});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0,2});
}
 else if (target.getSelector().equals(Selector.make(""String_Node_Str""))) {
return IntSetUtil.make(new int[]{0,2});
}
return ret;
}",0.8955848503871102
99680,"public void addStatement(NullaryStatement<?> s){
  if (s == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  IVariable<?> lhs=s.getLHS();
  graph.addNode(s);
  if (lhs != null) {
    variables.add(lhs);
    graph.addNode(lhs);
    graph.addEdge(s,lhs);
  }
  if (DEBUG) {
    checkGraph();
  }
}","public void addStatement(NullaryStatement<?> s){
  if (s == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  IVariable<?> lhs=s.getLHS();
  equations.add(s);
  graph.addNode(s);
  if (lhs != null) {
    variables.add(lhs);
    graph.addNode(lhs);
    graph.addEdge(s,lhs);
  }
  if (DEBUG) {
    checkGraph();
  }
}",0.9696048632218844
99681,"public CAstNode translateDoLoop(CAstNode loopTest,CAstNode loopBody,CAstNode continueNode,CAstNode breakNode,WalkContext<?,?> wc){
  if (replicateForDoLoops) {
    loopBody=Ast.makeNode(CAstNode.BLOCK_STMT,loopBody,continueNode);
    CAstRewriter.Rewrite x=(new CAstCloner(Ast,false)).copy(loopBody,wc.cfg(),wc.pos(),wc.getNodeTypeMap(),null);
    CAstNode otherBody=x.newRoot();
    wc.cfg().addAll(x.newCfg());
    wc.pos().addAll(x.newPos());
    wc.getNodeTypeMap().addAll(x.newTypes());
    return Ast.makeNode(CAstNode.BLOCK_STMT,loopBody,Ast.makeNode(CAstNode.LOOP,loopTest,otherBody),breakNode);
  }
 else {
    CAstNode header=Ast.makeNode(CAstNode.EMPTY);
    CAstNode loopGoto=Ast.makeNode(CAstNode.IFGOTO,loopTest);
    wc.cfg().map(header,header);
    wc.cfg().map(loopGoto,loopGoto);
    wc.cfg().add(loopGoto,header,Boolean.TRUE);
    return Ast.makeNode(CAstNode.BLOCK_STMT,header,Ast.makeNode(CAstNode.BLOCK_STMT,loopBody,continueNode),loopGoto,breakNode);
  }
}","public CAstNode translateDoLoop(CAstNode loopTest,CAstNode loopBody,CAstNode continueNode,CAstNode breakNode,WalkContext<?,?> wc){
  if (replicateForDoLoops) {
    loopBody=Ast.makeNode(CAstNode.BLOCK_STMT,loopBody,continueNode);
    CAstRewriter.Rewrite x=(new CAstCloner(Ast,false)).copy(loopBody,wc.cfg(),wc.pos(),wc.getNodeTypeMap(),null);
    CAstNode otherBody=x.newRoot();
    wc.cfg().addAll(x.newCfg());
    wc.pos().addAll(x.newPos());
    wc.getNodeTypeMap().addAll(x.newTypes());
    return Ast.makeNode(CAstNode.BLOCK_STMT,loopBody,Ast.makeNode(CAstNode.LOOP,loopTest,otherBody),breakNode);
  }
 else {
    CAstNode header=Ast.makeNode(CAstNode.LABEL_STMT,Ast.makeConstant(""String_Node_Str""),Ast.makeNode(CAstNode.EMPTY));
    CAstNode loopGoto=Ast.makeNode(CAstNode.IFGOTO,loopTest);
    wc.cfg().map(header,header);
    wc.cfg().map(loopGoto,loopGoto);
    wc.cfg().add(loopGoto,header,Boolean.TRUE);
    return Ast.makeNode(CAstNode.BLOCK_STMT,header,Ast.makeNode(CAstNode.BLOCK_STMT,loopBody,continueNode),loopGoto,breakNode);
  }
}",0.965483234714004
99682,"private ClassWriter.Element[] makeMethodAttributes(int m,ClassWriter w,CodeReader oldCode,Compiler.Output output,MethodData md) throws InvalidClassFileException {
  CodeWriter code=makeNewCode(w,output);
  int codeAttrCount=0;
  LineNumberTableWriter lines=null;
  LocalVariableTableWriter locals=null;
  StackMapTableWriter stacks=null;
  if (oldCode != null) {
    lines=makeNewLines(w,oldCode,output);
    if (lines != null) {
      codeAttrCount++;
    }
    locals=makeNewLocals(w,oldCode,output);
    if (locals != null) {
      codeAttrCount++;
    }
    if (oldCode.getClassReader().getMajorVersion() > 50) {
      try {
        List<StackMapFrame> sm=StackMapTableReader.readStackMap(oldCode);
        String[][] varTypes=null;
        int[] newToOld=output.getNewBytecodesToOldBytecodes();
        int[][] vars=LocalVariableTableReader.makeVarMap(oldCode);
        if (vars != null) {
          varTypes=new String[newToOld.length][];
          for (int i=0; i < newToOld.length; i++) {
            int idx=newToOld[i];
            if (idx != -1 && vars[idx] != null) {
              varTypes[i]=new String[vars[idx].length / 2];
              for (int j=1; j < vars[idx].length; j+=2) {
                int type=vars[idx][j];
                varTypes[i][j / 2]=type == 0 ? null : oldCode.getClassReader().getCP().getCPUtf8(type);
              }
            }
          }
        }
        stacks=new StackMapTableWriter(w,md,output,cha,varTypes,sm);
        codeAttrCount++;
      }
 catch (      IOException|FailureException e) {
        e.printStackTrace();
      }
    }
  }
  ClassWriter.Element[] codeAttributes=new ClassWriter.Element[codeAttrCount];
  int codeAttrIndex=0;
  if (lines != null) {
    codeAttributes[codeAttrIndex++]=lines;
  }
  if (locals != null) {
    codeAttributes[codeAttrIndex++]=locals;
  }
  if (stacks != null) {
    codeAttributes[codeAttrIndex++]=stacks;
  }
  code.setAttributes(codeAttributes);
  ClassReader.AttrIterator iter=new ClassReader.AttrIterator();
  cr.initMethodAttributeIterator(m,iter);
  int methodAttrCount=iter.getRemainingAttributesCount();
  if (oldCode == null) {
    methodAttrCount++;
  }
  ClassWriter.Element[] methodAttributes=new ClassWriter.Element[methodAttrCount];
  for (int i=0; iter.isValid(); iter.advance()) {
    if (iter.getName().equals(""String_Node_Str"")) {
      methodAttributes[i]=code;
      code=null;
      if (oldCode == null) {
        throw new Error(""String_Node_Str"");
      }
    }
 else {
      methodAttributes[i]=new ClassWriter.RawElement(cr.getBytes(),iter.getRawOffset(),iter.getRawSize());
    }
    i++;
  }
  if (oldCode == null) {
    if (code == null) {
      throw new Error(""String_Node_Str"");
    }
    methodAttributes[methodAttrCount - 1]=code;
  }
  return methodAttributes;
}","private ClassWriter.Element[] makeMethodAttributes(int m,ClassWriter w,CodeReader oldCode,Compiler.Output output,MethodData md) throws InvalidClassFileException {
  CodeWriter code=makeNewCode(w,output);
  int codeAttrCount=0;
  LineNumberTableWriter lines=null;
  LocalVariableTableWriter locals=null;
  StackMapTableWriter stacks=null;
  if (oldCode != null) {
    lines=makeNewLines(w,oldCode,output);
    if (lines != null) {
      codeAttrCount++;
    }
    locals=makeNewLocals(w,oldCode,output);
    if (locals != null) {
      codeAttrCount++;
    }
    if (oldCode.getClassReader().getMajorVersion() > 50) {
      try {
        List<StackMapFrame> sm=StackMapTableReader.readStackMap(oldCode);
        String[][] varTypes=null;
        int[] newToOld=output.getNewBytecodesToOldBytecodes();
        int[][] vars=LocalVariableTableReader.makeVarMap(oldCode);
        if (vars != null) {
          varTypes=new String[newToOld.length][];
          for (int i=0; i < newToOld.length; i++) {
            int idx=newToOld[i];
            if (idx != -1 && vars[idx] != null) {
              varTypes[i]=new String[vars[idx].length / 2];
              for (int j=1; j < vars[idx].length; j+=2) {
                int type=vars[idx][j];
                varTypes[i][j / 2]=type == 0 ? null : oldCode.getClassReader().getCP().getCPUtf8(type);
              }
            }
          }
        }
        stacks=new StackMapTableWriter(w,md,output,cha,varTypes);
        codeAttrCount++;
      }
 catch (      IOException|FailureException e) {
        e.printStackTrace();
      }
    }
  }
  ClassWriter.Element[] codeAttributes=new ClassWriter.Element[codeAttrCount];
  int codeAttrIndex=0;
  if (lines != null) {
    codeAttributes[codeAttrIndex++]=lines;
  }
  if (locals != null) {
    codeAttributes[codeAttrIndex++]=locals;
  }
  if (stacks != null) {
    codeAttributes[codeAttrIndex++]=stacks;
  }
  code.setAttributes(codeAttributes);
  ClassReader.AttrIterator iter=new ClassReader.AttrIterator();
  cr.initMethodAttributeIterator(m,iter);
  int methodAttrCount=iter.getRemainingAttributesCount();
  if (oldCode == null) {
    methodAttrCount++;
  }
  ClassWriter.Element[] methodAttributes=new ClassWriter.Element[methodAttrCount];
  for (int i=0; iter.isValid(); iter.advance()) {
    if (iter.getName().equals(""String_Node_Str"")) {
      methodAttributes[i]=code;
      code=null;
      if (oldCode == null) {
        throw new Error(""String_Node_Str"");
      }
    }
 else {
      methodAttributes[i]=new ClassWriter.RawElement(cr.getBytes(),iter.getRawOffset(),iter.getRawSize());
    }
    i++;
  }
  if (oldCode == null) {
    if (code == null) {
      throw new Error(""String_Node_Str"");
    }
    methodAttributes[methodAttrCount - 1]=code;
  }
  return methodAttributes;
}",0.9994624619243864
99683,"@Override public SSAAbstractInvokeInstruction addDirectCall(int function,int[] params,CallSiteReference site){
  CallSiteReference newSite=new JSCallSiteReference(statements.size());
  JavaScriptInvoke s=new JavaScriptInvoke(function,nextLocal++,params,nextLocal++,newSite);
  statements.add(s);
  return s;
}","@Override public SSAAbstractInvokeInstruction addDirectCall(int function,int[] params,CallSiteReference site){
  CallSiteReference newSite=new JSCallSiteReference(statements.size());
  JavaScriptInvoke s=new JavaScriptInvoke(statements.size(),function,nextLocal++,params,nextLocal++,newSite);
  statements.add(s);
  return s;
}",0.9716981132075472
99684,"private int passActualPropertyValsAsParams(JSInstructionFactory insts,int nargs,JavaScriptSummary S,int[] paramsToPassToInvoked){
  int curValNum=nargs + 2;
  for (int i=1; i < paramsToPassToInvoked.length; i++) {
    final int constVN=curValNum++;
    S.addConstant(constVN,new ConstantValue(i - 1));
    int propertyReadResult=curValNum++;
    S.addStatement(insts.PropertyRead(S.getNextProgramCounter(),propertyReadResult,4,constVN));
    paramsToPassToInvoked[i]=propertyReadResult;
  }
  return curValNum;
}","private int passActualPropertyValsAsParams(JSInstructionFactory insts,int nargs,JavaScriptSummary S,int[] paramsToPassToInvoked){
  int curValNum=nargs + 2;
  for (int i=1; i < paramsToPassToInvoked.length; i++) {
    final int constVN=curValNum++;
    S.addConstant(constVN,new ConstantValue(i - 1));
    int propertyReadResult=curValNum++;
    S.addStatement(insts.PropertyRead(S.getNumberOfStatements(),propertyReadResult,4,constVN));
    S.getNextProgramCounter();
    paramsToPassToInvoked[i]=propertyReadResult;
  }
  return curValNum;
}",0.9118483412322276
99685,"private IR makeIRForArgList(CGNode node){
  MethodReference ref=node.getMethod().getReference();
  IClass declaringClass=node.getMethod().getDeclaringClass();
  JSInstructionFactory insts=(JSInstructionFactory)declaringClass.getClassLoader().getInstructionFactory();
  int nargs=4;
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs);
  int numParamsToPass=10;
  int[] paramsToPassToInvoked=new int[numParamsToPass + 1];
  paramsToPassToInvoked[0]=3;
  int curValNum=passActualPropertyValsAsParams(insts,nargs,S,paramsToPassToInvoked);
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  int resultVal=curValNum++;
  int excVal=curValNum++;
  S.addStatement(insts.Invoke(S.getNextProgramCounter(),2,resultVal,paramsToPassToInvoked,excVal,cs));
  S.addStatement(insts.ReturnInstruction(S.getNextProgramCounter(),resultVal,false));
  JavaScriptSummarizedFunction t=new JavaScriptSummarizedFunction(ref,S,declaringClass);
  return t.makeIR(node.getContext(),null);
}","private IR makeIRForArgList(CGNode node){
  MethodReference ref=node.getMethod().getReference();
  IClass declaringClass=node.getMethod().getDeclaringClass();
  JSInstructionFactory insts=(JSInstructionFactory)declaringClass.getClassLoader().getInstructionFactory();
  int nargs=4;
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs);
  int numParamsToPass=10;
  int[] paramsToPassToInvoked=new int[numParamsToPass + 1];
  paramsToPassToInvoked[0]=3;
  int curValNum=passActualPropertyValsAsParams(insts,nargs,S,paramsToPassToInvoked);
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  int resultVal=curValNum++;
  int excVal=curValNum++;
  S.addStatement(insts.Invoke(S.getNumberOfStatements(),2,resultVal,paramsToPassToInvoked,excVal,cs));
  S.getNextProgramCounter();
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),resultVal,false));
  S.getNextProgramCounter();
  JavaScriptSummarizedFunction t=new JavaScriptSummarizedFunction(ref,S,declaringClass);
  return t.makeIR(node.getContext(),null);
}",0.7147058823529412
99686,"private IR makeIRForNoArgList(CGNode node){
  MethodReference ref=node.getMethod().getReference();
  IClass declaringClass=node.getMethod().getDeclaringClass();
  JSInstructionFactory insts=(JSInstructionFactory)declaringClass.getClassLoader().getInstructionFactory();
  int nargs=4;
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs);
  int resultVal=nargs + 2;
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  int[] params=new int[1];
  params[0]=3;
  S.addStatement(insts.Invoke(S.getNextProgramCounter(),2,resultVal,params,resultVal + 1,cs));
  S.addStatement(insts.ReturnInstruction(S.getNextProgramCounter(),resultVal,false));
  JavaScriptSummarizedFunction t=new JavaScriptSummarizedFunction(ref,S,declaringClass);
  return t.makeIR(node.getContext(),null);
}","private IR makeIRForNoArgList(CGNode node){
  MethodReference ref=node.getMethod().getReference();
  IClass declaringClass=node.getMethod().getDeclaringClass();
  JSInstructionFactory insts=(JSInstructionFactory)declaringClass.getClassLoader().getInstructionFactory();
  int nargs=4;
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs);
  int resultVal=nargs + 2;
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  int[] params=new int[1];
  params[0]=3;
  S.addStatement(insts.Invoke(S.getNumberOfStatements(),2,resultVal,params,resultVal + 1,cs));
  S.getNextProgramCounter();
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),resultVal,false));
  S.getNextProgramCounter();
  JavaScriptSummarizedFunction t=new JavaScriptSummarizedFunction(ref,S,declaringClass);
  return t.makeIR(node.getContext(),null);
}",0.8585247883917775
99687,"@SuppressWarnings(""String_Node_Str"") private int passArbitraryPropertyValAsParams(JSInstructionFactory insts,int nargs,JavaScriptSummary S,int[] paramsToPassToInvoked){
  int curValNum=nargs + 2;
  int eachElementGetResult=curValNum++;
  S.addStatement(insts.EachElementGetInstruction(S.getNextProgramCounter(),eachElementGetResult,4));
  int propertyReadResult=curValNum++;
  S.addStatement(insts.PropertyRead(S.getNextProgramCounter(),propertyReadResult,4,eachElementGetResult));
  for (int i=1; i < paramsToPassToInvoked.length; i++) {
    paramsToPassToInvoked[i]=propertyReadResult;
  }
  return curValNum;
}","@SuppressWarnings(""String_Node_Str"") private int passArbitraryPropertyValAsParams(JSInstructionFactory insts,int nargs,JavaScriptSummary S,int[] paramsToPassToInvoked){
  int curValNum=nargs + 2;
  int eachElementGetResult=curValNum++;
  S.addStatement(insts.EachElementGetInstruction(S.getNumberOfStatements(),eachElementGetResult,4));
  S.getNextProgramCounter();
  int propertyReadResult=curValNum++;
  S.addStatement(insts.PropertyRead(S.getNumberOfStatements(),propertyReadResult,4,eachElementGetResult));
  S.getNextProgramCounter();
  for (int i=1; i < paramsToPassToInvoked.length; i++) {
    paramsToPassToInvoked[i]=propertyReadResult;
  }
  return curValNum;
}",0.9018691588785048
99688,"/** 
 * generate a synthetic method modeling the invocation of Function.call() at the site
 * @param caller
 * @param site
 * @param receiver
 * @return
 */
private IMethod getFunctionCallTarget(CGNode caller,CallSiteReference site,IClass receiver){
  int nargs=getNumberOfArgsPassed(caller,site);
  if (nargs < 2)   return null;
  String key=getKey(nargs,caller,site);
  if (callModels.containsKey(key)) {
    return callModels.get(key);
  }
  JSInstructionFactory insts=(JSInstructionFactory)receiver.getClassLoader().getInstructionFactory();
  MethodReference ref=genSyntheticMethodRef(receiver,nargs,key);
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs);
  if (WARN_ABOUT_IMPRECISE_CALLGRAPH && caller.getMethod().getName().toString().contains(SYNTHETIC_CALL_METHOD_PREFIX))   warnAboutImpreciseCallGraph(caller,site);
  if (DEBUG_SYNTHETIC_CALL_METHODS) {
    IMethod method=caller.getMethod();
    if (method instanceof AstMethod) {
      int line=((AstMethod)method).getLineNumber(caller.getIR().getCallInstructionIndices(site).intIterator().next());
      System.err.println(""String_Node_Str"" + ref.getName() + ""String_Node_Str""+ line+ ""String_Node_Str""+ caller);
    }
 else {
      System.err.println(""String_Node_Str"" + ref.getName() + ""String_Node_Str""+ method.getName());
    }
  }
  int resultVal=nargs + 2;
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  int[] params=new int[nargs - 2];
  for (int i=0; i < params.length; i++) {
    params[i]=i + 3;
  }
  S.addStatement(insts.Invoke(S.getNextProgramCounter(),2,resultVal,params,resultVal + 1,cs));
  S.addStatement(insts.ReturnInstruction(S.getNextProgramCounter(),resultVal,false));
  JavaScriptSummarizedFunction t=new JavaScriptSummarizedFunction(ref,S,receiver);
  callModels.put(key,t);
  return t;
}","/** 
 * generate a synthetic method modeling the invocation of Function.call() at the site
 * @param caller
 * @param site
 * @param receiver
 * @return
 */
private IMethod getFunctionCallTarget(CGNode caller,CallSiteReference site,IClass receiver){
  int nargs=getNumberOfArgsPassed(caller,site);
  if (nargs < 2)   return null;
  String key=getKey(nargs,caller,site);
  if (callModels.containsKey(key)) {
    return callModels.get(key);
  }
  JSInstructionFactory insts=(JSInstructionFactory)receiver.getClassLoader().getInstructionFactory();
  MethodReference ref=genSyntheticMethodRef(receiver,nargs,key);
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs);
  if (WARN_ABOUT_IMPRECISE_CALLGRAPH && caller.getMethod().getName().toString().contains(SYNTHETIC_CALL_METHOD_PREFIX))   warnAboutImpreciseCallGraph(caller,site);
  if (DEBUG_SYNTHETIC_CALL_METHODS) {
    IMethod method=caller.getMethod();
    if (method instanceof AstMethod) {
      int line=((AstMethod)method).getLineNumber(caller.getIR().getCallInstructionIndices(site).intIterator().next());
      System.err.println(""String_Node_Str"" + ref.getName() + ""String_Node_Str""+ line+ ""String_Node_Str""+ caller);
    }
 else {
      System.err.println(""String_Node_Str"" + ref.getName() + ""String_Node_Str""+ method.getName());
    }
  }
  int resultVal=nargs + 2;
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  int[] params=new int[nargs - 2];
  for (int i=0; i < params.length; i++) {
    params[i]=i + 3;
  }
  S.addStatement(insts.Invoke(S.getNumberOfStatements(),2,resultVal,params,resultVal + 1,cs));
  S.getNextProgramCounter();
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),resultVal,false));
  S.getNextProgramCounter();
  JavaScriptSummarizedFunction t=new JavaScriptSummarizedFunction(ref,S,receiver);
  callModels.put(key,t);
  return t;
}",0.965160587915079
99689,"private IMethod makeUnaryNumberCall(IClass cls){
  JSInstructionFactory insts=(JSInstructionFactory)cls.getClassLoader().getInstructionFactory();
  MethodReference ref=AstMethodReference.fnReference(JavaScriptTypes.Number);
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(insts.GetInstruction(S.getNumberOfStatements(),4,2,""String_Node_Str""));
  S.getNextProgramCounter();
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  S.addStatement(insts.Invoke(4,5,new int[]{2},6,cs));
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),5,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls,cha.lookupClass(JavaScriptTypes.Number));
}","private IMethod makeUnaryNumberCall(IClass cls){
  JSInstructionFactory insts=(JSInstructionFactory)cls.getClassLoader().getInstructionFactory();
  MethodReference ref=AstMethodReference.fnReference(JavaScriptTypes.Number);
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(insts.GetInstruction(S.getNumberOfStatements(),4,2,""String_Node_Str""));
  S.getNextProgramCounter();
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  S.addStatement(insts.Invoke(S.getNumberOfStatements(),4,5,new int[]{2},6,cs));
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),5,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls,cha.lookupClass(JavaScriptTypes.Number));
}",0.98224043715847
99690,"private IMethod makeUnaryStringCall(IClass cls){
  JSInstructionFactory insts=(JSInstructionFactory)cls.getClassLoader().getInstructionFactory();
  MethodReference ref=AstMethodReference.fnReference(JavaScriptTypes.String);
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(insts.GetInstruction(S.getNumberOfStatements(),4,2,""String_Node_Str""));
  S.getNextProgramCounter();
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  S.addStatement(insts.Invoke(4,5,new int[]{2},6,cs));
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),5,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls,cha.lookupClass(JavaScriptTypes.String));
}","private IMethod makeUnaryStringCall(IClass cls){
  JSInstructionFactory insts=(JSInstructionFactory)cls.getClassLoader().getInstructionFactory();
  MethodReference ref=AstMethodReference.fnReference(JavaScriptTypes.String);
  JavaScriptSummary S=new JavaScriptSummary(ref,2);
  S.addStatement(insts.GetInstruction(S.getNumberOfStatements(),4,2,""String_Node_Str""));
  S.getNextProgramCounter();
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  S.addStatement(insts.Invoke(S.getNumberOfStatements(),4,5,new int[]{2},6,cs));
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),5,false));
  S.getNextProgramCounter();
  return new JavaScriptConstructor(ref,S,cls,cha.lookupClass(JavaScriptTypes.String));
}",0.98224043715847
99691,"private IMethod makeFunctionObjectConstructor(IClass cls,int nargs){
  JSInstructionFactory insts=(JSInstructionFactory)cls.getClassLoader().getInstructionFactory();
  Object key=Pair.make(cls,new Integer(nargs));
  if (constructors.containsKey(key))   return constructors.get(key);
  MethodReference ref=JavaScriptMethods.makeCtorReference(cls.getReference());
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs + 1);
  S.addStatement(insts.GetInstruction(S.getNumberOfStatements(),nargs + 4,1,""String_Node_Str""));
  S.getNextProgramCounter();
  S.addStatement(insts.NewInstruction(S.getNumberOfStatements(),nargs + 5,NewSiteReference.make(S.getNextProgramCounter(),JavaScriptTypes.Object)));
  S.addStatement(insts.SetPrototype(S.getNumberOfStatements(),nargs + 5,nargs + 4));
  S.getNextProgramCounter();
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  int[] args=new int[nargs + 1];
  args[0]=nargs + 5;
  for (int i=0; i < nargs; i++)   args[i + 1]=i + 2;
  S.addStatement(insts.Invoke(1,nargs + 7,args,nargs + 8,cs));
  int pc=S.getNextProgramCounter();
  S.addConstant(nargs + 9,null);
  S.addStatement(insts.ConditionalBranchInstruction(S.getNumberOfStatements(),Operator.EQ,JavaScriptTypes.Root,nargs + 7,nargs + 9,pc + 2));
  S.getNextProgramCounter();
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),nargs + 7,false));
  S.getNextProgramCounter();
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),nargs + 5,false));
  S.getNextProgramCounter();
  return record(key,new JavaScriptConstructor(ref,S,cls,cls));
}","private IMethod makeFunctionObjectConstructor(IClass cls,int nargs){
  JSInstructionFactory insts=(JSInstructionFactory)cls.getClassLoader().getInstructionFactory();
  Object key=Pair.make(cls,new Integer(nargs));
  if (constructors.containsKey(key))   return constructors.get(key);
  MethodReference ref=JavaScriptMethods.makeCtorReference(cls.getReference());
  JavaScriptSummary S=new JavaScriptSummary(ref,nargs + 1);
  S.addStatement(insts.GetInstruction(S.getNumberOfStatements(),nargs + 4,1,""String_Node_Str""));
  S.getNextProgramCounter();
  S.addStatement(insts.NewInstruction(S.getNumberOfStatements(),nargs + 5,NewSiteReference.make(S.getNextProgramCounter(),JavaScriptTypes.Object)));
  S.addStatement(insts.SetPrototype(S.getNumberOfStatements(),nargs + 5,nargs + 4));
  S.getNextProgramCounter();
  CallSiteReference cs=new JSCallSiteReference(S.getNextProgramCounter());
  int[] args=new int[nargs + 1];
  args[0]=nargs + 5;
  for (int i=0; i < nargs; i++)   args[i + 1]=i + 2;
  S.addStatement(insts.Invoke(S.getNumberOfStatements(),1,nargs + 7,args,nargs + 8,cs));
  int pc=S.getNextProgramCounter();
  S.addConstant(nargs + 9,null);
  S.addStatement(insts.ConditionalBranchInstruction(S.getNumberOfStatements(),Operator.EQ,JavaScriptTypes.Root,nargs + 7,nargs + 9,pc + 2));
  S.getNextProgramCounter();
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),nargs + 7,false));
  S.getNextProgramCounter();
  S.addStatement(insts.ReturnInstruction(S.getNumberOfStatements(),nargs + 5,false));
  S.getNextProgramCounter();
  return record(key,new JavaScriptConstructor(ref,S,cls,cls));
}",0.9918851435705368
99692,"protected void parseBytecode(){
  logger.debug(""String_Node_Str"" + eMethod.getClass().getSimpleName() + ""String_Node_Str""+ eMethod.method.getMethodString());
  org.jf.dexlib.Code.Instruction[] instrucs=eMethod.codeItem.getInstructions();
  logger.debug(""String_Node_Str"" + eMethod.method.getMethodString() + ""String_Node_Str""+ instrucs.length);
  instructions=new InstructionArray();
  int instLoc=0;
  int instCounter=-1;
  int currentCodeAddress=0;
  for (  org.jf.dexlib.Code.Instruction inst : instrucs) {
    totalInsts++;
    instCounter++;
    instLoc=currentCodeAddress;
    logger.debug(""String_Node_Str"" + instCounter + ""String_Node_Str""+ instLoc+ ""String_Node_Str""+ inst.opcode.name()+ ""String_Node_Str""+ inst.getFormat());
switch (inst.opcode) {
case NOP:
switch (inst.getFormat()) {
case ArrayData:
{
          for (int i=0; i < instructions.size(); i++) {
            if (instructions.getFromId(i) instanceof ArrayFill)             if (instLoc == (((ArrayFill)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
              ((ArrayFill)getInstructionFromIndex(i)).setArrayDataTable((ArrayDataPseudoInstruction)inst);
              break;
            }
          }
          break;
        }
case PackedSwitchData:
      for (int i=0; i < instructions.size(); i++) {
        if (instructions.getFromId(i) instanceof Switch)         if (instLoc == (((Switch)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
          ((Switch)getInstructionFromIndex(i)).setSwitchPad(new PackedSwitchPad(((PackedSwitchDataPseudoInstruction)inst),getAddressFromIndex(i + 1) - getAddressFromIndex(i)));
          break;
        }
      }
    break;
case SparseSwitchData:
{
    for (int i=0; i < instructions.size(); i++) {
      if (instructions.getFromId(i) instanceof Switch)       if (instLoc == (((Switch)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
        ((Switch)getInstructionFromIndex(i)).setSwitchPad(new SparseSwitchPad(((SparseSwitchDataPseudoInstruction)inst),getAddressFromIndex(i + 1) - getAddressFromIndex(i)));
        break;
      }
    }
    break;
  }
case UnresolvedOdexInstruction:
throw new RuntimeException(""String_Node_Str"" + inst.opcode.toString() + inst.getFormat());
default :
break;
}
break;
case MOVE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_RESULT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_RESULT_WIDE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_RESULT_OBJECT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_EXCEPTION:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getExceptionReg(),inst.opcode,this));
break;
case RETURN_VOID:
instructions.add(new Return.ReturnVoid(instLoc,inst.opcode,this));
break;
case RETURN:
instructions.add(new Return.ReturnSingle(instLoc,((Instruction11x)inst).getRegisterA(),true,inst.opcode,this));
break;
case RETURN_WIDE:
instructions.add(new Return.ReturnDouble(instLoc,((Instruction11x)inst).getRegisterA(),((Instruction11x)inst).getRegisterA() + 1,inst.opcode,this));
break;
case RETURN_OBJECT:
instructions.add(new Return.ReturnSingle(instLoc,((Instruction11x)inst).getRegisterA(),false,inst.opcode,this));
break;
case CONST_4:
{
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction11n)inst).getLiteral(),((Instruction11n)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction11n)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction11n)inst).getLiteral());
break;
}
case CONST_16:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction21s)inst).getLiteral(),((Instruction21s)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21s)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21s)inst).getLiteral());
break;
case CONST:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction31i)inst).getLiteral(),((Instruction31i)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction31i)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction31i)inst).getLiteral());
break;
case CONST_HIGH16:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction21h)inst).getLiteral(),((Instruction21h)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE_16:
instructions.add(new Constant.LongConstant(instLoc,((Instruction21s)inst).getLiteral(),((Instruction21s)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21s)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21s)inst).getLiteral());
break;
case CONST_WIDE_32:
instructions.add(new Constant.LongConstant(instLoc,((Instruction31i)inst).getLiteral(),((Instruction31i)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE:
instructions.add(new Constant.LongConstant(instLoc,((Instruction51l)inst).getLiteral(),((Instruction51l)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE_HIGH16:
instructions.add(new Constant.LongConstant(instLoc,((Instruction21h)inst).getLiteral(),((Instruction21h)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21h)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21h)inst).getLiteral());
break;
case CONST_STRING:
instructions.add(new Constant.StringConstant(instLoc,((StringIdItem)((Instruction21c)inst).getReferencedItem()).getStringValue(),((Instruction21c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((StringIdItem)((Instruction21c)inst).getReferencedItem()).getStringValue());
break;
case CONST_STRING_JUMBO:
instructions.add(new Constant.StringConstant(instLoc,((StringIdItem)((Instruction31c)inst).getReferencedItem()).getStringValue(),((Instruction31c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((StringIdItem)((Instruction31c)inst).getReferencedItem()).getStringValue());
break;
case CONST_CLASS:
{
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
TypeReference typeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname);
instructions.add(new Constant.ClassConstant(instLoc,typeRef,((Instruction21c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + cname+ ""String_Node_Str""+ this.myClass.getClassLoader().lookupClass(TypeName.findOrCreate(cname)));
break;
}
case MONITOR_ENTER:
instructions.add(new Monitor(instLoc,true,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case MONITOR_EXIT:
instructions.add(new Monitor(instLoc,false,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case CHECK_CAST:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new CheckCast(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname),((Instruction21c)inst).getRegisterA(),inst.opcode,this));
break;
}
case INSTANCE_OF:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new InstanceOf(instLoc,((Instruction22c)inst).getRegisterA(),TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname),((Instruction22c)inst).getRegisterB(),inst.opcode,this));
break;
}
case ARRAY_LENGTH:
instructions.add(new ArrayLength(instLoc,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEW_INSTANCE:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
logger.info(""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
instructions.add(new New(instLoc,((Instruction21c)inst).getRegisterA(),NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname)),inst.opcode,this));
break;
}
case NEW_ARRAY:
{
int[] params=new int[1];
params[0]=((Instruction22c)inst).getRegisterB();
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new NewArray(instLoc,((Instruction22c)inst).getRegisterA(),NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname)),params,inst.opcode,this));
break;
}
case FILLED_NEW_ARRAY:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] params=new int[1];
params[0]=registerCount;
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
NewSiteReference newSiteRef=NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname));
TypeReference myTypeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),newSiteRef.getDeclaredType().getArrayElementType().getName().toString());
instructions.add(new NewArrayFilled(instLoc,getReturnReg(),newSiteRef,myTypeRef,params,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor() + ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
logger.debug(registerCount + ""String_Node_Str"");
for (int temp_i=0; temp_i < registerCount; temp_i++) logger.debug(""String_Node_Str"" + args[temp_i]);
break;
}
case FILLED_NEW_ARRAY_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] params=new int[1];
params[0]=registerCount;
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction3rc)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction3rc)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
NewSiteReference newSiteRef=NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname));
TypeReference myTypeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),newSiteRef.getDeclaredType().getArrayElementType().getName().toString());
instructions.add(new NewArrayFilled(instLoc,getReturnReg(),newSiteRef,myTypeRef,params,args,inst.opcode,this));
break;
}
case FILL_ARRAY_DATA:
TypeReference arrayElementType=findOutArrayElementType(instrucs,instructions.toArray(new Instruction[0]),instCounter);
instructions.add(new ArrayFill(instLoc,((Instruction31t)inst).getRegisterA(),((Instruction31t)inst).getTargetAddressOffset(),TypeReference.findOrCreate(myClass.getClassLoader().getReference(),arrayElementType.getName().toString()),inst.opcode,this));
break;
case THROW:
instructions.add(new Throw(instLoc,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case GOTO:
instructions.add(new Goto(instLoc,((Instruction10t)inst).getTargetAddressOffset(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction10t)inst).getTargetAddressOffset());
break;
case GOTO_16:
instructions.add(new Goto(instLoc,((Instruction20t)inst).getTargetAddressOffset(),inst.opcode,this));
break;
case GOTO_32:
instructions.add(new Goto(instLoc,((Instruction30t)inst).getTargetAddressOffset(),inst.opcode,this));
break;
case PACKED_SWITCH:
case SPARSE_SWITCH:
instructions.add(new Switch(instLoc,((Instruction31t)inst).getRegisterA(),((Instruction31t)inst).getTargetAddressOffset(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + inst.getFormat());
break;
case CMPL_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPG_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPG_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPL_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPG_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPG_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMP_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case IF_EQ:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.EQ,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_NE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.NE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_LT:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.LT,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_GE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.GE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_GT:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.GT,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_LE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.LE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_EQZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.EQZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_NEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.NEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_LTZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.LTZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_GEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.GEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_GTZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.GTZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_LEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.LEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case AGET:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_int,inst.opcode,this));
break;
case AGET_WIDE:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_wide,inst.opcode,this));
break;
case AGET_OBJECT:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_object,inst.opcode,this));
break;
case AGET_BOOLEAN:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_boolean,inst.opcode,this));
break;
case AGET_BYTE:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_byte,inst.opcode,this));
break;
case AGET_CHAR:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_char,inst.opcode,this));
break;
case AGET_SHORT:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_short,inst.opcode,this));
break;
case APUT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_int,inst.opcode,this));
break;
case APUT_WIDE:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_wide,inst.opcode,this));
break;
case APUT_OBJECT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_object,inst.opcode,this));
break;
case APUT_BOOLEAN:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_boolean,inst.opcode,this));
break;
case APUT_BYTE:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_byte,inst.opcode,this));
break;
case APUT_CHAR:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_char,inst.opcode,this));
break;
case APUT_SHORT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_short,inst.opcode,this));
break;
case IGET:
case IGET_WIDE:
case IGET_OBJECT:
case IGET_BOOLEAN:
case IGET_BYTE:
case IGET_CHAR:
case IGET_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new GetField.GetInstanceField(instLoc,((Instruction22c)inst).getRegisterA(),((Instruction22c)inst).getRegisterB(),cname,fname,ftname,inst.opcode,this));
break;
}
case IPUT:
case IPUT_WIDE:
case IPUT_OBJECT:
case IPUT_BOOLEAN:
case IPUT_BYTE:
case IPUT_CHAR:
case IPUT_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new PutField.PutInstanceField(instLoc,((Instruction22c)inst).getRegisterA(),((Instruction22c)inst).getRegisterB(),cname,fname,ftname,inst.opcode,this));
break;
}
case SGET:
case SGET_WIDE:
case SGET_OBJECT:
case SGET_BOOLEAN:
case SGET_BYTE:
case SGET_CHAR:
case SGET_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new GetField.GetStaticField(instLoc,((Instruction21c)inst).getRegisterA(),cname,fname,ftname,inst.opcode,this));
break;
}
case SPUT:
case SPUT_WIDE:
case SPUT_OBJECT:
case SPUT_BOOLEAN:
case SPUT_BYTE:
case SPUT_CHAR:
case SPUT_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new PutField.PutStaticField(instLoc,((Instruction21c)inst).getRegisterA(),cname,fname,ftname,inst.opcode,this));
break;
}
case INVOKE_VIRTUAL:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
handleINVOKE_VIRTUAL(instLoc,cname,mname,pname,args,inst.opcode);
break;
}
case INVOKE_SUPER:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeSuper(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + cname + ""String_Node_Str""+ mname+ ""String_Node_Str""+ pname);
break;
}
case INVOKE_DIRECT:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeDirect(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor() + ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString()+ ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
break;
}
case INVOKE_STATIC:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeStatic(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor() + ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString()+ ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
break;
}
case INVOKE_INTERFACE:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeInterface(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_VIRTUAL_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeVirtual(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_SUPER_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeSuper(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_DIRECT_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeDirect(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_STATIC_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeStatic(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_INTERFACE_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeInterface(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case NEG_INT:
instructions.add(new UnaryOperation(instLoc,OpID.NEGINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NOT_INT:
instructions.add(new UnaryOperation(instLoc,OpID.NOTINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.NEGLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NOT_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.NOTLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.NEGFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.NEGDOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.INTTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_BYTE:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOBYTE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_CHAR:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOCHAR,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_SHORT:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOSHORT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case AND_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case OR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case XOR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHL_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case USHR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case AND_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case OR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case XOR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHL_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case USHR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case AND_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case OR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case XOR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHL_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case USHR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case AND_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case OR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case XOR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHL_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case USHR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.ADD_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case RSUB_INT:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.RSUB_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case MUL_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.MUL_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case DIV_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.DIV_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case REM_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.REM_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case AND_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.AND_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case OR_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.OR_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case XOR_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.XOR_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case ADD_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.ADD_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case RSUB_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.RSUB_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case MUL_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.MUL_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case DIV_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.DIV_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case REM_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.REM_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case AND_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.AND_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case OR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.OR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case XOR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.XOR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case SHL_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.SHL_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case SHR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.SHR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case USHR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.USHR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
default :
throw new RuntimeException(""String_Node_Str"" + inst.opcode.toString());
}
currentCodeAddress+=inst.getSize(currentCodeAddress);
}
logger.debug(""String_Node_Str"" + this.toString() + ""String_Node_Str"");
}","protected void parseBytecode(){
  logger.debug(""String_Node_Str"" + eMethod.getClass().getSimpleName() + ""String_Node_Str""+ eMethod.method.getMethodString());
  org.jf.dexlib.Code.Instruction[] instrucs=eMethod.codeItem.getInstructions();
  logger.debug(""String_Node_Str"" + eMethod.method.getMethodString() + ""String_Node_Str""+ instrucs.length);
  instructions=new InstructionArray();
  int instLoc=0;
  int instCounter=-1;
  int currentCodeAddress=0;
  for (  org.jf.dexlib.Code.Instruction inst : instrucs) {
    totalInsts++;
    instCounter++;
    instLoc=currentCodeAddress;
    logger.debug(""String_Node_Str"" + instCounter + ""String_Node_Str""+ instLoc+ ""String_Node_Str""+ inst.opcode.name()+ ""String_Node_Str""+ inst.getFormat());
switch (inst.opcode) {
case NOP:
switch (inst.getFormat()) {
case ArrayData:
{
          for (int i=0; i < instructions.size(); i++) {
            if (instructions.getFromId(i) instanceof ArrayFill)             if (instLoc == (((ArrayFill)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
              ((ArrayFill)getInstructionFromIndex(i)).setArrayDataTable((ArrayDataPseudoInstruction)inst);
              break;
            }
          }
          break;
        }
case PackedSwitchData:
      for (int i=0; i < instructions.size(); i++) {
        if (instructions.getFromId(i) instanceof Switch)         if (instLoc == (((Switch)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
          ((Switch)getInstructionFromIndex(i)).setSwitchPad(new PackedSwitchPad(((PackedSwitchDataPseudoInstruction)inst),getAddressFromIndex(i + 1) - getAddressFromIndex(i)));
          break;
        }
      }
    break;
case SparseSwitchData:
{
    for (int i=0; i < instructions.size(); i++) {
      if (instructions.getFromId(i) instanceof Switch)       if (instLoc == (((Switch)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
        ((Switch)getInstructionFromIndex(i)).setSwitchPad(new SparseSwitchPad(((SparseSwitchDataPseudoInstruction)inst),getAddressFromIndex(i + 1) - getAddressFromIndex(i)));
        break;
      }
    }
    break;
  }
case UnresolvedOdexInstruction:
throw new RuntimeException(""String_Node_Str"" + inst.opcode.toString() + inst.getFormat());
default :
break;
}
break;
case MOVE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_RESULT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_RESULT_WIDE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_RESULT_OBJECT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_EXCEPTION:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getExceptionReg(),inst.opcode,this));
break;
case RETURN_VOID:
instructions.add(new Return.ReturnVoid(instLoc,inst.opcode,this));
break;
case RETURN:
instructions.add(new Return.ReturnSingle(instLoc,((Instruction11x)inst).getRegisterA(),true,inst.opcode,this));
break;
case RETURN_WIDE:
instructions.add(new Return.ReturnDouble(instLoc,((Instruction11x)inst).getRegisterA(),((Instruction11x)inst).getRegisterA() + 1,inst.opcode,this));
break;
case RETURN_OBJECT:
instructions.add(new Return.ReturnSingle(instLoc,((Instruction11x)inst).getRegisterA(),false,inst.opcode,this));
break;
case CONST_4:
{
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction11n)inst).getLiteral(),((Instruction11n)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction11n)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction11n)inst).getLiteral());
break;
}
case CONST_16:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction21s)inst).getLiteral(),((Instruction21s)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21s)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21s)inst).getLiteral());
break;
case CONST:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction31i)inst).getLiteral(),((Instruction31i)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction31i)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction31i)inst).getLiteral());
break;
case CONST_HIGH16:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction21h)inst).getLiteral() << 16,((Instruction21h)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE_16:
instructions.add(new Constant.LongConstant(instLoc,((Instruction21s)inst).getLiteral(),((Instruction21s)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21s)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21s)inst).getLiteral());
break;
case CONST_WIDE_32:
instructions.add(new Constant.LongConstant(instLoc,((Instruction31i)inst).getLiteral(),((Instruction31i)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE:
instructions.add(new Constant.LongConstant(instLoc,((Instruction51l)inst).getLiteral(),((Instruction51l)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE_HIGH16:
instructions.add(new Constant.LongConstant(instLoc,((Instruction21h)inst).getLiteral() << 16,((Instruction21h)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21h)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21h)inst).getLiteral());
break;
case CONST_STRING:
instructions.add(new Constant.StringConstant(instLoc,((StringIdItem)((Instruction21c)inst).getReferencedItem()).getStringValue(),((Instruction21c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((StringIdItem)((Instruction21c)inst).getReferencedItem()).getStringValue());
break;
case CONST_STRING_JUMBO:
instructions.add(new Constant.StringConstant(instLoc,((StringIdItem)((Instruction31c)inst).getReferencedItem()).getStringValue(),((Instruction31c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((StringIdItem)((Instruction31c)inst).getReferencedItem()).getStringValue());
break;
case CONST_CLASS:
{
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
TypeReference typeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname);
instructions.add(new Constant.ClassConstant(instLoc,typeRef,((Instruction21c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + cname+ ""String_Node_Str""+ this.myClass.getClassLoader().lookupClass(TypeName.findOrCreate(cname)));
break;
}
case MONITOR_ENTER:
instructions.add(new Monitor(instLoc,true,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case MONITOR_EXIT:
instructions.add(new Monitor(instLoc,false,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case CHECK_CAST:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new CheckCast(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname),((Instruction21c)inst).getRegisterA(),inst.opcode,this));
break;
}
case INSTANCE_OF:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new InstanceOf(instLoc,((Instruction22c)inst).getRegisterA(),TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname),((Instruction22c)inst).getRegisterB(),inst.opcode,this));
break;
}
case ARRAY_LENGTH:
instructions.add(new ArrayLength(instLoc,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEW_INSTANCE:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
logger.info(""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
instructions.add(new New(instLoc,((Instruction21c)inst).getRegisterA(),NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname)),inst.opcode,this));
break;
}
case NEW_ARRAY:
{
int[] params=new int[1];
params[0]=((Instruction22c)inst).getRegisterB();
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new NewArray(instLoc,((Instruction22c)inst).getRegisterA(),NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname)),params,inst.opcode,this));
break;
}
case FILLED_NEW_ARRAY:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] params=new int[1];
params[0]=registerCount;
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
NewSiteReference newSiteRef=NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname));
TypeReference myTypeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),newSiteRef.getDeclaredType().getArrayElementType().getName().toString());
instructions.add(new NewArrayFilled(instLoc,getReturnReg(),newSiteRef,myTypeRef,params,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor() + ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
logger.debug(registerCount + ""String_Node_Str"");
for (int temp_i=0; temp_i < registerCount; temp_i++) logger.debug(""String_Node_Str"" + args[temp_i]);
break;
}
case FILLED_NEW_ARRAY_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] params=new int[1];
params[0]=registerCount;
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction3rc)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction3rc)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
NewSiteReference newSiteRef=NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname));
TypeReference myTypeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),newSiteRef.getDeclaredType().getArrayElementType().getName().toString());
instructions.add(new NewArrayFilled(instLoc,getReturnReg(),newSiteRef,myTypeRef,params,args,inst.opcode,this));
break;
}
case FILL_ARRAY_DATA:
TypeReference arrayElementType=findOutArrayElementType(instrucs,instructions.toArray(new Instruction[0]),instCounter);
instructions.add(new ArrayFill(instLoc,((Instruction31t)inst).getRegisterA(),((Instruction31t)inst).getTargetAddressOffset(),TypeReference.findOrCreate(myClass.getClassLoader().getReference(),arrayElementType.getName().toString()),inst.opcode,this));
break;
case THROW:
instructions.add(new Throw(instLoc,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case GOTO:
instructions.add(new Goto(instLoc,((Instruction10t)inst).getTargetAddressOffset(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction10t)inst).getTargetAddressOffset());
break;
case GOTO_16:
instructions.add(new Goto(instLoc,((Instruction20t)inst).getTargetAddressOffset(),inst.opcode,this));
break;
case GOTO_32:
instructions.add(new Goto(instLoc,((Instruction30t)inst).getTargetAddressOffset(),inst.opcode,this));
break;
case PACKED_SWITCH:
case SPARSE_SWITCH:
instructions.add(new Switch(instLoc,((Instruction31t)inst).getRegisterA(),((Instruction31t)inst).getTargetAddressOffset(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + inst.getFormat());
break;
case CMPL_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPG_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPG_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPL_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPG_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPG_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMP_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case IF_EQ:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.EQ,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_NE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.NE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_LT:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.LT,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_GE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.GE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_GT:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.GT,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_LE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.LE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_EQZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.EQZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_NEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.NEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_LTZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.LTZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_GEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.GEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_GTZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.GTZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_LEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.LEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case AGET:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_int,inst.opcode,this));
break;
case AGET_WIDE:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_wide,inst.opcode,this));
break;
case AGET_OBJECT:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_object,inst.opcode,this));
break;
case AGET_BOOLEAN:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_boolean,inst.opcode,this));
break;
case AGET_BYTE:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_byte,inst.opcode,this));
break;
case AGET_CHAR:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_char,inst.opcode,this));
break;
case AGET_SHORT:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_short,inst.opcode,this));
break;
case APUT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_int,inst.opcode,this));
break;
case APUT_WIDE:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_wide,inst.opcode,this));
break;
case APUT_OBJECT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_object,inst.opcode,this));
break;
case APUT_BOOLEAN:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_boolean,inst.opcode,this));
break;
case APUT_BYTE:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_byte,inst.opcode,this));
break;
case APUT_CHAR:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_char,inst.opcode,this));
break;
case APUT_SHORT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_short,inst.opcode,this));
break;
case IGET:
case IGET_WIDE:
case IGET_OBJECT:
case IGET_BOOLEAN:
case IGET_BYTE:
case IGET_CHAR:
case IGET_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new GetField.GetInstanceField(instLoc,((Instruction22c)inst).getRegisterA(),((Instruction22c)inst).getRegisterB(),cname,fname,ftname,inst.opcode,this));
break;
}
case IPUT:
case IPUT_WIDE:
case IPUT_OBJECT:
case IPUT_BOOLEAN:
case IPUT_BYTE:
case IPUT_CHAR:
case IPUT_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new PutField.PutInstanceField(instLoc,((Instruction22c)inst).getRegisterA(),((Instruction22c)inst).getRegisterB(),cname,fname,ftname,inst.opcode,this));
break;
}
case SGET:
case SGET_WIDE:
case SGET_OBJECT:
case SGET_BOOLEAN:
case SGET_BYTE:
case SGET_CHAR:
case SGET_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new GetField.GetStaticField(instLoc,((Instruction21c)inst).getRegisterA(),cname,fname,ftname,inst.opcode,this));
break;
}
case SPUT:
case SPUT_WIDE:
case SPUT_OBJECT:
case SPUT_BOOLEAN:
case SPUT_BYTE:
case SPUT_CHAR:
case SPUT_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new PutField.PutStaticField(instLoc,((Instruction21c)inst).getRegisterA(),cname,fname,ftname,inst.opcode,this));
break;
}
case INVOKE_VIRTUAL:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
handleINVOKE_VIRTUAL(instLoc,cname,mname,pname,args,inst.opcode);
break;
}
case INVOKE_SUPER:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeSuper(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + cname + ""String_Node_Str""+ mname+ ""String_Node_Str""+ pname);
break;
}
case INVOKE_DIRECT:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeDirect(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor() + ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString()+ ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
break;
}
case INVOKE_STATIC:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeStatic(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor() + ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString()+ ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
break;
}
case INVOKE_INTERFACE:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeInterface(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_VIRTUAL_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeVirtual(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_SUPER_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeSuper(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_DIRECT_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeDirect(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_STATIC_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeStatic(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_INTERFACE_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeInterface(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case NEG_INT:
instructions.add(new UnaryOperation(instLoc,OpID.NEGINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NOT_INT:
instructions.add(new UnaryOperation(instLoc,OpID.NOTINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.NEGLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NOT_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.NOTLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.NEGFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.NEGDOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.INTTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_BYTE:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOBYTE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_CHAR:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOCHAR,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_SHORT:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOSHORT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case AND_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case OR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case XOR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHL_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case USHR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case AND_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case OR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case XOR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHL_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case USHR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case AND_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case OR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case XOR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHL_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case USHR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case AND_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case OR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case XOR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHL_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case USHR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.ADD_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case RSUB_INT:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.RSUB_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case MUL_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.MUL_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case DIV_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.DIV_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case REM_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.REM_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case AND_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.AND_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case OR_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.OR_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case XOR_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.XOR_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case ADD_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.ADD_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case RSUB_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.RSUB_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case MUL_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.MUL_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case DIV_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.DIV_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case REM_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.REM_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case AND_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.AND_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case OR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.OR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case XOR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.XOR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case SHL_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.SHL_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case SHR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.SHR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case USHR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.USHR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
default :
throw new RuntimeException(""String_Node_Str"" + inst.opcode.toString());
}
currentCodeAddress+=inst.getSize(currentCodeAddress);
}
logger.debug(""String_Node_Str"" + this.toString() + ""String_Node_Str"");
}",0.999909412084428
99693,"@Override public int getLastCol(){
  return e.getSource().getRowColumnVector(e.getEnd()).getColumn();
}","@Override public int getLastCol(){
  return -1;
}",0.618421052631579
99694,"private Position getPosition(final Segment e){
  return new AbstractSourcePosition(){
    @Override public int getFirstLine(){
      return e.getSource().getRowColumnVector(e.getBegin()).getRow();
    }
    @Override public int getLastLine(){
      return e.getSource().getRowColumnVector(e.getEnd()).getRow();
    }
    @Override public int getFirstCol(){
      return e.getSource().getRowColumnVector(e.getBegin()).getColumn();
    }
    @Override public int getLastCol(){
      return e.getSource().getRowColumnVector(e.getEnd()).getColumn();
    }
    @Override public int getFirstOffset(){
      return e.getBegin();
    }
    @Override public int getLastOffset(){
      return e.getEnd();
    }
    @Override public URL getURL(){
      try {
        return new URL(""String_Node_Str"" + sourceFile);
      }
 catch (      MalformedURLException e) {
        return null;
      }
    }
    @Override public InputStream getInputStream() throws IOException {
      return new FileInputStream(sourceFile);
    }
  }
;
}","private Position getPosition(final Segment e){
  return new AbstractSourcePosition(){
    @Override public int getFirstLine(){
      return e.getSource().getRowColumnVector(e.getBegin()).getRow();
    }
    @Override public int getLastLine(){
      return e.getSource().getRowColumnVector(e.getEnd()).getRow();
    }
    @Override public int getFirstCol(){
      return -1;
    }
    @Override public int getLastCol(){
      return -1;
    }
    @Override public int getFirstOffset(){
      return e.getBegin();
    }
    @Override public int getLastOffset(){
      return e.getEnd();
    }
    @Override public URL getURL(){
      try {
        return new URL(""String_Node_Str"" + sourceFile);
      }
 catch (      MalformedURLException e) {
        return null;
      }
    }
    @Override public Reader getReader() throws IOException {
      return new FileReader(sourceFile);
    }
  }
;
}",0.847723704866562
99695,"public Pair<Integer,String> getBodyText(){
  Segment content=innerElement.getContent();
  Integer lineNum=innerElement.getSource().getRow(content.getBegin());
  String body=content.toString();
  return Pair.make(lineNum,body);
}","public Pair<Integer,String> getBodyText(){
  Segment content=innerElement.getContent();
  Integer lineNum=innerElement.getSource().getRow(content.getBegin());
  String body=content.toString().replace(content.getSource().getNewLine(),""String_Node_Str"");
  return Pair.make(lineNum,body);
}",0.8837209302325582
99696,"@Override public int getFirstCol(){
  return e.getSource().getRowColumnVector(e.getBegin()).getColumn();
}","@Override public int getFirstCol(){
  return -1;
}",0.6153846153846154
99697,"public SourceBuffer(Position p) throws IOException {
  this.p=p;
  BufferedReader reader=new BufferedReader(new InputStreamReader(p.getInputStream()));
  String currentLine=null;
  List<String> lines=new ArrayList<String>();
  int offset=0, line=0;
  do {
    currentLine=reader.readLine();
    if (currentLine == null) {
      this.lines=new String[0];
      return;
    }
    offset+=(currentLine.length() + 1);
    line++;
  }
 while (p.getLastOffset() >= 0 ? p.getFirstOffset() > offset : p.getFirstLine() > line);
  if (p.getLastOffset() >= 0) {
    if (p.getFirstOffset() == offset) {
      lines.add(""String_Node_Str"");
    }
 else {
      lines.add(currentLine.substring(p.getFirstOffset() - (offset - currentLine.length() - 1)));
    }
  }
 else {
    lines.add(currentLine.substring(p.getFirstCol()));
  }
  while (p.getLastOffset() >= 0 ? p.getLastOffset() >= offset : p.getLastLine() >= line) {
    currentLine=reader.readLine();
    if (currentLine == null) {
      offset=p.getLastOffset();
      break;
    }
 else {
      offset+=currentLine.length() + 1;
    }
    line++;
    if (p.getLastOffset() >= 0) {
      if (offset > p.getLastOffset()) {
        lines.add(currentLine.substring(0,currentLine.length() - (offset - p.getLastOffset()) + 1));
      }
 else {
        lines.add(currentLine);
      }
    }
 else {
      if (p.getLastLine() == line) {
        lines.add(currentLine.substring(0,p.getLastCol()));
      }
 else {
        lines.add(currentLine);
      }
    }
  }
  this.lines=lines.toArray(new String[lines.size()]);
}","public SourceBuffer(Position p) throws IOException {
  this.p=p;
  BufferedReader reader=new BufferedReader(p.getReader());
  String currentLine=null;
  List<String> lines=new ArrayList<String>();
  int offset=0, line=0;
  do {
    currentLine=reader.readLine();
    if (currentLine == null) {
      this.lines=new String[0];
      return;
    }
    offset+=(currentLine.length() + 1);
    line++;
  }
 while (p.getLastOffset() >= 0 ? p.getFirstOffset() > offset : p.getFirstLine() > line);
  if (p.getLastOffset() >= 0) {
    if (p.getFirstOffset() == offset) {
      lines.add(""String_Node_Str"");
    }
 else {
      int startOffset=p.getFirstOffset() - (offset - currentLine.length() - 1);
      if (offset > p.getLastOffset()) {
        int endOffset=p.getLastOffset() - (offset - currentLine.length() - 1);
        lines.add(currentLine.substring(startOffset,endOffset));
      }
 else {
        lines.add(currentLine.substring(startOffset));
      }
    }
  }
 else {
    lines.add(currentLine.substring(p.getFirstCol()));
  }
  while (p.getLastOffset() >= 0 ? p.getLastOffset() >= offset : p.getLastLine() >= line) {
    currentLine=reader.readLine();
    if (currentLine == null) {
      offset=p.getLastOffset();
      break;
    }
 else {
      offset+=currentLine.length() + 1;
    }
    line++;
    if (p.getLastOffset() >= 0) {
      if (offset > p.getLastOffset()) {
        lines.add(currentLine.substring(0,currentLine.length() - (offset - p.getLastOffset()) + 1));
      }
 else {
        lines.add(currentLine);
      }
    }
 else {
      if (p.getLastLine() == line) {
        lines.add(currentLine.substring(0,p.getLastCol()));
      }
 else {
        lines.add(currentLine);
      }
    }
  }
  this.lines=lines.toArray(new String[lines.size()]);
}",0.8793259103219982
99698,"public void substitute(Position range,String newText){
  int startLine=range.getFirstLine() - p.getFirstLine();
  int endLine=range.getLastLine() - p.getFirstLine();
  if (startLine != endLine) {
    String newLines[]=new String[lines.length - (endLine - startLine)];
    int i=0;
    while (i < startLine) {
      newLines[i]=lines[i];
      i++;
    }
    newLines[i++]=lines[startLine].substring(0,range.getFirstCol()) + lines[endLine].substring(range.getLastCol());
    while (i < newLines.length) {
      newLines[i]=lines[i + (endLine - startLine)];
      i++;
    }
    lines=newLines;
    endLine=startLine;
    final Position hack=range;
    range=new AbstractSourcePosition(){
      @Override public int getFirstLine(){
        return hack.getFirstLine();
      }
      @Override public int getLastLine(){
        return hack.getFirstLine();
      }
      @Override public int getFirstCol(){
        return hack.getFirstCol();
      }
      @Override public int getLastCol(){
        return hack.getFirstCol();
      }
      @Override public int getFirstOffset(){
        return hack.getFirstOffset();
      }
      @Override public int getLastOffset(){
        return hack.getFirstOffset();
      }
      @Override public URL getURL(){
        return hack.getURL();
      }
      @Override public InputStream getInputStream() throws IOException {
        return hack.getInputStream();
      }
    }
;
  }
  String[] newTextLines=newText.split(""String_Node_Str"");
  if (newTextLines.length == 1) {
    lines[startLine]=lines[startLine].substring(0,range.getFirstCol()) + newTextLines[0] + lines[startLine].substring(range.getLastCol() + 1);
  }
 else {
    String[] newLines=new String[lines.length + newTextLines.length - 1];
    int i=0;
    while (i < startLine) {
      newLines[i]=lines[i];
      i++;
    }
    newLines[i++]=lines[startLine].substring(0,range.getFirstCol()) + newTextLines[0];
    for (int j=1; j < newTextLines.length - 1; j++) {
      lines[i++]=newTextLines[j];
    }
    newLines[i++]=newTextLines[newTextLines.length - 1] + lines[endLine].substring(range.getLastCol() + 1);
    while (i < newLines.length) {
      newLines[i]=lines[i - newTextLines.length + 1];
      i++;
    }
    lines=newLines;
  }
}","public void substitute(Position range,String newText){
  int startLine=range.getFirstLine() - p.getFirstLine();
  int endLine=range.getLastLine() - p.getFirstLine();
  if (startLine != endLine) {
    String newLines[]=new String[lines.length - (endLine - startLine)];
    int i=0;
    while (i < startLine) {
      newLines[i]=lines[i];
      i++;
    }
    newLines[i++]=lines[startLine].substring(0,range.getFirstCol()) + lines[endLine].substring(range.getLastCol());
    while (i < newLines.length) {
      newLines[i]=lines[i + (endLine - startLine)];
      i++;
    }
    lines=newLines;
    endLine=startLine;
    final Position hack=range;
    range=new AbstractSourcePosition(){
      @Override public int getFirstLine(){
        return hack.getFirstLine();
      }
      @Override public int getLastLine(){
        return hack.getFirstLine();
      }
      @Override public int getFirstCol(){
        return hack.getFirstCol();
      }
      @Override public int getLastCol(){
        return hack.getFirstCol();
      }
      @Override public int getFirstOffset(){
        return hack.getFirstOffset();
      }
      @Override public int getLastOffset(){
        return hack.getFirstOffset();
      }
      @Override public URL getURL(){
        return hack.getURL();
      }
      @Override public Reader getReader() throws IOException {
        return hack.getReader();
      }
    }
;
  }
  String[] newTextLines=newText.split(""String_Node_Str"");
  if (newTextLines.length == 1) {
    lines[startLine]=lines[startLine].substring(0,range.getFirstCol()) + newTextLines[0] + lines[startLine].substring(range.getLastCol() + 1);
  }
 else {
    String[] newLines=new String[lines.length + newTextLines.length - 1];
    int i=0;
    while (i < startLine) {
      newLines[i]=lines[i];
      i++;
    }
    newLines[i++]=lines[startLine].substring(0,range.getFirstCol()) + newTextLines[0];
    for (int j=1; j < newTextLines.length - 1; j++) {
      lines[i++]=newTextLines[j];
    }
    newLines[i++]=newTextLines[newTextLines.length - 1] + lines[endLine].substring(range.getLastCol() + 1);
    while (i < newLines.length) {
      newLines[i]=lines[i - newTextLines.length + 1];
      i++;
    }
    lines=newLines;
  }
}",0.9867979413739092
99699,"/** 
 * Add flows from the special primitive functions to the corresponding global variables.
 * @param flowgraph the flow graph under construction
 */
private void addPrimitives(FlowGraph flowgraph){
  VertexFactory factory=flowgraph.getVertexFactory();
  for (  String pf : primitiveFunctions) {
    TypeReference typeref=TypeReference.findOrCreate(JavaScriptTypes.jsLoader,""String_Node_Str"" + pf);
    IClass klass=cha.lookupClass(typeref);
    flowgraph.addEdge(factory.makeFuncVertex(klass),factory.makePropVertex(pf));
  }
}","/** 
 * Add flows from the special primitive functions to the corresponding global variables.
 * @param flowgraph the flow graph under construction
 */
private void addPrimitives(FlowGraph flowgraph){
  VertexFactory factory=flowgraph.getVertexFactory();
  for (  String pf : primitiveFunctions) {
    TypeReference typeref=TypeReference.findOrCreate(JavaScriptTypes.jsLoader,""String_Node_Str"" + pf);
    IClass klass=cha.lookupClass(typeref);
    String prop=pf.endsWith(""String_Node_Str"") ? pf.substring(0,pf.length() - 6) : pf;
    flowgraph.addEdge(factory.makeFuncVertex(klass),factory.makePropVertex(prop));
  }
}",0.9208006962576152
99700,"@Override public int getLastCol(){
  return e.getSource().getRowColumnVector(e.getEnd()).getColumn();
}","@Override public int getLastCol(){
  return -1;
}",0.618421052631579
99701,"private Position getPosition(final Segment e){
  return new AbstractSourcePosition(){
    @Override public int getFirstLine(){
      return e.getSource().getRowColumnVector(e.getBegin()).getRow();
    }
    @Override public int getLastLine(){
      return e.getSource().getRowColumnVector(e.getEnd()).getRow();
    }
    @Override public int getFirstCol(){
      return e.getSource().getRowColumnVector(e.getBegin()).getColumn();
    }
    @Override public int getLastCol(){
      return e.getSource().getRowColumnVector(e.getEnd()).getColumn();
    }
    @Override public int getFirstOffset(){
      return e.getBegin();
    }
    @Override public int getLastOffset(){
      return e.getEnd();
    }
    @Override public URL getURL(){
      try {
        return new URL(""String_Node_Str"" + sourceFile);
      }
 catch (      MalformedURLException e) {
        return null;
      }
    }
    @Override public InputStream getInputStream() throws IOException {
      return new FileInputStream(sourceFile);
    }
  }
;
}","private Position getPosition(final Segment e){
  return new AbstractSourcePosition(){
    @Override public int getFirstLine(){
      return e.getSource().getRowColumnVector(e.getBegin()).getRow();
    }
    @Override public int getLastLine(){
      return e.getSource().getRowColumnVector(e.getEnd()).getRow();
    }
    @Override public int getFirstCol(){
      return -1;
    }
    @Override public int getLastCol(){
      return -1;
    }
    @Override public int getFirstOffset(){
      return e.getBegin();
    }
    @Override public int getLastOffset(){
      return e.getEnd();
    }
    @Override public URL getURL(){
      try {
        return new URL(""String_Node_Str"" + sourceFile);
      }
 catch (      MalformedURLException e) {
        return null;
      }
    }
    @Override public Reader getReader() throws IOException {
      return new FileReader(sourceFile);
    }
  }
;
}",0.847723704866562
99702,"public Pair<Integer,String> getBodyText(){
  Segment content=innerElement.getContent();
  Integer lineNum=innerElement.getSource().getRow(content.getBegin());
  String body=content.toString();
  return Pair.make(lineNum,body);
}","public Pair<Integer,String> getBodyText(){
  Segment content=innerElement.getContent();
  Integer lineNum=innerElement.getSource().getRow(content.getBegin());
  String body=content.toString().replace(content.getSource().getNewLine(),""String_Node_Str"");
  return Pair.make(lineNum,body);
}",0.8837209302325582
99703,"@Override public int getFirstCol(){
  return e.getSource().getRowColumnVector(e.getBegin()).getColumn();
}","@Override public int getFirstCol(){
  return -1;
}",0.6153846153846154
99704,"public SourceBuffer(Position p) throws IOException {
  this.p=p;
  BufferedReader reader=new BufferedReader(new InputStreamReader(p.getInputStream()));
  String currentLine=null;
  List<String> lines=new ArrayList<String>();
  int offset=0, line=0;
  do {
    currentLine=reader.readLine();
    if (currentLine == null) {
      this.lines=new String[0];
      return;
    }
    offset+=(currentLine.length() + 1);
    line++;
  }
 while (p.getLastOffset() >= 0 ? p.getFirstOffset() > offset : p.getFirstLine() > line);
  if (p.getLastOffset() >= 0) {
    if (p.getFirstOffset() == offset) {
      lines.add(""String_Node_Str"");
    }
 else {
      lines.add(currentLine.substring(p.getFirstOffset() - (offset - currentLine.length() - 1)));
    }
  }
 else {
    lines.add(currentLine.substring(p.getFirstCol()));
  }
  while (p.getLastOffset() >= 0 ? p.getLastOffset() >= offset : p.getLastLine() >= line) {
    currentLine=reader.readLine();
    if (currentLine == null) {
      offset=p.getLastOffset();
      break;
    }
 else {
      offset+=currentLine.length() + 1;
    }
    line++;
    if (p.getLastOffset() >= 0) {
      if (offset > p.getLastOffset()) {
        lines.add(currentLine.substring(0,currentLine.length() - (offset - p.getLastOffset()) + 1));
      }
 else {
        lines.add(currentLine);
      }
    }
 else {
      if (p.getLastLine() == line) {
        lines.add(currentLine.substring(0,p.getLastCol()));
      }
 else {
        lines.add(currentLine);
      }
    }
  }
  this.lines=lines.toArray(new String[lines.size()]);
}","public SourceBuffer(Position p) throws IOException {
  this.p=p;
  BufferedReader reader=new BufferedReader(p.getReader());
  String currentLine=null;
  List<String> lines=new ArrayList<String>();
  int offset=0, line=0;
  do {
    currentLine=reader.readLine();
    if (currentLine == null) {
      this.lines=new String[0];
      return;
    }
    offset+=(currentLine.length() + 1);
    line++;
  }
 while (p.getLastOffset() >= 0 ? p.getFirstOffset() > offset : p.getFirstLine() > line);
  if (p.getLastOffset() >= 0) {
    if (p.getFirstOffset() == offset) {
      lines.add(""String_Node_Str"");
    }
 else {
      int startOffset=p.getFirstOffset() - (offset - currentLine.length() - 1);
      if (offset > p.getLastOffset()) {
        int endOffset=p.getLastOffset() - (offset - currentLine.length() - 1);
        lines.add(currentLine.substring(startOffset,endOffset));
      }
 else {
        lines.add(currentLine.substring(startOffset));
      }
    }
  }
 else {
    lines.add(currentLine.substring(p.getFirstCol()));
  }
  while (p.getLastOffset() >= 0 ? p.getLastOffset() >= offset : p.getLastLine() >= line) {
    currentLine=reader.readLine();
    if (currentLine == null) {
      offset=p.getLastOffset();
      break;
    }
 else {
      offset+=currentLine.length() + 1;
    }
    line++;
    if (p.getLastOffset() >= 0) {
      if (offset > p.getLastOffset()) {
        lines.add(currentLine.substring(0,currentLine.length() - (offset - p.getLastOffset()) + 1));
      }
 else {
        lines.add(currentLine);
      }
    }
 else {
      if (p.getLastLine() == line) {
        lines.add(currentLine.substring(0,p.getLastCol()));
      }
 else {
        lines.add(currentLine);
      }
    }
  }
  this.lines=lines.toArray(new String[lines.size()]);
}",0.8793259103219982
99705,"public void substitute(Position range,String newText){
  int startLine=range.getFirstLine() - p.getFirstLine();
  int endLine=range.getLastLine() - p.getFirstLine();
  if (startLine != endLine) {
    String newLines[]=new String[lines.length - (endLine - startLine)];
    int i=0;
    while (i < startLine) {
      newLines[i]=lines[i];
      i++;
    }
    newLines[i++]=lines[startLine].substring(0,range.getFirstCol()) + lines[endLine].substring(range.getLastCol());
    while (i < newLines.length) {
      newLines[i]=lines[i + (endLine - startLine)];
      i++;
    }
    lines=newLines;
    endLine=startLine;
    final Position hack=range;
    range=new AbstractSourcePosition(){
      @Override public int getFirstLine(){
        return hack.getFirstLine();
      }
      @Override public int getLastLine(){
        return hack.getFirstLine();
      }
      @Override public int getFirstCol(){
        return hack.getFirstCol();
      }
      @Override public int getLastCol(){
        return hack.getFirstCol();
      }
      @Override public int getFirstOffset(){
        return hack.getFirstOffset();
      }
      @Override public int getLastOffset(){
        return hack.getFirstOffset();
      }
      @Override public URL getURL(){
        return hack.getURL();
      }
      @Override public InputStream getInputStream() throws IOException {
        return hack.getInputStream();
      }
    }
;
  }
  String[] newTextLines=newText.split(""String_Node_Str"");
  if (newTextLines.length == 1) {
    lines[startLine]=lines[startLine].substring(0,range.getFirstCol()) + newTextLines[0] + lines[startLine].substring(range.getLastCol() + 1);
  }
 else {
    String[] newLines=new String[lines.length + newTextLines.length - 1];
    int i=0;
    while (i < startLine) {
      newLines[i]=lines[i];
      i++;
    }
    newLines[i++]=lines[startLine].substring(0,range.getFirstCol()) + newTextLines[0];
    for (int j=1; j < newTextLines.length - 1; j++) {
      lines[i++]=newTextLines[j];
    }
    newLines[i++]=newTextLines[newTextLines.length - 1] + lines[endLine].substring(range.getLastCol() + 1);
    while (i < newLines.length) {
      newLines[i]=lines[i - newTextLines.length + 1];
      i++;
    }
    lines=newLines;
  }
}","public void substitute(Position range,String newText){
  int startLine=range.getFirstLine() - p.getFirstLine();
  int endLine=range.getLastLine() - p.getFirstLine();
  if (startLine != endLine) {
    String newLines[]=new String[lines.length - (endLine - startLine)];
    int i=0;
    while (i < startLine) {
      newLines[i]=lines[i];
      i++;
    }
    newLines[i++]=lines[startLine].substring(0,range.getFirstCol()) + lines[endLine].substring(range.getLastCol());
    while (i < newLines.length) {
      newLines[i]=lines[i + (endLine - startLine)];
      i++;
    }
    lines=newLines;
    endLine=startLine;
    final Position hack=range;
    range=new AbstractSourcePosition(){
      @Override public int getFirstLine(){
        return hack.getFirstLine();
      }
      @Override public int getLastLine(){
        return hack.getFirstLine();
      }
      @Override public int getFirstCol(){
        return hack.getFirstCol();
      }
      @Override public int getLastCol(){
        return hack.getFirstCol();
      }
      @Override public int getFirstOffset(){
        return hack.getFirstOffset();
      }
      @Override public int getLastOffset(){
        return hack.getFirstOffset();
      }
      @Override public URL getURL(){
        return hack.getURL();
      }
      @Override public Reader getReader() throws IOException {
        return hack.getReader();
      }
    }
;
  }
  String[] newTextLines=newText.split(""String_Node_Str"");
  if (newTextLines.length == 1) {
    lines[startLine]=lines[startLine].substring(0,range.getFirstCol()) + newTextLines[0] + lines[startLine].substring(range.getLastCol() + 1);
  }
 else {
    String[] newLines=new String[lines.length + newTextLines.length - 1];
    int i=0;
    while (i < startLine) {
      newLines[i]=lines[i];
      i++;
    }
    newLines[i++]=lines[startLine].substring(0,range.getFirstCol()) + newTextLines[0];
    for (int j=1; j < newTextLines.length - 1; j++) {
      lines[i++]=newTextLines[j];
    }
    newLines[i++]=newTextLines[newTextLines.length - 1] + lines[endLine].substring(range.getLastCol() + 1);
    while (i < newLines.length) {
      newLines[i]=lines[i - newTextLines.length + 1];
      i++;
    }
    lines=newLines;
  }
}",0.9867979413739092
99706,"/** 
 * Add flows from the special primitive functions to the corresponding global variables.
 * @param flowgraph the flow graph under construction
 */
private void addPrimitives(FlowGraph flowgraph){
  VertexFactory factory=flowgraph.getVertexFactory();
  for (  String pf : primitiveFunctions) {
    TypeReference typeref=TypeReference.findOrCreate(JavaScriptTypes.jsLoader,""String_Node_Str"" + pf);
    IClass klass=cha.lookupClass(typeref);
    flowgraph.addEdge(factory.makeFuncVertex(klass),factory.makePropVertex(pf));
  }
}","/** 
 * Add flows from the special primitive functions to the corresponding global variables.
 * @param flowgraph the flow graph under construction
 */
private void addPrimitives(FlowGraph flowgraph){
  VertexFactory factory=flowgraph.getVertexFactory();
  for (  String pf : primitiveFunctions) {
    TypeReference typeref=TypeReference.findOrCreate(JavaScriptTypes.jsLoader,""String_Node_Str"" + pf);
    IClass klass=cha.lookupClass(typeref);
    String prop=pf.endsWith(""String_Node_Str"") ? pf.substring(0,pf.length() - 6) : pf;
    flowgraph.addEdge(factory.makeFuncVertex(klass),factory.makePropVertex(prop));
  }
}",0.9208006962576152
99707,"public final Set<TypeReference> getUnresolvedClasses(){
  return unresolved;
}","@Override public final Set<TypeReference> getUnresolvedClasses(){
  return unresolved;
}",0.9397590361445785
99708,"/** 
 * Find a class in this class hierarchy.
 * @return the {@link IClass} for a if found; null if can't find the class.
 * @throws IllegalArgumentException if A is null
 */
@Override public IClass lookupClass(TypeReference a){
  if (a == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ClassLoaderReference loader=a.getClassLoader();
  ClassLoaderReference parent=loader.getParent();
  if (parent != null) {
    TypeReference p=TypeReference.findOrCreate(parent,a.getName());
    IClass c=lookupClass(p);
    if (c != null) {
      return c;
    }
  }
  if (a.isArrayType()) {
    TypeReference elt=a.getInnermostElementType();
    if (elt.isPrimitiveType()) {
      return getRootClass().getClassLoader().lookupClass(a.getName());
    }
 else {
      IClass c=lookupClass(elt);
      if (c == null) {
        unresolved.add(elt);
        return null;
      }
 else {
        return c.getClassLoader().lookupClass(a.getName());
      }
    }
  }
 else {
    Node n=map.get(a);
    if (n != null) {
      return n.klass;
    }
 else {
      unresolved.add(a);
      return null;
    }
  }
}","/** 
 * Find a class in this class hierarchy.
 * @return the {@link IClass} for a if found; null if can't find the class.
 * @throws IllegalArgumentException if A is null
 */
@Override public IClass lookupClass(TypeReference a){
  if (a == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final IClass cls=lookupClassRecursive(a);
  if (cls == null) {
    unresolved.add(a);
  }
  return cls;
}",0.4928292046936114
99709,"protected void parseBytecode(){
  logger.debug(""String_Node_Str"" + eMethod.getClass().getSimpleName() + ""String_Node_Str""+ eMethod.method.getMethodString());
  org.jf.dexlib.Code.Instruction[] instrucs=eMethod.codeItem.getInstructions();
  logger.debug(""String_Node_Str"" + eMethod.method.getMethodString() + ""String_Node_Str""+ instrucs.length);
  instructions=new InstructionArray();
  int instLoc=0;
  int instCounter=-1;
  int currentCodeAddress=0;
  for (  org.jf.dexlib.Code.Instruction inst : instrucs) {
    totalInsts++;
    instCounter++;
    instLoc=currentCodeAddress;
    logger.debug(""String_Node_Str"" + instCounter + ""String_Node_Str""+ instLoc+ ""String_Node_Str""+ inst.opcode.name()+ ""String_Node_Str""+ inst.getFormat());
switch (inst.opcode) {
case NOP:
switch (inst.getFormat()) {
case ArrayData:
{
          for (int i=0; i < instructions.size(); i++) {
            if (instructions.getFromId(i) instanceof ArrayFill)             if (instLoc == (((ArrayFill)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
              ((ArrayFill)getInstructionFromIndex(i)).setArrayDataTable((ArrayDataPseudoInstruction)inst);
              break;
            }
          }
          break;
        }
case PackedSwitchData:
      for (int i=0; i < instructions.size(); i++) {
        if (instructions.getFromId(i) instanceof Switch)         if (instLoc == (((Switch)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
          ((Switch)getInstructionFromIndex(i)).setSwitchPad(new PackedSwitchPad(((PackedSwitchDataPseudoInstruction)inst),getAddressFromIndex(i + 1) - getAddressFromIndex(i)));
          break;
        }
      }
    break;
case SparseSwitchData:
{
    for (int i=0; i < instructions.size(); i++) {
      if (instructions.getFromId(i) instanceof Switch)       if (instLoc == (((Switch)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
        ((Switch)getInstructionFromIndex(i)).setSwitchPad(new SparseSwitchPad(((SparseSwitchDataPseudoInstruction)inst),getAddressFromIndex(i + 1) - getAddressFromIndex(i)));
        break;
      }
    }
    break;
  }
case UnresolvedOdexInstruction:
throw new RuntimeException(""String_Node_Str"" + inst.opcode.toString() + inst.getFormat());
default :
break;
}
break;
case MOVE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_RESULT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_RESULT_WIDE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_RESULT_OBJECT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_EXCEPTION:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getExceptionReg(),inst.opcode,this));
break;
case RETURN_VOID:
instructions.add(new Return.ReturnVoid(instLoc,inst.opcode,this));
break;
case RETURN:
instructions.add(new Return.ReturnSingle(instLoc,((Instruction11x)inst).getRegisterA(),true,inst.opcode,this));
break;
case RETURN_WIDE:
instructions.add(new Return.ReturnDouble(instLoc,((Instruction11x)inst).getRegisterA(),((Instruction11x)inst).getRegisterA() + 1,inst.opcode,this));
break;
case RETURN_OBJECT:
instructions.add(new Return.ReturnSingle(instLoc,((Instruction11x)inst).getRegisterA(),false,inst.opcode,this));
break;
case CONST_4:
{
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction11n)inst).getLiteral(),((Instruction11n)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction11n)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction11n)inst).getLiteral());
break;
}
case CONST_16:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction21s)inst).getLiteral(),((Instruction21s)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21s)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21s)inst).getLiteral());
break;
case CONST:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction31i)inst).getLiteral(),((Instruction31i)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction31i)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction31i)inst).getLiteral());
break;
case CONST_HIGH16:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction21h)inst).getLiteral(),((Instruction21h)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE_16:
instructions.add(new Constant.LongConstant(instLoc,((Instruction21s)inst).getLiteral(),((Instruction21s)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21s)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21s)inst).getLiteral());
break;
case CONST_WIDE_32:
instructions.add(new Constant.LongConstant(instLoc,((Instruction31i)inst).getLiteral(),((Instruction31i)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE:
instructions.add(new Constant.LongConstant(instLoc,((Instruction51l)inst).getLiteral(),((Instruction51l)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE_HIGH16:
instructions.add(new Constant.LongConstant(instLoc,((Instruction21h)inst).getLiteral(),((Instruction21h)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21h)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21h)inst).getLiteral());
break;
case CONST_STRING:
instructions.add(new Constant.StringConstant(instLoc,((StringIdItem)((Instruction21c)inst).getReferencedItem()).getStringValue(),((Instruction21c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((StringIdItem)((Instruction21c)inst).getReferencedItem()).getStringValue());
break;
case CONST_STRING_JUMBO:
instructions.add(new Constant.StringConstant(instLoc,((StringIdItem)((Instruction31c)inst).getReferencedItem()).getStringValue(),((Instruction31c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((StringIdItem)((Instruction31c)inst).getReferencedItem()).getStringValue());
break;
case CONST_CLASS:
{
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
TypeReference typeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname);
instructions.add(new Constant.ClassConstant(instLoc,typeRef,((Instruction21c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + cname+ ""String_Node_Str""+ this.myClass.getClassLoader().lookupClass(TypeName.findOrCreate(cname)));
break;
}
case MONITOR_ENTER:
instructions.add(new Monitor(instLoc,true,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case MONITOR_EXIT:
instructions.add(new Monitor(instLoc,false,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case CHECK_CAST:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new CheckCast(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname),((Instruction21c)inst).getRegisterA(),inst.opcode,this));
break;
}
case INSTANCE_OF:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new InstanceOf(instLoc,((Instruction22c)inst).getRegisterA(),TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname),((Instruction22c)inst).getRegisterB(),inst.opcode,this));
break;
}
case ARRAY_LENGTH:
instructions.add(new ArrayLength(instLoc,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEW_INSTANCE:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
logger.info(""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
instructions.add(new New(instLoc,((Instruction21c)inst).getRegisterA(),NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname)),inst.opcode,this));
break;
}
case NEW_ARRAY:
{
int[] params=new int[1];
params[0]=((Instruction22c)inst).getRegisterB();
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new NewArray(instLoc,((Instruction22c)inst).getRegisterA(),NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname)),params,inst.opcode,this));
break;
}
case FILLED_NEW_ARRAY:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] params=new int[1];
params[0]=registerCount;
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
NewSiteReference newSiteRef=NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname));
TypeReference myTypeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),newSiteRef.getDeclaredType().getArrayElementType().getName().toString());
instructions.add(new NewArrayFilled(instLoc,getReturnReg(),newSiteRef,myTypeRef,params,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor() + ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
logger.debug(registerCount + ""String_Node_Str"");
for (int temp_i=0; temp_i < registerCount; temp_i++) logger.debug(""String_Node_Str"" + args[temp_i]);
break;
}
case FILLED_NEW_ARRAY_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] params=new int[1];
params[0]=registerCount;
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction3rc)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction3rc)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
NewSiteReference newSiteRef=NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname));
TypeReference myTypeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),newSiteRef.getDeclaredType().getArrayElementType().getName().toString());
instructions.add(new NewArrayFilled(instLoc,getReturnReg(),newSiteRef,myTypeRef,params,args,inst.opcode,this));
break;
}
case FILL_ARRAY_DATA:
Instruction prev_inst=getInstructionFromIndex(instCounter - 1);
if (prev_inst instanceof NewArray && ((NewArray)prev_inst).destination == ((Instruction31t)inst).getRegisterA()) {
instructions.add(new ArrayFill(instLoc,((Instruction31t)inst).getRegisterA(),((Instruction31t)inst).getTargetAddressOffset(),TypeReference.findOrCreate(myClass.getClassLoader().getReference(),((NewArray)prev_inst).newSiteRef.getDeclaredType().getArrayElementType().getName().toString()),inst.opcode,this));
}
 else {
throw new UnsupportedOperationException(""String_Node_Str"");
}
break;
case THROW:
instructions.add(new Throw(instLoc,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case GOTO:
instructions.add(new Goto(instLoc,((Instruction10t)inst).getTargetAddressOffset(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction10t)inst).getTargetAddressOffset());
break;
case GOTO_16:
instructions.add(new Goto(instLoc,((Instruction20t)inst).getTargetAddressOffset(),inst.opcode,this));
break;
case GOTO_32:
instructions.add(new Goto(instLoc,((Instruction30t)inst).getTargetAddressOffset(),inst.opcode,this));
break;
case PACKED_SWITCH:
case SPARSE_SWITCH:
instructions.add(new Switch(instLoc,((Instruction31t)inst).getRegisterA(),((Instruction31t)inst).getTargetAddressOffset(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + inst.getFormat());
break;
case CMPL_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPG_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPG_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPL_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPG_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPG_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMP_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case IF_EQ:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.EQ,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_NE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.NE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_LT:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.LT,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_GE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.GE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_GT:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.GT,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_LE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.LE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_EQZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.EQZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_NEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.NEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_LTZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.LTZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_GEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.GEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_GTZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.GTZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_LEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.LEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case AGET:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_int,inst.opcode,this));
break;
case AGET_WIDE:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_wide,inst.opcode,this));
break;
case AGET_OBJECT:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_object,inst.opcode,this));
break;
case AGET_BOOLEAN:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_boolean,inst.opcode,this));
break;
case AGET_BYTE:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_byte,inst.opcode,this));
break;
case AGET_CHAR:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_char,inst.opcode,this));
break;
case AGET_SHORT:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_short,inst.opcode,this));
break;
case APUT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_int,inst.opcode,this));
break;
case APUT_WIDE:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_wide,inst.opcode,this));
break;
case APUT_OBJECT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_object,inst.opcode,this));
break;
case APUT_BOOLEAN:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_boolean,inst.opcode,this));
break;
case APUT_BYTE:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_byte,inst.opcode,this));
break;
case APUT_CHAR:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_char,inst.opcode,this));
break;
case APUT_SHORT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_short,inst.opcode,this));
break;
case IGET:
case IGET_WIDE:
case IGET_OBJECT:
case IGET_BOOLEAN:
case IGET_BYTE:
case IGET_CHAR:
case IGET_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new GetField.GetInstanceField(instLoc,((Instruction22c)inst).getRegisterA(),((Instruction22c)inst).getRegisterB(),cname,fname,ftname,inst.opcode,this));
break;
}
case IPUT:
case IPUT_WIDE:
case IPUT_OBJECT:
case IPUT_BOOLEAN:
case IPUT_BYTE:
case IPUT_CHAR:
case IPUT_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new PutField.PutInstanceField(instLoc,((Instruction22c)inst).getRegisterA(),((Instruction22c)inst).getRegisterB(),cname,fname,ftname,inst.opcode,this));
break;
}
case SGET:
case SGET_WIDE:
case SGET_OBJECT:
case SGET_BOOLEAN:
case SGET_BYTE:
case SGET_CHAR:
case SGET_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new GetField.GetStaticField(instLoc,((Instruction21c)inst).getRegisterA(),cname,fname,ftname,inst.opcode,this));
break;
}
case SPUT:
case SPUT_WIDE:
case SPUT_OBJECT:
case SPUT_BOOLEAN:
case SPUT_BYTE:
case SPUT_CHAR:
case SPUT_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new PutField.PutStaticField(instLoc,((Instruction21c)inst).getRegisterA(),cname,fname,ftname,inst.opcode,this));
break;
}
case INVOKE_VIRTUAL:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
handleINVOKE_VIRTUAL(instLoc,cname,mname,pname,args,inst.opcode);
break;
}
case INVOKE_SUPER:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeSuper(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + cname + ""String_Node_Str""+ mname+ ""String_Node_Str""+ pname);
break;
}
case INVOKE_DIRECT:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeDirect(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor() + ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString()+ ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
break;
}
case INVOKE_STATIC:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeStatic(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor() + ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString()+ ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
break;
}
case INVOKE_INTERFACE:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeInterface(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_VIRTUAL_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeVirtual(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_SUPER_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeSuper(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_DIRECT_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeDirect(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_STATIC_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeStatic(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_INTERFACE_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeInterface(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case NEG_INT:
instructions.add(new UnaryOperation(instLoc,OpID.NEGINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NOT_INT:
instructions.add(new UnaryOperation(instLoc,OpID.NOTINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.NEGLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NOT_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.NOTLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.NEGFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.NEGDOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.INTTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_BYTE:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOBYTE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_CHAR:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOCHAR,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_SHORT:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOSHORT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case AND_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case OR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case XOR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHL_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case USHR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case AND_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case OR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case XOR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHL_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case USHR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case AND_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case OR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case XOR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHL_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case USHR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case AND_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case OR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case XOR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHL_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case USHR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.ADD_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case RSUB_INT:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.RSUB_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case MUL_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.MUL_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case DIV_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.DIV_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case REM_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.REM_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case AND_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.AND_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case OR_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.OR_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case XOR_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.XOR_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case ADD_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.ADD_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case RSUB_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.RSUB_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case MUL_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.MUL_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case DIV_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.DIV_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case REM_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.REM_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case AND_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.AND_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case OR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.OR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case XOR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.XOR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case SHL_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.SHL_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case SHR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.SHR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case USHR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.USHR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
default :
throw new RuntimeException(""String_Node_Str"" + inst.opcode.toString());
}
currentCodeAddress+=inst.getSize(currentCodeAddress);
}
logger.debug(""String_Node_Str"" + this.toString() + ""String_Node_Str"");
}","protected void parseBytecode(){
  logger.debug(""String_Node_Str"" + eMethod.getClass().getSimpleName() + ""String_Node_Str""+ eMethod.method.getMethodString());
  org.jf.dexlib.Code.Instruction[] instrucs=eMethod.codeItem.getInstructions();
  logger.debug(""String_Node_Str"" + eMethod.method.getMethodString() + ""String_Node_Str""+ instrucs.length);
  instructions=new InstructionArray();
  int instLoc=0;
  int instCounter=-1;
  int currentCodeAddress=0;
  for (  org.jf.dexlib.Code.Instruction inst : instrucs) {
    totalInsts++;
    instCounter++;
    instLoc=currentCodeAddress;
    logger.debug(""String_Node_Str"" + instCounter + ""String_Node_Str""+ instLoc+ ""String_Node_Str""+ inst.opcode.name()+ ""String_Node_Str""+ inst.getFormat());
switch (inst.opcode) {
case NOP:
switch (inst.getFormat()) {
case ArrayData:
{
          for (int i=0; i < instructions.size(); i++) {
            if (instructions.getFromId(i) instanceof ArrayFill)             if (instLoc == (((ArrayFill)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
              ((ArrayFill)getInstructionFromIndex(i)).setArrayDataTable((ArrayDataPseudoInstruction)inst);
              break;
            }
          }
          break;
        }
case PackedSwitchData:
      for (int i=0; i < instructions.size(); i++) {
        if (instructions.getFromId(i) instanceof Switch)         if (instLoc == (((Switch)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
          ((Switch)getInstructionFromIndex(i)).setSwitchPad(new PackedSwitchPad(((PackedSwitchDataPseudoInstruction)inst),getAddressFromIndex(i + 1) - getAddressFromIndex(i)));
          break;
        }
      }
    break;
case SparseSwitchData:
{
    for (int i=0; i < instructions.size(); i++) {
      if (instructions.getFromId(i) instanceof Switch)       if (instLoc == (((Switch)getInstructionFromIndex(i)).tableAddressOffset + getAddressFromIndex(i))) {
        ((Switch)getInstructionFromIndex(i)).setSwitchPad(new SparseSwitchPad(((SparseSwitchDataPseudoInstruction)inst),getAddressFromIndex(i + 1) - getAddressFromIndex(i)));
        break;
      }
    }
    break;
  }
case UnresolvedOdexInstruction:
throw new RuntimeException(""String_Node_Str"" + inst.opcode.toString() + inst.getFormat());
default :
break;
}
break;
case MOVE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_WIDE_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT_FROM16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction22x)inst).getRegisterA(),((Instruction22x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_OBJECT_16:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction32x)inst).getRegisterA(),((Instruction32x)inst).getRegisterB(),inst.opcode,this));
break;
case MOVE_RESULT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_RESULT_WIDE:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE_WIDE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_RESULT_OBJECT:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getReturnReg(),inst.opcode,this));
break;
case MOVE_EXCEPTION:
instructions.add(new UnaryOperation(instLoc,UnaryOperation.OpID.MOVE,((Instruction11x)inst).getRegisterA(),getExceptionReg(),inst.opcode,this));
break;
case RETURN_VOID:
instructions.add(new Return.ReturnVoid(instLoc,inst.opcode,this));
break;
case RETURN:
instructions.add(new Return.ReturnSingle(instLoc,((Instruction11x)inst).getRegisterA(),true,inst.opcode,this));
break;
case RETURN_WIDE:
instructions.add(new Return.ReturnDouble(instLoc,((Instruction11x)inst).getRegisterA(),((Instruction11x)inst).getRegisterA() + 1,inst.opcode,this));
break;
case RETURN_OBJECT:
instructions.add(new Return.ReturnSingle(instLoc,((Instruction11x)inst).getRegisterA(),false,inst.opcode,this));
break;
case CONST_4:
{
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction11n)inst).getLiteral(),((Instruction11n)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction11n)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction11n)inst).getLiteral());
break;
}
case CONST_16:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction21s)inst).getLiteral(),((Instruction21s)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21s)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21s)inst).getLiteral());
break;
case CONST:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction31i)inst).getLiteral(),((Instruction31i)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction31i)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction31i)inst).getLiteral());
break;
case CONST_HIGH16:
instructions.add(new Constant.IntConstant(instLoc,(int)((Instruction21h)inst).getLiteral(),((Instruction21h)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE_16:
instructions.add(new Constant.LongConstant(instLoc,((Instruction21s)inst).getLiteral(),((Instruction21s)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21s)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21s)inst).getLiteral());
break;
case CONST_WIDE_32:
instructions.add(new Constant.LongConstant(instLoc,((Instruction31i)inst).getLiteral(),((Instruction31i)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE:
instructions.add(new Constant.LongConstant(instLoc,((Instruction51l)inst).getLiteral(),((Instruction51l)inst).getRegisterA(),inst.opcode,this));
break;
case CONST_WIDE_HIGH16:
instructions.add(new Constant.LongConstant(instLoc,((Instruction21h)inst).getLiteral(),((Instruction21h)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21h)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21h)inst).getLiteral());
break;
case CONST_STRING:
instructions.add(new Constant.StringConstant(instLoc,((StringIdItem)((Instruction21c)inst).getReferencedItem()).getStringValue(),((Instruction21c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((StringIdItem)((Instruction21c)inst).getReferencedItem()).getStringValue());
break;
case CONST_STRING_JUMBO:
instructions.add(new Constant.StringConstant(instLoc,((StringIdItem)((Instruction31c)inst).getReferencedItem()).getStringValue(),((Instruction31c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((StringIdItem)((Instruction31c)inst).getReferencedItem()).getStringValue());
break;
case CONST_CLASS:
{
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
TypeReference typeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname);
instructions.add(new Constant.ClassConstant(instLoc,typeRef,((Instruction21c)inst).getRegisterA(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + cname+ ""String_Node_Str""+ this.myClass.getClassLoader().lookupClass(TypeName.findOrCreate(cname)));
break;
}
case MONITOR_ENTER:
instructions.add(new Monitor(instLoc,true,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case MONITOR_EXIT:
instructions.add(new Monitor(instLoc,false,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case CHECK_CAST:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new CheckCast(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname),((Instruction21c)inst).getRegisterA(),inst.opcode,this));
break;
}
case INSTANCE_OF:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new InstanceOf(instLoc,((Instruction22c)inst).getRegisterA(),TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname),((Instruction22c)inst).getRegisterB(),inst.opcode,this));
break;
}
case ARRAY_LENGTH:
instructions.add(new ArrayLength(instLoc,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEW_INSTANCE:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
logger.info(""String_Node_Str"" + ((TypeIdItem)((Instruction21c)inst).getReferencedItem()).getTypeDescriptor());
instructions.add(new New(instLoc,((Instruction21c)inst).getRegisterA(),NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname)),inst.opcode,this));
break;
}
case NEW_ARRAY:
{
int[] params=new int[1];
params[0]=((Instruction22c)inst).getRegisterB();
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction22c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new NewArray(instLoc,((Instruction22c)inst).getRegisterA(),NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname)),params,inst.opcode,this));
break;
}
case FILLED_NEW_ARRAY:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] params=new int[1];
params[0]=registerCount;
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
NewSiteReference newSiteRef=NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname));
TypeReference myTypeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),newSiteRef.getDeclaredType().getArrayElementType().getName().toString());
instructions.add(new NewArrayFilled(instLoc,getReturnReg(),newSiteRef,myTypeRef,params,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((TypeIdItem)((Instruction35c)inst).getReferencedItem()).getTypeDescriptor() + ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
logger.debug(registerCount + ""String_Node_Str"");
for (int temp_i=0; temp_i < registerCount; temp_i++) logger.debug(""String_Node_Str"" + args[temp_i]);
break;
}
case FILLED_NEW_ARRAY_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] params=new int[1];
params[0]=registerCount;
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((TypeIdItem)((Instruction3rc)inst).getReferencedItem()).getTypeDescriptor());
String cname=((TypeIdItem)((Instruction3rc)inst).getReferencedItem()).getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
NewSiteReference newSiteRef=NewSiteReference.make(instLoc,TypeReference.findOrCreate(myClass.getClassLoader().getReference(),cname));
TypeReference myTypeRef=TypeReference.findOrCreate(myClass.getClassLoader().getReference(),newSiteRef.getDeclaredType().getArrayElementType().getName().toString());
instructions.add(new NewArrayFilled(instLoc,getReturnReg(),newSiteRef,myTypeRef,params,args,inst.opcode,this));
break;
}
case FILL_ARRAY_DATA:
TypeReference arrayElementType=findOutArrayElementType(instrucs,instructions.toArray(new Instruction[0]),instCounter);
instructions.add(new ArrayFill(instLoc,((Instruction31t)inst).getRegisterA(),((Instruction31t)inst).getTargetAddressOffset(),TypeReference.findOrCreate(myClass.getClassLoader().getReference(),arrayElementType.getName().toString()),inst.opcode,this));
break;
case THROW:
instructions.add(new Throw(instLoc,((Instruction11x)inst).getRegisterA(),inst.opcode,this));
break;
case GOTO:
instructions.add(new Goto(instLoc,((Instruction10t)inst).getTargetAddressOffset(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction10t)inst).getTargetAddressOffset());
break;
case GOTO_16:
instructions.add(new Goto(instLoc,((Instruction20t)inst).getTargetAddressOffset(),inst.opcode,this));
break;
case GOTO_32:
instructions.add(new Goto(instLoc,((Instruction30t)inst).getTargetAddressOffset(),inst.opcode,this));
break;
case PACKED_SWITCH:
case SPARSE_SWITCH:
instructions.add(new Switch(instLoc,((Instruction31t)inst).getRegisterA(),((Instruction31t)inst).getTargetAddressOffset(),inst.opcode,this));
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + inst.getFormat());
break;
case CMPL_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPG_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPG_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPL_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMPG_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPG_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case CMP_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.CMPL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case IF_EQ:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.EQ,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_NE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.NE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_LT:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.LT,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_GE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.GE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_GT:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.GT,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_LE:
instructions.add(new Branch.BinaryBranch(instLoc,((Instruction22t)inst).getTargetAddressOffset(),Branch.BinaryBranch.CompareOp.LE,((Instruction22t)inst).getRegisterA(),((Instruction22t)inst).getRegisterB(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction22t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction22t)inst).getRegisterB()+ ""String_Node_Str""+ ((Instruction22t)inst).getTargetAddressOffset());
break;
case IF_EQZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.EQZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_NEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.NEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_LTZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.LTZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_GEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.GEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_GTZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.GTZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case IF_LEZ:
instructions.add(new Branch.UnaryBranch(instLoc,((Instruction21t)inst).getTargetAddressOffset(),Branch.UnaryBranch.CompareOp.LEZ,((Instruction21t)inst).getRegisterA(),inst.opcode,this));
logger.debug(""String_Node_Str"" + ((Instruction21t)inst).getRegisterA() + ""String_Node_Str""+ ((Instruction21t)inst).getTargetAddressOffset());
break;
case AGET:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_int,inst.opcode,this));
break;
case AGET_WIDE:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_wide,inst.opcode,this));
break;
case AGET_OBJECT:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_object,inst.opcode,this));
break;
case AGET_BOOLEAN:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_boolean,inst.opcode,this));
break;
case AGET_BYTE:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_byte,inst.opcode,this));
break;
case AGET_CHAR:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_char,inst.opcode,this));
break;
case AGET_SHORT:
instructions.add(new ArrayGet(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_short,inst.opcode,this));
break;
case APUT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_int,inst.opcode,this));
break;
case APUT_WIDE:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_wide,inst.opcode,this));
break;
case APUT_OBJECT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_object,inst.opcode,this));
break;
case APUT_BOOLEAN:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_boolean,inst.opcode,this));
break;
case APUT_BYTE:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_byte,inst.opcode,this));
break;
case APUT_CHAR:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_char,inst.opcode,this));
break;
case APUT_SHORT:
instructions.add(new ArrayPut(instLoc,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),Type.t_short,inst.opcode,this));
break;
case IGET:
case IGET_WIDE:
case IGET_OBJECT:
case IGET_BOOLEAN:
case IGET_BYTE:
case IGET_CHAR:
case IGET_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new GetField.GetInstanceField(instLoc,((Instruction22c)inst).getRegisterA(),((Instruction22c)inst).getRegisterB(),cname,fname,ftname,inst.opcode,this));
break;
}
case IPUT:
case IPUT_WIDE:
case IPUT_OBJECT:
case IPUT_BOOLEAN:
case IPUT_BYTE:
case IPUT_CHAR:
case IPUT_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction22c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new PutField.PutInstanceField(instLoc,((Instruction22c)inst).getRegisterA(),((Instruction22c)inst).getRegisterB(),cname,fname,ftname,inst.opcode,this));
break;
}
case SGET:
case SGET_WIDE:
case SGET_OBJECT:
case SGET_BOOLEAN:
case SGET_BYTE:
case SGET_CHAR:
case SGET_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new GetField.GetStaticField(instLoc,((Instruction21c)inst).getRegisterA(),cname,fname,ftname,inst.opcode,this));
break;
}
case SPUT:
case SPUT_WIDE:
case SPUT_OBJECT:
case SPUT_BOOLEAN:
case SPUT_BYTE:
case SPUT_CHAR:
case SPUT_SHORT:
{
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue()+ ""String_Node_Str""+ ((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor());
String cname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String fname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldName().getStringValue();
String ftname=((FieldIdItem)((Instruction21c)inst).getReferencedItem()).getFieldType().getTypeDescriptor();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
if (fname.endsWith(""String_Node_Str"")) fname=fname.substring(0,fname.length() - 1);
if (ftname.endsWith(""String_Node_Str"")) ftname=ftname.substring(0,ftname.length() - 1);
instructions.add(new PutField.PutStaticField(instLoc,((Instruction21c)inst).getRegisterA(),cname,fname,ftname,inst.opcode,this));
break;
}
case INVOKE_VIRTUAL:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
handleINVOKE_VIRTUAL(instLoc,cname,mname,pname,args,inst.opcode);
break;
}
case INVOKE_SUPER:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeSuper(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + cname + ""String_Node_Str""+ mname+ ""String_Node_Str""+ pname);
break;
}
case INVOKE_DIRECT:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeDirect(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor() + ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString()+ ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
break;
}
case INVOKE_STATIC:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeStatic(instLoc,cname,mname,pname,args,inst.opcode,this));
logger.debug(""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor() + ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString()+ ""String_Node_Str""+ ((Instruction35c)inst).getRegCount());
break;
}
case INVOKE_INTERFACE:
{
int registerCount=((Instruction35c)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) {
switch (i) {
case 0:
args[0]=((Instruction35c)inst).getRegisterD();
break;
case 1:
args[1]=((Instruction35c)inst).getRegisterE();
break;
case 2:
args[2]=((Instruction35c)inst).getRegisterF();
break;
case 3:
args[3]=((Instruction35c)inst).getRegisterG();
break;
case 4:
args[4]=((Instruction35c)inst).getRegisterA();
break;
default :
throw new RuntimeException(""String_Node_Str"" + instLoc + ""String_Node_Str"");
}
}
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction35c)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeInterface(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_VIRTUAL_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeVirtual(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_SUPER_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeSuper(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_DIRECT_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeDirect(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_STATIC_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeStatic(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case INVOKE_INTERFACE_RANGE:
{
int registerCount=((Instruction3rc)inst).getRegCount();
int[] args=new int[registerCount];
for (int i=0; i < registerCount; i++) args[i]=((Instruction3rc)inst).getStartRegister() + i;
logger.debug(inst.opcode.toString() + ""String_Node_Str"" + ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue()+ ""String_Node_Str""+ ((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString());
String cname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getContainingClass().getTypeDescriptor();
String mname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getMethodName().getStringValue();
String pname=((MethodIdItem)((Instruction3rc)inst).getReferencedItem()).getPrototype().getPrototypeString();
if (cname.endsWith(""String_Node_Str"")) cname=cname.substring(0,cname.length() - 1);
instructions.add(new Invoke.InvokeInterface(instLoc,cname,mname,pname,args,inst.opcode,this));
break;
}
case NEG_INT:
instructions.add(new UnaryOperation(instLoc,OpID.NEGINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NOT_INT:
instructions.add(new UnaryOperation(instLoc,OpID.NOTINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.NEGLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NOT_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.NOTLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.NEGFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case NEG_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.NEGDOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.INTTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case LONG_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.LONGTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case FLOAT_TO_DOUBLE:
instructions.add(new UnaryOperation(instLoc,OpID.FLOATTODOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_INT:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOINT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_LONG:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOLONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DOUBLE_TO_FLOAT:
instructions.add(new UnaryOperation(instLoc,OpID.DOUBLETOFLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_BYTE:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOBYTE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_CHAR:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOCHAR,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case INT_TO_SHORT:
instructions.add(new UnaryOperation(instLoc,OpID.INTTOSHORT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case AND_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case OR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case XOR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHL_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case USHR_INT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_INT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case AND_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case OR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case XOR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHL_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SHR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case USHR_LONG:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_LONG,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_FLOAT:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_FLOAT,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case SUB_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case MUL_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case DIV_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case REM_DOUBLE:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_DOUBLE,((Instruction23x)inst).getRegisterA(),((Instruction23x)inst).getRegisterB(),((Instruction23x)inst).getRegisterC(),inst.opcode,this));
break;
case ADD_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case AND_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case OR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case XOR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHL_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case USHR_INT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_INT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case AND_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.AND_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case OR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.OR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case XOR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.XOR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHL_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHL_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SHR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SHR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case USHR_LONG_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.USHR_LONG,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_FLOAT_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_FLOAT,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.ADD_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case SUB_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.SUB_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case MUL_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.MUL_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case DIV_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.DIV_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case REM_DOUBLE_2ADDR:
instructions.add(new BinaryOperation(instLoc,BinaryOperation.OpID.REM_DOUBLE,((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterA(),((Instruction12x)inst).getRegisterB(),inst.opcode,this));
break;
case ADD_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.ADD_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case RSUB_INT:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.RSUB_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case MUL_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.MUL_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case DIV_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.DIV_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case REM_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.REM_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case AND_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.AND_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case OR_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.OR_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case XOR_INT_LIT16:
{
Literal lit=new Literal.LongLiteral(((Instruction22s)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.XOR_INT,((Instruction22s)inst).getRegisterA(),((Instruction22s)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case ADD_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.ADD_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case RSUB_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.RSUB_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case MUL_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.MUL_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case DIV_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.DIV_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case REM_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.REM_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case AND_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.AND_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case OR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.OR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case XOR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.XOR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case SHL_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.SHL_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case SHR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.SHR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
case USHR_INT_LIT8:
{
Literal lit=new Literal.LongLiteral(((Instruction22b)inst).getLiteral());
instructions.add(new BinaryLiteralOperation(instLoc,BinaryLiteralOperation.OpID.USHR_INT,((Instruction22b)inst).getRegisterA(),((Instruction22b)inst).getRegisterB(),lit,inst.opcode,this));
break;
}
default :
throw new RuntimeException(""String_Node_Str"" + inst.opcode.toString());
}
currentCodeAddress+=inst.getSize(currentCodeAddress);
}
logger.debug(""String_Node_Str"" + this.toString() + ""String_Node_Str"");
}",0.9969844093965804
99710,"/** 
 * set up the methodMap mapping
 */
protected void computeMethodMapIfNeeded() throws InvalidClassFileException {
  if (methodMap == null) {
synchronized (this) {
      if (methodMap == null) {
        IMethod[] methods=computeDeclaredMethods();
        if (methods.length > 5) {
          methodMap=HashMapFactory.make(methods.length);
        }
 else {
          methodMap=new SmallMap<Selector,IMethod>();
        }
        for (int i=0; i < methods.length; i++) {
          IMethod m=methods[i];
          methodMap.put(m.getReference().getSelector(),m);
        }
      }
    }
  }
}","/** 
 * set up the methodMap mapping
 */
protected void computeMethodMapIfNeeded() throws InvalidClassFileException {
  if (methodMap == null) {
synchronized (this) {
      if (methodMap == null) {
        IMethod[] methods=computeDeclaredMethods();
        final Map<Selector,IMethod> tmpMethodMap;
        if (methods.length > 5) {
          tmpMethodMap=HashMapFactory.make(methods.length);
        }
 else {
          tmpMethodMap=new SmallMap<Selector,IMethod>();
        }
        for (int i=0; i < methods.length; i++) {
          IMethod m=methods[i];
          tmpMethodMap.put(m.getReference().getSelector(),m);
        }
        methodMap=tmpMethodMap;
      }
    }
  }
}",0.9223529411764706
99711,"public void unary1(){
}","@Override public void unary1(){
}",0.8214285714285714
99712,"public void unary2(){
  unary1();
}","@Override public void unary2(){
  unary1();
}",0.875
99713,"public void binary(Whatever arg){
  this.unary1();
  arg.unary2();
}","@Override public void binary(Whatever arg){
  this.unary1();
  arg.unary2();
}",0.9315068493150684
99714,"public static void main(String[] args){
  Whatever x=new This();
  Whatever y=new That();
  Whatever z=choice() ? x : y;
  if (z instanceof This)   x.binary(z);
 else   y.binary(z);
}","public static void main(String[] args){
  Whatever x=new This();
  Whatever y=new That();
  Whatever z=choice() ? x : y;
  if (z instanceof This)   x.binary(z);
 else   y.binary(z);
  localCast();
}",0.9606299212598424
99715,"private void checkCallAssertions(CallGraph cg,int desiredNumberOfTargets,int desiredNumberOfCalls){
}","private void checkCallAssertions(CallGraph cg,int desiredNumberOfTargets,int desiredNumberOfCalls,int numLocalCastCallees){
}",0.8938053097345132
99716,"@Test public void testNoPiNodes() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  checkCallAssertions(doGraph(false),2,2);
}","@Test public void testNoPiNodes() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  checkCallAssertions(doGraph(false),2,2,2);
}",0.9940476190476192
99717,"@Test public void testPiNodes() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  checkCallAssertions(doGraph(true),1,2);
}","@Test public void testPiNodes() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  checkCallAssertions(doGraph(true),1,2,1);
}",0.993939393939394
99718,"public void defineFunction(CAstEntity n,IClass owner,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] catchTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo){
  ((JavaClass)owner).addMethod(n,owner,cfg,symtab,hasCatchBlock,catchTypes,hasMonitorOp,lexicalInfo,debugInfo);
}","public void defineFunction(CAstEntity n,IClass owner,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,Map<IBasicBlock,TypeReference[]> caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo){
  ((JavaClass)owner).addMethod(n,owner,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,lexicalInfo,debugInfo);
}",0.9440459110473458
99719,"public ConcreteJavaMethod(CAstEntity methodEntity,IClass owner,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] catchTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo){
  super(methodEntity,owner,cfg,symtab,hasCatchBlock,catchTypes,hasMonitorOp,lexicalInfo,debugInfo);
}","public ConcreteJavaMethod(CAstEntity methodEntity,IClass owner,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,Map<IBasicBlock,TypeReference[]> caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo){
  super(methodEntity,owner,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,lexicalInfo,debugInfo);
}",0.9437229437229436
99720,"protected void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo){
}","protected void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,Map<IBasicBlock,TypeReference[]> caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo){
}",0.962671905697446
99721,"@Override protected void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] caughtTypes,boolean hasMonitorOp,AstLexicalInformation LI,DebuggingInformation debugInfo){
  if (N == codeBodyEntity) {
    specializedCode=myloader.makeCodeBodyCode(cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo,method.getDeclaringClass());
  }
 else {
    super.defineFunction(N,definingContext,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
  }
}","@Override protected void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,Map<IBasicBlock,TypeReference[]> caughtTypes,boolean hasMonitorOp,AstLexicalInformation LI,DebuggingInformation debugInfo){
  if (N == codeBodyEntity) {
    specializedCode=myloader.makeCodeBodyCode(cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo,method.getDeclaringClass());
  }
 else {
    super.defineFunction(N,definingContext,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
  }
}",0.9826166514181152
99722,"@Override public IR makeIR(final IMethod method,Context context,SSAOptions options){
  if (method instanceof Retranslatable) {
    @SuppressWarnings(""String_Node_Str"") final Value<Integer> v=(Value<Integer>)context.get(ArgumentCountContext.ARGUMENT_COUNT);
    final Retranslatable m=(Retranslatable)method;
    if (v != null) {
      final JavaScriptLoader myloader=(JavaScriptLoader)method.getDeclaringClass().getClassLoader();
class FixedArgumentsRewriter extends CAstBasicRewriter {
        private final CAstEntity e;
        Map<String,CAstNode> argRefs=HashMapFactory.make();
        public FixedArgumentsRewriter(        CAst Ast){
          super(Ast,false);
          this.e=m.getEntity();
          for (          Segments s : CAstPattern.findAll(destructuredAccessPattern,m.getEntity())) {
            argRefs.put(s.getSingle(""String_Node_Str"").getValue().toString(),s.getSingle(""String_Node_Str""));
          }
        }
        private CAstNode handleArgumentRef(        CAstNode n){
          Object x=n.getValue();
          if (x != null) {
            if (x instanceof Number && ((Number)x).intValue() < v.getValue() - 2) {
              int arg=((Number)x).intValue() + 2;
              if (arg < e.getArgumentCount()) {
                return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(e.getArgumentNames()[arg]));
              }
 else {
                return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str"" + arg));
              }
            }
 else             if (x instanceof String && ""String_Node_Str"".equals(x)) {
              return Ast.makeConstant(v.getValue());
            }
          }
          return null;
        }
        @Override protected CAstNode copyNodes(        CAstNode root,        CAstControlFlowMap cfg,        NonCopyingContext context,        Map<Pair<CAstNode,NoKey>,CAstNode> nodeMap){
          CAstNode result=null;
          Segments s;
          if ((s=CAstPattern.match(directAccessPattern,root)) != null) {
            result=handleArgumentRef(s.getSingle(""String_Node_Str""));
          }
 else           if ((s=CAstPattern.match(destructuredCallPattern,root)) != null) {
            if (argRefs.containsKey(s.getSingle(""String_Node_Str"").getValue().toString())) {
              List<CAstNode> x=new ArrayList<CAstNode>();
              CAstNode ref=handleArgumentRef(argRefs.get(s.getSingle(""String_Node_Str"").getValue().toString()));
              if (ref != null) {
                x.add(ref);
                x.add(Ast.makeConstant(""String_Node_Str""));
                x.add(Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str"")));
                for (                CAstNode c : s.getMultiple(""String_Node_Str"")) {
                  x.add(copyNodes(c,cfg,context,nodeMap));
                }
                result=Ast.makeNode(CAstNode.CALL,x.toArray(new CAstNode[x.size()]));
              }
            }
          }
 else           if (root.getKind() == CAstNode.CONSTANT) {
            result=Ast.makeConstant(root.getValue());
          }
 else           if (root.getKind() == CAstNode.OPERATOR) {
            result=root;
          }
          if (result == null) {
            CAstNode children[]=new CAstNode[root.getChildCount()];
            for (int i=0; i < children.length; i++) {
              children[i]=copyNodes(root.getChild(i),cfg,context,nodeMap);
            }
            for (            Object label : cfg.getTargetLabels(root)) {
              if (label instanceof CAstNode) {
                copyNodes((CAstNode)label,cfg,context,nodeMap);
              }
            }
            CAstNode copy=Ast.makeNode(root.getKind(),children);
            result=copy;
          }
          nodeMap.put(Pair.make(root,context.key()),result);
          return result;
        }
      }
      final FixedArgumentsRewriter args=new FixedArgumentsRewriter(new CAstImpl());
      final JSConstantFoldingRewriter fold=new JSConstantFoldingRewriter(new CAstImpl());
class ArgumentativeTranslator extends JSAstTranslator {
        public ArgumentativeTranslator(        JavaScriptLoader loader){
          super(loader);
        }
        private CAstEntity codeBodyEntity;
        private IMethod specializedCode;
        @Override protected int getArgumentCount(        CAstEntity f){
          return Math.max(super.getArgumentCount(f),v.getValue());
        }
        @Override protected String[] getArgumentNames(        CAstEntity f){
          if (super.getArgumentCount(f) >= v.getValue()) {
            return super.getArgumentNames(f);
          }
 else {
            String[] argNames=new String[v.getValue()];
            System.arraycopy(super.getArgumentNames(f),0,argNames,0,super.getArgumentCount(f));
            for (int i=super.getArgumentCount(f); i < argNames.length; i++) {
              argNames[i]=""String_Node_Str"" + i;
            }
            return argNames;
          }
        }
        @Override protected String composeEntityName(        WalkContext parent,        CAstEntity f){
          if (f == codeBodyEntity) {
            return super.composeEntityName(parent,f) + ""String_Node_Str"" + v.getValue().intValue();
          }
 else {
            return super.composeEntityName(parent,f);
          }
        }
        @Override protected void defineFunction(        CAstEntity N,        WalkContext definingContext,        AbstractCFG cfg,        SymbolTable symtab,        boolean hasCatchBlock,        TypeReference[][] caughtTypes,        boolean hasMonitorOp,        AstLexicalInformation LI,        DebuggingInformation debugInfo){
          if (N == codeBodyEntity) {
            specializedCode=myloader.makeCodeBodyCode(cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo,method.getDeclaringClass());
          }
 else {
            super.defineFunction(N,definingContext,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
          }
        }
        @Override public void translate(        CAstEntity N,        WalkContext context){
          if (N == m.getEntity()) {
            codeBodyEntity=fold.rewrite(args.rewrite(N));
            super.translate(codeBodyEntity,context);
          }
 else {
            super.translate(N,context);
          }
        }
      }
      ArgumentativeTranslator a=new ArgumentativeTranslator(myloader);
      m.retranslate(a);
      return super.makeIR(a.specializedCode,context,options);
    }
  }
  return super.makeIR(method,context,options);
}","@Override public IR makeIR(final IMethod method,Context context,SSAOptions options){
  if (method instanceof Retranslatable) {
    @SuppressWarnings(""String_Node_Str"") final Value<Integer> v=(Value<Integer>)context.get(ArgumentCountContext.ARGUMENT_COUNT);
    final Retranslatable m=(Retranslatable)method;
    if (v != null) {
      final JavaScriptLoader myloader=(JavaScriptLoader)method.getDeclaringClass().getClassLoader();
class FixedArgumentsRewriter extends CAstBasicRewriter {
        private final CAstEntity e;
        Map<String,CAstNode> argRefs=HashMapFactory.make();
        public FixedArgumentsRewriter(        CAst Ast){
          super(Ast,false);
          this.e=m.getEntity();
          for (          Segments s : CAstPattern.findAll(destructuredAccessPattern,m.getEntity())) {
            argRefs.put(s.getSingle(""String_Node_Str"").getValue().toString(),s.getSingle(""String_Node_Str""));
          }
        }
        private CAstNode handleArgumentRef(        CAstNode n){
          Object x=n.getValue();
          if (x != null) {
            if (x instanceof Number && ((Number)x).intValue() < v.getValue() - 2) {
              int arg=((Number)x).intValue() + 2;
              if (arg < e.getArgumentCount()) {
                return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(e.getArgumentNames()[arg]));
              }
 else {
                return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str"" + arg));
              }
            }
 else             if (x instanceof String && ""String_Node_Str"".equals(x)) {
              return Ast.makeConstant(v.getValue());
            }
          }
          return null;
        }
        @Override protected CAstNode copyNodes(        CAstNode root,        CAstControlFlowMap cfg,        NonCopyingContext context,        Map<Pair<CAstNode,NoKey>,CAstNode> nodeMap){
          CAstNode result=null;
          Segments s;
          if ((s=CAstPattern.match(directAccessPattern,root)) != null) {
            result=handleArgumentRef(s.getSingle(""String_Node_Str""));
          }
 else           if ((s=CAstPattern.match(destructuredCallPattern,root)) != null) {
            if (argRefs.containsKey(s.getSingle(""String_Node_Str"").getValue().toString())) {
              List<CAstNode> x=new ArrayList<CAstNode>();
              CAstNode ref=handleArgumentRef(argRefs.get(s.getSingle(""String_Node_Str"").getValue().toString()));
              if (ref != null) {
                x.add(ref);
                x.add(Ast.makeConstant(""String_Node_Str""));
                x.add(Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str"")));
                for (                CAstNode c : s.getMultiple(""String_Node_Str"")) {
                  x.add(copyNodes(c,cfg,context,nodeMap));
                }
                result=Ast.makeNode(CAstNode.CALL,x.toArray(new CAstNode[x.size()]));
              }
            }
          }
 else           if (root.getKind() == CAstNode.CONSTANT) {
            result=Ast.makeConstant(root.getValue());
          }
 else           if (root.getKind() == CAstNode.OPERATOR) {
            result=root;
          }
          if (result == null) {
            CAstNode children[]=new CAstNode[root.getChildCount()];
            for (int i=0; i < children.length; i++) {
              children[i]=copyNodes(root.getChild(i),cfg,context,nodeMap);
            }
            for (            Object label : cfg.getTargetLabels(root)) {
              if (label instanceof CAstNode) {
                copyNodes((CAstNode)label,cfg,context,nodeMap);
              }
            }
            CAstNode copy=Ast.makeNode(root.getKind(),children);
            result=copy;
          }
          nodeMap.put(Pair.make(root,context.key()),result);
          return result;
        }
      }
      final FixedArgumentsRewriter args=new FixedArgumentsRewriter(new CAstImpl());
      final JSConstantFoldingRewriter fold=new JSConstantFoldingRewriter(new CAstImpl());
class ArgumentativeTranslator extends JSAstTranslator {
        public ArgumentativeTranslator(        JavaScriptLoader loader){
          super(loader);
        }
        private CAstEntity codeBodyEntity;
        private IMethod specializedCode;
        @Override protected int getArgumentCount(        CAstEntity f){
          return Math.max(super.getArgumentCount(f),v.getValue());
        }
        @Override protected String[] getArgumentNames(        CAstEntity f){
          if (super.getArgumentCount(f) >= v.getValue()) {
            return super.getArgumentNames(f);
          }
 else {
            String[] argNames=new String[v.getValue()];
            System.arraycopy(super.getArgumentNames(f),0,argNames,0,super.getArgumentCount(f));
            for (int i=super.getArgumentCount(f); i < argNames.length; i++) {
              argNames[i]=""String_Node_Str"" + i;
            }
            return argNames;
          }
        }
        @Override protected String composeEntityName(        WalkContext parent,        CAstEntity f){
          if (f == codeBodyEntity) {
            return super.composeEntityName(parent,f) + ""String_Node_Str"" + v.getValue().intValue();
          }
 else {
            return super.composeEntityName(parent,f);
          }
        }
        @Override protected void defineFunction(        CAstEntity N,        WalkContext definingContext,        AbstractCFG cfg,        SymbolTable symtab,        boolean hasCatchBlock,        Map<IBasicBlock,TypeReference[]> caughtTypes,        boolean hasMonitorOp,        AstLexicalInformation LI,        DebuggingInformation debugInfo){
          if (N == codeBodyEntity) {
            specializedCode=myloader.makeCodeBodyCode(cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo,method.getDeclaringClass());
          }
 else {
            super.defineFunction(N,definingContext,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
          }
        }
        @Override public void translate(        CAstEntity N,        WalkContext context){
          if (N == m.getEntity()) {
            codeBodyEntity=fold.rewrite(args.rewrite(N));
            super.translate(codeBodyEntity,context);
          }
 else {
            super.translate(N,context);
          }
        }
      }
      ArgumentativeTranslator a=new ArgumentativeTranslator(myloader);
      m.retranslate(a);
      return super.makeIR(a.specializedCode,context,options);
    }
  }
  return super.makeIR(method,context,options);
}",0.998531117124082
99723,"@Override protected void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] caughtTypes,boolean hasMonitorOp,AstLexicalInformation LI,DebuggingInformation debugInfo){
  String fnName=""String_Node_Str"" + composeEntityName(definingContext,N);
  names.add(fnName);
  super.defineFunction(N,definingContext,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
}","@Override protected void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,Map<IBasicBlock,TypeReference[]> caughtTypes,boolean hasMonitorOp,AstLexicalInformation LI,DebuggingInformation debugInfo){
  String fnName=""String_Node_Str"" + composeEntityName(definingContext,N);
  names.add(fnName);
  super.defineFunction(N,definingContext,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
}",0.9791894852135816
99724,"/** 
 * @param cha
 * @param cl
 * @param fileName
 * @param url
 * @return The set of class names that where defined in the CHA as a resultloading process.
 * @throws IOException
 */
public static Set<String> loadAdditionalFile(IClassHierarchy cha,JavaScriptLoader cl,String fileName,URL url) throws IOException {
  try {
    SourceURLModule M=new SourceURLModule(url);
    TranslatorToCAst toCAst=getTranslatorFactory().make(new CAstImpl(),M);
    final Set<String> names=new HashSet<String>();
    JSAstTranslator toIR=new JSAstTranslator(cl){
      @Override protected void defineFunction(      CAstEntity N,      WalkContext definingContext,      AbstractCFG cfg,      SymbolTable symtab,      boolean hasCatchBlock,      TypeReference[][] caughtTypes,      boolean hasMonitorOp,      AstLexicalInformation LI,      DebuggingInformation debugInfo){
        String fnName=""String_Node_Str"" + composeEntityName(definingContext,N);
        names.add(fnName);
        super.defineFunction(N,definingContext,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
      }
      @Override protected void leaveFunctionStmt(      CAstNode n,      WalkContext c,      CAstVisitor<WalkContext> visitor){
        CAstEntity fn=(CAstEntity)n.getChild(0).getValue();
        Scope cs=c.currentScope();
        if (!cs.contains(fn.getName()) || cs.lookup(fn.getName()).getDefiningScope().getEntity().getKind() == CAstEntity.SCRIPT_ENTITY) {
          int result=processFunctionExpr(n,c);
          assignValue(n,c,cs.lookup(fn.getName()),fn.getName(),result);
        }
 else {
          super.leaveFunctionStmt(n,c,visitor);
        }
      }
    }
;
    CAstEntity tree;
    try {
      tree=toCAst.translateToCAst();
      if (DEBUG) {
        CAstPrinter.printTo(tree,new PrintWriter(System.err));
      }
      toIR.translate(tree,M);
      for (      String name : names) {
        IClass fcls=cl.lookupClass(name,cha);
        cha.addClass(fcls);
      }
      return names;
    }
 catch (    Error e) {
      return Collections.emptySet();
    }
  }
 catch (  RuntimeException e) {
    return Collections.emptySet();
  }
}","/** 
 * @param cha
 * @param cl
 * @param fileName
 * @param url
 * @return The set of class names that where defined in the CHA as a resultloading process.
 * @throws IOException
 */
public static Set<String> loadAdditionalFile(IClassHierarchy cha,JavaScriptLoader cl,String fileName,URL url) throws IOException {
  try {
    SourceURLModule M=new SourceURLModule(url);
    TranslatorToCAst toCAst=getTranslatorFactory().make(new CAstImpl(),M);
    final Set<String> names=new HashSet<String>();
    JSAstTranslator toIR=new JSAstTranslator(cl){
      @Override protected void defineFunction(      CAstEntity N,      WalkContext definingContext,      AbstractCFG cfg,      SymbolTable symtab,      boolean hasCatchBlock,      Map<IBasicBlock,TypeReference[]> caughtTypes,      boolean hasMonitorOp,      AstLexicalInformation LI,      DebuggingInformation debugInfo){
        String fnName=""String_Node_Str"" + composeEntityName(definingContext,N);
        names.add(fnName);
        super.defineFunction(N,definingContext,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
      }
      @Override protected void leaveFunctionStmt(      CAstNode n,      WalkContext c,      CAstVisitor<WalkContext> visitor){
        CAstEntity fn=(CAstEntity)n.getChild(0).getValue();
        Scope cs=c.currentScope();
        if (!cs.contains(fn.getName()) || cs.lookup(fn.getName()).getDefiningScope().getEntity().getKind() == CAstEntity.SCRIPT_ENTITY) {
          int result=processFunctionExpr(n,c);
          assignValue(n,c,cs.lookup(fn.getName()),fn.getName(),result);
        }
 else {
          super.leaveFunctionStmt(n,c,visitor);
        }
      }
    }
;
    CAstEntity tree;
    try {
      tree=toCAst.translateToCAst();
      if (DEBUG) {
        CAstPrinter.printTo(tree,new PrintWriter(System.err));
      }
      toIR.translate(tree,M);
      for (      String name : names) {
        IClass fcls=cl.lookupClass(name,cha);
        cha.addClass(fcls);
      }
      return names;
    }
 catch (    Error e) {
      return Collections.emptySet();
    }
  }
 catch (  RuntimeException e) {
    return Collections.emptySet();
  }
}",0.9955555555555556
99725,"public JavaScriptMethodObject makeCodeBodyCode(AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo,IClass C){
  return new JavaScriptMethodObject(C,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,lexicalInfo,debugInfo);
}","public JavaScriptMethodObject makeCodeBodyCode(AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,Map<IBasicBlock,TypeReference[]> caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo,IClass C){
  return new JavaScriptMethodObject(C,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,lexicalInfo,debugInfo);
}",0.972972972972973
99726,"public IMethod defineCodeBodyCode(String clsName,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo){
}","public IMethod defineCodeBodyCode(String clsName,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,Map<IBasicBlock,TypeReference[]> caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo){
}",0.9591397849462364
99727,"JavaScriptMethodObject(IClass cls,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo){
  super(cls,functionQualifiers,cfg,symtab,AstMethodReference.fnReference(cls.getReference()),hasCatchBlock,caughtTypes,hasMonitorOp,lexicalInfo,debugInfo,null);
  symtab.getNullConstant();
}","JavaScriptMethodObject(IClass cls,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,Map<IBasicBlock,TypeReference[]> caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo){
  super(cls,functionQualifiers,cfg,symtab,AstMethodReference.fnReference(cls.getReference()),hasCatchBlock,caughtTypes,hasMonitorOp,lexicalInfo,debugInfo,null);
  symtab.getNullConstant();
}",0.976629766297663
99728,"protected void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] caughtTypes,boolean hasMonitorOp,AstLexicalInformation LI,DebuggingInformation debugInfo){
  if (DEBUG)   System.err.println((""String_Node_Str"" + N));
  String fnName=composeEntityName(definingContext,N);
  if (DEBUG)   System.err.println(cfg);
  ((JavaScriptLoader)loader).defineCodeBodyCode(""String_Node_Str"" + fnName,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
}","protected void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,Map<IBasicBlock,TypeReference[]> caughtTypes,boolean hasMonitorOp,AstLexicalInformation LI,DebuggingInformation debugInfo){
  if (DEBUG)   System.err.println((""String_Node_Str"" + N));
  String fnName=composeEntityName(definingContext,N);
  if (DEBUG)   System.err.println(cfg);
  ((JavaScriptLoader)loader).defineCodeBodyCode(""String_Node_Str"" + fnName,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
}",0.9823911028730306
99729,"private void setupCatchTypes(SSACFG cfg,TypeReference[][] catchTypes){
  for (int i=0; i < catchTypes.length; i++) {
    if (catchTypes[i] != null) {
      ExceptionHandlerBasicBlock bb=(ExceptionHandlerBasicBlock)cfg.getNode(i);
      for (int j=0; j < catchTypes[i].length; j++) {
        bb.addCaughtExceptionType(catchTypes[i][j]);
      }
    }
  }
}","private void setupCatchTypes(SSACFG cfg,Map<IBasicBlock,TypeReference[]> map){
  for (  Map.Entry<IBasicBlock,TypeReference[]> e : map.entrySet()) {
    if (e.getKey().getNumber() != -1) {
      ExceptionHandlerBasicBlock bb=(ExceptionHandlerBasicBlock)cfg.getNode(e.getKey().getNumber());
      for (int j=0; j < e.getValue().length; j++) {
        bb.addCaughtExceptionType(e.getValue()[j]);
      }
    }
  }
}",0.6432291666666666
99730,"/** 
 * When adding an edge from source to target, it is possible that certain exception-handling code needs to be executed before the control is actually transfered to target. This method determines if this is the case, and if so, it generates the exception handler blocks and adds an appropriate edge to the target. It returns the basic block that should be the target of the edge from source (target itself if there is no exception-handling code, the initial catch block otherwise)
 */
public PreBasicBlock findOrCreateCode(PreBasicBlock source,PreBasicBlock target,final boolean exception){
  UnwindState sourceContext=unwindData.get(source);
  final CAstNode dummy=exception ? (new CAstImpl()).makeNode(CAstNode.EMPTY) : null;
  if (sourceContext == null)   return target;
  WalkContext astContext=sourceContext.astContext;
  UnwindState targetContext=null;
  if (target != null)   targetContext=unwindData.get(target);
  if (targetContext != null && targetContext.covers(sourceContext))   return target;
  Pair<UnwindState,Pair<PreBasicBlock,Boolean>> key=Pair.make(sourceContext,Pair.make(target,exception));
  if (code.containsKey(key)) {
    return code.get(key);
  }
 else {
    int e=-1;
    PreBasicBlock currentBlock=getCurrentBlock();
    if (!isDeadBlock(currentBlock)) {
      addInstruction(insts.GotoInstruction());
      newBlock(false);
    }
    PreBasicBlock startBlock=getCurrentBlock();
    if (exception) {
      setCurrentBlockAsHandler();
      e=sourceContext.astContext.currentScope().allocateTempValue();
      addInstruction(insts.GetCaughtExceptionInstruction(startBlock.getNumber(),e));
      sourceContext.astContext.setCatchType(startBlock.getNumber(),defaultCatchType());
    }
    while (sourceContext != null && (targetContext == null || !targetContext.covers(sourceContext))) {
      final CAstRewriter.Rewrite ast=(new CAstCloner(new CAstImpl()){
        protected CAstNode flowOutTo(        Map<Pair<CAstNode,NoKey>,CAstNode> nodeMap,        CAstNode oldSource,        Object label,        CAstNode oldTarget,        CAstControlFlowMap orig,        CAstSourcePositionMap src){
          if (exception && !isExceptionLabel(label)) {
            return dummy;
          }
 else {
            return oldTarget;
          }
        }
      }
).copy(sourceContext.unwindAst,sourceContext.astContext.getControlFlow(),sourceContext.astContext.getSourceMap(),sourceContext.astContext.top().getNodeTypeMap(),sourceContext.astContext.top().getAllScopedEntities());
      sourceContext.astVisitor.visit(ast.newRoot(),new DelegatingContext(sourceContext.astContext){
        public CAstSourcePositionMap getSourceMap(){
          return ast.newPos();
        }
        public CAstControlFlowMap getControlFlow(){
          return ast.newCfg();
        }
      }
,sourceContext.astVisitor);
      sourceContext=sourceContext.getParent();
    }
    PreBasicBlock endBlock=getCurrentBlock();
    if (exception) {
      addPreNode(dummy);
      doThrow(astContext,e);
    }
 else {
      addInstruction(insts.GotoInstruction());
    }
    newBlock(false);
    addEdge(currentBlock,getCurrentBlock());
    if (target != null) {
      addEdge(endBlock,target);
    }
 else {
      addDelayedEdge(endBlock,exitMarker,exception);
    }
    code.put(key,startBlock);
    return startBlock;
  }
}","/** 
 * When adding an edge from source to target, it is possible that certain exception-handling code needs to be executed before the control is actually transfered to target. This method determines if this is the case, and if so, it generates the exception handler blocks and adds an appropriate edge to the target. It returns the basic block that should be the target of the edge from source (target itself if there is no exception-handling code, the initial catch block otherwise)
 */
public PreBasicBlock findOrCreateCode(PreBasicBlock source,PreBasicBlock target,final boolean exception){
  UnwindState sourceContext=unwindData.get(source);
  final CAstNode dummy=exception ? (new CAstImpl()).makeNode(CAstNode.EMPTY) : null;
  if (sourceContext == null)   return target;
  WalkContext astContext=sourceContext.astContext;
  UnwindState targetContext=null;
  if (target != null)   targetContext=unwindData.get(target);
  if (targetContext != null && targetContext.covers(sourceContext))   return target;
  Pair<UnwindState,Pair<PreBasicBlock,Boolean>> key=Pair.make(sourceContext,Pair.make(target,exception));
  if (code.containsKey(key)) {
    return code.get(key);
  }
 else {
    int e=-1;
    PreBasicBlock currentBlock=getCurrentBlock();
    if (!isDeadBlock(currentBlock)) {
      addInstruction(insts.GotoInstruction());
      newBlock(false);
    }
    PreBasicBlock startBlock=getCurrentBlock();
    if (exception) {
      setCurrentBlockAsHandler();
      e=sourceContext.astContext.currentScope().allocateTempValue();
      addInstruction(insts.GetCaughtExceptionInstruction(startBlock.getNumber(),e));
      sourceContext.astContext.setCatchType(startBlock,defaultCatchType());
    }
    while (sourceContext != null && (targetContext == null || !targetContext.covers(sourceContext))) {
      final CAstRewriter.Rewrite ast=(new CAstCloner(new CAstImpl()){
        protected CAstNode flowOutTo(        Map<Pair<CAstNode,NoKey>,CAstNode> nodeMap,        CAstNode oldSource,        Object label,        CAstNode oldTarget,        CAstControlFlowMap orig,        CAstSourcePositionMap src){
          if (exception && !isExceptionLabel(label)) {
            return dummy;
          }
 else {
            return oldTarget;
          }
        }
      }
).copy(sourceContext.unwindAst,sourceContext.astContext.getControlFlow(),sourceContext.astContext.getSourceMap(),sourceContext.astContext.top().getNodeTypeMap(),sourceContext.astContext.top().getAllScopedEntities());
      sourceContext.astVisitor.visit(ast.newRoot(),new DelegatingContext(sourceContext.astContext){
        public CAstSourcePositionMap getSourceMap(){
          return ast.newPos();
        }
        public CAstControlFlowMap getControlFlow(){
          return ast.newCfg();
        }
      }
,sourceContext.astVisitor);
      sourceContext=sourceContext.getParent();
    }
    PreBasicBlock endBlock=getCurrentBlock();
    if (exception) {
      addPreNode(dummy);
      doThrow(astContext,e);
    }
 else {
      addInstruction(insts.GotoInstruction());
    }
    newBlock(false);
    addEdge(currentBlock,getCurrentBlock());
    if (target != null) {
      addEdge(endBlock,target);
    }
 else {
      addDelayedEdge(endBlock,exitMarker,exception);
    }
    code.put(key,startBlock);
    return startBlock;
  }
}",0.99818676337262
99731,"/** 
 * fully define a function. invoked after all the code of the function has been processed
 */
protected abstract void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] caughtTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo);","/** 
 * fully define a function. invoked after all the code of the function has been processed
 */
protected abstract void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,Map<IBasicBlock,TypeReference[]> catchTypes,boolean hasMonitorOp,AstLexicalInformation lexicalInfo,DebuggingInformation debugInfo);",0.9555555555555556
99732,"public TypeReference[][] getCatchTypes(){
  return null;
}","public Map<IBasicBlock,TypeReference[]> getCatchTypes(){
  return null;
}",0.8549618320610687
99733,"public void closeFunctionEntity(final CAstEntity n,WalkContext parentContext,WalkContext functionContext){
  functionContext.cfg().makeExitBlock(functionContext.cfg().newBlock(true));
  SymbolTable symtab=((AbstractScope)functionContext.currentScope()).getUnderlyingSymtab();
  TypeReference[][] catchTypes=functionContext.getCatchTypes();
  AstCFG cfg=new AstCFG(n,functionContext.cfg(),symtab);
  Position[] line=functionContext.cfg().getLinePositionMap();
  boolean katch=functionContext.cfg().hasCatchBlock();
  boolean monitor=functionContext.cfg().hasMonitorOp();
  String[] nms=makeNameMap(n,functionContext.entityScopes());
  patchLexicalAccesses(cfg.getInstructions(),functionContext.getAccesses(n));
  AstLexicalInformation LI=new AstLexicalInformation(functionContext.getEntityName(n),(AbstractScope)functionContext.currentScope(),cfg.getInstructions(),functionContext.exposeNameSet(n,false),functionContext.exposeNameSet(n,true),functionContext.getAccesses(n));
  DebuggingInformation DBG=new AstDebuggingInformation(n.getPosition(),line,nms);
  defineFunction(n,parentContext,cfg,symtab,katch,catchTypes,monitor,LI,DBG);
}","public void closeFunctionEntity(final CAstEntity n,WalkContext parentContext,WalkContext functionContext){
  functionContext.cfg().makeExitBlock(functionContext.cfg().newBlock(true));
  SymbolTable symtab=((AbstractScope)functionContext.currentScope()).getUnderlyingSymtab();
  Map<IBasicBlock,TypeReference[]> catchTypes=functionContext.getCatchTypes();
  AstCFG cfg=new AstCFG(n,functionContext.cfg(),symtab);
  Position[] line=functionContext.cfg().getLinePositionMap();
  boolean katch=functionContext.cfg().hasCatchBlock();
  boolean monitor=functionContext.cfg().hasMonitorOp();
  String[] nms=makeNameMap(n,functionContext.entityScopes());
  patchLexicalAccesses(cfg.getInstructions(),functionContext.getAccesses(n));
  AstLexicalInformation LI=new AstLexicalInformation(functionContext.getEntityName(n),(AbstractScope)functionContext.currentScope(),cfg.getInstructions(),functionContext.exposeNameSet(n,false),functionContext.exposeNameSet(n,true),functionContext.getAccesses(n));
  DebuggingInformation DBG=new AstDebuggingInformation(n.getPosition(),line,nms);
  defineFunction(n,parentContext,cfg,symtab,katch,catchTypes,monitor,LI,DBG);
}",0.9916849015317286
99734,"public void copyState(BitVectorVariable other){
  if (other == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (V == null) {
    if (other.V == null) {
      return;
    }
 else {
      V=new MutableSharedBitVectorIntSet(other.V);
      return;
    }
  }
  if (other.V != null) {
    V.copySet(other.V);
  }
}","public void copyState(BitVectorVariable other){
  if (other == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (V == null) {
    if (other.V == null) {
      return;
    }
 else {
      V=new MutableSharedBitVectorIntSet(other.V);
      return;
    }
  }
  if (other.V != null) {
    V.copySet(other.V);
  }
 else {
    V=null;
  }
}",0.9627507163323782
99735,"/** 
 * Properly creates the String file name of a   {@link URL}. This works around a bug in the Sun implementation of   {@link URL#getFile()}, which doesn't properly handle file paths with spaces (see <a href= ""http://sourceforge.net/tracker/index.php?func=detail&aid=1565842&group_id=176742&atid=878458"" >bug report</a>). For now, fails with an assertion if the url is malformed.
 * @param url
 * @return the path name for the url
 * @throws IllegalArgumentException if url is null
 */
public String filePathFromURL(URL url){
  if (url == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URI uri=new File(url.getPath()).toURI();
  try {
    return URLDecoder.decode(uri.getPath(),""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    Assertions.UNREACHABLE();
    return null;
  }
}","/** 
 * Properly creates the String file name of a   {@link URL}. This works around a bug in the Sun implementation of   {@link URL#getFile()}, which doesn't properly handle file paths with spaces (see <a href= ""http://sourceforge.net/tracker/index.php?func=detail&aid=1565842&group_id=176742&atid=878458"" >bug report</a>). For now, fails with an assertion if the url is malformed.
 * @param url
 * @return the path name for the url
 * @throws IllegalArgumentException if url is null
 */
public String filePathFromURL(URL url){
  if (url == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    URI uri=new File(URLDecoder.decode(url.getPath(),""String_Node_Str"")).toURI();
    return uri.getPath();
  }
 catch (  UnsupportedEncodingException e) {
    Assertions.UNREACHABLE();
    return null;
  }
}",0.9455864570737604
99736,"@TestAnnotation(doSomething=""String_Node_Str"",count=1,date=""String_Node_Str"") public void mymethod(){
}","@TestAnnotation(doSomething=""String_Node_Str"",count=1,date=""String_Node_Str"",stuff={}) public int mymethod(){
  @AnotherTestAnnotation(""String_Node_Str"") int i=0;
  return i;
}",0.7168458781362007
99737,"@TestAnnotation(doSomething=""String_Node_Str"",count=0,date=""String_Node_Str"") public static void main(String[] args){
  (new Annotations()).mymethod();
}","@TestAnnotation(doSomething=""String_Node_Str"",count=0,date=""String_Node_Str"",stuff={1,2,3,4,5}) public static void main(String[] args){
  (new Annotations()).mymethod();
}",0.9444444444444444
99738,"public void check(CallGraph cg){
  classes:   for (  ClassAnnotation ca : classAnnotations) {
    IClass cls=cg.getClassHierarchy().lookupClass(TypeReference.findOrCreate(ClassLoaderReference.Application,ca.className));
    IClass at=cg.getClassHierarchy().lookupClass(TypeReference.findOrCreate(ClassLoaderReference.Application,ca.annotationTypeName));
    for (    Annotation a : cls.getAnnotations()) {
      if (a.getType().equals(at.getReference())) {
        continue classes;
      }
    }
    Assert.assertFalse(""String_Node_Str"" + at + ""String_Node_Str""+ cls,false);
  }
  for (  MethodAnnotation ma : methodAnnotations) {
    IClass at=cg.getClassHierarchy().lookupClass(TypeReference.findOrCreate(ClassLoaderReference.Application,ma.annotationTypeName));
    annot:     for (    CGNode n : cg) {
      if (n.getMethod().getSignature().equals(ma.methodSig)) {
        for (        Annotation a : n.getMethod().getAnnotations()) {
          if (a.getType().equals(at.getReference())) {
            continue annot;
          }
        }
        Assert.assertFalse(""String_Node_Str"" + at,false);
      }
    }
  }
}","public void check(CallGraph cg){
  classes:   for (  ClassAnnotation ca : classAnnotations) {
    IClass cls=cg.getClassHierarchy().lookupClass(TypeReference.findOrCreate(ClassLoaderReference.Application,ca.className));
    IClass at=cg.getClassHierarchy().lookupClass(TypeReference.findOrCreate(ClassLoaderReference.Application,ca.annotationTypeName));
    for (    Annotation a : cls.getAnnotations()) {
      if (a.getType().equals(at.getReference())) {
        continue classes;
      }
    }
    Assert.assertFalse(""String_Node_Str"" + at + ""String_Node_Str""+ cls,false);
  }
  annot:   for (  MethodAnnotation ma : methodAnnotations) {
    IClass at=cg.getClassHierarchy().lookupClass(TypeReference.findOrCreate(ClassLoaderReference.Application,ma.annotationTypeName));
    for (    CGNode n : cg) {
      if (n.getMethod().getSignature().equals(ma.methodSig)) {
        for (        Annotation a : n.getMethod().getAnnotations()) {
          if (a.getType().equals(at.getReference())) {
            continue annot;
          }
        }
        Assert.assertFalse(""String_Node_Str"" + at,false);
      }
    }
  }
}",0.9910793933987512
99739,"protected CAstEntity parseJS(CAstImpl ast,SourceModule module) throws IOException {
  RhinoToAstTranslator translator=new RhinoToAstTranslator(ast,module,module.getName(),false);
  CAstEntity entity=translator.translateToCAst();
  return entity;
}","protected CAstEntity parseJS(CAstImpl ast,SourceModule module) throws IOException {
}",0.5120481927710844
99740,"protected CAstEntity parseJS(CAstImpl ast,SourceModule module) throws IOException {
  RhinoToAstTranslator translator=new RhinoToAstTranslator(ast,module,module.getName(),false);
  CAstEntity entity=translator.translateToCAst();
  return entity;
}","protected CAstEntity parseJS(CAstImpl ast,SourceModule module) throws IOException {
}",0.5120481927710844
99741,"public static void main(String args[]) throws ClassHierarchyException, IllegalArgumentException, IOException, CancelException {
  if (args.length != 1) {
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  boolean domless=false;
  URL url=new URL(args[0]);
  JSCallGraphBuilderUtil.setTranslatorFactory(new CAstRhinoTranslatorFactory());
  JavaScriptLoader.addBootstrapFile(WebUtil.preamble);
  SourceModule[] sources=getSources(domless,url);
  JSCFABuilder builder=makeCGBuilder(new WebPageLoaderFactory(translatorFactory),sources,CGBuilderType.ZERO_ONE_CFA,AstIRFactory.makeDefaultFactory());
  builder.setBaseURL(url);
  CallGraph cg=builder.makeCallGraph(builder.getOptions());
  PointerAnalysis pa=builder.getPointerAnalysis();
  new JsViewer(cg,pa);
}","public static void main(String args[]) throws ClassHierarchyException, IllegalArgumentException, IOException, CancelException, Error {
  if (args.length != 1) {
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  boolean domless=false;
  URL url=new URL(args[0]);
  JSCallGraphBuilderUtil.setTranslatorFactory(new CAstRhinoTranslatorFactory());
  JavaScriptLoader.addBootstrapFile(WebUtil.preamble);
  SourceModule[] sources=getSources(domless,url);
  JSCFABuilder builder=makeCGBuilder(new WebPageLoaderFactory(translatorFactory),sources,CGBuilderType.ZERO_ONE_CFA,AstIRFactory.makeDefaultFactory());
  builder.setBaseURL(url);
  CallGraph cg=builder.makeCallGraph(builder.getOptions());
  PointerAnalysis pa=builder.getPointerAnalysis();
  new JsViewer(cg,pa);
}",0.9954983922829582
99742,"private static SourceModule[] getSources(boolean domless,URL url) throws IOException {
  JSSourceExtractor sourceExtractor;
  if (domless) {
    sourceExtractor=new DomLessSourceExtractor();
  }
 else {
    sourceExtractor=new DefaultSourceExtractor();
  }
  Set<MappedSourceModule> sourcesMap=sourceExtractor.extractSources(url,new JerichoHtmlParser(),new IdentityUrlResolver());
  SourceModule[] sources=new SourceFileModule[sourcesMap.size()];
  int i=0;
  for (  SourceModule m : sourcesMap) {
    sources[i++]=m;
  }
  return sources;
}","private static SourceModule[] getSources(boolean domless,URL url) throws IOException, Error {
  JSSourceExtractor sourceExtractor;
  if (domless) {
    sourceExtractor=new DomLessSourceExtractor();
  }
 else {
    sourceExtractor=new DefaultSourceExtractor();
  }
  Set<MappedSourceModule> sourcesMap=sourceExtractor.extractSources(url,new JerichoHtmlParser(),new IdentityUrlResolver());
  SourceModule[] sources=new SourceFileModule[sourcesMap.size()];
  int i=0;
  for (  SourceModule m : sourcesMap) {
    sources[i++]=m;
  }
  return sources;
}",0.9935720844811754
99743,"/** 
 * Properly creates the String file name of a   {@link URL}. This works around a bug in the Sun implementation of   {@link URL#getFile()}, which doesn't properly handle file paths with spaces (see <a href= ""http://sourceforge.net/tracker/index.php?func=detail&aid=1565842&group_id=176742&atid=878458"" >bug report</a>). For now, fails with an assertion if the url is malformed.
 * @param url
 * @return the path name for the url
 * @throws IllegalArgumentException if url is null
 */
public String filePathFromURL(URL url){
  if (url == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URI uri=new File(url.getPath()).toURI();
  String filePath=uri.getPath();
  return filePath;
}","/** 
 * Properly creates the String file name of a   {@link URL}. This works around a bug in the Sun implementation of   {@link URL#getFile()}, which doesn't properly handle file paths with spaces (see <a href= ""http://sourceforge.net/tracker/index.php?func=detail&aid=1565842&group_id=176742&atid=878458"" >bug report</a>). For now, fails with an assertion if the url is malformed.
 * @param url
 * @return the path name for the url
 * @throws IllegalArgumentException if url is null
 */
public String filePathFromURL(URL url){
  if (url == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URI uri=new File(url.getPath()).toURI();
  try {
    return URLDecoder.decode(uri.getPath(),""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    Assertions.UNREACHABLE();
    return null;
  }
}",0.8748370273794003
99744,"@Override public byte evaluate(final BitVectorVariable lhs,final BitVectorVariable[] rhs){
  IntSet intersect=lhs.getValue();
  if (intersect == null || intersect.isEmpty()) {
    return NOT_CHANGED_AND_FIXED;
  }
  for (  final BitVectorVariable bv : rhs) {
    final IntSet vlhs=bv.getValue();
    intersect=intersect.intersection(vlhs);
  }
  if (intersect.sameValue(lhs.getValue())) {
    return NOT_CHANGED;
  }
 else {
    final BitVectorVariable bvv=new BitVectorVariable();
    intersect.foreach(new IntSetAction(){
      @Override public void act(      final int x){
        bvv.set(x);
      }
    }
);
    lhs.copyState(bvv);
    return CHANGED;
  }
}","@Override public byte evaluate(final BitVectorVariable lhs,final BitVectorVariable[] rhs){
  IntSet intersect=lhs.getValue();
  if (intersect == null || intersect.isEmpty()) {
    intersect=rhs[0].getValue();
  }
  for (  final BitVectorVariable bv : rhs) {
    final IntSet vlhs=bv.getValue();
    intersect=intersect.intersection(vlhs);
  }
  if (lhs.getValue() != null && intersect.sameValue(lhs.getValue())) {
    return NOT_CHANGED;
  }
 else {
    final BitVectorVariable bvv=new BitVectorVariable();
    intersect.foreach(new IntSetAction(){
      @Override public void act(      final int x){
        bvv.set(x);
      }
    }
);
    lhs.copyState(bvv);
    return CHANGED;
  }
}",0.3261675315048183
99745,"private int passActualPropertyValsAsParams(JSInstructionFactory insts,int nargs,JavaScriptSummary S,int[] paramsToPassToInvoked){
  int curValNum=nargs + 2;
  for (int i=1; i < paramsToPassToInvoked.length; i++) {
    final int constVN=curValNum++;
    S.addConstant(constVN,new ConstantValue(i - 1));
    int propertyReadResult=curValNum++;
    S.addStatement(insts.PropertyRead(propertyReadResult,4,constVN));
    paramsToPassToInvoked[i]=propertyReadResult;
  }
  return curValNum;
}","private int passActualPropertyValsAsParams(JSInstructionFactory insts,int nargs,JavaScriptSummary S,int[] paramsToPassToInvoked){
  int curValNum=nargs + 2;
  for (int i=1; i < paramsToPassToInvoked.length; i++) {
    final int constVN=curValNum++;
    S.addConstant(constVN,new ConstantValue(i - 1));
    int propertyReadResult=curValNum++;
    S.addStatement(insts.PropertyRead(propertyReadResult,4,constVN));
    S.getNextProgramCounter();
    paramsToPassToInvoked[i]=propertyReadResult;
  }
  return curValNum;
}",0.9690927218344964
99746,"@Override public void run(){
  try {
    boolean repeat=true;
    while (repeat) {
      try {
        Thread.sleep(SLEEP_MS);
      }
 catch (      InterruptedException e1) {
      }
      drain();
      try {
        p.exitValue();
        repeat=false;
        drain();
        if (logger != null) {
          logger.fine(""String_Node_Str"" + p.exitValue());
        }
      }
 catch (      IllegalThreadStateException e) {
        repeat=true;
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","@Override public void run(){
  try {
    boolean repeat=true;
    while (repeat) {
      try {
        Thread.sleep(SLEEP_MS);
      }
 catch (      InterruptedException e1) {
      }
      drain();
      try {
        p.exitValue();
        repeat=false;
        blockingDrain();
        if (logger != null) {
          logger.fine(""String_Node_Str"" + p.exitValue());
        }
      }
 catch (      IllegalThreadStateException e) {
        repeat=true;
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.9904942965779469
99747,abstract void drain() throws IOException ;,"/** 
 * Drain data from the stream, but don't block.
 */
abstract void drain() throws IOException ;",0.5957446808510638
99748,"protected Drainer captureStdErr(Process p){
  final BufferedInputStream out=new BufferedInputStream(p.getErrorStream(),BUFFER_SIZE);
  final ByteArrayOutputStream b=new ByteArrayOutputStream(BUFFER_SIZE);
  Drainer result=new Drainer(p){
    @Override void drain() throws IOException {
      drainAndCatch(out,b);
    }
  }
;
  result.setCapture(b);
  result.start();
  return result;
}","protected Drainer captureStdErr(Process p){
  final BufferedInputStream out=new BufferedInputStream(p.getErrorStream(),BUFFER_SIZE);
  final ByteArrayOutputStream b=new ByteArrayOutputStream(BUFFER_SIZE);
  Drainer result=new Drainer(p){
    @Override void drain() throws IOException {
      drainAndCatch(out,b);
    }
    @Override void blockingDrain() throws IOException {
      blockingDrainAndCatch(out,b);
    }
  }
;
  result.setCapture(b);
  result.start();
  return result;
}",0.8873563218390804
99749,"private void drainAndCatch(BufferedInputStream s,ByteArrayOutputStream b) throws IOException {
  try {
    while (s.available() > 0) {
      byte[] data=new byte[s.available()];
      int nRead=s.read(data);
      b.write(data,0,nRead);
    }
  }
 catch (  IOException e) {
  }
}","/** 
 * Drain some data from the input stream, and append said data to b.  Do not block.
 */
private void drainAndCatch(BufferedInputStream s,ByteArrayOutputStream b) throws IOException {
  try {
    while (s.available() > 0) {
      byte[] data=new byte[s.available()];
      int nRead=s.read(data);
      b.write(data,0,nRead);
    }
  }
 catch (  IOException e) {
  }
}",0.8571428571428571
99750,"protected Thread drainStdErr(Process p){
  final BufferedInputStream err=new BufferedInputStream(p.getErrorStream(),BUFFER_SIZE);
  Thread result=new Drainer(p){
    @Override void drain() throws IOException {
      drainAndPrint(err,System.err);
    }
  }
;
  result.start();
  return result;
}","protected Thread drainStdErr(Process p){
  final BufferedInputStream err=new BufferedInputStream(p.getErrorStream(),BUFFER_SIZE);
  Thread result=new Drainer(p){
    @Override void drain() throws IOException {
      drainAndPrint(err,System.err);
    }
    @Override void blockingDrain() throws IOException {
      blockingDrainAndPrint(err,System.err);
    }
  }
;
  result.start();
  return result;
}",0.8464849354375896
99751,"protected Thread drainStdOut(Process p){
  final BufferedInputStream out=new BufferedInputStream(p.getInputStream(),BUFFER_SIZE);
  Thread result=new Drainer(p){
    @Override void drain() throws IOException {
      drainAndPrint(out,System.out);
    }
  }
;
  result.start();
  return result;
}","protected Thread drainStdOut(Process p){
  final BufferedInputStream out=new BufferedInputStream(p.getInputStream(),BUFFER_SIZE);
  Thread result=new Drainer(p){
    @Override void drain() throws IOException {
      drainAndPrint(out,System.out);
    }
    @Override void blockingDrain() throws IOException {
      blockingDrainAndPrint(out,System.out);
    }
  }
;
  result.start();
  return result;
}",0.8464849354375896
99752,"protected Drainer captureStdOut(Process p){
  final BufferedInputStream out=new BufferedInputStream(p.getInputStream(),BUFFER_SIZE);
  final ByteArrayOutputStream b=new ByteArrayOutputStream(BUFFER_SIZE);
  Drainer result=new Drainer(p){
    @Override void drain() throws IOException {
      drainAndCatch(out,b);
    }
  }
;
  result.setCapture(b);
  result.start();
  return result;
}","protected Drainer captureStdOut(Process p){
  final BufferedInputStream out=new BufferedInputStream(p.getInputStream(),BUFFER_SIZE);
  final ByteArrayOutputStream b=new ByteArrayOutputStream(BUFFER_SIZE);
  Drainer result=new Drainer(p){
    @Override void drain() throws IOException {
      drainAndCatch(out,b);
    }
    @Override void blockingDrain() throws IOException {
      blockingDrainAndCatch(out,b);
    }
  }
;
  result.setCapture(b);
  result.start();
  return result;
}",0.8873563218390804
99753,"private void drainAndPrint(BufferedInputStream s,PrintStream p) throws IOException {
  try {
    while (s.available() > 0) {
      byte[] data=new byte[s.available()];
      s.read(data);
      p.print(new String(data));
    }
  }
 catch (  IOException e) {
  }
}","/** 
 * Drain some data from the input stream, and print said data to p.  Do not block.
 */
private void drainAndPrint(BufferedInputStream s,PrintStream p) throws IOException {
  try {
    while (s.available() > 0) {
      byte[] data=new byte[s.available()];
      s.read(data);
      p.print(new String(data));
    }
  }
 catch (  IOException e) {
  }
}",0.8511326860841424
99754,"/** 
 * Process an element indicating a new allocation site.
 * @param atts
 */
private void processAllocation(Attributes atts){
  Language lang=scope.getLanguage(governingLoader.getLanguage());
  SSAInstructionFactory insts=lang.instructionFactory();
  String classString=atts.getValue(A_CLASS);
  final TypeReference type=TypeReference.findOrCreate(governingLoader,TypeName.string2TypeName(classString));
  String defVar=atts.getValue(A_DEF);
  if (symbolTable.keySet().contains(defVar)) {
    Assertions.UNREACHABLE(""String_Node_Str"" + defVar + ""String_Node_Str""+ governingMethod);
  }
  if (defVar == null) {
    defVar=""String_Node_Str"" + nextLocal;
  }
  int defNum=nextLocal;
  symbolTable.put(defVar,new Integer(nextLocal++));
  NewSiteReference ref=NewSiteReference.make(governingMethod.getNextProgramCounter(),type);
  SSANewInstruction a=null;
  if (type.isArrayType()) {
    String size=atts.getValue(A_SIZE);
    Assertions.productionAssertion(size != null);
    Integer sNumber=symbolTable.get(size);
    Assertions.productionAssertion(sNumber != null);
    Assertions.productionAssertion(type.getDerivedMask() == ArrayMask || type.getDerivedMask() == ((ArrayMask << 2) | PrimitiveMask));
    a=insts.NewInstruction(defNum,ref,new int[]{sNumber.intValue()});
  }
 else {
    a=insts.NewInstruction(defNum,ref);
  }
  governingMethod.addStatement(a);
}","/** 
 * Process an element indicating a new allocation site.
 * @param atts
 */
private void processAllocation(Attributes atts){
  Language lang=scope.getLanguage(governingLoader.getLanguage());
  SSAInstructionFactory insts=lang.instructionFactory();
  String classString=atts.getValue(A_CLASS);
  final TypeReference type=TypeReference.findOrCreate(governingLoader,TypeName.string2TypeName(classString));
  String defVar=atts.getValue(A_DEF);
  if (symbolTable.keySet().contains(defVar)) {
    Assertions.UNREACHABLE(""String_Node_Str"" + defVar + ""String_Node_Str""+ governingMethod);
  }
  if (defVar == null) {
    defVar=""String_Node_Str"" + nextLocal;
  }
  int defNum=nextLocal;
  symbolTable.put(defVar,new Integer(nextLocal++));
  NewSiteReference ref=NewSiteReference.make(governingMethod.getNextProgramCounter(),type);
  SSANewInstruction a=null;
  if (type.isArrayType()) {
    String size=atts.getValue(A_SIZE);
    Assertions.productionAssertion(size != null);
    Integer sNumber=symbolTable.get(size);
    Assertions.productionAssertion(sNumber != null);
    Assertions.productionAssertion(type.getDerivedMask() == ArrayMask || type.getDerivedMask() == ((ArrayMask << ElementBits) | PrimitiveMask));
    a=insts.NewInstruction(defNum,ref,new int[]{sNumber.intValue()});
  }
 else {
    a=insts.NewInstruction(defNum,ref);
  }
  governingMethod.addStatement(a);
}",0.9956204379562044
99755,"protected void iterateCrossProduct(final CGNode caller,final CallSiteReference site,IntSet parameters,final InstanceKey[][] invariants,final VoidFunction<InstanceKey[]> f){
  final IR ir=caller.getIR();
  final int params[]=IntSetUtil.toArray(parameters);
  for (  final SSAAbstractInvokeInstruction call : ir.getCalls(site)) {
    final InstanceKey[] keys=new InstanceKey[call.getNumberOfParameters()];
    new Object(){
      private void rec(      final int pi){
        if (pi == params.length) {
          f.apply(keys);
        }
 else {
          final int p=params[pi];
          int vn=call.getUse(p);
          PointerKey var=getPointerKeyForLocal(caller,vn);
          InstanceKey[] ik=invariants != null ? invariants[p] : null;
          if (ik != null) {
            if (ik.length > 0) {
              for (int i=0; i < ik.length; i++) {
                system.findOrCreateIndexForInstanceKey(ik[i]);
                keys[p]=ik[i];
                rec(pi + 1);
              }
            }
 else {
              if (!site.isDispatch() || p != 0) {
                keys[p]=null;
                rec(pi + 1);
              }
            }
          }
 else {
            IntSet s=system.findOrCreatePointsToSet(var).getValue();
            if (s != null && !s.isEmpty()) {
              s.foreach(new IntSetAction(){
                public void act(                int x){
                  keys[p]=system.getInstanceKey(x);
                  rec(pi + 1);
                }
              }
);
            }
 else {
              if (!site.isDispatch() || p != 0) {
                keys[p]=null;
                rec(pi + 1);
              }
            }
          }
        }
      }
    }
.rec(0);
  }
}","protected void iterateCrossProduct(final CGNode caller,final SSAAbstractInvokeInstruction call,IntSet parameters,final InstanceKey[][] invariants,final VoidFunction<InstanceKey[]> f){
  final int params[]=IntSetUtil.toArray(parameters);
  final InstanceKey[] keys=new InstanceKey[call.getNumberOfParameters()];
  final CallSiteReference site=call.getCallSite();
  new Object(){
    private void rec(    final int pi){
      if (pi == params.length) {
        f.apply(keys);
      }
 else {
        final int p=params[pi];
        int vn=call.getUse(p);
        PointerKey var=getPointerKeyForLocal(caller,vn);
        InstanceKey[] ik=invariants != null ? invariants[p] : null;
        if (ik != null) {
          if (ik.length > 0) {
            for (int i=0; i < ik.length; i++) {
              system.findOrCreateIndexForInstanceKey(ik[i]);
              keys[p]=ik[i];
              rec(pi + 1);
            }
          }
 else {
            if (!site.isDispatch() || p != 0) {
              keys[p]=null;
              rec(pi + 1);
            }
          }
        }
 else {
          IntSet s=system.findOrCreatePointsToSet(var).getValue();
          if (s != null && !s.isEmpty()) {
            s.foreach(new IntSetAction(){
              public void act(              int x){
                keys[p]=system.getInstanceKey(x);
                rec(pi + 1);
              }
            }
);
          }
 else {
            if (!site.isDispatch() || p != 0) {
              keys[p]=null;
              rec(pi + 1);
            }
          }
        }
      }
    }
  }
.rec(0);
}",0.8460606060606061
99756,"protected void visitInvokeInternal(final SSAAbstractInvokeInstruction instruction,InvariantComputer invs){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + instruction);
  }
  PointerKey uniqueCatch=null;
  if (hasUniqueCatchBlock(instruction,ir)) {
    uniqueCatch=getBuilder().getUniqueCatchKey(instruction,ir,node);
  }
  InstanceKey[][] invariantParameters=invs.computeInvariantParameters(instruction);
  if (instruction.getCallSite().isStatic()) {
    for (    CGNode n : getBuilder().getTargetsForCall(node,instruction.getCallSite(),invariantParameters)) {
      getBuilder().processResolvedCall(node,instruction,n,invariantParameters,uniqueCatch);
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + n);
      }
      processClassInitializer(n.getMethod().getDeclaringClass());
    }
  }
 else {
    IntSet params=getBuilder().getContextSelector().getRelevantParameters(node,instruction.getCallSite());
    if (!params.contains(0)) {
      params=IntSetUtil.makeMutableCopy(params);
      ((MutableIntSet)params).add(0);
    }
    final int vns[]=new int[params.size()];
    params.foreach(new IntSetAction(){
      private int i=0;
      public void act(      int x){
        vns[i++]=instruction.getUse(x);
      }
    }
);
    if (contentsAreInvariant(symbolTable,du,vns)) {
      for (      CGNode n : getBuilder().getTargetsForCall(node,instruction.getCallSite(),invariantParameters)) {
        getBuilder().processResolvedCall(node,instruction,n,invariantParameters,uniqueCatch);
        processClassInitializer(n.getMethod().getDeclaringClass());
      }
    }
 else {
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + instruction + ""String_Node_Str""+ params);
      }
      final List<PointerKey> pks=new ArrayList<PointerKey>(params.size());
      params.foreach(new IntSetAction(){
        public void act(        int x){
          if (!contentsAreInvariant(symbolTable,du,instruction.getUse(x))) {
            pks.add(getBuilder().getPointerKeyForLocal(node,instruction.getUse(x)));
          }
        }
      }
);
      DispatchOperator dispatchOperator=getBuilder().new DispatchOperator(instruction,node,invariantParameters,uniqueCatch,params);
      system.newSideEffect(dispatchOperator,pks.toArray(new PointerKey[pks.size()]));
    }
  }
}","protected void visitInvokeInternal(final SSAAbstractInvokeInstruction instruction,InvariantComputer invs){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + instruction);
  }
  PointerKey uniqueCatch=null;
  if (hasUniqueCatchBlock(instruction,ir)) {
    uniqueCatch=getBuilder().getUniqueCatchKey(instruction,ir,node);
  }
  InstanceKey[][] invariantParameters=invs.computeInvariantParameters(instruction);
  if (instruction.getCallSite().isStatic()) {
    for (    CGNode n : getBuilder().getTargetsForCall(node,instruction,invariantParameters)) {
      getBuilder().processResolvedCall(node,instruction,n,invariantParameters,uniqueCatch);
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + n);
      }
      processClassInitializer(n.getMethod().getDeclaringClass());
    }
  }
 else {
    IntSet params=getBuilder().getContextSelector().getRelevantParameters(node,instruction.getCallSite());
    if (!params.contains(0)) {
      params=IntSetUtil.makeMutableCopy(params);
      ((MutableIntSet)params).add(0);
    }
    final int vns[]=new int[params.size()];
    params.foreach(new IntSetAction(){
      private int i=0;
      public void act(      int x){
        vns[i++]=instruction.getUse(x);
      }
    }
);
    if (contentsAreInvariant(symbolTable,du,vns)) {
      for (      CGNode n : getBuilder().getTargetsForCall(node,instruction,invariantParameters)) {
        getBuilder().processResolvedCall(node,instruction,n,invariantParameters,uniqueCatch);
        processClassInitializer(n.getMethod().getDeclaringClass());
      }
    }
 else {
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + instruction + ""String_Node_Str""+ params);
      }
      final List<PointerKey> pks=new ArrayList<PointerKey>(params.size());
      params.foreach(new IntSetAction(){
        public void act(        int x){
          if (!contentsAreInvariant(symbolTable,du,instruction.getUse(x))) {
            pks.add(getBuilder().getPointerKeyForLocal(node,instruction.getUse(x)));
          }
        }
      }
);
      DispatchOperator dispatchOperator=getBuilder().new DispatchOperator(instruction,node,invariantParameters,uniqueCatch,params);
      system.newSideEffect(dispatchOperator,pks.toArray(new PointerKey[pks.size()]));
    }
  }
}",0.9938811188811189
99757,"protected Set<CGNode> getTargetsForCall(final CGNode caller,final CallSiteReference site,InstanceKey[][] invs){
  IntSet params=contextSelector.getRelevantParameters(caller,site);
  if (!site.isStatic() && !params.contains(0)) {
    params=IntSetUtil.makeMutableCopy(params);
    ((MutableIntSet)params).add(0);
  }
  final Set<CGNode> targets=HashSetFactory.make();
  VoidFunction<InstanceKey[]> f=new VoidFunction<InstanceKey[]>(){
    public void apply(    InstanceKey[] v){
      IClass recv=null;
      if (site.isDispatch()) {
        recv=v[0].getConcreteType();
      }
      CGNode target=getTargetForCall(caller,site,recv,v);
      if (target != null) {
        targets.add(target);
      }
    }
  }
;
  iterateCrossProduct(caller,site,params,invs,f);
  return targets;
}","protected Set<CGNode> getTargetsForCall(final CGNode caller,final SSAAbstractInvokeInstruction instruction,InstanceKey[][] invs){
  final CallSiteReference site=instruction.getCallSite();
  IntSet params=contextSelector.getRelevantParameters(caller,site);
  if (!site.isStatic() && !params.contains(0)) {
    params=IntSetUtil.makeMutableCopy(params);
    ((MutableIntSet)params).add(0);
  }
  final Set<CGNode> targets=HashSetFactory.make();
  VoidFunction<InstanceKey[]> f=new VoidFunction<InstanceKey[]>(){
    public void apply(    InstanceKey[] v){
      IClass recv=null;
      if (site.isDispatch()) {
        recv=v[0].getConcreteType();
      }
      CGNode target=getTargetForCall(caller,site,recv,v);
      if (target != null) {
        targets.add(target);
      }
    }
  }
;
  iterateCrossProduct(caller,instruction,params,invs,f);
  return targets;
}",0.918032786885246
99758,"private boolean isNamedVar(CAstNode n,String name){
  if (n.getKind() == CAstNode.VAR) {
    String nm=(String)n.getChild(0).getValue();
    return nm.equals(name);
  }
  return false;
}","private boolean isNamedVar(CAstNode n,Pattern namePattern){
  if (n.getKind() == CAstNode.VAR) {
    String nm=(String)n.getChild(0).getValue();
    return namePattern.matcher(nm).matches();
  }
  return false;
}",0.7135678391959799
99759,"@Override protected String[] getArgumentNames(CAstEntity f){
  if (super.getArgumentCount(f) >= v.getValue()) {
    return super.getArgumentNames(f);
  }
 else {
    String[] argNames=new String[v.getValue()];
    System.arraycopy(super.getArgumentNames(f),0,argNames,0,super.getArgumentCount(f));
    for (int i=super.getArgumentCount(f); i < argNames.length; i++) {
      argNames[i]=""String_Node_Str"" + (i + 1);
    }
    return argNames;
  }
}","@Override protected String[] getArgumentNames(CAstEntity f){
  if (super.getArgumentCount(f) >= v.getValue()) {
    return super.getArgumentNames(f);
  }
 else {
    String[] argNames=new String[v.getValue()];
    System.arraycopy(super.getArgumentNames(f),0,argNames,0,super.getArgumentCount(f));
    for (int i=super.getArgumentCount(f); i < argNames.length; i++) {
      argNames[i]=""String_Node_Str"" + i;
    }
    return argNames;
  }
}",0.990990990990991
99760,"@Override public IR makeIR(final IMethod method,Context context,SSAOptions options){
  if (method instanceof Retranslatable) {
    @SuppressWarnings(""String_Node_Str"") final Value<Integer> v=(Value<Integer>)context.get(ArgumentCountContext.ARGUMENT_COUNT);
    final Retranslatable m=(Retranslatable)method;
    if (v != null) {
      final JavaScriptLoader myloader=(JavaScriptLoader)method.getDeclaringClass().getClassLoader();
class FixedArgumentsRewriter extends CAstBasicRewriter {
        private final CAstEntity e=m.getEntity();
        public FixedArgumentsRewriter(        CAst Ast){
          super(Ast,false);
        }
        private boolean isNamedVar(        CAstNode n,        String name){
          if (n.getKind() == CAstNode.VAR) {
            String nm=(String)n.getChild(0).getValue();
            return nm.equals(name);
          }
          return false;
        }
        private Object getIndexFromArgumentRef(        CAstNode n){
          if (n.getKind() == CAstNode.OBJECT_REF || n.getKind() == CAstNode.ARRAY_REF) {
            if (isNamedVar(n.getChild(0),""String_Node_Str"")) {
              return n.getChild(1).getValue();
            }
          }
          return null;
        }
        private Object getIndexFromBaseVar(        CAstNode n){
          if (n.getKind() == CAstNode.BLOCK_EXPR) {
            if (n.getChildCount() == 2) {
              CAstNode c1=n.getChild(0);
              if (c1.getKind() == CAstNode.ASSIGN) {
                if (isNamedVar(c1.getChild(0),""String_Node_Str"")) {
                  if (isNamedVar(c1.getChild(1),""String_Node_Str"")) {
                    CAstNode c2=n.getChild(1);
                    if (c2.getKind() == CAstNode.OBJECT_REF || c2.getKind() == CAstNode.ARRAY_REF) {
                      if (isNamedVar(c2.getChild(0),""String_Node_Str"")) {
                        return c2.getChild(1).getValue();
                      }
                    }
                  }
                }
              }
            }
          }
          return null;
        }
        private Object getStaticArgumentIndex(        CAstNode n){
          Object x=getIndexFromArgumentRef(n);
          if (x != null) {
            return x;
          }
 else {
            return getIndexFromBaseVar(n);
          }
        }
        private CAstNode handleArgumentRef(        CAstNode n){
          Object x=getStaticArgumentIndex(n);
          if (x != null) {
            if (x instanceof Number && ((Number)x).intValue() < v.getValue() - 2) {
              int arg=((Number)x).intValue() + 3;
              if (arg < e.getArgumentCount()) {
                return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(e.getArgumentNames()[arg]));
              }
 else {
                return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str"" + arg));
              }
            }
 else             if (x instanceof String && ""String_Node_Str"".equals(x)) {
              return Ast.makeConstant(v.getValue());
            }
          }
          return null;
        }
        @Override protected CAstNode copyNodes(        CAstNode root,        CAstControlFlowMap cfg,        NonCopyingContext context,        Map<Pair<CAstNode,NoKey>,CAstNode> nodeMap){
          CAstNode result=null;
          if (root.getKind() == CAstNode.ARRAY_REF || root.getKind() == CAstNode.OBJECT_REF || root.getKind() == CAstNode.BLOCK_EXPR) {
            result=handleArgumentRef(root);
          }
 else           if (root.getKind() == CAstNode.CONSTANT) {
            result=Ast.makeConstant(root.getValue());
          }
 else           if (root.getKind() == CAstNode.OPERATOR) {
            result=root;
          }
          if (result == null) {
            CAstNode children[]=new CAstNode[root.getChildCount()];
            for (int i=0; i < children.length; i++) {
              children[i]=copyNodes(root.getChild(i),cfg,context,nodeMap);
            }
            for (            Object label : cfg.getTargetLabels(root)) {
              if (label instanceof CAstNode) {
                copyNodes((CAstNode)label,cfg,context,nodeMap);
              }
            }
            CAstNode copy=Ast.makeNode(root.getKind(),children);
            result=copy;
          }
          nodeMap.put(Pair.make(root,context.key()),result);
          return result;
        }
      }
      final FixedArgumentsRewriter args=new FixedArgumentsRewriter(new CAstImpl());
      final JSConstantFoldingRewriter fold=new JSConstantFoldingRewriter(new CAstImpl());
class ArgumentativeTranslator extends JSAstTranslator {
        public ArgumentativeTranslator(        JavaScriptLoader loader){
          super(loader);
        }
        private CAstEntity codeBodyEntity;
        private IMethod specializedCode;
        @Override protected int getArgumentCount(        CAstEntity f){
          return Math.max(super.getArgumentCount(f),v.getValue());
        }
        @Override protected String[] getArgumentNames(        CAstEntity f){
          if (super.getArgumentCount(f) >= v.getValue()) {
            return super.getArgumentNames(f);
          }
 else {
            String[] argNames=new String[v.getValue()];
            System.arraycopy(super.getArgumentNames(f),0,argNames,0,super.getArgumentCount(f));
            for (int i=super.getArgumentCount(f); i < argNames.length; i++) {
              argNames[i]=""String_Node_Str"" + (i + 1);
            }
            return argNames;
          }
        }
        @Override protected String composeEntityName(        WalkContext parent,        CAstEntity f){
          if (f == codeBodyEntity) {
            return super.composeEntityName(parent,f) + ""String_Node_Str"" + v.getValue().intValue();
          }
 else {
            return super.composeEntityName(parent,f);
          }
        }
        @Override protected void defineFunction(        CAstEntity N,        WalkContext definingContext,        AbstractCFG cfg,        SymbolTable symtab,        boolean hasCatchBlock,        TypeReference[][] caughtTypes,        boolean hasMonitorOp,        AstLexicalInformation LI,        DebuggingInformation debugInfo){
          if (N == codeBodyEntity) {
            specializedCode=myloader.makeCodeBodyCode(cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo,method.getDeclaringClass());
          }
 else {
            super.defineFunction(N,definingContext,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
          }
        }
        @Override public void translate(        CAstEntity N,        WalkContext context){
          if (N == m.getEntity()) {
            codeBodyEntity=fold.rewrite(args.rewrite(N));
            super.translate(codeBodyEntity,context);
          }
 else {
            super.translate(N,context);
          }
        }
      }
      ArgumentativeTranslator a=new ArgumentativeTranslator(myloader);
      m.retranslate(a);
      return super.makeIR(a.specializedCode,context,options);
    }
  }
  return super.makeIR(method,context,options);
}","@Override public IR makeIR(final IMethod method,Context context,SSAOptions options){
  if (method instanceof Retranslatable) {
    @SuppressWarnings(""String_Node_Str"") final Value<Integer> v=(Value<Integer>)context.get(ArgumentCountContext.ARGUMENT_COUNT);
    final Retranslatable m=(Retranslatable)method;
    if (v != null) {
      final JavaScriptLoader myloader=(JavaScriptLoader)method.getDeclaringClass().getClassLoader();
class FixedArgumentsRewriter extends CAstBasicRewriter {
        private final CAstEntity e=m.getEntity();
        public FixedArgumentsRewriter(        CAst Ast){
          super(Ast,false);
        }
        private boolean isNamedVar(        CAstNode n,        String name){
          if (n.getKind() == CAstNode.VAR) {
            String nm=(String)n.getChild(0).getValue();
            return nm.equals(name);
          }
          return false;
        }
        private boolean isNamedVar(        CAstNode n,        Pattern namePattern){
          if (n.getKind() == CAstNode.VAR) {
            String nm=(String)n.getChild(0).getValue();
            return namePattern.matcher(nm).matches();
          }
          return false;
        }
        private Object getIndexFromArgumentRef(        CAstNode n){
          if (n.getKind() == CAstNode.OBJECT_REF || n.getKind() == CAstNode.ARRAY_REF) {
            if (isNamedVar(n.getChild(0),""String_Node_Str"")) {
              return n.getChild(1).getValue();
            }
          }
          return null;
        }
        private Object getIndexFromBaseVar(        CAstNode n){
          if (n.getKind() == CAstNode.BLOCK_EXPR) {
            if (n.getChildCount() == 2) {
              CAstNode c1=n.getChild(0);
              if (c1.getKind() == CAstNode.ASSIGN) {
                if (isNamedVar(c1.getChild(0),baseNameRegex)) {
                  if (isNamedVar(c1.getChild(1),""String_Node_Str"")) {
                    CAstNode c2=n.getChild(1);
                    if (c2.getKind() == CAstNode.OBJECT_REF || c2.getKind() == CAstNode.ARRAY_REF) {
                      if (isNamedVar(c2.getChild(0),baseNameRegex)) {
                        return c2.getChild(1).getValue();
                      }
                    }
                  }
                }
              }
            }
          }
          return null;
        }
        private Object getStaticArgumentIndex(        CAstNode n){
          Object x=getIndexFromArgumentRef(n);
          if (x != null) {
            return x;
          }
 else {
            return getIndexFromBaseVar(n);
          }
        }
        private CAstNode handleArgumentRef(        CAstNode n){
          Object x=getStaticArgumentIndex(n);
          if (x != null) {
            if (x instanceof Number && ((Number)x).intValue() < v.getValue() - 2) {
              int arg=((Number)x).intValue() + 2;
              if (arg < e.getArgumentCount()) {
                return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(e.getArgumentNames()[arg]));
              }
 else {
                return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str"" + arg));
              }
            }
 else             if (x instanceof String && ""String_Node_Str"".equals(x)) {
              return Ast.makeConstant(v.getValue());
            }
          }
          return null;
        }
        @Override protected CAstNode copyNodes(        CAstNode root,        CAstControlFlowMap cfg,        NonCopyingContext context,        Map<Pair<CAstNode,NoKey>,CAstNode> nodeMap){
          CAstNode result=null;
          if (root.getKind() == CAstNode.ARRAY_REF || root.getKind() == CAstNode.OBJECT_REF || root.getKind() == CAstNode.BLOCK_EXPR) {
            result=handleArgumentRef(root);
          }
 else           if (root.getKind() == CAstNode.CONSTANT) {
            result=Ast.makeConstant(root.getValue());
          }
 else           if (root.getKind() == CAstNode.OPERATOR) {
            result=root;
          }
          if (result == null) {
            CAstNode children[]=new CAstNode[root.getChildCount()];
            for (int i=0; i < children.length; i++) {
              children[i]=copyNodes(root.getChild(i),cfg,context,nodeMap);
            }
            for (            Object label : cfg.getTargetLabels(root)) {
              if (label instanceof CAstNode) {
                copyNodes((CAstNode)label,cfg,context,nodeMap);
              }
            }
            CAstNode copy=Ast.makeNode(root.getKind(),children);
            result=copy;
          }
          nodeMap.put(Pair.make(root,context.key()),result);
          return result;
        }
      }
      final FixedArgumentsRewriter args=new FixedArgumentsRewriter(new CAstImpl());
      final JSConstantFoldingRewriter fold=new JSConstantFoldingRewriter(new CAstImpl());
class ArgumentativeTranslator extends JSAstTranslator {
        public ArgumentativeTranslator(        JavaScriptLoader loader){
          super(loader);
        }
        private CAstEntity codeBodyEntity;
        private IMethod specializedCode;
        @Override protected int getArgumentCount(        CAstEntity f){
          return Math.max(super.getArgumentCount(f),v.getValue());
        }
        @Override protected String[] getArgumentNames(        CAstEntity f){
          if (super.getArgumentCount(f) >= v.getValue()) {
            return super.getArgumentNames(f);
          }
 else {
            String[] argNames=new String[v.getValue()];
            System.arraycopy(super.getArgumentNames(f),0,argNames,0,super.getArgumentCount(f));
            for (int i=super.getArgumentCount(f); i < argNames.length; i++) {
              argNames[i]=""String_Node_Str"" + i;
            }
            return argNames;
          }
        }
        @Override protected String composeEntityName(        WalkContext parent,        CAstEntity f){
          if (f == codeBodyEntity) {
            return super.composeEntityName(parent,f) + ""String_Node_Str"" + v.getValue().intValue();
          }
 else {
            return super.composeEntityName(parent,f);
          }
        }
        @Override protected void defineFunction(        CAstEntity N,        WalkContext definingContext,        AbstractCFG cfg,        SymbolTable symtab,        boolean hasCatchBlock,        TypeReference[][] caughtTypes,        boolean hasMonitorOp,        AstLexicalInformation LI,        DebuggingInformation debugInfo){
          if (N == codeBodyEntity) {
            specializedCode=myloader.makeCodeBodyCode(cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo,method.getDeclaringClass());
          }
 else {
            super.defineFunction(N,definingContext,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
          }
        }
        @Override public void translate(        CAstEntity N,        WalkContext context){
          if (N == m.getEntity()) {
            codeBodyEntity=fold.rewrite(args.rewrite(N));
            super.translate(codeBodyEntity,context);
          }
 else {
            super.translate(N,context);
          }
        }
      }
      ArgumentativeTranslator a=new ArgumentativeTranslator(myloader);
      m.retranslate(a);
      return super.makeIR(a.specializedCode,context,options);
    }
  }
  return super.makeIR(method,context,options);
}",0.9751522362987332
99761,"private CAstNode handleArgumentRef(CAstNode n){
  Object x=getStaticArgumentIndex(n);
  if (x != null) {
    if (x instanceof Number && ((Number)x).intValue() < v.getValue() - 2) {
      int arg=((Number)x).intValue() + 3;
      if (arg < e.getArgumentCount()) {
        return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(e.getArgumentNames()[arg]));
      }
 else {
        return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str"" + arg));
      }
    }
 else     if (x instanceof String && ""String_Node_Str"".equals(x)) {
      return Ast.makeConstant(v.getValue());
    }
  }
  return null;
}","private CAstNode handleArgumentRef(CAstNode n){
  Object x=getStaticArgumentIndex(n);
  if (x != null) {
    if (x instanceof Number && ((Number)x).intValue() < v.getValue() - 2) {
      int arg=((Number)x).intValue() + 2;
      if (arg < e.getArgumentCount()) {
        return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(e.getArgumentNames()[arg]));
      }
 else {
        return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str"" + arg));
      }
    }
 else     if (x instanceof String && ""String_Node_Str"".equals(x)) {
      return Ast.makeConstant(v.getValue());
    }
  }
  return null;
}",0.9983443708609272
99762,"private Object getIndexFromBaseVar(CAstNode n){
  if (n.getKind() == CAstNode.BLOCK_EXPR) {
    if (n.getChildCount() == 2) {
      CAstNode c1=n.getChild(0);
      if (c1.getKind() == CAstNode.ASSIGN) {
        if (isNamedVar(c1.getChild(0),""String_Node_Str"")) {
          if (isNamedVar(c1.getChild(1),""String_Node_Str"")) {
            CAstNode c2=n.getChild(1);
            if (c2.getKind() == CAstNode.OBJECT_REF || c2.getKind() == CAstNode.ARRAY_REF) {
              if (isNamedVar(c2.getChild(0),""String_Node_Str"")) {
                return c2.getChild(1).getValue();
              }
            }
          }
        }
      }
    }
  }
  return null;
}","private Object getIndexFromBaseVar(CAstNode n){
  if (n.getKind() == CAstNode.BLOCK_EXPR) {
    if (n.getChildCount() == 2) {
      CAstNode c1=n.getChild(0);
      if (c1.getKind() == CAstNode.ASSIGN) {
        if (isNamedVar(c1.getChild(0),baseNameRegex)) {
          if (isNamedVar(c1.getChild(1),""String_Node_Str"")) {
            CAstNode c2=n.getChild(1);
            if (c2.getKind() == CAstNode.OBJECT_REF || c2.getKind() == CAstNode.ARRAY_REF) {
              if (isNamedVar(c2.getChild(0),baseNameRegex)) {
                return c2.getChild(1).getValue();
              }
            }
          }
        }
      }
    }
  }
  return null;
}",0.9542682926829268
99763,"public IField getField(Atom name){
  if (declaredFields.containsKey(name)) {
    return declaredFields.get(name);
  }
 else   if (getSuperclass() != null) {
    return getSuperclass().getField(name);
  }
 else {
    return null;
  }
}","public IField getField(Atom name,TypeName type){
  return getField(name);
}",0.3948220064724919
99764,"public IField getField(Atom name){
  return loader.lookupClass(superReference.getName()).getField(name);
}","public IField getField(Atom name,TypeName type){
  return loader.lookupClass(superReference.getName()).getField(name);
}",0.9380530973451328
99765,"/** 
 * @throws FileNotFoundException
 */
public static File getFileFromClassLoader(String fileName,ClassLoader loader) throws FileNotFoundException {
  if (loader == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URL url=loader.getResource(fileName);
  if (DEBUG_LEVEL > 0) {
    System.err.println((""String_Node_Str"" + url + ""String_Node_Str""+ fileName));
  }
  if (url == null) {
    File f=new File(fileName);
    if (f.exists()) {
      return f;
    }
    throw new FileNotFoundException(fileName);
  }
 else {
    return new File(filePathFromURL(url));
  }
}","/** 
 * @throws FileNotFoundException
 */
public static File getFileFromClassLoader(String fileName,ClassLoader loader) throws FileNotFoundException {
  if (loader == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URL url=null;
  try {
    url=loader.getResource(fileName);
  }
 catch (  Exception e) {
  }
  if (DEBUG_LEVEL > 0) {
    System.err.println((""String_Node_Str"" + url + ""String_Node_Str""+ fileName));
  }
  if (url == null) {
    File f=new File(fileName);
    if (f.exists()) {
      return f;
    }
    throw new FileNotFoundException(fileName);
  }
 else {
    return new File(filePathFromURL(url));
  }
}",0.96113074204947
99766,"public void translate(final CAstEntity N,final WalkContext context){
  walkEntities(N,context);
}","public void translate(final CAstEntity N,final WalkContext context){
  final ExposedNamesCollector exposedNamesCollector=new ExposedNamesCollector();
  exposedNamesCollector.run(N);
  entity2ExposedNames=exposedNamesCollector.getEntity2ExposedNames();
  walkEntities(N,context);
}",0.5145888594164456
99767,"@Before public void setUp(){
  com.ibm.wala.cast.js.ipa.callgraph.Util.setTranslatorFactory(new CAstRhinoTranslatorFactory());
}","@Before public void setUp(){
  JSCallGraphUtil.setTranslatorFactory(new CAstRhinoTranslatorFactory());
}",0.8620689655172413
99768,"@Before public void setUp(){
  com.ibm.wala.cast.js.ipa.callgraph.Util.setTranslatorFactory(new CAstRhinoTranslatorFactory());
}","@Before public void setUp(){
  JSCallGraphUtil.setTranslatorFactory(new CAstRhinoTranslatorFactory());
}",0.8620689655172413
99769,"@Test public void testTranslateToCAstCrash3() throws IllegalArgumentException, IOException, CancelException {
  Util.makeScriptCG(""String_Node_Str"",""String_Node_Str"");
}","@Test public void testTranslateToCAstCrash3() throws IllegalArgumentException, IOException, CancelException {
  JSCallGraphBuilderUtil.makeScriptCG(""String_Node_Str"",""String_Node_Str"");
}",0.949438202247191
99770,"@Test public void testArgs() throws IOException, IllegalArgumentException, CancelException, ClassHierarchyException {
  JavaScriptLoaderFactory loaders=Util.makeLoaders();
  AnalysisScope scope=Util.makeScriptScope(""String_Node_Str"",""String_Node_Str"",loaders);
  IClassHierarchy cha=Util.makeHierarchy(scope,loaders);
  com.ibm.wala.cast.js.util.Util.checkForFrontEndErrors(cha);
  Iterable<Entrypoint> roots=Util.makeScriptRoots(cha);
  JSAnalysisOptions options=Util.makeOptions(scope,cha,roots);
  AnalysisCache cache=Util.makeCache(new ArgumentSpecialization.ArgumentCountIRFactory(options.getSSAOptions()));
  JSCFABuilder builder=new JSZeroOrOneXCFABuilder(cha,options,cache,null,null,ZeroXInstanceKeys.ALLOCATIONS,false);
  builder.setContextSelector(new ArgumentSpecialization.ArgumentCountContextSelector(builder.getContextSelector()));
  builder.setContextInterpreter(new ArgumentSpecialization.ArgumentSpecializationContextIntepreter(options,cache));
  CallGraph CG=builder.makeCallGraph(options);
  Util.AVOID_DUMP=false;
  Util.dumpCG(builder.getPointerAnalysis(),CG);
  verifyGraphAssertions(CG,assertionsForArgs);
}","@Test public void testArgs() throws IOException, IllegalArgumentException, CancelException, ClassHierarchyException {
  JavaScriptLoaderFactory loaders=JSCallGraphBuilderUtil.makeLoaders();
  AnalysisScope scope=JSCallGraphBuilderUtil.makeScriptScope(""String_Node_Str"",""String_Node_Str"",loaders);
  IClassHierarchy cha=JSCallGraphBuilderUtil.makeHierarchy(scope,loaders);
  com.ibm.wala.cast.js.util.Util.checkForFrontEndErrors(cha);
  Iterable<Entrypoint> roots=JSCallGraphBuilderUtil.makeScriptRoots(cha);
  JSAnalysisOptions options=JSCallGraphBuilderUtil.makeOptions(scope,cha,roots);
  AnalysisCache cache=JSCallGraphBuilderUtil.makeCache(new ArgumentSpecialization.ArgumentCountIRFactory(options.getSSAOptions()));
  JSCFABuilder builder=new JSZeroOrOneXCFABuilder(cha,options,cache,null,null,ZeroXInstanceKeys.ALLOCATIONS,false);
  builder.setContextSelector(new ArgumentSpecialization.ArgumentCountContextSelector(builder.getContextSelector()));
  builder.setContextInterpreter(new ArgumentSpecialization.ArgumentSpecializationContextIntepreter(options,cache));
  CallGraph CG=builder.makeCallGraph(options);
  CAstCallGraphUtil.AVOID_DUMP=false;
  CAstCallGraphUtil.dumpCG(builder.getPointerAnalysis(),CG);
  verifyGraphAssertions(CG,assertionsForArgs);
}",0.9440267335004175
99771,"@Test public void testEx1() throws IOException, IllegalArgumentException, CancelException {
  URL url=getClass().getClassLoader().getResource(""String_Node_Str"");
  JSCFABuilder builder=Util.makeHTMLCGBuilder(url);
  CallGraph CG=builder.makeCallGraph(builder.getOptions());
  Util.dumpCG(builder.getPointerAnalysis(),CG);
}","@Test public void testEx1() throws IOException, IllegalArgumentException, CancelException {
  URL url=getClass().getClassLoader().getResource(""String_Node_Str"");
  JSCFABuilder builder=JSCallGraphBuilderUtil.makeHTMLCGBuilder(url);
  CallGraph CG=builder.makeCallGraph(builder.getOptions());
  CAstCallGraphUtil.dumpCG(builder.getPointerAnalysis(),CG);
}",0.9542097488921714
99772,"@Test public void testSwineFlu() throws IOException, IllegalArgumentException, CancelException {
  URL url=new URL(""String_Node_Str"");
  CallGraph CG=JSCallGraphBuilderUtil.makeHTMLCG(url);
  verifyGraphAssertions(CG,assertionsForSwineFlu);
}","@Ignore(""String_Node_Str"") @Test public void testSwineFlu() throws IOException, IllegalArgumentException, CancelException {
  URL url=new URL(""String_Node_Str"");
  CallGraph CG=JSCallGraphBuilderUtil.makeHTMLCG(url);
  verifyGraphAssertions(CG,assertionsForSwineFlu);
}",0.9471624266144814
99773,"@Test public void testArgs() throws IOException, IllegalArgumentException, CancelException {
  CallGraph CG=Util.makeScriptCG(""String_Node_Str"",""String_Node_Str"");
  verifyGraphAssertions(CG,assertionsForArgs);
}","@Test public void testArgs() throws IOException, IllegalArgumentException, CancelException {
  CallGraph CG=JSCallGraphBuilderUtil.makeScriptCG(""String_Node_Str"",""String_Node_Str"");
  verifyGraphAssertions(CG,assertionsForArgs);
}",0.9592760180995475
99774,"@Test public void testCrawlPage17() throws IOException, IllegalArgumentException, CancelException {
}","@Test public void testCrawlPage17() throws IOException, IllegalArgumentException, CancelException {
  URL url=getClass().getClassLoader().getResource(""String_Node_Str"");
  CallGraph CG=JSCallGraphBuilderUtil.makeHTMLCG(url);
  verifyGraphAssertions(CG,assertionsForPage17);
}",0.5372340425531915
99775,"@Test public void testCrawlPage12() throws IOException, IllegalArgumentException, CancelException {
}","@Test public void testCrawlPage12() throws IOException, IllegalArgumentException, CancelException {
  URL url=getClass().getClassLoader().getResource(""String_Node_Str"");
  CallGraph CG=JSCallGraphBuilderUtil.makeHTMLCG(url);
  verifyGraphAssertions(CG,assertionsForPage12);
}",0.5372340425531915
99776,"private boolean forInOnFirstArg(IMethod method){
  MethodReference mref=method.getReference();
  if (method.getNumberOfParameters() < index)   return false;
  Boolean b=forInOnFirstArg_cache.get(mref);
  if (b != null)   return b;
  DefUse du=getDefUse(method);
  for (  SSAInstruction use : Iterator2Iterable.make(du.getUses(3))) {
    if (use instanceof EachElementGetInstruction) {
      forInOnFirstArg_cache.put(mref,true);
      return true;
    }
  }
  forInOnFirstArg_cache.put(mref,false);
  return false;
}","private boolean forInOnFirstArg(IMethod method){
  MethodReference mref=method.getReference();
  if (method.getNumberOfParameters() < index)   return false;
  Boolean b=forInOnFirstArg_cache.get(mref);
  if (b != null)   return b;
  DefUse du=getDefUse(method);
  for (  SSAInstruction use : Iterator2Iterable.make(du.getUses(index + 1))) {
    if (use instanceof EachElementGetInstruction) {
      forInOnFirstArg_cache.put(mref,true);
      return true;
    }
  }
  forInOnFirstArg_cache.put(mref,false);
  return false;
}",0.9903846153846154
99777,"private Frequency usesFirstArgAsPropertyName(IMethod method){
  MethodReference mref=method.getReference();
  if (method.getNumberOfParameters() < index)   return Frequency.NEVER;
  Frequency f=usesFirstArgAsPropertyName_cache.get(mref);
  if (f != null)   return f;
  boolean usedAsPropertyName=false, usedAsSomethingElse=false;
  DefUse du=getDefUse(method);
  for (  SSAInstruction use : Iterator2Iterable.make(du.getUses(3))) {
    if (use instanceof ReflectiveMemberAccess) {
      ReflectiveMemberAccess rma=(ReflectiveMemberAccess)use;
      if (rma.getMemberRef() == 3) {
        usedAsPropertyName=true;
        continue;
      }
    }
 else     if (use instanceof AstIsDefinedInstruction) {
      AstIsDefinedInstruction aidi=(AstIsDefinedInstruction)use;
      if (aidi.getNumberOfUses() > 1 && aidi.getUse(1) == 3) {
        usedAsPropertyName=true;
        continue;
      }
    }
    usedAsSomethingElse=true;
  }
  if (!usedAsPropertyName)   f=Frequency.NEVER;
 else   if (usedAsSomethingElse)   f=Frequency.SOMETIMES;
 else   f=Frequency.ALWAYS;
  usesFirstArgAsPropertyName_cache.put(mref,f);
  return f;
}","private Frequency usesFirstArgAsPropertyName(IMethod method){
  MethodReference mref=method.getReference();
  if (method.getNumberOfParameters() < index)   return Frequency.NEVER;
  Frequency f=usesFirstArgAsPropertyName_cache.get(mref);
  if (f != null)   return f;
  boolean usedAsPropertyName=false, usedAsSomethingElse=false;
  DefUse du=getDefUse(method);
  for (  SSAInstruction use : Iterator2Iterable.make(du.getUses(index + 1))) {
    if (use instanceof ReflectiveMemberAccess) {
      ReflectiveMemberAccess rma=(ReflectiveMemberAccess)use;
      if (rma.getMemberRef() == index + 1) {
        usedAsPropertyName=true;
        continue;
      }
    }
 else     if (use instanceof AstIsDefinedInstruction) {
      AstIsDefinedInstruction aidi=(AstIsDefinedInstruction)use;
      if (aidi.getNumberOfUses() > 1 && aidi.getUse(1) == index + 1) {
        usedAsPropertyName=true;
        continue;
      }
    }
    usedAsSomethingElse=true;
  }
  if (!usedAsPropertyName)   f=Frequency.NEVER;
 else   if (usedAsSomethingElse)   f=Frequency.SOMETIMES;
 else   f=Frequency.ALWAYS;
  usesFirstArgAsPropertyName_cache.put(mref,f);
  return f;
}",0.986784140969163
99778,"private Set<CGNode> getLexicalDefiners(final CGNode opNode,final Pair<String,String> definer){
  if (definer == null) {
    return Collections.singleton(getBuilder().getCallGraph().getFakeRootNode());
  }
 else {
    final Set<CGNode> result=HashSetFactory.make();
    PointerKey F=getBuilder().getPointerKeyForLocal(opNode,1);
    IR ir=getBuilder().getCFAContextInterpreter().getIR(opNode);
    SymbolTable symtab=ir.getSymbolTable();
    DefUse du=getAnalysisCache().getSSACache().findOrCreateDU(ir,opNode.getContext());
    if (contentsAreInvariant(symtab,du,1)) {
      system.recordImplicitPointsToSet(F);
      final InstanceKey[] functionKeys=getInvariantContents(symtab,du,opNode,1);
      for (int f=0; f < functionKeys.length; f++) {
        system.findOrCreateIndexForInstanceKey(functionKeys[f]);
        ScopeMappingInstanceKey K=(ScopeMappingInstanceKey)functionKeys[f];
        Iterator<CGNode> x=K.getFunargNodes(definer);
        while (x.hasNext()) {
          result.add(x.next());
        }
      }
    }
 else {
      PointsToSetVariable FV=system.findOrCreatePointsToSet(F);
      if (FV.getValue() != null) {
        FV.getValue().foreach(new IntSetAction(){
          public void act(          int ptr){
            InstanceKey iKey=system.getInstanceKey(ptr);
            if (iKey instanceof ScopeMappingInstanceKey) {
              ScopeMappingInstanceKey K=(ScopeMappingInstanceKey)iKey;
              Iterator<CGNode> x=K.getFunargNodes(definer);
              while (x.hasNext()) {
                result.add(x.next());
              }
            }
 else {
              Assertions.UNREACHABLE(""String_Node_Str"" + iKey);
            }
          }
        }
);
      }
    }
    return result;
  }
}","private Set<CGNode> getLexicalDefiners(final CGNode opNode,final Pair<String,String> definer){
}",0.1052054794520548
99779,"public JSZeroOrOneXCFABuilder(IClassHierarchy cha,JSAnalysisOptions options,AnalysisCache cache,ContextSelector appContextSelector,SSAContextInterpreter appContextInterpreter,int instancePolicy,boolean doOneCFA){
  super(cha,options,cache);
  SSAContextInterpreter contextInterpreter=makeDefaultContextInterpreters(appContextInterpreter,options,cha);
  if (options.handleCallApply()) {
    contextInterpreter=new DelegatingSSAContextInterpreter(new JavaScriptFunctionApplyContextInterpreter(options,cache),contextInterpreter);
  }
  setContextInterpreter(contextInterpreter);
  MethodTargetSelector targetSelector=new JavaScriptConstructTargetSelector(cha,options.getMethodTargetSelector());
  if (options.handleCallApply()) {
    targetSelector=new JavaScriptFunctionDotCallTargetSelector(targetSelector);
  }
  if (options.useLoadFileTargetSelector()) {
    targetSelector=new LoadFileTargetSelector(targetSelector,this);
  }
  options.setSelector(targetSelector);
  ContextSelector def=new ContextInsensitiveSelector();
  ContextSelector contextSelector=appContextSelector == null ? def : new DelegatingContextSelector(appContextSelector,def);
  contextSelector=new ScopeMappingKeysContextSelector(contextSelector);
  contextSelector=new JavaScriptConstructorContextSelector(contextSelector);
  if (USE_OBJECT_SENSITIVITY) {
    contextSelector=new ObjectSensitivityContextSelector(contextSelector);
  }
  if (options.handleCallApply()) {
    contextSelector=new JavaScriptFunctionApplyContextSelector(contextSelector);
  }
  contextSelector=new LexicalScopingResolverContexts(this,contextSelector);
  if (doOneCFA) {
    contextSelector=new nCFAContextSelector(1,contextSelector);
  }
  setContextSelector(contextSelector);
  setInstanceKeys(new JavaScriptScopeMappingInstanceKeys(cha,this,new JavaScriptConstructorInstanceKeys(new ZeroXInstanceKeys(options,cha,contextInterpreter,instancePolicy))));
}","public JSZeroOrOneXCFABuilder(IClassHierarchy cha,JSAnalysisOptions options,AnalysisCache cache,ContextSelector appContextSelector,SSAContextInterpreter appContextInterpreter,int instancePolicy,boolean doOneCFA){
  super(cha,options,cache);
  SSAContextInterpreter contextInterpreter=makeDefaultContextInterpreters(appContextInterpreter,options,cha);
  if (options.handleCallApply()) {
    contextInterpreter=new DelegatingSSAContextInterpreter(new JavaScriptFunctionApplyContextInterpreter(options,cache),contextInterpreter);
  }
  setContextInterpreter(contextInterpreter);
  MethodTargetSelector targetSelector=new JavaScriptConstructTargetSelector(cha,options.getMethodTargetSelector());
  if (options.handleCallApply()) {
    targetSelector=new JavaScriptFunctionApplyTargetSelector(new JavaScriptFunctionDotCallTargetSelector(targetSelector));
  }
  if (options.useLoadFileTargetSelector()) {
    targetSelector=new LoadFileTargetSelector(targetSelector,this);
  }
  options.setSelector(targetSelector);
  ContextSelector def=new ContextInsensitiveSelector();
  ContextSelector contextSelector=appContextSelector == null ? def : new DelegatingContextSelector(appContextSelector,def);
  contextSelector=new ScopeMappingKeysContextSelector(contextSelector);
  contextSelector=new JavaScriptConstructorContextSelector(contextSelector);
  if (USE_OBJECT_SENSITIVITY) {
    contextSelector=new ObjectSensitivityContextSelector(contextSelector);
  }
  if (options.handleCallApply()) {
    contextSelector=new JavaScriptFunctionApplyContextSelector(contextSelector);
  }
  contextSelector=new LexicalScopingResolverContexts(this,contextSelector);
  if (doOneCFA) {
    contextSelector=new nCFAContextSelector(1,contextSelector);
  }
  setContextSelector(contextSelector);
  setInstanceKeys(new JavaScriptScopeMappingInstanceKeys(cha,this,new JavaScriptConstructorInstanceKeys(new ZeroXInstanceKeys(options,cha,contextInterpreter,instancePolicy))));
}",0.988845654993515
99780,"public Context getCalleeTarget(CGNode caller,CallSiteReference site,IMethod callee,InstanceKey[] receiver){
  IClass declaringClass=callee.getDeclaringClass();
  IMethod method=declaringClass.getMethod(AstMethodReference.fnSelector);
  Context baseCtxt=base.getCalleeTarget(caller,site,callee,receiver);
  if (method != null) {
    String s=method.getReference().getDeclaringClass().getName().toString();
    if (s.equals(""String_Node_Str"")) {
      boolean isNonNullArray=false;
      if (receiver.length >= 4) {
        InstanceKey argsList=receiver[3];
        if (argsList != null && argsList.getConcreteType().equals(caller.getClassHierarchy().lookupClass(JavaScriptTypes.Array))) {
          isNonNullArray=true;
        }
      }
      if (USE_ONE_LEVEL_CALLSTRING)       baseCtxt=new DelegatingContext(oneLevel.getCalleeTarget(caller,site,callee,receiver),baseCtxt);
      return new ApplyContext(baseCtxt,isNonNullArray);
    }
  }
  return baseCtxt;
}","public Context getCalleeTarget(CGNode caller,CallSiteReference site,IMethod callee,InstanceKey[] receiver){
  IClass declaringClass=callee.getDeclaringClass();
  IMethod method=declaringClass.getMethod(AstMethodReference.fnSelector);
  Context baseCtxt=base.getCalleeTarget(caller,site,callee,receiver);
  if (method != null) {
    String s=method.getReference().getDeclaringClass().getName().toString();
    if (s.equals(""String_Node_Str"")) {
      boolean isNonNullArray=false;
      if (receiver.length >= 4) {
        InstanceKey argsList=receiver[3];
        if (argsList != null && argsList.getConcreteType().equals(caller.getClassHierarchy().lookupClass(JavaScriptTypes.Array))) {
          isNonNullArray=true;
        }
      }
      if (USE_ONE_LEVEL)       baseCtxt=oneLevel.getCalleeTarget(caller,site,callee,receiver);
      return new ApplyContext(baseCtxt,isNonNullArray);
    }
  }
  return baseCtxt;
}",0.9079297498669504
99781,"@Override public IMethod getCalleeTarget(CGNode caller,CallSiteReference site,IClass receiver){
  IMethod method=receiver.getMethod(AstMethodReference.fnSelector);
  if (method != null) {
    String s=method.getReference().getDeclaringClass().getName().toString();
    if (s.equals(""String_Node_Str"")) {
      final MethodReference ref=genSyntheticMethodRef(receiver);
      JavaScriptSummary S=new JavaScriptSummary(ref,1);
      return new JavaScriptSummarizedFunction(ref,S,receiver);
    }
  }
  return base.getCalleeTarget(caller,site,receiver);
}","@Override public IMethod getCalleeTarget(CGNode caller,CallSiteReference site,IClass receiver){
  IMethod method=receiver.getMethod(AstMethodReference.fnSelector);
  if (method != null) {
    String s=method.getReference().getDeclaringClass().getName().toString();
    if (s.equals(""String_Node_Str"")) {
      if (applyMethod == null) {
        applyMethod=createApplyDummyMethod(receiver);
      }
      return applyMethod;
    }
  }
  return base.getCalleeTarget(caller,site,receiver);
}",0.6416906820365034
99782,"@SuppressWarnings(""String_Node_Str"") public static void dumpCG(PointerAnalysis PA,CallGraph CG){
  if (AVOID_DUMP)   return;
  for (Iterator x=CG.iterator(); x.hasNext(); ) {
    CGNode N=(CGNode)x.next();
    System.err.print(""String_Node_Str"" + getShortName(N) + ""String_Node_Str"");
    boolean fst=true;
    for (Iterator<? extends CGNode> ns=CG.getSuccNodes(N); ns.hasNext(); ) {
      if (fst)       fst=false;
 else       System.err.print(""String_Node_Str"");
      System.err.print(getShortName(ns.next()));
    }
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"" + N.getGraphNodeId());
    IR ir=N.getIR();
    if (ir != null) {
      System.err.println(ir);
    }
 else {
      System.err.println(""String_Node_Str"");
    }
  }
  System.err.println(""String_Node_Str"");
  for (Iterator x=PA.getPointerKeys().iterator(); x.hasNext(); ) {
    PointerKey n=(PointerKey)x.next();
    try {
      System.err.println((n + ""String_Node_Str"" + PA.getPointsToSet(n)));
    }
 catch (    Throwable e) {
      System.err.println((""String_Node_Str"" + n));
    }
  }
}","@SuppressWarnings(""String_Node_Str"") public static void dumpCG(PointerAnalysis PA,CallGraph CG){
  if (AVOID_DUMP)   return;
  for (Iterator x=CG.iterator(); x.hasNext(); ) {
    CGNode N=(CGNode)x.next();
    System.err.print(""String_Node_Str"" + getShortName(N) + ""String_Node_Str"");
    boolean fst=true;
    for (Iterator<? extends CGNode> ns=CG.getSuccNodes(N); ns.hasNext(); ) {
      if (fst)       fst=false;
 else       System.err.print(""String_Node_Str"");
      System.err.print(getShortName(ns.next()));
    }
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"" + N.getGraphNodeId() + ""String_Node_Str""+ N.getContext());
    IR ir=N.getIR();
    if (ir != null) {
      System.err.println(ir);
    }
 else {
      System.err.println(""String_Node_Str"");
    }
  }
  System.err.println(""String_Node_Str"");
  for (Iterator x=PA.getPointerKeys().iterator(); x.hasNext(); ) {
    PointerKey n=(PointerKey)x.next();
    try {
      System.err.println((n + ""String_Node_Str"" + PA.getPointsToSet(n)));
    }
 catch (    Throwable e) {
      System.err.println((""String_Node_Str"" + n));
    }
  }
}",0.9838274932614556
99783,"protected boolean useLexicalAccessesForExposedVars(){
  return false;
}","protected boolean useLexicalAccessesForExposedVars(){
  return NEW_LEXICAL;
}",0.8918918918918919
99784,"protected boolean useLocalValuesForLexicalVars(){
  return true;
}","protected boolean useLocalValuesForLexicalVars(){
  return !NEW_LEXICAL;
}",0.8857142857142857
99785,"/** 
 * generate instructions for a write of a global
 */
protected void doGlobalWrite(WalkContext context,String name,int rval){
  Symbol S=context.currentScope().lookup(name);
  if (treatGlobalsAsLexicallyScoped()) {
    if (useLocalValuesForLexicalVars()) {
      int vn=S.valueNumber();
      Access A=new Access(name,null,vn);
      addExposedName(context.top(),null,name,vn,true,context);
      addAccess(context,context.top(),A);
      context.cfg().addInstruction(new AssignInstruction(vn,rval));
      context.cfg().addInstruction(new AstLexicalWrite(A));
    }
 else {
      Access A=new Access(name,null,rval);
      context.cfg().addInstruction(new AstLexicalWrite(A));
    }
  }
 else {
    FieldReference global=makeGlobalRef(name);
    context.cfg().addInstruction(new AstGlobalWrite(global,rval));
  }
}","/** 
 * generate instructions for a write of a global
 */
protected void doGlobalWrite(WalkContext context,String name,int rval){
  Symbol S=context.currentScope().lookup(name);
  if (treatGlobalsAsLexicallyScoped()) {
    if (useLocalValuesForLexicalVars()) {
      int vn=S.valueNumber();
      Access A=new Access(name,null,vn);
      addExposedName(context.top(),null,name,vn,true,context);
      addAccess(context,context.top(),A);
      context.cfg().addInstruction(new AssignInstruction(vn,rval));
      context.cfg().addInstruction(new AstLexicalWrite(A));
    }
 else {
      Access A=new Access(name,null,rval);
      context.cfg().addInstruction(new AstLexicalWrite(A));
      addAccess(context,context.top(),A);
    }
  }
 else {
    FieldReference global=makeGlobalRef(name);
    context.cfg().addInstruction(new AstGlobalWrite(global,rval));
  }
}",0.975
99786,"/** 
 * Note that the caller is responsible for ensuring that name is defined in a lexical scope.
 */
protected void doLexicallyScopedWrite(WalkContext context,String name,int rval){
  Symbol S=context.currentScope().lookup(name);
  Scope definingScope=S.getDefiningScope();
  CAstEntity E=definingScope.getEntity();
  addExposedName(E,E,name,definingScope.lookup(name).valueNumber(),true,context);
  if (useLocalValuesForLexicalVars()) {
    markExposedInEnclosingEntities(context,name,definingScope,E,context.getEntityName(E),true);
    context.cfg().addInstruction(new AssignInstruction(S.valueNumber(),rval));
    Access A=new Access(name,context.getEntityName(E),rval);
    context.cfg().addInstruction(new AstLexicalWrite(A));
  }
 else {
    Access A=new Access(name,context.getEntityName(E),rval);
    context.cfg().addInstruction(new AstLexicalWrite(A));
  }
}","/** 
 * Note that the caller is responsible for ensuring that name is defined in a lexical scope.
 */
protected void doLexicallyScopedWrite(WalkContext context,String name,int rval){
  Symbol S=context.currentScope().lookup(name);
  Scope definingScope=S.getDefiningScope();
  CAstEntity E=definingScope.getEntity();
  addExposedName(E,E,name,definingScope.lookup(name).valueNumber(),true,context);
  if (useLocalValuesForLexicalVars()) {
    markExposedInEnclosingEntities(context,name,definingScope,E,context.getEntityName(E),true);
    context.cfg().addInstruction(new AssignInstruction(S.valueNumber(),rval));
    Access A=new Access(name,context.getEntityName(E),rval);
    context.cfg().addInstruction(new AstLexicalWrite(A));
  }
 else {
    Access A=new Access(name,context.getEntityName(E),rval);
    context.cfg().addInstruction(new AstLexicalWrite(A));
    addAccess(context,context.top(),A);
  }
}",0.9775028121484814
99787,"/** 
 * generate instructions for a read of a global
 */
protected int doGlobalRead(CAstNode node,WalkContext context,String name){
  Symbol S=context.currentScope().lookup(name);
  if (treatGlobalsAsLexicallyScoped()) {
    if (useLocalValuesForLexicalVars()) {
      int vn=S.valueNumber();
      Access A=new Access(name,null,vn);
      addExposedName(context.top(),null,name,vn,false,context);
      addAccess(context,context.top(),A);
      return vn;
    }
 else {
      int result=context.currentScope().allocateTempValue();
      Access A=new Access(name,null,result);
      context.cfg().addInstruction(new AstLexicalRead(A));
      return result;
    }
  }
 else {
    int result=context.currentScope().allocateTempValue();
    FieldReference global=makeGlobalRef(name);
    context.cfg().addInstruction(new AstGlobalRead(result,global));
    return result;
  }
}","/** 
 * generate instructions for a read of a global
 */
protected int doGlobalRead(CAstNode node,WalkContext context,String name){
  Symbol S=context.currentScope().lookup(name);
  if (treatGlobalsAsLexicallyScoped()) {
    if (useLocalValuesForLexicalVars()) {
      int vn=S.valueNumber();
      Access A=new Access(name,null,vn);
      addExposedName(context.top(),null,name,vn,false,context);
      addAccess(context,context.top(),A);
      return vn;
    }
 else {
      int result=context.currentScope().allocateTempValue();
      Access A=new Access(name,null,result);
      context.cfg().addInstruction(new AstLexicalRead(A));
      addAccess(context,context.top(),A);
      return result;
    }
  }
 else {
    int result=context.currentScope().allocateTempValue();
    FieldReference global=makeGlobalRef(name);
    context.cfg().addInstruction(new AstGlobalRead(result,global));
    return result;
  }
}",0.976510067114094
99788,"/** 
 * we only have this method to avoid having to pass a node parameter at other call sites, as would be required for  {@link #doLexicallyScopedRead(CAstNode,WalkContext,String)}
 */
private int doLexReadHelper(WalkContext context,final String name){
  Symbol S=context.currentScope().lookup(name);
  Scope definingScope=S.getDefiningScope();
  CAstEntity E=definingScope.getEntity();
  addExposedName(E,E,name,definingScope.lookup(name).valueNumber(),false,context);
  final String entityName=context.getEntityName(E);
  if (useLocalValuesForLexicalVars()) {
    markExposedInEnclosingEntities(context,name,definingScope,E,entityName,false);
    return S.valueNumber();
  }
 else {
    int result=context.currentScope().allocateTempValue();
    Access A=new Access(name,entityName,result);
    context.cfg().addInstruction(new AstLexicalRead(A));
    return result;
  }
}","/** 
 * we only have this method to avoid having to pass a node parameter at other call sites, as would be required for  {@link #doLexicallyScopedRead(CAstNode,WalkContext,String)}
 */
private int doLexReadHelper(WalkContext context,final String name){
  Symbol S=context.currentScope().lookup(name);
  Scope definingScope=S.getDefiningScope();
  CAstEntity E=definingScope.getEntity();
  addExposedName(E,E,name,definingScope.lookup(name).valueNumber(),false,context);
  final String entityName=context.getEntityName(E);
  if (useLocalValuesForLexicalVars()) {
    markExposedInEnclosingEntities(context,name,definingScope,E,entityName,false);
    return S.valueNumber();
  }
 else {
    int result=context.currentScope().allocateTempValue();
    Access A=new Access(name,entityName,result);
    context.cfg().addInstruction(new AstLexicalRead(A));
    addAccess(context,context.top(),A);
    return result;
  }
}",0.977628635346756
99789,"/** 
 * record that in entity e, the access is performed using a local variable. in  {@link #patchLexicalAccesses(SSAInstruction[],Set)}, this information is used to update an instruction that performs all the accesses at the beginning of the method and defines the locals.
 */
private void addAccess(WalkContext context,CAstEntity e,Access access){
}","/** 
 * record that in entity e, the access is performed. If   {@link #useLocalValuesForLexicalVars()} is true, the access is performedusing a local variable. in {@link #patchLexicalAccesses(SSAInstruction[],Set)}, this information is used to update an instruction that performs all the accesses at the beginning of the method and defines the locals.
 */
private void addAccess(WalkContext context,CAstEntity e,Access access){
  context.getAccesses(e).add(access);
}",0.8543451652386781
99790,"public Context getCalleeTarget(CGNode caller,CallSiteReference site,IMethod callee,final InstanceKey[] receiver){
  Context baseContext=base.getCalleeTarget(caller,site,callee,receiver);
  String calleeFullName=callee.getDeclaringClass().getName().toString();
  String calleeShortName=calleeFullName.substring(calleeFullName.lastIndexOf('/') + 1);
  if (USE_NAME_TO_SELECT_CONTEXT) {
    if (calleeShortName.contains(HACK_METHOD_STR) && receiver.length > index) {
      return new ForInContext(baseContext,simulateToString(caller.getClassHierarchy(),receiver[index]));
    }
  }
 else   if (receiver.length > index) {
    Frequency f=usesFirstArgAsPropertyName(callee);
    if (f == Frequency.ALWAYS) {
      return new ForInContext(baseContext,simulateToString(caller.getClassHierarchy(),receiver[index]));
    }
 else     if (receiver[index] != null && (f == Frequency.SOMETIMES || forInOnFirstArg(callee))) {
      return new ForInContext(baseContext,receiver[index]);
    }
  }
  if (USE_CPA_IN_BODIES && FORIN_MARKER.equals(caller.getContext().get(FORIN_KEY))) {
    return new SelectiveCPAContext(baseContext,receiver);
  }
 else   if (USE_1LEVEL_IN_BODIES && FORIN_MARKER.equals(caller.getContext().get(FORIN_KEY))) {
    if (!identifyDependentParameters(caller,site).isEmpty()) {
      return oneLevel.getCalleeTarget(caller,site,callee,receiver);
    }
 else {
      return baseContext;
    }
  }
  return baseContext;
}","public Context getCalleeTarget(CGNode caller,CallSiteReference site,IMethod callee,final InstanceKey[] receiver){
  Context baseContext=base.getCalleeTarget(caller,site,callee,receiver);
  String calleeFullName=callee.getDeclaringClass().getName().toString();
  String calleeShortName=calleeFullName.substring(calleeFullName.lastIndexOf('/') + 1);
  if (USE_NAME_TO_SELECT_CONTEXT) {
    if (calleeShortName.contains(HACK_METHOD_STR) && receiver.length > index) {
      return new ForInContext(baseContext,simulateToString(caller.getClassHierarchy(),receiver[index]));
    }
  }
 else   if (receiver.length > index) {
    Frequency f=usesFirstArgAsPropertyName(callee);
    if (f == Frequency.ALWAYS) {
      return new ForInContext(baseContext,simulateToString(caller.getClassHierarchy(),receiver[index]));
    }
 else     if (f == Frequency.SOMETIMES || forInOnFirstArg(callee)) {
      if (receiver[index] == null) {
        IClass undef=caller.getClassHierarchy().lookupClass(JavaScriptTypes.Undefined);
        return new ForInContext(baseContext,new ConcreteTypeKey(undef));
      }
 else {
        return new ForInContext(baseContext,receiver[index]);
      }
    }
  }
  if (USE_CPA_IN_BODIES && FORIN_MARKER.equals(caller.getContext().get(FORIN_KEY))) {
    return new SelectiveCPAContext(baseContext,receiver);
  }
 else   if (USE_1LEVEL_IN_BODIES && FORIN_MARKER.equals(caller.getContext().get(FORIN_KEY))) {
    if (!identifyDependentParameters(caller,site).isEmpty()) {
      return oneLevel.getCalleeTarget(caller,site,callee,receiver);
    }
 else {
      return baseContext;
    }
  }
  return baseContext;
}",0.9171306911234852
99791,"private AbstractScope makeScriptScope(final CAstEntity s,Scope parent){
  return new AbstractScope(parent){
    SymbolTable scriptGlobalSymtab=new SymbolTable(s.getArgumentCount());
    public SymbolTable getUnderlyingSymtab(){
      return scriptGlobalSymtab;
    }
    protected AbstractScope getEntityScope(){
      return this;
    }
    public boolean isLexicallyScoped(    Symbol s){
      if (isGlobal(s))       return false;
 else       return ((AbstractScope)s.getDefiningScope()).getEntityScope() != this;
    }
    public CAstEntity getEntity(){
      return s;
    }
    public ScopeType type(){
      return ScopeType.SCRIPT;
    }
    protected Symbol makeSymbol(    final String nm,    final boolean isFinal,    final boolean isInternalName,    final Object defaultInitValue,    int vn,    Scope definer){
      final int v=vn == -1 ? getUnderlyingSymtab().newSymbol() : vn;
      if (useDefaultInitValues() && defaultInitValue != null) {
        if (getUnderlyingSymtab().getValue(v) == null) {
          setDefaultValue(getUnderlyingSymtab(),v,defaultInitValue);
        }
      }
      return new AbstractSymbol(definer,isFinal,defaultInitValue){
        public String toString(){
          return nm + ""String_Node_Str"" + System.identityHashCode(this);
        }
        public int valueNumber(){
          return v;
        }
        public boolean isInternalName(){
          return isInternalName;
        }
        public boolean isParameter(){
          return false;
        }
      }
;
    }
  }
;
}","private AbstractScope makeScriptScope(final CAstEntity s,Scope parent){
  return new AbstractScope(parent){
    SymbolTable scriptGlobalSymtab=new SymbolTable(s.getArgumentCount());
    public SymbolTable getUnderlyingSymtab(){
      return scriptGlobalSymtab;
    }
    protected AbstractScope getEntityScope(){
      return this;
    }
    public boolean isLexicallyScoped(    Symbol s){
      if (isGlobal(s))       return false;
 else       return ((AbstractScope)s.getDefiningScope()).getEntity() != getEntity();
    }
    public CAstEntity getEntity(){
      return s;
    }
    public ScopeType type(){
      return ScopeType.SCRIPT;
    }
    protected Symbol makeSymbol(    final String nm,    final boolean isFinal,    final boolean isInternalName,    final Object defaultInitValue,    int vn,    Scope definer){
      final int v=vn == -1 ? getUnderlyingSymtab().newSymbol() : vn;
      if (useDefaultInitValues() && defaultInitValue != null) {
        if (getUnderlyingSymtab().getValue(v) == null) {
          setDefaultValue(getUnderlyingSymtab(),v,defaultInitValue);
        }
      }
      return new AbstractSymbol(definer,isFinal,defaultInitValue){
        public String toString(){
          return nm + ""String_Node_Str"" + System.identityHashCode(this);
        }
        public int valueNumber(){
          return v;
        }
        public boolean isInternalName(){
          return isInternalName;
        }
        public boolean isParameter(){
          return false;
        }
      }
;
    }
  }
;
}",0.9934469200524246
99792,"/** 
 * record name as exposed for the current entity and for all enclosing entities up to that of the defining scope, since if the name is updated via a call to a nested function, SSA for these entities may need to be updated with the new definition
 * @param context
 * @param name
 * @param definingScope
 * @param E
 * @param entityName
 * @param isWrite
 */
private void markExposedInEnclosingEntities(WalkContext context,final String name,Scope definingScope,CAstEntity E,final String entityName,boolean isWrite){
  Scope curScope=context.currentScope();
  while (!curScope.equals(definingScope)) {
    final Symbol curSymbol=curScope.lookup(name);
    final int vn=curSymbol.valueNumber();
    final Access A=new Access(name,entityName,vn);
    final CAstEntity entity=curScope.getEntity();
    addExposedName(entity,E,name,vn,isWrite);
    addAccess(entity,A);
    curScope=curScope.getParent();
  }
}","/** 
 * record name as exposed for the current entity and for all enclosing entities up to that of the defining scope, since if the name is updated via a call to a nested function, SSA for these entities may need to be updated with the new definition
 * @param context
 * @param name
 * @param definingScope
 * @param E
 * @param entityName
 * @param isWrite
 */
private void markExposedInEnclosingEntities(WalkContext context,final String name,Scope definingScope,CAstEntity E,final String entityName,boolean isWrite){
  Scope curScope=context.currentScope();
  while (!curScope.equals(definingScope)) {
    final Symbol curSymbol=curScope.lookup(name);
    final int vn=curSymbol.valueNumber();
    final Access A=new Access(name,entityName,vn);
    final CAstEntity entity=curScope.getEntity();
    if (entity != definingScope.getEntity()) {
      addExposedName(entity,E,name,vn,isWrite);
      addAccess(entity,A);
    }
    curScope=curScope.getParent();
  }
}",0.9696
99793,"@Override public CAstNode visitVariableDeclaration(VariableDeclaration node,WalkContext arg){
  List<VariableInitializer> inits=node.getVariables();
  CAstNode[] children=new CAstNode[inits.size()];
  int i=0;
  for (  VariableInitializer init : inits) {
    arg.addNameDecl(noteSourcePosition(arg,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new CAstSymbolImpl(init.getTarget().getString())),readName(arg,""String_Node_Str"")),node));
    children[i++]=Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(init.getTarget().getString())),visit(init,arg));
  }
  return Ast.makeNode(CAstNode.BLOCK_STMT,children);
}","@Override public CAstNode visitVariableDeclaration(VariableDeclaration node,WalkContext arg){
  List<VariableInitializer> inits=node.getVariables();
  CAstNode[] children=new CAstNode[inits.size()];
  int i=0;
  for (  VariableInitializer init : inits) {
    arg.addNameDecl(noteSourcePosition(arg,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new CAstSymbolImpl(init.getTarget().getString())),readName(arg,""String_Node_Str"")),node));
    if (init.getInitializer() == null) {
      children[i++]=Ast.makeNode(CAstNode.EMPTY);
    }
 else {
      children[i++]=Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(init.getTarget().getString())),visit(init,arg));
    }
  }
  return Ast.makeNode(CAstNode.BLOCK_STMT,children);
}",0.918293564714389
99794,"@Override public CAstNode visitBreakStatement(BreakStatement node,WalkContext arg){
  CAstNode breakStmt;
  if (node.getBreakLabel() != null) {
    breakStmt=Ast.makeNode(CAstNode.GOTO,Ast.makeConstant(node.getBreakLabel().getIdentifier()));
  }
 else {
    breakStmt=Ast.makeNode(CAstNode.GOTO);
  }
  arg.cfg().map(node,breakStmt);
  Node target=node.getBreakTarget();
  arg.cfg().add(node,target,null);
  return breakStmt;
}","@Override public CAstNode visitBreakStatement(BreakStatement node,WalkContext arg){
  CAstNode breakStmt;
  Node target;
  if (node.getBreakLabel() != null) {
    breakStmt=Ast.makeNode(CAstNode.GOTO,Ast.makeConstant(node.getBreakLabel().getIdentifier()));
    target=arg.getBreakFor(node.getBreakLabel().getIdentifier());
  }
 else {
    breakStmt=Ast.makeNode(CAstNode.GOTO);
    target=arg.getBreakFor(null);
  }
  arg.cfg().map(node,breakStmt);
  arg.cfg().add(node,target,null);
  return breakStmt;
}",0.8369098712446352
99795,"@Override public CAstNode visitSwitchStatement(SwitchStatement node,WalkContext context){
  int i=0;
  CAstNode[] children=new CAstNode[node.getCases().size() * 2];
  for (  SwitchCase sc : node.getCases()) {
    CAstNode label=Ast.makeNode(CAstNode.LABEL_STMT,Ast.makeConstant(String.valueOf(i / 2)),Ast.makeNode(CAstNode.EMPTY));
    context.cfg().map(label,label);
    children[i++]=label;
    if (sc.isDefault()) {
      context.cfg().add(node,label,CAstControlFlowMap.SWITCH_DEFAULT);
    }
 else {
      CAstNode labelCAst=visit(sc.getExpression(),context);
      context.cfg().add(node,label,labelCAst);
    }
    children[i++]=visit(sc,context);
  }
  CAstNode s=Ast.makeNode(CAstNode.SWITCH,visit(node.getExpression(),context),Ast.makeNode(CAstNode.BLOCK_STMT,children));
  context.cfg().map(node,s);
  return s;
}","@Override public CAstNode visitSwitchStatement(SwitchStatement node,WalkContext context){
  AstNode breakStmt=makeEmptyLabelStmt(""String_Node_Str"");
  CAstNode breakLabel=visit(breakStmt,context);
  WalkContext switchBodyContext=makeBreakContext(node,context,breakStmt);
  int i=0;
  CAstNode[] children=new CAstNode[node.getCases().size() * 2];
  for (  SwitchCase sc : node.getCases()) {
    CAstNode label=Ast.makeNode(CAstNode.LABEL_STMT,Ast.makeConstant(String.valueOf(i / 2)),Ast.makeNode(CAstNode.EMPTY));
    context.cfg().map(label,label);
    children[i++]=label;
    if (sc.isDefault()) {
      context.cfg().add(node,label,CAstControlFlowMap.SWITCH_DEFAULT);
    }
 else {
      CAstNode labelCAst=visit(sc.getExpression(),context);
      context.cfg().add(node,label,labelCAst);
    }
    children[i++]=visit(sc,switchBodyContext);
  }
  CAstNode s=Ast.makeNode(CAstNode.SWITCH,visit(node.getExpression(),context),Ast.makeNode(CAstNode.BLOCK_STMT,children));
  context.cfg().map(node,s);
  return Ast.makeNode(CAstNode.BLOCK_STMT,s,breakLabel);
}",0.8724760892667375
99796,"@Override public CAstNode visitFunctionCall(FunctionCall n,WalkContext context){
  if (!isPrimitiveCall(context,n)) {
    CAstNode base=Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str""));
    AstNode callee=n.getTarget();
    WalkContext child=new BaseCollectingContext(context,callee,base);
    CAstNode fun=visit(callee,child);
    CAstNode[] args=gatherCallArguments(n,context);
    if (child.foundBase(callee))     return Ast.makeNode(CAstNode.LOCAL_SCOPE,Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new CAstSymbolImpl(""String_Node_Str"")),Ast.makeConstant(null)),makeCall(fun,base,args,context)));
 else     return makeCall(fun,makeVarRef(JSSSAPropagationCallGraphBuilder.GLOBAL_OBJ_VAR_NAME),args,context);
  }
 else {
    return Ast.makeNode(CAstNode.PRIMITIVE,gatherCallArguments(n,context));
  }
}","@Override public CAstNode visitFunctionCall(FunctionCall n,WalkContext context){
  if (!isPrimitiveCall(context,n)) {
    CAstNode base=Ast.makeNode(CAstNode.VAR,Ast.makeConstant(baseVarName));
    AstNode callee=n.getTarget();
    WalkContext child=new BaseCollectingContext(context,callee,base);
    CAstNode fun=visit(callee,child);
    CAstNode[] args=gatherCallArguments(n,context);
    if (child.foundBase(callee))     return Ast.makeNode(CAstNode.LOCAL_SCOPE,Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new CAstSymbolImpl(baseVarName)),Ast.makeConstant(null)),makeCall(fun,base,args,context)));
 else     return makeCall(fun,makeVarRef(JSSSAPropagationCallGraphBuilder.GLOBAL_OBJ_VAR_NAME),args,context);
  }
 else {
    return Ast.makeNode(CAstNode.PRIMITIVE,gatherCallArguments(n,context));
  }
}",0.967020023557126
99797,"@Override public CAstNode visitLabeledStatement(LabeledStatement node,WalkContext arg){
  CAstNode result=visit(node.getStatement(),arg);
  for (  Label label : node.getLabels()) {
    result=Ast.makeNode(CAstNode.LABEL_STMT,visit(label,arg),result);
    arg.cfg().map(label,result);
  }
  return result;
}","@Override public CAstNode visitLabeledStatement(LabeledStatement node,WalkContext arg){
  CAstNode result=visit(node.getStatement(),arg);
  AstNode prev=node;
  for (  Label label : node.getLabels()) {
    result=Ast.makeNode(CAstNode.LABEL_STMT,visit(label,arg),result);
    arg.cfg().map(prev,result);
    prev=label;
  }
  return result;
}",0.904320987654321
99798,"/** 
 * get the CGNode representing the lexical parent of   {@link #creator} withname definer
 * @param definer
 * @return
 */
Iterator<CGNode> getFunargNodes(Pair<String,String> name){
  Iterator<CGNode> result=EmptyIterator.instance();
  LexicalScopingResolver r=(LexicalScopingResolver)creator.getContext().get(LexicalScopingResolverContexts.RESOLVER);
  if (r != null) {
    CGNode def=r.getOriginalDefiner(name);
    if (def != null) {
      result=new NonNullSingletonIterator<CGNode>(def);
    }
  }
  PointerKey funcKey=builder.getPointerKeyForLocal(creator,1);
  OrdinalSet<InstanceKey> funcPtrs=builder.getPointerAnalysis().getPointsToSet(funcKey);
  for (  InstanceKey x : funcPtrs) {
    if (x instanceof ScopeMappingInstanceKey) {
      result=new CompoundIterator<CGNode>(result,((ScopeMappingInstanceKey)x).getFunargNodes(name));
    }
  }
  return result;
}","/** 
 * get the CGNode representing the lexical parent of   {@link #creator} withname definer
 * @param definer
 * @return
 */
Iterator<CGNode> getFunargNodes(Pair<String,String> name){
  Iterator<CGNode> result=EmptyIterator.instance();
  LexicalScopingResolver r=(LexicalScopingResolver)creator.getContext().get(LexicalScopingResolverContexts.RESOLVER);
  if (r != null) {
    CGNode def=r.getOriginalDefiner(name);
    if (def != null) {
      result=new NonNullSingletonIterator<CGNode>(def);
    }
  }
  ContextItem nested=creator.getContext().get(ScopeMappingKeysContextSelector.scopeKey);
  if (nested != null) {
    result=new CompoundIterator<CGNode>(result,((ScopeMappingInstanceKey)nested).getFunargNodes(name));
  }
  PointerKey funcKey=builder.getPointerKeyForLocal(creator,1);
  OrdinalSet<InstanceKey> funcPtrs=builder.getPointerAnalysis().getPointsToSet(funcKey);
  for (  InstanceKey x : funcPtrs) {
    if (x instanceof ScopeMappingInstanceKey) {
      result=new CompoundIterator<CGNode>(result,((ScopeMappingInstanceKey)x).getFunargNodes(name));
    }
  }
  return result;
}",0.887646161667514
99799,"/** 
 * compute the   {@link CGNode} correspond to each specified{@link LexicalParent} of {@link #base}, populating   {@link #scopeMap}
 */
private ScopeMappingInstanceKey(CGNode creator,InstanceKey base){
  this.creator=creator;
  this.base=base;
}","private ScopeMappingInstanceKey(CGNode creator,InstanceKey base){
  this.creator=creator;
  this.base=base;
}",0.6089385474860335
99800,"/** 
 * Note that the caller is responsible for ensuring that name is defined in a lexical scope.
 * @param node the AST node representing the read
 * @param context
 * @param name
 * @return
 */
protected int doLexicallyScopedRead(CAstNode node,WalkContext context,final String name){
  if (name.equals(""String_Node_Str"")) {
    System.err.println(""String_Node_Str"");
  }
  Symbol S=context.currentScope().lookup(name);
  Scope definingScope=S.getDefiningScope();
  CAstEntity E=definingScope.getEntity();
  addExposedName(E,E,name,definingScope.lookup(name).valueNumber(),false);
  String entityName=getEntityName(E);
  if (useLocalValuesForLexicalVars()) {
    Scope curScope=context.currentScope();
    while (!curScope.equals(definingScope)) {
      Symbol curSymbol=curScope.lookup(name);
      final int vn=curSymbol.valueNumber();
      Access A=new Access(name,entityName,vn);
      CAstEntity entity=curScope.getEntity();
      addExposedName(entity,E,name,vn,false);
      addAccess(entity,A);
      curScope=curScope.getParent();
    }
    return S.valueNumber();
  }
 else {
    int result=context.currentScope().allocateTempValue();
    Access A=new Access(name,entityName,result);
    context.cfg().addInstruction(new AstLexicalRead(A));
    return result;
  }
}","/** 
 * Note that the caller is responsible for ensuring that name is defined in a lexical scope.
 * @param node the AST node representing the read
 * @param context
 * @param name
 * @return
 */
protected int doLexicallyScopedRead(CAstNode node,WalkContext context,final String name){
  Symbol S=context.currentScope().lookup(name);
  Scope definingScope=S.getDefiningScope();
  CAstEntity E=definingScope.getEntity();
  addExposedName(E,E,name,definingScope.lookup(name).valueNumber(),false);
  final String entityName=getEntityName(E);
  if (useLocalValuesForLexicalVars()) {
    markExposedInEnclosingEntities(context,name,definingScope,E,entityName,false);
    return S.valueNumber();
  }
 else {
    int result=context.currentScope().allocateTempValue();
    Access A=new Access(name,entityName,result);
    context.cfg().addInstruction(new AstLexicalRead(A));
    return result;
  }
}",0.5987084870848709
99801,"/** 
 * Note that the caller is responsible for ensuring that name is defined in a lexical scope.
 */
protected void doLexicallyScopedWrite(WalkContext context,String name,int rval){
  Symbol S=context.currentScope().lookup(name);
  CAstEntity E=S.getDefiningScope().getEntity();
  addExposedName(E,E,name,S.getDefiningScope().lookup(name).valueNumber(),true);
  if (useLocalValuesForLexicalVars()) {
    int vn=S.valueNumber();
    Access A=new Access(name,getEntityName(E),vn);
    addExposedName(context.top(),E,name,vn,true);
    addAccess(context.top(),A);
    context.cfg().addInstruction(new AssignInstruction(vn,rval));
    context.cfg().addInstruction(new AstLexicalWrite(A));
  }
 else {
    Access A=new Access(name,getEntityName(E),rval);
    context.cfg().addInstruction(new AstLexicalWrite(A));
  }
}","/** 
 * Note that the caller is responsible for ensuring that name is defined in a lexical scope.
 */
protected void doLexicallyScopedWrite(WalkContext context,String name,int rval){
  Symbol S=context.currentScope().lookup(name);
  Scope definingScope=S.getDefiningScope();
  CAstEntity E=definingScope.getEntity();
  addExposedName(E,E,name,definingScope.lookup(name).valueNumber(),true);
  if (useLocalValuesForLexicalVars()) {
    markExposedInEnclosingEntities(context,name,definingScope,E,getEntityName(E),true);
    int vn=S.valueNumber();
    Access A=new Access(name,getEntityName(E),vn);
    context.cfg().addInstruction(new AssignInstruction(vn,rval));
    context.cfg().addInstruction(new AstLexicalWrite(A));
  }
 else {
    Access A=new Access(name,getEntityName(E),rval);
    context.cfg().addInstruction(new AstLexicalWrite(A));
  }
}",0.6009615384615384
99802,"@SuppressWarnings(""String_Node_Str"") AstLexicalInformation(String entityName,Scope scope,SSAInstruction[] instrs,Set<Pair<Pair<String,String>,Integer>> exposedNamesForReadSet,Set<Pair<Pair<String,String>,Integer>> exposedNamesForWriteSet,Set<Access> accesses){
  this.functionLexicalName=entityName;
  Pair<Pair<String,String>,Integer>[] EN=null;
  if (exposedNamesForReadSet != null || exposedNamesForWriteSet != null) {
    Set<Pair<Pair<String,String>,Integer>> exposedNamesSet=new HashSet<Pair<Pair<String,String>,Integer>>();
    if (exposedNamesForReadSet != null) {
      exposedNamesSet.addAll(exposedNamesForReadSet);
    }
    if (exposedNamesForWriteSet != null) {
      exposedNamesSet.addAll(exposedNamesForWriteSet);
    }
    EN=exposedNamesSet.toArray(new Pair[exposedNamesSet.size()]);
  }
  if (exposedNamesForReadSet != null) {
    Set<String> readOnlyNames=new HashSet<String>();
    for (    Pair<Pair<String,String>,Integer> v : exposedNamesForReadSet) {
      if (entityName != null && entityName.equals(v.fst.snd)) {
        readOnlyNames.add(v.fst.fst);
      }
    }
    if (exposedNamesForWriteSet != null) {
      for (      Pair<Pair<String,String>,Integer> v : exposedNamesForWriteSet) {
        if (entityName != null && entityName.equals(v.fst.snd)) {
          readOnlyNames.remove(v.fst.fst);
        }
      }
    }
    this.readOnlyNames=readOnlyNames;
  }
 else {
    this.readOnlyNames=null;
  }
  this.exposedNames=buildLexicalNamesArray(EN);
  this.exitLexicalUses=buildLexicalUseArray(EN,entityName);
  this.instructionLexicalUses=new int[instrs.length][];
  for (int i=0; i < instrs.length; i++) {
    if (instrs[i] instanceof SSAAbstractInvokeInstruction) {
      this.instructionLexicalUses[i]=buildLexicalUseArray(EN,null);
    }
  }
  if (accesses != null) {
    Set<String> parents=new LinkedHashSet<String>();
    for (Iterator<Access> ACS=accesses.iterator(); ACS.hasNext(); ) {
      Access AC=ACS.next();
      if (AC.variableDefiner != null) {
        parents.add(AC.variableDefiner);
      }
    }
    scopingParents=parents.toArray(new String[parents.size()]);
    if (DEBUG_LEXICAL) {
      System.err.println((""String_Node_Str"" + scope.getEntity()));
      System.err.println(parents.toString());
    }
  }
 else {
    scopingParents=null;
  }
  if (DEBUG_NAMES) {
    System.err.println((""String_Node_Str"" + scope.getEntity()));
    for (int i=0; i < instructionLexicalUses.length; i++) {
      if (instructionLexicalUses[i] != null) {
        System.err.println((""String_Node_Str"" + instrs[i]));
        for (int j=0; j < instructionLexicalUses[i].length; j++) {
          System.err.println((""String_Node_Str"" + this.exposedNames[j].fst + ""String_Node_Str""+ instructionLexicalUses[i][j]));
        }
      }
    }
  }
}","@SuppressWarnings(""String_Node_Str"") AstLexicalInformation(String entityName,Scope scope,SSAInstruction[] instrs,Set<Pair<Pair<String,String>,Integer>> exposedNamesForReadSet,Set<Pair<Pair<String,String>,Integer>> exposedNamesForWriteSet,Set<Access> accesses){
  if (entityName.contains(""String_Node_Str"")) {
    System.err.println(""String_Node_Str"");
  }
  this.functionLexicalName=entityName;
  Pair<Pair<String,String>,Integer>[] EN=null;
  if (exposedNamesForReadSet != null || exposedNamesForWriteSet != null) {
    Set<Pair<Pair<String,String>,Integer>> exposedNamesSet=new HashSet<Pair<Pair<String,String>,Integer>>();
    if (exposedNamesForReadSet != null) {
      exposedNamesSet.addAll(exposedNamesForReadSet);
    }
    if (exposedNamesForWriteSet != null) {
      exposedNamesSet.addAll(exposedNamesForWriteSet);
    }
    EN=exposedNamesSet.toArray(new Pair[exposedNamesSet.size()]);
  }
  if (exposedNamesForReadSet != null) {
    Set<String> readOnlyNames=new HashSet<String>();
    for (    Pair<Pair<String,String>,Integer> v : exposedNamesForReadSet) {
      if (entityName != null && entityName.equals(v.fst.snd)) {
        readOnlyNames.add(v.fst.fst);
      }
    }
    if (exposedNamesForWriteSet != null) {
      for (      Pair<Pair<String,String>,Integer> v : exposedNamesForWriteSet) {
        if (entityName != null && entityName.equals(v.fst.snd)) {
          readOnlyNames.remove(v.fst.fst);
        }
      }
    }
    this.readOnlyNames=readOnlyNames;
  }
 else {
    this.readOnlyNames=null;
  }
  this.exposedNames=buildLexicalNamesArray(EN);
  this.exitLexicalUses=buildLexicalUseArray(EN,entityName);
  this.instructionLexicalUses=new int[instrs.length][];
  for (int i=0; i < instrs.length; i++) {
    if (instrs[i] instanceof SSAAbstractInvokeInstruction) {
      this.instructionLexicalUses[i]=buildLexicalUseArray(EN,null);
    }
  }
  if (accesses != null) {
    Set<String> parents=new LinkedHashSet<String>();
    for (Iterator<Access> ACS=accesses.iterator(); ACS.hasNext(); ) {
      Access AC=ACS.next();
      if (AC.variableDefiner != null) {
        parents.add(AC.variableDefiner);
      }
    }
    scopingParents=parents.toArray(new String[parents.size()]);
    if (DEBUG_LEXICAL) {
      System.err.println((""String_Node_Str"" + scope.getEntity()));
      System.err.println(parents.toString());
    }
  }
 else {
    scopingParents=null;
  }
  if (DEBUG_NAMES) {
    System.err.println((""String_Node_Str"" + scope.getEntity()));
    for (int i=0; i < instructionLexicalUses.length; i++) {
      if (instructionLexicalUses[i] != null) {
        System.err.println((""String_Node_Str"" + instrs[i]));
        for (int j=0; j < instructionLexicalUses[i].length; j++) {
          System.err.println((""String_Node_Str"" + this.exposedNames[j].fst + ""String_Node_Str""+ instructionLexicalUses[i][j]));
        }
      }
    }
  }
}",0.9831888161387364
99803,"/** 
 * Note that the caller is responsible for ensuring that name is defined in a lexical scope.
 * @param node the AST node representing the read
 * @param context
 * @param name
 * @return
 */
protected int doLexicallyScopedRead(CAstNode node,WalkContext context,String name){
  Symbol S=context.currentScope().lookup(name);
  CAstEntity E=S.getDefiningScope().getEntity();
  addExposedName(E,E,name,S.getDefiningScope().lookup(name).valueNumber(),false);
  int vn=S.valueNumber();
  if (useLocalValuesForLexicalVars()) {
    Access A=new Access(name,getEntityName(E),vn);
    addExposedName(context.top(),E,name,vn,false);
    addAccess(context.top(),A);
    return vn;
  }
 else {
    int result=context.currentScope().allocateTempValue();
    Access A=new Access(name,getEntityName(E),result);
    context.cfg().addInstruction(new AstLexicalRead(A));
    return result;
  }
}","/** 
 * Note that the caller is responsible for ensuring that name is defined in a lexical scope.
 * @param node the AST node representing the read
 * @param context
 * @param name
 * @return
 */
protected int doLexicallyScopedRead(CAstNode node,WalkContext context,final String name){
  if (name.equals(""String_Node_Str"")) {
    System.err.println(""String_Node_Str"");
  }
  Symbol S=context.currentScope().lookup(name);
  Scope definingScope=S.getDefiningScope();
  CAstEntity E=definingScope.getEntity();
  addExposedName(E,E,name,definingScope.lookup(name).valueNumber(),false);
  String entityName=getEntityName(E);
  if (useLocalValuesForLexicalVars()) {
    Scope curScope=context.currentScope();
    while (!curScope.equals(definingScope)) {
      Symbol curSymbol=curScope.lookup(name);
      final int vn=curSymbol.valueNumber();
      Access A=new Access(name,entityName,vn);
      CAstEntity entity=curScope.getEntity();
      addExposedName(entity,E,name,vn,false);
      addAccess(entity,A);
      curScope=curScope.getParent();
    }
    return S.valueNumber();
  }
 else {
    int result=context.currentScope().allocateTempValue();
    Access A=new Access(name,entityName,result);
    context.cfg().addInstruction(new AstLexicalRead(A));
    return result;
  }
}",0.4865616311399444
99804,"public Context getCalleeTarget(CGNode caller,CallSiteReference site,IMethod callee,final InstanceKey[] receiver){
  Context baseContext=base.getCalleeTarget(caller,site,callee,receiver);
  if (useForInContext(callee,receiver)) {
    InstanceKey loopVar=receiver[2];
    IClass stringClass=caller.getClassHierarchy().lookupClass(JavaScriptTypes.String);
    if (loopVar instanceof ConstantKey) {
      Object value=((ConstantKey)loopVar).getValue();
      if (value instanceof String) {
        return new ForInContext(baseContext,loopVar);
      }
 else       if (value instanceof Number) {
        Integer ival=((Number)value).intValue();
        return new ForInContext(baseContext,new ConstantKey<String>(ival.toString(),stringClass));
      }
 else       if (value instanceof Boolean) {
        Boolean bval=(Boolean)value;
        return new ForInContext(baseContext,new ConstantKey<String>(bval.toString(),stringClass));
      }
 else       if (value == null) {
        return new ForInContext(baseContext,new ConstantKey<String>(""String_Node_Str"",stringClass));
      }
    }
    ConcreteTypeKey stringKey=new ConcreteTypeKey(stringClass);
    return new ForInContext(baseContext,stringKey);
  }
 else   if (USE_CPA_IN_BODIES && FORIN_MARKER.equals(caller.getContext().get(FORIN_KEY))) {
    return new SelectiveCPAContext(baseContext,receiver);
  }
 else   if (USE_1LEVEL_IN_BODIES && FORIN_MARKER.equals(caller.getContext().get(FORIN_KEY))) {
    if (!identifyDependentParameters(caller,site).isEmpty()) {
      return oneLevel.getCalleeTarget(caller,site,callee,receiver);
    }
 else {
      return baseContext;
    }
  }
 else {
    return baseContext;
  }
}","public Context getCalleeTarget(CGNode caller,CallSiteReference site,IMethod callee,final InstanceKey[] receiver){
  Context baseContext=base.getCalleeTarget(caller,site,callee,receiver);
  String calleeFullName=callee.getDeclaringClass().getName().toString();
  String calleeShortName=calleeFullName.substring(calleeFullName.lastIndexOf('/') + 1);
  if (USE_NAME_TO_SELECT_CONTEXT) {
    if (calleeShortName.contains(HACK_METHOD_STR)) {
      return new ForInContext(baseContext,simulateToString(caller.getClassHierarchy(),receiver[2]));
    }
  }
 else   if (receiver.length > 2 && receiver[2] != null) {
    Frequency f=usesFirstArgAsPropertyName(callee);
    if (f == Frequency.ALWAYS) {
      return new ForInContext(baseContext,simulateToString(caller.getClassHierarchy(),receiver[2]));
    }
 else     if (f == Frequency.SOMETIMES || forInOnFirstArg(callee)) {
      return new ForInContext(baseContext,receiver[2]);
    }
  }
  if (USE_CPA_IN_BODIES && FORIN_MARKER.equals(caller.getContext().get(FORIN_KEY))) {
    return new SelectiveCPAContext(baseContext,receiver);
  }
 else   if (USE_1LEVEL_IN_BODIES && FORIN_MARKER.equals(caller.getContext().get(FORIN_KEY))) {
    if (!identifyDependentParameters(caller,site).isEmpty()) {
      return oneLevel.getCalleeTarget(caller,site,callee,receiver);
    }
 else {
      return baseContext;
    }
  }
  return baseContext;
}",0.5068852459016393
99805,"private boolean usesFirstArgAsPropertyName(IMethod method){
  if (method.getNumberOfParameters() < 2)   return false;
  Boolean b=usesFirstArgAsPropertyName_cache.get(method);
  if (b != null)   return b;
  DefUse du=getDefUse(method);
  for (  SSAInstruction use : Iterator2Iterable.make(du.getUses(3))) {
    if (use instanceof ReflectiveMemberAccess) {
      ReflectiveMemberAccess rma=(ReflectiveMemberAccess)use;
      if (rma.getMemberRef() == 3) {
        usesFirstArgAsPropertyName_cache.put(method,true);
        return true;
      }
    }
  }
  usesFirstArgAsPropertyName_cache.put(method,false);
  return false;
}","private Frequency usesFirstArgAsPropertyName(IMethod method){
  if (method.getNumberOfParameters() < 2)   return Frequency.NEVER;
  Frequency f=usesFirstArgAsPropertyName_cache.get(method);
  if (f != null)   return f;
  boolean usedAsPropertyName=false, usedAsSomethingElse=false;
  DefUse du=getDefUse(method);
  for (  SSAInstruction use : Iterator2Iterable.make(du.getUses(3))) {
    if (use instanceof ReflectiveMemberAccess) {
      ReflectiveMemberAccess rma=(ReflectiveMemberAccess)use;
      if (rma.getMemberRef() == 3) {
        usedAsPropertyName=true;
        continue;
      }
    }
    usedAsSomethingElse=true;
  }
  if (!usedAsPropertyName)   f=Frequency.NEVER;
 else   if (usedAsSomethingElse)   f=Frequency.SOMETIMES;
 else   f=Frequency.ALWAYS;
  usesFirstArgAsPropertyName_cache.put(method,f);
  return f;
}",0.5840220385674931
99806,"public void setLexicallyMutatedIR(IR ir){
  lexicalScopingChanges=true;
  cachedIR=ir;
  cachedDU=new DefUse(ir);
}","public void setLexicallyMutatedIR(IR ir){
  lexicalScopingChanges=true;
  cachedIR=ir;
  cachedDU=null;
}",0.9272727272727272
99807,"public DefUse getLexicallyMutatedDU(){
  if (lexicalScopingChanges) {
    return cachedDU;
  }
 else {
    return null;
  }
}","public DefUse getLexicallyMutatedDU(){
  if (lexicalScopingChanges) {
    if (cachedDU == null) {
      cachedDU=new DefUse(cachedIR);
    }
    return cachedDU;
  }
 else {
    return null;
  }
}",0.778816199376947
99808,"/** 
 * @return the indices i s.t. x[i] == y, or null if none found.
 */
private int[] extractIndices(int[] x,int y){
  int count=0;
  for (int i=0; i < x.length; i++) {
    if (x[i] == y) {
      count++;
    }
  }
  if (count == 0) {
    return null;
  }
 else {
    int[] result=new int[count];
    int j=0;
    for (int i=0; i < x.length; i++) {
      if (x[i] == y) {
        result[j++]=i;
      }
    }
    return result;
  }
}","/** 
 * @return the indices i s.t. x[i] == y, or null if none found.
 */
private int[] extractIndices(int[] x,int y){
}",0.430379746835443
99809,"/** 
 * @param pc a program counter (index into ShrikeBT instruction array)
 * @param vn a value number
 * @return if we know that immediately after the given program counter, v_vn corresponds to some set of locals, then return anarray of the local numbers. else return null.
 */
private int[] findLocalsForValueNumber(int pc,int vn){
  IBasicBlock bb=shrikeCFG.getBlockForInstruction(pc);
  int firstInstruction=bb.getFirstInstructionIndex();
  int[] locals=block2LocalState[bb.getNumber()];
  for (int i=firstInstruction; i <= pc; i++) {
    if (localStoreMap[i] != null) {
      IntPair p=localStoreMap[i];
      setLocal(locals,p.getY(),p.getX());
    }
  }
  return extractIndices(locals,vn);
}","/** 
 * @param pc a program counter (index into ShrikeBT instruction array)
 * @param vn a value number
 * @return if we know that immediately after the given program counter, v_vn corresponds to some set of locals, then return anarray of the local numbers. else return null.
 */
private int[] findLocalsForValueNumber(int pc,int vn){
  if (vn < 0) {
    return null;
  }
  IBasicBlock bb=shrikeCFG.getBlockForInstruction(pc);
  int firstInstruction=bb.getFirstInstructionIndex();
  int[] locals=block2LocalState[bb.getNumber()];
  for (int i=firstInstruction; i <= pc; i++) {
    if (localStoreMap[i] != null) {
      IntPair p=localStoreMap[i];
      locals=setLocal(locals,p.getY(),p.getX());
    }
  }
  return locals == null ? null : extractIndices(locals,vn);
}",0.9536152796725784
99810,"public nCFABuilder(int n,IClassHierarchy cha,AnalysisOptions options,AnalysisCache cache,ContextSelector appContextSelector,SSAContextInterpreter appContextInterpreter){
  super(cha,options,cache,new DefaultPointerKeyFactory());
  if (options == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  setInstanceKeys(new ClassBasedInstanceKeys(options,cha));
  ContextSelector def=new DefaultContextSelector(options,cha);
  ContextSelector contextSelector=new DelegatingContextSelector(appContextSelector,def);
  contextSelector=new nCFAContextSelector(n,contextSelector);
  setContextSelector(contextSelector);
  SSAContextInterpreter defI=new DefaultSSAInterpreter(options,cache);
  defI=new DelegatingSSAContextInterpreter(ReflectionContextInterpreter.createReflectionContextInterpreter(cha,options,getAnalysisCache()),defI);
  SSAContextInterpreter contextInterpreter=new DelegatingSSAContextInterpreter(appContextInterpreter,defI);
  setContextInterpreter(contextInterpreter);
}","public nCFABuilder(int n,IClassHierarchy cha,AnalysisOptions options,AnalysisCache cache,ContextSelector appContextSelector,SSAContextInterpreter appContextInterpreter){
  super(cha,options,cache,new DefaultPointerKeyFactory());
  if (options == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  setInstanceKeys(new ClassBasedInstanceKeys(options,cha));
  ContextSelector def=new DefaultContextSelector(options,cha);
  ContextSelector contextSelector=appContextSelector == null ? def : new DelegatingContextSelector(appContextSelector,def);
  contextSelector=new nCFAContextSelector(n,contextSelector);
  setContextSelector(contextSelector);
  SSAContextInterpreter defI=new DefaultSSAInterpreter(options,cache);
  defI=new DelegatingSSAContextInterpreter(ReflectionContextInterpreter.createReflectionContextInterpreter(cha,options,getAnalysisCache()),defI);
  SSAContextInterpreter contextInterpreter=appContextInterpreter == null ? defI : new DelegatingSSAContextInterpreter(appContextInterpreter,defI);
  setContextInterpreter(contextInterpreter);
}",0.964354527938343
99811,"private static String composeString(Collection<String> s){
  StringBuffer result=new StringBuffer();
  Iterator<String> it=s.iterator();
  for (int i=0; i < s.size() - 1; i++) {
    result.append(it.next());
    result.append(';');
  }
  if (it.hasNext()) {
    result.append(it.next());
  }
  return result.toString();
}","private static String composeString(Collection<String> s){
  StringBuffer result=new StringBuffer();
  Iterator<String> it=s.iterator();
  for (int i=0; i < s.size() - 1; i++) {
    result.append(it.next());
    result.append(File.pathSeparator);
  }
  if (it.hasNext()) {
    result.append(it.next());
  }
  return result.toString();
}",0.9680365296803652
99812,"protected CAstNode copyNodes(CAstNode root,RewriteContext context,Map<Pair<CAstNode,ExpanderKey>,CAstNode> nodeMap){
  int kind=root.getKind();
  if (kind == CAstNode.OBJECT_REF && context.inRead()) {
    CAstNode readLoop;
    CAstNode receiver=copyNodes(root.getChild(0),READ,nodeMap);
    CAstNode element=copyNodes(root.getChild(1),READ,nodeMap);
    if (element.getKind() == CAstNode.CONSTANT && element.getValue() instanceof String) {
      readLoop=makeConstRead(root,receiver,element,context,nodeMap);
    }
 else {
      readLoop=makeVarRead(root,receiver,element,context,nodeMap);
    }
    return readLoop;
  }
 else   if (kind == CAstNode.ASSIGN_PRE_OP || kind == CAstNode.ASSIGN_POST_OP) {
    AssignPreOrPostOpContext ctxt=new AssignPreOrPostOpContext();
    CAstNode lval=copyNodes(root.getChild(0),ctxt,nodeMap);
    CAstNode rval=copyNodes(root.getChild(1),READ,nodeMap);
    CAstNode op=copyNodes(root.getChild(2),READ,nodeMap);
    if (ctxt.receiverTemp != null) {
      String temp1=TEMP_NAME + (readTempCounter++);
      String temp2=TEMP_NAME + (readTempCounter++);
      CAstNode copy=Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(temp1,true,false)),lval),rval,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(temp2,true,false)),Ast.makeNode(CAstNode.BINARY_EXPR,op,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(temp1)),rval)),Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.OBJECT_REF,ctxt.receiverTemp,ctxt.elementTemp),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(temp2))),Ast.makeNode(CAstNode.VAR,Ast.makeConstant((kind == CAstNode.ASSIGN_PRE_OP) ? temp2 : temp1)));
      nodeMap.put(Pair.make(root,context.key()),copy);
      return copy;
    }
 else {
      CAstNode copy=Ast.makeNode(kind,lval,rval,op);
      nodeMap.put(Pair.make(root,context.key()),copy);
      return copy;
    }
  }
 else   if (kind == CAstNode.ASSIGN) {
    CAstNode copy=Ast.makeNode(CAstNode.ASSIGN,copyNodes(root.getChild(0),ASSIGN,nodeMap),copyNodes(root.getChild(1),READ,nodeMap));
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (kind == CAstNode.BLOCK_EXPR) {
    CAstNode children[]=new CAstNode[root.getChildCount()];
    int last=(children.length - 1);
    for (int i=0; i < last; i++) {
      children[i]=copyNodes(root.getChild(i),READ,nodeMap);
    }
    children[last]=copyNodes(root.getChild(last),context,nodeMap);
    CAstNode copy=Ast.makeNode(CAstNode.BLOCK_EXPR,children);
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (root.getKind() == CAstNode.CONSTANT) {
    CAstNode copy=Ast.makeConstant(root.getValue());
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (root.getKind() == CAstNode.OPERATOR) {
    nodeMap.put(Pair.make(root,context.key()),root);
    return root;
  }
 else {
    CAstNode children[]=new CAstNode[root.getChildCount()];
    for (int i=0; i < children.length; i++) {
      children[i]=copyNodes(root.getChild(i),READ,nodeMap);
    }
    CAstNode copy=Ast.makeNode(kind,children);
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
}","protected CAstNode copyNodes(CAstNode root,RewriteContext context,Map<Pair<CAstNode,ExpanderKey>,CAstNode> nodeMap){
  int kind=root.getKind();
  if (kind == CAstNode.OBJECT_REF && context.inRead()) {
    CAstNode readLoop;
    CAstNode receiver=copyNodes(root.getChild(0),READ,nodeMap);
    CAstNode element=copyNodes(root.getChild(1),READ,nodeMap);
    if (element.getKind() == CAstNode.CONSTANT && element.getValue() instanceof String) {
      readLoop=makeConstRead(root,receiver,element,context,nodeMap);
    }
 else {
      readLoop=makeVarRead(root,receiver,element,context,nodeMap);
    }
    return readLoop;
  }
 else   if (kind == CAstNode.ASSIGN_PRE_OP || kind == CAstNode.ASSIGN_POST_OP) {
    AssignPreOrPostOpContext ctxt=new AssignPreOrPostOpContext();
    CAstNode lval=copyNodes(root.getChild(0),ctxt,nodeMap);
    CAstNode rval=copyNodes(root.getChild(1),READ,nodeMap);
    CAstNode op=copyNodes(root.getChild(2),READ,nodeMap);
    if (ctxt.receiverTemp != null) {
      String temp1=TEMP_NAME + (readTempCounter++);
      String temp2=TEMP_NAME + (readTempCounter++);
      CAstNode copy=Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(temp1,true,false)),lval),Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(temp2,true,false)),Ast.makeNode(CAstNode.BINARY_EXPR,op,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(temp1)),rval)),Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.OBJECT_REF,ctxt.receiverTemp,ctxt.elementTemp),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(temp2))),Ast.makeNode(CAstNode.VAR,Ast.makeConstant((kind == CAstNode.ASSIGN_PRE_OP) ? temp2 : temp1)));
      nodeMap.put(Pair.make(root,context.key()),copy);
      return copy;
    }
 else {
      CAstNode copy=Ast.makeNode(kind,lval,rval,op);
      nodeMap.put(Pair.make(root,context.key()),copy);
      return copy;
    }
  }
 else   if (kind == CAstNode.ASSIGN) {
    CAstNode copy=Ast.makeNode(CAstNode.ASSIGN,copyNodes(root.getChild(0),ASSIGN,nodeMap),copyNodes(root.getChild(1),READ,nodeMap));
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (kind == CAstNode.BLOCK_EXPR) {
    CAstNode children[]=new CAstNode[root.getChildCount()];
    int last=(children.length - 1);
    for (int i=0; i < last; i++) {
      children[i]=copyNodes(root.getChild(i),READ,nodeMap);
    }
    children[last]=copyNodes(root.getChild(last),context,nodeMap);
    CAstNode copy=Ast.makeNode(CAstNode.BLOCK_EXPR,children);
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (root.getKind() == CAstNode.CONSTANT) {
    CAstNode copy=Ast.makeConstant(root.getValue());
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (root.getKind() == CAstNode.OPERATOR) {
    nodeMap.put(Pair.make(root,context.key()),root);
    return root;
  }
 else {
    CAstNode children[]=new CAstNode[root.getChildCount()];
    for (int i=0; i < children.length; i++) {
      children[i]=copyNodes(root.getChild(i),READ,nodeMap);
    }
    CAstNode copy=Ast.makeNode(kind,children);
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
}",0.9992166692777692
99813,"public boolean inRead(){
  return false;
}","public boolean inRead(){
  return true;
}",0.9156626506024096
99814,"public void setAssign(CAstNode receiverTemp,CAstNode elementTemp){
  Assertions.UNREACHABLE();
}","/** 
 * store the CAstNodes used to represent the loop variable for the prototype-chain traversal (receiverTemp) and the desired property (elementTemp)
 */
public void setAssign(CAstNode receiverTemp,CAstNode elementTemp){
  this.receiverTemp=receiverTemp;
  this.elementTemp=elementTemp;
}",0.3834196891191709
99815,"protected CAstNode copyNodes(CAstNode root,RewriteContext context,Map<Pair<CAstNode,NoKey>,CAstNode> nodeMap){
  int kind=root.getKind();
  if (kind == CAstNode.OBJECT_REF && context.inRead()) {
    CAstNode readLoop;
    CAstNode receiver=copyNodes(root.getChild(0),READ,nodeMap);
    CAstNode element=copyNodes(root.getChild(1),READ,nodeMap);
    if (element.getKind() == CAstNode.CONSTANT && element.getValue() instanceof String) {
      readLoop=makeConstRead(root,receiver,element,context,nodeMap);
    }
 else {
      readLoop=makeVarRead(root,receiver,element,context,nodeMap);
    }
    return readLoop;
  }
 else   if (kind == CAstNode.ASSIGN_PRE_OP || kind == CAstNode.ASSIGN_POST_OP) {
    AssignPreOrPostOpContext ctxt=new AssignPreOrPostOpContext();
    CAstNode lval=copyNodes(root.getChild(0),ctxt,nodeMap);
    CAstNode rval=copyNodes(root.getChild(1),READ,nodeMap);
    CAstNode op=copyNodes(root.getChild(2),READ,nodeMap);
    if (ctxt.receiverTemp != null) {
      String temp1=TEMP_NAME + (readTempCounter++);
      String temp2=TEMP_NAME + (readTempCounter++);
      CAstNode copy=Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(temp1,true,false)),lval),rval,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(temp2,true,false)),Ast.makeNode(CAstNode.BINARY_EXPR,op,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(temp1)),rval)),Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.OBJECT_REF,ctxt.receiverTemp,ctxt.elementTemp),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(temp2))),Ast.makeNode(CAstNode.VAR,Ast.makeConstant((kind == CAstNode.ASSIGN_PRE_OP) ? temp2 : temp1)));
      nodeMap.put(Pair.make(root,context.key()),copy);
      return copy;
    }
 else {
      CAstNode copy=Ast.makeNode(kind,lval,rval,op);
      nodeMap.put(Pair.make(root,context.key()),copy);
      return copy;
    }
  }
 else   if (kind == CAstNode.ASSIGN) {
    CAstNode copy=Ast.makeNode(CAstNode.ASSIGN,copyNodes(root.getChild(0),ASSIGN,nodeMap),copyNodes(root.getChild(1),READ,nodeMap));
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (kind == CAstNode.BLOCK_EXPR) {
    CAstNode children[]=new CAstNode[root.getChildCount()];
    int last=(children.length - 1);
    for (int i=0; i < last; i++) {
      children[i]=copyNodes(root.getChild(i),READ,nodeMap);
    }
    children[last]=copyNodes(root.getChild(last),context,nodeMap);
    CAstNode copy=Ast.makeNode(CAstNode.BLOCK_EXPR,children);
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (root.getKind() == CAstNode.CONSTANT) {
    CAstNode copy=Ast.makeConstant(root.getValue());
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (root.getKind() == CAstNode.OPERATOR) {
    nodeMap.put(Pair.make(root,context.key()),root);
    return root;
  }
 else {
    CAstNode children[]=new CAstNode[root.getChildCount()];
    for (int i=0; i < children.length; i++) {
      children[i]=copyNodes(root.getChild(i),READ,nodeMap);
    }
    CAstNode copy=Ast.makeNode(kind,children);
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
}","protected CAstNode copyNodes(CAstNode root,RewriteContext context,Map<Pair<CAstNode,ExpanderKey>,CAstNode> nodeMap){
  int kind=root.getKind();
  if (kind == CAstNode.OBJECT_REF && context.inRead()) {
    CAstNode readLoop;
    CAstNode receiver=copyNodes(root.getChild(0),READ,nodeMap);
    CAstNode element=copyNodes(root.getChild(1),READ,nodeMap);
    if (element.getKind() == CAstNode.CONSTANT && element.getValue() instanceof String) {
      readLoop=makeConstRead(root,receiver,element,context,nodeMap);
    }
 else {
      readLoop=makeVarRead(root,receiver,element,context,nodeMap);
    }
    return readLoop;
  }
 else   if (kind == CAstNode.ASSIGN_PRE_OP || kind == CAstNode.ASSIGN_POST_OP) {
    AssignPreOrPostOpContext ctxt=new AssignPreOrPostOpContext();
    CAstNode lval=copyNodes(root.getChild(0),ctxt,nodeMap);
    CAstNode rval=copyNodes(root.getChild(1),READ,nodeMap);
    CAstNode op=copyNodes(root.getChild(2),READ,nodeMap);
    if (ctxt.receiverTemp != null) {
      String temp1=TEMP_NAME + (readTempCounter++);
      String temp2=TEMP_NAME + (readTempCounter++);
      CAstNode copy=Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(temp1,true,false)),lval),rval,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(temp2,true,false)),Ast.makeNode(CAstNode.BINARY_EXPR,op,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(temp1)),rval)),Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.OBJECT_REF,ctxt.receiverTemp,ctxt.elementTemp),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(temp2))),Ast.makeNode(CAstNode.VAR,Ast.makeConstant((kind == CAstNode.ASSIGN_PRE_OP) ? temp2 : temp1)));
      nodeMap.put(Pair.make(root,context.key()),copy);
      return copy;
    }
 else {
      CAstNode copy=Ast.makeNode(kind,lval,rval,op);
      nodeMap.put(Pair.make(root,context.key()),copy);
      return copy;
    }
  }
 else   if (kind == CAstNode.ASSIGN) {
    CAstNode copy=Ast.makeNode(CAstNode.ASSIGN,copyNodes(root.getChild(0),ASSIGN,nodeMap),copyNodes(root.getChild(1),READ,nodeMap));
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (kind == CAstNode.BLOCK_EXPR) {
    CAstNode children[]=new CAstNode[root.getChildCount()];
    int last=(children.length - 1);
    for (int i=0; i < last; i++) {
      children[i]=copyNodes(root.getChild(i),READ,nodeMap);
    }
    children[last]=copyNodes(root.getChild(last),context,nodeMap);
    CAstNode copy=Ast.makeNode(CAstNode.BLOCK_EXPR,children);
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (root.getKind() == CAstNode.CONSTANT) {
    CAstNode copy=Ast.makeConstant(root.getValue());
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
 else   if (root.getKind() == CAstNode.OPERATOR) {
    nodeMap.put(Pair.make(root,context.key()),root);
    return root;
  }
 else {
    CAstNode children[]=new CAstNode[root.getChildCount()];
    for (int i=0; i < children.length; i++) {
      children[i]=copyNodes(root.getChild(i),READ,nodeMap);
    }
    CAstNode copy=Ast.makeNode(kind,children);
    nodeMap.put(Pair.make(root,context.key()),copy);
    return copy;
  }
}",0.9984330930742714
99816,"/** 
 * create a CAstNode l representing a loop that traverses the prototype chain from receiver searching for the constant property element. update nodeMap to map root to an expression that reads the property from the right node.
 * @param root
 * @param receiver
 * @param element
 * @param context
 * @param nodeMap
 * @return
 */
private CAstNode makeConstRead(CAstNode root,CAstNode receiver,CAstNode element,RewriteContext context,Map<Pair<CAstNode,NoKey>,CAstNode> nodeMap){
  CAstNode get, result;
  String receiverTemp=TEMP_NAME + (readTempCounter++);
  String elt=(String)element.getValue();
  if (elt.equals(""String_Node_Str"") || elt.equals(""String_Node_Str"")) {
    result=Ast.makeNode(CAstNode.BLOCK_EXPR,get=Ast.makeNode(CAstNode.OBJECT_REF,receiver,Ast.makeConstant(elt)));
  }
 else {
    if (context.inAssignment()) {
      context.setAssign(Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeConstant(elt));
    }
    result=Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(receiverTemp,false,false)),receiver),Ast.makeNode(CAstNode.LOOP,Ast.makeNode(CAstNode.UNARY_EXPR,CAstOperator.OP_NOT,Ast.makeNode(CAstNode.IS_DEFINED_EXPR,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeConstant(elt))),Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeNode(CAstNode.OBJECT_REF,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeConstant(""String_Node_Str"")))),get=Ast.makeNode(CAstNode.OBJECT_REF,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeConstant(elt)));
  }
  nodeMap.put(Pair.make(root,context.key()),get);
  return result;
}","/** 
 * create a CAstNode l representing a loop that traverses the prototype chain from receiver searching for the constant property element. update nodeMap to map root to an expression that reads the property from the right node.
 * @param root
 * @param receiver
 * @param element
 * @param context
 * @param nodeMap
 * @return
 */
private CAstNode makeConstRead(CAstNode root,CAstNode receiver,CAstNode element,RewriteContext context,Map<Pair<CAstNode,ExpanderKey>,CAstNode> nodeMap){
  CAstNode get, result;
  String receiverTemp=TEMP_NAME + (readTempCounter++);
  String elt=(String)element.getValue();
  if (elt.equals(""String_Node_Str"") || elt.equals(""String_Node_Str"")) {
    result=Ast.makeNode(CAstNode.BLOCK_EXPR,get=Ast.makeNode(CAstNode.OBJECT_REF,receiver,Ast.makeConstant(elt)));
  }
 else {
    if (context.inAssignment()) {
      context.setAssign(Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeConstant(elt));
    }
    result=Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(receiverTemp,false,false)),receiver),Ast.makeNode(CAstNode.LOOP,Ast.makeNode(CAstNode.UNARY_EXPR,CAstOperator.OP_NOT,Ast.makeNode(CAstNode.IS_DEFINED_EXPR,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeConstant(elt))),Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeNode(CAstNode.OBJECT_REF,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeConstant(""String_Node_Str"")))),get=Ast.makeNode(CAstNode.OBJECT_REF,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeConstant(elt)));
  }
  nodeMap.put(Pair.make(root,context.key()),result);
  nodeMap.put(Pair.make(root,ExpanderKey.EXTRA),get);
  return result;
}",0.98075265728239
99817,"/** 
 * similar to makeConstRead(), but desired property is some expression instead of a constant
 * @see #makeConstRead(CAstNode,CAstNode,CAstNode,RewriteContext,Map)
 */
private CAstNode makeVarRead(CAstNode root,CAstNode receiver,CAstNode element,RewriteContext context,Map<Pair<CAstNode,NoKey>,CAstNode> nodeMap){
  String receiverTemp=TEMP_NAME + (readTempCounter++);
  String elementTemp=TEMP_NAME + (readTempCounter++);
  if (context.inAssignment()) {
    context.setAssign(Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(elementTemp)));
  }
  CAstNode get;
  CAstNode result=Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(receiverTemp,false,false)),receiver),Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(elementTemp,false,false)),element),Ast.makeNode(CAstNode.LOOP,Ast.makeNode(CAstNode.UNARY_EXPR,CAstOperator.OP_NOT,Ast.makeNode(CAstNode.IS_DEFINED_EXPR,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(elementTemp)))),Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeNode(CAstNode.OBJECT_REF,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeConstant(""String_Node_Str"")))),get=Ast.makeNode(CAstNode.OBJECT_REF,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(elementTemp))));
  nodeMap.put(Pair.make(root,context.key()),get);
  return result;
}","/** 
 * similar to makeConstRead(), but desired property is some expression instead of a constant
 * @see #makeConstRead(CAstNode,CAstNode,CAstNode,RewriteContext,Map)
 */
private CAstNode makeVarRead(CAstNode root,CAstNode receiver,CAstNode element,RewriteContext context,Map<Pair<CAstNode,ExpanderKey>,CAstNode> nodeMap){
  String receiverTemp=TEMP_NAME + (readTempCounter++);
  String elementTemp=TEMP_NAME + (readTempCounter++);
  if (context.inAssignment()) {
    context.setAssign(Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(elementTemp)));
  }
  CAstNode get;
  CAstNode result=Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(receiverTemp,false,false)),receiver),Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new InternalCAstSymbol(elementTemp,false,false)),element),Ast.makeNode(CAstNode.LOOP,Ast.makeNode(CAstNode.UNARY_EXPR,CAstOperator.OP_NOT,Ast.makeNode(CAstNode.IS_DEFINED_EXPR,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(elementTemp)))),Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeNode(CAstNode.OBJECT_REF,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeConstant(""String_Node_Str"")))),get=Ast.makeNode(CAstNode.OBJECT_REF,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(receiverTemp)),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(elementTemp))));
  nodeMap.put(Pair.make(root,context.key()),get);
  return result;
}",0.9968010236724248
99818,"public void copyState(IVariable v){
  MachineState other=(MachineState)v;
  if (other.stack == null) {
    stack=null;
  }
 else {
    stack=new int[other.stack.length];
    System.arraycopy(other.stack,0,stack,0,other.stack.length);
  }
  if (other.locals == null) {
    locals=null;
  }
 else {
    locals=new int[other.locals.length];
    System.arraycopy(other.locals,0,locals,0,other.locals.length);
  }
  stackHeight=other.stackHeight;
}","public void copyState(MachineState other){
  if (other.stack == null) {
    stack=null;
  }
 else {
    stack=new int[other.stack.length];
    System.arraycopy(other.stack,0,stack,0,other.stack.length);
  }
  if (other.locals == null) {
    locals=null;
  }
 else {
    locals=new int[other.locals.length];
    System.arraycopy(other.locals,0,locals,0,other.locals.length);
  }
  stackHeight=other.stackHeight;
}",0.0912280701754386
99819,"/** 
 * @return the state at the entry to a given block
 */
public MachineState getIn(ShrikeCFG.BasicBlock bb){
  return (MachineState)solver.getIn(bb);
}","/** 
 * @return the state at the entry to a given block
 */
public MachineState getIn(ShrikeCFG.BasicBlock bb){
  return solver.getIn(bb);
}",0.9523809523809524
99820,"public MachineState getEntryState(){
  return (MachineState)solver.getIn(cfg.entry());
}","public MachineState getEntryState(){
  return solver.getIn(cfg.entry());
}",0.9135802469135802
99821,"protected void visitInvokeInternal(final SSAAbstractInvokeInstruction instruction){
  super.visitInvokeInternal(instruction);
  if (instruction instanceof AbstractLexicalInvoke) {
    AbstractLexicalInvoke I=(AbstractLexicalInvoke)instruction;
    for (int wi=0; wi < I.getNumberOfDefs(); wi++) {
      if (I.isLexicalDef(wi)) {
        Access w=I.getLexicalDef(wi);
        for (int ri=0; ri < I.getNumberOfUses(); ri++) {
          if (I.isLexicalUse(ri)) {
            Access r=I.getLexicalUse(ri);
            if (w.variableName.equals(r.variableName)) {
              if (w.variableDefiner == null ? r.variableDefiner == null : w.variableDefiner.equals(r.variableDefiner)) {
                PointerKey rk=getBuilder().getPointerKeyForLocal(node,r.valueNumber);
                PointerKey wk=getBuilder().getPointerKeyForLocal(node,w.valueNumber);
                system.newConstraint(wk,assignOperator,rk);
              }
            }
          }
        }
      }
    }
  }
}","protected void visitInvokeInternal(final SSAAbstractInvokeInstruction instruction){
  super.visitInvokeInternal(instruction);
  if (instruction instanceof AbstractLexicalInvoke) {
    AbstractLexicalInvoke I=(AbstractLexicalInvoke)instruction;
    for (int wi=0; wi < I.getNumberOfDefs(); wi++) {
      if (I.isLexicalDef(wi)) {
        Access w=I.getLexicalDef(wi);
        for (int ri=0; ri < I.getNumberOfUses(); ri++) {
          if (I.isLexicalUse(ri)) {
            Access r=I.getLexicalUse(ri);
            if (w.variableName.equals(r.variableName)) {
              if (w.variableDefiner == null ? r.variableDefiner == null : w.variableDefiner.equals(r.variableDefiner)) {
                PointerKey rk=getBuilder().getPointerKeyForLocal(node,r.valueNumber);
                PointerKey wk=getBuilder().getPointerKeyForLocal(node,w.valueNumber);
                if (contentsAreInvariant(symbolTable,du,r.valueNumber)) {
                  system.recordImplicitPointsToSet(rk);
                  for (                  InstanceKey ik : getInvariantContents(r.valueNumber)) {
                    system.newConstraint(wk,ik);
                  }
                }
 else {
                  system.newConstraint(wk,assignOperator,rk);
                }
              }
            }
          }
        }
      }
    }
  }
}",0.8518197573656846
99822,"/** 
 * @param fileName
 * @return the jar file packaged with this plug-in of the given name, or null if not found.
 */
private static JarFileModule getFromPlugin(Plugin p,String fileName) throws IOException {
  URL url=getFileURLFromPlugin(p,fileName);
  return (url == null) ? null : new JarFileModule(new JarFile(filePathFromURL(url)));
}","/** 
 * @param fileName
 * @return the jar file packaged with this plug-in of the given name, or nullif not found.
 */
private static JarFileModule getFromPlugin(Plugin p,String fileName) throws IOException {
  URL url=getFileURLFromPlugin(p,fileName);
  return (url == null) ? null : new JarFileModule(new JarFile(filePathFromURL(url)));
}",0.998531571218796
99823,"/** 
 * Properly creates the String file name of a   {@link URL}. This works around a bug in the Sun implementation of  {@link URL#getFile()}, which doesn't properly handle file paths with spaces (see <a href=""http://sourceforge.net/tracker/index.php?func=detail&aid=1565842&group_id=176742&atid=878458"">bug report</a>). For now, fails with an assertion if the url is malformed.
 * @param url
 * @return the path name for the url
 * @throws IllegalArgumentException if url is null
 */
public static String filePathFromURL(URL url){
  if (url == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URI uri=null;
  try {
    uri=new URI(url.toString());
  }
 catch (  URISyntaxException e) {
    Assertions.UNREACHABLE();
  }
  String filePath=uri.getPath();
  return filePath;
}","/** 
 * Properly creates the String file name of a   {@link URL}. This works around a bug in the Sun implementation of   {@link URL#getFile()}, which doesn't properly handle file paths with spaces (see <a href= ""http://sourceforge.net/tracker/index.php?func=detail&aid=1565842&group_id=176742&atid=878458"" >bug report</a>). For now, fails with an assertion if the url is malformed.
 * @param url
 * @return the path name for the url
 * @throws IllegalArgumentException if url is null
 */
public static String filePathFromURL(URL url){
  if (url == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URI uri=new File(url.getPath()).toURI();
  String filePath=uri.getPath();
  return filePath;
}",0.8433575677461996
99824,"/** 
 * @param fileName
 * @return the jar file packaged with this plug-in of the given name, or null if not found.
 * @throws IllegalArgumentException if p is null
 */
public static File getFileFromPlugin(Plugin p,String fileName) throws IOException {
  if (p == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URL url=getFileURLFromPlugin(p,fileName);
  if (url == null) {
    throw new FileNotFoundException(fileName);
  }
  return new File(filePathFromURL(url));
}","/** 
 * @param fileName
 * @return the jar file packaged with this plug-in of the given name, or nullif not found.
 * @throws IllegalArgumentException if p is null
 */
public static File getFileFromPlugin(Plugin p,String fileName) throws IOException {
  if (p == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URL url=getFileURLFromPlugin(p,fileName);
  if (url == null) {
    throw new FileNotFoundException(fileName);
  }
  return new File(filePathFromURL(url));
}",0.999140154772141
99825,"/** 
 * escape spaces in a URL, primarily to work around a bug in   {@link File#toURL()}
 * @param url
 * @return an escaped version of the URL
 */
private static URL fixupFileURLSpaces(URL url){
  String urlString=url.toExternalForm();
  StringBuffer fixedUpUrl=new StringBuffer();
  int lastIndex=0;
  while (true) {
    int spaceIndex=urlString.indexOf(' ',lastIndex);
    if (spaceIndex < 0) {
      fixedUpUrl.append(urlString.substring(lastIndex));
      break;
    }
    fixedUpUrl.append(urlString.substring(lastIndex,spaceIndex));
    fixedUpUrl.append(""String_Node_Str"");
    lastIndex=spaceIndex + 1;
  }
  try {
    return new URL(fixedUpUrl.toString());
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
    Assertions.UNREACHABLE();
  }
  return null;
}","/** 
 * escape spaces in a URL, primarily to work around a bug in  {@link File#toURL()}
 * @param url
 * @return an escaped version of the URL
 */
private static URL fixupFileURLSpaces(URL url){
  String urlString=url.toExternalForm();
  StringBuffer fixedUpUrl=new StringBuffer();
  int lastIndex=0;
  while (true) {
    int spaceIndex=urlString.indexOf(' ',lastIndex);
    if (spaceIndex < 0) {
      fixedUpUrl.append(urlString.substring(lastIndex));
      break;
    }
    fixedUpUrl.append(urlString.substring(lastIndex,spaceIndex));
    fixedUpUrl.append(""String_Node_Str"");
    lastIndex=spaceIndex + 1;
  }
  try {
    return new URL(fixedUpUrl.toString());
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
    Assertions.UNREACHABLE();
  }
  return null;
}",0.9993610223642172
99826,"/** 
 * @return the jar file packaged with this plug-in of the given name, or null if not found: wrapped as a JarFileModule or aNestedJarFileModule
 * @throws IOException
 */
public static Module getJarFileFromClassLoader(String fileName,ClassLoader loader) throws IOException {
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (loader == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URL url=loader.getResource(fileName);
  if (DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + url + ""String_Node_Str""+ fileName);
  }
  if (url == null) {
    try {
      return new JarFileModule(new JarFile(fileName,false));
    }
 catch (    ZipException e) {
      throw new IOException(""String_Node_Str"" + fileName);
    }
  }
  if (url.getProtocol().equals(""String_Node_Str"")) {
    JarURLConnection jc=(JarURLConnection)url.openConnection();
    JarFile f=jc.getJarFile();
    JarEntry entry=jc.getJarEntry();
    JarFileModule parent=new JarFileModule(f);
    return new NestedJarFileModule(parent,entry);
  }
 else {
    String filePath=filePathFromURL(url);
    return new JarFileModule(new JarFile(filePath,false));
  }
}","/** 
 * @return the jar file packaged with this plug-in of the given name, or nullif not found: wrapped as a JarFileModule or a NestedJarFileModule
 * @throws IOException
 */
public static Module getJarFileFromClassLoader(String fileName,ClassLoader loader) throws IOException {
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (loader == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  URL url=loader.getResource(fileName);
  if (DEBUG_LEVEL > 0) {
    System.err.println(""String_Node_Str"" + url + ""String_Node_Str""+ fileName);
  }
  if (url == null) {
    try {
      return new JarFileModule(new JarFile(fileName,false));
    }
 catch (    ZipException e) {
      throw new IOException(""String_Node_Str"" + fileName);
    }
  }
  if (url.getProtocol().equals(""String_Node_Str"")) {
    JarURLConnection jc=(JarURLConnection)url.openConnection();
    JarFile f=jc.getJarFile();
    JarEntry entry=jc.getJarEntry();
    JarFileModule parent=new JarFileModule(f);
    return new NestedJarFileModule(parent,entry);
  }
 else {
    String filePath=filePathFromURL(url);
    return new JarFileModule(new JarFile(filePath,false));
  }
}",0.9991666666666666
99827,"private static void getMethodInClassOrSuperclass(IMethodBinding met,ITypeBinding klass,boolean superclassonly,HashMap<ITypeBinding,IMethodBinding> overridden){
  if (!superclassonly) {
    for (    IMethodBinding ourmet : klass.getDeclaredMethods())     if (met.isSubsignature(ourmet) && (met.getModifiers() & Modifier.PRIVATE) == 0) {
      overridden.put(ourmet.getMethodDeclaration().getReturnType(),ourmet.getMethodDeclaration());
      break;
    }
  }
  for (  ITypeBinding iface : klass.getInterfaces())   getMethodInClassOrSuperclass(met,iface,false,overridden);
  ITypeBinding superclass=klass.getSuperclass();
  if (superclass != null)   getMethodInClassOrSuperclass(met,superclass,false,overridden);
}","private static void getMethodInClassOrSuperclass(IMethodBinding met,ITypeBinding klass,boolean superclassonly,HashMap<ITypeBinding,IMethodBinding> overridden){
  if (!superclassonly) {
    for (    IMethodBinding ourmet : klass.getDeclaredMethods())     if (met.overrides(ourmet)) {
      overridden.put(ourmet.getMethodDeclaration().getReturnType(),ourmet.getMethodDeclaration());
      break;
    }
  }
  for (  ITypeBinding iface : klass.getInterfaces())   getMethodInClassOrSuperclass(met,iface,false,overridden);
  ITypeBinding superclass=klass.getSuperclass();
  if (superclass != null)   getMethodInClassOrSuperclass(met,superclass,false,overridden);
}",0.936542669584245
99828,"/** 
 * Make a ""fake"" function (it doesn't exist in source code but it does in bytecode) for covariant return types.
 * @param overriding Declaration of the overriding method.
 * @param overridden Binding of the overridden method, in a a superclass or implemented interface.
 * @param oldContext
 * @return
 */
private CAstEntity makeSyntheticCovariantRedirect(MethodDeclaration overriding,IMethodBinding overridingBinding,IMethodBinding overridden,WalkContext oldContext){
  final Map<CAstNode,CAstEntity> memberEntities=new LinkedHashMap<CAstNode,CAstEntity>();
  final MethodContext context=new MethodContext(oldContext,memberEntities);
  CAstNode calltarget;
  if ((overridingBinding.getModifiers() & Modifier.STATIC) == 0)   calltarget=makeNode(context,fFactory,null,CAstNode.THIS);
 else   calltarget=makeNode(context,fFactory,null,CAstNode.VOID);
  ITypeBinding paramTypes[]=overridden.getParameterTypes();
  ArrayList<CAstNode> arguments=new ArrayList<CAstNode>();
  int i=0;
  for (  Object o : overriding.parameters()) {
    SingleVariableDeclaration svd=(SingleVariableDeclaration)o;
    CAstNode varNode=makeNode(context,fFactory,null,CAstNode.VAR,fFactory.makeConstant(svd.getName().getIdentifier()));
    ITypeBinding fromType=JDT2CAstUtils.getErasedType(paramTypes[i],ast);
    ITypeBinding toType=JDT2CAstUtils.getErasedType(overridingBinding.getParameterTypes()[i],ast);
    if (fromType.equals(toType))     arguments.add(varNode);
 else     arguments.add(createCast(null,varNode,fromType,toType,context));
    i++;
  }
  CAstNode callnode=createMethodInvocation(null,overridingBinding,calltarget,arguments,context);
  CAstNode mdast=makeNode(context,fFactory,null,CAstNode.LOCAL_SCOPE,makeNode(context,fFactory,null,CAstNode.BLOCK_STMT,makeNode(context,fFactory,null,CAstNode.RETURN,callnode)));
  ArrayList<CAstType> paramCAstTypes=new ArrayList<CAstType>(overridden.getParameterTypes().length);
  for (  ITypeBinding paramType : overridden.getParameterTypes())   paramCAstTypes.add(fTypeDict.getCAstTypeFor(paramType));
  return new ProcedureEntity(mdast,overriding,overridingBinding.getDeclaringClass(),memberEntities,context,paramCAstTypes,overridden.getReturnType());
}","/** 
 * Make a ""fake"" function (it doesn't exist in source code but it does in bytecode) for covariant return types.
 * @param overriding Declaration of the overriding method.
 * @param overridden Binding of the overridden method, in a a superclass or implemented interface.
 * @param oldContext
 * @return
 */
private CAstEntity makeSyntheticCovariantRedirect(MethodDeclaration overriding,IMethodBinding overridingBinding,IMethodBinding overridden,WalkContext oldContext){
  final Map<CAstNode,CAstEntity> memberEntities=new LinkedHashMap<CAstNode,CAstEntity>();
  final MethodContext context=new MethodContext(oldContext,memberEntities);
  CAstNode calltarget;
  if ((overridingBinding.getModifiers() & Modifier.STATIC) == 0)   calltarget=makeNode(context,fFactory,null,CAstNode.SUPER);
 else   calltarget=makeNode(context,fFactory,null,CAstNode.VOID);
  ITypeBinding paramTypes[]=overridden.getParameterTypes();
  ArrayList<CAstNode> arguments=new ArrayList<CAstNode>();
  int i=0;
  for (  Object o : overriding.parameters()) {
    SingleVariableDeclaration svd=(SingleVariableDeclaration)o;
    CAstNode varNode=makeNode(context,fFactory,null,CAstNode.VAR,fFactory.makeConstant(svd.getName().getIdentifier()));
    ITypeBinding fromType=JDT2CAstUtils.getErasedType(paramTypes[i],ast);
    ITypeBinding toType=JDT2CAstUtils.getErasedType(overridingBinding.getParameterTypes()[i],ast);
    if (fromType.equals(toType)) {
      arguments.add(varNode);
    }
 else {
      arguments.add(createCast(null,varNode,fromType,toType,context));
    }
    i++;
  }
  CAstNode callnode=createMethodInvocation(null,overridingBinding,calltarget,arguments,context);
  CAstNode mdast=makeNode(context,fFactory,null,CAstNode.LOCAL_SCOPE,makeNode(context,fFactory,null,CAstNode.BLOCK_STMT,makeNode(context,fFactory,null,CAstNode.RETURN,callnode)));
  ArrayList<CAstType> paramCAstTypes=new ArrayList<CAstType>(overridden.getParameterTypes().length);
  for (  ITypeBinding paramType : overridden.getParameterTypes())   paramCAstTypes.add(fTypeDict.getCAstTypeFor(paramType));
  return new ProcedureEntity(mdast,overriding,overridingBinding.getDeclaringClass(),memberEntities,context,paramCAstTypes,overridden.getReturnType());
}",0.9920544835414302
99829,"/** 
 * @param n
 * @param bodyDecls
 * @param enumConstants
 * @param typeBinding
 * @param name Used in creating default constructor, and passed into new ClassEntity()
 * @param context
 * @return
 */
private CAstEntity createClassDeclaration(ASTNode n,List bodyDecls,List enumConstants,ITypeBinding typeBinding,String name,int modifiers,boolean isInterface,boolean isAnnotation,WalkContext context){
  final List<CAstEntity> memberEntities=new ArrayList<CAstEntity>();
  ArrayList<ASTNode> inits=new ArrayList<ASTNode>();
  ArrayList<ASTNode> staticInits=new ArrayList<ASTNode>();
  if (enumConstants != null) {
    for (    Object decl : enumConstants) {
      EnumConstantDeclaration ecd=(EnumConstantDeclaration)decl;
      staticInits.add(ecd);
    }
  }
  for (  Object decl : bodyDecls) {
    if (decl instanceof Initializer) {
      Initializer initializer=(Initializer)decl;
      boolean isStatic=((initializer.getModifiers() & Modifier.STATIC) != 0);
      (isStatic ? staticInits : inits).add(initializer);
    }
 else     if (decl instanceof FieldDeclaration) {
      FieldDeclaration fd=(FieldDeclaration)decl;
      for (      Object f : fd.fragments()) {
        VariableDeclarationFragment frag=(VariableDeclarationFragment)f;
        if (frag.getInitializer() != null) {
          boolean isStatic=((fd.getModifiers() & Modifier.STATIC) != 0);
          (isStatic ? staticInits : inits).add(frag);
        }
      }
    }
  }
  if (enumConstants != null) {
    for (    Object decl : enumConstants) {
      memberEntities.add(visit((EnumConstantDeclaration)decl,context));
    }
  }
  for (  Object d : bodyDecls) {
    BodyDeclaration decl=(BodyDeclaration)d;
    if (decl instanceof FieldDeclaration) {
      FieldDeclaration fieldDecl=(FieldDeclaration)decl;
      Collection<CAstQualifier> quals=JDT2CAstUtils.mapModifiersToQualifiers(fieldDecl.getModifiers(),false,false);
      for (      Object f : fieldDecl.fragments()) {
        VariableDeclarationFragment fieldFrag=(VariableDeclarationFragment)f;
        memberEntities.add(new FieldEntity(fieldFrag.getName().getIdentifier(),fieldFrag.resolveBinding().getType(),quals,makePosition(fieldFrag.getStartPosition(),fieldFrag.getStartPosition() + fieldFrag.getLength())));
      }
    }
 else     if (decl instanceof Initializer) {
    }
 else     if (decl instanceof MethodDeclaration) {
      MethodDeclaration metDecl=(MethodDeclaration)decl;
      if (typeBinding.isEnum() && metDecl.isConstructor())       memberEntities.add(createEnumConstructorWithParameters(metDecl.resolveBinding(),metDecl,context,inits,metDecl));
 else {
        memberEntities.add(visit(metDecl,typeBinding,context,inits));
        Collection<IMethodBinding> overriddenMets=JDT2CAstUtils.getOverriddenMethod(metDecl.resolveBinding());
        if (overriddenMets != null) {
          for (          IMethodBinding overridden : overriddenMets)           if (!JDT2CAstUtils.sameSignatureAndReturnType(metDecl.resolveBinding(),overridden))           memberEntities.add(makeSyntheticCovariantRedirect(metDecl,metDecl.resolveBinding(),overridden,context));
        }
      }
    }
 else     if (decl instanceof AbstractTypeDeclaration) {
      memberEntities.add(visit((AbstractTypeDeclaration)decl,context));
    }
 else     if (decl instanceof AnnotationTypeMemberDeclaration) {
    }
 else {
      Assertions.UNREACHABLE(""String_Node_Str"");
    }
  }
  for (  Object m : typeBinding.getDeclaredMethods()) {
    IMethodBinding met=(IMethodBinding)m;
    if (met.isDefaultConstructor()) {
      if (typeBinding.isEnum())       memberEntities.add(createEnumConstructorWithParameters(met,n,context,inits,null));
 else       if (met.getParameterTypes().length > 0)       memberEntities.add(createDefaultConstructorWithParameters(met,n,context,inits));
 else       memberEntities.add(createDefaultConstructor(name,typeBinding,context,inits,n));
    }
  }
  if (typeBinding.isEnum() && !typeBinding.isAnonymous())   doEnumHiddenEntities(typeBinding,staticInits,memberEntities,context);
  if (!staticInits.isEmpty()) {
    Map<CAstNode,CAstEntity> childEntities=HashMapFactory.make();
    final MethodContext newContext=new MethodContext(context,childEntities);
    CAstNode[] bodyNodes=new CAstNode[staticInits.size()];
    for (int i=0; i < staticInits.size(); i++)     bodyNodes[i]=visitFieldInitNode(staticInits.get(i),newContext);
    CAstNode staticInitAst=makeNode(newContext,fFactory,n,CAstNode.BLOCK_STMT,bodyNodes);
    memberEntities.add(new ProcedureEntity(staticInitAst,typeBinding,childEntities,newContext));
  }
  Collection<CAstQualifier> quals=JDT2CAstUtils.mapModifiersToQualifiers(modifiers,isInterface,isAnnotation);
  return new ClassEntity(typeBinding,name,quals,memberEntities,makePosition(n));
}","/** 
 * @param n
 * @param bodyDecls
 * @param enumConstants
 * @param typeBinding
 * @param name Used in creating default constructor, and passed into new ClassEntity()
 * @param context
 * @return
 */
private CAstEntity createClassDeclaration(ASTNode n,List bodyDecls,List enumConstants,ITypeBinding typeBinding,String name,int modifiers,boolean isInterface,boolean isAnnotation,WalkContext context){
  final List<CAstEntity> memberEntities=new ArrayList<CAstEntity>();
  ArrayList<ASTNode> inits=new ArrayList<ASTNode>();
  ArrayList<ASTNode> staticInits=new ArrayList<ASTNode>();
  if (enumConstants != null) {
    for (    Object decl : enumConstants) {
      EnumConstantDeclaration ecd=(EnumConstantDeclaration)decl;
      staticInits.add(ecd);
    }
  }
  for (  Object decl : bodyDecls) {
    if (decl instanceof Initializer) {
      Initializer initializer=(Initializer)decl;
      boolean isStatic=((initializer.getModifiers() & Modifier.STATIC) != 0);
      (isStatic ? staticInits : inits).add(initializer);
    }
 else     if (decl instanceof FieldDeclaration) {
      FieldDeclaration fd=(FieldDeclaration)decl;
      for (      Object f : fd.fragments()) {
        VariableDeclarationFragment frag=(VariableDeclarationFragment)f;
        if (frag.getInitializer() != null) {
          boolean isStatic=((fd.getModifiers() & Modifier.STATIC) != 0);
          (isStatic ? staticInits : inits).add(frag);
        }
      }
    }
  }
  if (enumConstants != null) {
    for (    Object decl : enumConstants) {
      memberEntities.add(visit((EnumConstantDeclaration)decl,context));
    }
  }
  for (  Object d : bodyDecls) {
    BodyDeclaration decl=(BodyDeclaration)d;
    if (decl instanceof FieldDeclaration) {
      FieldDeclaration fieldDecl=(FieldDeclaration)decl;
      Collection<CAstQualifier> quals=JDT2CAstUtils.mapModifiersToQualifiers(fieldDecl.getModifiers(),false,false);
      for (      Object f : fieldDecl.fragments()) {
        VariableDeclarationFragment fieldFrag=(VariableDeclarationFragment)f;
        memberEntities.add(new FieldEntity(fieldFrag.getName().getIdentifier(),fieldFrag.resolveBinding().getType(),quals,makePosition(fieldFrag.getStartPosition(),fieldFrag.getStartPosition() + fieldFrag.getLength())));
      }
    }
 else     if (decl instanceof Initializer) {
    }
 else     if (decl instanceof MethodDeclaration) {
      MethodDeclaration metDecl=(MethodDeclaration)decl;
      if (typeBinding.isEnum() && metDecl.isConstructor())       memberEntities.add(createEnumConstructorWithParameters(metDecl.resolveBinding(),metDecl,context,inits,metDecl));
 else {
        memberEntities.add(visit(metDecl,typeBinding,context,inits));
        Collection<IMethodBinding> overriddenMets=JDT2CAstUtils.getOverriddenMethod(metDecl.resolveBinding());
        if (overriddenMets != null) {
          for (          IMethodBinding overridden : overriddenMets)           if (!JDT2CAstUtils.sameErasedSignatureAndReturnType(metDecl.resolveBinding(),overridden))           memberEntities.add(makeSyntheticCovariantRedirect(metDecl,metDecl.resolveBinding(),overridden,context));
        }
      }
    }
 else     if (decl instanceof AbstractTypeDeclaration) {
      memberEntities.add(visit((AbstractTypeDeclaration)decl,context));
    }
 else     if (decl instanceof AnnotationTypeMemberDeclaration) {
    }
 else {
      Assertions.UNREACHABLE(""String_Node_Str"");
    }
  }
  for (  Object m : typeBinding.getDeclaredMethods()) {
    IMethodBinding met=(IMethodBinding)m;
    if (met.isDefaultConstructor()) {
      if (typeBinding.isEnum())       memberEntities.add(createEnumConstructorWithParameters(met,n,context,inits,null));
 else       if (met.getParameterTypes().length > 0)       memberEntities.add(createDefaultConstructorWithParameters(met,n,context,inits));
 else       memberEntities.add(createDefaultConstructor(name,typeBinding,context,inits,n));
    }
  }
  if (typeBinding.isEnum() && !typeBinding.isAnonymous())   doEnumHiddenEntities(typeBinding,staticInits,memberEntities,context);
  if (!staticInits.isEmpty()) {
    Map<CAstNode,CAstEntity> childEntities=HashMapFactory.make();
    final MethodContext newContext=new MethodContext(context,childEntities);
    CAstNode[] bodyNodes=new CAstNode[staticInits.size()];
    for (int i=0; i < staticInits.size(); i++)     bodyNodes[i]=visitFieldInitNode(staticInits.get(i),newContext);
    CAstNode staticInitAst=makeNode(newContext,fFactory,n,CAstNode.BLOCK_STMT,bodyNodes);
    memberEntities.add(new ProcedureEntity(staticInitAst,typeBinding,childEntities,newContext));
  }
  Collection<CAstQualifier> quals=JDT2CAstUtils.mapModifiersToQualifiers(modifiers,isInterface,isAnnotation);
  return new ClassEntity(typeBinding,name,quals,memberEntities,makePosition(n));
}",0.9993705413344524
99830,"@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new JDTJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
    }
  }
;
  try {
    engine.setExclusionsFile(FileProvider.getFileFromPlugin(CoreTestsPlugin.getDefault(),CallGraphTestUtil.REGRESSION_EXCLUSIONS).getAbsolutePath());
  }
 catch (  IOException e) {
    Assert.assertFalse(""String_Node_Str"",true);
  }
  return engine;
}","@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new JDTJavaSourceAnalysisEngine(JDTJavaIRTests.PROJECT_NAME){
    @Override protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
    }
  }
;
  try {
    engine.setExclusionsFile(FileProvider.getFileFromPlugin(CoreTestsPlugin.getDefault(),CallGraphTestUtil.REGRESSION_EXCLUSIONS).getAbsolutePath());
  }
 catch (  IOException e) {
    Assert.assertFalse(""String_Node_Str"",true);
  }
  return engine;
}",0.9721175584024114
99831,"protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
}","@Override protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
}",0.9742268041237112
99832,"protected void populateScope(JavaSourceAnalysisEngine engine,Collection<String> sources,List<String> libs) throws IOException {
  IDEIRTestUtil.populateScope(projectName,engine,sources,libs);
}","@Override protected void populateScope(JavaSourceAnalysisEngine engine,Collection<String> sources,List<String> libs) throws IOException {
  IDEIRTestUtil.populateScope(projectName,(JDTJavaSourceAnalysisEngine)engine,sources,libs);
}",0.908235294117647
99833,"@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new JDTJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
    }
  }
;
  try {
    engine.setExclusionsFile(FileProvider.getFileFromPlugin(CoreTestsPlugin.getDefault(),CallGraphTestUtil.REGRESSION_EXCLUSIONS).getAbsolutePath());
  }
 catch (  IOException e) {
    Assert.assertFalse(""String_Node_Str"",true);
  }
  return engine;
}","@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new JDTJavaSourceAnalysisEngine(PROJECT_NAME){
    @Override protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
    }
  }
;
  try {
    engine.setExclusionsFile(FileProvider.getFileFromPlugin(CoreTestsPlugin.getDefault(),CallGraphTestUtil.REGRESSION_EXCLUSIONS).getAbsolutePath());
  }
 catch (  IOException e) {
    Assert.assertFalse(""String_Node_Str"",true);
  }
  return engine;
}",0.9832317073170732
99834,"protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
}","@Override protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
}",0.9742268041237112
99835,"protected void populateScope(JavaSourceAnalysisEngine engine,Collection<String> sources,List<String> libs) throws IOException {
  IDEIRTestUtil.populateScope(projectName,engine,sources,libs);
}","@Override protected void populateScope(JavaSourceAnalysisEngine engine,Collection<String> sources,List<String> libs) throws IOException {
  IDEIRTestUtil.populateScope(projectName,(JDTJavaSourceAnalysisEngine)engine,sources,libs);
}",0.908235294117647
99836,"public static void populateScope(String projectName,JavaSourceAnalysisEngine engine,Collection<String> sources,List<String> libs) throws IOException {
}","public static void populateScope(String projectName,JDTJavaSourceAnalysisEngine engine,Collection<String> sources,List<String> libs) throws IOException {
}",0.990228013029316
99837,"protected IClassLoader makeNewClassLoader(ClassLoaderReference classLoaderReference,IClassHierarchy cha,IClassLoader parent,AnalysisScope scope) throws IOException {
  if (classLoaderReference.equals(JavaSourceAnalysisScope.SOURCE)) {
    ClassLoaderImpl cl=new JDTSourceLoaderImpl(classLoaderReference,parent,getExclusions(),cha);
    cl.init(scope.getModules(classLoaderReference));
    return cl;
  }
 else {
    return super.makeNewClassLoader(classLoaderReference,cha,parent,scope);
  }
}","protected IClassLoader makeNewClassLoader(ClassLoaderReference classLoaderReference,IClassHierarchy cha,IClassLoader parent,AnalysisScope scope) throws IOException {
  if (classLoaderReference.equals(JavaSourceAnalysisScope.SOURCE)) {
    ClassLoaderImpl cl=makeSourceLoader(classLoaderReference,cha,parent);
    cl.init(scope.getModules(classLoaderReference));
    return cl;
  }
 else {
    return super.makeNewClassLoader(classLoaderReference,cha,parent,scope);
  }
}",0.909657320872274
99838,"@SuppressWarnings(""String_Node_Str"") public void loadAllSources(Set modules){
}","public void loadAllSources(Set modules){
}",0.6942148760330579
99839,"protected void loadAllSources(Set<ModuleEntry> modules){
  getTranslator().loadAllSources(modules);
  fTypeMap=null;
}","protected void loadAllSources(Set<ModuleEntry> modules){
  getTranslator().loadAllSources(modules);
}",0.9223744292237442
99840,"/** 
 * Add any exceptional edges generated by the last instruction in a basic block.
 * @param last the last instruction in a basic block.
 */
protected void addExceptionalEdges(IInstruction last){
  IClassHierarchy cha=getMethod().getClassHierarchy();
  if (last.isPEI()) {
    Collection<TypeReference> exceptionTypes=null;
    boolean goToAllHandlers=false;
    ExceptionHandler[] hs=getExceptionHandlers();
    if (last instanceof ThrowInstruction) {
      goToAllHandlers=true;
    }
 else {
      if (hs != null && hs.length > 0) {
        IClassLoader loader=getMethod().getDeclaringClass().getClassLoader();
        BytecodeLanguage l=(BytecodeLanguage)loader.getLanguage();
        exceptionTypes=l.getImplicitExceptionTypes(last);
        if (last instanceof IInvokeInstruction) {
          IInvokeInstruction call=(IInvokeInstruction)last;
          exceptionTypes=HashSetFactory.make(exceptionTypes);
          MethodReference target=MethodReference.findOrCreate(l,loader.getReference(),call.getClassType(),call.getMethodName(),call.getMethodSignature());
          try {
            exceptionTypes.addAll(l.inferInvokeExceptions(target,cha));
          }
 catch (          InvalidClassFileException e) {
            e.printStackTrace();
            Assertions.UNREACHABLE();
          }
        }
      }
    }
    if (hs != null && hs.length > 0) {
      if (!goToAllHandlers) {
        exceptionTypes=HashSetFactory.make(exceptionTypes);
      }
      boolean needEdgeToExitForAllHandlers=true;
      for (int j=0; j < hs.length; j++) {
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + hs[j]);
        }
        BasicBlock b=getBlockForInstruction(hs[j].getHandler());
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + b);
        }
        if (goToAllHandlers) {
          if (DEBUG) {
            System.err.println(""String_Node_Str"" + b);
          }
          addExceptionalEdgeTo(b);
          if (hs[j].getCatchClass() == null) {
            needEdgeToExitForAllHandlers=false;
          }
        }
 else {
          TypeReference caughtException=null;
          if (hs[j].getCatchClass() != null) {
            ClassLoaderReference loader=ShrikeCFG.this.getMethod().getDeclaringClass().getReference().getClassLoader();
            caughtException=ShrikeUtil.makeTypeReference(loader,hs[j].getCatchClass());
            if (DEBUG) {
              System.err.println(""String_Node_Str"" + caughtException);
            }
            IClass caughtClass=cha.lookupClass(caughtException);
            if (caughtClass == null) {
              addExceptionalEdgeTo(b);
              Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
              caughtException=null;
            }
          }
 else {
            if (DEBUG) {
              System.err.println(""String_Node_Str"");
            }
            if (!exceptionTypes.isEmpty()) {
              addExceptionalEdgeTo(b);
              exceptionTypes.clear();
              caughtException=null;
            }
          }
          if (caughtException != null) {
            IClass caughtClass=cha.lookupClass(caughtException);
            ArrayList<TypeReference> caught=new ArrayList<TypeReference>(exceptionTypes.size());
            for (            TypeReference t : exceptionTypes) {
              if (t != null) {
                IClass klass=cha.lookupClass(t);
                if (klass == null) {
                  Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
                  addExceptionalEdgeTo(b);
                }
 else {
                  boolean subtype1=cha.isSubclassOf(klass,caughtClass);
                  if (subtype1 || cha.isSubclassOf(caughtClass,klass)) {
                    addExceptionalEdgeTo(b);
                    if (subtype1) {
                      caught.add(t);
                    }
                  }
                }
              }
            }
            exceptionTypes.removeAll(caught);
          }
        }
      }
      if ((exceptionTypes == null && needEdgeToExitForAllHandlers) || (exceptionTypes != null && !exceptionTypes.isEmpty())) {
        BasicBlock exit=exit();
        addExceptionalEdgeTo(exit);
      }
    }
 else {
      BasicBlock exit=exit();
      addExceptionalEdgeTo(exit);
    }
  }
}","/** 
 * Add any exceptional edges generated by the last instruction in a basic block.
 * @param last the last instruction in a basic block.
 */
protected void addExceptionalEdges(IInstruction last){
  IClassHierarchy cha=getMethod().getClassHierarchy();
  if (last.isPEI()) {
    Collection<TypeReference> exceptionTypes=null;
    boolean goToAllHandlers=false;
    ExceptionHandler[] hs=getExceptionHandlers();
    if (last instanceof ThrowInstruction) {
      goToAllHandlers=true;
    }
 else {
      if (hs != null && hs.length > 0) {
        IClassLoader loader=getMethod().getDeclaringClass().getClassLoader();
        BytecodeLanguage l=(BytecodeLanguage)loader.getLanguage();
        exceptionTypes=l.getImplicitExceptionTypes(last);
        if (last instanceof IInvokeInstruction) {
          IInvokeInstruction call=(IInvokeInstruction)last;
          exceptionTypes=HashSetFactory.make(exceptionTypes);
          MethodReference target=MethodReference.findOrCreate(l,loader.getReference(),call.getClassType(),call.getMethodName(),call.getMethodSignature());
          try {
            exceptionTypes.addAll(l.inferInvokeExceptions(target,cha));
          }
 catch (          InvalidClassFileException e) {
            e.printStackTrace();
            Assertions.UNREACHABLE();
          }
        }
      }
    }
    if (hs != null && hs.length > 0) {
      if (!goToAllHandlers) {
        exceptionTypes=HashSetFactory.make(exceptionTypes);
      }
      boolean needEdgeToExitForAllHandlers=true;
      for (int j=0; j < hs.length; j++) {
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + hs[j]);
        }
        BasicBlock b=getBlockForInstruction(hs[j].getHandler());
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + b);
        }
        if (goToAllHandlers) {
          if (DEBUG) {
            System.err.println(""String_Node_Str"" + b);
          }
          addExceptionalEdgeTo(b);
          if (hs[j].getCatchClass() == null) {
            needEdgeToExitForAllHandlers=false;
            break;
          }
        }
 else {
          TypeReference caughtException=null;
          if (hs[j].getCatchClass() != null) {
            ClassLoaderReference loader=ShrikeCFG.this.getMethod().getDeclaringClass().getReference().getClassLoader();
            caughtException=ShrikeUtil.makeTypeReference(loader,hs[j].getCatchClass());
            if (DEBUG) {
              System.err.println(""String_Node_Str"" + caughtException);
            }
            IClass caughtClass=cha.lookupClass(caughtException);
            if (caughtClass == null) {
              addExceptionalEdgeTo(b);
              Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
              caughtException=null;
            }
          }
 else {
            if (DEBUG) {
              System.err.println(""String_Node_Str"");
            }
            if (!exceptionTypes.isEmpty()) {
              addExceptionalEdgeTo(b);
              exceptionTypes.clear();
              caughtException=null;
            }
          }
          if (caughtException != null) {
            IClass caughtClass=cha.lookupClass(caughtException);
            ArrayList<TypeReference> caught=new ArrayList<TypeReference>(exceptionTypes.size());
            for (            TypeReference t : exceptionTypes) {
              if (t != null) {
                IClass klass=cha.lookupClass(t);
                if (klass == null) {
                  Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
                  addExceptionalEdgeTo(b);
                }
 else {
                  boolean subtype1=cha.isSubclassOf(klass,caughtClass);
                  if (subtype1 || cha.isSubclassOf(caughtClass,klass)) {
                    addExceptionalEdgeTo(b);
                    if (subtype1) {
                      caught.add(t);
                    }
                  }
                }
              }
            }
            exceptionTypes.removeAll(caught);
          }
        }
      }
      if ((exceptionTypes == null && needEdgeToExitForAllHandlers) || (exceptionTypes != null && !exceptionTypes.isEmpty())) {
        BasicBlock exit=exit();
        addExceptionalEdgeTo(exit);
      }
    }
 else {
      BasicBlock exit=exit();
      addExceptionalEdgeTo(exit);
    }
  }
}",0.9978067644003232
99841,"/** 
 * Build an IR, then check integrity on two flavors of CFG
 */
private void doMethod(String methodSig){
  try {
    AnalysisScope scope=AnalysisScopeReader.makePrimordialScope(FileProvider.getFile(CallGraphTestUtil.REGRESSION_EXCLUSIONS));
    ClassHierarchy cha=ClassHierarchy.make(scope);
    MethodReference mr=StringStuff.makeMethodReference(Language.JAVA,methodSig);
    IMethod m=cha.resolveMethod(mr);
    if (m == null) {
      Assertions.UNREACHABLE(""String_Node_Str"" + mr);
    }
    AnalysisOptions options=new AnalysisOptions();
    AnalysisCache cache=new AnalysisCache();
    options.getSSAOptions().setPiNodePolicy(SSAOptions.getAllBuiltInPiNodes());
    IR ir=cache.getSSACache().findOrCreateIR(m,Everywhere.EVERYWHERE,options.getSSAOptions());
    ControlFlowGraph<SSAInstruction,ISSABasicBlock> cfg=ir.getControlFlowGraph();
    try {
      GraphIntegrity.check(cfg);
    }
 catch (    UnsoundGraphException e) {
      e.printStackTrace();
      System.err.println(ir);
      Assert.assertTrue(""String_Node_Str"" + methodSig,false);
    }
    try {
      GraphIntegrity.check(cfg);
    }
 catch (    UnsoundGraphException e) {
      e.printStackTrace();
      System.err.println(ir);
      System.err.println(cfg);
      Assert.assertTrue(""String_Node_Str"" + methodSig,false);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    Assertions.UNREACHABLE();
  }
}","/** 
 * Build an IR, then check integrity on two flavors of CFG
 */
private void doMethod(String methodSig){
  try {
    MethodReference mr=StringStuff.makeMethodReference(Language.JAVA,methodSig);
    IMethod m=cha.resolveMethod(mr);
    if (m == null) {
      Assertions.UNREACHABLE(""String_Node_Str"" + mr);
    }
    AnalysisOptions options=new AnalysisOptions();
    AnalysisCache cache=new AnalysisCache();
    options.getSSAOptions().setPiNodePolicy(SSAOptions.getAllBuiltInPiNodes());
    IR ir=cache.getSSACache().findOrCreateIR(m,Everywhere.EVERYWHERE,options.getSSAOptions());
    ControlFlowGraph<SSAInstruction,ISSABasicBlock> cfg=ir.getControlFlowGraph();
    try {
      GraphIntegrity.check(cfg);
    }
 catch (    UnsoundGraphException e) {
      e.printStackTrace();
      System.err.println(ir);
      Assert.assertTrue(""String_Node_Str"" + methodSig,false);
    }
    try {
      GraphIntegrity.check(cfg);
    }
 catch (    UnsoundGraphException e) {
      e.printStackTrace();
      System.err.println(ir);
      System.err.println(cfg);
      Assert.assertTrue(""String_Node_Str"" + methodSig,false);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    Assertions.UNREACHABLE();
  }
}",0.931391337677271
99842,"/** 
 * Add any exceptional edges generated by the last instruction in a basic block.
 * @param last the last instruction in a basic block.
 */
protected void addExceptionalEdges(IInstruction last){
  IClassHierarchy cha=getMethod().getClassHierarchy();
  if (last.isPEI()) {
    Collection<TypeReference> exceptionTypes=null;
    boolean goToAllHandlers=false;
    ExceptionHandler[] hs=getExceptionHandlers();
    if (last instanceof ThrowInstruction) {
      goToAllHandlers=true;
    }
 else {
      if (hs != null && hs.length > 0) {
        IClassLoader loader=getMethod().getDeclaringClass().getClassLoader();
        BytecodeLanguage l=(BytecodeLanguage)loader.getLanguage();
        exceptionTypes=l.getImplicitExceptionTypes(last);
        if (last instanceof IInvokeInstruction) {
          IInvokeInstruction call=(IInvokeInstruction)last;
          exceptionTypes=HashSetFactory.make(exceptionTypes);
          MethodReference target=MethodReference.findOrCreate(l,loader.getReference(),call.getClassType(),call.getMethodName(),call.getMethodSignature());
          try {
            exceptionTypes.addAll(l.inferInvokeExceptions(target,cha));
          }
 catch (          InvalidClassFileException e) {
            e.printStackTrace();
            Assertions.UNREACHABLE();
          }
        }
      }
    }
    if (hs != null && hs.length > 0) {
      if (!goToAllHandlers) {
        exceptionTypes=HashSetFactory.make(exceptionTypes);
      }
      for (int j=0; j < hs.length; j++) {
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + hs[j]);
        }
        BasicBlock b=getBlockForInstruction(hs[j].getHandler());
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + b);
        }
        if (goToAllHandlers) {
          if (DEBUG) {
            System.err.println(""String_Node_Str"" + b);
          }
          addExceptionalEdgeTo(b);
        }
 else {
          TypeReference caughtException=null;
          if (hs[j].getCatchClass() != null) {
            ClassLoaderReference loader=ShrikeCFG.this.getMethod().getDeclaringClass().getReference().getClassLoader();
            caughtException=ShrikeUtil.makeTypeReference(loader,hs[j].getCatchClass());
            if (DEBUG) {
              System.err.println(""String_Node_Str"" + caughtException);
            }
            IClass caughtClass=cha.lookupClass(caughtException);
            if (caughtClass == null) {
              addExceptionalEdgeTo(b);
              Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
              caughtException=null;
            }
          }
 else {
            if (DEBUG) {
              System.err.println(""String_Node_Str"");
            }
            if (!exceptionTypes.isEmpty()) {
              addExceptionalEdgeTo(b);
              exceptionTypes.clear();
              caughtException=null;
            }
          }
          if (caughtException != null) {
            IClass caughtClass=cha.lookupClass(caughtException);
            ArrayList<TypeReference> caught=new ArrayList<TypeReference>(exceptionTypes.size());
            for (            TypeReference t : exceptionTypes) {
              if (t != null) {
                IClass klass=cha.lookupClass(t);
                if (klass == null) {
                  Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
                  addExceptionalEdgeTo(b);
                }
 else {
                  boolean subtype1=cha.isSubclassOf(klass,caughtClass);
                  if (subtype1 || cha.isSubclassOf(caughtClass,klass)) {
                    addExceptionalEdgeTo(b);
                    if (subtype1) {
                      caught.add(t);
                    }
                  }
                }
              }
            }
            exceptionTypes.removeAll(caught);
          }
        }
      }
      if (exceptionTypes == null || !exceptionTypes.isEmpty()) {
        BasicBlock exit=exit();
        addExceptionalEdgeTo(exit);
      }
    }
 else {
      BasicBlock exit=exit();
      addExceptionalEdgeTo(exit);
    }
  }
}","/** 
 * Add any exceptional edges generated by the last instruction in a basic block.
 * @param last the last instruction in a basic block.
 */
protected void addExceptionalEdges(IInstruction last){
  IClassHierarchy cha=getMethod().getClassHierarchy();
  if (last.isPEI()) {
    Collection<TypeReference> exceptionTypes=null;
    boolean goToAllHandlers=false;
    ExceptionHandler[] hs=getExceptionHandlers();
    if (last instanceof ThrowInstruction) {
      goToAllHandlers=true;
    }
 else {
      if (hs != null && hs.length > 0) {
        IClassLoader loader=getMethod().getDeclaringClass().getClassLoader();
        BytecodeLanguage l=(BytecodeLanguage)loader.getLanguage();
        exceptionTypes=l.getImplicitExceptionTypes(last);
        if (last instanceof IInvokeInstruction) {
          IInvokeInstruction call=(IInvokeInstruction)last;
          exceptionTypes=HashSetFactory.make(exceptionTypes);
          MethodReference target=MethodReference.findOrCreate(l,loader.getReference(),call.getClassType(),call.getMethodName(),call.getMethodSignature());
          try {
            exceptionTypes.addAll(l.inferInvokeExceptions(target,cha));
          }
 catch (          InvalidClassFileException e) {
            e.printStackTrace();
            Assertions.UNREACHABLE();
          }
        }
      }
    }
    if (hs != null && hs.length > 0) {
      if (!goToAllHandlers) {
        exceptionTypes=HashSetFactory.make(exceptionTypes);
      }
      boolean needEdgeToExitForAllHandlers=true;
      for (int j=0; j < hs.length; j++) {
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + hs[j]);
        }
        BasicBlock b=getBlockForInstruction(hs[j].getHandler());
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + b);
        }
        if (goToAllHandlers) {
          if (DEBUG) {
            System.err.println(""String_Node_Str"" + b);
          }
          addExceptionalEdgeTo(b);
          if (hs[j].getCatchClass() == null) {
            needEdgeToExitForAllHandlers=false;
          }
        }
 else {
          TypeReference caughtException=null;
          if (hs[j].getCatchClass() != null) {
            ClassLoaderReference loader=ShrikeCFG.this.getMethod().getDeclaringClass().getReference().getClassLoader();
            caughtException=ShrikeUtil.makeTypeReference(loader,hs[j].getCatchClass());
            if (DEBUG) {
              System.err.println(""String_Node_Str"" + caughtException);
            }
            IClass caughtClass=cha.lookupClass(caughtException);
            if (caughtClass == null) {
              addExceptionalEdgeTo(b);
              Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
              caughtException=null;
            }
          }
 else {
            if (DEBUG) {
              System.err.println(""String_Node_Str"");
            }
            if (!exceptionTypes.isEmpty()) {
              addExceptionalEdgeTo(b);
              exceptionTypes.clear();
              caughtException=null;
            }
          }
          if (caughtException != null) {
            IClass caughtClass=cha.lookupClass(caughtException);
            ArrayList<TypeReference> caught=new ArrayList<TypeReference>(exceptionTypes.size());
            for (            TypeReference t : exceptionTypes) {
              if (t != null) {
                IClass klass=cha.lookupClass(t);
                if (klass == null) {
                  Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
                  addExceptionalEdgeTo(b);
                }
 else {
                  boolean subtype1=cha.isSubclassOf(klass,caughtClass);
                  if (subtype1 || cha.isSubclassOf(caughtClass,klass)) {
                    addExceptionalEdgeTo(b);
                    if (subtype1) {
                      caught.add(t);
                    }
                  }
                }
              }
            }
            exceptionTypes.removeAll(caught);
          }
        }
      }
      if ((exceptionTypes == null && needEdgeToExitForAllHandlers) || (exceptionTypes != null && !exceptionTypes.isEmpty())) {
        BasicBlock exit=exit();
        addExceptionalEdgeTo(exit);
      }
    }
 else {
      BasicBlock exit=exit();
      addExceptionalEdgeTo(exit);
    }
  }
}",0.9586992641822928
99843,"/** 
 * Return a view of the   {@link ControlFlowGraph} for an {@link IR}, which elides all exceptional exits from PEIs in the IR.
 */
public static Graph<ISSABasicBlock> sanitize(IR ir,IClassHierarchy cha) throws IllegalArgumentException, WalaException {
  if (ir == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ControlFlowGraph<SSAInstruction,ISSABasicBlock> cfg=ir.getControlFlowGraph();
  Graph<ISSABasicBlock> g=SlowSparseNumberedGraph.make();
  for (Iterator<? extends ISSABasicBlock> it=cfg.iterator(); it.hasNext(); ) {
    g.addNode(it.next());
  }
  for (Iterator it=cfg.iterator(); it.hasNext(); ) {
    ISSABasicBlock b=(ISSABasicBlock)it.next();
    for (Iterator it2=cfg.getSuccNodes(b); it2.hasNext(); ) {
      ISSABasicBlock b2=(ISSABasicBlock)it2.next();
      if (!b2.isExitBlock()) {
        g.addEdge(b,b2);
      }
    }
  }
  ISSABasicBlock exit=cfg.exit();
  for (Iterator it=cfg.getPredNodes(exit); it.hasNext(); ) {
    ISSABasicBlock b=(ISSABasicBlock)it.next();
    SSAInstruction s=ir.getInstructions()[b.getLastInstructionIndex()];
    if (s == null) {
      continue;
    }
    if (s instanceof SSAReturnInstruction || s instanceof SSAThrowInstruction) {
      g.addEdge(b,exit);
    }
 else {
      TypeReference[] exceptions=null;
      try {
        exceptions=computeExceptions(cha,ir,s);
      }
 catch (      InvalidClassFileException e1) {
        e1.printStackTrace();
        Assertions.UNREACHABLE();
      }
      for (Iterator it2=cfg.getSuccNodes(b); it2.hasNext(); ) {
        IBasicBlock c=(IBasicBlock)it2.next();
        if (c.isCatchBlock()) {
          SSACFG.ExceptionHandlerBasicBlock cb=(ExceptionHandlerBasicBlock)c;
          for (Iterator it3=cb.getCaughtExceptionTypes(); it3.hasNext(); ) {
            TypeReference ex=(TypeReference)it3.next();
            IClass exClass=cha.lookupClass(ex);
            if (exClass == null) {
              throw new WalaException(""String_Node_Str"" + ex);
            }
            for (int i=0; i < exceptions.length; i++) {
              if (exceptions[i] != null) {
                IClass exi=cha.lookupClass(exceptions[i]);
                if (exi == null) {
                  throw new WalaException(""String_Node_Str"" + exceptions[i]);
                }
                if (cha.isSubclassOf(exi,exClass)) {
                  exceptions[i]=null;
                }
              }
            }
          }
        }
      }
      TypeReference[] declared=null;
      try {
        declared=ir.getMethod().getDeclaredExceptions();
      }
 catch (      InvalidClassFileException e) {
        e.printStackTrace();
        Assertions.UNREACHABLE();
      }
      if (declared != null && exceptions != null) {
        for (int i=0; i < exceptions.length; i++) {
          boolean isDeclared=false;
          if (exceptions[i] != null) {
            IClass exi=cha.lookupClass(exceptions[i]);
            if (exi == null) {
              throw new WalaException(""String_Node_Str"" + exceptions[i]);
            }
            for (int j=0; j < declared.length; j++) {
              IClass dc=cha.lookupClass(declared[j]);
              if (dc == null) {
                throw new WalaException(""String_Node_Str"" + declared[j]);
              }
              if (cha.isSubclassOf(exi,dc)) {
                isDeclared=true;
                break;
              }
            }
            if (isDeclared) {
              g.addEdge(b,exit);
            }
          }
        }
      }
    }
  }
  return g;
}","/** 
 * Return a view of the   {@link ControlFlowGraph} for an {@link IR}, which elides all exceptional exits from PEIs in the IR.
 */
public static Graph<ISSABasicBlock> sanitize(IR ir,IClassHierarchy cha) throws IllegalArgumentException, WalaException {
  if (ir == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ControlFlowGraph<SSAInstruction,ISSABasicBlock> cfg=ir.getControlFlowGraph();
  Graph<ISSABasicBlock> g=SlowSparseNumberedGraph.make();
  for (Iterator<? extends ISSABasicBlock> it=cfg.iterator(); it.hasNext(); ) {
    g.addNode(it.next());
  }
  for (Iterator it=cfg.iterator(); it.hasNext(); ) {
    ISSABasicBlock b=(ISSABasicBlock)it.next();
    for (Iterator it2=cfg.getSuccNodes(b); it2.hasNext(); ) {
      ISSABasicBlock b2=(ISSABasicBlock)it2.next();
      if (!b2.isExitBlock()) {
        g.addEdge(b,b2);
      }
    }
  }
  ISSABasicBlock exit=cfg.exit();
  for (Iterator it=cfg.getPredNodes(exit); it.hasNext(); ) {
    ISSABasicBlock b=(ISSABasicBlock)it.next();
    SSAInstruction s=ir.getInstructions()[b.getLastInstructionIndex()];
    if (s == null) {
      continue;
    }
    if (s instanceof SSAReturnInstruction || s instanceof SSAThrowInstruction || cfg.getSuccNodeCount(b) == 1) {
      g.addEdge(b,exit);
    }
 else {
      TypeReference[] exceptions=null;
      try {
        exceptions=computeExceptions(cha,ir,s);
      }
 catch (      InvalidClassFileException e1) {
        e1.printStackTrace();
        Assertions.UNREACHABLE();
      }
      for (Iterator it2=cfg.getSuccNodes(b); it2.hasNext(); ) {
        IBasicBlock c=(IBasicBlock)it2.next();
        if (c.isCatchBlock()) {
          SSACFG.ExceptionHandlerBasicBlock cb=(ExceptionHandlerBasicBlock)c;
          for (Iterator it3=cb.getCaughtExceptionTypes(); it3.hasNext(); ) {
            TypeReference ex=(TypeReference)it3.next();
            IClass exClass=cha.lookupClass(ex);
            if (exClass == null) {
              throw new WalaException(""String_Node_Str"" + ex);
            }
            for (int i=0; i < exceptions.length; i++) {
              if (exceptions[i] != null) {
                IClass exi=cha.lookupClass(exceptions[i]);
                if (exi == null) {
                  throw new WalaException(""String_Node_Str"" + exceptions[i]);
                }
                if (cha.isSubclassOf(exi,exClass)) {
                  exceptions[i]=null;
                }
              }
            }
          }
        }
      }
      TypeReference[] declared=null;
      try {
        declared=ir.getMethod().getDeclaredExceptions();
      }
 catch (      InvalidClassFileException e) {
        e.printStackTrace();
        Assertions.UNREACHABLE();
      }
      if (declared != null && exceptions != null) {
        for (int i=0; i < exceptions.length; i++) {
          boolean isDeclared=false;
          if (exceptions[i] != null) {
            IClass exi=cha.lookupClass(exceptions[i]);
            if (exi == null) {
              throw new WalaException(""String_Node_Str"" + exceptions[i]);
            }
            for (int j=0; j < declared.length; j++) {
              IClass dc=cha.lookupClass(declared[j]);
              if (dc == null) {
                throw new WalaException(""String_Node_Str"" + declared[j]);
              }
              if (cha.isSubclassOf(exi,dc)) {
                isDeclared=true;
                break;
              }
            }
            if (isDeclared) {
              g.addEdge(b,exit);
            }
          }
        }
      }
    }
  }
  return g;
}",0.995481502400452
99844,"/** 
 * Initialize internal data structures
 * @throws IllegalArgumentException if modules is null
 */
public void init(List<Module> modules) throws IOException {
  if (modules == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Set<ModuleEntry> classModuleEntries=HashSetFactory.make();
  Set<ModuleEntry> sourceModuleEntries=HashSetFactory.make();
  for (Iterator<Module> it=modules.iterator(); it.hasNext(); ) {
    Module archive=it.next();
    Set<ModuleEntry> classFiles=getClassFiles(archive);
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + archive);
    }
    removeClassFiles(classFiles,classModuleEntries);
    for (Iterator<ModuleEntry> it2=classFiles.iterator(); it2.hasNext(); ) {
      ModuleEntry file=it2.next();
      classModuleEntries.add(file);
    }
    Set<ModuleEntry> sourceFiles=getSourceFiles(archive);
    for (Iterator<ModuleEntry> it2=sourceFiles.iterator(); it2.hasNext(); ) {
      ModuleEntry file=it2.next();
      sourceModuleEntries.add(file);
    }
  }
  loadAllClasses(classModuleEntries);
  loadAllSources(sourceModuleEntries);
}","/** 
 * Initialize internal data structures
 * @throws IllegalArgumentException if modules is null
 */
public void init(List<Module> modules) throws IOException {
  if (modules == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Set<ModuleEntry> classModuleEntries=HashSetFactory.make();
  Set<ModuleEntry> sourceModuleEntries=HashSetFactory.make();
  for (Iterator<Module> it=modules.iterator(); it.hasNext(); ) {
    Module archive=it.next();
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + archive);
    }
    if (OPTIMIZE_JAR_FILE_IO && archive instanceof JarFileModule) {
      getJarFileContents((JarFileModule)archive);
    }
    Set<ModuleEntry> classFiles=getClassFiles(archive);
    removeClassFiles(classFiles,classModuleEntries);
    Set<ModuleEntry> sourceFiles=getSourceFiles(archive);
    Map<String,Object> allClassAndSourceFileContents=null;
    if (OPTIMIZE_JAR_FILE_IO) {
    }
    loadAllClasses(classFiles,allClassAndSourceFileContents);
    loadAllSources(sourceFiles);
    for (Iterator<ModuleEntry> it2=classFiles.iterator(); it2.hasNext(); ) {
      ModuleEntry file=it2.next();
      classModuleEntries.add(file);
    }
    for (Iterator<ModuleEntry> it2=sourceFiles.iterator(); it2.hasNext(); ) {
      ModuleEntry file=it2.next();
      sourceModuleEntries.add(file);
    }
  }
}",0.6871711857547551
99845,"/** 
 * Set up the set of classes loaded by this object.
 */
private void loadAllClasses(Collection<ModuleEntry> moduleEntries){
  for (Iterator<ModuleEntry> it=moduleEntries.iterator(); it.hasNext(); ) {
    ModuleEntry entry=it.next();
    if (!entry.isClassFile()) {
      continue;
    }
    String className=entry.getClassName().replace('.','/');
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + className);
    }
    if (exclusions != null && exclusions.contains(className)) {
      if (DEBUG_LEVEL > 0) {
        System.err.println(""String_Node_Str"" + className);
      }
      continue;
    }
    ShrikeClassReaderHandle reader=new ShrikeClassReaderHandle(entry);
    className=""String_Node_Str"" + className;
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + className);
    }
    try {
      TypeName T=TypeName.string2TypeName(className);
      if (loadedClasses.get(T) != null) {
        Warnings.add(MultipleImplementationsWarning.create(className));
      }
 else       if (parent != null && parent.lookupClass(T) != null) {
        Warnings.add(MultipleImplementationsWarning.create(className));
      }
 else {
        ShrikeClass klass=new ShrikeClass(reader,this,cha);
        if (klass.getReference().getName().equals(T)) {
          loadedClasses.put(T,klass);
          if (DEBUG_LEVEL > 1) {
            System.err.println(""String_Node_Str"" + T + ""String_Node_Str"");
          }
        }
 else {
          Warnings.add(InvalidClassFile.create(className));
        }
      }
    }
 catch (    InvalidClassFileException e) {
      if (DEBUG_LEVEL > 0) {
        System.err.println(""String_Node_Str"" + className + ""String_Node_Str"");
      }
      Warnings.add(InvalidClassFile.create(className));
    }
  }
}","/** 
 * Set up the set of classes loaded by this object.
 */
private void loadAllClasses(Collection<ModuleEntry> moduleEntries,Map<String,Object> fileContents){
  for (Iterator<ModuleEntry> it=moduleEntries.iterator(); it.hasNext(); ) {
    ModuleEntry entry=it.next();
    if (!entry.isClassFile()) {
      continue;
    }
    String className=entry.getClassName().replace('.','/');
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + className);
    }
    if (exclusions != null && exclusions.contains(className)) {
      if (DEBUG_LEVEL > 0) {
        System.err.println(""String_Node_Str"" + className);
      }
      continue;
    }
    ShrikeClassReaderHandle entryReader=new ShrikeClassReaderHandle(entry);
    className=""String_Node_Str"" + className;
    if (DEBUG_LEVEL > 0) {
      System.err.println(""String_Node_Str"" + className);
    }
    try {
      TypeName T=TypeName.string2TypeName(className);
      if (loadedClasses.get(T) != null) {
        Warnings.add(MultipleImplementationsWarning.create(className));
      }
 else       if (parent != null && parent.lookupClass(T) != null) {
        Warnings.add(MultipleImplementationsWarning.create(className));
      }
 else {
        ShrikeClassReaderHandle reader=entryReader;
        if (fileContents != null) {
          final Object contents=fileContents.get(entry.getName());
          if (contents != null) {
            reader=new ByteArrayReaderHandle(entry,(byte[])contents);
          }
        }
        ShrikeClass tmpKlass=new ShrikeClass(reader,this,cha);
        if (tmpKlass.getReference().getName().equals(T)) {
          loadedClasses.put(T,new ShrikeClass(entryReader,this,cha));
          if (DEBUG_LEVEL > 1) {
            System.err.println(""String_Node_Str"" + T + ""String_Node_Str"");
          }
        }
 else {
          Warnings.add(InvalidClassFile.create(className));
        }
      }
    }
 catch (    InvalidClassFileException e) {
      if (DEBUG_LEVEL > 0) {
        System.err.println(""String_Node_Str"" + className + ""String_Node_Str"");
      }
      Warnings.add(InvalidClassFile.create(className));
    }
  }
}",0.9051768323936444
99846,"@Test public void testTestCD5() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  AnalysisScope scope=findOrCreateAnalysisScope();
  IClassHierarchy cha=findOrCreateCHA(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.SLICE_TESTCD5);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphBuilder builder=Util.makeZeroOneCFABuilder(options,new AnalysisCache(),cha,scope);
  CallGraph cg=builder.makeCallGraph(options,null);
  CGNode main=findMainMethod(cg);
  Statement s=new MethodEntryStatement(main);
  System.err.println(""String_Node_Str"" + s);
  Collection<Statement> slice=Slicer.computeForwardSlice(s,cg,builder.getPointerAnalysis(),DataDependenceOptions.NONE,ControlDependenceOptions.FULL);
  dumpSlice(slice);
  Assert.assertTrue(slice.size() > 1);
}","@Test public void testTestCD5() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  AnalysisScope scope=findOrCreateAnalysisScope();
  IClassHierarchy cha=findOrCreateCHA(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.SLICE_TESTCD5);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphBuilder builder=Util.makeZeroOneCFABuilder(options,new AnalysisCache(),cha,scope);
  CallGraph cg=builder.makeCallGraph(options,null);
  CGNode main=findMainMethod(cg);
  Statement s=new MethodEntryStatement(main);
  System.err.println(""String_Node_Str"" + s);
  Collection<Statement> slice=Slicer.computeForwardSlice(s,cg,builder.getPointerAnalysis(),DataDependenceOptions.NONE,ControlDependenceOptions.NO_EXCEPTIONAL_EDGES);
  dumpSlice(slice);
  Assert.assertTrue(slice.size() > 1);
}",0.9880823401950164
99847,"public void setPc(int pc){
  Integer lineNum=pcToLine.get(pc);
  if (lineNum != null) {
    irLines.ensureIndexIsVisible(lineNum);
    irLines.setSelectedIndex(lineNum);
  }
}","public void setPc(int pc){
  Integer lineNum=pcToLine.get(pc);
  if (lineNum != null) {
    irLines.ensureIndexIsVisible(lineNum);
    irLines.setSelectedIndex(lineNum);
  }
 else {
    removeSelection();
  }
}",0.9090909090909092
99848,"public void setIRAndPc(IR ir,int pc){
  setIR(ir);
  if (pc != NA) {
    setPc(pc);
  }
 else {
    int curSelectedIndex=irLines.getSelectedIndex();
    irLines.removeSelectionInterval(curSelectedIndex,curSelectedIndex);
  }
}","public void setIRAndPc(IR ir,int pc){
  setIR(ir);
  if (pc != NA) {
    setPc(pc);
  }
 else {
    removeSelection();
  }
}",0.7085714285714285
99849,"public void setSource(URL url,int sourceLine){
  sourceCodeLocation.setText(""String_Node_Str"" + url);
  loadSource(url);
  if (sourceLine != IrViewer.NA) {
    sourceCodeLines.ensureIndexIsVisible(sourceLine - 1);
    sourceCodeLines.setSelectedIndex(sourceLine - 1);
    sourceCodeLines.validate();
  }
}","public void setSource(URL url,int sourceLine){
  boolean succsess=loadSource(url);
  if (succsess) {
    sourceCodeLocation.setText(""String_Node_Str"" + url);
    if (sourceLine != IrViewer.NA) {
      sourceCodeLines.ensureIndexIsVisible(sourceLine - 1);
      sourceCodeLines.setSelectedIndex(sourceLine - 1);
      sourceCodeLines.validate();
    }
  }
 else {
    sourceCodeLocation.setText(""String_Node_Str"" + url);
  }
}",0.7890410958904109
99850,"public void removeSource(){
  sourceURL=null;
  sourceCodeLocation=new JTextField(""String_Node_Str"");
  sourceCodeLinesList.clear();
  sourceCodeLines.validate();
}","public void removeSource(){
  sourceURL=null;
  sourceCodeLocation.setText(""String_Node_Str"");
  sourceCodeLinesList.clear();
  sourceCodeLines.validate();
}",0.9595015576323987
99851,"public void handleSimpleTag(HTML.Tag t,MutableAttributeSet a,int pos){
  System.out.println(""String_Node_Str"" + t);
  if (script) {
    try {
      writeEmbeddedScript(""String_Node_Str"" + t);
      Enumeration names=a.getAttributeNames();
      while (names.hasMoreElements()) {
        Object name=names.nextElement();
        Object val=a.getAttribute(name);
        writeEmbeddedScript(""String_Node_Str"" + name + ""String_Node_Str""+ val+ ""String_Node_Str"");
      }
      writeEmbeddedScript(""String_Node_Str"" + t + ""String_Node_Str"");
    }
 catch (    IOException e) {
    }
  }
 else {
    String nm=createElement(t,a);
    endElement(nm);
  }
}","public void handleSimpleTag(HTML.Tag t,MutableAttributeSet a,int pos){
  System.out.println(""String_Node_Str"" + t);
  if (script) {
  }
 else {
    String nm=createElement(t,a,pos);
    endElement(nm);
  }
}",0.4737456242707117
99852,"protected String createElement(HTML.Tag t,MutableAttributeSet a){
  String tag=t.toString().toUpperCase();
  if (tag.equals(""String_Node_Str"")) {
    Object l=a.getAttribute(HTML.Attribute.LANGUAGE);
    if (l == null || l.toString().toUpperCase().indexOf(""String_Node_Str"") < 0) {
      Object value=a.getAttribute(HTML.Attribute.SRC);
      if (value != null) {
        try {
          URL scriptSrc=new URL(input,value.toString());
          InputStreamReader scriptReader=new InputStreamReader(scriptSrc.openConnection().getInputStream());
          int read;
          char[] buffer=new char[1024];
          while ((read=scriptReader.read(buffer)) != -1) {
            writeEmbeddedScript(buffer,read);
          }
          embeddedScriptFile.flush();
          scriptReader.close();
        }
 catch (        IOException e) {
          System.out.println(""String_Node_Str"" + value);
        }
      }
 else {
        System.out.println(""String_Node_Str"");
        script=true;
      }
    }
  }
  String varName=null;
  Enumeration enu=a.getAttributeNames();
  while (enu.hasMoreElements()) {
    Object attrObj=enu.nextElement();
    String attr=attrObj.toString();
    String value=a.getAttribute(attrObj).toString();
    if (attr.equalsIgnoreCase(""String_Node_Str"")) {
      varName=value;
      break;
    }
  }
  if (varName == null) {
    varName=""String_Node_Str"" + (counter++);
  }
  String cons=constructors.get(tag);
  if (cons == null)   cons=""String_Node_Str"";
  try {
    writeElement(t,a,tag,cons,varName);
    domTreeFile.write(""String_Node_Str"");
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  return varName;
}","protected String createElement(HTML.Tag t,MutableAttributeSet a,int pos){
  String tag=t.toString().toUpperCase();
  if (tag.equals(""String_Node_Str"")) {
    Object l=a.getAttribute(HTML.Attribute.LANGUAGE);
    if (l == null || l.toString().toUpperCase().indexOf(""String_Node_Str"") < 0) {
      Object value=a.getAttribute(HTML.Attribute.SRC);
      if (value != null) {
        try {
          URL scriptSrc=new URL(input,value.toString());
          InputStreamReader scriptReader=new InputStreamReader(scriptSrc.openConnection().getInputStream());
          int read;
          char[] buffer=new char[1024];
          while ((read=scriptReader.read(buffer)) != -1) {
            writeEmbeddedScript(buffer,read);
          }
          embeddedScriptFile.flush();
          scriptReader.close();
        }
 catch (        IOException e) {
          System.out.println(""String_Node_Str"" + value);
        }
      }
 else {
        System.out.println(""String_Node_Str"");
        script=true;
        scriptStart=pos;
      }
    }
  }
  String varName=null;
  Enumeration enu=a.getAttributeNames();
  while (enu.hasMoreElements()) {
    Object attrObj=enu.nextElement();
    String attr=attrObj.toString();
    String value=a.getAttribute(attrObj).toString();
    if (attr.equalsIgnoreCase(""String_Node_Str"")) {
      varName=value;
      break;
    }
  }
  if (varName == null) {
    varName=""String_Node_Str"" + (counter++);
  }
  String cons=constructors.get(tag);
  if (cons == null)   cons=""String_Node_Str"";
  try {
    writeElement(t,a,tag,cons,varName);
    domTreeFile.write(""String_Node_Str"");
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  return varName;
}",0.9903197418597828
99853,"public void handleEndTag(HTML.Tag t,int pos){
  if (t.toString().toUpperCase().equals(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"");
    try {
      writeEmbeddedScript(""String_Node_Str"");
    }
 catch (    IOException e) {
    }
    script=false;
  }
  endElement(stack.pop());
}","public void handleEndTag(HTML.Tag t,int pos){
  if (t.toString().toUpperCase().equals(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"");
    if (script)     try {
      int scriptEnd=pos;
      InputStreamReader script=new InputStreamReader(input.openStream());
      char[] buf=new char[scriptEnd];
      script.read(buf);
      String s=String.valueOf(buf,scriptStart,scriptEnd - scriptStart);
      writeEmbeddedScript(s.substring(s.indexOf('>') + 1));
    }
 catch (    IOException e) {
    }
    script=false;
  }
  endElement(stack.pop());
}",0.6542491268917345
99854,"private void writeEmbeddedScript(String text) throws IOException {
  embeddedScriptFile.write(text);
  embeddedScriptFile.write(""String_Node_Str"");
}","private void writeEmbeddedScript(String text) throws IOException {
  embeddedScriptFile.write(text);
}",0.8127490039840638
99855,"public void handleStartTag(HTML.Tag t,MutableAttributeSet a,int pos){
  String varName=createElement(t,a);
  stack.push(varName);
}","public void handleStartTag(HTML.Tag t,MutableAttributeSet a,int pos){
  String varName=createElement(t,a,pos);
  stack.push(varName);
}",0.9849624060150376
99856,"public boolean isExit(Statement n){
switch (n.getKind()) {
case PARAM_CALLEE:
case HEAP_PARAM_CALLEE:
case PHI:
case PI:
case NORMAL_RET_CALLER:
case PARAM_CALLER:
case HEAP_RET_CALLER:
case NORMAL:
case EXC_RET_CALLER:
case METHOD_ENTRY:
case CATCH:
    return false;
case HEAP_RET_CALLEE:
case EXC_RET_CALLEE:
case NORMAL_RET_CALLEE:
case METHOD_EXIT:
  return true;
default :
Assertions.UNREACHABLE(n.toString());
return false;
}
}","public boolean isExit(Statement n){
switch (n.getKind()) {
case PARAM_CALLEE:
case HEAP_PARAM_CALLEE:
case HEAP_PARAM_CALLER:
case PHI:
case PI:
case NORMAL_RET_CALLER:
case PARAM_CALLER:
case HEAP_RET_CALLER:
case NORMAL:
case EXC_RET_CALLER:
case METHOD_ENTRY:
case CATCH:
    return false;
case HEAP_RET_CALLEE:
case EXC_RET_CALLEE:
case NORMAL_RET_CALLEE:
case METHOD_EXIT:
  return true;
default :
Assertions.UNREACHABLE(n.toString());
return false;
}
}",0.9730941704035876
99857,"public HTMLEditorKit.ParserCallback createCallback(URL input,FileWriter domTreeFile,FileWriter embeddedScriptFile,FileWriter entrypointFile){
  return new HTMLCallback(input,domTreeFile,embeddedScriptFile,entrypointFile);
}","public HTMLCallback createCallback(URL input,FileWriter domTreeFile,FileWriter embeddedScriptFile,FileWriter entrypointFile){
  return new HTMLCallback(input,domTreeFile,embeddedScriptFile,entrypointFile);
}",0.9627906976744186
99858,"public void generate(URL input,File outFile) throws IOException {
  InputStreamReader fr=getStream(input);
  FileWriter out=new FileWriter(outFile);
  FileWriter out1=new FileWriter(temp1);
  FileWriter out2=new FileWriter(temp2);
  FileWriter out3=new FileWriter(temp3);
  ParserDelegator pd=new ParserDelegator();
  HTMLEditorKit.ParserCallback cb=callbackFactory.createCallback(input,out1,out2,out3);
  pd.parse(fr,cb,ignoreCharset);
  out1.close();
  out2.close();
  out3.close();
  out.write(""String_Node_Str"" + input + ""String_Node_Str"");
  writeRegion(out,""String_Node_Str"",temp2);
  writeRegion(out,""String_Node_Str"",temp1);
  out.write(""String_Node_Str"");
  writeRegion(out,""String_Node_Str"",temp3);
  out.write(""String_Node_Str"");
  generateTrailer(out,cb);
  out.close();
}","public void generate(URL input,File outFile) throws IOException {
  InputStreamReader fr=getStream(input);
  FileWriter out=new FileWriter(outFile);
  FileWriter out1=new FileWriter(temp1);
  FileWriter out2=new FileWriter(temp2);
  FileWriter out3=new FileWriter(temp3);
  ParserDelegator pd=new ParserDelegator();
  HTMLCallback cb=callbackFactory.createCallback(input,out1,out2,out3);
  pd.parse(fr,cb,ignoreCharset);
  out1.flush();
  out1.close();
  out2.flush();
  out2.close();
  out3.flush();
  out3.close();
  out.write(""String_Node_Str"" + input + ""String_Node_Str"");
  writeRegion(out,""String_Node_Str"",temp2);
  writeRegion(out,""String_Node_Str"",temp1);
  out.write(""String_Node_Str"");
  writeRegion(out,""String_Node_Str"",temp3);
  out.write(""String_Node_Str"");
  generateTrailer(out,cb);
  out.close();
}",0.96
99859,"protected String createElement(HTML.Tag t,MutableAttributeSet a){
  String tag=t.toString().toUpperCase();
  if (tag.equals(""String_Node_Str"")) {
    Object l=a.getAttribute(HTML.Attribute.LANGUAGE);
    if (l == null || l.toString().toUpperCase().indexOf(""String_Node_Str"") < 0) {
      Object value=a.getAttribute(HTML.Attribute.SRC);
      if (value != null) {
        try {
          URL scriptSrc=new URL(input,value.toString());
          InputStreamReader scriptReader=new InputStreamReader(scriptSrc.openConnection().getInputStream());
          int read;
          char[] buffer=new char[1024];
          while ((read=scriptReader.read(buffer)) != -1) {
            writeEmbeddedScript(buffer);
            writeEmbeddedScript(""String_Node_Str"");
          }
          scriptReader.close();
        }
 catch (        IOException e) {
          System.out.println(""String_Node_Str"" + value);
        }
      }
 else {
        System.out.println(""String_Node_Str"");
        script=true;
      }
    }
  }
  String varName=null;
  Enumeration enu=a.getAttributeNames();
  while (enu.hasMoreElements()) {
    Object attrObj=enu.nextElement();
    String attr=attrObj.toString();
    String value=a.getAttribute(attrObj).toString();
    if (attr.equalsIgnoreCase(""String_Node_Str"")) {
      varName=value;
      break;
    }
  }
  if (varName == null) {
    varName=""String_Node_Str"" + (counter++);
  }
  String cons=constructors.get(tag);
  if (cons == null)   cons=""String_Node_Str"";
  try {
    writeElement(t,a,tag,cons,varName);
    domTreeFile.write(""String_Node_Str"");
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  return varName;
}","protected String createElement(HTML.Tag t,MutableAttributeSet a){
  String tag=t.toString().toUpperCase();
  if (tag.equals(""String_Node_Str"")) {
    Object l=a.getAttribute(HTML.Attribute.LANGUAGE);
    if (l == null || l.toString().toUpperCase().indexOf(""String_Node_Str"") < 0) {
      Object value=a.getAttribute(HTML.Attribute.SRC);
      if (value != null) {
        try {
          URL scriptSrc=new URL(input,value.toString());
          InputStreamReader scriptReader=new InputStreamReader(scriptSrc.openConnection().getInputStream());
          int read;
          char[] buffer=new char[1024];
          while ((read=scriptReader.read(buffer)) != -1) {
            writeEmbeddedScript(buffer,read);
          }
          embeddedScriptFile.flush();
          scriptReader.close();
        }
 catch (        IOException e) {
          System.out.println(""String_Node_Str"" + value);
        }
      }
 else {
        System.out.println(""String_Node_Str"");
        script=true;
      }
    }
  }
  String varName=null;
  Enumeration enu=a.getAttributeNames();
  while (enu.hasMoreElements()) {
    Object attrObj=enu.nextElement();
    String attr=attrObj.toString();
    String value=a.getAttribute(attrObj).toString();
    if (attr.equalsIgnoreCase(""String_Node_Str"")) {
      varName=value;
      break;
    }
  }
  if (varName == null) {
    varName=""String_Node_Str"" + (counter++);
  }
  String cons=constructors.get(tag);
  if (cons == null)   cons=""String_Node_Str"";
  try {
    writeElement(t,a,tag,cons,varName);
    domTreeFile.write(""String_Node_Str"");
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  return varName;
}",0.9719350073855244
99860,"private void getScript(char[] data){
  if (script) {
    try {
      writeEmbeddedScript(data);
    }
 catch (    IOException e) {
      System.out.println(""String_Node_Str"");
    }
  }
}","private void getScript(char[] data){
  if (script) {
    try {
      writeEmbeddedScript(data,data.length);
    }
 catch (    IOException e) {
      System.out.println(""String_Node_Str"");
    }
  }
}",0.9689119170984456
99861,"protected void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] caughtTypes,boolean hasMonitorOp,AstLexicalInformation LI,DebuggingInformation debugInfo){
  if (DEBUG)   System.err.println((""String_Node_Str"" + N));
  String fnName=composeEntityName(definingContext,N);
  if (DEBUG)   System.err.println(cfg);
  symtab.getConstant(""String_Node_Str"");
  symtab.getConstant(""String_Node_Str"");
  for (int i=0; i < 15; i++) {
    symtab.getConstant(i);
  }
  ((JavaScriptLoader)loader).defineCodeBodyCode(""String_Node_Str"" + fnName,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
}","protected void defineFunction(CAstEntity N,WalkContext definingContext,AbstractCFG cfg,SymbolTable symtab,boolean hasCatchBlock,TypeReference[][] caughtTypes,boolean hasMonitorOp,AstLexicalInformation LI,DebuggingInformation debugInfo){
  if (DEBUG)   System.err.println((""String_Node_Str"" + N));
  String fnName=composeEntityName(definingContext,N);
  if (DEBUG)   System.err.println(cfg);
  symtab.getConstant(""String_Node_Str"");
  symtab.getConstant(""String_Node_Str"");
  for (int i=0; i < 20; i++) {
    symtab.getConstant(i);
  }
  ((JavaScriptLoader)loader).defineCodeBodyCode(""String_Node_Str"" + fnName,cfg,symtab,hasCatchBlock,caughtTypes,hasMonitorOp,LI,debugInfo);
}",0.9970414201183432
99862,"protected void doFieldWrite(WalkContext context,int receiver,CAstNode elt,CAstNode parent,int rval){
  this.visit(elt,context,this);
  if (elt.getKind() == CAstNode.CONSTANT && elt.getValue() instanceof String) {
    context.cfg().addInstruction(((JSInstructionFactory)insts).PutInstruction(receiver,rval,(String)elt.getValue()));
  }
 else {
    context.cfg().addInstruction(((JSInstructionFactory)insts).PropertyWrite(receiver,getValue(elt),rval));
  }
}","protected void doFieldWrite(WalkContext context,int receiver,CAstNode elt,CAstNode parent,int rval){
}",0.3655913978494624
99863,"/** 
 * Figure out what a classpath entry means and add it to the appropriate set of modules
 */
private void resolveClasspathEntry(IClasspathEntry entry,Loader loader,boolean includeSource,boolean cpeFromMainProject) throws JavaModelException, IOException {
  IClasspathEntry e=JavaCore.getResolvedClasspathEntry(entry);
  if (alreadyResolved.contains(e)) {
    return;
  }
 else {
    alreadyResolved.add(e);
  }
  if (e.getEntryKind() == IClasspathEntry.CPE_CONTAINER) {
    IClasspathContainer cont=JavaCore.getClasspathContainer(entry.getPath(),project);
    IClasspathEntry[] entries=cont.getClasspathEntries();
    resolveClasspathEntries(entries,cont.getKind() == IClasspathContainer.K_APPLICATION ? loader : Loader.PRIMORDIAL,includeSource,false);
  }
 else   if (e.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
    File file=makeAbsolute(e.getPath()).toFile();
    JarFile j;
    try {
      j=new JarFile(file);
    }
 catch (    ZipException z) {
      return;
    }
catch (    FileNotFoundException z) {
      return;
    }
    if (isPrimordialJarFile(j)) {
      List<Module> s=MapUtil.findOrCreateList(modules,loader);
      s.add(file.isDirectory() ? (Module)new BinaryDirectoryTreeModule(file) : (Module)new JarFileModule(j));
    }
  }
 else   if (e.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
    if (includeSource) {
      List<Module> s=MapUtil.findOrCreateList(modules,Loader.APPLICATION);
      s.add(new EclipseSourceDirectoryTreeModule(e.getPath()));
    }
 else     if (e.getOutputLocation() != null) {
      File output=makeAbsolute(e.getOutputLocation()).toFile();
      List<Module> s=MapUtil.findOrCreateList(modules,cpeFromMainProject ? Loader.APPLICATION : loader);
      s.add(new BinaryDirectoryTreeModule(output));
    }
  }
 else   if (e.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
    IPath projectPath=makeAbsolute(e.getPath());
    IWorkspace ws=ResourcesPlugin.getWorkspace();
    IWorkspaceRoot root=ws.getRoot();
    IProject project=(IProject)root.getContainerForLocation(projectPath);
    try {
      if (project.hasNature(JavaCore.NATURE_ID)) {
        IJavaProject javaProject=JavaCore.create(project);
        if (isPluginProject(javaProject)) {
          resolvePluginClassPath(javaProject.getProject(),includeSource);
        }
        resolveClasspathEntries(javaProject.getRawClasspath(),loader,scopeType == AnalysisScopeType.SOURCE_FOR_PROJ_AND_LINKED_PROJS ? includeSource : false,false);
        File output=makeAbsolute(javaProject.getOutputLocation()).toFile();
        List<Module> s=MapUtil.findOrCreateList(modules,loader);
        if (!includeSource) {
          s.add(new BinaryDirectoryTreeModule(output));
        }
      }
    }
 catch (    CoreException e1) {
      e1.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + e);
  }
}","/** 
 * Figure out what a classpath entry means and add it to the appropriate set of modules
 */
private void resolveClasspathEntry(IClasspathEntry entry,Loader loader,boolean includeSource,boolean cpeFromMainProject) throws JavaModelException, IOException {
  IClasspathEntry e=JavaCore.getResolvedClasspathEntry(entry);
  if (alreadyResolved.contains(e)) {
    return;
  }
 else {
    alreadyResolved.add(e);
  }
  if (e.getEntryKind() == IClasspathEntry.CPE_CONTAINER) {
    IClasspathContainer cont=JavaCore.getClasspathContainer(entry.getPath(),project);
    IClasspathEntry[] entries=cont.getClasspathEntries();
    resolveClasspathEntries(entries,cont.getKind() == IClasspathContainer.K_APPLICATION ? loader : Loader.PRIMORDIAL,includeSource,false);
  }
 else   if (e.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
    File file=makeAbsolute(e.getPath()).toFile();
    JarFile j;
    try {
      j=new JarFile(file);
    }
 catch (    ZipException z) {
      return;
    }
catch (    FileNotFoundException z) {
      return;
    }
    if (isPrimordialJarFile(j)) {
      List<Module> s=MapUtil.findOrCreateList(modules,loader);
      s.add(file.isDirectory() ? (Module)new BinaryDirectoryTreeModule(file) : (Module)new JarFileModule(j));
    }
  }
 else   if (e.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
    if (includeSource) {
      List<Module> s=MapUtil.findOrCreateList(modules,Loader.APPLICATION);
      s.add(new EclipseSourceDirectoryTreeModule(e.getPath()));
    }
 else     if (e.getOutputLocation() != null) {
      File output=makeAbsolute(e.getOutputLocation()).toFile();
      List<Module> s=MapUtil.findOrCreateList(modules,cpeFromMainProject ? Loader.APPLICATION : loader);
      s.add(new BinaryDirectoryTreeModule(output));
    }
  }
 else   if (e.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
    IPath projectPath=makeAbsolute(e.getPath());
    IWorkspace ws=ResourcesPlugin.getWorkspace();
    IWorkspaceRoot root=ws.getRoot();
    IProject project=(IProject)root.getContainerForLocation(projectPath);
    try {
      if (project.hasNature(JavaCore.NATURE_ID)) {
        IJavaProject javaProject=JavaCore.create(project);
        if (isPluginProject(javaProject)) {
          resolvePluginClassPath(javaProject.getProject(),includeSource);
        }
        resolveClasspathEntries(javaProject.getRawClasspath(),loader,scopeType == AnalysisScopeType.SOURCE_FOR_PROJ_AND_LINKED_PROJS ? includeSource : false,false);
        File output=makeAbsolute(javaProject.getOutputLocation()).toFile();
        List<Module> s=MapUtil.findOrCreateList(modules,loader);
        if (!includeSource) {
          if (output.exists()) {
            s.add(new BinaryDirectoryTreeModule(output));
          }
        }
      }
    }
 catch (    CoreException e1) {
      e1.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + e);
  }
}",0.9918923581162672
99864,"@SuppressWarnings(""String_Node_Str"") void processJSCall(CGNode caller,JavaScriptInvoke instruction,CGNode target,InstanceKey function,InstanceKey constParams[][],PointerKey uniqueCatchKey){
  caller.addTarget(instruction.getCallSite(),target);
  if (!getBuilder().haveAlreadyVisited(target)) {
    getBuilder().markDiscovered(target);
  }
  IR sourceIR=getBuilder().getCFAContextInterpreter().getIR(caller);
  SymbolTable sourceST=sourceIR.getSymbolTable();
  IR targetIR=getBuilder().getCFAContextInterpreter().getIR(target);
  SymbolTable targetST=targetIR.getSymbolTable();
  int av=-1;
  for (int v=0; v <= targetST.getMaxValueNumber(); v++) {
    String[] vns=targetIR.getLocalNames(1,v);
    for (int n=0; vns != null && n < vns.length; n++) {
      if (""String_Node_Str"".equals(vns[n])) {
        av=v;
        break;
      }
    }
  }
  int paramCount=targetST.getParameterValueNumbers().length;
  int argCount=instruction.getNumberOfParameters();
  for (int i=0; i < Math.min(paramCount,argCount); i++) {
    int fn=targetST.getConstant(i);
    PointerKey F=(i == 0) ? getBuilder().getFilteredPointerKeyForLocal(target,targetST.getParameter(i),function) : getBuilder().getPointerKeyForLocal(target,targetST.getParameter(i));
    if (constParams != null && constParams[i] != null) {
      for (int j=0; j < constParams[i].length; j++) {
        system.newConstraint(F,constParams[i][j]);
      }
      if (av != -1)       newFieldWrite(target,av,fn,constParams[i]);
    }
 else {
      PointerKey A=getBuilder().getPointerKeyForLocal(caller,instruction.getUse(i));
      system.newConstraint(F,(F instanceof FilteredPointerKey) ? getBuilder().filterOperator : assignOperator,A);
      if (av != -1)       newFieldWrite(target,av,fn,F);
    }
  }
  if (paramCount < argCount) {
    if (av != -1) {
      for (int i=paramCount; i < argCount; i++) {
        int fn=targetST.getConstant(i);
        if (constParams != null && constParams[i] != null) {
          newFieldWrite(target,av,fn,constParams[i]);
        }
 else {
          PointerKey A=getBuilder().getPointerKeyForLocal(caller,instruction.getUse(i));
          newFieldWrite(target,av,fn,A);
        }
      }
    }
  }
 else   if (argCount < paramCount) {
    int nullvn=sourceST.getNullConstant();
    DefUse sourceDU=getBuilder().getCFAContextInterpreter().getDU(caller);
    InstanceKey[] nullkeys=getInvariantContents(sourceST,sourceDU,caller,nullvn);
    for (int i=argCount; i < paramCount; i++) {
      PointerKey F=getBuilder().getPointerKeyForLocal(target,targetST.getParameter(i));
      for (int k=0; k < nullkeys.length; k++) {
        system.newConstraint(F,nullkeys[k]);
      }
    }
  }
  if (av != -1) {
    int svn=targetST.getConstant(argCount);
    int lnv=targetST.getConstant(""String_Node_Str"");
    newFieldWrite(target,av,lnv,svn);
  }
  if (instruction.getDef(0) != -1) {
    PointerKey RF=getBuilder().getPointerKeyForReturnValue(target);
    PointerKey RA=getBuilder().getPointerKeyForLocal(caller,instruction.getDef(0));
    system.newConstraint(RA,assignOperator,RF);
  }
  PointerKey EF=getBuilder().getPointerKeyForExceptionalReturnValue(target);
  if (SHORT_CIRCUIT_SINGLE_USES && uniqueCatchKey != null) {
    system.newConstraint(uniqueCatchKey,assignOperator,EF);
  }
 else {
    PointerKey EA=getBuilder().getPointerKeyForLocal(caller,instruction.getDef(1));
    system.newConstraint(EA,assignOperator,EF);
  }
}","@SuppressWarnings(""String_Node_Str"") void processJSCall(CGNode caller,JavaScriptInvoke instruction,CGNode target,InstanceKey function,InstanceKey constParams[][],PointerKey uniqueCatchKey){
  caller.addTarget(instruction.getCallSite(),target);
  if (!getBuilder().haveAlreadyVisited(target)) {
    getBuilder().markDiscovered(target);
  }
  IR sourceIR=getBuilder().getCFAContextInterpreter().getIR(caller);
  SymbolTable sourceST=sourceIR.getSymbolTable();
  IR targetIR=getBuilder().getCFAContextInterpreter().getIR(target);
  SymbolTable targetST=targetIR.getSymbolTable();
  int av=-1;
  for (int v=0; v <= targetST.getMaxValueNumber(); v++) {
    String[] vns=targetIR.getLocalNames(1,v);
    for (int n=0; vns != null && n < vns.length; n++) {
      if (""String_Node_Str"".equals(vns[n])) {
        av=v;
        break;
      }
    }
  }
  int paramCount=targetST.getParameterValueNumbers().length;
  int argCount=instruction.getNumberOfParameters();
  for (int i=0; i < Math.min(paramCount,argCount); i++) {
    int fn=targetST.getConstant(i);
    PointerKey F=(i == 0) ? getBuilder().getFilteredPointerKeyForLocal(target,targetST.getParameter(i),function.getConcreteType()) : getBuilder().getPointerKeyForLocal(target,targetST.getParameter(i));
    if (constParams != null && constParams[i] != null) {
      for (int j=0; j < constParams[i].length; j++) {
        system.newConstraint(F,constParams[i][j]);
      }
      if (av != -1)       newFieldWrite(target,av,fn,constParams[i]);
    }
 else {
      PointerKey A=getBuilder().getPointerKeyForLocal(caller,instruction.getUse(i));
      system.newConstraint(F,(F instanceof FilteredPointerKey) ? getBuilder().filterOperator : assignOperator,A);
      if (av != -1)       newFieldWrite(target,av,fn,F);
    }
  }
  if (paramCount < argCount) {
    if (av != -1) {
      for (int i=paramCount; i < argCount; i++) {
        int fn=targetST.getConstant(i);
        if (constParams != null && constParams[i] != null) {
          newFieldWrite(target,av,fn,constParams[i]);
        }
 else {
          PointerKey A=getBuilder().getPointerKeyForLocal(caller,instruction.getUse(i));
          newFieldWrite(target,av,fn,A);
        }
      }
    }
  }
 else   if (argCount < paramCount) {
    int nullvn=sourceST.getNullConstant();
    DefUse sourceDU=getBuilder().getCFAContextInterpreter().getDU(caller);
    InstanceKey[] nullkeys=getInvariantContents(sourceST,sourceDU,caller,nullvn);
    for (int i=argCount; i < paramCount; i++) {
      PointerKey F=getBuilder().getPointerKeyForLocal(target,targetST.getParameter(i));
      for (int k=0; k < nullkeys.length; k++) {
        system.newConstraint(F,nullkeys[k]);
      }
    }
  }
  if (av != -1) {
    int svn=targetST.getConstant(argCount);
    int lnv=targetST.getConstant(""String_Node_Str"");
    newFieldWrite(target,av,lnv,svn);
  }
  if (instruction.getDef(0) != -1) {
    PointerKey RF=getBuilder().getPointerKeyForReturnValue(target);
    PointerKey RA=getBuilder().getPointerKeyForLocal(caller,instruction.getDef(0));
    system.newConstraint(RA,assignOperator,RF);
  }
  PointerKey EF=getBuilder().getPointerKeyForExceptionalReturnValue(target);
  if (SHORT_CIRCUIT_SINGLE_USES && uniqueCatchKey != null) {
    system.newConstraint(uniqueCatchKey,assignOperator,EF);
  }
 else {
    PointerKey EA=getBuilder().getPointerKeyForLocal(caller,instruction.getDef(1));
    system.newConstraint(EA,assignOperator,EF);
  }
}",0.9973714953271028
99865,"/** 
 * create a demand points-to analysis runner using a   {@link DemandPointerFlowGraph} as the underlying flow graph.
 * @see #make(CallGraph,HeapModel,MemoryAccessMap,IClassHierarchy,AnalysisOptions,StateMachineFactory,IFlowGraph)
 */
public static DemandRefinementPointsTo makeWithDefaultFlowGraph(CallGraph cg,HeapModel model,MemoryAccessMap mam,IClassHierarchy cha,AnalysisOptions options,StateMachineFactory<IFlowLabel> stateMachineFactory){
  return make(cg,new ThisFilteringHeapModel(model,cha),mam,cha,options,stateMachineFactory,new DemandPointerFlowGraph(cg,model,mam,cha));
}","/** 
 * create a demand points-to analysis runner
 * @param cg the underlying call graph for the analysis
 * @param model the heap model to be used for the analysis
 * @param mam indicates what code reads or writes each field
 * @param cha
 * @param options
 * @param stateMachineFactory factory for state machines to track additional properties like calling context
 */
public static DemandRefinementPointsTo makeWithDefaultFlowGraph(CallGraph cg,HeapModel model,MemoryAccessMap mam,IClassHierarchy cha,AnalysisOptions options,StateMachineFactory<IFlowLabel> stateMachineFactory){
  final ThisFilteringHeapModel thisFilteringHeapModel=new ThisFilteringHeapModel(model,cha);
  return new DemandRefinementPointsTo(cg,thisFilteringHeapModel,mam,cha,options,stateMachineFactory,new DemandPointerFlowGraph(cg,thisFilteringHeapModel,mam,cha));
}",0.2729181245626312
99866,"@Override public void visitCheckCast(SSACheckCastInstruction instruction){
  TypeAbstraction typeAbs=null;
  for (  TypeReference type : instruction.getDeclaredResultTypes()) {
    IClass klass=cha.lookupClass(type);
    if (klass == null) {
      typeAbs=BOTTOM;
    }
 else {
      if (typeAbs == null) {
        typeAbs=new ConeType(klass);
      }
 else {
        typeAbs=typeAbs.meet(new ConeType(klass));
      }
    }
  }
}","@Override public void visitCheckCast(SSACheckCastInstruction instruction){
  TypeAbstraction typeAbs=null;
  for (  TypeReference type : instruction.getDeclaredResultTypes()) {
    IClass klass=cha.lookupClass(type);
    if (klass == null) {
      typeAbs=BOTTOM;
    }
 else {
      if (typeAbs == null) {
        typeAbs=new ConeType(klass);
      }
 else {
        typeAbs=typeAbs.meet(new ConeType(klass));
      }
    }
  }
  result=new DeclaredTypeOperator(typeAbs);
}",0.9491150442477876
99867,"public static int countNormals(Collection<Statement> slice){
  int count=0;
  for (  Statement s : slice) {
    if (s.getKind().equals(Statement.Kind.NORMAL)) {
      NormalStatement ns=(NormalStatement)s;
      count++;
    }
  }
  return count;
}","public static int countNormals(Collection<Statement> slice){
  int count=0;
  for (  Statement s : slice) {
    if (s.getKind().equals(Statement.Kind.NORMAL)) {
      count++;
    }
  }
  return count;
}",0.9002217294900222
99868,"public static CGNode findMainMethod(CallGraph cg){
  Descriptor d=Descriptor.findOrCreateUTF8(""String_Node_Str"");
  Atom name=Atom.findOrCreateUnicodeAtom(""String_Node_Str"");
  for (Iterator<? extends CGNode> it=cg.getSuccNodes(cg.getFakeRootNode()); it.hasNext(); ) {
    CGNode n=it.next();
    if (n.getMethod().getName().equals(name) && n.getMethod().getDescriptor().equals(d)) {
      return n;
    }
  }
  Assertions.UNREACHABLE(""String_Node_Str"");
  return null;
}","public static CGNode findMainMethod(CallGraph cg){
  Descriptor d=Descriptor.findOrCreateUTF8(""String_Node_Str"");
  Atom name=Atom.findOrCreateUnicodeAtom(""String_Node_Str"");
  return findMethod(cg,d,name);
}",0.5331369661266568
99869,"/** 
 * Create nodes corresponding to <ul> <li> phi instructions <li> getCaughtExceptions </ul>
 */
private void createSpecialStatements(IR ir){
  for (Iterator<SSAInstruction> it=ir.iterateAllInstructions(); it.hasNext(); ) {
    SSAInstruction s=it.next();
    if (s instanceof SSAPhiInstruction) {
      delegate.addNode(new PhiStatement(node,(SSAPhiInstruction)s));
    }
 else     if (s instanceof SSAGetCaughtExceptionInstruction) {
      delegate.addNode(new GetCaughtExceptionStatement(node,(SSAGetCaughtExceptionInstruction)s));
    }
 else     if (s instanceof SSAPiInstruction) {
      delegate.addNode(new PiStatement(node,(SSAPiInstruction)s));
    }
  }
}","/** 
 * Create nodes corresponding to <ul> <li>phi instructions <li>getCaughtExceptions </ul>
 */
private void createSpecialStatements(IR ir){
  for (Iterator<SSAInstruction> it=ir.iterateAllInstructions(); it.hasNext(); ) {
    SSAInstruction s=it.next();
    if (s instanceof SSAPhiInstruction) {
      delegate.addNode(new PhiStatement(node,(SSAPhiInstruction)s));
    }
 else     if (s instanceof SSAGetCaughtExceptionInstruction) {
      delegate.addNode(new GetCaughtExceptionStatement(node,(SSAGetCaughtExceptionInstruction)s));
    }
 else     if (s instanceof SSAPiInstruction) {
      delegate.addNode(new PiStatement(node,(SSAPiInstruction)s));
    }
  }
}",0.998502994011976
99870,"/** 
 * Create nodes in the graph corresponding to ""normal"" (bytecode) instructions
 */
private void createNormalStatements(IR ir,Map<CGNode,OrdinalSet<PointerKey>> ref){
  SSAInstruction[] instructions=ir.getInstructions();
  for (int i=0; i < instructions.length; i++) {
    SSAInstruction s=instructions[i];
    if (s instanceof SSAGetCaughtExceptionInstruction) {
      continue;
    }
    if (s != null) {
      delegate.addNode(new NormalStatement(node,i));
    }
    if (s instanceof SSAAbstractInvokeInstruction) {
      addParamPassingStatements(i,ref,ir);
    }
  }
}","/** 
 * Create nodes in the graph corresponding to ""normal"" (bytecode) instructions
 */
private void createNormalStatements(IR ir,Map<CGNode,OrdinalSet<PointerKey>> ref){
  SSAInstruction[] instructions=ir.getInstructions();
  for (int i=0; i < instructions.length; i++) {
    SSAInstruction s=instructions[i];
    if (s instanceof SSAGetCaughtExceptionInstruction) {
      continue;
    }
    if (s != null) {
      final NormalStatement statement=new NormalStatement(node,i);
      delegate.addNode(statement);
      if (s instanceof SSAAbstractInvokeInstruction) {
        callSite2Statement.put(((SSAAbstractInvokeInstruction)s).getCallSite(),statement);
        addParamPassingStatements(i,ref,ir);
      }
    }
  }
}",0.8323076923076923
99871,"public Iterator<? extends Statement> getCallSites(Statement r,PDG callee){
switch (r.getKind()) {
case EXC_RET_CALLER:
{
      ExceptionalReturnCaller n=(ExceptionalReturnCaller)r;
      SSAAbstractInvokeInstruction call=n.getInstruction();
      PDG pdg=getProcOf(r);
      return pdg.getCallerParamStatements(call).iterator();
    }
case NORMAL_RET_CALLER:
{
    NormalReturnCaller n=(NormalReturnCaller)r;
    SSAAbstractInvokeInstruction call=n.getInstruction();
    PDG pdg=getProcOf(r);
    return pdg.getCallerParamStatements(call).iterator();
  }
case HEAP_RET_CALLER:
{
  HeapStatement.HeapReturnCaller n=(HeapStatement.HeapReturnCaller)r;
  SSAAbstractInvokeInstruction call=n.getCall();
  PDG pdg=getProcOf(r);
  return pdg.getCallerParamStatements(call).iterator();
}
default :
Assertions.UNREACHABLE(r.getKind().toString());
return null;
}
}","public Iterator<? extends Statement> getCallSites(Statement r,PDG callee){
switch (r.getKind()) {
case EXC_RET_CALLER:
{
      ExceptionalReturnCaller n=(ExceptionalReturnCaller)r;
      SSAAbstractInvokeInstruction call=n.getInstruction();
      PDG pdg=getProcOf(r);
      return pdg.getCallStatements(call).iterator();
    }
case NORMAL_RET_CALLER:
{
    NormalReturnCaller n=(NormalReturnCaller)r;
    SSAAbstractInvokeInstruction call=n.getInstruction();
    PDG pdg=getProcOf(r);
    return pdg.getCallStatements(call).iterator();
  }
case HEAP_RET_CALLER:
{
  HeapStatement.HeapReturnCaller n=(HeapStatement.HeapReturnCaller)r;
  SSAAbstractInvokeInstruction call=n.getCall();
  PDG pdg=getProcOf(r);
  return pdg.getCallStatements(call).iterator();
}
default :
Assertions.UNREACHABLE(r.getKind().toString());
return null;
}
}",0.9875518672199172
99872,"public JDTJava15IRTests(){
  super(""String_Node_Str"",""String_Node_Str"");
}","public JDTJava15IRTests(){
  super(""String_Node_Str"");
}",0.8615384615384616
99873,"public JDTJavaIRTests(){
  super(""String_Node_Str"",""String_Node_Str"");
}","public JDTJavaIRTests(){
  super(""String_Node_Str"");
}",0.8571428571428571
99874,"public PolyglotJavaIRTests(){
  super(""String_Node_Str"");
}","public PolyglotJavaIRTests(){
  super(null);
}",0.819047619047619
99875,"protected String singleJavaPkgInputForTest(String pkgName){
  return pkgName + File.separator + getName().substring(4)+ ""String_Node_Str"";
}","protected String singleJavaPkgInputForTest(String pkgName){
  return pkgName + File.separator + getTestName().substring(4)+ ""String_Node_Str"";
}",0.9859154929577464
99876,"protected String singleInputForTest(){
  return getName().substring(4);
}","protected String singleInputForTest(){
  return getTestName().substring(4);
}",0.9733333333333334
99877,"protected String singleJavaInputForTest(){
  return getName().substring(4) + ""String_Node_Str"";
}","protected String singleJavaInputForTest(){
  return getTestName().substring(4) + ""String_Node_Str"";
}",0.9797979797979798
99878,"public IRTests(String name,String projectName){
  this.name=name;
  this.projectName=projectName;
}","protected IRTests(String projectName){
  this.projectName=projectName;
}",0.7602339181286549
99879,"protected String[] simplePkgTestEntryPoint(String pkgName){
  return new String[]{""String_Node_Str"" + pkgName + ""String_Node_Str""+ getName().substring(4)};
}","protected String[] simplePkgTestEntryPoint(String pkgName){
  return new String[]{""String_Node_Str"" + pkgName + ""String_Node_Str""+ getTestName().substring(4)};
}",0.9874213836477987
99880,"protected String[] simpleTestEntryPoint(){
  return new String[]{""String_Node_Str"" + getName().substring(4)};
}","protected String[] simpleTestEntryPoint(){
  return new String[]{""String_Node_Str"" + getTestName().substring(4)};
}",0.9823008849557522
99881,"public JLexTest(String name){
  super(name,null);
}","public JLexTest(){
  super(null);
}",0.813953488372093
99882,"public JavaIRTests(String name){
  this(name,null);
}","public JavaIRTests(){
  this(null);
}",0.8222222222222222
99883,"public NameAwareTestClassRunner(Class<?> klass) throws InitializationError {
  super(klass);
}","public NameAwareTestClassRunner(Class<?> klass){
  super(klass);
}",0.825
99884,"public SyncDuplicatorTest(String name){
  super(name,null);
}","public SyncDuplicatorTest(){
  super(null);
}",0.8490566037735849
99885,"@Test public void testFlowsToLocals() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  doFlowsToSizeTest(TestInfo.FLOWSTO_TEST_LOCALS,1);
}","@Test public void testFlowsToLocals() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  doFlowsToSizeTest(TestInfo.FLOWSTO_TEST_LOCALS,4);
}",0.994475138121547
99886,"/** 
 * get all the pointer keys that some instance key can flow to
 */
public Pair<PointsToResult,Collection<PointerKey>> getFlowsTo(InstanceKey ik){
}","/** 
 * get all the pointer keys that some instance key can flow to
 * @return a pair consisting of (1) a {@link PointsToResult} indicating whether a flows-to set was computed, and (2) the lastcomputed flows-to set for the instance key (possibly <code>null</code> if no flows-to set could be computed in the budget)
 */
public Pair<PointsToResult,Collection<PointerKey>> getFlowsTo(InstanceKey ik){
}",0.5507246376811594
99887,"/** 
 * returns the instance key corresponding to the single allocation site of type FlowsToType
 */
private static InstanceKey getFlowsToInstanceKey(CGNode mainMethod,HeapModel heapModel){
}","/** 
 * returns the instance key corresponding to the single allocation site of type FlowsToType
 */
private InstanceKey getFlowsToInstanceKey(CGNode mainMethod,HeapModel heapModel){
}",0.9813333333333332
99888,"private Collection<PointerKey> getFlowsToSetToTest(String mainClass) throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  final DemandRefinementPointsTo dmp=makeDemandPointerAnalysis(mainClass);
  CGNode mainMethod=AbstractPtrTest.findMainMethod(dmp.getBaseCallGraph());
  InstanceKey keyToQuery=AbstractPtrTest.getFlowsToInstanceKey(mainMethod,dmp.getHeapModel());
  Collection<PointerKey> flowsTo=dmp.getFlowsTo(keyToQuery).snd;
  return flowsTo;
}","private Collection<PointerKey> getFlowsToSetToTest(String mainClass) throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  final DemandRefinementPointsTo dmp=makeDemandPointerAnalysis(mainClass);
  CGNode mainMethod=AbstractPtrTest.findMainMethod(dmp.getBaseCallGraph());
  InstanceKey keyToQuery=getFlowsToInstanceKey(mainMethod,dmp.getHeapModel());
  Collection<PointerKey> flowsTo=dmp.getFlowsTo(keyToQuery).snd;
  return flowsTo;
}",0.9833333333333332
99889,"@Override protected void compute(){
  InstanceKey ik=queriedIkAndState.getInstanceKey();
  g.addSubgraphForNode(((InstanceKeyWithNode)ik).getNode());
  for (  Object pred : Iterator2Iterable.make(g.getPredNodes(ik,NewLabel.v()))) {
    PointerKey predPk=(PointerKey)pred;
    PointerKeyAndState predPkAndState=new PointerKeyAndState(predPk,queriedIkAndState.getState());
    theFlowsToSet.add(predPkAndState);
    findOrCreate(pkToP2Set,predPkAndState).add(queriedIkAndStateNum);
    addToPToWorklist(predPkAndState);
  }
  worklistLoop();
}","@Override protected void compute(){
  InstanceKey ik=queriedIkAndState.getInstanceKey();
  g.addSubgraphForNode(((InstanceKeyWithNode)ik).getNode());
  for (  Object pred : Iterator2Iterable.make(g.getPredNodes(ik,NewLabel.v()))) {
    PointerKey predPk=(PointerKey)pred;
    PointerKeyAndState predPkAndState=new PointerKeyAndState(predPk,queriedIkAndState.getState());
    theFlowsToSet.add(predPkAndState);
    findOrCreate(pkToTrackedSet,predPkAndState).add(queriedIkAndStateNum);
    addToTrackedPToWorklist(predPkAndState);
  }
  worklistLoop();
}",0.9835466179159048
99890,"/** 
 * here, we want to add the graph unconditionally if pkAndState can point to the queried instance key
 */
@Override protected boolean calleeSubGraphMissingAndShouldNotBeAdded(boolean addGraphs,CGNode callee,PointerKeyAndState pkAndState){
  if (find(pkToP2Set,pkAndState).contains(queriedIkAndStateNum)) {
    return false;
  }
 else {
    return super.calleeSubGraphMissingAndShouldNotBeAdded(addGraphs,callee,pkAndState);
  }
}","/** 
 * when doing backward interprocedural propagation, is it true that we should not add a graph representation for a callee _and_ that the subgraph for the callee is missing?
 * @param addGraphs whether graphs should always be added
 * @param callee
 * @param pkAndState
 * @return
 */
protected boolean calleeSubGraphMissingAndShouldNotBeAdded(boolean addGraphs,CGNode callee,PointerKeyAndState pkAndState){
  return !addGraphs && !g.hasSubgraphForNode(callee);
}",0.3596004439511653
99891,"@Override protected void handleBackCopy(PointerKeyAndState curPkAndState,PointerKey predPk,IFlowLabel label){
  final MutableIntSet curPkP2Set=find(pkToP2Set,curPkAndState);
  if (curPkP2Set.contains(queriedIkAndStateNum)) {
    PointerKeyAndState predPkAndState=new PointerKeyAndState(predPk,stateMachine.transition(curPkAndState.getState(),label));
    if (addAllToP2Set(pkToP2Set,predPkAndState,curPkP2Set,label)) {
      theFlowsToSet.add(predPkAndState);
      addToPToWorklist(predPkAndState);
    }
  }
 else {
    super.handleBackCopy(curPkAndState,predPk,label);
  }
}","protected void handleBackCopy(PointerKeyAndState curPkAndState,PointerKey predPk,IFlowLabel label){
  for (  PointerKeyAndState predPkAndState : matchingPToQueried(curPkAndState,predPk,label)) {
    if (addAllToP2Set(pkToP2Set,predPkAndState,find(pkToP2Set,curPkAndState),label)) {
      addToPToWorklist(predPkAndState);
    }
  }
}",0.2967032967032967
99892,"/** 
 * Does the file name represent a .java file?
 * @param fileName name of a file
 * @return boolean
 * @throws IllegalArgumentException  if fileName is null
 */
public static boolean isSourceFile(String fileName){
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int suffixIndex=fileName.indexOf(""String_Node_Str"");
  if (suffixIndex > -1 && fileName.indexOf(CLASSPATH) == -1) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Does the file name represent a .java file?
 * @param fileName name of a file
 * @return boolean
 * @throws IllegalArgumentException if fileName is null
 */
public static boolean isSourceFile(String fileName){
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return fileName.endsWith(""String_Node_Str"");
}",0.7990373044524669
99893,"/** 
 * Does the file name represent a .class file?
 * @param fileName name of a file
 * @return boolean
 * @throws IllegalArgumentException  if fileName is null
 */
public static boolean isClassFile(String fileName){
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int suffixIndex=fileName.indexOf(CLASS_SUFFIX);
  if (suffixIndex > -1 && fileName.indexOf(CLASSPATH) == -1) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Does the file name represent a .class file?
 * @param fileName name of a file
 * @return boolean
 * @throws IllegalArgumentException if fileName is null
 */
public static boolean isClassFile(String fileName){
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return fileName.endsWith(CLASS_SUFFIX);
}",0.7965895249695494
99894,"/** 
 * Strip the "".class"" or "".java"" suffix from a file name TODO: generalize for all suffixes
 * @param fileName the file name
 * @throws IllegalArgumentException  if fileName is null
 */
public static String stripSuffix(String fileName){
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int suffixIndex=fileName.indexOf(CLASS_SUFFIX);
  suffixIndex=(suffixIndex > -1) ? suffixIndex : fileName.indexOf(""String_Node_Str"");
  if (suffixIndex > -1) {
    return fileName.substring(0,suffixIndex);
  }
 else {
    return fileName;
  }
}","/** 
 * Strip the "".class"" or "".java"" suffix from a file name TODO: generalize for all suffixes
 * @param fileName the file name
 * @throws IllegalArgumentException if fileName is null
 */
public static String stripSuffix(String fileName){
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int suffixIndex=fileName.indexOf(CLASS_SUFFIX);
  suffixIndex=(suffixIndex > -1) ? suffixIndex : fileName.indexOf(""String_Node_Str"");
  if (suffixIndex > -1) {
    return fileName.substring(0,suffixIndex);
  }
 else {
    return fileName;
  }
}",0.9991311902693312
99895,"/** 
 * Does the file name represent a .jar file?
 * @param fileName name of a file
 * @return boolean
 * @throws IllegalArgumentException  if fileName is null
 */
public static boolean isJarFile(String fileName){
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int suffixIndex=fileName.indexOf(JAR_SUFFIX);
  if (suffixIndex > -1) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Does the file name represent a .jar file?
 * @param fileName name of a file
 * @return boolean
 * @throws IllegalArgumentException if fileName is null
 */
public static boolean isJarFile(String fileName){
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return fileName.endsWith(JAR_SUFFIX);
}",0.8316062176165803
99896,"/** 
 * Does the file name represent a .war file?
 * @param fileName name of a file
 * @return boolean
 * @throws IllegalArgumentException  if fileName is null
 */
public static boolean isWarFile(String fileName){
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int suffixIndex=fileName.indexOf(WAR_SUFFIX);
  if (suffixIndex > -1) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Does the file name represent a .war file?
 * @param fileName name of a file
 * @return boolean
 * @throws IllegalArgumentException if fileName is null
 */
public static boolean isWarFile(String fileName){
  if (fileName == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return fileName.endsWith(WAR_SUFFIX);
}",0.8316062176165803
99897,"private DeclaredTypeOperator getPointerTypeOperator(TypeReference type){
  if (type.isPrimitiveType()) {
    return new DeclaredTypeOperator(PrimitiveType.getPrimitive(type));
  }
 else {
    IClass klass=cha.lookupClass(type);
    if (klass == null) {
      return new DeclaredTypeOperator(BOTTOM);
    }
 else {
      return new DeclaredTypeOperator(new ConeType(klass));
    }
  }
}","private DeclaredTypeOperator getPointerTypeOperator(TypeReference type){
  if (type.isPrimitiveType()) {
    return new DeclaredTypeOperator(language.getPrimitive(type));
  }
 else {
    IClass klass=cha.lookupClass(type);
    if (klass == null) {
      return new DeclaredTypeOperator(BOTTOM);
    }
 else {
      return new DeclaredTypeOperator(new ConeType(klass));
    }
  }
}",0.9751633986928104
99898,"@Override public void visitInvoke(SSAInvokeInstruction instruction){
  TypeReference type=instruction.getDeclaredResultType();
  if (type.isReferenceType()) {
    IClass klass=cha.lookupClass(type);
    if (klass == null) {
      result=new DeclaredTypeOperator(BOTTOM);
    }
 else {
      result=new DeclaredTypeOperator(new ConeType(klass));
    }
  }
 else   if (doPrimitives && type.isPrimitiveType()) {
    result=new DeclaredTypeOperator(PrimitiveType.getPrimitive(type));
  }
 else {
    result=null;
  }
}","@Override public void visitInvoke(SSAInvokeInstruction instruction){
  TypeReference type=instruction.getDeclaredResultType();
  if (type.isReferenceType()) {
    IClass klass=cha.lookupClass(type);
    if (klass == null) {
      result=new DeclaredTypeOperator(BOTTOM);
    }
 else {
      result=new DeclaredTypeOperator(new ConeType(klass));
    }
  }
 else   if (doPrimitives && type.isPrimitiveType()) {
    result=new DeclaredTypeOperator(language.getPrimitive(type));
  }
 else {
    result=null;
  }
}",0.981427174975562
99899,"@Override protected void initializeVariables(){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + ir.getMethod());
  }
  int[] parameterValueNumbers=ir.getParameterValueNumbers();
  for (int i=0; i < parameterValueNumbers.length; i++) {
    TypeVariable v=getVariable(parameterValueNumbers[i]);
    TypeReference t=ir.getParameterType(i);
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + parameterValueNumbers[i] + ""String_Node_Str""+ t);
    }
    if (t.isReferenceType()) {
      IClass klass=cha.lookupClass(t);
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + klass);
      }
      if (klass != null) {
        v.setType(new ConeType(klass));
      }
 else {
        v.setType(BOTTOM);
      }
    }
 else     if (doPrimitives) {
      v.setType(PrimitiveType.getPrimitive(t));
    }
  }
  SymbolTable st=ir.getSymbolTable();
  if (st != null) {
    for (int i=0; i <= st.getMaxValueNumber(); i++) {
      if (st.isConstant(i)) {
        TypeVariable v=getVariable(i);
        v.setType(getConstantType(i));
      }
    }
  }
  for (Iterator<SSAInstruction> it=ir.iterateNormalInstructions(); it.hasNext(); ) {
    SSAInstruction s=it.next();
    if (s instanceof SSAAbstractInvokeInstruction) {
      SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)s;
      TypeVariable v=getVariable(call.getException());
      Collection<TypeReference> defaultExceptions=call.getExceptionTypes();
      if (defaultExceptions.size() == 0) {
        continue;
      }
      Iterator<TypeReference> types=defaultExceptions.iterator();
      TypeReference t=types.next();
      IClass klass=cha.lookupClass(t);
      if (klass == null) {
        v.setType(BOTTOM);
      }
 else {
        v.setType(new PointType(klass));
      }
      while (types.hasNext()) {
        t=types.next();
        klass=cha.lookupClass(t);
        if (klass != null) {
          v.setType(v.getType().meet(new PointType(klass)));
        }
      }
      IMethod m=cha.resolveMethod(call.getDeclaredTarget());
      if (m != null) {
        TypeReference[] x=null;
        try {
          x=m.getDeclaredExceptions();
        }
 catch (        InvalidClassFileException e) {
          e.printStackTrace();
          Assertions.UNREACHABLE();
        }
catch (        UnsupportedOperationException e) {
          x=new TypeReference[]{language.getThrowableType()};
        }
        if (x != null) {
          for (int i=0; i < x.length; i++) {
            TypeReference tx=x[i];
            IClass tc=cha.lookupClass(tx);
            if (tc != null) {
              v.setType(v.getType().meet(new ConeType(tc)));
            }
          }
        }
      }
    }
  }
}","@Override protected void initializeVariables(){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + ir.getMethod());
  }
  int[] parameterValueNumbers=ir.getParameterValueNumbers();
  for (int i=0; i < parameterValueNumbers.length; i++) {
    TypeVariable v=getVariable(parameterValueNumbers[i]);
    TypeReference t=ir.getParameterType(i);
    if (DEBUG) {
      System.err.println(""String_Node_Str"" + parameterValueNumbers[i] + ""String_Node_Str""+ t);
    }
    if (t.isReferenceType()) {
      IClass klass=cha.lookupClass(t);
      if (DEBUG) {
        System.err.println(""String_Node_Str"" + klass);
      }
      if (klass != null) {
        v.setType(new ConeType(klass));
      }
 else {
        v.setType(BOTTOM);
      }
    }
 else     if (doPrimitives) {
      v.setType(language.getPrimitive(t));
    }
  }
  SymbolTable st=ir.getSymbolTable();
  if (st != null) {
    for (int i=0; i <= st.getMaxValueNumber(); i++) {
      if (st.isConstant(i)) {
        TypeVariable v=getVariable(i);
        v.setType(getConstantType(i));
      }
    }
  }
  for (Iterator<SSAInstruction> it=ir.iterateNormalInstructions(); it.hasNext(); ) {
    SSAInstruction s=it.next();
    if (s instanceof SSAAbstractInvokeInstruction) {
      SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)s;
      TypeVariable v=getVariable(call.getException());
      Collection<TypeReference> defaultExceptions=call.getExceptionTypes();
      if (defaultExceptions.size() == 0) {
        continue;
      }
      Iterator<TypeReference> types=defaultExceptions.iterator();
      TypeReference t=types.next();
      IClass klass=cha.lookupClass(t);
      if (klass == null) {
        v.setType(BOTTOM);
      }
 else {
        v.setType(new PointType(klass));
      }
      while (types.hasNext()) {
        t=types.next();
        klass=cha.lookupClass(t);
        if (klass != null) {
          v.setType(v.getType().meet(new PointType(klass)));
        }
      }
      IMethod m=cha.resolveMethod(call.getDeclaredTarget());
      if (m != null) {
        TypeReference[] x=null;
        try {
          x=m.getDeclaredExceptions();
        }
 catch (        InvalidClassFileException e) {
          e.printStackTrace();
          Assertions.UNREACHABLE();
        }
catch (        UnsupportedOperationException e) {
          x=new TypeReference[]{language.getThrowableType()};
        }
        if (x != null) {
          for (int i=0; i < x.length; i++) {
            TypeReference tx=x[i];
            IClass tc=cha.lookupClass(tx);
            if (tc != null) {
              v.setType(v.getType().meet(new ConeType(tc)));
            }
          }
        }
      }
    }
  }
}",0.9964611659526914
99900,"@Override public void visitGet(SSAGetInstruction instruction){
  TypeReference type=instruction.getDeclaredFieldType();
  if (doPrimitives && type.isPrimitiveType()) {
    result=new DeclaredTypeOperator(PrimitiveType.getPrimitive(type));
  }
 else {
    IClass klass=cha.lookupClass(type);
    if (klass == null) {
      result=new DeclaredTypeOperator(BOTTOM);
    }
 else {
      result=new DeclaredTypeOperator(new ConeType(klass));
    }
  }
}","@Override public void visitGet(SSAGetInstruction instruction){
  TypeReference type=instruction.getDeclaredFieldType();
  if (doPrimitives && type.isPrimitiveType()) {
    result=new DeclaredTypeOperator(language.getPrimitive(type));
  }
 else {
    IClass klass=cha.lookupClass(type);
    if (klass == null) {
      result=new DeclaredTypeOperator(BOTTOM);
    }
 else {
      result=new DeclaredTypeOperator(new ConeType(klass));
    }
  }
}",0.978675645342312
99901,"/** 
 * traverse the bundle description for an Eclipse project and populate the analysis scope accordingly
 */
private void resolvePluginClassPath(IProject p,boolean includeSource) throws CoreException, IOException {
  BundleDescription bd=findModel(p).getBundleDescription();
  for (int i=0; i < 3 && bd == null; i++) {
    try {
      Thread.sleep(5000);
    }
 catch (    InterruptedException e) {
    }
    bd=findModel(p).getBundleDescription();
  }
  if (bd == null) {
    throw new IllegalStateException(""String_Node_Str"" + p);
  }
  resolveBundleDescriptionClassPath(bd,Loader.APPLICATION,includeSource);
}","/** 
 * traverse the bundle description for an Eclipse project and populate the analysis scope accordingly
 */
private void resolvePluginClassPath(IProject p,boolean includeSource) throws CoreException, IOException {
  IPluginModelBase model=findModel(p);
  if (!model.isInSync() || model.isDisposed()) {
    model.load();
  }
  BundleDescription bd=model.getBundleDescription();
  for (int i=0; i < 3 && bd == null; i++) {
    try {
      Thread.sleep(5000);
    }
 catch (    InterruptedException e) {
    }
    bd=findModel(p).getBundleDescription();
  }
  if (bd == null) {
    throw new IllegalStateException(""String_Node_Str"" + p);
  }
  resolveBundleDescriptionClassPath(bd,Loader.APPLICATION,includeSource);
}",0.8940646130728775
99902,"/** 
 * Add any exceptional edges generated by the last instruction in a basic block.
 * @param last the last instruction in a basic block.
 */
protected void addExceptionalEdges(IInstruction last){
  IClassHierarchy cha=getMethod().getClassHierarchy();
  if (last.isPEI()) {
    Collection<TypeReference> exceptionTypes=null;
    boolean goToAllHandlers=false;
    ExceptionHandler[] hs=getExceptionHandlers();
    if (last instanceof ThrowInstruction) {
      goToAllHandlers=true;
    }
 else {
      if (hs != null && hs.length > 0) {
        IClassLoader loader=getMethod().getDeclaringClass().getClassLoader();
        BytecodeLanguage l=(BytecodeLanguage)loader.getLanguage();
        exceptionTypes=l.getImplicitExceptionTypes(last);
        if (last instanceof IInvokeInstruction) {
          IInvokeInstruction call=(IInvokeInstruction)last;
          exceptionTypes=HashSetFactory.make(exceptionTypes);
          MethodReference target=MethodReference.findOrCreate(l,loader.getReference(),call.getClassType(),call.getMethodName(),call.getMethodSignature());
          try {
            exceptionTypes.addAll(l.inferInvokeExceptions(target,cha));
          }
 catch (          InvalidClassFileException e) {
            e.printStackTrace();
            Assertions.UNREACHABLE();
          }
        }
      }
    }
    if (hs != null && hs.length > 0) {
      if (!goToAllHandlers) {
        exceptionTypes=HashSetFactory.make(exceptionTypes);
      }
      for (int j=0; j < hs.length; j++) {
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + hs[j]);
        }
        BasicBlock b=getBlockForInstruction(hs[j].getHandler());
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + b);
        }
        if (goToAllHandlers) {
          addExceptionalEdgeTo(b);
        }
 else {
          TypeReference caughtException=null;
          if (hs[j].getCatchClass() != null) {
            ClassLoaderReference loader=ShrikeCFG.this.getMethod().getDeclaringClass().getReference().getClassLoader();
            caughtException=ShrikeUtil.makeTypeReference(loader,hs[j].getCatchClass());
            if (DEBUG) {
              System.err.println(""String_Node_Str"" + caughtException);
            }
            IClass caughtClass=cha.lookupClass(caughtException);
            if (caughtClass == null) {
              addExceptionalEdgeTo(b);
              Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
              caughtException=null;
            }
          }
 else {
            addExceptionalEdgeTo(b);
            exceptionTypes.clear();
            caughtException=null;
          }
          if (caughtException != null) {
            IClass caughtClass=cha.lookupClass(caughtException);
            ArrayList<TypeReference> caught=new ArrayList<TypeReference>(exceptionTypes.size());
            for (            TypeReference t : exceptionTypes) {
              if (t != null) {
                IClass klass=cha.lookupClass(t);
                if (klass == null) {
                  Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
                  addExceptionalEdgeTo(b);
                }
 else {
                  boolean subtype1=cha.isSubclassOf(klass,caughtClass);
                  if (subtype1 || cha.isSubclassOf(caughtClass,klass)) {
                    addExceptionalEdgeTo(b);
                    if (subtype1) {
                      caught.add(t);
                    }
                  }
                }
              }
            }
            exceptionTypes.removeAll(caught);
          }
        }
      }
      if (exceptionTypes == null || !exceptionTypes.isEmpty()) {
        BasicBlock exit=exit();
        addExceptionalEdgeTo(exit);
      }
    }
 else {
      BasicBlock exit=exit();
      addExceptionalEdgeTo(exit);
    }
  }
}","/** 
 * Add any exceptional edges generated by the last instruction in a basic block.
 * @param last the last instruction in a basic block.
 */
protected void addExceptionalEdges(IInstruction last){
  IClassHierarchy cha=getMethod().getClassHierarchy();
  if (last.isPEI()) {
    Collection<TypeReference> exceptionTypes=null;
    boolean goToAllHandlers=false;
    ExceptionHandler[] hs=getExceptionHandlers();
    if (last instanceof ThrowInstruction) {
      goToAllHandlers=true;
    }
 else {
      if (hs != null && hs.length > 0) {
        IClassLoader loader=getMethod().getDeclaringClass().getClassLoader();
        BytecodeLanguage l=(BytecodeLanguage)loader.getLanguage();
        exceptionTypes=l.getImplicitExceptionTypes(last);
        if (last instanceof IInvokeInstruction) {
          IInvokeInstruction call=(IInvokeInstruction)last;
          exceptionTypes=HashSetFactory.make(exceptionTypes);
          MethodReference target=MethodReference.findOrCreate(l,loader.getReference(),call.getClassType(),call.getMethodName(),call.getMethodSignature());
          try {
            exceptionTypes.addAll(l.inferInvokeExceptions(target,cha));
          }
 catch (          InvalidClassFileException e) {
            e.printStackTrace();
            Assertions.UNREACHABLE();
          }
        }
      }
    }
    if (hs != null && hs.length > 0) {
      if (!goToAllHandlers) {
        exceptionTypes=HashSetFactory.make(exceptionTypes);
      }
      for (int j=0; j < hs.length; j++) {
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + hs[j]);
        }
        BasicBlock b=getBlockForInstruction(hs[j].getHandler());
        if (DEBUG) {
          System.err.println(""String_Node_Str"" + b);
        }
        if (goToAllHandlers) {
          if (DEBUG) {
            System.err.println(""String_Node_Str"" + b);
          }
          addExceptionalEdgeTo(b);
        }
 else {
          TypeReference caughtException=null;
          if (hs[j].getCatchClass() != null) {
            ClassLoaderReference loader=ShrikeCFG.this.getMethod().getDeclaringClass().getReference().getClassLoader();
            caughtException=ShrikeUtil.makeTypeReference(loader,hs[j].getCatchClass());
            if (DEBUG) {
              System.err.println(""String_Node_Str"" + caughtException);
            }
            IClass caughtClass=cha.lookupClass(caughtException);
            if (caughtClass == null) {
              addExceptionalEdgeTo(b);
              Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
              caughtException=null;
            }
          }
 else {
            if (DEBUG) {
              System.err.println(""String_Node_Str"");
            }
            if (!exceptionTypes.isEmpty()) {
              addExceptionalEdgeTo(b);
              exceptionTypes.clear();
              caughtException=null;
            }
          }
          if (caughtException != null) {
            IClass caughtClass=cha.lookupClass(caughtException);
            ArrayList<TypeReference> caught=new ArrayList<TypeReference>(exceptionTypes.size());
            for (            TypeReference t : exceptionTypes) {
              if (t != null) {
                IClass klass=cha.lookupClass(t);
                if (klass == null) {
                  Warnings.add(FailedExceptionResolutionWarning.create(caughtException));
                  addExceptionalEdgeTo(b);
                }
 else {
                  boolean subtype1=cha.isSubclassOf(klass,caughtClass);
                  if (subtype1 || cha.isSubclassOf(caughtClass,klass)) {
                    addExceptionalEdgeTo(b);
                    if (subtype1) {
                      caught.add(t);
                    }
                  }
                }
              }
            }
            exceptionTypes.removeAll(caught);
          }
        }
      }
      if (exceptionTypes == null || !exceptionTypes.isEmpty()) {
        BasicBlock exit=exit();
        addExceptionalEdgeTo(exit);
      }
    }
 else {
      BasicBlock exit=exit();
      addExceptionalEdgeTo(exit);
    }
  }
}",0.9644517020474814
99903,"public Collection<IMethod> getAllMethods() throws ClassHierarchyException {
  Collection<IMethod> result=new LinkedList<IMethod>();
  Iterator<IMethod> declaredMethods=getDeclaredMethods().iterator();
  while (declaredMethods.hasNext()) {
    result.add(declaredMethods.next());
  }
  IClass s=getSuperclass();
  while (s != null) {
    Iterator<IMethod> superDeclaredMethods=s.getDeclaredMethods().iterator();
    while (superDeclaredMethods.hasNext()) {
      result.add(superDeclaredMethods.next());
    }
    s=s.getSuperclass();
  }
  return result;
}","public Collection<IMethod> getAllMethods() throws ClassHierarchyException {
  Collection<IMethod> result=new LinkedList<IMethod>();
  Iterator<IMethod> declaredMethods=getDeclaredMethods().iterator();
  while (declaredMethods.hasNext()) {
    result.add(declaredMethods.next());
  }
  if (isInterface()) {
    for (    IClass i : getDirectInterfaces()) {
      result.addAll(i.getAllMethods());
    }
  }
  IClass s=getSuperclass();
  while (s != null) {
    Iterator<IMethod> superDeclaredMethods=s.getDeclaredMethods().iterator();
    while (superDeclaredMethods.hasNext()) {
      result.add(superDeclaredMethods.next());
    }
    s=s.getSuperclass();
  }
  return result;
}",0.9011345218800648
99904,"public boolean isPEI(){
  return true;
}","public boolean isPEI(){
  return !isStatic();
}",0.8505747126436781
99905,"public boolean isPEI(){
  return true;
}","public boolean isPEI(){
  return !isStatic();
}",0.8505747126436781
99906,"@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new PolyglotJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha,new String[]{""String_Node_Str""});
    }
  }
;
  engine.setExclusionsFile(CallGraphTestUtil.REGRESSION_EXCLUSIONS);
  return engine;
}","@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new PolyglotJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,new String[]{""String_Node_Str""});
    }
  }
;
  engine.setExclusionsFile(CallGraphTestUtil.REGRESSION_EXCLUSIONS);
  return engine;
}",0.9539406345957012
99907,"protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha,new String[]{""String_Node_Str""});
}","protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,new String[]{""String_Node_Str""});
}",0.8872180451127819
99908,"@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new PolyglotJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha,mainClassDescriptors);
    }
  }
;
  engine.setExclusionsFile(CallGraphTestUtil.REGRESSION_EXCLUSIONS);
  return engine;
}","@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new PolyglotJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
    }
  }
;
  engine.setExclusionsFile(CallGraphTestUtil.REGRESSION_EXCLUSIONS);
  return engine;
}",0.9528795811518324
99909,"protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha,mainClassDescriptors);
}","protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
}",0.9071618037135278
99910,"protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new PolyglotJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha,mainClassDescriptors);
    }
    public IRTranslatorExtension getTranslatorExtension(){
      JavaIRTranslatorExtension ext=new JavaIRTranslatorExtension();
      ext.setCAstRewriterFactory(new CAstRewriterFactory(){
        public CAstRewriter createCAstRewriter(        CAst ast){
          return new SynchronizedBlockDuplicator(ast,true,testMethod);
        }
      }
);
      return ext;
    }
  }
;
  engine.setExclusionsFile(CallGraphTestUtil.REGRESSION_EXCLUSIONS);
  return engine;
}","protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new PolyglotJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
    }
    public IRTranslatorExtension getTranslatorExtension(){
      JavaIRTranslatorExtension ext=new JavaIRTranslatorExtension();
      ext.setCAstRewriterFactory(new CAstRewriterFactory(){
        public CAstRewriter createCAstRewriter(        CAst ast){
          return new SynchronizedBlockDuplicator(ast,true,testMethod);
        }
      }
);
      return ext;
    }
  }
;
  engine.setExclusionsFile(CallGraphTestUtil.REGRESSION_EXCLUSIONS);
  return engine;
}",0.9731343283582088
99911,"protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha,mainClassDescriptors);
}","protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
}",0.9071618037135278
99912,"@Override protected void buildAnalysisScope(){
  try {
    scope=makeSourceAnalysisScope();
    if (getExclusionsFile() != null) {
      scope.setExclusions(new FileOfClasses(new File(getExclusionsFile())));
    }
    EclipseProjectPath epath=getEclipseProjectPath();
    for (    Module m : epath.getModules(Loader.PRIMORDIAL,true)) {
      scope.addToScope(scope.getPrimordialLoader(),m);
    }
    ClassLoaderReference app=scope.getApplicationLoader();
    for (    Module m : epath.getModules(Loader.APPLICATION,true)) {
      scope.addToScope(app,m);
    }
    for (    Module m : epath.getModules(Loader.EXTENSION,true)) {
      if (!(m instanceof BinaryDirectoryTreeModule))       scope.addToScope(app,m);
    }
    ClassLoaderReference src=((JavaSourceAnalysisScope)scope).getSourceLoader();
    for (    Module m : epath.getModules(Loader.SOURCE,false)) {
      scope.addToScope(src,m);
    }
  }
 catch (  IOException e) {
    Assertions.UNREACHABLE(e.toString());
  }
}","@Override protected void buildAnalysisScope(){
  try {
    scope=makeSourceAnalysisScope();
    if (getExclusionsFile() != null) {
      scope.setExclusions(FileOfClasses.createFileOfClasses(new File(getExclusionsFile())));
    }
    EclipseProjectPath epath=getEclipseProjectPath();
    for (    Module m : epath.getModules(Loader.PRIMORDIAL,true)) {
      scope.addToScope(scope.getPrimordialLoader(),m);
    }
    ClassLoaderReference app=scope.getApplicationLoader();
    for (    Module m : epath.getModules(Loader.APPLICATION,true)) {
      scope.addToScope(app,m);
    }
    for (    Module m : epath.getModules(Loader.EXTENSION,true)) {
      if (!(m instanceof BinaryDirectoryTreeModule))       scope.addToScope(app,m);
    }
    ClassLoaderReference src=((JavaSourceAnalysisScope)scope).getSourceLoader();
    for (    Module m : epath.getModules(Loader.APPLICATION,false)) {
      scope.addToScope(src,m);
    }
  }
 catch (  IOException e) {
    Assertions.UNREACHABLE(e.toString());
  }
}",0.9803129732458354
99913,"@Override protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha);
}","@Override protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha);
}",0.9014084507042254
99914,"protected IClassLoader makeNewClassLoader(ClassLoaderReference classLoaderReference,IClassHierarchy cha,IClassLoader parent,AnalysisScope scope) throws IOException {
  if (classLoaderReference.equals(EclipseProjectPath.SOURCE_REF)) {
    ClassLoaderImpl cl=new PolyglotSourceLoaderImpl(classLoaderReference,parent,getExclusions(),cha,getExtensionFor(classLoaderReference));
    cl.init(scope.getModules(classLoaderReference));
    return cl;
  }
 else {
    return super.makeNewClassLoader(classLoaderReference,cha,parent,scope);
  }
}","protected IClassLoader makeNewClassLoader(ClassLoaderReference classLoaderReference,IClassHierarchy cha,IClassLoader parent,AnalysisScope scope) throws IOException {
  if (classLoaderReference.equals(JavaSourceAnalysisScope.SOURCE)) {
    ClassLoaderImpl cl=new PolyglotSourceLoaderImpl(classLoaderReference,parent,getExclusions(),cha,getExtensionFor(classLoaderReference));
    cl.init(scope.getModules(classLoaderReference));
    return cl;
  }
 else {
    return super.makeNewClassLoader(classLoaderReference,cha,parent,scope);
  }
}",0.957983193277311
99915,"public PolyglotClassLoaderFactory(SetOfClasses exclusions,IRTranslatorExtension javaExtInfo){
  super(exclusions);
  fExtensionMap.put(EclipseProjectPath.SOURCE_REF,javaExtInfo);
}","public PolyglotClassLoaderFactory(SetOfClasses exclusions,IRTranslatorExtension javaExtInfo){
  super(exclusions);
  fExtensionMap.put(JavaSourceAnalysisScope.SOURCE,javaExtInfo);
}",0.9030470914127424
99916,"public Iterator<T> iterator(){
  return new ArrayIterator<T>(entries);
}","public Iterator<T> iterator(){
  if (entries.length == 0) {
    return EmptyIterator.instance();
  }
  return new ArrayIterator<T>(entries);
}",0.6728971962616822
99917,"public static void main(String[] args) throws Exception, IllegalArgumentException {
  if (args.length < 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String in=args[0];
  String out=args[1];
  String[] match=new String[args.length - 2];
  System.arraycopy(args,2,match,0,match.length);
  JarFile inJar=new JarFile(in);
  JarOutputStream outJar=new JarOutputStream(new FileOutputStream(out));
  JarFile[] matches=new JarFile[match.length];
  for (int i=0; i < match.length; i++) {
    matches[i]=new JarFile(match[i]);
  }
  for (Enumeration<JarEntry> e=inJar.entries(); e.hasMoreElements(); ) {
    JarEntry entry=e.nextElement();
    if (matchEntry(matches,entry)) {
      outJar.putNextEntry(entry);
      byte[] data=new byte[(int)entry.getSize()];
      InputStream stream=inJar.getInputStream(entry);
      readFully(stream,data);
      outJar.write(data);
      outJar.flush();
    }
  }
  outJar.close();
}","public static void main(String[] args) throws Exception, IllegalArgumentException {
  if (args.length < 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String in=args[0];
  String out=args[1];
  if (in == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (out == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String[] match=new String[args.length - 2];
  System.arraycopy(args,2,match,0,match.length);
  JarFile inJar=new JarFile(in);
  JarOutputStream outJar=new JarOutputStream(new FileOutputStream(out));
  JarFile[] matches=new JarFile[match.length];
  for (int i=0; i < match.length; i++) {
    matches[i]=new JarFile(match[i]);
  }
  for (Enumeration<JarEntry> e=inJar.entries(); e.hasMoreElements(); ) {
    JarEntry entry=e.nextElement();
    if (matchEntry(matches,entry)) {
      outJar.putNextEntry(entry);
      byte[] data=new byte[(int)entry.getSize()];
      InputStream stream=inJar.getInputStream(entry);
      readFully(stream,data);
      outJar.write(data);
      outJar.flush();
    }
  }
  outJar.close();
}",0.9181773640372366
99918,"@Override final public int hashCode(){
  return getType().hashCode() + 14411 * getValue().hashCode();
}","@Override final public int hashCode(){
  int v=getValue() == null ? 0 : getValue().hashCode();
  return getType().hashCode() + 14411 * v;
}",0.6776859504132231
99919,"/** 
 * @return the constant value pushed: an Integer, a Long, a Float, a Double, aString, or null
 */
public abstract Object getValue();","/** 
 * @return the constant value pushed: an Integer, a Long, a Float, a Double, a String, or null
 */
public abstract Object getValue();",0.9963636363636365
99920,"@Override final public boolean equals(Object o){
  if (o instanceof ConstantInstruction) {
    ConstantInstruction i=(ConstantInstruction)o;
    return i.getType().equals(getType()) && i.getValue().equals(getValue());
  }
 else {
    return false;
  }
}","@Override final public boolean equals(Object o){
  if (o instanceof ConstantInstruction) {
    ConstantInstruction i=(ConstantInstruction)o;
    if (!i.getType().equals(getType())) {
      return false;
    }
    if (i.getValue() == null) {
      if (getValue() == null) {
        return true;
      }
 else {
        return false;
      }
    }
 else {
      if (getValue() == null) {
        return false;
      }
 else {
        return i.getValue().equals(getValue());
      }
    }
  }
 else {
    return false;
  }
}",0.5400516795865633
99921,"protected InstanceofInstruction(String type){
  super(OP_instanceof);
  this.type=type;
}","protected InstanceofInstruction(String type){
  super(OP_instanceof);
  this.type=type;
  if (type == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}",0.6768060836501901
99922,"/** 
 * Build an editor for specific method data. After patching the code you can retrieve the new code, handlers and instructions-to-bytecode-offsets map.
 */
public MethodEditor(Instruction[] instructions,ExceptionHandler[][] handlers,int[] instructionsToBytecodes){
  methodInfo=null;
  this.instructionsToBytecodes=instructionsToBytecodes;
  this.instructions=instructions;
  this.handlers=handlers;
}","/** 
 * Build an editor for specific method data. After patching the code you can retrieve the new code, handlers and instructions-to-bytecode-offsets map.
 */
public MethodEditor(Instruction[] instructions,ExceptionHandler[][] handlers,int[] instructionsToBytecodes){
  if (instructions == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  methodInfo=null;
  this.instructionsToBytecodes=instructionsToBytecodes;
  this.instructions=instructions;
  this.handlers=handlers;
}",0.8970099667774086
99923,"/** 
 * Compute the promoted type that the JVM uses to manipulate values of type ""t"" on its working stack.
 * @throws IllegalArgumentException  if t is null
 */
public static String getStackType(String t){
  if (t == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
switch (t.charAt(0)) {
case 'Z':
case 'C':
case 'B':
case 'S':
    return ""String_Node_Str"";
default :
  return t;
}
}","/** 
 * Compute the promoted type that the JVM uses to manipulate values of type ""t"" on its working stack.
 * @throws IllegalArgumentException  if t is null
 */
public static String getStackType(String t){
  if (t == null || t.length() < 1) {
    throw new IllegalArgumentException(""String_Node_Str"" + t);
  }
switch (t.charAt(0)) {
case 'Z':
case 'C':
case 'B':
case 'S':
    return ""String_Node_Str"";
default :
  return t;
}
}",0.973621103117506
99924,"/** 
 * Compute the number of parameters given by method signature ""type"". Any ""this"" parameter is not included.
 * @throws IllegalArgumentException  if type == null
 */
static int getParamsCount(String type) throws IllegalArgumentException {
  if (type == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int index=1;
  int count=0;
  while (type.charAt(index) != ')') {
    count++;
    index+=getTypeLength(type,index);
  }
  return count;
}","/** 
 * Compute the number of parameters given by method signature ""type"". Any ""this"" parameter is not included.
 * @throws IllegalArgumentException  if type == null
 */
static int getParamsCount(String type) throws IllegalArgumentException {
  if (type == null || type.length() < 2) {
    throw new IllegalArgumentException(""String_Node_Str"" + type);
  }
  int index=1;
  int count=0;
  while (type.charAt(index) != ')') {
    count++;
    index+=getTypeLength(type,index);
  }
  return count;
}",0.970954356846473
99925,"/** 
 * @return true iff t is a primitive type
 */
public static boolean isPrimitiveType(String t){
  if (t == null) {
    return false;
  }
 else {
switch (t.charAt(0)) {
case 'L':
case '[':
      return false;
default :
    return true;
}
}
}","/** 
 * @return true iff t is a primitive type
 */
public static boolean isPrimitiveType(String t){
  if (t == null || t.length() == 0) {
    return false;
  }
 else {
switch (t.charAt(0)) {
case 'L':
case '[':
      return false;
default :
    return true;
}
}
}",0.9625246548323472
99926,"/** 
 * Initialize a verifier.
 * @throws NullPointerException  if info is null
 */
public Verifier(MethodData info) throws NullPointerException {
  super(info);
}","/** 
 * Initialize a verifier.
 * @throws NullPointerException if info is null
 */
public Verifier(MethodData info) throws NullPointerException {
  super(info);
}",0.9969230769230768
99927,"public static void main(String[] args){
  for (int i=0; i < args.length; i++) {
    try {
      byte[] data=Util.readFully(new FileInputStream(args[i]));
      ClassReader r=new ClassReader(data);
      System.out.println(Util.makeClass(r.getName()) + ""String_Node_Str"" + computeSerialVersionUID(r));
    }
 catch (    FileNotFoundException e) {
      System.err.println(""String_Node_Str"" + args[i]);
    }
catch (    IOException e) {
      System.err.println(""String_Node_Str"" + args[i]);
    }
catch (    InvalidClassFileException e) {
      System.err.println(""String_Node_Str"" + args[i]);
    }
  }
}","public static void main(String[] args){
  for (int i=0; i < args.length; i++) {
    if (args[i] == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
    }
    try {
      byte[] data=Util.readFully(new FileInputStream(args[i]));
      ClassReader r=new ClassReader(data);
      System.out.println(Util.makeClass(r.getName()) + ""String_Node_Str"" + computeSerialVersionUID(r));
    }
 catch (    FileNotFoundException e) {
      System.err.println(""String_Node_Str"" + args[i]);
    }
catch (    IOException e) {
      System.err.println(""String_Node_Str"" + args[i]);
    }
catch (    InvalidClassFileException e) {
      System.err.println(""String_Node_Str"" + args[i]);
    }
  }
}",0.9110105580693816
99928,"/** 
 * Call this when you're done modifying classes.
 */
final public void close() throws IOException {
  if (passUnmodifiedClasses) {
    writeUnmodifiedClasses();
  }
  if (outputJar != null) {
    outputJar.close();
  }
  if (cachedJar != null) {
    cachedJar.close();
  }
}","/** 
 * Call this when you're done modifying classes.
 */
final public void close() throws IOException, IllegalStateException {
  if (passUnmodifiedClasses) {
    writeUnmodifiedClasses();
  }
  if (outputJar != null) {
    outputJar.close();
  }
  if (cachedJar != null) {
    cachedJar.close();
  }
}",0.9604130808950088
99929,"/** 
 * Parse an argument list to find elements to instrument and the name of the output file. The ""-o filename"" option selects the output JAR file name. Any other argument not starting with ""-"" is added to the list of elements to instrument, if it appears to be the name of a class file, JAR file, or directory. If any argument starting with ""--"" is encountered, the rest of the command-line is considered leftover
 * @return the arguments that were not understood
 * @throws IllegalArgumentException  if args == null
 */
final public String[] parseStandardArgs(String[] args) throws IllegalArgumentException, IOException {
  if (args == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ArrayList<String> leftover=new ArrayList<String>();
  for (int i=0; i < args.length; i++) {
    String a=args[i];
    if (a.equals(""String_Node_Str"") && i + 1 < args.length) {
      setOutputJar(new File(args[i + 1]));
      i++;
      continue;
    }
 else     if (!a.startsWith(""String_Node_Str"")) {
      if (addInputElement(a)) {
        continue;
      }
    }
 else     if (a.startsWith(""String_Node_Str"")) {
      for (int j=i; j < args.length; j++) {
        leftover.add(args[j]);
      }
      break;
    }
    leftover.add(a);
  }
  String[] r=new String[leftover.size()];
  leftover.toArray(r);
  return r;
}","/** 
 * Parse an argument list to find elements to instrument and the name of the output file. The ""-o filename"" option selects the output JAR file name. Any other argument not starting with ""-"" is added to the list of elements to instrument, if it appears to be the name of a class file, JAR file, or directory. If any argument starting with ""--"" is encountered, the rest of the command-line is considered leftover
 * @return the arguments that were not understood
 * @throws IllegalArgumentException  if args == null
 */
final public String[] parseStandardArgs(String[] args) throws IllegalArgumentException, IOException {
  if (args == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ArrayList<String> leftover=new ArrayList<String>();
  for (int i=0; i < args.length; i++) {
    String a=args[i];
    if (a == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
    }
    if (a.equals(""String_Node_Str"") && i + 1 < args.length) {
      setOutputJar(new File(args[i + 1]));
      i++;
      continue;
    }
 else     if (!a.startsWith(""String_Node_Str"")) {
      if (addInputElement(a)) {
        continue;
      }
    }
 else     if (a.startsWith(""String_Node_Str"")) {
      for (int j=i; j < args.length; j++) {
        leftover.add(args[j]);
      }
      break;
    }
    leftover.add(a);
  }
  String[] r=new String[leftover.size()];
  leftover.toArray(r);
  return r;
}",0.9596541786743517
99930,"/** 
 * Set the 4 bytes at offset 'offset' in 'buf' to the signed 32-bit value in v.
 * @throws IllegalArgumentException if buf is null
 */
public static void setInt(byte[] buf,int offset,int v) throws IllegalArgumentException {
  if (buf == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (offset >= buf.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + offset);
  }
  buf[offset]=(byte)(v >> 24);
  buf[offset + 1]=(byte)(v >> 16);
  buf[offset + 2]=(byte)(v >> 8);
  buf[offset + 3]=(byte)v;
}","/** 
 * Set the 4 bytes at offset 'offset' in 'buf' to the signed 32-bit value in v.
 * @throws IllegalArgumentException if buf is null
 */
public static void setInt(byte[] buf,int offset,int v) throws IllegalArgumentException {
  if (buf == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    buf[offset]=(byte)(v >> 24);
    buf[offset + 1]=(byte)(v >> 16);
    buf[offset + 2]=(byte)(v >> 8);
    buf[offset + 3]=(byte)v;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + offset);
  }
}",0.7985739750445633
99931,"/** 
 * Set the 2 bytes at offset 'offset' in 'buf' to the unsigned 16-bit value in v.
 * @throws IllegalArgumentException if buf is null
 */
public static void setUShort(byte[] buf,int offset,int v) throws IllegalArgumentException {
  if (buf == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (offset + 1 >= buf.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + buf.length + ""String_Node_Str""+ offset);
  }
  buf[offset]=(byte)(v >> 8);
  buf[offset + 1]=(byte)v;
}","/** 
 * Set the 2 bytes at offset 'offset' in 'buf' to the unsigned 16-bit value in v.
 * @throws IllegalArgumentException if buf is null
 */
public static void setUShort(byte[] buf,int offset,int v) throws IllegalArgumentException {
  if (buf == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (offset < 0 || offset + 1 >= buf.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + buf.length + ""String_Node_Str""+ offset);
  }
  try {
    buf[offset]=(byte)(v >> 8);
    buf[offset + 1]=(byte)v;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + offset);
  }
}",0.8741496598639455
99932,"/** 
 * @param bytes the raw class file data
 * @param offset the start of the constant pool data
 * @param itemCount the number of items in the pool
 */
public ConstantPoolParser(byte[] bytes,int offset,int itemCount) throws InvalidClassFileException {
  this.bytes=bytes;
  if (offset < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + offset);
  }
  if (itemCount < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + itemCount);
  }
  parseConstantPool(offset,itemCount);
}","/** 
 * @param bytes the raw class file data
 * @param offset the start of the constant pool data
 * @param itemCount the number of items in the pool
 */
public ConstantPoolParser(byte[] bytes,int offset,int itemCount) throws InvalidClassFileException {
  this.bytes=bytes;
  if (offset < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + offset);
  }
  if (itemCount < 0 || itemCount > MAX_CP_ITEMS) {
    throw new IllegalArgumentException(""String_Node_Str"" + itemCount);
  }
  parseConstantPool(offset,itemCount);
}",0.972972972972973
99933,"@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new JDTJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha,mainClassDescriptors);
    }
  }
;
  try {
    engine.setExclusionsFile(FileProvider.getFileFromPlugin(CoreTestsPlugin.getDefault(),CallGraphTestUtil.REGRESSION_EXCLUSIONS).getAbsolutePath());
  }
 catch (  IOException e) {
    Assert.assertFalse(""String_Node_Str"",true);
  }
  return engine;
}","@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new JDTJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
    }
  }
;
  try {
    engine.setExclusionsFile(FileProvider.getFileFromPlugin(CoreTestsPlugin.getDefault(),CallGraphTestUtil.REGRESSION_EXCLUSIONS).getAbsolutePath());
  }
 catch (  IOException e) {
    Assert.assertFalse(""String_Node_Str"",true);
  }
  return engine;
}",0.965089216446858
99934,"protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha,mainClassDescriptors);
}","protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
}",0.9071618037135278
99935,"@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new JDTJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha,mainClassDescriptors);
    }
  }
;
  try {
    engine.setExclusionsFile(FileProvider.getFileFromPlugin(CoreTestsPlugin.getDefault(),CallGraphTestUtil.REGRESSION_EXCLUSIONS).getAbsolutePath());
  }
 catch (  IOException e) {
    Assert.assertFalse(""String_Node_Str"",true);
  }
  return engine;
}","@Override protected JavaSourceAnalysisEngine getAnalysisEngine(final String[] mainClassDescriptors){
  JavaSourceAnalysisEngine engine=new JDTJavaSourceAnalysisEngine(){
    protected Iterable<Entrypoint> makeDefaultEntrypoints(    AnalysisScope scope,    IClassHierarchy cha){
      return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
    }
  }
;
  try {
    engine.setExclusionsFile(FileProvider.getFileFromPlugin(CoreTestsPlugin.getDefault(),CallGraphTestUtil.REGRESSION_EXCLUSIONS).getAbsolutePath());
  }
 catch (  IOException e) {
    Assert.assertFalse(""String_Node_Str"",true);
  }
  return engine;
}",0.965089216446858
99936,"protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha,mainClassDescriptors);
}","protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha,mainClassDescriptors);
}",0.9071618037135278
99937,"protected IClassLoader makeNewClassLoader(ClassLoaderReference classLoaderReference,IClassHierarchy cha,IClassLoader parent,AnalysisScope scope) throws IOException {
  if (classLoaderReference.equals(EclipseProjectPath.SOURCE_REF)) {
    ClassLoaderImpl cl=new JDTSourceLoaderImpl(classLoaderReference,parent,getExclusions(),cha);
    cl.init(scope.getModules(classLoaderReference));
    return cl;
  }
 else {
    return super.makeNewClassLoader(classLoaderReference,cha,parent,scope);
  }
}","protected IClassLoader makeNewClassLoader(ClassLoaderReference classLoaderReference,IClassHierarchy cha,IClassLoader parent,AnalysisScope scope) throws IOException {
  if (classLoaderReference.equals(JavaSourceAnalysisScope.SOURCE)) {
    ClassLoaderImpl cl=new JDTSourceLoaderImpl(classLoaderReference,parent,getExclusions(),cha);
    cl.init(scope.getModules(classLoaderReference));
    return cl;
  }
 else {
    return super.makeNewClassLoader(classLoaderReference,cha,parent,scope);
  }
}",0.9543147208121828
99938,"protected static void dumpIR(CallGraph cg,boolean assertReachable) throws IOException {
  Set<IMethod> unreachable=HashSetFactory.make();
  IClassHierarchy cha=cg.getClassHierarchy();
  IClassLoader sourceLoader=cha.getLoader(EclipseProjectPath.SOURCE_REF);
  for (Iterator iter=sourceLoader.iterateAllClasses(); iter.hasNext(); ) {
    IClass clazz=(IClass)iter.next();
    Trace.println(clazz);
    if (clazz.isInterface())     continue;
    for (    IMethod m : clazz.getDeclaredMethods()) {
      if (m.isAbstract()) {
        Trace.println(m);
      }
 else {
        Iterator nodeIter=cg.getNodes(m.getReference()).iterator();
        if (!nodeIter.hasNext()) {
          Trace.println(""String_Node_Str"" + m.getReference() + ""String_Node_Str"");
          unreachable.add(m);
          continue;
        }
        CGNode node=(CGNode)nodeIter.next();
        Trace.println(node.getIR());
      }
    }
  }
  if (assertReachable) {
    Assert.assertTrue(""String_Node_Str"" + unreachable.toString(),unreachable.isEmpty());
  }
}","protected static void dumpIR(CallGraph cg,boolean assertReachable) throws IOException {
  Set<IMethod> unreachable=HashSetFactory.make();
  IClassHierarchy cha=cg.getClassHierarchy();
  IClassLoader sourceLoader=cha.getLoader(JavaSourceAnalysisScope.SOURCE);
  for (Iterator iter=sourceLoader.iterateAllClasses(); iter.hasNext(); ) {
    IClass clazz=(IClass)iter.next();
    Trace.println(clazz);
    if (clazz.isInterface())     continue;
    for (    IMethod m : clazz.getDeclaredMethods()) {
      if (m.isAbstract()) {
        Trace.println(m);
      }
 else {
        Iterator nodeIter=cg.getNodes(m.getReference()).iterator();
        if (!nodeIter.hasNext()) {
          Trace.println(""String_Node_Str"" + m.getReference() + ""String_Node_Str"");
          unreachable.add(m);
          continue;
        }
        CGNode node=(CGNode)nodeIter.next();
        Trace.println(node.getIR());
      }
    }
  }
  if (assertReachable) {
    Assert.assertTrue(""String_Node_Str"" + unreachable.toString(),unreachable.isEmpty());
  }
}",0.9791363415817564
99939,"private MethodReference getSliceRootReference(String className,String methodName,String methodDescriptor){
  TypeName clsName=TypeName.string2TypeName(""String_Node_Str"" + className.replace('.','/'));
  TypeReference clsRef=TypeReference.findOrCreate(EclipseProjectPath.SOURCE_REF,clsName);
  Atom nameAtom=Atom.findOrCreateUnicodeAtom(methodName);
  Descriptor descr=Descriptor.findOrCreateUTF8(methodDescriptor);
  return MethodReference.findOrCreate(clsRef,nameAtom,descr);
}","private MethodReference getSliceRootReference(String className,String methodName,String methodDescriptor){
  TypeName clsName=TypeName.string2TypeName(""String_Node_Str"" + className.replace('.','/'));
  TypeReference clsRef=TypeReference.findOrCreate(JavaSourceAnalysisScope.SOURCE,clsName);
  Atom nameAtom=Atom.findOrCreateUnicodeAtom(methodName);
  Descriptor descr=Descriptor.findOrCreateUTF8(methodDescriptor);
  return MethodReference.findOrCreate(clsRef,nameAtom,descr);
}",0.9528795811518324
99940,"protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(EclipseProjectPath.SOURCE_REF,cha);
}","protected Iterable<Entrypoint> makeDefaultEntrypoints(AnalysisScope scope,IClassHierarchy cha){
  return Util.makeMainEntrypoints(JavaSourceAnalysisScope.SOURCE,cha);
}",0.8955223880597015
99941,"public ClassLoaderReference getSourceLoader(){
  return getLoader(EclipseProjectPath.SOURCE);
}","public ClassLoaderReference getSourceLoader(){
  return SOURCE;
}",0.8125
99942,"public JavaSourceAnalysisScope(Collection<Language> languages){
  super(languages);
  initForJava();
  EclipseProjectPath.SOURCE_REF.setParent(getLoader(APPLICATION));
  getLoader(SYNTHETIC).setParent(EclipseProjectPath.SOURCE_REF);
  loadersByName.put(EclipseProjectPath.SOURCE,EclipseProjectPath.SOURCE_REF);
  setLoaderImpl(getLoader(SYNTHETIC),""String_Node_Str"");
  setLoaderImpl(EclipseProjectPath.SOURCE_REF,""String_Node_Str"");
}","public JavaSourceAnalysisScope(Collection<Language> languages){
  super(languages);
  initForJava();
  loadersByName.put(SOURCE.getName(),SOURCE);
  setLoaderImpl(getLoader(SYNTH_SOURCE.getName()),""String_Node_Str"");
  setLoaderImpl(SOURCE,""String_Node_Str"");
}",0.4310344827586206
99943,"public void performVerboseAction(){
  System.err.println(""String_Node_Str"" + nEvaluated);
  System.err.println(""String_Node_Str"" + nCreated);
  System.err.println(""String_Node_Str"" + workList.size());
  if (MORE_VERBOSE) {
    AbstractStatement s=workList.takeStatement();
    System.err.println(""String_Node_Str"" + lineBreak(s.toString(),132));
    if (s instanceof VerboseAction) {
      ((VerboseAction)s).performVerboseAction();
    }
    workList.insertStatement(s);
  }
}","public void performVerboseAction(){
  System.err.println(""String_Node_Str"" + nEvaluated);
  System.err.println(""String_Node_Str"" + nCreated);
  System.err.println(""String_Node_Str"" + workList.size());
  if (MORE_VERBOSE) {
    if (!workList.isEmpty()) {
      AbstractStatement s=workList.takeStatement();
      System.err.println(""String_Node_Str"" + lineBreak(s.toString(),132));
      if (s instanceof VerboseAction) {
        ((VerboseAction)s).performVerboseAction();
      }
      workList.insertStatement(s);
    }
  }
}",0.9511465603190428
99944,"/** 
 * Solve the set of dataflow graph. <p> PRECONDITION: graph is set up
 * @return true iff the evaluation of some equation caused a change in thevalue of some variable.
 */
@SuppressWarnings(""String_Node_Str"") public boolean solve(IProgressMonitor monitor) throws CancelException {
  boolean globalChange=false;
  if (firstSolve) {
    initForFirstSolve();
  }
  while (!workList.isEmpty()) {
    MonitorUtil.throwExceptionIfCanceled(monitor);
    orderStatements();
    AbstractStatement s=workList.takeStatement();
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + s);
    }
    byte code=s.evaluate();
    if (verbose) {
      nEvaluated++;
      if (nEvaluated % getVerboseInterval() == 0) {
        performVerboseAction();
      }
      if (nEvaluated % getPeriodicMaintainInterval() == 0) {
        periodicMaintenance();
      }
    }
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + s + ""String_Node_Str""+ isChanged(code));
    }
    if (isChanged(code)) {
      globalChange=true;
      updateWorkList(s);
    }
    if (isFixed(code)) {
      removeStatement(s);
    }
  }
  return globalChange;
}","/** 
 * Solve the set of dataflow graph. <p> PRECONDITION: graph is set up
 * @return true iff the evaluation of some equation caused a change in the value of some variable.
 */
@SuppressWarnings(""String_Node_Str"") public boolean solve(IProgressMonitor monitor) throws CancelException {
  boolean globalChange=false;
  if (firstSolve) {
    initForFirstSolve();
  }
  while (!workList.isEmpty()) {
    MonitorUtil.throwExceptionIfCanceled(monitor);
    orderStatements();
    AbstractStatement s=workList.takeStatement();
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + s);
    }
    byte code=s.evaluate();
    if (verbose) {
      nEvaluated++;
      if (nEvaluated % getVerboseInterval() == 0) {
        performVerboseAction();
      }
      if (nEvaluated % getPeriodicMaintainInterval() == 0) {
        periodicMaintenance();
      }
    }
    if (DEBUG) {
      Trace.println(""String_Node_Str"" + s + ""String_Node_Str""+ isChanged(code));
    }
    if (isChanged(code)) {
      globalChange=true;
      updateWorkList(s);
    }
    if (isFixed(code)) {
      removeStatement(s);
    }
  }
  return globalChange;
}",0.9995557529986672
99945,"/** 
 * @return StringBuffer holding dot output representing G
 * @throws WalaException
 */
private static <T>StringBuffer dotOutput(Graph<T> g,NodeDecorator labels,String title) throws WalaException {
  StringBuffer result=new StringBuffer(""String_Node_Str"");
  if (title != null) {
    result.append(""String_Node_Str"" + title + ""String_Node_Str"");
  }
 else {
    result.append(""String_Node_Str"");
  }
  String rankdir=getRankDir();
  if (rankdir != null) {
    result.append(""String_Node_Str"" + rankdir + ""String_Node_Str"");
  }
  String fontsizeStr=""String_Node_Str"" + fontSize;
  String fontcolorStr=(fontColor != null) ? ""String_Node_Str"" + fontColor : ""String_Node_Str"";
  String fontnameStr=(fontName != null) ? ""String_Node_Str"" + fontName : ""String_Node_Str"";
  result.append(""String_Node_Str"");
  result.append(fontsizeStr);
  result.append(""String_Node_Str"");
  result.append(fontsizeStr);
  result.append(""String_Node_Str"");
  result.append(fontcolorStr);
  result.append(fontnameStr);
  result.append(""String_Node_Str"");
  result.append(fontsizeStr);
  result.append(fontcolorStr);
  result.append(fontnameStr);
  result.append(""String_Node_Str"");
  Collection dotNodes=computeDotNodes(g);
  outputNodes(labels,result,dotNodes);
  for (Iterator<? extends T> it=g.iterator(); it.hasNext(); ) {
    T n=it.next();
    for (Iterator<? extends T> it2=g.getSuccNodes(n); it2.hasNext(); ) {
      T s=it2.next();
      result.append(""String_Node_Str"");
      result.append(getPort(n,labels));
      result.append(""String_Node_Str"");
      result.append(getPort(s,labels));
      result.append(""String_Node_Str"");
    }
  }
  result.append(""String_Node_Str"");
  return result;
}","/** 
 * @return StringBuffer holding dot output representing G
 * @throws WalaException
 */
private static <T>StringBuffer dotOutput(Graph<T> g,NodeDecorator labels,String title) throws WalaException {
  StringBuffer result=new StringBuffer(""String_Node_Str"");
  if (title != null) {
    result.append(""String_Node_Str"" + title + ""String_Node_Str"");
  }
 else {
    result.append(""String_Node_Str"");
  }
  String rankdir=getRankDir();
  if (rankdir != null) {
    result.append(""String_Node_Str"" + rankdir + ""String_Node_Str"");
  }
  String fontsizeStr=""String_Node_Str"" + fontSize;
  String fontcolorStr=(fontColor != null) ? ""String_Node_Str"" + fontColor : ""String_Node_Str"";
  String fontnameStr=(fontName != null) ? ""String_Node_Str"" + fontName : ""String_Node_Str"";
  result.append(""String_Node_Str"");
  result.append(fontsizeStr);
  result.append(""String_Node_Str"");
  result.append(fontsizeStr);
  result.append(fontcolorStr);
  result.append(fontnameStr);
  result.append(""String_Node_Str"");
  result.append(fontsizeStr);
  result.append(fontcolorStr);
  result.append(fontnameStr);
  result.append(""String_Node_Str"");
  Collection dotNodes=computeDotNodes(g);
  outputNodes(labels,result,dotNodes);
  for (Iterator<? extends T> it=g.iterator(); it.hasNext(); ) {
    T n=it.next();
    for (Iterator<? extends T> it2=g.getSuccNodes(n); it2.hasNext(); ) {
      T s=it2.next();
      result.append(""String_Node_Str"");
      result.append(getPort(n,labels));
      result.append(""String_Node_Str"");
      result.append(getPort(s,labels));
      result.append(""String_Node_Str"");
    }
  }
  result.append(""String_Node_Str"");
  return result;
}",0.9892021595680864
99946,"public boolean containsValue(Object value){
  if (keysAndValues == null) {
    return false;
  }
  for (int i=size(); i < keysAndValues.length; i++) {
    if (keysAndValues[i].equals(value)) {
      return true;
    }
  }
  return false;
}","public boolean containsValue(Object value){
  if (keysAndValues == null) {
    return false;
  }
  for (int i=size(); i < keysAndValues.length; i++) {
    Object v=keysAndValues[i];
    if (v == null) {
      if (value == null) {
        return true;
      }
    }
 else {
      if (v.equals(value)) {
        return true;
      }
    }
  }
  return false;
}",0.6532663316582915
99947,"private void resolvePluginClassPath(IProject p) throws CoreException, IOException {
  BundleDescription bd=findModel(p).getBundleDescription();
  resolveBundleDescriptionClassPath(bd,Loader.APPLICATION);
}","private void resolvePluginClassPath(IProject p) throws CoreException, IOException {
  BundleDescription bd=findModel(p).getBundleDescription();
  if (bd == null) {
    throw new IllegalStateException(""String_Node_Str"" + p);
  }
  resolveBundleDescriptionClassPath(bd,Loader.APPLICATION);
}",0.8299595141700404
99948,"/** 
 * If file extension is not provided, use system default
 * @throws JavaModelException
 * @throws IOException
 */
private void resolveProjectClasspathEntries() throws JavaModelException, IOException {
  resolveClasspathEntries(project.getRawClasspath(),Loader.EXTENSION);
}","private void resolveProjectClasspathEntries() throws JavaModelException, IOException {
  resolveClasspathEntries(project.getRawClasspath(),Loader.EXTENSION);
}",0.7276887871853547
99949,"/** 
 * create a new field-element
 * @param fld - field element to serve as part of a path
 */
public FieldPathElement(IField fld){
  Assertions.precondition(fld != null,""String_Node_Str"");
  this.fld=fld;
}","/** 
 * create a new field-element
 * @param fld - field element to serve as part of a path
 */
public FieldPathElement(IField fld){
  if (fld == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.fld=fld;
}",0.8099547511312217
99950,"/** 
 * create a new anchor element
 * @param lpk -anchor element to serve as head of path
 */
public LocalPathElement(AbstractPointerKey lpk){
  this.lpk=lpk;
  if (Assertions.verifyAssertions) {
    Assertions._assert(lpk != null);
  }
}","/** 
 * create a new anchor element
 * @param lpk - anchor element to serve as head of path
 */
public LocalPathElement(AbstractPointerKey lpk){
  this.lpk=lpk;
  if (lpk == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}",0.7257731958762886
99951,"protected HeapGraph(PointerAnalysis pa){
  this.pa=pa;
}","protected HeapGraph(PointerAnalysis pa){
  if (pa == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.pa=pa;
}",0.5743589743589743
99952,"public FieldImpl(IClass declaringClass,FieldReference canonicalRef,int accessFlags,Collection<Annotation> annotations){
  this.declaringClass=declaringClass;
  this.fieldRef=canonicalRef;
  this.accessFlags=accessFlags;
  this.annotations=annotations;
  if (Assertions.verifyAssertions) {
    Assertions._assert(declaringClass != null);
    Assertions._assert(fieldRef != null);
  }
}","public FieldImpl(IClass declaringClass,FieldReference canonicalRef,int accessFlags,Collection<Annotation> annotations){
  this.declaringClass=declaringClass;
  this.fieldRef=canonicalRef;
  this.accessFlags=accessFlags;
  this.annotations=annotations;
  if (declaringClass == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (fieldRef == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}",0.6528623629719854
99953,"private int findReturnToVar(int v,int addr,boolean[] visited) throws InvalidBytecodeException {
  while (true) {
    if (visited[addr]) {
      return 0;
    }
 else     if (retInfo[addr] != null && retInfo[addr].retVar == v) {
      return addr;
    }
 else {
      int offset=decodedOffset[addr];
      if (offset == UNSEEN) {
        return 0;
      }
      int size=decodedSize[addr];
      Instruction instr=null;
      visited[addr]=true;
      for (int j=0; j < rawHandlers.length; j+=4) {
        if (rawHandlers[j] <= addr && addr < rawHandlers[j + 1]) {
          int handlerAddr=rawHandlers[j + 2];
          if (decodedOffset[handlerAddr] < 0) {
            byte[] stackWords=new byte[code.length * 2];
            decodeAt(handlerAddr,1,stackWords);
          }
          int r=findReturnToVar(v,handlerAddr,visited);
          if (r != 0) {
            return r;
          }
        }
      }
      if (JSRs[addr] != 0) {
        if (!doesSubroutineReturn(JSRs[addr])) {
          return 0;
        }
      }
 else {
        for (int j=0; j < size; j++) {
          instr=decoded.get(offset + j);
          if (instr instanceof StoreInstruction && ((StoreInstruction)instr).getVarIndex() == v) {
            return 0;
          }
          int[] targets=instr.getBranchTargets();
          for (int k=0; k < targets.length; k++) {
            if (targets[k] >= 0) {
              int r=findReturnToVar(v,targets[k],visited);
              if (r != 0) {
                return r;
              }
            }
          }
        }
        if (instr != null && !instr.isFallThrough()) {
          return 0;
        }
      }
      do {
        addr++;
      }
 while (decodedOffset[addr] == INSIDE_INSTRUCTION);
    }
  }
}","private int findReturnToVar(int v,int addr,boolean[] visited) throws InvalidBytecodeException {
  while (true) {
    if (visited[addr]) {
      return 0;
    }
 else     if (retInfo[addr] != null && retInfo[addr].retVar == v) {
      return addr;
    }
 else {
      int offset=decodedOffset[addr];
      if (offset == UNSEEN) {
        return 0;
      }
      int size=decodedSize[addr];
      Instruction instr=null;
      visited[addr]=true;
      for (int j=0; j < rawHandlers.length; j+=4) {
        if (rawHandlers[j] <= addr && addr < rawHandlers[j + 1]) {
          int handlerAddr=rawHandlers[j + 2];
          if (decodedOffset[handlerAddr] < 0) {
            byte[] stackWords=new byte[code.length * 2];
            stackWords[0]=1;
            decodeAt(handlerAddr,1,stackWords);
          }
          int r=findReturnToVar(v,handlerAddr,visited);
          if (r != 0) {
            return r;
          }
        }
      }
      if (JSRs[addr] != 0) {
        if (!doesSubroutineReturn(JSRs[addr])) {
          return 0;
        }
      }
 else {
        for (int j=0; j < size; j++) {
          instr=decoded.get(offset + j);
          if (instr instanceof StoreInstruction && ((StoreInstruction)instr).getVarIndex() == v) {
            return 0;
          }
          int[] targets=instr.getBranchTargets();
          for (int k=0; k < targets.length; k++) {
            if (targets[k] >= 0) {
              int r=findReturnToVar(v,targets[k],visited);
              if (r != 0) {
                return r;
              }
            }
          }
        }
        if (instr != null && !instr.isFallThrough()) {
          return 0;
        }
      }
      do {
        addr++;
      }
 while (decodedOffset[addr] == INSIDE_INSTRUCTION);
    }
  }
}",0.9917166523850328
99954,"private void populate(CGNode n){
  if (ALWAYS_BUILD_IR || n.getMethod().isSynthetic()) {
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    SSAInstruction[] statements=n.getIR().getInstructions();
    SSAMemoryAccessVisitor v=new SSAMemoryAccessVisitor(n);
    for (int i=0; i < statements.length; i++) {
      SSAInstruction s=statements[i];
      if (s != null) {
        v.setInstructionIndex(i);
        s.visit(v);
      }
    }
  }
 else {
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    ShrikeCTMethod sm=(ShrikeCTMethod)n.getMethod();
    MemoryAccessVisitor v=new MemoryAccessVisitor(n.getMethod().getReference().getDeclaringClass().getClassLoader(),n);
    try {
      Instruction[] statements=sm.getInstructions();
      if (statements == null) {
        return;
      }
      if (DEBUG) {
        for (int i=0; i < statements.length; i++) {
          System.err.println(i + ""String_Node_Str"" + statements[i]);
        }
      }
      for (int i=0; i < statements.length; i++) {
        Instruction s=statements[i];
        if (s != null) {
          v.setInstructionIndex(i);
          s.visit(v);
        }
      }
    }
 catch (    InvalidClassFileException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
}","private void populate(CGNode n){
  if (ALWAYS_BUILD_IR || n.getMethod().isSynthetic()) {
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    IR ir=n.getIR();
    if (ir == null) {
      return;
    }
    SSAInstruction[] statements=ir.getInstructions();
    SSAMemoryAccessVisitor v=new SSAMemoryAccessVisitor(n);
    for (int i=0; i < statements.length; i++) {
      SSAInstruction s=statements[i];
      if (s != null) {
        v.setInstructionIndex(i);
        s.visit(v);
      }
    }
  }
 else {
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    ShrikeCTMethod sm=(ShrikeCTMethod)n.getMethod();
    MemoryAccessVisitor v=new MemoryAccessVisitor(n.getMethod().getReference().getDeclaringClass().getClassLoader(),n);
    try {
      Instruction[] statements=sm.getInstructions();
      if (statements == null) {
        return;
      }
      if (DEBUG) {
        for (int i=0; i < statements.length; i++) {
          System.err.println(i + ""String_Node_Str"" + statements[i]);
        }
      }
      for (int i=0; i < statements.length; i++) {
        Instruction s=statements[i];
        if (s != null) {
          v.setInstructionIndex(i);
          s.visit(v);
        }
      }
    }
 catch (    InvalidClassFileException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
}",0.9719696969696968
99955,"private void populate(CGNode n){
  if (n.getMethod().isSynthetic()) {
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    SSAInstruction[] statements=n.getIR().getInstructions();
    SSAMemoryAccessVisitor v=new SSAMemoryAccessVisitor(n);
    for (int i=0; i < statements.length; i++) {
      SSAInstruction s=statements[i];
      if (s != null) {
        v.setInstructionIndex(i);
        s.visit(v);
      }
    }
  }
 else {
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    ShrikeCTMethod sm=(ShrikeCTMethod)n.getMethod();
    MemoryAccessVisitor v=new MemoryAccessVisitor(n.getMethod().getReference().getDeclaringClass().getClassLoader(),n);
    try {
      Instruction[] statements=sm.getInstructions();
      if (statements == null) {
        return;
      }
      if (DEBUG) {
        for (int i=0; i < statements.length; i++) {
          System.err.println(i + ""String_Node_Str"" + statements[i]);
        }
      }
      for (int i=0; i < statements.length; i++) {
        Instruction s=statements[i];
        if (s != null) {
          v.setInstructionIndex(i);
          s.visit(v);
        }
      }
    }
 catch (    InvalidClassFileException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
}","private void populate(CGNode n){
  if (ALWAYS_BUILD_IR || n.getMethod().isSynthetic()) {
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    SSAInstruction[] statements=n.getIR().getInstructions();
    SSAMemoryAccessVisitor v=new SSAMemoryAccessVisitor(n);
    for (int i=0; i < statements.length; i++) {
      SSAInstruction s=statements[i];
      if (s != null) {
        v.setInstructionIndex(i);
        s.visit(v);
      }
    }
  }
 else {
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    ShrikeCTMethod sm=(ShrikeCTMethod)n.getMethod();
    MemoryAccessVisitor v=new MemoryAccessVisitor(n.getMethod().getReference().getDeclaringClass().getClassLoader(),n);
    try {
      Instruction[] statements=sm.getInstructions();
      if (statements == null) {
        return;
      }
      if (DEBUG) {
        for (int i=0; i < statements.length; i++) {
          System.err.println(i + ""String_Node_Str"" + statements[i]);
        }
      }
      for (int i=0; i < statements.length; i++) {
        Instruction s=statements[i];
        if (s != null) {
          v.setInstructionIndex(i);
          s.visit(v);
        }
      }
    }
 catch (    InvalidClassFileException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
}",0.9925925925925926
99956,"private void populate(CGNode n){
  if (n.getMethod().isSynthetic()) {
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    SyntheticMethod sm=(SyntheticMethod)n.getMethod();
    SSAInstruction[] statements=sm.getStatements();
    SSAMemoryAccessVisitor v=new SSAMemoryAccessVisitor(n);
    for (int i=0; i < statements.length; i++) {
      SSAInstruction s=statements[i];
      if (s != null) {
        v.setInstructionIndex(i);
        s.visit(v);
      }
    }
  }
 else {
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    ShrikeCTMethod sm=(ShrikeCTMethod)n.getMethod();
    MemoryAccessVisitor v=new MemoryAccessVisitor(n.getMethod().getReference().getDeclaringClass().getClassLoader(),n);
    try {
      Instruction[] statements=sm.getInstructions();
      if (statements == null) {
        return;
      }
      if (DEBUG) {
        for (int i=0; i < statements.length; i++) {
          System.err.println(i + ""String_Node_Str"" + statements[i]);
        }
      }
      for (int i=0; i < statements.length; i++) {
        Instruction s=statements[i];
        if (s != null) {
          v.setInstructionIndex(i);
          s.visit(v);
        }
      }
    }
 catch (    InvalidClassFileException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
}","private void populate(CGNode n){
  if (n.getMethod().isSynthetic()) {
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    SSAInstruction[] statements=n.getIR().getInstructions();
    SSAMemoryAccessVisitor v=new SSAMemoryAccessVisitor(n);
    for (int i=0; i < statements.length; i++) {
      SSAInstruction s=statements[i];
      if (s != null) {
        v.setInstructionIndex(i);
        s.visit(v);
      }
    }
  }
 else {
    if (DEBUG) {
      System.err.println(""String_Node_Str"");
    }
    ShrikeCTMethod sm=(ShrikeCTMethod)n.getMethod();
    MemoryAccessVisitor v=new MemoryAccessVisitor(n.getMethod().getReference().getDeclaringClass().getClassLoader(),n);
    try {
      Instruction[] statements=sm.getInstructions();
      if (statements == null) {
        return;
      }
      if (DEBUG) {
        for (int i=0; i < statements.length; i++) {
          System.err.println(i + ""String_Node_Str"" + statements[i]);
        }
      }
      for (int i=0; i < statements.length; i++) {
        Instruction s=statements[i];
        if (s != null) {
          v.setInstructionIndex(i);
          s.visit(v);
        }
      }
    }
 catch (    InvalidClassFileException e) {
      e.printStackTrace();
      Assertions.UNREACHABLE();
    }
  }
}",0.9637345679012346
99957,"/** 
 * @return Collection of IClasses, representing the interfaces this class implements.
 */
protected Collection<IClass> computeAllInterfacesAsCollection() throws ClassHierarchyException {
  Collection<IClass> c=getDirectInterfaces();
  Set<IClass> result=HashSetFactory.make();
  for (Iterator<IClass> it=c.iterator(); it.hasNext(); ) {
    IClass klass=it.next();
    if (klass.isInterface()) {
      result.add(klass);
    }
 else {
      Warnings.add(ClassHierarchyWarning.create(""String_Node_Str"" + klass));
    }
  }
  for (Iterator<IClass> it=c.iterator(); it.hasNext(); ) {
    BytecodeClass I=(BytecodeClass)it.next();
    if (I.isInterface()) {
      result.addAll(I.computeAllInterfacesAsCollection());
    }
 else {
      Warnings.add(ClassHierarchyWarning.create(""String_Node_Str"" + I));
    }
  }
  IClass sup=null;
  try {
    sup=getSuperclass();
  }
 catch (  ClassHierarchyException e1) {
    Assertions.UNREACHABLE();
  }
  if (sup != null) {
    result.addAll(sup.getAllImplementedInterfaces());
  }
  return result;
}","/** 
 * @return Collection of IClasses, representing the interfaces this class implements.
 */
protected Collection<IClass> computeAllInterfacesAsCollection() throws ClassHierarchyException {
  Collection<IClass> c=getDirectInterfaces();
  Set<IClass> result=HashSetFactory.make();
  for (Iterator<IClass> it=c.iterator(); it.hasNext(); ) {
    IClass klass=it.next();
    if (klass.isInterface()) {
      result.add(klass);
    }
 else {
      Warnings.add(ClassHierarchyWarning.create(""String_Node_Str"" + klass));
    }
  }
  Set<IClass> last=null;
  do {
    last=HashSetFactory.make(result);
    for (    IClass i : last) {
      result.addAll(i.getDirectInterfaces());
    }
  }
 while (last.size() < result.size());
  IClass sup=null;
  try {
    sup=getSuperclass();
  }
 catch (  ClassHierarchyException e1) {
    Assertions.UNREACHABLE();
  }
  if (sup != null) {
    result.addAll(sup.getAllImplementedInterfaces());
  }
  return result;
}",0.8190954773869347
99958,"/** 
 * Method array2Set.
 * @param interfaces a set of class names
 * @return Set of all IClasses that can be loaded corresponding to the class names in the interfaces array; raise warnings ifclasses can not be loaded
 */
private Collection<IClass> array2IClassSet(ImmutableByteArray[] interfaces){
  ArrayList<IClass> result=new ArrayList<IClass>(interfaces.length);
  for (int i=0; i < interfaces.length; i++) {
    ImmutableByteArray name=interfaces[i];
    IClass klass=null;
    klass=loader.lookupClass(TypeName.findOrCreate(name));
    if (klass == null) {
      Warnings.add(ClassNotFoundWarning.create(name));
    }
 else {
      result.add(klass);
    }
  }
  return result;
}","/** 
 * @param interfaces a set of class names
 * @return Set of all IClasses that can be loaded corresponding to the class names in the interfaces array; raise warnings ifclasses can not be loaded
 */
private Collection<IClass> array2IClassSet(ImmutableByteArray[] interfaces){
  ArrayList<IClass> result=new ArrayList<IClass>(interfaces.length);
  for (int i=0; i < interfaces.length; i++) {
    ImmutableByteArray name=interfaces[i];
    IClass klass=null;
    klass=loader.lookupClass(TypeName.findOrCreate(name));
    if (klass == null) {
      Warnings.add(ClassNotFoundWarning.create(name));
    }
 else {
      result.add(klass);
    }
  }
  return result;
}",0.984478935698448
99959,"/** 
 * @param line a whitespace-delimited string of column names
 */
private void populateColumnHeadings(String line,Character delimiter){
  StringTokenizer st=new StringTokenizer(line,delimiter.toString());
  int nColumns=st.countTokens();
  for (int i=0; i < nColumns; i++) {
    columnHeadings.set(i,(String)st.nextElement());
  }
}","/** 
 * @param line a whitespace-delimited string of column names
 */
private void populateColumnHeadings(String line,Character delimiter){
  StringTokenizer st=delimiter == null ? new StringTokenizer(line) : new StringTokenizer(line,delimiter.toString());
  int nColumns=st.countTokens();
  for (int i=0; i < nColumns; i++) {
    columnHeadings.set(i,(String)st.nextElement());
  }
}",0.9333333333333332
99960,"private void populateRow(int row,String line,Character delimiter){
  StringTokenizer st=new StringTokenizer(line,delimiter.toString());
  int nColumns=st.countTokens();
  Assertions.productionAssertion(nColumns == getNumberOfColumns(),""String_Node_Str"" + getNumberOfColumns() + ""String_Node_Str""+ nColumns+ ""String_Node_Str""+ row+ ""String_Node_Str""+ line.length()+ ""String_Node_Str""+ line);
  SimpleVector<String> r=new SimpleVector<String>();
  rows.add(row,r);
  for (int i=0; i < nColumns; i++) {
    r.set(i,(String)st.nextElement());
  }
}","private void populateRow(int row,String line,Character delimiter){
  StringTokenizer st=delimiter == null ? new StringTokenizer(line) : new StringTokenizer(line,delimiter.toString());
  int nColumns=st.countTokens();
  Assertions.productionAssertion(nColumns == getNumberOfColumns(),""String_Node_Str"" + getNumberOfColumns() + ""String_Node_Str""+ nColumns+ ""String_Node_Str""+ row+ ""String_Node_Str""+ line.length()+ ""String_Node_Str""+ line);
  SimpleVector<String> r=new SimpleVector<String>();
  rows.add(row,r);
  for (int i=0; i < nColumns; i++) {
    r.set(i,(String)st.nextElement());
  }
}",0.9577464788732394
99961,"/** 
 * TODO: really shouldn't allow A to be null.
 */
public DelegatingSSAContextInterpreter(SSAContextInterpreter A,SSAContextInterpreter B){
  super(A,B);
  this.A=A;
  this.B=B;
  if (Assertions.verifyAssertions) {
    Assertions._assert(B != null,""String_Node_Str"");
  }
}","/** 
 * neither A nor B should be null.
 */
public DelegatingSSAContextInterpreter(SSAContextInterpreter A,SSAContextInterpreter B){
  super(A,B);
  this.A=A;
  this.B=B;
  if (A == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (B == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}",0.6427406199021207
99962,"public ZeroXCFABuilder(IClassHierarchy cha,AnalysisOptions options,AnalysisCache cache,ContextSelector appContextSelector,SSAContextInterpreter appContextInterpreter,ReflectionSpecification reflect,int instancePolicy){
  super(cha,options,cache,new DefaultPointerKeyFactory());
  ContextSelector def=new DefaultContextSelector();
  ContextSelector contextSelector=appContextSelector == null ? def : new DelegatingContextSelector(appContextSelector,def);
  setContextSelector(contextSelector);
  SSAContextInterpreter c=new DefaultSSAInterpreter(options,cache);
  c=new DelegatingSSAContextInterpreter(ReflectionContextInterpreter.createReflectionContextInterpreter(cha,options,getAnalysisCache(),reflect),c);
  SSAContextInterpreter contextInterpreter=new DelegatingSSAContextInterpreter(appContextInterpreter,c);
  setContextInterpreter(contextInterpreter);
  ZeroXInstanceKeys zik=makeInstanceKeys(cha,options,contextInterpreter,instancePolicy);
  setInstanceKeys(zik);
}","public ZeroXCFABuilder(IClassHierarchy cha,AnalysisOptions options,AnalysisCache cache,ContextSelector appContextSelector,SSAContextInterpreter appContextInterpreter,ReflectionSpecification reflect,int instancePolicy){
  super(cha,options,cache,new DefaultPointerKeyFactory());
  ContextSelector def=new DefaultContextSelector();
  ContextSelector contextSelector=appContextSelector == null ? def : new DelegatingContextSelector(appContextSelector,def);
  setContextSelector(contextSelector);
  SSAContextInterpreter c=new DefaultSSAInterpreter(options,cache);
  c=new DelegatingSSAContextInterpreter(ReflectionContextInterpreter.createReflectionContextInterpreter(cha,options,getAnalysisCache(),reflect),c);
  SSAContextInterpreter contextInterpreter=appContextInterpreter == null ? c : new DelegatingSSAContextInterpreter(appContextInterpreter,c);
  setContextInterpreter(contextInterpreter);
  ZeroXInstanceKeys zik=makeInstanceKeys(cha,options,contextInterpreter,instancePolicy);
  setInstanceKeys(zik);
}",0.9818365287588294
99963,"protected SSAContextInterpreter makeContextInterpreter(SSAContextInterpreter appContextInterpreter,ReflectionSpecification reflect){
  SSAContextInterpreter defI=new DefaultSSAInterpreter(getOptions(),getAnalysisCache());
  defI=new DelegatingSSAContextInterpreter(ReflectionContextInterpreter.createReflectionContextInterpreter(cha,getOptions(),getAnalysisCache(),reflect),defI);
  SSAContextInterpreter contextInterpreter=new DelegatingSSAContextInterpreter(appContextInterpreter,defI);
  return contextInterpreter;
}","protected SSAContextInterpreter makeContextInterpreter(SSAContextInterpreter appContextInterpreter,ReflectionSpecification reflect){
  SSAContextInterpreter defI=new DefaultSSAInterpreter(getOptions(),getAnalysisCache());
  defI=new DelegatingSSAContextInterpreter(ReflectionContextInterpreter.createReflectionContextInterpreter(cha,getOptions(),getAnalysisCache(),reflect),defI);
  SSAContextInterpreter contextInterpreter=appContextInterpreter == null ? defI : new DelegatingSSAContextInterpreter(appContextInterpreter,defI);
  return contextInterpreter;
}",0.9637883008356546
99964,"@Override public void addSeed(PathEdge<T> seed){
  unbalancedSeeds.add(Pair.make(seed.entry,seed.d1));
  super.addSeed(seed);
}","@Override public void addSeed(PathEdge<T> seed){
  if (getSeeds().contains(seed)) {
    return;
  }
  unbalancedSeeds.add(Pair.make(seed.entry,seed.d1));
  super.addSeed(seed);
}",0.8327868852459016
99965,"/** 
 * Spawn a process to execute the given command
 * @return an object representing the process
 * @throws WalaException
 * @throws IllegalArgumentException
 * @throws IOException
 */
protected Process spawnProcess(String cmd) throws IllegalArgumentException, IOException {
  if (cmd == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (logger != null) {
    logger.fine(""String_Node_Str"" + cmd);
  }
  String[] ev=getEnv() == null ? null : buildEnv(getEnv());
  Process p=Runtime.getRuntime().exec(cmd,ev,getWorkingDir());
  return p;
}","/** 
 * Spawn a process to execute the given command
 * @return an object representing the process
 * @throws WalaException
 * @throws IllegalArgumentException
 * @throws IOException
 */
protected Process spawnProcess(String cmd) throws IllegalArgumentException, IOException {
  if (cmd == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"" + cmd);
  if (logger != null) {
    logger.fine(""String_Node_Str"" + cmd);
  }
  String[] ev=getEnv() == null ? null : buildEnv(getEnv());
  Process p=Runtime.getRuntime().exec(cmd,ev,getWorkingDir());
  return p;
}",0.9602032176121932
99966,"/** 
 * This is fragile.  Use with care.
 * @return a String representing the path to the wala.core plugin installation
 */
public static String getWalaCorePluginHome(){
  if (CorePlugin.getDefault() == null) {
    return null;
  }
  String install=Platform.getInstallLocation().getURL().getPath();
  Bundle b=Platform.getBundle(""String_Node_Str"");
  String l=b.getLocation();
  if (l.startsWith(""String_Node_Str"")) {
    l=l.replace(""String_Node_Str"",""String_Node_Str"");
  }
  return install + File.separator + l;
}","/** 
 * This is fragile.  Use with care.
 * @return a String representing the path to the wala.core plugin installation
 */
public static String getWalaCorePluginHome(){
  if (CorePlugin.getDefault() == null) {
    return null;
  }
  String install=Platform.getInstallLocation().getURL().getPath();
  Bundle b=Platform.getBundle(""String_Node_Str"");
  String l=b.getLocation();
  if (l.startsWith(""String_Node_Str"")) {
    l=l.replace(""String_Node_Str"",""String_Node_Str"");
  }
  if (l.startsWith(""String_Node_Str"")) {
    return l.replace(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    return install + File.separator + l;
  }
}",0.8973913043478261
99967,"private CAstNode walkNodesInternal(final Node n,WalkContext context){
  int NT=n.getType();
switch (NT) {
case Token.FUNCTION:
{
      int fnIndex=n.getExistingIntProp(Node.FUNCTION_PROP);
      FunctionNode fn=context.top().getFunctionNode(fnIndex);
      CAstEntity fne=walkEntity(fn,context);
      if (context.expressionContext()) {
        CAstNode fun=Ast.makeNode(CAstNode.FUNCTION_EXPR,Ast.makeConstant(fne));
        context.addScopedEntity(fun,fne);
        return fun;
      }
 else {
        context.addInitializer(Ast.makeNode(CAstNode.FUNCTION_STMT,Ast.makeConstant(fne)));
        context.addScopedEntity(null,fne);
        return Ast.makeNode(CAstNode.EMPTY);
      }
    }
case Token.CATCH_SCOPE:
{
    Node catchVarNode=n.getFirstChild();
    String catchVarName=catchVarNode.getString();
    Assertions._assert(catchVarName != null);
    context.setCatchVar(catchVarName);
    return Ast.makeNode(CAstNode.EMPTY);
  }
case Token.LOCAL_BLOCK:
{
  return Ast.makeNode(CAstNode.BLOCK_EXPR,gatherChildren(n,context));
}
case Token.TRY:
{
Node catchNode=((Node.Jump)n).target;
Node finallyNode=((Node.Jump)n).getFinally();
ArrayList<Node> tryList=new ArrayList<Node>();
ArrayList<Node> catchList=new ArrayList<Node>();
ArrayList<Node> finallyList=new ArrayList<Node>();
ArrayList<Node> current=tryList;
Node c;
for (c=n.getFirstChild(); c.getNext() != null; c=c.getNext()) {
  if (c == catchNode) {
    current=catchList;
  }
 else   if (c == finallyNode) {
    current=finallyList;
  }
  if (c.getType() == Token.GOTO && (c.getNext() == catchNode || c.getNext() == finallyNode)) {
    continue;
  }
  current.add(c);
}
CAstNode finallyBlock=null;
if (finallyNode != null) {
  int i=0;
  CAstNode[] finallyAsts=new CAstNode[finallyList.size()];
  for (Iterator<Node> fns=finallyList.iterator(); fns.hasNext(); ) {
    finallyAsts[i++]=walkNodes(fns.next(),context);
  }
  finallyBlock=Ast.makeNode(CAstNode.BLOCK_STMT,finallyAsts);
}
if (catchNode != null) {
  int i=0;
  WalkContext catchChild=new CatchBlockContext(context);
  CAstNode[] catchAsts=new CAstNode[catchList.size()];
  for (Iterator<Node> cns=catchList.iterator(); cns.hasNext(); ) {
    catchAsts[i++]=walkNodes(cns.next(),catchChild);
  }
  CAstNode catchBlock=Ast.makeNode(CAstNode.CATCH,Ast.makeConstant(catchChild.getCatchVar()),Ast.makeNode(CAstNode.BLOCK_STMT,catchAsts));
  context.cfg().map(catchBlock,catchBlock);
  i=0;
  WalkContext tryChild=new TryBlockContext(context,catchBlock);
  CAstNode[] tryAsts=new CAstNode[tryList.size()];
  for (Iterator<Node> tns=tryList.iterator(); tns.hasNext(); ) {
    tryAsts[i++]=walkNodes(tns.next(),tryChild);
  }
  CAstNode tryBlock=Ast.makeNode(CAstNode.BLOCK_STMT,tryAsts);
  if (finallyBlock != null) {
    return Ast.makeNode(CAstNode.BLOCK_STMT,Ast.makeNode(CAstNode.UNWIND,Ast.makeNode(CAstNode.TRY,tryBlock,catchBlock),finallyBlock),walkNodes(c,context));
  }
 else {
    return Ast.makeNode(CAstNode.BLOCK_STMT,Ast.makeNode(CAstNode.TRY,tryBlock,catchBlock),walkNodes(c,context));
  }
}
 else {
  int i=0;
  CAstNode[] tryAsts=new CAstNode[tryList.size()];
  for (Iterator<Node> tns=tryList.iterator(); tns.hasNext(); ) {
    tryAsts[i++]=walkNodes(tns.next(),context);
  }
  CAstNode tryBlock=Ast.makeNode(CAstNode.BLOCK_STMT,tryAsts);
  return Ast.makeNode(CAstNode.BLOCK_STMT,Ast.makeNode(CAstNode.UNWIND,Ast.makeNode(CAstNode.BLOCK_STMT,tryBlock),Ast.makeNode(CAstNode.BLOCK_STMT,finallyBlock)),walkNodes(c,context));
}
}
case Token.JSR:
{
return Ast.makeNode(CAstNode.EMPTY);
}
case Token.COMMA:
{
int count=0;
for (Node c=n.getFirstChild(); c != null; count++, c=c.getNext()) ;
CAstNode[] cs=new CAstNode[count];
int i=0;
for (Node c=n.getFirstChild(); c != null; i++, c=c.getNext()) {
if (c.getNext() == null) {
context.copyBase(n,c);
}
cs[i]=walkNodes(c,context);
}
return Ast.makeNode(CAstNode.BLOCK_EXPR,cs);
}
case Token.ENTERWITH:
case Token.LEAVEWITH:
{
return Ast.makeNode(CAstNode.EMPTY);
}
case Token.LOOP:
{
LoopContext child=new LoopContext(context);
CAstNode[] nodes=gatherChildren(n,child);
if (child.forInInitExpr != null) {
String nm=child.forInVar;
return Ast.makeNode(CAstNode.BLOCK_STMT,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new CAstSymbolImpl(nm,true)),walkNodes(child.forInInitExpr,context)),nodes);
}
 else {
return Ast.makeNode(CAstNode.BLOCK_STMT,nodes);
}
}
case Token.WITH:
case Token.FINALLY:
case Token.BLOCK:
case Token.LABEL:
{
Node c1=n.getFirstChild();
if (c1 != null && c1.getType() == Token.SWITCH) {
Node switchValue=c1.getFirstChild();
CAstNode defaultLabel=Ast.makeNode(CAstNode.LABEL_STMT,Ast.makeNode(CAstNode.EMPTY));
context.cfg().map(defaultLabel,defaultLabel);
for (Node kase=switchValue.getNext(); kase != null; kase=kase.getNext()) {
Assertions._assert(kase.getType() == Token.CASE);
Node caseLbl=kase.getFirstChild();
Node target=((Node.Jump)kase).target;
context.cfg().add(c1,target,walkNodes(caseLbl,context));
}
context.cfg().add(c1,defaultLabel,CAstControlFlowMap.SWITCH_DEFAULT);
CAstNode switchAst=Ast.makeNode(CAstNode.SWITCH,walkNodes(switchValue,context),Ast.makeNode(CAstNode.BLOCK_STMT,defaultLabel,gatherChildren(n,context,1)));
noteSourcePosition(context,switchAst,c1);
context.cfg().map(c1,switchAst);
return switchAst;
}
 else {
return Ast.makeNode(CAstNode.BLOCK_STMT,gatherChildren(n,context));
}
}
case Token.EXPR_VOID:
case Token.EXPR_RESULT:
case Token.POS:
{
WalkContext child=new ExpressionContext(context);
Node expr=n.getFirstChild();
if (NT == Token.EXPR_RESULT) {
child.copyBase(n,expr);
}
return walkNodes(expr,child);
}
case Token.CALL:
{
if (!isPrimitiveCall(context,n)) {
CAstNode base=Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str""));
Node callee=n.getFirstChild();
WalkContext child=new BaseCollectingContext(context,callee,base);
CAstNode fun=walkNodes(callee,child);
if (child.foundBase(callee)) return Ast.makeNode(CAstNode.LOCAL_SCOPE,Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new CAstSymbolImpl(""String_Node_Str"")),Ast.makeConstant(null)),makeCall(fun,base,callee.getNext(),context)));
 else return makeCall(fun,Ast.makeConstant(null),callee.getNext(),context);
}
 else {
return Ast.makeNode(CAstNode.PRIMITIVE,gatherChildren(n,context,1));
}
}
case Token.NAME:
{
return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(n.getString()));
}
case Token.THIS:
{
return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str""));
}
case Token.THISFN:
{
return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(((FunctionNode)context.top()).getFunctionName()));
}
case Token.STRING:
{
return Ast.makeConstant(n.getString());
}
case Token.NUMBER:
{
return Ast.makeConstant(n.getDouble());
}
case Token.FALSE:
{
return Ast.makeConstant(false);
}
case Token.TRUE:
{
return Ast.makeConstant(true);
}
case Token.NULL:
{
return Ast.makeConstant(null);
}
case Token.ADD:
case Token.DIV:
case Token.LSH:
case Token.MOD:
case Token.MUL:
case Token.RSH:
case Token.SUB:
case Token.URSH:
case Token.BITAND:
case Token.EQ:
case Token.SHEQ:
case Token.GE:
case Token.GT:
case Token.LE:
case Token.LT:
case Token.SHNE:
case Token.NE:
{
Node l=n.getFirstChild();
Node r=l.getNext();
return Ast.makeNode(CAstNode.BINARY_EXPR,translateOpcode(NT),walkNodes(l,context),walkNodes(r,context));
}
case Token.NEG:
{
return Ast.makeNode(CAstNode.BINARY_EXPR,translateOpcode(Token.SUB),Ast.makeConstant(0),walkNodes(n.getFirstChild(),context));
}
case Token.BITNOT:
case Token.NOT:
{
return Ast.makeNode(CAstNode.UNARY_EXPR,translateOpcode(NT),walkNodes(n.getFirstChild(),context));
}
case Token.VAR:
{
Node nm=n.getFirstChild();
context.addInitializer(Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new CAstSymbolImpl(nm.getString())),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str""))));
if (nm.getFirstChild() != null) {
WalkContext child=new ExpressionContext(context);
return Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(nm.getString())),walkNodes(nm.getFirstChild(),child));
}
 else {
if (n.getNext().getType() == Token.ENUM_INIT_KEYS) {
context.getForInVar(nm.getString(),n.getNext().getFirstChild());
}
return Ast.makeNode(CAstNode.EMPTY);
}
}
case Token.REGEXP:
{
int regexIdx=n.getIntProp(Node.REGEXP_PROP,-1);
Assertions._assert(regexIdx != -1,""String_Node_Str"" + context.top().toStringTree(context.top()) + ""String_Node_Str""+ n.toStringTree(context.top()));
String flags=context.top().getRegexpFlags(regexIdx);
Node flagsNode=Node.newString(flags);
String str=context.top().getRegexpString(regexIdx);
Node strNode=Node.newString(str);
strNode.addChildToFront(flagsNode);
return handleNew(context,""String_Node_Str"",strNode);
}
case Token.ENUM_INIT_KEYS:
{
return Ast.makeNode(CAstNode.EMPTY);
}
case Token.ENUM_ID:
{
return Ast.makeNode(CAstNode.EACH_ELEMENT_GET,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(context.getForInInitVar())));
}
case Token.ENUM_NEXT:
{
return Ast.makeNode(CAstNode.EACH_ELEMENT_HAS_NEXT,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(context.getForInInitVar())));
}
case Token.RETURN:
{
Node val=n.getFirstChild();
if (val != null) {
WalkContext child=new ExpressionContext(context);
return Ast.makeNode(CAstNode.RETURN,walkNodes(val,child));
}
 else {
return Ast.makeNode(CAstNode.RETURN);
}
}
case Token.SETNAME:
{
Node nm=n.getFirstChild();
return Ast.makeNode(CAstNode.ASSIGN,walkNodes(nm,context),walkNodes(nm.getNext(),context));
}
case Token.BINDNAME:
{
return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(n.getString()));
}
case Token.IFNE:
case Token.IFEQ:
{
context.cfg().add(n,((Node.Jump)n).target,Boolean.TRUE);
WalkContext child=new ExpressionContext(context);
CAstNode gotoAst=Ast.makeNode(CAstNode.IFGOTO,translateOpcode(NT),walkNodes(n.getFirstChild(),child),Ast.makeConstant(1));
context.cfg().map(n,gotoAst);
return gotoAst;
}
case Token.GOTO:
{
context.cfg().add(n,((Node.Jump)n).target,null);
CAstNode gotoAst=Ast.makeNode(CAstNode.GOTO,Ast.makeConstant(((Node.Jump)n).target.labelId()));
context.cfg().map(n,gotoAst);
return gotoAst;
}
case Token.BREAK:
{
context.cfg().add(n,((Node.Jump)n).getJumpStatement().target,null);
CAstNode gotoAst=Ast.makeNode(CAstNode.GOTO,Ast.makeConstant(((Node.Jump)n).getJumpStatement().target.labelId()));
context.cfg().map(n,gotoAst);
return gotoAst;
}
case Token.CONTINUE:
{
context.cfg().add(n,((Node.Jump)n).getJumpStatement().getContinue(),null);
CAstNode gotoAst=Ast.makeNode(CAstNode.GOTO,Ast.makeConstant(((Node.Jump)n).getJumpStatement().getContinue().labelId()));
context.cfg().map(n,gotoAst);
return gotoAst;
}
case Token.TARGET:
{
CAstNode result=Ast.makeNode(CAstNode.LABEL_STMT,Ast.makeConstant(n.labelId()),Ast.makeNode(CAstNode.EMPTY));
context.cfg().map(n,result);
return result;
}
case Token.OR:
{
Node l=n.getFirstChild();
Node r=l.getNext();
return Ast.makeNode(CAstNode.IF_EXPR,walkNodes(l,context),Ast.makeConstant(true),walkNodes(r,context));
}
case Token.AND:
{
Node l=n.getFirstChild();
Node r=l.getNext();
return Ast.makeNode(CAstNode.IF_EXPR,walkNodes(l,context),walkNodes(r,context),Ast.makeConstant(false));
}
case Token.HOOK:
{
Node cond=n.getFirstChild();
Node thenBranch=cond.getNext();
Node elseBranch=thenBranch.getNext();
return Ast.makeNode(CAstNode.IF_EXPR,walkNodes(cond,context),walkNodes(thenBranch,context),walkNodes(elseBranch,context));
}
case Token.INC:
case Token.DEC:
{
int flags=n.getIntProp(Node.INCRDECR_PROP,-1);
CAstNode op=((flags & Node.DECR_FLAG) != 0) ? CAstOperator.OP_SUB : CAstOperator.OP_ADD;
Node l=n.getFirstChild();
CAstNode last=walkNodes(l,context);
return Ast.makeNode((((flags & Node.POST_FLAG) != 0) ? CAstNode.ASSIGN_POST_OP : CAstNode.ASSIGN_PRE_OP),last,Ast.makeConstant(1),op);
}
case Token.NEW:
{
if (isPrimitiveCreation(context,n)) {
return makeBuiltinNew(context,n.getFirstChild().getString());
}
 else {
Node receiver=n.getFirstChild();
return handleNew(context,walkNodes(receiver,context),receiver.getNext());
}
}
case Token.ARRAYLIT:
{
int count=0;
for (Node x=n.getFirstChild(); x != null; count++, x=x.getNext()) ;
int i=0;
CAstNode[] args=new CAstNode[2 * count + 1];
args[i++]=(isPrologueScript(context)) ? makeBuiltinNew(context,""String_Node_Str"") : handleNew(context,""String_Node_Str"",null);
int[] skips=(int[])n.getProp(Node.SKIP_INDEXES_PROP);
int skip=0;
int idx=0;
Node elt=n.getFirstChild();
while (elt != null) {
if (skips != null && skip < skips.length && skips[skip] == idx) {
skip++;
idx++;
continue;
}
args[i++]=Ast.makeConstant(idx++);
args[i++]=walkNodes(elt,context);
elt=elt.getNext();
}
return Ast.makeNode(CAstNode.OBJECT_LITERAL,args);
}
case Token.OBJECTLIT:
{
Object[] propertyList=(Object[])n.getProp(Node.OBJECT_IDS_PROP);
CAstNode[] args=new CAstNode[propertyList.length * 2 + 1];
int i=0;
args[i++]=((isPrologueScript(context)) ? makeBuiltinNew(context,""String_Node_Str"") : handleNew(context,""String_Node_Str"",null));
Node val=n.getFirstChild();
int nameIdx=0;
for (; nameIdx < propertyList.length; nameIdx++, val=val.getNext()) {
args[i++]=Ast.makeConstant(propertyList[nameIdx]);
args[i++]=walkNodes(val,context);
}
return Ast.makeNode(CAstNode.OBJECT_LITERAL,args);
}
case Token.GETPROP:
case Token.GETELEM:
{
Node receiver=n.getFirstChild();
Node element=receiver.getNext();
CAstNode rcvr=walkNodes(receiver,context);
CAstNode baseVar=context.setBase(n);
CAstNode elt=walkNodes(element,context);
if (baseVar != null) {
return Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.ASSIGN,baseVar,rcvr),Ast.makeNode(CAstNode.OBJECT_REF,baseVar,elt));
}
 else {
return Ast.makeNode(CAstNode.OBJECT_REF,rcvr,elt);
}
}
case Token.SETPROP:
case Token.SETELEM:
{
Node receiver=n.getFirstChild();
Node elt=receiver.getNext();
Node val=elt.getNext();
CAstNode rcvr=walkNodes(receiver,context);
return Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.OBJECT_REF,rcvr,walkNodes(elt,context)),walkNodes(val,context));
}
case Token.DELPROP:
{
Node receiver=n.getFirstChild();
Node element=receiver.getNext();
CAstNode rcvr=walkNodes(receiver,context);
CAstNode baseVar=context.setBase(n);
CAstNode elt=walkNodes(element,context);
if (baseVar != null) {
return Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.ASSIGN,baseVar,rcvr),Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.OBJECT_REF,baseVar,elt),Ast.makeConstant(null)));
}
 else {
return Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.OBJECT_REF,rcvr,elt),Ast.makeConstant(null));
}
}
case Token.TYPEOFNAME:
{
return Ast.makeNode(CAstNode.TYPE_OF,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(n.getString())));
}
case Token.TYPEOF:
{
return Ast.makeNode(CAstNode.TYPE_OF,walkNodes(n.getFirstChild(),context));
}
case Token.SETPROP_OP:
case Token.SETELEM_OP:
{
Node receiver=n.getFirstChild();
Node elt=receiver.getNext();
Node op=elt.getNext();
CAstNode rcvr=walkNodes(receiver,context);
return Ast.makeNode(CAstNode.ASSIGN_POST_OP,Ast.makeNode(CAstNode.OBJECT_REF,rcvr,walkNodes(elt,context)),walkNodes(op.getFirstChild().getNext(),context),translateOpcode(op.getType()));
}
case Token.THROW:
{
CAstNode catchNode=context.getCatchTarget();
if (catchNode != null) context.cfg().add(n,context.getCatchTarget(),null);
 else context.cfg().add(n,CAstControlFlowMap.EXCEPTION_TO_EXIT,null);
CAstNode throwAst=Ast.makeNode(CAstNode.THROW,walkNodes(n.getFirstChild(),context));
context.cfg().map(n,throwAst);
return throwAst;
}
case Token.EMPTY:
{
return Ast.makeConstant(null);
}
default :
{
System.err.println(""String_Node_Str"" + context.top().toStringTree(context.top()) + ""String_Node_Str""+ n.toStringTree(context.top())+ ""String_Node_Str""+ NT+ ""String_Node_Str""+ n.getClass()+ ""String_Node_Str"");
Assertions.UNREACHABLE();
return null;
}
}
}","private CAstNode walkNodesInternal(final Node n,WalkContext context){
  int NT=n.getType();
switch (NT) {
case Token.FUNCTION:
{
      int fnIndex=n.getExistingIntProp(Node.FUNCTION_PROP);
      FunctionNode fn=context.top().getFunctionNode(fnIndex);
      CAstEntity fne=walkEntity(fn,context);
      if (context.expressionContext()) {
        CAstNode fun=Ast.makeNode(CAstNode.FUNCTION_EXPR,Ast.makeConstant(fne));
        context.addScopedEntity(fun,fne);
        return fun;
      }
 else {
        context.addInitializer(Ast.makeNode(CAstNode.FUNCTION_STMT,Ast.makeConstant(fne)));
        context.addScopedEntity(null,fne);
        return Ast.makeNode(CAstNode.EMPTY);
      }
    }
case Token.CATCH_SCOPE:
{
    Node catchVarNode=n.getFirstChild();
    String catchVarName=catchVarNode.getString();
    Assertions._assert(catchVarName != null);
    context.setCatchVar(catchVarName);
    return Ast.makeNode(CAstNode.EMPTY);
  }
case Token.LOCAL_BLOCK:
{
  return Ast.makeNode(CAstNode.BLOCK_EXPR,gatherChildren(n,context));
}
case Token.TRY:
{
Node catchNode=((Node.Jump)n).target;
Node finallyNode=((Node.Jump)n).getFinally();
ArrayList<Node> tryList=new ArrayList<Node>();
ArrayList<Node> catchList=new ArrayList<Node>();
ArrayList<Node> finallyList=new ArrayList<Node>();
ArrayList<Node> current=tryList;
Node c;
for (c=n.getFirstChild(); c.getNext() != null; c=c.getNext()) {
  if (c == catchNode) {
    current=catchList;
  }
 else   if (c == finallyNode) {
    current=finallyList;
  }
  if (c.getType() == Token.GOTO && (c.getNext() == catchNode || c.getNext() == finallyNode)) {
    continue;
  }
  current.add(c);
}
CAstNode finallyBlock=null;
if (finallyNode != null) {
  int i=0;
  CAstNode[] finallyAsts=new CAstNode[finallyList.size()];
  for (Iterator<Node> fns=finallyList.iterator(); fns.hasNext(); ) {
    finallyAsts[i++]=walkNodes(fns.next(),context);
  }
  finallyBlock=Ast.makeNode(CAstNode.BLOCK_STMT,finallyAsts);
}
if (catchNode != null) {
  int i=0;
  WalkContext catchChild=new CatchBlockContext(context);
  CAstNode[] catchAsts=new CAstNode[catchList.size()];
  for (Iterator<Node> cns=catchList.iterator(); cns.hasNext(); ) {
    catchAsts[i++]=walkNodes(cns.next(),catchChild);
  }
  CAstNode catchBlock=Ast.makeNode(CAstNode.CATCH,Ast.makeConstant(catchChild.getCatchVar()),Ast.makeNode(CAstNode.BLOCK_STMT,catchAsts));
  context.cfg().map(catchBlock,catchBlock);
  i=0;
  WalkContext tryChild=new TryBlockContext(context,catchBlock);
  CAstNode[] tryAsts=new CAstNode[tryList.size()];
  for (Iterator<Node> tns=tryList.iterator(); tns.hasNext(); ) {
    tryAsts[i++]=walkNodes(tns.next(),tryChild);
  }
  CAstNode tryBlock=Ast.makeNode(CAstNode.BLOCK_STMT,tryAsts);
  if (finallyBlock != null) {
    return Ast.makeNode(CAstNode.BLOCK_STMT,Ast.makeNode(CAstNode.UNWIND,Ast.makeNode(CAstNode.TRY,tryBlock,catchBlock),finallyBlock),walkNodes(c,context));
  }
 else {
    return Ast.makeNode(CAstNode.BLOCK_STMT,Ast.makeNode(CAstNode.TRY,tryBlock,catchBlock),walkNodes(c,context));
  }
}
 else {
  int i=0;
  CAstNode[] tryAsts=new CAstNode[tryList.size()];
  for (Iterator<Node> tns=tryList.iterator(); tns.hasNext(); ) {
    tryAsts[i++]=walkNodes(tns.next(),context);
  }
  CAstNode tryBlock=Ast.makeNode(CAstNode.BLOCK_STMT,tryAsts);
  return Ast.makeNode(CAstNode.BLOCK_STMT,Ast.makeNode(CAstNode.UNWIND,Ast.makeNode(CAstNode.BLOCK_STMT,tryBlock),Ast.makeNode(CAstNode.BLOCK_STMT,finallyBlock)),walkNodes(c,context));
}
}
case Token.JSR:
{
return Ast.makeNode(CAstNode.EMPTY);
}
case Token.COMMA:
{
int count=0;
for (Node c=n.getFirstChild(); c != null; count++, c=c.getNext()) ;
CAstNode[] cs=new CAstNode[count];
int i=0;
for (Node c=n.getFirstChild(); c != null; i++, c=c.getNext()) {
if (c.getNext() == null) {
context.copyBase(n,c);
}
cs[i]=walkNodes(c,context);
}
return Ast.makeNode(CAstNode.BLOCK_EXPR,cs);
}
case Token.ENTERWITH:
case Token.LEAVEWITH:
{
return Ast.makeNode(CAstNode.EMPTY);
}
case Token.LOOP:
{
LoopContext child=new LoopContext(context);
CAstNode[] nodes=gatherChildren(n,child);
if (child.forInInitExpr != null) {
String nm=child.forInVar;
return Ast.makeNode(CAstNode.BLOCK_STMT,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new CAstSymbolImpl(nm,true)),walkNodes(child.forInInitExpr,context)),nodes);
}
 else {
return Ast.makeNode(CAstNode.BLOCK_STMT,nodes);
}
}
case Token.WITH:
case Token.FINALLY:
case Token.BLOCK:
case Token.LABEL:
{
Node c1=n.getFirstChild();
if (c1 != null && c1.getType() == Token.SWITCH) {
Node switchValue=c1.getFirstChild();
CAstNode defaultLabel=Ast.makeNode(CAstNode.LABEL_STMT,Ast.makeNode(CAstNode.EMPTY));
context.cfg().map(defaultLabel,defaultLabel);
for (Node kase=switchValue.getNext(); kase != null; kase=kase.getNext()) {
Assertions._assert(kase.getType() == Token.CASE);
Node caseLbl=kase.getFirstChild();
Node target=((Node.Jump)kase).target;
context.cfg().add(c1,target,walkNodes(caseLbl,context));
}
context.cfg().add(c1,defaultLabel,CAstControlFlowMap.SWITCH_DEFAULT);
CAstNode switchAst=Ast.makeNode(CAstNode.SWITCH,walkNodes(switchValue,context),Ast.makeNode(CAstNode.BLOCK_STMT,defaultLabel,gatherChildren(n,context,1)));
noteSourcePosition(context,switchAst,c1);
context.cfg().map(c1,switchAst);
return switchAst;
}
 else {
return Ast.makeNode(CAstNode.BLOCK_STMT,gatherChildren(n,context));
}
}
case Token.EXPR_VOID:
case Token.EXPR_RESULT:
case Token.POS:
{
WalkContext child=new ExpressionContext(context);
Node expr=n.getFirstChild();
if (NT == Token.EXPR_RESULT) {
child.copyBase(n,expr);
}
return walkNodes(expr,child);
}
case Token.CALL:
{
if (!isPrimitiveCall(context,n)) {
CAstNode base=Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str""));
Node callee=n.getFirstChild();
WalkContext child=new BaseCollectingContext(context,callee,base);
CAstNode fun=walkNodes(callee,child);
if (child.foundBase(callee)) return Ast.makeNode(CAstNode.LOCAL_SCOPE,Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new CAstSymbolImpl(""String_Node_Str"")),Ast.makeConstant(null)),makeCall(fun,base,callee.getNext(),context)));
 else return makeCall(fun,Ast.makeConstant(null),callee.getNext(),context);
}
 else {
return Ast.makeNode(CAstNode.PRIMITIVE,gatherChildren(n,context,1));
}
}
case Token.NAME:
{
return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(n.getString()));
}
case Token.THIS:
{
return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str""));
}
case Token.THISFN:
{
return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(((FunctionNode)context.top()).getFunctionName()));
}
case Token.STRING:
{
return Ast.makeConstant(n.getString());
}
case Token.NUMBER:
{
return Ast.makeConstant(n.getDouble());
}
case Token.FALSE:
{
return Ast.makeConstant(false);
}
case Token.TRUE:
{
return Ast.makeConstant(true);
}
case Token.NULL:
case Token.VOID:
{
return Ast.makeConstant(null);
}
case Token.ADD:
case Token.DIV:
case Token.LSH:
case Token.MOD:
case Token.MUL:
case Token.RSH:
case Token.SUB:
case Token.URSH:
case Token.BITAND:
case Token.BITOR:
case Token.BITXOR:
case Token.EQ:
case Token.SHEQ:
case Token.GE:
case Token.GT:
case Token.LE:
case Token.LT:
case Token.SHNE:
case Token.NE:
{
Node l=n.getFirstChild();
Node r=l.getNext();
return Ast.makeNode(CAstNode.BINARY_EXPR,translateOpcode(NT),walkNodes(l,context),walkNodes(r,context));
}
case Token.NEG:
{
return Ast.makeNode(CAstNode.BINARY_EXPR,translateOpcode(Token.SUB),Ast.makeConstant(0),walkNodes(n.getFirstChild(),context));
}
case Token.BITNOT:
case Token.NOT:
{
return Ast.makeNode(CAstNode.UNARY_EXPR,translateOpcode(NT),walkNodes(n.getFirstChild(),context));
}
case Token.VAR:
{
Node nm=n.getFirstChild();
context.addInitializer(Ast.makeNode(CAstNode.DECL_STMT,Ast.makeConstant(new CAstSymbolImpl(nm.getString())),Ast.makeNode(CAstNode.VAR,Ast.makeConstant(""String_Node_Str""))));
if (nm.getFirstChild() != null) {
WalkContext child=new ExpressionContext(context);
return Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(nm.getString())),walkNodes(nm.getFirstChild(),child));
}
 else {
return Ast.makeNode(CAstNode.EMPTY);
}
}
case Token.REGEXP:
{
int regexIdx=n.getIntProp(Node.REGEXP_PROP,-1);
Assertions._assert(regexIdx != -1,""String_Node_Str"" + context.top().toStringTree(context.top()) + ""String_Node_Str""+ n.toStringTree(context.top()));
String flags=context.top().getRegexpFlags(regexIdx);
Node flagsNode=Node.newString(flags);
String str=context.top().getRegexpString(regexIdx);
Node strNode=Node.newString(str);
strNode.addChildToFront(flagsNode);
return handleNew(context,""String_Node_Str"",strNode);
}
case Token.ENUM_INIT_KEYS:
{
context.getForInVar(n.getFirstChild());
return Ast.makeNode(CAstNode.EMPTY);
}
case Token.ENUM_ID:
{
return Ast.makeNode(CAstNode.EACH_ELEMENT_GET,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(context.getForInInitVar())));
}
case Token.ENUM_NEXT:
{
return Ast.makeNode(CAstNode.EACH_ELEMENT_HAS_NEXT,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(context.getForInInitVar())));
}
case Token.RETURN:
{
Node val=n.getFirstChild();
if (val != null) {
WalkContext child=new ExpressionContext(context);
return Ast.makeNode(CAstNode.RETURN,walkNodes(val,child));
}
 else {
return Ast.makeNode(CAstNode.RETURN);
}
}
case Token.SETNAME:
{
Node nm=n.getFirstChild();
return Ast.makeNode(CAstNode.ASSIGN,walkNodes(nm,context),walkNodes(nm.getNext(),context));
}
case Token.BINDNAME:
{
return Ast.makeNode(CAstNode.VAR,Ast.makeConstant(n.getString()));
}
case Token.IFNE:
case Token.IFEQ:
{
context.cfg().add(n,((Node.Jump)n).target,Boolean.TRUE);
WalkContext child=new ExpressionContext(context);
CAstNode gotoAst=Ast.makeNode(CAstNode.IFGOTO,translateOpcode(NT),walkNodes(n.getFirstChild(),child),Ast.makeConstant(1));
context.cfg().map(n,gotoAst);
return gotoAst;
}
case Token.GOTO:
{
context.cfg().add(n,((Node.Jump)n).target,null);
CAstNode gotoAst=Ast.makeNode(CAstNode.GOTO,Ast.makeConstant(((Node.Jump)n).target.labelId()));
context.cfg().map(n,gotoAst);
return gotoAst;
}
case Token.BREAK:
{
context.cfg().add(n,((Node.Jump)n).getJumpStatement().target,null);
CAstNode gotoAst=Ast.makeNode(CAstNode.GOTO,Ast.makeConstant(((Node.Jump)n).getJumpStatement().target.labelId()));
context.cfg().map(n,gotoAst);
return gotoAst;
}
case Token.CONTINUE:
{
context.cfg().add(n,((Node.Jump)n).getJumpStatement().getContinue(),null);
CAstNode gotoAst=Ast.makeNode(CAstNode.GOTO,Ast.makeConstant(((Node.Jump)n).getJumpStatement().getContinue().labelId()));
context.cfg().map(n,gotoAst);
return gotoAst;
}
case Token.TARGET:
{
CAstNode result=Ast.makeNode(CAstNode.LABEL_STMT,Ast.makeConstant(n.labelId()),Ast.makeNode(CAstNode.EMPTY));
context.cfg().map(n,result);
return result;
}
case Token.OR:
{
Node l=n.getFirstChild();
Node r=l.getNext();
return Ast.makeNode(CAstNode.IF_EXPR,walkNodes(l,context),Ast.makeConstant(true),walkNodes(r,context));
}
case Token.AND:
{
Node l=n.getFirstChild();
Node r=l.getNext();
return Ast.makeNode(CAstNode.IF_EXPR,walkNodes(l,context),walkNodes(r,context),Ast.makeConstant(false));
}
case Token.HOOK:
{
Node cond=n.getFirstChild();
Node thenBranch=cond.getNext();
Node elseBranch=thenBranch.getNext();
return Ast.makeNode(CAstNode.IF_EXPR,walkNodes(cond,context),walkNodes(thenBranch,context),walkNodes(elseBranch,context));
}
case Token.INC:
case Token.DEC:
{
int flags=n.getIntProp(Node.INCRDECR_PROP,-1);
CAstNode op=((flags & Node.DECR_FLAG) != 0) ? CAstOperator.OP_SUB : CAstOperator.OP_ADD;
Node l=n.getFirstChild();
CAstNode last=walkNodes(l,context);
return Ast.makeNode((((flags & Node.POST_FLAG) != 0) ? CAstNode.ASSIGN_POST_OP : CAstNode.ASSIGN_PRE_OP),last,Ast.makeConstant(1),op);
}
case Token.NEW:
{
if (isPrimitiveCreation(context,n)) {
return makeBuiltinNew(context,n.getFirstChild().getString());
}
 else {
Node receiver=n.getFirstChild();
return handleNew(context,walkNodes(receiver,context),receiver.getNext());
}
}
case Token.ARRAYLIT:
{
int count=0;
for (Node x=n.getFirstChild(); x != null; count++, x=x.getNext()) ;
int i=0;
CAstNode[] args=new CAstNode[2 * count + 1];
args[i++]=(isPrologueScript(context)) ? makeBuiltinNew(context,""String_Node_Str"") : handleNew(context,""String_Node_Str"",null);
int[] skips=(int[])n.getProp(Node.SKIP_INDEXES_PROP);
int skip=0;
int idx=0;
Node elt=n.getFirstChild();
while (elt != null) {
if (skips != null && skip < skips.length && skips[skip] == idx) {
skip++;
idx++;
continue;
}
args[i++]=Ast.makeConstant(idx++);
args[i++]=walkNodes(elt,context);
elt=elt.getNext();
}
return Ast.makeNode(CAstNode.OBJECT_LITERAL,args);
}
case Token.OBJECTLIT:
{
Object[] propertyList=(Object[])n.getProp(Node.OBJECT_IDS_PROP);
CAstNode[] args=new CAstNode[propertyList.length * 2 + 1];
int i=0;
args[i++]=((isPrologueScript(context)) ? makeBuiltinNew(context,""String_Node_Str"") : handleNew(context,""String_Node_Str"",null));
Node val=n.getFirstChild();
int nameIdx=0;
for (; nameIdx < propertyList.length; nameIdx++, val=val.getNext()) {
args[i++]=Ast.makeConstant(propertyList[nameIdx]);
args[i++]=walkNodes(val,context);
}
return Ast.makeNode(CAstNode.OBJECT_LITERAL,args);
}
case Token.GETPROP:
case Token.GETELEM:
{
Node receiver=n.getFirstChild();
Node element=receiver.getNext();
CAstNode rcvr=walkNodes(receiver,context);
CAstNode baseVar=context.setBase(n);
CAstNode elt=walkNodes(element,context);
if (baseVar != null) {
return Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.ASSIGN,baseVar,rcvr),Ast.makeNode(CAstNode.OBJECT_REF,baseVar,elt));
}
 else {
return Ast.makeNode(CAstNode.OBJECT_REF,rcvr,elt);
}
}
case Token.SETPROP:
case Token.SETELEM:
{
Node receiver=n.getFirstChild();
Node elt=receiver.getNext();
Node val=elt.getNext();
CAstNode rcvr=walkNodes(receiver,context);
return Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.OBJECT_REF,rcvr,walkNodes(elt,context)),walkNodes(val,context));
}
case Token.DELPROP:
{
Node receiver=n.getFirstChild();
Node element=receiver.getNext();
CAstNode rcvr=walkNodes(receiver,context);
CAstNode baseVar=context.setBase(n);
CAstNode elt=walkNodes(element,context);
if (baseVar != null) {
return Ast.makeNode(CAstNode.BLOCK_EXPR,Ast.makeNode(CAstNode.ASSIGN,baseVar,rcvr),Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.OBJECT_REF,baseVar,elt),Ast.makeConstant(null)));
}
 else {
return Ast.makeNode(CAstNode.ASSIGN,Ast.makeNode(CAstNode.OBJECT_REF,rcvr,elt),Ast.makeConstant(null));
}
}
case Token.TYPEOFNAME:
{
return Ast.makeNode(CAstNode.TYPE_OF,Ast.makeNode(CAstNode.VAR,Ast.makeConstant(n.getString())));
}
case Token.TYPEOF:
{
return Ast.makeNode(CAstNode.TYPE_OF,walkNodes(n.getFirstChild(),context));
}
case Token.SETPROP_OP:
case Token.SETELEM_OP:
{
Node receiver=n.getFirstChild();
Node elt=receiver.getNext();
Node op=elt.getNext();
CAstNode rcvr=walkNodes(receiver,context);
return Ast.makeNode(CAstNode.ASSIGN_POST_OP,Ast.makeNode(CAstNode.OBJECT_REF,rcvr,walkNodes(elt,context)),walkNodes(op.getFirstChild().getNext(),context),translateOpcode(op.getType()));
}
case Token.THROW:
{
CAstNode catchNode=context.getCatchTarget();
if (catchNode != null) context.cfg().add(n,context.getCatchTarget(),null);
 else context.cfg().add(n,CAstControlFlowMap.EXCEPTION_TO_EXIT,null);
CAstNode throwAst=Ast.makeNode(CAstNode.THROW,walkNodes(n.getFirstChild(),context));
context.cfg().map(n,throwAst);
return throwAst;
}
case Token.EMPTY:
{
return Ast.makeConstant(null);
}
default :
{
System.err.println(""String_Node_Str"" + context.top().toStringTree(context.top()) + ""String_Node_Str""+ n.toStringTree(context.top())+ ""String_Node_Str""+ NT+ ""String_Node_Str""+ n.getClass()+ ""String_Node_Str"");
Assertions.UNREACHABLE();
return null;
}
}
}",0.993128692525045
99968,"public String getForInVar(String loopVarName,Node initExpr){
  this.loopVarName=loopVarName;
  this.forInVar=""String_Node_Str"" + counter++;
  this.forInInitExpr=initExpr;
  return forInVar;
}","public String getForInVar(Node initExpr){
  this.forInVar=""String_Node_Str"" + counter++;
  this.forInInitExpr=initExpr;
  return forInVar;
}",0.8459214501510574
99969,"public String getForInLoopVar(){
  Assertions._assert(loopVarName != null);
  return loopVarName;
}","public String getForInLoopVar(){
  return null;
}",0.6216216216216216
99970,"private CAstNode translateOpcode(int nodeType){
switch (nodeType) {
case Token.ADD:
    return CAstOperator.OP_ADD;
case Token.DIV:
  return CAstOperator.OP_DIV;
case Token.LSH:
return CAstOperator.OP_LSH;
case Token.MOD:
return CAstOperator.OP_MOD;
case Token.MUL:
return CAstOperator.OP_MUL;
case Token.RSH:
return CAstOperator.OP_RSH;
case Token.SUB:
return CAstOperator.OP_SUB;
case Token.URSH:
return CAstOperator.OP_URSH;
case Token.BITAND:
return CAstOperator.OP_BIT_AND;
case Token.EQ:
return CAstOperator.OP_EQ;
case Token.SHEQ:
return CAstOperator.OP_EQ;
case Token.IFEQ:
return CAstOperator.OP_EQ;
case Token.GE:
return CAstOperator.OP_GE;
case Token.GT:
return CAstOperator.OP_GT;
case Token.LE:
return CAstOperator.OP_LE;
case Token.LT:
return CAstOperator.OP_LT;
case Token.NE:
return CAstOperator.OP_NE;
case Token.SHNE:
return CAstOperator.OP_NE;
case Token.IFNE:
return CAstOperator.OP_NE;
case Token.BITNOT:
return CAstOperator.OP_BITNOT;
case Token.NOT:
return CAstOperator.OP_NOT;
default :
Assertions.UNREACHABLE();
return null;
}
}","private CAstNode translateOpcode(int nodeType){
switch (nodeType) {
case Token.ADD:
    return CAstOperator.OP_ADD;
case Token.DIV:
  return CAstOperator.OP_DIV;
case Token.LSH:
return CAstOperator.OP_LSH;
case Token.MOD:
return CAstOperator.OP_MOD;
case Token.MUL:
return CAstOperator.OP_MUL;
case Token.RSH:
return CAstOperator.OP_RSH;
case Token.SUB:
return CAstOperator.OP_SUB;
case Token.URSH:
return CAstOperator.OP_URSH;
case Token.BITAND:
return CAstOperator.OP_BIT_AND;
case Token.BITOR:
return CAstOperator.OP_BIT_OR;
case Token.BITXOR:
return CAstOperator.OP_BIT_XOR;
case Token.EQ:
return CAstOperator.OP_EQ;
case Token.SHEQ:
return CAstOperator.OP_EQ;
case Token.IFEQ:
return CAstOperator.OP_EQ;
case Token.GE:
return CAstOperator.OP_GE;
case Token.GT:
return CAstOperator.OP_GT;
case Token.LE:
return CAstOperator.OP_LE;
case Token.LT:
return CAstOperator.OP_LT;
case Token.NE:
return CAstOperator.OP_NE;
case Token.SHNE:
return CAstOperator.OP_NE;
case Token.IFNE:
return CAstOperator.OP_NE;
case Token.BITNOT:
return CAstOperator.OP_BITNOT;
case Token.NOT:
return CAstOperator.OP_NOT;
default :
Assertions.UNREACHABLE();
return null;
}
}",0.9546690843155032
99971,"/** 
 * Add a New statement of the given type
 * @return instruction added, or null
 * @throws IllegalArgumentException if T is null
 */
private SSANewInstruction addAllocation(TypeReference T,boolean invokeCtor){
  if (T == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int instance=nextLocal++;
  SSANewInstruction result=null;
  if (T.isReferenceType()) {
    NewSiteReference ref=NewSiteReference.make(statements.size(),T);
    if (T.isArrayType()) {
      int[] sizes=new int[T.getDimensionality()];
      Arrays.fill(sizes,getValueNumberForIntConstant(1));
      result=new SSANewInstruction(instance,ref,sizes);
    }
 else {
      result=new SSANewInstruction(instance,ref);
    }
    statements.add(result);
    IClass klass=cha.lookupClass(T);
    if (klass == null) {
      Warnings.add(AllocationFailure.create(T));
      return null;
    }
    if (klass.isArrayClass()) {
      int arrayRef=result.getDef();
      TypeReference e=klass.getReference().getArrayElementType();
      while (e != null && !e.isPrimitiveType()) {
        NewSiteReference n=NewSiteReference.make(statements.size(),e);
        int alloc=nextLocal++;
        SSANewInstruction ni=null;
        if (e.isArrayType()) {
          int[] sizes=new int[T.getDimensionality()];
          Arrays.fill(sizes,getValueNumberForIntConstant(1));
          ni=new SSANewInstruction(alloc,n,sizes);
        }
 else {
          ni=new SSANewInstruction(alloc,n);
        }
        statements.add(ni);
        SSAArrayStoreInstruction store=new SSAArrayStoreInstruction(arrayRef,0,alloc,e);
        statements.add(store);
        e=e.isArrayType() ? e.getArrayElementType() : null;
        arrayRef=alloc;
      }
    }
    if (invokeCtor) {
      IMethod ctor=cha.resolveMethod(klass,MethodReference.initSelector);
      if (ctor != null) {
        addInvocation(new int[]{instance},CallSiteReference.make(statements.size(),ctor.getReference(),IInvokeInstruction.Dispatch.SPECIAL));
      }
    }
  }
  cache.invalidate(this,Everywhere.EVERYWHERE);
  return result;
}","/** 
 * Add a New statement of the given type
 * @return instruction added, or null
 * @throws IllegalArgumentException if T is null
 */
private SSANewInstruction addAllocation(TypeReference T,boolean invokeCtor){
  if (T == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int instance=nextLocal++;
  SSANewInstruction result=null;
  if (T.isReferenceType()) {
    NewSiteReference ref=NewSiteReference.make(statements.size(),T);
    if (T.isArrayType()) {
      int[] sizes=new int[T.getDimensionality()];
      Arrays.fill(sizes,getValueNumberForIntConstant(1));
      result=new SSANewInstruction(instance,ref,sizes);
    }
 else {
      result=new SSANewInstruction(instance,ref);
    }
    statements.add(result);
    IClass klass=cha.lookupClass(T);
    if (klass == null) {
      Warnings.add(AllocationFailure.create(T));
      return null;
    }
    if (klass.isArrayClass()) {
      int arrayRef=result.getDef();
      TypeReference e=klass.getReference().getArrayElementType();
      while (e != null && !e.isPrimitiveType()) {
        NewSiteReference n=NewSiteReference.make(statements.size(),e);
        int alloc=nextLocal++;
        SSANewInstruction ni=null;
        if (e.isArrayType()) {
          int[] sizes=new int[T.getDimensionality()];
          Arrays.fill(sizes,getValueNumberForIntConstant(1));
          ni=new SSANewInstruction(alloc,n,sizes);
        }
 else {
          ni=new SSANewInstruction(alloc,n);
        }
        statements.add(ni);
        SSAArrayStoreInstruction store=new SSAArrayStoreInstruction(arrayRef,getValueNumberForIntConstant(0),alloc,e);
        statements.add(store);
        e=e.isArrayType() ? e.getArrayElementType() : null;
        arrayRef=alloc;
      }
    }
    if (invokeCtor) {
      IMethod ctor=cha.resolveMethod(klass,MethodReference.initSelector);
      if (ctor != null) {
        addInvocation(new int[]{instance},CallSiteReference.make(statements.size(),ctor.getReference(),IInvokeInstruction.Dispatch.SPECIAL));
      }
    }
  }
  cache.invalidate(this,Everywhere.EVERYWHERE);
  return result;
}",0.9927919269581932
99972,"public boolean hasEdge(Statement src,Statement dst){
  addPDGStatementNodes(src.getNode());
  addPDGStatementNodes(dst.getNode());
switch (src.getKind()) {
case NORMAL:
    if (cOptions.equals(ControlDependenceOptions.NONE)) {
      return getPDG(src.getNode()).hasEdge(src,dst);
    }
 else {
      NormalStatement ns=(NormalStatement)src;
      if (dst instanceof MethodEntryStatement) {
        if (ns.getInstruction() instanceof SSAAbstractInvokeInstruction) {
          SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)ns.getInstruction();
          return cg.getPossibleTargets(src.getNode(),call.getCallSite()).contains(dst.getNode());
        }
 else {
          return false;
        }
      }
 else {
        return getPDG(src.getNode()).hasEdge(src,dst);
      }
    }
case PHI:
case PI:
case EXC_RET_CALLER:
case NORMAL_RET_CALLER:
case PARAM_CALLEE:
case HEAP_PARAM_CALLEE:
case HEAP_RET_CALLER:
case METHOD_ENTRY:
  return getPDG(src.getNode()).hasEdge(src,dst);
case EXC_RET_CALLEE:
{
  if (dOptions.equals(DataDependenceOptions.NONE)) {
    return false;
  }
  if (dst.getKind().equals(Kind.EXC_RET_CALLER)) {
    ExceptionalReturnCaller r=(ExceptionalReturnCaller)dst;
    return cg.getPossibleTargets(r.getNode(),r.getInstruction().getCallSite()).contains(src.getNode());
  }
 else {
    return false;
  }
}
case NORMAL_RET_CALLEE:
{
if (dOptions.equals(DataDependenceOptions.NONE)) {
  return false;
}
if (dst.getKind().equals(Kind.NORMAL_RET_CALLER)) {
  NormalReturnCaller r=(NormalReturnCaller)dst;
  return cg.getPossibleTargets(r.getNode(),r.getInstruction().getCallSite()).contains(src.getNode());
}
 else {
  return false;
}
}
case HEAP_RET_CALLEE:
{
if (dOptions.equals(DataDependenceOptions.NONE)) {
return false;
}
if (dst.getKind().equals(Kind.HEAP_RET_CALLER)) {
HeapStatement.HeapReturnCaller r=(HeapStatement.HeapReturnCaller)dst;
HeapStatement h=(HeapStatement)src;
return h.getLocation().equals(r.getLocation()) && cg.getPossibleTargets(r.getNode(),r.getCall().getCallSite()).contains(src.getNode());
}
 else {
return false;
}
}
case PARAM_CALLER:
{
if (dOptions.equals(DataDependenceOptions.NONE)) {
return false;
}
if (dst.getKind().equals(Kind.PARAM_CALLEE)) {
ParamCallee callee=(ParamCallee)dst;
ParamCaller caller=(ParamCaller)src;
return caller.getValueNumber() == callee.getValueNumber() && cg.getPossibleTargets(caller.getNode(),caller.getInstruction().getCallSite()).contains(callee.getNode());
}
 else {
return false;
}
}
case HEAP_PARAM_CALLER:
if (dOptions.equals(DataDependenceOptions.NONE)) {
return false;
}
if (dst.getKind().equals(Kind.HEAP_PARAM_CALLEE)) {
HeapStatement.HeapParamCallee callee=(HeapStatement.HeapParamCallee)dst;
HeapStatement.HeapParamCaller caller=(HeapStatement.HeapParamCaller)src;
return caller.getLocation().equals(callee.getLocation()) && cg.getPossibleTargets(caller.getNode(),caller.getCall().getCallSite()).contains(callee.getNode());
}
 else {
return false;
}
default :
Assertions.UNREACHABLE(src.getKind());
return false;
}
}","public boolean hasEdge(Statement src,Statement dst){
  addPDGStatementNodes(src.getNode());
  addPDGStatementNodes(dst.getNode());
switch (src.getKind()) {
case NORMAL:
    if (cOptions.equals(ControlDependenceOptions.NONE)) {
      return getPDG(src.getNode()).hasEdge(src,dst);
    }
 else {
      NormalStatement ns=(NormalStatement)src;
      if (dst instanceof MethodEntryStatement) {
        if (ns.getInstruction() instanceof SSAAbstractInvokeInstruction) {
          SSAAbstractInvokeInstruction call=(SSAAbstractInvokeInstruction)ns.getInstruction();
          return cg.getPossibleTargets(src.getNode(),call.getCallSite()).contains(dst.getNode());
        }
 else {
          return false;
        }
      }
 else {
        return getPDG(src.getNode()).hasEdge(src,dst);
      }
    }
case PHI:
case PI:
case EXC_RET_CALLER:
case NORMAL_RET_CALLER:
case PARAM_CALLEE:
case HEAP_PARAM_CALLEE:
case HEAP_RET_CALLER:
case METHOD_ENTRY:
case METHOD_EXIT:
  return getPDG(src.getNode()).hasEdge(src,dst);
case EXC_RET_CALLEE:
{
  if (dOptions.equals(DataDependenceOptions.NONE)) {
    return false;
  }
  if (dst.getKind().equals(Kind.EXC_RET_CALLER)) {
    ExceptionalReturnCaller r=(ExceptionalReturnCaller)dst;
    return cg.getPossibleTargets(r.getNode(),r.getInstruction().getCallSite()).contains(src.getNode());
  }
 else {
    return false;
  }
}
case NORMAL_RET_CALLEE:
{
if (dOptions.equals(DataDependenceOptions.NONE)) {
  return false;
}
if (dst.getKind().equals(Kind.NORMAL_RET_CALLER)) {
  NormalReturnCaller r=(NormalReturnCaller)dst;
  return cg.getPossibleTargets(r.getNode(),r.getInstruction().getCallSite()).contains(src.getNode());
}
 else {
  return false;
}
}
case HEAP_RET_CALLEE:
{
if (dOptions.equals(DataDependenceOptions.NONE)) {
return false;
}
if (dst.getKind().equals(Kind.HEAP_RET_CALLER)) {
HeapStatement.HeapReturnCaller r=(HeapStatement.HeapReturnCaller)dst;
HeapStatement h=(HeapStatement)src;
return h.getLocation().equals(r.getLocation()) && cg.getPossibleTargets(r.getNode(),r.getCall().getCallSite()).contains(src.getNode());
}
 else {
return false;
}
}
case PARAM_CALLER:
{
if (dOptions.equals(DataDependenceOptions.NONE)) {
return false;
}
if (dst.getKind().equals(Kind.PARAM_CALLEE)) {
ParamCallee callee=(ParamCallee)dst;
ParamCaller caller=(ParamCaller)src;
SSAAbstractInvokeInstruction call=caller.getInstruction();
final CGNode calleeNode=callee.getNode();
if (!cg.getPossibleTargets(caller.getNode(),call.getCallSite()).contains(calleeNode)) {
return false;
}
if (dOptions.isTerminateAtCast() && call.isDispatch() && caller.getValueNumber() == call.getReceiver()) {
return false;
}
if (dOptions.isTerminateAtCast() && isUninformativeForReflection(calleeNode)) {
return false;
}
for (int i=0; i < calleeNode.getMethod().getNumberOfParameters(); i++) {
if (call.getUse(i) == caller.getValueNumber()) {
  if (callee.getValueNumber() == i + 1) {
    return true;
  }
}
}
return false;
}
 else {
return false;
}
}
case HEAP_PARAM_CALLER:
if (dOptions.equals(DataDependenceOptions.NONE)) {
return false;
}
if (dst.getKind().equals(Kind.HEAP_PARAM_CALLEE)) {
HeapStatement.HeapParamCallee callee=(HeapStatement.HeapParamCallee)dst;
HeapStatement.HeapParamCaller caller=(HeapStatement.HeapParamCaller)src;
return caller.getLocation().equals(callee.getLocation()) && cg.getPossibleTargets(caller.getNode(),caller.getCall().getCallSite()).contains(callee.getNode());
}
 else {
return false;
}
default :
Assertions.UNREACHABLE(src.getKind());
return false;
}
}",0.8885482140119577
99973,"/** 
 * don't call this unless you really know what you're doing
 */
public Operator getOperator(){
  if (opcode < OP_iand) {
    return Operator.values()[(opcode - OP_iadd) / 4];
  }
 else {
    return Operator.values()[(opcode - OP_iand) / 2];
  }
}","public Operator getOperator(){
  if (opcode < OP_iand) {
    return Operator.values()[(opcode - OP_iadd) / 4];
  }
 else {
    return Operator.values()[5 + (opcode - OP_iand) / 2];
  }
}",0.8329519450800915
99974,"/** 
 * Return the unique receiver of an invocation of method on an object of type declaringClass
 * @param receiverClass type of receiver
 * @param selector method signature
 * @return Method resolved method abstraction
 * @throws IllegalArgumentException if receiverClass is null
 */
public IMethod resolveMethod(IClass receiverClass,Selector selector){
  if (receiverClass == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  IMethod result=findMethod(receiverClass,selector);
  if (result != null) {
    return result;
  }
 else {
    IClass superclass=null;
    try {
      superclass=receiverClass.getSuperclass();
    }
 catch (    ClassHierarchyException e) {
      Assertions.UNREACHABLE();
    }
    if (superclass == null) {
      if (DEBUG) {
        Trace.println(""String_Node_Str"" + selector + ""String_Node_Str"");
      }
      return null;
    }
 else {
      if (DEBUG) {
        Trace.println(""String_Node_Str"" + receiverClass + ""String_Node_Str""+ superclass+ ""String_Node_Str""+ selector);
      }
      return resolveMethod(superclass,selector);
    }
  }
}","/** 
 * Return the unique target of an invocation of method on an object of type declaringClass
 * @param receiverClass type of receiver
 * @param selector method signature
 * @return Method resolved method abstraction
 * @throws IllegalArgumentException if receiverClass is null
 */
public IMethod resolveMethod(IClass receiverClass,Selector selector){
  if (receiverClass == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  IMethod result=findMethod(receiverClass,selector);
  if (result != null) {
    return result;
  }
 else {
    IClass superclass=null;
    try {
      superclass=receiverClass.getSuperclass();
    }
 catch (    ClassHierarchyException e) {
      Assertions.UNREACHABLE();
    }
    if (superclass == null) {
      if (DEBUG) {
        Trace.println(""String_Node_Str"" + selector + ""String_Node_Str"");
      }
      return null;
    }
 else {
      if (DEBUG) {
        Trace.println(""String_Node_Str"" + receiverClass + ""String_Node_Str""+ superclass+ ""String_Node_Str""+ selector);
      }
      return resolveMethod(superclass,selector);
    }
  }
}",0.9936189608021878
99975,"/** 
 * Find the possible receivers of a call to a method reference
 * @param ref method reference
 * @return the set of IMethods that this call can resolve to.
 */
@SuppressWarnings(""String_Node_Str"") private Set<IMethod> findOrCreateTargetSet(IClass declaredClass,MethodReference ref){
  Map<MethodReference,Set<IMethod>> classCache=(Map<MethodReference,Set<IMethod>>)CacheReference.get(targetCache.get(declaredClass));
  if (classCache == null) {
    classCache=HashMapFactory.make(3);
    targetCache.put(declaredClass,CacheReference.make(classCache));
  }
  Set<IMethod> result=classCache.get(ref);
  if (result == null) {
    result=getPossibleTargets(declaredClass,ref);
    classCache.put(ref,result);
  }
  return result;
}","/** 
 * Find the possible targets of a call to a method reference
 * @param ref method reference
 * @return the set of IMethods that this call can resolve to.
 */
@SuppressWarnings(""String_Node_Str"") private Set<IMethod> findOrCreateTargetSet(IClass declaredClass,MethodReference ref){
  Map<MethodReference,Set<IMethod>> classCache=(Map<MethodReference,Set<IMethod>>)CacheReference.get(targetCache.get(declaredClass));
  if (classCache == null) {
    classCache=HashMapFactory.make(3);
    targetCache.put(declaredClass,CacheReference.make(classCache));
  }
  Set<IMethod> result=classCache.get(ref);
  if (result == null) {
    result=getPossibleTargets(declaredClass,ref);
    classCache.put(ref,result);
  }
  return result;
}",0.9904240766073872
99976,"/** 
 * Find the possible receivers of a call to a method reference where the receiver is of a certain type
 * @param receiverClass the class of the receiver
 * @param ref method reference
 * @return the set of IMethods that this call can resolve to.
 */
public Set<IMethod> getPossibleTargets(IClass receiverClass,MethodReference ref);","/** 
 * Find the possible targets of a call to a method reference where the receiver is of a certain type
 * @param receiverClass the class of the receiver
 * @param ref method reference
 * @return the set of IMethods that this call can resolve to.
 */
public Set<IMethod> getPossibleTargets(IClass receiverClass,MethodReference ref);",0.9791044776119404
99977,"/** 
 * Propagate information for an ""exit"" edge to the appropriate return sites [23] for each d5 s.t. <s_p,d2> -> <returnSite(c),d5> ..
 * @param edge the edge being processed
 * @param succ numbers of the nodes that are successors of edge.n (the return block in the callee) in the call graph.
 * @param c a call site of edge.s_p
 * @param D4 set of d1 s.t. <c, d1> -> <edge.s_p, edge.d2> was recorded as call flow
 */
private void propagateToReturnSites(final PathEdge<T> edge,IntSet succ,final T c,final IntSet D4){
  if (DEBUG_LEVEL > 1) {
    System.err.println(""String_Node_Str"" + succ);
    for (IntIterator it=succ.intIterator(); it.hasNext(); ) {
      int x=it.next();
      System.err.println(""String_Node_Str"" + x + ""String_Node_Str""+ supergraph.getNode(x));
    }
  }
  P proc=supergraph.getProcOf(c);
  final T[] entries=supergraph.getEntriesForProcedure(proc);
  for (Iterator<? extends T> retSites=supergraph.getReturnSites(c,supergraph.getProcOf(edge.target)); retSites.hasNext(); ) {
    final T retSite=retSites.next();
    if (DEBUG_LEVEL > 1) {
      System.err.println(""String_Node_Str"" + retSite + ""String_Node_Str""+ supergraph.getNumber(retSite));
    }
    if (!succ.contains(supergraph.getNumber(retSite))) {
      continue;
    }
    if (DEBUG_LEVEL > 1) {
      System.err.println(""String_Node_Str"" + retSite);
    }
    final IFlowFunction retf=flowFunctionMap.getReturnFlowFunction(c,edge.target,retSite);
    if (retf instanceof IBinaryReturnFlowFunction) {
      propagateToReturnSiteWithBinaryFlowFunction(edge,c,D4,entries,retSite,retf);
    }
 else {
      final IntSet D5=computeFlow(edge.d2,(IUnaryFlowFunction)retf);
      if (DEBUG_LEVEL > 1) {
        System.err.println(""String_Node_Str"" + D4);
        System.err.println(""String_Node_Str"" + D5);
      }
      IntSetAction action=new IntSetAction(){
        public void act(        final int d4){
          if (D5 != null) {
            D5.foreach(new IntSetAction(){
              public void act(              final int d5){
                for (int i=0; i < entries.length; i++) {
                  final T s_p=entries[i];
                  if (DEBUG_LEVEL > 1) {
                    System.err.println(""String_Node_Str"" + s_p);
                  }
                  IntSet D3=getInversePathEdges(s_p,c,d4);
                  if (DEBUG_LEVEL > 1) {
                    System.err.println(""String_Node_Str"" + D3);
                  }
                  if (D3 != null) {
                    D3.foreach(new IntSetAction(){
                      public void act(                      int d3){
                        propagate(s_p,d3,retSite,d5);
                      }
                    }
);
                  }
                }
              }
            }
);
          }
        }
      }
;
      D4.foreach(action);
    }
  }
}","/** 
 * Propagate information for an ""exit"" edge to the appropriate return sites [23] for each d5 s.t. <s_p,d2> -> <returnSite(c),d5> ..
 * @param edge the edge being processed
 * @param succ numbers of the nodes that are successors of edge.n (the return block in the callee) in the call graph.
 * @param c a call site of edge.s_p
 * @param D4 set of d1 s.t. <c, d1> -> <edge.s_p, edge.d2> was recorded as call flow
 */
private void propagateToReturnSites(final PathEdge<T> edge,IntSet succ,final T c,final IntSet D4){
  if (DEBUG_LEVEL > 1) {
    System.err.println(""String_Node_Str"" + succ);
    for (IntIterator it=succ.intIterator(); it.hasNext(); ) {
      int x=it.next();
      System.err.println(""String_Node_Str"" + x + ""String_Node_Str""+ supergraph.getNode(x));
    }
  }
  P proc=supergraph.getProcOf(c);
  final T[] entries=supergraph.getEntriesForProcedure(proc);
  for (Iterator<? extends T> retSites=supergraph.getReturnSites(c,supergraph.getProcOf(edge.target)); retSites.hasNext(); ) {
    final T retSite=retSites.next();
    if (DEBUG_LEVEL > 1) {
      System.err.println(""String_Node_Str"" + retSite + ""String_Node_Str""+ supergraph.getNumber(retSite));
    }
    if (!succ.contains(supergraph.getNumber(retSite))) {
      continue;
    }
    if (DEBUG_LEVEL > 1) {
      System.err.println(""String_Node_Str"" + retSite);
    }
    final IFlowFunction retf=flowFunctionMap.getReturnFlowFunction(c,edge.target,retSite);
    if (retf instanceof IBinaryReturnFlowFunction) {
      propagateToReturnSiteWithBinaryFlowFunction(edge,c,D4,entries,retSite,retf);
    }
 else {
      final IntSet D5=computeFlow(edge.d2,(IUnaryFlowFunction)retf);
      if (DEBUG_LEVEL > 1) {
        System.err.println(""String_Node_Str"" + D4);
        System.err.println(""String_Node_Str"" + D5);
      }
      IntSetAction action=new IntSetAction(){
        public void act(        final int d4){
          propToReturnSite(c,entries,retSite,d4,D5);
        }
      }
;
      D4.foreach(action);
    }
  }
}",0.8118524658101948
99978,"/** 
 * Propagate information for an ""exit"" edge to a caller return site [23] for each d5 s.t. <s_p,d2> -> <returnSite(c),d5> ..
 * @param edge the edge being processed
 * @param c a call site of edge.s_p
 * @param D4 set of d1 s.t. <c, d1> -> <edge.s_p, edge.d2> was recorded as call flow
 * @param entries the blocks in the supergraph that are entries for the procedure of c
 * @param retSite the return site being propagated to
 * @param retf the flow function
 */
private void propagateToReturnSiteWithBinaryFlowFunction(final PathEdge edge,final T c,final IntSet D4,final T[] entries,final T retSite,final IFlowFunction retf){
  D4.foreach(new IntSetAction(){
    public void act(    final int d4){
      final IntSet D5=computeBinaryFlow(d4,edge.d2,(IBinaryReturnFlowFunction)retf);
      if (D5 != null) {
        D5.foreach(new IntSetAction(){
          public void act(          final int d5){
            for (int i=0; i < entries.length; i++) {
              final T s_p=entries[i];
              if (DEBUG_LEVEL > 1) {
                System.err.println(""String_Node_Str"" + s_p);
              }
              IntSet D3=getInversePathEdges(s_p,c,d4);
              if (DEBUG_LEVEL > 1) {
                System.err.println(""String_Node_Str"" + D3);
              }
              if (D3 != null) {
                D3.foreach(new IntSetAction(){
                  public void act(                  int d3){
                    propagate(s_p,d3,retSite,d5);
                  }
                }
);
              }
            }
          }
        }
);
      }
    }
  }
);
}","/** 
 * Propagate information for an ""exit"" edge to a caller return site [23] for each d5 s.t. <s_p,d2> -> <returnSite(c),d5> ..
 * @param edge the edge being processed
 * @param c a call site of edge.s_p
 * @param D4 set of d1 s.t. <c, d1> -> <edge.s_p, edge.d2> was recorded as call flow
 * @param entries the blocks in the supergraph that are entries for the procedure of c
 * @param retSite the return site being propagated to
 * @param retf the flow function
 */
private void propagateToReturnSiteWithBinaryFlowFunction(final PathEdge edge,final T c,final IntSet D4,final T[] entries,final T retSite,final IFlowFunction retf){
  D4.foreach(new IntSetAction(){
    public void act(    final int d4){
      final IntSet D5=computeBinaryFlow(d4,edge.d2,(IBinaryReturnFlowFunction)retf);
      propToReturnSite(c,entries,retSite,d4,D5);
    }
  }
);
}",0.6691297208538588
99979,"private void init(Graph<T> G,Iterator<? extends T> nodes){
  this.G=G;
  if (G.getNumberOfNodes() == 0) {
    return;
  }
  while (nodes.hasNext()) {
    T o=nodes.next();
    if (!visited.contains(o)) {
      Q.add(o);
      visited.add(o);
    }
  }
  index=0;
  T current=Q.get(0);
  visitChildren(current);
}","private void init(Graph<T> G,Iterator<? extends T> nodes){
  this.G=G;
  if (G.getNumberOfNodes() == 0) {
    return;
  }
  while (nodes.hasNext()) {
    T o=nodes.next();
    if (!visited.contains(o)) {
      Q.add(o);
      visited.add(o);
    }
  }
  index=0;
  if (Q.size() > 0) {
    T current=Q.get(0);
    visitChildren(current);
  }
}",0.9510703363914372
99980,"/** 
 * Method getBasicBlockStarts, stolen from ShrikeBT verifier
 */
private void makeBasicBlocks(){
  ExceptionHandler[][] handlers;
  try {
    handlers=method.getHandlers();
  }
 catch (  InvalidClassFileException e) {
    e.printStackTrace();
    Assertions.UNREACHABLE();
    handlers=null;
  }
  boolean[] r=new boolean[getInstructions().length];
  boolean[] catchers=new boolean[getInstructions().length];
  int blockCount=2;
  r[0]=true;
  Instruction[] instructions=(Instruction[])getInstructions();
  for (int i=0; i < instructions.length; i++) {
    int[] targets=instructions[i].getBranchTargets();
    if (targets.length > 0 || !instructions[i].isFallThrough()) {
      if (i + 1 < instructions.length && !r[i + 1]) {
        r[i + 1]=true;
        blockCount++;
      }
    }
    for (int j=0; j < targets.length; j++) {
      if (!r[targets[j]]) {
        r[targets[j]]=true;
        blockCount++;
      }
    }
    if (Exceptions.isPEI(instructions[i])) {
      ExceptionHandler[] hs=handlers[i];
      if (i + 1 < instructions.length && !r[i + 1]) {
        r[i + 1]=true;
        blockCount++;
      }
      if (hs != null && hs.length > 0) {
        for (int j=0; j < hs.length; j++) {
          exceptionHandlers.add(hs[j]);
          if (!r[hs[j].getHandler()]) {
            r[hs[j].getHandler()]=true;
            blockCount++;
          }
          catchers[hs[j].getHandler()]=true;
        }
      }
    }
  }
  BasicBlock entry=new BasicBlock(-1);
  addNode(entry);
  int j=1;
  for (int i=0; i < r.length; i++) {
    if (r[i]) {
      BasicBlock b=new BasicBlock(i);
      addNode(b);
      if (catchers[i]) {
        setCatchBlock(j);
      }
      j++;
    }
  }
  BasicBlock exit=new BasicBlock(-1);
  addNode(exit);
}","private void makeBasicBlocks(){
  ExceptionHandler[][] handlers;
  try {
    handlers=method.getHandlers();
  }
 catch (  InvalidClassFileException e) {
    e.printStackTrace();
    Assertions.UNREACHABLE();
    handlers=null;
  }
  boolean[] r=new boolean[getInstructions().length];
  boolean[] catchers=new boolean[getInstructions().length];
  int blockCount=2;
  r[0]=true;
  Instruction[] instructions=(Instruction[])getInstructions();
  for (int i=0; i < instructions.length; i++) {
    int[] targets=instructions[i].getBranchTargets();
    if (targets.length > 0 || !instructions[i].isFallThrough()) {
      if (i + 1 < instructions.length && !r[i + 1]) {
        r[i + 1]=true;
        blockCount++;
      }
    }
    for (int j=0; j < targets.length; j++) {
      if (!r[targets[j]]) {
        r[targets[j]]=true;
        blockCount++;
      }
    }
    if (Exceptions.isPEI(instructions[i])) {
      ExceptionHandler[] hs=handlers[i];
      if (i + 1 < instructions.length && !r[i + 1]) {
        r[i + 1]=true;
        blockCount++;
      }
      if (hs != null && hs.length > 0) {
        for (int j=0; j < hs.length; j++) {
          exceptionHandlers.add(hs[j]);
          if (!r[hs[j].getHandler()]) {
            r[hs[j].getHandler()]=true;
            blockCount++;
          }
          catchers[hs[j].getHandler()]=true;
        }
      }
    }
  }
  BasicBlock entry=new BasicBlock(-1);
  addNode(entry);
  int j=1;
  for (int i=0; i < r.length; i++) {
    if (r[i]) {
      BasicBlock b=new BasicBlock(i);
      addNode(b);
      if (catchers[i]) {
        setCatchBlock(j);
      }
      j++;
    }
  }
  BasicBlock exit=new BasicBlock(-1);
  addNode(exit);
}",0.979591836734694
99981,"/** 
 * Solely for optimization; return a Collection<TypeReference> representing the subclassesOfError kind of ugly. a better scheme?
 */
public Collection<TypeReference> getJavaLangErrorTypes(){
  if (subTypeRefsOfError == null) {
    computeSubClasses(TypeReference.JavaLangError);
    subTypeRefsOfError=HashSetFactory.make(subclassesOfError.size());
    for (Iterator it=subclassesOfError.iterator(); it.hasNext(); ) {
      IClass klass=(IClass)it.next();
      subTypeRefsOfError.add(klass.getReference());
    }
  }
  return Collections.unmodifiableCollection(subTypeRefsOfError);
}","/** 
 * Solely for optimization; return a Collection<TypeReference> representing the subclasses of Error kind of ugly. a better scheme?
 */
public Collection<TypeReference> getJavaLangErrorTypes(){
  if (subTypeRefsOfError == null) {
    computeSubClasses(TypeReference.JavaLangError);
    subTypeRefsOfError=HashSetFactory.make(subclassesOfError.size());
    for (Iterator it=subclassesOfError.iterator(); it.hasNext(); ) {
      IClass klass=(IClass)it.next();
      subTypeRefsOfError.add(klass.getReference());
    }
  }
  return Collections.unmodifiableCollection(subTypeRefsOfError);
}",0.994915254237288
99982,"/** 
 * @param klass
 * @return the classes that immediately extend klass. if klass is an array class A[][]...[], we return array classesB[][]...[] (same dimensionality) where B is an immediate subclass of A. If A is primitive, we return the empty set.
 */
public Collection<IClass> getImmediateSubclasses(IClass klass){
  if (klass.isArrayClass()) {
    return getImmediateArraySubclasses(klass);
  }
  Function<Node,IClass> node2Class=new Function<Node,IClass>(){
    public IClass apply(    Node n){
      return n.klass;
    }
  }
;
  return Iterator2Collection.toCollection(new MapIterator<Node,IClass>(findNode(klass).children.iterator(),node2Class));
}","/** 
 * @param klass
 * @return the classes that immediately extend klass. if klass is an array class A[][]...[], we return array classes B[][]...[](same dimensionality) where B is an immediate subclass of A. If A is primitive, we return the empty set.
 */
public Collection<IClass> getImmediateSubclasses(IClass klass){
  if (klass.isArrayClass()) {
    return getImmediateArraySubclasses(klass);
  }
  Function<Node,IClass> node2Class=new Function<Node,IClass>(){
    public IClass apply(    Node n){
      return n.klass;
    }
  }
;
  return Iterator2Collection.toCollection(new MapIterator<Node,IClass>(findNode(klass).children.iterator(),node2Class));
}",0.9984825493171472
99983,"/** 
 * Return set of all subclasses of type in the Class Hierarchy TODO: Tune this implementation. Consider caching if necessary.
 */
public Collection<IClass> computeSubClasses(TypeReference type){
  IClass T=lookupClass(type);
  if (Assertions.verifyAssertions) {
    if (T == null) {
      Assertions._assert(T != null,""String_Node_Str"" + type);
    }
  }
  if (T.getReference().equals(TypeReference.JavaLangError)) {
    if (subclassesOfError == null) {
      subclassesOfError=computeSubClassesInternal(T);
    }
    return subclassesOfError;
  }
 else {
    return computeSubClassesInternal(T);
  }
}","/** 
 * Return set of all subclasses of type in the Class Hierarchy TODO: Tune this implementation. Consider caching if necessary.
 */
public Collection<IClass> computeSubClasses(TypeReference type){
  IClass t=lookupClass(type);
  if (Assertions.verifyAssertions) {
    if (t == null) {
      Assertions._assert(t != null,""String_Node_Str"" + type);
    }
  }
  if (t.getReference().equals(TypeReference.JavaLangError)) {
    if (subclassesOfError == null) {
      subclassesOfError=computeSubClassesInternal(t);
    }
    return subclassesOfError;
  }
 else   if (t.getReference().equals(TypeReference.JavaLangRuntimeException)) {
    if (runtimeExceptionClasses == null) {
      runtimeExceptionClasses=computeSubClassesInternal(t);
    }
    return runtimeExceptionClasses;
  }
 else {
    return computeSubClassesInternal(t);
  }
}",0.7420249653259362
99984,"/** 
 * @param klass
 * @return the number of classes that immediately extend klass. if klass is an array class A[][]...[], we returnnumber of immediate subclasses of A. If A is primitive, we return 0.
 */
public int getNumberOfImmediateSubclasses(IClass klass){
  if (klass.isArrayClass()) {
    IClass innermost=getInnermostTypeOfArrayClass(klass);
    return innermost == null ? 0 : getNumberOfImmediateSubclasses(innermost);
  }
  Node node=findNode(klass);
  return node.children.size();
}","/** 
 * @param klass
 * @return the number of classes that immediately extend klass. if klass is an array class A[][]...[], we return number ofimmediate subclasses of A. If A is primitive, we return 0.
 */
public int getNumberOfImmediateSubclasses(IClass klass){
  if (klass.isArrayClass()) {
    IClass innermost=getInnermostTypeOfArrayClass(klass);
    return innermost == null ? 0 : getNumberOfImmediateSubclasses(innermost);
  }
  Node node=findNode(klass);
  return node.children.size();
}",0.979757085020243
99985,"/** 
 * Solely for optimization; return a Collection<TypeReference> representing the subclassesOfError kind of ugly. a better scheme?
 */
public Collection<TypeReference> getJavaLangErrorTypes();","/** 
 * Solely for optimization; return a Collection<TypeReference> representing the subclasses of Error kind of ugly. a better scheme?
 */
public Collection<TypeReference> getJavaLangErrorTypes();",0.9897959183673468
99986,"/** 
 * @return Collection<TypeReference>, set of exception types a call to adeclared target might throw.
 * @throws InvalidClassFileException 
 * @throws IllegalArgumentException  if target is null
 * @throws IllegalArgumentException  if cha is null
 */
public static Collection<TypeReference> inferInvokeExceptions(MethodReference target,IClassHierarchy cha) throws InvalidClassFileException {
  if (cha == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (target == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ArrayList<TypeReference> set=new ArrayList<TypeReference>(runtimeExceptions);
  set.addAll(cha.getJavaLangErrorTypes());
  IClass klass=cha.lookupClass(target.getDeclaringClass());
  if (klass == null) {
    Warnings.add(MethodResolutionFailure.moderate(target));
  }
  if (klass != null) {
    IMethod M=klass.getMethod(target.getSelector());
    if (M == null) {
      Warnings.add(MethodResolutionFailure.severe(target));
    }
 else {
      TypeReference[] exceptionTypes=M.getDeclaredExceptions();
      if (exceptionTypes != null) {
        set.addAll(Arrays.asList(exceptionTypes));
      }
    }
  }
  return set;
}","/** 
 * @return Collection<TypeReference>, set of exception types a call to adeclared target might throw.
 * @throws InvalidClassFileException 
 * @throws IllegalArgumentException  if target is null
 * @throws IllegalArgumentException  if cha is null
 */
public static Collection<TypeReference> inferInvokeExceptions(MethodReference target,IClassHierarchy cha) throws InvalidClassFileException {
  if (cha == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (target == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ArrayList<TypeReference> set=new ArrayList<TypeReference>(cha.getJavaLangRuntimeExceptionTypes());
  set.addAll(cha.getJavaLangErrorTypes());
  IClass klass=cha.lookupClass(target.getDeclaringClass());
  if (klass == null) {
    Warnings.add(MethodResolutionFailure.moderate(target));
  }
  if (klass != null) {
    IMethod M=klass.getMethod(target.getSelector());
    if (M == null) {
      Warnings.add(MethodResolutionFailure.severe(target));
    }
 else {
      TypeReference[] exceptionTypes=M.getDeclaredExceptions();
      if (exceptionTypes != null) {
        set.addAll(Arrays.asList(exceptionTypes));
      }
    }
  }
  return set;
}",0.9896049896049895
99987,"public void testMultiNewArray1() throws IOException, ClassHierarchyException {
  AnalysisScope scope=null;
  scope=AnalysisScopeReader.read(TestConstants.WALA_TESTDATA,FileProvider.getFile(""String_Node_Str""),MY_CLASSLOADER);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  IClass klass=cha.lookupClass(TypeReference.findOrCreate(ClassLoaderReference.Application,TestConstants.MULTI_DIM_MAIN));
  assertTrue(klass != null);
  IMethod m=klass.getMethod(Selector.make(""String_Node_Str""));
  assertTrue(m != null);
  AnalysisCache cache=new AnalysisCache();
  IR ir=cache.getIRFactory().makeIR(m,Everywhere.EVERYWHERE,new SSAOptions());
  assertTrue(ir != null);
  SSAInstruction[] instructions=ir.getInstructions();
  for (  SSAInstruction instr : instructions) {
    if (instr instanceof SSANewInstruction) {
    }
  }
}","public void testMultiNewArray1() throws IOException, ClassHierarchyException {
  AnalysisScope scope=null;
  scope=AnalysisScopeReader.read(TestConstants.WALA_TESTDATA,FileProvider.getFile(""String_Node_Str""),MY_CLASSLOADER);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  IClass klass=cha.lookupClass(TypeReference.findOrCreate(ClassLoaderReference.Application,TestConstants.MULTI_DIM_MAIN));
  assertTrue(klass != null);
  IMethod m=klass.getMethod(Selector.make(""String_Node_Str""));
  assertTrue(m != null);
  AnalysisCache cache=new AnalysisCache();
  IR ir=cache.getIRFactory().makeIR(m,Everywhere.EVERYWHERE,new SSAOptions());
  assertTrue(ir != null);
  SSAInstruction[] instructions=ir.getInstructions();
  for (  SSAInstruction instr : instructions) {
    if (instr instanceof SSANewInstruction) {
      System.err.println(instr.toString(ir.getSymbolTable()));
      assertTrue(instr.getNumberOfUses() == 3);
      assertTrue(ir.getSymbolTable().getIntValue(instr.getUse(0)) == 3);
      assertTrue(ir.getSymbolTable().getIntValue(instr.getUse(1)) == 4);
    }
  }
}",0.8646656134807793
99988,"/** 
 * @see com.ibm.wala.shrikeBT.Instruction.Visitor#visitNew(NewInstruction)
 */
@Override public void visitNew(com.ibm.wala.shrikeBT.NewInstruction instruction){
  int result=reuseOrCreateDef();
  TypeReference t=ShrikeUtil.makeTypeReference(loader,instruction.getType());
  NewSiteReference ref=NewSiteReference.make(getCurrentProgramCounter(),t);
  if (t.isArrayType()) {
    int[] sizes=new int[t.getDimensionality()];
    for (int i=0; i < instruction.getArrayBoundsCount(); i++) {
      sizes[i]=workingState.pop();
    }
    for (int i=instruction.getArrayBoundsCount(); i < sizes.length; i++) {
      sizes[i]=symbolTable.getConstant(0);
    }
    emitInstruction(new SSANewInstruction(result,ref,sizes));
  }
 else {
    emitInstruction(new SSANewInstruction(result,ref));
    popN(instruction);
  }
  workingState.push(result);
}","/** 
 * @see com.ibm.wala.shrikeBT.Instruction.Visitor#visitNew(NewInstruction)
 */
@Override public void visitNew(com.ibm.wala.shrikeBT.NewInstruction instruction){
  int result=reuseOrCreateDef();
  TypeReference t=ShrikeUtil.makeTypeReference(loader,instruction.getType());
  NewSiteReference ref=NewSiteReference.make(getCurrentProgramCounter(),t);
  if (t.isArrayType()) {
    int[] sizes=new int[t.getDimensionality()];
    for (int i=0; i < instruction.getArrayBoundsCount(); i++) {
      sizes[instruction.getArrayBoundsCount() - 1 - i]=workingState.pop();
    }
    for (int i=instruction.getArrayBoundsCount(); i < sizes.length; i++) {
      sizes[i]=symbolTable.getConstant(0);
    }
    emitInstruction(new SSANewInstruction(result,ref,sizes));
  }
 else {
    emitInstruction(new SSANewInstruction(result,ref));
    popN(instruction);
  }
  workingState.push(result);
}",0.976798143851508
99989,"/** 
 * @param pc a program counter (index into ShrikeBT instruction array)
 * @param vn a value number
 * @return if we know that immediately after the given program counter, v_vn corresponds to some set of locals, thenreturn an array of the local numbers. else return null.
 */
private int[] findLocalsForValueNumber(int pc,int vn){
  IBasicBlock bb=shrikeCFG.getBlockForInstruction(pc);
  int firstInstruction=bb.getFirstInstructionIndex();
  int[] locals=block2LocalState[bb.getNumber()];
  if (locals == null) {
    locals=allocateNewLocalsArray();
  }
  for (int i=firstInstruction; i <= pc; i++) {
    if (localStoreMap[i] != null) {
      IntPair p=localStoreMap[i];
      locals[p.getY()]=p.getX();
    }
  }
  return extractIndices(locals,vn);
}","/** 
 * @param pc a program counter (index into ShrikeBT instruction array)
 * @param vn a value number
 * @return if we know that immediately after the given program counter, v_vn corresponds to some set of locals, then return anarray of the local numbers. else return null.
 */
private int[] findLocalsForValueNumber(int pc,int vn){
  IBasicBlock bb=shrikeCFG.getBlockForInstruction(pc);
  int firstInstruction=bb.getFirstInstructionIndex();
  int[] locals=block2LocalState[bb.getNumber()];
  if (locals == null) {
    locals=allocateNewLocalsArray();
  }
  for (int i=firstInstruction; i <= pc; i++) {
    if (localStoreMap[i] != null) {
      IntPair p=localStoreMap[i];
      locals[p.getY()]=p.getX();
    }
  }
  return extractIndices(locals,vn);
}",0.9867549668874172
99990,"@Override public String toString(SymbolTable symbolTable){
  return getValueString(symbolTable,result) + ""String_Node_Str"" + site.getDeclaredType()+ ""String_Node_Str""+ site.getProgramCounter()+ (params == null ? ""String_Node_Str"" : ""String_Node_Str"" + params.length);
}","@Override public String toString(SymbolTable symbolTable){
  return getValueString(symbolTable,result) + ""String_Node_Str"" + site.getDeclaredType()+ ""String_Node_Str""+ site.getProgramCounter()+ (params == null ? ""String_Node_Str"" : ""String_Node_Str"" + params.length + ""String_Node_Str""+ array2String(params,symbolTable));
}",0.9087837837837838
99991,"@Override protected void propagate(T s_p,int i,T n,int j){
  super.propagate(s_p,i,n,j);
  if (isExitFromSeedMethod(n)) {
    for (Iterator<? extends T> it2=supergraph.getSuccNodes(n); it2.hasNext(); ) {
      T retSite=it2.next();
      PartiallyBalancedTabulationProblem<T,P> problem=(PartiallyBalancedTabulationProblem<T,P>)getProblem();
      IFlowFunction f=problem.getFunctionMap().getUnbalancedReturnFlowFunction(n,retSite);
      if (f instanceof IUnaryFlowFunction) {
        IUnaryFlowFunction uf=(IUnaryFlowFunction)f;
        IntSet facts=uf.getTargets(j);
        if (facts != null) {
          for (IntIterator it4=facts.intIterator(); it4.hasNext(); ) {
            int d3=it4.next();
            T fakeEntry=problem.getFakeEntry(retSite);
            PathEdge<T> seed=PathEdge.createPathEdge(fakeEntry,d3,retSite,d3);
            addSeed(seed);
          }
        }
      }
 else {
        Assertions.UNREACHABLE(""String_Node_Str"");
      }
    }
  }
}","@Override protected void propagate(T s_p,int i,T n,int j){
  super.propagate(s_p,i,n,j);
  if (wasUsedAsUnbalancedSeed(s_p,i) && supergraph.isExit(n)) {
    for (Iterator<? extends T> it2=supergraph.getSuccNodes(n); it2.hasNext(); ) {
      T retSite=it2.next();
      PartiallyBalancedTabulationProblem<T,P> problem=(PartiallyBalancedTabulationProblem<T,P>)getProblem();
      IFlowFunction f=problem.getFunctionMap().getUnbalancedReturnFlowFunction(n,retSite);
      if (f instanceof IUnaryFlowFunction) {
        IUnaryFlowFunction uf=(IUnaryFlowFunction)f;
        IntSet facts=uf.getTargets(j);
        if (facts != null) {
          for (IntIterator it4=facts.intIterator(); it4.hasNext(); ) {
            int d3=it4.next();
            T fakeEntry=problem.getFakeEntry(retSite);
            PathEdge<T> seed=PathEdge.createPathEdge(fakeEntry,d3,retSite,d3);
            addSeed(seed);
          }
        }
      }
 else {
        Assertions.UNREACHABLE(""String_Node_Str"");
      }
    }
  }
}",0.9700355510411376
99992,"@Override public void addSeed(PathEdge<T> seed){
  seedProcedures.add(getSupergraph().getProcOf(seed.entry));
  super.addSeed(seed);
}","@Override public void addSeed(PathEdge<T> seed){
  unbalancedSeeds.add(Pair.make(seed.entry,seed.d1));
  super.addSeed(seed);
}",0.7662835249042146
99993,"public InstanceKey getInstanceKeyForAllocation(CGNode node,NewSiteReference allocation){
  IClass type=options.getClassTargetSelector().getAllocatedTarget(node,allocation);
  if (type == null) {
    return null;
  }
  if (node.getContext() instanceof ReceiverInstanceContext) {
    IMethod m=node.getMethod();
    CGNode n=ContainerContextSelector.findNodeRecursiveMatchingContext(m,node.getContext());
    if (n != null) {
      return new NormalAllocationInNode(n,allocation,type);
    }
  }
  InstanceKey key=new NormalAllocationInNode(node,allocation,type);
  return key;
}","public InstanceKey getInstanceKeyForAllocation(CGNode node,NewSiteReference allocation){
  IClass type=options.getClassTargetSelector().getAllocatedTarget(node,allocation);
  if (type == null) {
    return null;
  }
  if (node.getContext() instanceof ReceiverInstanceContext || node.getContext() instanceof CallerContext) {
    IMethod m=node.getMethod();
    CGNode n=ContainerContextSelector.findNodeRecursiveMatchingContext(m,node.getContext());
    if (n != null) {
      return new NormalAllocationInNode(n,allocation,type);
    }
  }
  InstanceKey key=new NormalAllocationInNode(node,allocation,type);
  return key;
}",0.9616666666666668
99994,"/** 
 * This method walks recursively up the definition of a context C, to see if the chain of contexts that give rise to C includes the method M. If C is a ReceiverInstanceContext, Let N be the node that allocated C.instance. If N.method == M, return N. Else return findRecursiveMatchingContext(M, N.context) Else return null
 */
public static CGNode findNodeRecursiveMatchingContext(IMethod M,Context C){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + M + ""String_Node_Str""+ C);
  }
  if (C instanceof ReceiverInstanceContext) {
    ReceiverInstanceContext ric=(ReceiverInstanceContext)C;
    if (!(ric.getReceiver() instanceof AllocationSiteInNode)) {
      return null;
    }
    AllocationSiteInNode I=(AllocationSiteInNode)ric.getReceiver();
    CGNode N=I.getNode();
    if (N.getMethod().equals(M)) {
      return N;
    }
 else {
      return findNodeRecursiveMatchingContext(M,N.getContext());
    }
  }
 else {
    return null;
  }
}","/** 
 * This method walks recursively up the definition of a context C, to see if the chain of contexts that give rise to C includes the method M. If C is a ReceiverInstanceContext, Let N be the node that allocated C.instance. If N.method == M, return N. Else return findRecursiveMatchingContext(M, N.context) Else return null
 */
public static CGNode findNodeRecursiveMatchingContext(IMethod m,Context c){
  if (DEBUG) {
    System.err.println(""String_Node_Str"" + m + ""String_Node_Str""+ c);
  }
  if (c instanceof ReceiverInstanceContext) {
    ReceiverInstanceContext ric=(ReceiverInstanceContext)c;
    if (!(ric.getReceiver() instanceof AllocationSiteInNode)) {
      return null;
    }
    AllocationSiteInNode i=(AllocationSiteInNode)ric.getReceiver();
    CGNode n=i.getNode();
    if (n.getMethod().equals(m)) {
      return n;
    }
 else {
      return findNodeRecursiveMatchingContext(m,n.getContext());
    }
  }
 else   if (c instanceof CallerContext) {
    CallerContext cc=(CallerContext)c;
    CGNode n=cc.getCaller();
    if (n.getMethod().equals(m)) {
      return n;
    }
 else {
      return findNodeRecursiveMatchingContext(m,n.getContext());
    }
  }
 else {
    return null;
  }
}",0.7222222222222222
99995,"@Override public void acceptSearchMatch(SearchMatch match) throws CoreException {
  result.add((IMethod)match.getElement());
}","@Override public void acceptSearchMatch(SearchMatch match) throws CoreException {
  if (match.getElement() instanceof IMethod) {
    result.add((IMethod)match.getElement());
  }
}",0.8262295081967214
99996,"/** 
 * @param typeSignature Some of the type signatures examples are ""QString;"" (String) and ""I"" (int) The type signatures may be either unresolved (for source types) or resolved (for binary types), and either basic (for basic types) or rich (for parameterized types). See {@link Signature} for details.
 */
public static String getHumanReadableType(String typeSignature){
  String simpleName=Signature.getSignatureSimpleName(typeSignature);
  return simpleName;
}","/** 
 * @param typeSignature Some of the type signatures examples are ""QString;"" (String) and ""I"" (int) The type signatures may beeither unresolved (for source types) or resolved (for binary types), and either basic (for basic types) or rich (for parameterized types). See  {@link Signature} for details.
 */
public static String getHumanReadableType(String typeSignature){
  String simpleName=Signature.getSignatureSimpleName(typeSignature);
  return simpleName;
}",0.9978494623655914
99997,"/** 
 * Use the search engine to find all methods in a java element
 */
public static Collection<IMethod> findMethods(IJavaElement elt){
  if (elt instanceof ICompilationUnit) {
    Collection<IMethod> result=HashSetFactory.make();
    for (    IType type : getClasses((ICompilationUnit)elt)) {
      try {
        for (        IMethod m : type.getMethods()) {
          result.add(m);
        }
      }
 catch (      JavaModelException e) {
        e.printStackTrace();
      }
    }
    return result;
  }
 else {
    final Collection<IMethod> result=HashSetFactory.make();
    SearchPattern p=SearchPattern.createPattern(""String_Node_Str"",IJavaSearchConstants.METHOD,IJavaSearchConstants.DECLARATIONS,SearchPattern.R_PATTERN_MATCH);
    IJavaSearchScope scope=SearchEngine.createJavaSearchScope(new IJavaElement[]{elt},IJavaSearchScope.SOURCES);
    SearchEngine engine=new SearchEngine();
    SearchRequestor requestor=new SearchRequestor(){
      @Override public void acceptSearchMatch(      SearchMatch match) throws CoreException {
        result.add((IMethod)match.getElement());
      }
    }
;
    try {
      engine.search(p,new SearchParticipant[]{SearchEngine.getDefaultSearchParticipant()},scope,requestor,null);
    }
 catch (    CoreException e) {
      e.printStackTrace();
    }
    return result;
  }
}","/** 
 * Use the search engine to find all methods in a java element
 */
public static Collection<IMethod> findMethods(IJavaElement elt){
  if (elt instanceof ICompilationUnit) {
    Collection<IMethod> result=HashSetFactory.make();
    for (    IType type : getClasses((ICompilationUnit)elt)) {
      try {
        for (        IMethod m : type.getMethods()) {
          result.add(m);
        }
      }
 catch (      JavaModelException e) {
        e.printStackTrace();
      }
    }
    return result;
  }
 else {
    final Collection<IMethod> result=HashSetFactory.make();
    SearchPattern p=SearchPattern.createPattern(""String_Node_Str"",IJavaSearchConstants.METHOD,IJavaSearchConstants.DECLARATIONS,SearchPattern.R_PATTERN_MATCH);
    SearchPattern p2=SearchPattern.createPattern(""String_Node_Str"",IJavaSearchConstants.CONSTRUCTOR,IJavaSearchConstants.DECLARATIONS,SearchPattern.R_PATTERN_MATCH);
    IJavaSearchScope scope=SearchEngine.createJavaSearchScope(new IJavaElement[]{elt},IJavaSearchScope.SOURCES);
    SearchEngine engine=new SearchEngine();
    SearchRequestor requestor=new SearchRequestor(){
      @Override public void acceptSearchMatch(      SearchMatch match) throws CoreException {
        if (match.getElement() instanceof IMethod) {
          result.add((IMethod)match.getElement());
        }
      }
    }
;
    try {
      engine.search(p,new SearchParticipant[]{SearchEngine.getDefaultSearchParticipant()},scope,requestor,null);
      engine.search(p2,new SearchParticipant[]{SearchEngine.getDefaultSearchParticipant()},scope,requestor,null);
    }
 catch (    CoreException e) {
      e.printStackTrace();
    }
    return result;
  }
}",0.8765473402475744
99998,"public void testSlice2() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA,CallGraphTestUtil.REGRESSION_EXCLUSIONS);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.SLICE2_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphBuilder builder=Util.makeZeroOneCFABuilder(options,new AnalysisCache(),cha,scope);
  CallGraph cg=builder.makeCallGraph(options,null);
  CGNode main=findMethod(cg,""String_Node_Str"");
  Statement s=findCallTo(main,""String_Node_Str"");
  System.err.println(""String_Node_Str"" + s);
  Collection<Statement> computeBackwardSlice=Slicer.computeBackwardSlice(s,cg,builder.getPointerAnalysis(),DataDependenceOptions.FULL,ControlDependenceOptions.NONE);
  Collection<Statement> slice=computeBackwardSlice;
  dumpSlice(slice);
  assertEquals(22,slice.size());
}","public void testSlice2() throws ClassHierarchyException, IllegalArgumentException, CancelException, IOException {
  AnalysisScope scope=CallGraphTestUtil.makeJ2SEAnalysisScope(TestConstants.WALA_TESTDATA,CallGraphTestUtil.REGRESSION_EXCLUSIONS);
  ClassHierarchy cha=ClassHierarchy.make(scope);
  Iterable<Entrypoint> entrypoints=com.ibm.wala.ipa.callgraph.impl.Util.makeMainEntrypoints(scope,cha,TestConstants.SLICE2_MAIN);
  AnalysisOptions options=CallGraphTestUtil.makeAnalysisOptions(scope,entrypoints);
  CallGraphBuilder builder=Util.makeZeroOneCFABuilder(options,new AnalysisCache(),cha,scope);
  CallGraph cg=builder.makeCallGraph(options,null);
  CGNode main=findMethod(cg,""String_Node_Str"");
  Statement s=findCallTo(main,""String_Node_Str"");
  System.err.println(""String_Node_Str"" + s);
  Collection<Statement> computeBackwardSlice=Slicer.computeBackwardSlice(s,cg,builder.getPointerAnalysis(),DataDependenceOptions.FULL,ControlDependenceOptions.NONE);
  Collection<Statement> slice=computeBackwardSlice;
  dumpSlice(slice);
  assertEquals(30,slice.size());
}",0.9981308411214952
99999,"protected TabulationCancelException(CancelException cause,Result r){
  super(cause);
  this.result=r;
}","protected TabulationCancelException(Exception cause,Result r){
  super(cause);
  this.result=r;
}",0.97
100000,"/** 
 * Solve the dataflow problem.
 * @return a representation of the result
 */
public TabulationResult<T,P> solve() throws CancelException {
  try {
    initialize();
    forwardTabulateSLRPs();
    Result r=new Result();
    return r;
  }
 catch (  CancelException e) {
    Result r=new Result();
    throw new TabulationCancelException(e,r);
  }
}","/** 
 * Solve the dataflow problem.
 * @return a representation of the result
 */
public TabulationResult<T,P> solve() throws CancelException {
  try {
    initialize();
    forwardTabulateSLRPs();
    Result r=new Result();
    return r;
  }
 catch (  CancelException e) {
    Result r=new Result();
    throw new TabulationCancelException(e,r);
  }
catch (  CancelRuntimeException e) {
    Result r=new Result();
    throw new TabulationCancelException(e,r);
  }
}",0.8606356968215159
