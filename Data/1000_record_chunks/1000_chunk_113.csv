record_number,buggy_code,fixed_code,code_similarity
112001,"public MessageColumnIORecordConsumer(ColumnWriteStore columns){
  int maxDepth=0;
  this.columnWriter=new ColumnWriter[MessageColumnIO.this.getLeaves().size()];
  for (  PrimitiveColumnIO primitiveColumnIO : MessageColumnIO.this.getLeaves()) {
    maxDepth=Math.max(maxDepth,primitiveColumnIO.getFieldPath().length);
    columnWriter[primitiveColumnIO.getId()]=columns.getColumnWriter(primitiveColumnIO.getColumnDescriptor());
  }
  currentIndex=new int[maxDepth];
  r=new int[maxDepth];
}","public MessageColumnIORecordConsumer(ColumnWriteStore columns){
  int maxDepth=0;
  this.columnWriter=new ColumnWriter[MessageColumnIO.this.getLeaves().size()];
  for (  PrimitiveColumnIO primitiveColumnIO : MessageColumnIO.this.getLeaves()) {
    maxDepth=Math.max(maxDepth,primitiveColumnIO.getFieldPath().length);
    columnWriter[primitiveColumnIO.getId()]=columns.getColumnWriter(primitiveColumnIO.getColumnDescriptor());
  }
  fieldsWritten=new FieldsMarker[maxDepth];
  for (int i=0; i < maxDepth; i++) {
    fieldsWritten[i]=new FieldsMarker();
  }
  r=new int[maxDepth];
}",0.8841121495327103
112002,"@Override public long getLength(){
  if (realSplit == null) {
    return 0;
  }
 else {
    try {
      return realSplit.getLength();
    }
 catch (    IOException ex) {
      throw new RuntimeException(""String_Node_Str"" + realSplit,ex);
    }
catch (    InterruptedException ex) {
      throw new RuntimeException(""String_Node_Str"" + realSplit,ex);
    }
  }
}","@Override public long getLength(){
  if (realSplit == null) {
    return 0;
  }
 else {
    return realSplit.getLength();
  }
}",0.5204918032786885
112003,"@Override public String[] getLocations() throws IOException {
  try {
    return realSplit.getLocations();
  }
 catch (  final InterruptedException e) {
    throw new IOException(e);
  }
}","@Override public String[] getLocations() throws IOException {
  return realSplit.getLocations();
}",0.6853146853146853
112004,"/** 
 * In thrift enum values are written as ints, this method checks if the enum index is defined.
 * @param expectedType
 * @param i
 */
private void checkEnum(ThriftType expectedType,int i){
  if (expectedType.getType() == ThriftTypeID.ENUM) {
    List<ThriftType.EnumValue> enumValues=((ThriftType.EnumType)expectedType).getValues();
    if (i >= enumValues.size() || enumValues.get(i) == null)     throw new DecodingSchemaMismatchException(""String_Node_Str"" + i + ""String_Node_Str""+ expectedType);
  }
}","/** 
 * In thrift enum values are written as ints, this method checks if the enum index is defined.
 * @param expectedType
 * @param i
 */
private void checkEnum(ThriftType expectedType,int i){
  if (expectedType.getType() == ThriftTypeID.ENUM) {
    ThriftType.EnumType expectedEnumType=(ThriftType.EnumType)expectedType;
    if (expectedEnumType.getEnumValueById(i) == null) {
      throw new DecodingSchemaMismatchException(""String_Node_Str"" + i + ""String_Node_Str""+ expectedType);
    }
  }
}",0.7609561752988048
112005,"public EnumWriteProtocol(PrimitiveColumnIO columnIO,EnumType type,Events returnClause){
  super(returnClause);
  for (  EnumValue enumValue : type.getValues()) {
    enumLookup.put(enumValue.getId(),Binary.fromString(enumValue.getName()));
  }
  this.columnIO=columnIO;
}","public EnumWriteProtocol(PrimitiveColumnIO columnIO,EnumType type,Events returnClause){
  super(returnClause);
  this.columnIO=columnIO;
  this.type=type;
}",0.6463700234192038
112006,"public FieldEnumConverter(List<TProtocol> events,ThriftField field){
  this.events=events;
  final List<EnumValue> values=((EnumType)field.getType()).getValues();
  for (  EnumValue enumValue : values) {
    enumLookup.put(Binary.fromString(enumValue.getName()),enumValue.getId());
  }
}","public FieldEnumConverter(List<TProtocol> events,ThriftField field){
  this.events=events;
  final Iterable<EnumValue> values=((EnumType)field.getType()).getValues();
  for (  EnumValue enumValue : values) {
    enumLookup.put(Binary.fromString(enumValue.getName()),enumValue.getId());
  }
}",0.3771626297577855
112007,"public List<EnumValue> getValues(){
  return values;
}","public Iterable<EnumValue> getValues(){
  return new Iterable<EnumValue>(){
    @Override public Iterator<EnumValue> iterator(){
      return values.iterator();
    }
  }
;
}",0.4473684210526316
112008,"/** 
 * When enum value in data has an undefined index, it's considered as corrupted record and will be skipped.
 * @throws Exception
 */
@Test public void testEnumMissingSchema() throws Exception {
  CountingErrorHandler countingHandler=new CountingErrorHandler();
  BufferedProtocolReadToWrite p=new BufferedProtocolReadToWrite(new ThriftSchemaConverter().toStructType(StructWithEnum.class),countingHandler);
  final ByteArrayOutputStream in=new ByteArrayOutputStream();
  final ByteArrayOutputStream out=new ByteArrayOutputStream();
  StructWithMoreEnum moreEnum=new StructWithMoreEnum(NumberEnumWithMoreValue.FOUR);
  moreEnum.write(protocol(in));
  try {
    p.readOne(protocol(new ByteArrayInputStream(in.toByteArray())),protocol(out));
  }
 catch (  SkippableException e) {
    Throwable cause=e.getCause();
    assertTrue(cause instanceof DecodingSchemaMismatchException);
    assertTrue(cause.getMessage().contains(""String_Node_Str""));
  }
  assertEquals(0,countingHandler.recordCountOfMissingFields);
  assertEquals(0,countingHandler.fieldIgnoredCount);
}","/** 
 * When enum value in data has an undefined index, it's considered as corrupted record and will be skipped.
 * @throws Exception
 */
@Test public void testEnumMissingSchema() throws Exception {
  CountingErrorHandler countingHandler=new CountingErrorHandler();
  BufferedProtocolReadToWrite p=new BufferedProtocolReadToWrite(new ThriftSchemaConverter().toStructType(StructWithEnum.class),countingHandler);
  final ByteArrayOutputStream in=new ByteArrayOutputStream();
  final ByteArrayOutputStream out=new ByteArrayOutputStream();
  StructWithMoreEnum enumDefinedInOldDefinition=new StructWithMoreEnum(NumberEnumWithMoreValue.THREE);
  StructWithMoreEnum extraEnumDefinedInNewDefinition=new StructWithMoreEnum(NumberEnumWithMoreValue.FOUR);
  enumDefinedInOldDefinition.write(protocol(in));
  extraEnumDefinedInNewDefinition.write(protocol(in));
  try {
    p.readOne(protocol(new ByteArrayInputStream(in.toByteArray())),protocol(out));
  }
 catch (  SkippableException e) {
    Throwable cause=e.getCause();
    assertTrue(cause instanceof DecodingSchemaMismatchException);
    assertTrue(cause.getMessage().contains(""String_Node_Str""));
  }
  assertEquals(0,countingHandler.recordCountOfMissingFields);
  assertEquals(0,countingHandler.fieldIgnoredCount);
}",0.900815800772864
112009,"public EnumWriteProtocol(PrimitiveColumnIO columnIO,EnumType type,Events returnClause){
  super(returnClause);
  for (  EnumValue enumValue : type.getValues()) {
    enumLookup.put(enumValue.getId(),Binary.fromString(enumValue.getName()));
  }
  this.columnIO=columnIO;
}","public EnumWriteProtocol(PrimitiveColumnIO columnIO,EnumType type,Events returnClause){
  super(returnClause);
  this.columnIO=columnIO;
  this.type=type;
}",0.6463700234192038
112010,"public FieldEnumConverter(List<TProtocol> events,ThriftField field){
  this.events=events;
  final List<EnumValue> values=((EnumType)field.getType()).getValues();
  for (  EnumValue enumValue : values) {
    enumLookup.put(Binary.fromString(enumValue.getName()),enumValue.getId());
  }
}","public FieldEnumConverter(List<TProtocol> events,ThriftField field){
  this.events=events;
  final Iterable<EnumValue> values=((EnumType)field.getType()).getValues();
  for (  EnumValue enumValue : values) {
    enumLookup.put(Binary.fromString(enumValue.getName()),enumValue.getId());
  }
}",0.3771626297577855
112011,"public List<EnumValue> getValues(){
  return values;
}","public Iterable<EnumValue> getValues(){
  return new Iterable<EnumValue>(){
    @Override public Iterator<EnumValue> iterator(){
      return values.iterator();
    }
  }
;
}",0.4473684210526316
112012,"/** 
 * When enum value in data has an undefined index, it's considered as corrupted record and will be skipped.
 * @throws Exception
 */
@Test public void testEnumMissingSchema() throws Exception {
  CountingErrorHandler countingHandler=new CountingErrorHandler();
  BufferedProtocolReadToWrite p=new BufferedProtocolReadToWrite(new ThriftSchemaConverter().toStructType(StructWithEnum.class),countingHandler);
  final ByteArrayOutputStream in=new ByteArrayOutputStream();
  final ByteArrayOutputStream out=new ByteArrayOutputStream();
  StructWithMoreEnum moreEnum=new StructWithMoreEnum(NumberEnumWithMoreValue.FOUR);
  moreEnum.write(protocol(in));
  try {
    p.readOne(protocol(new ByteArrayInputStream(in.toByteArray())),protocol(out));
  }
 catch (  SkippableException e) {
    Throwable cause=e.getCause();
    assertTrue(cause instanceof DecodingSchemaMismatchException);
    assertTrue(cause.getMessage().contains(""String_Node_Str""));
  }
  assertEquals(0,countingHandler.recordCountOfMissingFields);
  assertEquals(0,countingHandler.fieldIgnoredCount);
}","/** 
 * When enum value in data has an undefined index, it's considered as corrupted record and will be skipped.
 * @throws Exception
 */
@Test public void testEnumMissingSchema() throws Exception {
  CountingErrorHandler countingHandler=new CountingErrorHandler();
  BufferedProtocolReadToWrite p=new BufferedProtocolReadToWrite(new ThriftSchemaConverter().toStructType(StructWithEnum.class),countingHandler);
  final ByteArrayOutputStream in=new ByteArrayOutputStream();
  final ByteArrayOutputStream out=new ByteArrayOutputStream();
  StructWithMoreEnum enumDefinedInOldDefinition=new StructWithMoreEnum(NumberEnumWithMoreValue.THREE);
  StructWithMoreEnum extraEnumDefinedInNewDefinition=new StructWithMoreEnum(NumberEnumWithMoreValue.FOUR);
  enumDefinedInOldDefinition.write(protocol(in));
  extraEnumDefinedInNewDefinition.write(protocol(in));
  try {
    p.readOne(protocol(new ByteArrayInputStream(in.toByteArray())),protocol(out));
  }
 catch (  SkippableException e) {
    Throwable cause=e.getCause();
    assertTrue(cause instanceof DecodingSchemaMismatchException);
    assertTrue(cause.getMessage().contains(""String_Node_Str""));
  }
  assertEquals(0,countingHandler.recordCountOfMissingFields);
  assertEquals(0,countingHandler.fieldIgnoredCount);
}",0.900815800772864
112013,"/** 
 * Internal method visible for testing purposes
 */
@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) Class<? extends HiveBinding> createInternal(Class hiveVersionInfo){
  String hiveVersion;
  try {
    Method getVersionMethod=hiveVersionInfo.getMethod(HIVE_VERSION_METHOD_NAME,(Class[])null);
    String rawVersion=(String)getVersionMethod.invoke(null,(Object[])null);
    LOG.debug(""String_Node_Str"" + hiveVersionInfo.getSimpleName() + ""String_Node_Str""+ rawVersion+ ""String_Node_Str"");
    hiveVersion=trimVersion(rawVersion);
  }
 catch (  Exception e) {
    throw new UnexpectedHiveVersionProviderError(""String_Node_Str"" + ""String_Node_Str"",e);
  }
  if (hiveVersion.startsWith(HIVE_VERSION_010)) {
    LOG.debug(""String_Node_Str"" + hiveVersion + ""String_Node_Str""+ Hive010Binding.class.getSimpleName());
    return Hive010Binding.class;
  }
 else   if (hiveVersion.startsWith(HIVE_VERSION_011)) {
    LOG.debug(""String_Node_Str"" + hiveVersion + ""String_Node_Str""+ Hive010Binding.class.getSimpleName()+ ""String_Node_Str""+ ""String_Node_Str"");
    return Hive010Binding.class;
  }
  LOG.debug(""String_Node_Str"" + hiveVersion + ""String_Node_Str""+ Hive012Binding.class.getSimpleName());
  return Hive012Binding.class;
}","/** 
 * Internal method visible for testing purposes
 */
@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) Class<? extends HiveBinding> createInternal(Class hiveVersionInfo){
  String hiveVersion;
  try {
    Method getVersionMethod=hiveVersionInfo.getMethod(HIVE_VERSION_METHOD_NAME,(Class[])null);
    String rawVersion=(String)getVersionMethod.invoke(null,(Object[])null);
    LOG.debug(""String_Node_Str"" + hiveVersionInfo.getSimpleName() + ""String_Node_Str""+ rawVersion+ ""String_Node_Str"");
    hiveVersion=trimVersion(rawVersion);
  }
 catch (  Exception e) {
    throw new UnexpectedHiveVersionProviderError(""String_Node_Str"" + ""String_Node_Str"",e);
  }
  if (hiveVersion.equalsIgnoreCase(HIVE_VERSION_UNKNOWN)) {
    LOG.debug(""String_Node_Str"");
    return createBindingForUnknownVersion();
  }
  if (hiveVersion.startsWith(HIVE_VERSION_010)) {
    LOG.debug(""String_Node_Str"" + hiveVersion + ""String_Node_Str""+ Hive010Binding.class.getSimpleName());
    return Hive010Binding.class;
  }
 else   if (hiveVersion.startsWith(HIVE_VERSION_011)) {
    LOG.debug(""String_Node_Str"" + hiveVersion + ""String_Node_Str""+ Hive010Binding.class.getSimpleName()+ ""String_Node_Str""+ ""String_Node_Str"");
    return Hive010Binding.class;
  }
  LOG.debug(""String_Node_Str"" + hiveVersion + ""String_Node_Str""+ Hive012Binding.class.getSimpleName());
  return Hive012Binding.class;
}",0.9451897278650824
112014,"@Test public void testUnknownHiveVersion(){
  hiveBindingFactory.createInternal(UnknownHiveVersion.class);
  Assert.assertEquals(Hive012Binding.class,hiveBindingFactory.createInternal(UnknownHiveVersion.class));
}","@Test public void testUnknownHiveVersion(){
  hiveBindingFactory.createInternal(BlankHiveVersion.class);
  Assert.assertEquals(Hive012Binding.class,hiveBindingFactory.createInternal(BlankHiveVersion.class));
}",0.962085308056872
112015,"private boolean readOneStruct(TProtocol in,List<Action> buffer,StructType type) throws TException {
  final TStruct struct=in.readStructBegin();
  buffer.add(new Action(){
    @Override public void write(    TProtocol out) throws TException {
      out.writeStructBegin(struct);
    }
    @Override public String toDebugString(){
      return ""String_Node_Str"";
    }
  }
);
  TField field;
  boolean hasFieldsIgnored=false;
  while ((field=in.readFieldBegin()).type != TType.STOP) {
    final TField currentField=field;
    if (field.id > type.getChildren().size()) {
      notifyIgnoredFieldsOfRecord(field);
      hasFieldsIgnored|=true;
      new ProtocolReadToWrite().readOneValue(in,new NullProtocol(),field.type);
      continue;
    }
    buffer.add(new Action(){
      @Override public void write(      TProtocol out) throws TException {
        out.writeFieldBegin(currentField);
      }
      @Override public String toDebugString(){
        return ""String_Node_Str"" + currentField.id + ""String_Node_Str""+ typeName(currentField.type)+ ""String_Node_Str"";
      }
    }
);
    ThriftField expectedField=type.getChildById(field.id);
    try {
      hasFieldsIgnored|=readOneValue(in,field.type,buffer,expectedField.getType());
    }
 catch (    Exception e) {
      throw new TException(""String_Node_Str"" + field + ""String_Node_Str""+ expectedField,e);
    }
    in.readFieldEnd();
    buffer.add(FIELD_END);
  }
  in.readStructEnd();
  buffer.add(STRUCT_END);
  return hasFieldsIgnored;
}","private boolean readOneStruct(TProtocol in,List<Action> buffer,StructType type) throws TException {
  final TStruct struct=in.readStructBegin();
  buffer.add(new Action(){
    @Override public void write(    TProtocol out) throws TException {
      out.writeStructBegin(struct);
    }
    @Override public String toDebugString(){
      return ""String_Node_Str"";
    }
  }
);
  TField field;
  boolean hasFieldsIgnored=false;
  while ((field=in.readFieldBegin()).type != TType.STOP) {
    final TField currentField=field;
    if (field.id > type.getChildren().size()) {
      notifyIgnoredFieldsOfRecord(field);
      hasFieldsIgnored|=true;
      new ProtocolReadToWrite().readOneValue(in,new NullProtocol(),field.type);
      continue;
    }
    buffer.add(new Action(){
      @Override public void write(      TProtocol out) throws TException {
        out.writeFieldBegin(currentField);
      }
      @Override public String toDebugString(){
        return ""String_Node_Str"" + currentField.id + ""String_Node_Str""+ typeName(currentField.type)+ ""String_Node_Str"";
      }
    }
);
    ThriftField expectedField=type.getChildById(field.id);
    hasFieldsIgnored|=readOneValue(in,field.type,buffer,expectedField.getType());
    in.readFieldEnd();
    buffer.add(FIELD_END);
  }
  in.readStructEnd();
  buffer.add(STRUCT_END);
  return hasFieldsIgnored;
}",0.9498069498069498
112016,"@Test public void testMissingFieldHandling() throws Exception {
  BufferedProtocolReadToWrite p=new BufferedProtocolReadToWrite(new ThriftSchemaConverter().toStructType(StructV3.class));
  CountingErrorHandler countingHandler=new CountingErrorHandler();
  p.unregisterAllErrorHandlers();
  p.registerErrorHandler(countingHandler);
  final ByteArrayOutputStream in=new ByteArrayOutputStream();
  StructV4WithExtracStructField dataWithNewSchema=new StructV4WithExtracStructField(""String_Node_Str"");
  dataWithNewSchema.setAge(""String_Node_Str"");
  dataWithNewSchema.setGender(""String_Node_Str"");
  StructV3 structV3=new StructV3(""String_Node_Str"");
  structV3.setAge(""String_Node_Str"");
  dataWithNewSchema.setAddedStruct(structV3);
  dataWithNewSchema.write(protocol(in));
  final ByteArrayOutputStream out=new ByteArrayOutputStream();
  p.readOne(protocol(new ByteArrayInputStream(in.toByteArray())),protocol(out));
  assertEquals(0,countingHandler.corruptedCount);
  assertEquals(1,countingHandler.recordCountOfMissingFields);
  assertEquals(1,countingHandler.fieldIgnoredCount);
}","/** 
 * When data contains extra field, it should notify the handler and read the data with extra field dropped
 * @throws Exception
 */
@Test public void testMissingFieldHandling() throws Exception {
  BufferedProtocolReadToWrite structForRead=new BufferedProtocolReadToWrite(new ThriftSchemaConverter().toStructType(StructV3.class));
  CountingErrorHandler countingHandler=new CountingErrorHandler(){
    @Override public void handleFieldIgnored(    TField field){
      assertEquals(field.id,4);
      fieldIgnoredCount++;
    }
  }
;
  structForRead.unregisterAllErrorHandlers();
  structForRead.registerErrorHandler(countingHandler);
  final ByteArrayOutputStream in=new ByteArrayOutputStream();
  StructV4WithExtracStructField dataWithNewSchema=new StructV4WithExtracStructField(""String_Node_Str"");
  dataWithNewSchema.setAge(""String_Node_Str"");
  dataWithNewSchema.setGender(""String_Node_Str"");
  StructV3 structV3=new StructV3(""String_Node_Str"");
  structV3.setAge(""String_Node_Str"");
  dataWithNewSchema.setAddedStruct(structV3);
  dataWithNewSchema.write(protocol(in));
  final ByteArrayOutputStream out=new ByteArrayOutputStream();
  structForRead.readOne(protocol(new ByteArrayInputStream(in.toByteArray())),protocol(out));
  assertEquals(0,countingHandler.corruptedCount);
  assertEquals(1,countingHandler.recordCountOfMissingFields);
  assertEquals(1,countingHandler.fieldIgnoredCount);
  assertEquals(0,countingHandler.schemaMismatchCount);
  StructV4WithExtracStructField b=StructV4WithExtracStructField.class.newInstance();
  b.read(protocol(new ByteArrayInputStream(out.toByteArray())));
  assertEquals(dataWithNewSchema.getName(),b.getName());
  assertEquals(dataWithNewSchema.getAge(),b.getAge());
  assertEquals(dataWithNewSchema.getGender(),b.getGender());
  assertEquals(null,b.getAddedStruct());
}",0.7413021012745435
112017,"@Override public void handleSkipRecordDueToSchemaMismatch(DecodingSchemaMismatchException e){
}","@Override public void handleSkipRecordDueToSchemaMismatch(DecodingSchemaMismatchException e){
  schemaMismatchCount++;
}",0.8837209302325582
112018,"@Override public void reset(){
  if (encodedValues != null) {
    encodedValues=new IntList();
  }
  plainValuesWriter.reset();
}","@Override public void reset(){
  if (encodedValues != null) {
    encodedValues=new IntList();
  }
  plainValuesWriter.reset();
  rawDataByteSize=0;
}",0.9247311827956988
112019,"@Test public void testLongDictionaryFallBack() throws IOException {
  int slabSize=100;
  int maxDictionaryByteSize=50;
  final DictionaryValuesWriter cw=new PlainLongDictionaryValuesWriter(maxDictionaryByteSize,slabSize);
  int fallBackThreshold=maxDictionaryByteSize / 8;
  for (long i=0; i < 100; i++) {
    cw.writeLong(i);
    if (i < fallBackThreshold) {
      assertEquals(cw.getEncoding(),PLAIN_DICTIONARY);
    }
 else {
      assertEquals(cw.getEncoding(),PLAIN);
    }
  }
  ValuesReader reader=new PlainValuesReader.LongPlainValuesReader();
  reader.initFromPage(100,cw.getBytes().toByteArray(),0);
  for (long i=0; i < 100; i++) {
    assertEquals(i,reader.readLong());
  }
}","@Test public void testLongDictionaryFallBack() throws IOException {
  int slabSize=100;
  int maxDictionaryByteSize=50;
  final DictionaryValuesWriter cw=new PlainLongDictionaryValuesWriter(maxDictionaryByteSize,slabSize);
  int fallBackThreshold=maxDictionaryByteSize / 8;
  for (long i=0; i < 100; i++) {
    cw.writeLong(i);
    if (i < fallBackThreshold) {
      assertEquals(cw.getEncoding(),PLAIN_DICTIONARY);
    }
 else {
      assertEquals(cw.getEncoding(),PLAIN);
    }
  }
  ValuesReader reader=new PlainValuesReader.LongPlainValuesReader();
  reader.initFromPage(100,cw.getBytes().toByteArray(),0);
  for (long i=0; i < 100; i++) {
    assertEquals(i,reader.readLong());
  }
  cw.reset();
  assertEquals(0,cw.getBufferedSize());
}",0.9622377622377624
112020,"/** 
 * Fallback strategy is to decode the dictionary and write the result to PlainWriter
 * @throws IOException
 */
@Test public void testIntDictionaryFallBack() throws IOException {
  int slabSize=100;
  int maxDictionaryByteSize=50;
  final DictionaryValuesWriter cw=new PlainIntegerDictionaryValuesWriter(maxDictionaryByteSize,slabSize);
  int fallBackThreshold=maxDictionaryByteSize / 4;
  for (int i=0; i < 100; i++) {
    cw.writeInteger(i);
    if (i < fallBackThreshold) {
      assertEquals(cw.getEncoding(),PLAIN_DICTIONARY);
    }
 else {
      assertEquals(cw.getEncoding(),PLAIN);
    }
  }
  ValuesReader reader=new PlainValuesReader.IntegerPlainValuesReader();
  reader.initFromPage(100,cw.getBytes().toByteArray(),0);
  for (int i=0; i < 100; i++) {
    assertEquals(i,reader.readInteger());
  }
}","/** 
 * Fallback strategy is to decode the dictionary and write the result to PlainWriter
 * @throws IOException
 */
@Test public void testIntDictionaryFallBack() throws IOException {
  int slabSize=100;
  int maxDictionaryByteSize=50;
  final DictionaryValuesWriter cw=new PlainIntegerDictionaryValuesWriter(maxDictionaryByteSize,slabSize);
  int fallBackThreshold=maxDictionaryByteSize / 4;
  for (int i=0; i < 100; i++) {
    cw.writeInteger(i);
    if (i < fallBackThreshold) {
      assertEquals(cw.getEncoding(),PLAIN_DICTIONARY);
    }
 else {
      assertEquals(cw.getEncoding(),PLAIN);
    }
  }
  ValuesReader reader=new PlainValuesReader.IntegerPlainValuesReader();
  reader.initFromPage(100,cw.getBytes().toByteArray(),0);
  for (int i=0; i < 100; i++) {
    assertEquals(i,reader.readInteger());
  }
  cw.reset();
  assertEquals(0,cw.getBufferedSize());
}",0.967895362663496
112021,"@Test public void testFloatDictionaryFallBack() throws IOException {
  int slabSize=100;
  int maxDictionaryByteSize=50;
  final DictionaryValuesWriter cw=new PlainFloatDictionaryValuesWriter(maxDictionaryByteSize,slabSize);
  int fallBackThreshold=maxDictionaryByteSize / 4;
  for (float i=0; i < 100; i++) {
    cw.writeFloat(i);
    if (i < fallBackThreshold) {
      assertEquals(cw.getEncoding(),PLAIN_DICTIONARY);
    }
 else {
      assertEquals(cw.getEncoding(),PLAIN);
    }
  }
  ValuesReader reader=new PlainValuesReader.FloatPlainValuesReader();
  reader.initFromPage(100,cw.getBytes().toByteArray(),0);
  for (float i=0; i < 100; i++) {
    assertEquals(i,reader.readFloat(),0.00001);
  }
}","@Test public void testFloatDictionaryFallBack() throws IOException {
  int slabSize=100;
  int maxDictionaryByteSize=50;
  final DictionaryValuesWriter cw=new PlainFloatDictionaryValuesWriter(maxDictionaryByteSize,slabSize);
  int fallBackThreshold=maxDictionaryByteSize / 4;
  for (float i=0; i < 100; i++) {
    cw.writeFloat(i);
    if (i < fallBackThreshold) {
      assertEquals(cw.getEncoding(),PLAIN_DICTIONARY);
    }
 else {
      assertEquals(cw.getEncoding(),PLAIN);
    }
  }
  ValuesReader reader=new PlainValuesReader.FloatPlainValuesReader();
  reader.initFromPage(100,cw.getBytes().toByteArray(),0);
  for (float i=0; i < 100; i++) {
    assertEquals(i,reader.readFloat(),0.00001);
  }
  cw.reset();
  assertEquals(0,cw.getBufferedSize());
}",0.963013698630137
112022,"@Test public void testDoubleDictionaryFallBack() throws IOException {
  int slabSize=100;
  int maxDictionaryByteSize=50;
  final DictionaryValuesWriter cw=new PlainDoubleDictionaryValuesWriter(maxDictionaryByteSize,slabSize);
  int fallBackThreshold=maxDictionaryByteSize / 8;
  for (double i=0; i < 100; i++) {
    cw.writeDouble(i);
    if (i < fallBackThreshold) {
      assertEquals(cw.getEncoding(),PLAIN_DICTIONARY);
    }
 else {
      assertEquals(cw.getEncoding(),PLAIN);
    }
  }
  ValuesReader reader=new PlainValuesReader.DoublePlainValuesReader();
  reader.initFromPage(100,cw.getBytes().toByteArray(),0);
  for (float i=0; i < 100; i++) {
    assertEquals(i,reader.readDouble(),0.00001);
  }
}","@Test public void testDoubleDictionaryFallBack() throws IOException {
  int slabSize=100;
  int maxDictionaryByteSize=50;
  final DictionaryValuesWriter cw=new PlainDoubleDictionaryValuesWriter(maxDictionaryByteSize,slabSize);
  int fallBackThreshold=maxDictionaryByteSize / 8;
  for (double i=0; i < 100; i++) {
    cw.writeDouble(i);
    if (i < fallBackThreshold) {
      assertEquals(cw.getEncoding(),PLAIN_DICTIONARY);
    }
 else {
      assertEquals(cw.getEncoding(),PLAIN);
    }
  }
  ValuesReader reader=new PlainValuesReader.DoublePlainValuesReader();
  reader.initFromPage(100,cw.getBytes().toByteArray(),0);
  for (float i=0; i < 100; i++) {
    assertEquals(i,reader.readDouble(),0.00001);
  }
  System.out.println(cw.getBufferedSize());
  cw.reset();
  assertEquals(0,cw.getBufferedSize());
}",0.9353562005277044
112023,"@Test public void testBinaryDictionaryFallBack() throws IOException {
  int slabSize=100;
  int maxDictionaryByteSize=50;
  final DictionaryValuesWriter cw=new PlainBinaryDictionaryValuesWriter(maxDictionaryByteSize,slabSize);
  int fallBackThreshold=maxDictionaryByteSize;
  int dataSize=0;
  for (long i=0; i < 100; i++) {
    Binary binary=Binary.fromString(""String_Node_Str"" + i);
    cw.writeBytes(binary);
    dataSize+=(binary.length() + 4);
    if (dataSize < fallBackThreshold) {
      assertEquals(PLAIN_DICTIONARY,cw.getEncoding());
    }
 else {
      assertEquals(PLAIN,cw.getEncoding());
    }
  }
  ValuesReader reader=new BinaryPlainValuesReader();
  reader.initFromPage(100,cw.getBytes().toByteArray(),0);
  for (long i=0; i < 100; i++) {
    assertEquals(Binary.fromString(""String_Node_Str"" + i),reader.readBytes());
  }
}","@Test public void testBinaryDictionaryFallBack() throws IOException {
  int slabSize=100;
  int maxDictionaryByteSize=50;
  final DictionaryValuesWriter cw=new PlainBinaryDictionaryValuesWriter(maxDictionaryByteSize,slabSize);
  int fallBackThreshold=maxDictionaryByteSize;
  int dataSize=0;
  for (long i=0; i < 100; i++) {
    Binary binary=Binary.fromString(""String_Node_Str"" + i);
    cw.writeBytes(binary);
    dataSize+=(binary.length() + 4);
    if (dataSize < fallBackThreshold) {
      assertEquals(PLAIN_DICTIONARY,cw.getEncoding());
    }
 else {
      assertEquals(PLAIN,cw.getEncoding());
    }
  }
  ValuesReader reader=new BinaryPlainValuesReader();
  reader.initFromPage(100,cw.getBytes().toByteArray(),0);
  for (long i=0; i < 100; i++) {
    assertEquals(Binary.fromString(""String_Node_Str"" + i),reader.readBytes());
  }
  cw.reset();
  assertEquals(0,cw.getBufferedSize());
}",0.9688581314878892
112024,"@Override public long getBufferedSize(){
  return rawDataByteSize;
}","@Override public long getBufferedSize(){
  return dictionaryTooBig ? plainValuesWriter.getBufferedSize() : encodedValues.size() * 4;
}",0.6138613861386139
112025,"@Override protected void clearDictionaryContent(){
  float[] reverseDictionary=new float[getDictionarySize()];
  FloatIterator dicKeyIterator=floatDictionaryContent.keySet().iterator();
  while (dicKeyIterator.hasNext()) {
    float key=dicKeyIterator.nextFloat();
    int id=floatDictionaryContent.get(key);
    reverseDictionary[id]=key;
  }
  IntIterator iterator=encodedValues.iterator();
  while (iterator.hasNext()) {
    int id=iterator.next();
    plainValuesWriter.writeFloat(reverseDictionary[id]);
  }
  floatDictionaryContent.clear();
}","@Override protected void clearDictionaryContent(){
  floatDictionaryContent.clear();
}",0.2712933753943217
112026,"private void fallBackToPlainEncoding(){
  if (DEBUG)   LOG.debug(""String_Node_Str"" + dictionaryByteSize + ""String_Node_Str""+ getDictionarySize()+ ""String_Node_Str"");
  dictionaryTooBig=true;
  if (lastUsedDictionarySize == 0) {
    clearDictionaryContent();
    dictionaryByteSize=0;
    encodedValues=null;
  }
}","private void fallBackToPlainEncoding(){
  if (DEBUG)   LOG.debug(""String_Node_Str"" + dictionaryByteSize + ""String_Node_Str""+ getDictionarySize()+ ""String_Node_Str"");
  dictionaryTooBig=true;
  fallBackDictionaryEncodedData();
  if (lastUsedDictionarySize == 0) {
    clearDictionaryContent();
    dictionaryByteSize=0;
    encodedValues=null;
  }
}",0.9470499243570348
112027,"@Override public int initFromPage(long valueCount,byte[] page,int offset) throws IOException {
  if (DEBUG)   LOG.debug(""String_Node_Str"" + offset + ""String_Node_Str""+ (page.length - offset));
  this.in=new ByteArrayInputStream(page,offset,page.length - offset);
  int bitWidth=BytesUtils.readIntLittleEndianOnOneByte(in);
  if (DEBUG)   LOG.debug(""String_Node_Str"" + bitWidth);
  decoder=new RunLengthBitPackingHybridDecoder((int)valueCount,bitWidth,in);
  return page.length;
}","@Override public int initFromPage(long valueCount,byte[] page,int offset) throws IOException {
  if (DEBUG)   LOG.debug(""String_Node_Str"" + offset + ""String_Node_Str""+ (page.length - offset));
  this.in=new ByteArrayInputStream(page,offset,page.length - offset);
  int bitWidth=BytesUtils.readIntLittleEndianOnOneByte(in);
  if (DEBUG)   LOG.debug(""String_Node_Str"" + bitWidth);
  decoder=new RunLengthBitPackingHybridDecoder(bitWidth,in);
  return page.length;
}",0.9660297239915074
112028,"public RunLengthBitPackingHybridDecoder(int numValues,int bitWidth,InputStream in){
  if (DEBUG)   LOG.debug(""String_Node_Str"" + bitWidth);
  Preconditions.checkArgument(bitWidth >= 0 && bitWidth <= 32,""String_Node_Str"");
  this.bitWidth=bitWidth;
  this.packer=Packer.LITTLE_ENDIAN.newBytePacker(bitWidth);
  this.in=in;
  this.valuesRemaining=numValues;
}","public RunLengthBitPackingHybridDecoder(int bitWidth,ByteArrayInputStream in){
  if (DEBUG)   LOG.debug(""String_Node_Str"" + bitWidth);
  Preconditions.checkArgument(bitWidth >= 0 && bitWidth <= 32,""String_Node_Str"");
  this.bitWidth=bitWidth;
  this.packer=Packer.LITTLE_ENDIAN.newBytePacker(bitWidth);
  this.in=in;
}",0.8918518518518519
112029,"public int readInt() throws IOException {
  Preconditions.checkArgument(valuesRemaining > 0,""String_Node_Str"");
  if (currentCount == 0) {
    readNext();
  }
  --currentCount;
  --valuesRemaining;
  int result;
switch (mode) {
case RLE:
    result=currentValue;
  break;
case PACKED:
result=currentBuffer[currentBuffer.length - 1 - currentCount];
break;
default :
throw new ParquetDecodingException(""String_Node_Str"" + mode);
}
return result;
}","public int readInt() throws IOException {
  if (currentCount == 0) {
    readNext();
  }
  --currentCount;
  int result;
switch (mode) {
case RLE:
    result=currentValue;
  break;
case PACKED:
result=currentBuffer[currentBuffer.length - 1 - currentCount];
break;
default :
throw new ParquetDecodingException(""String_Node_Str"" + mode);
}
return result;
}",0.886107634543179
112030,"private void readNext() throws IOException {
  final int header=BytesUtils.readUnsignedVarInt(in);
  mode=(header & 1) == 0 ? MODE.RLE : MODE.PACKED;
switch (mode) {
case RLE:
    currentCount=header >>> 1;
  if (DEBUG)   LOG.debug(""String_Node_Str"" + currentCount + ""String_Node_Str"");
currentValue=BytesUtils.readIntLittleEndianPaddedOnBitWidth(in,bitWidth);
break;
case PACKED:
int numGroups=header >>> 1;
currentCount=numGroups * 8;
if (DEBUG) LOG.debug(""String_Node_Str"" + currentCount + ""String_Node_Str"");
currentBuffer=new int[currentCount];
byte[] bytes=new byte[numGroups * bitWidth];
int valuesLeft=Math.min(currentCount,valuesRemaining);
new DataInputStream(in).readFully(bytes,0,(int)Math.ceil(valuesLeft * bitWidth / 8.0));
for (int valueIndex=0, byteIndex=0; valueIndex < currentCount; valueIndex+=8, byteIndex+=bitWidth) {
packer.unpack8Values(bytes,byteIndex,currentBuffer,valueIndex);
}
break;
default :
throw new ParquetDecodingException(""String_Node_Str"" + mode);
}
}","private void readNext() throws IOException {
  Preconditions.checkArgument(in.available() > 0,""String_Node_Str"");
  final int header=BytesUtils.readUnsignedVarInt(in);
  mode=(header & 1) == 0 ? MODE.RLE : MODE.PACKED;
switch (mode) {
case RLE:
    currentCount=header >>> 1;
  if (DEBUG)   LOG.debug(""String_Node_Str"" + currentCount + ""String_Node_Str"");
currentValue=BytesUtils.readIntLittleEndianPaddedOnBitWidth(in,bitWidth);
break;
case PACKED:
int numGroups=header >>> 1;
currentCount=numGroups * 8;
if (DEBUG) LOG.debug(""String_Node_Str"" + currentCount + ""String_Node_Str"");
currentBuffer=new int[currentCount];
byte[] bytes=new byte[numGroups * bitWidth];
int bytesToRead=(int)Math.ceil(currentCount * bitWidth / 8.0);
bytesToRead=Math.min(bytesToRead,in.available());
new DataInputStream(in).readFully(bytes,0,bytesToRead);
for (int valueIndex=0, byteIndex=0; valueIndex < currentCount; valueIndex+=8, byteIndex+=bitWidth) {
packer.unpack8Values(bytes,byteIndex,currentBuffer,valueIndex);
}
break;
default :
throw new ParquetDecodingException(""String_Node_Str"" + mode);
}
}",0.8680521991300145
112031,"@Override public int initFromPage(long valueCountL,byte[] page,int offset) throws IOException {
  int valueCount=Ints.checkedCast(valueCountL);
  if (valueCount <= 0) {
    return offset;
  }
  ByteArrayInputStream in=new ByteArrayInputStream(page,offset,page.length);
  int length=BytesUtils.readIntLittleEndian(in);
  decoder=new RunLengthBitPackingHybridDecoder(valueCount,bitWidth,in);
  return offset + length + 4;
}","@Override public int initFromPage(long valueCountL,byte[] page,int offset) throws IOException {
  int valueCount=Ints.checkedCast(valueCountL);
  if (valueCount <= 0) {
    return offset;
  }
  ByteArrayInputStream in=new ByteArrayInputStream(page,offset,page.length);
  int length=BytesUtils.readIntLittleEndian(in);
  decoder=new RunLengthBitPackingHybridDecoder(bitWidth,in);
  return offset + length + 4;
}",0.967509025270758
112032,"private void doIntegrationTest(int bitWidth) throws Exception {
  long modValue=1L << bitWidth;
  RunLengthBitPackingHybridEncoder encoder=new RunLengthBitPackingHybridEncoder(bitWidth,1000);
  int numValues=0;
  for (int i=0; i < 100; i++) {
    encoder.writeInt((int)(i % modValue));
  }
  numValues+=100;
  for (int i=0; i < 100; i++) {
    encoder.writeInt((int)(77 % modValue));
  }
  numValues+=100;
  for (int i=0; i < 100; i++) {
    encoder.writeInt((int)(88 % modValue));
  }
  numValues+=100;
  for (int i=0; i < 1000; i++) {
    encoder.writeInt((int)(i % modValue));
    encoder.writeInt((int)(i % modValue));
    encoder.writeInt((int)(i % modValue));
  }
  numValues+=3000;
  for (int i=0; i < 1000; i++) {
    encoder.writeInt((int)(17 % modValue));
  }
  numValues+=1000;
  InputStream in=new ByteArrayInputStream(encoder.toBytes().toByteArray());
  RunLengthBitPackingHybridDecoder decoder=new RunLengthBitPackingHybridDecoder(numValues,bitWidth,in);
  for (int i=0; i < 100; i++) {
    assertEquals(i % modValue,decoder.readInt());
  }
  for (int i=0; i < 100; i++) {
    assertEquals(77 % modValue,decoder.readInt());
  }
  for (int i=0; i < 100; i++) {
    assertEquals(88 % modValue,decoder.readInt());
  }
  for (int i=0; i < 1000; i++) {
    assertEquals(i % modValue,decoder.readInt());
    assertEquals(i % modValue,decoder.readInt());
    assertEquals(i % modValue,decoder.readInt());
  }
  for (int i=0; i < 1000; i++) {
    assertEquals(17 % modValue,decoder.readInt());
  }
}","private void doIntegrationTest(int bitWidth) throws Exception {
  long modValue=1L << bitWidth;
  RunLengthBitPackingHybridEncoder encoder=new RunLengthBitPackingHybridEncoder(bitWidth,1000);
  int numValues=0;
  for (int i=0; i < 100; i++) {
    encoder.writeInt((int)(i % modValue));
  }
  numValues+=100;
  for (int i=0; i < 100; i++) {
    encoder.writeInt((int)(77 % modValue));
  }
  numValues+=100;
  for (int i=0; i < 100; i++) {
    encoder.writeInt((int)(88 % modValue));
  }
  numValues+=100;
  for (int i=0; i < 1000; i++) {
    encoder.writeInt((int)(i % modValue));
    encoder.writeInt((int)(i % modValue));
    encoder.writeInt((int)(i % modValue));
  }
  numValues+=3000;
  for (int i=0; i < 1000; i++) {
    encoder.writeInt((int)(17 % modValue));
  }
  numValues+=1000;
  byte[] encodedBytes=encoder.toBytes().toByteArray();
  ByteArrayInputStream in=new ByteArrayInputStream(encodedBytes);
  RunLengthBitPackingHybridDecoder decoder=new RunLengthBitPackingHybridDecoder(bitWidth,in);
  for (int i=0; i < 100; i++) {
    assertEquals(i % modValue,decoder.readInt());
  }
  for (int i=0; i < 100; i++) {
    assertEquals(77 % modValue,decoder.readInt());
  }
  for (int i=0; i < 100; i++) {
    assertEquals(88 % modValue,decoder.readInt());
  }
  for (int i=0; i < 1000; i++) {
    assertEquals(i % modValue,decoder.readInt());
    assertEquals(i % modValue,decoder.readInt());
    assertEquals(i % modValue,decoder.readInt());
  }
  for (int i=0; i < 1000; i++) {
    assertEquals(17 % modValue,decoder.readInt());
  }
}",0.9582922824302136
112033,"@Test public void testGroupBoundary() throws Exception {
  byte[] bytes=new byte[2];
  bytes[0]=(1 << 1) | 1;
  bytes[1]=(1 << 0) | (2 << 2) | (3 << 4);
  ByteArrayInputStream stream=new ByteArrayInputStream(bytes);
  RunLengthBitPackingHybridDecoder decoder=new RunLengthBitPackingHybridDecoder(3,2,stream);
  assertEquals(decoder.readInt(),1);
  assertEquals(decoder.readInt(),2);
  assertEquals(decoder.readInt(),3);
  assertEquals(stream.available(),0);
}","@Test public void testGroupBoundary() throws Exception {
  byte[] bytes=new byte[2];
  bytes[0]=(1 << 1) | 1;
  bytes[1]=(1 << 0) | (2 << 2) | (3 << 4);
  ByteArrayInputStream stream=new ByteArrayInputStream(bytes);
  RunLengthBitPackingHybridDecoder decoder=new RunLengthBitPackingHybridDecoder(2,stream);
  assertEquals(decoder.readInt(),1);
  assertEquals(decoder.readInt(),2);
  assertEquals(decoder.readInt(),3);
  assertEquals(stream.available(),0);
}",0.8209606986899564
112034,"private void convertToElephantBirdCompatibleSchema(Schema schema){
  for (  FieldSchema fieldSchema : schema.getFields()) {
    if (fieldSchema.type == DataType.BOOLEAN) {
      fieldSchema.type=DataType.INTEGER;
    }
  }
}","private void convertToElephantBirdCompatibleSchema(Schema schema){
  if (schema == null) {
    return;
  }
  for (  FieldSchema fieldSchema : schema.getFields()) {
    if (fieldSchema.type == DataType.BOOLEAN) {
      fieldSchema.type=DataType.INTEGER;
    }
    convertToElephantBirdCompatibleSchema(fieldSchema.schema);
  }
}",0.8130671506352087
112035,"private void initSchema(Job job) throws IOException {
  if (requestedSchema == null) {
    final GlobalMetaData globalMetaData=getParquetInputFormat().getGlobalMetaData(job);
    schema=getPigSchemaFromMultipleFiles(globalMetaData.getSchema(),globalMetaData.getKeyValueMetaData());
    if (isElephantBirdCompatible(job)) {
      convertToElephantBirdCompatibleSchema(schema);
    }
  }
 else {
    schema=requestedSchema;
  }
}","private void initSchema(Job job) throws IOException {
  if (schema != null) {
    return;
  }
  if (requestedSchema != null) {
    schema=requestedSchema;
    return;
  }
  schema=PigSchemaConverter.parsePigSchema(UDFContext.getUDFContext().getUDFProperties(this.getClass(),new String[]{signature}).getProperty(PARQUET_PIG_SCHEMA));
  if (schema == null) {
    final GlobalMetaData globalMetaData=getParquetInputFormat().getGlobalMetaData(job);
    schema=getPigSchemaFromMultipleFiles(globalMetaData.getSchema(),globalMetaData.getKeyValueMetaData());
  }
  if (isElephantBirdCompatible(job)) {
    convertToElephantBirdCompatibleSchema(schema);
  }
}",0.7031539888682746
112036,"private void setInput(String location,Job job) throws IOException {
  this.setLocationHasBeenCalled=true;
  this.location=location;
  setInputPaths(job,location);
}","private void setInput(String location,Job job) throws IOException {
  this.setLocationHasBeenCalled=true;
  this.location=location;
  setInputPaths(job,location);
  initSchema(job);
}",0.9452449567723344
112037,"@Override public ResourceSchema getSchema(String location,Job job) throws IOException {
  if (DEBUG)   LOG.debug(""String_Node_Str"" + location + ""String_Node_Str""+ job+ ""String_Node_Str"");
  setInput(location,job);
  if (schema == null) {
    initSchema(job);
  }
  return new ResourceSchema(schema);
}","@Override public ResourceSchema getSchema(String location,Job job) throws IOException {
  if (DEBUG)   LOG.debug(""String_Node_Str"" + location + ""String_Node_Str""+ job+ ""String_Node_Str"");
  setInput(location,job);
  return new ResourceSchema(schema);
}",0.7956600361663653
112038,"@Override public RequiredFieldResponse pushProjection(RequiredFieldList requiredFieldList) throws FrontendException {
  if (requiredFieldList == null)   return null;
  schema=getSchemaFromRequiredFieldList(schema,requiredFieldList.getFields());
  return new RequiredFieldResponse(true);
}","@Override public RequiredFieldResponse pushProjection(RequiredFieldList requiredFieldList) throws FrontendException {
  if (requiredFieldList == null)   return null;
  schema=getSchemaFromRequiredFieldList(schema,requiredFieldList.getFields());
  storeInUDFContext(PARQUET_PIG_SCHEMA,pigSchemaToString(schema));
  return new RequiredFieldResponse(true);
}",0.895800933125972
112039,"@Override public void setLocation(String location,Job job) throws IOException {
  if (DEBUG)   LOG.debug(""String_Node_Str"" + location + ""String_Node_Str""+ job+ ""String_Node_Str"");
  setInput(location,job);
  if (schema == null) {
    initSchema(job);
  }
  getConfiguration(job).set(PARQUET_PIG_SCHEMA,pigSchemaToString(schema));
}","@Override public void setLocation(String location,Job job) throws IOException {
  if (DEBUG)   LOG.debug(""String_Node_Str"" + location + ""String_Node_Str""+ job+ ""String_Node_Str"");
  setInput(location,job);
  getConfiguration(job).set(PARQUET_PIG_SCHEMA,pigSchemaToString(schema));
}",0.9200652528548124
112040,"/** 
 * @param pigSchemaString the pig schema to parse
 * @return the parsed pig schema
 */
static Schema parsePigSchema(String pigSchemaString){
  try {
    return pigSchemaString == null ? null : Utils.getSchemaFromString(pigSchemaString);
  }
 catch (  ParserException e) {
    throw new SchemaConversionException(""String_Node_Str"" + pigSchemaString,e);
  }
}","/** 
 * @param pigSchemaString the pig schema to parse
 * @return the parsed pig schema
 */
public static Schema parsePigSchema(String pigSchemaString){
  try {
    return pigSchemaString == null ? null : Utils.getSchemaFromString(pigSchemaString);
  }
 catch (  ParserException e) {
    throw new SchemaConversionException(""String_Node_Str"" + pigSchemaString,e);
  }
}",0.9904240766073872
112041,"/** 
 * {@inheritDoc}
 * @see parquet.io.api.RecordMaterializer#getCurrentRecord()
 */
@Override public T getCurrentRecord(){
  try {
    rootEvents=new ProtocolEventsAmender(rootEvents).amendMissingRequiredFields(thriftType);
    protocol.addAll(rootEvents);
    rootEvents.clear();
    return thriftReader.readOneRecord(protocol);
  }
 catch (  TException e) {
    throw new ParquetDecodingException(""String_Node_Str"",e);
  }
}","/** 
 * {@inheritDoc}
 * @see parquet.io.api.RecordMaterializer#getCurrentRecord()
 */
@Override public T getCurrentRecord(){
  try {
    List<TProtocol> fixedEvents=new ProtocolEventsAmender(rootEvents).amendMissingRequiredFields(thriftType);
    protocol.addAll(fixedEvents);
    rootEvents.clear();
    return thriftReader.readOneRecord(protocol);
  }
 catch (  TException e) {
    throw new ParquetDecodingException(""String_Node_Str"",e);
  }
}",0.9611872146118722
112042,"public List<TProtocol> createProtocolEventsForField(ThriftField missingField){
  TProtocol fieldBegin=new ReadFieldBeginProtocol(missingField);
  createdEvents.add(fieldBegin);
  DummyCreatorVisitor dummyCreatorvisitor=new DummyCreatorVisitor();
  missingField.getType().accept(dummyCreatorvisitor);
  createdEvents.addAll(dummyCreatorvisitor.getEvents());
  createdEvents.add(READ_FIELD_END);
  return createdEvents;
}","public List<TProtocol> createProtocolEventsForField(ThriftField missingField){
  TProtocol fieldBegin=new ReadFieldBeginProtocol(missingField);
  createdEvents.add(fieldBegin);
  DefaultEventsVisitor dummyCreatorvisitor=new DefaultEventsVisitor();
  missingField.getType().accept(dummyCreatorvisitor);
  createdEvents.addAll(dummyCreatorvisitor.getEvents());
  createdEvents.add(READ_FIELD_END);
  return createdEvents;
}",0.923809523809524
112043,"private void flushStore() throws IOException {
  LOG.info(""String_Node_Str"" + store.allocatedSize());
  w.startBlock(recordCount);
  store.flush();
  pageStore.flushToFileWriter(w);
  recordCount=0;
  w.endBlock();
  store=null;
  pageStore=null;
}","private void flushStore() throws IOException {
  LOG.info(""String_Node_Str"" + store.allocatedSize());
  if (store.allocatedSize() > 3 * blockSize) {
    LOG.warn(""String_Node_Str"" + store.memUsageString());
  }
  w.startBlock(recordCount);
  store.flush();
  pageStore.flushToFileWriter(w);
  recordCount=0;
  w.endBlock();
  store=null;
  pageStore=null;
}",0.8198347107438017
112044,"private void checkBlockSizeReached() throws IOException {
  if (recordCount >= recordCountForNextMemCheck) {
    long memSize=store.memSize();
    if (memSize > blockSize) {
      LOG.info(""String_Node_Str"" + memSize + ""String_Node_Str""+ blockSize+ ""String_Node_Str""+ recordCount+ ""String_Node_Str"");
      flushStore();
      initStore();
      recordCountForNextMemCheck=Math.max(100,recordCount / 2);
    }
 else {
      float recordSize=(float)memSize / recordCount;
      recordCountForNextMemCheck=Math.max(100,(recordCount + (long)(blockSize / recordSize)) / 2);
      LOG.debug(""String_Node_Str"" + recordCount + ""String_Node_Str""+ recordCountForNextMemCheck);
    }
  }
}","private void checkBlockSizeReached() throws IOException {
  if (recordCount >= recordCountForNextMemCheck) {
    long memSize=store.memSize();
    if (memSize > blockSize) {
      LOG.info(""String_Node_Str"" + memSize + ""String_Node_Str""+ blockSize+ ""String_Node_Str""+ recordCount+ ""String_Node_Str"");
      flushStore();
      initStore();
      recordCountForNextMemCheck=min(max(MINIMUM_RECORD_COUNT_FOR_CHECK,recordCount / 2),MAXIMUM_RECORD_COUNT_FOR_CHECK);
    }
 else {
      float recordSize=(float)memSize / recordCount;
      recordCountForNextMemCheck=min(max(MINIMUM_RECORD_COUNT_FOR_CHECK,(recordCount + (long)(blockSize / recordSize)) / 2),recordCount + MAXIMUM_RECORD_COUNT_FOR_CHECK);
      if (DEBUG)       LOG.debug(""String_Node_Str"" + recordCount + ""String_Node_Str""+ recordCountForNextMemCheck);
    }
  }
}",0.881063122923588
112045,"@Test public void testBinaryDictionaryInefficiency() throws IOException {
  int COUNT=40000;
  ValuesWriter cw=new PlainBinaryDictionaryValuesWriter(2000000,10000);
  for (int i=0; i < COUNT; i++) {
    cw.writeBytes(Binary.fromString(""String_Node_Str"" + i));
  }
  final BytesInput bytes1=BytesInput.copy(cw.getBytes());
  final Encoding encoding1=cw.getEncoding();
  System.out.println(PrimitiveTypeName.BINARY.name() + ""String_Node_Str"" + encoding1+ ""String_Node_Str""+ bytes1.size());
  cw.reset();
  for (int i=0; i < COUNT; i++) {
    cw.writeBytes(Binary.fromString(""String_Node_Str"" + i));
  }
  final BytesInput bytes2=BytesInput.copy(cw.getBytes());
  final Encoding encoding2=cw.getEncoding();
  System.out.println(PrimitiveTypeName.BINARY.name() + ""String_Node_Str"" + encoding2+ ""String_Node_Str""+ bytes2.size());
  cw.reset();
  final DictionaryPage dictionaryPage=cw.createDictionaryPage();
  Dictionary dictionary=null;
  long dictPageSize=0;
  ValuesReader cr;
  if (dictionaryPage != null) {
    dictPageSize=dictionaryPage.getBytes().size();
    System.out.println(PrimitiveTypeName.BINARY.name() + ""String_Node_Str"" + dictPageSize);
    final ColumnDescriptor descriptor=new ColumnDescriptor(new String[]{""String_Node_Str""},PrimitiveTypeName.BINARY,0,0);
    dictionary=Encoding.PLAIN_DICTIONARY.initDictionary(descriptor,dictionaryPage);
    cr=new DictionaryValuesReader(dictionary);
  }
 else {
    cr=new BinaryPlainValuesReader();
  }
  cr.initFromPage(COUNT,bytes1.toByteArray(),0);
  for (int i=0; i < COUNT; i++) {
    final String str=cr.readBytes().toStringUsingUTF8();
    Assert.assertEquals(""String_Node_Str"" + i,str);
  }
  if (dictionary != null && encoding2 == Encoding.PLAIN_DICTIONARY) {
    cr=new DictionaryValuesReader(dictionary);
  }
 else {
    cr=new BinaryPlainValuesReader();
  }
  cr.initFromPage(COUNT,bytes2.toByteArray(),0);
  for (int i=0; i < COUNT; i++) {
    final String str=cr.readBytes().toStringUsingUTF8();
    Assert.assertEquals(""String_Node_Str"" + i,str);
  }
  assertTrue(""String_Node_Str"",bytes1.size() < bytes2.size());
  assertEquals(""String_Node_Str"",dictPageSize,bytes2.size());
}","@Test public void testBinaryDictionaryInefficiency() throws IOException {
  int COUNT=40000;
  ValuesWriter cw=new PlainBinaryDictionaryValuesWriter(500000,10000);
  for (int i=0; i < COUNT; i++) {
    cw.writeBytes(Binary.fromString(""String_Node_Str"" + i));
  }
  final BytesInput bytes1=BytesInput.copy(cw.getBytes());
  final Encoding encoding1=cw.getEncoding();
  System.out.println(PrimitiveTypeName.BINARY.name() + ""String_Node_Str"" + encoding1+ ""String_Node_Str""+ bytes1.size());
  cw.reset();
  for (int i=0; i < COUNT; i++) {
    cw.writeBytes(Binary.fromString(""String_Node_Str"" + i));
  }
  final BytesInput bytes2=BytesInput.copy(cw.getBytes());
  final Encoding encoding2=cw.getEncoding();
  System.out.println(PrimitiveTypeName.BINARY.name() + ""String_Node_Str"" + encoding2+ ""String_Node_Str""+ bytes2.size());
  cw.reset();
  final DictionaryPage dictionaryPage=cw.createDictionaryPage();
  Dictionary dictionary=null;
  long dictPageSize=0;
  ValuesReader cr;
  if (dictionaryPage != null) {
    dictPageSize=dictionaryPage.getBytes().size();
    System.out.println(PrimitiveTypeName.BINARY.name() + ""String_Node_Str"" + dictPageSize);
    final ColumnDescriptor descriptor=new ColumnDescriptor(new String[]{""String_Node_Str""},PrimitiveTypeName.BINARY,0,0);
    dictionary=Encoding.PLAIN_DICTIONARY.initDictionary(descriptor,dictionaryPage);
    cr=new DictionaryValuesReader(dictionary);
  }
 else {
    cr=new BinaryPlainValuesReader();
  }
  cr.initFromPage(COUNT,bytes1.toByteArray(),0);
  for (int i=0; i < COUNT; i++) {
    final String str=cr.readBytes().toStringUsingUTF8();
    Assert.assertEquals(""String_Node_Str"" + i,str);
  }
  if (dictionary != null && encoding2 == Encoding.PLAIN_DICTIONARY) {
    cr=new DictionaryValuesReader(dictionary);
  }
 else {
    cr=new BinaryPlainValuesReader();
  }
  cr.initFromPage(COUNT,bytes2.toByteArray(),0);
  for (int i=0; i < COUNT; i++) {
    final String str=cr.readBytes().toStringUsingUTF8();
    Assert.assertEquals(""String_Node_Str"" + i,str);
  }
  assertTrue(""String_Node_Str"",bytes1.size() < bytes2.size());
  assertEquals(""String_Node_Str"",dictPageSize,bytes2.size());
}",0.9993011879804332
112046,"private void writeFile() throws IOException {
  final MessageType schema=new MessageType(""String_Node_Str"",new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.INT32,""String_Node_Str""),new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.BINARY,""String_Node_Str""),new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.BINARY,""String_Node_Str""),new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.INT32,""String_Node_Str""),new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.BINARY,""String_Node_Str""),new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.DOUBLE,""String_Node_Str""),new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.BINARY,""String_Node_Str""),new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.BINARY,""String_Node_Str""),new GroupType(Repetition.OPTIONAL,""String_Node_Str"",OriginalType.MAP_KEY_VALUE,new GroupType(Repetition.REPEATED,""String_Node_Str"",new PrimitiveType(Repetition.REQUIRED,PrimitiveTypeName.BINARY,""String_Node_Str""),new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.BINARY,""String_Node_Str""))),new GroupType(Repetition.OPTIONAL,""String_Node_Str"",OriginalType.LIST,new GroupType(Repetition.REPEATED,""String_Node_Str"",new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.INT32,""String_Node_Str""))));
  final MemPageStore pageStore=new MemPageStore(1000);
  final ColumnWriteStoreImpl store=new ColumnWriteStoreImpl(pageStore,8 * 1024,8 * 1024,false);
  final MessageColumnIO columnIO=new ColumnIOFactory().getColumnIO(schema);
  final RecordConsumer recordWriter=columnIO.getRecordWriter(store);
  Map<String,String> map=new HashMap<String,String>();
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  List<Integer> list=new ArrayList<Integer>();
  list.add(0);
  list.add(12);
  list.add(17);
  int recordCount=0;
  mapData.clear();
  for (int i=0; i < 1000; i++) {
    recordWriter.startMessage();
    mapData.put(i,UtilitiesTestMethods.createArrayWritable(i,i % 11 == 0 ? null : ""String_Node_Str"" + i,i % 12 == 0 ? null : ""String_Node_Str"" + i,i % 13 == 0 ? null : i,i % 14 == 0 ? null : ""String_Node_Str"" + i,i % 15 == 0 ? null : 1.2d * i,i % 16 == 0 ? null : ""String_Node_Str"" + i,i % 17 == 0 ? null : ""String_Node_Str"" + i,i % 18 == 0 ? null : map,i % 19 == 0 ? null : list));
    saveData(recordWriter,i,i % 11 == 0 ? null : ""String_Node_Str"" + i,i % 12 == 0 ? null : ""String_Node_Str"" + i,i % 13 == 0 ? null : i,i % 14 == 0 ? null : ""String_Node_Str"" + i,i % 15 == 0 ? null : 1.2d * i,i % 16 == 0 ? null : ""String_Node_Str"" + i,i % 17 == 0 ? null : ""String_Node_Str"" + i,i % 18 == 0 ? null : map,i % 19 == 0 ? null : list);
    recordWriter.endMessage();
    ++recordCount;
  }
  store.flush();
  UtilitiesTestMethods.writeToFile(new Path(testFile.getAbsolutePath()),conf,schema,pageStore,recordCount);
}","private void writeFile() throws IOException {
  final MessageType schema=new MessageType(""String_Node_Str"",new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.INT32,""String_Node_Str""),new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.BINARY,""String_Node_Str""),new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.BINARY,""String_Node_Str""),new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.INT32,""String_Node_Str""),new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.BINARY,""String_Node_Str""),new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.DOUBLE,""String_Node_Str""),new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.BINARY,""String_Node_Str""),new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.BINARY,""String_Node_Str""),new GroupType(Repetition.OPTIONAL,""String_Node_Str"",OriginalType.MAP_KEY_VALUE,new GroupType(Repetition.REPEATED,""String_Node_Str"",new PrimitiveType(Repetition.REQUIRED,PrimitiveTypeName.BINARY,""String_Node_Str""),new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.BINARY,""String_Node_Str""))),new GroupType(Repetition.OPTIONAL,""String_Node_Str"",OriginalType.LIST,new GroupType(Repetition.REPEATED,""String_Node_Str"",new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.INT32,""String_Node_Str""))));
  final MemPageStore pageStore=new MemPageStore(1000);
  final ColumnWriteStoreImpl store=new ColumnWriteStoreImpl(pageStore,8 * 1024,8 * 1024,8 * 1024,false);
  final MessageColumnIO columnIO=new ColumnIOFactory().getColumnIO(schema);
  final RecordConsumer recordWriter=columnIO.getRecordWriter(store);
  Map<String,String> map=new HashMap<String,String>();
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  List<Integer> list=new ArrayList<Integer>();
  list.add(0);
  list.add(12);
  list.add(17);
  int recordCount=0;
  mapData.clear();
  for (int i=0; i < 1000; i++) {
    recordWriter.startMessage();
    mapData.put(i,UtilitiesTestMethods.createArrayWritable(i,i % 11 == 0 ? null : ""String_Node_Str"" + i,i % 12 == 0 ? null : ""String_Node_Str"" + i,i % 13 == 0 ? null : i,i % 14 == 0 ? null : ""String_Node_Str"" + i,i % 15 == 0 ? null : 1.2d * i,i % 16 == 0 ? null : ""String_Node_Str"" + i,i % 17 == 0 ? null : ""String_Node_Str"" + i,i % 18 == 0 ? null : map,i % 19 == 0 ? null : list));
    saveData(recordWriter,i,i % 11 == 0 ? null : ""String_Node_Str"" + i,i % 12 == 0 ? null : ""String_Node_Str"" + i,i % 13 == 0 ? null : i,i % 14 == 0 ? null : ""String_Node_Str"" + i,i % 15 == 0 ? null : 1.2d * i,i % 16 == 0 ? null : ""String_Node_Str"" + i,i % 17 == 0 ? null : ""String_Node_Str"" + i,i % 18 == 0 ? null : map,i % 19 == 0 ? null : list);
    recordWriter.endMessage();
    ++recordCount;
  }
  store.flush();
  UtilitiesTestMethods.writeToFile(new Path(testFile.getAbsolutePath()),conf,schema,pageStore,recordCount);
}",0.9984090507336044
112047,"public static void main(String[] args) throws Throwable {
  File out=new File(""String_Node_Str"");
  if (out.exists()) {
    if (!out.delete()) {
      throw new RuntimeException(""String_Node_Str"" + out.getAbsolutePath());
    }
  }
  Path testFile=new Path(out.toURI());
  Configuration configuration=new Configuration();
{
    MessageType schema=new MessageType(""String_Node_Str"",new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.INT32,""String_Node_Str""));
    MemPageStore pageStore=new MemPageStore(100);
    ColumnWriteStoreImpl store=new ColumnWriteStoreImpl(pageStore,8 * 1024,8 * 1024,false);
    MessageColumnIO columnIO=new ColumnIOFactory().getColumnIO(schema);
    RecordConsumer recordWriter=columnIO.getRecordWriter(store);
    int recordCount=0;
    for (int i=0; i < 100; i++) {
      recordWriter.startMessage();
      recordWriter.startField(""String_Node_Str"",0);
      if (i % 10 != 0) {
        recordWriter.addInteger(i);
      }
      recordWriter.endField(""String_Node_Str"",0);
      recordWriter.endMessage();
      ++recordCount;
    }
    store.flush();
    writeToFile(testFile,configuration,schema,pageStore,recordCount);
  }
{
    readTestFile(testFile,configuration);
  }
}","public static void main(String[] args) throws Throwable {
  File out=new File(""String_Node_Str"");
  if (out.exists()) {
    if (!out.delete()) {
      throw new RuntimeException(""String_Node_Str"" + out.getAbsolutePath());
    }
  }
  Path testFile=new Path(out.toURI());
  Configuration configuration=new Configuration();
{
    MessageType schema=new MessageType(""String_Node_Str"",new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.INT32,""String_Node_Str""));
    MemPageStore pageStore=new MemPageStore(100);
    ColumnWriteStoreImpl store=new ColumnWriteStoreImpl(pageStore,8 * 1024,8 * 1024,8 * 1024,false);
    MessageColumnIO columnIO=new ColumnIOFactory().getColumnIO(schema);
    RecordConsumer recordWriter=columnIO.getRecordWriter(store);
    int recordCount=0;
    for (int i=0; i < 100; i++) {
      recordWriter.startMessage();
      recordWriter.startField(""String_Node_Str"",0);
      if (i % 10 != 0) {
        recordWriter.addInteger(i);
      }
      recordWriter.endField(""String_Node_Str"",0);
      recordWriter.endMessage();
      ++recordCount;
    }
    store.flush();
    writeToFile(testFile,configuration,schema,pageStore,recordCount);
  }
{
    readTestFile(testFile,configuration);
  }
}",0.9962886597938144
112048,"public static void main(String[] args) throws IOException {
  File out=new File(""String_Node_Str"");
  if (out.exists()) {
    if (!out.delete()) {
      throw new RuntimeException(""String_Node_Str"" + out.getAbsolutePath());
    }
  }
  Path testFile=new Path(out.toURI());
  Configuration configuration=new Configuration();
  MessageType schema=new MessageType(""String_Node_Str"",new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.INT32,""String_Node_Str""),new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.BINARY,""String_Node_Str""),new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.BINARY,""String_Node_Str""),new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.INT32,""String_Node_Str""),new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.BINARY,""String_Node_Str""),new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.DOUBLE,""String_Node_Str""),new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.BINARY,""String_Node_Str""),new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.BINARY,""String_Node_Str""));
  MemPageStore pageStore=new MemPageStore(150000);
  ColumnWriteStoreImpl store=new ColumnWriteStoreImpl(pageStore,20 * 1024,1 * 1024,false);
  MessageColumnIO columnIO=new ColumnIOFactory(true).getColumnIO(schema);
  RecordConsumer recordWriter=columnIO.getRecordWriter(store);
  int recordCount=0;
  for (int i=0; i < 150000; i++) {
    recordWriter.startMessage();
    writeField(recordWriter,0,""String_Node_Str"",i % 10 == 0 ? null : i);
    writeField(recordWriter,1,""String_Node_Str"",i % 11 == 0 ? null : ""String_Node_Str"" + i);
    writeField(recordWriter,2,""String_Node_Str"",i % 12 == 0 ? null : ""String_Node_Str"" + i);
    writeField(recordWriter,3,""String_Node_Str"",i % 13 == 0 ? null : i);
    writeField(recordWriter,4,""String_Node_Str"",i % 14 == 0 ? null : ""String_Node_Str"" + i);
    writeField(recordWriter,5,""String_Node_Str"",i % 15 == 0 ? null : 1.2d * i);
    writeField(recordWriter,6,""String_Node_Str"",i % 16 == 0 ? null : ""String_Node_Str"" + i);
    writeField(recordWriter,7,""String_Node_Str"",i % 17 == 0 ? null : ""String_Node_Str"" + i);
    recordWriter.endMessage();
    ++recordCount;
  }
  store.flush();
  System.out.printf(""String_Node_Str"",store.memSize(),store.maxColMemSize(),store.allocatedSize());
  System.out.println(store.memUsageString());
  writeToFile(testFile,configuration,schema,pageStore,recordCount);
  try {
    readTestFile(testFile,configuration);
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"",e);
  }
}","public static void main(String[] args) throws IOException {
  File out=new File(""String_Node_Str"");
  if (out.exists()) {
    if (!out.delete()) {
      throw new RuntimeException(""String_Node_Str"" + out.getAbsolutePath());
    }
  }
  Path testFile=new Path(out.toURI());
  Configuration configuration=new Configuration();
  MessageType schema=new MessageType(""String_Node_Str"",new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.INT32,""String_Node_Str""),new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.BINARY,""String_Node_Str""),new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.BINARY,""String_Node_Str""),new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.INT32,""String_Node_Str""),new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.BINARY,""String_Node_Str""),new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.DOUBLE,""String_Node_Str""),new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.BINARY,""String_Node_Str""),new PrimitiveType(Repetition.OPTIONAL,PrimitiveTypeName.BINARY,""String_Node_Str""));
  MemPageStore pageStore=new MemPageStore(150000);
  ColumnWriteStoreImpl store=new ColumnWriteStoreImpl(pageStore,20 * 1024,1 * 1024,20 * 1024,false);
  MessageColumnIO columnIO=new ColumnIOFactory(true).getColumnIO(schema);
  RecordConsumer recordWriter=columnIO.getRecordWriter(store);
  int recordCount=0;
  for (int i=0; i < 150000; i++) {
    recordWriter.startMessage();
    writeField(recordWriter,0,""String_Node_Str"",i % 10 == 0 ? null : i);
    writeField(recordWriter,1,""String_Node_Str"",i % 11 == 0 ? null : ""String_Node_Str"" + i);
    writeField(recordWriter,2,""String_Node_Str"",i % 12 == 0 ? null : ""String_Node_Str"" + i);
    writeField(recordWriter,3,""String_Node_Str"",i % 13 == 0 ? null : i);
    writeField(recordWriter,4,""String_Node_Str"",i % 14 == 0 ? null : ""String_Node_Str"" + i);
    writeField(recordWriter,5,""String_Node_Str"",i % 15 == 0 ? null : 1.2d * i);
    writeField(recordWriter,6,""String_Node_Str"",i % 16 == 0 ? null : ""String_Node_Str"" + i);
    writeField(recordWriter,7,""String_Node_Str"",i % 17 == 0 ? null : ""String_Node_Str"" + i);
    recordWriter.endMessage();
    ++recordCount;
  }
  store.flush();
  System.out.printf(""String_Node_Str"",store.memSize(),store.maxColMemSize(),store.allocatedSize());
  System.out.println(store.memUsageString());
  writeToFile(testFile,configuration,schema,pageStore,recordCount);
  try {
    readTestFile(testFile,configuration);
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"",e);
  }
}",0.9980031948881788
112049,"public static void main(String[] args) throws Exception {
  String pigSchema=pigSchema(false,false);
  String pigSchemaProjected=pigSchema(true,false);
  String pigSchemaNoString=pigSchema(true,true);
  MessageType schema=new PigSchemaConverter().convert(Utils.getSchemaFromString(pigSchema));
  MemPageStore memPageStore=new MemPageStore(0);
  ColumnWriteStoreImpl columns=new ColumnWriteStoreImpl(memPageStore,50 * 1024 * 1024,50 * 1024 * 1024,false);
  write(memPageStore,columns,schema,pigSchema);
  columns.flush();
  read(memPageStore,pigSchema,pigSchemaProjected,pigSchemaNoString);
  System.out.println(columns.memSize() + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + columns.maxColMemSize() + ""String_Node_Str"");
}","public static void main(String[] args) throws Exception {
  String pigSchema=pigSchema(false,false);
  String pigSchemaProjected=pigSchema(true,false);
  String pigSchemaNoString=pigSchema(true,true);
  MessageType schema=new PigSchemaConverter().convert(Utils.getSchemaFromString(pigSchema));
  MemPageStore memPageStore=new MemPageStore(0);
  ColumnWriteStoreImpl columns=new ColumnWriteStoreImpl(memPageStore,50 * 1024 * 1024,50 * 1024 * 1024,50 * 1024 * 1024,false);
  write(memPageStore,columns,schema,pigSchema);
  columns.flush();
  read(memPageStore,pigSchema,pigSchemaProjected,pigSchemaNoString);
  System.out.println(columns.memSize() + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + columns.maxColMemSize() + ""String_Node_Str"");
}",0.988628762541806
112050,"/** 
 * @param thriftReader the class responsible for instantiating the final object and read from the protocol
 * @param name the name of that type ( the thrift class simple name)
 * @param requestedParquetSchema the schema for the incoming columnar events
 * @param thriftType the thrift type descriptor
 */
public ThriftRecordConverter(ThriftReader<T> thriftReader,String name,MessageType requestedParquetSchema,ThriftType.StructType thriftType){
  super();
  this.thriftReader=thriftReader;
  this.protocol=new ParquetReadProtocol();
  this.structConverter=new StructConverter(rootEvents,requestedParquetSchema,new ThriftField(name,(short)0,Requirement.REQUIRED,thriftType));
}","/** 
 * @param thriftReader the class responsible for instantiating the final object and read from the protocol
 * @param name the name of that type ( the thrift class simple name)
 * @param requestedParquetSchema the schema for the incoming columnar events
 * @param thriftType the thrift type descriptor
 */
public ThriftRecordConverter(ThriftReader<T> thriftReader,String name,MessageType requestedParquetSchema,ThriftType.StructType thriftType){
  super();
  this.thriftReader=thriftReader;
  this.protocol=new ParquetReadProtocol();
  this.thriftType=thriftType;
  this.structConverter=new StructConverter(rootEvents,requestedParquetSchema,new ThriftField(name,(short)0,Requirement.REQUIRED,thriftType));
}",0.978448275862069
112051,"/** 
 * {@inheritDoc}
 * @see parquet.io.api.RecordMaterializer#getCurrentRecord()
 */
@Override public T getCurrentRecord(){
  try {
    protocol.addAll(rootEvents);
    rootEvents.clear();
    return thriftReader.readOneRecord(protocol);
  }
 catch (  TException e) {
    throw new ParquetDecodingException(""String_Node_Str"",e);
  }
}","/** 
 * {@inheritDoc}
 * @see parquet.io.api.RecordMaterializer#getCurrentRecord()
 */
@Override public T getCurrentRecord(){
  try {
    rootEvents=new ProtocolEventsAmender(rootEvents).amendMissingRequiredFields(thriftType);
    protocol.addAll(rootEvents);
    rootEvents.clear();
    return thriftReader.readOneRecord(protocol);
  }
 catch (  TException e) {
    throw new ParquetDecodingException(""String_Node_Str"",e);
  }
}",0.8784313725490196
112052,"public ParquetMetadata fromParquetMetadata(FileMetaData parquetMetadata) throws IOException {
  MessageType messageType=fromParquetSchema(parquetMetadata.getSchema());
  List<BlockMetaData> blocks=new ArrayList<BlockMetaData>();
  List<RowGroup> row_groups=parquetMetadata.getRow_groups();
  for (  RowGroup rowGroup : row_groups) {
    BlockMetaData blockMetaData=new BlockMetaData();
    blockMetaData.setRowCount(rowGroup.getNum_rows());
    blockMetaData.setTotalByteSize(rowGroup.getTotal_byte_size());
    List<ColumnChunk> columns=rowGroup.getColumns();
    String filePath=columns.get(0).getFile_path();
    for (    ColumnChunk columnChunk : columns) {
      if ((filePath == null && columnChunk.getFile_path() != null) || (filePath != null && !filePath.equals(columnChunk.getFile_path()))) {
        throw new ParquetDecodingException(""String_Node_Str"");
      }
      parquet.format.ColumnMetaData metaData=columnChunk.meta_data;
      ColumnPath path=getPath(metaData);
      ColumnChunkMetaData column=ColumnChunkMetaData.get(path,messageType.getType(path.toArray()).asPrimitiveType().getPrimitiveTypeName(),CompressionCodecName.fromParquet(metaData.codec),fromFormatEncodings(metaData.encodings),metaData.data_page_offset,metaData.dictionary_page_offset,metaData.num_values,metaData.total_uncompressed_size,metaData.total_compressed_size);
      blockMetaData.addColumn(column);
    }
    blockMetaData.setPath(filePath);
    blocks.add(blockMetaData);
  }
  Map<String,String> keyValueMetaData=new HashMap<String,String>();
  List<KeyValue> key_value_metadata=parquetMetadata.getKey_value_metadata();
  if (key_value_metadata != null) {
    for (    KeyValue keyValue : key_value_metadata) {
      keyValueMetaData.put(keyValue.key,keyValue.value);
    }
  }
  return new ParquetMetadata(new parquet.hadoop.metadata.FileMetaData(messageType,keyValueMetaData,parquetMetadata.getCreated_by()),blocks);
}","public ParquetMetadata fromParquetMetadata(FileMetaData parquetMetadata) throws IOException {
  MessageType messageType=fromParquetSchema(parquetMetadata.getSchema());
  List<BlockMetaData> blocks=new ArrayList<BlockMetaData>();
  List<RowGroup> row_groups=parquetMetadata.getRow_groups();
  for (  RowGroup rowGroup : row_groups) {
    BlockMetaData blockMetaData=new BlockMetaData();
    blockMetaData.setRowCount(rowGroup.getNum_rows());
    blockMetaData.setTotalByteSize(rowGroup.getTotal_byte_size());
    List<ColumnChunk> columns=rowGroup.getColumns();
    String filePath=columns.get(0).getFile_path();
    for (    ColumnChunk columnChunk : columns) {
      if ((filePath == null && columnChunk.getFile_path() != null) || (filePath != null && !filePath.equals(columnChunk.getFile_path()))) {
        throw new ParquetDecodingException(""String_Node_Str"");
      }
      parquet.format.ColumnMetaData metaData=columnChunk.meta_data;
      ColumnPath path=getPath(metaData);
      ColumnChunkMetaData column=ColumnChunkMetaData.get(path,messageType.getType(path.toArray()).asPrimitiveType().getPrimitiveTypeName(),CompressionCodecName.fromParquet(metaData.codec),fromFormatEncodings(metaData.encodings),metaData.data_page_offset,metaData.dictionary_page_offset,metaData.num_values,metaData.total_compressed_size,metaData.total_uncompressed_size);
      blockMetaData.addColumn(column);
    }
    blockMetaData.setPath(filePath);
    blocks.add(blockMetaData);
  }
  Map<String,String> keyValueMetaData=new HashMap<String,String>();
  List<KeyValue> key_value_metadata=parquetMetadata.getKey_value_metadata();
  if (key_value_metadata != null) {
    for (    KeyValue keyValue : key_value_metadata) {
      keyValueMetaData.put(keyValue.key,keyValue.value);
    }
  }
  return new ParquetMetadata(new parquet.hadoop.metadata.FileMetaData(messageType,keyValueMetaData,parquetMetadata.getCreated_by()),blocks);
}",0.9989561586638832
112053,"@Override public int initFromPage(long valueCount,byte[] page,int offset) throws IOException {
  if (DEBUG)   LOG.debug(""String_Node_Str"" + offset + ""String_Node_Str""+ (page.length - offset));
  this.in=new ByteArrayInputStream(page,offset,page.length - offset);
  int bitWidth=BytesUtils.readIntLittleEndianOnOneByte(in);
  if (DEBUG)   LOG.debug(""String_Node_Str"" + bitWidth);
  decoder=new RunLengthBitPackingHybridDecoder(bitWidth,in);
  return page.length;
}","@Override public int initFromPage(long valueCount,byte[] page,int offset) throws IOException {
  if (DEBUG)   LOG.debug(""String_Node_Str"" + offset + ""String_Node_Str""+ (page.length - offset));
  this.in=new ByteArrayInputStream(page,offset,page.length - offset);
  int bitWidth=BytesUtils.readIntLittleEndianOnOneByte(in);
  if (DEBUG)   LOG.debug(""String_Node_Str"" + bitWidth);
  decoder=new RunLengthBitPackingHybridDecoder((int)valueCount,bitWidth,in);
  return page.length;
}",0.9830148619957536
112054,"public RunLengthBitPackingHybridDecoder(int bitWidth,InputStream in){
  if (DEBUG)   LOG.debug(""String_Node_Str"" + bitWidth);
  Preconditions.checkArgument(bitWidth >= 0 && bitWidth <= 32,""String_Node_Str"");
  this.bitWidth=bitWidth;
  this.packer=Packer.LITTLE_ENDIAN.newBytePacker(bitWidth);
  this.in=in;
}","public RunLengthBitPackingHybridDecoder(int numValues,int bitWidth,InputStream in){
  if (DEBUG)   LOG.debug(""String_Node_Str"" + bitWidth);
  Preconditions.checkArgument(bitWidth >= 0 && bitWidth <= 32,""String_Node_Str"");
  this.bitWidth=bitWidth;
  this.packer=Packer.LITTLE_ENDIAN.newBytePacker(bitWidth);
  this.in=in;
  this.valuesRemaining=numValues;
}",0.927927927927928
112055,"public int readInt() throws IOException {
  if (currentCount == 0) {
    readNext();
  }
  --currentCount;
  int result;
switch (mode) {
case RLE:
    result=currentValue;
  break;
case PACKED:
result=currentBuffer[currentBuffer.length - 1 - currentCount];
break;
default :
throw new ParquetDecodingException(""String_Node_Str"" + mode);
}
return result;
}","public int readInt() throws IOException {
  Preconditions.checkArgument(valuesRemaining > 0,""String_Node_Str"");
  if (currentCount == 0) {
    readNext();
  }
  --currentCount;
  --valuesRemaining;
  int result;
switch (mode) {
case RLE:
    result=currentValue;
  break;
case PACKED:
result=currentBuffer[currentBuffer.length - 1 - currentCount];
break;
default :
throw new ParquetDecodingException(""String_Node_Str"" + mode);
}
return result;
}",0.886107634543179
112056,"private void readNext() throws IOException {
  final int header=BytesUtils.readUnsignedVarInt(in);
  mode=(header & 1) == 0 ? MODE.RLE : MODE.PACKED;
switch (mode) {
case RLE:
    currentCount=header >>> 1;
  if (DEBUG)   LOG.debug(""String_Node_Str"" + currentCount + ""String_Node_Str"");
currentValue=BytesUtils.readIntLittleEndianPaddedOnBitWidth(in,bitWidth);
break;
case PACKED:
int numGroups=header >>> 1;
currentCount=numGroups * 8;
if (DEBUG) LOG.debug(""String_Node_Str"" + currentCount + ""String_Node_Str"");
currentBuffer=new int[currentCount];
byte[] bytes=new byte[numGroups * bitWidth];
new DataInputStream(in).readFully(bytes);
for (int valueIndex=0, byteIndex=0; valueIndex < currentCount; valueIndex+=8, byteIndex+=bitWidth) {
packer.unpack8Values(bytes,byteIndex,currentBuffer,valueIndex);
}
break;
default :
throw new ParquetDecodingException(""String_Node_Str"" + mode);
}
}","private void readNext() throws IOException {
  final int header=BytesUtils.readUnsignedVarInt(in);
  mode=(header & 1) == 0 ? MODE.RLE : MODE.PACKED;
switch (mode) {
case RLE:
    currentCount=header >>> 1;
  if (DEBUG)   LOG.debug(""String_Node_Str"" + currentCount + ""String_Node_Str"");
currentValue=BytesUtils.readIntLittleEndianPaddedOnBitWidth(in,bitWidth);
break;
case PACKED:
int numGroups=header >>> 1;
currentCount=numGroups * 8;
if (DEBUG) LOG.debug(""String_Node_Str"" + currentCount + ""String_Node_Str"");
currentBuffer=new int[currentCount];
byte[] bytes=new byte[numGroups * bitWidth];
int valuesLeft=Math.min(currentCount,valuesRemaining);
new DataInputStream(in).readFully(bytes,0,(int)Math.ceil(valuesLeft * bitWidth / 8.0));
for (int valueIndex=0, byteIndex=0; valueIndex < currentCount; valueIndex+=8, byteIndex+=bitWidth) {
packer.unpack8Values(bytes,byteIndex,currentBuffer,valueIndex);
}
break;
default :
throw new ParquetDecodingException(""String_Node_Str"" + mode);
}
}",0.9460758142018152
112057,"@Override public int initFromPage(long valueCountL,byte[] page,int offset) throws IOException {
  int valueCount=Ints.checkedCast(valueCountL);
  if (valueCount <= 0) {
    return offset;
  }
  ByteArrayInputStream in=new ByteArrayInputStream(page,offset,page.length);
  int length=BytesUtils.readIntLittleEndian(in);
  decoder=new RunLengthBitPackingHybridDecoder(bitWidth,in);
  return offset + length + 4;
}","@Override public int initFromPage(long valueCountL,byte[] page,int offset) throws IOException {
  int valueCount=Ints.checkedCast(valueCountL);
  if (valueCount <= 0) {
    return offset;
  }
  ByteArrayInputStream in=new ByteArrayInputStream(page,offset,page.length);
  int length=BytesUtils.readIntLittleEndian(in);
  decoder=new RunLengthBitPackingHybridDecoder(valueCount,bitWidth,in);
  return offset + length + 4;
}",0.98676293622142
112058,"private void doIntegrationTest(int bitWidth) throws Exception {
  long modValue=1L << bitWidth;
  RunLengthBitPackingHybridEncoder encoder=new RunLengthBitPackingHybridEncoder(bitWidth,1000);
  for (int i=0; i < 100; i++) {
    encoder.writeInt((int)(i % modValue));
  }
  for (int i=0; i < 100; i++) {
    encoder.writeInt((int)(77 % modValue));
  }
  for (int i=0; i < 100; i++) {
    encoder.writeInt((int)(88 % modValue));
  }
  for (int i=0; i < 1000; i++) {
    encoder.writeInt((int)(i % modValue));
    encoder.writeInt((int)(i % modValue));
    encoder.writeInt((int)(i % modValue));
  }
  for (int i=0; i < 1000; i++) {
    encoder.writeInt((int)(17 % modValue));
  }
  InputStream in=new ByteArrayInputStream(encoder.toBytes().toByteArray());
  RunLengthBitPackingHybridDecoder decoder=new RunLengthBitPackingHybridDecoder(bitWidth,in);
  for (int i=0; i < 100; i++) {
    assertEquals(i % modValue,decoder.readInt());
  }
  for (int i=0; i < 100; i++) {
    assertEquals(77 % modValue,decoder.readInt());
  }
  for (int i=0; i < 100; i++) {
    assertEquals(88 % modValue,decoder.readInt());
  }
  for (int i=0; i < 1000; i++) {
    assertEquals(i % modValue,decoder.readInt());
    assertEquals(i % modValue,decoder.readInt());
    assertEquals(i % modValue,decoder.readInt());
  }
  for (int i=0; i < 1000; i++) {
    assertEquals(17 % modValue,decoder.readInt());
  }
}","private void doIntegrationTest(int bitWidth) throws Exception {
  long modValue=1L << bitWidth;
  RunLengthBitPackingHybridEncoder encoder=new RunLengthBitPackingHybridEncoder(bitWidth,1000);
  int numValues=0;
  for (int i=0; i < 100; i++) {
    encoder.writeInt((int)(i % modValue));
  }
  numValues+=100;
  for (int i=0; i < 100; i++) {
    encoder.writeInt((int)(77 % modValue));
  }
  numValues+=100;
  for (int i=0; i < 100; i++) {
    encoder.writeInt((int)(88 % modValue));
  }
  numValues+=100;
  for (int i=0; i < 1000; i++) {
    encoder.writeInt((int)(i % modValue));
    encoder.writeInt((int)(i % modValue));
    encoder.writeInt((int)(i % modValue));
  }
  numValues+=3000;
  for (int i=0; i < 1000; i++) {
    encoder.writeInt((int)(17 % modValue));
  }
  numValues+=1000;
  InputStream in=new ByteArrayInputStream(encoder.toBytes().toByteArray());
  RunLengthBitPackingHybridDecoder decoder=new RunLengthBitPackingHybridDecoder(numValues,bitWidth,in);
  for (int i=0; i < 100; i++) {
    assertEquals(i % modValue,decoder.readInt());
  }
  for (int i=0; i < 100; i++) {
    assertEquals(77 % modValue,decoder.readInt());
  }
  for (int i=0; i < 100; i++) {
    assertEquals(88 % modValue,decoder.readInt());
  }
  for (int i=0; i < 1000; i++) {
    assertEquals(i % modValue,decoder.readInt());
    assertEquals(i % modValue,decoder.readInt());
    assertEquals(i % modValue,decoder.readInt());
  }
  for (int i=0; i < 1000; i++) {
    assertEquals(17 % modValue,decoder.readInt());
  }
}",0.958116995500173
112059,"@Override public org.apache.hadoop.mapred.RecordReader<Void,MapWritable> getRecordReader(final org.apache.hadoop.mapred.InputSplit split,final org.apache.hadoop.mapred.JobConf job,final org.apache.hadoop.mapred.Reporter reporter) throws IOException {
  return (RecordReader<Void,MapWritable>)new RecordReaderWrapper(realInput,split,job,reporter);
}","@Override public org.apache.hadoop.mapred.RecordReader<Void,MapWritable> getRecordReader(final org.apache.hadoop.mapred.InputSplit split,final org.apache.hadoop.mapred.JobConf job,final org.apache.hadoop.mapred.Reporter reporter) throws IOException {
  try {
    return (RecordReader<Void,MapWritable>)new RecordReaderWrapper(realInput,split,job,reporter);
  }
 catch (  final InterruptedException e) {
    e.printStackTrace();
    return null;
  }
}",0.8721804511278195
112060,"public RecordReaderWrapper(final ParquetInputFormat<MapWritable> newInputFormat,final InputSplit oldSplit,final JobConf oldJobConf,final Reporter reporter) throws IOException {
  splitLen=oldSplit.getLength();
  ParquetInputSplit split;
  if (oldSplit instanceof InputSplitWrapper) {
    split=((InputSplitWrapper)oldSplit).getRealSplit();
  }
 else   if (oldSplit instanceof FileSplit) {
    final Path finalPath=((FileSplit)oldSplit).getPath();
    final JobConf cloneJob=manageJob.cloneJobAndInit(oldJobConf,finalPath.getParent());
    final ParquetMetadata parquetMetadata=ParquetFileReader.readFooter(cloneJob,finalPath);
    final List<BlockMetaData> blocks=parquetMetadata.getBlocks();
    final FileMetaData fileMetaData=parquetMetadata.getFileMetaData();
    final List<String> listColumns=(List<String>)StringUtils.getStringCollection(cloneJob.get(""String_Node_Str""));
    final MessageType fileSchema=fileMetaData.getSchema();
    MessageType requestedSchemaByUser=fileSchema;
    final List<Integer> indexColumnsWanted=ColumnProjectionUtils.getReadColumnIDs(cloneJob);
    if (indexColumnsWanted.isEmpty() == false) {
      final List<Type> typeList=new ArrayList<Type>();
      for (      final Integer idx : indexColumnsWanted) {
        typeList.add(fileSchema.getType(listColumns.get(idx)));
      }
      requestedSchemaByUser=new MessageType(fileSchema.getName(),typeList);
    }
    split=new ParquetInputSplit(finalPath,((FileSplit)oldSplit).getStart(),oldSplit.getLength(),oldSplit.getLocations(),blocks,fileSchema.toString(),requestedSchemaByUser.toString(),fileMetaData.getKeyValueMetaData());
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  TaskAttemptID taskAttemptID=TaskAttemptID.forName(oldJobConf.get(""String_Node_Str""));
  if (taskAttemptID == null) {
    taskAttemptID=new TaskAttemptID();
  }
  final TaskAttemptContext taskContext=new TaskInputOutputContext(oldJobConf,taskAttemptID,null,null,new ReporterWrapper(reporter)){
    @Override public Object getCurrentKey() throws IOException, InterruptedException {
      throw new NotImplementedException();
    }
    @Override public Object getCurrentValue() throws IOException, InterruptedException {
      throw new NotImplementedException();
    }
    @Override public boolean nextKeyValue() throws IOException, InterruptedException {
      throw new NotImplementedException();
    }
  }
;
  try {
    realReader=newInputFormat.createRecordReader(split,taskContext);
    realReader.initialize(split,taskContext);
    if (realReader.nextKeyValue()) {
      firstRecord=true;
      valueObj=realReader.getCurrentValue();
    }
 else {
      eof=true;
    }
  }
 catch (  final InterruptedException e) {
    throw new IOException(e);
  }
}","public RecordReaderWrapper(final ParquetInputFormat<MapWritable> newInputFormat,final InputSplit oldSplit,final JobConf oldJobConf,final Reporter reporter) throws IOException, InterruptedException {
  splitLen=oldSplit.getLength();
  ParquetInputSplit split=null;
  if (oldSplit instanceof InputSplitWrapper) {
    split=((InputSplitWrapper)oldSplit).getRealSplit();
  }
 else   if (oldSplit instanceof FileSplit) {
    final Path finalPath=((FileSplit)oldSplit).getPath();
    final JobConf cloneJob=manageJob.cloneJobAndInit(oldJobConf,finalPath.getParent());
    final ParquetMetadata parquetMetadata=ParquetFileReader.readFooter(cloneJob,finalPath);
    final List<Footer> footers=new ArrayList<Footer>();
    footers.add(new Footer(finalPath,parquetMetadata));
    final List<ParquetInputSplit> splits=newInputFormat.getSplits(cloneJob,footers);
    for (    final ParquetInputSplit newSplit : splits) {
      if (((FileSplit)oldSplit).getStart() == newSplit.getStart() && oldSplit.getLength() == newSplit.getLength()) {
        split=newSplit;
        break;
      }
    }
    if (split == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  TaskAttemptID taskAttemptID=TaskAttemptID.forName(oldJobConf.get(""String_Node_Str""));
  if (taskAttemptID == null) {
    taskAttemptID=new TaskAttemptID();
  }
  final TaskAttemptContext taskContext=new TaskInputOutputContext(oldJobConf,taskAttemptID,null,null,new ReporterWrapper(reporter)){
    @Override public Object getCurrentKey() throws IOException, InterruptedException {
      throw new NotImplementedException();
    }
    @Override public Object getCurrentValue() throws IOException, InterruptedException {
      throw new NotImplementedException();
    }
    @Override public boolean nextKeyValue() throws IOException, InterruptedException {
      throw new NotImplementedException();
    }
  }
;
  try {
    realReader=newInputFormat.createRecordReader(split,taskContext);
    realReader.initialize(split,taskContext);
    if (realReader.nextKeyValue()) {
      firstRecord=true;
      valueObj=realReader.getCurrentValue();
    }
 else {
      eof=true;
    }
  }
 catch (  final InterruptedException e) {
    throw new IOException(e);
  }
}",0.7235481304693715
112061,"private ParquetInputFormat<Tuple> getParquetInputFormat() throws ParserException {
  checkSetLocationHasBeenCalled();
  if (parquetInputFormat == null) {
    parquetInputFormat=inputFormatCache.get(location);
    if (parquetInputFormat == null) {
      parquetInputFormat=new ParquetInputFormat<Tuple>(TupleReadSupport.class){
        @Override public RecordReader<Void,Tuple> createRecordReader(        InputSplit inputSplit,        TaskAttemptContext taskAttemptContext) throws IOException, InterruptedException {
          inputFormatCache.remove(location);
          return super.createRecordReader(inputSplit,taskAttemptContext);
        }
      }
;
      inputFormatCache.put(location,parquetInputFormat);
    }
  }
  return parquetInputFormat;
}","private ParquetInputFormat<Tuple> getParquetInputFormat() throws ParserException {
  checkSetLocationHasBeenCalled();
  if (parquetInputFormat == null) {
    parquetInputFormat=inputFormatCache.get(location);
    if (parquetInputFormat == null) {
      parquetInputFormat=new UnregisteringParquetInputFormat(location);
      inputFormatCache.put(location,parquetInputFormat);
    }
  }
  return parquetInputFormat;
}",0.523972602739726
112062,"protected void checkRead(){
  if (!consumed) {
    return;
  }
  if (isFullyConsumed()) {
    if (DEBUG)     LOG.debug(""String_Node_Str"");
    repetitionLevel=0;
    return;
  }
  if (isPageFullyConsumed()) {
    if (DEBUG)     LOG.debug(""String_Node_Str"");
    Page page=pageReader.readPage();
    this.repetitionLevelColumn=page.getRlEncoding().getValuesReader(path,ValuesType.REPETITION_LEVEL);
    this.definitionLevelColumn=page.getDlEncoding().getValuesReader(path,ValuesType.DEFINITION_LEVEL);
    if (dictionary == null) {
      this.dataColumn=page.getValueEncoding().getValuesReader(path,ValuesType.VALUES);
    }
 else {
      this.dataColumn=page.getValueEncoding().getDictionaryBasedValuesReader(path,ValuesType.VALUES,dictionary);
    }
    if (dictionary != null && converter.hasDictionarySupport()) {
      bindToDictionary(dictionary);
    }
 else {
      bind(path.getType());
    }
    this.pageValueCount=page.getValueCount();
    this.readValuesInPage=0;
    try {
      byte[] bytes=page.getBytes().toByteArray();
      if (DEBUG)       LOG.debug(""String_Node_Str"" + bytes.length + ""String_Node_Str""+ pageValueCount+ ""String_Node_Str"");
      if (DEBUG)       LOG.debug(""String_Node_Str"");
      int next=repetitionLevelColumn.initFromPage(pageValueCount,bytes,0);
      if (DEBUG)       LOG.debug(""String_Node_Str"" + next);
      next=definitionLevelColumn.initFromPage(pageValueCount,bytes,next);
      if (DEBUG)       LOG.debug(""String_Node_Str"" + next);
      dataColumn.initFromPage(pageValueCount,bytes,next);
    }
 catch (    IOException e) {
      throw new ParquetDecodingException(""String_Node_Str"" + page + ""String_Node_Str""+ path,e);
    }
  }
  read();
}","protected void checkRead(){
  if (!consumed) {
    return;
  }
  if (isFullyConsumed()) {
    if (DEBUG)     LOG.debug(""String_Node_Str"");
    repetitionLevel=0;
    return;
  }
  if (isPageFullyConsumed()) {
    if (DEBUG)     LOG.debug(""String_Node_Str"");
    Page page=pageReader.readPage();
    this.repetitionLevelColumn=page.getRlEncoding().getValuesReader(path,ValuesType.REPETITION_LEVEL);
    this.definitionLevelColumn=page.getDlEncoding().getValuesReader(path,ValuesType.DEFINITION_LEVEL);
    if (page.getValueEncoding().usesDictionary()) {
      if (dictionary == null) {
        throw new ParquetDecodingException(""String_Node_Str"" + page + ""String_Node_Str""+ path+ ""String_Node_Str""+ page.getValueEncoding());
      }
      this.dataColumn=page.getValueEncoding().getDictionaryBasedValuesReader(path,ValuesType.VALUES,dictionary);
    }
 else {
      this.dataColumn=page.getValueEncoding().getValuesReader(path,ValuesType.VALUES);
    }
    if (dictionary != null && converter.hasDictionarySupport()) {
      bindToDictionary(dictionary);
    }
 else {
      bind(path.getType());
    }
    this.pageValueCount=page.getValueCount();
    this.readValuesInPage=0;
    try {
      byte[] bytes=page.getBytes().toByteArray();
      if (DEBUG)       LOG.debug(""String_Node_Str"" + bytes.length + ""String_Node_Str""+ pageValueCount+ ""String_Node_Str"");
      if (DEBUG)       LOG.debug(""String_Node_Str"");
      int next=repetitionLevelColumn.initFromPage(pageValueCount,bytes,0);
      if (DEBUG)       LOG.debug(""String_Node_Str"" + next);
      next=definitionLevelColumn.initFromPage(pageValueCount,bytes,next);
      if (DEBUG)       LOG.debug(""String_Node_Str"" + next);
      dataColumn.initFromPage(pageValueCount,bytes,next);
    }
 catch (    IOException e) {
      throw new ParquetDecodingException(""String_Node_Str"" + page + ""String_Node_Str""+ path,e);
    }
  }
  read();
}",0.9291294642857144
112063,"/** 
 * {@inheritDoc}
 * @see parquet.column.ColumnReader#isFullyConsumed()
 */
@Override public boolean isFullyConsumed(){
  return readValues >= totalValueCount;
}","/** 
 * {@inheritDoc}
 * @see parquet.column.ColumnReader#isFullyConsumed()
 */
@Override public boolean isFullyConsumed(){
  return readValues > totalValueCount || (readValues == totalValueCount && consumed);
}",0.7925531914893617
112064,"/** 
 * Factory method for record filter which applies the supplied predicate to the specified column.
 * @param columnPath Dot separated path specifier, e.g. ""engine.capacity""
 * @param predicate Should call getBinary etc. and check the value
 */
public static final UnboundRecordFilter column(final String columnPath,final Predicate<ColumnReader> predicate){
  checkNotNull(columnPath,""String_Node_Str"");
  checkNotNull(predicate,""String_Node_Str"");
  return new UnboundRecordFilter(){
    final String[] filterPath=toArray(Splitter.on('.').split(columnPath),String.class);
    @Override public RecordFilter bind(    Iterable<ColumnReader> readers){
      for (      ColumnReader reader : readers) {
        if (Arrays.equals(reader.getDescriptor().getPath(),filterPath)) {
          return new ColumnRecordFilter(reader,predicate);
        }
      }
      throw new IllegalArgumentException(""String_Node_Str"" + columnPath + ""String_Node_Str"");
    }
  }
;
}","/** 
 * Factory method for record filter which applies the supplied predicate to the specified column. Note that if searching for a repeated sub-attribute it will only ever match against the first instance of it in the object.
 * @param columnPath Dot separated path specifier, e.g. ""engine.capacity""
 * @param predicate Should call getBinary etc. and check the value
 */
public static final UnboundRecordFilter column(final String columnPath,final Predicate<ColumnReader> predicate){
  checkNotNull(columnPath,""String_Node_Str"");
  checkNotNull(predicate,""String_Node_Str"");
  return new UnboundRecordFilter(){
    final String[] filterPath=toArray(Splitter.on('.').split(columnPath),String.class);
    @Override public RecordFilter bind(    Iterable<ColumnReader> readers){
      for (      ColumnReader reader : readers) {
        if (Arrays.equals(reader.getDescriptor().getPath(),filterPath)) {
          return new ColumnRecordFilter(reader,predicate);
        }
      }
      throw new IllegalArgumentException(""String_Node_Str"" + columnPath + ""String_Node_Str"");
    }
  }
;
}",0.9393346379647748
112065,"/** 
 * @param root the root of the schema
 * @param validating
 * @param columnsStore
 * @param unboundFilter Filter records, pass in NULL_FILTER to leave unfiltered.
 */
public RecordReaderImplementation(MessageColumnIO root,RecordMaterializer<T> recordMaterializer,boolean validating,ColumnReadStoreImpl columnStore,UnboundRecordFilter unboundFilter){
  this.recordMaterializer=recordMaterializer;
  this.recordConsumer=recordMaterializer.getRootConverter();
  PrimitiveColumnIO[] leaves=root.getLeaves().toArray(new PrimitiveColumnIO[root.getLeaves().size()]);
  ColumnReader[] columns=new ColumnReader[leaves.length];
  int[][] nextReader=new int[leaves.length][];
  int[][] nextLevel=new int[leaves.length][];
  GroupConverter[][] groupConverterPaths=new GroupConverter[leaves.length][];
  PrimitiveConverter[] primitiveConverters=new PrimitiveConverter[leaves.length];
  int[] firsts=new int[256];
  for (int i=0; i < leaves.length; i++) {
    PrimitiveColumnIO primitiveColumnIO=leaves[i];
    final int[] indexFieldPath=primitiveColumnIO.getIndexFieldPath();
    groupConverterPaths[i]=new GroupConverter[indexFieldPath.length - 1];
    GroupConverter current=this.recordConsumer;
    for (int j=0; j < indexFieldPath.length - 1; j++) {
      current=current.getConverter(indexFieldPath[j]).asGroupConverter();
      groupConverterPaths[i][j]=current;
    }
    primitiveConverters[i]=current.getConverter(indexFieldPath[indexFieldPath.length - 1]).asPrimitiveConverter();
    columns[i]=columnStore.getColumnReader(primitiveColumnIO.getColumnDescriptor());
    int repetitionLevel=primitiveColumnIO.getRepetitionLevel();
    nextReader[i]=new int[repetitionLevel + 1];
    nextLevel[i]=new int[repetitionLevel + 1];
    for (int r=0; r <= repetitionLevel; ++r) {
      if (primitiveColumnIO.isFirst(r)) {
        firsts[r]=i;
      }
      int next;
      if (r == 0) {
        next=i + 1;
      }
 else       if (primitiveColumnIO.isLast(r)) {
        next=firsts[r];
      }
 else {
        next=i + 1;
      }
      if (next == leaves.length) {
        nextLevel[i][r]=0;
      }
 else       if (primitiveColumnIO.isLast(r)) {
        ColumnIO parent=primitiveColumnIO.getParent(r);
        nextLevel[i][r]=parent.getFieldPath().length - 1;
      }
 else {
        nextLevel[i][r]=getCommonParentLevel(primitiveColumnIO.getFieldPath(),leaves[next].getFieldPath());
      }
      if (nextLevel[i][r] > leaves[i].getFieldPath().length - 1) {
        throw new ParquetEncodingException(Arrays.toString(leaves[i].getFieldPath()) + ""String_Node_Str"" + r+ ""String_Node_Str""+ nextLevel[i][r]);
      }
      nextReader[i][r]=next;
    }
  }
  states=new State[leaves.length];
  for (int i=0; i < leaves.length; i++) {
    states[i]=new State(i,leaves[i],columns[i],nextLevel[i],groupConverterPaths[i],primitiveConverters[i]);
    int[] definitionLevelToDepth=new int[states[i].primitiveColumnIO.getDefinitionLevel() + 1];
    final ColumnIO[] path=states[i].primitiveColumnIO.getPath();
    int depth=0;
    for (int d=0; d < definitionLevelToDepth.length; ++d) {
      while (depth < (states[i].fieldPath.length - 1) && d >= path[depth + 1].getDefinitionLevel()) {
        ++depth;
      }
      definitionLevelToDepth[d]=depth - 1;
    }
    states[i].definitionLevelToDepth=definitionLevelToDepth;
  }
  for (int i=0; i < leaves.length; i++) {
    State state=states[i];
    int[] nextStateIds=nextReader[i];
    state.nextState=new State[nextStateIds.length];
    for (int j=0; j < nextStateIds.length; j++) {
      state.nextState[j]=nextStateIds[j] == states.length ? null : states[nextStateIds[j]];
    }
  }
  for (int i=0; i < states.length; i++) {
    State state=states[i];
    final Map<Case,Case> definedCases=new HashMap<Case,Case>();
    final Map<Case,Case> undefinedCases=new HashMap<Case,Case>();
    Case[][][] caseLookup=new Case[state.fieldPath.length][][];
    for (int currentLevel=0; currentLevel < state.fieldPath.length; ++currentLevel) {
      caseLookup[currentLevel]=new Case[state.maxDefinitionLevel + 1][];
      for (int d=0; d <= state.maxDefinitionLevel; ++d) {
        caseLookup[currentLevel][d]=new Case[state.maxRepetitionLevel + 1];
        for (int nextR=0; nextR <= state.maxRepetitionLevel; ++nextR) {
          int caseStartLevel=currentLevel;
          int caseDepth=Math.max(state.getDepth(d),caseStartLevel - 1);
          int caseNextLevel=Math.min(state.nextLevel[nextR],caseDepth + 1);
          Case currentCase=new Case(caseStartLevel,caseDepth,caseNextLevel,getNextReader(state.id,nextR),d == state.maxDefinitionLevel);
          Map<Case,Case> cases=currentCase.isDefined() ? definedCases : undefinedCases;
          if (!cases.containsKey(currentCase)) {
            currentCase.setID(cases.size());
            cases.put(currentCase,currentCase);
          }
 else {
            currentCase=cases.get(currentCase);
          }
          caseLookup[currentLevel][d][nextR]=currentCase;
        }
      }
    }
    state.caseLookup=caseLookup;
    state.definedCases=new ArrayList<Case>(definedCases.values());
    state.undefinedCases=new ArrayList<Case>(undefinedCases.values());
    Comparator<Case> caseComparator=new Comparator<Case>(){
      @Override public int compare(      Case o1,      Case o2){
        return o1.id - o2.id;
      }
    }
;
    Collections.sort(state.definedCases,caseComparator);
    Collections.sort(state.undefinedCases,caseComparator);
  }
  recordFilter=unboundFilter.bind((unboundFilter == RecordFilter.NULL_FILTER) ? null : ImmutableList.copyOf(columns));
}","/** 
 * @param root the root of the schema
 * @param validating
 * @param columnStore
 * @param unboundFilter Filter records, pass in NULL_FILTER to leave unfiltered.
 */
public RecordReaderImplementation(MessageColumnIO root,RecordMaterializer<T> recordMaterializer,boolean validating,ColumnReadStoreImpl columnStore,UnboundRecordFilter unboundFilter){
  this.recordMaterializer=recordMaterializer;
  this.recordConsumer=recordMaterializer.getRootConverter();
  PrimitiveColumnIO[] leaves=root.getLeaves().toArray(new PrimitiveColumnIO[root.getLeaves().size()]);
  ColumnReader[] columns=new ColumnReader[leaves.length];
  int[][] nextReader=new int[leaves.length][];
  int[][] nextLevel=new int[leaves.length][];
  GroupConverter[][] groupConverterPaths=new GroupConverter[leaves.length][];
  PrimitiveConverter[] primitiveConverters=new PrimitiveConverter[leaves.length];
  int[] firsts=new int[256];
  for (int i=0; i < leaves.length; i++) {
    PrimitiveColumnIO primitiveColumnIO=leaves[i];
    final int[] indexFieldPath=primitiveColumnIO.getIndexFieldPath();
    groupConverterPaths[i]=new GroupConverter[indexFieldPath.length - 1];
    GroupConverter current=this.recordConsumer;
    for (int j=0; j < indexFieldPath.length - 1; j++) {
      current=current.getConverter(indexFieldPath[j]).asGroupConverter();
      groupConverterPaths[i][j]=current;
    }
    primitiveConverters[i]=current.getConverter(indexFieldPath[indexFieldPath.length - 1]).asPrimitiveConverter();
    columns[i]=columnStore.getColumnReader(primitiveColumnIO.getColumnDescriptor());
    int repetitionLevel=primitiveColumnIO.getRepetitionLevel();
    nextReader[i]=new int[repetitionLevel + 1];
    nextLevel[i]=new int[repetitionLevel + 1];
    for (int r=0; r <= repetitionLevel; ++r) {
      if (primitiveColumnIO.isFirst(r)) {
        firsts[r]=i;
      }
      int next;
      if (r == 0) {
        next=i + 1;
      }
 else       if (primitiveColumnIO.isLast(r)) {
        next=firsts[r];
      }
 else {
        next=i + 1;
      }
      if (next == leaves.length) {
        nextLevel[i][r]=0;
      }
 else       if (primitiveColumnIO.isLast(r)) {
        ColumnIO parent=primitiveColumnIO.getParent(r);
        nextLevel[i][r]=parent.getFieldPath().length - 1;
      }
 else {
        nextLevel[i][r]=getCommonParentLevel(primitiveColumnIO.getFieldPath(),leaves[next].getFieldPath());
      }
      if (nextLevel[i][r] > leaves[i].getFieldPath().length - 1) {
        throw new ParquetEncodingException(Arrays.toString(leaves[i].getFieldPath()) + ""String_Node_Str"" + r+ ""String_Node_Str""+ nextLevel[i][r]);
      }
      nextReader[i][r]=next;
    }
  }
  states=new State[leaves.length];
  for (int i=0; i < leaves.length; i++) {
    states[i]=new State(i,leaves[i],columns[i],nextLevel[i],groupConverterPaths[i],primitiveConverters[i]);
    int[] definitionLevelToDepth=new int[states[i].primitiveColumnIO.getDefinitionLevel() + 1];
    final ColumnIO[] path=states[i].primitiveColumnIO.getPath();
    int depth=0;
    for (int d=0; d < definitionLevelToDepth.length; ++d) {
      while (depth < (states[i].fieldPath.length - 1) && d >= path[depth + 1].getDefinitionLevel()) {
        ++depth;
      }
      definitionLevelToDepth[d]=depth - 1;
    }
    states[i].definitionLevelToDepth=definitionLevelToDepth;
  }
  for (int i=0; i < leaves.length; i++) {
    State state=states[i];
    int[] nextStateIds=nextReader[i];
    state.nextState=new State[nextStateIds.length];
    for (int j=0; j < nextStateIds.length; j++) {
      state.nextState[j]=nextStateIds[j] == states.length ? null : states[nextStateIds[j]];
    }
  }
  for (int i=0; i < states.length; i++) {
    State state=states[i];
    final Map<Case,Case> definedCases=new HashMap<Case,Case>();
    final Map<Case,Case> undefinedCases=new HashMap<Case,Case>();
    Case[][][] caseLookup=new Case[state.fieldPath.length][][];
    for (int currentLevel=0; currentLevel < state.fieldPath.length; ++currentLevel) {
      caseLookup[currentLevel]=new Case[state.maxDefinitionLevel + 1][];
      for (int d=0; d <= state.maxDefinitionLevel; ++d) {
        caseLookup[currentLevel][d]=new Case[state.maxRepetitionLevel + 1];
        for (int nextR=0; nextR <= state.maxRepetitionLevel; ++nextR) {
          int caseStartLevel=currentLevel;
          int caseDepth=Math.max(state.getDepth(d),caseStartLevel - 1);
          int caseNextLevel=Math.min(state.nextLevel[nextR],caseDepth + 1);
          Case currentCase=new Case(caseStartLevel,caseDepth,caseNextLevel,getNextReader(state.id,nextR),d == state.maxDefinitionLevel);
          Map<Case,Case> cases=currentCase.isDefined() ? definedCases : undefinedCases;
          if (!cases.containsKey(currentCase)) {
            currentCase.setID(cases.size());
            cases.put(currentCase,currentCase);
          }
 else {
            currentCase=cases.get(currentCase);
          }
          caseLookup[currentLevel][d][nextR]=currentCase;
        }
      }
    }
    state.caseLookup=caseLookup;
    state.definedCases=new ArrayList<Case>(definedCases.values());
    state.undefinedCases=new ArrayList<Case>(undefinedCases.values());
    Comparator<Case> caseComparator=new Comparator<Case>(){
      @Override public int compare(      Case o1,      Case o2){
        return o1.id - o2.id;
      }
    }
;
    Collections.sort(state.definedCases,caseComparator);
    Collections.sort(state.undefinedCases,caseComparator);
  }
  recordFilter=unboundFilter.bind((unboundFilter == RecordFilter.NULL_FILTER) ? null : ImmutableList.copyOf(columns));
}",0.999909934252004
112066,"/** 
 * @see parquet.io.RecordReader#read()
 */
@Override public T read(){
  while (!recordFilter.isFullyConsumed()) {
    int currentLevel=0;
    State currentState=states[0];
    boolean materializeRecord=recordFilter.isMatch();
    if (materializeRecord) {
      recordConsumer.start();
    }
    do {
      ColumnReader columnReader=currentState.column;
      int d=columnReader.getCurrentDefinitionLevel();
      if (materializeRecord) {
        int depth=currentState.definitionLevelToDepth[d];
        for (; currentLevel <= depth; ++currentLevel) {
          currentState.groupConverterPath[currentLevel].start();
        }
      }
      if (d >= currentState.maxDefinitionLevel) {
        if (materializeRecord) {
          columnReader.writeCurrentValueToConverter();
        }
 else {
          columnReader.skip();
        }
      }
      columnReader.consume();
      int nextR=currentState.maxRepetitionLevel == 0 ? 0 : columnReader.getCurrentRepetitionLevel();
      int next=currentState.nextLevel[nextR];
      if (materializeRecord) {
        for (; currentLevel > next; currentLevel--) {
          currentState.groupConverterPath[currentLevel - 1].end();
        }
      }
      currentState=currentState.nextState[nextR];
    }
 while (currentState != null);
    if (materializeRecord) {
      recordConsumer.end();
      return recordMaterializer.getCurrentRecord();
    }
  }
  return null;
}","/** 
 * @see parquet.io.RecordReader#read()
 */
@Override public T read(){
  if (!skipToMatch()) {
    return null;
  }
  int currentLevel=0;
  State currentState=states[0];
  recordConsumer.start();
  do {
    ColumnReader columnReader=currentState.column;
    int d=columnReader.getCurrentDefinitionLevel();
    int depth=currentState.definitionLevelToDepth[d];
    for (; currentLevel <= depth; ++currentLevel) {
      currentState.groupConverterPath[currentLevel].start();
    }
    if (d >= currentState.maxDefinitionLevel) {
      columnReader.writeCurrentValueToConverter();
    }
    columnReader.consume();
    int nextR=currentState.maxRepetitionLevel == 0 ? 0 : columnReader.getCurrentRepetitionLevel();
    int next=currentState.nextLevel[nextR];
    for (; currentLevel > next; currentLevel--) {
      currentState.groupConverterPath[currentLevel - 1].end();
    }
    currentState=currentState.nextState[nextR];
  }
 while (currentState != null);
  recordConsumer.end();
  return recordMaterializer.getCurrentRecord();
}",0.5408496732026143
112067,"/** 
 * Not yet working.
 */
@Ignore public void testFilterOnString(){
  MemPageStore memPageStore=new MemPageStore();
  MessageColumnIO columnIO=new ColumnIOFactory(true).getColumnIO(schema);
  writeTestRecords(memPageStore,columnIO,1);
  RecordMaterializer<Group> recordConverter=new GroupRecordConverter(schema);
  RecordReaderImplementation<Group> recordReader=(RecordReaderImplementation<Group>)columnIO.getRecordReader(memPageStore,recordConverter,column(""String_Node_Str"",equalTo(""String_Node_Str"")));
  Group actual2=recordReader.read();
  assertNull(""String_Node_Str"",recordReader.read());
  assertEquals(""String_Node_Str"",r2.toString(),actual2.toString());
}","@Test public void testFilterOnString(){
  MemPageStore memPageStore=new MemPageStore();
  MessageColumnIO columnIO=new ColumnIOFactory(true).getColumnIO(schema);
  writeTestRecords(memPageStore,columnIO,1);
  RecordMaterializer<Group> recordConverter=new GroupRecordConverter(schema);
  RecordReaderImplementation<Group> recordReader=(RecordReaderImplementation<Group>)columnIO.getRecordReader(memPageStore,recordConverter,column(""String_Node_Str"",equalTo(""String_Node_Str"")));
  Group actual1=recordReader.read();
  assertNull(""String_Node_Str"",recordReader.read());
  assertEquals(""String_Node_Str"",r1.toString(),actual1.toString());
  recordReader=(RecordReaderImplementation<Group>)columnIO.getRecordReader(memPageStore,recordConverter,column(""String_Node_Str"",equalTo(""String_Node_Str"")));
  assertNull(""String_Node_Str"",recordReader.read());
  recordReader=(RecordReaderImplementation<Group>)columnIO.getRecordReader(memPageStore,recordConverter,column(""String_Node_Str"",equalTo(""String_Node_Str"")));
  Group actual2=recordReader.read();
  assertNull(""String_Node_Str"",recordReader.read());
  assertEquals(""String_Node_Str"",r2.toString(),actual2.toString());
}",0.6902944383860414
112068,"/** 
 * writes an int using the requested number of bits. accepts only value < 2^bitWidth
 * @param value the value to write
 * @throws IOException
 */
public void writeInt(int value) throws IOException {
  input[inputSize]=value;
  ++inputSize;
  if (inputSize == VALUES_WRITTEN_AT_A_TIME) {
    pack();
    if (packedPosition == SLAB_SIZE) {
      slabs.add(BytesInput.from(packed));
      initPackedSlab();
    }
  }
}","/** 
 * writes an int using the requested number of bits. accepts only value < 2^bitWidth
 * @param value the value to write
 * @throws IOException
 */
public void writeInt(int value) throws IOException {
  input[inputSize]=value;
  ++inputSize;
  if (inputSize == VALUES_WRITTEN_AT_A_TIME) {
    pack();
    if (packedPosition == slabSize) {
      slabs.add(BytesInput.from(packed));
      initPackedSlab();
    }
  }
}",0.9797859690844232
112069,"private void initPackedSlab(){
  packed=new byte[SLAB_SIZE];
  packedPosition=0;
}","private void initPackedSlab(){
  packed=new byte[slabSize];
  packedPosition=0;
}",0.9079754601226994
112070,"/** 
 * @return the bytes representing the packed values
 * @throws IOException
 */
public BytesInput toBytes() throws IOException {
  int packedByteLength=packedPosition + BytesUtils.paddedByteCountFromBits(inputSize * bitWidth);
  if (DEBUG)   LOG.debug(""String_Node_Str"" + (slabs.size() * SLAB_SIZE + packedByteLength) + ""String_Node_Str"");
  if (inputSize > 0) {
    for (int i=inputSize; i < input.length; i++) {
      input[i]=0;
    }
    pack();
  }
  return concat(concat(slabs),BytesInput.from(packed,0,packedByteLength));
}","/** 
 * @return the bytes representing the packed values
 * @throws IOException
 */
public BytesInput toBytes() throws IOException {
  int packedByteLength=packedPosition + BytesUtils.paddedByteCountFromBits(inputSize * bitWidth);
  if (DEBUG)   LOG.debug(""String_Node_Str"" + (slabs.size() * slabSize + packedByteLength) + ""String_Node_Str"");
  if (inputSize > 0) {
    for (int i=inputSize; i < input.length; i++) {
      input[i]=0;
    }
    pack();
  }
  return concat(concat(slabs),BytesInput.from(packed,0,packedByteLength));
}",0.9840674789128396
112071,"/** 
 * @param bitWidth the number of bits used to encode an int
 */
public ByteBasedBitPackingEncoder(int bitWidth,Packer packer){
  this.bitWidth=bitWidth;
  this.inputSize=0;
  initPackedSlab();
  this.packer=packer.newBytePacker(bitWidth);
}","/** 
 * @param bitWidth the number of bits used to encode an int
 */
public ByteBasedBitPackingEncoder(int bitWidth,Packer packer){
  this.bitWidth=bitWidth;
  this.inputSize=0;
  this.slabSize=bitWidth * 64 * 1024;
  initPackedSlab();
  this.packer=packer.newBytePacker(bitWidth);
}",0.928030303030303
112072,"/** 
 * @return total memory allocated
 */
public long getAllocatedSize(){
  return (slabs.size() * SLAB_SIZE) + packed.length + input.length * 4;
}","/** 
 * @return total memory allocated
 */
public long getAllocatedSize(){
  return (slabs.size() * slabSize) + packed.length + input.length * 4;
}",0.9491525423728814
112073,"@Override public BytesInput getBytes(){
  if (!dictionaryTooBig && dict.size() > 0) {
    lastUsedDictionarySize=dict.size();
    lastUsedDictionaryByteSize=dictionaryByteSize;
    int maxDicId=dict.size() - 1;
    if (DEBUG)     LOG.debug(""String_Node_Str"" + maxDicId);
    int bitWidth=BytesUtils.getWidthFromMaxInt(maxDicId);
    final RunLengthBitPackingHybridEncoder encoder=new RunLengthBitPackingHybridEncoder(BytesUtils.getWidthFromMaxInt(maxDicId),64 * 1024);
    IntIterator iterator=out.iterator();
    try {
      while (iterator.hasNext()) {
        encoder.writeInt(iterator.next());
      }
      byte[] bytesHeader=new byte[]{(byte)(bitWidth & 0xFF)};
      BytesInput rleEncodedBytes=encoder.toBytes();
      if (DEBUG)       LOG.debug(""String_Node_Str"" + rleEncodedBytes.size());
      return concat(BytesInput.from(bytesHeader),rleEncodedBytes);
    }
 catch (    IOException e) {
      throw new ParquetEncodingException(""String_Node_Str"",e);
    }
  }
  return plainValuesWriter.getBytes();
}","@Override public BytesInput getBytes(){
  if (!dictionaryTooBig && dict.size() > 0) {
    lastUsedDictionarySize=dict.size();
    lastUsedDictionaryByteSize=dictionaryByteSize;
    int maxDicId=dict.size() - 1;
    if (DEBUG)     LOG.debug(""String_Node_Str"" + maxDicId);
    int bitWidth=BytesUtils.getWidthFromMaxInt(maxDicId);
    final RunLengthBitPackingHybridEncoder encoder=new RunLengthBitPackingHybridEncoder(BytesUtils.getWidthFromMaxInt(maxDicId),64 * 1024);
    IntIterator iterator=out.iterator();
    try {
      while (iterator.hasNext()) {
        encoder.writeInt(iterator.next());
      }
      byte[] bytesHeader=new byte[]{(byte)bitWidth};
      BytesInput rleEncodedBytes=encoder.toBytes();
      if (DEBUG)       LOG.debug(""String_Node_Str"" + rleEncodedBytes.size());
      return concat(BytesInput.from(bytesHeader),rleEncodedBytes);
    }
 catch (    IOException e) {
      throw new ParquetEncodingException(""String_Node_Str"",e);
    }
  }
  return plainValuesWriter.getBytes();
}",0.9955379276152702
112074,"/** 
 * writes an int using the requested number of bits. accepts only value < 2^bitWidth
 * @param value the value to write
 * @throws IOException
 */
public void writeInt(int value) throws IOException {
  input[inputSize]=value;
  ++inputSize;
  if (inputSize == VALUES_WRITTEN_AT_A_TIME) {
    pack();
    if (packedPosition == SLAB_SIZE) {
      slabs.add(BytesInput.from(packed));
      initPackedSlab();
    }
  }
}","/** 
 * writes an int using the requested number of bits. accepts only value < 2^bitWidth
 * @param value the value to write
 * @throws IOException
 */
public void writeInt(int value) throws IOException {
  input[inputSize]=value;
  ++inputSize;
  if (inputSize == VALUES_WRITTEN_AT_A_TIME) {
    pack();
    if (packedPosition == slabSize) {
      slabs.add(BytesInput.from(packed));
      initPackedSlab();
    }
  }
}",0.9797859690844232
112075,"private void initPackedSlab(){
  packed=new byte[SLAB_SIZE];
  packedPosition=0;
}","private void initPackedSlab(){
  packed=new byte[slabSize];
  packedPosition=0;
}",0.9079754601226994
112076,"/** 
 * @return the bytes representing the packed values
 * @throws IOException
 */
public BytesInput toBytes() throws IOException {
  int packedByteLength=packedPosition + BytesUtils.paddedByteCountFromBits(inputSize * bitWidth);
  if (DEBUG)   LOG.debug(""String_Node_Str"" + (slabs.size() * SLAB_SIZE + packedByteLength) + ""String_Node_Str"");
  if (inputSize > 0) {
    for (int i=inputSize; i < input.length; i++) {
      input[i]=0;
    }
    pack();
  }
  return concat(concat(slabs),BytesInput.from(packed,0,packedByteLength));
}","/** 
 * @return the bytes representing the packed values
 * @throws IOException
 */
public BytesInput toBytes() throws IOException {
  int packedByteLength=packedPosition + BytesUtils.paddedByteCountFromBits(inputSize * bitWidth);
  if (DEBUG)   LOG.debug(""String_Node_Str"" + (slabs.size() * slabSize + packedByteLength) + ""String_Node_Str"");
  if (inputSize > 0) {
    for (int i=inputSize; i < input.length; i++) {
      input[i]=0;
    }
    pack();
  }
  return concat(concat(slabs),BytesInput.from(packed,0,packedByteLength));
}",0.9840674789128396
112077,"/** 
 * @param bitWidth the number of bits used to encode an int
 */
public ByteBasedBitPackingEncoder(int bitWidth,Packer packer){
  this.bitWidth=bitWidth;
  this.inputSize=0;
  initPackedSlab();
  this.packer=packer.newBytePacker(bitWidth);
}","/** 
 * @param bitWidth the number of bits used to encode an int
 */
public ByteBasedBitPackingEncoder(int bitWidth,Packer packer){
  this.bitWidth=bitWidth;
  this.inputSize=0;
  this.slabSize=bitWidth * 64 * 1024;
  initPackedSlab();
  this.packer=packer.newBytePacker(bitWidth);
}",0.928030303030303
112078,"/** 
 * @return total memory allocated
 */
public long getAllocatedSize(){
  return (slabs.size() * SLAB_SIZE) + packed.length + input.length * 4;
}","/** 
 * @return total memory allocated
 */
public long getAllocatedSize(){
  return (slabs.size() * slabSize) + packed.length + input.length * 4;
}",0.9491525423728814
112079,"@Override public BytesInput getBytes(){
  if (!dictionaryTooBig && dict.size() > 0) {
    lastUsedDictionarySize=dict.size();
    lastUsedDictionaryByteSize=dictionaryByteSize;
    int maxDicId=dict.size() - 1;
    if (DEBUG)     LOG.debug(""String_Node_Str"" + maxDicId);
    int bitWidth=BytesUtils.getWidthFromMaxInt(maxDicId);
    RLESimpleEncoder rleSimpleEncoder=new RLESimpleEncoder(bitWidth);
    IntIterator iterator=out.iterator();
    try {
      while (iterator.hasNext()) {
        rleSimpleEncoder.writeInt(iterator.next());
      }
      byte[] bytesHeader=new byte[]{(byte)(bitWidth & 0xFF)};
      BytesInput rleEncodedBytes=rleSimpleEncoder.toBytes();
      if (DEBUG)       LOG.debug(""String_Node_Str"" + rleEncodedBytes.size());
      return concat(BytesInput.from(bytesHeader),rleEncodedBytes);
    }
 catch (    IOException e) {
      throw new ParquetEncodingException(""String_Node_Str"",e);
    }
  }
  return plainValuesWriter.getBytes();
}","@Override public BytesInput getBytes(){
  if (!dictionaryTooBig && dict.size() > 0) {
    lastUsedDictionarySize=dict.size();
    lastUsedDictionaryByteSize=dictionaryByteSize;
    int maxDicId=dict.size() - 1;
    if (DEBUG)     LOG.debug(""String_Node_Str"" + maxDicId);
    int bitWidth=BytesUtils.getWidthFromMaxInt(maxDicId);
    RLESimpleEncoder rleSimpleEncoder=new RLESimpleEncoder(bitWidth);
    IntIterator iterator=out.iterator();
    try {
      while (iterator.hasNext()) {
        rleSimpleEncoder.writeInt(iterator.next());
      }
      byte[] bytesHeader=new byte[]{(byte)bitWidth};
      BytesInput rleEncodedBytes=rleSimpleEncoder.toBytes();
      if (DEBUG)       LOG.debug(""String_Node_Str"" + rleEncodedBytes.size());
      return concat(BytesInput.from(bytesHeader),rleEncodedBytes);
    }
 catch (    IOException e) {
      throw new ParquetEncodingException(""String_Node_Str"",e);
    }
  }
  return plainValuesWriter.getBytes();
}",0.9952953476215368
112080,"@Override public void setDictionary(Dictionary dictionary){
  if (this.dict != null) {
    throw new ParquetDecodingException(""String_Node_Str"");
  }
  dict=new String[dictionary.getMaxId() + 1];
  for (int i=0; i <= dictionary.getMaxId(); i++) {
    dict[i]=dictionary.decodeToBinary(i).toStringUsingUTF8();
  }
}","@Override public void setDictionary(Dictionary dictionary){
  dict=new String[dictionary.getMaxId() + 1];
  for (int i=0; i <= dictionary.getMaxId(); i++) {
    dict[i]=dictionary.decodeToBinary(i).toStringUsingUTF8();
  }
}",0.8327137546468402
112081,"@SuppressWarnings(""String_Node_Str"") private void writeValue(Type type,Schema avroSchema,Object value){
  Schema.Type avroType=AvroSchemaConverter.getNonNull(avroSchema).getType();
  if (avroType.equals(Schema.Type.BOOLEAN)) {
    recordConsumer.addBoolean((Boolean)value);
  }
 else   if (avroType.equals(Schema.Type.INT)) {
    recordConsumer.addInteger(((Number)value).intValue());
  }
 else   if (avroType.equals(Schema.Type.LONG)) {
    recordConsumer.addLong(((Number)value).longValue());
  }
 else   if (avroType.equals(Schema.Type.FLOAT)) {
    recordConsumer.addFloat(((Number)value).floatValue());
  }
 else   if (avroType.equals(Schema.Type.DOUBLE)) {
    recordConsumer.addDouble(((Number)value).doubleValue());
  }
 else   if (avroType.equals(Schema.Type.BYTES)) {
    recordConsumer.addBinary(Binary.fromByteBuffer((ByteBuffer)value));
  }
 else   if (avroType.equals(Schema.Type.STRING)) {
    recordConsumer.addBinary(fromAvroString(value));
  }
 else   if (avroType.equals(Schema.Type.RECORD)) {
    writeRecord((GroupType)type,avroSchema,(GenericRecord)value);
  }
 else   if (avroType.equals(Schema.Type.ENUM)) {
    recordConsumer.addBinary(Binary.fromString(value.toString()));
  }
 else   if (avroType.equals(Schema.Type.ARRAY)) {
    writeArray((GroupType)type,avroSchema,(GenericArray<?>)value);
  }
 else   if (avroType.equals(Schema.Type.MAP)) {
    writeMap((GroupType)type,avroSchema,(Map<String,?>)value);
  }
 else   if (avroType.equals(Schema.Type.FIXED)) {
    recordConsumer.addBinary(Binary.fromByteArray(((GenericFixed)value).bytes()));
  }
}","@SuppressWarnings(""String_Node_Str"") private void writeValue(Type type,Schema avroSchema,Object value){
  Schema nonNullAvroSchema=AvroSchemaConverter.getNonNull(avroSchema);
  Schema.Type avroType=nonNullAvroSchema.getType();
  if (avroType.equals(Schema.Type.BOOLEAN)) {
    recordConsumer.addBoolean((Boolean)value);
  }
 else   if (avroType.equals(Schema.Type.INT)) {
    recordConsumer.addInteger(((Number)value).intValue());
  }
 else   if (avroType.equals(Schema.Type.LONG)) {
    recordConsumer.addLong(((Number)value).longValue());
  }
 else   if (avroType.equals(Schema.Type.FLOAT)) {
    recordConsumer.addFloat(((Number)value).floatValue());
  }
 else   if (avroType.equals(Schema.Type.DOUBLE)) {
    recordConsumer.addDouble(((Number)value).doubleValue());
  }
 else   if (avroType.equals(Schema.Type.BYTES)) {
    recordConsumer.addBinary(Binary.fromByteBuffer((ByteBuffer)value));
  }
 else   if (avroType.equals(Schema.Type.STRING)) {
    recordConsumer.addBinary(fromAvroString(value));
  }
 else   if (avroType.equals(Schema.Type.RECORD)) {
    writeRecord((GroupType)type,nonNullAvroSchema,(GenericRecord)value);
  }
 else   if (avroType.equals(Schema.Type.ENUM)) {
    recordConsumer.addBinary(Binary.fromString(value.toString()));
  }
 else   if (avroType.equals(Schema.Type.ARRAY)) {
    writeArray((GroupType)type,nonNullAvroSchema,(GenericArray<?>)value);
  }
 else   if (avroType.equals(Schema.Type.MAP)) {
    writeMap((GroupType)type,nonNullAvroSchema,(Map<String,?>)value);
  }
 else   if (avroType.equals(Schema.Type.FIXED)) {
    recordConsumer.addBinary(Binary.fromByteArray(((GenericFixed)value).bytes()));
  }
}",0.9686432784849426
112082,"@Test public void test() throws Exception {
  Schema schema=new Schema.Parser().parse(Resources.getResource(""String_Node_Str"").openStream());
  File tmp=File.createTempFile(getClass().getSimpleName(),""String_Node_Str"");
  tmp.deleteOnExit();
  tmp.delete();
  Path file=new Path(tmp.getPath());
  AvroParquetWriter<GenericRecord> writer=new AvroParquetWriter<GenericRecord>(file,schema);
  GenericData.Record nestedRecord=new GenericRecordBuilder(schema.getField(""String_Node_Str"").schema()).set(""String_Node_Str"",1).build();
  GenericData.Record record=new GenericRecordBuilder(schema).set(""String_Node_Str"",null).set(""String_Node_Str"",true).set(""String_Node_Str"",1).set(""String_Node_Str"",2L).set(""String_Node_Str"",3.1f).set(""String_Node_Str"",4.1).set(""String_Node_Str"",ByteBuffer.wrap(""String_Node_Str"".getBytes(Charsets.UTF_8))).set(""String_Node_Str"",""String_Node_Str"").set(""String_Node_Str"",nestedRecord).set(""String_Node_Str"",""String_Node_Str"").set(""String_Node_Str"",new GenericData.Array<Integer>(Schema.createArray(Schema.create(Schema.Type.INT)),Arrays.asList(1,2))).set(""String_Node_Str"",ImmutableMap.of(""String_Node_Str"",1,""String_Node_Str"",2)).build();
  writer.write(record);
  writer.close();
  AvroParquetReader<GenericRecord> reader=new AvroParquetReader<GenericRecord>(file);
  GenericRecord nextRecord=reader.read();
  assertNotNull(nextRecord);
  assertEquals(null,nextRecord.get(""String_Node_Str""));
  assertEquals(true,nextRecord.get(""String_Node_Str""));
  assertEquals(1,nextRecord.get(""String_Node_Str""));
  assertEquals(2L,nextRecord.get(""String_Node_Str""));
  assertEquals(3.1f,nextRecord.get(""String_Node_Str""));
  assertEquals(4.1,nextRecord.get(""String_Node_Str""));
  assertEquals(ByteBuffer.wrap(""String_Node_Str"".getBytes(Charsets.UTF_8)),nextRecord.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",nextRecord.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",nextRecord.get(""String_Node_Str""));
  assertEquals(nestedRecord,nextRecord.get(""String_Node_Str""));
  assertEquals(Arrays.asList(1,2),nextRecord.get(""String_Node_Str""));
  assertEquals(ImmutableMap.of(""String_Node_Str"",1,""String_Node_Str"",2),nextRecord.get(""String_Node_Str""));
}","@Test public void test() throws Exception {
  Schema schema=new Schema.Parser().parse(Resources.getResource(""String_Node_Str"").openStream());
  File tmp=File.createTempFile(getClass().getSimpleName(),""String_Node_Str"");
  tmp.deleteOnExit();
  tmp.delete();
  Path file=new Path(tmp.getPath());
  AvroParquetWriter<GenericRecord> writer=new AvroParquetWriter<GenericRecord>(file,schema);
  GenericData.Record nestedRecord=new GenericRecordBuilder(schema.getField(""String_Node_Str"").schema()).set(""String_Node_Str"",1).build();
  List<Integer> integerArray=Arrays.asList(1,2,3);
  GenericData.Array<Integer> genericIntegerArray=new GenericData.Array<Integer>(Schema.createArray(Schema.create(Schema.Type.INT)),integerArray);
  GenericData.Record record=new GenericRecordBuilder(schema).set(""String_Node_Str"",null).set(""String_Node_Str"",true).set(""String_Node_Str"",1).set(""String_Node_Str"",2L).set(""String_Node_Str"",3.1f).set(""String_Node_Str"",4.1).set(""String_Node_Str"",ByteBuffer.wrap(""String_Node_Str"".getBytes(Charsets.UTF_8))).set(""String_Node_Str"",""String_Node_Str"").set(""String_Node_Str"",nestedRecord).set(""String_Node_Str"",""String_Node_Str"").set(""String_Node_Str"",genericIntegerArray).set(""String_Node_Str"",genericIntegerArray).set(""String_Node_Str"",ImmutableMap.of(""String_Node_Str"",1,""String_Node_Str"",2)).build();
  writer.write(record);
  writer.close();
  AvroParquetReader<GenericRecord> reader=new AvroParquetReader<GenericRecord>(file);
  GenericRecord nextRecord=reader.read();
  assertNotNull(nextRecord);
  assertEquals(null,nextRecord.get(""String_Node_Str""));
  assertEquals(true,nextRecord.get(""String_Node_Str""));
  assertEquals(1,nextRecord.get(""String_Node_Str""));
  assertEquals(2L,nextRecord.get(""String_Node_Str""));
  assertEquals(3.1f,nextRecord.get(""String_Node_Str""));
  assertEquals(4.1,nextRecord.get(""String_Node_Str""));
  assertEquals(ByteBuffer.wrap(""String_Node_Str"".getBytes(Charsets.UTF_8)),nextRecord.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",nextRecord.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",nextRecord.get(""String_Node_Str""));
  assertEquals(nestedRecord,nextRecord.get(""String_Node_Str""));
  assertEquals(integerArray,nextRecord.get(""String_Node_Str""));
  assertEquals(integerArray,nextRecord.get(""String_Node_Str""));
  assertEquals(ImmutableMap.of(""String_Node_Str"",1,""String_Node_Str"",2),nextRecord.get(""String_Node_Str""));
}",0.9105974705625818
112083,"public static Binary fromByteBuffer(final ByteBuffer value){
  return new Binary(){
    @Override public String toStringUsingUTF8(){
      return new String(getBytes(),BytesUtils.UTF8);
    }
    @Override public int length(){
      return value.remaining();
    }
    @Override public void writeTo(    OutputStream out) throws IOException {
      out.write(getBytes());
    }
    @Override public byte[] getBytes(){
      byte[] bytes=new byte[value.remaining()];
      value.get(bytes);
      return bytes;
    }
    @Override public int hashCode(){
      if (value.hasArray()) {
        return Binary.hashCode(value.array(),value.arrayOffset() + value.position(),value.arrayOffset() + value.remaining());
      }
      byte[] bytes=getBytes();
      return Binary.hashCode(bytes,0,bytes.length);
    }
    @Override boolean equals(    Binary other){
      if (value.hasArray()) {
        return other.equals(value.array(),value.arrayOffset() + value.position(),value.arrayOffset() + value.remaining());
      }
      byte[] bytes=getBytes();
      return other.equals(bytes,0,bytes.length);
    }
    @Override boolean equals(    byte[] other,    int otherOffset,    int otherLength){
      if (value.hasArray()) {
        return Binary.equals(value.array(),value.arrayOffset() + value.position(),value.arrayOffset() + value.remaining(),other,otherOffset,otherLength);
      }
      byte[] bytes=getBytes();
      return Binary.equals(bytes,0,bytes.length,other,otherOffset,otherLength);
    }
    @Override public ByteBuffer toByteBuffer(){
      return value;
    }
  }
;
}","public static Binary fromByteBuffer(final ByteBuffer value){
  return new Binary(){
    @Override public String toStringUsingUTF8(){
      return new String(getBytes(),BytesUtils.UTF8);
    }
    @Override public int length(){
      return value.remaining();
    }
    @Override public void writeTo(    OutputStream out) throws IOException {
      out.write(getBytes());
    }
    @Override public byte[] getBytes(){
      byte[] bytes=new byte[value.remaining()];
      value.mark();
      value.get(bytes).reset();
      return bytes;
    }
    @Override public int hashCode(){
      if (value.hasArray()) {
        return Binary.hashCode(value.array(),value.arrayOffset() + value.position(),value.arrayOffset() + value.remaining());
      }
      byte[] bytes=getBytes();
      return Binary.hashCode(bytes,0,bytes.length);
    }
    @Override boolean equals(    Binary other){
      if (value.hasArray()) {
        return other.equals(value.array(),value.arrayOffset() + value.position(),value.arrayOffset() + value.remaining());
      }
      byte[] bytes=getBytes();
      return other.equals(bytes,0,bytes.length);
    }
    @Override boolean equals(    byte[] other,    int otherOffset,    int otherLength){
      if (value.hasArray()) {
        return Binary.equals(value.array(),value.arrayOffset() + value.position(),value.arrayOffset() + value.remaining(),other,otherOffset,otherLength);
      }
      byte[] bytes=getBytes();
      return Binary.equals(bytes,0,bytes.length,other,otherOffset,otherLength);
    }
    @Override public ByteBuffer toByteBuffer(){
      return value;
    }
  }
;
}",0.9855527638190956
112084,"/** 
 * @param root the root of the schema
 * @param leaves the leaves of the schema
 * @param validating
 * @param columns2
 */
public RecordReaderImplementation(MessageColumnIO root,RecordMaterializer<T> recordMaterializer,boolean validating,ColumnReadStoreImpl columnStore){
  this.recordMaterializer=recordMaterializer;
  this.recordConsumer=recordMaterializer.getRootConverter();
  PrimitiveColumnIO[] leaves=root.getLeaves().toArray(new PrimitiveColumnIO[root.getLeaves().size()]);
  ColumnReader[] columns=new ColumnReader[leaves.length];
  int[][] nextReader=new int[leaves.length][];
  int[][] nextLevel=new int[leaves.length][];
  GroupConverter[][] groupConverterPaths=new GroupConverter[leaves.length][];
  PrimitiveConverter[] primitiveConverters=new PrimitiveConverter[leaves.length];
  int[] firsts=new int[256];
  for (int i=0; i < leaves.length; i++) {
    PrimitiveColumnIO primitiveColumnIO=leaves[i];
    final int[] indexFieldPath=primitiveColumnIO.getIndexFieldPath();
    groupConverterPaths[i]=new GroupConverter[indexFieldPath.length - 1];
    GroupConverter current=this.recordConsumer;
    for (int j=0; j < indexFieldPath.length - 1; j++) {
      current=current.getConverter(indexFieldPath[j]).asGroupConverter();
      groupConverterPaths[i][j]=current;
    }
    primitiveConverters[i]=current.getConverter(indexFieldPath[indexFieldPath.length - 1]).asPrimitiveConverter();
    columns[i]=columnStore.getColumnReader(primitiveColumnIO.getColumnDescriptor());
    int repetitionLevel=primitiveColumnIO.getRepetitionLevel();
    nextReader[i]=new int[repetitionLevel + 1];
    nextLevel[i]=new int[repetitionLevel + 1];
    for (int r=0; r <= repetitionLevel; ++r) {
      if (primitiveColumnIO.isFirst(r)) {
        firsts[r]=i;
      }
      int next;
      if (r == 0) {
        next=i + 1;
      }
 else       if (primitiveColumnIO.isLast(r)) {
        next=firsts[r];
      }
 else {
        next=i + 1;
      }
      if (next == leaves.length) {
        nextLevel[i][r]=0;
      }
 else       if (primitiveColumnIO.isLast(r)) {
        ColumnIO parent=primitiveColumnIO.getParent(r);
        nextLevel[i][r]=parent.getFieldPath().length - 1;
      }
 else {
        nextLevel[i][r]=getCommonParentLevel(primitiveColumnIO.getFieldPath(),leaves[next].getFieldPath());
      }
      if (nextLevel[i][r] > leaves[i].getFieldPath().length - 1) {
        throw new ParquetEncodingException(Arrays.toString(leaves[i].getFieldPath()) + ""String_Node_Str"" + r+ ""String_Node_Str""+ nextLevel[i][r]);
      }
      nextReader[i][r]=next;
    }
  }
  states=new State[leaves.length];
  for (int i=0; i < leaves.length; i++) {
    states[i]=new State(i,leaves[i],columns[i],nextLevel[i],groupConverterPaths[i],primitiveConverters[i]);
    int[] definitionLevelToDepth=new int[states[i].primitiveColumnIO.getDefinitionLevel() + 1];
    int depth=0;
    for (int d=0; d < definitionLevelToDepth.length; ++d) {
      while (depth < (states[i].fieldPath.length - 1) && d > states[i].primitiveColumnIO.getPath()[depth].getDefinitionLevel()) {
        ++depth;
      }
      definitionLevelToDepth[d]=depth - 1;
    }
    states[i].definitionLevelToDepth=definitionLevelToDepth;
  }
  for (int i=0; i < leaves.length; i++) {
    State state=states[i];
    int[] nextStateIds=nextReader[i];
    state.nextState=new State[nextStateIds.length];
    for (int j=0; j < nextStateIds.length; j++) {
      state.nextState[j]=nextStateIds[j] == states.length ? null : states[nextStateIds[j]];
    }
  }
  for (int i=0; i < states.length; i++) {
    State state=states[i];
    final Map<Case,Case> definedCases=new HashMap<Case,Case>();
    final Map<Case,Case> undefinedCases=new HashMap<Case,Case>();
    Case[][][] caseLookup=new Case[state.fieldPath.length][][];
    for (int currentLevel=0; currentLevel < state.fieldPath.length; ++currentLevel) {
      caseLookup[currentLevel]=new Case[state.maxDefinitionLevel + 1][];
      for (int d=0; d <= state.maxDefinitionLevel; ++d) {
        caseLookup[currentLevel][d]=new Case[state.maxRepetitionLevel + 1];
        for (int nextR=0; nextR <= state.maxRepetitionLevel; ++nextR) {
          int caseStartLevel=currentLevel;
          int caseDepth=Math.max(state.getDepth(d),caseStartLevel - 1);
          int caseNextLevel=Math.min(state.nextLevel[nextR],caseDepth + 1);
          Case currentCase=new Case(caseStartLevel,caseDepth,caseNextLevel,getNextReader(state.id,nextR),d == state.maxDefinitionLevel);
          Map<Case,Case> cases=currentCase.isDefined() ? definedCases : undefinedCases;
          if (!cases.containsKey(currentCase)) {
            currentCase.setID(cases.size());
            cases.put(currentCase,currentCase);
          }
 else {
            currentCase=cases.get(currentCase);
          }
          caseLookup[currentLevel][d][nextR]=currentCase;
        }
      }
    }
    state.caseLookup=caseLookup;
    state.definedCases=new ArrayList<Case>(definedCases.values());
    state.undefinedCases=new ArrayList<Case>(undefinedCases.values());
    Comparator<Case> caseComparator=new Comparator<Case>(){
      @Override public int compare(      Case o1,      Case o2){
        return o1.id - o2.id;
      }
    }
;
    Collections.sort(state.definedCases,caseComparator);
    Collections.sort(state.undefinedCases,caseComparator);
  }
}","/** 
 * @param root the root of the schema
 * @param leaves the leaves of the schema
 * @param validating
 * @param columns2
 */
public RecordReaderImplementation(MessageColumnIO root,RecordMaterializer<T> recordMaterializer,boolean validating,ColumnReadStoreImpl columnStore){
  this.recordMaterializer=recordMaterializer;
  this.recordConsumer=recordMaterializer.getRootConverter();
  PrimitiveColumnIO[] leaves=root.getLeaves().toArray(new PrimitiveColumnIO[root.getLeaves().size()]);
  ColumnReader[] columns=new ColumnReader[leaves.length];
  int[][] nextReader=new int[leaves.length][];
  int[][] nextLevel=new int[leaves.length][];
  GroupConverter[][] groupConverterPaths=new GroupConverter[leaves.length][];
  PrimitiveConverter[] primitiveConverters=new PrimitiveConverter[leaves.length];
  int[] firsts=new int[256];
  for (int i=0; i < leaves.length; i++) {
    PrimitiveColumnIO primitiveColumnIO=leaves[i];
    final int[] indexFieldPath=primitiveColumnIO.getIndexFieldPath();
    groupConverterPaths[i]=new GroupConverter[indexFieldPath.length - 1];
    GroupConverter current=this.recordConsumer;
    for (int j=0; j < indexFieldPath.length - 1; j++) {
      current=current.getConverter(indexFieldPath[j]).asGroupConverter();
      groupConverterPaths[i][j]=current;
    }
    primitiveConverters[i]=current.getConverter(indexFieldPath[indexFieldPath.length - 1]).asPrimitiveConverter();
    columns[i]=columnStore.getColumnReader(primitiveColumnIO.getColumnDescriptor());
    int repetitionLevel=primitiveColumnIO.getRepetitionLevel();
    nextReader[i]=new int[repetitionLevel + 1];
    nextLevel[i]=new int[repetitionLevel + 1];
    for (int r=0; r <= repetitionLevel; ++r) {
      if (primitiveColumnIO.isFirst(r)) {
        firsts[r]=i;
      }
      int next;
      if (r == 0) {
        next=i + 1;
      }
 else       if (primitiveColumnIO.isLast(r)) {
        next=firsts[r];
      }
 else {
        next=i + 1;
      }
      if (next == leaves.length) {
        nextLevel[i][r]=0;
      }
 else       if (primitiveColumnIO.isLast(r)) {
        ColumnIO parent=primitiveColumnIO.getParent(r);
        nextLevel[i][r]=parent.getFieldPath().length - 1;
      }
 else {
        nextLevel[i][r]=getCommonParentLevel(primitiveColumnIO.getFieldPath(),leaves[next].getFieldPath());
      }
      if (nextLevel[i][r] > leaves[i].getFieldPath().length - 1) {
        throw new ParquetEncodingException(Arrays.toString(leaves[i].getFieldPath()) + ""String_Node_Str"" + r+ ""String_Node_Str""+ nextLevel[i][r]);
      }
      nextReader[i][r]=next;
    }
  }
  states=new State[leaves.length];
  for (int i=0; i < leaves.length; i++) {
    states[i]=new State(i,leaves[i],columns[i],nextLevel[i],groupConverterPaths[i],primitiveConverters[i]);
    int[] definitionLevelToDepth=new int[states[i].primitiveColumnIO.getDefinitionLevel() + 1];
    final ColumnIO[] path=states[i].primitiveColumnIO.getPath();
    int depth=0;
    for (int d=0; d < definitionLevelToDepth.length; ++d) {
      while (depth < (states[i].fieldPath.length - 1) && d >= path[depth + 1].getDefinitionLevel()) {
        ++depth;
      }
      definitionLevelToDepth[d]=depth - 1;
    }
    states[i].definitionLevelToDepth=definitionLevelToDepth;
  }
  for (int i=0; i < leaves.length; i++) {
    State state=states[i];
    int[] nextStateIds=nextReader[i];
    state.nextState=new State[nextStateIds.length];
    for (int j=0; j < nextStateIds.length; j++) {
      state.nextState[j]=nextStateIds[j] == states.length ? null : states[nextStateIds[j]];
    }
  }
  for (int i=0; i < states.length; i++) {
    State state=states[i];
    final Map<Case,Case> definedCases=new HashMap<Case,Case>();
    final Map<Case,Case> undefinedCases=new HashMap<Case,Case>();
    Case[][][] caseLookup=new Case[state.fieldPath.length][][];
    for (int currentLevel=0; currentLevel < state.fieldPath.length; ++currentLevel) {
      caseLookup[currentLevel]=new Case[state.maxDefinitionLevel + 1][];
      for (int d=0; d <= state.maxDefinitionLevel; ++d) {
        caseLookup[currentLevel][d]=new Case[state.maxRepetitionLevel + 1];
        for (int nextR=0; nextR <= state.maxRepetitionLevel; ++nextR) {
          int caseStartLevel=currentLevel;
          int caseDepth=Math.max(state.getDepth(d),caseStartLevel - 1);
          int caseNextLevel=Math.min(state.nextLevel[nextR],caseDepth + 1);
          Case currentCase=new Case(caseStartLevel,caseDepth,caseNextLevel,getNextReader(state.id,nextR),d == state.maxDefinitionLevel);
          Map<Case,Case> cases=currentCase.isDefined() ? definedCases : undefinedCases;
          if (!cases.containsKey(currentCase)) {
            currentCase.setID(cases.size());
            cases.put(currentCase,currentCase);
          }
 else {
            currentCase=cases.get(currentCase);
          }
          caseLookup[currentLevel][d][nextR]=currentCase;
        }
      }
    }
    state.caseLookup=caseLookup;
    state.definedCases=new ArrayList<Case>(definedCases.values());
    state.undefinedCases=new ArrayList<Case>(undefinedCases.values());
    Comparator<Case> caseComparator=new Comparator<Case>(){
      @Override public int compare(      Case o1,      Case o2){
        return o1.id - o2.id;
      }
    }
;
    Collections.sort(state.definedCases,caseComparator);
    Collections.sort(state.undefinedCases,caseComparator);
  }
}",0.9882903981264636
112085,"private ByteArrayBytesInput(byte[] in){
  this.in=in;
}","private ByteArrayBytesInput(byte[] in,int offset,int length){
  this.in=in;
  this.offset=offset;
  this.length=length;
}",0.625
112086,"@Override public long size(){
  return in.length;
}","@Override public long size(){
  return length;
}",0.9696969696969696
112087,"@Override public void writeAllTo(OutputStream out) throws IOException {
  out.write(in);
}","@Override public void writeAllTo(OutputStream out) throws IOException {
  out.write(in,offset,length);
}",0.9278350515463918
112088,"@Override public int initFromPage(long valueCount,byte[] page,int offset) throws IOException {
  int effectiveBitLength=(int)valueCount * bitsPerValue;
  int length=effectiveBitLength / 8 + (effectiveBitLength % 8 == 0 ? 0 : 1);
  int intLength=(int)(valueCount + 63) / 64 * bitsPerValue;
  this.encoded=new int[intLength];
  ByteBuffer.wrap(page,offset,(length + 3) / 4).asIntBuffer().get(encoded);
  if (Log.DEBUG)   LOG.debug(""String_Node_Str"" + length + ""String_Node_Str""+ valueCount+ ""String_Node_Str""+ bitsPerValue+ ""String_Node_Str"");
  return offset + length;
}","@Override public int initFromPage(long valueCount,byte[] page,int offset) throws IOException {
  int effectiveBitLength=(int)valueCount * bitsPerValue;
  int length=(effectiveBitLength + 7) / 8;
  int intLength=(int)(valueCount + 63) / 64 * bitsPerValue;
  this.encoded=new int[intLength];
  for (int i=0, j=offset; i < page.length / 4; ++i, j+=4) {
    int ch4=page[j] & 0xff;
    int ch3=page[j + 1] & 0xff;
    int ch2=page[j + 2] & 0xff;
    int ch1=page[j + 3] & 0xff;
    this.encoded[i]=((ch4 << 24) + (ch3 << 16) + (ch2 << 8)+ (ch1 << 0));
  }
  if (page.length % 4 > 0) {
    int ch4=0;
    int ch3=0;
    int ch2=0;
    int ch1=0;
    int j=offset + page.length / 4 * 4;
switch (page.length % 4) {
case 3:
      ch2=page[j + 2] & 0xff;
case 2:
    ch3=page[j + 1] & 0xff;
case 1:
  ch4=page[j + 0] & 0xff;
}
this.encoded[this.encoded.length - 1]=((ch4 << 24) + (ch3 << 16) + (ch2 << 8)+ (ch1 << 0));
}
if (Log.DEBUG) LOG.debug(""String_Node_Str"" + length + ""String_Node_Str""+ valueCount+ ""String_Node_Str""+ bitsPerValue+ ""String_Node_Str"");
return offset + length;
}",0.5535279805352799
112089,"/** 
 * @param bound the maximum value stored by this column
 */
public IntBasedBitPackingValuesReader(int bound){
  this.bitsPerValue=getWidthFromMaxInt(bound);
  packer=LemireBitPackingBE.getPacker(bitsPerValue);
  decode();
}","/** 
 * @param bound the maximum value stored by this column
 */
public IntBasedBitPackingValuesReader(int bound){
  this.bitsPerValue=getWidthFromMaxInt(bound);
  this.packer=LemireBitPackingBE.getPacker(bitsPerValue);
  this.encoded=new int[bitsPerValue];
  decode();
}",0.9138276553106212
112090,"private IntBasedBitPackingValuesWriter(int bitWidth){
  super();
  this.bitWidth=bitWidth;
  this.packer=LemireBitPackingBE.getPacker(bitWidth);
  this.packedArraySize=bitWidth * 100000;
  this.initPacked();
}","public IntBasedBitPackingValuesWriter(int bitWidth){
  super();
  this.bitWidth=bitWidth;
  this.packer=LemireBitPackingBE.getPacker(bitWidth);
  this.packedArraySize=bitWidth * 100000;
  this.initPacked();
}",0.973621103117506
112091,"@Override public void writeInteger(int v){
  inputBuffer[bufferedCount]=v;
  ++bufferedCount;
  if (bufferedCount == 32) {
    packer.pack32Values(inputBuffer,0,packed,packedCount);
    bufferedCount=0;
    packedCount+=bitWidth;
    if (packedCount == packed.length) {
      bytes.add(packed);
      initPacked();
    }
  }
}","@Override public void writeInteger(int v){
  ++totalValues;
  inputBuffer[bufferedCount]=v;
  ++bufferedCount;
  if (bufferedCount == 32) {
    pack();
  }
}",0.5797101449275363
112092,"@Override public BytesInput getBytes(){
  int size=(packedCount + bytes.size() * packedArraySize) * 4;
  final ByteBuffer buffer=ByteBuffer.allocate(size);
  buffer.order(ByteOrder.BIG_ENDIAN);
  final IntBuffer intBuffer=buffer.asIntBuffer();
  for (  int[] array : bytes) {
    intBuffer.put(array);
  }
  intBuffer.put(packed,0,packedCount);
  packedCount=0;
  return BytesInput.from(buffer.array());
}","@Override public BytesInput getBytes(){
  if (bufferedCount > 0) {
    for (int i=bufferedCount; i < inputBuffer.length; i++) {
      inputBuffer[i]=0;
    }
    pack();
  }
  int size=(packedCount + bytes.size() * packedArraySize) * 4;
  final ByteBuffer buffer=ByteBuffer.allocate(size);
  buffer.order(ByteOrder.BIG_ENDIAN);
  final IntBuffer intBuffer=buffer.asIntBuffer();
  for (  int[] array : bytes) {
    intBuffer.put(array);
  }
  intBuffer.put(packed,0,packedCount);
  packedCount=0;
  return BytesInput.from(buffer.array(),0,(totalValues * bitWidth + 7) / 8);
}",0.8273748723186926
112093,"@Test public void testPackUnPack(){
  System.out.println();
  System.out.println(""String_Node_Str"");
  for (int i=1; i < 32; i++) {
    System.out.println(""String_Node_Str"" + i);
    int[] values=new int[32];
    int[] packed=new int[i];
    int[] unpacked=new int[32];
    for (int j=0; j < values.length; j++) {
      values[j]=(int)(Math.random() * 100000) % (int)Math.pow(2,i);
    }
    System.out.println(""String_Node_Str"" + TestBitPacking.toString(values));
{
      final IntPacker packer=LemireBitPackingBE.getPacker(i);
      packer.pack32Values(values,0,packed,0);
      packer.unpack32Values(packed,0,unpacked,0);
      System.out.println(""String_Node_Str"" + TestBitPacking.toString(unpacked));
      Assert.assertArrayEquals(""String_Node_Str"" + i,values,unpacked);
    }
{
      final IntPacker packer=LemireBitPackingLE.getPacker(i);
      packer.pack32Values(values,0,packed,0);
      packer.unpack32Values(packed,0,unpacked,0);
      System.out.println(""String_Node_Str"" + TestBitPacking.toString(unpacked));
      Assert.assertArrayEquals(""String_Node_Str"" + i,values,unpacked);
    }
  }
}","@Test public void testPackUnPack(){
  System.out.println();
  System.out.println(""String_Node_Str"");
  for (int i=1; i < 32; i++) {
    System.out.println(""String_Node_Str"" + i);
    int[] unpacked=new int[32];
    int[] values=generateValues(i);
{
      packUnpack(LemireBitPackingBE.getPacker(i),values,unpacked);
      System.out.println(""String_Node_Str"" + TestBitPacking.toString(unpacked));
      Assert.assertArrayEquals(""String_Node_Str"" + i,values,unpacked);
    }
{
      packUnpack(LemireBitPackingLE.getPacker(i),values,unpacked);
      System.out.println(""String_Node_Str"" + TestBitPacking.toString(unpacked));
      Assert.assertArrayEquals(""String_Node_Str"" + i,values,unpacked);
    }
  }
}",0.6986754966887417
112094,"@Test public void testPackUnPackAgainstHandWritten() throws IOException {
  System.out.println();
  System.out.println(""String_Node_Str"");
  for (int i=1; i < 8; i++) {
    System.out.println(""String_Node_Str"" + i);
    int[] values=new int[32];
    int[] packed=new int[i];
    int[] unpacked=new int[32];
    for (int j=0; j < values.length; j++) {
      values[j]=(int)(Math.random() * 100000) % (int)Math.pow(2,i);
    }
    System.out.println(""String_Node_Str"" + TestBitPacking.toString(values));
    final IntPacker packer=LemireBitPackingBE.getPacker(i);
    packer.pack32Values(values,0,packed,0);
    final ByteArrayOutputStream lemireOut=new ByteArrayOutputStream();
    for (    int v : packed) {
      lemireOut.write((v >>> 24) & 0xFF);
      lemireOut.write((v >>> 16) & 0xFF);
      lemireOut.write((v >>> 8) & 0xFF);
      lemireOut.write((v >>> 0) & 0xFF);
    }
    final byte[] packedByLemireAsBytes=lemireOut.toByteArray();
    System.out.println(""String_Node_Str"" + TestBitPacking.toString(packedByLemireAsBytes));
    final ByteArrayOutputStream manualOut=new ByteArrayOutputStream();
    final BitPackingWriter writer=BitPacking.getBitPackingWriter(i,manualOut);
    for (int j=0; j < values.length; j++) {
      writer.write(values[j]);
    }
    final byte[] packedManualAsBytes=manualOut.toByteArray();
    System.out.println(""String_Node_Str"" + TestBitPacking.toString(packedManualAsBytes));
    final BitPackingReader reader=BitPacking.createBitPackingReader(i,new ByteArrayInputStream(packedByLemireAsBytes),32);
    for (int j=0; j < unpacked.length; j++) {
      unpacked[j]=reader.read();
    }
    System.out.println(""String_Node_Str"" + TestBitPacking.toString(unpacked));
    Assert.assertArrayEquals(""String_Node_Str"" + i,values,unpacked);
  }
}","@Test public void testPackUnPackAgainstHandWritten() throws IOException {
  System.out.println();
  System.out.println(""String_Node_Str"");
  for (int i=1; i < 8; i++) {
    System.out.println(""String_Node_Str"" + i);
    int[] packed=new int[i];
    int[] unpacked=new int[32];
    int[] values=generateValues(i);
    final IntPacker packer=LemireBitPackingBE.getPacker(i);
    packer.pack32Values(values,0,packed,0);
    final ByteArrayOutputStream lemireOut=new ByteArrayOutputStream();
    for (    int v : packed) {
      lemireOut.write((v >>> 24) & 0xFF);
      lemireOut.write((v >>> 16) & 0xFF);
      lemireOut.write((v >>> 8) & 0xFF);
      lemireOut.write((v >>> 0) & 0xFF);
    }
    final byte[] packedByLemireAsBytes=lemireOut.toByteArray();
    System.out.println(""String_Node_Str"" + TestBitPacking.toString(packedByLemireAsBytes));
    final ByteArrayOutputStream manualOut=new ByteArrayOutputStream();
    final BitPackingWriter writer=BitPacking.getBitPackingWriter(i,manualOut);
    for (int j=0; j < values.length; j++) {
      writer.write(values[j]);
    }
    final byte[] packedManualAsBytes=manualOut.toByteArray();
    System.out.println(""String_Node_Str"" + TestBitPacking.toString(packedManualAsBytes));
    final BitPackingReader reader=BitPacking.createBitPackingReader(i,new ByteArrayInputStream(packedByLemireAsBytes),32);
    for (int j=0; j < unpacked.length; j++) {
      unpacked[j]=reader.read();
    }
    System.out.println(""String_Node_Str"" + TestBitPacking.toString(unpacked));
    Assert.assertArrayEquals(""String_Node_Str"" + i,values,unpacked);
  }
}",0.2657964995550281
112095,"/** 
 * Reads all the columns requested from the row group at the current file position.
 * @throws IOException if an error occurs while reading
 * @return the PageReadStore which can provide PageReaders for each column. 
 */
public PageReadStore readNextRowGroup() throws IOException {
  if (currentBlock == blocks.size()) {
    return null;
  }
  BlockMetaData block=blocks.get(currentBlock);
  if (block.getRowCount() == 0) {
    throw new RuntimeException(""String_Node_Str"");
  }
  ColumnChunkPageReadStore columnChunkPageReadStore=new ColumnChunkPageReadStore(block.getRowCount());
  for (  ColumnChunkMetaData mc : block.getColumns()) {
    String pathKey=Arrays.toString(mc.getPath());
    ColumnDescriptor columnDescriptor=paths.get(pathKey);
    if (columnDescriptor != null) {
      List<Page> pagesInChunk=readColumnChunkPages(columnDescriptor,mc);
      BytesDecompressor decompressor=codecFactory.getDecompressor(mc.getCodec());
      ColumnChunkPageReader columnChunkPageReader=new ColumnChunkPageReader(decompressor,pagesInChunk);
      columnChunkPageReadStore.addColumn(columnDescriptor,columnChunkPageReader);
    }
  }
  ++currentBlock;
  return columnChunkPageReadStore;
}","/** 
 * Reads all the columns requested from the row group at the current file position.
 * @throws IOException if an error occurs while reading
 * @return the PageReadStore which can provide PageReaders for each column.
 */
public PageReadStore readNextRowGroup() throws IOException {
  if (currentBlock == blocks.size()) {
    return null;
  }
  BlockMetaData block=blocks.get(currentBlock);
  if (block.getRowCount() == 0) {
    throw new RuntimeException(""String_Node_Str"");
  }
  ColumnChunkPageReadStore columnChunkPageReadStore=new ColumnChunkPageReadStore(block.getRowCount());
  for (  ColumnChunkMetaData mc : block.getColumns()) {
    String pathKey=Arrays.toString(mc.getPath());
    ColumnDescriptor columnDescriptor=paths.get(pathKey);
    if (columnDescriptor != null) {
      List<Page> pagesInChunk=readColumnChunkPages(columnDescriptor,mc);
      BytesDecompressor decompressor=codecFactory.getDecompressor(mc.getCodec());
      ColumnChunkPageReader columnChunkPageReader=new ColumnChunkPageReader(decompressor,pagesInChunk);
      columnChunkPageReadStore.addColumn(columnDescriptor,columnChunkPageReader);
    }
  }
  ++currentBlock;
  return columnChunkPageReadStore;
}",0.9995803608896348
112096,"/** 
 * @param f the Parquet file
 * @param blocks the blocks to read
 * @param colums the columns to read (their path)
 * @param codecClassName the codec used to compress the blocks
 * @throws IOException if the file can not be opened
 */
public ParquetFileReader(Configuration configuration,Path filePath,List<BlockMetaData> blocks,List<ColumnDescriptor> columns) throws IOException {
  FileSystem fs=FileSystem.get(configuration);
  this.filePath=filePath;
  this.f=fs.open(filePath);
  this.blocks=blocks;
  for (  ColumnDescriptor col : columns) {
    paths.put(Arrays.toString(col.getPath()),col);
  }
  this.codecFactory=new CodecFactory(configuration);
}","/** 
 * @param f the Parquet file
 * @param blocks the blocks to read
 * @param colums the columns to read (their path)
 * @param codecClassName the codec used to compress the blocks
 * @throws IOException if the file can not be opened
 */
public ParquetFileReader(Configuration configuration,Path filePath,List<BlockMetaData> blocks,List<ColumnDescriptor> columns) throws IOException {
  this.filePath=filePath;
  FileSystem fs=filePath.getFileSystem(configuration);
  this.f=fs.open(filePath);
  this.blocks=blocks;
  for (  ColumnDescriptor col : columns) {
    paths.put(Arrays.toString(col.getPath()),col);
  }
  this.codecFactory=new CodecFactory(configuration);
}",0.927927927927928
112097,"/** 
 * {@inheritDoc}
 */
@Override public List<InputSplit> getSplits(JobContext jobContext) throws IOException {
  List<InputSplit> splits=new ArrayList<InputSplit>();
  Configuration configuration=jobContext.getConfiguration();
  FileSystem fs=FileSystem.get(configuration);
  List<Footer> footers=getFooters(jobContext);
  for (  Footer footer : footers) {
    LOG.debug(footer.getFile());
    FileStatus fileStatus=fs.getFileStatus(footer.getFile());
    ParquetMetadata parquetMetaData=footer.getParquetMetadata();
    List<BlockMetaData> blocks=parquetMetaData.getBlocks();
    BlockLocation[] fileBlockLocations=fs.getFileBlockLocations(fileStatus,0,fileStatus.getLen());
    splits.addAll(generateSplits(blocks,fileBlockLocations,fileStatus,parquetMetaData.getFileMetaData(),readSupportClass,requestedSchema,parquetMetaData.getKeyValueMetaData()));
  }
  return splits;
}","/** 
 * {@inheritDoc}
 */
@Override public List<InputSplit> getSplits(JobContext jobContext) throws IOException {
  List<InputSplit> splits=new ArrayList<InputSplit>();
  Configuration configuration=jobContext.getConfiguration();
  List<Footer> footers=getFooters(jobContext);
  for (  Footer footer : footers) {
    final Path file=footer.getFile();
    LOG.debug(file);
    FileSystem fs=file.getFileSystem(configuration);
    FileStatus fileStatus=fs.getFileStatus(file);
    ParquetMetadata parquetMetaData=footer.getParquetMetadata();
    List<BlockMetaData> blocks=parquetMetaData.getBlocks();
    BlockLocation[] fileBlockLocations=fs.getFileBlockLocations(fileStatus,0,fileStatus.getLen());
    splits.addAll(generateSplits(blocks,fileBlockLocations,fileStatus,parquetMetaData.getFileMetaData(),readSupportClass,requestedSchema,parquetMetaData.getKeyValueMetaData()));
  }
  return splits;
}",0.8526434195725534
112098,"protected void checkRead(){
  if (!consumed) {
    return;
  }
  if (isFullyConsumed()) {
    if (DEBUG)     LOG.debug(""String_Node_Str"");
    repetitionLevel=0;
    return;
  }
  if (isPageFullyConsumed()) {
    if (DEBUG)     LOG.debug(""String_Node_Str"");
    Page page=pageReader.readPage();
    if (page.getEncoding() != PLAIN) {
      throw new ParquetDecodingException(""String_Node_Str"" + page.getEncoding());
    }
    repetitionLevelColumn=new BitPackingColumnReader(path.getMaxRepetitionLevel());
    definitionLevelColumn=BoundedColumnFactory.getBoundedReader(path.getMaxDefinitionLevel());
switch (path.getType()) {
case BOOLEAN:
      this.dataColumn=new BooleanPlainColumnReader();
default :
    this.dataColumn=new PlainColumnReader();
}
this.pageValueCount=page.getValueCount();
this.readValuesInPage=0;
try {
  byte[] bytes=page.getBytes().toByteArray();
  if (DEBUG)   LOG.debug(""String_Node_Str"" + bytes.length + ""String_Node_Str""+ pageValueCount+ ""String_Node_Str"");
  if (DEBUG)   LOG.debug(""String_Node_Str"");
  int next=repetitionLevelColumn.initFromPage(pageValueCount,bytes,0);
  if (DEBUG)   LOG.debug(""String_Node_Str"" + next);
  next=definitionLevelColumn.initFromPage(pageValueCount,bytes,next);
  if (DEBUG)   LOG.debug(""String_Node_Str"" + next);
  dataColumn.initFromPage(pageValueCount,bytes,next);
}
 catch (IOException e) {
  throw new ParquetDecodingException(""String_Node_Str"" + page + ""String_Node_Str""+ path,e);
}
}
read();
}","protected void checkRead(){
  if (!consumed) {
    return;
  }
  if (isFullyConsumed()) {
    if (DEBUG)     LOG.debug(""String_Node_Str"");
    repetitionLevel=0;
    return;
  }
  if (isPageFullyConsumed()) {
    if (DEBUG)     LOG.debug(""String_Node_Str"");
    Page page=pageReader.readPage();
    if (page.getEncoding() != PLAIN) {
      throw new ParquetDecodingException(""String_Node_Str"" + page.getEncoding());
    }
    repetitionLevelColumn=new BitPackingColumnReader(path.getMaxRepetitionLevel());
    definitionLevelColumn=BoundedColumnFactory.getBoundedReader(path.getMaxDefinitionLevel());
switch (path.getType()) {
case BOOLEAN:
      this.dataColumn=new BooleanPlainColumnReader();
    break;
default :
  this.dataColumn=new PlainColumnReader();
}
this.pageValueCount=page.getValueCount();
this.readValuesInPage=0;
try {
byte[] bytes=page.getBytes().toByteArray();
if (DEBUG) LOG.debug(""String_Node_Str"" + bytes.length + ""String_Node_Str""+ pageValueCount+ ""String_Node_Str"");
if (DEBUG) LOG.debug(""String_Node_Str"");
int next=repetitionLevelColumn.initFromPage(pageValueCount,bytes,0);
if (DEBUG) LOG.debug(""String_Node_Str"" + next);
next=definitionLevelColumn.initFromPage(pageValueCount,bytes,next);
if (DEBUG) LOG.debug(""String_Node_Str"" + next);
dataColumn.initFromPage(pageValueCount,bytes,next);
}
 catch (IOException e) {
throw new ParquetDecodingException(""String_Node_Str"" + page + ""String_Node_Str""+ path,e);
}
}
read();
}",0.9865841073271414
112099,"public MemColumnWriter(ColumnDescriptor path,PageWriter pageWriter,int pageSizeThreshold){
  this.path=path;
  this.pageWriter=pageWriter;
  this.pageSizeThreshold=pageSizeThreshold;
  repetitionLevelColumn=new BitPackingColumnWriter(path.getMaxRepetitionLevel());
  definitionLevelColumn=BoundedColumnFactory.getBoundedWriter(path.getMaxDefinitionLevel());
switch (path.getType()) {
case BOOLEAN:
    this.dataColumn=new BooleanPlainColumnWriter(pageSizeThreshold * 11 / 10);
default :
  this.dataColumn=new PlainColumnWriter(pageSizeThreshold * 11 / 10);
}
}","public MemColumnWriter(ColumnDescriptor path,PageWriter pageWriter,int pageSizeThreshold){
  this.path=path;
  this.pageWriter=pageWriter;
  this.pageSizeThreshold=pageSizeThreshold;
  repetitionLevelColumn=new BitPackingColumnWriter(path.getMaxRepetitionLevel());
  definitionLevelColumn=BoundedColumnFactory.getBoundedWriter(path.getMaxDefinitionLevel());
switch (path.getType()) {
case BOOLEAN:
    this.dataColumn=new BooleanPlainColumnWriter(pageSizeThreshold * 11 / 10);
  break;
default :
this.dataColumn=new PlainColumnWriter(pageSizeThreshold * 11 / 10);
}
}",0.9902395740905058
112100,"/** 
 * @param value the value to encode
 */
public void writeByte(int value){
  throw new UnsupportedOperationException();
}","/** 
 * @param value the value to encode
 */
public void writeByte(int value){
  throw new UnsupportedOperationException(getClass().getName());
}",0.925925925925926
112101,"/** 
 * @param value the value to encode
 */
public void writeLong(long v){
  throw new UnsupportedOperationException();
}","/** 
 * @param value the value to encode
 */
public void writeLong(long v){
  throw new UnsupportedOperationException(getClass().getName());
}",0.9242424242424242
112102,"/** 
 * @param value the value to encode
 */
public void writeBytes(Binary v){
  throw new UnsupportedOperationException();
}","/** 
 * @param value the value to encode
 */
public void writeBytes(Binary v){
  throw new UnsupportedOperationException(getClass().getName());
}",0.925925925925926
112103,"/** 
 * @param value the value to encode
 */
public void writeFloat(float v){
  throw new UnsupportedOperationException();
}","/** 
 * @param value the value to encode
 */
public void writeFloat(float v){
  throw new UnsupportedOperationException(getClass().getName());
}",0.9253731343283582
112104,"/** 
 * @param value the value to encode
 */
public void writeBoolean(boolean v){
  throw new UnsupportedOperationException();
}","/** 
 * @param value the value to encode
 */
public void writeBoolean(boolean v){
  throw new UnsupportedOperationException(getClass().getName());
}",0.927536231884058
112105,"/** 
 * @param value the value to encode
 */
public void writeInteger(int v){
  throw new UnsupportedOperationException();
}","/** 
 * @param value the value to encode
 */
public void writeInteger(int v){
  throw new UnsupportedOperationException(getClass().getName());
}",0.9253731343283582
112106,"/** 
 * @param value the value to encode
 */
public void writeDouble(double v){
  throw new UnsupportedOperationException();
}","/** 
 * @param value the value to encode
 */
public void writeDouble(double v){
  throw new UnsupportedOperationException(getClass().getName());
}",0.9264705882352942
112107,"public static Binary fromByteArray(final byte[] value){
  return new Binary(){
    @Override public String toStringUsingUTF8(){
      return new String(value,BytesUtils.UTF8);
    }
    @Override public int length(){
      return value.length;
    }
    @Override public void writeTo(    OutputStream out) throws IOException {
      out.write(value);
    }
    @Override public byte[] getBytes(){
      return value;
    }
    @Override public int hashCode(){
      return Binary.hashCode(value,0,value.length);
    }
    @Override boolean equals(    Binary other){
      return other.equals(value,0,value.length);
    }
    @Override boolean equals(    byte[] other,    int otherOffset,    int otherLength){
      return equals(value,0,value.length,other,otherOffset,otherLength);
    }
  }
;
}","public static Binary fromByteArray(final byte[] value){
  return new Binary(){
    @Override public String toStringUsingUTF8(){
      return new String(value,BytesUtils.UTF8);
    }
    @Override public int length(){
      return value.length;
    }
    @Override public void writeTo(    OutputStream out) throws IOException {
      out.write(value);
    }
    @Override public byte[] getBytes(){
      return value;
    }
    @Override public int hashCode(){
      return Binary.hashCode(value,0,value.length);
    }
    @Override boolean equals(    Binary other){
      return other.equals(value,0,value.length);
    }
    @Override boolean equals(    byte[] other,    int otherOffset,    int otherLength){
      return equals(value,0,value.length,other,otherOffset,otherLength);
    }
    @Override public ByteBuffer toByteBuffer(){
      return ByteBuffer.wrap(value);
    }
  }
;
}",0.942296252230815
112108,"private void readOneValue(TProtocol in,TProtocol out,byte type) throws TException {
switch (type) {
case TType.LIST:
    readOneList(in,out);
  break;
case TType.MAP:
readOneMap(in,out);
break;
case TType.SET:
readOneSet(in,out);
break;
case TType.STRUCT:
readOneStruct(in,out);
break;
case TType.STOP:
break;
case TType.BOOL:
out.writeBool(in.readBool());
break;
case TType.BYTE:
out.writeBool(in.readBool());
break;
case TType.DOUBLE:
out.writeBool(in.readBool());
break;
case TType.I16:
out.writeI16(in.readI16());
break;
case TType.ENUM:
case TType.I32:
out.writeI32(in.readI32());
break;
case TType.I64:
out.writeI64(in.readI64());
break;
case TType.STRING:
out.writeString(in.readString());
break;
case TType.VOID:
break;
default :
throw new RuntimeException(""String_Node_Str"" + type);
}
}","private void readOneValue(TProtocol in,TProtocol out,byte type) throws TException {
switch (type) {
case TType.LIST:
    readOneList(in,out);
  break;
case TType.MAP:
readOneMap(in,out);
break;
case TType.SET:
readOneSet(in,out);
break;
case TType.STRUCT:
readOneStruct(in,out);
break;
case TType.STOP:
break;
case TType.BOOL:
out.writeBool(in.readBool());
break;
case TType.BYTE:
out.writeByte(in.readByte());
break;
case TType.DOUBLE:
out.writeDouble(in.readDouble());
break;
case TType.I16:
out.writeI16(in.readI16());
break;
case TType.ENUM:
case TType.I32:
out.writeI32(in.readI32());
break;
case TType.I64:
out.writeI64(in.readI64());
break;
case TType.STRING:
out.writeString(in.readString());
break;
case TType.VOID:
break;
default :
throw new RuntimeException(""String_Node_Str"" + type);
}
}",0.972396486825596
112109,"public SetConverter(List<TProtocol> parentEvents,GroupType parquetSchema,ThriftField field){
  super(parentEvents,parquetSchema,((ListType)field.getType()).getValues());
  this.parentEvents=parentEvents;
}","public SetConverter(List<TProtocol> parentEvents,GroupType parquetSchema,ThriftField field){
  super(parentEvents,parquetSchema,((SetType)field.getType()).getValues());
  this.parentEvents=parentEvents;
}",0.9877750611246944
112110,"public FieldPrimitiveConverter(List<TProtocol> events,ThriftField field){
  this.events=events;
}","public FieldPrimitiveConverter(List<TProtocol> events,ThriftField field){
  this.events=events;
  this.type=field.getType().getType();
}",0.8326180257510729
112111,"@Override public void addInt(final int value){
  events.add(new ParquetProtocol(""String_Node_Str""){
    @Override public int readI32() throws TException {
      return value;
    }
  }
);
}","@Override public void addInt(final int value){
switch (type) {
case BYTE:
    events.add(new ParquetProtocol(""String_Node_Str""){
      @Override public byte readByte() throws TException {
        return (byte)value;
      }
    }
);
  break;
case I16:
events.add(new ParquetProtocol(""String_Node_Str""){
  @Override public short readI16() throws TException {
    return (short)value;
  }
}
);
break;
case I32:
events.add(new ParquetProtocol(""String_Node_Str""){
@Override public int readI32() throws TException {
return value;
}
}
);
break;
default :
throw new UnsupportedOperationException(""String_Node_Str"" + type);
}
}",0.3638613861386138
112112,"private <T extends TBase<?,?>>void validate(T expected) throws TException {
  @SuppressWarnings(""String_Node_Str"") final Class<T> thriftClass=(Class<T>)expected.getClass();
  final MemPageStore memPageStore=new MemPageStore();
  final ThriftSchemaConverter schemaConverter=new ThriftSchemaConverter();
  final MessageType schema=schemaConverter.convert(thriftClass);
  final MessageColumnIO columnIO=new ColumnIOFactory().getColumnIO(schema);
  final MemColumnWriteStore columns=new MemColumnWriteStore(memPageStore,10000);
  final RecordConsumer recordWriter=columnIO.getRecordWriter(columns);
  final StructType thriftType=schemaConverter.toStructType(thriftClass);
  ParquetWriteProtocol parquetWriteProtocol=new ParquetWriteProtocol(recordWriter,columnIO,thriftType);
  expected.write(parquetWriteProtocol);
  columns.flush();
  ThriftRecordConverter<T> converter=new TBaseRecordConverter<T>(thriftClass,schema,thriftType);
  final RecordReader<T> recordReader=columnIO.getRecordReader(memPageStore,converter);
  final T result=recordReader.read();
  assertEquals(expected,result);
}","private <T extends TBase<?,?>>void validate(T expected) throws TException {
  @SuppressWarnings(""String_Node_Str"") final Class<T> thriftClass=(Class<T>)expected.getClass();
  final MemPageStore memPageStore=new MemPageStore();
  final ThriftSchemaConverter schemaConverter=new ThriftSchemaConverter();
  final MessageType schema=schemaConverter.convert(thriftClass);
  LOG.info(schema);
  final MessageColumnIO columnIO=new ColumnIOFactory().getColumnIO(schema);
  final MemColumnWriteStore columns=new MemColumnWriteStore(memPageStore,10000);
  final RecordConsumer recordWriter=columnIO.getRecordWriter(columns);
  final StructType thriftType=schemaConverter.toStructType(thriftClass);
  ParquetWriteProtocol parquetWriteProtocol=new ParquetWriteProtocol(recordWriter,columnIO,thriftType);
  expected.write(parquetWriteProtocol);
  columns.flush();
  ThriftRecordConverter<T> converter=new TBaseRecordConverter<T>(thriftClass,schema,thriftType);
  final RecordReader<T> recordReader=columnIO.getRecordReader(memPageStore,converter);
  final T result=recordReader.read();
  assertEquals(expected,result);
}",0.9908842297174112
112113,"/** 
 * give the number of bits needed to encode an int given the max value
 * @param bound max int that we want to encode
 * @return the number of bits required
 */
public static int getWidthFromMaxInt(int bound){
  return (int)Math.ceil(Math.log(bound + 1) / Math.log(2));
}","/** 
 * give the number of bits needed to encode an int given the max value
 * @param bound max int that we want to encode
 * @return the number of bits required
 */
public static int getWidthFromMaxInt(int bound){
  return (int)Math.ceil(Math.log((double)bound + 1) / Math.log(2));
}",0.9857142857142858
112114,"/** 
 * to initialize the column reader The underlying implementation knows how much data to read
 * @param in the array to read from
 * @param offset where to start reading from
 * @return the next offset to read from
 * @throws IOException
 */
public abstract int initFromPage(long valueCount,byte[] in,int offset) throws IOException ;","/** 
 * Called to initialize the column reader with a new page. The underlying implementation knows how much data to read <ul>The page contains the bytes for: <li> repetition levels column <li> definition levels column <li> data column </ul> Each column reader knows how much data to read and returns the next offset for the next column The data column always reads to the end and returns the array size.
 * @param valueCount count of values in this page
 * @param page the array to read from containing the page data (repetition levels, definition levels, data)
 * @param offset where to start reading from in the page
 * @return the offset to read from the next column (the page length in the case of the data column which is last in the page)
 * @throws IOException
 */
public abstract int initFromPage(long valueCount,byte[] page,int offset) throws IOException ;",0.5220282626766417
112115,"public long readLong(){
  throw new UnsupportedOperationException();
}","/** 
 * @return the next boolean from the page
 */
public long readLong(){
  throw new UnsupportedOperationException();
}",0.7329842931937173
112116,"public double readDouble(){
  throw new UnsupportedOperationException();
}","/** 
 * @return the next boolean from the page
 */
public double readDouble(){
  throw new UnsupportedOperationException();
}",0.7437185929648241
112117,"public float readFloat(){
  throw new UnsupportedOperationException();
}","/** 
 * @return the next boolean from the page
 */
public float readFloat(){
  throw new UnsupportedOperationException();
}",0.7384615384615385
112118,"public byte[] readBytes(){
  throw new UnsupportedOperationException();
}","/** 
 * @return the next boolean from the page
 */
public byte[] readBytes(){
  throw new UnsupportedOperationException();
}",0.7411167512690355
112119,"public boolean readBoolean(){
  throw new UnsupportedOperationException();
}","/** 
 * @return the next boolean from the page
 */
public boolean readBoolean(){
  throw new UnsupportedOperationException();
}",0.7487684729064039
112120,"public int readInteger(){
  throw new UnsupportedOperationException();
}","/** 
 * @return the next boolean from the page
 */
public int readInteger(){
  throw new UnsupportedOperationException();
}",0.7384615384615385
112121,"public int readByte(){
  throw new UnsupportedOperationException();
}","/** 
 * @return the next boolean from the page
 */
public int readByte(){
  throw new UnsupportedOperationException();
}",0.7301587301587301
112122,"public Object getCurrentRecord(){
  return a;
}","@Override public Object getCurrentRecord(){
  return a;
}",0.903846153846154
112123,"public GroupRecordConverter(MessageType schema){
  super(null,-1,schema);
  this.simpleGroupFactory=new SimpleGroupFactory(schema);
}","public GroupRecordConverter(MessageType schema){
  this.simpleGroupFactory=new SimpleGroupFactory(schema);
  this.root=new SimpleGroupConverter(null,0,schema){
    @Override public void start(){
      current=simpleGroupFactory.newGroup();
    }
    @Override public void end(){
    }
  }
;
}",0.348235294117647
112124,"@Override public Group getCurrentRecord(){
  return current;
}","public Group getCurrentRecord(){
  return current;
}",0.912280701754386
112125,"SimpleGroupConverter(SimpleGroupConverter parent,int index,GroupType schema){
  this.parent=parent;
  this.index=index;
  groupConverters=new GroupConverter[schema.getFieldCount()];
  primitiveConverters=new PrimitiveConverter[schema.getFieldCount()];
  for (int i=0; i < groupConverters.length; i++) {
    final Type type=schema.getType(i);
    if (type.isPrimitive()) {
      primitiveConverters[i]=new SimplePrimitiveConverter(this,i);
    }
 else {
      groupConverters[i]=new SimpleGroupConverter(this,i,type.asGroupType());
    }
  }
}","SimpleGroupConverter(SimpleGroupConverter parent,int index,GroupType schema){
  this.parent=parent;
  this.index=index;
  converters=new Converter[schema.getFieldCount()];
  for (int i=0; i < converters.length; i++) {
    final Type type=schema.getType(i);
    if (type.isPrimitive()) {
      converters[i]=new SimplePrimitiveConverter(this,i);
    }
 else {
      converters[i]=new SimpleGroupConverter(this,i,type.asGroupType());
    }
  }
}",0.8284263959390863
112126,"public MemColumnReader(ColumnDescriptor path,PageReader pageReader){
  this.path=path;
  this.pageReader=pageReader;
  this.totalValueCount=pageReader.getTotalValueCount();
}","public MemColumnReader(ColumnDescriptor path,PageReader pageReader){
  if (path == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (pageReader == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  this.path=path;
  this.pageReader=pageReader;
  this.totalValueCount=pageReader.getTotalValueCount();
  if (totalValueCount == 0) {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.5790349417637272
112127,"public MemPageReader(int totalValueCount,Iterator<Page> pages){
  super();
  this.totalValueCount=totalValueCount;
  this.pages=pages;
}","public MemPageReader(int totalValueCount,Iterator<Page> pages){
  super();
  if (pages == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  this.totalValueCount=totalValueCount;
  this.pages=pages;
}",0.768361581920904
112128,"@Override public PageReader getPageReader(ColumnDescriptor descriptor){
  MemPageWriter pageWriter=pageWriters.get(descriptor);
  if (pageWriter == null) {
    throw new UnknownColumnException(descriptor);
  }
  List<Page> pages=new ArrayList<Page>(pageWriter.getPages());
  return new MemPageReader(pageWriter.getTotalValueCount(),pages.iterator());
}","@Override public PageReader getPageReader(ColumnDescriptor descriptor){
  MemPageWriter pageWriter=pageWriters.get(descriptor);
  if (pageWriter == null) {
    throw new UnknownColumnException(descriptor);
  }
  List<Page> pages=new ArrayList<Page>(pageWriter.getPages());
  if (Log.DEBUG)   LOG.debug(""String_Node_Str"" + pageWriter.getTotalValueCount() + ""String_Node_Str""+ pages.size()+ ""String_Node_Str"");
  return new MemPageReader(pageWriter.getTotalValueCount(),pages.iterator());
}",0.8380952380952381
112129,"@Override public PageWriter getPageWriter(ColumnDescriptor path){
  MemPageWriter pageWriter;
  if (pageWriters.containsKey(pageWriters)) {
    pageWriter=pageWriters.get(path);
  }
 else {
    pageWriter=new MemPageWriter();
    pageWriters.put(path,pageWriter);
  }
  return pageWriter;
}","@Override public PageWriter getPageWriter(ColumnDescriptor path){
  MemPageWriter pageWriter;
  if (pageWriters.containsKey(path)) {
    pageWriter=pageWriters.get(path);
  }
 else {
    pageWriter=new MemPageWriter();
    pageWriters.put(path,pageWriter);
  }
  return pageWriter;
}",0.9808027923211168
112130,"@Override public void writePage(BytesInput bytesInput,int valueCount){
  memSize+=bytesInput.size();
  pages.add(new Page(BytesInput.copy(bytesInput),valueCount));
  totalValueCount+=valueCount;
  if (DEBUG)   LOG.debug(""String_Node_Str"" + bytesInput.size() + ""String_Node_Str""+ valueCount+ ""String_Node_Str"");
}","@Override public void writePage(BytesInput bytesInput,int valueCount){
  if (valueCount == 0) {
    throw new RuntimeException(""String_Node_Str"");
  }
  memSize+=bytesInput.size();
  pages.add(new Page(BytesInput.copy(bytesInput),valueCount));
  totalValueCount+=valueCount;
  if (DEBUG)   LOG.debug(""String_Node_Str"" + bytesInput.size() + ""String_Node_Str""+ valueCount+ ""String_Node_Str"");
}",0.8863636363636364
112131,"/** 
 * reads all the columns requested in the next block
 * @return the block data for the next block
 * @throws IOException if an error occurs while reading
 * @return how many records where read or 0 if end reached.
 */
public long readColumns(PageConsumer pageConsumer) throws IOException {
  if (currentBlock == blocks.size()) {
    return 0;
  }
  BlockMetaData block=blocks.get(currentBlock);
  LOG.info(""String_Node_Str"" + currentBlock);
  long t0=System.currentTimeMillis();
  for (  ColumnChunkMetaData mc : block.getColumns()) {
    String pathKey=Arrays.toString(mc.getPath());
    if (paths.contains(pathKey)) {
      f.seek(mc.getFirstDataPage());
      if (DEBUG)       LOG.debug(f.getPos() + ""String_Node_Str"" + Arrays.toString(mc.getPath())+ ""String_Node_Str""+ mc.getType()+ ""String_Node_Str""+ mc.getValueCount());
      long valuesCountReadSoFar=0;
      while (valuesCountReadSoFar < mc.getValueCount()) {
        PageHeader pageHeader=readNextDataPageHeader();
        pageConsumer.consumePage(mc.getPath(),pageHeader.data_page.num_values,f,pageHeader.compressed_page_size);
        valuesCountReadSoFar+=pageHeader.data_page.num_values;
      }
    }
  }
  long t1=System.currentTimeMillis();
  LOG.info(""String_Node_Str"" + (t1 - t0) + ""String_Node_Str"");
  ++currentBlock;
  return block.getRowCount();
}","/** 
 * reads all the columns requested in the next block
 * @return the block data for the next block
 * @throws IOException if an error occurs while reading
 * @return how many records where read or 0 if end reached.
 */
public long readColumns(PageConsumer pageConsumer) throws IOException {
  if (currentBlock == blocks.size()) {
    return 0;
  }
  BlockMetaData block=blocks.get(currentBlock);
  if (block.getRowCount() == 0) {
    throw new RuntimeException(""String_Node_Str"");
  }
  LOG.info(""String_Node_Str"" + currentBlock);
  long t0=System.currentTimeMillis();
  for (  ColumnChunkMetaData mc : block.getColumns()) {
    String pathKey=Arrays.toString(mc.getPath());
    if (paths.contains(pathKey)) {
      f.seek(mc.getFirstDataPage());
      if (DEBUG)       LOG.debug(f.getPos() + ""String_Node_Str"" + Arrays.toString(mc.getPath())+ ""String_Node_Str""+ mc.getType()+ ""String_Node_Str""+ mc.getValueCount());
      long valuesCountReadSoFar=0;
      while (valuesCountReadSoFar < mc.getValueCount()) {
        PageHeader pageHeader=readNextDataPageHeader();
        pageConsumer.consumePage(mc.getPath(),pageHeader.data_page.num_values,f,pageHeader.compressed_page_size);
        valuesCountReadSoFar+=pageHeader.data_page.num_values;
      }
    }
  }
  long t1=System.currentTimeMillis();
  LOG.info(""String_Node_Str"" + (t1 - t0) + ""String_Node_Str"");
  ++currentBlock;
  return block.getRowCount();
}",0.9675300985041956
112132,"/** 
 * {@inheritDoc}
 */
@Override public boolean nextKeyValue() throws IOException, InterruptedException {
  checkRead();
  if (current < total) {
    currentValue=recordReader.read();
    current++;
    return true;
  }
  return false;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean nextKeyValue() throws IOException, InterruptedException {
  checkRead();
  if (current < total) {
    currentValue=recordReader.read();
    if (DEBUG)     LOG.debug(""String_Node_Str"" + currentValue);
    current++;
    return true;
  }
  return false;
}",0.8823529411764706
112133,"public void consumePage(String[] path,int valueCount,InputStream is,int pageSize){
  PageWriter pageWriter=memPageStore.getPageWriter(requestedSchema.getColumnDescription(path));
  pageWriter.writePage(BytesInput.from(is,pageSize),valueCount);
}","public void consumePage(String[] path,int valueCount,InputStream is,int pageSize){
  if (DEBUG)   LOG.debug(""String_Node_Str"" + Arrays.toString(path) + ""String_Node_Str""+ valueCount+ ""String_Node_Str""+ pageSize+ ""String_Node_Str"");
  PageWriter pageWriter=memPageStore.getPageWriter(requestedSchema.getColumnDescription(path));
  pageWriter.writePage(BytesInput.from(is,pageSize),valueCount);
}",0.7668231611893583
112134,"private void checkRead() throws IOException {
  if (columnsStore == null || current == total) {
    if (columnsStore != null) {
      long timeAssembling=System.currentTimeMillis() - startedReadingCurrentBlockAt;
      totalTimeSpentProcessingRecords+=timeAssembling;
      LOG.info(""String_Node_Str"" + currentBlockRecordCount + ""String_Node_Str""+ timeAssembling+ ""String_Node_Str""+ ((float)currentBlockRecordCount / timeAssembling)+ ""String_Node_Str"");
      long totalTime=totalTimeSpentProcessingRecords + totalTimeSpentReadingBytes;
      long percentReading=100 * totalTimeSpentReadingBytes / totalTime;
      long percentProcessing=100 * totalTimeSpentProcessingRecords / totalTime;
      LOG.info(""String_Node_Str"" + percentReading + ""String_Node_Str""+ totalTimeSpentReadingBytes+ ""String_Node_Str""+ percentProcessing+ ""String_Node_Str""+ totalTimeSpentProcessingRecords+ ""String_Node_Str"");
    }
    final MemPageStore memPageStore=new MemPageStore();
    columnsStore=new MemColumnsStore(0,memPageStore,8 * 1024);
    LOG.info(""String_Node_Str"");
    long t0=System.currentTimeMillis();
    long count=reader.readColumns(new PageConsumer(){
      public void consumePage(      String[] path,      int valueCount,      InputStream is,      int pageSize){
        PageWriter pageWriter=memPageStore.getPageWriter(requestedSchema.getColumnDescription(path));
        pageWriter.writePage(BytesInput.from(is,pageSize),valueCount);
      }
    }
);
    if (count == 0) {
      return;
    }
    long timeSpentReading=System.currentTimeMillis() - t0;
    totalTimeSpentReadingBytes+=timeSpentReading;
    LOG.info(""String_Node_Str"" + timeSpentReading + ""String_Node_Str"");
    MessageColumnIO columnIO=columnIOFactory.getColumnIO(requestedSchema);
    recordReader=columnIO.getRecordReader(columnsStore,readSupport.newRecordConsumer());
    startedReadingCurrentBlockAt=System.currentTimeMillis();
    currentBlockRecordCount=count;
  }
}","private void checkRead() throws IOException {
  if (columnsStore == null || current == total) {
    if (columnsStore != null) {
      long timeAssembling=System.currentTimeMillis() - startedReadingCurrentBlockAt;
      totalTimeSpentProcessingRecords+=timeAssembling;
      LOG.info(""String_Node_Str"" + currentBlockRecordCount + ""String_Node_Str""+ timeAssembling+ ""String_Node_Str""+ ((float)currentBlockRecordCount / timeAssembling)+ ""String_Node_Str"");
      long totalTime=totalTimeSpentProcessingRecords + totalTimeSpentReadingBytes;
      long percentReading=100 * totalTimeSpentReadingBytes / totalTime;
      long percentProcessing=100 * totalTimeSpentProcessingRecords / totalTime;
      LOG.info(""String_Node_Str"" + percentReading + ""String_Node_Str""+ totalTimeSpentReadingBytes+ ""String_Node_Str""+ percentProcessing+ ""String_Node_Str""+ totalTimeSpentProcessingRecords+ ""String_Node_Str"");
    }
    final MemPageStore memPageStore=new MemPageStore();
    LOG.info(""String_Node_Str"");
    long t0=System.currentTimeMillis();
    long count=reader.readColumns(new PageConsumer(){
      public void consumePage(      String[] path,      int valueCount,      InputStream is,      int pageSize){
        if (DEBUG)         LOG.debug(""String_Node_Str"" + Arrays.toString(path) + ""String_Node_Str""+ valueCount+ ""String_Node_Str""+ pageSize+ ""String_Node_Str"");
        PageWriter pageWriter=memPageStore.getPageWriter(requestedSchema.getColumnDescription(path));
        pageWriter.writePage(BytesInput.from(is,pageSize),valueCount);
      }
    }
);
    if (count == 0) {
      return;
    }
    columnsStore=new MemColumnsStore(0,memPageStore,8 * 1024);
    long timeSpentReading=System.currentTimeMillis() - t0;
    totalTimeSpentReadingBytes+=timeSpentReading;
    LOG.info(""String_Node_Str"" + timeSpentReading + ""String_Node_Str""+ count);
    MessageColumnIO columnIO=columnIOFactory.getColumnIO(requestedSchema);
    recordReader=columnIO.getRecordReader(columnsStore,readSupport.newRecordConsumer());
    startedReadingCurrentBlockAt=System.currentTimeMillis();
    currentBlockRecordCount=count;
  }
}",0.6607407407407407
112135,"@Test public void testStorer() throws ExecException, Exception {
  String out=""String_Node_Str"";
  PigServer pigServer=new PigServer(ExecType.LOCAL);
  Data data=Storage.resetData(pigServer);
  Collection<Tuple> list=new ArrayList<Tuple>();
  for (int i=0; i < 1000; i++) {
    list.add(Storage.tuple(""String_Node_Str"" + i));
  }
  data.set(""String_Node_Str"",""String_Node_Str"",list);
  pigServer.setBatchOn();
  pigServer.registerQuery(""String_Node_Str"");
  pigServer.deleteFile(out);
  pigServer.registerQuery(""String_Node_Str"" + out + ""String_Node_Str""+ RedelmStorer.class.getName()+ ""String_Node_Str"");
  if (pigServer.executeBatch().get(0).getStatus() != JOB_STATUS.COMPLETED) {
    throw new RuntimeException(""String_Node_Str"",pigServer.executeBatch().get(0).getException());
  }
  pigServer.registerQuery(""String_Node_Str"" + out + ""String_Node_Str""+ RedelmLoader.class.getName()+ ""String_Node_Str"");
  pigServer.registerQuery(""String_Node_Str"");
  if (pigServer.executeBatch().get(0).getStatus() != JOB_STATUS.COMPLETED) {
    throw new RuntimeException(""String_Node_Str"",pigServer.executeBatch().get(0).getException());
  }
  List<Tuple> result=data.get(""String_Node_Str"");
  assertEquals(1000,result.size());
  int i=0;
  for (  Tuple tuple : result) {
    assertEquals(""String_Node_Str"" + i,tuple.get(0));
    ++i;
  }
}","@Test public void testStorer() throws ExecException, Exception {
  String out=""String_Node_Str"";
  int rows=10;
  PigServer pigServer=new PigServer(ExecType.LOCAL);
  Data data=Storage.resetData(pigServer);
  Collection<Tuple> list=new ArrayList<Tuple>();
  for (int i=0; i < rows; i++) {
    list.add(Storage.tuple(""String_Node_Str"" + i));
  }
  data.set(""String_Node_Str"",""String_Node_Str"",list);
  pigServer.setBatchOn();
  pigServer.registerQuery(""String_Node_Str"");
  pigServer.deleteFile(out);
  pigServer.registerQuery(""String_Node_Str"" + out + ""String_Node_Str""+ RedelmStorer.class.getName()+ ""String_Node_Str"");
  if (pigServer.executeBatch().get(0).getStatus() != JOB_STATUS.COMPLETED) {
    throw new RuntimeException(""String_Node_Str"",pigServer.executeBatch().get(0).getException());
  }
  pigServer.registerQuery(""String_Node_Str"" + out + ""String_Node_Str""+ RedelmLoader.class.getName()+ ""String_Node_Str"");
  pigServer.registerQuery(""String_Node_Str"");
  if (pigServer.executeBatch().get(0).getStatus() != JOB_STATUS.COMPLETED) {
    throw new RuntimeException(""String_Node_Str"",pigServer.executeBatch().get(0).getException());
  }
  List<Tuple> result=data.get(""String_Node_Str"");
  assertEquals(rows,result.size());
  int i=0;
  for (  Tuple tuple : result) {
    assertEquals(""String_Node_Str"" + i,tuple.get(0));
    ++i;
  }
}",0.9884025439580996
112136,"private void read(){
  if (!(repetitionLevelColumn instanceof DevNullColumnReader)) {
    repetitionLevel=repetitionLevelColumn.readInteger();
  }
  definitionLevel=definitionLevelColumn.readInteger();
  ++readValues;
  consumed=false;
}","private void read(){
  if (!(repetitionLevelColumn instanceof DevNullColumnReader)) {
    repetitionLevel=repetitionLevelColumn.readInteger();
  }
  if (!(definitionLevelColumn instanceof DevNullColumnReader)) {
    definitionLevel=definitionLevelColumn.readInteger();
  }
  ++readValues;
  consumed=false;
}",0.8697247706422019
112137,"private <S extends StatementBuilder<S>>S generateCase(boolean addPrimitive,State state,Case currentCase,S builder){
  if (currentCase.isGoingUp()) {
    for (int i=currentCase.getStartLevel(); i <= currentCase.getDepth(); i++) {
      String field=state.fieldPath[i];
      int index=state.indexFieldPath[i];
      builder=builder.exec().callOnThis(""String_Node_Str"").literal(field).nextParam().literal(index).endCall().endExec();
    }
  }
  if (addPrimitive) {
    String field=state.fieldPath[currentCase.getDepth() + 1];
    int index=state.indexFieldPath[currentCase.getDepth() + 1];
    builder=builder.exec().callOnThis(""String_Node_Str"" + state.primitive.name()).literal(field).nextParam().literal(index).nextParam().get(""String_Node_Str"" + state.id).endCall().endExec();
  }
  if (currentCase.isGoingDown()) {
    for (int i=currentCase.getDepth() + 1; i > currentCase.getNextLevel(); i--) {
      String field=state.fieldPath[i - 1];
      int index=state.indexFieldPath[i - 1];
      builder=builder.exec().callOnThis(""String_Node_Str"").literal(field).nextParam().literal(index).endCall().endExec();
    }
  }
  if (currentCase.isGoingDown()) {
    builder=builder.set(""String_Node_Str"").literal(currentCase.getNextLevel()).endSet();
  }
 else   if (currentCase.isGoingUp()) {
    builder=builder.set(""String_Node_Str"").literal(currentCase.getDepth() + 1).endSet();
  }
 else {
  }
  return builder;
}","private <S extends StatementBuilder<S>>S generateCase(boolean addPrimitive,State state,Case currentCase,S builder){
  if (currentCase.isGoingUp()) {
    for (int i=currentCase.getStartLevel(); i <= currentCase.getDepth(); i++) {
      String field=state.fieldPath[i];
      int index=state.indexFieldPath[i];
      builder=builder.exec().callOnThis(""String_Node_Str"").literal(field).nextParam().literal(index).endCall().endExec();
    }
  }
  if (addPrimitive) {
    builder=builder.exec().callOnThis(""String_Node_Str"" + state.primitive.name()).literal(state.primitiveField).nextParam().literal(state.primitiveFieldIndex).nextParam().get(""String_Node_Str"" + state.id).endCall().endExec();
  }
  if (currentCase.isGoingDown()) {
    for (int i=currentCase.getDepth() + 1; i > currentCase.getNextLevel(); i--) {
      String field=state.fieldPath[i - 1];
      int index=state.indexFieldPath[i - 1];
      builder=builder.exec().callOnThis(""String_Node_Str"").literal(field).nextParam().literal(index).endCall().endExec();
    }
  }
  if (currentCase.isGoingDown()) {
    builder=builder.set(""String_Node_Str"").literal(currentCase.getNextLevel()).endSet();
  }
 else   if (currentCase.isGoingUp()) {
    builder=builder.set(""String_Node_Str"").literal(currentCase.getDepth() + 1).endSet();
  }
 else {
  }
  return builder;
}",0.5342114892060007
112138,"protected void currentLevel(int currentLevel){
  LOG.debug(""String_Node_Str"" + currentLevel);
}","protected void currentLevel(int currentLevel){
  if (DEBUG)   LOG.debug(""String_Node_Str"" + currentLevel);
}",0.9359605911330048
112139,"public <T>RecordReader<T> compile(final RecordReaderImplementation<T> recordReader){
  int stateCount=recordReader.getStateCount();
  String className=""String_Node_Str"" + (++id);
  ClassBuilder classBuilder=startClass(className,existing(BaseRecordReader.class));
  for (int i=0; i < stateCount; i++) {
    classBuilder=classBuilder.field(PUBLIC,existing(ColumnReader.class),""String_Node_Str"" + i + ""String_Node_Str"").field(PUBLIC,existing(PrimitiveColumnIO.class),""String_Node_Str"" + i + ""String_Node_Str"");
  }
  MethodBuilder readMethodBuilder=classBuilder.startMethod(PUBLIC,VOID,""String_Node_Str"").var(INT,""String_Node_Str"").var(INT,""String_Node_Str"").var(INT,""String_Node_Str"").transform(this.<MethodBuilder>debug(""String_Node_Str"")).exec().callOnThisNoParam(""String_Node_Str"").endExec().set(""String_Node_Str"").literal(0).endSet();
  for (int i=0; i < stateCount; i++) {
    final State state=recordReader.getState(i);
    String columnReader=""String_Node_Str"" + i + ""String_Node_Str"";
    readMethodBuilder=readMethodBuilder.label(""String_Node_Str"" + i).transform(this.<MethodBuilder>debug(""String_Node_Str"" + i));
    if (state.maxDefinitionLevel == 0) {
      readMethodBuilder=generateSwitch(readMethodBuilder,true,state);
    }
 else {
      readMethodBuilder=readMethodBuilder.set(""String_Node_Str"").get(columnReader).callNoParam(""String_Node_Str"").endSet().ifExp().get(""String_Node_Str"").isEqualTo().literal(state.maxDefinitionLevel).thenBlock().transform(new Function<ThenBuilder<MethodBuilder>,ThenBuilder<MethodBuilder>>(){
        public ThenBuilder<MethodBuilder> apply(        ThenBuilder<MethodBuilder> builder){
          return generateSwitch(builder,true,state);
        }
      }
).elseBlock().transform(new Function<ElseBuilder<MethodBuilder>,ElseBuilder<MethodBuilder>>(){
        public ElseBuilder<MethodBuilder> apply(        ElseBuilder<MethodBuilder> builder){
          return generateSwitch(builder,false,state);
        }
      }
).endIf();
    }
    if (state.maxRepetitionLevel == 0) {
      int nextReader=recordReader.getNextReader(state.id,0);
      if (nextReader != state.id) {
        String label=nextReader == recordReader.getStateCount() ? ""String_Node_Str"" : ""String_Node_Str"" + nextReader;
        readMethodBuilder=readMethodBuilder.gotoLabel(label);
      }
    }
 else {
      readMethodBuilder=readMethodBuilder.switchOn().get(""String_Node_Str"").switchBlock().transform(new Function<SwitchBuilder<MethodBuilder>,SwitchBuilder<MethodBuilder>>(){
        public SwitchBuilder<MethodBuilder> apply(        SwitchBuilder<MethodBuilder> builder){
          for (int i=0; i <= state.maxRepetitionLevel; i++) {
            int nextReader=recordReader.getNextReader(state.id,i);
            String label=nextReader == recordReader.getStateCount() ? ""String_Node_Str"" : ""String_Node_Str"" + nextReader;
            builder=builder.gotoLabel(i,label);
          }
          return builder;
        }
      }
).defaultCase().exec().callOnThis(""String_Node_Str"").literal(""String_Node_Str"").endCall().endExec().breakCase().endSwitch();
    }
  }
  FutureType testClass=readMethodBuilder.label(""String_Node_Str"").exec().callOnThisNoParam(""String_Node_Str"").endExec().endMethod().endClass();
  cl.define(testClass);
  try {
    Class<?> generated=(Class<?>)cl.loadClass(className);
    BaseRecordReader<T> compiledRecordReader=(BaseRecordReader<T>)generated.getConstructor().newInstance();
    compiledRecordReader.caseLookup=new State[stateCount];
    for (int i=0; i < stateCount; i++) {
      State state=recordReader.getState(i);
      try {
        generated.getField(""String_Node_Str"" + i + ""String_Node_Str"").set(compiledRecordReader,state.column);
        generated.getField(""String_Node_Str"" + i + ""String_Node_Str"").set(compiledRecordReader,state.primitiveColumnIO);
      }
 catch (      NoSuchFieldException e) {
        throw new RuntimeException(""String_Node_Str"" + i,e);
      }
      compiledRecordReader.caseLookup[i]=state;
    }
    compiledRecordReader.recordMaterializer=recordReader.getMaterializer();
    compiledRecordReader.recordConsumer=recordReader.getRecordConsumer();
    return compiledRecordReader;
  }
 catch (  ClassNotFoundException e) {
    throw new RuntimeException(""String_Node_Str"" + className + ""String_Node_Str"",e);
  }
catch (  InstantiationException e) {
    throw new RuntimeException(""String_Node_Str"" + className + ""String_Node_Str"",e);
  }
catch (  IllegalAccessException e) {
    throw new RuntimeException(""String_Node_Str"" + className + ""String_Node_Str"",e);
  }
catch (  IllegalArgumentException e) {
    throw new RuntimeException(""String_Node_Str"" + className + ""String_Node_Str"",e);
  }
catch (  SecurityException e) {
    throw new RuntimeException(""String_Node_Str"" + className + ""String_Node_Str"",e);
  }
catch (  InvocationTargetException e) {
    throw new RuntimeException(""String_Node_Str"" + className + ""String_Node_Str"",e);
  }
catch (  NoSuchMethodException e) {
    throw new RuntimeException(""String_Node_Str"" + className + ""String_Node_Str"",e);
  }
}","public <T>RecordReader<T> compile(final RecordReaderImplementation<T> recordReader){
  int stateCount=recordReader.getStateCount();
  String className=""String_Node_Str"" + (++id);
  ClassBuilder classBuilder=startClass(className,existing(BaseRecordReader.class));
  for (int i=0; i < stateCount; i++) {
    classBuilder=classBuilder.field(PUBLIC,existing(ColumnReader.class),""String_Node_Str"" + i + ""String_Node_Str"");
  }
  MethodBuilder readMethodBuilder=classBuilder.startMethod(PUBLIC,VOID,""String_Node_Str"").var(INT,""String_Node_Str"").var(INT,""String_Node_Str"").var(INT,""String_Node_Str"").transform(this.<MethodBuilder>debug(""String_Node_Str"")).exec().callOnThisNoParam(""String_Node_Str"").endExec().set(""String_Node_Str"").literal(0).endSet();
  for (int i=0; i < stateCount; i++) {
    final State state=recordReader.getState(i);
    String columnReader=""String_Node_Str"" + i + ""String_Node_Str"";
    readMethodBuilder=readMethodBuilder.label(""String_Node_Str"" + i).transform(this.<MethodBuilder>debug(""String_Node_Str"" + i));
    if (state.maxDefinitionLevel == 0) {
      readMethodBuilder=generateSwitch(readMethodBuilder,true,state);
    }
 else {
      readMethodBuilder=readMethodBuilder.set(""String_Node_Str"").get(columnReader).callNoParam(""String_Node_Str"").endSet().ifExp().get(""String_Node_Str"").isEqualTo().literal(state.maxDefinitionLevel).thenBlock().transform(new Function<ThenBuilder<MethodBuilder>,ThenBuilder<MethodBuilder>>(){
        public ThenBuilder<MethodBuilder> apply(        ThenBuilder<MethodBuilder> builder){
          return generateSwitch(builder,true,state);
        }
      }
).elseBlock().transform(new Function<ElseBuilder<MethodBuilder>,ElseBuilder<MethodBuilder>>(){
        public ElseBuilder<MethodBuilder> apply(        ElseBuilder<MethodBuilder> builder){
          return generateSwitch(builder,false,state);
        }
      }
).endIf();
    }
    int firstTransitionNextReader=recordReader.getNextReader(state.id,0);
    boolean allTheSame=true;
    for (int j=0; j <= state.maxRepetitionLevel; j++) {
      if (recordReader.getNextReader(state.id,j) != firstTransitionNextReader) {
        allTheSame=false;
        break;
      }
    }
    if (allTheSame) {
      int nextReader=firstTransitionNextReader;
      if (nextReader != (state.id + 1)) {
        String label=nextReader == recordReader.getStateCount() ? ""String_Node_Str"" : ""String_Node_Str"" + nextReader;
        readMethodBuilder=readMethodBuilder.gotoLabel(label);
      }
    }
 else {
      readMethodBuilder=readMethodBuilder.switchOn().get(""String_Node_Str"").switchBlock().transform(new Function<SwitchBuilder<MethodBuilder>,SwitchBuilder<MethodBuilder>>(){
        public SwitchBuilder<MethodBuilder> apply(        SwitchBuilder<MethodBuilder> builder){
          for (int i=0; i <= state.maxRepetitionLevel; i++) {
            int nextReader=recordReader.getNextReader(state.id,i);
            String label=nextReader == recordReader.getStateCount() ? ""String_Node_Str"" : ""String_Node_Str"" + nextReader;
            builder=builder.gotoLabel(i,label);
          }
          return builder;
        }
      }
).defaultCase().exec().callOnThis(""String_Node_Str"").literal(""String_Node_Str"").endCall().endExec().breakCase().endSwitch();
    }
  }
  FutureType testClass=readMethodBuilder.label(""String_Node_Str"").exec().callOnThisNoParam(""String_Node_Str"").endExec().endMethod().endClass();
  cl.define(testClass);
  try {
    Class<?> generated=(Class<?>)cl.loadClass(className);
    BaseRecordReader<T> compiledRecordReader=(BaseRecordReader<T>)generated.getConstructor().newInstance();
    compiledRecordReader.caseLookup=new State[stateCount];
    for (int i=0; i < stateCount; i++) {
      State state=recordReader.getState(i);
      try {
        generated.getField(""String_Node_Str"" + i + ""String_Node_Str"").set(compiledRecordReader,state.column);
      }
 catch (      NoSuchFieldException e) {
        throw new RuntimeException(""String_Node_Str"" + i,e);
      }
      compiledRecordReader.caseLookup[i]=state;
    }
    compiledRecordReader.recordMaterializer=recordReader.getMaterializer();
    compiledRecordReader.recordConsumer=recordReader.getRecordConsumer();
    return compiledRecordReader;
  }
 catch (  ClassNotFoundException e) {
    throw new RuntimeException(""String_Node_Str"" + className + ""String_Node_Str"",e);
  }
catch (  InstantiationException e) {
    throw new RuntimeException(""String_Node_Str"" + className + ""String_Node_Str"",e);
  }
catch (  IllegalAccessException e) {
    throw new RuntimeException(""String_Node_Str"" + className + ""String_Node_Str"",e);
  }
catch (  IllegalArgumentException e) {
    throw new RuntimeException(""String_Node_Str"" + className + ""String_Node_Str"",e);
  }
catch (  SecurityException e) {
    throw new RuntimeException(""String_Node_Str"" + className + ""String_Node_Str"",e);
  }
catch (  InvocationTargetException e) {
    throw new RuntimeException(""String_Node_Str"" + className + ""String_Node_Str"",e);
  }
catch (  NoSuchMethodException e) {
    throw new RuntimeException(""String_Node_Str"" + className + ""String_Node_Str"",e);
  }
}",0.9393820114150758
112140,"public Class<?> define(FutureType type){
  new TypePrinter().print(type);
  byte[] classBytes=asmTypeGenerator.generate(type);
  return super.defineClass(type.getName(),classBytes,0,classBytes.length);
}","public Class<?> define(FutureType type){
  if (DEBUG)   new TypePrinter().print(type);
  byte[] classBytes=asmTypeGenerator.generate(type);
  return super.defineClass(type.getName(),classBytes,0,classBytes.length);
}",0.9689737470167064
112141,"/** 
 * @param root the root of the schema
 * @param leaves the leaves of the schema
 * @param validating
 * @param columns2
 */
public RecordReaderImplementation(MessageColumnIO root,RecordMaterializer<T> recordMaterializer,boolean validating,ColumnsStore columnStore){
  this.recordMaterializer=recordMaterializer;
  this.recordConsumer=validator(wrap(recordMaterializer),validating,root.getType());
  PrimitiveColumnIO[] leaves=root.getLeaves().toArray(new PrimitiveColumnIO[root.getLeaves().size()]);
  ColumnReader[] columns=new ColumnReader[leaves.length];
  int[][] nextReader=new int[leaves.length][];
  int[][] nextLevel=new int[leaves.length][];
  int[] firsts=new int[256];
  for (int i=0; i < leaves.length; i++) {
    PrimitiveColumnIO primitiveColumnIO=leaves[i];
    columns[i]=columnStore.getColumnReader(primitiveColumnIO.getColumnDescriptor());
    int repetitionLevel=primitiveColumnIO.getRepetitionLevel();
    nextReader[i]=new int[repetitionLevel + 1];
    nextLevel[i]=new int[repetitionLevel + 1];
    for (int r=0; r <= repetitionLevel; ++r) {
      if (primitiveColumnIO.isFirst(r)) {
        firsts[r]=i;
      }
      int next;
      if (r == 0) {
        next=i + 1;
      }
 else       if (primitiveColumnIO.isLast(r)) {
        next=firsts[r];
      }
 else {
        next=i + 1;
      }
      if (next == leaves.length) {
        nextLevel[i][r]=0;
      }
 else       if (primitiveColumnIO.isLast(r)) {
        ColumnIO parent=primitiveColumnIO.getParent(r);
        nextLevel[i][r]=parent.getFieldPath().length - 1;
      }
 else {
        nextLevel[i][r]=getCommonParentLevel(primitiveColumnIO.getFieldPath(),leaves[next].getFieldPath());
      }
      if (nextLevel[i][r] > leaves[i].getFieldPath().length - 1) {
        throw new RuntimeException(Arrays.toString(leaves[i].getFieldPath()) + ""String_Node_Str"" + r+ ""String_Node_Str""+ nextLevel[i][r]);
      }
      nextReader[i][r]=next;
    }
  }
  states=new State[leaves.length];
  for (int i=0; i < leaves.length; i++) {
    states[i]=new State(i,leaves[i],columns[i],nextLevel[i]);
    int[] definitionLevelToDepth=new int[states[i].primitiveColumnIO.getDefinitionLevel() + 1];
    int depth=0;
    for (int d=0; d < definitionLevelToDepth.length; ++d) {
      while (depth < (states[i].fieldPath.length - 1) && d > states[i].primitiveColumnIO.getPath()[depth].getDefinitionLevel()) {
        ++depth;
      }
      definitionLevelToDepth[d]=depth - 1;
    }
    states[i].definitionLevelToDepth=definitionLevelToDepth;
  }
  for (int i=0; i < leaves.length; i++) {
    State state=states[i];
    int[] nextStateIds=nextReader[i];
    state.nextState=new State[nextStateIds.length];
    for (int j=0; j < nextStateIds.length; j++) {
      state.nextState[j]=nextStateIds[j] == states.length ? null : states[nextStateIds[j]];
    }
  }
  for (int i=0; i < states.length; i++) {
    State state=states[i];
    final Map<Case,Case> cases=new HashMap<Case,Case>();
    int nextCaseID=0;
    Case[][][] caseLookup=new Case[state.fieldPath.length][][];
    for (int currentLevel=0; currentLevel < state.fieldPath.length; ++currentLevel) {
      caseLookup[currentLevel]=new Case[state.maxDefinitionLevel + 1][];
      for (int d=0; d <= state.maxDefinitionLevel; ++d) {
        caseLookup[currentLevel][d]=new Case[state.maxRepetitionLevel + 1];
        for (int nextR=0; nextR <= state.maxRepetitionLevel; ++nextR) {
          int caseStartLevel=currentLevel;
          int caseDepth=Math.max(state.getDepth(d),caseStartLevel - 1);
          int caseNextLevel=Math.min(state.nextLevel[nextR],caseDepth + 1);
          Case currentCase=new Case(caseStartLevel,caseDepth,caseNextLevel);
          if (!cases.containsKey(currentCase)) {
            currentCase.setID(++nextCaseID);
            cases.put(currentCase,currentCase);
          }
 else {
            currentCase=cases.get(currentCase);
          }
          caseLookup[currentLevel][d][nextR]=currentCase;
        }
      }
    }
    state.caseLookup=caseLookup;
    state.cases=cases.values();
  }
}","/** 
 * @param root the root of the schema
 * @param leaves the leaves of the schema
 * @param validating
 * @param columns2
 */
public RecordReaderImplementation(MessageColumnIO root,RecordMaterializer<T> recordMaterializer,boolean validating,ColumnsStore columnStore){
  this.recordMaterializer=recordMaterializer;
  this.recordConsumer=validator(wrap(recordMaterializer),validating,root.getType());
  PrimitiveColumnIO[] leaves=root.getLeaves().toArray(new PrimitiveColumnIO[root.getLeaves().size()]);
  ColumnReader[] columns=new ColumnReader[leaves.length];
  int[][] nextReader=new int[leaves.length][];
  int[][] nextLevel=new int[leaves.length][];
  int[] firsts=new int[256];
  for (int i=0; i < leaves.length; i++) {
    PrimitiveColumnIO primitiveColumnIO=leaves[i];
    columns[i]=columnStore.getColumnReader(primitiveColumnIO.getColumnDescriptor());
    int repetitionLevel=primitiveColumnIO.getRepetitionLevel();
    nextReader[i]=new int[repetitionLevel + 1];
    nextLevel[i]=new int[repetitionLevel + 1];
    for (int r=0; r <= repetitionLevel; ++r) {
      if (primitiveColumnIO.isFirst(r)) {
        firsts[r]=i;
      }
      int next;
      if (r == 0) {
        next=i + 1;
      }
 else       if (primitiveColumnIO.isLast(r)) {
        next=firsts[r];
      }
 else {
        next=i + 1;
      }
      if (next == leaves.length) {
        nextLevel[i][r]=0;
      }
 else       if (primitiveColumnIO.isLast(r)) {
        ColumnIO parent=primitiveColumnIO.getParent(r);
        nextLevel[i][r]=parent.getFieldPath().length - 1;
      }
 else {
        nextLevel[i][r]=getCommonParentLevel(primitiveColumnIO.getFieldPath(),leaves[next].getFieldPath());
      }
      if (nextLevel[i][r] > leaves[i].getFieldPath().length - 1) {
        throw new RuntimeException(Arrays.toString(leaves[i].getFieldPath()) + ""String_Node_Str"" + r+ ""String_Node_Str""+ nextLevel[i][r]);
      }
      nextReader[i][r]=next;
    }
  }
  states=new State[leaves.length];
  for (int i=0; i < leaves.length; i++) {
    states[i]=new State(i,leaves[i],columns[i],nextLevel[i]);
    int[] definitionLevelToDepth=new int[states[i].primitiveColumnIO.getDefinitionLevel() + 1];
    int depth=0;
    for (int d=0; d < definitionLevelToDepth.length; ++d) {
      while (depth < (states[i].fieldPath.length - 1) && d > states[i].primitiveColumnIO.getPath()[depth].getDefinitionLevel()) {
        ++depth;
      }
      definitionLevelToDepth[d]=depth - 1;
    }
    states[i].definitionLevelToDepth=definitionLevelToDepth;
  }
  for (int i=0; i < leaves.length; i++) {
    State state=states[i];
    int[] nextStateIds=nextReader[i];
    state.nextState=new State[nextStateIds.length];
    for (int j=0; j < nextStateIds.length; j++) {
      state.nextState[j]=nextStateIds[j] == states.length ? null : states[nextStateIds[j]];
    }
  }
  for (int i=0; i < states.length; i++) {
    State state=states[i];
    final Map<Case,Case> cases=new HashMap<Case,Case>();
    int nextCaseID=0;
    Case[][][] caseLookup=new Case[state.fieldPath.length][][];
    for (int currentLevel=0; currentLevel < state.fieldPath.length; ++currentLevel) {
      caseLookup[currentLevel]=new Case[state.maxDefinitionLevel + 1][];
      for (int d=0; d <= state.maxDefinitionLevel; ++d) {
        caseLookup[currentLevel][d]=new Case[state.maxRepetitionLevel + 1];
        for (int nextR=0; nextR <= state.maxRepetitionLevel; ++nextR) {
          int caseStartLevel=currentLevel;
          int caseDepth=Math.max(state.getDepth(d),caseStartLevel - 1);
          int caseNextLevel=Math.min(state.nextLevel[nextR],caseDepth + 1);
          Case currentCase=new Case(caseStartLevel,caseDepth,caseNextLevel);
          if (!cases.containsKey(currentCase)) {
            currentCase.setID(nextCaseID++);
            cases.put(currentCase,currentCase);
          }
 else {
            currentCase=cases.get(currentCase);
          }
          caseLookup[currentLevel][d][nextR]=currentCase;
        }
      }
    }
    state.caseLookup=caseLookup;
    state.cases=new ArrayList<Case>(cases.values());
    Collections.sort(state.cases,new Comparator<Case>(){
      @Override public int compare(      Case o1,      Case o2){
        return o1.id - o2.id;
      }
    }
);
  }
}",0.9120985269258634
112142,"public Collection<Case> getCases(){
  return cases;
}","public List<Case> getCases(){
  return cases;
}",0.88
112143,"private static void read(RecordReader<Object> recordReader,int count,MessageType schema){
  long t0=System.currentTimeMillis();
  Object[] records=new Object[count];
  recordReader.read(records,count);
  long t1=System.currentTimeMillis();
  long t=t1 - t0;
  float err=(float)100 * 2 / t;
  System.out.printf(""String_Node_Str"",count,t,t == 0 ? 0 : count * 1000 / t,err);
  System.out.println(records[0]);
}","private static void read(RecordReader<Object> recordReader,int count,MessageType schema){
  long t0=System.currentTimeMillis();
  Object[] records=new Object[count];
  recordReader.read(records,count);
  long t1=System.currentTimeMillis();
  long t=t1 - t0;
  float err=(float)100 * 2 / t;
  System.out.printf(""String_Node_Str"",count,t,t == 0 ? 0 : count * 1000 / t,err);
  if (!records[0].equals(""String_Node_Str"")) {
    throw new RuntimeException();
  }
}",0.869364161849711
112144,"public static void main(String[] args){
  MemColumnsStore columns=new MemColumnsStore(50 * 1024 * 1024,schema);
  write(columns);
  columns.flip();
  read(columns);
  System.out.println(columns.memSize() + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + columns.maxColMemSize() + ""String_Node_Str"");
}","public static void main(String[] args){
  MemColumnsStore columns=new MemColumnsStore(50 * 1024 * 1024,schema);
  write(columns);
  read(columns);
  System.out.println(columns.memSize() + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + columns.maxColMemSize() + ""String_Node_Str"");
}",0.9704918032786886
112145,"@Override public String readString(){
  try {
    int size=in.readInt();
    byte[] bytes=new byte[size];
    int i=0;
    do {
      int n=in.read(bytes,i,bytes.length - i);
      if (n == -1) {
        throw new RuntimeException(""String_Node_Str"");
      }
      i=i + n;
    }
 while (i < bytes.length);
    return new String(bytes,CHARSET);
  }
 catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","@Override public String readString(){
  try {
    int size=in.readInt();
    if (size == 0) {
      return ""String_Node_Str"";
    }
 else {
      byte[] bytes=new byte[size];
      int i=0;
      do {
        int n=in.read(bytes,i,bytes.length - i);
        if (n == -1) {
          throw new RuntimeException(""String_Node_Str"");
        }
        i=i + n;
      }
 while (i < bytes.length);
      return new String(bytes,CHARSET);
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}",0.8886576482830385
112146,"public RecordConsumer getRecordWriter(){
  return new RecordConsumer(){
    ColumnIO currentColumnIO;
    int currentLevel=0;
    int[] currentIndex=new int[16];
    int[] r=new int[16];
    public void printState(){
      log(currentLevel + ""String_Node_Str"" + currentIndex[currentLevel]+ ""String_Node_Str""+ Arrays.toString(currentColumnIO.getFieldPath())+ ""String_Node_Str""+ r[currentLevel]);
      if (r[currentLevel] > currentColumnIO.getRepetitionLevel()) {
        throw new RuntimeException(r[currentLevel] + ""String_Node_Str"" + currentColumnIO.getRepetitionLevel()+ ""String_Node_Str"");
      }
    }
    private void log(    Object m){
      String indent=""String_Node_Str"";
      for (int i=0; i < currentLevel; ++i) {
        indent+=""String_Node_Str"";
      }
      logger.debug(indent + m);
    }
    @Override public void startMessage(){
      if (DEBUG)       log(""String_Node_Str"");
      currentColumnIO=MessageColumnIO.this;
      r[0]=0;
      currentIndex[0]=0;
      if (DEBUG)       printState();
    }
    @Override public void endMessage(){
      if (DEBUG)       log(""String_Node_Str"");
      if (DEBUG)       printState();
    }
    @Override public void startField(    String field,    int index){
      try {
        if (DEBUG)         log(""String_Node_Str"" + field + ""String_Node_Str""+ index+ ""String_Node_Str"");
        writeNullForMissingFields(index - 1);
        currentColumnIO=((GroupColumnIO)currentColumnIO).getChild(index);
        currentIndex[currentLevel]=index;
        if (DEBUG)         printState();
      }
 catch (      RuntimeException e) {
        throw new RuntimeException(""String_Node_Str"" + field + ""String_Node_Str""+ index,e);
      }
    }
    private void writeNullForMissingFields(    final int to){
      final int from=currentIndex[currentLevel];
      for (; currentIndex[currentLevel] <= to; ++currentIndex[currentLevel]) {
        try {
          ColumnIO undefinedField=((GroupColumnIO)currentColumnIO).getChild(currentIndex[currentLevel]);
          int d=currentColumnIO.getDefinitionLevel();
          if (DEBUG)           log(Arrays.toString(undefinedField.getFieldPath()) + ""String_Node_Str"" + r[currentLevel]+ ""String_Node_Str""+ d+ ""String_Node_Str"");
          undefinedField.writeNull(r[currentLevel],d);
        }
 catch (        RuntimeException e) {
          throw new RuntimeException(""String_Node_Str"" + from + ""String_Node_Str""+ to+ ""String_Node_Str""+ currentIndex[currentLevel],e);
        }
      }
    }
    private void setRepetitionLevel(){
      r[currentLevel]=currentColumnIO.getRepetitionLevel();
      if (DEBUG)       log(""String_Node_Str"" + r[currentLevel]);
    }
    @Override public void endField(    String field,    int index){
      if (DEBUG)       log(""String_Node_Str"" + field + ""String_Node_Str""+ index+ ""String_Node_Str"");
      currentColumnIO=currentColumnIO.getParent();
      currentIndex[currentLevel]=index + 1;
      r[currentLevel]=currentLevel == 0 ? 0 : r[currentLevel - 1];
      if (DEBUG)       printState();
    }
    @Override public void startGroup(){
      if (DEBUG)       log(""String_Node_Str"");
      ++currentLevel;
      r[currentLevel]=r[currentLevel - 1];
      currentIndex[currentLevel]=0;
      if (DEBUG)       printState();
    }
    @Override public void endGroup(){
      if (DEBUG)       log(""String_Node_Str"");
      int lastIndex=((GroupColumnIO)currentColumnIO).getChildrenCount() - 1;
      writeNullForMissingFields(lastIndex);
      --currentLevel;
      setRepetitionLevel();
      if (DEBUG)       printState();
    }
    @Override public void addInt(    int value){
      if (DEBUG)       log(""String_Node_Str"" + value + ""String_Node_Str"");
      ((PrimitiveColumnIO)currentColumnIO).getColumnWriter().write(value,r[currentLevel],currentColumnIO.getDefinitionLevel());
      setRepetitionLevel();
      if (DEBUG)       printState();
    }
    @Override public void addLong(    long value){
      if (DEBUG)       log(""String_Node_Str"" + value + ""String_Node_Str"");
      ((PrimitiveColumnIO)currentColumnIO).getColumnWriter().write(value,r[currentLevel],currentColumnIO.getDefinitionLevel());
      setRepetitionLevel();
      if (DEBUG)       printState();
    }
    @Override public void addString(    String value){
      if (DEBUG)       log(""String_Node_Str"" + value + ""String_Node_Str"");
      ((PrimitiveColumnIO)currentColumnIO).getColumnWriter().write(value,r[currentLevel],currentColumnIO.getDefinitionLevel());
      setRepetitionLevel();
      if (DEBUG)       printState();
    }
    @Override public void addBoolean(    boolean value){
      if (DEBUG)       log(""String_Node_Str"" + value + ""String_Node_Str"");
      ((PrimitiveColumnIO)currentColumnIO).getColumnWriter().write(value,r[currentLevel],currentColumnIO.getDefinitionLevel());
      setRepetitionLevel();
      if (DEBUG)       printState();
    }
    @Override public void addBinary(    byte[] value){
      if (DEBUG)       log(""String_Node_Str"" + value + ""String_Node_Str"");
      ((PrimitiveColumnIO)currentColumnIO).getColumnWriter().write(value,r[currentLevel],currentColumnIO.getDefinitionLevel());
      setRepetitionLevel();
      if (DEBUG)       printState();
    }
    @Override public void addFloat(    float value){
      if (DEBUG)       log(""String_Node_Str"" + value + ""String_Node_Str"");
      ((PrimitiveColumnIO)currentColumnIO).getColumnWriter().write(value,r[currentLevel],currentColumnIO.getDefinitionLevel());
      setRepetitionLevel();
      if (DEBUG)       printState();
    }
    @Override public void addDouble(    double value){
      if (DEBUG)       log(""String_Node_Str"" + value + ""String_Node_Str"");
      ((PrimitiveColumnIO)currentColumnIO).getColumnWriter().write(value,r[currentLevel],currentColumnIO.getDefinitionLevel());
      setRepetitionLevel();
      if (DEBUG)       printState();
    }
  }
;
}","public RecordConsumer getRecordWriter(){
  return new RecordConsumer(){
    ColumnIO currentColumnIO;
    int currentLevel=0;
    int[] currentIndex=new int[16];
    int[] r=new int[16];
    public void printState(){
      log(currentLevel + ""String_Node_Str"" + currentIndex[currentLevel]+ ""String_Node_Str""+ Arrays.toString(currentColumnIO.getFieldPath())+ ""String_Node_Str""+ r[currentLevel]);
      if (r[currentLevel] > currentColumnIO.getRepetitionLevel()) {
        throw new RuntimeException(r[currentLevel] + ""String_Node_Str"" + currentColumnIO.getRepetitionLevel()+ ""String_Node_Str"");
      }
    }
    private void log(    Object m){
      String indent=""String_Node_Str"";
      for (int i=0; i < currentLevel; ++i) {
        indent+=""String_Node_Str"";
      }
      logger.debug(indent + m);
    }
    @Override public void startMessage(){
      if (DEBUG)       log(""String_Node_Str"");
      currentColumnIO=MessageColumnIO.this;
      r[0]=0;
      currentIndex[0]=0;
      if (DEBUG)       printState();
    }
    @Override public void endMessage(){
      writeNullForMissingFields(((GroupColumnIO)currentColumnIO).getChildrenCount() - 1);
      if (DEBUG)       log(""String_Node_Str"");
      if (DEBUG)       printState();
    }
    @Override public void startField(    String field,    int index){
      try {
        if (DEBUG)         log(""String_Node_Str"" + field + ""String_Node_Str""+ index+ ""String_Node_Str"");
        writeNullForMissingFields(index - 1);
        currentColumnIO=((GroupColumnIO)currentColumnIO).getChild(index);
        currentIndex[currentLevel]=index;
        if (DEBUG)         printState();
      }
 catch (      RuntimeException e) {
        throw new RuntimeException(""String_Node_Str"" + field + ""String_Node_Str""+ index,e);
      }
    }
    private void writeNullForMissingFields(    final int to){
      final int from=currentIndex[currentLevel];
      for (; currentIndex[currentLevel] <= to; ++currentIndex[currentLevel]) {
        try {
          ColumnIO undefinedField=((GroupColumnIO)currentColumnIO).getChild(currentIndex[currentLevel]);
          int d=currentColumnIO.getDefinitionLevel();
          if (DEBUG)           log(Arrays.toString(undefinedField.getFieldPath()) + ""String_Node_Str"" + r[currentLevel]+ ""String_Node_Str""+ d+ ""String_Node_Str"");
          undefinedField.writeNull(r[currentLevel],d);
        }
 catch (        RuntimeException e) {
          throw new RuntimeException(""String_Node_Str"" + from + ""String_Node_Str""+ to+ ""String_Node_Str""+ currentIndex[currentLevel],e);
        }
      }
    }
    private void setRepetitionLevel(){
      r[currentLevel]=currentColumnIO.getRepetitionLevel();
      if (DEBUG)       log(""String_Node_Str"" + r[currentLevel]);
    }
    @Override public void endField(    String field,    int index){
      if (DEBUG)       log(""String_Node_Str"" + field + ""String_Node_Str""+ index+ ""String_Node_Str"");
      currentColumnIO=currentColumnIO.getParent();
      currentIndex[currentLevel]=index + 1;
      r[currentLevel]=currentLevel == 0 ? 0 : r[currentLevel - 1];
      if (DEBUG)       printState();
    }
    @Override public void startGroup(){
      if (DEBUG)       log(""String_Node_Str"");
      ++currentLevel;
      r[currentLevel]=r[currentLevel - 1];
      currentIndex[currentLevel]=0;
      if (DEBUG)       printState();
    }
    @Override public void endGroup(){
      if (DEBUG)       log(""String_Node_Str"");
      int lastIndex=((GroupColumnIO)currentColumnIO).getChildrenCount() - 1;
      writeNullForMissingFields(lastIndex);
      --currentLevel;
      setRepetitionLevel();
      if (DEBUG)       printState();
    }
    @Override public void addInt(    int value){
      if (DEBUG)       log(""String_Node_Str"" + value + ""String_Node_Str"");
      ((PrimitiveColumnIO)currentColumnIO).getColumnWriter().write(value,r[currentLevel],currentColumnIO.getDefinitionLevel());
      setRepetitionLevel();
      if (DEBUG)       printState();
    }
    @Override public void addLong(    long value){
      if (DEBUG)       log(""String_Node_Str"" + value + ""String_Node_Str"");
      ((PrimitiveColumnIO)currentColumnIO).getColumnWriter().write(value,r[currentLevel],currentColumnIO.getDefinitionLevel());
      setRepetitionLevel();
      if (DEBUG)       printState();
    }
    @Override public void addString(    String value){
      if (DEBUG)       log(""String_Node_Str"" + value + ""String_Node_Str"");
      ((PrimitiveColumnIO)currentColumnIO).getColumnWriter().write(value,r[currentLevel],currentColumnIO.getDefinitionLevel());
      setRepetitionLevel();
      if (DEBUG)       printState();
    }
    @Override public void addBoolean(    boolean value){
      if (DEBUG)       log(""String_Node_Str"" + value + ""String_Node_Str"");
      ((PrimitiveColumnIO)currentColumnIO).getColumnWriter().write(value,r[currentLevel],currentColumnIO.getDefinitionLevel());
      setRepetitionLevel();
      if (DEBUG)       printState();
    }
    @Override public void addBinary(    byte[] value){
      if (DEBUG)       log(""String_Node_Str"" + value + ""String_Node_Str"");
      ((PrimitiveColumnIO)currentColumnIO).getColumnWriter().write(value,r[currentLevel],currentColumnIO.getDefinitionLevel());
      setRepetitionLevel();
      if (DEBUG)       printState();
    }
    @Override public void addFloat(    float value){
      if (DEBUG)       log(""String_Node_Str"" + value + ""String_Node_Str"");
      ((PrimitiveColumnIO)currentColumnIO).getColumnWriter().write(value,r[currentLevel],currentColumnIO.getDefinitionLevel());
      setRepetitionLevel();
      if (DEBUG)       printState();
    }
    @Override public void addDouble(    double value){
      if (DEBUG)       log(""String_Node_Str"" + value + ""String_Node_Str"");
      ((PrimitiveColumnIO)currentColumnIO).getColumnWriter().write(value,r[currentLevel],currentColumnIO.getDefinitionLevel());
      setRepetitionLevel();
      if (DEBUG)       printState();
    }
  }
;
}",0.9923767575808912
112147,"@Override public void endMessage(){
  if (DEBUG)   log(""String_Node_Str"");
  if (DEBUG)   printState();
}","@Override public void endMessage(){
  writeNullForMissingFields(((GroupColumnIO)currentColumnIO).getChildrenCount() - 1);
  if (DEBUG)   log(""String_Node_Str"");
  if (DEBUG)   printState();
}",0.7094594594594594
112148,"@Override public void addString(String value){
  if (DEBUG) {
    log(value);
  }
  delegate.addString(value);
}","@Override public void addString(String value){
  if (DEBUG)   log(value);
  delegate.addString(value);
}",0.9629629629629628
112149,"@Override public InputFormat<Object,Tuple> getInputFormat() throws IOException {
}","@Override public InputFormat<Object,Tuple> getInputFormat() throws IOException {
  return new InputFormat<Object,Tuple>(){
    @Override public RecordReader<Object,Tuple> createRecordReader(    InputSplit inputSplit,    TaskAttemptContext taskAttemptContext) throws IOException, InterruptedException {
      return new RecordReader<Object,Tuple>(){
        private Tuple currentTuple;
        private int total;
        private int current;
        private boolean dataAvailable;
        private void checkRead(){
        }
        @Override public void close() throws IOException {
        }
        @Override public Object getCurrentKey() throws IOException, InterruptedException {
          return null;
        }
        @Override public Tuple getCurrentValue() throws IOException, InterruptedException {
          checkRead();
          if (!dataAvailable) {
            throw new IOException(""String_Node_Str"");
          }
          return currentTuple;
        }
        @Override public float getProgress() throws IOException, InterruptedException {
          return (float)current / total;
        }
        @Override public void initialize(        InputSplit inputSplit,        TaskAttemptContext taskAttemptContext) throws IOException, InterruptedException {
        }
        @Override public boolean nextKeyValue() throws IOException, InterruptedException {
          checkRead();
          return dataAvailable;
        }
      }
;
    }
    @Override public List<InputSplit> getSplits(    JobContext jobContext) throws IOException, InterruptedException {
      return null;
    }
  }
;
}",0.0973293768545994
112150,"/** 
 * Extract all of the resources from a given bundle
 */
public static List<BundleEntryParts> toListOfEntries(FhirContext theContext,IBaseBundle theBundle){
  List<BundleEntryParts> retVal=new ArrayList<>();
  RuntimeResourceDefinition def=theContext.getResourceDefinition(theBundle);
  BaseRuntimeChildDefinition entryChild=def.getChildByName(""String_Node_Str"");
  List<IBase> entries=entryChild.getAccessor().getValues(theBundle);
  BaseRuntimeElementCompositeDefinition<?> entryChildElem=(BaseRuntimeElementCompositeDefinition<?>)entryChild.getChildByName(""String_Node_Str"");
  BaseRuntimeChildDefinition resourceChild=entryChildElem.getChildByName(""String_Node_Str"");
  BaseRuntimeChildDefinition requestChild=entryChildElem.getChildByName(""String_Node_Str"");
  BaseRuntimeElementCompositeDefinition<?> requestElem=(BaseRuntimeElementCompositeDefinition<?>)requestChild.getChildByName(""String_Node_Str"");
  BaseRuntimeChildDefinition urlChild=requestElem.getChildByName(""String_Node_Str"");
  BaseRuntimeChildDefinition methodChild=requestElem.getChildByName(""String_Node_Str"");
  IBaseResource resource=null;
  String url=null;
  RequestTypeEnum requestType=null;
  for (  IBase nextEntry : entries) {
    for (    IBase next : resourceChild.getAccessor().getValues(nextEntry)) {
      resource=(IBaseResource)next;
    }
    for (    IBase nextRequest : requestChild.getAccessor().getValues(nextEntry)) {
      for (      IBase nextUrl : urlChild.getAccessor().getValues(nextRequest)) {
        url=((IPrimitiveType<?>)nextUrl).getValueAsString();
      }
      for (      IBase nextUrl : methodChild.getAccessor().getValues(nextRequest)) {
        String methodString=((IPrimitiveType<?>)nextUrl).getValueAsString();
        if (isNotBlank(methodString)) {
          requestType=RequestTypeEnum.valueOf(methodString);
        }
      }
    }
    retVal.add(new BundleEntryParts(requestType,url,resource));
  }
  return retVal;
}","/** 
 * Extract all of the resources from a given bundle
 */
public static List<BundleEntryParts> toListOfEntries(FhirContext theContext,IBaseBundle theBundle){
  List<BundleEntryParts> retVal=new ArrayList<>();
  RuntimeResourceDefinition def=theContext.getResourceDefinition(theBundle);
  BaseRuntimeChildDefinition entryChild=def.getChildByName(""String_Node_Str"");
  List<IBase> entries=entryChild.getAccessor().getValues(theBundle);
  BaseRuntimeElementCompositeDefinition<?> entryChildElem=(BaseRuntimeElementCompositeDefinition<?>)entryChild.getChildByName(""String_Node_Str"");
  BaseRuntimeChildDefinition resourceChild=entryChildElem.getChildByName(""String_Node_Str"");
  BaseRuntimeChildDefinition requestChild=entryChildElem.getChildByName(""String_Node_Str"");
  BaseRuntimeElementCompositeDefinition<?> requestElem=(BaseRuntimeElementCompositeDefinition<?>)requestChild.getChildByName(""String_Node_Str"");
  BaseRuntimeChildDefinition urlChild=requestElem.getChildByName(""String_Node_Str"");
  BaseRuntimeChildDefinition methodChild=requestElem.getChildByName(""String_Node_Str"");
  for (  IBase nextEntry : entries) {
    IBaseResource resource=null;
    String url=null;
    RequestTypeEnum requestType=null;
    for (    IBase next : resourceChild.getAccessor().getValues(nextEntry)) {
      resource=(IBaseResource)next;
    }
    for (    IBase nextRequest : requestChild.getAccessor().getValues(nextEntry)) {
      for (      IBase nextUrl : urlChild.getAccessor().getValues(nextRequest)) {
        url=((IPrimitiveType<?>)nextUrl).getValueAsString();
      }
      for (      IBase nextUrl : methodChild.getAccessor().getValues(nextRequest)) {
        String methodString=((IPrimitiveType<?>)nextUrl).getValueAsString();
        if (isNotBlank(methodString)) {
          requestType=RequestTypeEnum.valueOf(methodString);
        }
      }
    }
    retVal.add(new BundleEntryParts(requestType,url,resource));
  }
  return retVal;
}",0.9788768675940236
112151,"private void doLoadPids(List<IBaseResource> theResourceListToPopulate,Set<Long> theRevIncludedPids,boolean theForHistoryOperation,EntityManager entityManager,FhirContext context,IDao theDao,Map<Long,Integer> position,Collection<Long> pids){
  CriteriaBuilder builder=entityManager.getCriteriaBuilder();
  CriteriaQuery<ResourceTable> cq=builder.createQuery(ResourceTable.class);
  Root<ResourceTable> from=cq.from(ResourceTable.class);
  cq.where(from.get(""String_Node_Str"").in(pids));
  TypedQuery<ResourceTable> q=entityManager.createQuery(cq);
  List<ResourceTable> resultList=q.getResultList();
  Map<Long,ResourceHistoryTable> historyMap=getResourceHistoryMap(pids);
  Map<Long,Collection<ResourceTag>> tagMap=getResourceTagMap(resultList);
  for (  ResourceTable next : resultList) {
    Class<? extends IBaseResource> resourceType=context.getResourceDefinition(next.getResourceType()).getImplementingClass();
    IBaseResource resource=theDao.toResource(resourceType,next,historyMap.get(next.getId()),tagMap.get(next.getId()),theForHistoryOperation);
    if (resource == null) {
      ourLog.warn(""String_Node_Str"",next.getResourceType(),next.getIdDt().getIdPart(),next.getVersion());
      continue;
    }
    Integer index=position.get(next.getId());
    if (index == null) {
      ourLog.warn(""String_Node_Str"",next.getId());
      continue;
    }
    if (resource instanceof IResource) {
      if (theRevIncludedPids.contains(next.getId())) {
        ResourceMetadataKeyEnum.ENTRY_SEARCH_MODE.put((IResource)resource,BundleEntrySearchModeEnum.INCLUDE);
      }
 else {
        ResourceMetadataKeyEnum.ENTRY_SEARCH_MODE.put((IResource)resource,BundleEntrySearchModeEnum.MATCH);
      }
    }
 else {
      if (theRevIncludedPids.contains(next.getId())) {
        ResourceMetadataKeyEnum.ENTRY_SEARCH_MODE.put((IAnyResource)resource,BundleEntrySearchModeEnum.INCLUDE.getCode());
      }
 else {
        ResourceMetadataKeyEnum.ENTRY_SEARCH_MODE.put((IAnyResource)resource,BundleEntrySearchModeEnum.MATCH.getCode());
      }
    }
    theResourceListToPopulate.set(index,resource);
  }
}","private void doLoadPids(List<IBaseResource> theResourceListToPopulate,Set<Long> theRevIncludedPids,boolean theForHistoryOperation,EntityManager entityManager,FhirContext context,IDao theDao,Map<Long,Integer> position,Collection<Long> pids){
  CriteriaBuilder builder=entityManager.getCriteriaBuilder();
  CriteriaQuery<ResourceTable> cq=builder.createQuery(ResourceTable.class);
  Root<ResourceTable> from=cq.from(ResourceTable.class);
  cq.where(from.get(""String_Node_Str"").in(pids));
  TypedQuery<ResourceTable> q=entityManager.createQuery(cq);
  List<ResourceTable> resultList=q.getResultList();
  Map<Long,ResourceHistoryTable> historyMap=getResourceHistoryMap(pids);
  Map<Long,Collection<ResourceTag>> tagMap=getResourceTagMap(resultList);
  Map<Long,ForcedId> forcedIdMap=getForcedIdMap(pids);
  ForcedId forcedId=null;
  Long resourceId=null;
  for (  ResourceTable next : resultList) {
    Class<? extends IBaseResource> resourceType=context.getResourceDefinition(next.getResourceType()).getImplementingClass();
    resourceId=next.getId();
    forcedId=forcedIdMap.get(resourceId);
    if (forcedId != null)     next.setForcedId(forcedId);
    IBaseResource resource=theDao.toResource(resourceType,next,historyMap.get(next.getId()),tagMap.get(next.getId()),theForHistoryOperation);
    if (resource == null) {
      ourLog.warn(""String_Node_Str"",next.getResourceType(),next.getIdDt().getIdPart(),next.getVersion());
      continue;
    }
    Integer index=position.get(next.getId());
    if (index == null) {
      ourLog.warn(""String_Node_Str"",next.getId());
      continue;
    }
    if (resource instanceof IResource) {
      if (theRevIncludedPids.contains(next.getId())) {
        ResourceMetadataKeyEnum.ENTRY_SEARCH_MODE.put((IResource)resource,BundleEntrySearchModeEnum.INCLUDE);
      }
 else {
        ResourceMetadataKeyEnum.ENTRY_SEARCH_MODE.put((IResource)resource,BundleEntrySearchModeEnum.MATCH);
      }
    }
 else {
      if (theRevIncludedPids.contains(next.getId())) {
        ResourceMetadataKeyEnum.ENTRY_SEARCH_MODE.put((IAnyResource)resource,BundleEntrySearchModeEnum.INCLUDE.getCode());
      }
 else {
        ResourceMetadataKeyEnum.ENTRY_SEARCH_MODE.put((IAnyResource)resource,BundleEntrySearchModeEnum.MATCH.getCode());
      }
    }
    theResourceListToPopulate.set(index,resource);
  }
}",0.9471066907775768
112152,"private void doLoadPids(List<IBaseResource> theResourceListToPopulate,Set<Long> theRevIncludedPids,boolean theForHistoryOperation,EntityManager entityManager,FhirContext context,IDao theDao,Map<Long,Integer> position,Collection<Long> pids){
  CriteriaBuilder builder=entityManager.getCriteriaBuilder();
  CriteriaQuery<ResourceTable> cq=builder.createQuery(ResourceTable.class);
  Root<ResourceTable> from=cq.from(ResourceTable.class);
  cq.where(from.get(""String_Node_Str"").in(pids));
  TypedQuery<ResourceTable> q=entityManager.createQuery(cq);
  List<ResourceTable> resultList=q.getResultList();
  Map<Long,ResourceHistoryTable> historyMap=getResourceHistoryMap(pids);
  Map<Long,Collection<ResourceTag>> tagMap=getResourceTagMap(resultList);
  for (  ResourceTable next : resultList) {
    Class<? extends IBaseResource> resourceType=context.getResourceDefinition(next.getResourceType()).getImplementingClass();
    IBaseResource resource=theDao.toResource(resourceType,next,historyMap.get(next.getId()),tagMap.get(next.getId()),theForHistoryOperation);
    if (resource == null) {
      ourLog.warn(""String_Node_Str"",next.getResourceType(),next.getIdDt().getIdPart(),next.getVersion());
      continue;
    }
    Integer index=position.get(next.getId());
    if (index == null) {
      ourLog.warn(""String_Node_Str"",next.getId());
      continue;
    }
    if (resource instanceof IResource) {
      if (theRevIncludedPids.contains(next.getId())) {
        ResourceMetadataKeyEnum.ENTRY_SEARCH_MODE.put((IResource)resource,BundleEntrySearchModeEnum.INCLUDE);
      }
 else {
        ResourceMetadataKeyEnum.ENTRY_SEARCH_MODE.put((IResource)resource,BundleEntrySearchModeEnum.MATCH);
      }
    }
 else {
      if (theRevIncludedPids.contains(next.getId())) {
        ResourceMetadataKeyEnum.ENTRY_SEARCH_MODE.put((IAnyResource)resource,BundleEntrySearchModeEnum.INCLUDE.getCode());
      }
 else {
        ResourceMetadataKeyEnum.ENTRY_SEARCH_MODE.put((IAnyResource)resource,BundleEntrySearchModeEnum.MATCH.getCode());
      }
    }
    theResourceListToPopulate.set(index,resource);
  }
}","private void doLoadPids(List<IBaseResource> theResourceListToPopulate,Set<Long> theRevIncludedPids,boolean theForHistoryOperation,EntityManager entityManager,FhirContext context,IDao theDao,Map<Long,Integer> position,Collection<Long> pids){
  CriteriaBuilder builder=entityManager.getCriteriaBuilder();
  CriteriaQuery<ResourceTable> cq=builder.createQuery(ResourceTable.class);
  Root<ResourceTable> from=cq.from(ResourceTable.class);
  cq.where(from.get(""String_Node_Str"").in(pids));
  TypedQuery<ResourceTable> q=entityManager.createQuery(cq);
  List<ResourceTable> resultList=q.getResultList();
  Map<Long,ResourceHistoryTable> historyMap=getResourceHistoryMap(pids);
  Map<Long,Collection<ResourceTag>> tagMap=getResourceTagMap(resultList);
  Map<Long,ForcedId> forcedIdMap=getForcedIdMap(pids);
  ForcedId forcedId=null;
  Long resourceId=null;
  for (  ResourceTable next : resultList) {
    Class<? extends IBaseResource> resourceType=context.getResourceDefinition(next.getResourceType()).getImplementingClass();
    resourceId=next.getId();
    forcedId=forcedIdMap.get(resourceId);
    if (forcedId != null)     next.setForcedId(forcedId);
    IBaseResource resource=theDao.toResource(resourceType,next,historyMap.get(next.getId()),tagMap.get(next.getId()),theForHistoryOperation);
    if (resource == null) {
      ourLog.warn(""String_Node_Str"",next.getResourceType(),next.getIdDt().getIdPart(),next.getVersion());
      continue;
    }
    Integer index=position.get(next.getId());
    if (index == null) {
      ourLog.warn(""String_Node_Str"",next.getId());
      continue;
    }
    if (resource instanceof IResource) {
      if (theRevIncludedPids.contains(next.getId())) {
        ResourceMetadataKeyEnum.ENTRY_SEARCH_MODE.put((IResource)resource,BundleEntrySearchModeEnum.INCLUDE);
      }
 else {
        ResourceMetadataKeyEnum.ENTRY_SEARCH_MODE.put((IResource)resource,BundleEntrySearchModeEnum.MATCH);
      }
    }
 else {
      if (theRevIncludedPids.contains(next.getId())) {
        ResourceMetadataKeyEnum.ENTRY_SEARCH_MODE.put((IAnyResource)resource,BundleEntrySearchModeEnum.INCLUDE.getCode());
      }
 else {
        ResourceMetadataKeyEnum.ENTRY_SEARCH_MODE.put((IAnyResource)resource,BundleEntrySearchModeEnum.MATCH.getCode());
      }
    }
    theResourceListToPopulate.set(index,resource);
  }
}",0.9471066907775768
112153,"/** 
 * This setter is needed in implementation classes (along with a no-arg constructor) to avoid reference cycles in the Spring wiring of a RestfulServer instance.
 * @param theRestfulServer
 */
public void setRestfulServer(RestfulServer theRestfulServer);","/** 
 * This setter is needed in implementation classes (along with a no-arg constructor) to avoid reference cycles in the Spring wiring of a RestfulServer instance.
 * @param theRestfulServer
 */
void setRestfulServer(RestfulServer theRestfulServer);",0.986247544204322
112154,"/** 
 * Actually create and return the conformance statement See the class documentation for an important note if you are extending this class
 */
public abstract T getServerConformance(HttpServletRequest theRequest);","/** 
 * Actually create and return the conformance statement See the class documentation for an important note if you are extending this class
 */
T getServerConformance(HttpServletRequest theRequest);",0.9617224880382776
112155,"/** 
 * Sets the resource providers for this server
 */
public void setResourceProviders(Collection<IResourceProvider> theResourceProviders){
  myResourceProviders.clear();
  if (theResourceProviders != null) {
    myResourceProviders.addAll(theResourceProviders);
  }
}","/** 
 * Sets the resource providers for this server
 */
public void setResourceProviders(IResourceProvider... theResourceProviders){
  myResourceProviders.clear();
  if (theResourceProviders != null) {
    myResourceProviders.addAll(Arrays.asList(theResourceProviders));
  }
}",0.8717948717948718
112156,"/** 
 * Sets the non-resource specific providers which implement method calls on this server.
 * @see #setResourceProviders(Collection)
 */
public void setPlainProviders(Collection<Object> theProviders){
  myPlainProviders.clear();
  if (theProviders != null) {
    myPlainProviders.addAll(theProviders);
  }
}","/** 
 * Sets the non-resource specific providers which implement method calls on this server.
 * @see #setResourceProviders(Collection)
 */
public void setPlainProviders(Object... theProv){
  setPlainProviders(Arrays.asList(theProv));
}",0.6813186813186813
112157,"public RestulfulServerConfiguration createConfiguration(){
  RestulfulServerConfiguration result=new RestulfulServerConfiguration();
  result.setResourceBindings(getResourceBindings());
  result.setServerBindings(getServerBindings());
  result.setImplementationDescription(getImplementationDescription());
  result.setServerVersion(getServerVersion());
  result.setServerName(getServerName());
  result.setFhirContext(getFhirContext());
  result.setServerAddressStrategy(myServerAddressStrategy);
  InputStream inputStream=null;
  try {
    inputStream=getClass().getResourceAsStream(""String_Node_Str"");
    if (inputStream != null) {
      Manifest manifest=new Manifest(inputStream);
      result.setConformanceDate(manifest.getMainAttributes().getValue(""String_Node_Str""));
    }
  }
 catch (  IOException e) {
  }
 finally {
    if (inputStream != null) {
      IOUtils.closeQuietly(inputStream);
    }
  }
  return result;
}","public RestulfulServerConfiguration createConfiguration(){
  RestulfulServerConfiguration result=new RestulfulServerConfiguration();
  result.setResourceBindings(getResourceBindings());
  result.setServerBindings(getServerBindings());
  result.setImplementationDescription(getImplementationDescription());
  result.setServerVersion(getServerVersion());
  result.setServerName(getServerName());
  result.setFhirContext(getFhirContext());
  result.setServerAddressStrategy(myServerAddressStrategy);
  try (InputStream inputStream=getClass().getResourceAsStream(""String_Node_Str"")){
    if (inputStream != null) {
      Manifest manifest=new Manifest(inputStream);
      String value=manifest.getMainAttributes().getValue(""String_Node_Str"");
      result.setConformanceDate(new InstantDt(value));
    }
  }
 catch (  Exception e) {
  }
  return result;
}",0.8550561797752809
112158,"/** 
 * Sets (or clears) the list of interceptors
 * @param theList The list of interceptors (may be null)
 */
public void setInterceptors(IServerInterceptor... theList){
  myInterceptors.clear();
  if (theList != null) {
    myInterceptors.addAll(Arrays.asList(theList));
  }
}","/** 
 * Sets (or clears) the list of interceptors
 * @param theList The list of interceptors (may be null)
 */
public void setInterceptors(List<IServerInterceptor> theList){
  myInterceptors.clear();
  if (theList != null) {
    myInterceptors.addAll(theList);
  }
}",0.9301470588235294
112159,"/** 
 * Set the serverBindings
 * @param serverBindings the serverBindings to set
 */
public RestulfulServerConfiguration setServerBindings(List<BaseMethodBinding<?>> serverBindings){
  this.serverBindings=serverBindings;
  return this;
}","/** 
 * Set the theServerBindings
 */
public RestulfulServerConfiguration setServerBindings(List<BaseMethodBinding<?>> theServerBindings){
  this.serverBindings=theServerBindings;
  return this;
}",0.847926267281106
112160,"/** 
 * Set the conformanceDate
 * @param conformanceDate the conformanceDate to set
 */
public void setConformanceDate(String conformanceDate){
  this.conformanceDate=conformanceDate;
}","/** 
 * Set the date that will be specified in the conformance profile exported by this server. Typically this would be populated with an InstanceType.
 */
public void setConformanceDate(IPrimitiveType<Date> theConformanceDate){
  myConformanceDate=theConformanceDate;
}",0.4517543859649123
112161,"/** 
 * Get the conformanceDate
 * @return the conformanceDate
 */
public String getConformanceDate(){
  return conformanceDate;
}","/** 
 * Get the date that will be specified in the conformance profile exported by this server. Typically this would be populated with an InstanceType.
 */
public IPrimitiveType<Date> getConformanceDate(){
  return myConformanceDate;
}",0.3780821917808219
112162,"@Test public void testSearchReferenceParameterWithList() throws Exception {
  RestfulServer rsNoType=new RestfulServer(ourCtx);
  rsNoType.registerProvider(new SearchProviderWithListNoType());
  ServerCapabilityStatementProvider scNoType=new ServerCapabilityStatementProvider(rsNoType);
  rsNoType.setServerConformanceProvider(scNoType);
  rsNoType.init(createServletConfig());
  scNoType.getServerConfiguration().setConformanceDate(""String_Node_Str"");
  CapabilityStatement conformance=scNoType.getServerConformance(createHttpServletRequest());
  String confNoType=ourCtx.newXmlParser().setPrettyPrint(true).encodeResourceToString(conformance);
  ourLog.info(confNoType);
  RestfulServer rsWithType=new RestfulServer(ourCtx);
  rsWithType.registerProvider(new SearchProviderWithListWithType());
  ServerCapabilityStatementProvider scWithType=new ServerCapabilityStatementProvider(rsWithType);
  rsWithType.setServerConformanceProvider(scWithType);
  rsWithType.init(createServletConfig());
  scWithType.getServerConfiguration().setConformanceDate(""String_Node_Str"");
  CapabilityStatement conformanceWithType=scWithType.getServerConformance(createHttpServletRequest());
  String confWithType=ourCtx.newXmlParser().setPrettyPrint(true).encodeResourceToString(conformanceWithType);
  ourLog.info(confWithType);
  assertEquals(confNoType,confWithType);
}","@Test public void testSearchReferenceParameterWithList() throws Exception {
  RestfulServer rsNoType=new RestfulServer(ourCtx){
    @Override public RestulfulServerConfiguration createConfiguration(){
      RestulfulServerConfiguration retVal=super.createConfiguration();
      retVal.setConformanceDate(new InstantDt(""String_Node_Str""));
      return retVal;
    }
  }
;
  rsNoType.registerProvider(new SearchProviderWithListNoType());
  ServerCapabilityStatementProvider scNoType=new ServerCapabilityStatementProvider(rsNoType);
  rsNoType.setServerConformanceProvider(scNoType);
  rsNoType.init(createServletConfig());
  CapabilityStatement conformance=scNoType.getServerConformance(createHttpServletRequest());
  String confNoType=ourCtx.newXmlParser().setPrettyPrint(true).encodeResourceToString(conformance);
  ourLog.info(confNoType);
  RestfulServer rsWithType=new RestfulServer(ourCtx){
    @Override public RestulfulServerConfiguration createConfiguration(){
      RestulfulServerConfiguration retVal=super.createConfiguration();
      retVal.setConformanceDate(new InstantDt(""String_Node_Str""));
      return retVal;
    }
  }
;
  rsWithType.registerProvider(new SearchProviderWithListWithType());
  ServerCapabilityStatementProvider scWithType=new ServerCapabilityStatementProvider(rsWithType);
  rsWithType.setServerConformanceProvider(scWithType);
  rsWithType.init(createServletConfig());
  CapabilityStatement conformanceWithType=scWithType.getServerConformance(createHttpServletRequest());
  String confWithType=ourCtx.newXmlParser().setPrettyPrint(true).encodeResourceToString(conformanceWithType);
  ourLog.info(confWithType);
  assertEquals(confNoType,confWithType);
  assertThat(confNoType,containsString(""String_Node_Str""));
}",0.4787096774193548
112163,"public void testCreateWrongType() throws Exception {
  Binary res=new Binary();
  res.setContent(new byte[]{1,2,3,4});
  res.setContentType(""String_Node_Str"");
  String stringContent=ourCtx.newJsonParser().encodeResourceToString(res);
  HttpPost http=new HttpPost(""String_Node_Str"" + ourPort + ""String_Node_Str"");
  http.setEntity(new StringEntity(stringContent,ContentType.create(Constants.CT_FHIR_JSON,""String_Node_Str"")));
  HttpResponse status=ourClient.execute(http);
  assertEquals(201,status.getStatusLine().getStatusCode());
  assertEquals(""String_Node_Str"",ourLast.getContentType());
  assertArrayEquals(new byte[]{1,2,3,4},ourLast.getContent());
}","@Test public void testCreateWrongType() throws Exception {
  Binary res=new Binary();
  res.setContent(new byte[]{1,2,3,4});
  res.setContentType(""String_Node_Str"");
  String stringContent=ourCtx.newJsonParser().encodeResourceToString(res);
  HttpPost http=new HttpPost(""String_Node_Str"" + ourPort + ""String_Node_Str"");
  http.setEntity(new StringEntity(stringContent,ContentType.create(Constants.CT_FHIR_JSON,""String_Node_Str"")));
  HttpResponse status=ourClient.execute(http);
  assertEquals(201,status.getStatusLine().getStatusCode());
  assertEquals(""String_Node_Str"",ourLast.getContentType().replace(""String_Node_Str"",""String_Node_Str"").toLowerCase());
}",0.9012158054711246
112164,"public void testRoundTrip() throws Exception {
  ZipInputStream is=new ZipInputStream(new FileInputStream(""String_Node_Str""));
  try {
    while (true) {
      ZipEntry nextEntry=is.getNextEntry();
      if (nextEntry == null) {
        break;
      }
      ByteArrayOutputStream oos=new ByteArrayOutputStream();
      byte[] buffer=new byte[2048];
      int len=0;
      while ((len=is.read(buffer)) > 0) {
        oos.write(buffer,0,len);
      }
      String exampleText=oos.toString(""String_Node_Str"");
      ourLog.info(""String_Node_Str"",nextEntry.getName(),exampleText.length());
      if (!nextEntry.getName().contains(""String_Node_Str"")) {
        continue;
      }
      IBaseResource parsed=ourCtx.newXmlParser().parseResource(exampleText);
      String encodedXml=ourCtx.newXmlParser().setPrettyPrint(true).encodeResourceToString(parsed);
      exampleText=cleanXml(exampleText);
      encodedXml=cleanXml(encodedXml);
      XmlParserDstu3Test.compareXml(exampleText,encodedXml);
    }
  }
  finally {
    is.close();
  }
}","@Test public void testRoundTrip() throws Exception {
  ZipInputStream is=new ZipInputStream(new FileInputStream(""String_Node_Str""));
  try {
    while (true) {
      ZipEntry nextEntry=is.getNextEntry();
      if (nextEntry == null) {
        break;
      }
      ByteArrayOutputStream oos=new ByteArrayOutputStream();
      byte[] buffer=new byte[2048];
      int len=0;
      while ((len=is.read(buffer)) > 0) {
        oos.write(buffer,0,len);
      }
      String exampleText=oos.toString(""String_Node_Str"");
      ourLog.info(""String_Node_Str"",nextEntry.getName(),exampleText.length());
      if (!nextEntry.getName().contains(""String_Node_Str"")) {
        continue;
      }
      IBaseResource parsed=ourCtx.newXmlParser().parseResource(exampleText);
      String encodedXml=ourCtx.newXmlParser().setPrettyPrint(true).encodeResourceToString(parsed);
      exampleText=cleanXml(exampleText);
      encodedXml=cleanXml(encodedXml);
      XmlParserDstu3Test.compareXml(exampleText,encodedXml);
    }
  }
  finally {
    is.close();
  }
}",0.9971070395371264
112165,"/** 
 * Extract all of the resources from a given bundle
 */
public static List<BundleEntryParts> toListOfEntries(FhirContext theContext,IBaseBundle theBundle){
  List<BundleEntryParts> retVal=new ArrayList<>();
  RuntimeResourceDefinition def=theContext.getResourceDefinition(theBundle);
  BaseRuntimeChildDefinition entryChild=def.getChildByName(""String_Node_Str"");
  List<IBase> entries=entryChild.getAccessor().getValues(theBundle);
  BaseRuntimeElementCompositeDefinition<?> entryChildElem=(BaseRuntimeElementCompositeDefinition<?>)entryChild.getChildByName(""String_Node_Str"");
  BaseRuntimeChildDefinition resourceChild=entryChildElem.getChildByName(""String_Node_Str"");
  BaseRuntimeChildDefinition requestChild=entryChildElem.getChildByName(""String_Node_Str"");
  BaseRuntimeElementCompositeDefinition<?> requestElem=(BaseRuntimeElementCompositeDefinition<?>)requestChild.getChildByName(""String_Node_Str"");
  BaseRuntimeChildDefinition urlChild=requestElem.getChildByName(""String_Node_Str"");
  BaseRuntimeChildDefinition methodChild=requestElem.getChildByName(""String_Node_Str"");
  IBaseResource resource=null;
  String url=null;
  RequestTypeEnum requestType=null;
  for (  IBase nextEntry : entries) {
    for (    IBase next : resourceChild.getAccessor().getValues(nextEntry)) {
      resource=(IBaseResource)next;
    }
    for (    IBase nextRequest : requestChild.getAccessor().getValues(nextEntry)) {
      for (      IBase nextUrl : urlChild.getAccessor().getValues(nextRequest)) {
        url=((IPrimitiveType<?>)nextUrl).getValueAsString();
      }
      for (      IBase nextUrl : methodChild.getAccessor().getValues(nextRequest)) {
        String methodString=((IPrimitiveType<?>)nextUrl).getValueAsString();
        if (isNotBlank(methodString)) {
          requestType=RequestTypeEnum.valueOf(methodString);
        }
      }
    }
    retVal.add(new BundleEntryParts(requestType,url,resource));
  }
  return retVal;
}","/** 
 * Extract all of the resources from a given bundle
 */
public static List<BundleEntryParts> toListOfEntries(FhirContext theContext,IBaseBundle theBundle){
  List<BundleEntryParts> retVal=new ArrayList<>();
  RuntimeResourceDefinition def=theContext.getResourceDefinition(theBundle);
  BaseRuntimeChildDefinition entryChild=def.getChildByName(""String_Node_Str"");
  List<IBase> entries=entryChild.getAccessor().getValues(theBundle);
  BaseRuntimeElementCompositeDefinition<?> entryChildElem=(BaseRuntimeElementCompositeDefinition<?>)entryChild.getChildByName(""String_Node_Str"");
  BaseRuntimeChildDefinition resourceChild=entryChildElem.getChildByName(""String_Node_Str"");
  BaseRuntimeChildDefinition requestChild=entryChildElem.getChildByName(""String_Node_Str"");
  BaseRuntimeElementCompositeDefinition<?> requestElem=(BaseRuntimeElementCompositeDefinition<?>)requestChild.getChildByName(""String_Node_Str"");
  BaseRuntimeChildDefinition urlChild=requestElem.getChildByName(""String_Node_Str"");
  BaseRuntimeChildDefinition methodChild=requestElem.getChildByName(""String_Node_Str"");
  for (  IBase nextEntry : entries) {
    IBaseResource resource=null;
    String url=null;
    RequestTypeEnum requestType=null;
    for (    IBase next : resourceChild.getAccessor().getValues(nextEntry)) {
      resource=(IBaseResource)next;
    }
    for (    IBase nextRequest : requestChild.getAccessor().getValues(nextEntry)) {
      for (      IBase nextUrl : urlChild.getAccessor().getValues(nextRequest)) {
        url=((IPrimitiveType<?>)nextUrl).getValueAsString();
      }
      for (      IBase nextUrl : methodChild.getAccessor().getValues(nextRequest)) {
        String methodString=((IPrimitiveType<?>)nextUrl).getValueAsString();
        if (isNotBlank(methodString)) {
          requestType=RequestTypeEnum.valueOf(methodString);
        }
      }
    }
    retVal.add(new BundleEntryParts(requestType,url,resource));
  }
  return retVal;
}",0.9788768675940236
112166,"@Bean() public LocalContainerEntityManagerFactoryBean entityManagerFactory(){
  return FhirServerConfigCommon.getEntityManagerFactory(env,dataSource());
}","@Bean() public LocalContainerEntityManagerFactoryBean entityManagerFactory(){
  return FhirServerConfigCommon.getEntityManagerFactory(env,dataSource(),fhirContextDstu3());
}",0.9418960244648318
112167,"@Override public void accept(CSVRecord theRecord){
  String code=trim(theRecord.get(""String_Node_Str""));
  if (isNotBlank(code)) {
    String longCommonName=trim(theRecord.get(""String_Node_Str""));
    String shortName=trim(theRecord.get(""String_Node_Str""));
    String consumerName=trim(theRecord.get(""String_Node_Str""));
    String display=TerminologyLoaderSvcImpl.firstNonBlank(longCommonName,shortName,consumerName);
    TermConcept concept=new TermConcept(myCodeSystemVersion,code);
    concept.setDisplay(display);
    if (!display.equalsIgnoreCase(shortName)) {
      concept.addDesignation().setUseDisplay(""String_Node_Str"").setValue(shortName);
    }
    for (    String nextPropertyName : myPropertyNames.keySet()) {
      if (!theRecord.toMap().containsKey(nextPropertyName)) {
        continue;
      }
      CodeSystem.PropertyType nextPropertyType=myPropertyNames.get(nextPropertyName);
      String nextPropertyValue=theRecord.get(nextPropertyName);
      if (isNotBlank(nextPropertyValue)) {
        nextPropertyValue=trim(nextPropertyValue);
switch (nextPropertyType) {
case STRING:
          concept.addPropertyString(nextPropertyName,nextPropertyValue);
        break;
case CODING:
      PartTypeAndPartName key=new PartTypeAndPartName(nextPropertyName,nextPropertyValue);
    String partNumber=myPartTypeAndPartNameToPartNumber.get(key);
  if (partNumber == null && nextPropertyName.equals(""String_Node_Str"")) {
    key=new PartTypeAndPartName(""String_Node_Str"",nextPropertyValue);
    partNumber=myPartTypeAndPartNameToPartNumber.get(key);
  }
if (partNumber == null && nextPropertyName.equals(""String_Node_Str"")) {
  key=new PartTypeAndPartName(""String_Node_Str"",nextPropertyValue);
  partNumber=myPartTypeAndPartNameToPartNumber.get(key);
}
if (partNumber == null && nextPropertyName.equals(""String_Node_Str"")) {
key=new PartTypeAndPartName(""String_Node_Str"",nextPropertyValue);
partNumber=myPartTypeAndPartNameToPartNumber.get(key);
}
if (partNumber == null && nextPropertyName.equals(""String_Node_Str"") && nextPropertyValue.startsWith(""String_Node_Str"")) {
continue;
}
if (isNotBlank(partNumber)) {
concept.addPropertyCoding(nextPropertyName,IHapiTerminologyLoaderSvc.LOINC_URI,partNumber,nextPropertyValue);
}
 else {
ourLog.warn(""String_Node_Str"",key.getPartType(),key.getPartName());
}
break;
case CODE:
case INTEGER:
case BOOLEAN:
case DATETIME:
case NULL:
throw new InternalErrorException(""String_Node_Str"" + nextPropertyType);
}
}
}
Validate.isTrue(!myCode2Concept.containsKey(code),""String_Node_Str"",code);
myCode2Concept.put(code,concept);
}
}","@Override public void accept(CSVRecord theRecord){
  String code=trim(theRecord.get(""String_Node_Str""));
  if (isNotBlank(code)) {
    String longCommonName=trim(theRecord.get(""String_Node_Str""));
    String shortName=trim(theRecord.get(""String_Node_Str""));
    String consumerName=trim(theRecord.get(""String_Node_Str""));
    String display=TerminologyLoaderSvcImpl.firstNonBlank(longCommonName,shortName,consumerName);
    TermConcept concept=new TermConcept(myCodeSystemVersion,code);
    concept.setDisplay(display);
    if (!display.equalsIgnoreCase(shortName)) {
      concept.addDesignation().setUseDisplay(""String_Node_Str"").setValue(shortName);
    }
    for (    String nextPropertyName : myPropertyNames.keySet()) {
      if (!theRecord.toMap().containsKey(nextPropertyName)) {
        continue;
      }
      CodeSystem.PropertyType nextPropertyType=myPropertyNames.get(nextPropertyName);
      String nextPropertyValue=theRecord.get(nextPropertyName);
      if (isNotBlank(nextPropertyValue)) {
        nextPropertyValue=trim(nextPropertyValue);
switch (nextPropertyType) {
case STRING:
          concept.addPropertyString(nextPropertyName,nextPropertyValue);
        break;
case CODING:
      PartTypeAndPartName key=new PartTypeAndPartName(nextPropertyName,nextPropertyValue);
    String partNumber=myPartTypeAndPartNameToPartNumber.get(key);
  if (partNumber == null && nextPropertyName.equals(""String_Node_Str"")) {
    key=new PartTypeAndPartName(""String_Node_Str"",nextPropertyValue);
    partNumber=myPartTypeAndPartNameToPartNumber.get(key);
  }
if (partNumber == null && nextPropertyName.equals(""String_Node_Str"")) {
  key=new PartTypeAndPartName(""String_Node_Str"",nextPropertyValue);
  partNumber=myPartTypeAndPartNameToPartNumber.get(key);
}
if (partNumber == null && nextPropertyName.equals(""String_Node_Str"")) {
key=new PartTypeAndPartName(""String_Node_Str"",nextPropertyValue);
partNumber=myPartTypeAndPartNameToPartNumber.get(key);
}
if (partNumber == null && nextPropertyName.equals(""String_Node_Str"") && nextPropertyValue.startsWith(""String_Node_Str"")) {
continue;
}
if (isNotBlank(partNumber)) {
concept.addPropertyCoding(nextPropertyName,IHapiTerminologyLoaderSvc.LOINC_URI,partNumber,nextPropertyValue);
}
 else {
ourLog.warn(""String_Node_Str"",key.getPartType(),key.getPartName());
}
break;
case DECIMAL:
case CODE:
case INTEGER:
case BOOLEAN:
case DATETIME:
case NULL:
throw new InternalErrorException(""String_Node_Str"" + nextPropertyType);
}
}
}
Validate.isTrue(!myCode2Concept.containsKey(code),""String_Node_Str"",code);
myCode2Concept.put(code,concept);
}
}",0.9972889233152596
112168,"@SuppressWarnings(""String_Node_Str"") @Override protected void initialize() throws ServletException {
  super.initialize();
  setFhirContext(ContextHolder.getCtx());
  myAppCtx=ContextLoaderListener.getCurrentWebApplicationContext();
  String resourceProviderBeanName;
  FhirVersionEnum fhirVersion=ContextHolder.getCtx().getVersion().getVersion();
switch (fhirVersion) {
case DSTU2:
    resourceProviderBeanName=""String_Node_Str"";
  break;
case DSTU3:
resourceProviderBeanName=""String_Node_Str"";
break;
case R4:
resourceProviderBeanName=""String_Node_Str"";
break;
default :
throw new IllegalStateException();
}
List<IResourceProvider> beans=myAppCtx.getBean(resourceProviderBeanName,List.class);
setResourceProviders(beans);
List<Object> systemProvider=new ArrayList<Object>();
if (fhirVersion == FhirVersionEnum.DSTU2) {
systemProvider.add(myAppCtx.getBean(""String_Node_Str"",JpaSystemProviderDstu2.class));
}
 else if (fhirVersion == FhirVersionEnum.DSTU3) {
systemProvider.add(myAppCtx.getBean(""String_Node_Str"",JpaSystemProviderDstu3.class));
systemProvider.add(myAppCtx.getBean(TerminologyUploaderProvider.class));
}
 else if (fhirVersion == FhirVersionEnum.R4) {
systemProvider.add(myAppCtx.getBean(""String_Node_Str"",JpaSystemProviderR4.class));
systemProvider.add(myAppCtx.getBean(TerminologyUploaderProvider.class));
}
 else {
throw new IllegalStateException();
}
setPlainProviders(systemProvider);
if (fhirVersion == FhirVersionEnum.DSTU2) {
IFhirSystemDao<Bundle,MetaDt> systemDao=myAppCtx.getBean(""String_Node_Str"",IFhirSystemDao.class);
JpaConformanceProviderDstu2 confProvider=new JpaConformanceProviderDstu2(this,systemDao,myAppCtx.getBean(DaoConfig.class));
confProvider.setImplementationDescription(""String_Node_Str"");
setServerConformanceProvider(confProvider);
}
 else if (fhirVersion == FhirVersionEnum.DSTU3) {
IFhirSystemDao<org.hl7.fhir.dstu3.model.Bundle,org.hl7.fhir.dstu3.model.Meta> systemDao=myAppCtx.getBean(""String_Node_Str"",IFhirSystemDao.class);
JpaConformanceProviderDstu3 confProvider=new JpaConformanceProviderDstu3(this,systemDao,myAppCtx.getBean(DaoConfig.class));
confProvider.setImplementationDescription(""String_Node_Str"");
setServerConformanceProvider(confProvider);
}
 else if (fhirVersion == FhirVersionEnum.R4) {
IFhirSystemDao<org.hl7.fhir.r4.model.Bundle,org.hl7.fhir.r4.model.Meta> systemDao=myAppCtx.getBean(""String_Node_Str"",IFhirSystemDao.class);
JpaConformanceProviderR4 confProvider=new JpaConformanceProviderR4(this,systemDao,myAppCtx.getBean(DaoConfig.class));
confProvider.setImplementationDescription(""String_Node_Str"");
setServerConformanceProvider(confProvider);
}
 else {
throw new IllegalStateException();
}
setETagSupport(ETagSupportEnum.ENABLED);
FhirContext ctx=getFhirContext();
ctx.setNarrativeGenerator(new DefaultThymeleafNarrativeGenerator());
setDefaultPrettyPrint(true);
setDefaultResponseEncoding(EncodingEnum.JSON);
setPagingProvider(new FifoMemoryPagingProvider(10));
CorsInterceptor corsInterceptor=new CorsInterceptor();
registerInterceptor(corsInterceptor);
Collection<IServerInterceptor> interceptorBeans=myAppCtx.getBeansOfType(IServerInterceptor.class).values();
for (IServerInterceptor interceptor : interceptorBeans) {
this.registerInterceptor(interceptor);
}
DaoConfig daoConfig=myAppCtx.getBean(DaoConfig.class);
daoConfig.setAllowExternalReferences(ContextHolder.isAllowExternalRefs());
daoConfig.setEnforceReferentialIntegrityOnDelete(!ContextHolder.isDisableReferentialIntegrity());
daoConfig.setEnforceReferentialIntegrityOnWrite(!ContextHolder.isDisableReferentialIntegrity());
daoConfig.setReuseCachedSearchResultsForMillis(ContextHolder.getReuseCachedSearchResultsForMillis());
}","@SuppressWarnings(""String_Node_Str"") @Override protected void initialize() throws ServletException {
  super.initialize();
  setFhirContext(ContextHolder.getCtx());
  myAppCtx=ContextLoaderListener.getCurrentWebApplicationContext();
  String resourceProviderBeanName;
  FhirVersionEnum fhirVersion=ContextHolder.getCtx().getVersion().getVersion();
switch (fhirVersion) {
case DSTU2:
    resourceProviderBeanName=""String_Node_Str"";
  break;
case DSTU3:
resourceProviderBeanName=""String_Node_Str"";
break;
case R4:
resourceProviderBeanName=""String_Node_Str"";
break;
default :
throw new IllegalStateException();
}
List<IResourceProvider> beans=myAppCtx.getBean(resourceProviderBeanName,List.class);
setResourceProviders(beans);
List<Object> systemProvider=new ArrayList<Object>();
if (fhirVersion == FhirVersionEnum.DSTU2) {
systemProvider.add(myAppCtx.getBean(""String_Node_Str"",JpaSystemProviderDstu2.class));
}
 else if (fhirVersion == FhirVersionEnum.DSTU3) {
systemProvider.add(myAppCtx.getBean(""String_Node_Str"",JpaSystemProviderDstu3.class));
systemProvider.add(myAppCtx.getBean(TerminologyUploaderProviderDstu3.class));
}
 else if (fhirVersion == FhirVersionEnum.R4) {
systemProvider.add(myAppCtx.getBean(""String_Node_Str"",JpaSystemProviderR4.class));
systemProvider.add(myAppCtx.getBean(TerminologyUploaderProviderR4.class));
}
 else {
throw new IllegalStateException();
}
setPlainProviders(systemProvider);
if (fhirVersion == FhirVersionEnum.DSTU2) {
IFhirSystemDao<Bundle,MetaDt> systemDao=myAppCtx.getBean(""String_Node_Str"",IFhirSystemDao.class);
JpaConformanceProviderDstu2 confProvider=new JpaConformanceProviderDstu2(this,systemDao,myAppCtx.getBean(DaoConfig.class));
confProvider.setImplementationDescription(""String_Node_Str"");
setServerConformanceProvider(confProvider);
}
 else if (fhirVersion == FhirVersionEnum.DSTU3) {
IFhirSystemDao<org.hl7.fhir.dstu3.model.Bundle,org.hl7.fhir.dstu3.model.Meta> systemDao=myAppCtx.getBean(""String_Node_Str"",IFhirSystemDao.class);
JpaConformanceProviderDstu3 confProvider=new JpaConformanceProviderDstu3(this,systemDao,myAppCtx.getBean(DaoConfig.class));
confProvider.setImplementationDescription(""String_Node_Str"");
setServerConformanceProvider(confProvider);
}
 else if (fhirVersion == FhirVersionEnum.R4) {
IFhirSystemDao<org.hl7.fhir.r4.model.Bundle,org.hl7.fhir.r4.model.Meta> systemDao=myAppCtx.getBean(""String_Node_Str"",IFhirSystemDao.class);
JpaConformanceProviderR4 confProvider=new JpaConformanceProviderR4(this,systemDao,myAppCtx.getBean(DaoConfig.class));
confProvider.setImplementationDescription(""String_Node_Str"");
setServerConformanceProvider(confProvider);
}
 else {
throw new IllegalStateException();
}
setETagSupport(ETagSupportEnum.ENABLED);
FhirContext ctx=getFhirContext();
ctx.setNarrativeGenerator(new DefaultThymeleafNarrativeGenerator());
setDefaultPrettyPrint(true);
setDefaultResponseEncoding(EncodingEnum.JSON);
setPagingProvider(new FifoMemoryPagingProvider(10));
CorsInterceptor corsInterceptor=new CorsInterceptor();
registerInterceptor(corsInterceptor);
Collection<IServerInterceptor> interceptorBeans=myAppCtx.getBeansOfType(IServerInterceptor.class).values();
for (IServerInterceptor interceptor : interceptorBeans) {
this.registerInterceptor(interceptor);
}
DaoConfig daoConfig=myAppCtx.getBean(DaoConfig.class);
daoConfig.setAllowExternalReferences(ContextHolder.isAllowExternalRefs());
daoConfig.setEnforceReferentialIntegrityOnDelete(!ContextHolder.isDisableReferentialIntegrity());
daoConfig.setEnforceReferentialIntegrityOnWrite(!ContextHolder.isDisableReferentialIntegrity());
daoConfig.setReuseCachedSearchResultsForMillis(ContextHolder.getReuseCachedSearchResultsForMillis());
}",0.9990461915792342
112169,"@SuppressWarnings(""String_Node_Str"") @Override protected void initialize() throws ServletException {
  super.initialize();
  WebApplicationContext parentAppCtx=ContextLoaderListener.getCurrentWebApplicationContext();
  String implDesc=getInitParameter(""String_Node_Str"");
  String fhirVersionParam=getInitParameter(""String_Node_Str"");
  if (StringUtils.isBlank(fhirVersionParam)) {
    fhirVersionParam=""String_Node_Str"";
  }
  List<IResourceProvider> beans;
  @SuppressWarnings(""String_Node_Str"") IFhirSystemDao systemDao;
  ETagSupportEnum etagSupport;
  String baseUrlProperty;
  List<Object> plainProviders=new ArrayList<Object>();
switch (fhirVersionParam.trim().toUpperCase()) {
case ""String_Node_Str"":
case ""String_Node_Str"":
{
      myAppCtx=new AnnotationConfigWebApplicationContext();
      myAppCtx.setServletConfig(getServletConfig());
      myAppCtx.setParent(parentAppCtx);
      if (""String_Node_Str"".equals(fhirVersionParam.trim().toUpperCase())) {
        myAppCtx.register(TdlDstu2Config.class);
        baseUrlProperty=FHIR_BASEURL_TDL2;
      }
 else {
        myAppCtx.register(TestDstu2Config.class,WebsocketDispatcherConfig.class);
        baseUrlProperty=FHIR_BASEURL_DSTU2;
      }
      myAppCtx.refresh();
      setFhirContext(FhirContext.forDstu2());
      beans=myAppCtx.getBean(""String_Node_Str"",List.class);
      plainProviders.add(myAppCtx.getBean(""String_Node_Str"",JpaSystemProviderDstu2.class));
      systemDao=myAppCtx.getBean(""String_Node_Str"",IFhirSystemDao.class);
      etagSupport=ETagSupportEnum.ENABLED;
      JpaConformanceProviderDstu2 confProvider=new JpaConformanceProviderDstu2(this,systemDao,myAppCtx.getBean(DaoConfig.class));
      confProvider.setImplementationDescription(implDesc);
      setServerConformanceProvider(confProvider);
      break;
    }
case ""String_Node_Str"":
case ""String_Node_Str"":
{
    myAppCtx=new AnnotationConfigWebApplicationContext();
    myAppCtx.setServletConfig(getServletConfig());
    myAppCtx.setParent(parentAppCtx);
    if (""String_Node_Str"".equals(fhirVersionParam.trim().toUpperCase())) {
      myAppCtx.register(TdlDstu3Config.class);
      baseUrlProperty=FHIR_BASEURL_TDL3;
    }
 else {
      myAppCtx.register(TestDstu3Config.class,WebsocketDispatcherConfig.class);
      baseUrlProperty=FHIR_BASEURL_DSTU3;
    }
    myAppCtx.refresh();
    setFhirContext(FhirContext.forDstu3());
    beans=myAppCtx.getBean(""String_Node_Str"",List.class);
    plainProviders.add(myAppCtx.getBean(""String_Node_Str"",JpaSystemProviderDstu3.class));
    systemDao=myAppCtx.getBean(""String_Node_Str"",IFhirSystemDao.class);
    etagSupport=ETagSupportEnum.ENABLED;
    JpaConformanceProviderDstu3 confProvider=new JpaConformanceProviderDstu3(this,systemDao,myAppCtx.getBean(DaoConfig.class));
    confProvider.setImplementationDescription(implDesc);
    setServerConformanceProvider(confProvider);
    plainProviders.add(myAppCtx.getBean(TerminologyUploaderProvider.class));
    break;
  }
case ""String_Node_Str"":
{
  myAppCtx=new AnnotationConfigWebApplicationContext();
  myAppCtx.setServletConfig(getServletConfig());
  myAppCtx.setParent(parentAppCtx);
  myAppCtx.register(TestR4Config.class,WebsocketDispatcherConfig.class);
  baseUrlProperty=FHIR_BASEURL_R4;
  myAppCtx.refresh();
  setFhirContext(FhirContext.forR4());
  beans=myAppCtx.getBean(""String_Node_Str"",List.class);
  plainProviders.add(myAppCtx.getBean(""String_Node_Str"",JpaSystemProviderR4.class));
  systemDao=myAppCtx.getBean(""String_Node_Str"",IFhirSystemDao.class);
  etagSupport=ETagSupportEnum.ENABLED;
  JpaConformanceProviderR4 confProvider=new JpaConformanceProviderR4(this,systemDao,myAppCtx.getBean(DaoConfig.class));
  confProvider.setImplementationDescription(implDesc);
  setServerConformanceProvider(confProvider);
  plainProviders.add(myAppCtx.getBean(TerminologyUploaderProvider.class));
  break;
}
default :
throw new ServletException(""String_Node_Str"" + fhirVersionParam);
}
setETagSupport(etagSupport);
FhirContext ctx=getFhirContext();
ctx.setNarrativeGenerator(new DefaultThymeleafNarrativeGenerator());
for (IResourceProvider nextResourceProvider : beans) {
ourLog.info(""String_Node_Str"",nextResourceProvider.getResourceType().getSimpleName());
}
setResourceProviders(beans);
setPlainProviders(plainProviders);
CorsInterceptor corsInterceptor=new CorsInterceptor();
registerInterceptor(corsInterceptor);
registerInterceptor(new VersionedApiConverterInterceptor());
ResponseHighlighterInterceptor responseHighlighterInterceptor=new ResponseHighlighterInterceptor();
responseHighlighterInterceptor.setShowRequestHeaders(false);
responseHighlighterInterceptor.setShowResponseHeaders(true);
registerInterceptor(responseHighlighterInterceptor);
registerInterceptor(new BanUnsupportedHttpMethodsInterceptor());
setDefaultPrettyPrint(true);
setDefaultResponseEncoding(EncodingEnum.JSON);
String baseUrl=System.getProperty(baseUrlProperty);
if (StringUtils.isBlank(baseUrl)) {
baseUrl=System.getProperty(""String_Node_Str"");
if (StringUtils.isBlank(baseUrl)) {
throw new ServletException(""String_Node_Str"" + baseUrlProperty);
}
}
setServerAddressStrategy(new MyHardcodedServerAddressStrategy(baseUrl));
setPagingProvider(myAppCtx.getBean(DatabaseBackedPagingProvider.class));
Collection<IServerInterceptor> interceptorBeans=myAppCtx.getBeansOfType(IServerInterceptor.class).values();
for (IServerInterceptor interceptor : interceptorBeans) {
this.registerInterceptor(interceptor);
}
}","@SuppressWarnings(""String_Node_Str"") @Override protected void initialize() throws ServletException {
  super.initialize();
  WebApplicationContext parentAppCtx=ContextLoaderListener.getCurrentWebApplicationContext();
  String implDesc=getInitParameter(""String_Node_Str"");
  String fhirVersionParam=getInitParameter(""String_Node_Str"");
  if (StringUtils.isBlank(fhirVersionParam)) {
    fhirVersionParam=""String_Node_Str"";
  }
  List<IResourceProvider> beans;
  @SuppressWarnings(""String_Node_Str"") IFhirSystemDao systemDao;
  ETagSupportEnum etagSupport;
  String baseUrlProperty;
  List<Object> plainProviders=new ArrayList<Object>();
switch (fhirVersionParam.trim().toUpperCase()) {
case ""String_Node_Str"":
case ""String_Node_Str"":
{
      myAppCtx=new AnnotationConfigWebApplicationContext();
      myAppCtx.setServletConfig(getServletConfig());
      myAppCtx.setParent(parentAppCtx);
      if (""String_Node_Str"".equals(fhirVersionParam.trim().toUpperCase())) {
        myAppCtx.register(TdlDstu2Config.class);
        baseUrlProperty=FHIR_BASEURL_TDL2;
      }
 else {
        myAppCtx.register(TestDstu2Config.class,WebsocketDispatcherConfig.class);
        baseUrlProperty=FHIR_BASEURL_DSTU2;
      }
      myAppCtx.refresh();
      setFhirContext(FhirContext.forDstu2());
      beans=myAppCtx.getBean(""String_Node_Str"",List.class);
      plainProviders.add(myAppCtx.getBean(""String_Node_Str"",JpaSystemProviderDstu2.class));
      systemDao=myAppCtx.getBean(""String_Node_Str"",IFhirSystemDao.class);
      etagSupport=ETagSupportEnum.ENABLED;
      JpaConformanceProviderDstu2 confProvider=new JpaConformanceProviderDstu2(this,systemDao,myAppCtx.getBean(DaoConfig.class));
      confProvider.setImplementationDescription(implDesc);
      setServerConformanceProvider(confProvider);
      break;
    }
case ""String_Node_Str"":
case ""String_Node_Str"":
{
    myAppCtx=new AnnotationConfigWebApplicationContext();
    myAppCtx.setServletConfig(getServletConfig());
    myAppCtx.setParent(parentAppCtx);
    if (""String_Node_Str"".equals(fhirVersionParam.trim().toUpperCase())) {
      myAppCtx.register(TdlDstu3Config.class);
      baseUrlProperty=FHIR_BASEURL_TDL3;
    }
 else {
      myAppCtx.register(TestDstu3Config.class,WebsocketDispatcherConfig.class);
      baseUrlProperty=FHIR_BASEURL_DSTU3;
    }
    myAppCtx.refresh();
    setFhirContext(FhirContext.forDstu3());
    beans=myAppCtx.getBean(""String_Node_Str"",List.class);
    plainProviders.add(myAppCtx.getBean(""String_Node_Str"",JpaSystemProviderDstu3.class));
    systemDao=myAppCtx.getBean(""String_Node_Str"",IFhirSystemDao.class);
    etagSupport=ETagSupportEnum.ENABLED;
    JpaConformanceProviderDstu3 confProvider=new JpaConformanceProviderDstu3(this,systemDao,myAppCtx.getBean(DaoConfig.class));
    confProvider.setImplementationDescription(implDesc);
    setServerConformanceProvider(confProvider);
    plainProviders.add(myAppCtx.getBean(TerminologyUploaderProviderDstu3.class));
    break;
  }
case ""String_Node_Str"":
{
  myAppCtx=new AnnotationConfigWebApplicationContext();
  myAppCtx.setServletConfig(getServletConfig());
  myAppCtx.setParent(parentAppCtx);
  myAppCtx.register(TestR4Config.class,WebsocketDispatcherConfig.class);
  baseUrlProperty=FHIR_BASEURL_R4;
  myAppCtx.refresh();
  setFhirContext(FhirContext.forR4());
  beans=myAppCtx.getBean(""String_Node_Str"",List.class);
  plainProviders.add(myAppCtx.getBean(""String_Node_Str"",JpaSystemProviderR4.class));
  systemDao=myAppCtx.getBean(""String_Node_Str"",IFhirSystemDao.class);
  etagSupport=ETagSupportEnum.ENABLED;
  JpaConformanceProviderR4 confProvider=new JpaConformanceProviderR4(this,systemDao,myAppCtx.getBean(DaoConfig.class));
  confProvider.setImplementationDescription(implDesc);
  setServerConformanceProvider(confProvider);
  plainProviders.add(myAppCtx.getBean(TerminologyUploaderProviderR4.class));
  break;
}
default :
throw new ServletException(""String_Node_Str"" + fhirVersionParam);
}
setETagSupport(etagSupport);
FhirContext ctx=getFhirContext();
ctx.setNarrativeGenerator(new DefaultThymeleafNarrativeGenerator());
for (IResourceProvider nextResourceProvider : beans) {
ourLog.info(""String_Node_Str"",nextResourceProvider.getResourceType().getSimpleName());
}
setResourceProviders(beans);
setPlainProviders(plainProviders);
CorsInterceptor corsInterceptor=new CorsInterceptor();
registerInterceptor(corsInterceptor);
registerInterceptor(new VersionedApiConverterInterceptor());
ResponseHighlighterInterceptor responseHighlighterInterceptor=new ResponseHighlighterInterceptor();
responseHighlighterInterceptor.setShowRequestHeaders(false);
responseHighlighterInterceptor.setShowResponseHeaders(true);
registerInterceptor(responseHighlighterInterceptor);
registerInterceptor(new BanUnsupportedHttpMethodsInterceptor());
setDefaultPrettyPrint(true);
setDefaultResponseEncoding(EncodingEnum.JSON);
String baseUrl=System.getProperty(baseUrlProperty);
if (StringUtils.isBlank(baseUrl)) {
baseUrl=System.getProperty(""String_Node_Str"");
if (StringUtils.isBlank(baseUrl)) {
throw new ServletException(""String_Node_Str"" + baseUrlProperty);
}
}
setServerAddressStrategy(new MyHardcodedServerAddressStrategy(baseUrl));
setPagingProvider(myAppCtx.getBean(DatabaseBackedPagingProvider.class));
Collection<IServerInterceptor> interceptorBeans=myAppCtx.getBeansOfType(IServerInterceptor.class).values();
for (IServerInterceptor interceptor : interceptorBeans) {
this.registerInterceptor(interceptor);
}
}",0.9993566767760316
112170,"@Override public List<IAuthRule> buildRuleList(RequestDetails theRequestDetails){
  String authHeader=theRequestDetails.getHeader(""String_Node_Str"");
  if (isBlank(authHeader)) {
    return new RuleBuilder().deny().operation().named(BaseJpaSystemProvider.MARK_ALL_RESOURCES_FOR_REINDEXING).onServer().andThen().deny().operation().named(TerminologyUploaderProvider.UPLOAD_EXTERNAL_CODE_SYSTEM).onServer().andThen().allowAll().build();
  }
  if (!authHeader.startsWith(""String_Node_Str"")) {
    throw new ForbiddenOperationException(""String_Node_Str"");
  }
  String token=authHeader.substring(""String_Node_Str"".length()).trim();
  if (!myTokens.contains(token)) {
    ourLog.error(""String_Node_Str"",token,myTokens);
    throw new ForbiddenOperationException(""String_Node_Str"");
  }
  ourLog.info(""String_Node_Str"" + token.substring(0,4) + ""String_Node_Str"");
  return new RuleBuilder().allowAll().build();
}","@Override public List<IAuthRule> buildRuleList(RequestDetails theRequestDetails){
  String authHeader=theRequestDetails.getHeader(""String_Node_Str"");
  if (isBlank(authHeader)) {
    return new RuleBuilder().deny().operation().named(BaseJpaSystemProvider.MARK_ALL_RESOURCES_FOR_REINDEXING).onServer().andThen().deny().operation().named(BaseTerminologyUploaderProvider.UPLOAD_EXTERNAL_CODE_SYSTEM).onServer().andThen().allowAll().build();
  }
  if (!authHeader.startsWith(""String_Node_Str"")) {
    throw new ForbiddenOperationException(""String_Node_Str"");
  }
  String token=authHeader.substring(""String_Node_Str"".length()).trim();
  if (!myTokens.contains(token)) {
    ourLog.error(""String_Node_Str"",token,myTokens);
    throw new ForbiddenOperationException(""String_Node_Str"");
  }
  ourLog.info(""String_Node_Str"" + token.substring(0,4) + ""String_Node_Str"");
  return new RuleBuilder().allowAll().build();
}",0.9977949283351708
112171,"private Predicate createPredicateString(IQueryParameterType theParameter,String theResourceName,String theParamName,CriteriaBuilder theBuilder,From<?,ResourceIndexedSearchParamString> theFrom){
  String rawSearchTerm;
  if (theParameter instanceof TokenParam) {
    TokenParam id=(TokenParam)theParameter;
    if (!id.isText()) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    rawSearchTerm=id.getValue();
  }
 else   if (theParameter instanceof StringParam) {
    StringParam id=(StringParam)theParameter;
    rawSearchTerm=id.getValue();
  }
 else   if (theParameter instanceof IPrimitiveDatatype<?>) {
    IPrimitiveDatatype<?> id=(IPrimitiveDatatype<?>)theParameter;
    rawSearchTerm=id.getValueAsString();
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + theParameter.getClass());
  }
  if (rawSearchTerm.length() > ResourceIndexedSearchParamString.MAX_LENGTH) {
    throw new InvalidRequestException(""String_Node_Str"" + theParamName + ""String_Node_Str""+ rawSearchTerm.length()+ ""String_Node_Str""+ ResourceIndexedSearchParamString.MAX_LENGTH+ ""String_Node_Str""+ rawSearchTerm);
  }
  String likeExpression=BaseHapiFhirDao.normalizeString(rawSearchTerm);
  likeExpression=createLeftMatchLikeExpression(likeExpression);
  Predicate singleCode=theBuilder.like(theFrom.get(""String_Node_Str"").as(String.class),likeExpression);
  if (theParameter instanceof StringParam && ((StringParam)theParameter).isExact()) {
    Predicate exactCode=theBuilder.equal(theFrom.get(""String_Node_Str""),rawSearchTerm);
    singleCode=theBuilder.and(singleCode,exactCode);
  }
  return combineParamIndexPredicateWithParamNamePredicate(theResourceName,theParamName,theFrom,singleCode);
}","private Predicate createPredicateString(IQueryParameterType theParameter,String theResourceName,String theParamName,CriteriaBuilder theBuilder,From<?,ResourceIndexedSearchParamString> theFrom){
  String rawSearchTerm;
  if (theParameter instanceof TokenParam) {
    TokenParam id=(TokenParam)theParameter;
    if (!id.isText()) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    rawSearchTerm=id.getValue();
  }
 else   if (theParameter instanceof StringParam) {
    StringParam id=(StringParam)theParameter;
    rawSearchTerm=id.getValue();
    if ((id.isContains()) && (!myCallingDao.getConfig().allowContainsSearches())) {
      throw new MethodNotAllowedException(""String_Node_Str"");
    }
  }
 else   if (theParameter instanceof IPrimitiveDatatype<?>) {
    IPrimitiveDatatype<?> id=(IPrimitiveDatatype<?>)theParameter;
    rawSearchTerm=id.getValueAsString();
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + theParameter.getClass());
  }
  if (rawSearchTerm.length() > ResourceIndexedSearchParamString.MAX_LENGTH) {
    throw new InvalidRequestException(""String_Node_Str"" + theParamName + ""String_Node_Str""+ rawSearchTerm.length()+ ""String_Node_Str""+ ResourceIndexedSearchParamString.MAX_LENGTH+ ""String_Node_Str""+ rawSearchTerm);
  }
  String likeExpression=BaseHapiFhirDao.normalizeString(rawSearchTerm);
  if (myCallingDao.getConfig().allowContainsSearches()) {
    if (theParameter instanceof StringParam) {
      if (((StringParam)theParameter).isContains()) {
        likeExpression=createLeftAndRightMatchLikeExpression(likeExpression);
      }
 else {
        likeExpression=createLeftMatchLikeExpression(likeExpression);
      }
    }
 else {
      likeExpression=createLeftMatchLikeExpression(likeExpression);
    }
  }
 else {
    likeExpression=createLeftMatchLikeExpression(likeExpression);
  }
  Predicate singleCode=theBuilder.like(theFrom.get(""String_Node_Str"").as(String.class),likeExpression);
  if (theParameter instanceof StringParam && ((StringParam)theParameter).isExact()) {
    Predicate exactCode=theBuilder.equal(theFrom.get(""String_Node_Str""),rawSearchTerm);
    singleCode=theBuilder.and(singleCode,exactCode);
  }
  return combineParamIndexPredicateWithParamNamePredicate(theResourceName,theParamName,theFrom,singleCode);
}",0.8531538269758165
112172,"@Override void doSetValueAsQueryToken(FhirContext theContext,String theParamName,String theQualifier,String theValue){
  String q=theQualifier;
  String resourceType=null;
  if (isNotBlank(q)) {
    if (q.startsWith(""String_Node_Str"")) {
      int nextIdx=q.indexOf('.');
      if (nextIdx != -1) {
        resourceType=q.substring(1,nextIdx);
        myChain=q.substring(nextIdx + 1);
      }
 else {
        resourceType=q.substring(1);
      }
    }
 else     if (q.startsWith(""String_Node_Str"")) {
      myChain=q.substring(1);
    }
  }
  setValue(theValue);
  if (isNotBlank(resourceType) && isBlank(getResourceType())) {
    setValue(resourceType + '/' + theValue);
  }
}","@Override void doSetValueAsQueryToken(FhirContext theContext,String theParamName,String theQualifier,String theValue){
  String q=theQualifier;
  String resourceType=null;
  boolean skipSetValue=false;
  if (isNotBlank(q)) {
    if (q.startsWith(""String_Node_Str"")) {
      int nextIdx=q.indexOf('.');
      if (nextIdx != -1) {
        resourceType=q.substring(1,nextIdx);
        myChain=q.substring(nextIdx + 1);
        myId.setParts(null,resourceType,theValue,null);
        skipSetValue=true;
      }
 else {
        resourceType=q.substring(1);
      }
    }
 else     if (q.startsWith(""String_Node_Str"")) {
      myChain=q.substring(1);
      myId.setParts(null,null,theValue,null);
      skipSetValue=true;
    }
  }
  if (!skipSetValue) {
    setValue(theValue);
    if (isNotBlank(resourceType) && isBlank(getResourceType())) {
      setValue(resourceType + '/' + theValue);
    }
  }
}",0.8355555555555556
112173,"@Test public void testWithResourceTypeAsQualifierAndChain(){
  ReferenceParam rp=new ReferenceParam();
  rp.setValueAsQueryToken(ourCtx,null,""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",rp.getResourceType());
  assertEquals(""String_Node_Str"",rp.getIdPart());
  assertEquals(""String_Node_Str"",rp.getQueryParameterQualifier());
  assertEquals(""String_Node_Str"",rp.getChain());
}","@Test public void testWithResourceTypeAsQualifierAndChain(){
  ReferenceParam rp=new ReferenceParam();
  rp.setValueAsQueryToken(ourCtx,null,""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",rp.getResourceType());
  assertEquals(""String_Node_Str"",rp.getIdPart());
  assertEquals(""String_Node_Str"",rp.getValue());
  assertEquals(""String_Node_Str"",rp.getQueryParameterQualifier());
  assertEquals(""String_Node_Str"",rp.getChain());
}",0.9425556858147714
112174,"@Test public void testWithResourceTypeAsQualifier(){
  ReferenceParam rp=new ReferenceParam();
  rp.setValueAsQueryToken(ourCtx,null,""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",rp.getResourceType());
  assertEquals(""String_Node_Str"",rp.getIdPart());
  assertEquals(null,rp.getQueryParameterQualifier());
}","@Test public void testWithResourceTypeAsQualifier(){
  ReferenceParam rp=new ReferenceParam();
  rp.setValueAsQueryToken(ourCtx,null,""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",rp.getResourceType());
  assertEquals(""String_Node_Str"",rp.getIdPart());
  assertEquals(""String_Node_Str"",rp.getValue());
  assertEquals(null,rp.getQueryParameterQualifier());
}",0.9312762973352032
112175,"@Test public void testWithResourceType(){
  ReferenceParam rp=new ReferenceParam();
  rp.setValueAsQueryToken(ourCtx,null,null,""String_Node_Str"");
  assertEquals(""String_Node_Str"",rp.getResourceType());
  assertEquals(""String_Node_Str"",rp.getIdPart());
  assertEquals(null,rp.getQueryParameterQualifier());
}","@Test public void testWithResourceType(){
  ReferenceParam rp=new ReferenceParam();
  rp.setValueAsQueryToken(ourCtx,null,null,""String_Node_Str"");
  assertEquals(""String_Node_Str"",rp.getResourceType());
  assertEquals(""String_Node_Str"",rp.getIdPart());
  assertEquals(""String_Node_Str"",rp.getValue());
  assertEquals(null,rp.getQueryParameterQualifier());
}",0.9263157894736842
112176,"private <T>T doXmlLoop(XMLEventReader streamReader,ParserState<T> parserState){
  ourLog.trace(""String_Node_Str"",parserState);
  try {
    List<String> heldComments=new ArrayList<String>(1);
    while (streamReader.hasNext()) {
      XMLEvent nextEvent=streamReader.nextEvent();
      try {
switch (nextEvent.getEventType()) {
case XMLStreamConstants.START_ELEMENT:
{
            StartElement elem=nextEvent.asStartElement();
            String namespaceURI=elem.getName().getNamespaceURI();
            if (""String_Node_Str"".equals(elem.getName().getLocalPart())) {
              Attribute urlAttr=elem.getAttributeByName(new QName(""String_Node_Str""));
              String url;
              if (urlAttr == null || isBlank(urlAttr.getValue())) {
                getErrorHandler().missingRequiredElement(new ParseLocation(""String_Node_Str""),""String_Node_Str"");
                url=null;
              }
 else {
                url=urlAttr.getValue();
              }
              parserState.enteringNewElementExtension(elem,url,false,getServerBaseUrl());
            }
 else             if (""String_Node_Str"".equals(elem.getName().getLocalPart())) {
              Attribute urlAttr=elem.getAttributeByName(new QName(""String_Node_Str""));
              String url;
              if (urlAttr == null || isBlank(urlAttr.getValue())) {
                getErrorHandler().missingRequiredElement(new ParseLocation(""String_Node_Str""),""String_Node_Str"");
                url=null;
              }
 else {
                url=urlAttr.getValue();
              }
              parserState.enteringNewElementExtension(elem,url,true,getServerBaseUrl());
            }
 else {
              String elementName=elem.getName().getLocalPart();
              parserState.enteringNewElement(namespaceURI,elementName);
            }
            if (!heldComments.isEmpty()) {
              for (              String next : heldComments) {
                parserState.commentPre(next);
              }
              heldComments.clear();
            }
            @SuppressWarnings(""String_Node_Str"") Iterator<Attribute> attributes=elem.getAttributes();
            for (Iterator<Attribute> iter=attributes; iter.hasNext(); ) {
              Attribute next=iter.next();
              parserState.attributeValue(next.getName().getLocalPart(),next.getValue());
            }
            break;
          }
case XMLStreamConstants.END_DOCUMENT:
case XMLStreamConstants.END_ELEMENT:
{
          if (!heldComments.isEmpty()) {
            for (            String next : heldComments) {
              parserState.commentPost(next);
            }
            heldComments.clear();
          }
          parserState.endingElement();
          break;
        }
case XMLStreamConstants.CHARACTERS:
{
        parserState.string(nextEvent.asCharacters().getData());
        break;
      }
case XMLStreamConstants.COMMENT:
{
      Comment comment=(Comment)nextEvent;
      String commentText=comment.getText();
      heldComments.add(commentText);
      break;
    }
}
parserState.xmlEvent(nextEvent);
}
 catch (DataFormatException e) {
throw new DataFormatException(""String_Node_Str"" + nextEvent.getLocation().toString() + ""String_Node_Str""+ e.getMessage(),e);
}
}
return parserState.getObject();
}
 catch (XMLStreamException e) {
throw new DataFormatException(e);
}
}","private <T>T doXmlLoop(XMLEventReader streamReader,ParserState<T> parserState){
  ourLog.trace(""String_Node_Str"",parserState);
  try {
    List<String> heldComments=new ArrayList<String>(1);
    while (streamReader.hasNext()) {
      XMLEvent nextEvent=streamReader.nextEvent();
      try {
switch (nextEvent.getEventType()) {
case XMLStreamConstants.START_ELEMENT:
{
            StartElement elem=nextEvent.asStartElement();
            String namespaceURI=elem.getName().getNamespaceURI();
            if (""String_Node_Str"".equals(elem.getName().getLocalPart())) {
              Attribute urlAttr=elem.getAttributeByName(new QName(""String_Node_Str""));
              String url;
              if (urlAttr == null || isBlank(urlAttr.getValue())) {
                getErrorHandler().missingRequiredElement(new ParseLocation().setParentElementName(""String_Node_Str""),""String_Node_Str"");
                url=null;
              }
 else {
                url=urlAttr.getValue();
              }
              parserState.enteringNewElementExtension(elem,url,false,getServerBaseUrl());
            }
 else             if (""String_Node_Str"".equals(elem.getName().getLocalPart())) {
              Attribute urlAttr=elem.getAttributeByName(new QName(""String_Node_Str""));
              String url;
              if (urlAttr == null || isBlank(urlAttr.getValue())) {
                getErrorHandler().missingRequiredElement(new ParseLocation().setParentElementName(""String_Node_Str""),""String_Node_Str"");
                url=null;
              }
 else {
                url=urlAttr.getValue();
              }
              parserState.enteringNewElementExtension(elem,url,true,getServerBaseUrl());
            }
 else {
              String elementName=elem.getName().getLocalPart();
              parserState.enteringNewElement(namespaceURI,elementName);
            }
            if (!heldComments.isEmpty()) {
              for (              String next : heldComments) {
                parserState.commentPre(next);
              }
              heldComments.clear();
            }
            @SuppressWarnings(""String_Node_Str"") Iterator<Attribute> attributes=elem.getAttributes();
            for (Iterator<Attribute> iter=attributes; iter.hasNext(); ) {
              Attribute next=iter.next();
              parserState.attributeValue(next.getName().getLocalPart(),next.getValue());
            }
            break;
          }
case XMLStreamConstants.END_DOCUMENT:
case XMLStreamConstants.END_ELEMENT:
{
          if (!heldComments.isEmpty()) {
            for (            String next : heldComments) {
              parserState.commentPost(next);
            }
            heldComments.clear();
          }
          parserState.endingElement();
          break;
        }
case XMLStreamConstants.CHARACTERS:
{
        parserState.string(nextEvent.asCharacters().getData());
        break;
      }
case XMLStreamConstants.COMMENT:
{
      Comment comment=(Comment)nextEvent;
      String commentText=comment.getText();
      heldComments.add(commentText);
      break;
    }
}
parserState.xmlEvent(nextEvent);
}
 catch (DataFormatException e) {
throw new DataFormatException(""String_Node_Str"" + nextEvent.getLocation().toString() + ""String_Node_Str""+ e.getMessage(),e);
}
}
return parserState.getObject();
}
 catch (XMLStreamException e) {
throw new DataFormatException(e);
}
}",0.993154761904762
112177,"@PostConstruct public void start(){
  for (  IFhirResourceDao<?> next : myResourceDaos) {
    if (myCtx.getResourceDefinition(next.getResourceType()).getName().equals(""String_Node_Str"")) {
      mySubscriptionDao=next;
    }
  }
  Validate.notNull(mySubscriptionDao);
  if (myCtx.getVersion().getVersion() == FhirVersionEnum.R4) {
    Validate.notNull(myEventDefinitionDaoR4);
  }
  if (getProcessingChannel() == null) {
    myProcessingExecutorQueue=new LinkedBlockingQueue<>(1000);
    RejectedExecutionHandler rejectedExecutionHandler=new RejectedExecutionHandler(){
      @Override public void rejectedExecution(      Runnable theRunnable,      ThreadPoolExecutor theExecutor){
        ourLog.info(""String_Node_Str"",myProcessingExecutorQueue.size());
        StopWatch sw=new StopWatch();
        try {
          myProcessingExecutorQueue.put(theRunnable);
        }
 catch (        InterruptedException theE) {
          throw new RejectedExecutionException(""String_Node_Str"" + theRunnable.toString() + ""String_Node_Str""+ theE.toString());
        }
        ourLog.info(""String_Node_Str"",sw.getMillis());
      }
    }
;
    ThreadFactory threadFactory=new BasicThreadFactory.Builder().namingPattern(""String_Node_Str"").daemon(false).priority(Thread.NORM_PRIORITY).build();
    myProcessingExecutor=new ThreadPoolExecutor(1,getExecutorThreadCount(),0L,TimeUnit.MILLISECONDS,myProcessingExecutorQueue,threadFactory,rejectedExecutionHandler);
    setProcessingChannel(new ExecutorSubscribableChannel(myProcessingExecutor));
  }
  if (getDeliveryChannel() == null) {
    myDeliveryExecutorQueue=new LinkedBlockingQueue<>(1000);
    BasicThreadFactory threadFactory=new BasicThreadFactory.Builder().namingPattern(""String_Node_Str"").daemon(false).priority(Thread.NORM_PRIORITY).build();
    RejectedExecutionHandler rejectedExecutionHandler=new RejectedExecutionHandler(){
      @Override public void rejectedExecution(      Runnable theRunnable,      ThreadPoolExecutor theExecutor){
        ourLog.info(""String_Node_Str"",myDeliveryExecutorQueue.size());
        StopWatch sw=new StopWatch();
        try {
          myDeliveryExecutorQueue.put(theRunnable);
        }
 catch (        InterruptedException theE) {
          throw new RejectedExecutionException(""String_Node_Str"" + theRunnable.toString() + ""String_Node_Str""+ theE.toString());
        }
        ourLog.info(""String_Node_Str"",sw.getMillis());
      }
    }
;
    myDeliveryExecutor=new ThreadPoolExecutor(1,getExecutorThreadCount(),0L,TimeUnit.MILLISECONDS,myDeliveryExecutorQueue,threadFactory,rejectedExecutionHandler);
    setDeliveryChannel(new ExecutorSubscribableChannel(myDeliveryExecutor));
  }
  if (mySubscriptionActivatingSubscriber == null) {
    mySubscriptionActivatingSubscriber=new SubscriptionActivatingSubscriber(getSubscriptionDao(),getChannelType(),this,myTxManager);
  }
  registerSubscriptionCheckingSubscriber();
  registerDeliverySubscriber();
  TransactionTemplate transactionTemplate=new TransactionTemplate(myTxManager);
  transactionTemplate.execute(new TransactionCallbackWithoutResult(){
    @Override protected void doInTransactionWithoutResult(    TransactionStatus status){
      initSubscriptions();
    }
  }
);
}","@PostConstruct public void start(){
  for (  IFhirResourceDao<?> next : myResourceDaos) {
    if (myCtx.getResourceDefinition(next.getResourceType()).getName().equals(""String_Node_Str"")) {
      mySubscriptionDao=next;
    }
  }
  Validate.notNull(mySubscriptionDao);
  if (myCtx.getVersion().getVersion() == FhirVersionEnum.R4) {
    Validate.notNull(myEventDefinitionDaoR4);
  }
  if (getProcessingChannel() == null) {
    myProcessingExecutorQueue=new LinkedBlockingQueue<>(1000);
    RejectedExecutionHandler rejectedExecutionHandler=new RejectedExecutionHandler(){
      @Override public void rejectedExecution(      Runnable theRunnable,      ThreadPoolExecutor theExecutor){
        ourLog.info(""String_Node_Str"",myProcessingExecutorQueue.size());
        StopWatch sw=new StopWatch();
        try {
          myProcessingExecutorQueue.put(theRunnable);
        }
 catch (        InterruptedException theE) {
          throw new RejectedExecutionException(""String_Node_Str"" + theRunnable.toString() + ""String_Node_Str""+ theE.toString());
        }
        ourLog.info(""String_Node_Str"",sw.getMillis());
      }
    }
;
    ThreadFactory threadFactory=new BasicThreadFactory.Builder().namingPattern(""String_Node_Str"").daemon(false).priority(Thread.NORM_PRIORITY).build();
    myProcessingExecutor=new ThreadPoolExecutor(1,getExecutorThreadCount(),0L,TimeUnit.MILLISECONDS,myProcessingExecutorQueue,threadFactory,rejectedExecutionHandler);
    setProcessingChannel(new ExecutorSubscribableChannel(myProcessingExecutor));
  }
  if (getDeliveryChannel() == null) {
    myDeliveryExecutorQueue=new LinkedBlockingQueue<>(1000);
    BasicThreadFactory threadFactory=new BasicThreadFactory.Builder().namingPattern(""String_Node_Str"").daemon(false).priority(Thread.NORM_PRIORITY).build();
    RejectedExecutionHandler rejectedExecutionHandler=new RejectedExecutionHandler(){
      @Override public void rejectedExecution(      Runnable theRunnable,      ThreadPoolExecutor theExecutor){
        ourLog.info(""String_Node_Str"",myDeliveryExecutorQueue.size());
        StopWatch sw=new StopWatch();
        try {
          myDeliveryExecutorQueue.put(theRunnable);
        }
 catch (        InterruptedException theE) {
          throw new RejectedExecutionException(""String_Node_Str"" + theRunnable.toString() + ""String_Node_Str""+ theE.toString());
        }
        ourLog.info(""String_Node_Str"",sw.getMillis());
      }
    }
;
    myDeliveryExecutor=new ThreadPoolExecutor(1,getExecutorThreadCount(),0L,TimeUnit.MILLISECONDS,myDeliveryExecutorQueue,threadFactory,rejectedExecutionHandler);
    setDeliveryChannel(new ExecutorSubscribableChannel(myDeliveryExecutor));
  }
  if (mySubscriptionActivatingSubscriber == null) {
    mySubscriptionActivatingSubscriber=new SubscriptionActivatingSubscriber(getSubscriptionDao(),getChannelType(),this,myTxManager,myAsyncTaskExecutor);
  }
  registerSubscriptionCheckingSubscriber();
  registerDeliverySubscriber();
  TransactionTemplate transactionTemplate=new TransactionTemplate(myTxManager);
  transactionTemplate.execute(new TransactionCallbackWithoutResult(){
    @Override protected void doInTransactionWithoutResult(    TransactionStatus status){
      initSubscriptions();
    }
  }
);
}",0.9968973006515668
112178,"/** 
 * Constructor
 */
public SubscriptionActivatingSubscriber(IFhirResourceDao<? extends IBaseResource> theSubscriptionDao,Subscription.SubscriptionChannelType theChannelType,BaseSubscriptionInterceptor theSubscriptionInterceptor,PlatformTransactionManager theTransactionManager){
  mySubscriptionDao=theSubscriptionDao;
  mySubscriptionInterceptor=theSubscriptionInterceptor;
  myChannelType=theChannelType;
  myCtx=theSubscriptionDao.getContext();
  myTransactionManager=theTransactionManager;
}","/** 
 * Constructor
 */
public SubscriptionActivatingSubscriber(IFhirResourceDao<? extends IBaseResource> theSubscriptionDao,Subscription.SubscriptionChannelType theChannelType,BaseSubscriptionInterceptor theSubscriptionInterceptor,PlatformTransactionManager theTransactionManager,AsyncTaskExecutor theTaskExecutor){
  mySubscriptionDao=theSubscriptionDao;
  mySubscriptionInterceptor=theSubscriptionInterceptor;
  myChannelType=theChannelType;
  myCtx=theSubscriptionDao.getContext();
  myTransactionManager=theTransactionManager;
  myTaskExecutor=theTaskExecutor;
  Validate.notNull(theTaskExecutor);
}",0.9048050770625566
112179,"public void activateAndRegisterSubscriptionIfRequired(final IBaseResource theSubscription){
  boolean subscriptionTypeApplies=BaseSubscriptionSubscriber.subscriptionTypeApplies(myCtx,theSubscription,myChannelType);
  if (subscriptionTypeApplies == false) {
    return;
  }
  final IPrimitiveType<?> status=myCtx.newTerser().getSingleValueOrNull(theSubscription,BaseSubscriptionInterceptor.SUBSCRIPTION_STATUS,IPrimitiveType.class);
  String statusString=status.getValueAsString();
  final String requestedStatus=Subscription.SubscriptionStatus.REQUESTED.toCode();
  final String activeStatus=Subscription.SubscriptionStatus.ACTIVE.toCode();
  if (requestedStatus.equals(statusString)) {
    if (TransactionSynchronizationManager.isSynchronizationActive()) {
      TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter(){
        @Override public void afterCommit(){
          activateSubscription(status,activeStatus,theSubscription,requestedStatus);
        }
      }
);
    }
 else {
      activateSubscription(status,activeStatus,theSubscription,requestedStatus);
    }
  }
 else   if (activeStatus.equals(statusString)) {
    if (!mySubscriptionInterceptor.hasSubscription(theSubscription.getIdElement())) {
      ourLog.info(""String_Node_Str"",theSubscription.getIdElement().toUnqualified().getValue());
    }
    mySubscriptionInterceptor.registerSubscription(theSubscription.getIdElement(),theSubscription);
  }
 else {
    if (mySubscriptionInterceptor.hasSubscription(theSubscription.getIdElement())) {
      ourLog.info(""String_Node_Str"",statusString,theSubscription.getIdElement().toUnqualified().getValue());
    }
    mySubscriptionInterceptor.unregisterSubscription(theSubscription.getIdElement());
  }
}","public void activateAndRegisterSubscriptionIfRequired(final IBaseResource theSubscription){
  boolean subscriptionTypeApplies=BaseSubscriptionSubscriber.subscriptionTypeApplies(myCtx,theSubscription,myChannelType);
  if (subscriptionTypeApplies == false) {
    return;
  }
  final IPrimitiveType<?> status=myCtx.newTerser().getSingleValueOrNull(theSubscription,BaseSubscriptionInterceptor.SUBSCRIPTION_STATUS,IPrimitiveType.class);
  String statusString=status.getValueAsString();
  final String requestedStatus=Subscription.SubscriptionStatus.REQUESTED.toCode();
  final String activeStatus=Subscription.SubscriptionStatus.ACTIVE.toCode();
  if (requestedStatus.equals(statusString)) {
    if (TransactionSynchronizationManager.isSynchronizationActive()) {
      TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter(){
        @Override public void afterCommit(){
          Future<?> activationFuture=myTaskExecutor.submit(new Runnable(){
            @Override public void run(){
              activateSubscription(activeStatus,theSubscription,requestedStatus);
            }
          }
);
          if (ourWaitForSubscriptionActivationSynchronouslyForUnitTest) {
            try {
              activationFuture.get(5,TimeUnit.SECONDS);
            }
 catch (            Exception e) {
              ourLog.error(""String_Node_Str"",e);
            }
          }
        }
      }
);
    }
 else {
      activateSubscription(activeStatus,theSubscription,requestedStatus);
    }
  }
 else   if (activeStatus.equals(statusString)) {
    if (!mySubscriptionInterceptor.hasSubscription(theSubscription.getIdElement())) {
      ourLog.info(""String_Node_Str"",theSubscription.getIdElement().toUnqualified().getValue());
    }
    mySubscriptionInterceptor.registerSubscription(theSubscription.getIdElement(),theSubscription);
  }
 else {
    if (mySubscriptionInterceptor.hasSubscription(theSubscription.getIdElement())) {
      ourLog.info(""String_Node_Str"",statusString,theSubscription.getIdElement().toUnqualified().getValue());
    }
    mySubscriptionInterceptor.unregisterSubscription(theSubscription.getIdElement());
  }
}",0.8662420382165605
112180,"@Override public void afterCommit(){
  activateSubscription(status,activeStatus,theSubscription,requestedStatus);
}","@Override public void afterCommit(){
  Future<?> activationFuture=myTaskExecutor.submit(new Runnable(){
    @Override public void run(){
      activateSubscription(activeStatus,theSubscription,requestedStatus);
    }
  }
);
  if (ourWaitForSubscriptionActivationSynchronouslyForUnitTest) {
    try {
      activationFuture.get(5,TimeUnit.SECONDS);
    }
 catch (    Exception e) {
      ourLog.error(""String_Node_Str"",e);
    }
  }
}",0.1861313868613138
112181,"private void activateSubscription(IPrimitiveType<?> theStatus,String theActiveStatus,final IBaseResource theSubscription,String theRequestedStatus){
  theStatus.setValueAsString(theActiveStatus);
  ourLog.info(""String_Node_Str"",theSubscription.getIdElement().toUnqualified().getValue(),theRequestedStatus,theActiveStatus);
  try {
    mySubscriptionDao.update(theSubscription);
  }
 catch (  final UnprocessableEntityException e) {
    ourLog.info(""String_Node_Str"",theSubscription.getIdElement());
    IBaseResource subscription=mySubscriptionDao.read(theSubscription.getIdElement());
    SubscriptionUtil.setStatus(myCtx,subscription,""String_Node_Str"");
    SubscriptionUtil.setReason(myCtx,subscription,e.getMessage());
    mySubscriptionDao.update(subscription);
  }
}","private void activateSubscription(String theActiveStatus,final IBaseResource theSubscription,String theRequestedStatus){
  IBaseResource subscription=mySubscriptionDao.read(theSubscription.getIdElement());
  ourLog.info(""String_Node_Str"",subscription.getIdElement().toUnqualified().getValue(),theRequestedStatus,theActiveStatus);
  try {
    SubscriptionUtil.setStatus(myCtx,subscription,theActiveStatus);
    mySubscriptionDao.update(subscription);
    mySubscriptionInterceptor.registerSubscription(subscription.getIdElement(),subscription);
  }
 catch (  final UnprocessableEntityException e) {
    ourLog.info(""String_Node_Str"",subscription.getIdElement());
    SubscriptionUtil.setStatus(myCtx,subscription,""String_Node_Str"");
    SubscriptionUtil.setReason(myCtx,subscription,e.getMessage());
    mySubscriptionDao.update(subscription);
  }
}",0.608641975308642
112182,"@Bean() public BasicDataSource basicDataSource(){
  BasicDataSource retVal=new BasicDataSource(){
    @Override public Connection getConnection() throws SQLException {
      ConnectionWrapper retVal;
      try {
        retVal=new ConnectionWrapper(super.getConnection());
      }
 catch (      Exception e) {
        ourLog.error(""String_Node_Str"",e);
        logGetConnectionStackTrace();
        fail(""String_Node_Str"" + e.toString());
        retVal=null;
      }
      try {
        throw new Exception();
      }
 catch (      Exception e) {
        myLastStackTrace=e;
      }
      return retVal;
    }
    private void logGetConnectionStackTrace(){
      StringBuilder b=new StringBuilder();
      b.append(""String_Node_Str"");
      for (      StackTraceElement next : myLastStackTrace.getStackTrace()) {
        b.append(""String_Node_Str"");
        b.append(next.getClassName());
        b.append(""String_Node_Str"");
        b.append(next.getMethodName());
        b.append(""String_Node_Str"");
        b.append(next.getFileName());
        b.append(""String_Node_Str"");
        b.append(next.getLineNumber());
        b.append(""String_Node_Str"");
      }
      ourLog.info(b.toString());
    }
  }
;
  retVal.setDriver(new org.apache.derby.jdbc.EmbeddedDriver());
  retVal.setUrl(""String_Node_Str"");
  retVal.setMaxWaitMillis(10000);
  retVal.setUsername(""String_Node_Str"");
  retVal.setPassword(""String_Node_Str"");
  int maxThreads=(int)(Math.random() * 6.0) + 1;
  maxThreads=1;
  retVal.setMaxTotal(maxThreads);
  return retVal;
}","@Bean() public BasicDataSource basicDataSource(){
  BasicDataSource retVal=new BasicDataSource(){
    @Override public Connection getConnection(){
      ConnectionWrapper retVal;
      try {
        retVal=new ConnectionWrapper(super.getConnection());
      }
 catch (      Exception e) {
        ourLog.error(""String_Node_Str"",e);
        logGetConnectionStackTrace();
        fail(""String_Node_Str"" + e.toString());
        retVal=null;
      }
      try {
        throw new Exception();
      }
 catch (      Exception e) {
        myLastStackTrace=e;
      }
      return retVal;
    }
    private void logGetConnectionStackTrace(){
      StringBuilder b=new StringBuilder();
      b.append(""String_Node_Str"");
      for (      StackTraceElement next : myLastStackTrace.getStackTrace()) {
        b.append(""String_Node_Str"");
        b.append(next.getClassName());
        b.append(""String_Node_Str"");
        b.append(next.getMethodName());
        b.append(""String_Node_Str"");
        b.append(next.getFileName());
        b.append(""String_Node_Str"");
        b.append(next.getLineNumber());
        b.append(""String_Node_Str"");
      }
      ourLog.info(b.toString());
    }
  }
;
  retVal.setDriver(new org.apache.derby.jdbc.EmbeddedDriver());
  retVal.setUrl(""String_Node_Str"");
  retVal.setMaxWaitMillis(10000);
  retVal.setUsername(""String_Node_Str"");
  retVal.setPassword(""String_Node_Str"");
  int maxThreads=(int)(Math.random() * 6.0) + 1;
  maxThreads=1;
  retVal.setMaxTotal(maxThreads);
  return retVal;
}",0.9931439764936336
112183,"@Override public Connection getConnection() throws SQLException {
  ConnectionWrapper retVal;
  try {
    retVal=new ConnectionWrapper(super.getConnection());
  }
 catch (  Exception e) {
    ourLog.error(""String_Node_Str"",e);
    logGetConnectionStackTrace();
    fail(""String_Node_Str"" + e.toString());
    retVal=null;
  }
  try {
    throw new Exception();
  }
 catch (  Exception e) {
    myLastStackTrace=e;
  }
  return retVal;
}","@Override public Connection getConnection(){
  ConnectionWrapper retVal;
  try {
    retVal=new ConnectionWrapper(super.getConnection());
  }
 catch (  Exception e) {
    ourLog.error(""String_Node_Str"",e);
    logGetConnectionStackTrace();
    fail(""String_Node_Str"" + e.toString());
    retVal=null;
  }
  try {
    throw new Exception();
  }
 catch (  Exception e) {
    myLastStackTrace=e;
  }
  return retVal;
}",0.9753231492361928
112184,"@After public void afterResetDao(){
  myDaoConfig.setResourceServerIdStrategy(new DaoConfig().getResourceServerIdStrategy());
  BaseHapiFhirDao.setValidationDisabledForUnitTest(false);
}","@After public void afterResetDao(){
  SubscriptionActivatingSubscriber.setWaitForSubscriptionActivationSynchronouslyForUnitTest(false);
  myDaoConfig.setResourceServerIdStrategy(new DaoConfig().getResourceServerIdStrategy());
  BaseHapiFhirDao.setValidationDisabledForUnitTest(false);
}",0.788135593220339
112185,"public boolean matchesInclude(Include theInclude){
  if (theInclude.getValue().equals(""String_Node_Str"")) {
    return true;
  }
  int colonIndex=theInclude.getValue().indexOf(':');
  if (colonIndex != -1) {
    String resourceName=theInclude.getValue().substring(0,colonIndex);
    String paramName=theInclude.getValue().substring(colonIndex + 1);
    RuntimeResourceDefinition resourceDef=myContext.getResourceDefinition(resourceName);
    if (resourceDef != null) {
      RuntimeSearchParam searchParamDef=resourceDef.getSearchParam(paramName);
      if (searchParamDef != null) {
        if (searchParamDef.getPathsSplit().contains(myOwningResource + ""String_Node_Str"" + myName)) {
          return true;
        }
      }
    }
    return false;
  }
  return (theInclude.getValue().equals(myOwningResource + '.' + myName));
}","public boolean matchesInclude(Include theInclude){
  if (theInclude.getValue().equals(""String_Node_Str"")) {
    return true;
  }
  int colonIndex=theInclude.getValue().indexOf(':');
  if (colonIndex != -1) {
    String resourceName=theInclude.getValue().substring(0,colonIndex);
    String paramName=theInclude.getValue().substring(colonIndex + 1);
    RuntimeResourceDefinition resourceDef=myContext.getResourceDefinition(resourceName);
    if (resourceDef != null) {
      RuntimeSearchParam searchParamDef=resourceDef.getSearchParam(paramName);
      if (searchParamDef != null) {
        final String myCompleteName=myOwningResource + ""String_Node_Str"" + myName;
        boolean matched=false;
        for (        String s : searchParamDef.getPathsSplit()) {
          if (s.equals(myCompleteName) || s.startsWith(myCompleteName + ""String_Node_Str"")) {
            matched=true;
            break;
          }
        }
        return matched;
      }
    }
    return false;
  }
  return (theInclude.getValue().equals(myOwningResource + '.' + myName));
}",0.8201058201058201
112186,"@Override public int hashCode(){
  HashCodeBuilder b=new HashCodeBuilder();
  b.append(getParamName());
  b.append(getResource());
  b.append(getValueHigh());
  b.append(getValueLow());
  return b.toHashCode();
}","@Override public int hashCode(){
  HashCodeBuilder b=new HashCodeBuilder();
  b.append(getParamName());
  b.append(getResource());
  b.append(getTimeFromDate(getValueHigh()));
  b.append(getTimeFromDate(getValueLow()));
  return b.toHashCode();
}",0.8733624454148472
112187,"@Override public boolean equals(Object theObj){
  if (this == theObj) {
    return true;
  }
  if (theObj == null) {
    return false;
  }
  if (!(theObj instanceof ResourceIndexedSearchParamDate)) {
    return false;
  }
  ResourceIndexedSearchParamDate obj=(ResourceIndexedSearchParamDate)theObj;
  EqualsBuilder b=new EqualsBuilder();
  b.append(getParamName(),obj.getParamName());
  b.append(getResource(),obj.getResource());
  b.append(getValueHigh(),obj.getValueHigh());
  b.append(getValueLow(),obj.getValueLow());
  return b.isEquals();
}","@Override public boolean equals(Object theObj){
  if (this == theObj) {
    return true;
  }
  if (theObj == null) {
    return false;
  }
  if (!(theObj instanceof ResourceIndexedSearchParamDate)) {
    return false;
  }
  ResourceIndexedSearchParamDate obj=(ResourceIndexedSearchParamDate)theObj;
  EqualsBuilder b=new EqualsBuilder();
  b.append(getParamName(),obj.getParamName());
  b.append(getResource(),obj.getResource());
  b.append(getTimeFromDate(getValueHigh()),getTimeFromDate(obj.getValueHigh()));
  b.append(getTimeFromDate(getValueLow()),getTimeFromDate(obj.getValueLow()));
  return b.isEquals();
}",0.9206896551724136
112188,"/** 
 * This method will retrieve the conformance using the http GET method
 * @return the response containing the conformance
 */
@GET @Path(""String_Node_Str"") public Response conformance() throws IOException {
  Builder request=getRequest(RequestTypeEnum.OPTIONS,RestOperationTypeEnum.METADATA);
  IRestfulResponse response=request.build().getResponse();
  response.addHeader(Constants.HEADER_CORS_ALLOW_ORIGIN,""String_Node_Str"");
  IBaseResource conformance=null;
  if (super.getFhirContext().getVersion().getVersion().equals(FhirVersionEnum.R4)) {
    conformance=myR4CapabilityStatement;
  }
 else   if (super.getFhirContext().getVersion().getVersion().equals(FhirVersionEnum.DSTU3)) {
    conformance=myDstu3CapabilityStatement;
  }
 else   if (super.getFhirContext().getVersion().getVersion().equals(FhirVersionEnum.DSTU2_1)) {
    conformance=myDstu2_1Conformance;
  }
 else   if (super.getFhirContext().getVersion().getVersion().equals(FhirVersionEnum.DSTU2)) {
    conformance=myDstu2Conformance;
  }
 else   if (super.getFhirContext().getVersion().getVersion().equals(FhirVersionEnum.DSTU2_HL7ORG)) {
    conformance=myDstu2Hl7OrgConformance;
  }
  if (conformance != null) {
    Set<SummaryEnum> summaryMode=Collections.emptySet();
    return (Response)response.streamResponseAsResource(conformance,false,summaryMode,Constants.STATUS_HTTP_200_OK,null,true,false);
  }
  return (Response)response.returnResponse(null,Constants.STATUS_HTTP_500_INTERNAL_ERROR,true,null,getResourceType().getSimpleName());
}","/** 
 * This method will retrieve the conformance using the http GET method
 * @return the response containing the conformance
 */
@GET @Path(""String_Node_Str"") public Response conformance() throws IOException {
  Builder request=getRequest(RequestTypeEnum.OPTIONS,RestOperationTypeEnum.METADATA);
  IRestfulResponse response=request.build().getResponse();
  response.addHeader(Constants.HEADER_CORS_ALLOW_ORIGIN,""String_Node_Str"");
  IBaseResource conformance;
  FhirVersionEnum fhirContextVersion=super.getFhirContext().getVersion().getVersion();
switch (fhirContextVersion) {
case R4:
    conformance=myR4CapabilityStatement;
  break;
case DSTU3:
conformance=myDstu3CapabilityStatement;
break;
case DSTU2_1:
conformance=myDstu2_1Conformance;
break;
case DSTU2_HL7ORG:
conformance=myDstu2Hl7OrgConformance;
break;
case DSTU2:
conformance=myDstu2Conformance;
break;
default :
throw new ConfigurationException(""String_Node_Str"" + fhirContextVersion);
}
if (conformance != null) {
Set<SummaryEnum> summaryMode=Collections.emptySet();
return (Response)response.streamResponseAsResource(conformance,false,summaryMode,Constants.STATUS_HTTP_200_OK,null,true,false);
}
return (Response)response.returnResponse(null,Constants.STATUS_HTTP_500_INTERNAL_ERROR,true,null,getResourceType().getSimpleName());
}",0.7422680412371134
112189,"@SuppressWarnings(""String_Node_Str"") @Override public Class<IBaseResource> getResourceType(){
  if (super.getFhirContext().getVersion().getVersion().equals(FhirVersionEnum.R4)) {
    return Class.class.cast(org.hl7.fhir.r4.model.CapabilityStatement.class);
  }
 else   if (super.getFhirContext().getVersion().getVersion().equals(FhirVersionEnum.DSTU3)) {
    return Class.class.cast(CapabilityStatement.class);
  }
 else   if (super.getFhirContext().getVersion().getVersion().equals(FhirVersionEnum.DSTU2_1)) {
    return Class.class.cast(org.hl7.fhir.dstu2016may.model.Conformance.class);
  }
 else   if (super.getFhirContext().getVersion().getVersion().equals(FhirVersionEnum.DSTU2)) {
    return Class.class.cast(ca.uhn.fhir.model.dstu2.resource.Conformance.class);
  }
 else   if (super.getFhirContext().getVersion().getVersion().equals(FhirVersionEnum.DSTU2_HL7ORG)) {
    return Class.class.cast(org.hl7.fhir.instance.model.Conformance.class);
  }
  return null;
}","@SuppressWarnings(""String_Node_Str"") @Override public Class<IBaseResource> getResourceType(){
  FhirVersionEnum fhirContextVersion=super.getFhirContext().getVersion().getVersion();
switch (fhirContextVersion) {
case R4:
    return Class.class.cast(org.hl7.fhir.r4.model.CapabilityStatement.class);
case DSTU3:
  return Class.class.cast(org.hl7.fhir.dstu3.model.CapabilityStatement.class);
case DSTU2_1:
return Class.class.cast(org.hl7.fhir.dstu2016may.model.Conformance.class);
case DSTU2_HL7ORG:
return Class.class.cast(org.hl7.fhir.instance.model.Conformance.class);
case DSTU2:
return Class.class.cast(ca.uhn.fhir.model.dstu2.resource.Conformance.class);
default :
throw new ConfigurationException(""String_Node_Str"" + fhirContextVersion);
}
}",0.5061224489795918
112190,"/** 
 * This method will set the conformance during the postconstruct phase. The method   {@link AbstractJaxRsConformanceProvider#getProviders()} is used to get all the resource providers include in theconformance
 */
@PostConstruct protected void setUpPostConstruct(){
  for (  Entry<Class<? extends IResourceProvider>,IResourceProvider> provider : getProviders().entrySet()) {
    addProvider(provider.getValue(),provider.getKey());
  }
  List<BaseMethodBinding<?>> serverBindings=new ArrayList<BaseMethodBinding<?>>();
  for (  ResourceBinding baseMethodBinding : myResourceNameToBinding.values()) {
    serverBindings.addAll(baseMethodBinding.getMethodBindings());
  }
  serverConfiguration.setServerBindings(serverBindings);
  serverConfiguration.setResourceBindings(new LinkedList<ResourceBinding>(myResourceNameToBinding.values()));
  HardcodedServerAddressStrategy hardcodedServerAddressStrategy=new HardcodedServerAddressStrategy();
  hardcodedServerAddressStrategy.setValue(getBaseForServer());
  serverConfiguration.setServerAddressStrategy(hardcodedServerAddressStrategy);
  if (super.getFhirContext().getVersion().getVersion().equals(FhirVersionEnum.R4)) {
    org.hl7.fhir.r4.hapi.rest.server.ServerCapabilityStatementProvider serverCapabilityStatementProvider=new org.hl7.fhir.r4.hapi.rest.server.ServerCapabilityStatementProvider(serverConfiguration);
    serverCapabilityStatementProvider.initializeOperations();
    myR4CapabilityStatement=serverCapabilityStatementProvider.getServerConformance(null);
  }
 else   if (super.getFhirContext().getVersion().getVersion().equals(FhirVersionEnum.DSTU3)) {
    ServerCapabilityStatementProvider serverCapabilityStatementProvider=new ServerCapabilityStatementProvider(serverConfiguration);
    serverCapabilityStatementProvider.initializeOperations();
    myDstu3CapabilityStatement=serverCapabilityStatementProvider.getServerConformance(null);
  }
 else   if (super.getFhirContext().getVersion().getVersion().equals(FhirVersionEnum.DSTU2_1)) {
    org.hl7.fhir.dstu2016may.hapi.rest.server.ServerConformanceProvider serverCapabilityStatementProvider=new org.hl7.fhir.dstu2016may.hapi.rest.server.ServerConformanceProvider(serverConfiguration);
    serverCapabilityStatementProvider.initializeOperations();
    myDstu2_1Conformance=serverCapabilityStatementProvider.getServerConformance(null);
  }
 else   if (super.getFhirContext().getVersion().getVersion().equals(FhirVersionEnum.DSTU2)) {
    ca.uhn.fhir.rest.server.provider.dstu2.ServerConformanceProvider serverCapabilityStatementProvider=new ca.uhn.fhir.rest.server.provider.dstu2.ServerConformanceProvider(serverConfiguration);
    serverCapabilityStatementProvider.initializeOperations();
    myDstu2Conformance=serverCapabilityStatementProvider.getServerConformance(null);
  }
 else   if (super.getFhirContext().getVersion().getVersion().equals(FhirVersionEnum.DSTU2_HL7ORG)) {
    org.hl7.fhir.instance.conf.ServerConformanceProvider serverCapabilityStatementProvider=new org.hl7.fhir.instance.conf.ServerConformanceProvider(serverConfiguration);
    serverCapabilityStatementProvider.initializeOperations();
    myDstu2Hl7OrgConformance=serverCapabilityStatementProvider.getServerConformance(null);
  }
}","/** 
 * This method will set the conformance during the postconstruct phase. The method   {@link AbstractJaxRsConformanceProvider#getProviders()} is used to get all the resource providers include in theconformance
 */
@PostConstruct protected void setUpPostConstruct(){
  for (  Entry<Class<? extends IResourceProvider>,IResourceProvider> provider : getProviders().entrySet()) {
    addProvider(provider.getValue(),provider.getKey());
  }
  List<BaseMethodBinding<?>> serverBindings=new ArrayList<BaseMethodBinding<?>>();
  for (  ResourceBinding baseMethodBinding : myResourceNameToBinding.values()) {
    serverBindings.addAll(baseMethodBinding.getMethodBindings());
  }
  serverConfiguration.setServerBindings(serverBindings);
  serverConfiguration.setResourceBindings(new LinkedList<ResourceBinding>(myResourceNameToBinding.values()));
  HardcodedServerAddressStrategy hardcodedServerAddressStrategy=new HardcodedServerAddressStrategy();
  hardcodedServerAddressStrategy.setValue(getBaseForServer());
  serverConfiguration.setServerAddressStrategy(hardcodedServerAddressStrategy);
  FhirVersionEnum fhirContextVersion=super.getFhirContext().getVersion().getVersion();
switch (fhirContextVersion) {
case R4:
    org.hl7.fhir.r4.hapi.rest.server.ServerCapabilityStatementProvider r4ServerCapabilityStatementProvider=new org.hl7.fhir.r4.hapi.rest.server.ServerCapabilityStatementProvider(serverConfiguration);
  r4ServerCapabilityStatementProvider.initializeOperations();
myR4CapabilityStatement=r4ServerCapabilityStatementProvider.getServerConformance(null);
break;
case DSTU3:
org.hl7.fhir.dstu3.hapi.rest.server.ServerCapabilityStatementProvider dstu3ServerCapabilityStatementProvider=new org.hl7.fhir.dstu3.hapi.rest.server.ServerCapabilityStatementProvider(serverConfiguration);
dstu3ServerCapabilityStatementProvider.initializeOperations();
myDstu3CapabilityStatement=dstu3ServerCapabilityStatementProvider.getServerConformance(null);
break;
case DSTU2_1:
org.hl7.fhir.dstu2016may.hapi.rest.server.ServerConformanceProvider dstu2_1ServerConformanceProvider=new org.hl7.fhir.dstu2016may.hapi.rest.server.ServerConformanceProvider(serverConfiguration);
dstu2_1ServerConformanceProvider.initializeOperations();
myDstu2_1Conformance=dstu2_1ServerConformanceProvider.getServerConformance(null);
break;
case DSTU2_HL7ORG:
org.hl7.fhir.instance.conf.ServerConformanceProvider dstu2Hl7OrgServerConformanceProvider=new org.hl7.fhir.instance.conf.ServerConformanceProvider(serverConfiguration);
dstu2Hl7OrgServerConformanceProvider.initializeOperations();
myDstu2Hl7OrgConformance=dstu2Hl7OrgServerConformanceProvider.getServerConformance(null);
break;
case DSTU2:
ca.uhn.fhir.rest.server.provider.dstu2.ServerConformanceProvider dstu2ServerConformanceProvider=new ca.uhn.fhir.rest.server.provider.dstu2.ServerConformanceProvider(serverConfiguration);
dstu2ServerConformanceProvider.initializeOperations();
myDstu2Conformance=dstu2ServerConformanceProvider.getServerConformance(null);
break;
default :
throw new ConfigurationException(""String_Node_Str"" + fhirContextVersion);
}
}",0.7016820057124722
112191,"/** 
 * Create the jax-rs request
 * @return the jax-rs request
 */
public JaxRsRequest build(){
  JaxRsRequest result=new JaxRsRequest(myServer,myResource,myRequestType,myRestOperation);
  if ((StringUtils.isNotBlank(myVersion) || StringUtils.isNotBlank(myCompartment)) && StringUtils.isBlank(myId)) {
    throw new InvalidRequestException(""String_Node_Str"" + myServer.getUriInfo().getRequestUri().toASCIIString());
  }
  FhirVersionEnum fhirContextVersion=myServer.getFhirContext().getVersion().getVersion();
  if (StringUtils.isNotBlank(myVersion)) {
    if (FhirVersionEnum.DSTU3.equals(fhirContextVersion) || FhirVersionEnum.DSTU2_HL7ORG.equals(fhirContextVersion)) {
      result.setId(new IdType(myServer.getBaseForRequest(),UrlUtil.unescape(myId),UrlUtil.unescape(myVersion)));
    }
 else     if (FhirVersionEnum.DSTU2.equals(fhirContextVersion)) {
      result.setId(new IdDt(myServer.getBaseForRequest(),UrlUtil.unescape(myId),UrlUtil.unescape(myVersion)));
    }
  }
 else   if (StringUtils.isNotBlank(myId)) {
    if (FhirVersionEnum.DSTU3.equals(fhirContextVersion) || FhirVersionEnum.DSTU2_HL7ORG.equals(fhirContextVersion)) {
      result.setId(new IdType(myServer.getBaseForRequest(),UrlUtil.unescape(myId)));
    }
 else     if (FhirVersionEnum.DSTU2.equals(fhirContextVersion)) {
      result.setId(new IdDt(myServer.getBaseForRequest(),UrlUtil.unescape(myId)));
    }
  }
  if (myRestOperation == RestOperationTypeEnum.UPDATE) {
    String contentLocation=result.getHeader(Constants.HEADER_CONTENT_LOCATION);
    if (contentLocation != null) {
      if (FhirVersionEnum.DSTU3.equals(fhirContextVersion) || FhirVersionEnum.DSTU2_HL7ORG.equals(fhirContextVersion)) {
        result.setId(new IdType(contentLocation));
      }
 else       if (FhirVersionEnum.DSTU2.equals(fhirContextVersion)) {
        result.setId(new IdDt(contentLocation));
      }
    }
  }
  result.setCompartmentName(myCompartment);
  result.setCompleteUrl(myRequestUrl);
  result.setResourceName(myResourceName);
  return result;
}","/** 
 * Create the jax-rs request
 * @return the jax-rs request
 */
public JaxRsRequest build(){
  JaxRsRequest result=new JaxRsRequest(myServer,myResource,myRequestType,myRestOperation);
  if ((StringUtils.isNotBlank(myVersion) || StringUtils.isNotBlank(myCompartment)) && StringUtils.isBlank(myId)) {
    throw new InvalidRequestException(""String_Node_Str"" + myServer.getUriInfo().getRequestUri().toASCIIString());
  }
  FhirVersionEnum fhirContextVersion=myServer.getFhirContext().getVersion().getVersion();
  if (StringUtils.isNotBlank(myVersion)) {
switch (fhirContextVersion) {
case R4:
      result.setId(new org.hl7.fhir.r4.model.IdType(myServer.getBaseForRequest(),UrlUtil.unescape(myId),UrlUtil.unescape(myVersion)));
    break;
case DSTU3:
  result.setId(new org.hl7.fhir.dstu3.model.IdType(myServer.getBaseForRequest(),UrlUtil.unescape(myId),UrlUtil.unescape(myVersion)));
break;
case DSTU2_1:
result.setId(new org.hl7.fhir.dstu2016may.model.IdType(myServer.getBaseForRequest(),UrlUtil.unescape(myId),UrlUtil.unescape(myVersion)));
break;
case DSTU2_HL7ORG:
result.setId(new org.hl7.fhir.instance.model.IdType(myServer.getBaseForRequest(),UrlUtil.unescape(myId),UrlUtil.unescape(myVersion)));
break;
case DSTU2:
result.setId(new ca.uhn.fhir.model.primitive.IdDt(myServer.getBaseForRequest(),UrlUtil.unescape(myId),UrlUtil.unescape(myVersion)));
break;
default :
throw new ConfigurationException(""String_Node_Str"" + fhirContextVersion);
}
}
 else if (StringUtils.isNotBlank(myId)) {
switch (fhirContextVersion) {
case R4:
result.setId(new org.hl7.fhir.r4.model.IdType(myServer.getBaseForRequest(),UrlUtil.unescape(myId)));
break;
case DSTU3:
result.setId(new org.hl7.fhir.dstu3.model.IdType(myServer.getBaseForRequest(),UrlUtil.unescape(myId)));
break;
case DSTU2_1:
result.setId(new org.hl7.fhir.dstu2016may.model.IdType(myServer.getBaseForRequest(),UrlUtil.unescape(myId)));
break;
case DSTU2_HL7ORG:
result.setId(new org.hl7.fhir.instance.model.IdType(myServer.getBaseForRequest(),UrlUtil.unescape(myId)));
break;
case DSTU2:
result.setId(new ca.uhn.fhir.model.primitive.IdDt(myServer.getBaseForRequest(),UrlUtil.unescape(myId)));
break;
default :
throw new ConfigurationException(""String_Node_Str"" + fhirContextVersion);
}
}
if (myRestOperation == RestOperationTypeEnum.UPDATE) {
String contentLocation=result.getHeader(Constants.HEADER_CONTENT_LOCATION);
if (contentLocation != null) {
switch (fhirContextVersion) {
case R4:
result.setId(new org.hl7.fhir.r4.model.IdType(contentLocation));
break;
case DSTU3:
result.setId(new org.hl7.fhir.dstu3.model.IdType(contentLocation));
break;
case DSTU2_1:
result.setId(new org.hl7.fhir.dstu2016may.model.IdType(contentLocation));
break;
case DSTU2_HL7ORG:
result.setId(new org.hl7.fhir.instance.model.IdType(contentLocation));
break;
case DSTU2:
result.setId(new ca.uhn.fhir.model.primitive.IdDt(contentLocation));
break;
default :
throw new ConfigurationException(""String_Node_Str"" + fhirContextVersion);
}
}
}
result.setCompartmentName(myCompartment);
result.setCompleteUrl(myRequestUrl);
result.setResourceName(myResourceName);
return result;
}",0.3713672713087576
112192,"@Override public IBundleProvider invokeServer(IRestfulServer<?> theServer,RequestDetails theRequest,Object[] theMethodParams) throws InvalidRequestException, InternalErrorException {
  IIdType requestId=theRequest.getId();
  theMethodParams[myIdIndex]=ParameterUtil.convertIdToType(requestId,myIdParameterType);
  Object response=invokeServerMethod(theServer,theRequest,theMethodParams);
  IBundleProvider retVal=toResourceList(response);
  if (retVal.size() == 1) {
    List<IBaseResource> responseResources=retVal.getResources(0,1);
    IBaseResource responseResource=responseResources.get(0);
    if (theRequest.getServer().getETagSupport() == ETagSupportEnum.ENABLED) {
      String ifNoneMatch=theRequest.getHeader(Constants.HEADER_IF_NONE_MATCH_LC);
      if (StringUtils.isNotBlank(ifNoneMatch)) {
        ifNoneMatch=ParameterUtil.parseETagValue(ifNoneMatch);
        if (responseResource.getIdElement() != null && responseResource.getIdElement().hasVersionIdPart()) {
          if (responseResource.getIdElement().getVersionIdPart().equals(ifNoneMatch)) {
            ourLog.debug(""String_Node_Str"",Constants.HEADER_IF_NONE_MATCH,ifNoneMatch);
            throw new NotModifiedException(""String_Node_Str"");
          }
        }
      }
    }
    String ifModifiedSince=theRequest.getHeader(Constants.HEADER_IF_MODIFIED_SINCE_LC);
    if (isNotBlank(ifModifiedSince)) {
      Date ifModifiedSinceDate=DateUtils.parseDate(ifModifiedSince);
      Date lastModified=null;
      if (responseResource instanceof IResource) {
        InstantDt lastModifiedDt=ResourceMetadataKeyEnum.UPDATED.get((IResource)responseResource);
        if (lastModifiedDt != null) {
          lastModified=lastModifiedDt.getValue();
        }
      }
 else {
        lastModified=responseResource.getMeta().getLastUpdated();
      }
      if (lastModified != null && lastModified.getTime() > ifModifiedSinceDate.getTime()) {
        ourLog.debug(""String_Node_Str"");
        throw new NotModifiedException(""String_Node_Str"");
      }
    }
  }
  return retVal;
}","@Override public IBundleProvider invokeServer(IRestfulServer<?> theServer,RequestDetails theRequest,Object[] theMethodParams) throws InvalidRequestException, InternalErrorException {
  IIdType requestId=theRequest.getId();
  theMethodParams[myIdIndex]=ParameterUtil.convertIdToType(requestId,myIdParameterType);
  Object response=invokeServerMethod(theServer,theRequest,theMethodParams);
  IBundleProvider retVal=toResourceList(response);
  if (retVal.size() == 1) {
    List<IBaseResource> responseResources=retVal.getResources(0,1);
    IBaseResource responseResource=responseResources.get(0);
    if (theRequest.getServer().getETagSupport() == ETagSupportEnum.ENABLED) {
      String ifNoneMatch=theRequest.getHeader(Constants.HEADER_IF_NONE_MATCH_LC);
      if (StringUtils.isNotBlank(ifNoneMatch)) {
        ifNoneMatch=ParameterUtil.parseETagValue(ifNoneMatch);
        if (responseResource.getIdElement() != null && responseResource.getIdElement().hasVersionIdPart()) {
          if (responseResource.getIdElement().getVersionIdPart().equals(ifNoneMatch)) {
            ourLog.debug(""String_Node_Str"",Constants.HEADER_IF_NONE_MATCH,ifNoneMatch);
            throw new NotModifiedException(""String_Node_Str"");
          }
        }
      }
    }
    String ifModifiedSince=theRequest.getHeader(Constants.HEADER_IF_MODIFIED_SINCE_LC);
    if (isNotBlank(ifModifiedSince)) {
      Date ifModifiedSinceDate=DateUtils.parseDate(ifModifiedSince);
      Date lastModified=null;
      if (responseResource instanceof IResource) {
        InstantDt lastModifiedDt=ResourceMetadataKeyEnum.UPDATED.get((IResource)responseResource);
        if (lastModifiedDt != null) {
          lastModified=lastModifiedDt.getValue();
        }
      }
 else {
        lastModified=responseResource.getMeta().getLastUpdated();
      }
      if (lastModified != null && lastModified.getTime() <= ifModifiedSinceDate.getTime()) {
        ourLog.debug(""String_Node_Str"");
        throw new NotModifiedException(""String_Node_Str"");
      }
    }
  }
  return retVal;
}",0.9992663242846662
112193,"@Test public void testIfModifiedSince() throws Exception {
  CloseableHttpResponse status;
  HttpGet httpGet;
  httpGet=new HttpGet(""String_Node_Str"" + ourPort + ""String_Node_Str"");
  httpGet.addHeader(Constants.HEADER_IF_MODIFIED_SINCE,DateUtils.formatDate(new InstantDt(""String_Node_Str"").getValue()));
  status=ourClient.execute(httpGet);
  try {
    assertEquals(200,status.getStatusLine().getStatusCode());
  }
  finally {
    IOUtils.closeQuietly(status);
  }
  httpGet=new HttpGet(""String_Node_Str"" + ourPort + ""String_Node_Str"");
  httpGet.addHeader(Constants.HEADER_IF_MODIFIED_SINCE,DateUtils.formatDate(new InstantDt(""String_Node_Str"").getValue()));
  status=ourClient.execute(httpGet);
  try {
    assertEquals(304,status.getStatusLine().getStatusCode());
  }
  finally {
    IOUtils.closeQuietly(status);
  }
}","@Test public void testIfModifiedSince() throws Exception {
  CloseableHttpResponse status;
  HttpGet httpGet;
  httpGet=new HttpGet(""String_Node_Str"" + ourPort + ""String_Node_Str"");
  httpGet.addHeader(Constants.HEADER_IF_MODIFIED_SINCE,DateUtils.formatDate(new InstantDt(""String_Node_Str"").getValue()));
  status=ourClient.execute(httpGet);
  try {
    assertEquals(304,status.getStatusLine().getStatusCode());
  }
  finally {
    IOUtils.closeQuietly(status);
  }
  httpGet=new HttpGet(""String_Node_Str"" + ourPort + ""String_Node_Str"");
  httpGet.addHeader(Constants.HEADER_IF_MODIFIED_SINCE,DateUtils.formatDate(new InstantDt(""String_Node_Str"").getValue()));
  status=ourClient.execute(httpGet);
  try {
    assertEquals(304,status.getStatusLine().getStatusCode());
  }
  finally {
    IOUtils.closeQuietly(status);
  }
  httpGet=new HttpGet(""String_Node_Str"" + ourPort + ""String_Node_Str"");
  httpGet.addHeader(Constants.HEADER_IF_MODIFIED_SINCE,DateUtils.formatDate(new InstantDt(""String_Node_Str"").getValue()));
  status=ourClient.execute(httpGet);
  try {
    assertEquals(200,status.getStatusLine().getStatusCode());
  }
  finally {
    IOUtils.closeQuietly(status);
  }
}",0.4665334665334665
112194,"@Test public void testIfModifiedSince() throws Exception {
  CloseableHttpResponse status;
  HttpGet httpGet;
  httpGet=new HttpGet(""String_Node_Str"" + ourPort + ""String_Node_Str"");
  httpGet.addHeader(Constants.HEADER_IF_MODIFIED_SINCE,DateUtils.formatDate(new InstantDt(""String_Node_Str"").getValue()));
  status=ourClient.execute(httpGet);
  try {
    assertEquals(200,status.getStatusLine().getStatusCode());
  }
  finally {
    IOUtils.closeQuietly(status);
  }
  httpGet=new HttpGet(""String_Node_Str"" + ourPort + ""String_Node_Str"");
  httpGet.addHeader(Constants.HEADER_IF_MODIFIED_SINCE,DateUtils.formatDate(new InstantDt(""String_Node_Str"").getValue()));
  status=ourClient.execute(httpGet);
  try {
    assertEquals(304,status.getStatusLine().getStatusCode());
  }
  finally {
    IOUtils.closeQuietly(status);
  }
}","@Test public void testIfModifiedSince() throws Exception {
  CloseableHttpResponse status;
  HttpGet httpGet;
  httpGet=new HttpGet(""String_Node_Str"" + ourPort + ""String_Node_Str"");
  httpGet.addHeader(Constants.HEADER_IF_MODIFIED_SINCE,DateUtils.formatDate(new InstantDt(""String_Node_Str"").getValue()));
  status=ourClient.execute(httpGet);
  try {
    assertEquals(304,status.getStatusLine().getStatusCode());
  }
  finally {
    IOUtils.closeQuietly(status);
  }
  httpGet=new HttpGet(""String_Node_Str"" + ourPort + ""String_Node_Str"");
  httpGet.addHeader(Constants.HEADER_IF_MODIFIED_SINCE,DateUtils.formatDate(new InstantDt(""String_Node_Str"").getValue()));
  status=ourClient.execute(httpGet);
  try {
    assertEquals(304,status.getStatusLine().getStatusCode());
  }
  finally {
    IOUtils.closeQuietly(status);
  }
  httpGet=new HttpGet(""String_Node_Str"" + ourPort + ""String_Node_Str"");
  httpGet.addHeader(Constants.HEADER_IF_MODIFIED_SINCE,DateUtils.formatDate(new InstantDt(""String_Node_Str"").getValue()));
  status=ourClient.execute(httpGet);
  try {
    assertEquals(200,status.getStatusLine().getStatusCode());
  }
  finally {
    IOUtils.closeQuietly(status);
  }
}",0.4665334665334665
112195,"/** 
 * Convert an exception to a response
 * @param theRequest the incoming request
 * @param theException the exception to convert
 * @return response
 * @throws IOException
 */
public Response handleException(final JaxRsRequest theRequest,final Throwable theException) throws IOException {
  if (theException instanceof JaxRsResponseException) {
    return new JaxRsExceptionInterceptor().convertExceptionIntoResponse(theRequest,(JaxRsResponseException)theException);
  }
 else   if (theException instanceof DataFormatException) {
    return new JaxRsExceptionInterceptor().convertExceptionIntoResponse(theRequest,new JaxRsResponseException(new InvalidRequestException(theException.getMessage(),createOutcome((DataFormatException)theException))));
  }
 else {
    return new JaxRsExceptionInterceptor().convertExceptionIntoResponse(theRequest,new JaxRsExceptionInterceptor().convertException(this,theException));
  }
}","/** 
 * Convert an exception to a response
 * @param theRequest the incoming request
 * @param theException the exception to convert
 * @return response
 * @throws IOException
 */
public Response handleException(final JaxRsRequest theRequest,final Throwable theException) throws IOException {
  if (theException instanceof JaxRsResponseException) {
    return new JaxRsExceptionInterceptor().convertExceptionIntoResponse(theRequest,(JaxRsResponseException)theException);
  }
 else {
    return new JaxRsExceptionInterceptor().convertExceptionIntoResponse(theRequest,new JaxRsExceptionInterceptor().convertException(this,theException));
  }
}",0.7528809218950064
112196,"@Override public BaseServerResponseException preProcessOutgoingException(RequestDetails theRequestDetails,Throwable theException,HttpServletRequest theServletRequest) throws ServletException {
  BaseServerResponseException retVal;
  if (!(theException instanceof BaseServerResponseException)) {
    retVal=new InternalErrorException(theException);
  }
 else {
    retVal=(BaseServerResponseException)theException;
  }
  if (retVal.getOperationOutcome() == null) {
    retVal.setOperationOutcome(createOperationOutcome(theException,theRequestDetails.getServer().getFhirContext()));
  }
  return retVal;
}","@Override public BaseServerResponseException preProcessOutgoingException(RequestDetails theRequestDetails,Throwable theException,HttpServletRequest theServletRequest) throws ServletException {
  BaseServerResponseException retVal;
  if (theException instanceof DataFormatException) {
    retVal=new InvalidRequestException(theException);
  }
 else   if (!(theException instanceof BaseServerResponseException)) {
    retVal=new InternalErrorException(theException);
  }
 else {
    retVal=(BaseServerResponseException)theException;
  }
  if (retVal.getOperationOutcome() == null) {
    retVal.setOperationOutcome(createOperationOutcome(theException,theRequestDetails.getServer().getFhirContext()));
  }
  return retVal;
}",0.91156462585034
112197,"private IBaseOperationOutcome createOutcome(final DataFormatException theException){
  final IBaseOperationOutcome oo=OperationOutcomeUtil.newInstance(getFhirContext());
  final String detailsValue=theException.getMessage() + ""String_Node_Str"" + ExceptionUtils.getStackTrace(theException);
  OperationOutcomeUtil.addIssue(getFhirContext(),oo,ERROR,detailsValue,null,PROCESSING);
  return oo;
}","private IBaseOperationOutcome createOutcome(final DataFormatException theException){
  final IBaseOperationOutcome oo=OperationOutcomeUtil.newInstance(getFhirContext());
  final String detailsValue=theException.getMessage() + (this.withStackTrace() ? ""String_Node_Str"" + ExceptionUtils.getStackTrace(theException) : ""String_Node_Str"");
  OperationOutcomeUtil.addIssue(getFhirContext(),oo,ERROR,detailsValue,null,PROCESSING);
  return oo;
}",0.9447115384615384
112198,"private void readArray(JsonArray arr,boolean root) throws FHIRException {
  while (!((itemType == ItemType.End) || (root && (itemType == ItemType.Eof)))) {
switch (itemType) {
case Object:
      JsonObject obj=new JsonObject();
    LocationData loc=lexer.location.copy();
  arr.add(obj);
next();
readObject(obj,false);
map.put(obj,loc);
break;
case String:
JsonPrimitive v=new JsonPrimitive(itemValue);
arr.add(v);
map.put(v,lexer.location.copy());
break;
case Number:
v=new JsonPrimitive(new BigDecimal(itemValue));
arr.add(v);
map.put(v,lexer.location.copy());
break;
case Null:
JsonNull n=new JsonNull();
arr.add(n);
map.put(n,lexer.location.copy());
break;
case Array:
JsonArray child=new JsonArray();
loc=lexer.location.copy();
arr.add(child);
next();
readArray(child,false);
map.put(arr,loc);
break;
case Eof:
throw lexer.error(""String_Node_Str"");
default :
break;
}
next();
}
}","private void readArray(JsonArray arr,boolean root) throws FHIRException {
  while (!((itemType == ItemType.End) || (root && (itemType == ItemType.Eof)))) {
switch (itemType) {
case Object:
      JsonObject obj=new JsonObject();
    LocationData loc=lexer.location.copy();
  arr.add(obj);
next();
readObject(obj,false);
map.put(obj,loc);
break;
case String:
JsonPrimitive v=new JsonPrimitive(itemValue);
arr.add(v);
map.put(v,lexer.location.copy());
break;
case Number:
v=new JsonPrimitive(new BigDecimal(itemValue));
arr.add(v);
map.put(v,lexer.location.copy());
break;
case Null:
JsonNull n=new JsonNull();
arr.add(n);
map.put(n,lexer.location.copy());
break;
case Array:
JsonArray child=new JsonArray();
loc=lexer.location.copy();
arr.add(child);
next();
readArray(child,false);
map.put(arr,loc);
break;
case Eof:
throw lexer.error(""String_Node_Str"");
case Boolean:
case End:
default :
break;
}
next();
}
}",0.9866071428571428
112199,"private void readObject(JsonObject obj,boolean root) throws FHIRException {
  map.put(obj,lexer.location.copy());
  while (!(itemType == ItemType.End) || (root && (itemType == ItemType.Eof))) {
    if (obj.has(itemName))     throw lexer.error(""String_Node_Str"" + itemName);
switch (itemType) {
case Object:
      JsonObject child=new JsonObject();
    LocationData loc=lexer.location.copy();
  obj.add(itemName,child);
next();
readObject(child,false);
map.put(obj,loc);
break;
case Boolean:
JsonPrimitive v=new JsonPrimitive(Boolean.valueOf(itemValue));
obj.add(itemName,v);
map.put(v,lexer.location.copy());
break;
case String:
v=new JsonPrimitive(itemValue);
obj.add(itemName,v);
map.put(v,lexer.location.copy());
break;
case Number:
v=new JsonPrimitive(new BigDecimal(itemValue));
obj.add(itemName,v);
map.put(v,lexer.location.copy());
break;
case Null:
JsonNull n=new JsonNull();
obj.add(itemName,n);
map.put(n,lexer.location.copy());
break;
case Array:
JsonArray arr=new JsonArray();
loc=lexer.location.copy();
obj.add(itemName,arr);
next();
readArray(arr,false);
map.put(arr,loc);
break;
case Eof:
throw lexer.error(""String_Node_Str"");
default :
break;
}
next();
}
}","private void readObject(JsonObject obj,boolean root) throws FHIRException {
  map.put(obj,lexer.location.copy());
  while (!(itemType == ItemType.End) || (root && (itemType == ItemType.Eof))) {
    if (obj.has(itemName))     throw lexer.error(""String_Node_Str"" + itemName);
switch (itemType) {
case Object:
      JsonObject child=new JsonObject();
    LocationData loc=lexer.location.copy();
  obj.add(itemName,child);
next();
readObject(child,false);
map.put(obj,loc);
break;
case Boolean:
JsonPrimitive v=new JsonPrimitive(Boolean.valueOf(itemValue));
obj.add(itemName,v);
map.put(v,lexer.location.copy());
break;
case String:
v=new JsonPrimitive(itemValue);
obj.add(itemName,v);
map.put(v,lexer.location.copy());
break;
case Number:
v=new JsonPrimitive(new BigDecimal(itemValue));
obj.add(itemName,v);
map.put(v,lexer.location.copy());
break;
case Null:
JsonNull n=new JsonNull();
obj.add(itemName,n);
map.put(n,lexer.location.copy());
break;
case Array:
JsonArray arr=new JsonArray();
loc=lexer.location.copy();
obj.add(itemName,arr);
next();
readArray(arr,false);
map.put(arr,loc);
break;
case Eof:
throw lexer.error(""String_Node_Str"");
case End:
default :
break;
}
next();
}
}",0.995751911639762
112200,"private void deleteSearch(final Long theSearchPid){
  Search searchToDelete=mySearchDao.findOne(theSearchPid);
  ourLog.info(""String_Node_Str"",searchToDelete.getId(),searchToDelete.getUuid(),searchToDelete.getCreated(),searchToDelete.getSearchLastReturned());
  mySearchIncludeDao.deleteForSearch(searchToDelete.getId());
  mySearchResultDao.deleteForSearch(searchToDelete.getId());
  mySearchDao.delete(searchToDelete);
}","private void deleteSearch(final Long theSearchPid){
  Search searchToDelete=mySearchDao.findOne(theSearchPid);
  if (searchToDelete != null) {
    ourLog.info(""String_Node_Str"",searchToDelete.getId(),searchToDelete.getUuid(),searchToDelete.getCreated(),searchToDelete.getSearchLastReturned());
    mySearchIncludeDao.deleteForSearch(searchToDelete.getId());
    mySearchResultDao.deleteForSearch(searchToDelete.getId());
    mySearchDao.delete(searchToDelete);
  }
}",0.9504504504504504
112201,"private void validateBundle(List<ValidationMessage> errors,Element bundle,NodeStack stack){
  List<Element> entries=new ArrayList<Element>();
  bundle.getNamedChildren(""String_Node_Str"",entries);
  String type=bundle.getNamedChildValue(""String_Node_Str"");
  if (entries.size() == 0) {
    rule(errors,IssueType.INVALID,stack.getLiteralPath(),!(type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")),""String_Node_Str"");
  }
 else {
    Element firstEntry=entries.get(0);
    NodeStack firstStack=stack.push(firstEntry,0,null,null);
    String fullUrl=firstEntry.getNamedChildValue(""String_Node_Str"");
    if (type.equals(""String_Node_Str"")) {
      Element resource=firstEntry.getNamedChild(""String_Node_Str"");
      NodeStack localStack=firstStack.push(resource,-1,null,null);
      String id=resource.getNamedChildValue(""String_Node_Str"");
      if (rule(errors,IssueType.INVALID,firstEntry.line(),firstEntry.col(),stack.addToLiteralPath(""String_Node_Str"",""String_Node_Str""),resource != null,""String_Node_Str"")) {
        validateDocument(errors,entries,resource,localStack.push(resource,-1,null,null),fullUrl,id);
      }
      checkAllInterlinked(errors,entries,stack,bundle);
    }
    if (type.equals(""String_Node_Str"")) {
      Element resource=firstEntry.getNamedChild(""String_Node_Str"");
      NodeStack localStack=firstStack.push(resource,-1,null,null);
      String id=resource.getNamedChildValue(""String_Node_Str"");
      if (rule(errors,IssueType.INVALID,firstEntry.line(),firstEntry.col(),stack.addToLiteralPath(""String_Node_Str"",""String_Node_Str""),resource != null,""String_Node_Str"")) {
        validateMessage(errors,entries,resource,localStack.push(resource,-1,null,null),fullUrl,id);
      }
      checkAllInterlinked(errors,entries,stack,bundle);
    }
  }
}","private void validateBundle(List<ValidationMessage> errors,Element bundle,NodeStack stack){
  List<Element> entries=new ArrayList<Element>();
  bundle.getNamedChildren(""String_Node_Str"",entries);
  String type=bundle.getNamedChildValue(""String_Node_Str"");
  type=StringUtils.defaultString(type);
  if (entries.size() == 0) {
    rule(errors,IssueType.INVALID,stack.getLiteralPath(),!(type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")),""String_Node_Str"");
  }
 else {
    Element firstEntry=entries.get(0);
    NodeStack firstStack=stack.push(firstEntry,0,null,null);
    String fullUrl=firstEntry.getNamedChildValue(""String_Node_Str"");
    if (type.equals(""String_Node_Str"")) {
      Element resource=firstEntry.getNamedChild(""String_Node_Str"");
      NodeStack localStack=firstStack.push(resource,-1,null,null);
      String id=resource.getNamedChildValue(""String_Node_Str"");
      if (rule(errors,IssueType.INVALID,firstEntry.line(),firstEntry.col(),stack.addToLiteralPath(""String_Node_Str"",""String_Node_Str""),resource != null,""String_Node_Str"")) {
        validateDocument(errors,entries,resource,localStack.push(resource,-1,null,null),fullUrl,id);
      }
      checkAllInterlinked(errors,entries,stack,bundle);
    }
    if (type.equals(""String_Node_Str"")) {
      Element resource=firstEntry.getNamedChild(""String_Node_Str"");
      NodeStack localStack=firstStack.push(resource,-1,null,null);
      String id=resource.getNamedChildValue(""String_Node_Str"");
      if (rule(errors,IssueType.INVALID,firstEntry.line(),firstEntry.col(),stack.addToLiteralPath(""String_Node_Str"",""String_Node_Str""),resource != null,""String_Node_Str"")) {
        validateMessage(errors,entries,resource,localStack.push(resource,-1,null,null),fullUrl,id);
      }
      checkAllInterlinked(errors,entries,stack,bundle);
    }
  }
}",0.9889319313779744
112202,"private void checkReference(Object appContext,List<ValidationMessage> errors,String path,Element element,StructureDefinition profile,ElementDefinition container,String parentType,NodeStack stack) throws FHIRException, IOException {
  Reference reference=readAsReference(element);
  String ref=reference.getReference();
  if (Utilities.noString(ref)) {
    if (Utilities.noString(reference.getIdentifier().getSystem()) && Utilities.noString(reference.getIdentifier().getValue())) {
      warning(errors,IssueType.STRUCTURE,element.line(),element.col(),path,!Utilities.noString(element.getNamedChildValue(""String_Node_Str"")),""String_Node_Str"");
    }
    return;
  }
  Element we=localResolve(ref,stack,errors,path);
  String refType;
  if (ref.startsWith(""String_Node_Str"")) {
    refType=""String_Node_Str"";
  }
 else {
    if (we == null) {
      refType=""String_Node_Str"";
    }
 else {
      refType=""String_Node_Str"";
    }
  }
  String ft;
  if (we != null)   ft=we.getType();
 else   ft=tryParse(ref);
  ReferenceValidationPolicy pol=refType.equals(""String_Node_Str"") ? ReferenceValidationPolicy.CHECK_VALID : fetcher == null ? ReferenceValidationPolicy.IGNORE : fetcher.validationPolicy(appContext,path,ref);
  if (pol.checkExists()) {
    if (we == null) {
      if (fetcher == null)       throw new FHIRException(""String_Node_Str"");
      we=fetcher.fetch(appContext,ref);
    }
    rule(errors,IssueType.STRUCTURE,element.line(),element.col(),path,we != null,""String_Node_Str"" + ref + ""String_Node_Str"");
  }
  if (we != null && pol.checkType()) {
    if (warning(errors,IssueType.STRUCTURE,element.line(),element.col(),path,ft != null,""String_Node_Str"")) {
      boolean ok=false;
      CommaSeparatedStringBuilder b=new CommaSeparatedStringBuilder();
      for (      TypeRefComponent type : container.getType()) {
        if (!ok && type.getCode().equals(""String_Node_Str"")) {
          if (!type.hasTargetProfile() || type.getTargetProfile().equals(""String_Node_Str""))           ok=true;
 else {
            String pr=type.getTargetProfile();
            String bt=getBaseType(profile,pr);
            StructureDefinition sd=context.fetchResource(StructureDefinition.class,""String_Node_Str"" + bt);
            if (rule(errors,IssueType.STRUCTURE,element.line(),element.col(),path,bt != null,""String_Node_Str"" + pr + ""String_Node_Str"")) {
              b.append(bt);
              ok=bt.equals(ft);
              if (ok && we != null && pol.checkValid()) {
                doResourceProfile(appContext,we,pr,errors,stack.push(we,-1,null,null),path,element);
              }
            }
 else             ok=true;
            if (ok && type.hasAggregation()) {
              boolean modeOk;
              for (              Enumeration<AggregationMode> mode : type.getAggregation()) {
                if (mode.getValue().equals(AggregationMode.CONTAINED) && refType.equals(""String_Node_Str""))                 ok=true;
 else                 if (mode.getValue().equals(AggregationMode.BUNDLED) && refType.equals(""String_Node_Str""))                 ok=true;
 else                 if (mode.getValue().equals(AggregationMode.REFERENCED) && (refType.equals(""String_Node_Str"") || refType.equals(""String_Node_Str"")))                 ok=true;
              }
              rule(errors,IssueType.STRUCTURE,element.line(),element.col(),path,ok,""String_Node_Str"" + refType + ""String_Node_Str"");
            }
          }
        }
        if (!ok && type.getCode().equals(""String_Node_Str"")) {
          ok=true;
        }
      }
      rule(errors,IssueType.STRUCTURE,element.line(),element.col(),path,ok,""String_Node_Str"" + ft + ""String_Node_Str""+ b.toString()+ ""String_Node_Str"");
    }
  }
  if (pol == ReferenceValidationPolicy.CHECK_VALID) {
  }
}","private void checkReference(Object appContext,List<ValidationMessage> errors,String path,Element element,StructureDefinition profile,ElementDefinition container,String parentType,NodeStack stack) throws FHIRException, IOException {
  String ref=null;
  try {
    ref=element.getNamedChildValue(""String_Node_Str"");
  }
 catch (  Error e) {
  }
  if (Utilities.noString(ref)) {
    warning(errors,IssueType.STRUCTURE,element.line(),element.col(),path,!Utilities.noString(element.getNamedChildValue(""String_Node_Str"")),""String_Node_Str"");
    return;
  }
  Element we=localResolve(ref,stack,errors,path);
  String refType;
  if (ref.startsWith(""String_Node_Str"")) {
    refType=""String_Node_Str"";
  }
 else {
    if (we == null) {
      refType=""String_Node_Str"";
    }
 else {
      refType=""String_Node_Str"";
    }
  }
  String ft;
  if (we != null)   ft=we.getType();
 else   ft=tryParse(ref);
  ReferenceValidationPolicy pol=refType.equals(""String_Node_Str"") ? ReferenceValidationPolicy.CHECK_VALID : fetcher == null ? ReferenceValidationPolicy.IGNORE : fetcher.validationPolicy(appContext,path,ref);
  if (pol.checkExists()) {
    if (we == null) {
      if (fetcher == null)       throw new FHIRException(""String_Node_Str"");
      we=fetcher.fetch(appContext,ref);
    }
    rule(errors,IssueType.STRUCTURE,element.line(),element.col(),path,we != null,""String_Node_Str"" + ref + ""String_Node_Str"");
  }
  if (we != null && pol.checkType()) {
    if (warning(errors,IssueType.STRUCTURE,element.line(),element.col(),path,ft != null,""String_Node_Str"")) {
      boolean ok=false;
      CommaSeparatedStringBuilder b=new CommaSeparatedStringBuilder();
      for (      TypeRefComponent type : container.getType()) {
        if (!ok && type.getCode().equals(""String_Node_Str"")) {
          if (!type.hasTargetProfile() || type.getTargetProfile().equals(""String_Node_Str""))           ok=true;
 else {
            String pr=type.getTargetProfile();
            String bt=getBaseType(profile,pr);
            StructureDefinition sd=context.fetchResource(StructureDefinition.class,""String_Node_Str"" + bt);
            if (rule(errors,IssueType.STRUCTURE,element.line(),element.col(),path,bt != null,""String_Node_Str"" + pr + ""String_Node_Str"")) {
              b.append(bt);
              ok=bt.equals(ft);
              if (ok && we != null && pol.checkValid()) {
                doResourceProfile(appContext,we,pr,errors,stack.push(we,-1,null,null),path,element);
              }
            }
 else             ok=true;
            if (ok && type.hasAggregation()) {
              boolean modeOk;
              for (              Enumeration<AggregationMode> mode : type.getAggregation()) {
                if (mode.getValue().equals(AggregationMode.CONTAINED) && refType.equals(""String_Node_Str""))                 ok=true;
 else                 if (mode.getValue().equals(AggregationMode.BUNDLED) && refType.equals(""String_Node_Str""))                 ok=true;
 else                 if (mode.getValue().equals(AggregationMode.REFERENCED) && (refType.equals(""String_Node_Str"") || refType.equals(""String_Node_Str"")))                 ok=true;
              }
              rule(errors,IssueType.STRUCTURE,element.line(),element.col(),path,ok,""String_Node_Str"" + refType + ""String_Node_Str"");
            }
          }
        }
        if (!ok && type.getCode().equals(""String_Node_Str"")) {
          ok=true;
        }
      }
      rule(errors,IssueType.STRUCTURE,element.line(),element.col(),path,ok,""String_Node_Str"" + ft + ""String_Node_Str""+ b.toString()+ ""String_Node_Str"");
    }
  }
  if (pol == ReferenceValidationPolicy.CHECK_VALID) {
  }
}",0.9587559161595672
112203,"private void validateBundle(List<ValidationMessage> errors,Element bundle,NodeStack stack){
  List<Element> entries=new ArrayList<Element>();
  bundle.getNamedChildren(""String_Node_Str"",entries);
  String type=bundle.getNamedChildValue(""String_Node_Str"");
  if (entries.size() == 0) {
    rule(errors,IssueType.INVALID,stack.getLiteralPath(),!(type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")),""String_Node_Str"");
  }
 else {
    Element firstEntry=entries.get(0);
    NodeStack firstStack=stack.push(firstEntry,0,null,null);
    String fullUrl=firstEntry.getNamedChildValue(""String_Node_Str"");
    if (type.equals(""String_Node_Str"")) {
      Element resource=firstEntry.getNamedChild(""String_Node_Str"");
      NodeStack localStack=firstStack.push(resource,-1,null,null);
      String id=resource.getNamedChildValue(""String_Node_Str"");
      if (rule(errors,IssueType.INVALID,firstEntry.line(),firstEntry.col(),stack.addToLiteralPath(""String_Node_Str"",""String_Node_Str""),resource != null,""String_Node_Str"")) {
        validateDocument(errors,entries,resource,localStack.push(resource,-1,null,null),fullUrl,id);
      }
      checkAllInterlinked(errors,entries,stack,bundle);
    }
    if (type.equals(""String_Node_Str"")) {
      Element resource=firstEntry.getNamedChild(""String_Node_Str"");
      NodeStack localStack=firstStack.push(resource,-1,null,null);
      String id=resource.getNamedChildValue(""String_Node_Str"");
      if (rule(errors,IssueType.INVALID,firstEntry.line(),firstEntry.col(),stack.addToLiteralPath(""String_Node_Str"",""String_Node_Str""),resource != null,""String_Node_Str"")) {
        validateMessage(errors,entries,resource,localStack.push(resource,-1,null,null),fullUrl,id);
      }
      checkAllInterlinked(errors,entries,stack,bundle);
    }
  }
}","private void validateBundle(List<ValidationMessage> errors,Element bundle,NodeStack stack){
  List<Element> entries=new ArrayList<Element>();
  bundle.getNamedChildren(""String_Node_Str"",entries);
  String type=bundle.getNamedChildValue(""String_Node_Str"");
  type=StringUtils.defaultString(type);
  if (entries.size() == 0) {
    rule(errors,IssueType.INVALID,stack.getLiteralPath(),!(type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")),""String_Node_Str"");
  }
 else {
    Element firstEntry=entries.get(0);
    NodeStack firstStack=stack.push(firstEntry,0,null,null);
    String fullUrl=firstEntry.getNamedChildValue(""String_Node_Str"");
    if (type.equals(""String_Node_Str"")) {
      Element resource=firstEntry.getNamedChild(""String_Node_Str"");
      NodeStack localStack=firstStack.push(resource,-1,null,null);
      String id=resource.getNamedChildValue(""String_Node_Str"");
      if (rule(errors,IssueType.INVALID,firstEntry.line(),firstEntry.col(),stack.addToLiteralPath(""String_Node_Str"",""String_Node_Str""),resource != null,""String_Node_Str"")) {
        validateDocument(errors,entries,resource,localStack.push(resource,-1,null,null),fullUrl,id);
      }
      checkAllInterlinked(errors,entries,stack,bundle);
    }
    if (type.equals(""String_Node_Str"")) {
      Element resource=firstEntry.getNamedChild(""String_Node_Str"");
      NodeStack localStack=firstStack.push(resource,-1,null,null);
      String id=resource.getNamedChildValue(""String_Node_Str"");
      if (rule(errors,IssueType.INVALID,firstEntry.line(),firstEntry.col(),stack.addToLiteralPath(""String_Node_Str"",""String_Node_Str""),resource != null,""String_Node_Str"")) {
        validateMessage(errors,entries,resource,localStack.push(resource,-1,null,null),fullUrl,id);
      }
      checkAllInterlinked(errors,entries,stack,bundle);
    }
  }
}",0.9889319313779744
112204,"private void checkReference(ValidatorHostContext hostContext,List<ValidationMessage> errors,String path,Element element,StructureDefinition profile,ElementDefinition container,String parentType,NodeStack stack) throws FHIRException, IOException {
  Reference reference=ObjectConverter.readAsReference(element);
  String ref=reference.getReference();
  if (Utilities.noString(ref)) {
    if (Utilities.noString(reference.getIdentifier().getSystem()) && Utilities.noString(reference.getIdentifier().getValue())) {
      warning(errors,IssueType.STRUCTURE,element.line(),element.col(),path,!Utilities.noString(element.getNamedChildValue(""String_Node_Str"")),""String_Node_Str"");
    }
    return;
  }
  Element we=localResolve(ref,stack,errors,path);
  String refType;
  if (ref.startsWith(""String_Node_Str"")) {
    refType=""String_Node_Str"";
  }
 else {
    if (we == null) {
      refType=""String_Node_Str"";
    }
 else {
      refType=""String_Node_Str"";
    }
  }
  ReferenceValidationPolicy pol=refType.equals(""String_Node_Str"") ? ReferenceValidationPolicy.CHECK_VALID : fetcher == null ? ReferenceValidationPolicy.IGNORE : fetcher.validationPolicy(hostContext.appContext,path,ref);
  if (pol.checkExists()) {
    if (we == null) {
      if (fetcher == null)       throw new FHIRException(""String_Node_Str"");
      we=fetcher.fetch(hostContext.appContext,ref);
    }
    rule(errors,IssueType.STRUCTURE,element.line(),element.col(),path,we != null,""String_Node_Str"" + ref + ""String_Node_Str"");
  }
  String ft;
  if (we != null)   ft=we.getType();
 else   ft=tryParse(ref);
  if (we != null && pol.checkType()) {
    if (warning(errors,IssueType.STRUCTURE,element.line(),element.col(),path,ft != null,""String_Node_Str"")) {
      boolean ok=false;
      CommaSeparatedStringBuilder b=new CommaSeparatedStringBuilder();
      for (      TypeRefComponent type : container.getType()) {
        if (!ok && type.getCode().equals(""String_Node_Str"")) {
          if (!type.hasTargetProfile() || type.getTargetProfile().equals(""String_Node_Str""))           ok=true;
 else {
            String pr=type.getTargetProfile();
            String bt=getBaseType(profile,pr);
            StructureDefinition sd=context.fetchResource(StructureDefinition.class,""String_Node_Str"" + bt);
            if (rule(errors,IssueType.STRUCTURE,element.line(),element.col(),path,bt != null,""String_Node_Str"" + pr + ""String_Node_Str"")) {
              b.append(bt);
              ok=bt.equals(ft);
              if (ok && we != null && pol.checkValid()) {
                doResourceProfile(hostContext,we,pr,errors,stack.push(we,-1,null,null),path,element);
              }
            }
 else             ok=true;
            if (ok && type.hasAggregation()) {
              boolean modeOk;
              for (              Enumeration<AggregationMode> mode : type.getAggregation()) {
                if (mode.getValue().equals(AggregationMode.CONTAINED) && refType.equals(""String_Node_Str""))                 ok=true;
 else                 if (mode.getValue().equals(AggregationMode.BUNDLED) && refType.equals(""String_Node_Str""))                 ok=true;
 else                 if (mode.getValue().equals(AggregationMode.REFERENCED) && (refType.equals(""String_Node_Str"") || refType.equals(""String_Node_Str"")))                 ok=true;
              }
              rule(errors,IssueType.STRUCTURE,element.line(),element.col(),path,ok,""String_Node_Str"" + refType + ""String_Node_Str"");
            }
          }
        }
        if (!ok && type.getCode().equals(""String_Node_Str"")) {
          ok=true;
        }
      }
      rule(errors,IssueType.STRUCTURE,element.line(),element.col(),path,ok,""String_Node_Str"" + ft + ""String_Node_Str""+ b.toString()+ ""String_Node_Str"");
    }
  }
  if (pol == ReferenceValidationPolicy.CHECK_VALID) {
  }
}","private void checkReference(ValidatorHostContext hostContext,List<ValidationMessage> errors,String path,Element element,StructureDefinition profile,ElementDefinition container,String parentType,NodeStack stack) throws FHIRException, IOException {
  Reference reference=ObjectConverter.readAsReference(element);
  String ref=reference.getReference();
  if (Utilities.noString(ref)) {
    if (Utilities.noString(reference.getIdentifier().getSystem()) && Utilities.noString(reference.getIdentifier().getValue())) {
      warning(errors,IssueType.STRUCTURE,element.line(),element.col(),path,!Utilities.noString(element.getNamedChildValue(""String_Node_Str"")),""String_Node_Str"");
    }
    return;
  }
  Element we=localResolve(ref,stack,errors,path);
  String refType;
  if (ref.startsWith(""String_Node_Str"")) {
    refType=""String_Node_Str"";
  }
 else {
    if (we == null) {
      refType=""String_Node_Str"";
    }
 else {
      refType=""String_Node_Str"";
    }
  }
  ReferenceValidationPolicy pol=refType.equals(""String_Node_Str"") || refType.equals(""String_Node_Str"") ? ReferenceValidationPolicy.CHECK_VALID : fetcher == null ? ReferenceValidationPolicy.IGNORE : fetcher.validationPolicy(hostContext.appContext,path,ref);
  if (pol.checkExists()) {
    if (we == null) {
      if (fetcher == null)       throw new FHIRException(""String_Node_Str"");
      we=fetcher.fetch(hostContext.appContext,ref);
    }
    rule(errors,IssueType.STRUCTURE,element.line(),element.col(),path,we != null,""String_Node_Str"" + ref + ""String_Node_Str"");
  }
  String ft;
  if (we != null)   ft=we.getType();
 else   ft=tryParse(ref);
  if (we != null && pol.checkType()) {
    if (warning(errors,IssueType.STRUCTURE,element.line(),element.col(),path,ft != null,""String_Node_Str"")) {
      boolean ok=false;
      CommaSeparatedStringBuilder b=new CommaSeparatedStringBuilder();
      for (      TypeRefComponent type : container.getType()) {
        if (!ok && type.getCode().equals(""String_Node_Str"")) {
          if (!type.hasTargetProfile() || type.getTargetProfile().equals(""String_Node_Str""))           ok=true;
 else {
            String pr=type.getTargetProfile();
            String bt=getBaseType(profile,pr);
            StructureDefinition sd=context.fetchResource(StructureDefinition.class,""String_Node_Str"" + bt);
            if (rule(errors,IssueType.STRUCTURE,element.line(),element.col(),path,bt != null,""String_Node_Str"" + pr + ""String_Node_Str"")) {
              b.append(bt);
              ok=bt.equals(ft);
              if (ok && we != null && pol.checkValid()) {
                doResourceProfile(hostContext,we,pr,errors,stack.push(we,-1,null,null),path,element);
              }
            }
 else             ok=true;
            if (ok && type.hasAggregation()) {
              boolean modeOk;
              for (              Enumeration<AggregationMode> mode : type.getAggregation()) {
                if (mode.getValue().equals(AggregationMode.CONTAINED) && refType.equals(""String_Node_Str""))                 ok=true;
 else                 if (mode.getValue().equals(AggregationMode.BUNDLED) && refType.equals(""String_Node_Str""))                 ok=true;
 else                 if (mode.getValue().equals(AggregationMode.REFERENCED) && (refType.equals(""String_Node_Str"") || refType.equals(""String_Node_Str"")))                 ok=true;
              }
              rule(errors,IssueType.STRUCTURE,element.line(),element.col(),path,ok,""String_Node_Str"" + refType + ""String_Node_Str"");
            }
          }
        }
        if (!ok && type.getCode().equals(""String_Node_Str"")) {
          ok=true;
        }
      }
      rule(errors,IssueType.STRUCTURE,element.line(),element.col(),path,ok,""String_Node_Str"" + ft + ""String_Node_Str""+ b.toString()+ ""String_Node_Str"");
    }
  }
  if (pol == ReferenceValidationPolicy.CHECK_VALID) {
  }
}",0.9951678202951548
112205,"private boolean checkCode(List<ValidationMessage> errors,Element element,String path,String code,String system,String display) throws TerminologyServiceException {
  long t=System.nanoTime();
  boolean ss=context.supportsSystem(system);
  txTime=txTime + (System.nanoTime() - t);
  if (ss) {
    t=System.nanoTime();
    ValidationResult s=context.validateCode(system,code,display);
    txTime=txTime + (System.nanoTime() - t);
    if (s == null)     return true;
    if (s.isOk()) {
      if (s.getMessage() != null)       warning(errors,IssueType.CODEINVALID,element.line(),element.col(),path,s == null,s.getMessage());
      return true;
    }
    if (s.getSeverity() == IssueSeverity.INFORMATION)     hint(errors,IssueType.CODEINVALID,element.line(),element.col(),path,s == null,s.getMessage());
 else     if (s.getSeverity() == IssueSeverity.WARNING)     warning(errors,IssueType.CODEINVALID,element.line(),element.col(),path,s == null,s.getMessage());
 else     return rule(errors,IssueType.CODEINVALID,element.line(),element.col(),path,s == null,s.getMessage());
    return true;
  }
 else   if (system.startsWith(""String_Node_Str"")) {
    if (system.equals(""String_Node_Str""))     return true;
 else {
      CodeSystem cs=getCodeSystem(system);
      if (warning(errors,IssueType.CODEINVALID,element.line(),element.col(),path,cs != null,""String_Node_Str"" + system)) {
        ConceptDefinitionComponent def=getCodeDefinition(cs,code);
        if (warning(errors,IssueType.CODEINVALID,element.line(),element.col(),path,def != null,""String_Node_Str"" + system + ""String_Node_Str""+ code+ ""String_Node_Str""))         return warning(errors,IssueType.CODEINVALID,element.line(),element.col(),path,display == null || display.equals(def.getDisplay()),""String_Node_Str"" + def.getDisplay() + ""String_Node_Str"");
      }
      return false;
    }
  }
 else   if (context.isNoTerminologyServer() && Utilities.existsInList(system,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")) {
    return true;
  }
 else   if (startsWithButIsNot(system,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")) {
    rule(errors,IssueType.CODEINVALID,element.line(),element.col(),path,false,""String_Node_Str"" + system);
    return false;
  }
 else {
    try {
      if (context.fetchResourceWithException(ValueSet.class,system) != null) {
        rule(errors,IssueType.CODEINVALID,element.line(),element.col(),path,false,""String_Node_Str"" + system + ""String_Node_Str"");
        return false;
      }
 else       return true;
    }
 catch (    Exception e) {
      return true;
    }
  }
}","private boolean checkCode(List<ValidationMessage> errors,Element element,String path,String code,String system,String display) throws TerminologyServiceException {
  long t=System.nanoTime();
  boolean ss=context.supportsSystem(system);
  txTime=txTime + (System.nanoTime() - t);
  if (ss) {
    t=System.nanoTime();
    ValidationResult s=context.validateCode(system,code,display);
    txTime=txTime + (System.nanoTime() - t);
    if (s == null)     return true;
    if (s.isOk()) {
      if (s.getMessage() != null)       warning(errors,IssueType.CODEINVALID,element.line(),element.col(),path,s == null,s.getMessage());
      return true;
    }
    if (s.getSeverity() == IssueSeverity.INFORMATION)     hint(errors,IssueType.CODEINVALID,element.line(),element.col(),path,s == null,s.getMessage());
 else     if (s.getSeverity() == IssueSeverity.WARNING)     warning(errors,IssueType.CODEINVALID,element.line(),element.col(),path,s == null,s.getMessage());
 else     return rule(errors,IssueType.CODEINVALID,element.line(),element.col(),path,s == null,s.getMessage());
    return true;
  }
 else   if (system.startsWith(""String_Node_Str"")) {
    if (system.equals(""String_Node_Str""))     return true;
 else {
      CodeSystem cs=getCodeSystem(system);
      if (warning(errors,IssueType.CODEINVALID,element.line(),element.col(),path,cs != null,""String_Node_Str"" + system)) {
        ConceptDefinitionComponent def=getCodeDefinition(cs,code);
        if (warning(errors,IssueType.CODEINVALID,element.line(),element.col(),path,def != null,""String_Node_Str"" + system + ""String_Node_Str""+ code+ ""String_Node_Str""))         return warning(errors,IssueType.CODEINVALID,element.line(),element.col(),path,display == null || display.equals(def.getDisplay()),""String_Node_Str"" + def.getDisplay() + ""String_Node_Str"");
      }
      return false;
    }
  }
 else   if (context.isNoTerminologyServer() && Utilities.existsInList(system,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")) {
    return true;
  }
 else   if (startsWithButIsNot(system,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")) {
    rule(errors,IssueType.CODEINVALID,element.line(),element.col(),path,false,""String_Node_Str"" + system);
    return false;
  }
 else {
    try {
      if (context.fetchResourceWithException(ValueSet.class,system) != null) {
        rule(errors,IssueType.CODEINVALID,element.line(),element.col(),path,false,""String_Node_Str"" + system + ""String_Node_Str"");
      }
      return true;
    }
 catch (    Exception e) {
      return true;
    }
  }
}",0.9946070878274268
112206,"@Override public void run(CommandLine theCommandLine) throws ParseException, Exception {
  FhirContext ctx=getSpecVersionContext(theCommandLine);
  String targetServer=theCommandLine.getOptionValue(""String_Node_Str"");
  IGenericClient client=ctx.newRestfulGenericClient(targetServer);
  String url=theCommandLine.getOptionValue(""String_Node_Str"");
  Collection<File> files=loadFile(ctx,url,null,false);
  for (  File nextFile : files) {
switch (ctx.getVersion().getVersion()) {
case DSTU3:
      IgPackParserDstu3 packParser=new IgPackParserDstu3(ctx);
    IValidationSupport ig=packParser.parseIg(new FileInputStream(nextFile),nextFile.getName());
  Iterable<IBaseResource> conformanceResources=ig.fetchAllConformanceResources(ctx);
for (IBaseResource nextResource : conformanceResources) {
  String nextResourceUrl=((IPrimitiveType<?>)ctx.newTerser().getSingleValueOrNull(nextResource,""String_Node_Str"")).getValueAsString();
  ourLog.info(""String_Node_Str"",nextResourceUrl);
  client.update().resource(nextResource).conditional().and(StructureDefinition.URL.matches().value(nextResourceUrl)).execute();
}
default :
throw new ParseException(""String_Node_Str"" + ctx.getVersion().getVersion());
}
}
}","@Override public void run(CommandLine theCommandLine) throws ParseException, Exception {
  FhirContext ctx=getSpecVersionContext(theCommandLine);
  String targetServer=theCommandLine.getOptionValue(""String_Node_Str"");
  IGenericClient client=ctx.newRestfulGenericClient(targetServer);
  String url=theCommandLine.getOptionValue(""String_Node_Str"");
  Collection<File> files=loadFile(ctx,url,null,false);
  for (  File nextFile : files) {
switch (ctx.getVersion().getVersion()) {
case DSTU3:
      IgPackParserDstu3 packParser=new IgPackParserDstu3(ctx);
    IValidationSupport ig=packParser.parseIg(new FileInputStream(nextFile),nextFile.getName());
  Iterable<IBaseResource> conformanceResources=ig.fetchAllConformanceResources(ctx);
for (IBaseResource nextResource : conformanceResources) {
  String nextResourceUrl=((IPrimitiveType<?>)ctx.newTerser().getSingleValueOrNull(nextResource,""String_Node_Str"")).getValueAsString();
  ourLog.info(""String_Node_Str"",nextResourceUrl);
  client.update().resource(nextResource).conditional().and(StructureDefinition.URL.matches().value(nextResourceUrl)).execute();
}
break;
default :
throw new ParseException(""String_Node_Str"" + ctx.getVersion().getVersion());
}
}
}",0.9970893970893971
112207,"@Override public String getClientInfo(String theName) throws SQLException {
  return getClientInfo(theName);
}","@Override public String getClientInfo(String theName) throws SQLException {
  return myWrap.getClientInfo(theName);
}",0.9691629955947136
112208,"protected List<String> toUnqualifiedVersionlessIdValues(IBundleProvider theFound){
  List<String> retVal=new ArrayList<String>();
  int size=theFound.size();
  ourLog.info(""String_Node_Str"",size);
  List<IBaseResource> resources=theFound.getResources(0,size);
  for (  IBaseResource next : resources) {
    retVal.add(next.getIdElement().toUnqualifiedVersionless().getValue());
  }
  return retVal;
}","protected List<String> toUnqualifiedVersionlessIdValues(IBundleProvider theFound){
  List<String> retVal=new ArrayList<String>();
  Integer size=theFound.size();
  ourLog.info(""String_Node_Str"",size);
  if (size == null) {
    size=99999;
  }
  List<IBaseResource> resources=theFound.getResources(0,size);
  for (  IBaseResource next : resources) {
    retVal.add(next.getIdElement().toUnqualifiedVersionless().getValue());
  }
  return retVal;
}",0.9385342789598108
112209,"private OperationOutcome doTestValidateResourceContainingProfileDeclaration(String methodName,EncodingEnum enc) throws IOException {
  Bundle vss=loadResourceFromClasspath(Bundle.class,""String_Node_Str"");
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  StructureDefinition sd=loadResourceFromClasspath(StructureDefinition.class,""String_Node_Str"");
  sd.setId(new IdDt());
  sd.setUrl(""String_Node_Str"" + methodName);
  myStructureDefinitionDao.create(sd,mySrd);
  Observation input=new Observation();
  ResourceMetadataKeyEnum.PROFILES.put(input,Arrays.asList(new IdDt(sd.getUrl())));
  input.addIdentifier().setSystem(""String_Node_Str"").setValue(""String_Node_Str"");
  input.getEncounter().setReference(""String_Node_Str"");
  input.setStatus(ObservationStatusEnum.FINAL);
  input.getCode().addCoding().setSystem(""String_Node_Str"").setCode(""String_Node_Str"");
  String encoded=null;
  MethodOutcome outcome=null;
  ValidationModeEnum mode=ValidationModeEnum.CREATE;
switch (enc) {
case JSON:
    encoded=myFhirCtx.newJsonParser().setPrettyPrint(true).encodeResourceToString(input);
  ourLog.info(encoded);
try {
  myObservationDao.validate(input,null,encoded,EncodingEnum.JSON,mode,null,mySrd);
  fail();
}
 catch (PreconditionFailedException e) {
  return (OperationOutcome)e.getOperationOutcome();
}
case XML:
encoded=myFhirCtx.newXmlParser().encodeResourceToString(input);
try {
myObservationDao.validate(input,null,encoded,EncodingEnum.XML,mode,null,mySrd);
fail();
}
 catch (PreconditionFailedException e) {
return (OperationOutcome)e.getOperationOutcome();
}
}
throw new IllegalStateException();
}","private OperationOutcome doTestValidateResourceContainingProfileDeclaration(String methodName,EncodingEnum enc) throws IOException {
  Bundle vss=loadResourceFromClasspath(Bundle.class,""String_Node_Str"");
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  StructureDefinition sd=loadResourceFromClasspath(StructureDefinition.class,""String_Node_Str"");
  sd.setId(new IdDt());
  sd.setUrl(""String_Node_Str"" + methodName);
  myStructureDefinitionDao.create(sd,mySrd);
  Observation input=new Observation();
  ResourceMetadataKeyEnum.PROFILES.put(input,Arrays.asList(new IdDt(sd.getUrl())));
  input.addIdentifier().setSystem(""String_Node_Str"").setValue(""String_Node_Str"");
  input.getEncounter().setReference(""String_Node_Str"");
  input.setStatus(ObservationStatusEnum.FINAL);
  input.getCode().addCoding().setSystem(""String_Node_Str"").setCode(""String_Node_Str"");
  String encoded=null;
  MethodOutcome outcome=null;
  ValidationModeEnum mode=ValidationModeEnum.CREATE;
switch (enc) {
case JSON:
    encoded=myFhirCtx.newJsonParser().setPrettyPrint(true).encodeResourceToString(input);
  ourLog.info(encoded);
try {
  myObservationDao.validate(input,null,encoded,EncodingEnum.JSON,mode,null,mySrd);
  fail();
}
 catch (PreconditionFailedException e) {
  return (OperationOutcome)e.getOperationOutcome();
}
break;
case XML:
encoded=myFhirCtx.newXmlParser().encodeResourceToString(input);
try {
myObservationDao.validate(input,null,encoded,EncodingEnum.XML,mode,null,mySrd);
fail();
}
 catch (PreconditionFailedException e) {
return (OperationOutcome)e.getOperationOutcome();
}
break;
}
throw new IllegalStateException();
}",0.997037663986458
112210,"private OperationOutcome doTestValidateResourceContainingProfileDeclaration(String methodName,EncodingEnum enc) throws IOException {
  Bundle vss=loadResourceFromClasspath(Bundle.class,""String_Node_Str"");
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  StructureDefinition sd=loadResourceFromClasspath(StructureDefinition.class,""String_Node_Str"");
  sd.setId(new IdType());
  sd.setUrl(""String_Node_Str"" + methodName);
  myStructureDefinitionDao.create(sd,mySrd);
  Observation input=new Observation();
  input.getMeta().getProfile().add(new IdType(sd.getUrl()));
  input.addIdentifier().setSystem(""String_Node_Str"").setValue(""String_Node_Str"");
  input.getContext().setReference(""String_Node_Str"");
  input.setStatus(ObservationStatus.FINAL);
  input.getCode().addCoding().setSystem(""String_Node_Str"").setCode(""String_Node_Str"");
  String encoded=null;
  MethodOutcome outcome=null;
  ValidationModeEnum mode=ValidationModeEnum.CREATE;
switch (enc) {
case JSON:
    encoded=myFhirCtx.newJsonParser().encodeResourceToString(input);
  try {
    myObservationDao.validate(input,null,encoded,EncodingEnum.JSON,mode,null,mySrd);
    fail();
  }
 catch (  PreconditionFailedException e) {
    return (OperationOutcome)e.getOperationOutcome();
  }
case XML:
encoded=myFhirCtx.newXmlParser().encodeResourceToString(input);
try {
myObservationDao.validate(input,null,encoded,EncodingEnum.XML,mode,null,mySrd);
fail();
}
 catch (PreconditionFailedException e) {
return (OperationOutcome)e.getOperationOutcome();
}
}
throw new IllegalStateException();
}","private OperationOutcome doTestValidateResourceContainingProfileDeclaration(String methodName,EncodingEnum enc) throws IOException {
  Bundle vss=loadResourceFromClasspath(Bundle.class,""String_Node_Str"");
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  StructureDefinition sd=loadResourceFromClasspath(StructureDefinition.class,""String_Node_Str"");
  sd.setId(new IdType());
  sd.setUrl(""String_Node_Str"" + methodName);
  myStructureDefinitionDao.create(sd,mySrd);
  Observation input=new Observation();
  input.getMeta().getProfile().add(new IdType(sd.getUrl()));
  input.addIdentifier().setSystem(""String_Node_Str"").setValue(""String_Node_Str"");
  input.getContext().setReference(""String_Node_Str"");
  input.setStatus(ObservationStatus.FINAL);
  input.getCode().addCoding().setSystem(""String_Node_Str"").setCode(""String_Node_Str"");
  String encoded=null;
  MethodOutcome outcome=null;
  ValidationModeEnum mode=ValidationModeEnum.CREATE;
switch (enc) {
case JSON:
    encoded=myFhirCtx.newJsonParser().encodeResourceToString(input);
  try {
    myObservationDao.validate(input,null,encoded,EncodingEnum.JSON,mode,null,mySrd);
    fail();
  }
 catch (  PreconditionFailedException e) {
    return (OperationOutcome)e.getOperationOutcome();
  }
break;
case XML:
encoded=myFhirCtx.newXmlParser().encodeResourceToString(input);
try {
myObservationDao.validate(input,null,encoded,EncodingEnum.XML,mode,null,mySrd);
fail();
}
 catch (PreconditionFailedException e) {
return (OperationOutcome)e.getOperationOutcome();
}
break;
}
throw new IllegalStateException();
}",0.9969631236442515
112211,"private OperationOutcome doTestValidateResourceContainingProfileDeclaration(String methodName,EncodingEnum enc) throws IOException {
  Bundle vss=loadResourceFromClasspath(Bundle.class,""String_Node_Str"");
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  StructureDefinition sd=loadResourceFromClasspath(StructureDefinition.class,""String_Node_Str"");
  sd.setId(new IdType());
  sd.setUrl(""String_Node_Str"" + methodName);
  myStructureDefinitionDao.create(sd,mySrd);
  Observation input=new Observation();
  input.getMeta().getProfile().add(new IdType(sd.getUrl()));
  input.addIdentifier().setSystem(""String_Node_Str"").setValue(""String_Node_Str"");
  input.getContext().setReference(""String_Node_Str"");
  input.setStatus(ObservationStatus.FINAL);
  input.getCode().addCoding().setSystem(""String_Node_Str"").setCode(""String_Node_Str"");
  String encoded=null;
  MethodOutcome outcome=null;
  ValidationModeEnum mode=ValidationModeEnum.CREATE;
switch (enc) {
case JSON:
    encoded=myFhirCtx.newJsonParser().encodeResourceToString(input);
  try {
    myObservationDao.validate(input,null,encoded,EncodingEnum.JSON,mode,null,mySrd);
    fail();
  }
 catch (  PreconditionFailedException e) {
    return (OperationOutcome)e.getOperationOutcome();
  }
case XML:
encoded=myFhirCtx.newXmlParser().encodeResourceToString(input);
try {
myObservationDao.validate(input,null,encoded,EncodingEnum.XML,mode,null,mySrd);
fail();
}
 catch (PreconditionFailedException e) {
return (OperationOutcome)e.getOperationOutcome();
}
}
throw new IllegalStateException();
}","private OperationOutcome doTestValidateResourceContainingProfileDeclaration(String methodName,EncodingEnum enc) throws IOException {
  Bundle vss=loadResourceFromClasspath(Bundle.class,""String_Node_Str"");
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  myValueSetDao.update((ValueSet)findResourceByIdInBundle(vss,""String_Node_Str""),mySrd);
  StructureDefinition sd=loadResourceFromClasspath(StructureDefinition.class,""String_Node_Str"");
  sd.setId(new IdType());
  sd.setUrl(""String_Node_Str"" + methodName);
  myStructureDefinitionDao.create(sd,mySrd);
  Observation input=new Observation();
  input.getMeta().getProfile().add(new IdType(sd.getUrl()));
  input.addIdentifier().setSystem(""String_Node_Str"").setValue(""String_Node_Str"");
  input.getContext().setReference(""String_Node_Str"");
  input.setStatus(ObservationStatus.FINAL);
  input.getCode().addCoding().setSystem(""String_Node_Str"").setCode(""String_Node_Str"");
  String encoded=null;
  MethodOutcome outcome=null;
  ValidationModeEnum mode=ValidationModeEnum.CREATE;
switch (enc) {
case JSON:
    encoded=myFhirCtx.newJsonParser().encodeResourceToString(input);
  try {
    myObservationDao.validate(input,null,encoded,EncodingEnum.JSON,mode,null,mySrd);
    fail();
  }
 catch (  PreconditionFailedException e) {
    return (OperationOutcome)e.getOperationOutcome();
  }
break;
case XML:
encoded=myFhirCtx.newXmlParser().encodeResourceToString(input);
try {
myObservationDao.validate(input,null,encoded,EncodingEnum.XML,mode,null,mySrd);
fail();
}
 catch (PreconditionFailedException e) {
return (OperationOutcome)e.getOperationOutcome();
}
break;
}
throw new IllegalStateException();
}",0.9969631236442515
112212,"@Override public IBundleProvider invokeServer(IRestfulServer<?> theServer,RequestDetails theRequest,Object[] theMethodParams) throws InvalidRequestException, InternalErrorException {
  IIdType requestId=theRequest.getId();
  theMethodParams[myIdIndex]=ParameterUtil.convertIdToType(requestId,myIdParameterType);
  Object response=invokeServerMethod(theServer,theRequest,theMethodParams);
  IBundleProvider retVal=toResourceList(response);
  if (retVal.size() == 1) {
    List<IBaseResource> responseResources=retVal.getResources(0,1);
    IBaseResource responseResource=responseResources.get(0);
    if (theRequest.getServer().getETagSupport() == ETagSupportEnum.ENABLED) {
      String ifNoneMatch=theRequest.getHeader(Constants.HEADER_IF_NONE_MATCH_LC);
      if (StringUtils.isNotBlank(ifNoneMatch)) {
        ifNoneMatch=ParameterUtil.parseETagValue(ifNoneMatch);
        if (responseResource.getIdElement() != null && responseResource.getIdElement().hasVersionIdPart()) {
          if (responseResource.getIdElement().getVersionIdPart().equals(ifNoneMatch)) {
            ourLog.debug(""String_Node_Str"",Constants.HEADER_IF_NONE_MATCH,ifNoneMatch);
            throw new NotModifiedException(""String_Node_Str"");
          }
        }
      }
    }
    String ifModifiedSince=theRequest.getHeader(Constants.HEADER_IF_MODIFIED_SINCE_LC);
    if (isNotBlank(ifModifiedSince)) {
      Date ifModifiedSinceDate=DateUtils.parseDate(ifModifiedSince);
      Date lastModified=null;
      if (responseResource instanceof IResource) {
        InstantDt lastModifiedDt=ResourceMetadataKeyEnum.UPDATED.get((IResource)responseResource);
        if (lastModifiedDt != null) {
          lastModified=lastModifiedDt.getValue();
        }
      }
 else {
        lastModified=responseResource.getMeta().getLastUpdated();
      }
      if (lastModified != null && lastModified.getTime() > ifModifiedSinceDate.getTime()) {
        ourLog.debug(""String_Node_Str"");
        throw new NotModifiedException(""String_Node_Str"");
      }
    }
  }
  return retVal;
}","@Override public IBundleProvider invokeServer(IRestfulServer<?> theServer,RequestDetails theRequest,Object[] theMethodParams) throws InvalidRequestException, InternalErrorException {
  IIdType requestId=theRequest.getId();
  theMethodParams[myIdIndex]=ParameterUtil.convertIdToType(requestId,myIdParameterType);
  Object response=invokeServerMethod(theServer,theRequest,theMethodParams);
  IBundleProvider retVal=toResourceList(response);
  if (retVal.size() == 1) {
    List<IBaseResource> responseResources=retVal.getResources(0,1);
    IBaseResource responseResource=responseResources.get(0);
    if (theRequest.getServer().getETagSupport() == ETagSupportEnum.ENABLED) {
      String ifNoneMatch=theRequest.getHeader(Constants.HEADER_IF_NONE_MATCH_LC);
      if (StringUtils.isNotBlank(ifNoneMatch)) {
        ifNoneMatch=ParameterUtil.parseETagValue(ifNoneMatch);
        if (responseResource.getIdElement() != null && responseResource.getIdElement().hasVersionIdPart()) {
          if (responseResource.getIdElement().getVersionIdPart().equals(ifNoneMatch)) {
            ourLog.debug(""String_Node_Str"",Constants.HEADER_IF_NONE_MATCH,ifNoneMatch);
            throw new NotModifiedException(""String_Node_Str"");
          }
        }
      }
    }
    String ifModifiedSince=theRequest.getHeader(Constants.HEADER_IF_MODIFIED_SINCE_LC);
    if (isNotBlank(ifModifiedSince)) {
      Date ifModifiedSinceDate=DateUtils.parseDate(ifModifiedSince);
      Date lastModified=null;
      if (responseResource instanceof IResource) {
        InstantDt lastModifiedDt=ResourceMetadataKeyEnum.UPDATED.get((IResource)responseResource);
        if (lastModifiedDt != null) {
          lastModified=lastModifiedDt.getValue();
        }
      }
 else {
        lastModified=responseResource.getMeta().getLastUpdated();
      }
      if (lastModified != null && lastModified.getTime() <= ifModifiedSinceDate.getTime()) {
        ourLog.debug(""String_Node_Str"");
        throw new NotModifiedException(""String_Node_Str"");
      }
    }
  }
  return retVal;
}",0.9992663242846662
112213,"@Test public void testIfModifiedSince() throws Exception {
  CloseableHttpResponse status;
  HttpGet httpGet;
  httpGet=new HttpGet(""String_Node_Str"" + ourPort + ""String_Node_Str"");
  httpGet.addHeader(Constants.HEADER_IF_MODIFIED_SINCE,DateUtils.formatDate(new InstantDt(""String_Node_Str"").getValue()));
  status=ourClient.execute(httpGet);
  try {
    assertEquals(200,status.getStatusLine().getStatusCode());
  }
  finally {
    IOUtils.closeQuietly(status);
  }
  httpGet=new HttpGet(""String_Node_Str"" + ourPort + ""String_Node_Str"");
  httpGet.addHeader(Constants.HEADER_IF_MODIFIED_SINCE,DateUtils.formatDate(new InstantDt(""String_Node_Str"").getValue()));
  status=ourClient.execute(httpGet);
  try {
    assertEquals(304,status.getStatusLine().getStatusCode());
  }
  finally {
    IOUtils.closeQuietly(status);
  }
}","@Test public void testIfModifiedSince() throws Exception {
  CloseableHttpResponse status;
  HttpGet httpGet;
  httpGet=new HttpGet(""String_Node_Str"" + ourPort + ""String_Node_Str"");
  httpGet.addHeader(Constants.HEADER_IF_MODIFIED_SINCE,DateUtils.formatDate(new InstantDt(""String_Node_Str"").getValue()));
  status=ourClient.execute(httpGet);
  try {
    assertEquals(304,status.getStatusLine().getStatusCode());
  }
  finally {
    IOUtils.closeQuietly(status);
  }
  httpGet=new HttpGet(""String_Node_Str"" + ourPort + ""String_Node_Str"");
  httpGet.addHeader(Constants.HEADER_IF_MODIFIED_SINCE,DateUtils.formatDate(new InstantDt(""String_Node_Str"").getValue()));
  status=ourClient.execute(httpGet);
  try {
    assertEquals(304,status.getStatusLine().getStatusCode());
  }
  finally {
    IOUtils.closeQuietly(status);
  }
  httpGet=new HttpGet(""String_Node_Str"" + ourPort + ""String_Node_Str"");
  httpGet.addHeader(Constants.HEADER_IF_MODIFIED_SINCE,DateUtils.formatDate(new InstantDt(""String_Node_Str"").getValue()));
  status=ourClient.execute(httpGet);
  try {
    assertEquals(200,status.getStatusLine().getStatusCode());
  }
  finally {
    IOUtils.closeQuietly(status);
  }
}",0.4665334665334665
112214,"/** 
 * Returns the value of this ID. Note that this value may be a fully qualified URL, a relative/partial URL, or a simple ID. Use   {@link #getIdPart()} to get just the ID portion.
 * @see #getIdPart()
 */
@Override public String getValue(){
  if (super.getValue() == null && myHaveComponentParts) {
    if (isLocal() || isUrn()) {
      return myUnqualifiedId;
    }
    StringBuilder b=new StringBuilder();
    if (isNotBlank(myBaseUrl)) {
      b.append(myBaseUrl);
      if (myBaseUrl.charAt(myBaseUrl.length() - 1) != '/') {
        b.append('/');
      }
    }
    if (isNotBlank(myResourceType)) {
      b.append(myResourceType);
    }
    if (b.length() > 0) {
      b.append('/');
    }
    b.append(myUnqualifiedId);
    if (isNotBlank(myUnqualifiedVersionId)) {
      b.append('/');
      b.append(Constants.PARAM_HISTORY);
      b.append('/');
      b.append(myUnqualifiedVersionId);
    }
    String value=b.toString();
    super.setValue(value);
  }
  return super.getValue();
}","/** 
 * Returns the value of this ID. Note that this value may be a fully qualified URL, a relative/partial URL, or a simple ID. Use   {@link #getIdPart()} to get just the ID portion.
 * @see #getIdPart()
 */
@Override public String getValue(){
  if (super.getValue() == null && myHaveComponentParts) {
    if (isLocal() || isUrn()) {
      return myUnqualifiedId;
    }
    StringBuilder b=new StringBuilder();
    if (isNotBlank(myBaseUrl)) {
      b.append(myBaseUrl);
      if (myBaseUrl.charAt(myBaseUrl.length() - 1) != '/') {
        b.append('/');
      }
    }
    if (isNotBlank(myResourceType)) {
      b.append(myResourceType);
    }
    if (b.length() > 0 && isNotBlank(myUnqualifiedId)) {
      b.append('/');
    }
    if (isNotBlank(myUnqualifiedId)) {
      b.append(myUnqualifiedId);
    }
 else     if (isNotBlank(myUnqualifiedVersionId)) {
      b.append('/');
    }
    if (isNotBlank(myUnqualifiedVersionId)) {
      b.append('/');
      b.append(Constants.PARAM_HISTORY);
      b.append('/');
      b.append(myUnqualifiedVersionId);
    }
    String value=b.toString();
    super.setValue(value);
  }
  return super.getValue();
}",0.9184909175593852
112215,"/** 
 * Set the value <p> <b>Description</b>: A whole number in the range 0 to 2^64-1 (optionally represented in hex), a uuid, an oid, or any other combination of lowercase letters, numerals, ""-"" and ""."", with a length limit of 36 characters. </p> <p> regex: [a-z0-9\-\.]{1,36} </p>
 */
@Override public IdDt setValue(String theValue) throws DataFormatException {
  super.setValue(theValue);
  myHaveComponentParts=false;
  if (StringUtils.isBlank(theValue)) {
    myBaseUrl=null;
    super.setValue(null);
    myUnqualifiedId=null;
    myUnqualifiedVersionId=null;
    myResourceType=null;
  }
 else   if (theValue.charAt(0) == '#' && theValue.length() > 1) {
    super.setValue(theValue);
    myBaseUrl=null;
    myUnqualifiedId=theValue;
    myUnqualifiedVersionId=null;
    myResourceType=null;
    myHaveComponentParts=true;
  }
 else   if (theValue.startsWith(""String_Node_Str"")) {
    myBaseUrl=null;
    myUnqualifiedId=theValue;
    myUnqualifiedVersionId=null;
    myResourceType=null;
    myHaveComponentParts=true;
  }
 else {
    int vidIndex=theValue.indexOf(""String_Node_Str"");
    int idIndex;
    if (vidIndex != -1) {
      myUnqualifiedVersionId=theValue.substring(vidIndex + ""String_Node_Str"".length());
      idIndex=theValue.lastIndexOf('/',vidIndex - 1);
      myUnqualifiedId=theValue.substring(idIndex + 1,vidIndex);
    }
 else {
      idIndex=theValue.lastIndexOf('/');
      myUnqualifiedId=theValue.substring(idIndex + 1);
      myUnqualifiedVersionId=null;
    }
    myBaseUrl=null;
    if (idIndex <= 0) {
      myResourceType=null;
    }
 else {
      int typeIndex=theValue.lastIndexOf('/',idIndex - 1);
      if (typeIndex == -1) {
        myResourceType=theValue.substring(0,idIndex);
      }
 else {
        myResourceType=theValue.substring(typeIndex + 1,idIndex);
        if (typeIndex > 4) {
          myBaseUrl=theValue.substring(0,typeIndex);
        }
      }
    }
  }
  return this;
}","/** 
 * Set the value <p> <b>Description</b>: A whole number in the range 0 to 2^64-1 (optionally represented in hex), a uuid, an oid, or any other combination of lowercase letters, numerals, ""-"" and ""."", with a length limit of 36 characters. </p> <p> regex: [a-z0-9\-\.]{1,36} </p>
 */
@Override public IdDt setValue(String theValue) throws DataFormatException {
  super.setValue(theValue);
  myHaveComponentParts=false;
  if (StringUtils.isBlank(theValue)) {
    myBaseUrl=null;
    super.setValue(null);
    myUnqualifiedId=null;
    myUnqualifiedVersionId=null;
    myResourceType=null;
  }
 else   if (theValue.charAt(0) == '#' && theValue.length() > 1) {
    super.setValue(theValue);
    myBaseUrl=null;
    myUnqualifiedId=theValue;
    myUnqualifiedVersionId=null;
    myResourceType=null;
    myHaveComponentParts=true;
  }
 else   if (theValue.startsWith(""String_Node_Str"")) {
    myBaseUrl=null;
    myUnqualifiedId=theValue;
    myUnqualifiedVersionId=null;
    myResourceType=null;
    myHaveComponentParts=true;
  }
 else {
    int vidIndex=theValue.indexOf(""String_Node_Str"");
    int idIndex;
    if (vidIndex != -1) {
      myUnqualifiedVersionId=theValue.substring(vidIndex + ""String_Node_Str"".length());
      idIndex=theValue.lastIndexOf('/',vidIndex - 1);
      myUnqualifiedId=theValue.substring(idIndex + 1,vidIndex);
    }
 else {
      idIndex=theValue.lastIndexOf('/');
      myUnqualifiedId=theValue.substring(idIndex + 1);
      myUnqualifiedVersionId=null;
    }
    myBaseUrl=null;
    if (idIndex <= 0) {
      myResourceType=null;
    }
 else {
      int typeIndex=theValue.lastIndexOf('/',idIndex - 1);
      if (typeIndex == -1) {
        myResourceType=theValue.substring(0,idIndex);
      }
 else {
        if (typeIndex > 0 && '/' == theValue.charAt(typeIndex - 1)) {
          typeIndex=theValue.indexOf('/',typeIndex + 1);
        }
        if (typeIndex >= idIndex) {
          myResourceType=myUnqualifiedId;
          myUnqualifiedId=null;
          super.setValue(null);
          myHaveComponentParts=true;
        }
 else {
          myResourceType=theValue.substring(typeIndex + 1,idIndex);
        }
        if (typeIndex > 4) {
          myBaseUrl=theValue.substring(0,typeIndex);
        }
      }
    }
  }
  return this;
}",0.917658257972394
112216,"public void setTargetResourceUrl(IIdType theTargetResourceUrl){
  Validate.isTrue(theTargetResourceUrl.hasBaseUrl());
  Validate.isTrue(theTargetResourceUrl.hasResourceType());
  Validate.isTrue(theTargetResourceUrl.hasIdPart());
  myTargetResourceType=theTargetResourceUrl.getResourceType();
  myTargetResourceUrl=theTargetResourceUrl.getValue();
}","public void setTargetResourceUrl(IIdType theTargetResourceUrl){
  Validate.isTrue(theTargetResourceUrl.hasBaseUrl());
  Validate.isTrue(theTargetResourceUrl.hasResourceType());
  if (theTargetResourceUrl.hasIdPart()) {
  }
 else {
  }
  myTargetResourceType=theTargetResourceUrl.getResourceType();
  myTargetResourceUrl=theTargetResourceUrl.getValue();
}",0.5291607396870555
112217,"/** 
 * Returns the value of this ID. Note that this value may be a fully qualified URL, a relative/partial URL, or a simple ID. Use   {@link #getIdPart()} toget just the ID portion.
 * @see #getIdPart()
 */
@Override public String getValue(){
  String retVal=super.getValue();
  if (retVal == null && myHaveComponentParts) {
    if (isLocal() || isUrn()) {
      return myUnqualifiedId;
    }
    StringBuilder b=new StringBuilder();
    if (isNotBlank(myBaseUrl)) {
      b.append(myBaseUrl);
      if (myBaseUrl.charAt(myBaseUrl.length() - 1) != '/') {
        b.append('/');
      }
    }
    if (isNotBlank(myResourceType)) {
      b.append(myResourceType);
    }
    if (b.length() > 0) {
      b.append('/');
    }
    b.append(myUnqualifiedId);
    if (isNotBlank(myUnqualifiedVersionId)) {
      b.append('/');
      b.append(""String_Node_Str"");
      b.append('/');
      b.append(myUnqualifiedVersionId);
    }
    retVal=b.toString();
    super.setValue(retVal);
  }
  return retVal;
}","/** 
 * Returns the value of this ID. Note that this value may be a fully qualified URL, a relative/partial URL, or a simple ID. Use   {@link #getIdPart()} toget just the ID portion.
 * @see #getIdPart()
 */
@Override public String getValue(){
  String retVal=super.getValue();
  if (retVal == null && myHaveComponentParts) {
    if (isLocal() || isUrn()) {
      return myUnqualifiedId;
    }
    StringBuilder b=new StringBuilder();
    if (isNotBlank(myBaseUrl)) {
      b.append(myBaseUrl);
      if (myBaseUrl.charAt(myBaseUrl.length() - 1) != '/') {
        b.append('/');
      }
    }
    if (isNotBlank(myResourceType)) {
      b.append(myResourceType);
    }
    if (b.length() > 0 && isNotBlank(myUnqualifiedId)) {
      b.append('/');
    }
    if (isNotBlank(myUnqualifiedId)) {
      b.append(myUnqualifiedId);
    }
 else     if (isNotBlank(myUnqualifiedVersionId)) {
      b.append('/');
    }
    if (isNotBlank(myUnqualifiedVersionId)) {
      b.append('/');
      b.append(""String_Node_Str"");
      b.append('/');
      b.append(myUnqualifiedVersionId);
    }
    retVal=b.toString();
    super.setValue(retVal);
  }
  return retVal;
}",0.8916782891678289
112218,"/** 
 * Set the value <p> <b>Description</b>: A whole number in the range 0 to 2^64-1 (optionally represented in hex), a uuid, an oid, or any other combination of lowercase letters, numerals, ""-"" and ""."", with a length limit of 36 characters. </p> <p> regex: [a-z0-9\-\.]{1,36} </p>
 */
@Override public IdType setValue(String theValue){
  super.setValue(theValue);
  myHaveComponentParts=false;
  if (StringUtils.isBlank(theValue)) {
    myBaseUrl=null;
    super.setValue(null);
    myUnqualifiedId=null;
    myUnqualifiedVersionId=null;
    myResourceType=null;
  }
 else   if (theValue.charAt(0) == '#' && theValue.length() > 1) {
    super.setValue(theValue);
    myBaseUrl=null;
    myUnqualifiedId=theValue;
    myUnqualifiedVersionId=null;
    myResourceType=null;
    myHaveComponentParts=true;
  }
 else   if (theValue.startsWith(""String_Node_Str"")) {
    myBaseUrl=null;
    myUnqualifiedId=theValue;
    myUnqualifiedVersionId=null;
    myResourceType=null;
    myHaveComponentParts=true;
  }
 else {
    int vidIndex=theValue.indexOf(""String_Node_Str"");
    int idIndex;
    if (vidIndex != -1) {
      myUnqualifiedVersionId=theValue.substring(vidIndex + ""String_Node_Str"".length());
      idIndex=theValue.lastIndexOf('/',vidIndex - 1);
      myUnqualifiedId=theValue.substring(idIndex + 1,vidIndex);
    }
 else {
      idIndex=theValue.lastIndexOf('/');
      myUnqualifiedId=theValue.substring(idIndex + 1);
      myUnqualifiedVersionId=null;
    }
    myBaseUrl=null;
    if (idIndex <= 0) {
      myResourceType=null;
    }
 else {
      int typeIndex=theValue.lastIndexOf('/',idIndex - 1);
      if (typeIndex == -1) {
        myResourceType=theValue.substring(0,idIndex);
      }
 else {
        myResourceType=theValue.substring(typeIndex + 1,idIndex);
        if (typeIndex > 4) {
          myBaseUrl=theValue.substring(0,typeIndex);
        }
      }
    }
  }
  return this;
}","/** 
 * Set the value <p> <b>Description</b>: A whole number in the range 0 to 2^64-1 (optionally represented in hex), a uuid, an oid, or any other combination of lowercase letters, numerals, ""-"" and ""."", with a length limit of 36 characters. </p> <p> regex: [a-z0-9\-\.]{1,36} </p>
 */
@Override public IdType setValue(String theValue){
  super.setValue(theValue);
  myHaveComponentParts=false;
  if (StringUtils.isBlank(theValue)) {
    myBaseUrl=null;
    super.setValue(null);
    myUnqualifiedId=null;
    myUnqualifiedVersionId=null;
    myResourceType=null;
  }
 else   if (theValue.charAt(0) == '#' && theValue.length() > 1) {
    super.setValue(theValue);
    myBaseUrl=null;
    myUnqualifiedId=theValue;
    myUnqualifiedVersionId=null;
    myResourceType=null;
    myHaveComponentParts=true;
  }
 else   if (theValue.startsWith(""String_Node_Str"")) {
    myBaseUrl=null;
    myUnqualifiedId=theValue;
    myUnqualifiedVersionId=null;
    myResourceType=null;
    myHaveComponentParts=true;
  }
 else {
    int vidIndex=theValue.indexOf(""String_Node_Str"");
    int idIndex;
    if (vidIndex != -1) {
      myUnqualifiedVersionId=theValue.substring(vidIndex + ""String_Node_Str"".length());
      idIndex=theValue.lastIndexOf('/',vidIndex - 1);
      myUnqualifiedId=theValue.substring(idIndex + 1,vidIndex);
    }
 else {
      idIndex=theValue.lastIndexOf('/');
      myUnqualifiedId=theValue.substring(idIndex + 1);
      myUnqualifiedVersionId=null;
    }
    myBaseUrl=null;
    if (idIndex <= 0) {
      myResourceType=null;
    }
 else {
      int typeIndex=theValue.lastIndexOf('/',idIndex - 1);
      if (typeIndex == -1) {
        myResourceType=theValue.substring(0,idIndex);
      }
 else {
        if (typeIndex > 0 && '/' == theValue.charAt(typeIndex - 1)) {
          typeIndex=theValue.indexOf('/',typeIndex + 1);
        }
        if (typeIndex >= idIndex) {
          myResourceType=myUnqualifiedId;
          myUnqualifiedId=null;
          super.setValue(null);
          myHaveComponentParts=true;
        }
 else {
          myResourceType=theValue.substring(typeIndex + 1,idIndex);
        }
        if (typeIndex > 4) {
          myBaseUrl=theValue.substring(0,typeIndex);
        }
      }
    }
  }
  return this;
}",0.9166265060240965
112219,"/** 
 * Returns the value of this ID. Note that this value may be a fully qualified URL, a relative/partial URL, or a simple ID. Use   {@link #getIdPart()} toget just the ID portion.
 * @see #getIdPart()
 */
@Override public String getValue(){
  String retVal=super.getValue();
  if (retVal == null && myHaveComponentParts) {
    if (isLocal() || isUrn()) {
      return myUnqualifiedId;
    }
    StringBuilder b=new StringBuilder();
    if (isNotBlank(myBaseUrl)) {
      b.append(myBaseUrl);
      if (myBaseUrl.charAt(myBaseUrl.length() - 1) != '/') {
        b.append('/');
      }
    }
    if (isNotBlank(myResourceType)) {
      b.append(myResourceType);
    }
    if (b.length() > 0) {
      b.append('/');
    }
    b.append(myUnqualifiedId);
    if (isNotBlank(myUnqualifiedVersionId)) {
      b.append('/');
      b.append(""String_Node_Str"");
      b.append('/');
      b.append(myUnqualifiedVersionId);
    }
    retVal=b.toString();
    super.setValue(retVal);
  }
  return retVal;
}","/** 
 * Returns the value of this ID. Note that this value may be a fully qualified URL, a relative/partial URL, or a simple ID. Use   {@link #getIdPart()} toget just the ID portion.
 * @see #getIdPart()
 */
@Override public String getValue(){
  String retVal=super.getValue();
  if (retVal == null && myHaveComponentParts) {
    if (isLocal() || isUrn()) {
      return myUnqualifiedId;
    }
    StringBuilder b=new StringBuilder();
    if (isNotBlank(myBaseUrl)) {
      b.append(myBaseUrl);
      if (myBaseUrl.charAt(myBaseUrl.length() - 1) != '/') {
        b.append('/');
      }
    }
    if (isNotBlank(myResourceType)) {
      b.append(myResourceType);
    }
    if (b.length() > 0 && isNotBlank(myUnqualifiedId)) {
      b.append('/');
    }
    if (isNotBlank(myUnqualifiedId)) {
      b.append(myUnqualifiedId);
    }
 else     if (isNotBlank(myUnqualifiedVersionId)) {
      b.append('/');
    }
    if (isNotBlank(myUnqualifiedVersionId)) {
      b.append('/');
      b.append(""String_Node_Str"");
      b.append('/');
      b.append(myUnqualifiedVersionId);
    }
    retVal=b.toString();
    super.setValue(retVal);
  }
  return retVal;
}",0.8916782891678289
112220,"/** 
 * Set the value <p> <b>Description</b>: A whole number in the range 0 to 2^64-1 (optionally represented in hex), a uuid, an oid, or any other combination of lowercase letters, numerals, ""-"" and ""."", with a length limit of 36 characters. </p> <p> regex: [a-z0-9\-\.]{1,36} </p>
 */
@Override public IdType setValue(String theValue){
  super.setValue(theValue);
  myHaveComponentParts=false;
  if (StringUtils.isBlank(theValue)) {
    myBaseUrl=null;
    super.setValue(null);
    myUnqualifiedId=null;
    myUnqualifiedVersionId=null;
    myResourceType=null;
  }
 else   if (theValue.charAt(0) == '#' && theValue.length() > 1) {
    super.setValue(theValue);
    myBaseUrl=null;
    myUnqualifiedId=theValue;
    myUnqualifiedVersionId=null;
    myResourceType=null;
    myHaveComponentParts=true;
  }
 else   if (theValue.startsWith(""String_Node_Str"")) {
    myBaseUrl=null;
    myUnqualifiedId=theValue;
    myUnqualifiedVersionId=null;
    myResourceType=null;
    myHaveComponentParts=true;
  }
 else {
    int vidIndex=theValue.indexOf(""String_Node_Str"");
    int idIndex;
    if (vidIndex != -1) {
      myUnqualifiedVersionId=theValue.substring(vidIndex + ""String_Node_Str"".length());
      idIndex=theValue.lastIndexOf('/',vidIndex - 1);
      myUnqualifiedId=theValue.substring(idIndex + 1,vidIndex);
    }
 else {
      idIndex=theValue.lastIndexOf('/');
      myUnqualifiedId=theValue.substring(idIndex + 1);
      myUnqualifiedVersionId=null;
    }
    myBaseUrl=null;
    if (idIndex <= 0) {
      myResourceType=null;
    }
 else {
      int typeIndex=theValue.lastIndexOf('/',idIndex - 1);
      if (typeIndex == -1) {
        myResourceType=theValue.substring(0,idIndex);
      }
 else {
        myResourceType=theValue.substring(typeIndex + 1,idIndex);
        if (typeIndex > 4) {
          myBaseUrl=theValue.substring(0,typeIndex);
        }
      }
    }
  }
  return this;
}","/** 
 * Set the value <p> <b>Description</b>: A whole number in the range 0 to 2^64-1 (optionally represented in hex), a uuid, an oid, or any other combination of lowercase letters, numerals, ""-"" and ""."", with a length limit of 36 characters. </p> <p> regex: [a-z0-9\-\.]{1,36} </p>
 */
@Override public IdType setValue(String theValue){
  super.setValue(theValue);
  myHaveComponentParts=false;
  if (StringUtils.isBlank(theValue)) {
    myBaseUrl=null;
    super.setValue(null);
    myUnqualifiedId=null;
    myUnqualifiedVersionId=null;
    myResourceType=null;
  }
 else   if (theValue.charAt(0) == '#' && theValue.length() > 1) {
    super.setValue(theValue);
    myBaseUrl=null;
    myUnqualifiedId=theValue;
    myUnqualifiedVersionId=null;
    myResourceType=null;
    myHaveComponentParts=true;
  }
 else   if (theValue.startsWith(""String_Node_Str"")) {
    myBaseUrl=null;
    myUnqualifiedId=theValue;
    myUnqualifiedVersionId=null;
    myResourceType=null;
    myHaveComponentParts=true;
  }
 else {
    int vidIndex=theValue.indexOf(""String_Node_Str"");
    int idIndex;
    if (vidIndex != -1) {
      myUnqualifiedVersionId=theValue.substring(vidIndex + ""String_Node_Str"".length());
      idIndex=theValue.lastIndexOf('/',vidIndex - 1);
      myUnqualifiedId=theValue.substring(idIndex + 1,vidIndex);
    }
 else {
      idIndex=theValue.lastIndexOf('/');
      myUnqualifiedId=theValue.substring(idIndex + 1);
      myUnqualifiedVersionId=null;
    }
    myBaseUrl=null;
    if (idIndex <= 0) {
      myResourceType=null;
    }
 else {
      int typeIndex=theValue.lastIndexOf('/',idIndex - 1);
      if (typeIndex == -1) {
        myResourceType=theValue.substring(0,idIndex);
      }
 else {
        if (typeIndex > 0 && '/' == theValue.charAt(typeIndex - 1)) {
          typeIndex=theValue.indexOf('/',typeIndex + 1);
        }
        if (typeIndex >= idIndex) {
          myResourceType=myUnqualifiedId;
          myUnqualifiedId=null;
          super.setValue(null);
          myHaveComponentParts=true;
        }
 else {
          myResourceType=theValue.substring(typeIndex + 1,idIndex);
        }
        if (typeIndex > 4) {
          myBaseUrl=theValue.substring(0,typeIndex);
        }
      }
    }
  }
  return this;
}",0.9166265060240965
112221,"/** 
 * @return Returns a set containing all of the parameter names thatwere found to have a value
 */
@SuppressWarnings(""String_Node_Str"") protected Set<String> extractResourceLinks(ResourceTable theEntity,IBaseResource theResource,Set<ResourceLink> theLinks,Date theUpdateTime){
  HashSet<String> retVal=new HashSet<String>();
  if (theResource instanceof IBaseBundle) {
    return Collections.emptySet();
  }
  Map<String,RuntimeSearchParam> searchParams=mySearchParamRegistry.getActiveSearchParams(toResourceName(theResource.getClass()));
  for (  RuntimeSearchParam nextSpDef : searchParams.values()) {
    if (nextSpDef.getParamType() != RestSearchParameterTypeEnum.REFERENCE) {
      continue;
    }
    String nextPathsUnsplit=nextSpDef.getPath();
    if (isBlank(nextPathsUnsplit)) {
      continue;
    }
    boolean multiType=false;
    if (nextPathsUnsplit.endsWith(""String_Node_Str"")) {
      multiType=true;
    }
    List<PathAndRef> refs=mySearchParamExtractor.extractResourceLinks(theResource,nextSpDef);
    for (    PathAndRef nextPathAndRef : refs) {
      Object nextObject=nextPathAndRef.getRef();
      if (nextObject instanceof IBaseExtension<?,?>) {
        nextObject=((IBaseExtension<?,?>)nextObject).getValue();
      }
      IIdType nextId;
      if (nextObject instanceof IBaseReference) {
        IBaseReference nextValue=(IBaseReference)nextObject;
        if (nextValue.isEmpty()) {
          continue;
        }
        nextId=nextValue.getReferenceElement();
        if (nextId.isEmpty() || nextId.getValue().startsWith(""String_Node_Str"")) {
          continue;
        }
      }
 else       if (nextObject instanceof IBaseResource) {
        nextId=((IBaseResource)nextObject).getIdElement();
        if (nextId == null || nextId.hasIdPart() == false) {
          continue;
        }
      }
 else       if (myContext.getElementDefinition((Class<? extends IBase>)nextObject.getClass()).getName().equals(""String_Node_Str"")) {
        continue;
      }
 else {
        if (!multiType) {
          if (nextSpDef.getName().equals(""String_Node_Str"")) {
            continue;
          }
          throw new ConfigurationException(""String_Node_Str"" + nextSpDef.getName() + ""String_Node_Str""+ nextObject.getClass());
        }
 else {
          continue;
        }
      }
      retVal.add(nextSpDef.getName());
      if (isLogicalReference(nextId)) {
        ResourceLink resourceLink=new ResourceLink(nextPathAndRef.getPath(),theEntity,nextId,theUpdateTime);
        if (theLinks.add(resourceLink)) {
          ourLog.debug(""String_Node_Str"",nextId);
        }
        continue;
      }
      String baseUrl=nextId.getBaseUrl();
      String typeString=nextId.getResourceType();
      if (isBlank(typeString)) {
        throw new InvalidRequestException(""String_Node_Str"" + nextPathsUnsplit + ""String_Node_Str""+ nextId.getValue());
      }
      RuntimeResourceDefinition resourceDefinition;
      try {
        resourceDefinition=getContext().getResourceDefinition(typeString);
      }
 catch (      DataFormatException e) {
        throw new InvalidRequestException(""String_Node_Str"" + nextPathsUnsplit + ""String_Node_Str""+ nextId.getValue());
      }
      if (isNotBlank(baseUrl)) {
        if (!getConfig().getTreatBaseUrlsAsLocal().contains(baseUrl) && !getConfig().isAllowExternalReferences()) {
          String msg=getContext().getLocalizer().getMessage(BaseHapiFhirDao.class,""String_Node_Str"",nextId.getValue());
          throw new InvalidRequestException(msg);
        }
 else {
          ResourceLink resourceLink=new ResourceLink(nextPathAndRef.getPath(),theEntity,nextId,theUpdateTime);
          if (theLinks.add(resourceLink)) {
            ourLog.info(""String_Node_Str"",nextId);
          }
          continue;
        }
      }
      Class<? extends IBaseResource> type=resourceDefinition.getImplementingClass();
      String id=nextId.getIdPart();
      if (StringUtils.isBlank(id)) {
        throw new InvalidRequestException(""String_Node_Str"" + nextPathsUnsplit + ""String_Node_Str""+ nextId.getValue());
      }
      IFhirResourceDao<?> dao=getDao(type);
      if (dao == null) {
        StringBuilder b=new StringBuilder();
        b.append(""String_Node_Str"");
        b.append(myContext.getVersion().getVersion());
        b.append(""String_Node_Str"");
        b.append(nextId.getResourceType());
        b.append(""String_Node_Str"");
        b.append(myResourceTypeToDao.keySet().toString());
        throw new InvalidRequestException(b.toString());
      }
      Long valueOf;
      try {
        valueOf=translateForcedIdToPid(typeString,id);
      }
 catch (      ResourceNotFoundException e) {
        if (myConfig.isEnforceReferentialIntegrityOnWrite() == false) {
          continue;
        }
        String resName=getContext().getResourceDefinition(type).getName();
        throw new InvalidRequestException(""String_Node_Str"" + resName + ""String_Node_Str""+ id+ ""String_Node_Str""+ nextPathsUnsplit);
      }
      ResourceTable target=myEntityManager.find(ResourceTable.class,valueOf);
      RuntimeResourceDefinition targetResourceDef=getContext().getResourceDefinition(type);
      if (target == null) {
        String resName=targetResourceDef.getName();
        throw new InvalidRequestException(""String_Node_Str"" + resName + ""String_Node_Str""+ id+ ""String_Node_Str""+ nextPathsUnsplit);
      }
      if (!typeString.equals(target.getResourceType())) {
        throw new UnprocessableEntityException(""String_Node_Str"" + nextId.getValue() + ""String_Node_Str""+ nextId.getIdPart()+ ""String_Node_Str""+ target.getResourceType());
      }
      if (nextSpDef.getTargets() != null && !nextSpDef.getTargets().contains(typeString)) {
        continue;
      }
      ResourceLink resourceLink=new ResourceLink(nextPathAndRef.getPath(),theEntity,target,theUpdateTime);
      theLinks.add(resourceLink);
    }
  }
  theEntity.setHasLinks(theLinks.size() > 0);
  return retVal;
}","/** 
 * @return Returns a set containing all of the parameter names thatwere found to have a value
 */
@SuppressWarnings(""String_Node_Str"") protected Set<String> extractResourceLinks(ResourceTable theEntity,IBaseResource theResource,Set<ResourceLink> theLinks,Date theUpdateTime){
  HashSet<String> retVal=new HashSet<String>();
  if (theResource instanceof IBaseBundle) {
    return Collections.emptySet();
  }
  Map<String,RuntimeSearchParam> searchParams=mySearchParamRegistry.getActiveSearchParams(toResourceName(theResource.getClass()));
  for (  RuntimeSearchParam nextSpDef : searchParams.values()) {
    if (nextSpDef.getParamType() != RestSearchParameterTypeEnum.REFERENCE) {
      continue;
    }
    String nextPathsUnsplit=nextSpDef.getPath();
    if (isBlank(nextPathsUnsplit)) {
      continue;
    }
    boolean multiType=false;
    if (nextPathsUnsplit.endsWith(""String_Node_Str"")) {
      multiType=true;
    }
    List<PathAndRef> refs=mySearchParamExtractor.extractResourceLinks(theResource,nextSpDef);
    for (    PathAndRef nextPathAndRef : refs) {
      Object nextObject=nextPathAndRef.getRef();
      if (nextObject instanceof IBaseExtension<?,?>) {
        nextObject=((IBaseExtension<?,?>)nextObject).getValue();
      }
      IIdType nextId;
      if (nextObject instanceof IBaseReference) {
        IBaseReference nextValue=(IBaseReference)nextObject;
        if (nextValue.isEmpty()) {
          continue;
        }
        nextId=nextValue.getReferenceElement();
        if (nextId.isEmpty() && nextValue.getResource() != null) {
          nextId=nextValue.getResource().getIdElement();
        }
        if (nextId.isEmpty() || nextId.getValue().startsWith(""String_Node_Str"")) {
          continue;
        }
      }
 else       if (nextObject instanceof IBaseResource) {
        nextId=((IBaseResource)nextObject).getIdElement();
        if (nextId == null || nextId.hasIdPart() == false) {
          continue;
        }
      }
 else       if (myContext.getElementDefinition((Class<? extends IBase>)nextObject.getClass()).getName().equals(""String_Node_Str"")) {
        continue;
      }
 else {
        if (!multiType) {
          if (nextSpDef.getName().equals(""String_Node_Str"")) {
            continue;
          }
          throw new ConfigurationException(""String_Node_Str"" + nextSpDef.getName() + ""String_Node_Str""+ nextObject.getClass());
        }
 else {
          continue;
        }
      }
      retVal.add(nextSpDef.getName());
      if (isLogicalReference(nextId)) {
        ResourceLink resourceLink=new ResourceLink(nextPathAndRef.getPath(),theEntity,nextId,theUpdateTime);
        if (theLinks.add(resourceLink)) {
          ourLog.debug(""String_Node_Str"",nextId);
        }
        continue;
      }
      String baseUrl=nextId.getBaseUrl();
      String typeString=nextId.getResourceType();
      if (isBlank(typeString)) {
        throw new InvalidRequestException(""String_Node_Str"" + nextPathsUnsplit + ""String_Node_Str""+ nextId.getValue());
      }
      RuntimeResourceDefinition resourceDefinition;
      try {
        resourceDefinition=getContext().getResourceDefinition(typeString);
      }
 catch (      DataFormatException e) {
        throw new InvalidRequestException(""String_Node_Str"" + nextPathsUnsplit + ""String_Node_Str""+ nextId.getValue());
      }
      if (isNotBlank(baseUrl)) {
        if (!getConfig().getTreatBaseUrlsAsLocal().contains(baseUrl) && !getConfig().isAllowExternalReferences()) {
          String msg=getContext().getLocalizer().getMessage(BaseHapiFhirDao.class,""String_Node_Str"",nextId.getValue());
          throw new InvalidRequestException(msg);
        }
 else {
          ResourceLink resourceLink=new ResourceLink(nextPathAndRef.getPath(),theEntity,nextId,theUpdateTime);
          if (theLinks.add(resourceLink)) {
            ourLog.info(""String_Node_Str"",nextId);
          }
          continue;
        }
      }
      Class<? extends IBaseResource> type=resourceDefinition.getImplementingClass();
      String id=nextId.getIdPart();
      if (StringUtils.isBlank(id)) {
        throw new InvalidRequestException(""String_Node_Str"" + nextPathsUnsplit + ""String_Node_Str""+ nextId.getValue());
      }
      IFhirResourceDao<?> dao=getDao(type);
      if (dao == null) {
        StringBuilder b=new StringBuilder();
        b.append(""String_Node_Str"");
        b.append(myContext.getVersion().getVersion());
        b.append(""String_Node_Str"");
        b.append(nextId.getResourceType());
        b.append(""String_Node_Str"");
        b.append(myResourceTypeToDao.keySet().toString());
        throw new InvalidRequestException(b.toString());
      }
      Long valueOf;
      try {
        valueOf=translateForcedIdToPid(typeString,id);
      }
 catch (      ResourceNotFoundException e) {
        if (myConfig.isEnforceReferentialIntegrityOnWrite() == false) {
          continue;
        }
        String resName=getContext().getResourceDefinition(type).getName();
        throw new InvalidRequestException(""String_Node_Str"" + resName + ""String_Node_Str""+ id+ ""String_Node_Str""+ nextPathsUnsplit);
      }
      ResourceTable target=myEntityManager.find(ResourceTable.class,valueOf);
      RuntimeResourceDefinition targetResourceDef=getContext().getResourceDefinition(type);
      if (target == null) {
        String resName=targetResourceDef.getName();
        throw new InvalidRequestException(""String_Node_Str"" + resName + ""String_Node_Str""+ id+ ""String_Node_Str""+ nextPathsUnsplit);
      }
      if (!typeString.equals(target.getResourceType())) {
        throw new UnprocessableEntityException(""String_Node_Str"" + nextId.getValue() + ""String_Node_Str""+ nextId.getIdPart()+ ""String_Node_Str""+ target.getResourceType());
      }
      if (nextSpDef.getTargets() != null && !nextSpDef.getTargets().contains(typeString)) {
        continue;
      }
      ResourceLink resourceLink=new ResourceLink(nextPathAndRef.getPath(),theEntity,target,theUpdateTime);
      theLinks.add(resourceLink);
    }
  }
  theEntity.setHasLinks(theLinks.size() > 0);
  return retVal;
}",0.9888314719119852
112222,"@Test public void testUpdateFails(){
  Subscription subs=new Subscription();
  subs.getChannel().setType(SubscriptionChannelType.RESTHOOK);
  subs.setStatus(SubscriptionStatus.REQUESTED);
  subs.setCriteria(""String_Node_Str"");
  IIdType id=ourClient.create().resource(subs).execute().getId().toUnqualifiedVersionless();
  subs.setId(id);
  try {
    subs.setStatus(SubscriptionStatus.ACTIVE);
    ourClient.update().resource(subs).execute();
    fail();
  }
 catch (  UnprocessableEntityException e) {
    assertEquals(""String_Node_Str"",e.getMessage());
  }
  try {
    subs.setStatus((SubscriptionStatus)null);
    ourClient.update().resource(subs).execute();
    fail();
  }
 catch (  UnprocessableEntityException e) {
    assertEquals(""String_Node_Str"",e.getMessage());
  }
  subs.setStatus(SubscriptionStatus.OFF);
}","@Test public void testUpdateFails(){
  Subscription subs=new Subscription();
  subs.getChannel().setType(SubscriptionChannelType.RESTHOOK);
  subs.getChannel().setPayload(""String_Node_Str"");
  subs.getChannel().setEndpoint(""String_Node_Str"");
  subs.setStatus(SubscriptionStatus.REQUESTED);
  subs.setCriteria(""String_Node_Str"");
  IIdType id=ourClient.create().resource(subs).execute().getId().toUnqualifiedVersionless();
  subs.setId(id);
  try {
    subs.setStatus(SubscriptionStatus.ACTIVE);
    ourClient.update().resource(subs).execute();
    fail();
  }
 catch (  UnprocessableEntityException e) {
    assertEquals(""String_Node_Str"",e.getMessage());
  }
  try {
    subs.setStatus((SubscriptionStatus)null);
    ourClient.update().resource(subs).execute();
    fail();
  }
 catch (  UnprocessableEntityException e) {
    assertEquals(""String_Node_Str"",e.getMessage());
  }
  subs.setStatus(SubscriptionStatus.OFF);
}",0.9409064830751578
112223,"@Test public void testUpdateToInvalidStatus(){
  Subscription subs=new Subscription();
  subs.getChannel().setType(SubscriptionChannelType.RESTHOOK);
  subs.setCriteria(""String_Node_Str"");
  subs.setStatus(SubscriptionStatus.REQUESTED);
  IIdType id=ourClient.create().resource(subs).execute().getId();
  subs.setId(id);
  try {
    subs.setStatus(SubscriptionStatus.ACTIVE);
    ourClient.update().resource(subs).execute();
    fail();
  }
 catch (  UnprocessableEntityException e) {
    assertEquals(""String_Node_Str"",e.getMessage());
  }
  try {
    subs.setStatus((SubscriptionStatus)null);
    ourClient.update().resource(subs).execute();
    fail();
  }
 catch (  UnprocessableEntityException e) {
    assertEquals(""String_Node_Str"",e.getMessage());
  }
  subs.setStatus(SubscriptionStatus.OFF);
  ourClient.update().resource(subs).execute();
}","@Test public void testUpdateToInvalidStatus(){
  Subscription subs=new Subscription();
  subs.getChannel().setType(SubscriptionChannelType.RESTHOOK);
  subs.getChannel().setPayload(""String_Node_Str"");
  subs.getChannel().setEndpoint(""String_Node_Str"");
  subs.setCriteria(""String_Node_Str"");
  subs.setStatus(SubscriptionStatus.REQUESTED);
  IIdType id=ourClient.create().resource(subs).execute().getId();
  subs.setId(id);
  try {
    subs.setStatus(SubscriptionStatus.ACTIVE);
    ourClient.update().resource(subs).execute();
    fail();
  }
 catch (  UnprocessableEntityException e) {
    assertEquals(""String_Node_Str"",e.getMessage());
  }
  try {
    subs.setStatus((SubscriptionStatus)null);
    ourClient.update().resource(subs).execute();
    fail();
  }
 catch (  UnprocessableEntityException e) {
    assertEquals(""String_Node_Str"",e.getMessage());
  }
  subs.setStatus(SubscriptionStatus.OFF);
  ourClient.update().resource(subs).execute();
}",0.9428729894620078
112224,"@Test public void testCreateInvalidNoStatus(){
  Subscription subs=new Subscription();
  subs.getChannel().setType(SubscriptionChannelType.RESTHOOK);
  subs.setCriteria(""String_Node_Str"");
  try {
    ourClient.create().resource(subs).execute();
    fail();
  }
 catch (  UnprocessableEntityException e) {
    assertEquals(""String_Node_Str"",e.getMessage());
  }
  subs.setId(""String_Node_Str"");
  try {
    ourClient.update().resource(subs).execute();
    fail();
  }
 catch (  UnprocessableEntityException e) {
    assertEquals(""String_Node_Str"",e.getMessage());
  }
  subs.setStatus(SubscriptionStatus.REQUESTED);
  ourClient.update().resource(subs).execute();
}","@Test public void testCreateInvalidNoStatus(){
  Subscription subs=new Subscription();
  subs.getChannel().setType(SubscriptionChannelType.RESTHOOK);
  subs.getChannel().setPayload(""String_Node_Str"");
  subs.getChannel().setEndpoint(""String_Node_Str"");
  subs.setCriteria(""String_Node_Str"");
  try {
    ourClient.create().resource(subs).execute();
    fail();
  }
 catch (  UnprocessableEntityException e) {
    assertEquals(""String_Node_Str"",e.getMessage());
  }
  subs.setId(""String_Node_Str"");
  try {
    ourClient.update().resource(subs).execute();
    fail();
  }
 catch (  UnprocessableEntityException e) {
    assertEquals(""String_Node_Str"",e.getMessage());
  }
  subs.setStatus(SubscriptionStatus.REQUESTED);
  ourClient.update().resource(subs).execute();
}",0.9280223619846262
112225,"@Override public void run(CommandLine theCommandLine) throws ParseException {
  myPort=parseOptionInteger(theCommandLine,OPTION_P,DEFAULT_PORT);
  if (theCommandLine.hasOption(OPTION_LOWMEM)) {
    ourLog.info(""String_Node_Str"");
    System.setProperty(OPTION_LOWMEM,OPTION_LOWMEM);
  }
  if (theCommandLine.hasOption(OPTION_ALLOW_EXTERNAL_REFS)) {
    ourLog.info(""String_Node_Str"");
    ContextHolder.setAllowExternalRefs(true);
  }
  ContextHolder.setCtx(getSpecVersionContext(theCommandLine));
  ourLog.info(""String_Node_Str"",myPort);
  File tempWarFile;
  try {
    tempWarFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    tempWarFile.deleteOnExit();
    InputStream inStream=RunServerCommand.class.getResourceAsStream(""String_Node_Str"");
    OutputStream outStream=new BufferedOutputStream(new FileOutputStream(tempWarFile,false));
    IOUtils.copy(inStream,outStream);
  }
 catch (  IOException e) {
    ourLog.error(""String_Node_Str"",e);
    return;
  }
  final ContextLoaderListener cll=new ContextLoaderListener();
  ourLog.info(""String_Node_Str"",ContextHolder.getCtx().getVersion().getVersion());
  WebAppContext root=new WebAppContext();
  root.setAllowDuplicateFragmentNames(true);
  root.setWar(tempWarFile.getAbsolutePath());
  root.setParentLoaderPriority(true);
  root.setContextPath(""String_Node_Str"");
  root.addEventListener(new ServletContextListener(){
    @Override public void contextInitialized(    ServletContextEvent theSce){
      theSce.getServletContext().setInitParameter(ContextLoader.CONTEXT_CLASS_PARAM,AnnotationConfigWebApplicationContext.class.getName());
switch (ContextHolder.getCtx().getVersion().getVersion()) {
case DSTU2:
        theSce.getServletContext().setInitParameter(ContextLoader.CONFIG_LOCATION_PARAM,FhirServerConfig.class.getName());
      break;
case DSTU3:
    theSce.getServletContext().setInitParameter(ContextLoader.CONFIG_LOCATION_PARAM,FhirServerConfigDstu3.class.getName());
  break;
case DSTU1:
case DSTU2_1:
case DSTU2_HL7ORG:
break;
}
cll.contextInitialized(theSce);
}
@Override public void contextDestroyed(ServletContextEvent theSce){
cll.contextDestroyed(theSce);
}
}
);
String path=ContextHolder.getPath();
root.addServlet(""String_Node_Str"",path + ""String_Node_Str"");
myServer=new Server(myPort);
myServer.setHandler(root);
try {
myServer.start();
}
 catch (SocketException e) {
throw new CommandFailureException(""String_Node_Str"" + myPort + ""String_Node_Str""+ e.toString()+ ""String_Node_Str"");
}
catch (Exception e) {
ourLog.error(""String_Node_Str"",e);
throw new CommandFailureException(""String_Node_Str"",e);
}
ourLog.info(""String_Node_Str"",myPort);
ourLog.info(""String_Node_Str"",myPort);
ourLog.info(""String_Node_Str"",myPort,path);
}","@Override public void run(CommandLine theCommandLine) throws ParseException {
  myPort=parseOptionInteger(theCommandLine,OPTION_P,DEFAULT_PORT);
  if (theCommandLine.hasOption(OPTION_LOWMEM)) {
    ourLog.info(""String_Node_Str"");
    System.setProperty(OPTION_LOWMEM,OPTION_LOWMEM);
  }
  if (theCommandLine.hasOption(OPTION_ALLOW_EXTERNAL_REFS)) {
    ourLog.info(""String_Node_Str"");
    ContextHolder.setAllowExternalRefs(true);
  }
  if (theCommandLine.hasOption(OPTION_DISABLE_REFERENTIAL_INTEGRITY)) {
    ourLog.info(""String_Node_Str"");
    ContextHolder.setDisableReferentialIntegrity(true);
  }
  ContextHolder.setCtx(getSpecVersionContext(theCommandLine));
  ourLog.info(""String_Node_Str"",myPort);
  File tempWarFile;
  try {
    tempWarFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    tempWarFile.deleteOnExit();
    InputStream inStream=RunServerCommand.class.getResourceAsStream(""String_Node_Str"");
    OutputStream outStream=new BufferedOutputStream(new FileOutputStream(tempWarFile,false));
    IOUtils.copy(inStream,outStream);
  }
 catch (  IOException e) {
    ourLog.error(""String_Node_Str"",e);
    return;
  }
  final ContextLoaderListener cll=new ContextLoaderListener();
  ourLog.info(""String_Node_Str"",ContextHolder.getCtx().getVersion().getVersion());
  WebAppContext root=new WebAppContext();
  root.setAllowDuplicateFragmentNames(true);
  root.setWar(tempWarFile.getAbsolutePath());
  root.setParentLoaderPriority(true);
  root.setContextPath(""String_Node_Str"");
  root.addEventListener(new ServletContextListener(){
    @Override public void contextInitialized(    ServletContextEvent theSce){
      theSce.getServletContext().setInitParameter(ContextLoader.CONTEXT_CLASS_PARAM,AnnotationConfigWebApplicationContext.class.getName());
switch (ContextHolder.getCtx().getVersion().getVersion()) {
case DSTU2:
        theSce.getServletContext().setInitParameter(ContextLoader.CONFIG_LOCATION_PARAM,FhirServerConfig.class.getName());
      break;
case DSTU3:
    theSce.getServletContext().setInitParameter(ContextLoader.CONFIG_LOCATION_PARAM,FhirServerConfigDstu3.class.getName());
  break;
case DSTU1:
case DSTU2_1:
case DSTU2_HL7ORG:
break;
}
cll.contextInitialized(theSce);
}
@Override public void contextDestroyed(ServletContextEvent theSce){
cll.contextDestroyed(theSce);
}
}
);
String path=ContextHolder.getPath();
root.addServlet(""String_Node_Str"",path + ""String_Node_Str"");
myServer=new Server(myPort);
myServer.setHandler(root);
try {
myServer.start();
}
 catch (SocketException e) {
throw new CommandFailureException(""String_Node_Str"" + myPort + ""String_Node_Str""+ e.toString()+ ""String_Node_Str"");
}
catch (Exception e) {
ourLog.error(""String_Node_Str"",e);
throw new CommandFailureException(""String_Node_Str"",e);
}
ourLog.info(""String_Node_Str"",myPort);
ourLog.info(""String_Node_Str"",myPort);
ourLog.info(""String_Node_Str"",myPort,path);
}",0.9700534759358288
112226,"@Override public Options getOptions(){
  Options options=new Options();
  addFhirVersionOption(options);
  options.addOption(OPTION_P,""String_Node_Str"",true,""String_Node_Str"" + DEFAULT_PORT + ""String_Node_Str"");
  options.addOption(null,OPTION_LOWMEM,false,""String_Node_Str"");
  options.addOption(null,OPTION_ALLOW_EXTERNAL_REFS,false,""String_Node_Str"");
  options.addOption(null,DISABLE_REFERENTIAL_INTEGRITY,false,""String_Node_Str"");
  return options;
}","@Override public Options getOptions(){
  Options options=new Options();
  addFhirVersionOption(options);
  options.addOption(OPTION_P,""String_Node_Str"",true,""String_Node_Str"" + DEFAULT_PORT + ""String_Node_Str"");
  options.addOption(null,OPTION_LOWMEM,false,""String_Node_Str"");
  options.addOption(null,OPTION_ALLOW_EXTERNAL_REFS,false,""String_Node_Str"");
  options.addOption(null,OPTION_DISABLE_REFERENTIAL_INTEGRITY,false,""String_Node_Str"");
  return options;
}",0.9923664122137404
112227,"protected void processAndAddLastClientInvocation(GenericClient theClient,ResultType theResultType,ModelMap theModelMap,long theLatency,String outcomeDescription,CaptureInterceptor theInterceptor,HomeRequest theRequest){
  try {
    IHttpRequest lastRequest=theInterceptor.getLastRequest();
    IHttpResponse lastResponse=theInterceptor.getLastResponse();
    String requestBody=null;
    String requestUrl=null;
    String action=null;
    String resultStatus=null;
    String resultBody=null;
    String mimeType=null;
    ContentType ct=null;
    if (lastRequest != null) {
      requestBody=lastRequest.getRequestBodyFromStream();
      requestUrl=lastRequest.getUri();
      action=lastRequest.getHttpVerbName();
    }
    if (lastResponse != null) {
      resultStatus=""String_Node_Str"" + lastResponse.getStatus() + ""String_Node_Str""+ lastResponse.getStatusInfo();
      lastResponse.bufferEntity();
      resultBody=IOUtils.toString(lastResponse.readEntity(),Constants.CHARSET_UTF8);
      List<String> ctStrings=lastResponse.getAllHeaders().get(Constants.HEADER_CONTENT_TYPE);
      if (ctStrings != null && ctStrings.isEmpty() == false) {
        ct=ContentType.parse(ctStrings.get(0));
        mimeType=ct.getMimeType();
      }
    }
    EncodingEnum ctEnum=EncodingEnum.forContentType(mimeType);
    String narrativeString=""String_Node_Str"";
    StringBuilder resultDescription=new StringBuilder();
    Bundle bundle=null;
    IBaseResource riBundle=null;
    FhirContext context=getContext(theRequest);
    if (ctEnum == null) {
      resultDescription.append(""String_Node_Str"");
    }
 else {
switch (ctEnum) {
case JSON:
        if (theResultType == ResultType.RESOURCE) {
          narrativeString=parseNarrative(theRequest,ctEnum,resultBody);
          resultDescription.append(""String_Node_Str"");
        }
 else         if (theResultType == ResultType.BUNDLE) {
          resultDescription.append(""String_Node_Str"");
          if (context.getVersion().getVersion().isRi()) {
            riBundle=context.newJsonParser().parseResource(resultBody);
          }
 else {
            bundle=context.newJsonParser().parseBundle(resultBody);
          }
        }
      break;
case XML:
default :
    if (theResultType == ResultType.RESOURCE) {
      narrativeString=parseNarrative(theRequest,ctEnum,resultBody);
      resultDescription.append(""String_Node_Str"");
    }
 else     if (theResultType == ResultType.BUNDLE) {
      resultDescription.append(""String_Node_Str"");
      if (context.getVersion().getVersion().isRi()) {
        riBundle=context.newXmlParser().parseResource(resultBody);
      }
 else {
        bundle=context.newXmlParser().parseBundle(resultBody);
      }
    }
  break;
}
}
resultDescription.append(""String_Node_Str"").append(resultBody.length() + ""String_Node_Str"");
Header[] requestHeaders=lastRequest != null ? applyHeaderFilters(lastRequest.getAllHeaders()) : new Header[0];
Header[] responseHeaders=lastResponse != null ? applyHeaderFilters(lastResponse.getAllHeaders()) : new Header[0];
theModelMap.put(""String_Node_Str"",outcomeDescription);
theModelMap.put(""String_Node_Str"",resultDescription.toString());
theModelMap.put(""String_Node_Str"",action);
theModelMap.put(""String_Node_Str"",bundle);
theModelMap.put(""String_Node_Str"",riBundle);
theModelMap.put(""String_Node_Str"",resultStatus);
theModelMap.put(""String_Node_Str"",requestUrl);
theModelMap.put(""String_Node_Str"",formatUrl(theClient.getUrlBase(),requestUrl));
String requestBodyText=format(requestBody,ctEnum);
theModelMap.put(""String_Node_Str"",requestBodyText);
String resultBodyText=format(resultBody,ctEnum);
theModelMap.put(""String_Node_Str"",resultBodyText);
theModelMap.put(""String_Node_Str"",resultBodyText.length() > 1000);
theModelMap.put(""String_Node_Str"",requestHeaders);
theModelMap.put(""String_Node_Str"",responseHeaders);
theModelMap.put(""String_Node_Str"",narrativeString);
theModelMap.put(""String_Node_Str"",theLatency);
}
 catch (Exception e) {
ourLog.error(""String_Node_Str"",e);
theModelMap.put(""String_Node_Str"",""String_Node_Str"" + e.getMessage());
}
}","protected void processAndAddLastClientInvocation(GenericClient theClient,ResultType theResultType,ModelMap theModelMap,long theLatency,String outcomeDescription,CaptureInterceptor theInterceptor,HomeRequest theRequest){
  try {
    IHttpRequest lastRequest=theInterceptor.getLastRequest();
    IHttpResponse lastResponse=theInterceptor.getLastResponse();
    String requestBody=null;
    String requestUrl=null;
    String action=null;
    String resultStatus=null;
    String resultBody=null;
    String mimeType=null;
    ContentType ct=null;
    if (lastRequest != null) {
      requestBody=lastRequest.getRequestBodyFromStream();
      requestUrl=lastRequest.getUri();
      action=lastRequest.getHttpVerbName();
    }
    if (lastResponse != null) {
      resultStatus=""String_Node_Str"" + lastResponse.getStatus() + ""String_Node_Str""+ lastResponse.getStatusInfo();
      lastResponse.bufferEntity();
      resultBody=IOUtils.toString(lastResponse.readEntity(),Constants.CHARSET_UTF8);
      List<String> ctStrings=lastResponse.getHeaders(Constants.HEADER_CONTENT_TYPE);
      if (ctStrings != null && ctStrings.isEmpty() == false) {
        ct=ContentType.parse(ctStrings.get(0));
        mimeType=ct.getMimeType();
      }
    }
    EncodingEnum ctEnum=EncodingEnum.forContentType(mimeType);
    String narrativeString=""String_Node_Str"";
    StringBuilder resultDescription=new StringBuilder();
    Bundle bundle=null;
    IBaseResource riBundle=null;
    FhirContext context=getContext(theRequest);
    if (ctEnum == null) {
      resultDescription.append(""String_Node_Str"");
    }
 else {
switch (ctEnum) {
case JSON:
        if (theResultType == ResultType.RESOURCE) {
          narrativeString=parseNarrative(theRequest,ctEnum,resultBody);
          resultDescription.append(""String_Node_Str"");
        }
 else         if (theResultType == ResultType.BUNDLE) {
          resultDescription.append(""String_Node_Str"");
          if (context.getVersion().getVersion().isRi()) {
            riBundle=context.newJsonParser().parseResource(resultBody);
          }
 else {
            bundle=context.newJsonParser().parseBundle(resultBody);
          }
        }
      break;
case XML:
default :
    if (theResultType == ResultType.RESOURCE) {
      narrativeString=parseNarrative(theRequest,ctEnum,resultBody);
      resultDescription.append(""String_Node_Str"");
    }
 else     if (theResultType == ResultType.BUNDLE) {
      resultDescription.append(""String_Node_Str"");
      if (context.getVersion().getVersion().isRi()) {
        riBundle=context.newXmlParser().parseResource(resultBody);
      }
 else {
        bundle=context.newXmlParser().parseBundle(resultBody);
      }
    }
  break;
}
}
resultDescription.append(""String_Node_Str"").append(resultBody.length() + ""String_Node_Str"");
Header[] requestHeaders=lastRequest != null ? applyHeaderFilters(lastRequest.getAllHeaders()) : new Header[0];
Header[] responseHeaders=lastResponse != null ? applyHeaderFilters(lastResponse.getAllHeaders()) : new Header[0];
theModelMap.put(""String_Node_Str"",outcomeDescription);
theModelMap.put(""String_Node_Str"",resultDescription.toString());
theModelMap.put(""String_Node_Str"",action);
theModelMap.put(""String_Node_Str"",bundle);
theModelMap.put(""String_Node_Str"",riBundle);
theModelMap.put(""String_Node_Str"",resultStatus);
theModelMap.put(""String_Node_Str"",requestUrl);
theModelMap.put(""String_Node_Str"",formatUrl(theClient.getUrlBase(),requestUrl));
String requestBodyText=format(requestBody,ctEnum);
theModelMap.put(""String_Node_Str"",requestBodyText);
String resultBodyText=format(resultBody,ctEnum);
theModelMap.put(""String_Node_Str"",resultBodyText);
theModelMap.put(""String_Node_Str"",resultBodyText.length() > 1000);
theModelMap.put(""String_Node_Str"",requestHeaders);
theModelMap.put(""String_Node_Str"",responseHeaders);
theModelMap.put(""String_Node_Str"",narrativeString);
theModelMap.put(""String_Node_Str"",theLatency);
}
 catch (Exception e) {
ourLog.error(""String_Node_Str"",e);
theModelMap.put(""String_Node_Str"",""String_Node_Str"" + e.getMessage());
}
}",0.99889121596649
112228,"public GenericClient newClient(HttpServletRequest theRequest,FhirContext theContext,TesterConfig theConfig,Controller.CaptureInterceptor theInterceptor){
  theContext.getRestfulClientFactory().setServerValidationMode(ServerValidationModeEnum.NEVER);
  GenericClient retVal;
  ITestingUiClientFactory clientFactory=theConfig.getClientFactory();
  if (clientFactory != null) {
    retVal=(GenericClient)clientFactory.newClient(theContext,theRequest,getServerBase(theRequest,theConfig));
  }
 else {
    retVal=(GenericClient)theContext.newRestfulGenericClient(getServerBase(theRequest,theConfig));
  }
  retVal.setKeepResponses(true);
  if (""String_Node_Str"".equals(getPretty())) {
    retVal.setPrettyPrint(true);
  }
 else   if (""String_Node_Str"".equals(getPretty())) {
    retVal.setPrettyPrint(false);
  }
  if (""String_Node_Str"".equals(getEncoding())) {
    retVal.setEncoding(EncodingEnum.XML);
  }
 else   if (""String_Node_Str"".equals(getEncoding())) {
    retVal.setEncoding(EncodingEnum.JSON);
  }
  if (isNotBlank(get_summary())) {
    SummaryEnum summary=SummaryEnum.fromCode(get_summary());
    if (summary != null) {
      retVal.setSummary(summary);
    }
  }
  retVal.registerInterceptor(theInterceptor);
  final String remoteAddr=org.slf4j.MDC.get(""String_Node_Str"");
  retVal.registerInterceptor(new IClientInterceptor(){
    @Override public void interceptResponse(    IHttpResponse theRequest){
    }
    @Override public void interceptRequest(    IHttpRequest theRequest){
      if (isNotBlank(remoteAddr)) {
        theRequest.addHeader(""String_Node_Str"",remoteAddr);
      }
    }
  }
);
  return retVal;
}","public GenericClient newClient(HttpServletRequest theRequest,FhirContext theContext,TesterConfig theConfig,Controller.CaptureInterceptor theInterceptor){
  theContext.getRestfulClientFactory().setServerValidationMode(ServerValidationModeEnum.NEVER);
  GenericClient retVal;
  ITestingUiClientFactory clientFactory=theConfig.getClientFactory();
  if (clientFactory != null) {
    retVal=(GenericClient)clientFactory.newClient(theContext,theRequest,getServerBase(theRequest,theConfig));
  }
 else {
    retVal=(GenericClient)theContext.newRestfulGenericClient(getServerBase(theRequest,theConfig));
  }
  retVal.registerInterceptor(new BufferResponseInterceptor());
  retVal.setKeepResponses(true);
  if (""String_Node_Str"".equals(getPretty())) {
    retVal.setPrettyPrint(true);
  }
 else   if (""String_Node_Str"".equals(getPretty())) {
    retVal.setPrettyPrint(false);
  }
  if (""String_Node_Str"".equals(getEncoding())) {
    retVal.setEncoding(EncodingEnum.XML);
  }
 else   if (""String_Node_Str"".equals(getEncoding())) {
    retVal.setEncoding(EncodingEnum.JSON);
  }
  if (isNotBlank(get_summary())) {
    SummaryEnum summary=SummaryEnum.fromCode(get_summary());
    if (summary != null) {
      retVal.setSummary(summary);
    }
  }
  retVal.registerInterceptor(theInterceptor);
  final String remoteAddr=org.slf4j.MDC.get(""String_Node_Str"");
  retVal.registerInterceptor(new IClientInterceptor(){
    @Override public void interceptResponse(    IHttpResponse theRequest){
    }
    @Override public void interceptRequest(    IHttpRequest theRequest){
      if (isNotBlank(remoteAddr)) {
        theRequest.addHeader(""String_Node_Str"",remoteAddr);
      }
    }
  }
);
  return retVal;
}",0.980995475113122
112229,"@Override protected void validateSealed(){
  if (!mySealed) {
synchronized (myContext) {
      sealAndInitialize(myContext,myClassToElementDefinitions);
    }
  }
}","@Override protected void validateSealed(){
  if (!mySealed) {
synchronized (myContext) {
      if (!mySealed) {
        sealAndInitialize(myContext,myClassToElementDefinitions);
      }
    }
  }
}",0.9085872576177284
112230,"@Override public boolean elementIsRepeating(String theChildName){
  try {
    BaseRuntimeChildDefinition child=myDefinition.getChildByNameOrThrowDataFormatException(theChildName);
    return child.getMax() > 1 || child.getMax() == Child.MAX_UNLIMITED;
  }
 catch (  DataFormatException e) {
    return false;
  }
}","@Override public boolean elementIsRepeating(String theChildName){
  BaseRuntimeChildDefinition child=myDefinition.getChildByName(theChildName);
  if (child == null) {
    return false;
  }
  return child.getMax() > 1 || child.getMax() == Child.MAX_UNLIMITED;
}",0.7560975609756098
112231,"@Override protected void validateSealed(){
  if (!mySealed) {
synchronized (myContext) {
      sealAndInitialize(myContext,myClassToElementDefinitions);
    }
  }
}","@Override protected void validateSealed(){
  if (!mySealed) {
synchronized (myContext) {
      if (!mySealed) {
        sealAndInitialize(myContext,myClassToElementDefinitions);
      }
    }
  }
}",0.9085872576177284
112232,"@Override protected void doInTransactionWithoutResult(TransactionStatus theArg0){
  if (mySearch.getId() == null) {
    doSaveSearch();
  }
  List<SearchResult> resultsToSave=Lists.newArrayList();
  for (  Long nextPid : myUnsyncedPids) {
    SearchResult nextResult=new SearchResult(mySearch);
    nextResult.setResourcePid(nextPid);
    nextResult.setOrder(myCountSaved++);
    resultsToSave.add(nextResult);
  }
  mySearchResultDao.save(resultsToSave);
synchronized (mySyncedPids) {
    int numSyncedThisPass=myUnsyncedPids.size();
    ourLog.info(""String_Node_Str"",numSyncedThisPass);
    mySyncedPids.addAll(myUnsyncedPids);
    myUnsyncedPids.clear();
    if (theResultIter.hasNext() == false) {
      mySearch.setStatus(SearchStatusEnum.FINISHED);
      mySearch.setTotalCount(myCountSaved);
      for (      CountDownLatch next : myResultSizeLatch) {
        while (next.getCount() > 0) {
          next.countDown();
        }
      }
    }
 else {
      if (myResultSizeLatch.isEmpty() == false) {
        for (        CountDownLatch next : myResultSizeLatch) {
          for (int i=0; i < numSyncedThisPass; i++) {
            next.countDown();
          }
        }
      }
    }
  }
  mySearch.setNumFound(myCountSaved);
  doSaveSearch();
}","@Override protected void doInTransactionWithoutResult(TransactionStatus theArg0){
  if (mySearch.getId() == null) {
    doSaveSearch();
  }
  List<SearchResult> resultsToSave=Lists.newArrayList();
  for (  Long nextPid : myUnsyncedPids) {
    SearchResult nextResult=new SearchResult(mySearch);
    nextResult.setResourcePid(nextPid);
    nextResult.setOrder(myCountSaved++);
    resultsToSave.add(nextResult);
  }
  mySearchResultDao.save(resultsToSave);
synchronized (mySyncedPids) {
    int numSyncedThisPass=myUnsyncedPids.size();
    ourLog.trace(""String_Node_Str"",numSyncedThisPass);
    mySyncedPids.addAll(myUnsyncedPids);
    myUnsyncedPids.clear();
    if (theResultIter.hasNext() == false) {
      mySearch.setStatus(SearchStatusEnum.FINISHED);
      mySearch.setTotalCount(myCountSaved);
      for (      CountDownLatch next : myResultSizeLatch) {
        while (next.getCount() > 0) {
          next.countDown();
        }
      }
    }
 else {
      if (myResultSizeLatch.isEmpty() == false) {
        for (        CountDownLatch next : myResultSizeLatch) {
          for (int i=0; i < numSyncedThisPass; i++) {
            next.countDown();
          }
        }
      }
    }
  }
  mySearch.setNumFound(myCountSaved);
  doSaveSearch();
}",0.9964071856287424
112233,"@Override @Transactional(value=TxType.NOT_SUPPORTED) public List<Long> getResources(final String theUuid,int theFrom,int theTo){
  if (myNeverUseLocalSearchForUnitTests == false) {
    SearchTask task=myIdToSearchTask.get(theUuid);
    if (task != null) {
      return task.getResourcePids(theFrom,theTo);
    }
  }
  Search search;
  StopWatch sw=new StopWatch();
  while (true) {
    TransactionTemplate txTemplate=new TransactionTemplate(myTxManager);
    txTemplate.setPropagationBehavior(TransactionTemplate.PROPAGATION_REQUIRES_NEW);
    search=txTemplate.execute(new TransactionCallback<Search>(){
      @Override public Search doInTransaction(      TransactionStatus theStatus){
        return mySearchDao.findByUuid(theUuid);
      }
    }
);
    if (search == null) {
      ourLog.info(""String_Node_Str"",theUuid);
      String msg=myContext.getLocalizer().getMessage(PageMethodBinding.class,""String_Node_Str"",theUuid);
      throw new ResourceGoneException(msg);
    }
    verifySearchHasntFailedOrThrowInternalErrorException(search);
    if (search.getStatus() == SearchStatusEnum.FINISHED) {
      ourLog.info(""String_Node_Str"");
      break;
    }
    if (search.getNumFound() >= theTo) {
      ourLog.info(""String_Node_Str"",search.getNumFound());
      break;
    }
    if (sw.getMillis() > myMaxMillisToWaitForRemoteResults) {
      throw new InternalErrorException(""String_Node_Str"" + sw.getMillis() + ""String_Node_Str"");
    }
    try {
      Thread.sleep(500);
    }
 catch (    InterruptedException e) {
    }
  }
  Pageable page=toPage(theFrom,theTo);
  if (page == null) {
    return Collections.emptyList();
  }
  Page<SearchResult> searchResults=mySearchResultDao.findWithSearchUuid(search,page);
  List<Long> retVal=new ArrayList<Long>();
  for (  SearchResult next : searchResults) {
    retVal.add(next.getResourcePid());
  }
  return retVal;
}","@Override @Transactional(value=TxType.NOT_SUPPORTED) public List<Long> getResources(final String theUuid,int theFrom,int theTo){
  if (myNeverUseLocalSearchForUnitTests == false) {
    SearchTask task=myIdToSearchTask.get(theUuid);
    if (task != null) {
      return task.getResourcePids(theFrom,theTo);
    }
  }
  TransactionTemplate txTemplate=new TransactionTemplate(myTxManager);
  txTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
  Search search;
  StopWatch sw=new StopWatch();
  while (true) {
    search=txTemplate.execute(new TransactionCallback<Search>(){
      @Override public Search doInTransaction(      TransactionStatus theStatus){
        return mySearchDao.findByUuid(theUuid);
      }
    }
);
    if (search == null) {
      ourLog.info(""String_Node_Str"",theUuid);
      String msg=myContext.getLocalizer().getMessage(PageMethodBinding.class,""String_Node_Str"",theUuid);
      throw new ResourceGoneException(msg);
    }
    verifySearchHasntFailedOrThrowInternalErrorException(search);
    if (search.getStatus() == SearchStatusEnum.FINISHED) {
      ourLog.info(""String_Node_Str"");
      break;
    }
    if (search.getNumFound() >= theTo) {
      ourLog.info(""String_Node_Str"",search.getNumFound());
      break;
    }
    if (sw.getMillis() > myMaxMillisToWaitForRemoteResults) {
      throw new InternalErrorException(""String_Node_Str"" + sw.getMillis() + ""String_Node_Str"");
    }
    try {
      Thread.sleep(500);
    }
 catch (    InterruptedException e) {
    }
  }
  final Pageable page=toPage(theFrom,theTo);
  if (page == null) {
    return Collections.emptyList();
  }
  final Search foundSearch=search;
  List<Long> retVal=txTemplate.execute(new TransactionCallback<List<Long>>(){
    @Override public List<Long> doInTransaction(    TransactionStatus theStatus){
      final List<Long> resultPids=new ArrayList<Long>();
      Page<SearchResult> searchResults=mySearchResultDao.findWithSearchUuid(foundSearch,page);
      for (      SearchResult next : searchResults) {
        resultPids.add(next.getResourcePid());
      }
      return resultPids;
    }
  }
);
  return retVal;
}",0.8243781094527363
112234,"private void saveUnsynced(final Iterator<Long> theResultIter){
  TransactionTemplate txTemplate=new TransactionTemplate(myTxManager);
  txTemplate.setPropagationBehavior(TransactionTemplate.PROPAGATION_REQUIRES_NEW);
  txTemplate.execute(new TransactionCallbackWithoutResult(){
    @Override protected void doInTransactionWithoutResult(    TransactionStatus theArg0){
      if (mySearch.getId() == null) {
        doSaveSearch();
      }
      List<SearchResult> resultsToSave=Lists.newArrayList();
      for (      Long nextPid : myUnsyncedPids) {
        SearchResult nextResult=new SearchResult(mySearch);
        nextResult.setResourcePid(nextPid);
        nextResult.setOrder(myCountSaved++);
        resultsToSave.add(nextResult);
      }
      mySearchResultDao.save(resultsToSave);
synchronized (mySyncedPids) {
        int numSyncedThisPass=myUnsyncedPids.size();
        ourLog.info(""String_Node_Str"",numSyncedThisPass);
        mySyncedPids.addAll(myUnsyncedPids);
        myUnsyncedPids.clear();
        if (theResultIter.hasNext() == false) {
          mySearch.setStatus(SearchStatusEnum.FINISHED);
          mySearch.setTotalCount(myCountSaved);
          for (          CountDownLatch next : myResultSizeLatch) {
            while (next.getCount() > 0) {
              next.countDown();
            }
          }
        }
 else {
          if (myResultSizeLatch.isEmpty() == false) {
            for (            CountDownLatch next : myResultSizeLatch) {
              for (int i=0; i < numSyncedThisPass; i++) {
                next.countDown();
              }
            }
          }
        }
      }
      mySearch.setNumFound(myCountSaved);
      doSaveSearch();
    }
  }
);
  myInitialCollectionLatch.countDown();
}","private void saveUnsynced(final Iterator<Long> theResultIter){
  TransactionTemplate txTemplate=new TransactionTemplate(myTxManager);
  txTemplate.setPropagationBehavior(TransactionTemplate.PROPAGATION_REQUIRES_NEW);
  txTemplate.execute(new TransactionCallbackWithoutResult(){
    @Override protected void doInTransactionWithoutResult(    TransactionStatus theArg0){
      if (mySearch.getId() == null) {
        doSaveSearch();
      }
      List<SearchResult> resultsToSave=Lists.newArrayList();
      for (      Long nextPid : myUnsyncedPids) {
        SearchResult nextResult=new SearchResult(mySearch);
        nextResult.setResourcePid(nextPid);
        nextResult.setOrder(myCountSaved++);
        resultsToSave.add(nextResult);
      }
      mySearchResultDao.save(resultsToSave);
synchronized (mySyncedPids) {
        int numSyncedThisPass=myUnsyncedPids.size();
        ourLog.trace(""String_Node_Str"",numSyncedThisPass);
        mySyncedPids.addAll(myUnsyncedPids);
        myUnsyncedPids.clear();
        if (theResultIter.hasNext() == false) {
          mySearch.setStatus(SearchStatusEnum.FINISHED);
          mySearch.setTotalCount(myCountSaved);
          for (          CountDownLatch next : myResultSizeLatch) {
            while (next.getCount() > 0) {
              next.countDown();
            }
          }
        }
 else {
          if (myResultSizeLatch.isEmpty() == false) {
            for (            CountDownLatch next : myResultSizeLatch) {
              for (int i=0; i < numSyncedThisPass; i++) {
                next.countDown();
              }
            }
          }
        }
      }
      mySearch.setNumFound(myCountSaved);
      doSaveSearch();
    }
  }
);
  myInitialCollectionLatch.countDown();
}",0.9974189848006882
112235,"public List<Long> getResourcePids(int theFromIndex,int theToIndex){
  ourLog.info(""String_Node_Str"",theFromIndex,theToIndex);
  CountDownLatch latch=null;
synchronized (mySyncedPids) {
    if (mySyncedPids.size() < theToIndex && mySearch.getStatus() == SearchStatusEnum.LOADING) {
      int latchSize=theToIndex - mySyncedPids.size();
      ourLog.info(""String_Node_Str"",latchSize,theToIndex);
      latch=new CountDownLatch(latchSize);
      myResultSizeLatch.add(latch);
    }
  }
  if (latch != null) {
    while (latch.getCount() > 0 && mySearch.getStatus() == SearchStatusEnum.LOADING) {
      try {
        ourLog.trace(""String_Node_Str"",latch.getCount());
        latch.await(500,TimeUnit.MILLISECONDS);
      }
 catch (      InterruptedException e) {
      }
    }
  }
  ArrayList<Long> retVal=new ArrayList<Long>();
synchronized (mySyncedPids) {
    verifySearchHasntFailedOrThrowInternalErrorException(mySearch);
    int toIndex=theToIndex;
    if (mySyncedPids.size() < toIndex) {
      toIndex=mySyncedPids.size();
    }
    for (int i=theFromIndex; i < toIndex; i++) {
      retVal.add(mySyncedPids.get(i));
    }
  }
  return retVal;
}","public List<Long> getResourcePids(int theFromIndex,int theToIndex){
  ourLog.info(""String_Node_Str"",theFromIndex,theToIndex);
  CountDownLatch latch=null;
synchronized (mySyncedPids) {
    if (mySyncedPids.size() < theToIndex && mySearch.getStatus() == SearchStatusEnum.LOADING) {
      int latchSize=theToIndex - mySyncedPids.size();
      ourLog.trace(""String_Node_Str"",latchSize,theToIndex);
      latch=new CountDownLatch(latchSize);
      myResultSizeLatch.add(latch);
    }
  }
  if (latch != null) {
    while (latch.getCount() > 0 && mySearch.getStatus() == SearchStatusEnum.LOADING) {
      try {
        ourLog.trace(""String_Node_Str"",latch.getCount());
        latch.await(500,TimeUnit.MILLISECONDS);
      }
 catch (      InterruptedException e) {
      }
    }
  }
  ArrayList<Long> retVal=new ArrayList<Long>();
synchronized (mySyncedPids) {
    verifySearchHasntFailedOrThrowInternalErrorException(mySearch);
    int toIndex=theToIndex;
    if (mySyncedPids.size() < toIndex) {
      toIndex=mySyncedPids.size();
    }
    for (int i=theFromIndex; i < toIndex; i++) {
      retVal.add(mySyncedPids.get(i));
    }
  }
  return retVal;
}",0.9960852544584602
112236,"@Override public Search doInTransaction(TransactionStatus theStatus){
  return mySearchDao.findByUuid(theUuid);
}","@Override public List<Long> doInTransaction(TransactionStatus theStatus){
  final List<Long> resultPids=new ArrayList<Long>();
  Page<SearchResult> searchResults=mySearchResultDao.findWithSearchUuid(foundSearch,page);
  for (  SearchResult next : searchResults) {
    resultPids.add(next.getResourcePid());
  }
  return resultPids;
}",0.4080717488789238
112237,"public void awaitInitialSync(){
  ourLog.info(""String_Node_Str"");
  do {
    try {
      if (myInitialCollectionLatch.await(250,TimeUnit.MILLISECONDS)) {
        break;
      }
    }
 catch (    InterruptedException e) {
      throw new InternalErrorException(e);
    }
  }
 while (mySearch.getStatus() == SearchStatusEnum.LOADING);
  ourLog.info(""String_Node_Str"");
}","public void awaitInitialSync(){
  ourLog.trace(""String_Node_Str"");
  do {
    try {
      if (myInitialCollectionLatch.await(250,TimeUnit.MILLISECONDS)) {
        break;
      }
    }
 catch (    InterruptedException e) {
      throw new InternalErrorException(e);
    }
  }
 while (mySearch.getStatus() == SearchStatusEnum.LOADING);
  ourLog.trace(""String_Node_Str"");
}",0.975609756097561
112238,"public static ParserBase makeParser(IWorkerContext context,FhirFormat format){
switch (format) {
case JSON:
    return new JsonParser(context);
case XML:
  return new XmlParser(context);
}
return null;
}","public static ParserBase makeParser(IWorkerContext context,FhirFormat format){
switch (format) {
case JSON:
    return new JsonParser(context);
case XML:
  return new XmlParser(context);
default :
throw new IllegalArgumentException(""String_Node_Str"" + format);
}
}",0.8137044967880086
112239,"private Cell generateDescription(HierarchicalTableGenerator gen,Row row,ElementDefinition definition,ElementDefinition fallback,boolean used,String baseURL,String url,StructureDefinition profile,String corePath,boolean root,boolean logicalModel) throws IOException {
  Cell c=gen.new Cell();
  row.getCells().add(c);
  if (used) {
    if (logicalModel && ToolingExtensions.hasExtension(profile,""String_Node_Str"")) {
      if (root) {
        c.getPieces().add(gen.new Piece(null,""String_Node_Str"",null).addStyle(""String_Node_Str""));
        c.getPieces().add(gen.new Piece(null,ToolingExtensions.readStringExtension(profile,""String_Node_Str""),null));
      }
 else       if (!root && ToolingExtensions.hasExtension(definition,""String_Node_Str"") && !ToolingExtensions.readStringExtension(definition,""String_Node_Str"").equals(ToolingExtensions.readStringExtension(profile,""String_Node_Str""))) {
        c.getPieces().add(gen.new Piece(null,""String_Node_Str"",null).addStyle(""String_Node_Str""));
        c.getPieces().add(gen.new Piece(null,ToolingExtensions.readStringExtension(definition,""String_Node_Str""),null));
      }
    }
    if (definition.hasContentReference()) {
      ElementDefinition ed=getElementByName(profile.getSnapshot().getElement(),definition.getContentReference());
      if (ed == null)       c.getPieces().add(gen.new Piece(null,""String_Node_Str"" + definition.getContentReference(),null));
 else       c.getPieces().add(gen.new Piece(""String_Node_Str"" + ed.getPath(),""String_Node_Str"" + ed.getPath(),null));
    }
    if (definition.getPath().endsWith(""String_Node_Str"") && definition.hasFixed()) {
      c.getPieces().add(checkForNoChange(definition.getFixed(),gen.new Piece(null,""String_Node_Str"" + buildJson(definition.getFixed()) + ""String_Node_Str"",null).addStyle(""String_Node_Str"")));
    }
 else {
      if (definition != null && definition.hasShort()) {
        if (!c.getPieces().isEmpty())         c.addPiece(gen.new Piece(""String_Node_Str""));
        c.addPiece(checkForNoChange(definition.getShortElement(),gen.new Piece(null,definition.getShort(),null)));
      }
 else       if (fallback != null && fallback != null && fallback.hasShort()) {
        if (!c.getPieces().isEmpty())         c.addPiece(gen.new Piece(""String_Node_Str""));
        c.addPiece(checkForNoChange(fallback.getShortElement(),gen.new Piece(null,fallback.getShort(),null)));
      }
      if (url != null) {
        if (!c.getPieces().isEmpty())         c.addPiece(gen.new Piece(""String_Node_Str""));
        String fullUrl=url.startsWith(""String_Node_Str"") ? baseURL + url : url;
        StructureDefinition ed=context.fetchResource(StructureDefinition.class,url);
        String ref=ed == null ? null : (String)corePath + ed.getUserData(""String_Node_Str"");
        c.getPieces().add(gen.new Piece(null,""String_Node_Str"",null).addStyle(""String_Node_Str""));
        c.getPieces().add(gen.new Piece(ref,fullUrl,null));
      }
      if (definition.hasSlicing()) {
        if (!c.getPieces().isEmpty())         c.addPiece(gen.new Piece(""String_Node_Str""));
        c.getPieces().add(gen.new Piece(null,""String_Node_Str"",null).addStyle(""String_Node_Str""));
        c.getPieces().add(gen.new Piece(null,describeSlice(definition.getSlicing()),null));
      }
      if (definition != null) {
        if (definition.hasBinding()) {
          if (!c.getPieces().isEmpty())           c.addPiece(gen.new Piece(""String_Node_Str""));
          BindingResolution br=pkp.resolveBinding(definition.getBinding());
          c.getPieces().add(checkForNoChange(definition.getBinding(),gen.new Piece(null,""String_Node_Str"",null).addStyle(""String_Node_Str"")));
          c.getPieces().add(checkForNoChange(definition.getBinding(),gen.new Piece(br.url == null ? null : Utilities.isAbsoluteUrl(br.url) ? br.url : corePath + br.url,br.display,null)));
          if (definition.getBinding().hasStrength()) {
            c.getPieces().add(checkForNoChange(definition.getBinding(),gen.new Piece(null,""String_Node_Str"",null)));
            c.getPieces().add(checkForNoChange(definition.getBinding(),gen.new Piece(corePath + ""String_Node_Str"" + definition.getBinding().getStrength().toCode(),definition.getBinding().getStrength().toCode(),definition.getBinding().getStrength().getDefinition())));
            c.getPieces().add(gen.new Piece(null,""String_Node_Str"",null));
          }
        }
        for (        ElementDefinitionConstraintComponent inv : definition.getConstraint()) {
          if (!c.getPieces().isEmpty())           c.addPiece(gen.new Piece(""String_Node_Str""));
          c.getPieces().add(checkForNoChange(inv,gen.new Piece(null,inv.getKey() + ""String_Node_Str"",null).addStyle(""String_Node_Str"")));
          c.getPieces().add(checkForNoChange(inv,gen.new Piece(null,inv.getHuman(),null)));
        }
        if (definition.hasFixed()) {
          if (!c.getPieces().isEmpty())           c.addPiece(gen.new Piece(""String_Node_Str""));
          c.getPieces().add(checkForNoChange(definition.getFixed(),gen.new Piece(null,""String_Node_Str"",null).addStyle(""String_Node_Str"")));
          c.getPieces().add(checkForNoChange(definition.getFixed(),gen.new Piece(null,buildJson(definition.getFixed()),null).addStyle(""String_Node_Str"")));
        }
 else         if (definition.hasPattern()) {
          if (!c.getPieces().isEmpty())           c.addPiece(gen.new Piece(""String_Node_Str""));
          c.getPieces().add(checkForNoChange(definition.getPattern(),gen.new Piece(null,""String_Node_Str"",null).addStyle(""String_Node_Str"")));
          c.getPieces().add(checkForNoChange(definition.getPattern(),gen.new Piece(null,buildJson(definition.getPattern()),null).addStyle(""String_Node_Str"")));
        }
 else         if (definition.hasExample()) {
          if (!c.getPieces().isEmpty())           c.addPiece(gen.new Piece(""String_Node_Str""));
          c.getPieces().add(checkForNoChange(definition.getExample(),gen.new Piece(null,""String_Node_Str"",null).addStyle(""String_Node_Str"")));
          c.getPieces().add(checkForNoChange(definition.getExample(),gen.new Piece(null,buildJson(definition.getExample()),null).addStyle(""String_Node_Str"")));
        }
      }
    }
  }
  return c;
}","private Cell generateDescription(HierarchicalTableGenerator gen,Row row,ElementDefinition definition,ElementDefinition fallback,boolean used,String baseURL,String url,StructureDefinition profile,String corePath,boolean root,boolean logicalModel) throws IOException {
  Cell c=gen.new Cell();
  row.getCells().add(c);
  if (used) {
    if (logicalModel && ToolingExtensions.hasExtension(profile,""String_Node_Str"")) {
      if (root) {
        c.getPieces().add(gen.new Piece(null,""String_Node_Str"",null).addStyle(""String_Node_Str""));
        c.getPieces().add(gen.new Piece(null,ToolingExtensions.readStringExtension(profile,""String_Node_Str""),null));
      }
 else       if (!root && ToolingExtensions.hasExtension(definition,""String_Node_Str"") && !ToolingExtensions.readStringExtension(definition,""String_Node_Str"").equals(ToolingExtensions.readStringExtension(profile,""String_Node_Str""))) {
        c.getPieces().add(gen.new Piece(null,""String_Node_Str"",null).addStyle(""String_Node_Str""));
        c.getPieces().add(gen.new Piece(null,ToolingExtensions.readStringExtension(definition,""String_Node_Str""),null));
      }
    }
    if (definition.hasContentReference()) {
      ElementDefinition ed=getElementByName(profile.getSnapshot().getElement(),definition.getContentReference());
      if (ed == null)       c.getPieces().add(gen.new Piece(null,""String_Node_Str"" + definition.getContentReference(),null));
 else       c.getPieces().add(gen.new Piece(""String_Node_Str"" + ed.getPath(),""String_Node_Str"" + ed.getPath(),null));
    }
    if (definition.getPath().endsWith(""String_Node_Str"") && definition.hasFixed()) {
      c.getPieces().add(checkForNoChange(definition.getFixed(),gen.new Piece(null,""String_Node_Str"" + buildJson(definition.getFixed()) + ""String_Node_Str"",null).addStyle(""String_Node_Str"")));
    }
 else {
      if (definition != null && definition.hasShort()) {
        if (!c.getPieces().isEmpty())         c.addPiece(gen.new Piece(""String_Node_Str""));
        c.addPiece(checkForNoChange(definition.getShortElement(),gen.new Piece(null,definition.getShort(),null)));
      }
 else       if (fallback != null && fallback.hasShort()) {
        if (!c.getPieces().isEmpty())         c.addPiece(gen.new Piece(""String_Node_Str""));
        c.addPiece(checkForNoChange(fallback.getShortElement(),gen.new Piece(null,fallback.getShort(),null)));
      }
      if (url != null) {
        if (!c.getPieces().isEmpty())         c.addPiece(gen.new Piece(""String_Node_Str""));
        String fullUrl=url.startsWith(""String_Node_Str"") ? baseURL + url : url;
        StructureDefinition ed=context.fetchResource(StructureDefinition.class,url);
        String ref=ed == null ? null : (String)corePath + ed.getUserData(""String_Node_Str"");
        c.getPieces().add(gen.new Piece(null,""String_Node_Str"",null).addStyle(""String_Node_Str""));
        c.getPieces().add(gen.new Piece(ref,fullUrl,null));
      }
      if (definition.hasSlicing()) {
        if (!c.getPieces().isEmpty())         c.addPiece(gen.new Piece(""String_Node_Str""));
        c.getPieces().add(gen.new Piece(null,""String_Node_Str"",null).addStyle(""String_Node_Str""));
        c.getPieces().add(gen.new Piece(null,describeSlice(definition.getSlicing()),null));
      }
      if (definition != null) {
        if (definition.hasBinding()) {
          if (!c.getPieces().isEmpty())           c.addPiece(gen.new Piece(""String_Node_Str""));
          BindingResolution br=pkp.resolveBinding(definition.getBinding());
          c.getPieces().add(checkForNoChange(definition.getBinding(),gen.new Piece(null,""String_Node_Str"",null).addStyle(""String_Node_Str"")));
          c.getPieces().add(checkForNoChange(definition.getBinding(),gen.new Piece(br.url == null ? null : Utilities.isAbsoluteUrl(br.url) ? br.url : corePath + br.url,br.display,null)));
          if (definition.getBinding().hasStrength()) {
            c.getPieces().add(checkForNoChange(definition.getBinding(),gen.new Piece(null,""String_Node_Str"",null)));
            c.getPieces().add(checkForNoChange(definition.getBinding(),gen.new Piece(corePath + ""String_Node_Str"" + definition.getBinding().getStrength().toCode(),definition.getBinding().getStrength().toCode(),definition.getBinding().getStrength().getDefinition())));
            c.getPieces().add(gen.new Piece(null,""String_Node_Str"",null));
          }
        }
        for (        ElementDefinitionConstraintComponent inv : definition.getConstraint()) {
          if (!c.getPieces().isEmpty())           c.addPiece(gen.new Piece(""String_Node_Str""));
          c.getPieces().add(checkForNoChange(inv,gen.new Piece(null,inv.getKey() + ""String_Node_Str"",null).addStyle(""String_Node_Str"")));
          c.getPieces().add(checkForNoChange(inv,gen.new Piece(null,inv.getHuman(),null)));
        }
        if (definition.hasFixed()) {
          if (!c.getPieces().isEmpty())           c.addPiece(gen.new Piece(""String_Node_Str""));
          c.getPieces().add(checkForNoChange(definition.getFixed(),gen.new Piece(null,""String_Node_Str"",null).addStyle(""String_Node_Str"")));
          c.getPieces().add(checkForNoChange(definition.getFixed(),gen.new Piece(null,buildJson(definition.getFixed()),null).addStyle(""String_Node_Str"")));
        }
 else         if (definition.hasPattern()) {
          if (!c.getPieces().isEmpty())           c.addPiece(gen.new Piece(""String_Node_Str""));
          c.getPieces().add(checkForNoChange(definition.getPattern(),gen.new Piece(null,""String_Node_Str"",null).addStyle(""String_Node_Str"")));
          c.getPieces().add(checkForNoChange(definition.getPattern(),gen.new Piece(null,buildJson(definition.getPattern()),null).addStyle(""String_Node_Str"")));
        }
 else         if (definition.hasExample()) {
          if (!c.getPieces().isEmpty())           c.addPiece(gen.new Piece(""String_Node_Str""));
          c.getPieces().add(checkForNoChange(definition.getExample(),gen.new Piece(null,""String_Node_Str"",null).addStyle(""String_Node_Str"")));
          c.getPieces().add(checkForNoChange(definition.getExample(),gen.new Piece(null,buildJson(definition.getExample()),null).addStyle(""String_Node_Str"")));
        }
      }
    }
  }
  return c;
}",0.998378728923476
112240,"@SuppressWarnings(""String_Node_Str"") @Override public Object translateQueryParametersIntoServerArgument(RequestDetails theRequest,BaseMethodBinding<?> theMethodBinding) throws InternalErrorException, InvalidRequestException {
  SearchParameterMap retVal=new SearchParameterMap();
  for (  String next : theRequest.getParameters().keySet()) {
    String qualifier=null;
    String qualifiedParamName=next;
    String unqualifiedParamName=next;
    RuntimeSearchParam param=myNameToParam.get(next);
    if (param == null) {
      int colonIndex=next.indexOf(':');
      int dotIndex=next.indexOf('.');
      if (colonIndex != -1 || dotIndex != -1) {
        int index;
        if (colonIndex != -1 && dotIndex != -1) {
          index=Math.min(colonIndex,dotIndex);
        }
 else {
          index=(colonIndex != -1) ? colonIndex : dotIndex;
        }
        qualifier=next.substring(index);
        next=next.substring(0,index);
        unqualifiedParamName=next;
        param=myNameToParam.get(next);
      }
    }
    if (param != null) {
      for (      String nextValue : theRequest.getParameters().get(qualifiedParamName)) {
        QualifiedParamList paramList=QualifiedParamList.splitQueryStringByCommasIgnoreEscape(qualifier,nextValue);
        FhirContext ctx=theRequest.getServer().getFhirContext();
switch (param.getParamType()) {
case COMPOSITE:
          Class<? extends IQueryParameterType> left=toParamType(param.getCompositeOf().get(0));
        Class<? extends IQueryParameterType> right=toParamType(param.getCompositeOf().get(0));
      @SuppressWarnings({""String_Node_Str""}) CompositeOrListParam compositeOrListParam=new CompositeOrListParam(left,right);
    compositeOrListParam.setValuesAsQueryTokens(ctx,unqualifiedParamName,paramList);
  retVal.add(next,compositeOrListParam);
break;
case DATE:
DateOrListParam dateOrListParam=new DateOrListParam();
dateOrListParam.setValuesAsQueryTokens(ctx,unqualifiedParamName,paramList);
retVal.add(next,dateOrListParam);
break;
case NUMBER:
NumberOrListParam numberOrListParam=new NumberOrListParam();
numberOrListParam.setValuesAsQueryTokens(ctx,unqualifiedParamName,paramList);
retVal.add(next,numberOrListParam);
break;
case QUANTITY:
QuantityOrListParam quantityOrListParam=new QuantityOrListParam();
quantityOrListParam.setValuesAsQueryTokens(ctx,unqualifiedParamName,paramList);
retVal.add(next,quantityOrListParam);
break;
case REFERENCE:
ReferenceOrListParam referenceOrListParam=new ReferenceOrListParam();
referenceOrListParam.setValuesAsQueryTokens(ctx,unqualifiedParamName,paramList);
retVal.add(next,referenceOrListParam);
break;
case STRING:
StringOrListParam stringOrListParam=new StringOrListParam();
stringOrListParam.setValuesAsQueryTokens(ctx,unqualifiedParamName,paramList);
retVal.add(next,stringOrListParam);
break;
case TOKEN:
TokenOrListParam tokenOrListParam=new TokenOrListParam();
tokenOrListParam.setValuesAsQueryTokens(ctx,unqualifiedParamName,paramList);
retVal.add(next,tokenOrListParam);
break;
case URI:
UriOrListParam uriOrListParam=new UriOrListParam();
uriOrListParam.setValuesAsQueryTokens(ctx,unqualifiedParamName,paramList);
retVal.add(next,uriOrListParam);
break;
}
}
}
}
return retVal;
}","@SuppressWarnings(""String_Node_Str"") @Override public Object translateQueryParametersIntoServerArgument(RequestDetails theRequest,BaseMethodBinding<?> theMethodBinding) throws InternalErrorException, InvalidRequestException {
  SearchParameterMap retVal=new SearchParameterMap();
  for (  String next : theRequest.getParameters().keySet()) {
    String qualifier=null;
    String qualifiedParamName=next;
    String unqualifiedParamName=next;
    RuntimeSearchParam param=myNameToParam.get(next);
    if (param == null) {
      int colonIndex=next.indexOf(':');
      int dotIndex=next.indexOf('.');
      if (colonIndex != -1 || dotIndex != -1) {
        int index;
        if (colonIndex != -1 && dotIndex != -1) {
          index=Math.min(colonIndex,dotIndex);
        }
 else {
          index=(colonIndex != -1) ? colonIndex : dotIndex;
        }
        qualifier=next.substring(index);
        next=next.substring(0,index);
        unqualifiedParamName=next;
        param=myNameToParam.get(next);
      }
    }
    if (param != null) {
      for (      String nextValue : theRequest.getParameters().get(qualifiedParamName)) {
        QualifiedParamList paramList=QualifiedParamList.splitQueryStringByCommasIgnoreEscape(qualifier,nextValue);
        FhirContext ctx=theRequest.getServer().getFhirContext();
switch (param.getParamType()) {
case COMPOSITE:
          Class<? extends IQueryParameterType> left=toParamType(param.getCompositeOf().get(0));
        Class<? extends IQueryParameterType> right=toParamType(param.getCompositeOf().get(0));
      @SuppressWarnings({""String_Node_Str""}) CompositeOrListParam compositeOrListParam=new CompositeOrListParam(left,right);
    compositeOrListParam.setValuesAsQueryTokens(ctx,unqualifiedParamName,paramList);
  retVal.add(next,compositeOrListParam);
break;
case DATE:
DateOrListParam dateOrListParam=new DateOrListParam();
dateOrListParam.setValuesAsQueryTokens(ctx,unqualifiedParamName,paramList);
retVal.add(next,dateOrListParam);
break;
case NUMBER:
NumberOrListParam numberOrListParam=new NumberOrListParam();
numberOrListParam.setValuesAsQueryTokens(ctx,unqualifiedParamName,paramList);
retVal.add(next,numberOrListParam);
break;
case QUANTITY:
QuantityOrListParam quantityOrListParam=new QuantityOrListParam();
quantityOrListParam.setValuesAsQueryTokens(ctx,unqualifiedParamName,paramList);
retVal.add(next,quantityOrListParam);
break;
case REFERENCE:
ReferenceOrListParam referenceOrListParam=new ReferenceOrListParam();
referenceOrListParam.setValuesAsQueryTokens(ctx,unqualifiedParamName,paramList);
retVal.add(next,referenceOrListParam);
break;
case STRING:
StringOrListParam stringOrListParam=new StringOrListParam();
stringOrListParam.setValuesAsQueryTokens(ctx,unqualifiedParamName,paramList);
retVal.add(next,stringOrListParam);
break;
case TOKEN:
TokenOrListParam tokenOrListParam=new TokenOrListParam();
tokenOrListParam.setValuesAsQueryTokens(ctx,unqualifiedParamName,paramList);
retVal.add(next,tokenOrListParam);
break;
case URI:
UriOrListParam uriOrListParam=new UriOrListParam();
uriOrListParam.setValuesAsQueryTokens(ctx,unqualifiedParamName,paramList);
retVal.add(next,uriOrListParam);
break;
case HAS:
break;
}
}
}
}
return retVal;
}",0.9973458235753316
112241,"public static Integer findParamAnnotationIndex(Method theMethod,Class<?> toFind){
  int paramIndex=0;
  for (  Annotation[] annotations : theMethod.getParameterAnnotations()) {
    for (int annotationIndex=0; annotationIndex < annotations.length; annotationIndex++) {
      Annotation nextAnnotation=annotations[annotationIndex];
      Class<? extends Annotation> class1=nextAnnotation.getClass();
      if (toFind.isAssignableFrom(class1)) {
        return paramIndex;
      }
    }
    paramIndex++;
  }
  return null;
}","@SuppressWarnings(""String_Node_Str"") public static Integer findParamAnnotationIndex(Method theMethod,Class<?> toFind){
  int paramIndex=0;
  for (  Annotation[] annotations : theMethod.getParameterAnnotations()) {
    for (int annotationIndex=0; annotationIndex < annotations.length; annotationIndex++) {
      Annotation nextAnnotation=annotations[annotationIndex];
      Class<? extends Annotation> class1=nextAnnotation.getClass();
      if (toFind.isAssignableFrom(class1)) {
        return paramIndex;
      }
    }
    paramIndex++;
  }
  return null;
}",0.96577243293247
112242,"@Override public boolean incomingServerRequestMatchesMethod(RequestDetails theRequest){
  String clientPreference=theRequest.getHeader(Constants.HEADER_PREFER);
  boolean lenientHandling=false;
  if (clientPreference != null) {
    String[] preferences=clientPreference.split(""String_Node_Str"");
    for (    String p : preferences) {
      if (""String_Node_Str"".equalsIgnoreCase(p)) {
        lenientHandling=true;
        break;
      }
    }
  }
  if (theRequest.getId() != null && myIdParamIndex == null) {
    ourLog.trace(""String_Node_Str"",theRequest.getId());
    return false;
  }
  if (theRequest.getRequestType() == RequestTypeEnum.GET && theRequest.getOperation() != null && !Constants.PARAM_SEARCH.equals(theRequest.getOperation())) {
    ourLog.trace(""String_Node_Str"",theRequest.getId(),theRequest.getOperation());
    return false;
  }
  if (theRequest.getRequestType() == RequestTypeEnum.POST && !Constants.PARAM_SEARCH.equals(theRequest.getOperation())) {
    ourLog.trace(""String_Node_Str"",theRequest.getId(),theRequest.getOperation());
    return false;
  }
  if (theRequest.getRequestType() != RequestTypeEnum.GET && theRequest.getRequestType() != RequestTypeEnum.POST) {
    ourLog.trace(""String_Node_Str"",getMethod());
    return false;
  }
  if (!StringUtils.equals(myCompartmentName,theRequest.getCompartmentName())) {
    ourLog.trace(""String_Node_Str"",new Object[]{getMethod(),myCompartmentName,theRequest.getCompartmentName()});
    return false;
  }
  Set<String> methodParamsTemp=new HashSet<String>();
  Set<String> unqualifiedNames=theRequest.getUnqualifiedToQualifiedNames().keySet();
  Set<String> qualifiedParamNames=theRequest.getParameters().keySet();
  for (int i=0; i < this.getParameters().size(); i++) {
    if (!(getParameters().get(i) instanceof BaseQueryParameter)) {
      continue;
    }
    BaseQueryParameter temp=(BaseQueryParameter)getParameters().get(i);
    String name=temp.getName();
    if (temp.isRequired()) {
      if (qualifiedParamNames.contains(name)) {
        QualifierDetails qualifiers=extractQualifiersFromParameterName(name);
        if (qualifiers.passes(temp.getQualifierWhitelist(),temp.getQualifierBlacklist())) {
          methodParamsTemp.add(name);
        }
      }
      if (unqualifiedNames.contains(name)) {
        List<String> qualifiedNames=theRequest.getUnqualifiedToQualifiedNames().get(name);
        qualifiedNames=processWhitelistAndBlacklist(qualifiedNames,temp.getQualifierWhitelist(),temp.getQualifierBlacklist());
        methodParamsTemp.addAll(qualifiedNames);
      }
      if (!qualifiedParamNames.contains(name) && !unqualifiedNames.contains(name)) {
        ourLog.trace(""String_Node_Str"",getMethod().getName(),name);
        return false;
      }
    }
 else {
      if (qualifiedParamNames.contains(name)) {
        QualifierDetails qualifiers=extractQualifiersFromParameterName(name);
        if (qualifiers.passes(temp.getQualifierWhitelist(),temp.getQualifierBlacklist())) {
          methodParamsTemp.add(name);
        }
      }
      if (unqualifiedNames.contains(name)) {
        List<String> qualifiedNames=theRequest.getUnqualifiedToQualifiedNames().get(name);
        qualifiedNames=processWhitelistAndBlacklist(qualifiedNames,temp.getQualifierWhitelist(),temp.getQualifierBlacklist());
        methodParamsTemp.addAll(qualifiedNames);
      }
      if (!qualifiedParamNames.contains(name) && !qualifiedParamNames.contains(name)) {
        methodParamsTemp.add(name);
      }
    }
  }
  if (myQueryName != null) {
    String[] queryNameValues=theRequest.getParameters().get(Constants.PARAM_QUERY);
    if (queryNameValues != null && StringUtils.isNotBlank(queryNameValues[0])) {
      String queryName=queryNameValues[0];
      if (!myQueryName.equals(queryName)) {
        ourLog.trace(""String_Node_Str"",myQueryName);
        return false;
      }
      methodParamsTemp.add(Constants.PARAM_QUERY);
    }
 else {
      ourLog.trace(""String_Node_Str"",myQueryName);
      return false;
    }
  }
 else {
    String[] queryNameValues=theRequest.getParameters().get(Constants.PARAM_QUERY);
    if (queryNameValues != null && StringUtils.isNotBlank(queryNameValues[0])) {
      ourLog.trace(""String_Node_Str"");
      return false;
    }
  }
  for (  String next : theRequest.getParameters().keySet()) {
    if (ALLOWED_PARAMS.contains(next)) {
      methodParamsTemp.add(next);
    }
  }
  Set<String> keySet=theRequest.getParameters().keySet();
  if (lenientHandling == true)   return true;
  if (myAllowUnknownParams == false) {
    for (    String next : keySet) {
      if (!methodParamsTemp.contains(next)) {
        return false;
      }
    }
  }
  return true;
}","@Override public boolean incomingServerRequestMatchesMethod(RequestDetails theRequest){
  String clientPreference=theRequest.getHeader(Constants.HEADER_PREFER);
  boolean lenientHandling=false;
  if (clientPreference != null) {
    String[] preferences=clientPreference.split(""String_Node_Str"");
    for (    String p : preferences) {
      if (""String_Node_Str"".equalsIgnoreCase(p)) {
        lenientHandling=true;
        break;
      }
    }
  }
  if (theRequest.getId() != null && myIdParamIndex == null) {
    ourLog.trace(""String_Node_Str"",theRequest.getId());
    return false;
  }
  if (theRequest.getRequestType() == RequestTypeEnum.GET && theRequest.getOperation() != null && !Constants.PARAM_SEARCH.equals(theRequest.getOperation())) {
    ourLog.trace(""String_Node_Str"",theRequest.getId(),theRequest.getOperation());
    return false;
  }
  if (theRequest.getRequestType() == RequestTypeEnum.POST && !Constants.PARAM_SEARCH.equals(theRequest.getOperation())) {
    ourLog.trace(""String_Node_Str"",theRequest.getId(),theRequest.getOperation());
    return false;
  }
  if (theRequest.getRequestType() != RequestTypeEnum.GET && theRequest.getRequestType() != RequestTypeEnum.POST) {
    ourLog.trace(""String_Node_Str"",getMethod());
    return false;
  }
  if (!StringUtils.equals(myCompartmentName,theRequest.getCompartmentName())) {
    ourLog.trace(""String_Node_Str"",new Object[]{getMethod(),myCompartmentName,theRequest.getCompartmentName()});
    return false;
  }
  Set<String> methodParamsTemp=new HashSet<String>();
  Set<String> unqualifiedNames=theRequest.getUnqualifiedToQualifiedNames().keySet();
  Set<String> qualifiedParamNames=theRequest.getParameters().keySet();
  for (int i=0; i < this.getParameters().size(); i++) {
    if (!(getParameters().get(i) instanceof BaseQueryParameter)) {
      continue;
    }
    BaseQueryParameter temp=(BaseQueryParameter)getParameters().get(i);
    String name=temp.getName();
    if (temp.isRequired()) {
      if (qualifiedParamNames.contains(name)) {
        QualifierDetails qualifiers=extractQualifiersFromParameterName(name);
        if (qualifiers.passes(temp.getQualifierWhitelist(),temp.getQualifierBlacklist())) {
          methodParamsTemp.add(name);
        }
      }
      if (unqualifiedNames.contains(name)) {
        List<String> qualifiedNames=theRequest.getUnqualifiedToQualifiedNames().get(name);
        qualifiedNames=processWhitelistAndBlacklist(qualifiedNames,temp.getQualifierWhitelist(),temp.getQualifierBlacklist());
        methodParamsTemp.addAll(qualifiedNames);
      }
      if (!qualifiedParamNames.contains(name) && !unqualifiedNames.contains(name)) {
        ourLog.trace(""String_Node_Str"",getMethod().getName(),name);
        return false;
      }
    }
 else {
      if (qualifiedParamNames.contains(name)) {
        QualifierDetails qualifiers=extractQualifiersFromParameterName(name);
        if (qualifiers.passes(temp.getQualifierWhitelist(),temp.getQualifierBlacklist())) {
          methodParamsTemp.add(name);
        }
      }
      if (unqualifiedNames.contains(name)) {
        List<String> qualifiedNames=theRequest.getUnqualifiedToQualifiedNames().get(name);
        qualifiedNames=processWhitelistAndBlacklist(qualifiedNames,temp.getQualifierWhitelist(),temp.getQualifierBlacklist());
        methodParamsTemp.addAll(qualifiedNames);
      }
      if (!qualifiedParamNames.contains(name)) {
        methodParamsTemp.add(name);
      }
    }
  }
  if (myQueryName != null) {
    String[] queryNameValues=theRequest.getParameters().get(Constants.PARAM_QUERY);
    if (queryNameValues != null && StringUtils.isNotBlank(queryNameValues[0])) {
      String queryName=queryNameValues[0];
      if (!myQueryName.equals(queryName)) {
        ourLog.trace(""String_Node_Str"",myQueryName);
        return false;
      }
      methodParamsTemp.add(Constants.PARAM_QUERY);
    }
 else {
      ourLog.trace(""String_Node_Str"",myQueryName);
      return false;
    }
  }
 else {
    String[] queryNameValues=theRequest.getParameters().get(Constants.PARAM_QUERY);
    if (queryNameValues != null && StringUtils.isNotBlank(queryNameValues[0])) {
      ourLog.trace(""String_Node_Str"");
      return false;
    }
  }
  for (  String next : theRequest.getParameters().keySet()) {
    if (ALLOWED_PARAMS.contains(next)) {
      methodParamsTemp.add(next);
    }
  }
  Set<String> keySet=theRequest.getParameters().keySet();
  if (lenientHandling == true)   return true;
  if (myAllowUnknownParams == false) {
    for (    String next : keySet) {
      if (!methodParamsTemp.contains(next)) {
        return false;
      }
    }
  }
  return true;
}",0.9958105059619724
112243,"public Date getLowerBoundAsInstant(){
  if (myLowerBound == null) {
    return null;
  }
  Date retVal=myLowerBound.getValue();
  if (myLowerBound.getPrefix() != null) {
switch (myLowerBound.getPrefix()) {
case GREATERTHAN:
      retVal=myLowerBound.getPrecision().add(retVal,1);
    break;
case EQUAL:
case GREATERTHAN_OR_EQUALS:
  break;
case LESSTHAN:
case LESSTHAN_OR_EQUALS:
throw new IllegalStateException(""String_Node_Str"" + myLowerBound.getPrefix());
}
}
return retVal;
}","public Date getLowerBoundAsInstant(){
  if (myLowerBound == null) {
    return null;
  }
  Date retVal=myLowerBound.getValue();
  if (myLowerBound.getPrefix() != null) {
switch (myLowerBound.getPrefix()) {
case GREATERTHAN:
      retVal=myLowerBound.getPrecision().add(retVal,1);
    break;
case EQUAL:
case GREATERTHAN_OR_EQUALS:
  break;
case LESSTHAN:
case APPROXIMATE:
case LESSTHAN_OR_EQUALS:
case ENDS_BEFORE:
case NOT_EQUAL:
case STARTS_AFTER:
throw new IllegalStateException(""String_Node_Str"" + myLowerBound.getPrefix());
}
}
return retVal;
}",0.9310009718172984
112244,"public Date getUpperBoundAsInstant(){
  if (myUpperBound == null) {
    return null;
  }
  Date retVal=myUpperBound.getValue();
  if (myUpperBound.getPrefix() != null) {
switch (myUpperBound.getPrefix()) {
case LESSTHAN:
      retVal=new Date(retVal.getTime() - 1L);
    break;
case EQUAL:
case LESSTHAN_OR_EQUALS:
  retVal=myUpperBound.getPrecision().add(retVal,1);
retVal=new Date(retVal.getTime() - 1L);
break;
case GREATERTHAN_OR_EQUALS:
case GREATERTHAN:
throw new IllegalStateException(""String_Node_Str"" + myUpperBound.getPrefix());
}
}
return retVal;
}","public Date getUpperBoundAsInstant(){
  if (myUpperBound == null) {
    return null;
  }
  Date retVal=myUpperBound.getValue();
  if (myUpperBound.getPrefix() != null) {
switch (myUpperBound.getPrefix()) {
case LESSTHAN:
      retVal=new Date(retVal.getTime() - 1L);
    break;
case EQUAL:
case LESSTHAN_OR_EQUALS:
  retVal=myUpperBound.getPrecision().add(retVal,1);
retVal=new Date(retVal.getTime() - 1L);
break;
case GREATERTHAN_OR_EQUALS:
case GREATERTHAN:
case APPROXIMATE:
case ENDS_BEFORE:
case NOT_EQUAL:
case STARTS_AFTER:
throw new IllegalStateException(""String_Node_Str"" + myUpperBound.getPrefix());
}
}
return retVal;
}",0.9402859545836838
112245,"private String format(String theResultBody,EncodingEnum theEncodingEnum){
  String str=StringEscapeUtils.escapeHtml4(theResultBody);
  if (str == null || theEncodingEnum == null) {
    return str;
  }
  StringBuilder b=new StringBuilder();
  if (theEncodingEnum == EncodingEnum.JSON) {
    boolean inValue=false;
    boolean inQuote=false;
    for (int i=0; i < str.length(); i++) {
      char prevChar=(i > 0) ? str.charAt(i - 1) : ' ';
      char nextChar=str.charAt(i);
      char nextChar2=(i + 1) < str.length() ? str.charAt(i + 1) : ' ';
      char nextChar3=(i + 2) < str.length() ? str.charAt(i + 2) : ' ';
      char nextChar4=(i + 3) < str.length() ? str.charAt(i + 3) : ' ';
      char nextChar5=(i + 4) < str.length() ? str.charAt(i + 4) : ' ';
      char nextChar6=(i + 5) < str.length() ? str.charAt(i + 5) : ' ';
      if (inQuote) {
        b.append(nextChar);
        if (prevChar != '\\' && nextChar == '&' && nextChar2 == 'q' && nextChar3 == 'u' && nextChar4 == 'o' && nextChar5 == 't' && nextChar6 == ';') {
          b.append(""String_Node_Str"");
          i+=5;
          inQuote=false;
        }
 else         if (nextChar == '\\' && nextChar2 == '""') {
          b.append(""String_Node_Str"");
          i+=5;
          inQuote=false;
        }
      }
 else {
        if (nextChar == ':') {
          inValue=true;
          b.append(nextChar);
        }
 else         if (nextChar == '[' || nextChar == '{') {
          b.append(""String_Node_Str"");
          b.append(nextChar);
          b.append(""String_Node_Str"");
          inValue=false;
        }
 else         if (nextChar == '}' || nextChar == '}' || nextChar == ',') {
          b.append(""String_Node_Str"");
          b.append(nextChar);
          b.append(""String_Node_Str"");
          inValue=false;
        }
 else         if (nextChar == '&' && nextChar2 == 'q' && nextChar3 == 'u' && nextChar4 == 'o' && nextChar5 == 't' && nextChar6 == ';') {
          if (inValue) {
            b.append(""String_Node_Str"");
          }
 else {
            b.append(""String_Node_Str"");
          }
          inQuote=true;
          i+=5;
        }
 else         if (nextChar == ':') {
          b.append(""String_Node_Str"");
          b.append(nextChar);
          b.append(""String_Node_Str"");
          inValue=true;
        }
 else {
          b.append(nextChar);
        }
      }
    }
  }
 else {
    boolean inQuote=false;
    boolean inTag=false;
    for (int i=0; i < str.length(); i++) {
      char nextChar=str.charAt(i);
      char nextChar2=(i + 1) < str.length() ? str.charAt(i + 1) : ' ';
      char nextChar3=(i + 2) < str.length() ? str.charAt(i + 2) : ' ';
      char nextChar4=(i + 3) < str.length() ? str.charAt(i + 3) : ' ';
      char nextChar5=(i + 4) < str.length() ? str.charAt(i + 4) : ' ';
      char nextChar6=(i + 5) < str.length() ? str.charAt(i + 5) : ' ';
      if (inQuote) {
        b.append(nextChar);
        if (nextChar == '&' && nextChar2 == 'q' && nextChar3 == 'u' && nextChar4 == 'o' && nextChar5 == 't' && nextChar6 == ';') {
          b.append(""String_Node_Str"");
          i+=5;
          inQuote=false;
        }
      }
 else       if (inTag) {
        if (nextChar == '&' && nextChar2 == 'g' && nextChar3 == 't' && nextChar4 == ';') {
          b.append(""String_Node_Str"");
          inTag=false;
          i+=3;
        }
 else         if (nextChar == ' ') {
          b.append(""String_Node_Str"");
          b.append(nextChar);
        }
 else         if (nextChar == '&' && nextChar2 == 'q' && nextChar3 == 'u' && nextChar4 == 'o' && nextChar5 == 't' && nextChar6 == ';') {
          b.append(""String_Node_Str"");
          inQuote=true;
          i+=5;
        }
 else {
          b.append(nextChar);
        }
      }
 else {
        if (nextChar == '&' && nextChar2 == 'l' && nextChar3 == 't' && nextChar4 == ';') {
          b.append(""String_Node_Str"");
          inTag=true;
          i+=3;
        }
 else {
          b.append(nextChar);
        }
      }
    }
  }
  return b.toString();
}","private String format(String theResultBody,EncodingEnum theEncodingEnum){
  String str=StringEscapeUtils.escapeHtml4(theResultBody);
  if (str == null || theEncodingEnum == null) {
    return str;
  }
  StringBuilder b=new StringBuilder();
  if (theEncodingEnum == EncodingEnum.JSON) {
    boolean inValue=false;
    boolean inQuote=false;
    for (int i=0; i < str.length(); i++) {
      char prevChar=(i > 0) ? str.charAt(i - 1) : ' ';
      char nextChar=str.charAt(i);
      char nextChar2=(i + 1) < str.length() ? str.charAt(i + 1) : ' ';
      char nextChar3=(i + 2) < str.length() ? str.charAt(i + 2) : ' ';
      char nextChar4=(i + 3) < str.length() ? str.charAt(i + 3) : ' ';
      char nextChar5=(i + 4) < str.length() ? str.charAt(i + 4) : ' ';
      char nextChar6=(i + 5) < str.length() ? str.charAt(i + 5) : ' ';
      if (inQuote) {
        b.append(nextChar);
        if (prevChar != '\\' && nextChar == '&' && nextChar2 == 'q' && nextChar3 == 'u' && nextChar4 == 'o' && nextChar5 == 't' && nextChar6 == ';') {
          b.append(""String_Node_Str"");
          i+=5;
          inQuote=false;
        }
 else         if (nextChar == '\\' && nextChar2 == '""') {
          b.append(""String_Node_Str"");
          i+=5;
          inQuote=false;
        }
      }
 else {
        if (nextChar == ':') {
          inValue=true;
          b.append(nextChar);
        }
 else         if (nextChar == '[' || nextChar == '{') {
          b.append(""String_Node_Str"");
          b.append(nextChar);
          b.append(""String_Node_Str"");
          inValue=false;
        }
 else         if (nextChar == '{' || nextChar == '}' || nextChar == ',') {
          b.append(""String_Node_Str"");
          b.append(nextChar);
          b.append(""String_Node_Str"");
          inValue=false;
        }
 else         if (nextChar == '&' && nextChar2 == 'q' && nextChar3 == 'u' && nextChar4 == 'o' && nextChar5 == 't' && nextChar6 == ';') {
          if (inValue) {
            b.append(""String_Node_Str"");
          }
 else {
            b.append(""String_Node_Str"");
          }
          inQuote=true;
          i+=5;
        }
 else         if (nextChar == ':') {
          b.append(""String_Node_Str"");
          b.append(nextChar);
          b.append(""String_Node_Str"");
          inValue=true;
        }
 else {
          b.append(nextChar);
        }
      }
    }
  }
 else {
    boolean inQuote=false;
    boolean inTag=false;
    for (int i=0; i < str.length(); i++) {
      char nextChar=str.charAt(i);
      char nextChar2=(i + 1) < str.length() ? str.charAt(i + 1) : ' ';
      char nextChar3=(i + 2) < str.length() ? str.charAt(i + 2) : ' ';
      char nextChar4=(i + 3) < str.length() ? str.charAt(i + 3) : ' ';
      char nextChar5=(i + 4) < str.length() ? str.charAt(i + 4) : ' ';
      char nextChar6=(i + 5) < str.length() ? str.charAt(i + 5) : ' ';
      if (inQuote) {
        b.append(nextChar);
        if (nextChar == '&' && nextChar2 == 'q' && nextChar3 == 'u' && nextChar4 == 'o' && nextChar5 == 't' && nextChar6 == ';') {
          b.append(""String_Node_Str"");
          i+=5;
          inQuote=false;
        }
      }
 else       if (inTag) {
        if (nextChar == '&' && nextChar2 == 'g' && nextChar3 == 't' && nextChar4 == ';') {
          b.append(""String_Node_Str"");
          inTag=false;
          i+=3;
        }
 else         if (nextChar == ' ') {
          b.append(""String_Node_Str"");
          b.append(nextChar);
        }
 else         if (nextChar == '&' && nextChar2 == 'q' && nextChar3 == 'u' && nextChar4 == 'o' && nextChar5 == 't' && nextChar6 == ';') {
          b.append(""String_Node_Str"");
          inQuote=true;
          i+=5;
        }
 else {
          b.append(nextChar);
        }
      }
 else {
        if (nextChar == '&' && nextChar2 == 'l' && nextChar3 == 't' && nextChar4 == ';') {
          b.append(""String_Node_Str"");
          inTag=true;
          i+=3;
        }
 else {
          b.append(nextChar);
        }
      }
    }
  }
  return b.toString();
}",0.9997508719481814
112246,"@Override public Verdict applyRule(RestOperationTypeEnum theOperation,RequestDetails theRequestDetails,IBaseResource theInputResource,IIdType theInputResourceId,IBaseResource theOutputResource,IRuleApplier theRuleApplier){
  if (theInputResourceId != null) {
    return null;
  }
  if (theOperation == myOperationType) {
switch (myAppliesTo) {
case ALL_RESOURCES:
      break;
case TYPES:
    if (theInputResource == null || !myAppliesToTypes.contains(theInputResource.getClass())) {
      return null;
    }
  break;
}
if (theRequestDetails.getConditionalUrl(myOperationType) == null) {
return null;
}
return newVerdict();
}
return null;
}","@Override public Verdict applyRule(RestOperationTypeEnum theOperation,RequestDetails theRequestDetails,IBaseResource theInputResource,IIdType theInputResourceId,IBaseResource theOutputResource,IRuleApplier theRuleApplier){
  if (theInputResourceId != null) {
    return null;
  }
  if (theOperation == myOperationType) {
switch (myAppliesTo) {
case ALL_RESOURCES:
case INSTANCES:
      break;
case TYPES:
    if (theInputResource == null || !myAppliesToTypes.contains(theInputResource.getClass())) {
      return null;
    }
  break;
}
if (theRequestDetails.getConditionalUrl(myOperationType) == null) {
return null;
}
return newVerdict();
}
return null;
}",0.9876543209876544
112247,"@Override public void contextInitialized(ServletContextEvent theSce){
  theSce.getServletContext().setInitParameter(ContextLoader.CONTEXT_CLASS_PARAM,AnnotationConfigWebApplicationContext.class.getName());
switch (ContextHolder.getCtx().getVersion().getVersion()) {
case DSTU2:
    theSce.getServletContext().setInitParameter(ContextLoader.CONFIG_LOCATION_PARAM,FhirServerConfig.class.getName());
  break;
case DSTU3:
theSce.getServletContext().setInitParameter(ContextLoader.CONFIG_LOCATION_PARAM,FhirServerConfigDstu3.class.getName());
break;
}
cll.contextInitialized(theSce);
}","@Override public void contextInitialized(ServletContextEvent theSce){
  theSce.getServletContext().setInitParameter(ContextLoader.CONTEXT_CLASS_PARAM,AnnotationConfigWebApplicationContext.class.getName());
switch (ContextHolder.getCtx().getVersion().getVersion()) {
case DSTU2:
    theSce.getServletContext().setInitParameter(ContextLoader.CONFIG_LOCATION_PARAM,FhirServerConfig.class.getName());
  break;
case DSTU3:
theSce.getServletContext().setInitParameter(ContextLoader.CONFIG_LOCATION_PARAM,FhirServerConfigDstu3.class.getName());
break;
case DSTU1:
case DSTU2_1:
case DSTU2_HL7ORG:
break;
}
cll.contextInitialized(theSce);
}",0.9570957095709572
112248,"@Override public void run(CommandLine theCommandLine) throws ParseException {
  myPort=parseOptionInteger(theCommandLine,OPTION_P,DEFAULT_PORT);
  if (theCommandLine.hasOption(OPTION_LOWMEM)) {
    ourLog.info(""String_Node_Str"");
    System.setProperty(OPTION_LOWMEM,OPTION_LOWMEM);
  }
  if (theCommandLine.hasOption(OPTION_ALLOW_EXTERNAL_REFS)) {
    ourLog.info(""String_Node_Str"");
    ContextHolder.setAllowExternalRefs(true);
  }
  ContextHolder.setCtx(getSpecVersionContext(theCommandLine));
  ourLog.info(""String_Node_Str"",myPort);
  File tempWarFile;
  try {
    tempWarFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    tempWarFile.deleteOnExit();
    InputStream inStream=RunServerCommand.class.getResourceAsStream(""String_Node_Str"");
    OutputStream outStream=new BufferedOutputStream(new FileOutputStream(tempWarFile,false));
    IOUtils.copy(inStream,outStream);
  }
 catch (  IOException e) {
    ourLog.error(""String_Node_Str"",e);
    return;
  }
  final ContextLoaderListener cll=new ContextLoaderListener();
  ourLog.info(""String_Node_Str"",ContextHolder.getCtx().getVersion().getVersion());
  WebAppContext root=new WebAppContext();
  root.setAllowDuplicateFragmentNames(true);
  root.setWar(tempWarFile.getAbsolutePath());
  root.setParentLoaderPriority(true);
  root.setContextPath(""String_Node_Str"");
  root.addEventListener(new ServletContextListener(){
    @Override public void contextInitialized(    ServletContextEvent theSce){
      theSce.getServletContext().setInitParameter(ContextLoader.CONTEXT_CLASS_PARAM,AnnotationConfigWebApplicationContext.class.getName());
switch (ContextHolder.getCtx().getVersion().getVersion()) {
case DSTU2:
        theSce.getServletContext().setInitParameter(ContextLoader.CONFIG_LOCATION_PARAM,FhirServerConfig.class.getName());
      break;
case DSTU3:
    theSce.getServletContext().setInitParameter(ContextLoader.CONFIG_LOCATION_PARAM,FhirServerConfigDstu3.class.getName());
  break;
}
cll.contextInitialized(theSce);
}
@Override public void contextDestroyed(ServletContextEvent theSce){
cll.contextDestroyed(theSce);
}
}
);
String path=ContextHolder.getPath();
root.addServlet(""String_Node_Str"",path + ""String_Node_Str"");
myServer=new Server(myPort);
myServer.setHandler(root);
try {
myServer.start();
}
 catch (SocketException e) {
throw new CommandFailureException(""String_Node_Str"" + myPort + ""String_Node_Str""+ e.toString()+ ""String_Node_Str"");
}
catch (Exception e) {
ourLog.error(""String_Node_Str"",e);
throw new CommandFailureException(""String_Node_Str"",e);
}
ourLog.info(""String_Node_Str"",myPort);
ourLog.info(""String_Node_Str"",myPort);
ourLog.info(""String_Node_Str"",myPort,path);
}","@Override public void run(CommandLine theCommandLine) throws ParseException {
  myPort=parseOptionInteger(theCommandLine,OPTION_P,DEFAULT_PORT);
  if (theCommandLine.hasOption(OPTION_LOWMEM)) {
    ourLog.info(""String_Node_Str"");
    System.setProperty(OPTION_LOWMEM,OPTION_LOWMEM);
  }
  if (theCommandLine.hasOption(OPTION_ALLOW_EXTERNAL_REFS)) {
    ourLog.info(""String_Node_Str"");
    ContextHolder.setAllowExternalRefs(true);
  }
  ContextHolder.setCtx(getSpecVersionContext(theCommandLine));
  ourLog.info(""String_Node_Str"",myPort);
  File tempWarFile;
  try {
    tempWarFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    tempWarFile.deleteOnExit();
    InputStream inStream=RunServerCommand.class.getResourceAsStream(""String_Node_Str"");
    OutputStream outStream=new BufferedOutputStream(new FileOutputStream(tempWarFile,false));
    IOUtils.copy(inStream,outStream);
  }
 catch (  IOException e) {
    ourLog.error(""String_Node_Str"",e);
    return;
  }
  final ContextLoaderListener cll=new ContextLoaderListener();
  ourLog.info(""String_Node_Str"",ContextHolder.getCtx().getVersion().getVersion());
  WebAppContext root=new WebAppContext();
  root.setAllowDuplicateFragmentNames(true);
  root.setWar(tempWarFile.getAbsolutePath());
  root.setParentLoaderPriority(true);
  root.setContextPath(""String_Node_Str"");
  root.addEventListener(new ServletContextListener(){
    @Override public void contextInitialized(    ServletContextEvent theSce){
      theSce.getServletContext().setInitParameter(ContextLoader.CONTEXT_CLASS_PARAM,AnnotationConfigWebApplicationContext.class.getName());
switch (ContextHolder.getCtx().getVersion().getVersion()) {
case DSTU2:
        theSce.getServletContext().setInitParameter(ContextLoader.CONFIG_LOCATION_PARAM,FhirServerConfig.class.getName());
      break;
case DSTU3:
    theSce.getServletContext().setInitParameter(ContextLoader.CONFIG_LOCATION_PARAM,FhirServerConfigDstu3.class.getName());
  break;
case DSTU1:
case DSTU2_1:
case DSTU2_HL7ORG:
break;
}
cll.contextInitialized(theSce);
}
@Override public void contextDestroyed(ServletContextEvent theSce){
cll.contextDestroyed(theSce);
}
}
);
String path=ContextHolder.getPath();
root.addServlet(""String_Node_Str"",path + ""String_Node_Str"");
myServer=new Server(myPort);
myServer.setHandler(root);
try {
myServer.start();
}
 catch (SocketException e) {
throw new CommandFailureException(""String_Node_Str"" + myPort + ""String_Node_Str""+ e.toString()+ ""String_Node_Str"");
}
catch (Exception e) {
ourLog.error(""String_Node_Str"",e);
throw new CommandFailureException(""String_Node_Str"",e);
}
ourLog.info(""String_Node_Str"",myPort);
ourLog.info(""String_Node_Str"",myPort);
ourLog.info(""String_Node_Str"",myPort,path);
}",0.9903525046382188
112249,"@SuppressWarnings(""String_Node_Str"") private Bundle doTransaction(ServletRequestDetails theRequestDetails,Bundle theRequest,String theActionName){
  BundleTypeEnum transactionType=theRequest.getTypeElement().getValueAsEnum();
  if (transactionType == BundleTypeEnum.BATCH) {
    return batch(theRequestDetails,theRequest);
  }
  if (transactionType == null) {
    String message=""String_Node_Str"" + BundleTypeEnum.TRANSACTION.getCode();
    ourLog.warn(message);
    transactionType=BundleTypeEnum.TRANSACTION;
  }
  if (transactionType != BundleTypeEnum.TRANSACTION) {
    throw new InvalidRequestException(""String_Node_Str"" + transactionType.getCode());
  }
  ourLog.info(""String_Node_Str"",theActionName,theRequest.getEntry().size());
  long start=System.currentTimeMillis();
  Date updateTime=new Date();
  Set<IdDt> allIds=new LinkedHashSet<IdDt>();
  Map<IdDt,IdDt> idSubstitutions=new HashMap<IdDt,IdDt>();
  Map<IdDt,DaoMethodOutcome> idToPersistedOutcome=new HashMap<IdDt,DaoMethodOutcome>();
  Bundle response=new Bundle();
  List<Entry> getEntries=new ArrayList<Entry>();
  IdentityHashMap<Entry,Integer> originalRequestOrder=new IdentityHashMap<Bundle.Entry,Integer>();
  for (int i=0; i < theRequest.getEntry().size(); i++) {
    originalRequestOrder.put(theRequest.getEntry().get(i),i);
    response.addEntry();
    if (theRequest.getEntry().get(i).getRequest().getMethodElement().getValueAsEnum() == HTTPVerbEnum.GET) {
      getEntries.add(theRequest.getEntry().get(i));
    }
  }
  Collections.sort(theRequest.getEntry(),new TransactionSorter());
  List<IIdType> deletedResources=new ArrayList<IIdType>();
  List<DeleteConflict> deleteConflicts=new ArrayList<DeleteConflict>();
  Map<Entry,ResourceTable> entriesToProcess=new IdentityHashMap<Entry,ResourceTable>();
  Set<ResourceTable> nonUpdatedEntities=new HashSet<ResourceTable>();
  for (int i=0; i < theRequest.getEntry().size(); i++) {
    if (i % 100 == 0) {
      ourLog.info(""String_Node_Str"",i,theRequest.getEntry().size());
    }
    Entry nextReqEntry=theRequest.getEntry().get(i);
    IResource res=nextReqEntry.getResource();
    IdDt nextResourceId=null;
    if (res != null) {
      nextResourceId=res.getId();
      if (nextResourceId.hasIdPart() == false) {
        if (isNotBlank(nextReqEntry.getFullUrl())) {
          nextResourceId=new IdDt(nextReqEntry.getFullUrl());
        }
      }
      if (nextResourceId.hasIdPart() && nextResourceId.getIdPart().matches(""String_Node_Str"") && !isPlaceholder(nextResourceId)) {
        throw new InvalidRequestException(""String_Node_Str"" + nextResourceId.getIdPart() + ""String_Node_Str"");
      }
      if (nextResourceId.hasIdPart() && !nextResourceId.hasResourceType() && !isPlaceholder(nextResourceId)) {
        nextResourceId=new IdDt(toResourceName(res.getClass()),nextResourceId.getIdPart());
        res.setId(nextResourceId);
      }
      if (isPlaceholder(nextResourceId)) {
        if (!allIds.add(nextResourceId)) {
          throw new InvalidRequestException(getContext().getLocalizer().getMessage(BaseHapiFhirSystemDao.class,""String_Node_Str"",nextResourceId));
        }
      }
 else       if (nextResourceId.hasResourceType() && nextResourceId.hasIdPart()) {
        IdDt nextId=nextResourceId.toUnqualifiedVersionless();
        if (!allIds.add(nextId)) {
          throw new InvalidRequestException(getContext().getLocalizer().getMessage(BaseHapiFhirSystemDao.class,""String_Node_Str"",nextId));
        }
      }
    }
    HTTPVerbEnum verb=nextReqEntry.getRequest().getMethodElement().getValueAsEnum();
    if (verb == null) {
      throw new InvalidRequestException(getContext().getLocalizer().getMessage(BaseHapiFhirSystemDao.class,""String_Node_Str"",nextReqEntry.getRequest().getMethod()));
    }
    String resourceType=res != null ? getContext().getResourceDefinition(res).getName() : null;
    Entry nextRespEntry=response.getEntry().get(originalRequestOrder.get(nextReqEntry));
switch (verb) {
case POST:
{
        @SuppressWarnings(""String_Node_Str"") IFhirResourceDao resourceDao=getDaoOrThrowException(res.getClass());
        res.setId((String)null);
        DaoMethodOutcome outcome;
        outcome=resourceDao.create(res,nextReqEntry.getRequest().getIfNoneExist(),false,theRequestDetails);
        handleTransactionCreateOrUpdateOutcome(idSubstitutions,idToPersistedOutcome,nextResourceId,outcome,nextRespEntry,resourceType,res);
        entriesToProcess.put(nextRespEntry,outcome.getEntity());
        if (outcome.getCreated() == false) {
          nonUpdatedEntities.add(outcome.getEntity());
        }
        break;
      }
case DELETE:
{
      String url=extractTransactionUrlOrThrowException(nextReqEntry,verb);
      UrlParts parts=UrlUtil.parseUrl(url);
      ca.uhn.fhir.jpa.dao.IFhirResourceDao<? extends IBaseResource> dao=toDao(parts,verb.getCode(),url);
      int status=Constants.STATUS_HTTP_204_NO_CONTENT;
      if (parts.getResourceId() != null) {
        DaoMethodOutcome outcome=dao.delete(new IdDt(parts.getResourceType(),parts.getResourceId()),deleteConflicts,theRequestDetails);
        if (outcome.getEntity() != null) {
          deletedResources.add(outcome.getId().toUnqualifiedVersionless());
          entriesToProcess.put(nextRespEntry,outcome.getEntity());
        }
      }
 else {
        DeleteMethodOutcome deleteOutcome=dao.deleteByUrl(parts.getResourceType() + '?' + parts.getParams(),deleteConflicts,theRequestDetails);
        List<ResourceTable> allDeleted=deleteOutcome.getDeletedEntities();
        for (        ResourceTable deleted : allDeleted) {
          deletedResources.add(deleted.getIdDt().toUnqualifiedVersionless());
        }
        if (allDeleted.isEmpty()) {
          status=Constants.STATUS_HTTP_404_NOT_FOUND;
        }
      }
      nextRespEntry.getResponse().setStatus(toStatusString(status));
      break;
    }
case PUT:
{
    @SuppressWarnings(""String_Node_Str"") IFhirResourceDao resourceDao=getDaoOrThrowException(res.getClass());
    DaoMethodOutcome outcome;
    String url=extractTransactionUrlOrThrowException(nextReqEntry,verb);
    UrlParts parts=UrlUtil.parseUrl(url);
    if (isNotBlank(parts.getResourceId())) {
      res.setId(new IdDt(parts.getResourceType(),parts.getResourceId()));
      outcome=resourceDao.update(res,null,false,theRequestDetails);
    }
 else {
      res.setId((String)null);
      outcome=resourceDao.update(res,parts.getResourceType() + '?' + parts.getParams(),false,theRequestDetails);
    }
    handleTransactionCreateOrUpdateOutcome(idSubstitutions,idToPersistedOutcome,nextResourceId,outcome,nextRespEntry,resourceType,res);
    entriesToProcess.put(nextRespEntry,outcome.getEntity());
    break;
  }
}
}
for (Iterator<DeleteConflict> iter=deleteConflicts.iterator(); iter.hasNext(); ) {
DeleteConflict next=iter.next();
if (deletedResources.contains(next.getTargetId().toVersionless())) {
iter.remove();
}
}
validateDeleteConflictsEmptyOrThrowException(deleteConflicts);
FhirTerser terser=getContext().newTerser();
for (DaoMethodOutcome nextOutcome : idToPersistedOutcome.values()) {
IResource nextResource=(IResource)nextOutcome.getResource();
if (nextResource == null) {
continue;
}
List<BaseResourceReferenceDt> allRefs=terser.getAllPopulatedChildElementsOfType(nextResource,BaseResourceReferenceDt.class);
for (BaseResourceReferenceDt nextRef : allRefs) {
IdDt nextId=nextRef.getReference();
if (!nextId.hasIdPart()) {
  continue;
}
if (idSubstitutions.containsKey(nextId)) {
  IdDt newId=idSubstitutions.get(nextId);
  ourLog.info(""String_Node_Str"",nextId,newId);
  nextRef.setReference(newId);
}
 else {
  ourLog.debug(""String_Node_Str"",nextId);
}
}
InstantDt deletedInstantOrNull=ResourceMetadataKeyEnum.DELETED_AT.get(nextResource);
Date deletedTimestampOrNull=deletedInstantOrNull != null ? deletedInstantOrNull.getValue() : null;
boolean shouldUpdate=!nonUpdatedEntities.contains(nextOutcome.getEntity());
if (shouldUpdate) {
updateEntity(nextResource,nextOutcome.getEntity(),deletedTimestampOrNull,true,true,updateTime);
}
}
myEntityManager.flush();
for (Entry nextEntry : theRequest.getEntry()) {
if (nextEntry.getRequest().getMethodElement().getValueAsEnum() == HTTPVerbEnum.POST) {
String matchUrl=nextEntry.getRequest().getIfNoneExist();
if (isNotBlank(matchUrl)) {
  IFhirResourceDao<?> resourceDao=getDao(nextEntry.getResource().getClass());
  Set<Long> val=resourceDao.processMatchUrl(matchUrl);
  if (val.size() > 1) {
    throw new InvalidRequestException(""String_Node_Str"" + theActionName + ""String_Node_Str""+ matchUrl+ ""String_Node_Str"");
  }
}
}
}
for (IdDt next : allIds) {
IdDt replacement=idSubstitutions.get(next);
if (replacement == null) {
continue;
}
if (replacement.equals(next)) {
continue;
}
ourLog.info(""String_Node_Str"",next,replacement);
}
for (int i=0; i < getEntries.size(); i++) {
Entry nextReqEntry=getEntries.get(i);
Integer originalOrder=originalRequestOrder.get(nextReqEntry);
Entry nextRespEntry=response.getEntry().get(originalOrder);
ServletSubRequestDetails requestDetails=new ServletSubRequestDetails();
requestDetails.setServletRequest(theRequestDetails.getServletRequest());
requestDetails.setRequestType(RequestTypeEnum.GET);
requestDetails.setServer(theRequestDetails.getServer());
String url=extractTransactionUrlOrThrowException(nextReqEntry,HTTPVerbEnum.GET);
int qIndex=url.indexOf('?');
ArrayListMultimap<String,String> paramValues=ArrayListMultimap.create();
requestDetails.setParameters(new HashMap<String,String[]>());
if (qIndex != -1) {
String params=url.substring(qIndex);
List<NameValuePair> parameters=translateMatchUrl(params);
for (NameValuePair next : parameters) {
  paramValues.put(next.getName(),next.getValue());
}
for (java.util.Map.Entry<String,Collection<String>> nextParamEntry : paramValues.asMap().entrySet()) {
  String[] nextValue=nextParamEntry.getValue().toArray(new String[nextParamEntry.getValue().size()]);
  requestDetails.getParameters().put(nextParamEntry.getKey(),nextValue);
}
url=url.substring(0,qIndex);
}
requestDetails.setRequestPath(url);
requestDetails.setFhirServerBase(theRequestDetails.getFhirServerBase());
theRequestDetails.getServer().populateRequestDetailsFromRequestPath(requestDetails,url);
BaseMethodBinding<?> method=theRequestDetails.getServer().determineResourceMethod(requestDetails,url);
if (method == null) {
throw new IllegalArgumentException(""String_Node_Str"" + url);
}
if (isNotBlank(nextReqEntry.getRequest().getIfMatch())) {
requestDetails.addHeader(Constants.HEADER_IF_MATCH,nextReqEntry.getRequest().getIfMatch());
}
if (isNotBlank(nextReqEntry.getRequest().getIfNoneExist())) {
requestDetails.addHeader(Constants.HEADER_IF_NONE_EXIST,nextReqEntry.getRequest().getIfNoneExist());
}
if (isNotBlank(nextReqEntry.getRequest().getIfNoneMatch())) {
requestDetails.addHeader(Constants.HEADER_IF_NONE_MATCH,nextReqEntry.getRequest().getIfNoneMatch());
}
if (method instanceof BaseResourceReturningMethodBinding) {
try {
  ResourceOrDstu1Bundle responseData=((BaseResourceReturningMethodBinding)method).doInvokeServer(theRequestDetails.getServer(),requestDetails);
  IBaseResource resource=responseData.getResource();
  if (paramValues.containsKey(Constants.PARAM_SUMMARY) || paramValues.containsKey(Constants.PARAM_CONTENT)) {
    resource=filterNestedBundle(requestDetails,resource);
  }
  nextRespEntry.setResource((IResource)resource);
  nextRespEntry.getResponse().setStatus(toStatusString(Constants.STATUS_HTTP_200_OK));
}
 catch (NotModifiedException e) {
  nextRespEntry.getResponse().setStatus(toStatusString(Constants.STATUS_HTTP_304_NOT_MODIFIED));
}
}
 else {
throw new IllegalArgumentException(""String_Node_Str"" + url);
}
}
ourLog.info(""String_Node_Str"",theActionName);
myEntityManager.flush();
for (java.util.Map.Entry<Entry,ResourceTable> nextEntry : entriesToProcess.entrySet()) {
nextEntry.getKey().getResponse().setLocation(nextEntry.getValue().getIdDt().toUnqualified().getValue());
nextEntry.getKey().getResponse().setEtag(nextEntry.getValue().getIdDt().getVersionIdPart());
}
long delay=System.currentTimeMillis() - start;
int numEntries=theRequest.getEntry().size();
long delayPer=delay / numEntries;
ourLog.info(""String_Node_Str"",new Object[]{theActionName,delay,numEntries,delayPer});
response.setType(BundleTypeEnum.TRANSACTION_RESPONSE);
return response;
}","@SuppressWarnings(""String_Node_Str"") private Bundle doTransaction(ServletRequestDetails theRequestDetails,Bundle theRequest,String theActionName){
  BundleTypeEnum transactionType=theRequest.getTypeElement().getValueAsEnum();
  if (transactionType == BundleTypeEnum.BATCH) {
    return batch(theRequestDetails,theRequest);
  }
  if (transactionType == null) {
    String message=""String_Node_Str"" + BundleTypeEnum.TRANSACTION.getCode();
    ourLog.warn(message);
    transactionType=BundleTypeEnum.TRANSACTION;
  }
  if (transactionType != BundleTypeEnum.TRANSACTION) {
    throw new InvalidRequestException(""String_Node_Str"" + transactionType.getCode());
  }
  ourLog.info(""String_Node_Str"",theActionName,theRequest.getEntry().size());
  long start=System.currentTimeMillis();
  Date updateTime=new Date();
  Set<IdDt> allIds=new LinkedHashSet<IdDt>();
  Map<IdDt,IdDt> idSubstitutions=new HashMap<IdDt,IdDt>();
  Map<IdDt,DaoMethodOutcome> idToPersistedOutcome=new HashMap<IdDt,DaoMethodOutcome>();
  Bundle response=new Bundle();
  List<Entry> getEntries=new ArrayList<Entry>();
  IdentityHashMap<Entry,Integer> originalRequestOrder=new IdentityHashMap<Bundle.Entry,Integer>();
  for (int i=0; i < theRequest.getEntry().size(); i++) {
    originalRequestOrder.put(theRequest.getEntry().get(i),i);
    response.addEntry();
    if (theRequest.getEntry().get(i).getRequest().getMethodElement().getValueAsEnum() == HTTPVerbEnum.GET) {
      getEntries.add(theRequest.getEntry().get(i));
    }
  }
  Collections.sort(theRequest.getEntry(),new TransactionSorter());
  List<IIdType> deletedResources=new ArrayList<IIdType>();
  List<DeleteConflict> deleteConflicts=new ArrayList<DeleteConflict>();
  Map<Entry,ResourceTable> entriesToProcess=new IdentityHashMap<Entry,ResourceTable>();
  Set<ResourceTable> nonUpdatedEntities=new HashSet<ResourceTable>();
  for (int i=0; i < theRequest.getEntry().size(); i++) {
    if (i % 100 == 0) {
      ourLog.info(""String_Node_Str"",i,theRequest.getEntry().size());
    }
    Entry nextReqEntry=theRequest.getEntry().get(i);
    IResource res=nextReqEntry.getResource();
    IdDt nextResourceId=null;
    if (res != null) {
      nextResourceId=res.getId();
      if (nextResourceId.hasIdPart() == false) {
        if (isNotBlank(nextReqEntry.getFullUrl())) {
          nextResourceId=new IdDt(nextReqEntry.getFullUrl());
        }
      }
      if (nextResourceId.hasIdPart() && nextResourceId.getIdPart().matches(""String_Node_Str"") && !isPlaceholder(nextResourceId)) {
        throw new InvalidRequestException(""String_Node_Str"" + nextResourceId.getIdPart() + ""String_Node_Str"");
      }
      if (nextResourceId.hasIdPart() && !nextResourceId.hasResourceType() && !isPlaceholder(nextResourceId)) {
        nextResourceId=new IdDt(toResourceName(res.getClass()),nextResourceId.getIdPart());
        res.setId(nextResourceId);
      }
      if (isPlaceholder(nextResourceId)) {
        if (!allIds.add(nextResourceId)) {
          throw new InvalidRequestException(getContext().getLocalizer().getMessage(BaseHapiFhirSystemDao.class,""String_Node_Str"",nextResourceId));
        }
      }
 else       if (nextResourceId.hasResourceType() && nextResourceId.hasIdPart()) {
        IdDt nextId=nextResourceId.toUnqualifiedVersionless();
        if (!allIds.add(nextId)) {
          throw new InvalidRequestException(getContext().getLocalizer().getMessage(BaseHapiFhirSystemDao.class,""String_Node_Str"",nextId));
        }
      }
    }
    HTTPVerbEnum verb=nextReqEntry.getRequest().getMethodElement().getValueAsEnum();
    if (verb == null) {
      throw new InvalidRequestException(getContext().getLocalizer().getMessage(BaseHapiFhirSystemDao.class,""String_Node_Str"",nextReqEntry.getRequest().getMethod()));
    }
    String resourceType=res != null ? getContext().getResourceDefinition(res).getName() : null;
    Entry nextRespEntry=response.getEntry().get(originalRequestOrder.get(nextReqEntry));
switch (verb) {
case POST:
{
        @SuppressWarnings(""String_Node_Str"") IFhirResourceDao resourceDao=getDaoOrThrowException(res.getClass());
        res.setId((String)null);
        DaoMethodOutcome outcome;
        outcome=resourceDao.create(res,nextReqEntry.getRequest().getIfNoneExist(),false,theRequestDetails);
        handleTransactionCreateOrUpdateOutcome(idSubstitutions,idToPersistedOutcome,nextResourceId,outcome,nextRespEntry,resourceType,res);
        entriesToProcess.put(nextRespEntry,outcome.getEntity());
        if (outcome.getCreated() == false) {
          nonUpdatedEntities.add(outcome.getEntity());
        }
        break;
      }
case DELETE:
{
      String url=extractTransactionUrlOrThrowException(nextReqEntry,verb);
      UrlParts parts=UrlUtil.parseUrl(url);
      ca.uhn.fhir.jpa.dao.IFhirResourceDao<? extends IBaseResource> dao=toDao(parts,verb.getCode(),url);
      int status=Constants.STATUS_HTTP_204_NO_CONTENT;
      if (parts.getResourceId() != null) {
        DaoMethodOutcome outcome=dao.delete(new IdDt(parts.getResourceType(),parts.getResourceId()),deleteConflicts,theRequestDetails);
        if (outcome.getEntity() != null) {
          deletedResources.add(outcome.getId().toUnqualifiedVersionless());
          entriesToProcess.put(nextRespEntry,outcome.getEntity());
        }
      }
 else {
        DeleteMethodOutcome deleteOutcome=dao.deleteByUrl(parts.getResourceType() + '?' + parts.getParams(),deleteConflicts,theRequestDetails);
        List<ResourceTable> allDeleted=deleteOutcome.getDeletedEntities();
        for (        ResourceTable deleted : allDeleted) {
          deletedResources.add(deleted.getIdDt().toUnqualifiedVersionless());
        }
        if (allDeleted.isEmpty()) {
          status=Constants.STATUS_HTTP_404_NOT_FOUND;
        }
      }
      nextRespEntry.getResponse().setStatus(toStatusString(status));
      break;
    }
case PUT:
{
    @SuppressWarnings(""String_Node_Str"") IFhirResourceDao resourceDao=getDaoOrThrowException(res.getClass());
    DaoMethodOutcome outcome;
    String url=extractTransactionUrlOrThrowException(nextReqEntry,verb);
    UrlParts parts=UrlUtil.parseUrl(url);
    if (isNotBlank(parts.getResourceId())) {
      res.setId(new IdDt(parts.getResourceType(),parts.getResourceId()));
      outcome=resourceDao.update(res,null,false,theRequestDetails);
    }
 else {
      res.setId((String)null);
      outcome=resourceDao.update(res,parts.getResourceType() + '?' + parts.getParams(),false,theRequestDetails);
    }
    handleTransactionCreateOrUpdateOutcome(idSubstitutions,idToPersistedOutcome,nextResourceId,outcome,nextRespEntry,resourceType,res);
    entriesToProcess.put(nextRespEntry,outcome.getEntity());
    break;
  }
case GET:
break;
}
}
for (Iterator<DeleteConflict> iter=deleteConflicts.iterator(); iter.hasNext(); ) {
DeleteConflict next=iter.next();
if (deletedResources.contains(next.getTargetId().toVersionless())) {
iter.remove();
}
}
validateDeleteConflictsEmptyOrThrowException(deleteConflicts);
FhirTerser terser=getContext().newTerser();
for (DaoMethodOutcome nextOutcome : idToPersistedOutcome.values()) {
IResource nextResource=(IResource)nextOutcome.getResource();
if (nextResource == null) {
continue;
}
List<BaseResourceReferenceDt> allRefs=terser.getAllPopulatedChildElementsOfType(nextResource,BaseResourceReferenceDt.class);
for (BaseResourceReferenceDt nextRef : allRefs) {
IdDt nextId=nextRef.getReference();
if (!nextId.hasIdPart()) {
continue;
}
if (idSubstitutions.containsKey(nextId)) {
IdDt newId=idSubstitutions.get(nextId);
ourLog.info(""String_Node_Str"",nextId,newId);
nextRef.setReference(newId);
}
 else {
ourLog.debug(""String_Node_Str"",nextId);
}
}
InstantDt deletedInstantOrNull=ResourceMetadataKeyEnum.DELETED_AT.get(nextResource);
Date deletedTimestampOrNull=deletedInstantOrNull != null ? deletedInstantOrNull.getValue() : null;
boolean shouldUpdate=!nonUpdatedEntities.contains(nextOutcome.getEntity());
if (shouldUpdate) {
updateEntity(nextResource,nextOutcome.getEntity(),deletedTimestampOrNull,true,true,updateTime);
}
}
myEntityManager.flush();
for (Entry nextEntry : theRequest.getEntry()) {
if (nextEntry.getRequest().getMethodElement().getValueAsEnum() == HTTPVerbEnum.POST) {
String matchUrl=nextEntry.getRequest().getIfNoneExist();
if (isNotBlank(matchUrl)) {
IFhirResourceDao<?> resourceDao=getDao(nextEntry.getResource().getClass());
Set<Long> val=resourceDao.processMatchUrl(matchUrl);
if (val.size() > 1) {
  throw new InvalidRequestException(""String_Node_Str"" + theActionName + ""String_Node_Str""+ matchUrl+ ""String_Node_Str"");
}
}
}
}
for (IdDt next : allIds) {
IdDt replacement=idSubstitutions.get(next);
if (replacement == null) {
continue;
}
if (replacement.equals(next)) {
continue;
}
ourLog.info(""String_Node_Str"",next,replacement);
}
for (int i=0; i < getEntries.size(); i++) {
Entry nextReqEntry=getEntries.get(i);
Integer originalOrder=originalRequestOrder.get(nextReqEntry);
Entry nextRespEntry=response.getEntry().get(originalOrder);
ServletSubRequestDetails requestDetails=new ServletSubRequestDetails();
requestDetails.setServletRequest(theRequestDetails.getServletRequest());
requestDetails.setRequestType(RequestTypeEnum.GET);
requestDetails.setServer(theRequestDetails.getServer());
String url=extractTransactionUrlOrThrowException(nextReqEntry,HTTPVerbEnum.GET);
int qIndex=url.indexOf('?');
ArrayListMultimap<String,String> paramValues=ArrayListMultimap.create();
requestDetails.setParameters(new HashMap<String,String[]>());
if (qIndex != -1) {
String params=url.substring(qIndex);
List<NameValuePair> parameters=translateMatchUrl(params);
for (NameValuePair next : parameters) {
paramValues.put(next.getName(),next.getValue());
}
for (java.util.Map.Entry<String,Collection<String>> nextParamEntry : paramValues.asMap().entrySet()) {
String[] nextValue=nextParamEntry.getValue().toArray(new String[nextParamEntry.getValue().size()]);
requestDetails.getParameters().put(nextParamEntry.getKey(),nextValue);
}
url=url.substring(0,qIndex);
}
requestDetails.setRequestPath(url);
requestDetails.setFhirServerBase(theRequestDetails.getFhirServerBase());
theRequestDetails.getServer().populateRequestDetailsFromRequestPath(requestDetails,url);
BaseMethodBinding<?> method=theRequestDetails.getServer().determineResourceMethod(requestDetails,url);
if (method == null) {
throw new IllegalArgumentException(""String_Node_Str"" + url);
}
if (isNotBlank(nextReqEntry.getRequest().getIfMatch())) {
requestDetails.addHeader(Constants.HEADER_IF_MATCH,nextReqEntry.getRequest().getIfMatch());
}
if (isNotBlank(nextReqEntry.getRequest().getIfNoneExist())) {
requestDetails.addHeader(Constants.HEADER_IF_NONE_EXIST,nextReqEntry.getRequest().getIfNoneExist());
}
if (isNotBlank(nextReqEntry.getRequest().getIfNoneMatch())) {
requestDetails.addHeader(Constants.HEADER_IF_NONE_MATCH,nextReqEntry.getRequest().getIfNoneMatch());
}
if (method instanceof BaseResourceReturningMethodBinding) {
try {
ResourceOrDstu1Bundle responseData=((BaseResourceReturningMethodBinding)method).doInvokeServer(theRequestDetails.getServer(),requestDetails);
IBaseResource resource=responseData.getResource();
if (paramValues.containsKey(Constants.PARAM_SUMMARY) || paramValues.containsKey(Constants.PARAM_CONTENT)) {
  resource=filterNestedBundle(requestDetails,resource);
}
nextRespEntry.setResource((IResource)resource);
nextRespEntry.getResponse().setStatus(toStatusString(Constants.STATUS_HTTP_200_OK));
}
 catch (NotModifiedException e) {
nextRespEntry.getResponse().setStatus(toStatusString(Constants.STATUS_HTTP_304_NOT_MODIFIED));
}
}
 else {
throw new IllegalArgumentException(""String_Node_Str"" + url);
}
}
ourLog.info(""String_Node_Str"",theActionName);
myEntityManager.flush();
for (java.util.Map.Entry<Entry,ResourceTable> nextEntry : entriesToProcess.entrySet()) {
nextEntry.getKey().getResponse().setLocation(nextEntry.getValue().getIdDt().toUnqualified().getValue());
nextEntry.getKey().getResponse().setEtag(nextEntry.getValue().getIdDt().getVersionIdPart());
}
long delay=System.currentTimeMillis() - start;
int numEntries=theRequest.getEntry().size();
long delayPer=delay / numEntries;
ourLog.info(""String_Node_Str"",new Object[]{theActionName,delay,numEntries,delayPer});
response.setType(BundleTypeEnum.TRANSACTION_RESPONSE);
return response;
}",0.993671144502062
112250,"private void searchForIdsWithAndOr(SearchParameterMap theParams,DateRangeParam theLastUpdated){
  SearchParameterMap params=theParams;
  if (params == null) {
    params=new SearchParameterMap();
  }
  myParams=theParams;
  doInitializeSearch();
  for (  Entry<String,List<List<? extends IQueryParameterType>>> nextParamEntry : params.entrySet()) {
    String nextParamName=nextParamEntry.getKey();
    if (nextParamName.equals(BaseResource.SP_RES_ID)) {
      if (nextParamEntry.getValue().isEmpty()) {
        continue;
      }
 else {
        for (        List<? extends IQueryParameterType> nextValue : nextParamEntry.getValue()) {
          Set<Long> joinPids=new HashSet<Long>();
          if (nextValue == null || nextValue.size() == 0) {
            continue;
          }
 else {
            for (            IQueryParameterType next : nextValue) {
              String value=next.getValueAsQueryToken(myContext);
              IIdType valueId=new IdDt(value);
              try {
                BaseHasResource entity=myCallingDao.readEntity(valueId);
                if (entity.getDeleted() != null) {
                  continue;
                }
                joinPids.add(entity.getId());
              }
 catch (              ResourceNotFoundException e) {
              }
            }
            if (joinPids.isEmpty()) {
              doSetPids(new HashSet<Long>());
              return;
            }
          }
          addPredicateId(joinPids);
          if (doHaveNoResults()) {
            return;
          }
        }
      }
    }
 else     if (nextParamName.equals(BaseResource.SP_RES_LANGUAGE)) {
      addPredicateLanguage(nextParamEntry.getValue());
    }
 else     if (nextParamName.equals(Constants.PARAM_HAS)) {
      addPredicateHas(nextParamEntry.getValue(),theLastUpdated);
    }
 else     if (nextParamName.equals(Constants.PARAM_TAG) || nextParamName.equals(Constants.PARAM_PROFILE) || nextParamName.equals(Constants.PARAM_SECURITY)) {
      addPredicateTag(nextParamEntry.getValue(),nextParamName,theLastUpdated);
    }
 else {
      RuntimeSearchParam nextParamDef=mySearchParamRegistry.getActiveSearchParam(myResourceName,nextParamName);
      if (nextParamDef != null) {
switch (nextParamDef.getParamType()) {
case DATE:
          for (          List<? extends IQueryParameterType> nextAnd : nextParamEntry.getValue()) {
            addPredicateDate(nextParamName,nextAnd);
            if (doHaveNoResults()) {
              return;
            }
          }
        break;
case QUANTITY:
      for (      List<? extends IQueryParameterType> nextAnd : nextParamEntry.getValue()) {
        addPredicateQuantity(nextParamName,nextAnd);
        if (doHaveNoResults()) {
          return;
        }
      }
    break;
case REFERENCE:
  for (  List<? extends IQueryParameterType> nextAnd : nextParamEntry.getValue()) {
    addPredicateReference(nextParamName,nextAnd);
    if (doHaveNoResults()) {
      return;
    }
  }
break;
case STRING:
for (List<? extends IQueryParameterType> nextAnd : nextParamEntry.getValue()) {
addPredicateString(nextParamName,nextAnd);
if (doHaveNoResults()) {
  return;
}
}
break;
case TOKEN:
for (List<? extends IQueryParameterType> nextAnd : nextParamEntry.getValue()) {
addPredicateToken(nextParamName,nextAnd);
if (doHaveNoResults()) {
return;
}
}
break;
case NUMBER:
for (List<? extends IQueryParameterType> nextAnd : nextParamEntry.getValue()) {
addPredicateNumber(nextParamName,nextAnd);
if (doHaveNoResults()) {
return;
}
}
break;
case COMPOSITE:
for (List<? extends IQueryParameterType> nextAnd : nextParamEntry.getValue()) {
addPredicateComposite(nextParamDef,nextAnd);
if (doHaveNoResults()) {
return;
}
}
break;
case URI:
for (List<? extends IQueryParameterType> nextAnd : nextParamEntry.getValue()) {
addPredicateUri(nextParamName,nextAnd);
if (doHaveNoResults()) {
return;
}
}
break;
}
}
}
if (doHaveNoResults()) {
return;
}
}
}","private void searchForIdsWithAndOr(SearchParameterMap theParams,DateRangeParam theLastUpdated){
  SearchParameterMap params=theParams;
  if (params == null) {
    params=new SearchParameterMap();
  }
  myParams=theParams;
  doInitializeSearch();
  for (  Entry<String,List<List<? extends IQueryParameterType>>> nextParamEntry : params.entrySet()) {
    String nextParamName=nextParamEntry.getKey();
    if (nextParamName.equals(BaseResource.SP_RES_ID)) {
      if (nextParamEntry.getValue().isEmpty()) {
        continue;
      }
 else {
        for (        List<? extends IQueryParameterType> nextValue : nextParamEntry.getValue()) {
          Set<Long> joinPids=new HashSet<Long>();
          if (nextValue == null || nextValue.size() == 0) {
            continue;
          }
 else {
            for (            IQueryParameterType next : nextValue) {
              String value=next.getValueAsQueryToken(myContext);
              IIdType valueId=new IdDt(value);
              try {
                BaseHasResource entity=myCallingDao.readEntity(valueId);
                if (entity.getDeleted() != null) {
                  continue;
                }
                joinPids.add(entity.getId());
              }
 catch (              ResourceNotFoundException e) {
              }
            }
            if (joinPids.isEmpty()) {
              doSetPids(new HashSet<Long>());
              return;
            }
          }
          addPredicateId(joinPids);
          if (doHaveNoResults()) {
            return;
          }
        }
      }
    }
 else     if (nextParamName.equals(BaseResource.SP_RES_LANGUAGE)) {
      addPredicateLanguage(nextParamEntry.getValue());
    }
 else     if (nextParamName.equals(Constants.PARAM_HAS)) {
      addPredicateHas(nextParamEntry.getValue(),theLastUpdated);
    }
 else     if (nextParamName.equals(Constants.PARAM_TAG) || nextParamName.equals(Constants.PARAM_PROFILE) || nextParamName.equals(Constants.PARAM_SECURITY)) {
      addPredicateTag(nextParamEntry.getValue(),nextParamName,theLastUpdated);
    }
 else {
      RuntimeSearchParam nextParamDef=mySearchParamRegistry.getActiveSearchParam(myResourceName,nextParamName);
      if (nextParamDef != null) {
switch (nextParamDef.getParamType()) {
case DATE:
          for (          List<? extends IQueryParameterType> nextAnd : nextParamEntry.getValue()) {
            addPredicateDate(nextParamName,nextAnd);
            if (doHaveNoResults()) {
              return;
            }
          }
        break;
case QUANTITY:
      for (      List<? extends IQueryParameterType> nextAnd : nextParamEntry.getValue()) {
        addPredicateQuantity(nextParamName,nextAnd);
        if (doHaveNoResults()) {
          return;
        }
      }
    break;
case REFERENCE:
  for (  List<? extends IQueryParameterType> nextAnd : nextParamEntry.getValue()) {
    addPredicateReference(nextParamName,nextAnd);
    if (doHaveNoResults()) {
      return;
    }
  }
break;
case STRING:
for (List<? extends IQueryParameterType> nextAnd : nextParamEntry.getValue()) {
addPredicateString(nextParamName,nextAnd);
if (doHaveNoResults()) {
  return;
}
}
break;
case TOKEN:
for (List<? extends IQueryParameterType> nextAnd : nextParamEntry.getValue()) {
addPredicateToken(nextParamName,nextAnd);
if (doHaveNoResults()) {
return;
}
}
break;
case NUMBER:
for (List<? extends IQueryParameterType> nextAnd : nextParamEntry.getValue()) {
addPredicateNumber(nextParamName,nextAnd);
if (doHaveNoResults()) {
return;
}
}
break;
case COMPOSITE:
for (List<? extends IQueryParameterType> nextAnd : nextParamEntry.getValue()) {
addPredicateComposite(nextParamDef,nextAnd);
if (doHaveNoResults()) {
return;
}
}
break;
case URI:
for (List<? extends IQueryParameterType> nextAnd : nextParamEntry.getValue()) {
addPredicateUri(nextParamName,nextAnd);
if (doHaveNoResults()) {
return;
}
}
break;
case HAS:
break;
}
}
}
if (doHaveNoResults()) {
return;
}
}
}",0.997833566968268
112251,"private Predicate createCompositeParamPart(CriteriaBuilder builder,Root<ResourceTable> from,RuntimeSearchParam left,IQueryParameterType leftValue){
  Predicate retVal=null;
switch (left.getParamType()) {
case STRING:
{
      From<ResourceIndexedSearchParamString,ResourceIndexedSearchParamString> stringJoin=from.join(""String_Node_Str"",JoinType.INNER);
      retVal=createPredicateString(leftValue,left.getName(),builder,stringJoin);
      break;
    }
case TOKEN:
{
    From<ResourceIndexedSearchParamToken,ResourceIndexedSearchParamToken> tokenJoin=from.join(""String_Node_Str"",JoinType.INNER);
    retVal=createPredicateToken(leftValue,left.getName(),builder,tokenJoin);
    break;
  }
case DATE:
{
  From<ResourceIndexedSearchParamDate,ResourceIndexedSearchParamDate> dateJoin=from.join(""String_Node_Str"",JoinType.INNER);
  retVal=createPredicateDate(builder,dateJoin,leftValue);
  break;
}
case QUANTITY:
{
From<ResourceIndexedSearchParamQuantity,ResourceIndexedSearchParamQuantity> dateJoin=from.join(""String_Node_Str"",JoinType.INNER);
retVal=createPredicateQuantity(builder,dateJoin,leftValue);
break;
}
}
if (retVal == null) {
throw new InvalidRequestException(""String_Node_Str"" + left.getParamType());
}
return retVal;
}","private Predicate createCompositeParamPart(CriteriaBuilder builder,Root<ResourceTable> from,RuntimeSearchParam left,IQueryParameterType leftValue){
  Predicate retVal=null;
switch (left.getParamType()) {
case STRING:
{
      From<ResourceIndexedSearchParamString,ResourceIndexedSearchParamString> stringJoin=from.join(""String_Node_Str"",JoinType.INNER);
      retVal=createPredicateString(leftValue,left.getName(),builder,stringJoin);
      break;
    }
case TOKEN:
{
    From<ResourceIndexedSearchParamToken,ResourceIndexedSearchParamToken> tokenJoin=from.join(""String_Node_Str"",JoinType.INNER);
    retVal=createPredicateToken(leftValue,left.getName(),builder,tokenJoin);
    break;
  }
case DATE:
{
  From<ResourceIndexedSearchParamDate,ResourceIndexedSearchParamDate> dateJoin=from.join(""String_Node_Str"",JoinType.INNER);
  retVal=createPredicateDate(builder,dateJoin,leftValue);
  break;
}
case QUANTITY:
{
From<ResourceIndexedSearchParamQuantity,ResourceIndexedSearchParamQuantity> dateJoin=from.join(""String_Node_Str"",JoinType.INNER);
retVal=createPredicateQuantity(builder,dateJoin,leftValue);
break;
}
case COMPOSITE:
case HAS:
case NUMBER:
case REFERENCE:
case URI:
break;
}
if (retVal == null) {
throw new InvalidRequestException(""String_Node_Str"" + left.getParamType());
}
return retVal;
}",0.971518987341772
112252,"@SuppressWarnings(""String_Node_Str"") private Bundle doTransaction(ServletRequestDetails theRequestDetails,Bundle theRequest,String theActionName){
  BundleType transactionType=theRequest.getTypeElement().getValue();
  if (transactionType == BundleType.BATCH) {
    return batch(theRequestDetails,theRequest);
  }
  if (transactionType == null) {
    String message=""String_Node_Str"" + BundleType.TRANSACTION.toCode();
    ourLog.warn(message);
    transactionType=BundleType.TRANSACTION;
  }
  if (transactionType != BundleType.TRANSACTION) {
    throw new InvalidRequestException(""String_Node_Str"" + transactionType.toCode());
  }
  ourLog.info(""String_Node_Str"",theActionName,theRequest.getEntry().size());
  long start=System.currentTimeMillis();
  Date updateTime=new Date();
  Set<IdType> allIds=new LinkedHashSet<IdType>();
  Map<IdType,IdType> idSubstitutions=new HashMap<IdType,IdType>();
  Map<IdType,DaoMethodOutcome> idToPersistedOutcome=new HashMap<IdType,DaoMethodOutcome>();
  for (int i=0; i < theRequest.getEntry().size(); i++) {
    BundleEntryComponent nextReqEntry=theRequest.getEntry().get(i);
    HTTPVerb verb=nextReqEntry.getRequest().getMethodElement().getValue();
    if (verb == null) {
      throw new InvalidRequestException(getContext().getLocalizer().getMessage(BaseHapiFhirSystemDao.class,""String_Node_Str"",nextReqEntry.getRequest().getMethod(),i));
    }
  }
  Bundle response=new Bundle();
  List<BundleEntryComponent> getEntries=new ArrayList<BundleEntryComponent>();
  IdentityHashMap<BundleEntryComponent,Integer> originalRequestOrder=new IdentityHashMap<Bundle.BundleEntryComponent,Integer>();
  for (int i=0; i < theRequest.getEntry().size(); i++) {
    originalRequestOrder.put(theRequest.getEntry().get(i),i);
    response.addEntry();
    if (theRequest.getEntry().get(i).getRequest().getMethodElement().getValue() == HTTPVerb.GET) {
      getEntries.add(theRequest.getEntry().get(i));
    }
  }
  Collections.sort(theRequest.getEntry(),new TransactionSorter());
  Set<String> deletedResources=new HashSet<String>();
  List<DeleteConflict> deleteConflicts=new ArrayList<DeleteConflict>();
  Map<BundleEntryComponent,ResourceTable> entriesToProcess=new IdentityHashMap<BundleEntryComponent,ResourceTable>();
  Set<ResourceTable> nonUpdatedEntities=new HashSet<ResourceTable>();
  for (int i=0; i < theRequest.getEntry().size(); i++) {
    if (i % 100 == 0) {
      ourLog.info(""String_Node_Str"",i,theRequest.getEntry().size());
    }
    BundleEntryComponent nextReqEntry=theRequest.getEntry().get(i);
    Resource res=nextReqEntry.getResource();
    IdType nextResourceId=null;
    if (res != null) {
      nextResourceId=res.getIdElement();
      if (nextResourceId.hasIdPart() == false) {
        if (isNotBlank(nextReqEntry.getFullUrl())) {
          nextResourceId=new IdType(nextReqEntry.getFullUrl());
        }
      }
      if (nextResourceId.hasIdPart() && nextResourceId.getIdPart().matches(""String_Node_Str"") && !isPlaceholder(nextResourceId)) {
        throw new InvalidRequestException(""String_Node_Str"" + nextResourceId.getIdPart() + ""String_Node_Str"");
      }
      if (nextResourceId.hasIdPart() && !nextResourceId.hasResourceType() && !isPlaceholder(nextResourceId)) {
        nextResourceId=new IdType(toResourceName(res.getClass()),nextResourceId.getIdPart());
        res.setId(nextResourceId);
      }
      if (isPlaceholder(nextResourceId)) {
        if (!allIds.add(nextResourceId)) {
          throw new InvalidRequestException(getContext().getLocalizer().getMessage(BaseHapiFhirSystemDao.class,""String_Node_Str"",nextResourceId));
        }
      }
 else       if (nextResourceId.hasResourceType() && nextResourceId.hasIdPart()) {
        IdType nextId=nextResourceId.toUnqualifiedVersionless();
        if (!allIds.add(nextId)) {
          throw new InvalidRequestException(getContext().getLocalizer().getMessage(BaseHapiFhirSystemDao.class,""String_Node_Str"",nextId));
        }
      }
    }
    HTTPVerb verb=nextReqEntry.getRequest().getMethodElement().getValue();
    String resourceType=res != null ? getContext().getResourceDefinition(res).getName() : null;
    BundleEntryComponent nextRespEntry=response.getEntry().get(originalRequestOrder.get(nextReqEntry));
switch (verb) {
case POST:
{
        @SuppressWarnings(""String_Node_Str"") IFhirResourceDao resourceDao=getDaoOrThrowException(res.getClass());
        res.setId((String)null);
        DaoMethodOutcome outcome;
        String matchUrl=nextReqEntry.getRequest().getIfNoneExist();
        outcome=resourceDao.create(res,matchUrl,false,theRequestDetails);
        if (nextResourceId != null) {
          handleTransactionCreateOrUpdateOutcome(idSubstitutions,idToPersistedOutcome,nextResourceId,outcome,nextRespEntry,resourceType,res);
        }
        entriesToProcess.put(nextRespEntry,outcome.getEntity());
        if (outcome.getCreated() == false) {
          nonUpdatedEntities.add(outcome.getEntity());
        }
        break;
      }
case DELETE:
{
      String url=extractTransactionUrlOrThrowException(nextReqEntry,verb);
      UrlParts parts=UrlUtil.parseUrl(url);
      ca.uhn.fhir.jpa.dao.IFhirResourceDao<? extends IBaseResource> dao=toDao(parts,verb.toCode(),url);
      int status=Constants.STATUS_HTTP_204_NO_CONTENT;
      if (parts.getResourceId() != null) {
        IdType deleteId=new IdType(parts.getResourceType(),parts.getResourceId());
        if (!deletedResources.contains(deleteId.getValueAsString())) {
          DaoMethodOutcome outcome=dao.delete(deleteId,deleteConflicts,theRequestDetails);
          if (outcome.getEntity() != null) {
            deletedResources.add(deleteId.getValueAsString());
            entriesToProcess.put(nextRespEntry,outcome.getEntity());
          }
        }
      }
 else {
        DeleteMethodOutcome deleteOutcome=dao.deleteByUrl(parts.getResourceType() + '?' + parts.getParams(),deleteConflicts,theRequestDetails);
        List<ResourceTable> allDeleted=deleteOutcome.getDeletedEntities();
        for (        ResourceTable deleted : allDeleted) {
          deletedResources.add(deleted.getIdDt().toUnqualifiedVersionless().getValueAsString());
        }
        if (allDeleted.isEmpty()) {
          status=Constants.STATUS_HTTP_204_NO_CONTENT;
        }
        nextRespEntry.getResponse().setOutcome((Resource)deleteOutcome.getOperationOutcome());
      }
      nextRespEntry.getResponse().setStatus(toStatusString(status));
      break;
    }
case PUT:
{
    @SuppressWarnings(""String_Node_Str"") IFhirResourceDao resourceDao=getDaoOrThrowException(res.getClass());
    String url=extractTransactionUrlOrThrowException(nextReqEntry,verb);
    DaoMethodOutcome outcome;
    UrlParts parts=UrlUtil.parseUrl(url);
    if (isNotBlank(parts.getResourceId())) {
      res.setId(new IdType(parts.getResourceType(),parts.getResourceId()));
      outcome=resourceDao.update(res,null,false,theRequestDetails);
    }
 else {
      res.setId((String)null);
      outcome=resourceDao.update(res,parts.getResourceType() + '?' + parts.getParams(),false,theRequestDetails);
    }
    handleTransactionCreateOrUpdateOutcome(idSubstitutions,idToPersistedOutcome,nextResourceId,outcome,nextRespEntry,resourceType,res);
    entriesToProcess.put(nextRespEntry,outcome.getEntity());
    break;
  }
}
}
for (Iterator<DeleteConflict> iter=deleteConflicts.iterator(); iter.hasNext(); ) {
DeleteConflict next=iter.next();
if (deletedResources.contains(next.getTargetId().toUnqualifiedVersionless().getValue())) {
iter.remove();
}
}
validateDeleteConflictsEmptyOrThrowException(deleteConflicts);
FhirTerser terser=getContext().newTerser();
for (DaoMethodOutcome nextOutcome : idToPersistedOutcome.values()) {
IBaseResource nextResource=nextOutcome.getResource();
if (nextResource == null) {
continue;
}
List<IBaseReference> allRefs=terser.getAllPopulatedChildElementsOfType(nextResource,IBaseReference.class);
for (IBaseReference nextRef : allRefs) {
IIdType nextId=nextRef.getReferenceElement();
if (!nextId.hasIdPart()) {
  continue;
}
if (idSubstitutions.containsKey(nextId)) {
  IdType newId=idSubstitutions.get(nextId);
  ourLog.info(""String_Node_Str"",nextId,newId);
  nextRef.setReference(newId.getValue());
}
 else if (nextId.getValue().startsWith(""String_Node_Str"")) {
  throw new InvalidRequestException(""String_Node_Str"" + nextId.getValue());
}
 else {
  ourLog.debug(""String_Node_Str"",nextId);
}
}
IPrimitiveType<Date> deletedInstantOrNull=ResourceMetadataKeyEnum.DELETED_AT.get((IAnyResource)nextResource);
Date deletedTimestampOrNull=deletedInstantOrNull != null ? deletedInstantOrNull.getValue() : null;
boolean shouldUpdate=!nonUpdatedEntities.contains(nextOutcome.getEntity());
if (shouldUpdate) {
updateEntity(nextResource,nextOutcome.getEntity(),deletedTimestampOrNull,shouldUpdate,true,updateTime);
}
}
myEntityManager.flush();
for (BundleEntryComponent nextEntry : theRequest.getEntry()) {
if (nextEntry.getRequest().getMethodElement().getValue() == HTTPVerb.POST) {
String matchUrl=nextEntry.getRequest().getIfNoneExist();
if (isNotBlank(matchUrl)) {
  IFhirResourceDao<?> resourceDao=getDao(nextEntry.getResource().getClass());
  Set<Long> val=resourceDao.processMatchUrl(matchUrl);
  if (val.size() > 1) {
    throw new InvalidRequestException(""String_Node_Str"" + theActionName + ""String_Node_Str""+ matchUrl+ ""String_Node_Str"");
  }
}
}
}
for (IdType next : allIds) {
IdType replacement=idSubstitutions.get(next);
if (replacement == null) {
continue;
}
if (replacement.equals(next)) {
continue;
}
ourLog.info(""String_Node_Str"",next,replacement);
}
for (int i=0; i < getEntries.size(); i++) {
BundleEntryComponent nextReqEntry=getEntries.get(i);
Integer originalOrder=originalRequestOrder.get(nextReqEntry);
BundleEntryComponent nextRespEntry=response.getEntry().get(originalOrder);
ServletSubRequestDetails requestDetails=new ServletSubRequestDetails();
requestDetails.setServletRequest(theRequestDetails.getServletRequest());
requestDetails.setRequestType(RequestTypeEnum.GET);
requestDetails.setServer(theRequestDetails.getServer());
String url=extractTransactionUrlOrThrowException(nextReqEntry,HTTPVerb.GET);
int qIndex=url.indexOf('?');
ArrayListMultimap<String,String> paramValues=ArrayListMultimap.create();
requestDetails.setParameters(new HashMap<String,String[]>());
if (qIndex != -1) {
String params=url.substring(qIndex);
List<NameValuePair> parameters=translateMatchUrl(params);
for (NameValuePair next : parameters) {
  paramValues.put(next.getName(),next.getValue());
}
for (java.util.Map.Entry<String,Collection<String>> nextParamEntry : paramValues.asMap().entrySet()) {
  String[] nextValue=nextParamEntry.getValue().toArray(new String[nextParamEntry.getValue().size()]);
  requestDetails.getParameters().put(nextParamEntry.getKey(),nextValue);
}
url=url.substring(0,qIndex);
}
requestDetails.setRequestPath(url);
requestDetails.setFhirServerBase(theRequestDetails.getFhirServerBase());
theRequestDetails.getServer().populateRequestDetailsFromRequestPath(requestDetails,url);
BaseMethodBinding<?> method=theRequestDetails.getServer().determineResourceMethod(requestDetails,url);
if (method == null) {
throw new IllegalArgumentException(""String_Node_Str"" + url);
}
if (isNotBlank(nextReqEntry.getRequest().getIfMatch())) {
requestDetails.addHeader(Constants.HEADER_IF_MATCH,nextReqEntry.getRequest().getIfMatch());
}
if (isNotBlank(nextReqEntry.getRequest().getIfNoneExist())) {
requestDetails.addHeader(Constants.HEADER_IF_NONE_EXIST,nextReqEntry.getRequest().getIfNoneExist());
}
if (isNotBlank(nextReqEntry.getRequest().getIfNoneMatch())) {
requestDetails.addHeader(Constants.HEADER_IF_NONE_MATCH,nextReqEntry.getRequest().getIfNoneMatch());
}
if (method instanceof BaseResourceReturningMethodBinding) {
try {
  ResourceOrDstu1Bundle responseData=((BaseResourceReturningMethodBinding)method).doInvokeServer(theRequestDetails.getServer(),requestDetails);
  IBaseResource resource=responseData.getResource();
  if (paramValues.containsKey(Constants.PARAM_SUMMARY) || paramValues.containsKey(Constants.PARAM_CONTENT)) {
    resource=filterNestedBundle(requestDetails,resource);
  }
  nextRespEntry.setResource((Resource)resource);
  nextRespEntry.getResponse().setStatus(toStatusString(Constants.STATUS_HTTP_200_OK));
}
 catch (NotModifiedException e) {
  nextRespEntry.getResponse().setStatus(toStatusString(Constants.STATUS_HTTP_304_NOT_MODIFIED));
}
}
 else {
throw new IllegalArgumentException(""String_Node_Str"" + url);
}
}
for (Entry<BundleEntryComponent,ResourceTable> nextEntry : entriesToProcess.entrySet()) {
nextEntry.getKey().getResponse().setLocation(nextEntry.getValue().getIdDt().toUnqualified().getValue());
nextEntry.getKey().getResponse().setEtag(nextEntry.getValue().getIdDt().getVersionIdPart());
}
long delay=System.currentTimeMillis() - start;
ourLog.info(theActionName + ""String_Node_Str"",new Object[]{delay});
response.setType(BundleType.TRANSACTIONRESPONSE);
return response;
}","@SuppressWarnings(""String_Node_Str"") private Bundle doTransaction(ServletRequestDetails theRequestDetails,Bundle theRequest,String theActionName){
  BundleType transactionType=theRequest.getTypeElement().getValue();
  if (transactionType == BundleType.BATCH) {
    return batch(theRequestDetails,theRequest);
  }
  if (transactionType == null) {
    String message=""String_Node_Str"" + BundleType.TRANSACTION.toCode();
    ourLog.warn(message);
    transactionType=BundleType.TRANSACTION;
  }
  if (transactionType != BundleType.TRANSACTION) {
    throw new InvalidRequestException(""String_Node_Str"" + transactionType.toCode());
  }
  ourLog.info(""String_Node_Str"",theActionName,theRequest.getEntry().size());
  long start=System.currentTimeMillis();
  Date updateTime=new Date();
  Set<IdType> allIds=new LinkedHashSet<IdType>();
  Map<IdType,IdType> idSubstitutions=new HashMap<IdType,IdType>();
  Map<IdType,DaoMethodOutcome> idToPersistedOutcome=new HashMap<IdType,DaoMethodOutcome>();
  for (int i=0; i < theRequest.getEntry().size(); i++) {
    BundleEntryComponent nextReqEntry=theRequest.getEntry().get(i);
    HTTPVerb verb=nextReqEntry.getRequest().getMethodElement().getValue();
    if (verb == null) {
      throw new InvalidRequestException(getContext().getLocalizer().getMessage(BaseHapiFhirSystemDao.class,""String_Node_Str"",nextReqEntry.getRequest().getMethod(),i));
    }
  }
  Bundle response=new Bundle();
  List<BundleEntryComponent> getEntries=new ArrayList<BundleEntryComponent>();
  IdentityHashMap<BundleEntryComponent,Integer> originalRequestOrder=new IdentityHashMap<Bundle.BundleEntryComponent,Integer>();
  for (int i=0; i < theRequest.getEntry().size(); i++) {
    originalRequestOrder.put(theRequest.getEntry().get(i),i);
    response.addEntry();
    if (theRequest.getEntry().get(i).getRequest().getMethodElement().getValue() == HTTPVerb.GET) {
      getEntries.add(theRequest.getEntry().get(i));
    }
  }
  Collections.sort(theRequest.getEntry(),new TransactionSorter());
  Set<String> deletedResources=new HashSet<String>();
  List<DeleteConflict> deleteConflicts=new ArrayList<DeleteConflict>();
  Map<BundleEntryComponent,ResourceTable> entriesToProcess=new IdentityHashMap<BundleEntryComponent,ResourceTable>();
  Set<ResourceTable> nonUpdatedEntities=new HashSet<ResourceTable>();
  for (int i=0; i < theRequest.getEntry().size(); i++) {
    if (i % 100 == 0) {
      ourLog.info(""String_Node_Str"",i,theRequest.getEntry().size());
    }
    BundleEntryComponent nextReqEntry=theRequest.getEntry().get(i);
    Resource res=nextReqEntry.getResource();
    IdType nextResourceId=null;
    if (res != null) {
      nextResourceId=res.getIdElement();
      if (nextResourceId.hasIdPart() == false) {
        if (isNotBlank(nextReqEntry.getFullUrl())) {
          nextResourceId=new IdType(nextReqEntry.getFullUrl());
        }
      }
      if (nextResourceId.hasIdPart() && nextResourceId.getIdPart().matches(""String_Node_Str"") && !isPlaceholder(nextResourceId)) {
        throw new InvalidRequestException(""String_Node_Str"" + nextResourceId.getIdPart() + ""String_Node_Str"");
      }
      if (nextResourceId.hasIdPart() && !nextResourceId.hasResourceType() && !isPlaceholder(nextResourceId)) {
        nextResourceId=new IdType(toResourceName(res.getClass()),nextResourceId.getIdPart());
        res.setId(nextResourceId);
      }
      if (isPlaceholder(nextResourceId)) {
        if (!allIds.add(nextResourceId)) {
          throw new InvalidRequestException(getContext().getLocalizer().getMessage(BaseHapiFhirSystemDao.class,""String_Node_Str"",nextResourceId));
        }
      }
 else       if (nextResourceId.hasResourceType() && nextResourceId.hasIdPart()) {
        IdType nextId=nextResourceId.toUnqualifiedVersionless();
        if (!allIds.add(nextId)) {
          throw new InvalidRequestException(getContext().getLocalizer().getMessage(BaseHapiFhirSystemDao.class,""String_Node_Str"",nextId));
        }
      }
    }
    HTTPVerb verb=nextReqEntry.getRequest().getMethodElement().getValue();
    String resourceType=res != null ? getContext().getResourceDefinition(res).getName() : null;
    BundleEntryComponent nextRespEntry=response.getEntry().get(originalRequestOrder.get(nextReqEntry));
switch (verb) {
case POST:
{
        @SuppressWarnings(""String_Node_Str"") IFhirResourceDao resourceDao=getDaoOrThrowException(res.getClass());
        res.setId((String)null);
        DaoMethodOutcome outcome;
        String matchUrl=nextReqEntry.getRequest().getIfNoneExist();
        outcome=resourceDao.create(res,matchUrl,false,theRequestDetails);
        if (nextResourceId != null) {
          handleTransactionCreateOrUpdateOutcome(idSubstitutions,idToPersistedOutcome,nextResourceId,outcome,nextRespEntry,resourceType,res);
        }
        entriesToProcess.put(nextRespEntry,outcome.getEntity());
        if (outcome.getCreated() == false) {
          nonUpdatedEntities.add(outcome.getEntity());
        }
        break;
      }
case DELETE:
{
      String url=extractTransactionUrlOrThrowException(nextReqEntry,verb);
      UrlParts parts=UrlUtil.parseUrl(url);
      ca.uhn.fhir.jpa.dao.IFhirResourceDao<? extends IBaseResource> dao=toDao(parts,verb.toCode(),url);
      int status=Constants.STATUS_HTTP_204_NO_CONTENT;
      if (parts.getResourceId() != null) {
        IdType deleteId=new IdType(parts.getResourceType(),parts.getResourceId());
        if (!deletedResources.contains(deleteId.getValueAsString())) {
          DaoMethodOutcome outcome=dao.delete(deleteId,deleteConflicts,theRequestDetails);
          if (outcome.getEntity() != null) {
            deletedResources.add(deleteId.getValueAsString());
            entriesToProcess.put(nextRespEntry,outcome.getEntity());
          }
        }
      }
 else {
        DeleteMethodOutcome deleteOutcome=dao.deleteByUrl(parts.getResourceType() + '?' + parts.getParams(),deleteConflicts,theRequestDetails);
        List<ResourceTable> allDeleted=deleteOutcome.getDeletedEntities();
        for (        ResourceTable deleted : allDeleted) {
          deletedResources.add(deleted.getIdDt().toUnqualifiedVersionless().getValueAsString());
        }
        if (allDeleted.isEmpty()) {
          status=Constants.STATUS_HTTP_204_NO_CONTENT;
        }
        nextRespEntry.getResponse().setOutcome((Resource)deleteOutcome.getOperationOutcome());
      }
      nextRespEntry.getResponse().setStatus(toStatusString(status));
      break;
    }
case PUT:
{
    @SuppressWarnings(""String_Node_Str"") IFhirResourceDao resourceDao=getDaoOrThrowException(res.getClass());
    String url=extractTransactionUrlOrThrowException(nextReqEntry,verb);
    DaoMethodOutcome outcome;
    UrlParts parts=UrlUtil.parseUrl(url);
    if (isNotBlank(parts.getResourceId())) {
      res.setId(new IdType(parts.getResourceType(),parts.getResourceId()));
      outcome=resourceDao.update(res,null,false,theRequestDetails);
    }
 else {
      res.setId((String)null);
      outcome=resourceDao.update(res,parts.getResourceType() + '?' + parts.getParams(),false,theRequestDetails);
    }
    handleTransactionCreateOrUpdateOutcome(idSubstitutions,idToPersistedOutcome,nextResourceId,outcome,nextRespEntry,resourceType,res);
    entriesToProcess.put(nextRespEntry,outcome.getEntity());
    break;
  }
case GET:
case NULL:
break;
}
}
for (Iterator<DeleteConflict> iter=deleteConflicts.iterator(); iter.hasNext(); ) {
DeleteConflict next=iter.next();
if (deletedResources.contains(next.getTargetId().toUnqualifiedVersionless().getValue())) {
iter.remove();
}
}
validateDeleteConflictsEmptyOrThrowException(deleteConflicts);
FhirTerser terser=getContext().newTerser();
for (DaoMethodOutcome nextOutcome : idToPersistedOutcome.values()) {
IBaseResource nextResource=nextOutcome.getResource();
if (nextResource == null) {
continue;
}
List<IBaseReference> allRefs=terser.getAllPopulatedChildElementsOfType(nextResource,IBaseReference.class);
for (IBaseReference nextRef : allRefs) {
IIdType nextId=nextRef.getReferenceElement();
if (!nextId.hasIdPart()) {
continue;
}
if (idSubstitutions.containsKey(nextId)) {
IdType newId=idSubstitutions.get(nextId);
ourLog.info(""String_Node_Str"",nextId,newId);
nextRef.setReference(newId.getValue());
}
 else if (nextId.getValue().startsWith(""String_Node_Str"")) {
throw new InvalidRequestException(""String_Node_Str"" + nextId.getValue());
}
 else {
ourLog.debug(""String_Node_Str"",nextId);
}
}
IPrimitiveType<Date> deletedInstantOrNull=ResourceMetadataKeyEnum.DELETED_AT.get((IAnyResource)nextResource);
Date deletedTimestampOrNull=deletedInstantOrNull != null ? deletedInstantOrNull.getValue() : null;
boolean shouldUpdate=!nonUpdatedEntities.contains(nextOutcome.getEntity());
if (shouldUpdate) {
updateEntity(nextResource,nextOutcome.getEntity(),deletedTimestampOrNull,shouldUpdate,true,updateTime);
}
}
myEntityManager.flush();
for (BundleEntryComponent nextEntry : theRequest.getEntry()) {
if (nextEntry.getRequest().getMethodElement().getValue() == HTTPVerb.POST) {
String matchUrl=nextEntry.getRequest().getIfNoneExist();
if (isNotBlank(matchUrl)) {
IFhirResourceDao<?> resourceDao=getDao(nextEntry.getResource().getClass());
Set<Long> val=resourceDao.processMatchUrl(matchUrl);
if (val.size() > 1) {
  throw new InvalidRequestException(""String_Node_Str"" + theActionName + ""String_Node_Str""+ matchUrl+ ""String_Node_Str"");
}
}
}
}
for (IdType next : allIds) {
IdType replacement=idSubstitutions.get(next);
if (replacement == null) {
continue;
}
if (replacement.equals(next)) {
continue;
}
ourLog.info(""String_Node_Str"",next,replacement);
}
for (int i=0; i < getEntries.size(); i++) {
BundleEntryComponent nextReqEntry=getEntries.get(i);
Integer originalOrder=originalRequestOrder.get(nextReqEntry);
BundleEntryComponent nextRespEntry=response.getEntry().get(originalOrder);
ServletSubRequestDetails requestDetails=new ServletSubRequestDetails();
requestDetails.setServletRequest(theRequestDetails.getServletRequest());
requestDetails.setRequestType(RequestTypeEnum.GET);
requestDetails.setServer(theRequestDetails.getServer());
String url=extractTransactionUrlOrThrowException(nextReqEntry,HTTPVerb.GET);
int qIndex=url.indexOf('?');
ArrayListMultimap<String,String> paramValues=ArrayListMultimap.create();
requestDetails.setParameters(new HashMap<String,String[]>());
if (qIndex != -1) {
String params=url.substring(qIndex);
List<NameValuePair> parameters=translateMatchUrl(params);
for (NameValuePair next : parameters) {
paramValues.put(next.getName(),next.getValue());
}
for (java.util.Map.Entry<String,Collection<String>> nextParamEntry : paramValues.asMap().entrySet()) {
String[] nextValue=nextParamEntry.getValue().toArray(new String[nextParamEntry.getValue().size()]);
requestDetails.getParameters().put(nextParamEntry.getKey(),nextValue);
}
url=url.substring(0,qIndex);
}
requestDetails.setRequestPath(url);
requestDetails.setFhirServerBase(theRequestDetails.getFhirServerBase());
theRequestDetails.getServer().populateRequestDetailsFromRequestPath(requestDetails,url);
BaseMethodBinding<?> method=theRequestDetails.getServer().determineResourceMethod(requestDetails,url);
if (method == null) {
throw new IllegalArgumentException(""String_Node_Str"" + url);
}
if (isNotBlank(nextReqEntry.getRequest().getIfMatch())) {
requestDetails.addHeader(Constants.HEADER_IF_MATCH,nextReqEntry.getRequest().getIfMatch());
}
if (isNotBlank(nextReqEntry.getRequest().getIfNoneExist())) {
requestDetails.addHeader(Constants.HEADER_IF_NONE_EXIST,nextReqEntry.getRequest().getIfNoneExist());
}
if (isNotBlank(nextReqEntry.getRequest().getIfNoneMatch())) {
requestDetails.addHeader(Constants.HEADER_IF_NONE_MATCH,nextReqEntry.getRequest().getIfNoneMatch());
}
if (method instanceof BaseResourceReturningMethodBinding) {
try {
ResourceOrDstu1Bundle responseData=((BaseResourceReturningMethodBinding)method).doInvokeServer(theRequestDetails.getServer(),requestDetails);
IBaseResource resource=responseData.getResource();
if (paramValues.containsKey(Constants.PARAM_SUMMARY) || paramValues.containsKey(Constants.PARAM_CONTENT)) {
  resource=filterNestedBundle(requestDetails,resource);
}
nextRespEntry.setResource((Resource)resource);
nextRespEntry.getResponse().setStatus(toStatusString(Constants.STATUS_HTTP_200_OK));
}
 catch (NotModifiedException e) {
nextRespEntry.getResponse().setStatus(toStatusString(Constants.STATUS_HTTP_304_NOT_MODIFIED));
}
}
 else {
throw new IllegalArgumentException(""String_Node_Str"" + url);
}
}
for (Entry<BundleEntryComponent,ResourceTable> nextEntry : entriesToProcess.entrySet()) {
nextEntry.getKey().getResponse().setLocation(nextEntry.getValue().getIdDt().toUnqualified().getValue());
nextEntry.getKey().getResponse().setEtag(nextEntry.getValue().getIdDt().getVersionIdPart());
}
long delay=System.currentTimeMillis() - start;
ourLog.info(theActionName + ""String_Node_Str"",new Object[]{delay});
response.setType(BundleType.TRANSACTIONRESPONSE);
return response;
}",0.9935708752904724
112253,"private IBaseResource loadAndAddConf(HttpServletRequest theServletRequest,final HomeRequest theRequest,final ModelMap theModel){
switch (theRequest.getFhirVersion(myConfig)) {
case DSTU1:
    return loadAndAddConfDstu1(theServletRequest,theRequest,theModel);
case DSTU2:
  return loadAndAddConfDstu2(theServletRequest,theRequest,theModel);
case DSTU3:
return loadAndAddConfDstu3(theServletRequest,theRequest,theModel);
}
throw new IllegalStateException(""String_Node_Str"" + theRequest.getFhirVersion(myConfig));
}","private IBaseResource loadAndAddConf(HttpServletRequest theServletRequest,final HomeRequest theRequest,final ModelMap theModel){
switch (theRequest.getFhirVersion(myConfig)) {
case DSTU1:
    return loadAndAddConfDstu1(theServletRequest,theRequest,theModel);
case DSTU2:
  return loadAndAddConfDstu2(theServletRequest,theRequest,theModel);
case DSTU3:
return loadAndAddConfDstu3(theServletRequest,theRequest,theModel);
case DSTU2_1:
case DSTU2_HL7ORG:
break;
}
throw new IllegalStateException(""String_Node_Str"" + theRequest.getFhirVersion(myConfig));
}",0.962406015037594
112254,"private String format(String theResultBody,EncodingEnum theEncodingEnum){
  String str=StringEscapeUtils.escapeHtml4(theResultBody);
  if (str == null || theEncodingEnum == null) {
    return str;
  }
  StringBuilder b=new StringBuilder();
  if (theEncodingEnum == EncodingEnum.JSON) {
    boolean inValue=false;
    boolean inQuote=false;
    for (int i=0; i < str.length(); i++) {
      char prevChar=(i > 0) ? str.charAt(i - 1) : ' ';
      char nextChar=str.charAt(i);
      char nextChar2=(i + 1) < str.length() ? str.charAt(i + 1) : ' ';
      char nextChar3=(i + 2) < str.length() ? str.charAt(i + 2) : ' ';
      char nextChar4=(i + 3) < str.length() ? str.charAt(i + 3) : ' ';
      char nextChar5=(i + 4) < str.length() ? str.charAt(i + 4) : ' ';
      char nextChar6=(i + 5) < str.length() ? str.charAt(i + 5) : ' ';
      if (inQuote) {
        b.append(nextChar);
        if (prevChar != '\\' && nextChar == '&' && nextChar2 == 'q' && nextChar3 == 'u' && nextChar4 == 'o' && nextChar5 == 't' && nextChar6 == ';') {
          b.append(""String_Node_Str"");
          i+=5;
          inQuote=false;
        }
 else         if (nextChar == '\\' && nextChar2 == '""') {
          b.append(""String_Node_Str"");
          i+=5;
          inQuote=false;
        }
      }
 else {
        if (nextChar == ':') {
          inValue=true;
          b.append(nextChar);
        }
 else         if (nextChar == '[' || nextChar == '{') {
          b.append(""String_Node_Str"");
          b.append(nextChar);
          b.append(""String_Node_Str"");
          inValue=false;
        }
 else         if (nextChar == '}' || nextChar == '}' || nextChar == ',') {
          b.append(""String_Node_Str"");
          b.append(nextChar);
          b.append(""String_Node_Str"");
          inValue=false;
        }
 else         if (nextChar == '&' && nextChar2 == 'q' && nextChar3 == 'u' && nextChar4 == 'o' && nextChar5 == 't' && nextChar6 == ';') {
          if (inValue) {
            b.append(""String_Node_Str"");
          }
 else {
            b.append(""String_Node_Str"");
          }
          inQuote=true;
          i+=5;
        }
 else         if (nextChar == ':') {
          b.append(""String_Node_Str"");
          b.append(nextChar);
          b.append(""String_Node_Str"");
          inValue=true;
        }
 else {
          b.append(nextChar);
        }
      }
    }
  }
 else {
    boolean inQuote=false;
    boolean inTag=false;
    for (int i=0; i < str.length(); i++) {
      char nextChar=str.charAt(i);
      char nextChar2=(i + 1) < str.length() ? str.charAt(i + 1) : ' ';
      char nextChar3=(i + 2) < str.length() ? str.charAt(i + 2) : ' ';
      char nextChar4=(i + 3) < str.length() ? str.charAt(i + 3) : ' ';
      char nextChar5=(i + 4) < str.length() ? str.charAt(i + 4) : ' ';
      char nextChar6=(i + 5) < str.length() ? str.charAt(i + 5) : ' ';
      if (inQuote) {
        b.append(nextChar);
        if (nextChar == '&' && nextChar2 == 'q' && nextChar3 == 'u' && nextChar4 == 'o' && nextChar5 == 't' && nextChar6 == ';') {
          b.append(""String_Node_Str"");
          i+=5;
          inQuote=false;
        }
      }
 else       if (inTag) {
        if (nextChar == '&' && nextChar2 == 'g' && nextChar3 == 't' && nextChar4 == ';') {
          b.append(""String_Node_Str"");
          inTag=false;
          i+=3;
        }
 else         if (nextChar == ' ') {
          b.append(""String_Node_Str"");
          b.append(nextChar);
        }
 else         if (nextChar == '&' && nextChar2 == 'q' && nextChar3 == 'u' && nextChar4 == 'o' && nextChar5 == 't' && nextChar6 == ';') {
          b.append(""String_Node_Str"");
          inQuote=true;
          i+=5;
        }
 else {
          b.append(nextChar);
        }
      }
 else {
        if (nextChar == '&' && nextChar2 == 'l' && nextChar3 == 't' && nextChar4 == ';') {
          b.append(""String_Node_Str"");
          inTag=true;
          i+=3;
        }
 else {
          b.append(nextChar);
        }
      }
    }
  }
  return b.toString();
}","private String format(String theResultBody,EncodingEnum theEncodingEnum){
  String str=StringEscapeUtils.escapeHtml4(theResultBody);
  if (str == null || theEncodingEnum == null) {
    return str;
  }
  StringBuilder b=new StringBuilder();
  if (theEncodingEnum == EncodingEnum.JSON) {
    boolean inValue=false;
    boolean inQuote=false;
    for (int i=0; i < str.length(); i++) {
      char prevChar=(i > 0) ? str.charAt(i - 1) : ' ';
      char nextChar=str.charAt(i);
      char nextChar2=(i + 1) < str.length() ? str.charAt(i + 1) : ' ';
      char nextChar3=(i + 2) < str.length() ? str.charAt(i + 2) : ' ';
      char nextChar4=(i + 3) < str.length() ? str.charAt(i + 3) : ' ';
      char nextChar5=(i + 4) < str.length() ? str.charAt(i + 4) : ' ';
      char nextChar6=(i + 5) < str.length() ? str.charAt(i + 5) : ' ';
      if (inQuote) {
        b.append(nextChar);
        if (prevChar != '\\' && nextChar == '&' && nextChar2 == 'q' && nextChar3 == 'u' && nextChar4 == 'o' && nextChar5 == 't' && nextChar6 == ';') {
          b.append(""String_Node_Str"");
          i+=5;
          inQuote=false;
        }
 else         if (nextChar == '\\' && nextChar2 == '""') {
          b.append(""String_Node_Str"");
          i+=5;
          inQuote=false;
        }
      }
 else {
        if (nextChar == ':') {
          inValue=true;
          b.append(nextChar);
        }
 else         if (nextChar == '[' || nextChar == '{') {
          b.append(""String_Node_Str"");
          b.append(nextChar);
          b.append(""String_Node_Str"");
          inValue=false;
        }
 else         if (nextChar == '{' || nextChar == '}' || nextChar == ',') {
          b.append(""String_Node_Str"");
          b.append(nextChar);
          b.append(""String_Node_Str"");
          inValue=false;
        }
 else         if (nextChar == '&' && nextChar2 == 'q' && nextChar3 == 'u' && nextChar4 == 'o' && nextChar5 == 't' && nextChar6 == ';') {
          if (inValue) {
            b.append(""String_Node_Str"");
          }
 else {
            b.append(""String_Node_Str"");
          }
          inQuote=true;
          i+=5;
        }
 else         if (nextChar == ':') {
          b.append(""String_Node_Str"");
          b.append(nextChar);
          b.append(""String_Node_Str"");
          inValue=true;
        }
 else {
          b.append(nextChar);
        }
      }
    }
  }
 else {
    boolean inQuote=false;
    boolean inTag=false;
    for (int i=0; i < str.length(); i++) {
      char nextChar=str.charAt(i);
      char nextChar2=(i + 1) < str.length() ? str.charAt(i + 1) : ' ';
      char nextChar3=(i + 2) < str.length() ? str.charAt(i + 2) : ' ';
      char nextChar4=(i + 3) < str.length() ? str.charAt(i + 3) : ' ';
      char nextChar5=(i + 4) < str.length() ? str.charAt(i + 4) : ' ';
      char nextChar6=(i + 5) < str.length() ? str.charAt(i + 5) : ' ';
      if (inQuote) {
        b.append(nextChar);
        if (nextChar == '&' && nextChar2 == 'q' && nextChar3 == 'u' && nextChar4 == 'o' && nextChar5 == 't' && nextChar6 == ';') {
          b.append(""String_Node_Str"");
          i+=5;
          inQuote=false;
        }
      }
 else       if (inTag) {
        if (nextChar == '&' && nextChar2 == 'g' && nextChar3 == 't' && nextChar4 == ';') {
          b.append(""String_Node_Str"");
          inTag=false;
          i+=3;
        }
 else         if (nextChar == ' ') {
          b.append(""String_Node_Str"");
          b.append(nextChar);
        }
 else         if (nextChar == '&' && nextChar2 == 'q' && nextChar3 == 'u' && nextChar4 == 'o' && nextChar5 == 't' && nextChar6 == ';') {
          b.append(""String_Node_Str"");
          inQuote=true;
          i+=5;
        }
 else {
          b.append(nextChar);
        }
      }
 else {
        if (nextChar == '&' && nextChar2 == 'l' && nextChar3 == 't' && nextChar4 == ';') {
          b.append(""String_Node_Str"");
          inTag=true;
          i+=3;
        }
 else {
          b.append(nextChar);
        }
      }
    }
  }
  return b.toString();
}",0.9997508719481814
112255,"protected StructureDefinition getDefinition(int line,int col,String name) throws FHIRFormatError {
  if (name == null) {
    logError(line,col,name,IssueType.STRUCTURE,""String_Node_Str"",IssueSeverity.FATAL);
    return null;
  }
  for (  StructureDefinition sd : context.allStructures()) {
    if (name.equals(sd.getId())) {
      return sd;
    }
  }
  logError(line,col,name,IssueType.STRUCTURE,""String_Node_Str"" + name + ""String_Node_Str"",IssueSeverity.FATAL);
  return null;
}","protected StructureDefinition getDefinition(int line,int col,String name) throws FHIRFormatError {
  if (name == null) {
    logError(line,col,name,IssueType.STRUCTURE,""String_Node_Str"",IssueSeverity.FATAL);
    return null;
  }
  for (  StructureDefinition sd : context.allStructures()) {
    if (name.equals(sd.getIdElement().getIdPart())) {
      return sd;
    }
  }
  logError(line,col,name,IssueType.STRUCTURE,""String_Node_Str"" + name + ""String_Node_Str"",IssueSeverity.FATAL);
  return null;
}",0.9805924412665986
112256,"/** 
 * Search for Patient resources matching a given family name
 */
@Search public IBundleProvider search(@RequiredParam(name=Patient.SP_FAMILY) StringParam theFamily){
  final InstantDt searchTime=InstantDt.withCurrentTime();
  final List<Long> matchingResourceIds=null;
  return new IBundleProvider(){
    @Override public int size(){
      return matchingResourceIds.size();
    }
    @Override public List<IBaseResource> getResources(    int theFromIndex,    int theToIndex){
      int end=Math.max(theToIndex,matchingResourceIds.size() - 1);
      List<Long> idsToReturn=matchingResourceIds.subList(theFromIndex,end);
      return loadResourcesByIds(idsToReturn);
    }
    @Override public InstantDt getPublished(){
      return searchTime;
    }
    @Override public Integer preferredPageSize(){
      return null;
    }
  }
;
}","/** 
 * Search for Patient resources matching a given family name
 */
@Search public IBundleProvider search(@RequiredParam(name=Patient.SP_FAMILY) StringParam theFamily){
  final InstantDt searchTime=InstantDt.withCurrentTime();
  final List<Long> matchingResourceIds=null;
  return new IBundleProvider(){
    @Override public int size(){
      return matchingResourceIds.size();
    }
    @Override public List<IBaseResource> getResources(    int theFromIndex,    int theToIndex){
      int end=Math.max(theToIndex,matchingResourceIds.size() - 1);
      List<Long> idsToReturn=matchingResourceIds.subList(theFromIndex,end);
      return loadResourcesByIds(idsToReturn);
    }
    @Override public InstantDt getPublished(){
      return searchTime;
    }
    @Override public Integer preferredPageSize(){
      return null;
    }
    @Override public String getUuid(){
      return null;
    }
  }
;
}",0.9631760644418872
112257,"@Override public InstantDt getPublished(){
  return resources.getPublished();
}","@Override public IPrimitiveType<Date> getPublished(){
  return resources.getPublished();
}",0.8757396449704142
112258,"@Override public IBundleProvider invokeServer(IRestfulServer<?> theServer,RequestDetails theRequest,Object[] theMethodParams) throws InvalidRequestException, InternalErrorException {
  if (myIdParamIndex != null) {
    theMethodParams[myIdParamIndex]=theRequest.getId();
  }
  Object response=invokeServerMethod(theServer,theRequest,theMethodParams);
  final IBundleProvider resources=toResourceList(response);
  return new IBundleProvider(){
    @Override public InstantDt getPublished(){
      return resources.getPublished();
    }
    @Override public List<IBaseResource> getResources(    int theFromIndex,    int theToIndex){
      List<IBaseResource> retVal=resources.getResources(theFromIndex,theToIndex);
      int index=theFromIndex;
      for (      IBaseResource nextResource : retVal) {
        if (nextResource.getIdElement() == null || isBlank(nextResource.getIdElement().getIdPart())) {
          throw new InternalErrorException(""String_Node_Str"" + index + ""String_Node_Str"");
        }
        if (isBlank(nextResource.getIdElement().getVersionIdPart()) && nextResource instanceof IResource) {
          IdDt versionId=(IdDt)ResourceMetadataKeyEnum.VERSION_ID.get((IResource)nextResource);
          if (versionId == null || versionId.isEmpty()) {
            throw new InternalErrorException(""String_Node_Str"" + index + ""String_Node_Str"");
          }
        }
        index++;
      }
      return retVal;
    }
    @Override public int size(){
      return resources.size();
    }
    @Override public Integer preferredPageSize(){
      return resources.preferredPageSize();
    }
    @Override public String getUuid(){
      return resources.getUuid();
    }
  }
;
}","@Override public IBundleProvider invokeServer(IRestfulServer<?> theServer,RequestDetails theRequest,Object[] theMethodParams) throws InvalidRequestException, InternalErrorException {
  if (myIdParamIndex != null) {
    theMethodParams[myIdParamIndex]=theRequest.getId();
  }
  Object response=invokeServerMethod(theServer,theRequest,theMethodParams);
  final IBundleProvider resources=toResourceList(response);
  return new IBundleProvider(){
    @Override public IPrimitiveType<Date> getPublished(){
      return resources.getPublished();
    }
    @Override public List<IBaseResource> getResources(    int theFromIndex,    int theToIndex){
      List<IBaseResource> retVal=resources.getResources(theFromIndex,theToIndex);
      int index=theFromIndex;
      for (      IBaseResource nextResource : retVal) {
        if (nextResource.getIdElement() == null || isBlank(nextResource.getIdElement().getIdPart())) {
          throw new InternalErrorException(""String_Node_Str"" + index + ""String_Node_Str"");
        }
        if (isBlank(nextResource.getIdElement().getVersionIdPart()) && nextResource instanceof IResource) {
          IdDt versionId=(IdDt)ResourceMetadataKeyEnum.VERSION_ID.get((IResource)nextResource);
          if (versionId == null || versionId.isEmpty()) {
            throw new InternalErrorException(""String_Node_Str"" + index + ""String_Node_Str"");
          }
        }
        index++;
      }
      return retVal;
    }
    @Override public int size(){
      return resources.size();
    }
    @Override public Integer preferredPageSize(){
      return resources.preferredPageSize();
    }
    @Override public String getUuid(){
      return resources.getUuid();
    }
  }
;
}",0.9926188367286684
112259,"/** 
 * Load the given collection of resources by index, plus any additional resources per the server's processing rules (e.g. _include'd resources, OperationOutcome, etc.). For example, if the method is invoked with index 0,10 the method might return 10 search results, plus an  additional 20 resources which matched a client's _include specification.
 * @param theFromIndex The low index (inclusive) to return
 * @param theToIndex The high index (exclusive) to return
 * @return A list of resources. The size of this list must be at least <code>theToIndex - theFromIndex</code>.
 */
List<IBaseResource> getResources(int theFromIndex,int theToIndex);","/** 
 * Load the given collection of resources by index, plus any additional resources per the server's processing rules (e.g. _include'd resources, OperationOutcome, etc.). For example, if the method is invoked with index 0,10 the method might return 10 search results, plus an additional 20 resources which matched a client's _include specification.
 * @param theFromIndex The low index (inclusive) to return
 * @param theToIndex The high index (exclusive) to return
 * @return A list of resources. The size of this list must be at least <code>theToIndex - theFromIndex</code>.
 */
List<IBaseResource> getResources(int theFromIndex,int theToIndex);",0.9992313604919292
112260,"/** 
 * Returns the UUID associated with this search. Note that this does not need to return a non-null value unless it a  {@link IPagingProvider} is being used that requires UUIDsbeing returned. <p> Otherwise you may simply return  {@code null}</p>
 */
public String getUuid();","/** 
 * Returns the UUID associated with this search. Note that this does not need to return a non-null value unless it a  {@link IPagingProvider} is being used that requires UUIDsbeing returned. <p> In other words, if you are using the default  {@link FifoMemoryPagingProvider} inyour server, it is fine for this method to simply return  {@code null} since {@link FifoMemoryPagingProvider}does not use the value anyhow. On the other hand, if you are creating a custom [@code IPagingProvider} implementation you might use this method to communicate the search ID back to the provider. </p>
 */
public String getUuid();",0.5334821428571429
112261,"/** 
 * Returns the instant as of which this result was valid
 */
InstantDt getPublished();","/** 
 * Returns the instant as of which this result was valid
 */
IPrimitiveType<Date> getPublished();",0.8911917098445595
112262,"@Search(queryName=""String_Node_Str"") public IBundleProvider searchWithBundleProvider(){
  return new IBundleProvider(){
    @Override public InstantDt getPublished(){
      return ourReturnPublished;
    }
    @Override public List<IBaseResource> getResources(    int theFromIndex,    int theToIndex){
      throw new IllegalStateException();
    }
    @Override public Integer preferredPageSize(){
      return null;
    }
    @Override public int size(){
      return 0;
    }
  }
;
}","@Search(queryName=""String_Node_Str"") public IBundleProvider searchWithBundleProvider(){
  return new IBundleProvider(){
    @Override public InstantDt getPublished(){
      return ourReturnPublished;
    }
    @Override public List<IBaseResource> getResources(    int theFromIndex,    int theToIndex){
      throw new IllegalStateException();
    }
    @Override public Integer preferredPageSize(){
      return null;
    }
    @Override public int size(){
      return 0;
    }
    @Override public String getUuid(){
      return null;
    }
  }
;
}",0.9324324324324323
112263,"@SuppressWarnings({""String_Node_Str""}) public static void main(String[] args) throws Exception {
{
    int myPort=8888;
    Server server=new Server(myPort);
    WebAppContext root=new WebAppContext();
    root.setContextPath(""String_Node_Str"");
    root.setDescriptor(""String_Node_Str"");
    root.setResourceBase(""String_Node_Str"");
    root.setParentLoaderPriority(true);
    server.setHandler(root);
    server.start();
  }
  if (true) {
    return;
  }
  ourAppCtx=new AnnotationConfigApplicationContext(FhirServerConfig.class);
  ServletContextHandler proxyHandler=new ServletContextHandler();
  proxyHandler.setContextPath(""String_Node_Str"");
  RestfulServer restServerDstu2=new RestfulServer();
  restServerDstu2.setPagingProvider(new FifoMemoryPagingProvider(10));
  restServerDstu2.setImplementationDescription(""String_Node_Str"");
  restServerDstu2.setFhirContext(ourAppCtx.getBean(""String_Node_Str"",FhirContext.class));
  List<IResourceProvider> rpsDev=(List<IResourceProvider>)ourAppCtx.getBean(""String_Node_Str"",List.class);
  restServerDstu2.setResourceProviders(rpsDev);
  JpaSystemProviderDstu2 systemProvDev=(JpaSystemProviderDstu2)ourAppCtx.getBean(""String_Node_Str"",JpaSystemProviderDstu2.class);
  restServerDstu2.setPlainProviders(systemProvDev);
  ServletHolder servletHolder=new ServletHolder();
  servletHolder.setServlet(restServerDstu2);
  proxyHandler.addServlet(servletHolder,""String_Node_Str"");
  int port=8887;
  Server server=new Server(port);
  server.setHandler(proxyHandler);
  server.start();
  if (true) {
    String base=""String_Node_Str"" + port + ""String_Node_Str"";
    IGenericClient client=restServerDstu2.getFhirContext().newRestfulGenericClient(base);
    client.setLogRequestAndResponse(true);
    Organization o1=new Organization();
    o1.getName().setValue(""String_Node_Str"");
    MethodOutcome create=client.create().resource(o1).execute();
    IdDt orgId=(IdDt)create.getId();
    Patient p1=new Patient();
    p1.getText().getDiv().setValueAsString(""String_Node_Str"");
    p1.addIdentifier(""String_Node_Str"",""String_Node_Str"");
    p1.addName().addFamily(""String_Node_Str"").addGiven(""String_Node_Str"");
    p1.getManagingOrganization().setReference(orgId);
    TagList list=new TagList();
    list.addTag(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    ResourceMetadataKeyEnum.TAG_LIST.put(p1,list);
    client.create().resource(p1).execute();
    client.create().resource(p1).execute();
    client.create().resource(p1).execute();
    client.create().resource(p1).execute();
    client.create().resource(p1).execute();
    client.create().resource(p1).execute();
    client.create().resource(p1).execute();
    client.create().resource(p1).execute();
    client.create().resource(p1).execute();
    client.create().resource(p1).execute();
    client.create().resource(p1).execute();
    client.create().resource(p1).execute();
    client.create().resource(p1).execute();
    client.create().resource(p1).execute();
    client.create().resource(p1).execute();
    client.setLogRequestAndResponse(true);
    client.create().resource(p1).execute();
  }
}","@SuppressWarnings({""String_Node_Str""}) public static void main(String[] args) throws Exception {
{
    int myPort=8888;
    Server server=new Server(myPort);
    WebAppContext root=new WebAppContext();
    root.setContextPath(""String_Node_Str"");
    root.setDescriptor(""String_Node_Str"");
    root.setResourceBase(""String_Node_Str"");
    root.setParentLoaderPriority(true);
    server.setHandler(root);
    server.start();
  }
  if (true) {
    return;
  }
}",0.2565826330532212
112264,"public void setRestfulServer(RestfulServer theRestfulServer){
  myServerConfiguration=theRestfulServer.createConfiguration();
}","@Override public void setRestfulServer(RestfulServer theRestfulServer){
  myServerConfiguration=theRestfulServer.createConfiguration();
}",0.9621212121212122
112265,"@Test public void testSearchReferenceParameterWithList() throws Exception {
  RestfulServer rsNoType=new RestfulServer(ourCtx);
  rsNoType.registerProvider(new SearchProviderWithListNoType());
  ServerConformanceProvider sc=new ServerConformanceProvider(rsNoType);
  rsNoType.setServerConformanceProvider(sc);
  rsNoType.init(createServletConfig());
  Conformance conformance=sc.getServerConformance(createHttpServletRequest());
  String confNoType=ourCtx.newXmlParser().setPrettyPrint(true).encodeResourceToString(conformance);
  ourLog.info(confNoType);
  RestfulServer rsWithType=new RestfulServer(ourCtx);
  rsWithType.registerProvider(new SearchProviderWithListWithType());
  ServerConformanceProvider scWithType=new ServerConformanceProvider(rsWithType);
  rsWithType.setServerConformanceProvider(scWithType);
  rsWithType.init(createServletConfig());
  Conformance conformanceWithType=scWithType.getServerConformance(createHttpServletRequest());
  String confWithType=ourCtx.newXmlParser().setPrettyPrint(true).encodeResourceToString(conformanceWithType);
  ourLog.info(confWithType);
  assertEquals(confNoType,confWithType);
}","@Test public void testSearchReferenceParameterWithList() throws Exception {
  RestfulServer rsNoType=new RestfulServer(ourCtx);
  rsNoType.registerProvider(new SearchProviderWithListNoType());
  ServerConformanceProvider scNoType=new ServerConformanceProvider(rsNoType);
  rsNoType.setServerConformanceProvider(scNoType);
  rsNoType.init(createServletConfig());
  scNoType.getServerConfiguration().setConformanceDate(""String_Node_Str"");
  Conformance conformance=scNoType.getServerConformance(createHttpServletRequest());
  String confNoType=ourCtx.newXmlParser().setPrettyPrint(true).encodeResourceToString(conformance);
  ourLog.info(confNoType);
  RestfulServer rsWithType=new RestfulServer(ourCtx);
  rsWithType.registerProvider(new SearchProviderWithListWithType());
  ServerConformanceProvider scWithType=new ServerConformanceProvider(rsWithType);
  rsWithType.setServerConformanceProvider(scWithType);
  rsWithType.init(createServletConfig());
  scWithType.getServerConfiguration().setConformanceDate(""String_Node_Str"");
  Conformance conformanceWithType=scWithType.getServerConformance(createHttpServletRequest());
  String confWithType=ourCtx.newXmlParser().setPrettyPrint(true).encodeResourceToString(conformanceWithType);
  ourLog.info(confWithType);
  assertEquals(confNoType,confWithType);
}",0.930270713699754
112266,"protected void handleRequest(RequestTypeEnum theRequestType,HttpServletRequest theRequest,HttpServletResponse theResponse) throws ServletException, IOException {
  String fhirServerBase=null;
  ServletRequestDetails requestDetails=new ServletRequestDetails();
  requestDetails.setServer(this);
  requestDetails.setRequestType(theRequestType);
  requestDetails.setServletRequest(theRequest);
  requestDetails.setServletResponse(theResponse);
  theRequest.setAttribute(SERVLET_CONTEXT_ATTRIBUTE,getServletContext());
  try {
    String requestFullPath=StringUtils.defaultString(theRequest.getRequestURI());
    String servletPath=StringUtils.defaultString(theRequest.getServletPath());
    StringBuffer requestUrl=theRequest.getRequestURL();
    String servletContextPath=IncomingRequestAddressStrategy.determineServletContextPath(theRequest,this);
    if (ourLog.isTraceEnabled()) {
      ourLog.trace(""String_Node_Str"",requestFullPath);
      ourLog.trace(""String_Node_Str"",servletPath);
      ourLog.trace(""String_Node_Str"",requestUrl);
      ourLog.trace(""String_Node_Str"",servletContextPath);
    }
    String completeUrl;
    Map<String,String[]> params=null;
    if (StringUtils.isNotBlank(theRequest.getQueryString())) {
      completeUrl=requestUrl + ""String_Node_Str"" + theRequest.getQueryString();
      if (isIgnoreServerParsedRequestParameters()) {
        String contentType=theRequest.getHeader(Constants.HEADER_CONTENT_TYPE);
        if (theRequestType == RequestTypeEnum.POST && isNotBlank(contentType) && contentType.startsWith(Constants.CT_X_FORM_URLENCODED)) {
          String requestBody=new String(requestDetails.loadRequestContents(),Constants.CHARSET_UTF8);
          params=UrlUtil.parseQueryStrings(theRequest.getQueryString(),requestBody);
        }
 else         if (theRequestType == RequestTypeEnum.GET) {
          params=UrlUtil.parseQueryString(theRequest.getQueryString());
        }
      }
    }
 else {
      completeUrl=requestUrl.toString();
    }
    if (params == null) {
      params=new HashMap<String,String[]>(theRequest.getParameterMap());
    }
    requestDetails.setParameters(params);
    for (    IServerInterceptor next : myInterceptors) {
      boolean continueProcessing=next.incomingRequestPreProcessed(theRequest,theResponse);
      if (!continueProcessing) {
        ourLog.debug(""String_Node_Str"");
        return;
      }
    }
    String requestPath=getRequestPath(requestFullPath,servletContextPath,servletPath);
    if (requestPath.length() > 0 && requestPath.charAt(0) == '/') {
      requestPath=requestPath.substring(1);
    }
    fhirServerBase=getServerBaseForRequest(theRequest);
    IIdType id;
    populateRequestDetailsFromRequestPath(requestDetails,requestPath);
    if (theRequestType == RequestTypeEnum.PUT) {
      String contentLocation=theRequest.getHeader(Constants.HEADER_CONTENT_LOCATION);
      if (contentLocation != null) {
        id=myFhirContext.getVersion().newIdType();
        id.setValue(contentLocation);
        requestDetails.setId(id);
      }
    }
    String acceptEncoding=theRequest.getHeader(Constants.HEADER_ACCEPT_ENCODING);
    boolean respondGzip=false;
    if (acceptEncoding != null) {
      String[] parts=acceptEncoding.trim().split(""String_Node_Str"");
      for (      String string : parts) {
        if (string.equals(""String_Node_Str"")) {
          respondGzip=true;
        }
      }
    }
    requestDetails.setRespondGzip(respondGzip);
    requestDetails.setRequestPath(requestPath);
    requestDetails.setFhirServerBase(fhirServerBase);
    requestDetails.setCompleteUrl(completeUrl);
    BaseMethodBinding<?> resourceMethod=determineResourceMethod(requestDetails,requestPath);
    requestDetails.setRestOperationType(resourceMethod.getRestOperationType());
    for (    IServerInterceptor next : myInterceptors) {
      boolean continueProcessing=next.incomingRequestPostProcessed(requestDetails,theRequest,theResponse);
      if (!continueProcessing) {
        ourLog.debug(""String_Node_Str"");
        return;
      }
    }
    Closeable outputStreamOrWriter=(Closeable)resourceMethod.invokeServer(this,requestDetails);
    for (int i=getInterceptors().size() - 1; i >= 0; i--) {
      IServerInterceptor next=getInterceptors().get(i);
      next.processingCompletedNormally(requestDetails);
    }
    outputStreamOrWriter.close();
  }
 catch (  NotModifiedException e) {
    for (int i=getInterceptors().size() - 1; i >= 0; i--) {
      IServerInterceptor next=getInterceptors().get(i);
      if (!next.handleException(requestDetails,e,theRequest,theResponse)) {
        ourLog.debug(""String_Node_Str"");
        return;
      }
    }
    writeExceptionToResponse(theResponse,e);
  }
catch (  AuthenticationException e) {
    for (int i=getInterceptors().size() - 1; i >= 0; i--) {
      IServerInterceptor next=getInterceptors().get(i);
      if (!next.handleException(requestDetails,e,theRequest,theResponse)) {
        ourLog.debug(""String_Node_Str"");
        return;
      }
    }
    writeExceptionToResponse(theResponse,e);
  }
catch (  Throwable e) {
    BaseServerResponseException exception=null;
    for (int i=getInterceptors().size() - 1; i >= 0; i--) {
      IServerInterceptor next=getInterceptors().get(i);
      exception=next.preProcessOutgoingException(requestDetails,e,theRequest);
      if (exception != null) {
        ourLog.debug(""String_Node_Str"");
        break;
      }
    }
    if (exception == null) {
      exception=DEFAULT_EXCEPTION_HANDLER.preProcessOutgoingException(requestDetails,e,theRequest);
    }
    for (int i=getInterceptors().size() - 1; i >= 0; i--) {
      IServerInterceptor next=getInterceptors().get(i);
      if (!next.handleException(requestDetails,exception,theRequest,theResponse)) {
        ourLog.debug(""String_Node_Str"");
        return;
      }
    }
    requestDetails.getParameters().remove(Constants.PARAM_SUMMARY);
    requestDetails.getParameters().remove(Constants.PARAM_ELEMENTS);
    DEFAULT_EXCEPTION_HANDLER.handleException(requestDetails,exception,theRequest,theResponse);
  }
}","protected void handleRequest(RequestTypeEnum theRequestType,HttpServletRequest theRequest,HttpServletResponse theResponse) throws ServletException, IOException {
  String fhirServerBase=null;
  ServletRequestDetails requestDetails=new ServletRequestDetails();
  requestDetails.setServer(this);
  requestDetails.setRequestType(theRequestType);
  requestDetails.setServletRequest(theRequest);
  requestDetails.setServletResponse(theResponse);
  theRequest.setAttribute(SERVLET_CONTEXT_ATTRIBUTE,getServletContext());
  try {
    String requestFullPath=StringUtils.defaultString(theRequest.getRequestURI());
    String servletPath=StringUtils.defaultString(theRequest.getServletPath());
    StringBuffer requestUrl=theRequest.getRequestURL();
    String servletContextPath=IncomingRequestAddressStrategy.determineServletContextPath(theRequest,this);
    if (ourLog.isTraceEnabled()) {
      ourLog.trace(""String_Node_Str"",requestFullPath);
      ourLog.trace(""String_Node_Str"",servletPath);
      ourLog.trace(""String_Node_Str"",requestUrl);
      ourLog.trace(""String_Node_Str"",servletContextPath);
    }
    String completeUrl;
    Map<String,String[]> params=null;
    if (StringUtils.isNotBlank(theRequest.getQueryString())) {
      completeUrl=requestUrl + ""String_Node_Str"" + theRequest.getQueryString();
      if (isIgnoreServerParsedRequestParameters()) {
        String contentType=theRequest.getHeader(Constants.HEADER_CONTENT_TYPE);
        if (theRequestType == RequestTypeEnum.POST && isNotBlank(contentType) && contentType.startsWith(Constants.CT_X_FORM_URLENCODED)) {
          String requestBody=new String(requestDetails.loadRequestContents(),Constants.CHARSET_UTF8);
          params=UrlUtil.parseQueryStrings(theRequest.getQueryString(),requestBody);
        }
 else         if (theRequestType == RequestTypeEnum.GET) {
          params=UrlUtil.parseQueryString(theRequest.getQueryString());
        }
      }
    }
 else {
      completeUrl=requestUrl.toString();
    }
    if (params == null) {
      params=new HashMap<String,String[]>(theRequest.getParameterMap());
    }
    requestDetails.setParameters(params);
    for (    IServerInterceptor next : myInterceptors) {
      boolean continueProcessing=next.incomingRequestPreProcessed(theRequest,theResponse);
      if (!continueProcessing) {
        ourLog.debug(""String_Node_Str"");
        return;
      }
    }
    String requestPath=getRequestPath(requestFullPath,servletContextPath,servletPath);
    if (requestPath.length() > 0 && requestPath.charAt(0) == '/') {
      requestPath=requestPath.substring(1);
    }
    fhirServerBase=getServerBaseForRequest(theRequest);
    IIdType id;
    populateRequestDetailsFromRequestPath(requestDetails,requestPath);
    if (theRequestType == RequestTypeEnum.PUT) {
      String contentLocation=theRequest.getHeader(Constants.HEADER_CONTENT_LOCATION);
      if (contentLocation != null) {
        id=myFhirContext.getVersion().newIdType();
        id.setValue(contentLocation);
        requestDetails.setId(id);
      }
    }
    String acceptEncoding=theRequest.getHeader(Constants.HEADER_ACCEPT_ENCODING);
    boolean respondGzip=false;
    if (acceptEncoding != null) {
      String[] parts=acceptEncoding.trim().split(""String_Node_Str"");
      for (      String string : parts) {
        if (string.equals(""String_Node_Str"")) {
          respondGzip=true;
        }
      }
    }
    requestDetails.setRespondGzip(respondGzip);
    requestDetails.setRequestPath(requestPath);
    requestDetails.setFhirServerBase(fhirServerBase);
    requestDetails.setCompleteUrl(completeUrl);
    BaseMethodBinding<?> resourceMethod=determineResourceMethod(requestDetails,requestPath);
    requestDetails.setRestOperationType(resourceMethod.getRestOperationType());
    for (    IServerInterceptor next : myInterceptors) {
      boolean continueProcessing=next.incomingRequestPostProcessed(requestDetails,theRequest,theResponse);
      if (!continueProcessing) {
        ourLog.debug(""String_Node_Str"");
        return;
      }
    }
    Closeable outputStreamOrWriter=(Closeable)resourceMethod.invokeServer(this,requestDetails);
    for (int i=getInterceptors().size() - 1; i >= 0; i--) {
      IServerInterceptor next=getInterceptors().get(i);
      next.processingCompletedNormally(requestDetails);
    }
    if (outputStreamOrWriter != null) {
      outputStreamOrWriter.close();
    }
  }
 catch (  NotModifiedException e) {
    for (int i=getInterceptors().size() - 1; i >= 0; i--) {
      IServerInterceptor next=getInterceptors().get(i);
      if (!next.handleException(requestDetails,e,theRequest,theResponse)) {
        ourLog.debug(""String_Node_Str"");
        return;
      }
    }
    writeExceptionToResponse(theResponse,e);
  }
catch (  AuthenticationException e) {
    for (int i=getInterceptors().size() - 1; i >= 0; i--) {
      IServerInterceptor next=getInterceptors().get(i);
      if (!next.handleException(requestDetails,e,theRequest,theResponse)) {
        ourLog.debug(""String_Node_Str"");
        return;
      }
    }
    writeExceptionToResponse(theResponse,e);
  }
catch (  Throwable e) {
    BaseServerResponseException exception=null;
    for (int i=getInterceptors().size() - 1; i >= 0; i--) {
      IServerInterceptor next=getInterceptors().get(i);
      exception=next.preProcessOutgoingException(requestDetails,e,theRequest);
      if (exception != null) {
        ourLog.debug(""String_Node_Str"");
        break;
      }
    }
    if (exception == null) {
      exception=DEFAULT_EXCEPTION_HANDLER.preProcessOutgoingException(requestDetails,e,theRequest);
    }
    for (int i=getInterceptors().size() - 1; i >= 0; i--) {
      IServerInterceptor next=getInterceptors().get(i);
      if (!next.handleException(requestDetails,exception,theRequest,theResponse)) {
        ourLog.debug(""String_Node_Str"");
        return;
      }
    }
    requestDetails.getParameters().remove(Constants.PARAM_SUMMARY);
    requestDetails.getParameters().remove(Constants.PARAM_ELEMENTS);
    DEFAULT_EXCEPTION_HANDLER.handleException(requestDetails,exception,theRequest,theResponse);
  }
}",0.9945768282662284
112267,"private Pageable toPage(int theFromIndex,int theToIndex){
  int pageSize=theToIndex - theFromIndex;
  if (pageSize < 1) {
    return null;
  }
  int pageIndex=theFromIndex / pageSize;
  Pageable page=new PageRequest(pageIndex,pageSize);
  return page;
}","public static Pageable toPage(final int theFromIndex,int theToIndex){
  int pageSize=theToIndex - theFromIndex;
  if (pageSize < 1) {
    return null;
  }
  int pageIndex=theFromIndex / pageSize;
  Pageable page=new PageRequest(pageIndex,pageSize){
    private static final long serialVersionUID=1L;
    @Override public int getOffset(){
      return theFromIndex;
    }
  }
;
  return page;
}",0.7120743034055728
112268,"/** 
 * THIS IS FOR UNIT TESTS ONLY When we run the unit tests in cobertura, JUnit doesn't seem to clean up static fields which leads to  tons of memory being used by the end and the JVM crashes in Travis. Manually clearing all of the static fields seems to solve this.
 */
public static void clearAllStaticFieldsForUnitTest(){
  Class<?> theType;
  try {
    throw new Exception();
  }
 catch (  Exception e) {
    StackTraceElement[] st=e.getStackTrace();
    StackTraceElement elem=st[1];
    String clazzName=elem.getClassName();
    try {
      theType=Class.forName(clazzName);
    }
 catch (    ClassNotFoundException e1) {
      throw new Error(e);
    }
  }
  for (  Field next : Arrays.asList(theType.getDeclaredFields())) {
    if (Modifier.isStatic(next.getModifiers())) {
      if (!Modifier.isFinal(next.getModifiers()) && !next.getType().isPrimitive()) {
        ourLog.info(""String_Node_Str"",next.toString());
        try {
          next.setAccessible(true);
          next.set(theType,null);
        }
 catch (        Exception e) {
          throw new Error(e);
        }
      }
      if (Modifier.isFinal(next.getModifiers())) {
        if (next.getType().equals(FhirContext.class)) {
          throw new Error(""String_Node_Str"" + next);
        }
      }
    }
  }
  Locale[] availableLocales={Locale.CANADA,Locale.GERMANY,Locale.TAIWAN};
  Locale.setDefault(availableLocales[(int)(Math.random() * availableLocales.length)]);
  ourLog.info(""String_Node_Str"" + Locale.getDefault().getDisplayName());
  if (Math.random() < 0.5) {
    ourLog.info(""String_Node_Str"");
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    ourLog.info(""String_Node_Str"");
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
  }
  String availableTimeZones[]={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  String timeZone=availableTimeZones[(int)(Math.random() * availableTimeZones.length)];
  TimeZone.setDefault(TimeZone.getTimeZone(timeZone));
  ourLog.info(""String_Node_Str"",TimeZone.getDefault().getID());
}","/** 
 * <b>THIS IS FOR UNIT TESTS ONLY - DO NOT CALL THIS METHOD FROM USER CODE</b> When we run the unit tests in cobertura, JUnit doesn't seem to clean up static fields which leads to  tons of memory being used by the end and the JVM crashes in Travis. Manually clearing all of the static fields seems to solve this.
 */
public static void clearAllStaticFieldsForUnitTest(){
  Class<?> theType;
  try {
    throw new Exception();
  }
 catch (  Exception e) {
    StackTraceElement[] st=e.getStackTrace();
    StackTraceElement elem=st[1];
    String clazzName=elem.getClassName();
    try {
      theType=Class.forName(clazzName);
    }
 catch (    ClassNotFoundException e1) {
      throw new Error(e);
    }
  }
  for (  Field next : Arrays.asList(theType.getDeclaredFields())) {
    if (Modifier.isStatic(next.getModifiers())) {
      if (!Modifier.isFinal(next.getModifiers()) && !next.getType().isPrimitive()) {
        ourLog.info(""String_Node_Str"",next.toString());
        try {
          next.setAccessible(true);
          next.set(theType,null);
        }
 catch (        Exception e) {
          throw new Error(e);
        }
      }
      if (Modifier.isFinal(next.getModifiers())) {
        if (next.getType().equals(FhirContext.class)) {
          throw new Error(""String_Node_Str"" + next);
        }
      }
    }
  }
  Locale[] availableLocales={Locale.CANADA,Locale.GERMANY,Locale.TAIWAN};
  Locale.setDefault(availableLocales[(int)(Math.random() * availableLocales.length)]);
  ourLog.info(""String_Node_Str"" + Locale.getDefault().getDisplayName());
  if (Math.random() < 0.5) {
    ourLog.info(""String_Node_Str"");
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    ourLog.info(""String_Node_Str"");
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
  }
  String availableTimeZones[]={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  String timeZone=availableTimeZones[(int)(Math.random() * availableTimeZones.length)];
  TimeZone.setDefault(TimeZone.getTimeZone(timeZone));
  ourLog.info(""String_Node_Str"",TimeZone.getDefault().getID());
}",0.9891843172600272
112269,"@SuppressWarnings(""String_Node_Str"") @RequestMapping(value={""String_Node_Str""}) public String actionSearch(HttpServletRequest theReq,HomeRequest theRequest,BindingResult theBindingResult,ModelMap theModel) throws IOException {
  addCommonParams(theReq,theRequest,theModel);
  StringWriter clientCodeJsonStringWriter=new StringWriter();
  JsonWriter clientCodeJsonWriter=new JsonWriter(clientCodeJsonStringWriter);
  clientCodeJsonWriter.beginObject();
  clientCodeJsonWriter.name(""String_Node_Str"");
  clientCodeJsonWriter.value(""String_Node_Str"");
  clientCodeJsonWriter.name(""String_Node_Str"");
  clientCodeJsonWriter.value((String)theModel.get(""String_Node_Str""));
  CaptureInterceptor interceptor=new CaptureInterceptor();
  GenericClient client=theRequest.newClient(theReq,getContext(theRequest),myConfig,interceptor);
  IUntypedQuery search=client.search();
  IQuery query;
  if (isNotBlank(theReq.getParameter(""String_Node_Str""))) {
    try {
      query=search.forResource((Class<? extends IBaseResource>)getResourceType(theRequest,theReq).getImplementingClass());
    }
 catch (    ServletException e) {
      theModel.put(""String_Node_Str"",e.toString());
      return ""String_Node_Str"";
    }
    clientCodeJsonWriter.name(""String_Node_Str"");
    clientCodeJsonWriter.value(theReq.getParameter(""String_Node_Str""));
  }
 else {
    query=search.forAllResources();
    clientCodeJsonWriter.name(""String_Node_Str"");
    clientCodeJsonWriter.nullValue();
  }
  if (client.getPrettyPrint() != null) {
    clientCodeJsonWriter.name(""String_Node_Str"");
    clientCodeJsonWriter.value(client.getPrettyPrint().toString());
  }
 else {
    clientCodeJsonWriter.name(""String_Node_Str"");
    clientCodeJsonWriter.nullValue();
  }
  if (client.getEncoding() != null) {
    clientCodeJsonWriter.name(""String_Node_Str"");
    clientCodeJsonWriter.value(client.getEncoding().getRequestContentType());
  }
 else {
    clientCodeJsonWriter.name(""String_Node_Str"");
    clientCodeJsonWriter.nullValue();
  }
  String outcomeDescription=""String_Node_Str"";
  clientCodeJsonWriter.name(""String_Node_Str"");
  clientCodeJsonWriter.beginArray();
  int paramIdx=-1;
  while (true) {
    paramIdx++;
    String paramIdxString=Integer.toString(paramIdx);
    boolean shouldContinue=handleSearchParam(paramIdxString,theReq,query,clientCodeJsonWriter);
    if (!shouldContinue) {
      break;
    }
  }
  clientCodeJsonWriter.endArray();
  clientCodeJsonWriter.name(""String_Node_Str"");
  clientCodeJsonWriter.beginArray();
  String[] incValues=theReq.getParameterValues(Constants.PARAM_INCLUDE);
  if (incValues != null) {
    for (    String next : incValues) {
      if (isNotBlank(next)) {
        query.include(new Include(next));
        clientCodeJsonWriter.value(next);
      }
    }
  }
  clientCodeJsonWriter.endArray();
  clientCodeJsonWriter.name(""String_Node_Str"");
  clientCodeJsonWriter.beginArray();
  String[] revIncValues=theReq.getParameterValues(Constants.PARAM_REVINCLUDE);
  if (revIncValues != null) {
    for (    String next : revIncValues) {
      if (isNotBlank(next)) {
        query.revInclude(new Include(next));
        clientCodeJsonWriter.value(next);
      }
    }
  }
  clientCodeJsonWriter.endArray();
  String limit=theReq.getParameter(""String_Node_Str"");
  if (isNotBlank(limit)) {
    if (!limit.matches(""String_Node_Str"")) {
      theModel.put(""String_Node_Str"",""String_Node_Str"");
      return ""String_Node_Str"";
    }
    int limitInt=Integer.parseInt(limit);
    query.limitTo(limitInt);
    clientCodeJsonWriter.name(""String_Node_Str"");
    clientCodeJsonWriter.value(limit);
  }
 else {
    clientCodeJsonWriter.name(""String_Node_Str"");
    clientCodeJsonWriter.nullValue();
  }
  String[] sort=theReq.getParameterValues(""String_Node_Str"");
  if (sort != null) {
    for (    String next : sort) {
      if (isBlank(next)) {
        continue;
      }
      String direction=theReq.getParameter(""String_Node_Str"");
      if (""String_Node_Str"".equals(direction)) {
        query.sort().ascending(new StringClientParam(next));
      }
 else       if (""String_Node_Str"".equals(direction)) {
        query.sort().descending(new StringClientParam(next));
      }
 else {
        query.sort().defaultOrder(new StringClientParam(next));
      }
    }
  }
  if (client.getFhirContext().getVersion().getVersion() != FhirVersionEnum.DSTU1) {
    query.returnBundle(client.getFhirContext().getResourceDefinition(""String_Node_Str"").getImplementingClass());
  }
  long start=System.currentTimeMillis();
  ResultType returnsResource;
  try {
    ourLog.info(logPrefix(theModel) + ""String_Node_Str"");
    query.execute();
    returnsResource=ResultType.BUNDLE;
  }
 catch (  Exception e) {
    returnsResource=handleClientException(client,e,theModel);
  }
  long delay=System.currentTimeMillis() - start;
  processAndAddLastClientInvocation(client,returnsResource,theModel,delay,outcomeDescription,interceptor,theRequest);
  clientCodeJsonWriter.endObject();
  clientCodeJsonWriter.close();
  String clientCodeJson=clientCodeJsonStringWriter.toString();
  theModel.put(""String_Node_Str"",clientCodeJson);
  return ""String_Node_Str"";
}","@SuppressWarnings(""String_Node_Str"") @RequestMapping(value={""String_Node_Str""}) public String actionSearch(HttpServletRequest theReq,HomeRequest theRequest,BindingResult theBindingResult,ModelMap theModel) throws IOException {
  addCommonParams(theReq,theRequest,theModel);
  StringWriter clientCodeJsonStringWriter=new StringWriter();
  JsonWriter clientCodeJsonWriter=new JsonWriter(clientCodeJsonStringWriter);
  clientCodeJsonWriter.beginObject();
  clientCodeJsonWriter.name(""String_Node_Str"");
  clientCodeJsonWriter.value(""String_Node_Str"");
  clientCodeJsonWriter.name(""String_Node_Str"");
  clientCodeJsonWriter.value((String)theModel.get(""String_Node_Str""));
  CaptureInterceptor interceptor=new CaptureInterceptor();
  GenericClient client=theRequest.newClient(theReq,getContext(theRequest),myConfig,interceptor);
  IUntypedQuery search=client.search();
  IQuery query;
  if (isNotBlank(theReq.getParameter(""String_Node_Str""))) {
    try {
      query=search.forResource((Class<? extends IBaseResource>)getResourceType(theRequest,theReq).getImplementingClass());
    }
 catch (    ServletException e) {
      theModel.put(""String_Node_Str"",e.toString());
      return ""String_Node_Str"";
    }
    clientCodeJsonWriter.name(""String_Node_Str"");
    clientCodeJsonWriter.value(theReq.getParameter(""String_Node_Str""));
  }
 else {
    query=search.forAllResources();
    clientCodeJsonWriter.name(""String_Node_Str"");
    clientCodeJsonWriter.nullValue();
  }
  if (client.isPrettyPrint()) {
    clientCodeJsonWriter.name(""String_Node_Str"");
    clientCodeJsonWriter.value(""String_Node_Str"");
  }
 else {
    clientCodeJsonWriter.name(""String_Node_Str"");
    clientCodeJsonWriter.nullValue();
  }
  if (client.getEncoding() != null) {
    clientCodeJsonWriter.name(""String_Node_Str"");
    clientCodeJsonWriter.value(client.getEncoding().getRequestContentType());
  }
 else {
    clientCodeJsonWriter.name(""String_Node_Str"");
    clientCodeJsonWriter.nullValue();
  }
  String outcomeDescription=""String_Node_Str"";
  clientCodeJsonWriter.name(""String_Node_Str"");
  clientCodeJsonWriter.beginArray();
  int paramIdx=-1;
  while (true) {
    paramIdx++;
    String paramIdxString=Integer.toString(paramIdx);
    boolean shouldContinue=handleSearchParam(paramIdxString,theReq,query,clientCodeJsonWriter);
    if (!shouldContinue) {
      break;
    }
  }
  clientCodeJsonWriter.endArray();
  clientCodeJsonWriter.name(""String_Node_Str"");
  clientCodeJsonWriter.beginArray();
  String[] incValues=theReq.getParameterValues(Constants.PARAM_INCLUDE);
  if (incValues != null) {
    for (    String next : incValues) {
      if (isNotBlank(next)) {
        query.include(new Include(next));
        clientCodeJsonWriter.value(next);
      }
    }
  }
  clientCodeJsonWriter.endArray();
  clientCodeJsonWriter.name(""String_Node_Str"");
  clientCodeJsonWriter.beginArray();
  String[] revIncValues=theReq.getParameterValues(Constants.PARAM_REVINCLUDE);
  if (revIncValues != null) {
    for (    String next : revIncValues) {
      if (isNotBlank(next)) {
        query.revInclude(new Include(next));
        clientCodeJsonWriter.value(next);
      }
    }
  }
  clientCodeJsonWriter.endArray();
  String limit=theReq.getParameter(""String_Node_Str"");
  if (isNotBlank(limit)) {
    if (!limit.matches(""String_Node_Str"")) {
      theModel.put(""String_Node_Str"",""String_Node_Str"");
      return ""String_Node_Str"";
    }
    int limitInt=Integer.parseInt(limit);
    query.limitTo(limitInt);
    clientCodeJsonWriter.name(""String_Node_Str"");
    clientCodeJsonWriter.value(limit);
  }
 else {
    clientCodeJsonWriter.name(""String_Node_Str"");
    clientCodeJsonWriter.nullValue();
  }
  String[] sort=theReq.getParameterValues(""String_Node_Str"");
  if (sort != null) {
    for (    String next : sort) {
      if (isBlank(next)) {
        continue;
      }
      String direction=theReq.getParameter(""String_Node_Str"");
      if (""String_Node_Str"".equals(direction)) {
        query.sort().ascending(new StringClientParam(next));
      }
 else       if (""String_Node_Str"".equals(direction)) {
        query.sort().descending(new StringClientParam(next));
      }
 else {
        query.sort().defaultOrder(new StringClientParam(next));
      }
    }
  }
  if (client.getFhirContext().getVersion().getVersion() != FhirVersionEnum.DSTU1) {
    query.returnBundle(client.getFhirContext().getResourceDefinition(""String_Node_Str"").getImplementingClass());
  }
  long start=System.currentTimeMillis();
  ResultType returnsResource;
  try {
    ourLog.info(logPrefix(theModel) + ""String_Node_Str"");
    query.execute();
    returnsResource=ResultType.BUNDLE;
  }
 catch (  Exception e) {
    returnsResource=handleClientException(client,e,theModel);
  }
  long delay=System.currentTimeMillis() - start;
  processAndAddLastClientInvocation(client,returnsResource,theModel,delay,outcomeDescription,interceptor,theRequest);
  clientCodeJsonWriter.endObject();
  clientCodeJsonWriter.close();
  String clientCodeJson=clientCodeJsonStringWriter.toString();
  theModel.put(""String_Node_Str"",clientCodeJson);
  return ""String_Node_Str"";
}",0.993758533255315
112270,"@Test public void testParseWithTrailingContent() throws Exception {
  String bundle=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  Bundle b=ourCtx.newJsonParser().parseResource(Bundle.class,bundle);
}","@Test(expected=DataFormatException.class) public void testParseWithTrailingContent() throws Exception {
  String bundle=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  Bundle b=ourCtx.newJsonParser().parseResource(Bundle.class,bundle);
}",0.9282868525896414
112271,"@Override public CodeValidationResult validateCode(FhirContext theContext,String theCodeSystem,String theCode,String theDisplay){
  CodeSystem cs=fetchCodeSystem(theContext,theCodeSystem);
  if (cs != null) {
    for (    ConceptDefinitionComponent next : cs.getConcept()) {
      if (next.getCode().equals(theCode)) {
        return new CodeValidationResult(next);
      }
    }
  }
  return new CodeValidationResult(IssueSeverity.INFORMATION,""String_Node_Str"" + theCodeSystem + ""String_Node_Str""+ theCode);
}","@Override public CodeValidationResult validateCode(FhirContext theContext,String theCodeSystem,String theCode,String theDisplay){
  CodeSystem cs=fetchCodeSystem(theContext,theCodeSystem);
  if (cs != null) {
    CodeValidationResult retVal=testIfConceptIsInList(theCode,cs.getConcept());
    if (retVal != null) {
      return retVal;
    }
  }
  return new CodeValidationResult(IssueSeverity.INFORMATION,""String_Node_Str"" + theCodeSystem + ""String_Node_Str""+ theCode);
}",0.7535641547861507
112272,"public boolean isEmpty(){
  return super.isEmpty() && (use == null || use.isEmpty()) && (text == null || text.isEmpty())&& (family == null || family.isEmpty())&& (given == null || given.isEmpty())&& (prefix == null || prefix.isEmpty())&& (suffix == null || suffix.isEmpty())&& (period == null || period.isEmpty());
}","public boolean isEmpty(){
  return super.isEmpty() && ElementUtil.isEmpty(use,text,family,given,prefix,suffix,period);
}",0.4724770642201835
112273,"private <R extends IBaseResource>R populateResourceMetadataHapi(Class<R> theResourceType,BaseHasResource theEntity,boolean theForHistoryOperation,IResource res){
  R retVal=(R)res;
  if (theEntity.getDeleted() != null) {
    res=(IResource)myContext.getResourceDefinition(theResourceType).newInstance();
    retVal=(R)res;
    ResourceMetadataKeyEnum.DELETED_AT.put(res,new InstantDt(theEntity.getDeleted()));
    if (theForHistoryOperation) {
      ResourceMetadataKeyEnum.ENTRY_TRANSACTION_METHOD.put(res,BundleEntryTransactionMethodEnum.DELETE);
    }
  }
 else   if (theForHistoryOperation) {
    Date published=theEntity.getPublished().getValue();
    Date updated=theEntity.getUpdated().getValue();
    if (published.equals(updated)) {
      ResourceMetadataKeyEnum.ENTRY_TRANSACTION_METHOD.put(res,BundleEntryTransactionMethodEnum.POST);
    }
 else {
      ResourceMetadataKeyEnum.ENTRY_TRANSACTION_METHOD.put(res,BundleEntryTransactionMethodEnum.PUT);
    }
  }
  res.setId(theEntity.getIdDt());
  ResourceMetadataKeyEnum.VERSION.put(res,Long.toString(theEntity.getVersion()));
  ResourceMetadataKeyEnum.PUBLISHED.put(res,theEntity.getPublished());
  ResourceMetadataKeyEnum.UPDATED.put(res,theEntity.getUpdated());
  IDao.RESOURCE_PID.put(res,theEntity.getId());
  if (theEntity.getTitle() != null) {
    ResourceMetadataKeyEnum.TITLE.put(res,theEntity.getTitle());
  }
  Collection<? extends BaseTag> tags=theEntity.getTags();
  if (theEntity.isHasTags()) {
    TagList tagList=new TagList();
    List<IBaseCoding> securityLabels=new ArrayList<IBaseCoding>();
    List<IdDt> profiles=new ArrayList<IdDt>();
    for (    BaseTag next : tags) {
switch (next.getTag().getTagType()) {
case PROFILE:
        profiles.add(new IdDt(next.getTag().getCode()));
      break;
case SECURITY_LABEL:
    IBaseCoding secLabel=(IBaseCoding)myContext.getVersion().newCodingDt();
  secLabel.setSystem(next.getTag().getSystem());
secLabel.setCode(next.getTag().getCode());
secLabel.setDisplay(next.getTag().getDisplay());
securityLabels.add(secLabel);
break;
case TAG:
tagList.add(new Tag(next.getTag().getSystem(),next.getTag().getCode(),next.getTag().getDisplay()));
break;
}
}
if (tagList.size() > 0) {
ResourceMetadataKeyEnum.TAG_LIST.put(res,tagList);
}
if (securityLabels.size() > 0) {
ResourceMetadataKeyEnum.SECURITY_LABELS.put(res,toBaseCodingList(securityLabels));
}
if (profiles.size() > 0) {
ResourceMetadataKeyEnum.PROFILES.put(res,profiles);
}
}
return retVal;
}","@SuppressWarnings(""String_Node_Str"") private <R extends IBaseResource>R populateResourceMetadataHapi(Class<R> theResourceType,BaseHasResource theEntity,boolean theForHistoryOperation,IResource res){
  R retVal=(R)res;
  if (theEntity.getDeleted() != null) {
    res=(IResource)myContext.getResourceDefinition(theResourceType).newInstance();
    retVal=(R)res;
    ResourceMetadataKeyEnum.DELETED_AT.put(res,new InstantDt(theEntity.getDeleted()));
    if (theForHistoryOperation) {
      ResourceMetadataKeyEnum.ENTRY_TRANSACTION_METHOD.put(res,BundleEntryTransactionMethodEnum.DELETE);
    }
  }
 else   if (theForHistoryOperation) {
    Date published=theEntity.getPublished().getValue();
    Date updated=theEntity.getUpdated().getValue();
    if (published.equals(updated)) {
      ResourceMetadataKeyEnum.ENTRY_TRANSACTION_METHOD.put(res,BundleEntryTransactionMethodEnum.POST);
    }
 else {
      ResourceMetadataKeyEnum.ENTRY_TRANSACTION_METHOD.put(res,BundleEntryTransactionMethodEnum.PUT);
    }
  }
  res.setId(theEntity.getIdDt());
  ResourceMetadataKeyEnum.VERSION.put(res,Long.toString(theEntity.getVersion()));
  ResourceMetadataKeyEnum.PUBLISHED.put(res,theEntity.getPublished());
  ResourceMetadataKeyEnum.UPDATED.put(res,theEntity.getUpdated());
  IDao.RESOURCE_PID.put(res,theEntity.getId());
  if (theEntity.getTitle() != null) {
    ResourceMetadataKeyEnum.TITLE.put(res,theEntity.getTitle());
  }
  Collection<? extends BaseTag> tags=theEntity.getTags();
  if (theEntity.isHasTags()) {
    TagList tagList=new TagList();
    List<IBaseCoding> securityLabels=new ArrayList<IBaseCoding>();
    List<IdDt> profiles=new ArrayList<IdDt>();
    for (    BaseTag next : tags) {
switch (next.getTag().getTagType()) {
case PROFILE:
        profiles.add(new IdDt(next.getTag().getCode()));
      break;
case SECURITY_LABEL:
    IBaseCoding secLabel=(IBaseCoding)myContext.getVersion().newCodingDt();
  secLabel.setSystem(next.getTag().getSystem());
secLabel.setCode(next.getTag().getCode());
secLabel.setDisplay(next.getTag().getDisplay());
securityLabels.add(secLabel);
break;
case TAG:
tagList.add(new Tag(next.getTag().getSystem(),next.getTag().getCode(),next.getTag().getDisplay()));
break;
}
}
if (tagList.size() > 0) {
ResourceMetadataKeyEnum.TAG_LIST.put(res,tagList);
}
if (securityLabels.size() > 0) {
ResourceMetadataKeyEnum.SECURITY_LABELS.put(res,toBaseCodingList(securityLabels));
}
if (profiles.size() > 0) {
ResourceMetadataKeyEnum.PROFILES.put(res,profiles);
}
}
return retVal;
}",0.99255982304444
112274,"private <R extends IBaseResource>R populateResourceMetadataRi(Class<R> theResourceType,BaseHasResource theEntity,boolean theForHistoryOperation,IAnyResource res){
  R retVal=(R)res;
  if (theEntity.getDeleted() != null) {
    res=(IAnyResource)myContext.getResourceDefinition(theResourceType).newInstance();
    retVal=(R)res;
    ResourceMetadataKeyEnum.DELETED_AT.put(res,new InstantDt(theEntity.getDeleted()));
    if (theForHistoryOperation) {
      ResourceMetadataKeyEnum.ENTRY_TRANSACTION_METHOD.put(res,HTTPVerb.DELETE.toCode());
    }
  }
 else   if (theForHistoryOperation) {
    Date published=theEntity.getPublished().getValue();
    Date updated=theEntity.getUpdated().getValue();
    if (published.equals(updated)) {
      ResourceMetadataKeyEnum.ENTRY_TRANSACTION_METHOD.put(res,HTTPVerb.POST.toCode());
    }
 else {
      ResourceMetadataKeyEnum.ENTRY_TRANSACTION_METHOD.put(res,HTTPVerb.PUT.toCode());
    }
  }
  res.getMeta().getTag().clear();
  res.getMeta().getProfile().clear();
  res.getMeta().getSecurity().clear();
  res.getMeta().setLastUpdated(null);
  res.getMeta().setVersionId(null);
  populateResourceId(res,theEntity);
  res.getMeta().setLastUpdated(theEntity.getUpdatedDate());
  IDao.RESOURCE_PID.put(res,theEntity.getId());
  Collection<? extends BaseTag> tags=theEntity.getTags();
  if (theEntity.isHasTags()) {
    for (    BaseTag next : tags) {
switch (next.getTag().getTagType()) {
case PROFILE:
        res.getMeta().addProfile(next.getTag().getCode());
      break;
case SECURITY_LABEL:
    IBaseCoding sec=res.getMeta().addSecurity();
  sec.setSystem(next.getTag().getSystem());
sec.setCode(next.getTag().getCode());
sec.setDisplay(next.getTag().getDisplay());
break;
case TAG:
IBaseCoding tag=res.getMeta().addTag();
tag.setSystem(next.getTag().getSystem());
tag.setCode(next.getTag().getCode());
tag.setDisplay(next.getTag().getDisplay());
break;
}
}
}
return retVal;
}","@SuppressWarnings(""String_Node_Str"") private <R extends IBaseResource>R populateResourceMetadataRi(Class<R> theResourceType,BaseHasResource theEntity,boolean theForHistoryOperation,IAnyResource res){
  R retVal=(R)res;
  if (theEntity.getDeleted() != null) {
    res=(IAnyResource)myContext.getResourceDefinition(theResourceType).newInstance();
    retVal=(R)res;
    ResourceMetadataKeyEnum.DELETED_AT.put(res,new InstantDt(theEntity.getDeleted()));
    if (theForHistoryOperation) {
      ResourceMetadataKeyEnum.ENTRY_TRANSACTION_METHOD.put(res,HTTPVerb.DELETE.toCode());
    }
  }
 else   if (theForHistoryOperation) {
    Date published=theEntity.getPublished().getValue();
    Date updated=theEntity.getUpdated().getValue();
    if (published.equals(updated)) {
      ResourceMetadataKeyEnum.ENTRY_TRANSACTION_METHOD.put(res,HTTPVerb.POST.toCode());
    }
 else {
      ResourceMetadataKeyEnum.ENTRY_TRANSACTION_METHOD.put(res,HTTPVerb.PUT.toCode());
    }
  }
  res.getMeta().getTag().clear();
  res.getMeta().getProfile().clear();
  res.getMeta().getSecurity().clear();
  res.getMeta().setLastUpdated(null);
  res.getMeta().setVersionId(null);
  populateResourceId(res,theEntity);
  res.getMeta().setLastUpdated(theEntity.getUpdatedDate());
  IDao.RESOURCE_PID.put(res,theEntity.getId());
  Collection<? extends BaseTag> tags=theEntity.getTags();
  if (theEntity.isHasTags()) {
    for (    BaseTag next : tags) {
switch (next.getTag().getTagType()) {
case PROFILE:
        res.getMeta().addProfile(next.getTag().getCode());
      break;
case SECURITY_LABEL:
    IBaseCoding sec=res.getMeta().addSecurity();
  sec.setSystem(next.getTag().getSystem());
sec.setCode(next.getTag().getCode());
sec.setDisplay(next.getTag().getDisplay());
break;
case TAG:
IBaseCoding tag=res.getMeta().addTag();
tag.setSystem(next.getTag().getSystem());
tag.setCode(next.getTag().getCode());
tag.setDisplay(next.getTag().getDisplay());
break;
}
}
}
return retVal;
}",0.9904318593224722
112275,"protected ResourceTable updateEntity(final IResource theResource,ResourceTable entity,boolean theUpdateHistory,Date theDeletedTimestampOrNull,Date theUpdateTime){
  return updateEntity(theResource,entity,theUpdateHistory,theDeletedTimestampOrNull,true,true,theUpdateTime);
}","@SuppressWarnings(""String_Node_Str"") protected ResourceTable updateEntity(final IBaseResource theResource,ResourceTable theEntity,boolean theUpdateHistory,Date theDeletedTimestampOrNull,boolean thePerformIndexing,boolean theUpdateVersion,Date theUpdateTime,RequestDetails theRequestDetails){
  if (theResource != null) {
    if (thePerformIndexing) {
      validateResourceForStorage((T)theResource,theEntity,theRequestDetails);
    }
    String resourceType=myContext.getResourceDefinition(theResource).getName();
    if (isNotBlank(theEntity.getResourceType()) && !theEntity.getResourceType().equals(resourceType)) {
      throw new UnprocessableEntityException(""String_Node_Str"" + theEntity.getIdDt().toUnqualifiedVersionless() + ""String_Node_Str""+ theEntity.getResourceType()+ ""String_Node_Str""+ resourceType+ ""String_Node_Str"");
    }
  }
  if (theEntity.getPublished() == null) {
    theEntity.setPublished(theUpdateTime);
  }
  if (theUpdateHistory) {
    final ResourceHistoryTable historyEntry=theEntity.toHistory();
    myEntityManager.persist(historyEntry);
  }
  if (theUpdateVersion) {
    theEntity.setVersion(theEntity.getVersion() + 1);
  }
  Collection<ResourceIndexedSearchParamString> paramsString=new ArrayList<ResourceIndexedSearchParamString>();
  if (theEntity.isParamsStringPopulated()) {
    paramsString.addAll(theEntity.getParamsString());
  }
  Collection<ResourceIndexedSearchParamToken> paramsToken=new ArrayList<ResourceIndexedSearchParamToken>();
  if (theEntity.isParamsTokenPopulated()) {
    paramsToken.addAll(theEntity.getParamsToken());
  }
  Collection<ResourceIndexedSearchParamNumber> paramsNumber=new ArrayList<ResourceIndexedSearchParamNumber>();
  if (theEntity.isParamsNumberPopulated()) {
    paramsNumber.addAll(theEntity.getParamsNumber());
  }
  Collection<ResourceIndexedSearchParamQuantity> paramsQuantity=new ArrayList<ResourceIndexedSearchParamQuantity>();
  if (theEntity.isParamsQuantityPopulated()) {
    paramsQuantity.addAll(theEntity.getParamsQuantity());
  }
  Collection<ResourceIndexedSearchParamDate> paramsDate=new ArrayList<ResourceIndexedSearchParamDate>();
  if (theEntity.isParamsDatePopulated()) {
    paramsDate.addAll(theEntity.getParamsDate());
  }
  Collection<ResourceIndexedSearchParamUri> paramsUri=new ArrayList<ResourceIndexedSearchParamUri>();
  if (theEntity.isParamsUriPopulated()) {
    paramsUri.addAll(theEntity.getParamsUri());
  }
  Collection<ResourceIndexedSearchParamCoords> paramsCoords=new ArrayList<ResourceIndexedSearchParamCoords>();
  if (theEntity.isParamsCoordsPopulated()) {
    paramsCoords.addAll(theEntity.getParamsCoords());
  }
  Collection<ResourceLink> existingResourceLinks=new ArrayList<ResourceLink>();
  if (theEntity.isHasLinks()) {
    existingResourceLinks.addAll(theEntity.getResourceLinks());
  }
  Set<ResourceIndexedSearchParamString> stringParams=null;
  Set<ResourceIndexedSearchParamToken> tokenParams=null;
  Set<ResourceIndexedSearchParamNumber> numberParams=null;
  Set<ResourceIndexedSearchParamQuantity> quantityParams=null;
  Set<ResourceIndexedSearchParamDate> dateParams=null;
  Set<ResourceIndexedSearchParamUri> uriParams=null;
  Set<ResourceIndexedSearchParamCoords> coordsParams=null;
  Set<ResourceLink> links=null;
  if (theDeletedTimestampOrNull != null) {
    stringParams=Collections.emptySet();
    tokenParams=Collections.emptySet();
    numberParams=Collections.emptySet();
    quantityParams=Collections.emptySet();
    dateParams=Collections.emptySet();
    uriParams=Collections.emptySet();
    coordsParams=Collections.emptySet();
    links=Collections.emptySet();
    theEntity.setDeleted(theDeletedTimestampOrNull);
    theEntity.setUpdated(theDeletedTimestampOrNull);
    theEntity.setNarrativeTextParsedIntoWords(null);
    theEntity.setContentTextParsedIntoWords(null);
  }
 else {
    theEntity.setDeleted(null);
    if (thePerformIndexing) {
      stringParams=extractSearchParamStrings(theEntity,theResource);
      numberParams=extractSearchParamNumber(theEntity,theResource);
      quantityParams=extractSearchParamQuantity(theEntity,theResource);
      dateParams=extractSearchParamDates(theEntity,theResource);
      uriParams=extractSearchParamUri(theEntity,theResource);
      coordsParams=extractSearchParamCoords(theEntity,theResource);
      ourLog.trace(""String_Node_Str"",stringParams);
      tokenParams=new HashSet<ResourceIndexedSearchParamToken>();
      for (      BaseResourceIndexedSearchParam next : extractSearchParamTokens(theEntity,theResource)) {
        if (next instanceof ResourceIndexedSearchParamToken) {
          tokenParams.add((ResourceIndexedSearchParamToken)next);
        }
 else {
          stringParams.add((ResourceIndexedSearchParamString)next);
        }
      }
      if (myConfig.isAllowInlineMatchUrlReferences()) {
        FhirTerser terser=getContext().newTerser();
        List<IBaseReference> allRefs=terser.getAllPopulatedChildElementsOfType(theResource,IBaseReference.class);
        for (        IBaseReference nextRef : allRefs) {
          IIdType nextId=nextRef.getReferenceElement();
          String nextIdText=nextId.getValue();
          int qmIndex=nextIdText.indexOf('?');
          if (qmIndex != -1) {
            for (int i=qmIndex - 1; i >= 0; i--) {
              if (nextIdText.charAt(i) == '/') {
                nextIdText=nextIdText.substring(i + 1);
                break;
              }
            }
            String resourceTypeString=nextIdText.substring(0,nextIdText.indexOf('?'));
            RuntimeResourceDefinition matchResourceDef=getContext().getResourceDefinition(resourceTypeString);
            if (matchResourceDef == null) {
              String msg=getContext().getLocalizer().getMessage(BaseHapiFhirDao.class,""String_Node_Str"",nextId.getValue(),resourceTypeString);
              throw new InvalidRequestException(msg);
            }
            Class<? extends IBaseResource> matchResourceType=matchResourceDef.getImplementingClass();
            Set<Long> matches=processMatchUrl(nextIdText,matchResourceType);
            if (matches.isEmpty()) {
              String msg=getContext().getLocalizer().getMessage(BaseHapiFhirDao.class,""String_Node_Str"",nextId.getValue());
              throw new InvalidRequestException(msg);
            }
            if (matches.size() > 1) {
              String msg=getContext().getLocalizer().getMessage(BaseHapiFhirDao.class,""String_Node_Str"",nextId.getValue());
              throw new InvalidRequestException(msg);
            }
            Long next=matches.iterator().next();
            String newId=resourceTypeString + '/' + translatePidIdToForcedId(next);
            ourLog.info(""String_Node_Str"",nextId.getValue(),newId);
            nextRef.setReference(newId);
          }
        }
      }
      links=extractResourceLinks(theEntity,theResource);
      for (Iterator<ResourceLink> existingLinkIter=existingResourceLinks.iterator(); existingLinkIter.hasNext(); ) {
        ResourceLink nextExisting=existingLinkIter.next();
        if (links.remove(nextExisting)) {
          existingLinkIter.remove();
          links.add(nextExisting);
        }
      }
      populateResourceIntoEntity(theResource,theEntity);
      theEntity.setUpdated(theUpdateTime);
      if (theResource instanceof IResource) {
        theEntity.setLanguage(((IResource)theResource).getLanguage().getValue());
      }
 else {
        theEntity.setLanguage(((IAnyResource)theResource).getLanguageElement().getValue());
      }
      theEntity.setParamsString(stringParams);
      theEntity.setParamsStringPopulated(stringParams.isEmpty() == false);
      theEntity.setParamsToken(tokenParams);
      theEntity.setParamsTokenPopulated(tokenParams.isEmpty() == false);
      theEntity.setParamsNumber(numberParams);
      theEntity.setParamsNumberPopulated(numberParams.isEmpty() == false);
      theEntity.setParamsQuantity(quantityParams);
      theEntity.setParamsQuantityPopulated(quantityParams.isEmpty() == false);
      theEntity.setParamsDate(dateParams);
      theEntity.setParamsDatePopulated(dateParams.isEmpty() == false);
      theEntity.setParamsUri(uriParams);
      theEntity.setParamsUriPopulated(uriParams.isEmpty() == false);
      theEntity.setParamsCoords(coordsParams);
      theEntity.setParamsCoordsPopulated(coordsParams.isEmpty() == false);
      theEntity.setResourceLinks(links);
      theEntity.setHasLinks(links.isEmpty() == false);
      theEntity.setIndexStatus(INDEX_STATUS_INDEXED);
      theEntity.setNarrativeTextParsedIntoWords(parseNarrativeTextIntoWords(theResource));
      theEntity.setContentTextParsedIntoWords(parseContentTextIntoWords(theResource));
    }
 else {
      populateResourceIntoEntity(theResource,theEntity);
      theEntity.setUpdated(theUpdateTime);
      theEntity.setIndexStatus(null);
    }
  }
  if (theEntity.getId() == null) {
    myEntityManager.persist(theEntity);
    if (theEntity.getForcedId() != null) {
      myEntityManager.persist(theEntity.getForcedId());
    }
    postPersist(theEntity,(T)theResource);
  }
 else {
    theEntity=myEntityManager.merge(theEntity);
    postUpdate(theEntity,(T)theResource);
  }
  if (thePerformIndexing) {
    for (    ResourceIndexedSearchParamString next : paramsString) {
      myEntityManager.remove(next);
    }
    for (    ResourceIndexedSearchParamString next : stringParams) {
      myEntityManager.persist(next);
    }
    for (    ResourceIndexedSearchParamToken next : paramsToken) {
      myEntityManager.remove(next);
    }
    for (    ResourceIndexedSearchParamToken next : tokenParams) {
      myEntityManager.persist(next);
    }
    for (    ResourceIndexedSearchParamNumber next : paramsNumber) {
      myEntityManager.remove(next);
    }
    for (    ResourceIndexedSearchParamNumber next : numberParams) {
      myEntityManager.persist(next);
    }
    for (    ResourceIndexedSearchParamQuantity next : paramsQuantity) {
      myEntityManager.remove(next);
    }
    for (    ResourceIndexedSearchParamQuantity next : quantityParams) {
      myEntityManager.persist(next);
    }
    for (    ResourceIndexedSearchParamDate next : paramsDate) {
      myEntityManager.remove(next);
    }
    for (    ResourceIndexedSearchParamDate next : dateParams) {
      myEntityManager.persist(next);
    }
    for (    ResourceIndexedSearchParamUri next : paramsUri) {
      myEntityManager.remove(next);
    }
    for (    ResourceIndexedSearchParamUri next : uriParams) {
      myEntityManager.persist(next);
    }
    for (    ResourceIndexedSearchParamCoords next : paramsCoords) {
      myEntityManager.remove(next);
    }
    for (    ResourceIndexedSearchParamCoords next : coordsParams) {
      myEntityManager.persist(next);
    }
    for (    ResourceLink next : existingResourceLinks) {
      myEntityManager.remove(next);
    }
    for (    ResourceLink next : links) {
      myEntityManager.persist(next);
    }
  }
  theEntity=myEntityManager.merge(theEntity);
  myEntityManager.flush();
  if (theResource != null) {
    populateResourceId(theResource,theEntity);
  }
  return theEntity;
}",0.0392571076489745
112276,"@Override @SuppressWarnings(""String_Node_Str"") public <R extends IBaseResource>R toResource(Class<R> theResourceType,BaseHasResource theEntity,boolean theForHistoryOperation){
  String resourceText=null;
switch (theEntity.getEncoding()) {
case JSON:
    try {
      resourceText=new String(theEntity.getResource(),""String_Node_Str"");
    }
 catch (    UnsupportedEncodingException e) {
      throw new Error(""String_Node_Str"",e);
    }
  break;
case JSONC:
resourceText=GZipUtil.decompress(theEntity.getResource());
break;
}
IParser parser=theEntity.getEncoding().newParser(getContext(theEntity.getFhirVersion()));
R retVal;
try {
retVal=parser.parseResource(theResourceType,resourceText);
}
 catch (Exception e) {
StringBuilder b=new StringBuilder();
b.append(""String_Node_Str"");
b.append(theResourceType);
b.append(""String_Node_Str"");
b.append(theEntity.getIdDt().getIdPart());
b.append(""String_Node_Str"");
b.append(theEntity.getId());
b.append(""String_Node_Str"");
b.append(myContext.getVersion().getVersion());
b.append(""String_Node_Str"");
b.append(e.getMessage());
String msg=b.toString();
ourLog.error(msg,e);
throw new DataFormatException(msg,e);
}
if (retVal instanceof IResource) {
IResource res=(IResource)retVal;
retVal=populateResourceMetadataHapi(theResourceType,theEntity,theForHistoryOperation,res);
}
 else {
IAnyResource res=(IAnyResource)retVal;
retVal=populateResourceMetadataRi(theResourceType,theEntity,theForHistoryOperation,res);
}
return retVal;
}","@Override public <R extends IBaseResource>R toResource(Class<R> theResourceType,BaseHasResource theEntity,boolean theForHistoryOperation){
  String resourceText=null;
switch (theEntity.getEncoding()) {
case JSON:
    try {
      resourceText=new String(theEntity.getResource(),""String_Node_Str"");
    }
 catch (    UnsupportedEncodingException e) {
      throw new Error(""String_Node_Str"",e);
    }
  break;
case JSONC:
resourceText=GZipUtil.decompress(theEntity.getResource());
break;
}
IParser parser=theEntity.getEncoding().newParser(getContext(theEntity.getFhirVersion()));
R retVal;
try {
retVal=parser.parseResource(theResourceType,resourceText);
}
 catch (Exception e) {
StringBuilder b=new StringBuilder();
b.append(""String_Node_Str"");
b.append(theResourceType);
b.append(""String_Node_Str"");
b.append(theEntity.getIdDt().getIdPart());
b.append(""String_Node_Str"");
b.append(theEntity.getId());
b.append(""String_Node_Str"");
b.append(myContext.getVersion().getVersion());
b.append(""String_Node_Str"");
b.append(e.getMessage());
String msg=b.toString();
ourLog.error(msg,e);
throw new DataFormatException(msg,e);
}
if (retVal instanceof IResource) {
IResource res=(IResource)retVal;
retVal=populateResourceMetadataHapi(theResourceType,theEntity,theForHistoryOperation,res);
}
 else {
IAnyResource res=(IAnyResource)retVal;
retVal=populateResourceMetadataRi(theResourceType,theEntity,theForHistoryOperation,res);
}
return retVal;
}",0.9872545642438856
112277,"/** 
 * Subclasses may override to provide behaviour. Called when a resource has been inserved into the database for the first time.
 * @param theEntity The entity being updated (Do not modify the entity! Undefined behaviour will occur!)
 * @param theTag The tag
 * @return Returns <code>true</code> if the tag should be removed
 * @see <a href=""http://hl7.org/fhir/2015Sep/resource.html#1.11.3.7"">Updates to Tags, Profiles, and Security Labels</a> for a description of the logic that the default behaviour folows.
 */
protected void postPersist(ResourceTable theEntity,T theResource){
}","/** 
 * Subclasses may override to provide behaviour. Called when a resource has been inserved into the database for the first time.
 * @param theEntity The entity being updated (Do not modify the entity! Undefined behaviour will occur!)
 * @param theTag The tag
 * @return Returns <code>true</code> if the tag should be removed
 * @see <a href=""http://hl7.org/fhir/2015Sep/resource.html#1.11.3.7"">Updates to Tags, Profiles, and Security Labels</a> for a description of the logic that the default behaviour folows.
 */
@SuppressWarnings(""String_Node_Str"") protected void postPersist(ResourceTable theEntity,T theResource){
}",0.9694467382328654
112278,"public BaseHasResource readEntity(IIdType theValueId){
  throw new NotImplementedException(""String_Node_Str"");
}","@SuppressWarnings(""String_Node_Str"") @CoverageIgnore public BaseHasResource readEntity(IIdType theValueId){
  throw new NotImplementedException(""String_Node_Str"");
}",0.8086642599277978
112279,"@Test public void testIndexContained(){
  Patient p=new Patient();
  p.setId(""String_Node_Str"");
  p.addName().addFamily(""String_Node_Str"").addGiven(""String_Node_Str"");
  Observation o1=new Observation();
  o1.getCode().setText(""String_Node_Str"");
  o1.setSubject(new Reference(p));
  IIdType oid1=myObservationDao.create(o1).getId().toUnqualifiedVersionless();
  Observation o2=new Observation();
  o2.getCode().setText(""String_Node_Str"");
  o2.setSubject(new Reference(p));
  IIdType oid2=myObservationDao.create(o2).getId().toUnqualifiedVersionless();
  Patient p2=new Patient();
  p2.addName().addFamily(""String_Node_Str"").addGiven(""String_Node_Str"");
  IIdType pid2=myPatientDao.create(p2).getId().toUnqualifiedVersionless();
  ourLog.info(myFhirCtx.newXmlParser().setPrettyPrint(true).encodeResourceToString(o2));
  SearchParameterMap map;
}","@Test public void testIndexContained(){
  Patient p=new Patient();
  p.setId(""String_Node_Str"");
  p.addName().addFamily(""String_Node_Str"").addGiven(""String_Node_Str"");
  Observation o1=new Observation();
  o1.getCode().setText(""String_Node_Str"");
  o1.setSubject(new Reference(p));
  IIdType oid1=myObservationDao.create(o1,new ServletRequestDetails()).getId().toUnqualifiedVersionless();
  Observation o2=new Observation();
  o2.getCode().setText(""String_Node_Str"");
  o2.setSubject(new Reference(p));
  IIdType oid2=myObservationDao.create(o2,new ServletRequestDetails()).getId().toUnqualifiedVersionless();
  Patient p2=new Patient();
  p2.addName().addFamily(""String_Node_Str"").addGiven(""String_Node_Str"");
  IIdType pid2=myPatientDao.create(p2,new ServletRequestDetails()).getId().toUnqualifiedVersionless();
  ourLog.info(myFhirCtx.newXmlParser().setPrettyPrint(true).encodeResourceToString(o2));
  SearchParameterMap map;
}",0.952755905511811
112280,"@Test public void testSimpleResourceEncodeWithCustomType() throws IOException {
  FhirContext fhirCtx=new FhirContext(MyPatientWithExtensions.class);
  String xmlString=IOUtils.toString(JsonParser.class.getResourceAsStream(""String_Node_Str""),Charset.forName(""String_Node_Str""));
  MyPatientWithExtensions obs=fhirCtx.newXmlParser().parseResource(MyPatientWithExtensions.class,xmlString);
  assertEquals(0,obs.getAllUndeclaredExtensions().size());
  assertEquals(""String_Node_Str"",obs.getExtAtt().getContentType().getValue());
  assertEquals(""String_Node_Str"",obs.getMoreExt().getStr1().getValue());
  assertEquals(""String_Node_Str"",obs.getModExt().getValueAsString());
  List<ExtensionDt> undeclaredExtensions=obs.getContact().get(0).getName().getFamily().get(0).getUndeclaredExtensions();
  ExtensionDt undeclaredExtension=undeclaredExtensions.get(0);
  assertEquals(""String_Node_Str"",undeclaredExtension.getUrl());
  IParser jsonParser=fhirCtx.newJsonParser().setPrettyPrint(true);
  String encoded=jsonParser.encodeResourceToString(obs);
  ourLog.info(encoded);
  String jsonString=IOUtils.toString(JsonParser.class.getResourceAsStream(""String_Node_Str""),Charset.forName(""String_Node_Str""));
  JSON expected=JSONSerializer.toJSON(jsonString);
  JSON actual=JSONSerializer.toJSON(encoded.trim());
  String exp=expected.toString().replace(""String_Node_Str"",""String_Node_Str"");
  String act=actual.toString();
  ourLog.info(""String_Node_Str"",exp);
  ourLog.info(""String_Node_Str"",act);
  assertEquals(exp,act);
}","@Test public void testSimpleResourceEncodeWithCustomType() throws IOException {
  FhirContext fhirCtx=new FhirContext(MyPatientWithExtensions.class);
  String xmlString=IOUtils.toString(JsonParser.class.getResourceAsStream(""String_Node_Str""),Charset.forName(""String_Node_Str""));
  MyPatientWithExtensions obs=fhirCtx.newXmlParser().parseResource(MyPatientWithExtensions.class,xmlString);
  assertEquals(0,obs.getAllUndeclaredExtensions().size());
  assertEquals(""String_Node_Str"",obs.getExtAtt().getContentType().getValue());
  assertEquals(""String_Node_Str"",obs.getMoreExt().getStr1().getValue());
  assertEquals(""String_Node_Str"",obs.getModExt().getValueAsString());
  List<ExtensionDt> undeclaredExtensions=obs.getContact().get(0).getName().getFamily().get(0).getUndeclaredExtensions();
  ExtensionDt undeclaredExtension=undeclaredExtensions.get(0);
  assertEquals(""String_Node_Str"",undeclaredExtension.getUrl());
  IParser jsonParser=fhirCtx.newJsonParser().setPrettyPrint(true);
  String encoded=jsonParser.encodeResourceToString(obs);
  ourLog.info(encoded);
  String jsonString=IOUtils.toString(JsonParser.class.getResourceAsStream(""String_Node_Str""),Charset.forName(""String_Node_Str""));
  JSON expected=JSONSerializer.toJSON(jsonString);
  JSON actual=JSONSerializer.toJSON(encoded.trim());
  String exp=expected.toString().replace(""String_Node_Str"",""String_Node_Str"");
  String act=actual.toString();
  ourLog.info(""String_Node_Str"",exp);
  ourLog.info(""String_Node_Str"",act);
  assertEquals(""String_Node_Str"" + exp + ""String_Node_Str""+ act,exp,act);
}",0.9840546697038725
112281,"@Test public void testSimpleResourceEncode() throws IOException {
  String xmlString=IOUtils.toString(JsonParser.class.getResourceAsStream(""String_Node_Str""),Charset.forName(""String_Node_Str""));
  Patient obs=ourCtx.newXmlParser().parseResource(Patient.class,xmlString);
  List<ExtensionDt> undeclaredExtensions=obs.getContact().get(0).getName().getFamily().get(0).getUndeclaredExtensions();
  ExtensionDt undeclaredExtension=undeclaredExtensions.get(0);
  assertEquals(""String_Node_Str"",undeclaredExtension.getUrl());
  assertEquals(""String_Node_Str"",((CodeDt)undeclaredExtension.getValue()).getValue());
  ourCtx.newJsonParser().setPrettyPrint(true).encodeResourceToWriter(obs,new OutputStreamWriter(System.out));
  IParser jsonParser=ourCtx.newJsonParser();
  String encoded=jsonParser.encodeResourceToString(obs);
  ourLog.info(encoded);
  String jsonString=IOUtils.toString(JsonParser.class.getResourceAsStream(""String_Node_Str""),Charset.forName(""String_Node_Str""));
  JSON expected=JSONSerializer.toJSON(jsonString);
  JSON actual=JSONSerializer.toJSON(encoded.trim());
  String exp=expected.toString().replace(""String_Node_Str"",""String_Node_Str"");
  String act=actual.toString();
  ourLog.info(""String_Node_Str"",exp);
  ourLog.info(""String_Node_Str"",act);
  assertEquals(""String_Node_Str"" + exp + ""String_Node_Str""+ act,exp,act);
}","@Test public void testSimpleResourceEncode() throws IOException {
  String xmlString=IOUtils.toString(JsonParser.class.getResourceAsStream(""String_Node_Str""),Charset.forName(""String_Node_Str""));
  IParser parser=ourCtx.newXmlParser();
  parser.setParserErrorHandler(new StrictErrorHandler());
  Patient obs=parser.parseResource(Patient.class,xmlString);
  List<ExtensionDt> undeclaredExtensions=obs.getContact().get(0).getName().getFamily().get(0).getUndeclaredExtensions();
  ExtensionDt undeclaredExtension=undeclaredExtensions.get(0);
  assertEquals(""String_Node_Str"",undeclaredExtension.getUrl());
  assertEquals(""String_Node_Str"",((CodeDt)undeclaredExtension.getValue()).getValue());
  ourCtx.newJsonParser().setPrettyPrint(true).encodeResourceToWriter(obs,new OutputStreamWriter(System.out));
  IParser jsonParser=ourCtx.newJsonParser();
  String encoded=jsonParser.encodeResourceToString(obs);
  ourLog.info(encoded);
  String jsonString=IOUtils.toString(JsonParser.class.getResourceAsStream(""String_Node_Str""),Charset.forName(""String_Node_Str""));
  JSON expected=JSONSerializer.toJSON(jsonString);
  JSON actual=JSONSerializer.toJSON(encoded.trim());
  String exp=expected.toString().replace(""String_Node_Str"",""String_Node_Str"");
  String act=actual.toString();
  ourLog.info(""String_Node_Str"",exp);
  ourLog.info(""String_Node_Str"",act);
  assertEquals(""String_Node_Str"" + exp + ""String_Node_Str""+ act,exp,act);
}",0.96339253352664
112282,"@Override public void execute() throws MojoExecutionException, MojoFailureException {
  FhirContext fhirContext;
  if (""String_Node_Str"".equals(version)) {
    fhirContext=FhirContext.forDstu1();
  }
 else   if (""String_Node_Str"".equals(version)) {
    fhirContext=FhirContext.forDstu2();
  }
 else   if (""String_Node_Str"".equals(version)) {
    fhirContext=FhirContext.forDstu2_1();
  }
 else   if (""String_Node_Str"".equals(version)) {
    fhirContext=FhirContext.forDev();
  }
 else {
    throw new MojoFailureException(""String_Node_Str"" + version);
  }
  if (baseResourceNames == null || baseResourceNames.isEmpty()) {
    baseResourceNames=new ArrayList<String>();
    ourLog.info(""String_Node_Str"",fhirContext.getVersion().getVersion());
    Properties p=new Properties();
    try {
      p.load(fhirContext.getVersion().getFhirVersionPropertiesFile());
    }
 catch (    IOException e) {
      throw new MojoFailureException(""String_Node_Str"",e);
    }
    ourLog.debug(""String_Node_Str"",p);
    TreeSet<String> keys=new TreeSet<String>();
    for (    Object next : p.keySet()) {
      keys.add((String)next);
    }
    for (    String next : keys) {
      if (next.startsWith(""String_Node_Str"")) {
        baseResourceNames.add(next.substring(""String_Node_Str"".length()).toLowerCase());
      }
    }
  }
  for (int i=0; i < baseResourceNames.size(); i++) {
    baseResourceNames.set(i,baseResourceNames.get(i).toLowerCase());
  }
  if (excludeResourceNames != null) {
    for (int i=0; i < excludeResourceNames.size(); i++) {
      excludeResourceNames.set(i,excludeResourceNames.get(i).toLowerCase());
    }
    baseResourceNames.removeAll(excludeResourceNames);
  }
  ourLog.info(""String_Node_Str"",baseResourceNames);
  File configPackageDirectoryBase=new File(targetDirectory,configPackageBase.replace(""String_Node_Str"",File.separatorChar + ""String_Node_Str""));
  configPackageDirectoryBase.mkdirs();
  File packageDirectoryBase=new File(targetDirectory,packageBase.replace(""String_Node_Str"",File.separatorChar + ""String_Node_Str""));
  packageDirectoryBase.mkdirs();
  ResourceGeneratorUsingSpreadsheet gen=new ResourceGeneratorUsingSpreadsheet(version,baseDir);
  gen.setBaseResourceNames(baseResourceNames);
  try {
    gen.parse();
    gen.setFilenameSuffix(""String_Node_Str"");
    gen.setTemplate(""String_Node_Str"");
    gen.writeAll(packageDirectoryBase,null,packageBase);
  }
 catch (  Exception e) {
    throw new MojoFailureException(""String_Node_Str"",e);
  }
  myProject.addCompileSourceRoot(targetDirectory.getAbsolutePath());
  try {
    VelocityContext ctx=new VelocityContext();
    ctx.put(""String_Node_Str"",gen.getResources());
    ctx.put(""String_Node_Str"",packageBase);
    ctx.put(""String_Node_Str"",configPackageBase);
    ctx.put(""String_Node_Str"",version);
    ctx.put(""String_Node_Str"",new EscapeTool());
    String capitalize=WordUtils.capitalize(version);
    if (""String_Node_Str"".equals(capitalize)) {
      capitalize=""String_Node_Str"";
    }
    ctx.put(""String_Node_Str"",capitalize);
    VelocityEngine v=new VelocityEngine();
    v.setProperty(""String_Node_Str"",""String_Node_Str"");
    v.setProperty(""String_Node_Str"",""String_Node_Str"");
    v.setProperty(""String_Node_Str"",Boolean.TRUE);
    InputStream templateIs=ResourceGeneratorUsingSpreadsheet.class.getResourceAsStream(""String_Node_Str"");
    InputStreamReader templateReader=new InputStreamReader(templateIs);
    targetResourceDirectory.mkdirs();
    File f=new File(targetResourceDirectory,targetResourceSpringBeansFile);
    OutputStreamWriter w=new OutputStreamWriter(new FileOutputStream(f,false),""String_Node_Str"");
    v.evaluate(ctx,w,""String_Node_Str"",templateReader);
    w.close();
    Resource resource=new Resource();
    resource.setDirectory(targetResourceDirectory.getAbsolutePath());
    resource.addInclude(targetResourceSpringBeansFile);
    myProject.addResource(resource);
    templateIs=ResourceGeneratorUsingSpreadsheet.class.getResourceAsStream(""String_Node_Str"");
    templateReader=new InputStreamReader(templateIs);
    f=new File(configPackageDirectoryBase,""String_Node_Str"" + capitalize + ""String_Node_Str"");
    w=new OutputStreamWriter(new FileOutputStream(f,false),""String_Node_Str"");
    v.evaluate(ctx,w,""String_Node_Str"",templateReader);
    w.close();
  }
 catch (  Exception e) {
    throw new MojoFailureException(""String_Node_Str"",e);
  }
}","@Override public void execute() throws MojoExecutionException, MojoFailureException {
  FhirContext fhirContext;
  if (""String_Node_Str"".equals(version)) {
    fhirContext=FhirContext.forDstu1();
  }
 else   if (""String_Node_Str"".equals(version)) {
    fhirContext=FhirContext.forDstu2();
  }
 else   if (""String_Node_Str"".equals(version)) {
    fhirContext=FhirContext.forDstu2_1();
  }
 else {
    throw new MojoFailureException(""String_Node_Str"" + version);
  }
  if (baseResourceNames == null || baseResourceNames.isEmpty()) {
    baseResourceNames=new ArrayList<String>();
    ourLog.info(""String_Node_Str"",fhirContext.getVersion().getVersion());
    Properties p=new Properties();
    try {
      p.load(fhirContext.getVersion().getFhirVersionPropertiesFile());
    }
 catch (    IOException e) {
      throw new MojoFailureException(""String_Node_Str"",e);
    }
    ourLog.debug(""String_Node_Str"",p);
    TreeSet<String> keys=new TreeSet<String>();
    for (    Object next : p.keySet()) {
      keys.add((String)next);
    }
    for (    String next : keys) {
      if (next.startsWith(""String_Node_Str"")) {
        baseResourceNames.add(next.substring(""String_Node_Str"".length()).toLowerCase());
      }
    }
  }
  for (int i=0; i < baseResourceNames.size(); i++) {
    baseResourceNames.set(i,baseResourceNames.get(i).toLowerCase());
  }
  if (excludeResourceNames != null) {
    for (int i=0; i < excludeResourceNames.size(); i++) {
      excludeResourceNames.set(i,excludeResourceNames.get(i).toLowerCase());
    }
    baseResourceNames.removeAll(excludeResourceNames);
  }
  ourLog.info(""String_Node_Str"",baseResourceNames);
  File configPackageDirectoryBase=new File(targetDirectory,configPackageBase.replace(""String_Node_Str"",File.separatorChar + ""String_Node_Str""));
  configPackageDirectoryBase.mkdirs();
  File packageDirectoryBase=new File(targetDirectory,packageBase.replace(""String_Node_Str"",File.separatorChar + ""String_Node_Str""));
  packageDirectoryBase.mkdirs();
  ResourceGeneratorUsingSpreadsheet gen=new ResourceGeneratorUsingSpreadsheet(version,baseDir);
  gen.setBaseResourceNames(baseResourceNames);
  try {
    gen.parse();
    gen.setFilenameSuffix(""String_Node_Str"");
    gen.setTemplate(""String_Node_Str"");
    gen.writeAll(packageDirectoryBase,null,packageBase);
  }
 catch (  Exception e) {
    throw new MojoFailureException(""String_Node_Str"",e);
  }
  myProject.addCompileSourceRoot(targetDirectory.getAbsolutePath());
  try {
    VelocityContext ctx=new VelocityContext();
    ctx.put(""String_Node_Str"",gen.getResources());
    ctx.put(""String_Node_Str"",packageBase);
    ctx.put(""String_Node_Str"",configPackageBase);
    ctx.put(""String_Node_Str"",version);
    ctx.put(""String_Node_Str"",new EscapeTool());
    String capitalize=WordUtils.capitalize(version);
    if (""String_Node_Str"".equals(capitalize)) {
      capitalize=""String_Node_Str"";
    }
    ctx.put(""String_Node_Str"",capitalize);
    VelocityEngine v=new VelocityEngine();
    v.setProperty(""String_Node_Str"",""String_Node_Str"");
    v.setProperty(""String_Node_Str"",""String_Node_Str"");
    v.setProperty(""String_Node_Str"",Boolean.TRUE);
    InputStream templateIs=ResourceGeneratorUsingSpreadsheet.class.getResourceAsStream(""String_Node_Str"");
    InputStreamReader templateReader=new InputStreamReader(templateIs);
    targetResourceDirectory.mkdirs();
    File f=new File(targetResourceDirectory,targetResourceSpringBeansFile);
    OutputStreamWriter w=new OutputStreamWriter(new FileOutputStream(f,false),""String_Node_Str"");
    v.evaluate(ctx,w,""String_Node_Str"",templateReader);
    w.close();
    Resource resource=new Resource();
    resource.setDirectory(targetResourceDirectory.getAbsolutePath());
    resource.addInclude(targetResourceSpringBeansFile);
    myProject.addResource(resource);
    templateIs=ResourceGeneratorUsingSpreadsheet.class.getResourceAsStream(""String_Node_Str"");
    templateReader=new InputStreamReader(templateIs);
    f=new File(configPackageDirectoryBase,""String_Node_Str"" + capitalize + ""String_Node_Str"");
    w=new OutputStreamWriter(new FileOutputStream(f,false),""String_Node_Str"");
    v.evaluate(ctx,w,""String_Node_Str"",templateReader);
    w.close();
  }
 catch (  Exception e) {
    throw new MojoFailureException(""String_Node_Str"",e);
  }
}",0.9894979803808424
112283,"private int pollForNewUndeliveredResources(SubscriptionTable theSubscriptionTable){
  Subscription subscription=toResource(Subscription.class,theSubscriptionTable.getSubscriptionResource(),false);
  RuntimeResourceDefinition resourceDef=validateCriteriaAndReturnResourceDefinition(subscription);
  SearchParameterMap criteriaUrl=translateMatchUrl(subscription.getCriteria(),resourceDef);
  criteriaUrl=new SearchParameterMap();
  long start=theSubscriptionTable.getMostRecentMatch().getTime();
  long end=System.currentTimeMillis() - getConfig().getSubscriptionPollDelay();
  if (end <= start) {
    ourLog.trace(""String_Node_Str"");
    return 0;
  }
  ourLog.debug(""String_Node_Str"",new Object[]{subscription.getId().getIdPart(),new InstantDt(new Date(start)),new InstantDt(new Date(end))});
  DateRangeParam range=new DateRangeParam();
  range.setLowerBound(new DateParam(QuantityCompararatorEnum.GREATERTHAN,start));
  range.setUpperBound(new DateParam(QuantityCompararatorEnum.LESSTHAN,end));
  criteriaUrl.setLastUpdated(range);
  criteriaUrl.setSort(new SortSpec(Constants.PARAM_LASTUPDATED,SortOrderEnum.ASC));
  IFhirResourceDao<? extends IBaseResource> dao=getDao(resourceDef.getImplementingClass());
  IBundleProvider results=dao.search(criteriaUrl);
  if (results.size() == 0) {
    return 0;
  }
  ourLog.info(""String_Node_Str"",results.size(),subscription.getId().getIdPart());
  List<SubscriptionFlaggedResource> flags=new ArrayList<SubscriptionFlaggedResource>();
  Date mostRecentMatch=null;
  for (  IBaseResource next : results.getResources(0,results.size())) {
    Date updated=ResourceMetadataKeyEnum.PUBLISHED.get((IResource)next).getValue();
    if (mostRecentMatch == null) {
      mostRecentMatch=updated;
    }
 else {
      long mostRecentMatchTime=mostRecentMatch.getTime();
      long updatedTime=updated.getTime();
      if (mostRecentMatchTime < updatedTime) {
        mostRecentMatch=updated;
      }
    }
    SubscriptionFlaggedResource nextFlag=new SubscriptionFlaggedResource();
    Long pid=IDao.RESOURCE_PID.get((IResource)next);
    nextFlag.setResource(myEntityManager.find(ResourceTable.class,pid));
    nextFlag.setSubscription(theSubscriptionTable);
    nextFlag.setVersion(next.getIdElement().getVersionIdPartAsLong());
    flags.add(nextFlag);
  }
  mySubscriptionFlaggedResourceDataDao.save(flags);
  ourLog.debug(""String_Node_Str"",subscription.getId().getIdPart(),new InstantDt(mostRecentMatch));
  theSubscriptionTable.setMostRecentMatch(mostRecentMatch);
  myEntityManager.merge(theSubscriptionTable);
  return results.size();
}","private int pollForNewUndeliveredResources(SubscriptionTable theSubscriptionTable){
  Subscription subscription=toResource(Subscription.class,theSubscriptionTable.getSubscriptionResource(),false);
  RuntimeResourceDefinition resourceDef=validateCriteriaAndReturnResourceDefinition(subscription);
  SearchParameterMap criteriaUrl=translateMatchUrl(subscription.getCriteria(),resourceDef);
  criteriaUrl=new SearchParameterMap();
  long start=theSubscriptionTable.getMostRecentMatch().getTime();
  long end=System.currentTimeMillis() - getConfig().getSubscriptionPollDelay();
  if (end <= start) {
    ourLog.trace(""String_Node_Str"");
    return 0;
  }
  ourLog.debug(""String_Node_Str"",new Object[]{subscription.getId().getIdPart(),new InstantDt(new Date(start)),new InstantDt(new Date(end))});
  DateRangeParam range=new DateRangeParam();
  range.setLowerBound(new DateParam(QuantityCompararatorEnum.GREATERTHAN,start));
  range.setUpperBound(new DateParam(QuantityCompararatorEnum.LESSTHAN,end));
  criteriaUrl.setLastUpdated(range);
  criteriaUrl.setSort(new SortSpec(Constants.PARAM_LASTUPDATED,SortOrderEnum.ASC));
  IFhirResourceDao<? extends IBaseResource> dao=getDao(resourceDef.getImplementingClass());
  IBundleProvider results=dao.search(criteriaUrl);
  if (results.size() == 0) {
    return 0;
  }
  ourLog.info(""String_Node_Str"",results.size(),subscription.getId().getIdPart());
  List<SubscriptionFlaggedResource> flags=new ArrayList<SubscriptionFlaggedResource>();
  Date mostRecentMatch=null;
  for (  IBaseResource next : results.getResources(0,results.size())) {
    Date updated=ResourceMetadataKeyEnum.UPDATED.get((IResource)next).getValue();
    if (mostRecentMatch == null) {
      mostRecentMatch=updated;
    }
 else {
      long mostRecentMatchTime=mostRecentMatch.getTime();
      long updatedTime=updated.getTime();
      if (mostRecentMatchTime < updatedTime) {
        mostRecentMatch=updated;
      }
    }
    SubscriptionFlaggedResource nextFlag=new SubscriptionFlaggedResource();
    Long pid=IDao.RESOURCE_PID.get((IResource)next);
    ourLog.info(""String_Node_Str"",pid);
    nextFlag.setResource(myEntityManager.find(ResourceTable.class,pid));
    nextFlag.setSubscription(theSubscriptionTable);
    nextFlag.setVersion(next.getIdElement().getVersionIdPartAsLong());
    flags.add(nextFlag);
  }
  mySubscriptionFlaggedResourceDataDao.save(flags);
  ourLog.debug(""String_Node_Str"",subscription.getId().getIdPart(),new InstantDt(mostRecentMatch));
  theSubscriptionTable.setMostRecentMatch(mostRecentMatch);
  mySubscriptionTableDao.save(theSubscriptionTable);
  return results.size();
}",0.9822872545244512
112284,"@Override protected String encode(List<XMLEvent> theValue){
  try {
    StringWriter w=new StringWriter();
    XMLEventWriter ew=XmlUtil.createXmlWriter(w);
    for (    XMLEvent next : getValue()) {
      if (next.isCharacters()) {
        ew.add(next);
      }
 else {
        ew.add(next);
      }
    }
    ew.close();
    return w.toString();
  }
 catch (  XMLStreamException e) {
    throw new DataFormatException(""String_Node_Str"",e);
  }
catch (  FactoryConfigurationError e) {
    throw new ConfigurationException(e);
  }
}","@Override protected String encode(List<XMLEvent> theValue){
  try {
    StringWriter w=new StringWriter();
    XMLEventWriter ew=XmlUtil.createXmlFragmentWriter(w);
    for (    XMLEvent next : getValue()) {
      if (next.isCharacters()) {
        ew.add(next);
      }
 else {
        ew.add(next);
      }
    }
    ew.close();
    return w.toString();
  }
 catch (  XMLStreamException e) {
    throw new DataFormatException(""String_Node_Str"",e);
  }
catch (  FactoryConfigurationError e) {
    throw new ConfigurationException(e);
  }
}",0.9925373134328358
112285,"private IBaseOperationOutcome createOperationOutcome(Throwable theException,FhirContext ctx) throws ServletException {
  IBaseOperationOutcome oo=null;
  if (theException instanceof BaseServerResponseException) {
    oo=((BaseServerResponseException)theException).getOperationOutcome();
  }
  if (oo == null) {
    try {
      oo=OperationOutcomeUtil.newInstance(ctx);
      if (theException instanceof InternalErrorException) {
        ourLog.error(""String_Node_Str"",theException);
        populateDetails(ctx,theException,oo);
      }
 else       if (theException instanceof BaseServerResponseException) {
        ourLog.warn(""String_Node_Str"",theException);
        BaseServerResponseException baseServerResponseException=(BaseServerResponseException)theException;
        populateDetails(ctx,theException,oo);
        if (baseServerResponseException.getAdditionalMessages() != null) {
          for (          String next : baseServerResponseException.getAdditionalMessages()) {
            OperationOutcomeUtil.addIssue(ctx,oo,""String_Node_Str"",next);
          }
        }
      }
 else {
        ourLog.error(""String_Node_Str"" + theException.toString(),theException);
        populateDetails(ctx,theException,oo);
      }
    }
 catch (    Exception e1) {
      ourLog.error(""String_Node_Str"",e1);
      throw new ServletException(""String_Node_Str"",e1);
    }
  }
 else {
    ourLog.error(""String_Node_Str"",theException);
  }
  return oo;
}","private IBaseOperationOutcome createOperationOutcome(Throwable theException,FhirContext ctx) throws ServletException {
  IBaseOperationOutcome oo=null;
  if (theException instanceof BaseServerResponseException) {
    oo=((BaseServerResponseException)theException).getOperationOutcome();
  }
  if (oo == null) {
    try {
      oo=OperationOutcomeUtil.newInstance(ctx);
      if (theException instanceof InternalErrorException) {
        ourLog.error(""String_Node_Str"",theException);
        populateDetails(ctx,theException,oo);
      }
 else       if (theException instanceof BaseServerResponseException) {
        int statusCode=((BaseServerResponseException)theException).getStatusCode();
        if (statusCode < 500) {
          ourLog.warn(""String_Node_Str"",theException.toString());
        }
 else {
          ourLog.warn(""String_Node_Str"",theException);
        }
        BaseServerResponseException baseServerResponseException=(BaseServerResponseException)theException;
        populateDetails(ctx,theException,oo);
        if (baseServerResponseException.getAdditionalMessages() != null) {
          for (          String next : baseServerResponseException.getAdditionalMessages()) {
            OperationOutcomeUtil.addIssue(ctx,oo,""String_Node_Str"",next,null,PROCESSING);
          }
        }
      }
 else {
        ourLog.error(""String_Node_Str"" + theException.toString(),theException);
        populateDetails(ctx,theException,oo);
      }
    }
 catch (    Exception e1) {
      ourLog.error(""String_Node_Str"",e1);
      throw new ServletException(""String_Node_Str"",e1);
    }
  }
 else {
    ourLog.error(""String_Node_Str"",theException);
  }
  return oo;
}",0.9269698910954516
112286,"private void populateDetails(FhirContext theCtx,Throwable theException,IBaseOperationOutcome theOo){
  if (myReturnStackTracesForExceptionTypes != null) {
    for (    Class<?> next : myReturnStackTracesForExceptionTypes) {
      if (next.isAssignableFrom(theException.getClass())) {
        String detailsValue=theException.getMessage() + ""String_Node_Str"" + ExceptionUtils.getStackTrace(theException);
        OperationOutcomeUtil.addIssue(theCtx,theOo,""String_Node_Str"",detailsValue);
        return;
      }
    }
  }
  OperationOutcomeUtil.addIssue(theCtx,theOo,""String_Node_Str"",theException.getMessage());
}","private void populateDetails(FhirContext theCtx,Throwable theException,IBaseOperationOutcome theOo){
  if (myReturnStackTracesForExceptionTypes != null) {
    for (    Class<?> next : myReturnStackTracesForExceptionTypes) {
      if (next.isAssignableFrom(theException.getClass())) {
        String detailsValue=theException.getMessage() + ""String_Node_Str"" + ExceptionUtils.getStackTrace(theException);
        OperationOutcomeUtil.addIssue(theCtx,theOo,""String_Node_Str"",detailsValue,null,PROCESSING);
        return;
      }
    }
  }
  OperationOutcomeUtil.addIssue(theCtx,theOo,""String_Node_Str"",theException.getMessage(),null,PROCESSING);
}",0.9746031746031746
112287,"@Override public String lookup(String theKey){
  if (""String_Node_Str"".equals(theKey)) {
    if (myRequestDetails.getRestOperationType() != null) {
      return myRequestDetails.getRestOperationType().getCode();
    }
    return ""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equals(theKey)) {
    if (myRequestDetails.getRestOperationType() != null) {
switch (myRequestDetails.getRestOperationType()) {
case EXTENDED_OPERATION_INSTANCE:
case EXTENDED_OPERATION_SERVER:
case EXTENDED_OPERATION_TYPE:
        return myRequestDetails.getOperation();
default :
      return ""String_Node_Str"";
  }
}
 else {
  return ""String_Node_Str"";
}
}
 else if (""String_Node_Str"".equals(theKey)) {
if (myRequestDetails.getId() != null) {
  return myRequestDetails.getId().getValue();
}
return ""String_Node_Str"";
}
 else if (""String_Node_Str"".equals(theKey)) {
return StringUtils.defaultString(myRequest.getServletPath());
}
 else if (""String_Node_Str"".equals(theKey)) {
if (myRequestDetails.getId() != null) {
  return myRequestDetails.getId().getValue();
}
if (myRequestDetails.getResourceName() != null) {
  return myRequestDetails.getResourceName();
}
return ""String_Node_Str"";
}
 else if (theKey.equals(""String_Node_Str"")) {
StringBuilder b=new StringBuilder();
for (Entry<String,String[]> next : myRequestDetails.getParameters().entrySet()) {
  for (  String nextValue : next.getValue()) {
    if (b.length() == 0) {
      b.append('?');
    }
 else {
      b.append('&');
    }
    try {
      b.append(URLEncoder.encode(next.getKey(),""String_Node_Str""));
      b.append('=');
      b.append(URLEncoder.encode(nextValue,""String_Node_Str""));
    }
 catch (    UnsupportedEncodingException e) {
      throw new ca.uhn.fhir.context.ConfigurationException(""String_Node_Str"",e);
    }
  }
}
return b.toString();
}
 else if (theKey.startsWith(""String_Node_Str"")) {
String val=myRequest.getHeader(theKey.substring(""String_Node_Str"".length()));
return StringUtils.defaultString(val);
}
 else if (theKey.startsWith(""String_Node_Str"")) {
return StringUtils.defaultString(myRequest.getRemoteAddr());
}
 else if (theKey.equals(""String_Node_Str"")) {
EncodingEnum encoding=RestfulServerUtils.determineResponseEncodingNoDefault(myRequest,myRequestDetails.getServer().getDefaultResponseEncoding());
if (encoding != null) {
  return encoding.name();
}
 else {
  return ""String_Node_Str"";
}
}
return ""String_Node_Str"";
}","@Override public String lookup(String theKey){
  if (""String_Node_Str"".equals(theKey)) {
    if (myRequestDetails.getRestOperationType() != null) {
      return myRequestDetails.getRestOperationType().getCode();
    }
    return ""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equals(theKey)) {
    if (myRequestDetails.getRestOperationType() != null) {
switch (myRequestDetails.getRestOperationType()) {
case EXTENDED_OPERATION_INSTANCE:
case EXTENDED_OPERATION_SERVER:
case EXTENDED_OPERATION_TYPE:
        return myRequestDetails.getOperation();
default :
      return ""String_Node_Str"";
  }
}
 else {
  return ""String_Node_Str"";
}
}
 else if (""String_Node_Str"".equals(theKey)) {
if (myRequestDetails.getId() != null) {
  return myRequestDetails.getId().getValue();
}
return ""String_Node_Str"";
}
 else if (""String_Node_Str"".equals(theKey)) {
return StringUtils.defaultString(myRequest.getServletPath());
}
 else if (""String_Node_Str"".equals(theKey)) {
if (myRequestDetails.getId() != null) {
  return myRequestDetails.getId().getValue();
}
if (myRequestDetails.getResourceName() != null) {
  return myRequestDetails.getResourceName();
}
return ""String_Node_Str"";
}
 else if (theKey.equals(""String_Node_Str"")) {
StringBuilder b=new StringBuilder();
for (Entry<String,String[]> next : myRequestDetails.getParameters().entrySet()) {
  for (  String nextValue : next.getValue()) {
    if (b.length() == 0) {
      b.append('?');
    }
 else {
      b.append('&');
    }
    try {
      b.append(URLEncoder.encode(next.getKey(),""String_Node_Str""));
      b.append('=');
      b.append(URLEncoder.encode(nextValue,""String_Node_Str""));
    }
 catch (    UnsupportedEncodingException e) {
      throw new ca.uhn.fhir.context.ConfigurationException(""String_Node_Str"",e);
    }
  }
}
return b.toString();
}
 else if (theKey.startsWith(""String_Node_Str"")) {
String val=myRequest.getHeader(theKey.substring(""String_Node_Str"".length()));
return StringUtils.defaultString(val);
}
 else if (theKey.startsWith(""String_Node_Str"")) {
return StringUtils.defaultString(myRequest.getRemoteAddr());
}
 else if (theKey.equals(""String_Node_Str"")) {
EncodingEnum encoding=RestfulServerUtils.determineResponseEncodingNoDefault(myRequest,myRequestDetails.getServer().getDefaultResponseEncoding());
if (encoding != null) {
  return encoding.name();
}
 else {
  return ""String_Node_Str"";
}
}
 else if (theKey.equals(""String_Node_Str"")) {
return myException != null ? myException.getMessage() : null;
}
 else if (theKey.equals(""String_Node_Str"")) {
return myRequest.getRequestURL().toString();
}
 else if (theKey.equals(""String_Node_Str"")) {
return myRequest.getMethod();
}
return ""String_Node_Str"";
}",0.9340161512704352
112288,"private MyLookup(HttpServletRequest theRequest,RequestDetails theRequestDetails){
  myRequest=theRequest;
  myRequestDetails=theRequestDetails;
}","public MyLookup(HttpServletRequest theServletRequest,BaseServerResponseException theException,RequestDetails theRequestDetails){
  myException=theException;
  myRequestDetails=theRequestDetails;
  myRequest=theServletRequest;
}",0.6344086021505376
112289,"/** 
 * Add an issue to an OperationOutcome
 * @param theCtx The fhir context
 * @param theOperationOutcome The OO resource to add to
 * @param theSeverity The severity (e.g. ""error"")
 * @param theDetails The details string
 */
public static void addIssue(FhirContext theCtx,IBaseOperationOutcome theOperationOutcome,String theSeverity,String theDetails,String theLocation){
  IBase issue=createIssue(theCtx,theOperationOutcome);
  populateDetails(theCtx,issue,theSeverity,theDetails,theLocation);
}","/** 
 * Add an issue to an OperationOutcome
 * @param theCtx The fhir context
 * @param theOperationOutcome The OO resource to add to
 * @param theSeverity The severity (e.g. ""error"")
 * @param theDetails The details string
 * @param theCode 
 */
public static void addIssue(FhirContext theCtx,IBaseOperationOutcome theOperationOutcome,String theSeverity,String theDetails,String theLocation,String theCode){
  IBase issue=createIssue(theCtx,theOperationOutcome);
  populateDetails(theCtx,issue,theSeverity,theDetails,theLocation,theCode);
}",0.9596153846153846
112290,"private static void populateDetails(FhirContext theCtx,IBase theIssue,String theSeverity,String theDetails,String theLocation){
  BaseRuntimeElementCompositeDefinition<?> issueElement=(BaseRuntimeElementCompositeDefinition<?>)theCtx.getElementDefinition(theIssue.getClass());
  BaseRuntimeChildDefinition detailsChild;
  if (theCtx.getVersion().getVersion().isNewerThan(FhirVersionEnum.DSTU1)) {
    detailsChild=issueElement.getChildByName(""String_Node_Str"");
  }
 else {
    detailsChild=issueElement.getChildByName(""String_Node_Str"");
  }
  BaseRuntimeElementDefinition<?> stringDef=theCtx.getElementDefinition(""String_Node_Str"");
  BaseRuntimeChildDefinition severityChild=issueElement.getChildByName(""String_Node_Str"");
  BaseRuntimeChildDefinition locationChild=issueElement.getChildByName(""String_Node_Str"");
  IPrimitiveType<?> severityElem=(IPrimitiveType<?>)severityChild.getChildByName(""String_Node_Str"").newInstance(severityChild.getInstanceConstructorArguments());
  severityElem.setValueAsString(theSeverity);
  severityChild.getMutator().addValue(theIssue,severityElem);
  IPrimitiveType<?> string=(IPrimitiveType<?>)stringDef.newInstance();
  string.setValueAsString(theDetails);
  detailsChild.getMutator().setValue(theIssue,string);
  if (isNotBlank(theLocation)) {
    IPrimitiveType<?> locationElem=(IPrimitiveType<?>)locationChild.getChildByName(""String_Node_Str"").newInstance(locationChild.getInstanceConstructorArguments());
    locationElem.setValueAsString(theLocation);
    locationChild.getMutator().addValue(theIssue,locationElem);
  }
}","private static void populateDetails(FhirContext theCtx,IBase theIssue,String theSeverity,String theDetails,String theLocation,String theCode){
  BaseRuntimeElementCompositeDefinition<?> issueElement=(BaseRuntimeElementCompositeDefinition<?>)theCtx.getElementDefinition(theIssue.getClass());
  BaseRuntimeChildDefinition detailsChild;
  if (theCtx.getVersion().getVersion().isNewerThan(FhirVersionEnum.DSTU1)) {
    detailsChild=issueElement.getChildByName(""String_Node_Str"");
    BaseRuntimeChildDefinition codeChild=issueElement.getChildByName(""String_Node_Str"");
    IPrimitiveType<?> codeElem=(IPrimitiveType<?>)codeChild.getChildByName(""String_Node_Str"").newInstance(codeChild.getInstanceConstructorArguments());
    codeElem.setValueAsString(theCode);
    codeChild.getMutator().addValue(theIssue,codeElem);
  }
 else {
    detailsChild=issueElement.getChildByName(""String_Node_Str"");
  }
  BaseRuntimeElementDefinition<?> stringDef=theCtx.getElementDefinition(""String_Node_Str"");
  BaseRuntimeChildDefinition severityChild=issueElement.getChildByName(""String_Node_Str"");
  BaseRuntimeChildDefinition locationChild=issueElement.getChildByName(""String_Node_Str"");
  IPrimitiveType<?> severityElem=(IPrimitiveType<?>)severityChild.getChildByName(""String_Node_Str"").newInstance(severityChild.getInstanceConstructorArguments());
  severityElem.setValueAsString(theSeverity);
  severityChild.getMutator().addValue(theIssue,severityElem);
  IPrimitiveType<?> string=(IPrimitiveType<?>)stringDef.newInstance();
  string.setValueAsString(theDetails);
  detailsChild.getMutator().setValue(theIssue,string);
  if (isNotBlank(theLocation)) {
    IPrimitiveType<?> locationElem=(IPrimitiveType<?>)locationChild.getChildByName(""String_Node_Str"").newInstance(locationChild.getInstanceConstructorArguments());
    locationElem.setValueAsString(theLocation);
    locationChild.getMutator().addValue(theIssue,locationElem);
  }
}",0.5611717403790925
112291,"private void pollForNewUndeliveredResources(SubscriptionTable theSubscriptionTable){
  Subscription subscription=toResource(Subscription.class,theSubscriptionTable.getSubscriptionResource(),false);
  RuntimeResourceDefinition resourceDef=validateCriteriaAndReturnResourceDefinition(subscription);
  SearchParameterMap criteriaUrl=translateMatchUrl(subscription.getCriteria(),resourceDef);
  criteriaUrl=new SearchParameterMap();
  long start=theSubscriptionTable.getMostRecentMatch().getTime();
  long end=System.currentTimeMillis() - getConfig().getSubscriptionPollDelay();
  if (end <= start) {
    ourLog.trace(""String_Node_Str"");
    return;
  }
  ourLog.info(""String_Node_Str"",start,end);
  DateRangeParam range=new DateRangeParam();
  range.setLowerBound(new DateParam(QuantityCompararatorEnum.GREATERTHAN,start));
  range.setUpperBound(new DateParam(QuantityCompararatorEnum.LESSTHAN,end));
  criteriaUrl.setLastUpdated(range);
  IFhirResourceDao<? extends IBaseResource> dao=getDao(resourceDef.getImplementingClass());
  IBundleProvider results=dao.search(criteriaUrl);
  if (results.size() == 0) {
    return;
  }
  ourLog.info(""String_Node_Str"",results.size(),subscription.getId().getIdPart());
  List<SubscriptionFlaggedResource> flags=new ArrayList<SubscriptionFlaggedResource>();
  for (  IBaseResource next : results.getResources(0,results.size())) {
    SubscriptionFlaggedResource nextFlag=new SubscriptionFlaggedResource();
    nextFlag.setResource();
  }
}","private void pollForNewUndeliveredResources(SubscriptionTable theSubscriptionTable){
  Subscription subscription=toResource(Subscription.class,theSubscriptionTable.getSubscriptionResource(),false);
  RuntimeResourceDefinition resourceDef=validateCriteriaAndReturnResourceDefinition(subscription);
  SearchParameterMap criteriaUrl=translateMatchUrl(subscription.getCriteria(),resourceDef);
  criteriaUrl=new SearchParameterMap();
  long start=theSubscriptionTable.getMostRecentMatch().getTime();
  long end=System.currentTimeMillis() - getConfig().getSubscriptionPollDelay();
  if (end <= start) {
    ourLog.trace(""String_Node_Str"");
    return;
  }
  ourLog.info(""String_Node_Str"",start,end);
  DateRangeParam range=new DateRangeParam();
  range.setLowerBound(new DateParam(QuantityCompararatorEnum.GREATERTHAN,start));
  range.setUpperBound(new DateParam(QuantityCompararatorEnum.LESSTHAN,end));
  criteriaUrl.setLastUpdated(range);
  IFhirResourceDao<? extends IBaseResource> dao=getDao(resourceDef.getImplementingClass());
  IBundleProvider results=dao.search(criteriaUrl);
  if (results.size() == 0) {
    return;
  }
  ourLog.info(""String_Node_Str"",results.size(),subscription.getId().getIdPart());
  List<SubscriptionFlaggedResource> flags=new ArrayList<SubscriptionFlaggedResource>();
  for (  IBaseResource next : results.getResources(0,results.size())) {
    SubscriptionFlaggedResource nextFlag=new SubscriptionFlaggedResource();
  }
}",0.9904109589041096
112292,"protected void handleRequest(RequestTypeEnum theRequestType,HttpServletRequest theRequest,HttpServletResponse theResponse) throws ServletException, IOException {
  for (  IServerInterceptor next : myInterceptors) {
    boolean continueProcessing=next.incomingRequestPreProcessed(theRequest,theResponse);
    if (!continueProcessing) {
      ourLog.debug(""String_Node_Str"");
      return;
    }
  }
  String fhirServerBase=null;
  boolean requestIsBrowser=requestIsBrowser(theRequest);
  RequestDetails requestDetails=new RequestDetails();
  requestDetails.setServer(this);
  requestDetails.setRequestType(theRequestType);
  requestDetails.setServletRequest(theRequest);
  requestDetails.setServletResponse(theResponse);
  try {
    String resourceName=null;
    String requestFullPath=StringUtils.defaultString(theRequest.getRequestURI());
    String servletPath=StringUtils.defaultString(theRequest.getServletPath());
    StringBuffer requestUrl=theRequest.getRequestURL();
    String servletContextPath=""String_Node_Str"";
    if (getServletContext() != null) {
      servletContextPath=StringUtils.defaultString(getServletContext().getContextPath());
    }
    if (ourLog.isTraceEnabled()) {
      ourLog.trace(""String_Node_Str"",requestFullPath);
      ourLog.trace(""String_Node_Str"",servletPath);
      ourLog.trace(""String_Node_Str"",requestUrl);
      ourLog.trace(""String_Node_Str"",servletContextPath);
    }
    IdDt id=null;
    String operation=null;
    String compartment=null;
    String requestPath=getRequestPath(requestFullPath,servletContextPath,servletPath);
    if (requestPath.length() > 0 && requestPath.charAt(0) == '/') {
      requestPath=requestPath.substring(1);
    }
    fhirServerBase=getServerBaseForRequest(theRequest);
    String completeUrl=StringUtils.isNotBlank(theRequest.getQueryString()) ? requestUrl + ""String_Node_Str"" + theRequest.getQueryString() : requestUrl.toString();
    Map<String,String[]> params=new HashMap<String,String[]>(theRequest.getParameterMap());
    requestDetails.setParameters(params);
    StringTokenizer tok=new StringTokenizer(requestPath,""String_Node_Str"");
    if (tok.hasMoreTokens()) {
      resourceName=tok.nextToken();
      if (partIsOperation(resourceName)) {
        operation=resourceName;
        resourceName=null;
      }
    }
    requestDetails.setResourceName(resourceName);
    ResourceBinding resourceBinding=null;
    BaseMethodBinding<?> resourceMethod=null;
    if (Constants.URL_TOKEN_METADATA.equals(resourceName) || theRequestType == RequestTypeEnum.OPTIONS) {
      resourceMethod=myServerConformanceMethod;
    }
 else     if (resourceName == null) {
      resourceBinding=myServerBinding;
    }
 else {
      resourceBinding=myResourceNameToBinding.get(resourceName);
      if (resourceBinding == null) {
        throw new InvalidRequestException(""String_Node_Str"" + resourceName + ""String_Node_Str""+ myResourceNameToBinding.keySet());
      }
    }
    if (tok.hasMoreTokens()) {
      String nextString=tok.nextToken();
      if (partIsOperation(nextString)) {
        operation=nextString;
      }
 else {
        id=new IdDt(resourceName,UrlUtil.unescape(nextString));
      }
    }
    if (tok.hasMoreTokens()) {
      String nextString=tok.nextToken();
      if (nextString.equals(Constants.PARAM_HISTORY)) {
        if (tok.hasMoreTokens()) {
          String versionString=tok.nextToken();
          if (id == null) {
            throw new InvalidRequestException(""String_Node_Str"" + requestPath);
          }
          id=new IdDt(resourceName,id.getIdPart(),UrlUtil.unescape(versionString));
        }
 else {
          operation=Constants.PARAM_HISTORY;
        }
      }
 else       if (partIsOperation(nextString)) {
        if (operation != null) {
          throw new InvalidRequestException(""String_Node_Str"" + requestPath);
        }
        operation=nextString;
      }
 else {
        compartment=nextString;
      }
    }
    String secondaryOperation=null;
    while (tok.hasMoreTokens()) {
      String nextString=tok.nextToken();
      if (operation == null) {
        operation=nextString;
      }
 else       if (secondaryOperation == null) {
        secondaryOperation=nextString;
      }
 else {
        throw new InvalidRequestException(""String_Node_Str"" + nextString + ""String_Node_Str""+ requestPath);
      }
    }
    if (theRequestType == RequestTypeEnum.PUT) {
      String contentLocation=theRequest.getHeader(Constants.HEADER_CONTENT_LOCATION);
      if (contentLocation != null) {
        id=new IdDt(contentLocation);
      }
    }
    requestDetails.setId(id);
    requestDetails.setOperation(operation);
    requestDetails.setSecondaryOperation(secondaryOperation);
    requestDetails.setCompartmentName(compartment);
    String acceptEncoding=theRequest.getHeader(Constants.HEADER_ACCEPT_ENCODING);
    boolean respondGzip=false;
    if (acceptEncoding != null) {
      String[] parts=acceptEncoding.trim().split(""String_Node_Str"");
      for (      String string : parts) {
        if (string.equals(""String_Node_Str"")) {
          respondGzip=true;
        }
      }
    }
    requestDetails.setRespondGzip(respondGzip);
    requestDetails.setRequestPath(requestPath);
    requestDetails.setFhirServerBase(fhirServerBase);
    requestDetails.setCompleteUrl(completeUrl);
    String pagingAction=theRequest.getParameter(Constants.PARAM_PAGINGACTION);
    if (getPagingProvider() != null && isNotBlank(pagingAction)) {
      requestDetails.setOtherOperationType(OtherOperationTypeEnum.GET_PAGE);
      if (theRequestType != RequestTypeEnum.GET) {
        throw new InvalidRequestException(getFhirContext().getLocalizer().getMessage(RestfulServer.class,""String_Node_Str""));
      }
      handlePagingRequest(requestDetails,theResponse,pagingAction);
      return;
    }
    if (resourceMethod == null) {
      if (resourceBinding != null) {
        resourceMethod=resourceBinding.getMethod(requestDetails);
      }
    }
    if (resourceMethod == null) {
      if (isBlank(requestPath)) {
        throw new InvalidRequestException(myFhirContext.getLocalizer().getMessage(RestfulServer.class,""String_Node_Str""));
      }
 else {
        throw new InvalidRequestException(myFhirContext.getLocalizer().getMessage(RestfulServer.class,""String_Node_Str"",theRequestType.name(),requestPath,params.keySet()));
      }
    }
    requestDetails.setResourceOperationType(resourceMethod.getResourceOperationType());
    requestDetails.setSystemOperationType(resourceMethod.getSystemOperationType());
    requestDetails.setOtherOperationType(resourceMethod.getOtherOperationType());
    for (    IServerInterceptor next : myInterceptors) {
      boolean continueProcessing=next.incomingRequestPostProcessed(requestDetails,theRequest,theResponse);
      if (!continueProcessing) {
        ourLog.debug(""String_Node_Str"");
        return;
      }
    }
    resourceMethod.invokeServer(this,requestDetails);
  }
 catch (  NotModifiedException e) {
    for (int i=getInterceptors().size() - 1; i >= 0; i--) {
      IServerInterceptor next=getInterceptors().get(i);
      if (!next.handleException(requestDetails,e,theRequest,theResponse)) {
        ourLog.debug(""String_Node_Str"");
        return;
      }
    }
    writeExceptionToResponse(theResponse,e);
  }
catch (  AuthenticationException e) {
    for (int i=getInterceptors().size() - 1; i >= 0; i--) {
      IServerInterceptor next=getInterceptors().get(i);
      if (!next.handleException(requestDetails,e,theRequest,theResponse)) {
        ourLog.debug(""String_Node_Str"");
        return;
      }
    }
    if (requestIsBrowser) {
      theResponse.setHeader(""String_Node_Str"",""String_Node_Str"");
    }
    writeExceptionToResponse(theResponse,e);
  }
catch (  Throwable e) {
    BaseServerResponseException exception=null;
    for (int i=getInterceptors().size() - 1; i >= 0; i--) {
      IServerInterceptor next=getInterceptors().get(i);
      exception=next.preProcessOutgoingException(requestDetails,exception,theRequest);
      if (exception != null) {
        ourLog.debug(""String_Node_Str"");
        break;
      }
    }
    if (exception == null) {
      exception=new ExceptionHandlingInterceptor().preProcessOutgoingException(requestDetails,e,theRequest);
    }
    for (int i=getInterceptors().size() - 1; i >= 0; i--) {
      IServerInterceptor next=getInterceptors().get(i);
      if (!next.handleException(requestDetails,exception,theRequest,theResponse)) {
        ourLog.debug(""String_Node_Str"");
        return;
      }
    }
    new ExceptionHandlingInterceptor().handleException(requestDetails,exception,theRequest,theResponse);
  }
}","protected void handleRequest(RequestTypeEnum theRequestType,HttpServletRequest theRequest,HttpServletResponse theResponse) throws ServletException, IOException {
  for (  IServerInterceptor next : myInterceptors) {
    boolean continueProcessing=next.incomingRequestPreProcessed(theRequest,theResponse);
    if (!continueProcessing) {
      ourLog.debug(""String_Node_Str"");
      return;
    }
  }
  String fhirServerBase=null;
  boolean requestIsBrowser=requestIsBrowser(theRequest);
  RequestDetails requestDetails=new RequestDetails();
  requestDetails.setServer(this);
  requestDetails.setRequestType(theRequestType);
  requestDetails.setServletRequest(theRequest);
  requestDetails.setServletResponse(theResponse);
  try {
    String resourceName=null;
    String requestFullPath=StringUtils.defaultString(theRequest.getRequestURI());
    String servletPath=StringUtils.defaultString(theRequest.getServletPath());
    StringBuffer requestUrl=theRequest.getRequestURL();
    String servletContextPath=""String_Node_Str"";
    if (getServletContext() != null) {
      servletContextPath=StringUtils.defaultString(getServletContext().getContextPath());
    }
    if (ourLog.isTraceEnabled()) {
      ourLog.trace(""String_Node_Str"",requestFullPath);
      ourLog.trace(""String_Node_Str"",servletPath);
      ourLog.trace(""String_Node_Str"",requestUrl);
      ourLog.trace(""String_Node_Str"",servletContextPath);
    }
    IdDt id=null;
    String operation=null;
    String compartment=null;
    String requestPath=getRequestPath(requestFullPath,servletContextPath,servletPath);
    if (requestPath.length() > 0 && requestPath.charAt(0) == '/') {
      requestPath=requestPath.substring(1);
    }
    fhirServerBase=getServerBaseForRequest(theRequest);
    String completeUrl=StringUtils.isNotBlank(theRequest.getQueryString()) ? requestUrl + ""String_Node_Str"" + theRequest.getQueryString() : requestUrl.toString();
    Map<String,String[]> params=new HashMap<String,String[]>(theRequest.getParameterMap());
    requestDetails.setParameters(params);
    StringTokenizer tok=new StringTokenizer(requestPath,""String_Node_Str"");
    if (tok.hasMoreTokens()) {
      resourceName=tok.nextToken();
      if (partIsOperation(resourceName)) {
        operation=resourceName;
        resourceName=null;
      }
    }
    requestDetails.setResourceName(resourceName);
    ResourceBinding resourceBinding=null;
    BaseMethodBinding<?> resourceMethod=null;
    if (Constants.URL_TOKEN_METADATA.equals(resourceName) || theRequestType == RequestTypeEnum.OPTIONS) {
      resourceMethod=myServerConformanceMethod;
    }
 else     if (resourceName == null) {
      resourceBinding=myServerBinding;
    }
 else {
      resourceBinding=myResourceNameToBinding.get(resourceName);
      if (resourceBinding == null) {
        throw new InvalidRequestException(""String_Node_Str"" + resourceName + ""String_Node_Str""+ myResourceNameToBinding.keySet());
      }
    }
    if (tok.hasMoreTokens()) {
      String nextString=tok.nextToken();
      if (partIsOperation(nextString)) {
        operation=nextString;
      }
 else {
        id=new IdDt(resourceName,UrlUtil.unescape(nextString));
      }
    }
    if (tok.hasMoreTokens()) {
      String nextString=tok.nextToken();
      if (nextString.equals(Constants.PARAM_HISTORY)) {
        if (tok.hasMoreTokens()) {
          String versionString=tok.nextToken();
          if (id == null) {
            throw new InvalidRequestException(""String_Node_Str"" + requestPath);
          }
          id=new IdDt(resourceName,id.getIdPart(),UrlUtil.unescape(versionString));
        }
 else {
          operation=Constants.PARAM_HISTORY;
        }
      }
 else       if (partIsOperation(nextString)) {
        if (operation != null) {
          throw new InvalidRequestException(""String_Node_Str"" + requestPath);
        }
        operation=nextString;
      }
 else {
        compartment=nextString;
      }
    }
    String secondaryOperation=null;
    while (tok.hasMoreTokens()) {
      String nextString=tok.nextToken();
      if (operation == null) {
        operation=nextString;
      }
 else       if (secondaryOperation == null) {
        secondaryOperation=nextString;
      }
 else {
        throw new InvalidRequestException(""String_Node_Str"" + nextString + ""String_Node_Str""+ requestPath);
      }
    }
    if (theRequestType == RequestTypeEnum.PUT) {
      String contentLocation=theRequest.getHeader(Constants.HEADER_CONTENT_LOCATION);
      if (contentLocation != null) {
        id=new IdDt(contentLocation);
      }
    }
    requestDetails.setId(id);
    requestDetails.setOperation(operation);
    requestDetails.setSecondaryOperation(secondaryOperation);
    requestDetails.setCompartmentName(compartment);
    String acceptEncoding=theRequest.getHeader(Constants.HEADER_ACCEPT_ENCODING);
    boolean respondGzip=false;
    if (acceptEncoding != null) {
      String[] parts=acceptEncoding.trim().split(""String_Node_Str"");
      for (      String string : parts) {
        if (string.equals(""String_Node_Str"")) {
          respondGzip=true;
        }
      }
    }
    requestDetails.setRespondGzip(respondGzip);
    requestDetails.setRequestPath(requestPath);
    requestDetails.setFhirServerBase(fhirServerBase);
    requestDetails.setCompleteUrl(completeUrl);
    String pagingAction=theRequest.getParameter(Constants.PARAM_PAGINGACTION);
    if (getPagingProvider() != null && isNotBlank(pagingAction)) {
      requestDetails.setOtherOperationType(OtherOperationTypeEnum.GET_PAGE);
      if (theRequestType != RequestTypeEnum.GET) {
        throw new InvalidRequestException(getFhirContext().getLocalizer().getMessage(RestfulServer.class,""String_Node_Str""));
      }
      handlePagingRequest(requestDetails,theResponse,pagingAction);
      return;
    }
    if (resourceMethod == null) {
      if (resourceBinding != null) {
        resourceMethod=resourceBinding.getMethod(requestDetails);
      }
    }
    if (resourceMethod == null) {
      if (isBlank(requestPath)) {
        throw new InvalidRequestException(myFhirContext.getLocalizer().getMessage(RestfulServer.class,""String_Node_Str""));
      }
 else {
        throw new InvalidRequestException(myFhirContext.getLocalizer().getMessage(RestfulServer.class,""String_Node_Str"",theRequestType.name(),requestPath,params.keySet()));
      }
    }
    requestDetails.setResourceOperationType(resourceMethod.getResourceOperationType());
    requestDetails.setSystemOperationType(resourceMethod.getSystemOperationType());
    requestDetails.setOtherOperationType(resourceMethod.getOtherOperationType());
    for (    IServerInterceptor next : myInterceptors) {
      boolean continueProcessing=next.incomingRequestPostProcessed(requestDetails,theRequest,theResponse);
      if (!continueProcessing) {
        ourLog.debug(""String_Node_Str"");
        return;
      }
    }
    resourceMethod.invokeServer(this,requestDetails);
  }
 catch (  NotModifiedException e) {
    for (int i=getInterceptors().size() - 1; i >= 0; i--) {
      IServerInterceptor next=getInterceptors().get(i);
      if (!next.handleException(requestDetails,e,theRequest,theResponse)) {
        ourLog.debug(""String_Node_Str"");
        return;
      }
    }
    writeExceptionToResponse(theResponse,e);
  }
catch (  AuthenticationException e) {
    for (int i=getInterceptors().size() - 1; i >= 0; i--) {
      IServerInterceptor next=getInterceptors().get(i);
      if (!next.handleException(requestDetails,e,theRequest,theResponse)) {
        ourLog.debug(""String_Node_Str"");
        return;
      }
    }
    if (requestIsBrowser) {
      theResponse.setHeader(""String_Node_Str"",""String_Node_Str"");
    }
    writeExceptionToResponse(theResponse,e);
  }
catch (  Throwable e) {
    BaseServerResponseException exception=null;
    for (int i=getInterceptors().size() - 1; i >= 0; i--) {
      IServerInterceptor next=getInterceptors().get(i);
      exception=next.preProcessOutgoingException(requestDetails,e,theRequest);
      if (exception != null) {
        ourLog.debug(""String_Node_Str"");
        break;
      }
    }
    if (exception == null) {
      exception=new ExceptionHandlingInterceptor().preProcessOutgoingException(requestDetails,e,theRequest);
    }
    for (int i=getInterceptors().size() - 1; i >= 0; i--) {
      IServerInterceptor next=getInterceptors().get(i);
      if (!next.handleException(requestDetails,exception,theRequest,theResponse)) {
        ourLog.debug(""String_Node_Str"");
        return;
      }
    }
    new ExceptionHandlingInterceptor().handleException(requestDetails,exception,theRequest,theResponse);
  }
}",0.9995360167033986
112293,"private void createSort(CriteriaBuilder theBuilder,Root<ResourceTable> theFrom,SortSpec theSort,List<Order> theOrders,List<Predicate> thePredicates){
  if (theSort == null || isBlank(theSort.getParamName())) {
    return;
  }
  if (""String_Node_Str"".equals(theSort.getParamName())) {
    From<?,?> forcedIdJoin=theFrom.join(""String_Node_Str"",JoinType.LEFT);
    if (theSort.getOrder() == null || theSort.getOrder() == SortOrderEnum.ASC) {
      theOrders.add(theBuilder.asc(forcedIdJoin.get(""String_Node_Str"")));
      theOrders.add(theBuilder.asc(theFrom.get(""String_Node_Str"")));
    }
 else {
      theOrders.add(theBuilder.desc(forcedIdJoin.get(""String_Node_Str"")));
      theOrders.add(theBuilder.desc(theFrom.get(""String_Node_Str"")));
    }
    createSort(theBuilder,theFrom,theSort.getChain(),theOrders,thePredicates);
    return;
  }
  RuntimeResourceDefinition resourceDef=getContext().getResourceDefinition(myResourceType);
  RuntimeSearchParam param=resourceDef.getSearchParam(theSort.getParamName());
  if (param == null) {
    throw new InvalidRequestException(""String_Node_Str"" + theSort.getParamName() + ""String_Node_Str"");
  }
  String joinAttrName;
  String sortAttrName;
switch (param.getParamType()) {
case STRING:
    joinAttrName=""String_Node_Str"";
  sortAttrName=""String_Node_Str"";
break;
case DATE:
joinAttrName=""String_Node_Str"";
sortAttrName=""String_Node_Str"";
break;
case REFERENCE:
joinAttrName=""String_Node_Str"";
sortAttrName=""String_Node_Str"";
break;
default :
throw new NotImplementedException(""String_Node_Str"" + param.getParamType() + ""String_Node_Str""+ theSort.getParamName());
}
From<?,?> stringJoin=theFrom.join(joinAttrName,JoinType.INNER);
thePredicates.add(theBuilder.equal(stringJoin.get(""String_Node_Str""),theSort.getParamName()));
if (theSort.getOrder() == null || theSort.getOrder() == SortOrderEnum.ASC) {
theOrders.add(theBuilder.asc(stringJoin.get(sortAttrName)));
}
 else {
theOrders.add(theBuilder.desc(stringJoin.get(sortAttrName)));
}
createSort(theBuilder,theFrom,theSort.getChain(),theOrders,thePredicates);
}","private void createSort(CriteriaBuilder theBuilder,Root<ResourceTable> theFrom,SortSpec theSort,List<Order> theOrders,List<Predicate> thePredicates){
  if (theSort == null || isBlank(theSort.getParamName())) {
    return;
  }
  if (""String_Node_Str"".equals(theSort.getParamName())) {
    From<?,?> forcedIdJoin=theFrom.join(""String_Node_Str"",JoinType.LEFT);
    if (theSort.getOrder() == null || theSort.getOrder() == SortOrderEnum.ASC) {
      theOrders.add(theBuilder.asc(forcedIdJoin.get(""String_Node_Str"")));
      theOrders.add(theBuilder.asc(theFrom.get(""String_Node_Str"")));
    }
 else {
      theOrders.add(theBuilder.desc(forcedIdJoin.get(""String_Node_Str"")));
      theOrders.add(theBuilder.desc(theFrom.get(""String_Node_Str"")));
    }
    createSort(theBuilder,theFrom,theSort.getChain(),theOrders,thePredicates);
    return;
  }
  RuntimeResourceDefinition resourceDef=getContext().getResourceDefinition(myResourceType);
  RuntimeSearchParam param=resourceDef.getSearchParam(theSort.getParamName());
  if (param == null) {
    throw new InvalidRequestException(""String_Node_Str"" + theSort.getParamName() + ""String_Node_Str"");
  }
  String joinAttrName;
  String sortAttrName;
switch (param.getParamType()) {
case STRING:
    joinAttrName=""String_Node_Str"";
  sortAttrName=""String_Node_Str"";
break;
case DATE:
joinAttrName=""String_Node_Str"";
sortAttrName=""String_Node_Str"";
break;
case REFERENCE:
joinAttrName=""String_Node_Str"";
sortAttrName=""String_Node_Str"";
break;
default :
throw new NotImplementedException(""String_Node_Str"" + param.getParamType() + ""String_Node_Str""+ theSort.getParamName());
}
From<?,?> stringJoin=theFrom.join(joinAttrName,JoinType.INNER);
if (param.getParamType() == RestSearchParameterTypeEnum.REFERENCE) {
thePredicates.add(stringJoin.get(""String_Node_Str"").as(String.class).in(param.getPathsSplit()));
}
 else {
thePredicates.add(theBuilder.equal(stringJoin.get(""String_Node_Str""),theSort.getParamName()));
}
if (theSort.getOrder() == null || theSort.getOrder() == SortOrderEnum.ASC) {
theOrders.add(theBuilder.asc(stringJoin.get(sortAttrName)));
}
 else {
theOrders.add(theBuilder.desc(stringJoin.get(sortAttrName)));
}
createSort(theBuilder,theFrom,theSort.getChain(),theOrders,thePredicates);
}",0.957189390414146
112294,"/** 
 * <b>Not supported!</b>
 * @deprecated get/setMissing is not supported in StringDt. Use {@link TokenParam} instead if youneed this functionality
 */
@Deprecated @Override public Boolean getMissing(){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","/** 
 * <b>Not supported!</b>
 * @deprecated get/setMissing is not supported in StringDt. Use {@link TokenParam} instead if youneed this functionality
 */
@Deprecated @Override public Boolean getMissing(){
  return null;
}",0.8594704684317719
112295,"/** 
 * <b>Not supported!</b>
 * @deprecated get/setMissing is not supported in StringDt. Use {@link QuantityParam} instead if youneed this functionality
 */
@Deprecated @Override public Boolean getMissing(){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","/** 
 * <b>Not supported!</b>
 * @deprecated get/setMissing is not supported in StringDt. Use {@link QuantityParam} instead if youneed this functionality
 */
@Deprecated @Override public Boolean getMissing(){
  return null;
}",0.8611670020120724
112296,"/** 
 * <b>Not supported!</b>
 * @deprecated get/setMissing is not supported in StringDt. Use {@link StringParam} instead if youneed this functionality
 */
@Deprecated @Override public Boolean getMissing(){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","/** 
 * <b>Not supported!</b>
 * @deprecated get/setMissing is not supported in StringDt. Use {@link StringParam} instead if youneed this functionality
 */
@Deprecated @Override public Boolean getMissing(){
  return null;
}",0.8600405679513184
112297,"@Override public final void setValueAsQueryToken(String theQualifier,String theValue){
  if (Constants.PARAMQUALIFIER_MISSING.equals(theQualifier)) {
    myMissing=""String_Node_Str"".equals(theValue);
  }
 else {
    myMissing=null;
    doSetValueAsQueryToken(theQualifier,theValue);
  }
}","@Override public final void setValueAsQueryToken(String theQualifier,String theValue){
  if (Constants.PARAMQUALIFIER_MISSING.equals(theQualifier)) {
    myMissing=""String_Node_Str"".equals(theValue);
    doSetValueAsQueryToken(null,null);
  }
 else {
    myMissing=null;
    doSetValueAsQueryToken(theQualifier,theValue);
  }
}",0.9365853658536586
112298,"@Override String doGetValueAsQueryToken(){
  if (super.getMissing() != null) {
    return super.getValueAsQueryToken();
  }
  StringBuilder b=new StringBuilder();
  if (myApproximate) {
    b.append('~');
  }
 else {
    b.append(defaultString(escape(myQuantity.getComparatorElement().getValue())));
  }
  if (!myQuantity.getValueElement().isEmpty()) {
    b.append(defaultString(escape(myQuantity.getValueElement().getValueAsString())));
  }
  b.append('|');
  if (!myQuantity.getSystemElement().isEmpty()) {
    b.append(defaultString(escape(myQuantity.getSystemElement().getValueAsString())));
  }
  b.append('|');
  if (!myQuantity.getUnitsElement().isEmpty()) {
    b.append(defaultString(escape(myQuantity.getUnitsElement().getValueAsString())));
  }
  return b.toString();
}","@Override String doGetValueAsQueryToken(){
  StringBuilder b=new StringBuilder();
  if (myApproximate) {
    b.append('~');
  }
 else {
    b.append(defaultString(escape(myQuantity.getComparatorElement().getValue())));
  }
  if (!myQuantity.getValueElement().isEmpty()) {
    b.append(defaultString(escape(myQuantity.getValueElement().getValueAsString())));
  }
  b.append('|');
  if (!myQuantity.getSystemElement().isEmpty()) {
    b.append(defaultString(escape(myQuantity.getSystemElement().getValueAsString())));
  }
  b.append('|');
  if (!myQuantity.getUnitsElement().isEmpty()) {
    b.append(defaultString(escape(myQuantity.getUnitsElement().getValueAsString())));
  }
  return b.toString();
}",0.9453072248480756
112299,"@Override void doSetValueAsQueryToken(String theQualifier,String theValue){
  clear();
  super.setValueAsQueryToken(theQualifier,theValue);
  if (getMissing() != null) {
    return;
  }
  if (theValue == null) {
    return;
  }
  List<String> parts=ParameterUtil.splitParameterString(theValue,'|',true);
  if (parts.size() > 0 && StringUtils.isNotBlank(parts.get(0))) {
    if (parts.get(0).startsWith(""String_Node_Str"")) {
      myQuantity.setComparator((QuantityCompararatorEnum)null);
      myApproximate=true;
      myQuantity.setValue(new BigDecimal(parts.get(0).substring(1)));
    }
 else     if (parts.get(0).startsWith(""String_Node_Str"")) {
      myQuantity.setComparator(QuantityCompararatorEnum.LESSTHAN_OR_EQUALS);
      myQuantity.setValue(new BigDecimal(parts.get(0).substring(2)));
    }
 else     if (parts.get(0).startsWith(""String_Node_Str"")) {
      myQuantity.setComparator(QuantityCompararatorEnum.LESSTHAN);
      String valStr=parts.get(0).substring(1);
      myQuantity.setValue(new BigDecimal(valStr));
    }
 else     if (parts.get(0).startsWith(""String_Node_Str"")) {
      myQuantity.setComparator(QuantityCompararatorEnum.GREATERTHAN_OR_EQUALS);
      myQuantity.setValue(new BigDecimal(parts.get(0).substring(2)));
    }
 else     if (parts.get(0).startsWith(""String_Node_Str"")) {
      myQuantity.setComparator(QuantityCompararatorEnum.GREATERTHAN);
      myQuantity.setValue(new BigDecimal(parts.get(0).substring(1)));
    }
 else {
      myQuantity.setValue(new BigDecimal(parts.get(0)));
    }
  }
  if (parts.size() > 1 && StringUtils.isNotBlank(parts.get(1))) {
    myQuantity.setSystem(parts.get(1));
  }
  if (parts.size() > 2 && StringUtils.isNotBlank(parts.get(2))) {
    myQuantity.setUnits(parts.get(2));
  }
}","@Override void doSetValueAsQueryToken(String theQualifier,String theValue){
  clear();
  if (theValue == null) {
    return;
  }
  List<String> parts=ParameterUtil.splitParameterString(theValue,'|',true);
  if (parts.size() > 0 && StringUtils.isNotBlank(parts.get(0))) {
    if (parts.get(0).startsWith(""String_Node_Str"")) {
      myQuantity.setComparator((QuantityCompararatorEnum)null);
      myApproximate=true;
      myQuantity.setValue(new BigDecimal(parts.get(0).substring(1)));
    }
 else     if (parts.get(0).startsWith(""String_Node_Str"")) {
      myQuantity.setComparator(QuantityCompararatorEnum.LESSTHAN_OR_EQUALS);
      myQuantity.setValue(new BigDecimal(parts.get(0).substring(2)));
    }
 else     if (parts.get(0).startsWith(""String_Node_Str"")) {
      myQuantity.setComparator(QuantityCompararatorEnum.LESSTHAN);
      String valStr=parts.get(0).substring(1);
      myQuantity.setValue(new BigDecimal(valStr));
    }
 else     if (parts.get(0).startsWith(""String_Node_Str"")) {
      myQuantity.setComparator(QuantityCompararatorEnum.GREATERTHAN_OR_EQUALS);
      myQuantity.setValue(new BigDecimal(parts.get(0).substring(2)));
    }
 else     if (parts.get(0).startsWith(""String_Node_Str"")) {
      myQuantity.setComparator(QuantityCompararatorEnum.GREATERTHAN);
      myQuantity.setValue(new BigDecimal(parts.get(0).substring(1)));
    }
 else {
      myQuantity.setValue(new BigDecimal(parts.get(0)));
    }
  }
  if (parts.size() > 1 && StringUtils.isNotBlank(parts.get(1))) {
    myQuantity.setSystem(parts.get(1));
  }
  if (parts.size() > 2 && StringUtils.isNotBlank(parts.get(2))) {
    myQuantity.setUnits(parts.get(2));
  }
}",0.9709080223332354
112300,"@Override String doGetQueryParameterQualifier(){
  return super.getQueryParameterQualifier();
}","@Override String doGetQueryParameterQualifier(){
  return null;
}",0.7875
112301,"private Set<Long> addPredicateString(String theParamName,Set<Long> thePids,List<? extends IQueryParameterType> theList){
  if (theList == null || theList.isEmpty()) {
    return thePids;
  }
  if (Boolean.TRUE.equals(theList.get(0).getMissing())) {
    return addPredicateParamMissing(thePids,""String_Node_Str"");
  }
  CriteriaBuilder builder=myEntityManager.getCriteriaBuilder();
  CriteriaQuery<Long> cq=builder.createQuery(Long.class);
  Root<ResourceIndexedSearchParamString> from=cq.from(ResourceIndexedSearchParamString.class);
  cq.select(from.get(""String_Node_Str"").as(Long.class));
  List<Predicate> codePredicates=new ArrayList<Predicate>();
  for (  IQueryParameterType nextOr : theList) {
    IQueryParameterType theParameter=nextOr;
    if (addPredicateMissingFalseIfPresent(theParamName,from,codePredicates,nextOr)) {
      continue;
    }
    Predicate singleCode=createPredicateString(theParameter,theParamName,builder,from);
    codePredicates.add(singleCode);
  }
  Predicate masterCodePredicate=builder.or(codePredicates.toArray(new Predicate[0]));
  Predicate type=builder.equal(from.get(""String_Node_Str""),myResourceName);
  Predicate name=builder.equal(from.get(""String_Node_Str""),theParamName);
  if (thePids.size() > 0) {
    Predicate inPids=(from.get(""String_Node_Str"").in(thePids));
    cq.where(builder.and(type,name,masterCodePredicate,inPids));
  }
 else {
    cq.where(builder.and(type,name,masterCodePredicate));
  }
  TypedQuery<Long> q=myEntityManager.createQuery(cq);
  return new HashSet<Long>(q.getResultList());
}","private Set<Long> addPredicateString(String theParamName,Set<Long> thePids,List<? extends IQueryParameterType> theList){
  if (theList == null || theList.isEmpty()) {
    return thePids;
  }
  if (Boolean.TRUE.equals(theList.get(0).getMissing())) {
    return addPredicateParamMissing(thePids,""String_Node_Str"",theParamName,ResourceIndexedSearchParamString.class);
  }
  CriteriaBuilder builder=myEntityManager.getCriteriaBuilder();
  CriteriaQuery<Long> cq=builder.createQuery(Long.class);
  Root<ResourceIndexedSearchParamString> from=cq.from(ResourceIndexedSearchParamString.class);
  cq.select(from.get(""String_Node_Str"").as(Long.class));
  List<Predicate> codePredicates=new ArrayList<Predicate>();
  for (  IQueryParameterType nextOr : theList) {
    IQueryParameterType theParameter=nextOr;
    if (addPredicateMissingFalseIfPresent(builder,theParamName,from,codePredicates,nextOr)) {
      continue;
    }
    Predicate singleCode=createPredicateString(theParameter,theParamName,builder,from);
    codePredicates.add(singleCode);
  }
  Predicate masterCodePredicate=builder.or(codePredicates.toArray(new Predicate[0]));
  Predicate type=builder.equal(from.get(""String_Node_Str""),myResourceName);
  Predicate name=builder.equal(from.get(""String_Node_Str""),theParamName);
  if (thePids.size() > 0) {
    Predicate inPids=(from.get(""String_Node_Str"").in(thePids));
    cq.where(builder.and(type,name,masterCodePredicate,inPids));
  }
 else {
    cq.where(builder.and(type,name,masterCodePredicate));
  }
  TypedQuery<Long> q=myEntityManager.createQuery(cq);
  return new HashSet<Long>(q.getResultList());
}",0.9810246679316889
112302,"private Set<Long> addPredicateToken(String theParamName,Set<Long> thePids,List<? extends IQueryParameterType> theList){
  if (theList == null || theList.isEmpty()) {
    return thePids;
  }
  if (Boolean.TRUE.equals(theList.get(0).getMissing())) {
    return addPredicateParamMissing(thePids,""String_Node_Str"");
  }
  CriteriaBuilder builder=myEntityManager.getCriteriaBuilder();
  CriteriaQuery<Long> cq=builder.createQuery(Long.class);
  Root<ResourceIndexedSearchParamToken> from=cq.from(ResourceIndexedSearchParamToken.class);
  cq.select(from.get(""String_Node_Str"").as(Long.class));
  List<Predicate> codePredicates=new ArrayList<Predicate>();
  for (  IQueryParameterType nextOr : theList) {
    if (nextOr instanceof TokenParam) {
      TokenParam id=(TokenParam)nextOr;
      if (id.isText()) {
        return addPredicateString(theParamName,thePids,theList);
      }
    }
    if (addPredicateMissingFalseIfPresent(theParamName,from,codePredicates,nextOr)) {
      continue;
    }
    Predicate singleCode=createPredicateToken(nextOr,theParamName,builder,from);
    codePredicates.add(singleCode);
  }
  Predicate masterCodePredicate=builder.or(codePredicates.toArray(new Predicate[0]));
  Predicate type=builder.equal(from.get(""String_Node_Str""),myResourceName);
  Predicate name=builder.equal(from.get(""String_Node_Str""),theParamName);
  if (thePids.size() > 0) {
    Predicate inPids=(from.get(""String_Node_Str"").in(thePids));
    cq.where(builder.and(type,name,masterCodePredicate,inPids));
  }
 else {
    cq.where(builder.and(type,name,masterCodePredicate));
  }
  TypedQuery<Long> q=myEntityManager.createQuery(cq);
  return new HashSet<Long>(q.getResultList());
}","private Set<Long> addPredicateToken(String theParamName,Set<Long> thePids,List<? extends IQueryParameterType> theList){
  if (theList == null || theList.isEmpty()) {
    return thePids;
  }
  if (Boolean.TRUE.equals(theList.get(0).getMissing())) {
    return addPredicateParamMissing(thePids,""String_Node_Str"",theParamName,ResourceIndexedSearchParamToken.class);
  }
  CriteriaBuilder builder=myEntityManager.getCriteriaBuilder();
  CriteriaQuery<Long> cq=builder.createQuery(Long.class);
  Root<ResourceIndexedSearchParamToken> from=cq.from(ResourceIndexedSearchParamToken.class);
  cq.select(from.get(""String_Node_Str"").as(Long.class));
  List<Predicate> codePredicates=new ArrayList<Predicate>();
  for (  IQueryParameterType nextOr : theList) {
    if (addPredicateMissingFalseIfPresent(builder,theParamName,from,codePredicates,nextOr)) {
      continue;
    }
    if (nextOr instanceof TokenParam) {
      TokenParam id=(TokenParam)nextOr;
      if (id.isText()) {
        return addPredicateString(theParamName,thePids,theList);
      }
    }
    Predicate singleCode=createPredicateToken(nextOr,theParamName,builder,from);
    codePredicates.add(singleCode);
  }
  Predicate masterCodePredicate=builder.or(codePredicates.toArray(new Predicate[0]));
  Predicate type=builder.equal(from.get(""String_Node_Str""),myResourceName);
  Predicate name=builder.equal(from.get(""String_Node_Str""),theParamName);
  if (thePids.size() > 0) {
    Predicate inPids=(from.get(""String_Node_Str"").in(thePids));
    cq.where(builder.and(type,name,masterCodePredicate,inPids));
  }
 else {
    cq.where(builder.and(type,name,masterCodePredicate));
  }
  TypedQuery<Long> q=myEntityManager.createQuery(cq);
  return new HashSet<Long>(q.getResultList());
}",0.8751096811933314
112303,"private Set<Long> addPredicateParamMissing(Set<Long> thePids,String joinName){
  CriteriaBuilder builder=myEntityManager.getCriteriaBuilder();
  CriteriaQuery<Long> cq=builder.createQuery(Long.class);
  Root<ResourceTable> from=cq.from(ResourceTable.class);
  cq.select(from.get(""String_Node_Str"").as(Long.class));
  Join<Object,Object> join=from.join(joinName,JoinType.LEFT);
  if (thePids.size() > 0) {
    Predicate inPids=(from.get(""String_Node_Str"").in(thePids));
    cq.where(builder.and(inPids,join.isNull()));
  }
 else {
    cq.where(join.isNull());
  }
  TypedQuery<Long> q=myEntityManager.createQuery(cq);
  return new HashSet<Long>(q.getResultList());
}","private Set<Long> addPredicateParamMissing(Set<Long> thePids,String joinName,String theParamName,Class<? extends BaseResourceIndexedSearchParam> theParamTable){
  CriteriaBuilder builder=myEntityManager.getCriteriaBuilder();
  CriteriaQuery<Long> cq=builder.createQuery(Long.class);
  Root<ResourceTable> from=cq.from(ResourceTable.class);
  cq.select(from.get(""String_Node_Str"").as(Long.class));
  Subquery<Long> subQ=cq.subquery(Long.class);
  Root<? extends BaseResourceIndexedSearchParam> subQfrom=subQ.from(theParamTable);
  subQ.select(subQfrom.get(""String_Node_Str"").as(Long.class));
  subQ.where(builder.equal(subQfrom.get(""String_Node_Str""),theParamName));
  Predicate joinPredicate=builder.not(builder.in(from.get(""String_Node_Str"")).value(subQ));
  if (thePids.size() > 0) {
    Predicate inPids=(from.get(""String_Node_Str"").in(thePids));
    cq.where(builder.and(inPids,joinPredicate));
  }
 else {
    cq.where(joinPredicate);
  }
  TypedQuery<Long> q=myEntityManager.createQuery(cq);
  List<Long> resultList=q.getResultList();
  HashSet<Long> retVal=new HashSet<Long>(resultList);
  return retVal;
}",0.4499437570303712
112304,"private boolean addPredicateMissingFalseIfPresentForResourceLink(String theParamName,Root<? extends ResourceLink> from,List<Predicate> codePredicates,IQueryParameterType nextOr){
  boolean missingFalse=false;
  if (nextOr.getMissing() != null) {
    if (nextOr.getMissing().booleanValue() == true) {
      throw new InvalidRequestException(getContext().getLocalizer().getMessage(BaseFhirResourceDao.class,""String_Node_Str"",theParamName));
    }
    Predicate singleCode=from.get(""String_Node_Str"").isNotNull();
    codePredicates.add(singleCode);
    missingFalse=true;
  }
  return missingFalse;
}","private boolean addPredicateMissingFalseIfPresentForResourceLink(CriteriaBuilder theBuilder,String theParamName,Root<? extends ResourceLink> from,List<Predicate> codePredicates,IQueryParameterType nextOr){
  boolean missingFalse=false;
  if (nextOr.getMissing() != null) {
    if (nextOr.getMissing().booleanValue() == true) {
      throw new InvalidRequestException(getContext().getLocalizer().getMessage(BaseFhirResourceDao.class,""String_Node_Str"",theParamName));
    }
    Predicate singleCode=from.get(""String_Node_Str"").isNotNull();
    Predicate name=createResourceLinkPathPredicate(theParamName,theBuilder,from);
    codePredicates.add(theBuilder.and(name,singleCode));
    missingFalse=true;
  }
  return missingFalse;
}",0.8733031674208145
112305,"private Set<Long> addPredicateNumber(String theParamName,Set<Long> thePids,List<? extends IQueryParameterType> theList){
  if (theList == null || theList.isEmpty()) {
    return thePids;
  }
  if (Boolean.TRUE.equals(theList.get(0).getMissing())) {
    return addPredicateParamMissing(thePids,""String_Node_Str"");
  }
  CriteriaBuilder builder=myEntityManager.getCriteriaBuilder();
  CriteriaQuery<Long> cq=builder.createQuery(Long.class);
  Root<ResourceIndexedSearchParamNumber> from=cq.from(ResourceIndexedSearchParamNumber.class);
  cq.select(from.get(""String_Node_Str"").as(Long.class));
  List<Predicate> codePredicates=new ArrayList<Predicate>();
  for (  IQueryParameterType nextOr : theList) {
    IQueryParameterType params=nextOr;
    if (addPredicateMissingFalseIfPresent(theParamName,from,codePredicates,nextOr)) {
      continue;
    }
    if (params instanceof NumberParam) {
      NumberParam param=(NumberParam)params;
      BigDecimal value=param.getValue();
      if (value == null) {
        return thePids;
      }
      Path<Object> fromObj=from.get(""String_Node_Str"");
      if (param.getComparator() == null) {
        double mul=value.doubleValue() * 1.01;
        double low=value.doubleValue() - mul;
        double high=value.doubleValue() + mul;
        Predicate lowPred=builder.ge(fromObj.as(Long.class),low);
        Predicate highPred=builder.le(fromObj.as(Long.class),high);
        codePredicates.add(builder.and(lowPred,highPred));
      }
 else {
switch (param.getComparator()) {
case GREATERTHAN:
          codePredicates.add(builder.greaterThan(fromObj.as(BigDecimal.class),value));
        break;
case GREATERTHAN_OR_EQUALS:
      codePredicates.add(builder.ge(fromObj.as(BigDecimal.class),value));
    break;
case LESSTHAN:
  codePredicates.add(builder.lessThan(fromObj.as(BigDecimal.class),value));
break;
case LESSTHAN_OR_EQUALS:
codePredicates.add(builder.le(fromObj.as(BigDecimal.class),value));
break;
}
}
}
 else {
throw new IllegalArgumentException(""String_Node_Str"" + params.getClass());
}
}
Predicate masterCodePredicate=builder.or(codePredicates.toArray(new Predicate[0]));
Predicate type=builder.equal(from.get(""String_Node_Str""),myResourceName);
Predicate name=builder.equal(from.get(""String_Node_Str""),theParamName);
if (thePids.size() > 0) {
Predicate inPids=(from.get(""String_Node_Str"").in(thePids));
cq.where(builder.and(type,name,masterCodePredicate,inPids));
}
 else {
cq.where(builder.and(type,name,masterCodePredicate));
}
TypedQuery<Long> q=myEntityManager.createQuery(cq);
return new HashSet<Long>(q.getResultList());
}","private Set<Long> addPredicateNumber(String theParamName,Set<Long> thePids,List<? extends IQueryParameterType> theList){
  if (theList == null || theList.isEmpty()) {
    return thePids;
  }
  if (Boolean.TRUE.equals(theList.get(0).getMissing())) {
    return addPredicateParamMissing(thePids,""String_Node_Str"",theParamName,ResourceIndexedSearchParamNumber.class);
  }
  CriteriaBuilder builder=myEntityManager.getCriteriaBuilder();
  CriteriaQuery<Long> cq=builder.createQuery(Long.class);
  Root<ResourceIndexedSearchParamNumber> from=cq.from(ResourceIndexedSearchParamNumber.class);
  cq.select(from.get(""String_Node_Str"").as(Long.class));
  List<Predicate> codePredicates=new ArrayList<Predicate>();
  for (  IQueryParameterType nextOr : theList) {
    IQueryParameterType params=nextOr;
    if (addPredicateMissingFalseIfPresent(builder,theParamName,from,codePredicates,nextOr)) {
      continue;
    }
    if (params instanceof NumberParam) {
      NumberParam param=(NumberParam)params;
      BigDecimal value=param.getValue();
      if (value == null) {
        return thePids;
      }
      Path<Object> fromObj=from.get(""String_Node_Str"");
      if (param.getComparator() == null) {
        double mul=value.doubleValue() * 1.01;
        double low=value.doubleValue() - mul;
        double high=value.doubleValue() + mul;
        Predicate lowPred=builder.ge(fromObj.as(Long.class),low);
        Predicate highPred=builder.le(fromObj.as(Long.class),high);
        codePredicates.add(builder.and(lowPred,highPred));
      }
 else {
switch (param.getComparator()) {
case GREATERTHAN:
          codePredicates.add(builder.greaterThan(fromObj.as(BigDecimal.class),value));
        break;
case GREATERTHAN_OR_EQUALS:
      codePredicates.add(builder.ge(fromObj.as(BigDecimal.class),value));
    break;
case LESSTHAN:
  codePredicates.add(builder.lessThan(fromObj.as(BigDecimal.class),value));
break;
case LESSTHAN_OR_EQUALS:
codePredicates.add(builder.le(fromObj.as(BigDecimal.class),value));
break;
}
}
}
 else {
throw new IllegalArgumentException(""String_Node_Str"" + params.getClass());
}
}
Predicate masterCodePredicate=builder.or(codePredicates.toArray(new Predicate[0]));
Predicate type=builder.equal(from.get(""String_Node_Str""),myResourceName);
Predicate name=builder.equal(from.get(""String_Node_Str""),theParamName);
if (thePids.size() > 0) {
Predicate inPids=(from.get(""String_Node_Str"").in(thePids));
cq.where(builder.and(type,name,masterCodePredicate,inPids));
}
 else {
cq.where(builder.and(type,name,masterCodePredicate));
}
TypedQuery<Long> q=myEntityManager.createQuery(cq);
return new HashSet<Long>(q.getResultList());
}",0.9885057471264368
112306,"private boolean addPredicateMissingFalseIfPresent(String theParamName,Root<? extends BaseResourceIndexedSearchParam> from,List<Predicate> codePredicates,IQueryParameterType nextOr){
  boolean missingFalse=false;
  if (nextOr.getMissing() != null) {
    if (nextOr.getMissing().booleanValue() == true) {
      throw new InvalidRequestException(getContext().getLocalizer().getMessage(BaseFhirResourceDao.class,""String_Node_Str"",theParamName));
    }
    Predicate singleCode=from.get(""String_Node_Str"").isNotNull();
    codePredicates.add(singleCode);
    missingFalse=true;
  }
  return missingFalse;
}","private boolean addPredicateMissingFalseIfPresent(CriteriaBuilder theBuilder,String theParamName,Root<? extends BaseResourceIndexedSearchParam> from,List<Predicate> codePredicates,IQueryParameterType nextOr){
  boolean missingFalse=false;
  if (nextOr.getMissing() != null) {
    if (nextOr.getMissing().booleanValue() == true) {
      throw new InvalidRequestException(getContext().getLocalizer().getMessage(BaseFhirResourceDao.class,""String_Node_Str"",theParamName));
    }
    Predicate singleCode=from.get(""String_Node_Str"").isNotNull();
    Predicate name=theBuilder.equal(from.get(""String_Node_Str""),theParamName);
    codePredicates.add(theBuilder.and(name,singleCode));
    missingFalse=true;
  }
  return missingFalse;
}",0.8758465011286681
112307,"private Set<Long> addPredicateDate(String theParamName,Set<Long> thePids,List<? extends IQueryParameterType> theList){
  if (theList == null || theList.isEmpty()) {
    return thePids;
  }
  if (Boolean.TRUE.equals(theList.get(0).getMissing())) {
    return addPredicateParamMissing(thePids,""String_Node_Str"");
  }
  CriteriaBuilder builder=myEntityManager.getCriteriaBuilder();
  CriteriaQuery<Long> cq=builder.createQuery(Long.class);
  Root<ResourceIndexedSearchParamDate> from=cq.from(ResourceIndexedSearchParamDate.class);
  cq.select(from.get(""String_Node_Str"").as(Long.class));
  List<Predicate> codePredicates=new ArrayList<Predicate>();
  for (  IQueryParameterType nextOr : theList) {
    if (addPredicateMissingFalseIfPresent(theParamName,from,codePredicates,nextOr)) {
      continue;
    }
    IQueryParameterType params=nextOr;
    Predicate p=createPredicateDate(builder,from,params);
    codePredicates.add(p);
  }
  Predicate masterCodePredicate=builder.or(codePredicates.toArray(new Predicate[0]));
  Predicate type=builder.equal(from.get(""String_Node_Str""),myResourceName);
  Predicate name=builder.equal(from.get(""String_Node_Str""),theParamName);
  if (thePids.size() > 0) {
    Predicate inPids=(from.get(""String_Node_Str"").in(thePids));
    cq.where(builder.and(type,name,masterCodePredicate,inPids));
  }
 else {
    cq.where(builder.and(type,name,masterCodePredicate));
  }
  TypedQuery<Long> q=myEntityManager.createQuery(cq);
  return new HashSet<Long>(q.getResultList());
}","private Set<Long> addPredicateDate(String theParamName,Set<Long> thePids,List<? extends IQueryParameterType> theList){
  if (theList == null || theList.isEmpty()) {
    return thePids;
  }
  if (Boolean.TRUE.equals(theList.get(0).getMissing())) {
    return addPredicateParamMissing(thePids,""String_Node_Str"",theParamName,ResourceIndexedSearchParamDate.class);
  }
  CriteriaBuilder builder=myEntityManager.getCriteriaBuilder();
  CriteriaQuery<Long> cq=builder.createQuery(Long.class);
  Root<ResourceIndexedSearchParamDate> from=cq.from(ResourceIndexedSearchParamDate.class);
  cq.select(from.get(""String_Node_Str"").as(Long.class));
  List<Predicate> codePredicates=new ArrayList<Predicate>();
  for (  IQueryParameterType nextOr : theList) {
    if (addPredicateMissingFalseIfPresent(builder,theParamName,from,codePredicates,nextOr)) {
      continue;
    }
    IQueryParameterType params=nextOr;
    Predicate p=createPredicateDate(builder,from,params);
    codePredicates.add(p);
  }
  Predicate masterCodePredicate=builder.or(codePredicates.toArray(new Predicate[0]));
  Predicate type=builder.equal(from.get(""String_Node_Str""),myResourceName);
  Predicate name=builder.equal(from.get(""String_Node_Str""),theParamName);
  if (thePids.size() > 0) {
    Predicate inPids=(from.get(""String_Node_Str"").in(thePids));
    cq.where(builder.and(type,name,masterCodePredicate,inPids));
  }
 else {
    cq.where(builder.and(type,name,masterCodePredicate));
  }
  TypedQuery<Long> q=myEntityManager.createQuery(cq);
  return new HashSet<Long>(q.getResultList());
}",0.9810333551340744
112308,"private Set<Long> addPredicateQuantity(String theParamName,Set<Long> thePids,List<? extends IQueryParameterType> theList){
  if (theList == null || theList.isEmpty()) {
    return thePids;
  }
  if (Boolean.TRUE.equals(theList.get(0).getMissing())) {
    return addPredicateParamMissing(thePids,""String_Node_Str"");
  }
  CriteriaBuilder builder=myEntityManager.getCriteriaBuilder();
  CriteriaQuery<Long> cq=builder.createQuery(Long.class);
  Root<ResourceIndexedSearchParamQuantity> from=cq.from(ResourceIndexedSearchParamQuantity.class);
  cq.select(from.get(""String_Node_Str"").as(Long.class));
  List<Predicate> codePredicates=new ArrayList<Predicate>();
  for (  IQueryParameterType nextOr : theList) {
    IQueryParameterType params=nextOr;
    if (addPredicateMissingFalseIfPresent(theParamName,from,codePredicates,nextOr)) {
      continue;
    }
    String systemValue;
    String unitsValue;
    QuantityCompararatorEnum cmpValue;
    BigDecimal valueValue;
    boolean approx=false;
    if (params instanceof BaseQuantityDt) {
      BaseQuantityDt param=(BaseQuantityDt)params;
      systemValue=param.getSystemElement().getValueAsString();
      unitsValue=param.getUnitsElement().getValueAsString();
      cmpValue=QuantityCompararatorEnum.VALUESET_BINDER.fromCodeString(param.getComparatorElement().getValueAsString());
      valueValue=param.getValueElement().getValue();
    }
 else     if (params instanceof QuantityParam) {
      QuantityParam param=(QuantityParam)params;
      systemValue=param.getSystem().getValueAsString();
      unitsValue=param.getUnits();
      cmpValue=param.getComparator();
      valueValue=param.getValue().getValue();
      approx=param.isApproximate();
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + params.getClass());
    }
    Predicate system=null;
    if (!isBlank(systemValue)) {
      system=builder.equal(from.get(""String_Node_Str""),systemValue);
    }
    Predicate code=null;
    if (!isBlank(unitsValue)) {
      code=builder.equal(from.get(""String_Node_Str""),unitsValue);
    }
    Predicate num;
    if (cmpValue == null) {
      BigDecimal mul=approx ? new BigDecimal(0.1) : new BigDecimal(0.01);
      BigDecimal low=valueValue.subtract(valueValue.multiply(mul));
      BigDecimal high=valueValue.add(valueValue.multiply(mul));
      Predicate lowPred=builder.gt(from.get(""String_Node_Str"").as(BigDecimal.class),low);
      Predicate highPred=builder.lt(from.get(""String_Node_Str"").as(BigDecimal.class),high);
      num=builder.and(lowPred,highPred);
    }
 else {
switch (cmpValue) {
case GREATERTHAN:
        Expression<Number> path=from.get(""String_Node_Str"");
      num=builder.gt(path,valueValue);
    break;
case GREATERTHAN_OR_EQUALS:
  path=from.get(""String_Node_Str"");
num=builder.ge(path,valueValue);
break;
case LESSTHAN:
path=from.get(""String_Node_Str"");
num=builder.lt(path,valueValue);
break;
case LESSTHAN_OR_EQUALS:
path=from.get(""String_Node_Str"");
num=builder.le(path,valueValue);
break;
default :
throw new IllegalStateException(cmpValue.getCode());
}
}
if (system == null && code == null) {
codePredicates.add(num);
}
 else if (system == null) {
Predicate singleCode=builder.and(code,num);
codePredicates.add(singleCode);
}
 else if (code == null) {
Predicate singleCode=builder.and(system,num);
codePredicates.add(singleCode);
}
 else {
Predicate singleCode=builder.and(system,code,num);
codePredicates.add(singleCode);
}
}
Predicate masterCodePredicate=builder.or(codePredicates.toArray(new Predicate[0]));
Predicate type=builder.equal(from.get(""String_Node_Str""),myResourceName);
Predicate name=builder.equal(from.get(""String_Node_Str""),theParamName);
if (thePids.size() > 0) {
Predicate inPids=(from.get(""String_Node_Str"").in(thePids));
cq.where(builder.and(type,name,masterCodePredicate,inPids));
}
 else {
cq.where(builder.and(type,name,masterCodePredicate));
}
TypedQuery<Long> q=myEntityManager.createQuery(cq);
return new HashSet<Long>(q.getResultList());
}","private Set<Long> addPredicateQuantity(String theParamName,Set<Long> thePids,List<? extends IQueryParameterType> theList){
  if (theList == null || theList.isEmpty()) {
    return thePids;
  }
  if (Boolean.TRUE.equals(theList.get(0).getMissing())) {
    return addPredicateParamMissing(thePids,""String_Node_Str"",theParamName,ResourceIndexedSearchParamQuantity.class);
  }
  CriteriaBuilder builder=myEntityManager.getCriteriaBuilder();
  CriteriaQuery<Long> cq=builder.createQuery(Long.class);
  Root<ResourceIndexedSearchParamQuantity> from=cq.from(ResourceIndexedSearchParamQuantity.class);
  cq.select(from.get(""String_Node_Str"").as(Long.class));
  List<Predicate> codePredicates=new ArrayList<Predicate>();
  for (  IQueryParameterType nextOr : theList) {
    IQueryParameterType params=nextOr;
    if (addPredicateMissingFalseIfPresent(builder,theParamName,from,codePredicates,nextOr)) {
      continue;
    }
    String systemValue;
    String unitsValue;
    QuantityCompararatorEnum cmpValue;
    BigDecimal valueValue;
    boolean approx=false;
    if (params instanceof BaseQuantityDt) {
      BaseQuantityDt param=(BaseQuantityDt)params;
      systemValue=param.getSystemElement().getValueAsString();
      unitsValue=param.getUnitsElement().getValueAsString();
      cmpValue=QuantityCompararatorEnum.VALUESET_BINDER.fromCodeString(param.getComparatorElement().getValueAsString());
      valueValue=param.getValueElement().getValue();
    }
 else     if (params instanceof QuantityParam) {
      QuantityParam param=(QuantityParam)params;
      systemValue=param.getSystem().getValueAsString();
      unitsValue=param.getUnits();
      cmpValue=param.getComparator();
      valueValue=param.getValue().getValue();
      approx=param.isApproximate();
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + params.getClass());
    }
    Predicate system=null;
    if (!isBlank(systemValue)) {
      system=builder.equal(from.get(""String_Node_Str""),systemValue);
    }
    Predicate code=null;
    if (!isBlank(unitsValue)) {
      code=builder.equal(from.get(""String_Node_Str""),unitsValue);
    }
    Predicate num;
    if (cmpValue == null) {
      BigDecimal mul=approx ? new BigDecimal(0.1) : new BigDecimal(0.01);
      BigDecimal low=valueValue.subtract(valueValue.multiply(mul));
      BigDecimal high=valueValue.add(valueValue.multiply(mul));
      Predicate lowPred=builder.gt(from.get(""String_Node_Str"").as(BigDecimal.class),low);
      Predicate highPred=builder.lt(from.get(""String_Node_Str"").as(BigDecimal.class),high);
      num=builder.and(lowPred,highPred);
    }
 else {
switch (cmpValue) {
case GREATERTHAN:
        Expression<Number> path=from.get(""String_Node_Str"");
      num=builder.gt(path,valueValue);
    break;
case GREATERTHAN_OR_EQUALS:
  path=from.get(""String_Node_Str"");
num=builder.ge(path,valueValue);
break;
case LESSTHAN:
path=from.get(""String_Node_Str"");
num=builder.lt(path,valueValue);
break;
case LESSTHAN_OR_EQUALS:
path=from.get(""String_Node_Str"");
num=builder.le(path,valueValue);
break;
default :
throw new IllegalStateException(cmpValue.getCode());
}
}
if (system == null && code == null) {
codePredicates.add(num);
}
 else if (system == null) {
Predicate singleCode=builder.and(code,num);
codePredicates.add(singleCode);
}
 else if (code == null) {
Predicate singleCode=builder.and(system,num);
codePredicates.add(singleCode);
}
 else {
Predicate singleCode=builder.and(system,code,num);
codePredicates.add(singleCode);
}
}
Predicate masterCodePredicate=builder.or(codePredicates.toArray(new Predicate[0]));
Predicate type=builder.equal(from.get(""String_Node_Str""),myResourceName);
Predicate name=builder.equal(from.get(""String_Node_Str""),theParamName);
if (thePids.size() > 0) {
Predicate inPids=(from.get(""String_Node_Str"").in(thePids));
cq.where(builder.and(type,name,masterCodePredicate,inPids));
}
 else {
cq.where(builder.and(type,name,masterCodePredicate));
}
TypedQuery<Long> q=myEntityManager.createQuery(cq);
return new HashSet<Long>(q.getResultList());
}",0.9922654690618764
112309,"/** 
 * Creates a new entry using the given resource and populates it accordingly
 * @param theResource The resource to add
 * @return Returns the newly created bundle entry that was added to the bundle
 */
public BundleEntry addResource(IResource theResource,FhirContext theContext,String theServerBase){
  BundleEntry entry=addEntry();
  entry.setResource(theResource);
  RuntimeResourceDefinition def=theContext.getResourceDefinition(theResource);
  String title=ResourceMetadataKeyEnum.TITLE.get(theResource);
  if (title != null) {
    entry.getTitle().setValue(title);
  }
 else {
    entry.getTitle().setValue(def.getName() + ""String_Node_Str"" + StringUtils.defaultString(theResource.getId().getValue(),""String_Node_Str""));
  }
  if (theResource.getId() != null) {
    if (theResource.getId().isAbsolute()) {
      entry.getLinkSelf().setValue(theResource.getId().getValue());
      entry.getId().setValue(theResource.getId().toVersionless().getValue());
    }
 else     if (StringUtils.isNotBlank(theResource.getId().getValue())) {
      StringBuilder b=new StringBuilder();
      b.append(theServerBase);
      if (b.length() > 0 && b.charAt(b.length() - 1) != '/') {
        b.append('/');
      }
      b.append(def.getName());
      b.append('/');
      String resId=theResource.getId().getIdPart();
      b.append(resId);
      entry.getId().setValue(b.toString());
      if (isNotBlank(theResource.getId().getVersionIdPart())) {
        b.append('/');
        b.append(Constants.PARAM_HISTORY);
        b.append('/');
        b.append(theResource.getId().getVersionIdPart());
      }
 else {
        IdDt versionId=(IdDt)ResourceMetadataKeyEnum.VERSION_ID.get(theResource);
        if (versionId != null) {
          b.append('/');
          b.append(Constants.PARAM_HISTORY);
          b.append('/');
          b.append(versionId.getValue());
        }
      }
      String qualifiedId=b.toString();
      entry.getLinkSelf().setValue(qualifiedId);
    }
  }
  InstantDt published=ResourceMetadataKeyEnum.PUBLISHED.get(theResource);
  if (published == null) {
    entry.getPublished().setToCurrentTimeInLocalTimeZone();
  }
 else {
    entry.setPublished(published);
  }
  InstantDt updated=ResourceMetadataKeyEnum.UPDATED.get(theResource);
  if (updated != null) {
    entry.setUpdated(updated);
  }
  InstantDt deleted=ResourceMetadataKeyEnum.DELETED_AT.get(theResource);
  if (deleted != null) {
    entry.setDeleted(deleted);
  }
  IdDt previous=ResourceMetadataKeyEnum.PREVIOUS_ID.get(theResource);
  if (previous != null) {
    entry.getLinkAlternate().setValue(previous.withServerBase(theServerBase,def.getName()).getValue());
  }
  TagList tagList=ResourceMetadataKeyEnum.TAG_LIST.get(theResource);
  if (tagList != null) {
    for (    Tag nextTag : tagList) {
      entry.addCategory(nextTag);
    }
  }
  String linkSearch=ResourceMetadataKeyEnum.LINK_SEARCH.get(theResource);
  if (isNotBlank(linkSearch)) {
    if (!UrlUtil.isAbsolute(linkSearch)) {
      linkSearch=(theServerBase + ""String_Node_Str"" + linkSearch);
    }
    entry.getLinkSearch().setValue(linkSearch);
  }
  String linkAlternate=ResourceMetadataKeyEnum.LINK_ALTERNATE.get(theResource);
  if (isNotBlank(linkAlternate)) {
    if (!UrlUtil.isAbsolute(linkAlternate)) {
      linkSearch=(theServerBase + ""String_Node_Str"" + linkAlternate);
    }
    entry.getLinkAlternate().setValue(linkSearch);
  }
  BundleEntrySearchModeEnum entryStatus=ResourceMetadataKeyEnum.ENTRY_SEARCH_MODE.get(theResource);
  if (entryStatus != null) {
    entry.getSearchMode().setValueAsEnum(entryStatus);
  }
  BundleEntryTransactionOperationEnum entryTransactionOperation=ResourceMetadataKeyEnum.ENTRY_TRANSACTION_OPERATION.get(theResource);
  if (entryTransactionOperation != null) {
    entry.getTransactionOperation().setValueAsEnum(entryTransactionOperation);
  }
  DecimalDt entryScore=ResourceMetadataKeyEnum.ENTRY_SCORE.get(theResource);
  if (entryScore != null) {
    entry.setScore(entryScore);
  }
  return entry;
}","/** 
 * Creates a new entry using the given resource and populates it accordingly
 * @param theResource The resource to add
 * @return Returns the newly created bundle entry that was added to the bundle
 */
public BundleEntry addResource(IResource theResource,FhirContext theContext,String theServerBase){
  BundleEntry entry=addEntry();
  entry.setResource(theResource);
  RuntimeResourceDefinition def=theContext.getResourceDefinition(theResource);
  String title=ResourceMetadataKeyEnum.TITLE.get(theResource);
  if (title != null) {
    entry.getTitle().setValue(title);
  }
 else {
    entry.getTitle().setValue(def.getName() + ""String_Node_Str"" + StringUtils.defaultString(theResource.getId().getValue(),""String_Node_Str""));
  }
  if (theResource.getId() != null) {
    if (theResource.getId().isAbsolute()) {
      entry.getLinkSelf().setValue(theResource.getId().getValue());
      entry.getId().setValue(theResource.getId().toVersionless().getValue());
    }
 else     if (StringUtils.isNotBlank(theResource.getId().getValue())) {
      StringBuilder b=new StringBuilder();
      b.append(theServerBase);
      if (b.length() > 0 && b.charAt(b.length() - 1) != '/') {
        b.append('/');
      }
      b.append(def.getName());
      b.append('/');
      String resId=theResource.getId().getIdPart();
      b.append(resId);
      entry.getId().setValue(b.toString());
      if (isNotBlank(theResource.getId().getVersionIdPart())) {
        b.append('/');
        b.append(Constants.PARAM_HISTORY);
        b.append('/');
        b.append(theResource.getId().getVersionIdPart());
      }
 else {
        IdDt versionId=(IdDt)ResourceMetadataKeyEnum.VERSION_ID.get(theResource);
        if (versionId != null) {
          b.append('/');
          b.append(Constants.PARAM_HISTORY);
          b.append('/');
          b.append(versionId.getValue());
        }
      }
      String qualifiedId=b.toString();
      entry.getLinkSelf().setValue(qualifiedId);
    }
  }
  InstantDt published=ResourceMetadataKeyEnum.PUBLISHED.get(theResource);
  if (published == null) {
    entry.getPublished().setToCurrentTimeInLocalTimeZone();
  }
 else {
    entry.setPublished(published);
  }
  InstantDt updated=ResourceMetadataKeyEnum.UPDATED.get(theResource);
  if (updated != null) {
    entry.setUpdated(updated);
  }
  InstantDt deleted=ResourceMetadataKeyEnum.DELETED_AT.get(theResource);
  if (deleted != null) {
    entry.setDeleted(deleted);
  }
  IdDt previous=ResourceMetadataKeyEnum.PREVIOUS_ID.get(theResource);
  if (previous != null) {
    entry.getLinkAlternate().setValue(previous.withServerBase(theServerBase,def.getName()).getValue());
  }
  TagList tagList=ResourceMetadataKeyEnum.TAG_LIST.get(theResource);
  if (tagList != null) {
    for (    Tag nextTag : tagList) {
      entry.addCategory(nextTag);
    }
  }
  String linkSearch=ResourceMetadataKeyEnum.LINK_SEARCH.get(theResource);
  if (isNotBlank(linkSearch)) {
    if (!UrlUtil.isAbsolute(linkSearch)) {
      linkSearch=(theServerBase + ""String_Node_Str"" + linkSearch);
    }
    entry.getLinkSearch().setValue(linkSearch);
  }
  String linkAlternate=ResourceMetadataKeyEnum.LINK_ALTERNATE.get(theResource);
  if (isNotBlank(linkAlternate)) {
    if (!UrlUtil.isAbsolute(linkAlternate)) {
      linkSearch=(theServerBase + ""String_Node_Str"" + linkAlternate);
    }
    entry.getLinkAlternate().setValue(linkSearch);
  }
  BundleEntrySearchModeEnum entryStatus=ResourceMetadataKeyEnum.ENTRY_SEARCH_MODE.get(theResource);
  if (entryStatus != null) {
    entry.getSearchMode().setValueAsEnum(entryStatus);
  }
  BundleEntryTransactionMethodEnum entryTransactionOperation=ResourceMetadataKeyEnum.ENTRY_TRANSACTION_METHOD.get(theResource);
  if (entryTransactionOperation != null) {
    entry.getTransactionMethod().setValueAsEnum(entryTransactionOperation);
  }
  DecimalDt entryScore=ResourceMetadataKeyEnum.ENTRY_SCORE.get(theResource);
  if (entryScore != null) {
    entry.setScore(entryScore);
  }
  return entry;
}",0.9946202927561616
112310,"private void encodeBundleToWriterInDstu2Format(Bundle theBundle,JsonGenerator theEventWriter) throws IOException {
  theEventWriter.writeStartObject();
  theEventWriter.write(""String_Node_Str"",""String_Node_Str"");
  writeOptionalTagWithTextNode(theEventWriter,""String_Node_Str"",theBundle.getId().getIdPart());
  if (!ElementUtil.isEmpty(theBundle.getId().getVersionIdPart(),theBundle.getUpdated())) {
    theEventWriter.writeStartObject(""String_Node_Str"");
    writeOptionalTagWithTextNode(theEventWriter,""String_Node_Str"",theBundle.getId().getVersionIdPart());
    writeOptionalTagWithTextNode(theEventWriter,""String_Node_Str"",theBundle.getUpdated());
    theEventWriter.writeEnd();
  }
  writeOptionalTagWithTextNode(theEventWriter,""String_Node_Str"",theBundle.getType());
  writeOptionalTagWithTextNode(theEventWriter,""String_Node_Str"",theBundle.getLinkBase());
  writeOptionalTagWithNumberNode(theEventWriter,""String_Node_Str"",theBundle.getTotalResults());
  boolean linkStarted=false;
  linkStarted=writeAtomLinkInDstu2Format(theEventWriter,""String_Node_Str"",theBundle.getLinkNext(),linkStarted);
  linkStarted=writeAtomLinkInDstu2Format(theEventWriter,""String_Node_Str"",theBundle.getLinkSelf(),linkStarted);
  linkStarted=writeAtomLinkInDstu2Format(theEventWriter,""String_Node_Str"",theBundle.getLinkFirst(),linkStarted);
  linkStarted=writeAtomLinkInDstu2Format(theEventWriter,""String_Node_Str"",theBundle.getLinkPrevious(),linkStarted);
  linkStarted=writeAtomLinkInDstu2Format(theEventWriter,""String_Node_Str"",theBundle.getLinkLast(),linkStarted);
  if (linkStarted) {
    theEventWriter.writeEnd();
  }
  theEventWriter.writeStartArray(""String_Node_Str"");
  for (  BundleEntry nextEntry : theBundle.getEntries()) {
    theEventWriter.writeStartObject();
    writeOptionalTagWithTextNode(theEventWriter,""String_Node_Str"",determineResourceBaseUrl(theBundle.getLinkBase().getValue(),nextEntry));
    boolean deleted=nextEntry.getDeletedAt() != null && nextEntry.getDeletedAt().isEmpty() == false;
    IResource resource=nextEntry.getResource();
    if (resource != null && !resource.isEmpty() && !deleted) {
      RuntimeResourceDefinition resDef=myContext.getResourceDefinition(resource);
      encodeResourceToJsonStreamWriter(resDef,resource,theEventWriter,""String_Node_Str"",false);
    }
    if (nextEntry.getSearchMode().isEmpty() == false || nextEntry.getScore().isEmpty() == false) {
      theEventWriter.writeStartObject(""String_Node_Str"");
      writeOptionalTagWithTextNode(theEventWriter,""String_Node_Str"",nextEntry.getSearchMode().getValueAsString());
      writeOptionalTagWithDecimalNode(theEventWriter,""String_Node_Str"",nextEntry.getScore());
      theEventWriter.writeEnd();
    }
    if (nextEntry.getTransactionOperation().isEmpty() == false || nextEntry.getLinkSearch().isEmpty() == false) {
      theEventWriter.writeStartObject(""String_Node_Str"");
      writeOptionalTagWithTextNode(theEventWriter,""String_Node_Str"",nextEntry.getTransactionOperation().getValue());
      writeOptionalTagWithTextNode(theEventWriter,""String_Node_Str"",nextEntry.getLinkSearch().getValue());
      theEventWriter.writeEnd();
    }
    if (deleted) {
      theEventWriter.writeStartObject(""String_Node_Str"");
      if (nextEntry.getResource() != null) {
        theEventWriter.write(""String_Node_Str"",myContext.getResourceDefinition(nextEntry.getResource()).getName());
        writeOptionalTagWithTextNode(theEventWriter,""String_Node_Str"",nextEntry.getResource().getId().getIdPart());
        writeOptionalTagWithTextNode(theEventWriter,""String_Node_Str"",nextEntry.getResource().getId().getVersionIdPart());
      }
      writeTagWithTextNode(theEventWriter,""String_Node_Str"",nextEntry.getDeletedAt());
      theEventWriter.writeEnd();
    }
    if (nextEntry.getSummary().isEmpty() == false) {
      theEventWriter.write(""String_Node_Str"",nextEntry.getSummary().getValueAsString());
    }
    theEventWriter.writeEnd();
  }
  theEventWriter.writeEnd();
  theEventWriter.writeEnd();
}","private void encodeBundleToWriterInDstu2Format(Bundle theBundle,JsonGenerator theEventWriter) throws IOException {
  theEventWriter.writeStartObject();
  theEventWriter.write(""String_Node_Str"",""String_Node_Str"");
  writeOptionalTagWithTextNode(theEventWriter,""String_Node_Str"",theBundle.getId().getIdPart());
  if (!ElementUtil.isEmpty(theBundle.getId().getVersionIdPart(),theBundle.getUpdated())) {
    theEventWriter.writeStartObject(""String_Node_Str"");
    writeOptionalTagWithTextNode(theEventWriter,""String_Node_Str"",theBundle.getId().getVersionIdPart());
    writeOptionalTagWithTextNode(theEventWriter,""String_Node_Str"",theBundle.getUpdated());
    theEventWriter.writeEnd();
  }
  writeOptionalTagWithTextNode(theEventWriter,""String_Node_Str"",theBundle.getType());
  writeOptionalTagWithTextNode(theEventWriter,""String_Node_Str"",theBundle.getLinkBase());
  writeOptionalTagWithNumberNode(theEventWriter,""String_Node_Str"",theBundle.getTotalResults());
  boolean linkStarted=false;
  linkStarted=writeAtomLinkInDstu2Format(theEventWriter,""String_Node_Str"",theBundle.getLinkNext(),linkStarted);
  linkStarted=writeAtomLinkInDstu2Format(theEventWriter,""String_Node_Str"",theBundle.getLinkSelf(),linkStarted);
  linkStarted=writeAtomLinkInDstu2Format(theEventWriter,""String_Node_Str"",theBundle.getLinkFirst(),linkStarted);
  linkStarted=writeAtomLinkInDstu2Format(theEventWriter,""String_Node_Str"",theBundle.getLinkPrevious(),linkStarted);
  linkStarted=writeAtomLinkInDstu2Format(theEventWriter,""String_Node_Str"",theBundle.getLinkLast(),linkStarted);
  if (linkStarted) {
    theEventWriter.writeEnd();
  }
  theEventWriter.writeStartArray(""String_Node_Str"");
  for (  BundleEntry nextEntry : theBundle.getEntries()) {
    theEventWriter.writeStartObject();
    writeOptionalTagWithTextNode(theEventWriter,""String_Node_Str"",determineResourceBaseUrl(theBundle.getLinkBase().getValue(),nextEntry));
    boolean deleted=nextEntry.getDeletedAt() != null && nextEntry.getDeletedAt().isEmpty() == false;
    IResource resource=nextEntry.getResource();
    if (resource != null && !resource.isEmpty() && !deleted) {
      RuntimeResourceDefinition resDef=myContext.getResourceDefinition(resource);
      encodeResourceToJsonStreamWriter(resDef,resource,theEventWriter,""String_Node_Str"",false);
    }
    if (nextEntry.getSearchMode().isEmpty() == false || nextEntry.getScore().isEmpty() == false) {
      theEventWriter.writeStartObject(""String_Node_Str"");
      writeOptionalTagWithTextNode(theEventWriter,""String_Node_Str"",nextEntry.getSearchMode().getValueAsString());
      writeOptionalTagWithDecimalNode(theEventWriter,""String_Node_Str"",nextEntry.getScore());
      theEventWriter.writeEnd();
    }
    if (nextEntry.getTransactionMethod().isEmpty() == false || nextEntry.getLinkSearch().isEmpty() == false) {
      theEventWriter.writeStartObject(""String_Node_Str"");
      writeOptionalTagWithTextNode(theEventWriter,""String_Node_Str"",nextEntry.getTransactionMethod().getValue());
      writeOptionalTagWithTextNode(theEventWriter,""String_Node_Str"",nextEntry.getLinkSearch().getValue());
      theEventWriter.writeEnd();
    }
    if (deleted) {
      theEventWriter.writeStartObject(""String_Node_Str"");
      if (nextEntry.getResource() != null) {
        theEventWriter.write(""String_Node_Str"",myContext.getResourceDefinition(nextEntry.getResource()).getName());
        writeOptionalTagWithTextNode(theEventWriter,""String_Node_Str"",nextEntry.getResource().getId().getIdPart());
        writeOptionalTagWithTextNode(theEventWriter,""String_Node_Str"",nextEntry.getResource().getId().getVersionIdPart());
      }
      writeTagWithTextNode(theEventWriter,""String_Node_Str"",nextEntry.getDeletedAt());
      theEventWriter.writeEnd();
    }
    if (nextEntry.getSummary().isEmpty() == false) {
      theEventWriter.write(""String_Node_Str"",nextEntry.getSummary().getValueAsString());
    }
    theEventWriter.writeEnd();
  }
  theEventWriter.writeEnd();
  theEventWriter.writeEnd();
}",0.9962358845671268
112311,"private void encodeBundleToWriterDstu2(Bundle theBundle,XMLStreamWriter theEventWriter) throws XMLStreamException {
  theEventWriter.writeStartElement(""String_Node_Str"");
  theEventWriter.writeDefaultNamespace(FHIR_NS);
  writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",theBundle.getId().getIdPart());
  InstantDt updated=(InstantDt)theBundle.getResourceMetadata().get(ResourceMetadataKeyEnum.UPDATED);
  IdDt bundleId=theBundle.getId();
  if (bundleId != null && isNotBlank(bundleId.getVersionIdPart()) || (updated != null && !updated.isEmpty())) {
    theEventWriter.writeStartElement(""String_Node_Str"");
    writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",bundleId.getVersionIdPart());
    if (updated != null) {
      writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",updated.getValueAsString());
    }
    theEventWriter.writeEndElement();
  }
  String bundleBaseUrl=theBundle.getLinkBase().getValue();
  writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",theBundle.getType().getValue());
  writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",bundleBaseUrl);
  writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",theBundle.getTotalResults().getValueAsString());
  writeBundleResourceLink(theEventWriter,""String_Node_Str"",theBundle.getLinkFirst());
  writeBundleResourceLink(theEventWriter,""String_Node_Str"",theBundle.getLinkPrevious());
  writeBundleResourceLink(theEventWriter,""String_Node_Str"",theBundle.getLinkNext());
  writeBundleResourceLink(theEventWriter,""String_Node_Str"",theBundle.getLinkLast());
  writeBundleResourceLink(theEventWriter,""String_Node_Str"",theBundle.getLinkSelf());
  for (  BundleEntry nextEntry : theBundle.getEntries()) {
    theEventWriter.writeStartElement(""String_Node_Str"");
    boolean deleted=false;
    if (nextEntry.getDeletedAt() != null && nextEntry.getDeletedAt().isEmpty() == false) {
      deleted=true;
    }
    writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",determineResourceBaseUrl(bundleBaseUrl,nextEntry));
    IResource resource=nextEntry.getResource();
    if (resource != null && !resource.isEmpty() && !deleted) {
      theEventWriter.writeStartElement(""String_Node_Str"");
      encodeResourceToXmlStreamWriter(resource,theEventWriter,false);
      theEventWriter.writeEndElement();
    }
 else {
      ourLog.debug(""String_Node_Str"");
    }
    if (nextEntry.getSearchMode().isEmpty() == false || nextEntry.getScore().isEmpty() == false) {
      theEventWriter.writeStartElement(""String_Node_Str"");
      writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",nextEntry.getSearchMode().getValueAsString());
      writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",nextEntry.getScore().getValueAsString());
      theEventWriter.writeEndElement();
    }
    if (nextEntry.getTransactionOperation().isEmpty() == false || nextEntry.getLinkSearch().isEmpty() == false) {
      theEventWriter.writeStartElement(""String_Node_Str"");
      writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",nextEntry.getTransactionOperation().getValue());
      writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",nextEntry.getLinkSearch().getValue());
      theEventWriter.writeEndElement();
    }
    if (deleted) {
      theEventWriter.writeStartElement(""String_Node_Str"");
      writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",nextEntry.getId().getResourceType());
      writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",nextEntry.getId().getIdPart());
      writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",nextEntry.getId().getVersionIdPart());
      writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",nextEntry.getDeletedAt().getValueAsString());
      theEventWriter.writeEndElement();
    }
    theEventWriter.writeEndElement();
  }
  theEventWriter.writeEndElement();
  theEventWriter.close();
}","private void encodeBundleToWriterDstu2(Bundle theBundle,XMLStreamWriter theEventWriter) throws XMLStreamException {
  theEventWriter.writeStartElement(""String_Node_Str"");
  theEventWriter.writeDefaultNamespace(FHIR_NS);
  writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",theBundle.getId().getIdPart());
  InstantDt updated=(InstantDt)theBundle.getResourceMetadata().get(ResourceMetadataKeyEnum.UPDATED);
  IdDt bundleId=theBundle.getId();
  if (bundleId != null && isNotBlank(bundleId.getVersionIdPart()) || (updated != null && !updated.isEmpty())) {
    theEventWriter.writeStartElement(""String_Node_Str"");
    writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",bundleId.getVersionIdPart());
    if (updated != null) {
      writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",updated.getValueAsString());
    }
    theEventWriter.writeEndElement();
  }
  String bundleBaseUrl=theBundle.getLinkBase().getValue();
  writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",theBundle.getType().getValue());
  writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",bundleBaseUrl);
  writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",theBundle.getTotalResults().getValueAsString());
  writeBundleResourceLink(theEventWriter,""String_Node_Str"",theBundle.getLinkFirst());
  writeBundleResourceLink(theEventWriter,""String_Node_Str"",theBundle.getLinkPrevious());
  writeBundleResourceLink(theEventWriter,""String_Node_Str"",theBundle.getLinkNext());
  writeBundleResourceLink(theEventWriter,""String_Node_Str"",theBundle.getLinkLast());
  writeBundleResourceLink(theEventWriter,""String_Node_Str"",theBundle.getLinkSelf());
  for (  BundleEntry nextEntry : theBundle.getEntries()) {
    theEventWriter.writeStartElement(""String_Node_Str"");
    boolean deleted=false;
    if (nextEntry.getDeletedAt() != null && nextEntry.getDeletedAt().isEmpty() == false) {
      deleted=true;
    }
    writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",determineResourceBaseUrl(bundleBaseUrl,nextEntry));
    IResource resource=nextEntry.getResource();
    if (resource != null && !resource.isEmpty() && !deleted) {
      theEventWriter.writeStartElement(""String_Node_Str"");
      encodeResourceToXmlStreamWriter(resource,theEventWriter,false);
      theEventWriter.writeEndElement();
    }
 else {
      ourLog.debug(""String_Node_Str"");
    }
    if (nextEntry.getSearchMode().isEmpty() == false || nextEntry.getScore().isEmpty() == false) {
      theEventWriter.writeStartElement(""String_Node_Str"");
      writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",nextEntry.getSearchMode().getValueAsString());
      writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",nextEntry.getScore().getValueAsString());
      theEventWriter.writeEndElement();
    }
    if (nextEntry.getTransactionMethod().isEmpty() == false || nextEntry.getLinkSearch().isEmpty() == false) {
      theEventWriter.writeStartElement(""String_Node_Str"");
      writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",nextEntry.getTransactionMethod().getValue());
      writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",nextEntry.getLinkSearch().getValue());
      theEventWriter.writeEndElement();
    }
    if (deleted) {
      theEventWriter.writeStartElement(""String_Node_Str"");
      writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",nextEntry.getId().getResourceType());
      writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",nextEntry.getId().getIdPart());
      writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",nextEntry.getId().getVersionIdPart());
      writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",nextEntry.getDeletedAt().getValueAsString());
      theEventWriter.writeEndElement();
    }
    theEventWriter.writeEndElement();
  }
  theEventWriter.writeEndElement();
  theEventWriter.close();
}",0.939974126778784
112312,"@Override public boolean handleException(RequestDetails theRequestDetails,Throwable theException,HttpServletRequest theRequest,HttpServletResponse theResponse) throws ServletException, IOException {
  BaseOperationOutcome oo=null;
  int statusCode=Constants.STATUS_HTTP_500_INTERNAL_ERROR;
  FhirContext ctx=theRequestDetails.getServer().getFhirContext();
  if (theException instanceof BaseServerResponseException) {
    oo=((BaseServerResponseException)theException).getOperationOutcome();
    statusCode=((BaseServerResponseException)theException).getStatusCode();
  }
  if (oo == null) {
    try {
      oo=(BaseOperationOutcome)ctx.getResourceDefinition(""String_Node_Str"").getImplementingClass().newInstance();
    }
 catch (    Exception e1) {
      ourLog.error(""String_Node_Str"",e1);
      throw new ServletException(""String_Node_Str"",e1);
    }
    BaseIssue issue=oo.addIssue();
    issue.getSeverityElement().setValue(""String_Node_Str"");
    if (theException instanceof InternalErrorException) {
      ourLog.error(""String_Node_Str"",theException);
      populateDetails(theException,issue);
    }
 else     if (theException instanceof BaseServerResponseException) {
      ourLog.warn(""String_Node_Str"",theException);
      BaseServerResponseException baseServerResponseException=(BaseServerResponseException)theException;
      statusCode=baseServerResponseException.getStatusCode();
      populateDetails(theException,issue);
      if (baseServerResponseException.getAdditionalMessages() != null) {
        for (        String next : baseServerResponseException.getAdditionalMessages()) {
          BaseIssue issue2=oo.addIssue();
          issue2.getSeverityElement().setValue(""String_Node_Str"");
          issue2.setDetails(next);
        }
      }
    }
 else {
      ourLog.error(""String_Node_Str"" + theException.toString(),theException);
      populateDetails(theException,issue);
      statusCode=Constants.STATUS_HTTP_500_INTERNAL_ERROR;
    }
  }
 else {
    ourLog.error(""String_Node_Str"",theException);
  }
  boolean requestIsBrowser=RestfulServer.requestIsBrowser(theRequest);
  String fhirServerBase=((Request)theRequestDetails).getFhirServerBase();
  RestfulServerUtils.streamResponseAsResource(theRequestDetails.getServer(),theResponse,oo,RestfulServerUtils.determineResponseEncodingNoDefault(theRequest),true,requestIsBrowser,NarrativeModeEnum.NORMAL,statusCode,false,fhirServerBase);
  theResponse.setStatus(statusCode);
  theRequestDetails.getServer().addHeadersToResponse(theResponse);
  theResponse.setContentType(""String_Node_Str"");
  theResponse.setCharacterEncoding(""String_Node_Str"");
  theResponse.getWriter().append(theException.getMessage());
  theResponse.getWriter().close();
  return false;
}","@Override public boolean handleException(RequestDetails theRequestDetails,Throwable theException,HttpServletRequest theRequest,HttpServletResponse theResponse) throws ServletException, IOException {
  ourLog.error(""String_Node_Str"",theException);
  BaseOperationOutcome oo=null;
  int statusCode=Constants.STATUS_HTTP_500_INTERNAL_ERROR;
  FhirContext ctx=theRequestDetails.getServer().getFhirContext();
  if (theException instanceof BaseServerResponseException) {
    oo=((BaseServerResponseException)theException).getOperationOutcome();
    statusCode=((BaseServerResponseException)theException).getStatusCode();
  }
  if (oo == null) {
    try {
      oo=(BaseOperationOutcome)ctx.getResourceDefinition(""String_Node_Str"").getImplementingClass().newInstance();
    }
 catch (    Exception e1) {
      ourLog.error(""String_Node_Str"",e1);
      throw new ServletException(""String_Node_Str"",e1);
    }
    BaseIssue issue=oo.addIssue();
    issue.getSeverityElement().setValue(""String_Node_Str"");
    if (theException instanceof InternalErrorException) {
      ourLog.error(""String_Node_Str"",theException);
      populateDetails(theException,issue);
    }
 else     if (theException instanceof BaseServerResponseException) {
      ourLog.warn(""String_Node_Str"",theException);
      BaseServerResponseException baseServerResponseException=(BaseServerResponseException)theException;
      statusCode=baseServerResponseException.getStatusCode();
      populateDetails(theException,issue);
      if (baseServerResponseException.getAdditionalMessages() != null) {
        for (        String next : baseServerResponseException.getAdditionalMessages()) {
          BaseIssue issue2=oo.addIssue();
          issue2.getSeverityElement().setValue(""String_Node_Str"");
          issue2.setDetails(next);
        }
      }
    }
 else {
      ourLog.error(""String_Node_Str"" + theException.toString(),theException);
      populateDetails(theException,issue);
      statusCode=Constants.STATUS_HTTP_500_INTERNAL_ERROR;
    }
  }
 else {
    ourLog.error(""String_Node_Str"",theException);
  }
  boolean requestIsBrowser=RestfulServer.requestIsBrowser(theRequest);
  String fhirServerBase=((Request)theRequestDetails).getFhirServerBase();
  RestfulServerUtils.streamResponseAsResource(theRequestDetails.getServer(),theResponse,oo,RestfulServerUtils.determineResponseEncodingNoDefault(theRequest),true,requestIsBrowser,NarrativeModeEnum.NORMAL,statusCode,false,fhirServerBase);
  theResponse.setStatus(statusCode);
  theRequestDetails.getServer().addHeadersToResponse(theResponse);
  theResponse.setContentType(""String_Node_Str"");
  theResponse.setCharacterEncoding(""String_Node_Str"");
  theResponse.getWriter().append(theException.getMessage());
  theResponse.getWriter().close();
  return false;
}",0.9912917271407836
112313,"@SuppressWarnings(""String_Node_Str"") @Override protected void initialize() throws ServletException {
  super.initialize();
  myAppCtx=ContextLoaderListener.getCurrentWebApplicationContext();
  String implDesc=getInitParameter(""String_Node_Str"");
  String fhirVersionParam=getInitParameter(""String_Node_Str"");
  if (StringUtils.isBlank(fhirVersionParam)) {
    fhirVersionParam=""String_Node_Str"";
  }
  List<IResourceProvider> beans;
  JpaSystemProviderDstu1 systemProvider;
  IFhirSystemDao systemDao;
  ETagSupportEnum etagSupport;
  String baseUrlProperty;
switch (fhirVersionParam.trim().toUpperCase()) {
case ""String_Node_Str"":
{
      setFhirContext(FhirContext.forDstu1());
      beans=myAppCtx.getBean(""String_Node_Str"",List.class);
      systemProvider=myAppCtx.getBean(""String_Node_Str"",JpaSystemProviderDstu1.class);
      systemDao=myAppCtx.getBean(""String_Node_Str"",IFhirSystemDao.class);
      etagSupport=ETagSupportEnum.DISABLED;
      JpaConformanceProviderDstu1 confProvider=new JpaConformanceProviderDstu1(this,systemDao);
      confProvider.setImplementationDescription(implDesc);
      setServerConformanceProvider(confProvider);
      baseUrlProperty=""String_Node_Str"";
      break;
    }
case ""String_Node_Str"":
{
    setFhirContext(FhirContext.forDstu1());
    beans=myAppCtx.getBean(""String_Node_Str"",List.class);
    systemProvider=myAppCtx.getBean(""String_Node_Str"",JpaSystemProviderDstu1.class);
    systemDao=myAppCtx.getBean(""String_Node_Str"",IFhirSystemDao.class);
    etagSupport=ETagSupportEnum.DISABLED;
    JpaConformanceProviderDstu1 confProvider=new JpaConformanceProviderDstu1(this,systemDao);
    confProvider.setImplementationDescription(implDesc);
    setServerConformanceProvider(confProvider);
    baseUrlProperty=""String_Node_Str"";
    break;
  }
case ""String_Node_Str"":
{
  setFhirContext(FhirContext.forDstu2());
  beans=myAppCtx.getBean(""String_Node_Str"",List.class);
  systemProvider=myAppCtx.getBean(""String_Node_Str"",JpaSystemProviderDstu1.class);
  systemDao=myAppCtx.getBean(""String_Node_Str"",IFhirSystemDao.class);
  etagSupport=ETagSupportEnum.ENABLED;
  JpaConformanceProviderDstu2 confProvider=new JpaConformanceProviderDstu2(this,systemDao);
  confProvider.setImplementationDescription(implDesc);
  setServerConformanceProvider(confProvider);
  baseUrlProperty=""String_Node_Str"";
  break;
}
default :
throw new ServletException(""String_Node_Str"" + fhirVersionParam);
}
setETagSupport(etagSupport);
FhirContext ctx=getFhirContext();
ctx.setNarrativeGenerator(new DefaultThymeleafNarrativeGenerator());
for (IResourceProvider nextResourceProvider : beans) {
ourLog.info(""String_Node_Str"",nextResourceProvider.getResourceType().getSimpleName());
}
setResourceProviders(beans);
setPlainProviders(systemProvider);
setUseBrowserFriendlyContentTypes(true);
String baseUrl=System.getProperty(baseUrlProperty);
if (StringUtils.isBlank(baseUrl)) {
baseUrl=System.getProperty(""String_Node_Str"");
if (StringUtils.isBlank(baseUrl)) {
throw new ServletException(""String_Node_Str"" + baseUrlProperty);
}
}
setServerAddressStrategy(new MyHardcodedServerAddressStrategy(baseUrl));
setPagingProvider(new FifoMemoryPagingProvider(10));
LoggingInterceptor loggingInterceptor=new LoggingInterceptor();
loggingInterceptor.setLoggerName(""String_Node_Str"");
loggingInterceptor.setMessageFormat(""String_Node_Str"");
this.registerInterceptor(loggingInterceptor);
}","@SuppressWarnings(""String_Node_Str"") @Override protected void initialize() throws ServletException {
  super.initialize();
  myAppCtx=ContextLoaderListener.getCurrentWebApplicationContext();
  String implDesc=getInitParameter(""String_Node_Str"");
  String fhirVersionParam=getInitParameter(""String_Node_Str"");
  if (StringUtils.isBlank(fhirVersionParam)) {
    fhirVersionParam=""String_Node_Str"";
  }
  List<IResourceProvider> beans;
  JpaSystemProviderDstu1 systemProviderDstu1=null;
  JpaSystemProviderDstu2 systemProviderDstu2=null;
  IFhirSystemDao systemDao;
  ETagSupportEnum etagSupport;
  String baseUrlProperty;
switch (fhirVersionParam.trim().toUpperCase()) {
case ""String_Node_Str"":
{
      setFhirContext(FhirContext.forDstu1());
      beans=myAppCtx.getBean(""String_Node_Str"",List.class);
      systemProviderDstu1=myAppCtx.getBean(""String_Node_Str"",JpaSystemProviderDstu1.class);
      systemDao=myAppCtx.getBean(""String_Node_Str"",IFhirSystemDao.class);
      etagSupport=ETagSupportEnum.DISABLED;
      JpaConformanceProviderDstu1 confProvider=new JpaConformanceProviderDstu1(this,systemDao);
      confProvider.setImplementationDescription(implDesc);
      setServerConformanceProvider(confProvider);
      baseUrlProperty=""String_Node_Str"";
      break;
    }
case ""String_Node_Str"":
{
    setFhirContext(FhirContext.forDstu1());
    beans=myAppCtx.getBean(""String_Node_Str"",List.class);
    systemProviderDstu1=myAppCtx.getBean(""String_Node_Str"",JpaSystemProviderDstu1.class);
    systemDao=myAppCtx.getBean(""String_Node_Str"",IFhirSystemDao.class);
    etagSupport=ETagSupportEnum.DISABLED;
    JpaConformanceProviderDstu1 confProvider=new JpaConformanceProviderDstu1(this,systemDao);
    confProvider.setImplementationDescription(implDesc);
    setServerConformanceProvider(confProvider);
    baseUrlProperty=""String_Node_Str"";
    break;
  }
case ""String_Node_Str"":
{
  setFhirContext(FhirContext.forDstu2());
  beans=myAppCtx.getBean(""String_Node_Str"",List.class);
  systemProviderDstu2=myAppCtx.getBean(""String_Node_Str"",JpaSystemProviderDstu2.class);
  systemDao=myAppCtx.getBean(""String_Node_Str"",IFhirSystemDao.class);
  etagSupport=ETagSupportEnum.ENABLED;
  JpaConformanceProviderDstu2 confProvider=new JpaConformanceProviderDstu2(this,systemDao);
  confProvider.setImplementationDescription(implDesc);
  setServerConformanceProvider(confProvider);
  baseUrlProperty=""String_Node_Str"";
  break;
}
default :
throw new ServletException(""String_Node_Str"" + fhirVersionParam);
}
setETagSupport(etagSupport);
FhirContext ctx=getFhirContext();
ctx.setNarrativeGenerator(new DefaultThymeleafNarrativeGenerator());
for (IResourceProvider nextResourceProvider : beans) {
ourLog.info(""String_Node_Str"",nextResourceProvider.getResourceType().getSimpleName());
}
setResourceProviders(beans);
List provList=new ArrayList();
if (systemProviderDstu1 != null) provList.add(systemProviderDstu1);
if (systemProviderDstu2 != null) provList.add(systemProviderDstu2);
setPlainProviders(provList);
setUseBrowserFriendlyContentTypes(true);
String baseUrl=System.getProperty(baseUrlProperty);
if (StringUtils.isBlank(baseUrl)) {
baseUrl=System.getProperty(""String_Node_Str"");
if (StringUtils.isBlank(baseUrl)) {
throw new ServletException(""String_Node_Str"" + baseUrlProperty);
}
}
setServerAddressStrategy(new MyHardcodedServerAddressStrategy(baseUrl));
setPagingProvider(new FifoMemoryPagingProvider(10));
LoggingInterceptor loggingInterceptor=new LoggingInterceptor();
loggingInterceptor.setLoggerName(""String_Node_Str"");
loggingInterceptor.setMessageFormat(""String_Node_Str"");
this.registerInterceptor(loggingInterceptor);
}",0.956843754450933
112314,"private void encodeResourceToXmlStreamWriter(IBaseResource theResource,XMLStreamWriter theEventWriter,boolean theContainedResource,String theResourceId) throws XMLStreamException {
  if (!theContainedResource) {
    super.containResourcesForEncoding(theResource);
  }
  RuntimeResourceDefinition resDef=myContext.getResourceDefinition(theResource);
  if (resDef == null) {
    throw new ConfigurationException(""String_Node_Str"" + theResource.getClass());
  }
  theEventWriter.writeStartElement(resDef.getName());
  theEventWriter.writeDefaultNamespace(FHIR_NS);
  if (theResource instanceof IAnyResource) {
    encodeCompositeElementToStreamWriter(theResource,theResource,theEventWriter,resDef,theContainedResource);
  }
 else {
    if (myContext.getVersion().getVersion().isNewerThan(FhirVersionEnum.DSTU1)) {
      IResource resource=(IResource)theResource;
      writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",theResourceId);
      InstantDt updated=(InstantDt)resource.getResourceMetadata().get(ResourceMetadataKeyEnum.UPDATED);
      IdDt resourceId=resource.getId();
      if (resourceId != null && isNotBlank(resourceId.getVersionIdPart()) || (updated != null && !updated.isEmpty())) {
        theEventWriter.writeStartElement(""String_Node_Str"");
        String versionIdPart=resourceId.getVersionIdPart();
        if (isBlank(versionIdPart)) {
          versionIdPart=ResourceMetadataKeyEnum.VERSION.get(resource);
        }
        writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",versionIdPart);
        if (updated != null) {
          writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",updated.getValueAsString());
        }
        Object securityLabelRawObj=resource.getResourceMetadata().get(ResourceMetadataKeyEnum.SECURITY_LABELS);
        if (securityLabelRawObj != null) {
          List<BaseCodingDt> securityLabels=(List<BaseCodingDt>)securityLabelRawObj;
          if (!securityLabels.isEmpty()) {
            for (            BaseCodingDt securityLabel : securityLabels) {
              theEventWriter.writeStartElement(""String_Node_Str"");
              UriDt system=securityLabel.getSystemElement();
              if (system != null && !system.isEmpty())               writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",system.getValueAsString());
              CodeDt code=securityLabel.getCodeElement();
              if (code != null && !code.isEmpty())               writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",code.getValueAsString());
              StringDt display=securityLabel.getDisplayElement();
              if (display != null && !display.isEmpty())               writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",display.getValueAsString());
              theEventWriter.writeEndElement();
            }
          }
        }
        theEventWriter.writeEndElement();
      }
      if (theResource instanceof BaseBinary) {
        BaseBinary bin=(BaseBinary)theResource;
        writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",bin.getContentType());
        writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",bin.getContentAsBase64());
      }
 else {
        encodeResourceToStreamWriterInDstu2Format(resDef,theResource,theResource,theEventWriter,resDef,theContainedResource);
      }
    }
 else {
      if (theResourceId != null && theContainedResource) {
        theEventWriter.writeAttribute(""String_Node_Str"",theResourceId);
      }
      if (theResource instanceof BaseBinary) {
        BaseBinary bin=(BaseBinary)theResource;
        if (bin.getContentType() != null) {
          theEventWriter.writeAttribute(""String_Node_Str"",bin.getContentType());
        }
        theEventWriter.writeCharacters(bin.getContentAsBase64());
      }
 else {
        encodeCompositeElementToStreamWriter(theResource,theResource,theEventWriter,resDef,theContainedResource);
      }
    }
  }
  theEventWriter.writeEndElement();
}","private void encodeResourceToXmlStreamWriter(IBaseResource theResource,XMLStreamWriter theEventWriter,boolean theContainedResource,String theResourceId) throws XMLStreamException {
  if (!theContainedResource) {
    super.containResourcesForEncoding(theResource);
  }
  RuntimeResourceDefinition resDef=myContext.getResourceDefinition(theResource);
  if (resDef == null) {
    throw new ConfigurationException(""String_Node_Str"" + theResource.getClass());
  }
  theEventWriter.writeStartElement(resDef.getName());
  theEventWriter.writeDefaultNamespace(FHIR_NS);
  if (theResource instanceof IAnyResource) {
    encodeCompositeElementToStreamWriter(theResource,theResource,theEventWriter,resDef,theContainedResource);
  }
 else {
    if (myContext.getVersion().getVersion().isNewerThan(FhirVersionEnum.DSTU1)) {
      IResource resource=(IResource)theResource;
      writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",theResourceId);
      InstantDt updated=(InstantDt)resource.getResourceMetadata().get(ResourceMetadataKeyEnum.UPDATED);
      List<BaseCodingDt> securityLabels=(List<BaseCodingDt>)resource.getResourceMetadata().get(ResourceMetadataKeyEnum.SECURITY_LABELS);
      IdDt resourceId=resource.getId();
      if (resourceId != null && isNotBlank(resourceId.getVersionIdPart()) || (updated != null && !updated.isEmpty()) || (securityLabels != null && !securityLabels.isEmpty())) {
        theEventWriter.writeStartElement(""String_Node_Str"");
        String versionIdPart=resourceId.getVersionIdPart();
        if (isBlank(versionIdPart)) {
          versionIdPart=ResourceMetadataKeyEnum.VERSION.get(resource);
        }
        writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",versionIdPart);
        if (updated != null) {
          writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",updated.getValueAsString());
        }
        if (securityLabels != null) {
          if (!securityLabels.isEmpty()) {
            for (            BaseCodingDt securityLabel : securityLabels) {
              theEventWriter.writeStartElement(""String_Node_Str"");
              UriDt system=securityLabel.getSystemElement();
              if (system != null && !system.isEmpty())               writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",system.getValueAsString());
              CodeDt code=securityLabel.getCodeElement();
              if (code != null && !code.isEmpty())               writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",code.getValueAsString());
              StringDt display=securityLabel.getDisplayElement();
              if (display != null && !display.isEmpty())               writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",display.getValueAsString());
              theEventWriter.writeEndElement();
            }
          }
        }
        theEventWriter.writeEndElement();
      }
      if (theResource instanceof BaseBinary) {
        BaseBinary bin=(BaseBinary)theResource;
        writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",bin.getContentType());
        writeOptionalTagWithValue(theEventWriter,""String_Node_Str"",bin.getContentAsBase64());
      }
 else {
        encodeResourceToStreamWriterInDstu2Format(resDef,theResource,theResource,theEventWriter,resDef,theContainedResource);
      }
    }
 else {
      if (theResourceId != null && theContainedResource) {
        theEventWriter.writeAttribute(""String_Node_Str"",theResourceId);
      }
      if (theResource instanceof BaseBinary) {
        BaseBinary bin=(BaseBinary)theResource;
        if (bin.getContentType() != null) {
          theEventWriter.writeAttribute(""String_Node_Str"",bin.getContentType());
        }
        theEventWriter.writeCharacters(bin.getContentAsBase64());
      }
 else {
        encodeCompositeElementToStreamWriter(theResource,theResource,theEventWriter,resDef,theContainedResource);
      }
    }
  }
  theEventWriter.writeEndElement();
}",0.8142784552845529
112315,"@SuppressWarnings(""String_Node_Str"") @Override protected void initialize() throws ServletException {
  super.initialize();
  myAppCtx=ContextLoaderListener.getCurrentWebApplicationContext();
  String implDesc=getInitParameter(""String_Node_Str"");
  String fhirVersionParam=getInitParameter(""String_Node_Str"");
  if (StringUtils.isBlank(fhirVersionParam)) {
    fhirVersionParam=""String_Node_Str"";
  }
  List<IResourceProvider> beans;
  JpaSystemProvider systemProvider;
  IFhirSystemDao systemDao;
  ETagSupportEnum etagSupport;
  String baseUrlProperty;
switch (fhirVersionParam.trim().toUpperCase()) {
case ""String_Node_Str"":
case ""String_Node_Str"":
{
      setFhirContext(FhirContext.forDstu1());
      beans=myAppCtx.getBean(""String_Node_Str"",List.class);
      systemProvider=myAppCtx.getBean(""String_Node_Str"",JpaSystemProvider.class);
      systemDao=myAppCtx.getBean(""String_Node_Str"",IFhirSystemDao.class);
      etagSupport=ETagSupportEnum.DISABLED;
      JpaConformanceProviderDstu1 confProvider=new JpaConformanceProviderDstu1(this,systemDao);
      confProvider.setImplementationDescription(implDesc);
      setServerConformanceProvider(confProvider);
      baseUrlProperty=""String_Node_Str"";
      break;
    }
case ""String_Node_Str"":
{
    setFhirContext(FhirContext.forDev());
    beans=myAppCtx.getBean(""String_Node_Str"",List.class);
    systemProvider=myAppCtx.getBean(""String_Node_Str"",JpaSystemProvider.class);
    systemDao=myAppCtx.getBean(""String_Node_Str"",IFhirSystemDao.class);
    etagSupport=ETagSupportEnum.ENABLED;
    JpaConformanceProviderDev confProvider=new JpaConformanceProviderDev(this,systemDao);
    confProvider.setImplementationDescription(implDesc);
    setServerConformanceProvider(confProvider);
    baseUrlProperty=""String_Node_Str"";
    break;
  }
default :
throw new ServletException(""String_Node_Str"" + fhirVersionParam);
}
setETagSupport(etagSupport);
FhirContext ctx=getFhirContext();
ctx.setNarrativeGenerator(new DefaultThymeleafNarrativeGenerator());
for (IResourceProvider nextResourceProvider : beans) {
ourLog.info(""String_Node_Str"",nextResourceProvider.getResourceType().getSimpleName());
}
setResourceProviders(beans);
setPlainProviders(systemProvider);
FhirContext ctx=getFhirContext();
ctx.setNarrativeGenerator(new DefaultThymeleafNarrativeGenerator());
setUseBrowserFriendlyContentTypes(true);
String baseUrl=System.getProperty(baseUrlProperty);
if (StringUtils.isBlank(baseUrl)) {
baseUrl=System.getProperty(""String_Node_Str"");
if (StringUtils.isBlank(baseUrl)) {
throw new ServletException(""String_Node_Str"" + baseUrlProperty);
}
}
setServerAddressStrategy(new HardcodedServerAddressStrategy(baseUrl));
setPagingProvider(new FifoMemoryPagingProvider(10));
LoggingInterceptor loggingInterceptor=new LoggingInterceptor();
loggingInterceptor.setLoggerName(""String_Node_Str"");
loggingInterceptor.setMessageFormat(""String_Node_Str"");
this.registerInterceptor(loggingInterceptor);
}","@SuppressWarnings(""String_Node_Str"") @Override protected void initialize() throws ServletException {
  super.initialize();
  myAppCtx=ContextLoaderListener.getCurrentWebApplicationContext();
  String implDesc=getInitParameter(""String_Node_Str"");
  String fhirVersionParam=getInitParameter(""String_Node_Str"");
  if (StringUtils.isBlank(fhirVersionParam)) {
    fhirVersionParam=""String_Node_Str"";
  }
  List<IResourceProvider> beans;
  JpaSystemProvider systemProvider;
  IFhirSystemDao systemDao;
  ETagSupportEnum etagSupport;
  String baseUrlProperty;
switch (fhirVersionParam.trim().toUpperCase()) {
case ""String_Node_Str"":
case ""String_Node_Str"":
{
      setFhirContext(FhirContext.forDstu1());
      beans=myAppCtx.getBean(""String_Node_Str"",List.class);
      systemProvider=myAppCtx.getBean(""String_Node_Str"",JpaSystemProvider.class);
      systemDao=myAppCtx.getBean(""String_Node_Str"",IFhirSystemDao.class);
      etagSupport=ETagSupportEnum.DISABLED;
      JpaConformanceProviderDstu1 confProvider=new JpaConformanceProviderDstu1(this,systemDao);
      confProvider.setImplementationDescription(implDesc);
      setServerConformanceProvider(confProvider);
      baseUrlProperty=""String_Node_Str"";
      break;
    }
case ""String_Node_Str"":
{
    setFhirContext(FhirContext.forDev());
    beans=myAppCtx.getBean(""String_Node_Str"",List.class);
    systemProvider=myAppCtx.getBean(""String_Node_Str"",JpaSystemProvider.class);
    systemDao=myAppCtx.getBean(""String_Node_Str"",IFhirSystemDao.class);
    etagSupport=ETagSupportEnum.ENABLED;
    JpaConformanceProviderDev confProvider=new JpaConformanceProviderDev(this,systemDao);
    confProvider.setImplementationDescription(implDesc);
    setServerConformanceProvider(confProvider);
    baseUrlProperty=""String_Node_Str"";
    break;
  }
default :
throw new ServletException(""String_Node_Str"" + fhirVersionParam);
}
setETagSupport(etagSupport);
FhirContext ctx=getFhirContext();
ctx.setNarrativeGenerator(new DefaultThymeleafNarrativeGenerator());
for (IResourceProvider nextResourceProvider : beans) {
ourLog.info(""String_Node_Str"",nextResourceProvider.getResourceType().getSimpleName());
}
setResourceProviders(beans);
setPlainProviders(systemProvider);
setUseBrowserFriendlyContentTypes(true);
String baseUrl=System.getProperty(baseUrlProperty);
if (StringUtils.isBlank(baseUrl)) {
baseUrl=System.getProperty(""String_Node_Str"");
if (StringUtils.isBlank(baseUrl)) {
throw new ServletException(""String_Node_Str"" + baseUrlProperty);
}
}
setServerAddressStrategy(new HardcodedServerAddressStrategy(baseUrl));
setPagingProvider(new FifoMemoryPagingProvider(10));
LoggingInterceptor loggingInterceptor=new LoggingInterceptor();
loggingInterceptor.setLoggerName(""String_Node_Str"");
loggingInterceptor.setMessageFormat(""String_Node_Str"");
this.registerInterceptor(loggingInterceptor);
}",0.9821583232288238
112316,"/** 
 * Invoked prior to use to perform any initialization and make object mutable
 */
void sealAndInitialize(Map<Class<? extends IElement>,BaseRuntimeElementDefinition<?>> theClassToElementDefinitions){
  for (  BaseRuntimeChildDefinition next : myExtensions) {
    next.sealAndInitialize(theClassToElementDefinitions);
  }
  for (  RuntimeChildDeclaredExtensionDefinition next : myExtensions) {
    String extUrl=next.getExtensionUrl();
    if (myUrlToExtension.containsKey(extUrl)) {
      throw new ConfigurationException(""String_Node_Str"" + extUrl);
    }
 else {
      myUrlToExtension.put(extUrl,next);
    }
    if (next.isModifier()) {
      myExtensionsModifier.add(next);
    }
 else {
      myExtensionsNonModifier.add(next);
    }
  }
  myExtensions=Collections.unmodifiableList(myExtensions);
}","/** 
 * Invoked prior to use to perform any initialization and make object mutable
 */
void sealAndInitialize(Map<Class<? extends IElement>,BaseRuntimeElementDefinition<?>> theClassToElementDefinitions){
  for (  BaseRuntimeChildDefinition next : myExtensions) {
    next.sealAndInitialize(theClassToElementDefinitions);
  }
  for (  RuntimeChildDeclaredExtensionDefinition next : myExtensions) {
    String extUrl=next.getExtensionUrl();
    if (myUrlToExtension.containsKey(extUrl)) {
      throw new ConfigurationException(""String_Node_Str"" + extUrl + ""String_Node_Str""+ getName()+ ""String_Node_Str"");
    }
 else {
      myUrlToExtension.put(extUrl,next);
    }
    if (next.isModifier()) {
      myExtensionsModifier.add(next);
    }
 else {
      myExtensionsNonModifier.add(next);
    }
  }
  myExtensions=Collections.unmodifiableList(myExtensions);
}",0.9699879951980792
112317,"private Map<RuntimeChildDeclaredExtensionDefinition,String> scanForExtensions(Profile theProfile,BaseRuntimeElementDefinition<?> def){
  BaseRuntimeElementCompositeDefinition<?> cdef=((BaseRuntimeElementCompositeDefinition<?>)def);
  Map<RuntimeChildDeclaredExtensionDefinition,String> extensionDefToCode=new HashMap<RuntimeChildDeclaredExtensionDefinition,String>();
  for (  RuntimeChildDeclaredExtensionDefinition nextChild : cdef.getExtensions()) {
    if (extensionDefToCode.containsKey(nextChild)) {
      continue;
    }
    if (nextChild.isDefinedLocally() == false) {
      continue;
    }
    ExtensionDefn defn=theProfile.addExtensionDefn();
    String code=null;
    if (nextChild.getExtensionUrl().contains(""String_Node_Str"") && !nextChild.getExtensionUrl().endsWith(""String_Node_Str"")) {
      code=nextChild.getExtensionUrl().substring(nextChild.getExtensionUrl().indexOf('#') + 1);
    }
 else {
      throw new ConfigurationException(""String_Node_Str"" + nextChild.getExtensionUrl());
    }
    defn.setCode(code);
    if (extensionDefToCode.values().contains(code)) {
      throw new IllegalStateException(""String_Node_Str"" + code);
    }
    extensionDefToCode.put(nextChild,code);
    if (nextChild.getChildType() != null && IPrimitiveDatatype.class.isAssignableFrom(nextChild.getChildType())) {
      RuntimePrimitiveDatatypeDefinition pdef=(RuntimePrimitiveDatatypeDefinition)nextChild.getSingleChildOrThrow();
      defn.getDefinition().addType().setCode(DataTypeEnum.VALUESET_BINDER.fromCodeString(pdef.getName()));
    }
 else     if (nextChild.getChildType() != null && ICompositeDatatype.class.isAssignableFrom(nextChild.getChildType())) {
      RuntimeCompositeDatatypeDefinition pdef=(RuntimeCompositeDatatypeDefinition)nextChild.getSingleChildOrThrow();
      defn.getDefinition().addType().setCode(DataTypeEnum.VALUESET_BINDER.fromCodeString(pdef.getName()));
    }
 else {
      RuntimeResourceBlockDefinition pdef=(RuntimeResourceBlockDefinition)nextChild.getSingleChildOrThrow();
      scanForExtensions(theProfile,pdef);
      for (      RuntimeChildDeclaredExtensionDefinition nextChildExt : pdef.getExtensions()) {
        StructureElementDefinitionType type=defn.getDefinition().addType();
        type.setCode(DataTypeEnum.EXTENSION);
        type.setProfile(""String_Node_Str"" + extensionDefToCode.get(nextChildExt));
      }
    }
  }
  return extensionDefToCode;
}","private Map<RuntimeChildDeclaredExtensionDefinition,String> scanForExtensions(Profile theProfile,BaseRuntimeElementDefinition<?> def,Map<RuntimeChildDeclaredExtensionDefinition,String> theExtensionDefToCode){
  BaseRuntimeElementCompositeDefinition<?> cdef=((BaseRuntimeElementCompositeDefinition<?>)def);
  for (  RuntimeChildDeclaredExtensionDefinition nextChild : cdef.getExtensions()) {
    if (theExtensionDefToCode.containsKey(nextChild)) {
      continue;
    }
    if (nextChild.isDefinedLocally() == false) {
      continue;
    }
    ExtensionDefn defn=theProfile.addExtensionDefn();
    String code=null;
    if (nextChild.getExtensionUrl().contains(""String_Node_Str"") && !nextChild.getExtensionUrl().endsWith(""String_Node_Str"")) {
      code=nextChild.getExtensionUrl().substring(nextChild.getExtensionUrl().indexOf('#') + 1);
    }
 else {
      throw new ConfigurationException(""String_Node_Str"" + nextChild.getExtensionUrl());
    }
    defn.setCode(code);
    if (theExtensionDefToCode.values().contains(code)) {
      throw new IllegalStateException(""String_Node_Str"" + code);
    }
    theExtensionDefToCode.put(nextChild,code);
    if (nextChild.getChildType() != null && IPrimitiveDatatype.class.isAssignableFrom(nextChild.getChildType())) {
      RuntimePrimitiveDatatypeDefinition pdef=(RuntimePrimitiveDatatypeDefinition)nextChild.getSingleChildOrThrow();
      defn.getDefinition().addType().setCode(DataTypeEnum.VALUESET_BINDER.fromCodeString(pdef.getName()));
    }
 else     if (nextChild.getChildType() != null && ICompositeDatatype.class.isAssignableFrom(nextChild.getChildType())) {
      RuntimeCompositeDatatypeDefinition pdef=(RuntimeCompositeDatatypeDefinition)nextChild.getSingleChildOrThrow();
      defn.getDefinition().addType().setCode(DataTypeEnum.VALUESET_BINDER.fromCodeString(pdef.getName()));
    }
 else {
      RuntimeResourceBlockDefinition pdef=(RuntimeResourceBlockDefinition)nextChild.getSingleChildOrThrow();
      scanForExtensions(theProfile,pdef,theExtensionDefToCode);
      for (      RuntimeChildDeclaredExtensionDefinition nextChildExt : pdef.getExtensions()) {
        StructureElementDefinitionType type=defn.getDefinition().addType();
        type.setCode(DataTypeEnum.EXTENSION);
        type.setProfile(""String_Node_Str"" + theExtensionDefToCode.get(nextChildExt));
      }
    }
  }
  return theExtensionDefToCode;
}",0.9433409993727786
112318,"@Override public IResource generateProfile(RuntimeResourceDefinition theRuntimeResourceDefinition){
  Profile retVal=new Profile();
  RuntimeResourceDefinition def=theRuntimeResourceDefinition;
  myId=def.getId();
  if (StringUtils.isBlank(myId)) {
    myId=theRuntimeResourceDefinition.getName().toLowerCase();
  }
  retVal.setId(new IdDt(myId));
  scanForExtensions(retVal,def);
  Collections.sort(retVal.getExtensionDefn(),new Comparator<ExtensionDefn>(){
    @Override public int compare(    ExtensionDefn theO1,    ExtensionDefn theO2){
      return theO1.getCode().compareTo(theO2.getCode());
    }
  }
);
  retVal.setName(def.getName());
  Structure struct=retVal.addStructure();
  LinkedList<String> path=new LinkedList<String>();
  StructureElement element=struct.addElement();
  element.getDefinition().setMin(1);
  element.getDefinition().setMax(""String_Node_Str"");
  fillProfile(struct,element,def,path,null);
  retVal.getStructure().get(0).getElement().get(0).getDefinition().addType().getCode().setValue(""String_Node_Str"");
  return retVal;
}","@Override public IResource generateProfile(RuntimeResourceDefinition theRuntimeResourceDefinition){
  Profile retVal=new Profile();
  RuntimeResourceDefinition def=theRuntimeResourceDefinition;
  myId=def.getId();
  if (StringUtils.isBlank(myId)) {
    myId=theRuntimeResourceDefinition.getName().toLowerCase();
  }
  retVal.setId(new IdDt(myId));
  scanForExtensions(retVal,def,new HashMap<RuntimeChildDeclaredExtensionDefinition,String>());
  Collections.sort(retVal.getExtensionDefn(),new Comparator<ExtensionDefn>(){
    @Override public int compare(    ExtensionDefn theO1,    ExtensionDefn theO2){
      return theO1.getCode().compareTo(theO2.getCode());
    }
  }
);
  retVal.setName(def.getName());
  Structure struct=retVal.addStructure();
  LinkedList<String> path=new LinkedList<String>();
  StructureElement element=struct.addElement();
  element.getDefinition().setMin(1);
  element.getDefinition().setMax(""String_Node_Str"");
  fillProfile(struct,element,def,path,null);
  retVal.getStructure().get(0).getElement().get(0).getDefinition().addType().getCode().setValue(""String_Node_Str"");
  return retVal;
}",0.97148114075437
112319,"/** 
 * Accepts a textual DIV and parses it into XHTML events which are stored internally. <p> <b>Formatting note:</b> The text will be trimmed   {@link String#trim()}. If the text does not start with an HTML tag (generally this would be a div tag), a div tag will be automatically placed surrounding the text. </p> <p> Also note that if the parsed text contains any entities (&foo;) which are not a part of the entities defined in core XML (e.g. &sect; which is valid in XHTML 1.0 but not in XML 1.0) they will be parsed and converted to their equivalent unicode character. </p>
 */
@Override public void setValueAsString(String theValue) throws DataFormatException {
  String value=theValue.trim();
  if (value.charAt(0) != '<') {
    value=""String_Node_Str"" + value + ""String_Node_Str"";
  }
  super.setValueAsString(value);
}","/** 
 * Accepts a textual DIV and parses it into XHTML events which are stored internally. <p> <b>Formatting note:</b> The text will be trimmed   {@link String#trim()}. If the text does not start with an HTML tag (generally this would be a div tag), a div tag will be automatically placed surrounding the text. </p> <p> Also note that if the parsed text contains any entities (&foo;) which are not a part of the entities defined in core XML (e.g. &sect; which is valid in XHTML 1.0 but not in XML 1.0) they will be parsed and converted to their equivalent unicode character. </p>
 */
@Override public void setValueAsString(String theValue) throws DataFormatException {
  if (theValue == null || theValue.isEmpty()) {
    super.setValueAsString(null);
  }
 else {
    String value=theValue.trim();
    if (value.charAt(0) != '<') {
      value=""String_Node_Str"" + value + ""String_Node_Str"";
    }
    super.setValueAsString(value);
  }
}",0.9387755102040816
112320,"@Test public void testProfileWithBoundCode() throws IOException {
  String content=IOUtils.toString(XmlParserTest.class.getResourceAsStream(""String_Node_Str""));
  ourCtx.newXmlParser().parseResource(Profile.class,content);
}","@Test public void testProfileWithBoundCode() throws IOException {
  String content=IOUtils.toString(XmlParserTest.class.getResourceAsStream(""String_Node_Str""),""String_Node_Str"");
  ourCtx.newXmlParser().parseResource(Profile.class,content);
}",0.96137339055794
112321,"public static HttpPutClientInvocation createUpdateInvocation(IResource theResource,String theResourceBody,IdDt theId,FhirContext theContext){
  String resourceName=theContext.getResourceDefinition(theResource).getName();
  StringBuilder urlBuilder=new StringBuilder();
  urlBuilder.append(resourceName);
  urlBuilder.append('/');
  urlBuilder.append(theId.getIdPart());
  HttpPutClientInvocation retVal;
  String urlExtension=urlBuilder.toString();
  if (StringUtils.isBlank(theResourceBody)) {
    retVal=new HttpPutClientInvocation(theContext,theResource,urlExtension);
  }
 else {
    retVal=new HttpPutClientInvocation(theContext,theResourceBody,false,urlExtension);
  }
  if (theId.hasVersionIdPart()) {
    String versionId=theId.getVersionIdPart();
    if (StringUtils.isNotBlank(versionId)) {
      urlBuilder.append('/');
      urlBuilder.append(Constants.PARAM_HISTORY);
      urlBuilder.append('/');
      urlBuilder.append(versionId);
      retVal.addHeader(Constants.HEADER_CONTENT_LOCATION,urlBuilder.toString());
    }
  }
  addTagsToPostOrPut(theResource,retVal);
  return retVal;
}","public static HttpPutClientInvocation createUpdateInvocation(IResource theResource,String theResourceBody,IdDt theId,FhirContext theContext){
  String resourceName=theContext.getResourceDefinition(theResource).getName();
  StringBuilder urlBuilder=new StringBuilder();
  urlBuilder.append(resourceName);
  urlBuilder.append('/');
  urlBuilder.append(theId.getIdPart());
  HttpPutClientInvocation retVal;
  String urlExtension=urlBuilder.toString();
  if (StringUtils.isBlank(theResourceBody)) {
    retVal=new HttpPutClientInvocation(theContext,theResource,urlExtension);
  }
 else {
    retVal=new HttpPutClientInvocation(theContext,theResourceBody,false,urlExtension);
  }
  if (theId.hasVersionIdPart()) {
    String versionId=theId.getVersionIdPart();
    if (StringUtils.isNotBlank(versionId)) {
      urlBuilder.append('/');
      urlBuilder.append(Constants.PARAM_HISTORY);
      urlBuilder.append('/');
      urlBuilder.append(versionId);
      retVal.addHeader(Constants.HEADER_CONTENT_LOCATION,urlBuilder.toString());
    }
  }
  addTagsToPostOrPut(theResource,retVal);
  addContentTypeHeaderBasedOnDetectedType(retVal,theResourceBody);
  return retVal;
}",0.964206805125939
112322,"public static HttpPostClientInvocation createCreateInvocation(IResource theResource,String theResourceBody,String theId,FhirContext theContext){
  RuntimeResourceDefinition def=theContext.getResourceDefinition(theResource);
  String resourceName=def.getName();
  StringBuilder urlExtension=new StringBuilder();
  urlExtension.append(resourceName);
  if (StringUtils.isNotBlank(theId)) {
    urlExtension.append('/');
    urlExtension.append(theId);
  }
  HttpPostClientInvocation retVal;
  if (StringUtils.isBlank(theResourceBody)) {
    retVal=new HttpPostClientInvocation(theContext,theResource,urlExtension.toString());
  }
 else {
    retVal=new HttpPostClientInvocation(theContext,theResourceBody,false,urlExtension.toString());
  }
  addTagsToPostOrPut(theResource,retVal);
  return retVal;
}","public static HttpPostClientInvocation createCreateInvocation(IResource theResource,String theResourceBody,String theId,FhirContext theContext){
  RuntimeResourceDefinition def=theContext.getResourceDefinition(theResource);
  String resourceName=def.getName();
  StringBuilder urlExtension=new StringBuilder();
  urlExtension.append(resourceName);
  if (StringUtils.isNotBlank(theId)) {
    urlExtension.append('/');
    urlExtension.append(theId);
  }
  HttpPostClientInvocation retVal;
  if (StringUtils.isBlank(theResourceBody)) {
    retVal=new HttpPostClientInvocation(theContext,theResource,urlExtension.toString());
  }
 else {
    retVal=new HttpPostClientInvocation(theContext,theResourceBody,false,urlExtension.toString());
  }
  addTagsToPostOrPut(theResource,retVal);
  addContentTypeHeaderBasedOnDetectedType(retVal,theResourceBody);
  return retVal;
}",0.9512928442573662
112323,"protected List<ResourceIndexedSearchParamString> extractSearchParamStrings(ResourceTable theEntity,IResource theResource){
  ArrayList<ResourceIndexedSearchParamString> retVal=new ArrayList<ResourceIndexedSearchParamString>();
  RuntimeResourceDefinition def=getContext().getResourceDefinition(theResource);
  FhirTerser t=getContext().newTerser();
  for (  RuntimeSearchParam nextSpDef : def.getSearchParams()) {
    if (nextSpDef.getParamType() != SearchParamTypeEnum.STRING) {
      continue;
    }
    if (nextSpDef.getPath().isEmpty()) {
      continue;
    }
    String nextPath=nextSpDef.getPath();
    List<Object> values=t.getValues(theResource,nextPath);
    for (    Object nextObject : values) {
      if (nextObject == null || ((IDatatype)nextObject).isEmpty()) {
        continue;
      }
      String resourceName=nextSpDef.getName();
      boolean multiType=false;
      if (nextPath.endsWith(""String_Node_Str"")) {
        multiType=true;
      }
      if (nextObject instanceof IPrimitiveDatatype<?>) {
        IPrimitiveDatatype<?> nextValue=(IPrimitiveDatatype<?>)nextObject;
        String searchTerm=nextValue.getValueAsString();
        if (searchTerm.length() > ResourceIndexedSearchParamString.MAX_LENGTH) {
          searchTerm=searchTerm.substring(0,ResourceIndexedSearchParamString.MAX_LENGTH);
        }
        ResourceIndexedSearchParamString nextEntity=new ResourceIndexedSearchParamString(resourceName,normalizeString(searchTerm),searchTerm);
        nextEntity.setResource(theEntity);
        retVal.add(nextEntity);
      }
 else {
        if (nextObject instanceof HumanNameDt) {
          ArrayList<StringDt> allNames=new ArrayList<StringDt>();
          HumanNameDt nextHumanName=(HumanNameDt)nextObject;
          allNames.addAll(nextHumanName.getFamily());
          allNames.addAll(nextHumanName.getGiven());
          for (          StringDt nextName : allNames) {
            if (nextName.isEmpty()) {
              continue;
            }
            ResourceIndexedSearchParamString nextEntity=new ResourceIndexedSearchParamString(resourceName,normalizeString(nextName.getValueAsString()),nextName.getValueAsString());
            nextEntity.setResource(theEntity);
            retVal.add(nextEntity);
          }
        }
 else         if (nextObject instanceof AddressDt) {
          ArrayList<StringDt> allNames=new ArrayList<StringDt>();
          AddressDt nextAddress=(AddressDt)nextObject;
          allNames.addAll(nextAddress.getLine());
          allNames.add(nextAddress.getCity());
          allNames.add(nextAddress.getState());
          allNames.add(nextAddress.getCountry());
          allNames.add(nextAddress.getZip());
          for (          StringDt nextName : allNames) {
            if (nextName.isEmpty()) {
              continue;
            }
            ResourceIndexedSearchParamString nextEntity=new ResourceIndexedSearchParamString(resourceName,normalizeString(nextName.getValueAsString()),nextName.getValueAsString());
            nextEntity.setResource(theEntity);
            retVal.add(nextEntity);
          }
        }
 else         if (nextObject instanceof ContactDt) {
          ContactDt nextContact=(ContactDt)nextObject;
          if (nextContact.getValue().isEmpty() == false) {
            ResourceIndexedSearchParamString nextEntity=new ResourceIndexedSearchParamString(resourceName,normalizeString(nextContact.getValue().getValueAsString()),nextContact.getValue().getValueAsString());
            nextEntity.setResource(theEntity);
            retVal.add(nextEntity);
          }
        }
 else {
          if (!multiType) {
            throw new ConfigurationException(""String_Node_Str"" + resourceName + ""String_Node_Str""+ nextObject.getClass());
          }
        }
      }
    }
  }
  theEntity.setParamsStringPopulated(retVal.size() > 0);
  return retVal;
}","protected List<ResourceIndexedSearchParamString> extractSearchParamStrings(ResourceTable theEntity,IResource theResource){
  ArrayList<ResourceIndexedSearchParamString> retVal=new ArrayList<ResourceIndexedSearchParamString>();
  RuntimeResourceDefinition def=getContext().getResourceDefinition(theResource);
  FhirTerser t=getContext().newTerser();
  for (  RuntimeSearchParam nextSpDef : def.getSearchParams()) {
    if (nextSpDef.getParamType() != SearchParamTypeEnum.STRING) {
      continue;
    }
    String nextPath=nextSpDef.getPath();
    if (isBlank(nextPath)) {
      continue;
    }
    List<Object> values=t.getValues(theResource,nextPath);
    for (    Object nextObject : values) {
      if (nextObject == null || ((IDatatype)nextObject).isEmpty()) {
        continue;
      }
      String resourceName=nextSpDef.getName();
      boolean multiType=false;
      if (nextPath.endsWith(""String_Node_Str"")) {
        multiType=true;
      }
      if (nextObject instanceof IPrimitiveDatatype<?>) {
        IPrimitiveDatatype<?> nextValue=(IPrimitiveDatatype<?>)nextObject;
        String searchTerm=nextValue.getValueAsString();
        if (searchTerm.length() > ResourceIndexedSearchParamString.MAX_LENGTH) {
          searchTerm=searchTerm.substring(0,ResourceIndexedSearchParamString.MAX_LENGTH);
        }
        ResourceIndexedSearchParamString nextEntity=new ResourceIndexedSearchParamString(resourceName,normalizeString(searchTerm),searchTerm);
        nextEntity.setResource(theEntity);
        retVal.add(nextEntity);
      }
 else {
        if (nextObject instanceof HumanNameDt) {
          ArrayList<StringDt> allNames=new ArrayList<StringDt>();
          HumanNameDt nextHumanName=(HumanNameDt)nextObject;
          allNames.addAll(nextHumanName.getFamily());
          allNames.addAll(nextHumanName.getGiven());
          for (          StringDt nextName : allNames) {
            if (nextName.isEmpty()) {
              continue;
            }
            ResourceIndexedSearchParamString nextEntity=new ResourceIndexedSearchParamString(resourceName,normalizeString(nextName.getValueAsString()),nextName.getValueAsString());
            nextEntity.setResource(theEntity);
            retVal.add(nextEntity);
          }
        }
 else         if (nextObject instanceof AddressDt) {
          ArrayList<StringDt> allNames=new ArrayList<StringDt>();
          AddressDt nextAddress=(AddressDt)nextObject;
          allNames.addAll(nextAddress.getLine());
          allNames.add(nextAddress.getCity());
          allNames.add(nextAddress.getState());
          allNames.add(nextAddress.getCountry());
          allNames.add(nextAddress.getZip());
          for (          StringDt nextName : allNames) {
            if (nextName.isEmpty()) {
              continue;
            }
            ResourceIndexedSearchParamString nextEntity=new ResourceIndexedSearchParamString(resourceName,normalizeString(nextName.getValueAsString()),nextName.getValueAsString());
            nextEntity.setResource(theEntity);
            retVal.add(nextEntity);
          }
        }
 else         if (nextObject instanceof ContactDt) {
          ContactDt nextContact=(ContactDt)nextObject;
          if (nextContact.getValue().isEmpty() == false) {
            ResourceIndexedSearchParamString nextEntity=new ResourceIndexedSearchParamString(resourceName,normalizeString(nextContact.getValue().getValueAsString()),nextContact.getValue().getValueAsString());
            nextEntity.setResource(theEntity);
            retVal.add(nextEntity);
          }
        }
 else {
          if (!multiType) {
            throw new ConfigurationException(""String_Node_Str"" + resourceName + ""String_Node_Str""+ nextObject.getClass());
          }
        }
      }
    }
  }
  theEntity.setParamsStringPopulated(retVal.size() > 0);
  return retVal;
}",0.9875357050116852
112324,"protected List<ResourceLink> extractResourceLinks(ResourceTable theEntity,IResource theResource){
  ArrayList<ResourceLink> retVal=new ArrayList<ResourceLink>();
  RuntimeResourceDefinition def=getContext().getResourceDefinition(theResource);
  FhirTerser t=getContext().newTerser();
  for (  RuntimeSearchParam nextSpDef : def.getSearchParams()) {
    if (nextSpDef.getParamType() != SearchParamTypeEnum.REFERENCE) {
      continue;
    }
    String nextPath=nextSpDef.getPath();
    boolean multiType=false;
    if (nextPath.endsWith(""String_Node_Str"")) {
      multiType=true;
    }
    List<Object> values=t.getValues(theResource,nextPath);
    for (    Object nextObject : values) {
      if (nextObject == null) {
        continue;
      }
      ResourceLink nextEntity;
      if (nextObject instanceof ResourceReferenceDt) {
        ResourceReferenceDt nextValue=(ResourceReferenceDt)nextObject;
        if (nextValue.isEmpty()) {
          continue;
        }
        if (nextValue.getReference().getValue().startsWith(""String_Node_Str"")) {
          continue;
        }
        String typeString=nextValue.getReference().getResourceType();
        if (isBlank(typeString)) {
          throw new InvalidRequestException(""String_Node_Str"" + nextPath + ""String_Node_Str""+ nextValue.getReference().getValue());
        }
        Class<? extends IResource> type=getContext().getResourceDefinition(typeString).getImplementingClass();
        String id=nextValue.getReference().getIdPart();
        if (StringUtils.isBlank(id)) {
          continue;
        }
        IFhirResourceDao<?> dao=getDao(type);
        if (dao == null) {
          throw new InvalidRequestException(""String_Node_Str"" + nextValue.getReference().getResourceType());
        }
        Long valueOf;
        try {
          valueOf=translateForcedIdToPid(nextValue.getReference());
        }
 catch (        Exception e) {
          String resName=getContext().getResourceDefinition(type).getName();
          throw new InvalidRequestException(""String_Node_Str"" + resName + ""String_Node_Str""+ id+ ""String_Node_Str""+ nextPath+ ""String_Node_Str"");
        }
        ResourceTable target=myEntityManager.find(ResourceTable.class,valueOf);
        if (target == null) {
          String resName=getContext().getResourceDefinition(type).getName();
          throw new InvalidRequestException(""String_Node_Str"" + resName + ""String_Node_Str""+ id+ ""String_Node_Str""+ nextPath);
        }
        nextEntity=new ResourceLink(nextPath,theEntity,target);
      }
 else {
        if (!multiType) {
          throw new ConfigurationException(""String_Node_Str"" + nextSpDef.getName() + ""String_Node_Str""+ nextObject.getClass());
        }
 else {
          continue;
        }
      }
      if (nextEntity != null) {
        retVal.add(nextEntity);
      }
    }
  }
  theEntity.setHasLinks(retVal.size() > 0);
  return retVal;
}","protected List<ResourceLink> extractResourceLinks(ResourceTable theEntity,IResource theResource){
  ArrayList<ResourceLink> retVal=new ArrayList<ResourceLink>();
  RuntimeResourceDefinition def=getContext().getResourceDefinition(theResource);
  FhirTerser t=getContext().newTerser();
  for (  RuntimeSearchParam nextSpDef : def.getSearchParams()) {
    if (nextSpDef.getParamType() != SearchParamTypeEnum.REFERENCE) {
      continue;
    }
    String nextPath=nextSpDef.getPath();
    if (isBlank(nextPath)) {
      continue;
    }
    boolean multiType=false;
    if (nextPath.endsWith(""String_Node_Str"")) {
      multiType=true;
    }
    List<Object> values=t.getValues(theResource,nextPath);
    for (    Object nextObject : values) {
      if (nextObject == null) {
        continue;
      }
      ResourceLink nextEntity;
      if (nextObject instanceof ResourceReferenceDt) {
        ResourceReferenceDt nextValue=(ResourceReferenceDt)nextObject;
        if (nextValue.isEmpty()) {
          continue;
        }
        if (nextValue.getReference().getValue().startsWith(""String_Node_Str"")) {
          continue;
        }
        String typeString=nextValue.getReference().getResourceType();
        if (isBlank(typeString)) {
          throw new InvalidRequestException(""String_Node_Str"" + nextPath + ""String_Node_Str""+ nextValue.getReference().getValue());
        }
        Class<? extends IResource> type=getContext().getResourceDefinition(typeString).getImplementingClass();
        String id=nextValue.getReference().getIdPart();
        if (StringUtils.isBlank(id)) {
          continue;
        }
        IFhirResourceDao<?> dao=getDao(type);
        if (dao == null) {
          throw new InvalidRequestException(""String_Node_Str"" + nextValue.getReference().getResourceType());
        }
        Long valueOf;
        try {
          valueOf=translateForcedIdToPid(nextValue.getReference());
        }
 catch (        Exception e) {
          String resName=getContext().getResourceDefinition(type).getName();
          throw new InvalidRequestException(""String_Node_Str"" + resName + ""String_Node_Str""+ id+ ""String_Node_Str""+ nextPath+ ""String_Node_Str"");
        }
        ResourceTable target=myEntityManager.find(ResourceTable.class,valueOf);
        if (target == null) {
          String resName=getContext().getResourceDefinition(type).getName();
          throw new InvalidRequestException(""String_Node_Str"" + resName + ""String_Node_Str""+ id+ ""String_Node_Str""+ nextPath);
        }
        nextEntity=new ResourceLink(nextPath,theEntity,target);
      }
 else {
        if (!multiType) {
          throw new ConfigurationException(""String_Node_Str"" + nextSpDef.getName() + ""String_Node_Str""+ nextObject.getClass());
        }
 else {
          continue;
        }
      }
      if (nextEntity != null) {
        retVal.add(nextEntity);
      }
    }
  }
  theEntity.setHasLinks(retVal.size() > 0);
  return retVal;
}",0.9912536443148688
112325,"protected List<ResourceIndexedSearchParamQuantity> extractSearchParamQuantity(ResourceTable theEntity,IResource theResource){
  ArrayList<ResourceIndexedSearchParamQuantity> retVal=new ArrayList<ResourceIndexedSearchParamQuantity>();
  RuntimeResourceDefinition def=getContext().getResourceDefinition(theResource);
  FhirTerser t=getContext().newTerser();
  for (  RuntimeSearchParam nextSpDef : def.getSearchParams()) {
    if (nextSpDef.getParamType() != SearchParamTypeEnum.QUANTITY) {
      continue;
    }
    String nextPath=nextSpDef.getPath();
    List<Object> values=t.getValues(theResource,nextPath);
    for (    Object nextObject : values) {
      if (nextObject == null || ((IDatatype)nextObject).isEmpty()) {
        continue;
      }
      String resourceName=nextSpDef.getName();
      boolean multiType=false;
      if (nextPath.endsWith(""String_Node_Str"")) {
        multiType=true;
      }
      if (nextObject instanceof QuantityDt) {
        QuantityDt nextValue=(QuantityDt)nextObject;
        if (nextValue.getValue().isEmpty()) {
          continue;
        }
        ResourceIndexedSearchParamQuantity nextEntity=new ResourceIndexedSearchParamQuantity(resourceName,nextValue.getValue().getValue(),nextValue.getSystem().getValueAsString(),nextValue.getUnits().getValue());
        nextEntity.setResource(theEntity);
        retVal.add(nextEntity);
      }
 else {
        if (!multiType) {
          throw new ConfigurationException(""String_Node_Str"" + resourceName + ""String_Node_Str""+ nextObject.getClass());
        }
 else {
          continue;
        }
      }
    }
  }
  theEntity.setParamsNumberPopulated(retVal.size() > 0);
  return retVal;
}","protected List<ResourceIndexedSearchParamQuantity> extractSearchParamQuantity(ResourceTable theEntity,IResource theResource){
  ArrayList<ResourceIndexedSearchParamQuantity> retVal=new ArrayList<ResourceIndexedSearchParamQuantity>();
  RuntimeResourceDefinition def=getContext().getResourceDefinition(theResource);
  FhirTerser t=getContext().newTerser();
  for (  RuntimeSearchParam nextSpDef : def.getSearchParams()) {
    if (nextSpDef.getParamType() != SearchParamTypeEnum.QUANTITY) {
      continue;
    }
    String nextPath=nextSpDef.getPath();
    if (isBlank(nextPath)) {
      continue;
    }
    List<Object> values=t.getValues(theResource,nextPath);
    for (    Object nextObject : values) {
      if (nextObject == null || ((IDatatype)nextObject).isEmpty()) {
        continue;
      }
      String resourceName=nextSpDef.getName();
      boolean multiType=false;
      if (nextPath.endsWith(""String_Node_Str"")) {
        multiType=true;
      }
      if (nextObject instanceof QuantityDt) {
        QuantityDt nextValue=(QuantityDt)nextObject;
        if (nextValue.getValue().isEmpty()) {
          continue;
        }
        ResourceIndexedSearchParamQuantity nextEntity=new ResourceIndexedSearchParamQuantity(resourceName,nextValue.getValue().getValue(),nextValue.getSystem().getValueAsString(),nextValue.getUnits().getValue());
        nextEntity.setResource(theEntity);
        retVal.add(nextEntity);
      }
 else {
        if (!multiType) {
          throw new ConfigurationException(""String_Node_Str"" + resourceName + ""String_Node_Str""+ nextObject.getClass());
        }
 else {
          continue;
        }
      }
    }
  }
  theEntity.setParamsNumberPopulated(retVal.size() > 0);
  return retVal;
}",0.985013223626212
112326,"protected List<ResourceIndexedSearchParamDate> extractSearchParamDates(ResourceTable theEntity,IResource theResource){
  ArrayList<ResourceIndexedSearchParamDate> retVal=new ArrayList<ResourceIndexedSearchParamDate>();
  RuntimeResourceDefinition def=getContext().getResourceDefinition(theResource);
  FhirTerser t=getContext().newTerser();
  for (  RuntimeSearchParam nextSpDef : def.getSearchParams()) {
    if (nextSpDef.getParamType() != SearchParamTypeEnum.DATE) {
      continue;
    }
    String nextPath=nextSpDef.getPath();
    boolean multiType=false;
    if (nextPath.endsWith(""String_Node_Str"")) {
      multiType=true;
    }
    List<Object> values=t.getValues(theResource,nextPath);
    for (    Object nextObject : values) {
      if (nextObject == null) {
        continue;
      }
      ResourceIndexedSearchParamDate nextEntity;
      if (nextObject instanceof BaseDateTimeDt) {
        BaseDateTimeDt nextValue=(BaseDateTimeDt)nextObject;
        if (nextValue.isEmpty()) {
          continue;
        }
        nextEntity=new ResourceIndexedSearchParamDate(nextSpDef.getName(),nextValue.getValue(),nextValue.getValue());
      }
 else       if (nextObject instanceof PeriodDt) {
        PeriodDt nextValue=(PeriodDt)nextObject;
        if (nextValue.isEmpty()) {
          continue;
        }
        nextEntity=new ResourceIndexedSearchParamDate(nextSpDef.getName(),nextValue.getStart().getValue(),nextValue.getEnd().getValue());
      }
 else {
        if (!multiType) {
          throw new ConfigurationException(""String_Node_Str"" + nextSpDef.getName() + ""String_Node_Str""+ nextObject.getClass());
        }
 else {
          continue;
        }
      }
      if (nextEntity != null) {
        nextEntity.setResource(theEntity);
        retVal.add(nextEntity);
      }
    }
  }
  theEntity.setParamsDatePopulated(retVal.size() > 0);
  return retVal;
}","protected List<ResourceIndexedSearchParamDate> extractSearchParamDates(ResourceTable theEntity,IResource theResource){
  ArrayList<ResourceIndexedSearchParamDate> retVal=new ArrayList<ResourceIndexedSearchParamDate>();
  RuntimeResourceDefinition def=getContext().getResourceDefinition(theResource);
  FhirTerser t=getContext().newTerser();
  for (  RuntimeSearchParam nextSpDef : def.getSearchParams()) {
    if (nextSpDef.getParamType() != SearchParamTypeEnum.DATE) {
      continue;
    }
    String nextPath=nextSpDef.getPath();
    if (isBlank(nextPath)) {
      continue;
    }
    boolean multiType=false;
    if (nextPath.endsWith(""String_Node_Str"")) {
      multiType=true;
    }
    List<Object> values=t.getValues(theResource,nextPath);
    for (    Object nextObject : values) {
      if (nextObject == null) {
        continue;
      }
      ResourceIndexedSearchParamDate nextEntity;
      if (nextObject instanceof BaseDateTimeDt) {
        BaseDateTimeDt nextValue=(BaseDateTimeDt)nextObject;
        if (nextValue.isEmpty()) {
          continue;
        }
        nextEntity=new ResourceIndexedSearchParamDate(nextSpDef.getName(),nextValue.getValue(),nextValue.getValue());
      }
 else       if (nextObject instanceof PeriodDt) {
        PeriodDt nextValue=(PeriodDt)nextObject;
        if (nextValue.isEmpty()) {
          continue;
        }
        nextEntity=new ResourceIndexedSearchParamDate(nextSpDef.getName(),nextValue.getStart().getValue(),nextValue.getEnd().getValue());
      }
 else {
        if (!multiType) {
          throw new ConfigurationException(""String_Node_Str"" + nextSpDef.getName() + ""String_Node_Str""+ nextObject.getClass());
        }
 else {
          continue;
        }
      }
      if (nextEntity != null) {
        nextEntity.setResource(theEntity);
        retVal.add(nextEntity);
      }
    }
  }
  theEntity.setParamsDatePopulated(retVal.size() > 0);
  return retVal;
}",0.9865824782951856
112327,"protected ArrayList<ResourceIndexedSearchParamNumber> extractSearchParamNumber(ResourceTable theEntity,IResource theResource){
  ArrayList<ResourceIndexedSearchParamNumber> retVal=new ArrayList<ResourceIndexedSearchParamNumber>();
  RuntimeResourceDefinition def=getContext().getResourceDefinition(theResource);
  FhirTerser t=getContext().newTerser();
  for (  RuntimeSearchParam nextSpDef : def.getSearchParams()) {
    if (nextSpDef.getParamType() != SearchParamTypeEnum.NUMBER) {
      continue;
    }
    String nextPath=nextSpDef.getPath();
    List<Object> values=t.getValues(theResource,nextPath);
    for (    Object nextObject : values) {
      if (nextObject == null || ((IDatatype)nextObject).isEmpty()) {
        continue;
      }
      String resourceName=nextSpDef.getName();
      boolean multiType=false;
      if (nextPath.endsWith(""String_Node_Str"")) {
        multiType=true;
      }
      if (nextObject instanceof DurationDt) {
        DurationDt nextValue=(DurationDt)nextObject;
        if (nextValue.getValue().isEmpty()) {
          continue;
        }
        if (new UriDt(UCUM_NS).equals(nextValue.getSystem())) {
          if (isNotBlank(nextValue.getCode().getValue())) {
            Unit<? extends Quantity> unit=Unit.valueOf(nextValue.getCode().getValue());
            javax.measure.converter.UnitConverter dayConverter=unit.getConverterTo(NonSI.DAY);
            double dayValue=dayConverter.convert(nextValue.getValue().getValue().doubleValue());
            DurationDt newValue=new DurationDt();
            newValue.setSystem(UCUM_NS);
            newValue.setCode(NonSI.DAY.toString());
            newValue.setValue(dayValue);
            nextValue=newValue;
          }
        }
        ResourceIndexedSearchParamNumber nextEntity=new ResourceIndexedSearchParamNumber(resourceName,nextValue.getValue().getValue());
        nextEntity.setResource(theEntity);
        retVal.add(nextEntity);
      }
 else       if (nextObject instanceof QuantityDt) {
        QuantityDt nextValue=(QuantityDt)nextObject;
        if (nextValue.getValue().isEmpty()) {
          continue;
        }
        ResourceIndexedSearchParamNumber nextEntity=new ResourceIndexedSearchParamNumber(resourceName,nextValue.getValue().getValue());
        nextEntity.setResource(theEntity);
        retVal.add(nextEntity);
      }
 else {
        if (!multiType) {
          throw new ConfigurationException(""String_Node_Str"" + resourceName + ""String_Node_Str""+ nextObject.getClass());
        }
 else {
          continue;
        }
      }
    }
  }
  theEntity.setParamsNumberPopulated(retVal.size() > 0);
  return retVal;
}","protected ArrayList<ResourceIndexedSearchParamNumber> extractSearchParamNumber(ResourceTable theEntity,IResource theResource){
  ArrayList<ResourceIndexedSearchParamNumber> retVal=new ArrayList<ResourceIndexedSearchParamNumber>();
  RuntimeResourceDefinition def=getContext().getResourceDefinition(theResource);
  FhirTerser t=getContext().newTerser();
  for (  RuntimeSearchParam nextSpDef : def.getSearchParams()) {
    if (nextSpDef.getParamType() != SearchParamTypeEnum.NUMBER) {
      continue;
    }
    String nextPath=nextSpDef.getPath();
    if (isBlank(nextPath)) {
      continue;
    }
    List<Object> values=t.getValues(theResource,nextPath);
    for (    Object nextObject : values) {
      if (nextObject == null || ((IDatatype)nextObject).isEmpty()) {
        continue;
      }
      String resourceName=nextSpDef.getName();
      boolean multiType=false;
      if (nextPath.endsWith(""String_Node_Str"")) {
        multiType=true;
      }
      if (nextObject instanceof DurationDt) {
        DurationDt nextValue=(DurationDt)nextObject;
        if (nextValue.getValue().isEmpty()) {
          continue;
        }
        if (new UriDt(UCUM_NS).equals(nextValue.getSystem())) {
          if (isNotBlank(nextValue.getCode().getValue())) {
            Unit<? extends Quantity> unit=Unit.valueOf(nextValue.getCode().getValue());
            javax.measure.converter.UnitConverter dayConverter=unit.getConverterTo(NonSI.DAY);
            double dayValue=dayConverter.convert(nextValue.getValue().getValue().doubleValue());
            DurationDt newValue=new DurationDt();
            newValue.setSystem(UCUM_NS);
            newValue.setCode(NonSI.DAY.toString());
            newValue.setValue(dayValue);
            nextValue=newValue;
          }
        }
        ResourceIndexedSearchParamNumber nextEntity=new ResourceIndexedSearchParamNumber(resourceName,nextValue.getValue().getValue());
        nextEntity.setResource(theEntity);
        retVal.add(nextEntity);
      }
 else       if (nextObject instanceof QuantityDt) {
        QuantityDt nextValue=(QuantityDt)nextObject;
        if (nextValue.getValue().isEmpty()) {
          continue;
        }
        ResourceIndexedSearchParamNumber nextEntity=new ResourceIndexedSearchParamNumber(resourceName,nextValue.getValue().getValue());
        nextEntity.setResource(theEntity);
        retVal.add(nextEntity);
      }
 else {
        if (!multiType) {
          throw new ConfigurationException(""String_Node_Str"" + resourceName + ""String_Node_Str""+ nextObject.getClass());
        }
 else {
          continue;
        }
      }
    }
  }
  theEntity.setParamsNumberPopulated(retVal.size() > 0);
  return retVal;
}",0.9904189366898366
112328,"protected void handleRequest(SearchMethodBinding.RequestType theRequestType,HttpServletRequest theRequest,HttpServletResponse theResponse) throws ServletException, IOException {
}","protected void handleRequest(SearchMethodBinding.RequestType theRequestType,HttpServletRequest theRequest,HttpServletResponse theResponse) throws ServletException, IOException {
  for (  IServerInterceptor next : myInterceptors) {
    boolean continueProcessing=next.incomingRequestPreProcessed(theRequest,theResponse);
    if (!continueProcessing) {
      ourLog.debug(""String_Node_Str"");
      return;
    }
  }
  String fhirServerBase=null;
  boolean requestIsBrowser=requestIsBrowser(theRequest);
  RequestDetails requestDetails=null;
  try {
    String resourceName=null;
    String requestFullPath=StringUtils.defaultString(theRequest.getRequestURI());
    String servletPath=StringUtils.defaultString(theRequest.getServletPath());
    StringBuffer requestUrl=theRequest.getRequestURL();
    String servletContextPath=""String_Node_Str"";
    if (getServletContext() != null) {
      servletContextPath=StringUtils.defaultString(getServletContext().getContextPath());
    }
    if (ourLog.isTraceEnabled()) {
      ourLog.trace(""String_Node_Str"",requestFullPath);
      ourLog.trace(""String_Node_Str"",servletPath);
      ourLog.trace(""String_Node_Str"",requestUrl);
      ourLog.trace(""String_Node_Str"",servletContextPath);
    }
    IdDt id=null;
    String operation=null;
    String compartment=null;
    String requestPath=requestFullPath.substring(escapedLength(servletContextPath) + escapedLength(servletPath));
    if (requestPath.length() > 0 && requestPath.charAt(0) == '/') {
      requestPath=requestPath.substring(1);
    }
    fhirServerBase=myServerAddressStrategy.determineServerBase(getServletContext(),theRequest);
    if (fhirServerBase.endsWith(""String_Node_Str"")) {
      fhirServerBase=fhirServerBase.substring(0,fhirServerBase.length() - 1);
    }
    String completeUrl=StringUtils.isNotBlank(theRequest.getQueryString()) ? requestUrl + ""String_Node_Str"" + theRequest.getQueryString() : requestUrl.toString();
    Map<String,String[]> params=new HashMap<String,String[]>(theRequest.getParameterMap());
    StringTokenizer tok=new StringTokenizer(requestPath,""String_Node_Str"");
    if (tok.hasMoreTokens()) {
      resourceName=tok.nextToken();
      if (resourceName.startsWith(""String_Node_Str"")) {
        operation=resourceName;
        resourceName=null;
      }
    }
    ResourceBinding resourceBinding=null;
    BaseMethodBinding<?> resourceMethod=null;
    if (""String_Node_Str"".equals(resourceName) || theRequestType == RequestType.OPTIONS) {
      resourceMethod=myServerConformanceMethod;
    }
 else     if (resourceName == null) {
      resourceBinding=myNullResourceBinding;
    }
 else {
      resourceBinding=myResourceNameToProvider.get(resourceName);
      if (resourceBinding == null) {
        throw new InvalidRequestException(""String_Node_Str"" + resourceName + ""String_Node_Str""+ myResourceNameToProvider.keySet());
      }
    }
    if (tok.hasMoreTokens()) {
      String nextString=tok.nextToken();
      if (nextString.startsWith(""String_Node_Str"")) {
        operation=nextString;
      }
 else {
        id=new IdDt(resourceName,nextString);
      }
    }
    if (tok.hasMoreTokens()) {
      String nextString=tok.nextToken();
      if (nextString.equals(Constants.PARAM_HISTORY)) {
        if (tok.hasMoreTokens()) {
          String versionString=tok.nextToken();
          if (id == null) {
            throw new InvalidRequestException(""String_Node_Str"" + requestPath);
          }
          id=new IdDt(resourceName + ""String_Node_Str"" + id.getIdPart()+ ""String_Node_Str""+ versionString);
        }
 else {
          operation=Constants.PARAM_HISTORY;
        }
      }
 else       if (nextString.startsWith(""String_Node_Str"")) {
        if (operation != null) {
          throw new InvalidRequestException(""String_Node_Str"" + requestPath);
        }
        operation=nextString;
      }
 else {
        compartment=nextString;
      }
    }
    String secondaryOperation=null;
    while (tok.hasMoreTokens()) {
      String nextString=tok.nextToken();
      if (operation == null) {
        operation=nextString;
      }
 else       if (secondaryOperation == null) {
        secondaryOperation=nextString;
      }
 else {
        throw new InvalidRequestException(""String_Node_Str"" + nextString + ""String_Node_Str""+ requestPath);
      }
    }
    if (theRequestType == RequestType.PUT) {
      String contentLocation=theRequest.getHeader(Constants.HEADER_CONTENT_LOCATION);
      if (contentLocation != null) {
        id=new IdDt(contentLocation);
      }
    }
    String acceptEncoding=theRequest.getHeader(Constants.HEADER_ACCEPT_ENCODING);
    boolean respondGzip=false;
    if (acceptEncoding != null) {
      String[] parts=acceptEncoding.trim().split(""String_Node_Str"");
      for (      String string : parts) {
        if (string.equals(""String_Node_Str"")) {
          respondGzip=true;
        }
      }
    }
    Request r=new Request();
    r.setResourceName(resourceName);
    r.setId(id);
    r.setOperation(operation);
    r.setSecondaryOperation(secondaryOperation);
    r.setParameters(params);
    r.setRequestType(theRequestType);
    r.setFhirServerBase(fhirServerBase);
    r.setCompleteUrl(completeUrl);
    r.setServletRequest(theRequest);
    r.setServletResponse(theResponse);
    r.setRespondGzip(respondGzip);
    r.setCompartmentName(compartment);
    String pagingAction=theRequest.getParameter(Constants.PARAM_PAGINGACTION);
    if (getPagingProvider() != null && isNotBlank(pagingAction)) {
      r.setOtherOperationType(OtherOperationTypeEnum.GET_PAGE);
      handlePagingRequest(r,theResponse,pagingAction);
      return;
    }
    if (resourceMethod == null && resourceBinding != null) {
      resourceMethod=resourceBinding.getMethod(r);
    }
    if (resourceMethod == null) {
      StringBuilder b=new StringBuilder();
      b.append(""String_Node_Str"");
      b.append(theRequestType.name());
      b.append(""String_Node_Str"");
      b.append(requestPath);
      b.append(""String_Node_Str"");
      b.append(""String_Node_Str"");
      b.append(params.keySet());
      throw new InvalidRequestException(b.toString());
    }
    requestDetails=r;
    requestDetails.setResourceOperationType(resourceMethod.getResourceOperationType());
    requestDetails.setSystemOperationType(resourceMethod.getSystemOperationType());
    requestDetails.setOtherOperationType(resourceMethod.getOtherOperationType());
    for (    IServerInterceptor next : myInterceptors) {
      boolean continueProcessing=next.incomingRequestPostProcessed(requestDetails,theRequest,theResponse);
      if (!continueProcessing) {
        ourLog.debug(""String_Node_Str"");
        return;
      }
    }
    resourceMethod.invokeServer(this,r);
  }
 catch (  AuthenticationException e) {
    for (int i=getInterceptors().size() - 1; i >= 0; i--) {
      IServerInterceptor next=getInterceptors().get(i);
      if (!next.handleException(requestDetails,e,theRequest,theResponse)) {
        ourLog.debug(""String_Node_Str"");
        return;
      }
    }
    if (requestIsBrowser) {
      theResponse.setHeader(""String_Node_Str"",""String_Node_Str"");
    }
    theResponse.setStatus(e.getStatusCode());
    addHeadersToResponse(theResponse);
    theResponse.setContentType(""String_Node_Str"");
    theResponse.setCharacterEncoding(""String_Node_Str"");
    theResponse.getWriter().write(e.getMessage());
  }
catch (  Throwable e) {
    for (int i=getInterceptors().size() - 1; i >= 0; i--) {
      IServerInterceptor next=getInterceptors().get(i);
      if (!next.handleException(requestDetails,e,theRequest,theResponse)) {
        ourLog.debug(""String_Node_Str"");
        return;
      }
    }
    BaseOperationOutcome oo=null;
    int statusCode=Constants.STATUS_HTTP_500_INTERNAL_ERROR;
    if (e instanceof BaseServerResponseException) {
      oo=((BaseServerResponseException)e).getOperationOutcome();
      statusCode=((BaseServerResponseException)e).getStatusCode();
    }
    if (oo == null) {
      try {
        oo=(BaseOperationOutcome)myFhirContext.getResourceDefinition(""String_Node_Str"").getImplementingClass().newInstance();
      }
 catch (      Exception e1) {
        ourLog.error(""String_Node_Str"",e1);
        throw new ServletException(""String_Node_Str"",e1);
      }
      BaseIssue issue=oo.addIssue();
      issue.getSeverityElement().setValue(""String_Node_Str"");
      if (e instanceof InternalErrorException) {
        ourLog.error(""String_Node_Str"",e);
        issue.getDetailsElement().setValue(e.toString() + ""String_Node_Str"" + ExceptionUtils.getStackTrace(e));
      }
 else       if (e instanceof BaseServerResponseException) {
        ourLog.warn(""String_Node_Str"",e.toString());
        BaseServerResponseException baseServerResponseException=(BaseServerResponseException)e;
        statusCode=baseServerResponseException.getStatusCode();
        issue.getDetailsElement().setValue(e.getMessage());
        if (baseServerResponseException.getAdditionalMessages() != null) {
          for (          String next : baseServerResponseException.getAdditionalMessages()) {
            BaseIssue issue2=oo.addIssue();
            issue2.getSeverityElement().setValue(""String_Node_Str"");
            issue2.setDetails(next);
          }
        }
      }
 else {
        ourLog.error(""String_Node_Str"" + e.toString(),e);
        issue.getDetailsElement().setValue(e.toString() + ""String_Node_Str"" + ExceptionUtils.getStackTrace(e));
        statusCode=Constants.STATUS_HTTP_500_INTERNAL_ERROR;
      }
    }
    streamResponseAsResource(this,theResponse,oo,determineResponseEncoding(theRequest),true,requestIsBrowser,NarrativeModeEnum.NORMAL,statusCode,false,fhirServerBase);
    theResponse.setStatus(statusCode);
    addHeadersToResponse(theResponse);
    theResponse.setContentType(""String_Node_Str"");
    theResponse.setCharacterEncoding(""String_Node_Str"");
    theResponse.getWriter().append(e.getMessage());
    theResponse.getWriter().close();
  }
}",0.0353929807217004
112329,"/** 
 * Returns the scanned runtime model for the given type. This is an advanced feature which is generally only needed for extending the core library.
 */
@SuppressWarnings(""String_Node_Str"") public RuntimeResourceDefinition getResourceDefinition(String theResourceName){
  String resourceName=theResourceName;
  if (Character.isLowerCase(resourceName.charAt(0))) {
    resourceName=WordUtils.capitalize(resourceName);
  }
  Validate.notBlank(resourceName,""String_Node_Str"");
  RuntimeResourceDefinition retVal=myNameToElementDefinition.get(resourceName);
  if (retVal == null) {
    try {
      String className=myNameToResourceType.get(resourceName.toLowerCase());
      if (className == null) {
        throw new DataFormatException(""String_Node_Str"" + resourceName + ""String_Node_Str"");
      }
      Class<?> clazz=Class.forName(className);
      if (IResource.class.isAssignableFrom(clazz)) {
        retVal=scanResourceType((Class<? extends IResource>)clazz);
      }
    }
 catch (    ClassNotFoundException e) {
      throw new DataFormatException(""String_Node_Str"" + resourceName + ""String_Node_Str"");
    }
  }
  return retVal;
}","/** 
 * Returns the scanned runtime model for the given type. This is an advanced feature which is generally only needed for extending the core library.
 */
@SuppressWarnings(""String_Node_Str"") public RuntimeResourceDefinition getResourceDefinition(String theResourceName){
  String resourceName=theResourceName;
  if (Character.isLowerCase(resourceName.charAt(0))) {
    resourceName=WordUtils.capitalize(resourceName);
  }
  Validate.notBlank(resourceName,""String_Node_Str"");
  RuntimeResourceDefinition retVal=myNameToElementDefinition.get(resourceName);
  if (retVal == null) {
    try {
      String className=myNameToResourceType.get(resourceName.toLowerCase());
      if (className == null) {
        if (""String_Node_Str"".equals(resourceName.toLowerCase())) {
          className=Binary.class.getName();
        }
 else {
          throw new DataFormatException(""String_Node_Str"" + resourceName + ""String_Node_Str"");
        }
      }
      Class<?> clazz=Class.forName(className);
      if (IResource.class.isAssignableFrom(clazz)) {
        retVal=scanResourceType((Class<? extends IResource>)clazz);
      }
    }
 catch (    ClassNotFoundException e) {
      throw new DataFormatException(""String_Node_Str"" + resourceName + ""String_Node_Str"");
    }
  }
  return retVal;
}",0.9414674361088212
112330,"private Set<Long> addPredicateString(Set<Long> thePids,List<IQueryParameterType> theOrParams){
  if (theOrParams == null || theOrParams.isEmpty()) {
    return thePids;
  }
  CriteriaBuilder builder=myEntityManager.getCriteriaBuilder();
  CriteriaQuery<Long> cq=builder.createQuery(Long.class);
  Root<ResourceIndexedSearchParamString> from=cq.from(ResourceIndexedSearchParamString.class);
  cq.select(from.get(""String_Node_Str"").as(Long.class));
  List<Predicate> codePredicates=new ArrayList<Predicate>();
  for (  IQueryParameterType nextOr : theOrParams) {
    IQueryParameterType params=nextOr;
    String string;
    if (params instanceof IPrimitiveDatatype<?>) {
      IPrimitiveDatatype<?> id=(IPrimitiveDatatype<?>)params;
      string=id.getValueAsString();
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + params.getClass());
    }
    Predicate singleCode=builder.equal(from.get(""String_Node_Str""),normalizeString(string));
    if (params instanceof StringParam && ((StringParam)params).isExact()) {
      Predicate exactCode=builder.equal(from.get(""String_Node_Str""),string);
      singleCode=builder.and(singleCode,exactCode);
    }
    codePredicates.add(singleCode);
  }
  Predicate masterCodePredicate=builder.or(codePredicates.toArray(new Predicate[0]));
  Predicate type=builder.equal(from.get(""String_Node_Str""),myResourceName);
  if (thePids.size() > 0) {
    Predicate inPids=(from.get(""String_Node_Str"").in(thePids));
    cq.where(builder.and(type,inPids,masterCodePredicate));
  }
 else {
    cq.where(builder.and(type,masterCodePredicate));
  }
  TypedQuery<Long> q=myEntityManager.createQuery(cq);
  return new HashSet<Long>(q.getResultList());
}","private Set<Long> addPredicateString(String theParamName,Set<Long> thePids,List<IQueryParameterType> theOrParams){
  if (theOrParams == null || theOrParams.isEmpty()) {
    return thePids;
  }
  CriteriaBuilder builder=myEntityManager.getCriteriaBuilder();
  CriteriaQuery<Long> cq=builder.createQuery(Long.class);
  Root<ResourceIndexedSearchParamString> from=cq.from(ResourceIndexedSearchParamString.class);
  cq.select(from.get(""String_Node_Str"").as(Long.class));
  List<Predicate> codePredicates=new ArrayList<Predicate>();
  for (  IQueryParameterType nextOr : theOrParams) {
    IQueryParameterType params=nextOr;
    String string;
    if (params instanceof IPrimitiveDatatype<?>) {
      IPrimitiveDatatype<?> id=(IPrimitiveDatatype<?>)params;
      string=id.getValueAsString();
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + params.getClass());
    }
    Predicate singleCode=builder.equal(from.get(""String_Node_Str""),normalizeString(string));
    if (params instanceof StringParam && ((StringParam)params).isExact()) {
      Predicate exactCode=builder.equal(from.get(""String_Node_Str""),string);
      singleCode=builder.and(singleCode,exactCode);
    }
    codePredicates.add(singleCode);
  }
  Predicate masterCodePredicate=builder.or(codePredicates.toArray(new Predicate[0]));
  Predicate type=builder.equal(from.get(""String_Node_Str""),myResourceName);
  Predicate name=builder.equal(from.get(""String_Node_Str""),theParamName);
  if (thePids.size() > 0) {
    Predicate inPids=(from.get(""String_Node_Str"").in(thePids));
    cq.where(builder.and(type,name,masterCodePredicate,inPids));
  }
 else {
    cq.where(builder.and(type,name,masterCodePredicate));
  }
  TypedQuery<Long> q=myEntityManager.createQuery(cq);
  return new HashSet<Long>(q.getResultList());
}",0.9405714285714286
112331,"private Set<Long> addPredicateToken(Set<Long> thePids,List<IQueryParameterType> theOrParams){
  if (theOrParams == null || theOrParams.isEmpty()) {
    return thePids;
  }
  CriteriaBuilder builder=myEntityManager.getCriteriaBuilder();
  CriteriaQuery<Long> cq=builder.createQuery(Long.class);
  Root<ResourceIndexedSearchParamToken> from=cq.from(ResourceIndexedSearchParamToken.class);
  cq.select(from.get(""String_Node_Str"").as(Long.class));
  List<Predicate> codePredicates=new ArrayList<Predicate>();
  for (  IQueryParameterType nextOr : theOrParams) {
    IQueryParameterType params=nextOr;
    String code;
    String system;
    if (params instanceof IdentifierDt) {
      IdentifierDt id=(IdentifierDt)params;
      system=id.getSystem().getValueAsString();
      code=id.getValue().getValue();
    }
 else     if (params instanceof CodingDt) {
      CodingDt id=(CodingDt)params;
      system=id.getSystem().getValueAsString();
      code=id.getCode().getValue();
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + params.getClass());
    }
    ArrayList<Predicate> singleCodePredicates=(new ArrayList<Predicate>());
    if (StringUtils.isNotBlank(system)) {
      singleCodePredicates.add(builder.equal(from.get(""String_Node_Str""),system));
    }
 else {
      singleCodePredicates.add(builder.isNull(from.get(""String_Node_Str"")));
    }
    if (StringUtils.isNotBlank(code)) {
      singleCodePredicates.add(builder.equal(from.get(""String_Node_Str""),code));
    }
 else {
      singleCodePredicates.add(builder.isNull(from.get(""String_Node_Str"")));
    }
    Predicate singleCode=builder.and(singleCodePredicates.toArray(new Predicate[0]));
    codePredicates.add(singleCode);
  }
  Predicate masterCodePredicate=builder.or(codePredicates.toArray(new Predicate[0]));
  Predicate type=builder.equal(from.get(""String_Node_Str""),myResourceName);
  if (thePids.size() > 0) {
    Predicate inPids=(from.get(""String_Node_Str"").in(thePids));
    cq.where(builder.and(type,inPids,masterCodePredicate));
  }
 else {
    cq.where(builder.and(type,masterCodePredicate));
  }
  TypedQuery<Long> q=myEntityManager.createQuery(cq);
  return new HashSet<Long>(q.getResultList());
}","private Set<Long> addPredicateToken(String theParamName,Set<Long> thePids,List<IQueryParameterType> theOrParams){
  if (theOrParams == null || theOrParams.isEmpty()) {
    return thePids;
  }
  CriteriaBuilder builder=myEntityManager.getCriteriaBuilder();
  CriteriaQuery<Long> cq=builder.createQuery(Long.class);
  Root<ResourceIndexedSearchParamToken> from=cq.from(ResourceIndexedSearchParamToken.class);
  cq.select(from.get(""String_Node_Str"").as(Long.class));
  List<Predicate> codePredicates=new ArrayList<Predicate>();
  for (  IQueryParameterType nextOr : theOrParams) {
    IQueryParameterType params=nextOr;
    String code;
    String system;
    if (params instanceof IdentifierDt) {
      IdentifierDt id=(IdentifierDt)params;
      system=id.getSystem().getValueAsString();
      code=id.getValue().getValue();
    }
 else     if (params instanceof CodingDt) {
      CodingDt id=(CodingDt)params;
      system=id.getSystem().getValueAsString();
      code=id.getCode().getValue();
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + params.getClass());
    }
    ArrayList<Predicate> singleCodePredicates=(new ArrayList<Predicate>());
    if (StringUtils.isNotBlank(system)) {
      singleCodePredicates.add(builder.equal(from.get(""String_Node_Str""),system));
    }
 else {
      singleCodePredicates.add(builder.isNull(from.get(""String_Node_Str"")));
    }
    if (StringUtils.isNotBlank(code)) {
      singleCodePredicates.add(builder.equal(from.get(""String_Node_Str""),code));
    }
 else {
      singleCodePredicates.add(builder.isNull(from.get(""String_Node_Str"")));
    }
    Predicate singleCode=builder.and(singleCodePredicates.toArray(new Predicate[0]));
    codePredicates.add(singleCode);
  }
  Predicate masterCodePredicate=builder.or(codePredicates.toArray(new Predicate[0]));
  Predicate type=builder.equal(from.get(""String_Node_Str""),myResourceName);
  Predicate name=builder.equal(from.get(""String_Node_Str""),theParamName);
  if (thePids.size() > 0) {
    Predicate inPids=(from.get(""String_Node_Str"").in(thePids));
    cq.where(builder.and(type,name,masterCodePredicate,inPids));
  }
 else {
    cq.where(builder.and(type,name,masterCodePredicate));
  }
  TypedQuery<Long> q=myEntityManager.createQuery(cq);
  return new HashSet<Long>(q.getResultList());
}",0.9538598047914818
112332,"@Override public Set<Long> searchForIdsWithAndOr(Map<String,List<List<IQueryParameterType>>> theParams){
  Map<String,List<List<IQueryParameterType>>> params=theParams;
  if (params == null) {
    params=Collections.emptyMap();
  }
  RuntimeResourceDefinition resourceDef=getContext().getResourceDefinition(myResourceType);
  Set<Long> pids=new HashSet<Long>();
  for (  Entry<String,List<List<IQueryParameterType>>> nextParamEntry : params.entrySet()) {
    String nextParamName=nextParamEntry.getKey();
    if (nextParamName.equals(""String_Node_Str"")) {
      if (nextParamEntry.getValue().isEmpty()) {
        continue;
      }
 else       if (nextParamEntry.getValue().size() > 1) {
        throw new InvalidRequestException(""String_Node_Str"");
      }
 else {
        Set<Long> joinPids=new HashSet<Long>();
        List<IQueryParameterType> nextValue=nextParamEntry.getValue().get(0);
        if (nextValue == null || nextValue.size() == 0) {
          continue;
        }
 else {
          for (          IQueryParameterType next : nextValue) {
            String value=next.getValueAsQueryToken();
            long valueLong=Long.parseLong(value);
            joinPids.add(valueLong);
          }
          if (joinPids.isEmpty()) {
            continue;
          }
        }
        if (pids.isEmpty()) {
          pids.addAll(joinPids);
        }
 else {
          pids.retainAll(joinPids);
        }
      }
    }
    RuntimeSearchParam nextParamDef=resourceDef.getSearchParam(nextParamName);
    if (nextParamDef != null) {
      if (nextParamDef.getParamType() == SearchParamTypeEnum.TOKEN) {
        for (        List<IQueryParameterType> nextAnd : nextParamEntry.getValue()) {
          pids=addPredicateToken(pids,nextAnd);
          if (pids.isEmpty()) {
            return new HashSet<Long>();
          }
        }
      }
 else       if (nextParamDef.getParamType() == SearchParamTypeEnum.STRING) {
        for (        List<IQueryParameterType> nextAnd : nextParamEntry.getValue()) {
          pids=addPredicateString(pids,nextAnd);
          if (pids.isEmpty()) {
            return new HashSet<Long>();
          }
        }
      }
 else       if (nextParamDef.getParamType() == SearchParamTypeEnum.QUANTITY) {
        for (        List<IQueryParameterType> nextAnd : nextParamEntry.getValue()) {
          pids=addPredicateQuantity(pids,nextAnd);
          if (pids.isEmpty()) {
            return new HashSet<Long>();
          }
        }
      }
 else       if (nextParamDef.getParamType() == SearchParamTypeEnum.DATE) {
        for (        List<IQueryParameterType> nextAnd : nextParamEntry.getValue()) {
          pids=addPredicateDate(pids,nextAnd);
          if (pids.isEmpty()) {
            return new HashSet<Long>();
          }
        }
      }
 else       if (nextParamDef.getParamType() == SearchParamTypeEnum.REFERENCE) {
        for (        List<IQueryParameterType> nextAnd : nextParamEntry.getValue()) {
          pids=addPredicateReference(nextParamName,pids,nextAnd);
          if (pids.isEmpty()) {
            return new HashSet<Long>();
          }
        }
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + nextParamDef.getParamType());
      }
    }
  }
  return pids;
}","@Override public Set<Long> searchForIdsWithAndOr(Map<String,List<List<IQueryParameterType>>> theParams){
  Map<String,List<List<IQueryParameterType>>> params=theParams;
  if (params == null) {
    params=Collections.emptyMap();
  }
  RuntimeResourceDefinition resourceDef=getContext().getResourceDefinition(myResourceType);
  Set<Long> pids=new HashSet<Long>();
  for (  Entry<String,List<List<IQueryParameterType>>> nextParamEntry : params.entrySet()) {
    String nextParamName=nextParamEntry.getKey();
    if (nextParamName.equals(""String_Node_Str"")) {
      if (nextParamEntry.getValue().isEmpty()) {
        continue;
      }
 else       if (nextParamEntry.getValue().size() > 1) {
        throw new InvalidRequestException(""String_Node_Str"");
      }
 else {
        Set<Long> joinPids=new HashSet<Long>();
        List<IQueryParameterType> nextValue=nextParamEntry.getValue().get(0);
        if (nextValue == null || nextValue.size() == 0) {
          continue;
        }
 else {
          for (          IQueryParameterType next : nextValue) {
            String value=next.getValueAsQueryToken();
            long valueLong=Long.parseLong(value);
            joinPids.add(valueLong);
          }
          if (joinPids.isEmpty()) {
            continue;
          }
        }
        if (pids.isEmpty()) {
          pids.addAll(joinPids);
        }
 else {
          pids.retainAll(joinPids);
        }
      }
    }
    RuntimeSearchParam nextParamDef=resourceDef.getSearchParam(nextParamName);
    if (nextParamDef != null) {
      if (nextParamDef.getParamType() == SearchParamTypeEnum.TOKEN) {
        for (        List<IQueryParameterType> nextAnd : nextParamEntry.getValue()) {
          pids=addPredicateToken(nextParamName,pids,nextAnd);
          if (pids.isEmpty()) {
            return new HashSet<Long>();
          }
        }
      }
 else       if (nextParamDef.getParamType() == SearchParamTypeEnum.STRING) {
        for (        List<IQueryParameterType> nextAnd : nextParamEntry.getValue()) {
          pids=addPredicateString(nextParamName,pids,nextAnd);
          if (pids.isEmpty()) {
            return new HashSet<Long>();
          }
        }
      }
 else       if (nextParamDef.getParamType() == SearchParamTypeEnum.QUANTITY) {
        for (        List<IQueryParameterType> nextAnd : nextParamEntry.getValue()) {
          pids=addPredicateQuantity(nextParamName,pids,nextAnd);
          if (pids.isEmpty()) {
            return new HashSet<Long>();
          }
        }
      }
 else       if (nextParamDef.getParamType() == SearchParamTypeEnum.DATE) {
        for (        List<IQueryParameterType> nextAnd : nextParamEntry.getValue()) {
          pids=addPredicateDate(nextParamName,pids,nextAnd);
          if (pids.isEmpty()) {
            return new HashSet<Long>();
          }
        }
      }
 else       if (nextParamDef.getParamType() == SearchParamTypeEnum.REFERENCE) {
        for (        List<IQueryParameterType> nextAnd : nextParamEntry.getValue()) {
          pids=addPredicateReference(nextParamName,pids,nextAnd);
          if (pids.isEmpty()) {
            return new HashSet<Long>();
          }
        }
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + nextParamDef.getParamType());
      }
    }
  }
  return pids;
}",0.991468616697136
112333,"private Set<Long> addPredicateDate(Set<Long> thePids,List<IQueryParameterType> theOrParams){
  if (theOrParams == null || theOrParams.isEmpty()) {
    return thePids;
  }
  CriteriaBuilder builder=myEntityManager.getCriteriaBuilder();
  CriteriaQuery<Long> cq=builder.createQuery(Long.class);
  Root<ResourceIndexedSearchParamDate> from=cq.from(ResourceIndexedSearchParamDate.class);
  cq.select(from.get(""String_Node_Str"").as(Long.class));
  List<Predicate> codePredicates=new ArrayList<Predicate>();
  for (  IQueryParameterType nextOr : theOrParams) {
    IQueryParameterType params=nextOr;
    if (params instanceof QualifiedDateParam) {
      QualifiedDateParam id=(QualifiedDateParam)params;
      DateRangeParam range=new DateRangeParam(id);
      addPredicateDateFromRange(builder,from,codePredicates,range);
    }
 else     if (params instanceof DateRangeParam) {
      DateRangeParam range=(DateRangeParam)params;
      addPredicateDateFromRange(builder,from,codePredicates,range);
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + params.getClass());
    }
  }
  Predicate masterCodePredicate=builder.or(codePredicates.toArray(new Predicate[0]));
  Predicate type=builder.equal(from.get(""String_Node_Str""),myResourceName);
  if (thePids.size() > 0) {
    Predicate inPids=(from.get(""String_Node_Str"").in(thePids));
    cq.where(builder.and(type,inPids,masterCodePredicate));
  }
 else {
    cq.where(builder.and(type,masterCodePredicate));
  }
  TypedQuery<Long> q=myEntityManager.createQuery(cq);
  return new HashSet<Long>(q.getResultList());
}","private Set<Long> addPredicateDate(String theParamName,Set<Long> thePids,List<IQueryParameterType> theOrParams){
  if (theOrParams == null || theOrParams.isEmpty()) {
    return thePids;
  }
  CriteriaBuilder builder=myEntityManager.getCriteriaBuilder();
  CriteriaQuery<Long> cq=builder.createQuery(Long.class);
  Root<ResourceIndexedSearchParamDate> from=cq.from(ResourceIndexedSearchParamDate.class);
  cq.select(from.get(""String_Node_Str"").as(Long.class));
  List<Predicate> codePredicates=new ArrayList<Predicate>();
  for (  IQueryParameterType nextOr : theOrParams) {
    IQueryParameterType params=nextOr;
    if (params instanceof QualifiedDateParam) {
      QualifiedDateParam id=(QualifiedDateParam)params;
      DateRangeParam range=new DateRangeParam(id);
      addPredicateDateFromRange(builder,from,codePredicates,range);
    }
 else     if (params instanceof DateRangeParam) {
      DateRangeParam range=(DateRangeParam)params;
      addPredicateDateFromRange(builder,from,codePredicates,range);
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + params.getClass());
    }
  }
  Predicate masterCodePredicate=builder.or(codePredicates.toArray(new Predicate[0]));
  Predicate type=builder.equal(from.get(""String_Node_Str""),myResourceName);
  Predicate name=builder.equal(from.get(""String_Node_Str""),theParamName);
  if (thePids.size() > 0) {
    Predicate inPids=(from.get(""String_Node_Str"").in(thePids));
    cq.where(builder.and(type,name,masterCodePredicate,inPids));
  }
 else {
    cq.where(builder.and(type,name,masterCodePredicate));
  }
  TypedQuery<Long> q=myEntityManager.createQuery(cq);
  return new HashSet<Long>(q.getResultList());
}",0.9363525091799264
112334,"private Set<Long> addPredicateQuantity(Set<Long> thePids,List<IQueryParameterType> theOrParams){
  if (theOrParams == null || theOrParams.isEmpty()) {
    return thePids;
  }
  CriteriaBuilder builder=myEntityManager.getCriteriaBuilder();
  CriteriaQuery<Long> cq=builder.createQuery(Long.class);
  Root<ResourceIndexedSearchParamNumber> from=cq.from(ResourceIndexedSearchParamNumber.class);
  cq.select(from.get(""String_Node_Str"").as(Long.class));
  List<Predicate> codePredicates=new ArrayList<Predicate>();
  for (  IQueryParameterType nextOr : theOrParams) {
    IQueryParameterType params=nextOr;
    if (params instanceof QuantityDt) {
      QuantityDt id=(QuantityDt)params;
      Predicate system;
      if (id.getSystem().isEmpty()) {
        system=builder.isNull(from.get(""String_Node_Str""));
      }
 else {
        system=builder.equal(from.get(""String_Node_Str""),id.getSystem().getValueAsString());
      }
      Predicate code;
      if (id.getCode().isEmpty()) {
        code=builder.isNull(from.get(""String_Node_Str""));
      }
 else {
        code=builder.equal(from.get(""String_Node_Str""),id.getUnits().getValueAsString());
      }
      Predicate num;
      if (id.getComparator().getValueAsEnum() == null) {
        num=builder.equal(from.get(""String_Node_Str""),id.getValue().getValue());
      }
 else {
switch (id.getComparator().getValueAsEnum()) {
case GREATERTHAN:
          Expression<Number> path=from.get(""String_Node_Str"");
        Number value=id.getValue().getValue();
      num=builder.gt(path,value);
    break;
case GREATERTHAN_OR_EQUALS:
  path=from.get(""String_Node_Str"");
value=id.getValue().getValue();
num=builder.ge(path,value);
break;
case LESSTHAN:
path=from.get(""String_Node_Str"");
value=id.getValue().getValue();
num=builder.lt(path,value);
break;
case LESSTHAN_OR_EQUALS:
path=from.get(""String_Node_Str"");
value=id.getValue().getValue();
num=builder.le(path,value);
break;
default :
throw new IllegalStateException(id.getComparator().getValueAsString());
}
}
Predicate singleCode=builder.and(system,code,num);
codePredicates.add(singleCode);
}
 else {
throw new IllegalArgumentException(""String_Node_Str"" + params.getClass());
}
}
Predicate masterCodePredicate=builder.or(codePredicates.toArray(new Predicate[0]));
Predicate type=builder.equal(from.get(""String_Node_Str""),myResourceName);
if (thePids.size() > 0) {
Predicate inPids=(from.get(""String_Node_Str"").in(thePids));
cq.where(builder.and(type,inPids,masterCodePredicate));
}
 else {
cq.where(builder.and(type,masterCodePredicate));
}
TypedQuery<Long> q=myEntityManager.createQuery(cq);
return new HashSet<Long>(q.getResultList());
}","private Set<Long> addPredicateQuantity(String theParamName,Set<Long> thePids,List<IQueryParameterType> theOrParams){
  if (theOrParams == null || theOrParams.isEmpty()) {
    return thePids;
  }
  CriteriaBuilder builder=myEntityManager.getCriteriaBuilder();
  CriteriaQuery<Long> cq=builder.createQuery(Long.class);
  Root<ResourceIndexedSearchParamNumber> from=cq.from(ResourceIndexedSearchParamNumber.class);
  cq.select(from.get(""String_Node_Str"").as(Long.class));
  List<Predicate> codePredicates=new ArrayList<Predicate>();
  for (  IQueryParameterType nextOr : theOrParams) {
    IQueryParameterType params=nextOr;
    if (params instanceof QuantityDt) {
      QuantityDt id=(QuantityDt)params;
      Predicate system;
      if (id.getSystem().isEmpty()) {
        system=builder.isNull(from.get(""String_Node_Str""));
      }
 else {
        system=builder.equal(from.get(""String_Node_Str""),id.getSystem().getValueAsString());
      }
      Predicate code;
      if (id.getCode().isEmpty()) {
        code=builder.isNull(from.get(""String_Node_Str""));
      }
 else {
        code=builder.equal(from.get(""String_Node_Str""),id.getUnits().getValueAsString());
      }
      Predicate num;
      if (id.getComparator().getValueAsEnum() == null) {
        num=builder.equal(from.get(""String_Node_Str""),id.getValue().getValue());
      }
 else {
switch (id.getComparator().getValueAsEnum()) {
case GREATERTHAN:
          Expression<Number> path=from.get(""String_Node_Str"");
        Number value=id.getValue().getValue();
      num=builder.gt(path,value);
    break;
case GREATERTHAN_OR_EQUALS:
  path=from.get(""String_Node_Str"");
value=id.getValue().getValue();
num=builder.ge(path,value);
break;
case LESSTHAN:
path=from.get(""String_Node_Str"");
value=id.getValue().getValue();
num=builder.lt(path,value);
break;
case LESSTHAN_OR_EQUALS:
path=from.get(""String_Node_Str"");
value=id.getValue().getValue();
num=builder.le(path,value);
break;
default :
throw new IllegalStateException(id.getComparator().getValueAsString());
}
}
Predicate singleCode=builder.and(system,code,num);
codePredicates.add(singleCode);
}
 else {
throw new IllegalArgumentException(""String_Node_Str"" + params.getClass());
}
}
Predicate masterCodePredicate=builder.or(codePredicates.toArray(new Predicate[0]));
Predicate type=builder.equal(from.get(""String_Node_Str""),myResourceName);
Predicate name=builder.equal(from.get(""String_Node_Str""),theParamName);
if (thePids.size() > 0) {
Predicate inPids=(from.get(""String_Node_Str"").in(thePids));
cq.where(builder.and(type,name,masterCodePredicate,inPids));
}
 else {
cq.where(builder.and(type,name,masterCodePredicate));
}
TypedQuery<Long> q=myEntityManager.createQuery(cq);
return new HashSet<Long>(q.getResultList());
}",0.9787867510234464
112335,"public ResourceIndexedSearchParamDate(String theName,Date theLow,Date theHigh){
  setName(theName);
  setValueLow(theLow);
  setValueHigh(theHigh);
}","public ResourceIndexedSearchParamDate(String theName,Date theLow,Date theHigh){
  setParamName(theName);
  setValueLow(theLow);
  setValueHigh(theHigh);
}",0.9834983498349836
112336,"public ResourceIndexedSearchParamNumber(String theParamName,BigDecimal theValue,String theSystem,String theUnits){
  setName(theParamName);
  setSystem(theSystem);
  setValue(theValue);
  setUnits(theUnits);
}","public ResourceIndexedSearchParamNumber(String theParamName,BigDecimal theValue,String theSystem,String theUnits){
  setParamName(theParamName);
  setSystem(theSystem);
  setValue(theValue);
  setUnits(theUnits);
}",0.9881796690307328
112337,"public ResourceIndexedSearchParamString(String theName,String theValueNormalized,String theValueExact){
  setName(theName);
  setValueNormalized(theValueNormalized);
  setValueExact(theValueExact);
}","public ResourceIndexedSearchParamString(String theName,String theValueNormalized,String theValueExact){
  setParamName(theName);
  setValueNormalized(theValueNormalized);
  setValueExact(theValueExact);
}",0.9875930521091812
112338,"public ResourceIndexedSearchParamToken(String theName,String theSystem,String theValue){
  setName(theName);
  setSystem(theSystem);
  setValue(theValue);
}","public ResourceIndexedSearchParamToken(String theName,String theSystem,String theValue){
  setParamName(theName);
  setSystem(theSystem);
  setValue(theValue);
}",0.9842271293375394
112339,"@Test public void testSearchStringParamWithNonNormalized(){
{
    Patient patient=new Patient();
    patient.addIdentifier(""String_Node_Str"",""String_Node_Str"");
    patient.addName().addGiven(""String_Node_Str"");
    ourPatientDao.create(patient);
  }
{
    Patient patient=new Patient();
    patient.addIdentifier(""String_Node_Str"",""String_Node_Str"");
    patient.addName().addGiven(""String_Node_Str"");
    ourPatientDao.create(patient);
  }
  Map<String,IQueryParameterType> params=new HashMap<String,IQueryParameterType>();
  params.put(Patient.SP_FAMILY,new StringDt(""String_Node_Str""));
  List<Patient> patients=ourPatientDao.search(params);
  assertEquals(2,patients.size());
  StringParam parameter=new StringParam(""String_Node_Str"");
  parameter.setExact(true);
  params.put(Patient.SP_FAMILY,parameter);
  patients=ourPatientDao.search(params);
  assertEquals(0,patients.size());
}","@Test public void testSearchStringParamWithNonNormalized(){
{
    Patient patient=new Patient();
    patient.addIdentifier(""String_Node_Str"",""String_Node_Str"");
    patient.addName().addGiven(""String_Node_Str"");
    ourPatientDao.create(patient);
  }
{
    Patient patient=new Patient();
    patient.addIdentifier(""String_Node_Str"",""String_Node_Str"");
    patient.addName().addGiven(""String_Node_Str"");
    ourPatientDao.create(patient);
  }
  Map<String,IQueryParameterType> params=new HashMap<String,IQueryParameterType>();
  params.put(Patient.SP_GIVEN,new StringDt(""String_Node_Str""));
  List<Patient> patients=ourPatientDao.search(params);
  assertEquals(2,patients.size());
  StringParam parameter=new StringParam(""String_Node_Str"");
  parameter.setExact(true);
  params.put(Patient.SP_GIVEN,parameter);
  patients=ourPatientDao.search(params);
  assertEquals(0,patients.size());
}",0.9898648648648648
112340,"@Test public void testPersistSearchParamDate(){
  Patient patient=new Patient();
  patient.addIdentifier(""String_Node_Str"",""String_Node_Str"");
  patient.setBirthDate(new DateTimeDt(""String_Node_Str""));
  ourPatientDao.create(patient);
  List<Patient> found=ourPatientDao.search(""String_Node_Str"",new QualifiedDateParam(QuantityCompararatorEnum.GREATERTHAN,""String_Node_Str""));
  assertEquals(1,found.size());
}","@Test public void testPersistSearchParamDate(){
  Patient patient=new Patient();
  patient.addIdentifier(""String_Node_Str"",""String_Node_Str"");
  patient.setBirthDate(new DateTimeDt(""String_Node_Str""));
  ourPatientDao.create(patient);
  List<Patient> found=ourPatientDao.search(Patient.SP_BIRTHDATE,new QualifiedDateParam(QuantityCompararatorEnum.GREATERTHAN,""String_Node_Str""));
  assertEquals(1,found.size());
  found=ourPatientDao.search(Patient.SP_BIRTHDATE + ""String_Node_Str"",new QualifiedDateParam(QuantityCompararatorEnum.GREATERTHAN,""String_Node_Str""));
  assertEquals(0,found.size());
}",0.7813121272365805
112341,"@Test public void testPersistSearchParams(){
  Patient patient=new Patient();
  patient.addIdentifier(""String_Node_Str"",""String_Node_Str"");
  patient.getGender().setValueAsEnum(AdministrativeGenderCodesEnum.M);
  patient.addName().addFamily(""String_Node_Str"").addGiven(""String_Node_Str"");
  MethodOutcome outcome=ourPatientDao.create(patient);
  assertNotNull(outcome.getId());
  assertFalse(outcome.getId().isEmpty());
  long id=outcome.getId().asLong();
  IdentifierDt value=new IdentifierDt(""String_Node_Str"",""String_Node_Str"");
  List<Patient> found=ourPatientDao.search(Patient.SP_IDENTIFIER,value);
  assertEquals(1,found.size());
  assertEquals(id,found.get(0).getId().asLong().longValue());
  SearchParameterMap map=new SearchParameterMap();
  map.put(Patient.SP_IDENTIFIER,new ArrayList<List<IQueryParameterType>>());
  map.get(Patient.SP_IDENTIFIER).add(new ArrayList<IQueryParameterType>());
  map.get(Patient.SP_IDENTIFIER).get(0).add(new IdentifierDt(""String_Node_Str"",""String_Node_Str""));
  map.put(Patient.SP_GENDER,new ArrayList<List<IQueryParameterType>>());
  map.get(Patient.SP_GENDER).add(new ArrayList<IQueryParameterType>());
  map.get(Patient.SP_GENDER).get(0).add(new IdentifierDt(null,""String_Node_Str""));
  found=ourPatientDao.search(map);
  assertEquals(1,found.size());
  assertEquals(id,found.get(0).getId().asLong().longValue());
  map=new SearchParameterMap();
  map.put(Patient.SP_IDENTIFIER,new ArrayList<List<IQueryParameterType>>());
  map.get(Patient.SP_IDENTIFIER).add(new ArrayList<IQueryParameterType>());
  map.get(Patient.SP_IDENTIFIER).get(0).add(new IdentifierDt(""String_Node_Str"",""String_Node_Str""));
  map.put(Patient.SP_GENDER,new ArrayList<List<IQueryParameterType>>());
  map.get(Patient.SP_GENDER).add(new ArrayList<IQueryParameterType>());
  map.get(Patient.SP_GENDER).get(0).add(new IdentifierDt(null,""String_Node_Str""));
  found=ourPatientDao.search(map);
  assertEquals(0,found.size());
}","@Test public void testPersistSearchParams(){
  Patient patient=new Patient();
  patient.addIdentifier(""String_Node_Str"",""String_Node_Str"");
  patient.getGender().setValueAsEnum(AdministrativeGenderCodesEnum.M);
  patient.addName().addFamily(""String_Node_Str"").addGiven(""String_Node_Str"");
  MethodOutcome outcome=ourPatientDao.create(patient);
  assertNotNull(outcome.getId());
  assertFalse(outcome.getId().isEmpty());
  long id=outcome.getId().asLong();
  IdentifierDt value=new IdentifierDt(""String_Node_Str"",""String_Node_Str"");
  List<Patient> found=ourPatientDao.search(Patient.SP_IDENTIFIER,value);
  assertEquals(1,found.size());
  assertEquals(id,found.get(0).getId().asLong().longValue());
  SearchParameterMap map=new SearchParameterMap();
  map.put(Patient.SP_IDENTIFIER,new ArrayList<List<IQueryParameterType>>());
  map.get(Patient.SP_IDENTIFIER).add(new ArrayList<IQueryParameterType>());
  map.get(Patient.SP_IDENTIFIER).get(0).add(new IdentifierDt(""String_Node_Str"",""String_Node_Str""));
  map.put(Patient.SP_GENDER,new ArrayList<List<IQueryParameterType>>());
  map.get(Patient.SP_GENDER).add(new ArrayList<IQueryParameterType>());
  map.get(Patient.SP_GENDER).get(0).add(new IdentifierDt(AdministrativeGenderCodesEnum.M.getSystem(),""String_Node_Str""));
  found=ourPatientDao.search(map);
  assertEquals(1,found.size());
  assertEquals(id,found.get(0).getId().asLong().longValue());
  map=new SearchParameterMap();
  map.put(Patient.SP_IDENTIFIER,new ArrayList<List<IQueryParameterType>>());
  map.get(Patient.SP_IDENTIFIER).add(new ArrayList<IQueryParameterType>());
  map.get(Patient.SP_IDENTIFIER).get(0).add(new IdentifierDt(""String_Node_Str"",""String_Node_Str""));
  map.put(Patient.SP_GENDER,new ArrayList<List<IQueryParameterType>>());
  map.get(Patient.SP_GENDER).add(new ArrayList<IQueryParameterType>());
  map.get(Patient.SP_GENDER).get(0).add(new IdentifierDt(AdministrativeGenderCodesEnum.M.getSystem(),""String_Node_Str""));
  found=ourPatientDao.search(map);
  assertEquals(0,found.size());
}",0.9762626262626264
112342,"@Test public void testSearchNameParam(){
  IdDt id1;
{
    Patient patient=new Patient();
    patient.addIdentifier(""String_Node_Str"",""String_Node_Str"");
    patient.addName().addFamily(""String_Node_Str"").addGiven(""String_Node_Str"");
    id1=ourPatientDao.create(patient).getId();
  }
{
    Patient patient=new Patient();
    patient.addIdentifier(""String_Node_Str"",""String_Node_Str"");
    patient.addName().addFamily(""String_Node_Str"").addGiven(""String_Node_Str"");
    ourPatientDao.create(patient);
  }
  Map<String,IQueryParameterType> params=new HashMap<String,IQueryParameterType>();
  params.put(Patient.SP_FAMILY,new StringDt(""String_Node_Str""));
  List<Patient> patients=ourPatientDao.search(params);
  assertEquals(1,patients.size());
  assertEquals(id1.getUnqualifiedId(),patients.get(0).getId().getUnqualifiedId());
  params=new HashMap<String,IQueryParameterType>();
  params.put(Patient.SP_FAMILY,new StringDt(""String_Node_Str""));
  patients=ourPatientDao.search(params);
  assertEquals(1,patients.size());
  assertEquals(id1.getUnqualifiedId(),patients.get(0).getId().getUnqualifiedId());
  params=new HashMap<String,IQueryParameterType>();
  params.put(Patient.SP_FAMILY,new StringDt(""String_Node_Str""));
  patients=ourPatientDao.search(params);
  assertEquals(0,patients.size());
}","@Test public void testSearchNameParam(){
  IdDt id1;
{
    Patient patient=new Patient();
    patient.addIdentifier(""String_Node_Str"",""String_Node_Str"");
    patient.addName().addFamily(""String_Node_Str"").addGiven(""String_Node_Str"");
    id1=ourPatientDao.create(patient).getId();
  }
{
    Patient patient=new Patient();
    patient.addIdentifier(""String_Node_Str"",""String_Node_Str"");
    patient.addName().addFamily(""String_Node_Str"").addGiven(""String_Node_Str"");
    ourPatientDao.create(patient);
  }
  Map<String,IQueryParameterType> params=new HashMap<String,IQueryParameterType>();
  params.put(Patient.SP_FAMILY,new StringDt(""String_Node_Str""));
  List<Patient> patients=ourPatientDao.search(params);
  assertEquals(1,patients.size());
  assertEquals(id1.getUnqualifiedId(),patients.get(0).getId().getUnqualifiedId());
  params=new HashMap<String,IQueryParameterType>();
  params.put(Patient.SP_FAMILY,new StringDt(""String_Node_Str""));
  patients=ourPatientDao.search(params);
  assertEquals(0,patients.size());
  params=new HashMap<String,IQueryParameterType>();
  params.put(Patient.SP_NAME,new StringDt(""String_Node_Str""));
  patients=ourPatientDao.search(params);
  assertEquals(1,patients.size());
  assertEquals(id1.getUnqualifiedId(),patients.get(0).getId().getUnqualifiedId());
  params=new HashMap<String,IQueryParameterType>();
  params.put(Patient.SP_NAME,new StringDt(""String_Node_Str""));
  patients=ourPatientDao.search(params);
  assertEquals(1,patients.size());
  assertEquals(id1.getUnqualifiedId(),patients.get(0).getId().getUnqualifiedId());
  params=new HashMap<String,IQueryParameterType>();
  params.put(Patient.SP_FAMILY,new StringDt(""String_Node_Str""));
  patients=ourPatientDao.search(params);
  assertEquals(0,patients.size());
}",0.8479895390650539
112343,"private void writeUndeclaredExt(RuntimeResourceDefinition theResDef,IResource theResource,JsonGenerator theEventWriter,ExtensionDt ext) throws IOException {
  theEventWriter.writeStartObject();
  theEventWriter.write(""String_Node_Str"",ext.getUrl().getValue());
  IElement value=ext.getValue();
  if (value == null && ext.getAllUndeclaredExtensions().isEmpty()) {
    theEventWriter.writeNull();
  }
 else   if (value == null) {
    theEventWriter.writeStartArray(""String_Node_Str"");
    for (    ExtensionDt next : ext.getUndeclaredExtensions()) {
      writeUndeclaredExt(theResDef,theResource,theEventWriter,next);
    }
    theEventWriter.writeEnd();
  }
 else {
    RuntimeChildUndeclaredExtensionDefinition extDef=myContext.getRuntimeChildUndeclaredExtensionDefinition();
    String childName=extDef.getChildNameByDatatype(value.getClass());
    if (childName == null) {
      throw new ConfigurationException(""String_Node_Str"" + value.getClass().getCanonicalName());
    }
    BaseRuntimeElementDefinition<?> childDef=extDef.getChildElementDefinitionByDatatype(value.getClass());
    encodeChildElementToStreamWriter(theResDef,theResource,theEventWriter,value,childDef,childName);
  }
  theEventWriter.writeEnd();
}","private void writeUndeclaredExt(RuntimeResourceDefinition theResDef,IResource theResource,JsonGenerator theEventWriter,ExtensionDt ext) throws IOException {
  IElement value=ext.getValue();
  theEventWriter.writeStartObject();
  theEventWriter.write(""String_Node_Str"",ext.getUrl().getValue());
  if (value == null && ext.getAllUndeclaredExtensions().isEmpty()) {
    ourLog.debug(""String_Node_Str"",ext.getUrl().getValue());
  }
 else   if (value == null) {
    theEventWriter.writeStartArray(""String_Node_Str"");
    for (    ExtensionDt next : ext.getUndeclaredExtensions()) {
      writeUndeclaredExt(theResDef,theResource,theEventWriter,next);
    }
    theEventWriter.writeEnd();
  }
 else {
    RuntimeChildUndeclaredExtensionDefinition extDef=myContext.getRuntimeChildUndeclaredExtensionDefinition();
    String childName=extDef.getChildNameByDatatype(value.getClass());
    if (childName == null) {
      throw new ConfigurationException(""String_Node_Str"" + value.getClass().getCanonicalName());
    }
    BaseRuntimeElementDefinition<?> childDef=extDef.getChildElementDefinitionByDatatype(value.getClass());
    encodeChildElementToStreamWriter(theResDef,theResource,theEventWriter,value,childDef,childName);
  }
  theEventWriter.writeEnd();
}",0.942128692836908
112344,"Object invokeClient(IClientResponseHandler binding,BaseClientInvocation clientInvocation,boolean theLogRequestAndResponse){
  HttpRequestBase httpRequest;
  HttpResponse response;
  try {
    httpRequest=clientInvocation.asHttpRequest(myUrlBase,createExtraParams(),getEncoding());
    if (theLogRequestAndResponse) {
      ourLog.info(""String_Node_Str"",httpRequest);
    }
    response=myClient.execute(httpRequest);
  }
 catch (  DataFormatException e) {
    throw new FhirClientConnectionException(e);
  }
catch (  IOException e) {
    throw new FhirClientConnectionException(e);
  }
  try {
    Reader reader=createReaderFromResponse(response);
    if (ourLog.isTraceEnabled() || myKeepResponses) {
      String responseString=IOUtils.toString(reader);
      if (myKeepResponses) {
        myLastResponse=response;
        myLastResponseBody=responseString;
      }
      ourLog.trace(""String_Node_Str"",response,responseString);
      reader=new StringReader(responseString);
    }
    ContentType ct=ContentType.get(response.getEntity());
    String mimeType=ct != null ? ct.getMimeType() : null;
    Map<String,List<String>> headers=new HashMap<String,List<String>>();
    if (response.getAllHeaders() != null) {
      for (      Header next : response.getAllHeaders()) {
        String name=next.getName().toLowerCase();
        List<String> list=headers.get(name);
        if (list == null) {
          list=new ArrayList<String>();
          headers.put(name,list);
        }
        list.add(next.getValue());
      }
    }
    if (response.getStatusLine().getStatusCode() < 200 || response.getStatusLine().getStatusCode() > 299) {
      throw BaseServerResponseException.newInstance(response.getStatusLine().getStatusCode(),response.getStatusLine().getReasonPhrase());
    }
    try {
      return binding.invokeClient(mimeType,reader,response.getStatusLine().getStatusCode(),headers);
    }
  finally {
      reader.close();
    }
  }
 catch (  IllegalStateException e) {
    throw new FhirClientConnectionException(e);
  }
catch (  IOException e) {
    throw new FhirClientConnectionException(e);
  }
 finally {
    if (response instanceof CloseableHttpResponse) {
      try {
        ((CloseableHttpResponse)response).close();
      }
 catch (      IOException e) {
        ourLog.debug(""String_Node_Str"",e);
      }
    }
  }
}","<T>T invokeClient(IClientResponseHandler<T> binding,BaseClientInvocation clientInvocation,boolean theLogRequestAndResponse){
  HttpRequestBase httpRequest;
  HttpResponse response;
  try {
    httpRequest=clientInvocation.asHttpRequest(myUrlBase,createExtraParams(),getEncoding());
    if (theLogRequestAndResponse) {
      ourLog.info(""String_Node_Str"",httpRequest);
    }
    response=myClient.execute(httpRequest);
  }
 catch (  DataFormatException e) {
    throw new FhirClientConnectionException(e);
  }
catch (  IOException e) {
    throw new FhirClientConnectionException(e);
  }
  try {
    Reader reader=createReaderFromResponse(response);
    if (ourLog.isTraceEnabled() || myKeepResponses) {
      String responseString=IOUtils.toString(reader);
      if (myKeepResponses) {
        myLastResponse=response;
        myLastResponseBody=responseString;
      }
      ourLog.trace(""String_Node_Str"",response,responseString);
      reader=new StringReader(responseString);
    }
    ContentType ct=ContentType.get(response.getEntity());
    String mimeType=ct != null ? ct.getMimeType() : null;
    Map<String,List<String>> headers=new HashMap<String,List<String>>();
    if (response.getAllHeaders() != null) {
      for (      Header next : response.getAllHeaders()) {
        String name=next.getName().toLowerCase();
        List<String> list=headers.get(name);
        if (list == null) {
          list=new ArrayList<String>();
          headers.put(name,list);
        }
        list.add(next.getValue());
      }
    }
    if (response.getStatusLine().getStatusCode() < 200 || response.getStatusLine().getStatusCode() > 299) {
      BaseServerResponseException exception=BaseServerResponseException.newInstance(response.getStatusLine().getStatusCode(),response.getStatusLine().getReasonPhrase());
      try {
        String body=IOUtils.toString(reader);
        exception.setResponseBody(body);
      }
 catch (      Exception e) {
        ourLog.debug(""String_Node_Str"",e);
      }
 finally {
        IOUtils.closeQuietly(reader);
      }
      throw exception;
    }
    try {
      return binding.invokeClient(mimeType,reader,response.getStatusLine().getStatusCode(),headers);
    }
  finally {
      IOUtils.closeQuietly(reader);
    }
  }
 catch (  IllegalStateException e) {
    throw new FhirClientConnectionException(e);
  }
catch (  IOException e) {
    throw new FhirClientConnectionException(e);
  }
 finally {
    if (response instanceof CloseableHttpResponse) {
      try {
        ((CloseableHttpResponse)response).close();
      }
 catch (      IOException e) {
        ourLog.debug(""String_Node_Str"",e);
      }
    }
  }
}",0.9271417133706964
112345,"@Override public Object invoke(Object theProxy,Method theMethod,Object[] theArgs) throws Throwable {
  Object directRetVal=myMethodToReturnValue.get(theMethod);
  if (directRetVal != null) {
    return directRetVal;
  }
  BaseMethodBinding binding=myBindings.get(theMethod);
  if (binding != null) {
    BaseClientInvocation clientInvocation=binding.invokeClient(theArgs);
    return invokeClient(binding,clientInvocation);
  }
  ILambda lambda=myMethodToLambda.get(theMethod);
  if (lambda != null) {
    return lambda.handle(theArgs);
  }
  throw new UnsupportedOperationException(""String_Node_Str"" + theMethod.getName() + ""String_Node_Str""+ theMethod.getDeclaringClass().getSimpleName()+ ""String_Node_Str"");
}","@Override public Object invoke(Object theProxy,Method theMethod,Object[] theArgs) throws Throwable {
  Object directRetVal=myMethodToReturnValue.get(theMethod);
  if (directRetVal != null) {
    return directRetVal;
  }
  BaseMethodBinding<?> binding=myBindings.get(theMethod);
  if (binding != null) {
    BaseClientInvocation clientInvocation=binding.invokeClient(theArgs);
    return invokeClient(binding,clientInvocation);
  }
  ILambda lambda=myMethodToLambda.get(theMethod);
  if (lambda != null) {
    return lambda.handle(theArgs);
  }
  throw new UnsupportedOperationException(""String_Node_Str"" + theMethod.getName() + ""String_Node_Str""+ theMethod.getDeclaringClass().getSimpleName()+ ""String_Node_Str"");
}",0.9978976874562018
112346,"public void addBinding(Method theMethod,BaseMethodBinding theBinding){
  myBindings.put(theMethod,theBinding);
}","public void addBinding(Method theMethod,BaseMethodBinding<?> theBinding){
  myBindings.put(theMethod,theBinding);
}",0.986784140969163
112347,"@Override protected void doPost(HttpServletRequest theReq,HttpServletResponse theResp) throws ServletException, IOException {
  if (DEBUGMODE) {
    myTemplateEngine.getCacheManager().clearAllCaches();
  }
  try {
    GenericClient client=(GenericClient)myCtx.newRestfulGenericClient(myServerBase);
    client.setKeepResponses(true);
    String method=theReq.getParameter(""String_Node_Str"");
    String prettyParam=theReq.getParameter(""String_Node_Str"");
    if (""String_Node_Str"".equals(prettyParam)) {
      client.setPrettyPrint(true);
    }
    if (""String_Node_Str"".equals(theReq.getParameter(""String_Node_Str""))) {
      client.setEncoding(EncodingEnum.XML);
    }
 else     if (""String_Node_Str"".equals(theReq.getParameter(""String_Node_Str""))) {
      client.setEncoding(EncodingEnum.JSON);
    }
    String requestUrl;
    String action;
    String resultStatus;
    String resultBody;
    String resultSyntaxHighlighterClass;
    boolean returnsResource;
    try {
      if (""String_Node_Str"".equals(method)) {
        returnsResource=true;
        client.conformance();
      }
 else       if (""String_Node_Str"".equals(method)) {
        RuntimeResourceDefinition def=getResourceType(theReq);
        String id=StringUtils.defaultString(theReq.getParameter(""String_Node_Str""));
        if (StringUtils.isBlank(id)) {
          theResp.sendError(Constants.STATUS_HTTP_400_BAD_REQUEST,""String_Node_Str"");
        }
        returnsResource=true;
        client.read(def.getImplementingClass(),new IdDt(id));
      }
 else       if (""String_Node_Str"".equals(method)) {
        RuntimeResourceDefinition def=getResourceType(theReq);
        String id=StringUtils.defaultString(theReq.getParameter(""String_Node_Str""));
        if (StringUtils.isBlank(id)) {
          theResp.sendError(Constants.STATUS_HTTP_400_BAD_REQUEST,""String_Node_Str"");
        }
        String versionId=StringUtils.defaultString(theReq.getParameter(""String_Node_Str""));
        if (StringUtils.isBlank(versionId)) {
          theResp.sendError(Constants.STATUS_HTTP_400_BAD_REQUEST,""String_Node_Str"");
        }
        returnsResource=true;
        client.vread(def.getImplementingClass(),new IdDt(id),new IdDt(versionId));
      }
 else       if (""String_Node_Str"".equals(method)) {
        RuntimeResourceDefinition def=getResourceType(theReq);
        String id=StringUtils.defaultString(theReq.getParameter(""String_Node_Str""));
        if (StringUtils.isBlank(id)) {
          theResp.sendError(Constants.STATUS_HTTP_400_BAD_REQUEST,""String_Node_Str"");
        }
        returnsResource=false;
        client.delete(def.getImplementingClass(),new IdDt(id));
      }
 else       if (""String_Node_Str"".equals(method)) {
        RuntimeResourceDefinition def=getResourceType(theReq);
        String id=StringUtils.defaultString(theReq.getParameter(""String_Node_Str""));
        if (StringUtils.isBlank(id)) {
          theResp.sendError(Constants.STATUS_HTTP_400_BAD_REQUEST,""String_Node_Str"");
        }
        returnsResource=false;
        client.history(def.getImplementingClass(),new IdDt(id));
      }
 else       if (""String_Node_Str"".equals(method)) {
        RuntimeResourceDefinition def=getResourceType(theReq);
        String resourceText=StringUtils.defaultString(theReq.getParameter(""String_Node_Str""));
        if (StringUtils.isBlank(resourceText)) {
          theResp.sendError(Constants.STATUS_HTTP_400_BAD_REQUEST,""String_Node_Str"");
        }
        IResource resource;
        if (client.getEncoding() == null || client.getEncoding() == EncodingEnum.XML) {
          resource=myCtx.newXmlParser().parseResource(def.getImplementingClass(),resourceText);
        }
 else {
          resource=myCtx.newJsonParser().parseResource(def.getImplementingClass(),resourceText);
        }
        returnsResource=false;
        client.create(resource);
      }
 else       if (""String_Node_Str"".equals(method)) {
        RuntimeResourceDefinition def=getResourceType(theReq);
        String resourceText=StringUtils.defaultString(theReq.getParameter(""String_Node_Str""));
        if (StringUtils.isBlank(resourceText)) {
          theResp.sendError(Constants.STATUS_HTTP_400_BAD_REQUEST,""String_Node_Str"");
        }
        IResource resource;
        if (client.getEncoding() == null || client.getEncoding() == EncodingEnum.XML) {
          resource=myCtx.newXmlParser().parseResource(def.getImplementingClass(),resourceText);
        }
 else {
          resource=myCtx.newJsonParser().parseResource(def.getImplementingClass(),resourceText);
        }
        returnsResource=false;
        client.validate(resource);
      }
 else       if (""String_Node_Str"".equals(method)) {
        RuntimeResourceDefinition def=getResourceType(theReq);
        String resourceText=StringUtils.defaultString(theReq.getParameter(""String_Node_Str""));
        if (StringUtils.isBlank(resourceText)) {
          theResp.sendError(Constants.STATUS_HTTP_400_BAD_REQUEST,""String_Node_Str"");
        }
        String id=StringUtils.defaultString(theReq.getParameter(""String_Node_Str""));
        if (StringUtils.isBlank(id)) {
          theResp.sendError(Constants.STATUS_HTTP_400_BAD_REQUEST,""String_Node_Str"");
        }
        IResource resource;
        if (client.getEncoding() == null || client.getEncoding() == EncodingEnum.XML) {
          resource=myCtx.newXmlParser().parseResource(def.getImplementingClass(),resourceText);
        }
 else {
          resource=myCtx.newJsonParser().parseResource(def.getImplementingClass(),resourceText);
        }
        returnsResource=false;
        client.update(new IdDt(id),resource);
      }
 else       if (""String_Node_Str"".equals(method)) {
        Map<String,List<IQueryParameterType>> params=new HashMap<String,List<IQueryParameterType>>();
        HashSet<String> hashSet=new HashSet<String>(theReq.getParameterMap().keySet());
        String paramName=null;
        IQueryParameterType paramValue=null;
        while (hashSet.isEmpty() == false) {
          String nextKey=hashSet.iterator().next();
          String nextValue=theReq.getParameter(nextKey);
          paramName=null;
          paramValue=null;
          if (nextKey.startsWith(""String_Node_Str"")) {
            int prefixLength=""String_Node_Str"".length();
            paramName=nextKey.substring(prefixLength + 2);
            String systemKey=""String_Node_Str"" + ""String_Node_Str"" + paramName;
            String valueKey=""String_Node_Str"" + ""String_Node_Str"" + paramName;
            String system=theReq.getParameter(systemKey);
            String value=theReq.getParameter(valueKey);
            paramValue=new IdentifierDt(system,value);
            hashSet.remove(systemKey);
            hashSet.remove(valueKey);
          }
 else           if (nextKey.startsWith(""String_Node_Str"")) {
            paramName=nextKey.substring(""String_Node_Str"".length());
            paramValue=new StringDt(nextValue);
          }
          if (paramName != null) {
            if (params.containsKey(paramName) == false) {
              params.put(paramName,new ArrayList<IQueryParameterType>());
            }
            params.get(paramName).add(paramValue);
          }
          hashSet.remove(nextKey);
        }
        RuntimeResourceDefinition def=getResourceType(theReq);
        returnsResource=false;
        client.search(def.getImplementingClass(),params);
      }
 else {
        theResp.sendError(Constants.STATUS_HTTP_400_BAD_REQUEST,""String_Node_Str"" + method);
        return;
      }
    }
 catch (    BaseServerResponseException e) {
      ourLog.error(""String_Node_Str"",e);
      returnsResource=false;
    }
    HttpRequestBase lastRequest=client.getLastRequest();
    String requestBody=null;
    String requestSyntaxHighlighterClass=null;
    if (lastRequest instanceof HttpEntityEnclosingRequest) {
      HttpEntityEnclosingRequest lastEERequest=(HttpEntityEnclosingRequest)lastRequest;
      HttpEntity lastEE=lastEERequest.getEntity();
      if (lastEE.isRepeatable()) {
        StringWriter requestCapture=new StringWriter();
        lastEE.writeTo(new WriterOutputStream(requestCapture,""String_Node_Str""));
        requestBody=requestCapture.toString();
        ContentType ct=ContentType.get(lastEE);
        String mimeType=ct.getMimeType();
        EncodingEnum ctEnum=EncodingEnum.forContentType(mimeType);
        if (ctEnum == null) {
          requestSyntaxHighlighterClass=""String_Node_Str"";
        }
 else {
switch (ctEnum) {
case JSON:
            requestSyntaxHighlighterClass=""String_Node_Str"";
          break;
case XML:
default :
        requestSyntaxHighlighterClass=""String_Node_Str"";
      break;
  }
}
}
}
requestUrl=lastRequest.getURI().toASCIIString();
action=client.getLastRequest().getMethod();
resultStatus=client.getLastResponse().getStatusLine().toString();
resultBody=client.getLastResponseBody();
HttpResponse lastResponse=client.getLastResponse();
ContentType ct=ContentType.get(lastResponse.getEntity());
String mimeType=ct != null ? ct.getMimeType() : null;
EncodingEnum ctEnum=EncodingEnum.forContentType(mimeType);
String narrativeString=""String_Node_Str"";
if (ctEnum == null) {
resultSyntaxHighlighterClass=""String_Node_Str"";
}
 else {
switch (ctEnum) {
case JSON:
resultSyntaxHighlighterClass=""String_Node_Str"";
if (returnsResource) {
narrativeString=parseNarrative(ctEnum,resultBody);
}
break;
case XML:
default :
resultSyntaxHighlighterClass=""String_Node_Str"";
if (returnsResource) {
narrativeString=parseNarrative(ctEnum,resultBody);
}
break;
}
}
Header[] requestHeaders=applyHeaderFilters(lastRequest.getAllHeaders());
Header[] responseHeaders=applyHeaderFilters(lastResponse.getAllHeaders());
WebContext ctx=new WebContext(theReq,theResp,theReq.getServletContext(),theReq.getLocale());
ctx.setVariable(""String_Node_Str"",myServerBase);
ctx.setVariable(""String_Node_Str"",requestUrl);
ctx.setVariable(""String_Node_Str"",action);
ctx.setVariable(""String_Node_Str"",resultStatus);
ctx.setVariable(""String_Node_Str"",StringEscapeUtils.escapeHtml4(requestBody));
ctx.setVariable(""String_Node_Str"",requestSyntaxHighlighterClass);
ctx.setVariable(""String_Node_Str"",StringEscapeUtils.escapeHtml4(resultBody));
ctx.setVariable(""String_Node_Str"",resultSyntaxHighlighterClass);
ctx.setVariable(""String_Node_Str"",requestHeaders);
ctx.setVariable(""String_Node_Str"",responseHeaders);
ctx.setVariable(""String_Node_Str"",narrativeString);
myTemplateEngine.process(PUBLIC_TESTER_RESULT_HTML,ctx,theResp.getWriter());
}
 catch (Exception e) {
ourLog.error(""String_Node_Str"",e);
theResp.sendError(500,e.toString());
}
}","@Override protected void doPost(HttpServletRequest theReq,HttpServletResponse theResp) throws ServletException, IOException {
  if (DEBUGMODE) {
    myTemplateEngine.getCacheManager().clearAllCaches();
  }
  GenericClient client=(GenericClient)myCtx.newRestfulGenericClient(myServerBase);
  client.setKeepResponses(true);
  boolean returnsResource;
  try {
    String method=theReq.getParameter(""String_Node_Str"");
    String prettyParam=theReq.getParameter(""String_Node_Str"");
    if (""String_Node_Str"".equals(prettyParam)) {
      client.setPrettyPrint(true);
    }
    if (""String_Node_Str"".equals(theReq.getParameter(""String_Node_Str""))) {
      client.setEncoding(EncodingEnum.XML);
    }
 else     if (""String_Node_Str"".equals(theReq.getParameter(""String_Node_Str""))) {
      client.setEncoding(EncodingEnum.JSON);
    }
    if (""String_Node_Str"".equals(method)) {
      returnsResource=true;
      client.conformance();
    }
 else     if (""String_Node_Str"".equals(method)) {
      RuntimeResourceDefinition def=getResourceType(theReq);
      String id=StringUtils.defaultString(theReq.getParameter(""String_Node_Str""));
      if (StringUtils.isBlank(id)) {
        theResp.sendError(Constants.STATUS_HTTP_400_BAD_REQUEST,""String_Node_Str"");
      }
      returnsResource=true;
      client.read(def.getImplementingClass(),new IdDt(id));
    }
 else     if (""String_Node_Str"".equals(method)) {
      RuntimeResourceDefinition def=getResourceType(theReq);
      String id=StringUtils.defaultString(theReq.getParameter(""String_Node_Str""));
      if (StringUtils.isBlank(id)) {
        theResp.sendError(Constants.STATUS_HTTP_400_BAD_REQUEST,""String_Node_Str"");
      }
      String versionId=StringUtils.defaultString(theReq.getParameter(""String_Node_Str""));
      if (StringUtils.isBlank(versionId)) {
        theResp.sendError(Constants.STATUS_HTTP_400_BAD_REQUEST,""String_Node_Str"");
      }
      returnsResource=true;
      client.vread(def.getImplementingClass(),new IdDt(id),new IdDt(versionId));
    }
 else     if (""String_Node_Str"".equals(method)) {
      RuntimeResourceDefinition def=getResourceType(theReq);
      String id=StringUtils.defaultString(theReq.getParameter(""String_Node_Str""));
      if (StringUtils.isBlank(id)) {
        theResp.sendError(Constants.STATUS_HTTP_400_BAD_REQUEST,""String_Node_Str"");
      }
      returnsResource=false;
      client.delete(def.getImplementingClass(),new IdDt(id));
    }
 else     if (""String_Node_Str"".equals(method)) {
      RuntimeResourceDefinition def=getResourceType(theReq);
      String id=StringUtils.defaultString(theReq.getParameter(""String_Node_Str""));
      if (StringUtils.isBlank(id)) {
        theResp.sendError(Constants.STATUS_HTTP_400_BAD_REQUEST,""String_Node_Str"");
      }
      returnsResource=false;
      client.history(def.getImplementingClass(),new IdDt(id));
    }
 else     if (""String_Node_Str"".equals(method)) {
      IResource resource=parseIncomingResource(theReq,theResp,client);
      returnsResource=false;
      client.create(resource);
    }
 else     if (""String_Node_Str"".equals(method)) {
      IResource resource=parseIncomingResource(theReq,theResp,client);
      returnsResource=false;
      client.validate(resource);
    }
 else     if (""String_Node_Str"".equals(method)) {
      String id=StringUtils.defaultString(theReq.getParameter(""String_Node_Str""));
      if (StringUtils.isBlank(id)) {
        theResp.sendError(Constants.STATUS_HTTP_400_BAD_REQUEST,""String_Node_Str"");
      }
      IResource resource=parseIncomingResource(theReq,theResp,client);
      returnsResource=false;
      client.update(new IdDt(id),resource);
    }
 else     if (""String_Node_Str"".equals(method)) {
      Map<String,List<IQueryParameterType>> params=new HashMap<String,List<IQueryParameterType>>();
      HashSet<String> hashSet=new HashSet<String>(theReq.getParameterMap().keySet());
      String paramName=null;
      IQueryParameterType paramValue=null;
      while (hashSet.isEmpty() == false) {
        String nextKey=hashSet.iterator().next();
        String nextValue=theReq.getParameter(nextKey);
        paramName=null;
        paramValue=null;
        if (nextKey.startsWith(""String_Node_Str"")) {
          int prefixLength=""String_Node_Str"".length();
          paramName=nextKey.substring(prefixLength + 2);
          String systemKey=""String_Node_Str"" + ""String_Node_Str"" + paramName;
          String valueKey=""String_Node_Str"" + ""String_Node_Str"" + paramName;
          String system=theReq.getParameter(systemKey);
          String value=theReq.getParameter(valueKey);
          paramValue=new IdentifierDt(system,value);
          hashSet.remove(systemKey);
          hashSet.remove(valueKey);
        }
 else         if (nextKey.startsWith(""String_Node_Str"")) {
          paramName=nextKey.substring(""String_Node_Str"".length());
          paramValue=new StringDt(nextValue);
        }
        if (paramName != null) {
          if (params.containsKey(paramName) == false) {
            params.put(paramName,new ArrayList<IQueryParameterType>());
          }
          params.get(paramName).add(paramValue);
        }
        hashSet.remove(nextKey);
      }
      RuntimeResourceDefinition def=getResourceType(theReq);
      returnsResource=false;
      client.search(def.getImplementingClass(),params);
    }
 else {
      theResp.sendError(Constants.STATUS_HTTP_400_BAD_REQUEST,""String_Node_Str"" + method);
      return;
    }
  }
 catch (  DataFormatException e) {
    ourLog.error(""String_Node_Str"",e);
    returnsResource=false;
  }
catch (  Exception e) {
    ourLog.error(""String_Node_Str"",e);
    returnsResource=false;
  }
  try {
    HttpRequestBase lastRequest=client.getLastRequest();
    String requestBody=null;
    String requestSyntaxHighlighterClass=null;
    if (lastRequest instanceof HttpEntityEnclosingRequest) {
      HttpEntityEnclosingRequest lastEERequest=(HttpEntityEnclosingRequest)lastRequest;
      HttpEntity lastEE=lastEERequest.getEntity();
      if (lastEE.isRepeatable()) {
        StringWriter requestCapture=new StringWriter();
        lastEE.writeTo(new WriterOutputStream(requestCapture,""String_Node_Str""));
        requestBody=requestCapture.toString();
        ContentType ct=ContentType.get(lastEE);
        String mimeType=ct.getMimeType();
        EncodingEnum ctEnum=EncodingEnum.forContentType(mimeType);
        if (ctEnum == null) {
          requestSyntaxHighlighterClass=""String_Node_Str"";
        }
 else {
switch (ctEnum) {
case JSON:
            requestSyntaxHighlighterClass=""String_Node_Str"";
          break;
case XML:
default :
        requestSyntaxHighlighterClass=""String_Node_Str"";
      break;
  }
}
}
}
String resultSyntaxHighlighterClass;
String requestUrl=lastRequest != null ? lastRequest.getURI().toASCIIString() : null;
String action=client.getLastRequest() != null ? client.getLastRequest().getMethod() : null;
String resultStatus=client.getLastResponse() != null ? client.getLastResponse().getStatusLine().toString() : null;
String resultBody=client.getLastResponseBody();
HttpResponse lastResponse=client.getLastResponse();
ContentType ct=lastResponse != null ? ContentType.get(lastResponse.getEntity()) : null;
String mimeType=ct != null ? ct.getMimeType() : null;
EncodingEnum ctEnum=EncodingEnum.forContentType(mimeType);
String narrativeString=""String_Node_Str"";
if (ctEnum == null) {
resultSyntaxHighlighterClass=""String_Node_Str"";
}
 else {
switch (ctEnum) {
case JSON:
resultSyntaxHighlighterClass=""String_Node_Str"";
if (returnsResource) {
narrativeString=parseNarrative(ctEnum,resultBody);
}
break;
case XML:
default :
resultSyntaxHighlighterClass=""String_Node_Str"";
if (returnsResource) {
narrativeString=parseNarrative(ctEnum,resultBody);
}
break;
}
}
Header[] requestHeaders=lastRequest != null ? applyHeaderFilters(lastRequest.getAllHeaders()) : new Header[0];
Header[] responseHeaders=lastResponse != null ? applyHeaderFilters(lastResponse.getAllHeaders()) : new Header[0];
WebContext ctx=new WebContext(theReq,theResp,theReq.getServletContext(),theReq.getLocale());
ctx.setVariable(""String_Node_Str"",myServerBase);
ctx.setVariable(""String_Node_Str"",requestUrl);
ctx.setVariable(""String_Node_Str"",action);
ctx.setVariable(""String_Node_Str"",resultStatus);
ctx.setVariable(""String_Node_Str"",StringEscapeUtils.escapeHtml4(requestBody));
ctx.setVariable(""String_Node_Str"",requestSyntaxHighlighterClass);
ctx.setVariable(""String_Node_Str"",StringEscapeUtils.escapeHtml4(resultBody));
ctx.setVariable(""String_Node_Str"",resultSyntaxHighlighterClass);
ctx.setVariable(""String_Node_Str"",requestHeaders);
ctx.setVariable(""String_Node_Str"",responseHeaders);
ctx.setVariable(""String_Node_Str"",narrativeString);
myTemplateEngine.process(PUBLIC_TESTER_RESULT_HTML,ctx,theResp.getWriter());
}
 catch (Exception e) {
ourLog.error(""String_Node_Str"",e);
theResp.sendError(500,e.toString());
}
}",0.629492328287509
112348,"public RestfulServerTesterServlet(){
  myStaticResources=new HashMap<String,String>();
  myStaticResources.put(""String_Node_Str"",""String_Node_Str"");
  myStaticResources.put(""String_Node_Str"",""String_Node_Str"");
  myStaticResources.put(""String_Node_Str"",""String_Node_Str"");
  myStaticResources.put(""String_Node_Str"",""String_Node_Str"");
  myStaticResources.put(""String_Node_Str"",""String_Node_Str"");
  myStaticResources.put(""String_Node_Str"",""String_Node_Str"");
  myStaticResources.put(""String_Node_Str"",""String_Node_Str"");
  myStaticResources.put(""String_Node_Str"",""String_Node_Str"");
  myStaticResources.put(""String_Node_Str"",""String_Node_Str"");
  myStaticResources.put(""String_Node_Str"",""String_Node_Str"");
  myStaticResources.put(""String_Node_Str"",""String_Node_Str"");
  myCtx=new FhirContext();
}","public RestfulServerTesterServlet(){
  myStaticResources=new HashMap<String,String>();
  myStaticResources.put(""String_Node_Str"",""String_Node_Str"");
  myStaticResources.put(""String_Node_Str"",""String_Node_Str"");
  myStaticResources.put(""String_Node_Str"",""String_Node_Str"");
  myStaticResources.put(""String_Node_Str"",""String_Node_Str"");
  myStaticResources.put(""String_Node_Str"",""String_Node_Str"");
  myStaticResources.put(""String_Node_Str"",""String_Node_Str"");
  myStaticResources.put(""String_Node_Str"",""String_Node_Str"");
  myStaticResources.put(""String_Node_Str"",""String_Node_Str"");
  myStaticResources.put(""String_Node_Str"",""String_Node_Str"");
  myStaticResources.put(""String_Node_Str"",""String_Node_Str"");
  myStaticResources.put(""String_Node_Str"",""String_Node_Str"");
  myStaticResources.put(""String_Node_Str"",""String_Node_Str"");
  myStaticResources.put(""String_Node_Str"",""String_Node_Str"");
  myCtx=new FhirContext();
}",0.9278230500582072
112349,"@Override protected void doGet(HttpServletRequest theReq,HttpServletResponse theResp) throws ServletException, IOException {
  if (DEBUGMODE) {
    myTemplateEngine.getCacheManager().clearAllCaches();
  }
  try {
    ourLog.info(""String_Node_Str"",theReq.getPathInfo());
    String resName=theReq.getPathInfo().substring(1);
    if (myStaticResources.containsKey(resName)) {
      streamResponse(resName,myStaticResources.get(resName),theResp);
      return;
    }
    ConformanceClient client=myCtx.newRestfulClient(ConformanceClient.class,myServerBase);
    Conformance conformance=client.getConformance();
    WebContext ctx=new WebContext(theReq,theResp,theReq.getServletContext(),theReq.getLocale());
    ctx.setVariable(""String_Node_Str"",conformance);
    ctx.setVariable(""String_Node_Str"",myServerBase);
    ctx.setVariable(""String_Node_Str"",myCtx.newJsonParser().encodeResourceToString(conformance));
    myTemplateEngine.process(theReq.getPathInfo(),ctx,theResp.getWriter());
  }
 catch (  Exception e) {
    ourLog.error(""String_Node_Str"",e);
    theResp.sendError(500,e.getMessage());
  }
}","@Override protected void doGet(HttpServletRequest theReq,HttpServletResponse theResp) throws ServletException, IOException {
  if (DEBUGMODE) {
    myTemplateEngine.getCacheManager().clearAllCaches();
  }
  try {
    ourLog.info(""String_Node_Str"",theReq.getPathInfo());
    String resName=theReq.getPathInfo().substring(1);
    if (myStaticResources.containsKey(resName)) {
      streamResponse(resName,myStaticResources.get(resName),theResp);
      return;
    }
    ConformanceClient client=myCtx.newRestfulClient(ConformanceClient.class,myServerBase);
    Conformance conformance=client.getConformance();
    WebContext ctx=new WebContext(theReq,theResp,theReq.getServletContext(),theReq.getLocale());
    ctx.setVariable(""String_Node_Str"",conformance);
    ctx.setVariable(""String_Node_Str"",myServerBase);
    ctx.setVariable(""String_Node_Str"",myCtx.newJsonParser().encodeResourceToString(conformance));
    theResp.setContentType(""String_Node_Str"");
    theResp.setCharacterEncoding(""String_Node_Str"");
    myTemplateEngine.process(theReq.getPathInfo(),ctx,theResp.getWriter());
  }
 catch (  Exception e) {
    ourLog.error(""String_Node_Str"",e);
    theResp.sendError(500,e.getMessage());
  }
}",0.9565217391304348
112350,IParser setPrettyPrint(boolean thePrettyPrint);,"/** 
 * Sets the ""pretty print"" flag, meaning that the parser will encode resources with human-readable spacing and newlines between elements instead of condensing output as much as possible.
 * @param thePrettyPrint The flag
 * @return Returns an instance of <code>this</code> parser so that methodcalls can be conveniently chained
 */
IParser setPrettyPrint(boolean thePrettyPrint);",0.2180974477958236
112351,"String encodeBundleToString(Bundle theBundle) throws DataFormatException, IOException ;",String encodeBundleToString(Bundle theBundle) throws DataFormatException ;,0.9192546583850932
112352,"String encodeResourceToString(IResource theResource) throws DataFormatException, IOException ;",String encodeResourceToString(IResource theResource) throws DataFormatException ;,0.9257142857142856
112353,"public OperationOutcome getOperationOutcome(){
  return myOperationOutcome;
}","/** 
 * Returns the   {@link OperationOutcome} resource to return to the client or<code>null</code> if none.
 * @return This method <b>will return null</b>, unlike many methods in theAPI.
 */
public OperationOutcome getOperationOutcome(){
  return myOperationOutcome;
}",0.4450867052023121
112354,"public void setOperationOutcome(OperationOutcome theOperationOutcome){
  myOperationOutcome=theOperationOutcome;
}","/** 
 * Sets the   {@link OperationOutcome} resource to return to the client. Setto <code>null</code> (which is the default) if none.
 */
public void setOperationOutcome(OperationOutcome theOperationOutcome){
  myOperationOutcome=theOperationOutcome;
}",0.6229508196721312
112355,"private void fillProfile(Structure theStruct,StructureElement theElement,BaseRuntimeElementDefinition<?> def,LinkedList<String> path,BaseRuntimeDeclaredChildDefinition theChild){
  fillBasics(theElement,def,path,theChild);
  String expectedPath=StringUtils.join(path,'.');
  ourLog.info(""String_Node_Str"",expectedPath);
  if (!expectedPath.equals(def.getName())) {
    theElement.getDefinition().getNameReference().setValue(def.getName());
    return;
  }
  fillExtensions(theStruct,path,def.getExtensionsNonModifier(),""String_Node_Str"",false);
  fillExtensions(theStruct,path,def.getExtensionsModifier(),""String_Node_Str"",true);
  if (def.getChildType() == ChildTypeEnum.RESOURCE) {
    StructureElement narrative=theStruct.addElement();
    narrative.setName(""String_Node_Str"");
    narrative.setPath(join(path,'.') + ""String_Node_Str"");
    narrative.getDefinition().addType().setCode(DataTypeEnum.NARRATIVE);
    narrative.getDefinition().setIsModifier(false);
    narrative.getDefinition().setMin(0);
    narrative.getDefinition().setMax(""String_Node_Str"");
    StructureElement contained=theStruct.addElement();
    contained.setName(""String_Node_Str"");
    contained.setPath(join(path,'.') + ""String_Node_Str"");
    contained.getDefinition().addType().getCode().setValue(""String_Node_Str"");
    contained.getDefinition().setIsModifier(false);
    contained.getDefinition().setMin(0);
    contained.getDefinition().setMax(""String_Node_Str"");
  }
  if (def instanceof BaseRuntimeElementCompositeDefinition) {
    BaseRuntimeElementCompositeDefinition<?> cdef=((BaseRuntimeElementCompositeDefinition<?>)def);
    for (    BaseRuntimeChildDefinition nextChild : cdef.getChildren()) {
      if (nextChild instanceof RuntimeChildUndeclaredExtensionDefinition) {
        continue;
      }
      BaseRuntimeDeclaredChildDefinition child=(BaseRuntimeDeclaredChildDefinition)nextChild;
      StructureElement elem=theStruct.addElement();
      fillMinAndMaxAndDefinitions(child,elem);
      if (child instanceof RuntimeChildResourceBlockDefinition) {
        RuntimeResourceBlockDefinition nextDef=(RuntimeResourceBlockDefinition)child.getSingleChildOrThrow();
        fillProfile(theStruct,elem,nextDef,path,child);
      }
 else       if (child instanceof RuntimeChildContainedResources) {
      }
 else       if (child instanceof RuntimeChildDeclaredExtensionDefinition) {
        throw new IllegalStateException(""String_Node_Str"" + child.getClass().getCanonicalName());
      }
 else       if (child instanceof RuntimeChildCompositeDatatypeDefinition || child instanceof RuntimeChildPrimitiveDatatypeDefinition || child instanceof RuntimeChildChoiceDefinition|| child instanceof RuntimeChildResourceDefinition) {
        Iterator<String> childNamesIter=child.getValidChildNames().iterator();
        String nextName=childNamesIter.next();
        BaseRuntimeElementDefinition<?> nextDef=child.getChildByName(nextName);
        fillBasics(elem,nextDef,path,child);
        fillName(elem,nextDef);
        while (childNamesIter.hasNext()) {
          nextDef=child.getChildByName(childNamesIter.next());
          fillName(elem,nextDef);
        }
        path.pollLast();
      }
 else {
        throw new IllegalStateException(""String_Node_Str"" + child.getClass().getCanonicalName());
      }
    }
  }
 else {
    throw new IllegalStateException(""String_Node_Str"" + def.getClass().getCanonicalName());
  }
  path.pollLast();
}","private void fillProfile(Structure theStruct,StructureElement theElement,BaseRuntimeElementDefinition<?> def,LinkedList<String> path,BaseRuntimeDeclaredChildDefinition theChild){
  fillBasics(theElement,def,path,theChild);
  String expectedPath=StringUtils.join(path,'.');
  ourLog.info(""String_Node_Str"",expectedPath);
  String name=def.getName();
  if (!expectedPath.equals(name)) {
    path.pollLast();
    theElement.getDefinition().getNameReference().setValue(def.getName());
    return;
  }
  fillExtensions(theStruct,path,def.getExtensionsNonModifier(),""String_Node_Str"",false);
  fillExtensions(theStruct,path,def.getExtensionsModifier(),""String_Node_Str"",true);
  if (def.getChildType() == ChildTypeEnum.RESOURCE) {
    StructureElement narrative=theStruct.addElement();
    narrative.setName(""String_Node_Str"");
    narrative.setPath(join(path,'.') + ""String_Node_Str"");
    narrative.getDefinition().addType().setCode(DataTypeEnum.NARRATIVE);
    narrative.getDefinition().setIsModifier(false);
    narrative.getDefinition().setMin(0);
    narrative.getDefinition().setMax(""String_Node_Str"");
    StructureElement contained=theStruct.addElement();
    contained.setName(""String_Node_Str"");
    contained.setPath(join(path,'.') + ""String_Node_Str"");
    contained.getDefinition().addType().getCode().setValue(""String_Node_Str"");
    contained.getDefinition().setIsModifier(false);
    contained.getDefinition().setMin(0);
    contained.getDefinition().setMax(""String_Node_Str"");
  }
  if (def instanceof BaseRuntimeElementCompositeDefinition) {
    BaseRuntimeElementCompositeDefinition<?> cdef=((BaseRuntimeElementCompositeDefinition<?>)def);
    for (    BaseRuntimeChildDefinition nextChild : cdef.getChildren()) {
      if (nextChild instanceof RuntimeChildUndeclaredExtensionDefinition) {
        continue;
      }
      BaseRuntimeDeclaredChildDefinition child=(BaseRuntimeDeclaredChildDefinition)nextChild;
      StructureElement elem=theStruct.addElement();
      fillMinAndMaxAndDefinitions(child,elem);
      if (child instanceof RuntimeChildResourceBlockDefinition) {
        RuntimeResourceBlockDefinition nextDef=(RuntimeResourceBlockDefinition)child.getSingleChildOrThrow();
        fillProfile(theStruct,elem,nextDef,path,child);
      }
 else       if (child instanceof RuntimeChildContainedResources) {
      }
 else       if (child instanceof RuntimeChildDeclaredExtensionDefinition) {
        throw new IllegalStateException(""String_Node_Str"" + child.getClass().getCanonicalName());
      }
 else       if (child instanceof RuntimeChildCompositeDatatypeDefinition || child instanceof RuntimeChildPrimitiveDatatypeDefinition || child instanceof RuntimeChildChoiceDefinition|| child instanceof RuntimeChildResourceDefinition) {
        Iterator<String> childNamesIter=child.getValidChildNames().iterator();
        String nextName=childNamesIter.next();
        BaseRuntimeElementDefinition<?> nextDef=child.getChildByName(nextName);
        fillBasics(elem,nextDef,path,child);
        fillName(elem,nextDef);
        while (childNamesIter.hasNext()) {
          nextDef=child.getChildByName(childNamesIter.next());
          fillName(elem,nextDef);
        }
        path.pollLast();
      }
 else {
        throw new IllegalStateException(""String_Node_Str"" + child.getClass().getCanonicalName());
      }
    }
  }
 else {
    throw new IllegalStateException(""String_Node_Str"" + def.getClass().getCanonicalName());
  }
  path.pollLast();
}",0.9902856314339568
112356,"private void streamResponseAsBundle(HttpServletResponse theHttpResponse,List<IResource> theResult,EncodingUtil theResponseEncoding) throws IOException {
  theHttpResponse.setStatus(200);
  theHttpResponse.setContentType(theResponseEncoding.getBundleContentType());
  theHttpResponse.setCharacterEncoding(""String_Node_Str"");
  Bundle bundle=new Bundle();
  bundle.getAuthorName().setValue(getClass().getCanonicalName());
  bundle.getId().setValue(UUID.randomUUID().toString());
  bundle.getPublished().setToCurrentTimeInLocalTimeZone();
  for (  IResource next : theResult) {
    BundleEntry entry=new BundleEntry();
    bundle.getEntries().add(entry);
    entry.setResource(next);
  }
  bundle.getTotalResults().setValue(theResult.size());
  PrintWriter writer=theHttpResponse.getWriter();
  getNewParser(theResponseEncoding).encodeBundleToWriter(bundle,writer);
  writer.close();
}","private void streamResponseAsBundle(HttpServletResponse theHttpResponse,List<IResource> theResult,EncodingUtil theResponseEncoding) throws IOException {
  theHttpResponse.setStatus(200);
  theHttpResponse.setContentType(theResponseEncoding.getBundleContentType());
  theHttpResponse.setCharacterEncoding(""String_Node_Str"");
  Bundle bundle=new Bundle();
  bundle.getAuthorName().setValue(getClass().getCanonicalName());
  bundle.getBundleId().setValue(UUID.randomUUID().toString());
  bundle.getPublished().setToCurrentTimeInLocalTimeZone();
  for (  IResource next : theResult) {
    BundleEntry entry=new BundleEntry();
    bundle.getEntries().add(entry);
    entry.setResource(next);
  }
  bundle.getTotalResults().setValue(theResult.size());
  PrintWriter writer=theHttpResponse.getWriter();
  getNewParser(theResponseEncoding).encodeBundleToWriter(bundle,writer);
  writer.close();
}",0.9966101694915256
112357,"@Test public void testParseBundle(){
  String summaryText=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  String msg=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + summaryText + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  IParser p=new FhirContext(ValueSet.class).newXmlParser();
  Bundle bundle=p.parseBundle(msg);
  assertEquals(""String_Node_Str"",bundle.getTitle().getValue());
  assertEquals(""String_Node_Str"",bundle.getLinkSelf().getValue());
  assertEquals(""String_Node_Str"",bundle.getUpdated().getValueAsString());
  assertEquals(1,bundle.getEntries().size());
  BundleEntry entry=bundle.getEntries().get(0);
  assertEquals(""String_Node_Str"",entry.getAuthorName().getValue());
  assertEquals(""String_Node_Str"",entry.getId().getValue());
  ValueSet resource=(ValueSet)entry.getResource();
  assertEquals(""String_Node_Str"",resource.getName().getValue());
  assertEquals(summaryText.trim(),entry.getSummary().getValueAsString().trim());
}","@Test public void testParseBundle(){
  String summaryText=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  String msg=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + summaryText + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  IParser p=new FhirContext(ValueSet.class).newXmlParser();
  Bundle bundle=p.parseBundle(msg);
  assertEquals(""String_Node_Str"",bundle.getTitle().getValue());
  assertEquals(""String_Node_Str"",bundle.getLinkSelf().getValue());
  assertEquals(""String_Node_Str"",bundle.getUpdated().getValueAsString());
  assertEquals(1,bundle.getEntries().size());
  BundleEntry entry=bundle.getEntries().get(0);
  assertEquals(""String_Node_Str"",entry.getAuthorName().getValue());
  assertEquals(""String_Node_Str"",entry.getEntryId().getValue());
  ValueSet resource=(ValueSet)entry.getResource();
  assertEquals(""String_Node_Str"",resource.getName().getValue());
  assertEquals(summaryText.trim(),entry.getSummary().getValueAsString().trim());
}",0.9986122675548156
112358,"public ModelScanner(Class<ResourceWithExtensionsA> theClass){
}","ModelScanner(Collection<Class<? extends IResource>> theResourceTypes) throws ConfigurationException {
  init(new HashSet<Class<? extends IElement>>(theResourceTypes));
}",0.3448275862068966
112359,"@Override public RuntimeResourceBlockDefinition getChildByName(String theName){
  if (!getElementName().equals(theName)) {
    return myElementDef;
  }
 else {
    return null;
  }
}","@Override public RuntimeResourceBlockDefinition getChildByName(String theName){
  if (getElementName().equals(theName)) {
    return myElementDef;
  }
 else {
    return null;
  }
}",0.9972451790633609
112360,"/** 
 * Sets the value(s) for country (Country (can be ISO 3166 3 letter code)) <p> <b>Definition:</b> Country - a nation as commonly understood or generally accepted </p> 
 */
public void setCountry(StringDt theValue){
  myCountry=theValue;
}","/** 
 * Sets the value(s) for <b>country</b> (Country (can be ISO 3166 3 letter code)) <p> <b>Definition:</b> Country - a nation as commonly understood or generally accepted </p> 
 */
public void setCountry(String theString){
  myCountry=new StringDt(theString);
}",0.8165680473372781
112361,"/** 
 * Gets the value(s) for zip (Postal code for area) <p> <b>Definition:</b> A postal code designating a region defined by the postal service. </p> 
 */
public StringDt getZip(){
  return myZip;
}","/** 
 * Gets the value(s) for <b>zip</b> (Postal code for area). creating it if it does not exist. Will not return <code>null</code>. <p> <b>Definition:</b> A postal code designating a region defined by the postal service. </p> 
 */
public StringDt getZip(){
  if (myZip == null) {
    myZip=new StringDt();
  }
  return myZip;
}",0.7272727272727273
112362,"/** 
 * Gets the value(s) for country (Country (can be ISO 3166 3 letter code)) <p> <b>Definition:</b> Country - a nation as commonly understood or generally accepted </p> 
 */
public StringDt getCountry(){
  return myCountry;
}","/** 
 * Gets the value(s) for <b>country</b> (Country (can be ISO 3166 3 letter code)). creating it if it does not exist. Will not return <code>null</code>. <p> <b>Definition:</b> Country - a nation as commonly understood or generally accepted </p> 
 */
public StringDt getCountry(){
  if (myCountry == null) {
    myCountry=new StringDt();
  }
  return myCountry;
}",0.6902356902356902
112363,"/** 
 * Sets the value(s) for city (Name of city, town etc.) <p> <b>Definition:</b> The name of the city, town, village or other community or delivery center. </p> 
 */
public void setCity(StringDt theValue){
  myCity=theValue;
}","/** 
 * Sets the value(s) for <b>city</b> (Name of city, town etc.) <p> <b>Definition:</b> The name of the city, town, village or other community or delivery center. </p> 
 */
public void setCity(String theString){
  myCity=new StringDt(theString);
}",0.8183716075156576
112364,"/** 
 * Gets the value(s) for text (Text representation of the address) <p> <b>Definition:</b> A full text representation of the address </p> 
 */
public StringDt getText(){
  return myText;
}","/** 
 * Gets the value(s) for <b>text</b> (Text representation of the address). creating it if it does not exist. Will not return <code>null</code>. <p> <b>Definition:</b> A full text representation of the address </p> 
 */
public StringDt getText(){
  if (myText == null) {
    myText=new StringDt();
  }
  return myText;
}",0.7015503875968992
112365,"/** 
 * Sets the value(s) for use (home | work | temp | old - purpose of this address) <p> <b>Definition:</b> The purpose of this address </p> 
 */
public void setUse(CodeDt theValue){
  myUse=theValue;
}","/** 
 * Sets the value(s) for <b>use</b> (home | work | temp | old - purpose of this address) <p> <b>Definition:</b> The purpose of this address </p> 
 */
public void setUse(CodeDt theValue){
  myUse=theValue;
}",0.9686746987951808
112366,"/** 
 * Gets the value(s) for line (Street name, number, direction & P.O. Box etc ) <p> <b>Definition:</b> This component contains the house number, apartment number, street name, street direction,  P.O. Box number, delivery hints, and similar address information </p> 
 */
public List<StringDt> getLine(){
  return myLine;
}","/** 
 * Gets the value(s) for <b>line</b> (Street name, number, direction & P.O. Box etc ). creating it if it does not exist. Will not return <code>null</code>. <p> <b>Definition:</b> This component contains the house number, apartment number, street name, street direction,  P.O. Box number, delivery hints, and similar address information </p> 
 */
public List<StringDt> getLine(){
  if (myLine == null) {
    myLine=new ArrayList<StringDt>();
  }
  return myLine;
}",0.7919293820933165
112367,"/** 
 * Sets the value(s) for period (Time period when address was/is in use) <p> <b>Definition:</b> Time period when address was/is in use </p> 
 */
public void setPeriod(PeriodDt theValue){
  myPeriod=theValue;
}","/** 
 * Sets the value(s) for <b>period</b> (Time period when address was/is in use) <p> <b>Definition:</b> Time period when address was/is in use </p> 
 */
public void setPeriod(PeriodDt theValue){
  myPeriod=theValue;
}",0.9563218390804598
112368,"/** 
 * Gets the value(s) for period (Time period when address was/is in use) <p> <b>Definition:</b> Time period when address was/is in use </p> 
 */
public PeriodDt getPeriod(){
  return myPeriod;
}","/** 
 * Gets the value(s) for <b>period</b> (Time period when address was/is in use). creating it if it does not exist. Will not return <code>null</code>. <p> <b>Definition:</b> Time period when address was/is in use </p> 
 */
public PeriodDt getPeriod(){
  if (myPeriod == null) {
    myPeriod=new PeriodDt();
  }
  return myPeriod;
}",0.6966292134831461
112369,"/** 
 * Gets the value(s) for state (Sub-unit of country (abreviations ok)) <p> <b>Definition:</b> Sub-unit of a country with limited sovereignty in a federally organized country. A code may be used if codes are in common use (i.e. US 2 letter state codes). </p> 
 */
public StringDt getState(){
  return myState;
}","/** 
 * Gets the value(s) for <b>state</b> (Sub-unit of country (abreviations ok)). creating it if it does not exist. Will not return <code>null</code>. <p> <b>Definition:</b> Sub-unit of a country with limited sovereignty in a federally organized country. A code may be used if codes are in common use (i.e. US 2 letter state codes). </p> 
 */
public StringDt getState(){
  if (myState == null) {
    myState=new StringDt();
  }
  return myState;
}",0.774869109947644
112370,"/** 
 * Gets the value(s) for use (home | work | temp | old - purpose of this address) <p> <b>Definition:</b> The purpose of this address </p> 
 */
public CodeDt getUse(){
  return myUse;
}","/** 
 * Gets the value(s) for <b>use</b> (home | work | temp | old - purpose of this address). creating it if it does not exist. Will not return <code>null</code>. <p> <b>Definition:</b> The purpose of this address </p> 
 */
public CodeDt getUse(){
  if (myUse == null) {
    myUse=new CodeDt();
  }
  return myUse;
}",0.7075098814229249
112371,"/** 
 * Sets the value(s) for state (Sub-unit of country (abreviations ok)) <p> <b>Definition:</b> Sub-unit of a country with limited sovereignty in a federally organized country. A code may be used if codes are in common use (i.e. US 2 letter state codes). </p> 
 */
public void setState(StringDt theValue){
  myState=theValue;
}","/** 
 * Sets the value(s) for <b>state</b> (Sub-unit of country (abreviations ok)) <p> <b>Definition:</b> Sub-unit of a country with limited sovereignty in a federally organized country. A code may be used if codes are in common use (i.e. US 2 letter state codes). </p> 
 */
public void setState(String theString){
  myState=new StringDt(theString);
}",0.8751835535976505
112372,"/** 
 * Sets the value(s) for line (Street name, number, direction & P.O. Box etc ) <p> <b>Definition:</b> This component contains the house number, apartment number, street name, street direction,  P.O. Box number, delivery hints, and similar address information </p> 
 */
public void setLine(List<StringDt> theValue){
  myLine=theValue;
}","/** 
 * Sets the value(s) for <b>line</b> (Street name, number, direction & P.O. Box etc ) <p> <b>Definition:</b> This component contains the house number, apartment number, street name, street direction,  P.O. Box number, delivery hints, and similar address information </p> 
 */
public void setLine(List<StringDt> theValue){
  myLine=theValue;
}",0.9781659388646288
112373,"/** 
 * Sets the value(s) for zip (Postal code for area) <p> <b>Definition:</b> A postal code designating a region defined by the postal service. </p> 
 */
public void setZip(StringDt theValue){
  myZip=theValue;
}","/** 
 * Sets the value(s) for <b>zip</b> (Postal code for area) <p> <b>Definition:</b> A postal code designating a region defined by the postal service. </p> 
 */
public void setZip(String theString){
  myZip=new StringDt(theString);
}",0.8685968819599109
112374,"/** 
 * Sets the value(s) for text (Text representation of the address) <p> <b>Definition:</b> A full text representation of the address </p> 
 */
public void setText(StringDt theValue){
  myText=theValue;
}","/** 
 * Sets the value(s) for <b>text</b> (Text representation of the address) <p> <b>Definition:</b> A full text representation of the address </p> 
 */
public void setText(String theString){
  myText=new StringDt(theString);
}",0.8459770114942529
112375,"/** 
 * Gets the value(s) for city (Name of city, town etc.) <p> <b>Definition:</b> The name of the city, town, village or other community or delivery center. </p> 
 */
public StringDt getCity(){
  return myCity;
}","/** 
 * Gets the value(s) for <b>city</b> (Name of city, town etc.). creating it if it does not exist. Will not return <code>null</code>. <p> <b>Definition:</b> The name of the city, town, village or other community or delivery center. </p> 
 */
public StringDt getCity(){
  if (myCity == null) {
    myCity=new StringDt();
  }
  return myCity;
}",0.725
112376,"/** 
 * Override this method to customize each cell given a   {@link ParseObject}. <p/> If a view is not provided, a default view will be created based upon  {@code android.R.layout.activity_list_item}. <p/> This method expects a   {@code TextView} with id {@code android.R.id.text1} in your object views.If  {@link #setImageKey(String)} was used, this method also expects an {@code ImageView} with id{@code android.R.id.icon}. <p/> This method displays the text value specified by the text key (set via  {@link #setTextKey(String)}) and an image (described by a   {@link ParseFile}, under the key set via   {@link #setImageKey(String)}) if applicable. If the text key is not set, the value for  {@link ParseObject#getObjectId()} will be displayed instead.
 * @param object The  {@link ParseObject} associated with this item.
 * @param v The  {@code View} associated with this row. This view, if non-null, is being recycledand intended to be used for displaying this item.
 * @param parent The parent that this view will eventually be attached to
 * @return The customized view displaying the {@link ParseObject}'s information.
 */
public View getItemView(T object,View v,ViewGroup parent){
  if (v == null) {
    v=getDefaultView(parent.getContext());
  }
  TextView textView;
  try {
    textView=(TextView)v.findViewById(android.R.id.text1);
  }
 catch (  ClassCastException ex) {
    throw new IllegalStateException(""String_Node_Str"",ex);
  }
  if (textView != null) {
    if (textKey == null) {
      textView.setText(object.getObjectId());
    }
 else     if (object.get(textKey) != null) {
      textView.setText(object.get(textKey).toString());
    }
 else {
      textView.setText(null);
    }
  }
  if (imageKey != null) {
    ParseImageView imageView;
    try {
      imageView=(ParseImageView)v.findViewById(android.R.id.icon);
    }
 catch (    ClassCastException ex) {
      throw new IllegalStateException(""String_Node_Str"",ex);
    }
    if (imageView == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    if (!imageViewSet.containsKey(imageView)) {
      imageViewSet.put(imageView,null);
    }
    imageView.setPlaceholder(placeholder);
    imageView.setParseFile((ParseFile)object.get(imageKey));
    imageView.loadInBackground();
  }
  return v;
}","/** 
 * Override this method to customize each cell given a   {@link ParseObject}. <p> If a view is not provided, a default view will be created based upon  {@code android.R.layout.activity_list_item}. <p> This method expects a   {@code TextView} with id {@code android.R.id.text1} in your object views.If  {@link #setImageKey(String)} was used, this method also expects an {@code ImageView} with id{@code android.R.id.icon}. <p> This method displays the text value specified by the text key (set via  {@link #setTextKey(String)}) and an image (described by a   {@link ParseFile}, under the key set via   {@link #setImageKey(String)}) if applicable. If the text key is not set, the value for  {@link ParseObject#getObjectId()} will be displayed instead.
 * @param object The  {@link ParseObject} associated with this item.
 * @param v The  {@code View} associated with this row. This view, if non-null, is being recycledand intended to be used for displaying this item.
 * @param parent The parent that this view will eventually be attached to
 * @return The customized view displaying the {@link ParseObject}'s information.
 */
public View getItemView(T object,View v,ViewGroup parent){
  if (v == null) {
    v=getDefaultView(parent.getContext());
  }
  TextView textView;
  try {
    textView=(TextView)v.findViewById(android.R.id.text1);
  }
 catch (  ClassCastException ex) {
    throw new IllegalStateException(""String_Node_Str"",ex);
  }
  if (textView != null) {
    if (textKey == null) {
      textView.setText(object.getObjectId());
    }
 else     if (object.get(textKey) != null) {
      textView.setText(object.get(textKey).toString());
    }
 else {
      textView.setText(null);
    }
  }
  if (imageKey != null) {
    ParseImageView imageView;
    try {
      imageView=(ParseImageView)v.findViewById(android.R.id.icon);
    }
 catch (    ClassCastException ex) {
      throw new IllegalStateException(""String_Node_Str"",ex);
    }
    if (imageView == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    if (!imageViewSet.containsKey(imageView)) {
      imageViewSet.put(imageView,null);
    }
    imageView.setPlaceholder(placeholder);
    imageView.setParseFile((ParseFile)object.get(imageKey));
    imageView.loadInBackground();
  }
  return v;
}",0.9993451211525868
112377,"/** 
 * Clears the table and loads the first page of objects asynchronously. This method is called automatically when this   {@code Adapter} is attached to an {@code AdapterView}. <p/>  {@code loadObjects()} should only need to be called if {@link #setAutoload(boolean)} is set to{@code false}.
 */
public void loadObjects(){
  loadNextPage(true);
}","/** 
 * Clears the table and loads the first page of objects asynchronously. This method is called automatically when this   {@code Adapter} is attached to an {@code AdapterView}. <p>  {@code loadObjects()} should only need to be called if {@link #setAutoload(boolean)} is set to{@code false}.
 */
public void loadObjects(){
  loadNextPage(true);
}",0.9985652797704448
112378,"/** 
 * Override this method to customize the ""Load Next Page"" cell, visible when pagination is turned on and there may be more results to display. <p/> This method expects a   {@code TextView} with id {@code android.R.id.text1}.
 * @param v The view object associated with this row + type (a ""Next Page"" view, instead of an ""Item"" view).
 * @param parent The parent that this view will eventually be attached to
 * @return The view object that allows the user to paginate.
 */
public View getNextPageView(View v,ViewGroup parent){
  if (v == null) {
    v=getDefaultView(parent.getContext());
  }
  TextView textView=(TextView)v.findViewById(android.R.id.text1);
  textView.setText(""String_Node_Str"");
  return v;
}","/** 
 * Override this method to customize the ""Load Next Page"" cell, visible when pagination is turned on and there may be more results to display. <p> This method expects a   {@code TextView} with id {@code android.R.id.text1}.
 * @param v The view object associated with this row + type (a ""Next Page"" view, instead of an ""Item"" view).
 * @param parent The parent that this view will eventually be attached to
 * @return The view object that allows the user to paginate.
 */
public View getNextPageView(View v,ViewGroup parent){
  if (v == null) {
    v=getDefaultView(parent.getContext());
  }
  TextView textView=(TextView)v.findViewById(android.R.id.text1);
  textView.setText(""String_Node_Str"");
  return v;
}",0.9993011879804332
112379,"/** 
 * Override this method to manually paginate the provided   {@code ParseQuery}. By default, this method will set the   {@code limit} value to {@link #getObjectsPerPage()} and the {@code skip}value to   {@link #getObjectsPerPage()} * {@code page}. <p/> Overriding this method will not be necessary, in most cases.
 * @param page the page number of results to fetch from Parse.
 * @param query the  {@link ParseQuery} used to fetch items from Parse. This query will be mutated andused in its mutated form.
 */
protected void setPageOnQuery(int page,ParseQuery<T> query){
  query.setLimit(objectsPerPage + 1);
  query.setSkip(page * objectsPerPage);
}","/** 
 * Override this method to manually paginate the provided   {@code ParseQuery}. By default, this method will set the   {@code limit} value to {@link #getObjectsPerPage()} and the {@code skip}value to   {@link #getObjectsPerPage()} * {@code page}. <p> Overriding this method will not be necessary, in most cases.
 * @param page the page number of results to fetch from Parse.
 * @param query the  {@link ParseQuery} used to fetch items from Parse. This query will be mutated andused in its mutated form.
 */
protected void setPageOnQuery(int page,ParseQuery<T> query){
  query.setLimit(objectsPerPage + 1);
  query.setSkip(page * objectsPerPage);
}",0.9992337164750956
112380,"/** 
 * Loads the next page of objects, appends to table, and notifies the UI that the model has changed.
 */
public void loadNextPage(){
  this.loadObjects(currentPage + 1,false);
}","/** 
 * Loads the next page of objects, appends to table, and notifies the UI that the model has changed.
 */
public void loadNextPage(){
  if (objects.size() == 0 && runningQueries.size() == 0) {
    loadObjects(0,false);
  }
 else {
    loadObjects(currentPage + 1,false);
  }
}",0.7748917748917749
112381,"private void loadObjects(final int page,final boolean shouldClear){
  final ParseQuery<T> query=this.queryFactory.create();
  if (this.objectsPerPage > 0 && this.paginationEnabled) {
    this.setPageOnQuery(page,query);
  }
  this.notifyOnLoadingListeners();
  if (page >= objectPages.size()) {
    objectPages.add(page,new ArrayList<T>());
  }
  final Capture<Boolean> firstCallBack=new Capture<>(true);
  query.findInBackground(new FindCallback<T>(){
    @SuppressLint(""String_Node_Str"") @Override public void done(    List<T> foundObjects,    ParseException e){
      if ((!Parse.isLocalDatastoreEnabled() && query.getCachePolicy() == CachePolicy.CACHE_ONLY) && (e != null) && e.getCode() == ParseException.CACHE_MISS) {
        return;
      }
      if ((e != null) && ((e.getCode() == ParseException.CONNECTION_FAILED) || (e.getCode() != ParseException.CACHE_MISS))) {
        hasNextPage=true;
      }
 else       if (foundObjects != null) {
        if (shouldClear && firstCallBack.get()) {
          objectPages.clear();
          objectPages.add(new ArrayList<T>());
          currentPage=page;
          firstCallBack.set(false);
        }
        if (page >= currentPage) {
          currentPage=page;
          hasNextPage=(foundObjects.size() > objectsPerPage);
        }
        if (paginationEnabled && foundObjects.size() > objectsPerPage) {
          foundObjects.remove(objectsPerPage);
        }
        List<T> currentPage=objectPages.get(page);
        currentPage.clear();
        currentPage.addAll(foundObjects);
        syncObjectsWithPages();
        notifyDataSetChanged();
      }
      notifyOnLoadedListeners(foundObjects,e);
    }
  }
);
}","private void loadObjects(final int page,final boolean shouldClear){
  final ParseQuery<T> query=this.queryFactory.create();
  if (this.objectsPerPage > 0 && this.paginationEnabled) {
    this.setPageOnQuery(page,query);
  }
  this.notifyOnLoadingListeners();
  if (page >= objectPages.size()) {
    objectPages.add(page,new ArrayList<T>());
  }
  final Capture<Boolean> firstCallBack=new Capture<>(true);
  runningQueries.add(query);
  query.findInBackground(new FindCallback<T>(){
    @Override public void done(    List<T> foundObjects,    ParseException e){
      if (!runningQueries.contains(query)) {
        return;
      }
      if (query.getCachePolicy() != CachePolicy.CACHE_THEN_NETWORK || (query.getCachePolicy() == CachePolicy.CACHE_THEN_NETWORK && !firstCallBack.get())) {
        runningQueries.remove(query);
      }
      if ((!Parse.isLocalDatastoreEnabled() && query.getCachePolicy() == CachePolicy.CACHE_ONLY) && (e != null) && e.getCode() == ParseException.CACHE_MISS) {
        return;
      }
      if ((e != null) && ((e.getCode() == ParseException.CONNECTION_FAILED) || (e.getCode() != ParseException.CACHE_MISS))) {
        hasNextPage=true;
      }
 else       if (foundObjects != null) {
        if (shouldClear && firstCallBack.get()) {
          runningQueries.remove(query);
          cancelAllQueries();
          runningQueries.add(query);
          objectPages.clear();
          objectPages.add(new ArrayList<T>());
          currentPage=page;
          firstCallBack.set(false);
        }
        if (page >= currentPage) {
          currentPage=page;
          hasNextPage=(foundObjects.size() > objectsPerPage);
        }
        if (paginationEnabled && foundObjects.size() > objectsPerPage) {
          foundObjects.remove(objectsPerPage);
        }
        List<T> currentPage=objectPages.get(page);
        currentPage.clear();
        currentPage.addAll(foundObjects);
        syncObjectsWithPages();
        notifyDataSetChanged();
      }
      notifyOnLoadedListeners(foundObjects,e);
    }
  }
);
}",0.8815293484114163
112382,"/** 
 * Remove all elements from the list.
 */
public void clear(){
  this.objectPages.clear();
  syncObjectsWithPages();
  this.notifyDataSetChanged();
  this.currentPage=0;
}","/** 
 * Remove all elements from the list.
 */
public void clear(){
  this.objectPages.clear();
  cancelAllQueries();
  syncObjectsWithPages();
  this.notifyDataSetChanged();
  this.currentPage=0;
}",0.9411764705882352
112383,"@SuppressLint(""String_Node_Str"") @Override public void done(List<T> foundObjects,ParseException e){
  if ((!Parse.isLocalDatastoreEnabled() && query.getCachePolicy() == CachePolicy.CACHE_ONLY) && (e != null) && e.getCode() == ParseException.CACHE_MISS) {
    return;
  }
  if ((e != null) && ((e.getCode() == ParseException.CONNECTION_FAILED) || (e.getCode() != ParseException.CACHE_MISS))) {
    hasNextPage=true;
  }
 else   if (foundObjects != null) {
    if (shouldClear && firstCallBack.get()) {
      objectPages.clear();
      objectPages.add(new ArrayList<T>());
      currentPage=page;
      firstCallBack.set(false);
    }
    if (page >= currentPage) {
      currentPage=page;
      hasNextPage=(foundObjects.size() > objectsPerPage);
    }
    if (paginationEnabled && foundObjects.size() > objectsPerPage) {
      foundObjects.remove(objectsPerPage);
    }
    List<T> currentPage=objectPages.get(page);
    currentPage.clear();
    currentPage.addAll(foundObjects);
    syncObjectsWithPages();
    notifyDataSetChanged();
  }
  notifyOnLoadedListeners(foundObjects,e);
}","@Override public void done(List<T> foundObjects,ParseException e){
  if (!runningQueries.contains(query)) {
    return;
  }
  if (query.getCachePolicy() != CachePolicy.CACHE_THEN_NETWORK || (query.getCachePolicy() == CachePolicy.CACHE_THEN_NETWORK && !firstCallBack.get())) {
    runningQueries.remove(query);
  }
  if ((!Parse.isLocalDatastoreEnabled() && query.getCachePolicy() == CachePolicy.CACHE_ONLY) && (e != null) && e.getCode() == ParseException.CACHE_MISS) {
    return;
  }
  if ((e != null) && ((e.getCode() == ParseException.CONNECTION_FAILED) || (e.getCode() != ParseException.CACHE_MISS))) {
    hasNextPage=true;
  }
 else   if (foundObjects != null) {
    if (shouldClear && firstCallBack.get()) {
      runningQueries.remove(query);
      cancelAllQueries();
      runningQueries.add(query);
      objectPages.clear();
      objectPages.add(new ArrayList<T>());
      currentPage=page;
      firstCallBack.set(false);
    }
    if (page >= currentPage) {
      currentPage=page;
      hasNextPage=(foundObjects.size() > objectsPerPage);
    }
    if (paginationEnabled && foundObjects.size() > objectsPerPage) {
      foundObjects.remove(objectsPerPage);
    }
    List<T> currentPage=objectPages.get(page);
    currentPage.clear();
    currentPage.addAll(foundObjects);
    syncObjectsWithPages();
    notifyDataSetChanged();
  }
  notifyOnLoadedListeners(foundObjects,e);
}",0.8486071861122325
112384,"/** 
 * Loads the next page of objects, appends to table, and notifies the UI that the model has changed.
 */
public void loadNextPage(){
  this.loadObjects(currentPage + 1,false);
}","/** 
 * Loads the next page of objects, appends to table, and notifies the UI that the model has changed.
 */
public void loadNextPage(){
  if (objects.size() == 0 && runningQueries.size() == 0) {
    loadObjects(0,false);
  }
 else {
    loadObjects(currentPage + 1,false);
  }
}",0.7748917748917749
112385,"private void loadObjects(final int page,final boolean shouldClear){
  final ParseQuery<T> query=this.queryFactory.create();
  if (this.objectsPerPage > 0 && this.paginationEnabled) {
    this.setPageOnQuery(page,query);
  }
  this.notifyOnLoadingListeners();
  if (page >= objectPages.size()) {
    objectPages.add(page,new ArrayList<T>());
  }
  final Capture<Boolean> firstCallBack=new Capture<>(true);
  query.findInBackground(new FindCallback<T>(){
    @SuppressLint(""String_Node_Str"") @Override public void done(    List<T> foundObjects,    ParseException e){
      if ((!Parse.isLocalDatastoreEnabled() && query.getCachePolicy() == CachePolicy.CACHE_ONLY) && (e != null) && e.getCode() == ParseException.CACHE_MISS) {
        return;
      }
      if ((e != null) && ((e.getCode() == ParseException.CONNECTION_FAILED) || (e.getCode() != ParseException.CACHE_MISS))) {
        hasNextPage=true;
      }
 else       if (foundObjects != null) {
        if (shouldClear && firstCallBack.get()) {
          objectPages.clear();
          objectPages.add(new ArrayList<T>());
          currentPage=page;
          firstCallBack.set(false);
        }
        if (page >= currentPage) {
          currentPage=page;
          hasNextPage=(foundObjects.size() > objectsPerPage);
        }
        if (paginationEnabled && foundObjects.size() > objectsPerPage) {
          foundObjects.remove(objectsPerPage);
        }
        List<T> currentPage=objectPages.get(page);
        currentPage.clear();
        currentPage.addAll(foundObjects);
        syncObjectsWithPages();
        notifyDataSetChanged();
      }
      notifyOnLoadedListeners(foundObjects,e);
    }
  }
);
}","private void loadObjects(final int page,final boolean shouldClear){
  final ParseQuery<T> query=this.queryFactory.create();
  if (this.objectsPerPage > 0 && this.paginationEnabled) {
    this.setPageOnQuery(page,query);
  }
  this.notifyOnLoadingListeners();
  if (page >= objectPages.size()) {
    objectPages.add(page,new ArrayList<T>());
  }
  final Capture<Boolean> firstCallBack=new Capture<>(true);
  runningQueries.add(query);
  query.findInBackground(new FindCallback<T>(){
    @Override public void done(    List<T> foundObjects,    ParseException e){
      if (!runningQueries.contains(query)) {
        return;
      }
      if (query.getCachePolicy() != CachePolicy.CACHE_THEN_NETWORK || (query.getCachePolicy() == CachePolicy.CACHE_THEN_NETWORK && !firstCallBack.get())) {
        runningQueries.remove(query);
      }
      if ((!Parse.isLocalDatastoreEnabled() && query.getCachePolicy() == CachePolicy.CACHE_ONLY) && (e != null) && e.getCode() == ParseException.CACHE_MISS) {
        return;
      }
      if ((e != null) && ((e.getCode() == ParseException.CONNECTION_FAILED) || (e.getCode() != ParseException.CACHE_MISS))) {
        hasNextPage=true;
      }
 else       if (foundObjects != null) {
        if (shouldClear && firstCallBack.get()) {
          runningQueries.remove(query);
          cancelAllQueries();
          runningQueries.add(query);
          objectPages.clear();
          objectPages.add(new ArrayList<T>());
          currentPage=page;
          firstCallBack.set(false);
        }
        if (page >= currentPage) {
          currentPage=page;
          hasNextPage=(foundObjects.size() > objectsPerPage);
        }
        if (paginationEnabled && foundObjects.size() > objectsPerPage) {
          foundObjects.remove(objectsPerPage);
        }
        List<T> currentPage=objectPages.get(page);
        currentPage.clear();
        currentPage.addAll(foundObjects);
        syncObjectsWithPages();
        notifyDataSetChanged();
      }
      notifyOnLoadedListeners(foundObjects,e);
    }
  }
);
}",0.8815293484114163
112386,"/** 
 * Remove all elements from the list.
 */
public void clear(){
  this.objectPages.clear();
  syncObjectsWithPages();
  this.notifyDataSetChanged();
  this.currentPage=0;
}","/** 
 * Remove all elements from the list.
 */
public void clear(){
  this.objectPages.clear();
  cancelAllQueries();
  syncObjectsWithPages();
  this.notifyDataSetChanged();
  this.currentPage=0;
}",0.9411764705882352
112387,"@SuppressLint(""String_Node_Str"") @Override public void done(List<T> foundObjects,ParseException e){
  if ((!Parse.isLocalDatastoreEnabled() && query.getCachePolicy() == CachePolicy.CACHE_ONLY) && (e != null) && e.getCode() == ParseException.CACHE_MISS) {
    return;
  }
  if ((e != null) && ((e.getCode() == ParseException.CONNECTION_FAILED) || (e.getCode() != ParseException.CACHE_MISS))) {
    hasNextPage=true;
  }
 else   if (foundObjects != null) {
    if (shouldClear && firstCallBack.get()) {
      objectPages.clear();
      objectPages.add(new ArrayList<T>());
      currentPage=page;
      firstCallBack.set(false);
    }
    if (page >= currentPage) {
      currentPage=page;
      hasNextPage=(foundObjects.size() > objectsPerPage);
    }
    if (paginationEnabled && foundObjects.size() > objectsPerPage) {
      foundObjects.remove(objectsPerPage);
    }
    List<T> currentPage=objectPages.get(page);
    currentPage.clear();
    currentPage.addAll(foundObjects);
    syncObjectsWithPages();
    notifyDataSetChanged();
  }
  notifyOnLoadedListeners(foundObjects,e);
}","@Override public void done(List<T> foundObjects,ParseException e){
  if (!runningQueries.contains(query)) {
    return;
  }
  if (query.getCachePolicy() != CachePolicy.CACHE_THEN_NETWORK || (query.getCachePolicy() == CachePolicy.CACHE_THEN_NETWORK && !firstCallBack.get())) {
    runningQueries.remove(query);
  }
  if ((!Parse.isLocalDatastoreEnabled() && query.getCachePolicy() == CachePolicy.CACHE_ONLY) && (e != null) && e.getCode() == ParseException.CACHE_MISS) {
    return;
  }
  if ((e != null) && ((e.getCode() == ParseException.CONNECTION_FAILED) || (e.getCode() != ParseException.CACHE_MISS))) {
    hasNextPage=true;
  }
 else   if (foundObjects != null) {
    if (shouldClear && firstCallBack.get()) {
      runningQueries.remove(query);
      cancelAllQueries();
      runningQueries.add(query);
      objectPages.clear();
      objectPages.add(new ArrayList<T>());
      currentPage=page;
      firstCallBack.set(false);
    }
    if (page >= currentPage) {
      currentPage=page;
      hasNextPage=(foundObjects.size() > objectsPerPage);
    }
    if (paginationEnabled && foundObjects.size() > objectsPerPage) {
      foundObjects.remove(objectsPerPage);
    }
    List<T> currentPage=objectPages.get(page);
    currentPage.clear();
    currentPage.addAll(foundObjects);
    syncObjectsWithPages();
    notifyDataSetChanged();
  }
  notifyOnLoadedListeners(foundObjects,e);
}",0.8486071861122325
112388,"/** 
 * Copies resources from the jar file of the current thread and extract it to the destination path.
 * @param jarConnection
 * @param destPath destination file or directory
 */
static void copyJarResourceToPath(JarURLConnection jarConnection,File destPath){
  try (JarFile jarFile=jarConnection.getJarFile()){
    String jarConnectionEntryName=jarConnection.getEntryName();
    for (Enumeration<JarEntry> e=jarFile.entries(); e.hasMoreElements(); ) {
      JarEntry jarEntry=e.nextElement();
      String jarEntryName=jarEntry.getName();
      if (jarEntryName.startsWith(jarConnectionEntryName + ""String_Node_Str"") || jarEntryName.startsWith(jarConnectionEntryName)) {
        String filename=jarEntryName.substring(jarConnectionEntryName.length());
        File targetFile=new File(destPath,filename);
        if (jarEntry.isDirectory()) {
          targetFile.mkdirs();
        }
 else {
          if (!targetFile.exists() || targetFile.length() != jarEntry.getSize()) {
            try (InputStream is=jarFile.getInputStream(jarEntry);OutputStream out=FileUtils.openOutputStream(targetFile)){
              IOUtils.copy(is,out);
            }
           }
        }
      }
    }
  }
 catch (  IOException e) {
    logger.warn(e.getMessage(),e);
  }
}","/** 
 * Copies resources from the jar file of the current thread and extract it to the destination path.
 * @param jarConnection
 * @param destPath destination file or directory
 */
static void copyJarResourceToPath(JarURLConnection jarConnection,File destPath){
  try (JarFile jarFile=jarConnection.getJarFile()){
    String jarConnectionEntryName=jarConnection.getEntryName();
    if (!jarConnectionEntryName.endsWith(""String_Node_Str"")) {
      jarConnectionEntryName+=""String_Node_Str"";
    }
    for (Enumeration<JarEntry> e=jarFile.entries(); e.hasMoreElements(); ) {
      JarEntry jarEntry=e.nextElement();
      String jarEntryName=jarEntry.getName();
      if (jarEntryName.startsWith(jarConnectionEntryName)) {
        String filename=jarEntryName.substring(jarConnectionEntryName.length());
        File targetFile=new File(destPath,filename);
        if (jarEntry.isDirectory()) {
          targetFile.mkdirs();
        }
 else {
          if (!targetFile.exists() || targetFile.length() != jarEntry.getSize()) {
            try (InputStream is=jarFile.getInputStream(jarEntry);OutputStream out=FileUtils.openOutputStream(targetFile)){
              IOUtils.copy(is,out);
            }
           }
        }
      }
    }
  }
 catch (  IOException e) {
    logger.warn(e.getMessage(),e);
  }
}",0.9263731982859368
112389,"/** 
 * Converts PDF to TIFF format.
 * @param inputPdfFile input file
 * @return a multi-page TIFF image
 * @throws IOException
 */
public static File convertPdf2Tiff(File inputPdfFile) throws IOException {
  File[] pngFiles=null;
  try {
    pngFiles=convertPdf2Png(inputPdfFile);
    File tiffFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    ImageIOHelper.mergeTiff(pngFiles,tiffFile);
    return tiffFile;
  }
 catch (  UnsatisfiedLinkError ule) {
    throw new RuntimeException(getMessage(ule.getMessage()));
  }
catch (  NoClassDefFoundError ncdfe) {
    throw new RuntimeException(getMessage(ncdfe.getMessage()));
  }
 finally {
    if (pngFiles != null) {
      for (      File tempFile : pngFiles) {
        tempFile.delete();
      }
    }
  }
}","/** 
 * Converts PDF to TIFF format.
 * @param inputPdfFile input file
 * @return a multi-page TIFF image
 * @throws IOException
 */
public static File convertPdf2Tiff(File inputPdfFile) throws IOException {
  File[] pngFiles=null;
  try {
    pngFiles=convertPdf2Png(inputPdfFile);
    File tiffFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    ImageIOHelper.mergeTiff(pngFiles,tiffFile);
    return tiffFile;
  }
 catch (  UnsatisfiedLinkError ule) {
    throw new RuntimeException(getMessage(ule.getMessage()));
  }
catch (  NoClassDefFoundError ncdfe) {
    throw new RuntimeException(getMessage(ncdfe.getMessage()));
  }
 finally {
    if (pngFiles != null && pngFiles.length > 0) {
      File pngDirectory=new File(pngFiles[0].getParent());
      for (      File tempFile : pngFiles) {
        tempFile.delete();
      }
      if (pngDirectory.getAbsoluteFile().getName().equals(inputPdfFile.getName().replace(""String_Node_Str"",""String_Node_Str""))) {
        pngDirectory.delete();
      }
    }
  }
}",0.8603227601558152
112390,"/** 
 * Converts PDF to PNG format.
 * @param inputPdfFile input file
 * @return an array of PNG images
 */
public static File[] convertPdf2Png(File inputPdfFile){
  File imageDir=inputPdfFile.getParentFile();
  if (imageDir == null) {
    String userDir=System.getProperty(""String_Node_Str"");
    imageDir=new File(userDir);
  }
  Ghostscript gs=Ghostscript.getInstance();
  List<String> gsArgs=new ArrayList<String>();
  gsArgs.add(""String_Node_Str"");
  gsArgs.add(""String_Node_Str"");
  gsArgs.add(""String_Node_Str"");
  gsArgs.add(""String_Node_Str"");
  gsArgs.add(""String_Node_Str"");
  gsArgs.add(""String_Node_Str"");
  gsArgs.add(""String_Node_Str"");
  gsArgs.add(""String_Node_Str"");
  gsArgs.add(""String_Node_Str"");
  gsArgs.add(""String_Node_Str"" + imageDir.getPath() + ""String_Node_Str"");
  gsArgs.add(inputPdfFile.getPath());
  try {
synchronized (gs) {
      gs.initialize(gsArgs.toArray(new String[0]));
      gs.exit();
    }
  }
 catch (  GhostscriptException e) {
    logger.error(e.getCause() != null ? e.getCause().toString() : e.getMessage(),e);
  }
 finally {
    try {
      Ghostscript.deleteInstance();
    }
 catch (    GhostscriptException e) {
    }
  }
  File[] workingFiles=imageDir.listFiles(new FilenameFilter(){
    @Override public boolean accept(    File dir,    String name){
      return name.toLowerCase().matches(""String_Node_Str"");
    }
  }
);
  Arrays.sort(workingFiles,new Comparator<File>(){
    @Override public int compare(    File f1,    File f2){
      return f1.getName().compareTo(f2.getName());
    }
  }
);
  return workingFiles;
}","/** 
 * Converts PDF to PNG format.
 * @param inputPdfFile input file
 * @return an array of PNG images
 */
@SuppressWarnings(""String_Node_Str"") public synchronized static File[] convertPdf2Png(File inputPdfFile){
  File imageDir=new File(inputPdfFile.getParentFile() + System.getProperty(""String_Node_Str"") + inputPdfFile.getName().replace(""String_Node_Str"",""String_Node_Str""));
  imageDir.mkdirs();
  if (imageDir == null) {
    String userDir=System.getProperty(""String_Node_Str"");
    imageDir=new File(userDir);
  }
  Ghostscript gs=Ghostscript.getInstance();
  List<String> gsArgs=new ArrayList<String>();
  gsArgs.add(""String_Node_Str"");
  gsArgs.add(""String_Node_Str"");
  gsArgs.add(""String_Node_Str"");
  gsArgs.add(""String_Node_Str"");
  gsArgs.add(""String_Node_Str"");
  gsArgs.add(""String_Node_Str"");
  gsArgs.add(""String_Node_Str"");
  gsArgs.add(""String_Node_Str"");
  gsArgs.add(""String_Node_Str"");
  gsArgs.add(""String_Node_Str"" + imageDir.getPath() + ""String_Node_Str"");
  gsArgs.add(inputPdfFile.getPath());
  try {
synchronized (gs) {
      gs.initialize(gsArgs.toArray(new String[0]));
      gs.exit();
    }
  }
 catch (  GhostscriptException e) {
    logger.error(e.getCause() != null ? e.getCause().toString() : e.getMessage(),e);
  }
 finally {
    try {
      Ghostscript.deleteInstance();
    }
 catch (    GhostscriptException e) {
    }
  }
  File[] workingFiles=imageDir.listFiles(new FilenameFilter(){
    @Override public boolean accept(    File dir,    String name){
      return name.toLowerCase().matches(""String_Node_Str"");
    }
  }
);
  Arrays.sort(workingFiles,new Comparator<File>(){
    @Override public int compare(    File f1,    File f2){
      return f1.getName().compareTo(f2.getName());
    }
  }
);
  return workingFiles;
}",0.9427972446840373
112391,"public void clear(){
  rowKeyToRowMutationState.clear();
}","public void clear(){
  rowKeyToRowMutationState.clear();
  estimatedSize=0;
}",0.8592592592592593
112392,"/** 
 * Test writing edits into an region, closing it, splitting logs, opening Region again. Verify seqids.
 * @throws Exception on failure
 */
@Test public void testReplayEditsWrittenViaHRegion() throws Exception {
  final String tableNameStr=""String_Node_Str"";
  final RegionInfo hri=RegionInfoBuilder.newBuilder(org.apache.hadoop.hbase.TableName.valueOf(tableNameStr)).setSplit(false).build();
  final Path basedir=FSUtils.getTableDir(hbaseRootDir,org.apache.hadoop.hbase.TableName.valueOf(tableNameStr));
  deleteDir(basedir);
  final TableDescriptor htd=createBasic3FamilyHTD(tableNameStr);
  byte[] family=new byte[]{'a'};
  ColumnGroup fam1=new ColumnGroup(INDEX_TABLE_NAME);
  fam1.add(new CoveredColumn(family,CoveredColumn.ALL_QUALIFIERS));
  CoveredColumnIndexSpecifierBuilder builder=new CoveredColumnIndexSpecifierBuilder();
  builder.addIndexGroup(fam1);
  builder.build(htd);
  WALFactory walFactory=new WALFactory(this.conf,null,""String_Node_Str"");
  WAL wal=createWAL(this.conf,walFactory);
  HRegion region0=HRegion.createHRegion(hri,hbaseRootDir,this.conf,htd,wal);
  region0.close();
  region0.getWAL().close();
  HRegionServer mockRS=Mockito.mock(HRegionServer.class);
  when(mockRS.getWAL(null)).thenReturn(wal);
  RegionServerAccounting rsa=Mockito.mock(RegionServerAccounting.class);
  when(mockRS.getRegionServerAccounting()).thenReturn(rsa);
  ServerName mockServerName=Mockito.mock(ServerName.class);
  when(mockServerName.getServerName()).thenReturn(tableNameStr + ""String_Node_Str"");
  when(mockRS.getServerName()).thenReturn(mockServerName);
  HRegion region=spy(new HRegion(basedir,wal,this.fs,this.conf,hri,htd,mockRS));
  region.initialize();
  byte[] rowkey=Bytes.toBytes(""String_Node_Str"");
  Put p=new Put(rowkey);
  p.addColumn(family,Bytes.toBytes(""String_Node_Str""),Bytes.toBytes(""String_Node_Str""));
  region.put(p);
  Mockito.verify(mockRS,Mockito.times(1)).abort(Mockito.anyString(),Mockito.any(Exception.class));
  TestIndexManagementUtil.createIndexTable(UTIL.getAdmin(),INDEX_TABLE_NAME);
  runWALSplit(this.conf,walFactory);
  WAL wal2=createWAL(this.conf,walFactory);
  HRegion region1=new HRegion(basedir,wal2,this.fs,this.conf,hri,htd,mockRS);
  region1.initialize();
  org.apache.hadoop.hbase.client.Connection hbaseConn=ConnectionFactory.createConnection(UTIL.getConfiguration());
  Table index=hbaseConn.getTable(org.apache.hadoop.hbase.TableName.valueOf(INDEX_TABLE_NAME));
  int indexSize=getKeyValueCount(index);
  assertEquals(""String_Node_Str"",1,indexSize);
  Get g=new Get(rowkey);
  final Result result=region1.get(g);
  assertEquals(""String_Node_Str"",1,result.size());
  Admin admin=UTIL.getAdmin();
  admin.disableTable(TableName.valueOf(INDEX_TABLE_NAME));
  admin.deleteTable(TableName.valueOf(INDEX_TABLE_NAME));
  admin.close();
}","/** 
 * Test writing edits into an region, closing it, splitting logs, opening Region again. Verify seqids.
 * @throws Exception on failure
 */
@Test public void testReplayEditsWrittenViaHRegion() throws Exception {
  final String tableNameStr=""String_Node_Str"";
  final RegionInfo hri=RegionInfoBuilder.newBuilder(org.apache.hadoop.hbase.TableName.valueOf(tableNameStr)).setSplit(false).build();
  final Path basedir=FSUtils.getTableDir(hbaseRootDir,org.apache.hadoop.hbase.TableName.valueOf(tableNameStr));
  deleteDir(basedir);
  final TableDescriptor htd=createBasic3FamilyHTD(tableNameStr);
  byte[] family=new byte[]{'a'};
  ColumnGroup fam1=new ColumnGroup(INDEX_TABLE_NAME);
  fam1.add(new CoveredColumn(family,CoveredColumn.ALL_QUALIFIERS));
  CoveredColumnIndexSpecifierBuilder builder=new CoveredColumnIndexSpecifierBuilder();
  builder.addIndexGroup(fam1);
  builder.build(htd);
  WALFactory walFactory=new WALFactory(this.conf,""String_Node_Str"");
  WAL wal=createWAL(this.conf,walFactory);
  HRegion region0=HRegion.createHRegion(hri,hbaseRootDir,this.conf,htd,wal);
  region0.close();
  region0.getWAL().close();
  HRegionServer mockRS=Mockito.mock(HRegionServer.class);
  when(mockRS.getWAL(null)).thenReturn(wal);
  RegionServerAccounting rsa=Mockito.mock(RegionServerAccounting.class);
  when(mockRS.getRegionServerAccounting()).thenReturn(rsa);
  ServerName mockServerName=Mockito.mock(ServerName.class);
  when(mockServerName.getServerName()).thenReturn(tableNameStr + ""String_Node_Str"");
  when(mockRS.getServerName()).thenReturn(mockServerName);
  HRegion region=spy(new HRegion(basedir,wal,this.fs,this.conf,hri,htd,mockRS));
  region.initialize();
  byte[] rowkey=Bytes.toBytes(""String_Node_Str"");
  Put p=new Put(rowkey);
  p.addColumn(family,Bytes.toBytes(""String_Node_Str""),Bytes.toBytes(""String_Node_Str""));
  region.put(p);
  Mockito.verify(mockRS,Mockito.times(1)).abort(Mockito.anyString(),Mockito.any(Exception.class));
  TestIndexManagementUtil.createIndexTable(UTIL.getAdmin(),INDEX_TABLE_NAME);
  runWALSplit(this.conf,walFactory);
  WAL wal2=createWAL(this.conf,walFactory);
  HRegion region1=new HRegion(basedir,wal2,this.fs,this.conf,hri,htd,mockRS);
  region1.initialize();
  org.apache.hadoop.hbase.client.Connection hbaseConn=ConnectionFactory.createConnection(UTIL.getConfiguration());
  Table index=hbaseConn.getTable(org.apache.hadoop.hbase.TableName.valueOf(INDEX_TABLE_NAME));
  int indexSize=getKeyValueCount(index);
  assertEquals(""String_Node_Str"",1,indexSize);
  Get g=new Get(rowkey);
  final Result result=region1.get(g);
  assertEquals(""String_Node_Str"",1,result.size());
  Admin admin=UTIL.getAdmin();
  admin.disableTable(TableName.valueOf(INDEX_TABLE_NAME));
  admin.deleteTable(TableName.valueOf(INDEX_TABLE_NAME));
  admin.close();
}",0.999104744852283
112393,"private void commitBatch(Region region,List<Mutation> mutations,long blockingMemstoreSize) throws IOException {
  if (mutations.isEmpty()) {
    return;
  }
  Mutation[] mutationArray=new Mutation[mutations.size()];
  for (int i=0; region.getMemStoreSize() > blockingMemstoreSize && i < 30; i++) {
    try {
      checkForRegionClosing();
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new IOException(e);
    }
  }
  logger.debug(""String_Node_Str"" + mutations.size() + ""String_Node_Str""+ region.getRegionInfo().getTable().getNameAsString());
  region.batchMutate(mutations.toArray(mutationArray));
}","private void commitBatch(Region region,List<Mutation> mutations,long blockingMemstoreSize) throws IOException {
  if (mutations.isEmpty()) {
    return;
  }
  Mutation[] mutationArray=new Mutation[mutations.size()];
  for (int i=0; (region.getMemStoreHeapSize() + region.getMemStoreOffHeapSize()) > blockingMemstoreSize && i < 30; i++) {
    try {
      checkForRegionClosing();
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new IOException(e);
    }
  }
  logger.debug(""String_Node_Str"" + mutations.size() + ""String_Node_Str""+ region.getRegionInfo().getTable().getNameAsString());
  region.batchMutate(mutations.toArray(mutationArray));
}",0.971264367816092
112394,"@Override public WAL.Entry filter(WAL.Entry entry){
  if (!SchemaUtil.isMetaTable(entry.getKey().getTablename().getName())) {
    return entry;
  }
  List<Cell> cells=entry.getEdit().getCells();
  List<Cell> cellsToRemove=Lists.newArrayList();
  for (  Cell cell : cells) {
    if (!isTenantRowCell(cell)) {
      cellsToRemove.add(cell);
    }
  }
  cells.removeAll(cellsToRemove);
  if (cells.size() > 0) {
    return entry;
  }
 else {
    return null;
  }
}","@Override public WAL.Entry filter(WAL.Entry entry){
  if (!SchemaUtil.isMetaTable(entry.getKey().getTableName().getName())) {
    return entry;
  }
  List<Cell> cells=entry.getEdit().getCells();
  List<Cell> cellsToRemove=Lists.newArrayList();
  for (  Cell cell : cells) {
    if (!isTenantRowCell(cell)) {
      cellsToRemove.add(cell);
    }
  }
  cells.removeAll(cellsToRemove);
  if (cells.size() > 0) {
    return entry;
  }
 else {
    return null;
  }
}",0.9978308026030368
112395,"@SuppressWarnings(""String_Node_Str"") @Before public void setUp() throws Exception {
  Path hbaseRootDir=new Path(getClass().getSimpleName() + ""String_Node_Str"" + testName.getMethodName());
  TEST_UTIL.getConfiguration().set(""String_Node_Str"",hbaseRootDir.toString());
  FileSystem newFS=miniDfs.getFileSystem();
  RegionInfo hri=RegionInfoBuilder.newBuilder(tableName).setStartKey(null).setEndKey(null).setSplit(false).build();
  Path basedir=FSUtils.getTableDir(hbaseRootDir,tableName);
  Random rn=new Random();
  tableName=TableName.valueOf(""String_Node_Str"" + rn.nextInt());
  WALFactory walFactory=new WALFactory(TEST_UTIL.getConfiguration(),null,getClass().getSimpleName());
  wal=walFactory.getWAL(RegionInfoBuilder.newBuilder(TableName.valueOf(""String_Node_Str"")).build());
  TableDescriptor htd=TableDescriptorBuilder.newBuilder(tableName).addColumnFamily(ColumnFamilyDescriptorBuilder.newBuilder(Bytes.toBytes(""String_Node_Str"")).build()).build();
  r1=new HRegion(basedir,wal,newFS,TEST_UTIL.getConfiguration(),hri,htd,null){
    @Override public int hashCode(){
      return 1;
    }
    @Override public String toString(){
      return ""String_Node_Str"";
    }
  }
;
  r2=new HRegion(basedir,wal,newFS,TEST_UTIL.getConfiguration(),hri,htd,null){
    @Override public int hashCode(){
      return 2;
    }
    @Override public String toString(){
      return ""String_Node_Str"";
    }
  }
;
}","@SuppressWarnings(""String_Node_Str"") @Before public void setUp() throws Exception {
  Path hbaseRootDir=new Path(getClass().getSimpleName() + ""String_Node_Str"" + testName.getMethodName());
  TEST_UTIL.getConfiguration().set(""String_Node_Str"",hbaseRootDir.toString());
  FileSystem newFS=miniDfs.getFileSystem();
  RegionInfo hri=RegionInfoBuilder.newBuilder(tableName).setStartKey(null).setEndKey(null).setSplit(false).build();
  Path basedir=FSUtils.getTableDir(hbaseRootDir,tableName);
  Random rn=new Random();
  tableName=TableName.valueOf(""String_Node_Str"" + rn.nextInt());
  WALFactory walFactory=new WALFactory(TEST_UTIL.getConfiguration(),getClass().getSimpleName());
  wal=walFactory.getWAL(RegionInfoBuilder.newBuilder(TableName.valueOf(""String_Node_Str"")).build());
  TableDescriptor htd=TableDescriptorBuilder.newBuilder(tableName).addColumnFamily(ColumnFamilyDescriptorBuilder.newBuilder(Bytes.toBytes(""String_Node_Str"")).build()).build();
  r1=new HRegion(basedir,wal,newFS,TEST_UTIL.getConfiguration(),hri,htd,null){
    @Override public int hashCode(){
      return 1;
    }
    @Override public String toString(){
      return ""String_Node_Str"";
    }
  }
;
  r2=new HRegion(basedir,wal,newFS,TEST_UTIL.getConfiguration(),hri,htd,null){
    @Override public int hashCode(){
      return 2;
    }
    @Override public String toString(){
      return ""String_Node_Str"";
    }
  }
;
}",0.9982149232416994
112396,"@Override public RegionScanner preScannerOpen(final ObserverContext<RegionCoprocessorEnvironment> c,final Scan scan,final RegionScanner s) throws IOException {
  byte[] txnScn=scan.getAttribute(TX_SCN);
  if (txnScn != null) {
    TimeRange timeRange=scan.getTimeRange();
    scan.setTimeRange(timeRange.getMin(),Bytes.toLong(txnScn));
  }
  if (isRegionObserverFor(scan)) {
    if (!skipRegionBoundaryCheck(scan) || ScanUtil.isLocalIndex(scan)) {
      throwIfScanOutOfRegion(scan,c.getEnvironment().getRegion());
    }
    ScanUtil.setupReverseScan(scan);
  }
  this.encodingScheme=EncodedColumnsUtil.getQualifierEncodingScheme(scan);
  this.useNewValueColumnQualifier=EncodedColumnsUtil.useNewValueColumnQualifier(scan);
  return s;
}","@Override public void preScannerOpen(org.apache.hadoop.hbase.coprocessor.ObserverContext<RegionCoprocessorEnvironment> c,Scan scan) throws IOException {
  byte[] txnScn=scan.getAttribute(TX_SCN);
  if (txnScn != null) {
    TimeRange timeRange=scan.getTimeRange();
    scan.setTimeRange(timeRange.getMin(),Bytes.toLong(txnScn));
  }
  if (isRegionObserverFor(scan)) {
    if (!skipRegionBoundaryCheck(scan) || ScanUtil.isLocalIndex(scan)) {
      throwIfScanOutOfRegion(scan,c.getEnvironment().getRegion());
    }
    ScanUtil.setupReverseScan(scan);
  }
  this.encodingScheme=EncodedColumnsUtil.getQualifierEncodingScheme(scan);
  this.useNewValueColumnQualifier=EncodedColumnsUtil.useNewValueColumnQualifier(scan);
}",0.9195876288659792
112397,"@Override public InternalScanner preFlush(ObserverContext<RegionCoprocessorEnvironment> c,Store store,InternalScanner scanner) throws IOException {
  return delegate.preFlush(c,store,scanner);
}","@Override public InternalScanner preFlush(org.apache.hadoop.hbase.coprocessor.ObserverContext<RegionCoprocessorEnvironment> c,Store store,InternalScanner scanner,org.apache.hadoop.hbase.regionserver.FlushLifeCycleTracker tracker) throws IOException {
  return delegate.preFlush(c,store,scanner,tracker);
}",0.7775551102204409
112398,"@Override public RegionScanner preScannerOpen(ObserverContext<RegionCoprocessorEnvironment> c,Scan scan,RegionScanner s) throws IOException {
  return delegate.preScannerOpen(c,scan,s);
}","@Override public void preScannerOpen(org.apache.hadoop.hbase.coprocessor.ObserverContext<RegionCoprocessorEnvironment> c,Scan scan) throws IOException {
  delegate.preScannerOpen(c,scan);
}",0.7978723404255319
112399,"@Override public void postFlush(ObserverContext<RegionCoprocessorEnvironment> c,Store store,StoreFile resultFile) throws IOException {
  delegate.postFlush(c,store,resultFile);
}","@Override public void postFlush(org.apache.hadoop.hbase.coprocessor.ObserverContext<RegionCoprocessorEnvironment> c,Store store,StoreFile resultFile,org.apache.hadoop.hbase.regionserver.FlushLifeCycleTracker tracker) throws IOException {
  delegate.postFlush(c,store,resultFile,tracker);
}",0.7623126338329764
112400,"@Override public HRegionInfo getRegionInfo(){
  return scanner.getRegionInfo();
}","@Override public RegionInfo getRegionInfo(){
  return scanner.getRegionInfo();
}",0.9937888198757764
112401,"private RegionScanner collectStats(final RegionScanner innerScanner,StatisticsCollector stats,final Region region,final Scan scan,Configuration config) throws IOException {
  StatsCollectionCallable callable=new StatsCollectionCallable(stats,region,innerScanner,config,scan);
  byte[] asyncBytes=scan.getAttribute(BaseScannerRegionObserver.RUN_UPDATE_STATS_ASYNC_ATTRIB);
  boolean async=false;
  if (asyncBytes != null) {
    async=Bytes.toBoolean(asyncBytes);
  }
  long rowCount=0;
  StatisticsCollectionRunTracker statsRunTracker=StatisticsCollectionRunTracker.getInstance(config);
  boolean runUpdateStats=statsRunTracker.addUpdateStatsCommandRegion(region.getRegionInfo());
  if (runUpdateStats) {
    if (!async) {
      rowCount=callable.call();
    }
 else {
      statsRunTracker.runTask(callable);
    }
  }
 else {
    rowCount=CONCURRENT_UPDATE_STATS_ROW_COUNT;
    logger.info(""String_Node_Str"" + region.getRegionInfo().getRegionNameAsString());
  }
  byte[] rowCountBytes=PLong.INSTANCE.toBytes(Long.valueOf(rowCount));
  final Cell aggKeyValue=PhoenixKeyValueUtil.newKeyValue(UNGROUPED_AGG_ROW_KEY,SINGLE_COLUMN_FAMILY,SINGLE_COLUMN,AGG_TIMESTAMP,rowCountBytes,0,rowCountBytes.length);
  RegionScanner scanner=new BaseRegionScanner(innerScanner){
    @Override public HRegionInfo getRegionInfo(){
      return region.getRegionInfo();
    }
    @Override public boolean isFilterDone(){
      return true;
    }
    @Override public void close() throws IOException {
    }
    @Override public boolean next(    List<Cell> results) throws IOException {
      results.add(aggKeyValue);
      return false;
    }
    @Override public long getMaxResultSize(){
      return scan.getMaxResultSize();
    }
  }
;
  return scanner;
}","private RegionScanner collectStats(final RegionScanner innerScanner,StatisticsCollector stats,final Region region,final Scan scan,Configuration config) throws IOException {
  StatsCollectionCallable callable=new StatsCollectionCallable(stats,region,innerScanner,config,scan);
  byte[] asyncBytes=scan.getAttribute(BaseScannerRegionObserver.RUN_UPDATE_STATS_ASYNC_ATTRIB);
  boolean async=false;
  if (asyncBytes != null) {
    async=Bytes.toBoolean(asyncBytes);
  }
  long rowCount=0;
  StatisticsCollectionRunTracker statsRunTracker=StatisticsCollectionRunTracker.getInstance(config);
  boolean runUpdateStats=statsRunTracker.addUpdateStatsCommandRegion(region.getRegionInfo());
  if (runUpdateStats) {
    if (!async) {
      rowCount=callable.call();
    }
 else {
      statsRunTracker.runTask(callable);
    }
  }
 else {
    rowCount=CONCURRENT_UPDATE_STATS_ROW_COUNT;
    logger.info(""String_Node_Str"" + region.getRegionInfo().getRegionNameAsString());
  }
  byte[] rowCountBytes=PLong.INSTANCE.toBytes(Long.valueOf(rowCount));
  final Cell aggKeyValue=PhoenixKeyValueUtil.newKeyValue(UNGROUPED_AGG_ROW_KEY,SINGLE_COLUMN_FAMILY,SINGLE_COLUMN,AGG_TIMESTAMP,rowCountBytes,0,rowCountBytes.length);
  RegionScanner scanner=new BaseRegionScanner(innerScanner){
    @Override public RegionInfo getRegionInfo(){
      return region.getRegionInfo();
    }
    @Override public boolean isFilterDone(){
      return true;
    }
    @Override public void close() throws IOException {
    }
    @Override public boolean next(    List<Cell> results) throws IOException {
      results.add(aggKeyValue);
      return false;
    }
    @Override public long getMaxResultSize(){
      return scan.getMaxResultSize();
    }
  }
;
  return scanner;
}",0.999712395743457
112402,"private boolean areMutationsInSameTable(Table targetHTable,Region region){
  return (targetHTable == null || Bytes.compareTo(targetHTable.getName(),region.getTableDesc().getTableName().getName()) == 0);
}","private boolean areMutationsInSameTable(Table targetHTable,Region region){
  return (targetHTable == null || Bytes.compareTo(targetHTable.getName().getName(),region.getTableDescriptor().getTableName().getName()) == 0);
}",0.9622641509433962
112403,"@Override public RegionScanner preScannerOpen(ObserverContext<RegionCoprocessorEnvironment> e,Scan scan,RegionScanner s) throws IOException {
  s=super.preScannerOpen(e,scan,s);
  if (ScanUtil.isAnalyzeTable(scan)) {
    scan.setStartRow(HConstants.EMPTY_START_ROW);
    scan.setStopRow(HConstants.EMPTY_END_ROW);
    scan.setFilter(null);
  }
  return s;
}","@Override public void preScannerOpen(org.apache.hadoop.hbase.coprocessor.ObserverContext<RegionCoprocessorEnvironment> c,Scan scan) throws IOException {
  if (ScanUtil.isAnalyzeTable(scan)) {
    scan.withStartRow(HConstants.EMPTY_START_ROW);
    scan.withStopRow(HConstants.EMPTY_END_ROW);
    scan.setFilter(null);
  }
}",0.7569955817378498
112404,"private void separateLocalAndRemoteMutations(Table targetHTable,Region region,List<Mutation> mutations,List<Mutation> localRegionMutations,List<Mutation> remoteRegionMutations,boolean isPKChanging){
  boolean areMutationsInSameTable=areMutationsInSameTable(targetHTable,region);
  if (areMutationsInSameTable && isPKChanging) {
    HRegionInfo regionInfo=region.getRegionInfo();
    for (    Mutation mutation : mutations) {
      if (regionInfo.containsRow(mutation.getRow())) {
        localRegionMutations.add(mutation);
      }
 else {
        remoteRegionMutations.add(mutation);
      }
    }
  }
 else   if (areMutationsInSameTable && !isPKChanging) {
    localRegionMutations.addAll(mutations);
  }
 else {
    remoteRegionMutations.addAll(mutations);
  }
}","private void separateLocalAndRemoteMutations(Table targetHTable,Region region,List<Mutation> mutations,List<Mutation> localRegionMutations,List<Mutation> remoteRegionMutations,boolean isPKChanging){
  boolean areMutationsInSameTable=areMutationsInSameTable(targetHTable,region);
  if (areMutationsInSameTable && isPKChanging) {
    RegionInfo regionInfo=region.getRegionInfo();
    for (    Mutation mutation : mutations) {
      if (regionInfo.containsRow(mutation.getRow())) {
        localRegionMutations.add(mutation);
      }
 else {
        remoteRegionMutations.add(mutation);
      }
    }
  }
 else   if (areMutationsInSameTable && !isPKChanging) {
    localRegionMutations.addAll(mutations);
  }
 else {
    remoteRegionMutations.addAll(mutations);
  }
}",0.999345977763244
112405,"@Override public HRegionInfo getRegionInfo(){
  return region.getRegionInfo();
}","@Override public RegionInfo getRegionInfo(){
  return region.getRegionInfo();
}",0.9937106918238994
112406,"private RegionScanner rebuildIndices(final RegionScanner innerScanner,final Region region,final Scan scan,Configuration config) throws IOException {
  byte[] indexMetaData=scan.getAttribute(PhoenixIndexCodec.INDEX_PROTO_MD);
  boolean useProto=true;
  if (indexMetaData == null) {
    useProto=false;
    indexMetaData=scan.getAttribute(PhoenixIndexCodec.INDEX_MD);
  }
  boolean hasMore;
  int rowCount=0;
  try {
    int maxBatchSize=config.getInt(MUTATE_BATCH_SIZE_ATTRIB,QueryServicesOptions.DEFAULT_MUTATE_BATCH_SIZE);
    long maxBatchSizeBytes=config.getLong(MUTATE_BATCH_SIZE_BYTES_ATTRIB,QueryServicesOptions.DEFAULT_MUTATE_BATCH_SIZE_BYTES);
    MutationList mutations=new MutationList(maxBatchSize);
    region.startRegionOperation();
    byte[] uuidValue=ServerCacheClient.generateId();
synchronized (innerScanner) {
      do {
        List<Cell> results=new ArrayList<Cell>();
        hasMore=innerScanner.nextRaw(results);
        if (!results.isEmpty()) {
          Put put=null;
          Delete del=null;
          for (          Cell cell : results) {
            if (KeyValue.Type.codeToType(cell.getTypeByte()) == KeyValue.Type.Put) {
              if (put == null) {
                put=new Put(CellUtil.cloneRow(cell));
                put.setAttribute(useProto ? PhoenixIndexCodec.INDEX_PROTO_MD : PhoenixIndexCodec.INDEX_MD,indexMetaData);
                put.setAttribute(PhoenixIndexCodec.INDEX_UUID,uuidValue);
                put.setAttribute(REPLAY_WRITES,REPLAY_ONLY_INDEX_WRITES);
                mutations.add(put);
                put.setDurability(Durability.SKIP_WAL);
              }
              put.add(cell);
            }
 else {
              if (del == null) {
                del=new Delete(CellUtil.cloneRow(cell));
                del.setAttribute(useProto ? PhoenixIndexCodec.INDEX_PROTO_MD : PhoenixIndexCodec.INDEX_MD,indexMetaData);
                del.setAttribute(PhoenixIndexCodec.INDEX_UUID,uuidValue);
                del.setAttribute(REPLAY_WRITES,REPLAY_ONLY_INDEX_WRITES);
                mutations.add(del);
                del.setDurability(Durability.SKIP_WAL);
              }
              del.addDeleteMarker(cell);
            }
          }
          if (ServerUtil.readyToCommit(mutations.size(),mutations.byteSize(),maxBatchSize,maxBatchSizeBytes)) {
            region.batchMutate(mutations.toArray(new Mutation[mutations.size()]));
            uuidValue=ServerCacheClient.generateId();
            mutations.clear();
          }
          rowCount++;
        }
      }
 while (hasMore);
      if (!mutations.isEmpty()) {
        region.batchMutate(mutations.toArray(new Mutation[mutations.size()]));
      }
    }
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"" + Throwables.getStackTraceAsString(e));
    throw e;
  }
 finally {
    region.closeRegionOperation();
  }
  byte[] rowCountBytes=PLong.INSTANCE.toBytes(Long.valueOf(rowCount));
  final Cell aggKeyValue=PhoenixKeyValueUtil.newKeyValue(UNGROUPED_AGG_ROW_KEY,SINGLE_COLUMN_FAMILY,SINGLE_COLUMN,AGG_TIMESTAMP,rowCountBytes,0,rowCountBytes.length);
  RegionScanner scanner=new BaseRegionScanner(innerScanner){
    @Override public HRegionInfo getRegionInfo(){
      return region.getRegionInfo();
    }
    @Override public boolean isFilterDone(){
      return true;
    }
    @Override public void close() throws IOException {
      innerScanner.close();
    }
    @Override public boolean next(    List<Cell> results) throws IOException {
      results.add(aggKeyValue);
      return false;
    }
    @Override public long getMaxResultSize(){
      return scan.getMaxResultSize();
    }
  }
;
  return scanner;
}","private RegionScanner rebuildIndices(final RegionScanner innerScanner,final Region region,final Scan scan,Configuration config) throws IOException {
  byte[] indexMetaData=scan.getAttribute(PhoenixIndexCodec.INDEX_PROTO_MD);
  boolean useProto=true;
  if (indexMetaData == null) {
    useProto=false;
    indexMetaData=scan.getAttribute(PhoenixIndexCodec.INDEX_MD);
  }
  boolean hasMore;
  int rowCount=0;
  try {
    int maxBatchSize=config.getInt(MUTATE_BATCH_SIZE_ATTRIB,QueryServicesOptions.DEFAULT_MUTATE_BATCH_SIZE);
    long maxBatchSizeBytes=config.getLong(MUTATE_BATCH_SIZE_BYTES_ATTRIB,QueryServicesOptions.DEFAULT_MUTATE_BATCH_SIZE_BYTES);
    MutationList mutations=new MutationList(maxBatchSize);
    region.startRegionOperation();
    byte[] uuidValue=ServerCacheClient.generateId();
synchronized (innerScanner) {
      do {
        List<Cell> results=new ArrayList<Cell>();
        hasMore=innerScanner.nextRaw(results);
        if (!results.isEmpty()) {
          Put put=null;
          Delete del=null;
          for (          Cell cell : results) {
            if (KeyValue.Type.codeToType(cell.getTypeByte()) == KeyValue.Type.Put) {
              if (put == null) {
                put=new Put(CellUtil.cloneRow(cell));
                put.setAttribute(useProto ? PhoenixIndexCodec.INDEX_PROTO_MD : PhoenixIndexCodec.INDEX_MD,indexMetaData);
                put.setAttribute(PhoenixIndexCodec.INDEX_UUID,uuidValue);
                put.setAttribute(REPLAY_WRITES,REPLAY_ONLY_INDEX_WRITES);
                mutations.add(put);
                put.setDurability(Durability.SKIP_WAL);
              }
              put.add(cell);
            }
 else {
              if (del == null) {
                del=new Delete(CellUtil.cloneRow(cell));
                del.setAttribute(useProto ? PhoenixIndexCodec.INDEX_PROTO_MD : PhoenixIndexCodec.INDEX_MD,indexMetaData);
                del.setAttribute(PhoenixIndexCodec.INDEX_UUID,uuidValue);
                del.setAttribute(REPLAY_WRITES,REPLAY_ONLY_INDEX_WRITES);
                mutations.add(del);
                del.setDurability(Durability.SKIP_WAL);
              }
              del.addDeleteMarker(cell);
            }
          }
          if (ServerUtil.readyToCommit(mutations.size(),mutations.byteSize(),maxBatchSize,maxBatchSizeBytes)) {
            region.batchMutate(mutations.toArray(new Mutation[mutations.size()]));
            uuidValue=ServerCacheClient.generateId();
            mutations.clear();
          }
          rowCount++;
        }
      }
 while (hasMore);
      if (!mutations.isEmpty()) {
        region.batchMutate(mutations.toArray(new Mutation[mutations.size()]));
      }
    }
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"" + Throwables.getStackTraceAsString(e));
    throw e;
  }
 finally {
    region.closeRegionOperation();
  }
  byte[] rowCountBytes=PLong.INSTANCE.toBytes(Long.valueOf(rowCount));
  final Cell aggKeyValue=PhoenixKeyValueUtil.newKeyValue(UNGROUPED_AGG_ROW_KEY,SINGLE_COLUMN_FAMILY,SINGLE_COLUMN,AGG_TIMESTAMP,rowCountBytes,0,rowCountBytes.length);
  RegionScanner scanner=new BaseRegionScanner(innerScanner){
    @Override public RegionInfo getRegionInfo(){
      return region.getRegionInfo();
    }
    @Override public boolean isFilterDone(){
      return true;
    }
    @Override public void close() throws IOException {
      innerScanner.close();
    }
    @Override public boolean next(    List<Cell> results) throws IOException {
      results.add(aggKeyValue);
      return false;
    }
    @Override public long getMaxResultSize(){
      return scan.getMaxResultSize();
    }
  }
;
  return scanner;
}",0.999863331966653
112407,"private void checkForLocalIndexColumnFamilies(Region region,List<IndexMaintainer> indexMaintainers) throws IOException {
  HTableDescriptor tableDesc=region.getTableDesc();
  String schemaName=tableDesc.getTableName().getNamespaceAsString().equals(NamespaceDescriptor.DEFAULT_NAMESPACE_NAME_STR) ? SchemaUtil.getSchemaNameFromFullName(tableDesc.getTableName().getNameAsString()) : tableDesc.getTableName().getNamespaceAsString();
  String tableName=SchemaUtil.getTableNameFromFullName(tableDesc.getTableName().getNameAsString());
  for (  IndexMaintainer indexMaintainer : indexMaintainers) {
    Set<ColumnReference> coveredColumns=indexMaintainer.getCoveredColumns();
    if (coveredColumns.isEmpty()) {
      byte[] localIndexCf=indexMaintainer.getEmptyKeyValueFamily().get();
      if (tableDesc.getFamily(localIndexCf) == null) {
        ServerUtil.throwIOException(""String_Node_Str"",new ColumnFamilyNotFoundException(schemaName,tableName,Bytes.toString(localIndexCf)));
      }
    }
    for (    ColumnReference reference : coveredColumns) {
      byte[] cf=IndexUtil.getLocalIndexColumnFamily(reference.getFamily());
      HColumnDescriptor family=region.getTableDesc().getFamily(cf);
      if (family == null) {
        ServerUtil.throwIOException(""String_Node_Str"",new ColumnFamilyNotFoundException(schemaName,tableName,Bytes.toString(cf)));
      }
    }
  }
}","private void checkForLocalIndexColumnFamilies(Region region,List<IndexMaintainer> indexMaintainers) throws IOException {
  TableDescriptor tableDesc=region.getTableDescriptor();
  String schemaName=tableDesc.getTableName().getNamespaceAsString().equals(NamespaceDescriptor.DEFAULT_NAMESPACE_NAME_STR) ? SchemaUtil.getSchemaNameFromFullName(tableDesc.getTableName().getNameAsString()) : tableDesc.getTableName().getNamespaceAsString();
  String tableName=SchemaUtil.getTableNameFromFullName(tableDesc.getTableName().getNameAsString());
  for (  IndexMaintainer indexMaintainer : indexMaintainers) {
    Set<ColumnReference> coveredColumns=indexMaintainer.getCoveredColumns();
    if (coveredColumns.isEmpty()) {
      byte[] localIndexCf=indexMaintainer.getEmptyKeyValueFamily().get();
      if (tableDesc.getColumnFamily(localIndexCf) == null) {
        ServerUtil.throwIOException(""String_Node_Str"",new ColumnFamilyNotFoundException(schemaName,tableName,Bytes.toString(localIndexCf)));
      }
    }
    for (    ColumnReference reference : coveredColumns) {
      byte[] cf=IndexUtil.getLocalIndexColumnFamily(reference.getFamily());
      ColumnFamilyDescriptor family=region.getTableDescriptor().getColumnFamily(cf);
      if (family == null) {
        ServerUtil.throwIOException(""String_Node_Str"",new ColumnFamilyNotFoundException(schemaName,tableName,Bytes.toString(cf)));
      }
    }
  }
}",0.9797833935018052
112408,"private void initGuidepostDepth() throws IOException, ClassNotFoundException, SQLException {
  if (guidePostPerRegionBytes != null || guidePostWidthBytes != null) {
    int guidepostPerRegion=0;
    long guidepostWidth=QueryServicesOptions.DEFAULT_STATS_GUIDEPOST_WIDTH_BYTES;
    if (guidePostPerRegionBytes != null) {
      guidepostPerRegion=PInteger.INSTANCE.getCodec().decodeInt(guidePostPerRegionBytes,0,SortOrder.getDefault());
    }
    if (guidePostWidthBytes != null) {
      guidepostWidth=PLong.INSTANCE.getCodec().decodeInt(guidePostWidthBytes,0,SortOrder.getDefault());
    }
    this.guidePostDepth=StatisticsUtil.getGuidePostDepth(guidepostPerRegion,guidepostWidth,env.getRegion().getTableDesc());
  }
 else {
    long guidepostWidth=-1;
    Table htable=null;
    try {
      htable=env.getConnection().getTable(SchemaUtil.getPhysicalTableName(PhoenixDatabaseMetaData.SYSTEM_CATALOG_NAME_BYTES,env.getConfiguration()));
      Get get=new Get(ptableKey);
      get.addColumn(PhoenixDatabaseMetaData.TABLE_FAMILY_BYTES,PhoenixDatabaseMetaData.GUIDE_POSTS_WIDTH_BYTES);
      Result result=htable.get(get);
      if (!result.isEmpty()) {
        Cell cell=result.listCells().get(0);
        guidepostWidth=PLong.INSTANCE.getCodec().decodeLong(cell.getValueArray(),cell.getValueOffset(),SortOrder.getDefault());
      }
 else       if (!isViewIndexTable) {
        try (Connection conn=QueryUtil.getConnectionOnServer(env.getConfiguration())){
          PTable table=PhoenixRuntime.getTable(conn,tableName);
          if (table.getType() == PTableType.INDEX && table.getIndexType() == IndexType.GLOBAL) {
            PName parentName=table.getParentName();
            byte[] parentKey=SchemaUtil.getTableKeyFromFullName(parentName.getString());
            get=new Get(parentKey);
            get.addColumn(PhoenixDatabaseMetaData.TABLE_FAMILY_BYTES,PhoenixDatabaseMetaData.GUIDE_POSTS_WIDTH_BYTES);
            result=htable.get(get);
            if (!result.isEmpty()) {
              Cell cell=result.listCells().get(0);
              guidepostWidth=PLong.INSTANCE.getCodec().decodeLong(cell.getValueArray(),cell.getValueOffset(),SortOrder.getDefault());
            }
          }
        }
       }
    }
  finally {
      if (htable != null) {
        try {
          htable.close();
        }
 catch (        IOException e) {
          LOG.warn(""String_Node_Str"" + htable.getName(),e);
        }
      }
    }
    if (guidepostWidth >= 0) {
      this.guidePostDepth=guidepostWidth;
    }
 else {
      Configuration config=env.getConfiguration();
      this.guidePostDepth=StatisticsUtil.getGuidePostDepth(config.getInt(QueryServices.STATS_GUIDEPOST_PER_REGION_ATTRIB,QueryServicesOptions.DEFAULT_STATS_GUIDEPOST_PER_REGION),config.getLong(QueryServices.STATS_GUIDEPOST_WIDTH_BYTES_ATTRIB,QueryServicesOptions.DEFAULT_STATS_GUIDEPOST_WIDTH_BYTES),env.getRegion().getTableDesc());
    }
  }
}","private void initGuidepostDepth() throws IOException, ClassNotFoundException, SQLException {
  if (guidePostPerRegionBytes != null || guidePostWidthBytes != null) {
    int guidepostPerRegion=0;
    long guidepostWidth=QueryServicesOptions.DEFAULT_STATS_GUIDEPOST_WIDTH_BYTES;
    if (guidePostPerRegionBytes != null) {
      guidepostPerRegion=PInteger.INSTANCE.getCodec().decodeInt(guidePostPerRegionBytes,0,SortOrder.getDefault());
    }
    if (guidePostWidthBytes != null) {
      guidepostWidth=PLong.INSTANCE.getCodec().decodeInt(guidePostWidthBytes,0,SortOrder.getDefault());
    }
    this.guidePostDepth=StatisticsUtil.getGuidePostDepth(guidepostPerRegion,guidepostWidth,env.getRegion().getTableDescriptor());
  }
 else {
    long guidepostWidth=-1;
    Table htable=null;
    try {
      htable=env.getConnection().getTable(SchemaUtil.getPhysicalTableName(PhoenixDatabaseMetaData.SYSTEM_CATALOG_NAME_BYTES,env.getConfiguration()));
      Get get=new Get(ptableKey);
      get.addColumn(PhoenixDatabaseMetaData.TABLE_FAMILY_BYTES,PhoenixDatabaseMetaData.GUIDE_POSTS_WIDTH_BYTES);
      Result result=htable.get(get);
      if (!result.isEmpty()) {
        Cell cell=result.listCells().get(0);
        guidepostWidth=PLong.INSTANCE.getCodec().decodeLong(cell.getValueArray(),cell.getValueOffset(),SortOrder.getDefault());
      }
 else       if (!isViewIndexTable) {
        try (Connection conn=QueryUtil.getConnectionOnServer(env.getConfiguration())){
          PTable table=PhoenixRuntime.getTable(conn,tableName);
          if (table.getType() == PTableType.INDEX && table.getIndexType() == IndexType.GLOBAL) {
            PName parentName=table.getParentName();
            byte[] parentKey=SchemaUtil.getTableKeyFromFullName(parentName.getString());
            get=new Get(parentKey);
            get.addColumn(PhoenixDatabaseMetaData.TABLE_FAMILY_BYTES,PhoenixDatabaseMetaData.GUIDE_POSTS_WIDTH_BYTES);
            result=htable.get(get);
            if (!result.isEmpty()) {
              Cell cell=result.listCells().get(0);
              guidepostWidth=PLong.INSTANCE.getCodec().decodeLong(cell.getValueArray(),cell.getValueOffset(),SortOrder.getDefault());
            }
          }
        }
       }
    }
  finally {
      if (htable != null) {
        try {
          htable.close();
        }
 catch (        IOException e) {
          LOG.warn(""String_Node_Str"" + htable.getName(),e);
        }
      }
    }
    if (guidepostWidth >= 0) {
      this.guidePostDepth=guidepostWidth;
    }
 else {
      Configuration config=env.getConfiguration();
      this.guidePostDepth=StatisticsUtil.getGuidePostDepth(config.getInt(QueryServices.STATS_GUIDEPOST_PER_REGION_ATTRIB,QueryServicesOptions.DEFAULT_STATS_GUIDEPOST_PER_REGION),config.getLong(QueryServices.STATS_GUIDEPOST_WIDTH_BYTES_ATTRIB,QueryServicesOptions.DEFAULT_STATS_GUIDEPOST_WIDTH_BYTES),env.getRegion().getTableDescriptor());
    }
  }
}",0.997943797121316
112409,"@Override public InternalScanner createCompactionScanner(RegionCoprocessorEnvironment env,Store store,InternalScanner s) throws IOException {
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"");
  }
  ImmutableBytesPtr cfKey=new ImmutableBytesPtr(store.getFamily().getName());
  init();
  StatisticsScanner scanner=new StatisticsScanner(this,statsWriter,env,s,cfKey);
  return scanner;
}","@Override public InternalScanner createCompactionScanner(RegionCoprocessorEnvironment env,Store store,InternalScanner s) throws IOException {
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"");
  }
  ImmutableBytesPtr cfKey=new ImmutableBytesPtr(store.getColumnFamilyDescriptor().getName());
  init();
  StatisticsScanner scanner=new StatisticsScanner(this,statsWriter,env,s,cfKey);
  return scanner;
}",0.9805825242718448
112410,"public MutationState(TableRef table,Map<ImmutableBytesPtr,RowMutationState> mutations,long sizeOffset,long maxSize,long maxSizeBytes,PhoenixConnection connection) throws SQLException {
  this(maxSize,maxSizeBytes,connection,false,null,sizeOffset);
  if (!mutations.isEmpty()) {
    this.mutations.put(table,mutations);
  }
  this.numRows=mutations.size();
  this.estimatedSize=KeyValueUtil.getEstimatedRowSize(table,mutations);
  throwIfTooBig();
}","public MutationState(TableRef table,Map<ImmutableBytesPtr,RowMutationState> mutations,long sizeOffset,long maxSize,long maxSizeBytes,PhoenixConnection connection) throws SQLException {
  this(maxSize,maxSizeBytes,connection,false,null,sizeOffset);
  if (!mutations.isEmpty()) {
    this.mutations.put(table,mutations);
  }
  this.numRows=mutations.size();
  this.estimatedSize=PhoenixKeyValueUtil.getEstimatedRowSize(table,mutations);
  throwIfTooBig();
}",0.992248062015504
112411,"@Override public void start(CoprocessorEnvironment e) throws IOException {
  try {
    final RegionCoprocessorEnvironment env=(RegionCoprocessorEnvironment)e;
    String serverName=env.getServerName().getServerName();
    if (env.getConfiguration().getBoolean(CHECK_VERSION_CONF_KEY,true)) {
      String errormsg=Indexer.validateVersion(env.getHBaseVersion(),env.getConfiguration());
      if (errormsg != null) {
        IOException ioe=new IOException(errormsg);
        env.getRegionServerServices().abort(errormsg,ioe);
        throw ioe;
      }
    }
    this.builder=new IndexBuildManager(env);
    Configuration clonedConfig=PropertiesUtil.cloneConfig(e.getConfiguration());
    clonedConfig.setClass(RpcControllerFactory.CUSTOM_CONTROLLER_CONF_KEY,InterRegionServerIndexRpcControllerFactory.class,RpcControllerFactory.class);
    clonedConfig.setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER,env.getConfiguration().getInt(INDEX_WRITER_RPC_RETRIES_NUMBER,DEFAULT_INDEX_WRITER_RPC_RETRIES_NUMBER));
    clonedConfig.setInt(HConstants.HBASE_CLIENT_PAUSE,env.getConfiguration().getInt(INDEX_WRITER_RPC_PAUSE,DEFAULT_INDEX_WRITER_RPC_PAUSE));
    DelegateRegionCoprocessorEnvironment indexWriterEnv=new DelegateRegionCoprocessorEnvironment(clonedConfig,env);
    this.writer=new IndexWriter(indexWriterEnv,serverName + ""String_Node_Str"");
    this.rowLockWaitDuration=clonedConfig.getInt(""String_Node_Str"",DEFAULT_ROWLOCK_WAIT_DURATION);
    this.lockManager=new LockManager();
    this.metricSource=MetricsIndexerSourceFactory.getInstance().create();
    setSlowThresholds(e.getConfiguration());
    compactionConfig=PropertiesUtil.cloneConfig(e.getConfiguration());
    compactionConfig.setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER,e.getConfiguration().getInt(QueryServices.METADATA_WRITE_RETRIES_NUMBER,QueryServicesOptions.DEFAULT_METADATA_WRITE_RETRIES_NUMBER));
    compactionConfig.setInt(HConstants.HBASE_CLIENT_PAUSE,e.getConfiguration().getInt(QueryServices.METADATA_WRITE_RETRY_PAUSE,QueryServicesOptions.DEFAULT_METADATA_WRITE_RETRY_PAUSE));
    try {
      Class<? extends IndexFailurePolicy> policyClass=env.getConfiguration().getClass(INDEX_RECOVERY_FAILURE_POLICY_KEY,StoreFailuresInCachePolicy.class,IndexFailurePolicy.class);
      IndexFailurePolicy policy=policyClass.getConstructor(PerRegionIndexWriteCache.class).newInstance(failedIndexEdits);
      LOG.debug(""String_Node_Str"" + policy.getClass());
      recoveryWriter=new RecoveryIndexWriter(policy,indexWriterEnv,serverName + ""String_Node_Str"");
    }
 catch (    Exception ex) {
      throw new IOException(""String_Node_Str"",ex);
    }
  }
 catch (  NoSuchMethodError ex) {
    disabled=true;
    LOG.error(""String_Node_Str"",ex);
  }
}","@Override public void start(CoprocessorEnvironment e) throws IOException {
  try {
    final RegionCoprocessorEnvironment env=(RegionCoprocessorEnvironment)e;
    String serverName=env.getServerName().getServerName();
    if (env.getConfiguration().getBoolean(CHECK_VERSION_CONF_KEY,true)) {
      String errormsg=Indexer.validateVersion(env.getHBaseVersion(),env.getConfiguration());
      if (errormsg != null) {
        IOException ioe=new IOException(errormsg);
        throw ioe;
      }
    }
    this.builder=new IndexBuildManager(env);
    Configuration clonedConfig=PropertiesUtil.cloneConfig(e.getConfiguration());
    clonedConfig.setClass(RpcControllerFactory.CUSTOM_CONTROLLER_CONF_KEY,InterRegionServerIndexRpcControllerFactory.class,RpcControllerFactory.class);
    clonedConfig.setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER,env.getConfiguration().getInt(INDEX_WRITER_RPC_RETRIES_NUMBER,DEFAULT_INDEX_WRITER_RPC_RETRIES_NUMBER));
    clonedConfig.setInt(HConstants.HBASE_CLIENT_PAUSE,env.getConfiguration().getInt(INDEX_WRITER_RPC_PAUSE,DEFAULT_INDEX_WRITER_RPC_PAUSE));
    DelegateRegionCoprocessorEnvironment indexWriterEnv=new DelegateRegionCoprocessorEnvironment(clonedConfig,env);
    this.writer=new IndexWriter(indexWriterEnv,serverName + ""String_Node_Str"");
    this.rowLockWaitDuration=clonedConfig.getInt(""String_Node_Str"",DEFAULT_ROWLOCK_WAIT_DURATION);
    this.lockManager=new LockManager();
    this.metricSource=MetricsIndexerSourceFactory.getInstance().create();
    setSlowThresholds(e.getConfiguration());
    compactionConfig=PropertiesUtil.cloneConfig(e.getConfiguration());
    compactionConfig.setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER,e.getConfiguration().getInt(QueryServices.METADATA_WRITE_RETRIES_NUMBER,QueryServicesOptions.DEFAULT_METADATA_WRITE_RETRIES_NUMBER));
    compactionConfig.setInt(HConstants.HBASE_CLIENT_PAUSE,e.getConfiguration().getInt(QueryServices.METADATA_WRITE_RETRY_PAUSE,QueryServicesOptions.DEFAULT_METADATA_WRITE_RETRY_PAUSE));
    try {
      Class<? extends IndexFailurePolicy> policyClass=env.getConfiguration().getClass(INDEX_RECOVERY_FAILURE_POLICY_KEY,StoreFailuresInCachePolicy.class,IndexFailurePolicy.class);
      IndexFailurePolicy policy=policyClass.getConstructor(PerRegionIndexWriteCache.class).newInstance(failedIndexEdits);
      LOG.debug(""String_Node_Str"" + policy.getClass());
      recoveryWriter=new RecoveryIndexWriter(policy,indexWriterEnv,serverName + ""String_Node_Str"");
    }
 catch (    Exception ex) {
      throw new IOException(""String_Node_Str"",ex);
    }
  }
 catch (  NoSuchMethodError ex) {
    disabled=true;
    LOG.error(""String_Node_Str"",ex);
  }
}",0.9890150809905046
112412,"private synchronized Connection getConnection(Configuration conf) throws IOException {
  if (connection == null || connection.isClosed()) {
    connection=new CoprocessorHConnection(conf,server);
  }
  return connection;
}","private synchronized Connection getConnection(Configuration conf) throws IOException {
  if (connection == null || connection.isClosed()) {
    connection=env.createConnection(conf);
  }
  return connection;
}",0.8584686774941995
112413,"public static HTableFactory getDefaultDelegateHTableFactory(RegionCoprocessorEnvironment env){
  Configuration conf=env.getConfiguration();
  int htableThreads=conf.getInt(IndexWriterUtils.INDEX_WRITER_PER_TABLE_THREADS_CONF_KEY,IndexWriterUtils.DEFAULT_NUM_PER_TABLE_THREADS);
  LOG.trace(""String_Node_Str"" + htableThreads + ""String_Node_Str"");
  IndexManagementUtil.setIfNotSet(conf,HTABLE_THREAD_KEY,htableThreads);
  if (env instanceof RegionCoprocessorEnvironment) {
    RegionCoprocessorEnvironment e=(RegionCoprocessorEnvironment)env;
    RegionServerServices services=e.getRegionServerServices();
    if (services instanceof HRegionServer) {
      return new CoprocessorHConnectionTableFactory(conf,(HRegionServer)services);
    }
  }
  return new CoprocessorHTableFactory(env);
}","public static HTableFactory getDefaultDelegateHTableFactory(RegionCoprocessorEnvironment env){
  Configuration conf=env.getConfiguration();
  int htableThreads=conf.getInt(IndexWriterUtils.INDEX_WRITER_PER_TABLE_THREADS_CONF_KEY,IndexWriterUtils.DEFAULT_NUM_PER_TABLE_THREADS);
  LOG.trace(""String_Node_Str"" + htableThreads + ""String_Node_Str"");
  IndexManagementUtil.setIfNotSet(conf,HTABLE_THREAD_KEY,htableThreads);
  return new CoprocessorHConnectionTableFactory(conf,env);
}",0.6740331491712708
112414,"CoprocessorHConnectionTableFactory(Configuration conf,HRegionServer server){
  this.conf=conf;
  this.server=server;
}","CoprocessorHConnectionTableFactory(Configuration conf,RegionCoprocessorEnvironment env){
  this.conf=conf;
  this.env=env;
}",0.8429752066115702
112415,"private static IndexMetaDataCache getIndexMetaData(RegionCoprocessorEnvironment env,Map<String,byte[]> attributes) throws IOException {
  if (attributes == null) {
    return IndexMetaDataCache.EMPTY_INDEX_META_DATA_CACHE;
  }
  byte[] uuid=attributes.get(PhoenixIndexCodec.INDEX_UUID);
  if (uuid == null) {
    return IndexMetaDataCache.EMPTY_INDEX_META_DATA_CACHE;
  }
  boolean useProto=false;
  byte[] md=attributes.get(PhoenixIndexCodec.INDEX_PROTO_MD);
  useProto=md != null;
  if (md == null) {
    md=attributes.get(PhoenixIndexCodec.INDEX_MD);
  }
  byte[] txState=attributes.get(BaseScannerRegionObserver.TX_STATE);
  if (md != null) {
    final List<IndexMaintainer> indexMaintainers=IndexMaintainer.deserialize(md,useProto);
    final PhoenixTransactionContext txnContext=TransactionFactory.getTransactionFactory().getTransactionContext(txState);
    return new IndexMetaDataCache(){
      @Override public void close() throws IOException {
      }
      @Override public List<IndexMaintainer> getIndexMaintainers(){
        return indexMaintainers;
      }
      @Override public PhoenixTransactionContext getTransactionContext(){
        return txnContext;
      }
    }
;
  }
 else {
    byte[] tenantIdBytes=attributes.get(PhoenixRuntime.TENANT_ID_ATTRIB);
    ImmutableBytesPtr tenantId=tenantIdBytes == null ? null : new ImmutableBytesPtr(tenantIdBytes);
    TenantCache cache=GlobalCache.getTenantCache(env,tenantId);
    IndexMetaDataCache indexCache=(IndexMetaDataCache)cache.getServerCache(new ImmutableBytesPtr(uuid));
    if (indexCache == null) {
      String msg=""String_Node_Str"" + ServerCacheClient.idToString(uuid) + ""String_Node_Str""+ env.getRegion()+ ""String_Node_Str""+ env.getRegionServerServices().getServerName();
      SQLException e=new SQLExceptionInfo.Builder(SQLExceptionCode.INDEX_METADATA_NOT_FOUND).setMessage(msg).build().buildException();
      ServerUtil.throwIOException(""String_Node_Str"",e);
    }
    return indexCache;
  }
}","private static IndexMetaDataCache getIndexMetaData(RegionCoprocessorEnvironment env,Map<String,byte[]> attributes) throws IOException {
  if (attributes == null) {
    return IndexMetaDataCache.EMPTY_INDEX_META_DATA_CACHE;
  }
  byte[] uuid=attributes.get(PhoenixIndexCodec.INDEX_UUID);
  if (uuid == null) {
    return IndexMetaDataCache.EMPTY_INDEX_META_DATA_CACHE;
  }
  boolean useProto=false;
  byte[] md=attributes.get(PhoenixIndexCodec.INDEX_PROTO_MD);
  useProto=md != null;
  if (md == null) {
    md=attributes.get(PhoenixIndexCodec.INDEX_MD);
  }
  byte[] txState=attributes.get(BaseScannerRegionObserver.TX_STATE);
  if (md != null) {
    final List<IndexMaintainer> indexMaintainers=IndexMaintainer.deserialize(md,useProto);
    final PhoenixTransactionContext txnContext=TransactionFactory.getTransactionFactory().getTransactionContext(txState);
    return new IndexMetaDataCache(){
      @Override public void close() throws IOException {
      }
      @Override public List<IndexMaintainer> getIndexMaintainers(){
        return indexMaintainers;
      }
      @Override public PhoenixTransactionContext getTransactionContext(){
        return txnContext;
      }
    }
;
  }
 else {
    byte[] tenantIdBytes=attributes.get(PhoenixRuntime.TENANT_ID_ATTRIB);
    ImmutableBytesPtr tenantId=tenantIdBytes == null ? null : new ImmutableBytesPtr(tenantIdBytes);
    TenantCache cache=GlobalCache.getTenantCache(env,tenantId);
    IndexMetaDataCache indexCache=(IndexMetaDataCache)cache.getServerCache(new ImmutableBytesPtr(uuid));
    if (indexCache == null) {
      String msg=""String_Node_Str"" + ServerCacheClient.idToString(uuid) + ""String_Node_Str""+ env.getRegion()+ ""String_Node_Str""+ env.getServerName().getServerName();
      SQLException e=new SQLExceptionInfo.Builder(SQLExceptionCode.INDEX_METADATA_NOT_FOUND).setMessage(msg).build().buildException();
      ServerUtil.throwIOException(""String_Node_Str"",e);
    }
    return indexCache;
  }
}",0.9954291518537328
112416,"private RegionCoprocessorEnvironment getSnapshotContextEnvironment(final Configuration conf){
  return new RegionCoprocessorEnvironment(){
    @Override public Region getRegion(){
      return region;
    }
    @Override public RegionInfo getRegionInfo(){
      return region.getRegionInfo();
    }
    @Override public ConcurrentMap<String,Object> getSharedData(){
      throw new UnsupportedOperationException();
    }
    @Override public int getVersion(){
      throw new UnsupportedOperationException();
    }
    @Override public String getHBaseVersion(){
      throw new UnsupportedOperationException();
    }
    @Override public int getPriority(){
      throw new UnsupportedOperationException();
    }
    @Override public int getLoadSequence(){
      throw new UnsupportedOperationException();
    }
    @Override public Configuration getConfiguration(){
      return conf;
    }
    @Override public ClassLoader getClassLoader(){
      throw new UnsupportedOperationException();
    }
    @Override public RegionCoprocessor getInstance(){
      throw new UnsupportedOperationException();
    }
    @Override public OnlineRegions getOnlineRegions(){
      throw new UnsupportedOperationException();
    }
    @Override public ServerName getServerName(){
      throw new UnsupportedOperationException();
    }
    @Override public Connection getConnection(){
      throw new UnsupportedOperationException();
    }
    @Override public MetricRegistry getMetricRegistryForRegionServer(){
      throw new UnsupportedOperationException();
    }
  }
;
}","private RegionCoprocessorEnvironment getSnapshotContextEnvironment(final Configuration conf){
  return new RegionCoprocessorEnvironment(){
    @Override public Region getRegion(){
      return region;
    }
    @Override public RegionInfo getRegionInfo(){
      return region.getRegionInfo();
    }
    @Override public ConcurrentMap<String,Object> getSharedData(){
      throw new UnsupportedOperationException();
    }
    @Override public int getVersion(){
      throw new UnsupportedOperationException();
    }
    @Override public String getHBaseVersion(){
      throw new UnsupportedOperationException();
    }
    @Override public int getPriority(){
      throw new UnsupportedOperationException();
    }
    @Override public int getLoadSequence(){
      throw new UnsupportedOperationException();
    }
    @Override public Configuration getConfiguration(){
      return conf;
    }
    @Override public ClassLoader getClassLoader(){
      throw new UnsupportedOperationException();
    }
    @Override public RegionCoprocessor getInstance(){
      throw new UnsupportedOperationException();
    }
    @Override public OnlineRegions getOnlineRegions(){
      throw new UnsupportedOperationException();
    }
    @Override public ServerName getServerName(){
      throw new UnsupportedOperationException();
    }
    @Override public Connection getConnection(){
      throw new UnsupportedOperationException();
    }
    @Override public MetricRegistry getMetricRegistryForRegionServer(){
      throw new UnsupportedOperationException();
    }
    @Override public Connection createConnection(    Configuration conf) throws IOException {
      throw new UnsupportedOperationException();
    }
    @Override public ExtendedCellBuilder getCellBuilder(){
      throw new UnsupportedOperationException();
    }
  }
;
}",0.9221663213968628
112417,"public int scheduleIndexBuilds() throws Exception {
  ZooKeeperWatcher zookeeperWatcher=new ZooKeeperWatcher(conf,""String_Node_Str"",null);
  if (!ZKBasedMasterElectionUtil.acquireLock(zookeeperWatcher,PHOENIX_LOCKS_PARENT,AUTO_INDEX_BUILD_LOCK_NAME)) {
    LOG.info(""String_Node_Str"");
    return -1;
  }
  Map<String,PhoenixAsyncIndex> candidateJobs=getCandidateJobs();
  LOG.info(""String_Node_Str"" + candidateJobs);
  Set<String> submittedJobs=getSubmittedYarnApps();
  LOG.info(""String_Node_Str"" + submittedJobs);
  Set<PhoenixAsyncIndex> jobsToSchedule=getJobsToSubmit(candidateJobs,submittedJobs);
  LOG.info(""String_Node_Str"" + jobsToSchedule);
  List<Future<Boolean>> results=new ArrayList<Future<Boolean>>(jobsToSchedule.size());
  int failedJobSubmissionCount=0;
  int timedoutJobSubmissionCount=0;
  ExecutorService jobSubmitPool=Executors.newFixedThreadPool(10);
  LOG.info(""String_Node_Str"" + jobsToSchedule);
  try {
    for (    PhoenixAsyncIndex indexToBuild : jobsToSchedule) {
      PhoenixMRJobCallable task=new PhoenixMRJobCallable(HBaseConfiguration.create(conf),indexToBuild,""String_Node_Str"");
      results.add(jobSubmitPool.submit(task));
    }
    for (    Future<Boolean> result : results) {
      try {
        result.get(JOB_SUBMIT_POOL_TIMEOUT,TimeUnit.MINUTES);
      }
 catch (      InterruptedException e) {
        failedJobSubmissionCount++;
      }
catch (      ExecutionException e) {
        failedJobSubmissionCount++;
      }
catch (      TimeoutException e) {
        timedoutJobSubmissionCount++;
      }
    }
  }
  finally {
    PhoenixMRJobUtil.shutdown(jobSubmitPool);
  }
  LOG.info(""String_Node_Str"" + jobsToSchedule.size() + ""String_Node_Str""+ failedJobSubmissionCount+ ""String_Node_Str""+ timedoutJobSubmissionCount);
  return failedJobSubmissionCount;
}","public int scheduleIndexBuilds() throws Exception {
  ZKWatcher zookeeperWatcher=new ZKWatcher(conf,""String_Node_Str"",null);
  if (!ZKBasedMasterElectionUtil.acquireLock(zookeeperWatcher,PHOENIX_LOCKS_PARENT,AUTO_INDEX_BUILD_LOCK_NAME)) {
    LOG.info(""String_Node_Str"");
    return -1;
  }
  Map<String,PhoenixAsyncIndex> candidateJobs=getCandidateJobs();
  LOG.info(""String_Node_Str"" + candidateJobs);
  Set<String> submittedJobs=getSubmittedYarnApps();
  LOG.info(""String_Node_Str"" + submittedJobs);
  Set<PhoenixAsyncIndex> jobsToSchedule=getJobsToSubmit(candidateJobs,submittedJobs);
  LOG.info(""String_Node_Str"" + jobsToSchedule);
  List<Future<Boolean>> results=new ArrayList<Future<Boolean>>(jobsToSchedule.size());
  int failedJobSubmissionCount=0;
  int timedoutJobSubmissionCount=0;
  ExecutorService jobSubmitPool=Executors.newFixedThreadPool(10);
  LOG.info(""String_Node_Str"" + jobsToSchedule);
  try {
    for (    PhoenixAsyncIndex indexToBuild : jobsToSchedule) {
      PhoenixMRJobCallable task=new PhoenixMRJobCallable(HBaseConfiguration.create(conf),indexToBuild,""String_Node_Str"");
      results.add(jobSubmitPool.submit(task));
    }
    for (    Future<Boolean> result : results) {
      try {
        result.get(JOB_SUBMIT_POOL_TIMEOUT,TimeUnit.MINUTES);
      }
 catch (      InterruptedException e) {
        failedJobSubmissionCount++;
      }
catch (      ExecutionException e) {
        failedJobSubmissionCount++;
      }
catch (      TimeoutException e) {
        timedoutJobSubmissionCount++;
      }
    }
  }
  finally {
    PhoenixMRJobUtil.shutdown(jobSubmitPool);
  }
  LOG.info(""String_Node_Str"" + jobsToSchedule.size() + ""String_Node_Str""+ failedJobSubmissionCount+ ""String_Node_Str""+ timedoutJobSubmissionCount);
  return failedJobSubmissionCount;
}",0.9894150417827298
112418,"@Override public void coerceBytes(ImmutableBytesWritable ptr,Object object,PDataType actualType,Integer maxLength,Integer scale,SortOrder actualModifier,Integer desiredMaxLength,Integer desiredScale,SortOrder expectedModifier){
  if (ptr.getLength() > getByteSize()) {
    ptr.set(ptr.get(),ptr.getOffset(),getByteSize());
  }
  super.coerceBytes(ptr,object,actualType,maxLength,scale,actualModifier,desiredMaxLength,desiredScale,expectedModifier);
}","@Override public void coerceBytes(ImmutableBytesWritable ptr,Object object,PDataType actualType,Integer maxLength,Integer scale,SortOrder actualModifier,Integer desiredMaxLength,Integer desiredScale,SortOrder expectedModifier){
  if (ptr.getLength() > getByteSize() && actualType.isCoercibleTo(PTimestamp.INSTANCE)) {
    ptr.set(ptr.get(),ptr.getOffset(),getByteSize());
  }
  super.coerceBytes(ptr,object,actualType,maxLength,scale,actualModifier,desiredMaxLength,desiredScale,expectedModifier);
}",0.9483667017913592
112419,"@Test public void testExecuteStatements() throws Exception {
  String tenantId=getOrganizationId();
  String tableName=initATableValues(tenantId,getDefaultSplits(tenantId),getUrl());
  String ptsdbTableName=generateUniqueName();
  String statements=""String_Node_Str"" + tableName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ptsdbTableName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ptsdbTableName+ ""String_Node_Str""+ ""String_Node_Str""+ ptsdbTableName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ptsdbTableName+ ""String_Node_Str""+ ""String_Node_Str""+ tableName+ ""String_Node_Str""+ ""String_Node_Str""+ ptsdbTableName+ ""String_Node_Str""+ ""String_Node_Str""+ ptsdbTableName+ ""String_Node_Str"";
  Date now=new Date(System.currentTimeMillis());
  Connection conn=DriverManager.getConnection(getUrl());
  conn.setAutoCommit(true);
  List<Object> binds=Arrays.<Object>asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",6);
  int nStatements=PhoenixRuntime.executeStatements(conn,new StringReader(statements),binds);
  assertEquals(7,nStatements);
  Date then=new Date(System.currentTimeMillis() + QueryConstants.MILLIS_IN_DAY);
  String query=""String_Node_Str"" + ptsdbTableName + ""String_Node_Str"";
  PreparedStatement statement=conn.prepareStatement(query);
  ResultSet rs=statement.executeQuery();
  assertTrue(rs.next());
  assertEquals(null,rs.getString(1));
  assertEquals(ROW6,rs.getString(2));
  assertTrue(rs.getDate(3).after(now) && rs.getDate(3).before(then));
  assertEquals(null,rs.getBigDecimal(4));
  assertTrue(rs.next());
  assertEquals(null,rs.getString(1));
  assertEquals(ROW7,rs.getString(2));
  assertTrue(rs.getDate(3).after(now) && rs.getDate(3).before(then));
  assertTrue(BigDecimal.valueOf(70).compareTo(rs.getBigDecimal(4)) == 0);
  assertTrue(rs.next());
  assertEquals(null,rs.getString(1));
  assertEquals(ROW8,rs.getString(2));
  assertTrue(rs.getDate(3).after(now) && rs.getDate(3).before(then));
  assertTrue(BigDecimal.valueOf(60).compareTo(rs.getBigDecimal(4)) == 0);
  assertTrue(rs.next());
  assertEquals(null,rs.getString(1));
  assertEquals(ROW9,rs.getString(2));
  assertTrue(rs.getDate(3).after(now) && rs.getDate(3).before(then));
  assertTrue(BigDecimal.valueOf(50).compareTo(rs.getBigDecimal(4)) == 0);
  assertFalse(rs.next());
  conn.close();
}","@Test public void testExecuteStatements() throws Exception {
  String tenantId=getOrganizationId();
  String tableName=initATableValues(tenantId,getDefaultSplits(tenantId),getUrl());
  String ptsdbTableName=generateUniqueName();
  String statements=""String_Node_Str"" + tableName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ptsdbTableName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ptsdbTableName+ ""String_Node_Str""+ ""String_Node_Str""+ ptsdbTableName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ptsdbTableName+ ""String_Node_Str""+ ""String_Node_Str""+ tableName+ ""String_Node_Str""+ ""String_Node_Str""+ ptsdbTableName+ ""String_Node_Str""+ ""String_Node_Str""+ ptsdbTableName+ ""String_Node_Str"";
  Date now=new Date(System.currentTimeMillis());
  Connection conn=DriverManager.getConnection(getUrl());
  conn.setAutoCommit(true);
  List<Object> binds=Arrays.<Object>asList(6);
  int nStatements=PhoenixRuntime.executeStatements(conn,new StringReader(statements),binds);
  assertEquals(7,nStatements);
  Date then=new Date(System.currentTimeMillis() + QueryConstants.MILLIS_IN_DAY);
  String query=""String_Node_Str"" + ptsdbTableName + ""String_Node_Str"";
  PreparedStatement statement=conn.prepareStatement(query);
  ResultSet rs=statement.executeQuery();
  assertTrue(rs.next());
  assertEquals(null,rs.getString(1));
  assertEquals(ROW6,rs.getString(2));
  assertTrue(rs.getDate(3).after(now) && rs.getDate(3).before(then));
  assertEquals(null,rs.getBigDecimal(4));
  assertTrue(rs.next());
  assertEquals(null,rs.getString(1));
  assertEquals(ROW7,rs.getString(2));
  assertTrue(rs.getDate(3).after(now) && rs.getDate(3).before(then));
  assertTrue(BigDecimal.valueOf(70).compareTo(rs.getBigDecimal(4)) == 0);
  assertTrue(rs.next());
  assertEquals(null,rs.getString(1));
  assertEquals(ROW8,rs.getString(2));
  assertTrue(rs.getDate(3).after(now) && rs.getDate(3).before(then));
  assertTrue(BigDecimal.valueOf(60).compareTo(rs.getBigDecimal(4)) == 0);
  assertTrue(rs.next());
  assertEquals(null,rs.getString(1));
  assertEquals(ROW9,rs.getString(2));
  assertTrue(rs.getDate(3).after(now) && rs.getDate(3).before(then));
  assertTrue(BigDecimal.valueOf(50).compareTo(rs.getBigDecimal(4)) == 0);
  assertFalse(rs.next());
  conn.close();
}",0.988929889298893
112420,"private void createTable(Connection conn,byte[][] splits) throws SQLException {
  PreparedStatement stmt=conn.prepareStatement(""String_Node_Str"" + tableName + ""String_Node_Str""+ ""String_Node_Str""+ Joiner.on(',').join(Collections.nCopies(splits.length,""String_Node_Str""))+ ""String_Node_Str"");
  for (int i=0; i < splits.length; i++) {
    stmt.setBytes(i + 1,splits[i]);
  }
  stmt.execute();
}","private void createTable(Connection conn,byte[][] splits) throws SQLException {
  List<String> splitsList=new ArrayList<String>(splits.length);
  for (  byte[] split : splits) {
    splitsList.add(""String_Node_Str"" + Bytes.toString(split) + ""String_Node_Str"");
  }
  conn.createStatement().execute(""String_Node_Str"" + tableName + ""String_Node_Str""+ ""String_Node_Str""+ Joiner.on(',').join(splitsList)+ ""String_Node_Str"");
}",0.505521472392638
112421,"@Test public void testSkipScanIntersectionAtEnd() throws Exception {
  Connection conn=DriverManager.getConnection(getUrl());
  String tableName=generateUniqueName();
  PreparedStatement stmt=conn.prepareStatement(""String_Node_Str"" + tableName + ""String_Node_Str""+ ""String_Node_Str"");
  stmt.setBytes(1,new byte[]{1,1});
  stmt.setBytes(2,new byte[]{2,1});
  stmt.setBytes(3,new byte[]{3,1});
  stmt.execute();
  conn.createStatement().execute(""String_Node_Str"" + tableName + ""String_Node_Str"");
  conn.createStatement().execute(""String_Node_Str"" + tableName + ""String_Node_Str"");
  conn.createStatement().execute(""String_Node_Str"" + tableName + ""String_Node_Str"");
  conn.createStatement().execute(""String_Node_Str"" + tableName + ""String_Node_Str"");
  conn.commit();
  ResultSet rs=conn.createStatement().executeQuery(""String_Node_Str"" + tableName + ""String_Node_Str"");
  assertTrue(rs.next());
  assertEquals(4,rs.getInt(1));
  assertFalse(rs.next());
}","@Test public void testSkipScanIntersectionAtEnd() throws Exception {
  Connection conn=DriverManager.getConnection(getUrl());
  String tableName=generateUniqueName();
  conn.createStatement().execute(""String_Node_Str"" + tableName + ""String_Node_Str""+ ""String_Node_Str""+ Bytes.toString(new byte[]{1,1})+ ""String_Node_Str""+ Bytes.toString(new byte[]{2,1})+ ""String_Node_Str""+ Bytes.toString(new byte[]{3,1})+ ""String_Node_Str"");
  conn.createStatement().execute(""String_Node_Str"" + tableName + ""String_Node_Str"");
  conn.createStatement().execute(""String_Node_Str"" + tableName + ""String_Node_Str"");
  conn.createStatement().execute(""String_Node_Str"" + tableName + ""String_Node_Str"");
  conn.createStatement().execute(""String_Node_Str"" + tableName + ""String_Node_Str"");
  conn.commit();
  ResultSet rs=conn.createStatement().executeQuery(""String_Node_Str"" + tableName + ""String_Node_Str"");
  assertTrue(rs.next());
  assertEquals(4,rs.getInt(1));
  assertFalse(rs.next());
}",0.8089304257528557
112422,"protected void helpTestSelectColOnlyInDataTable(boolean mutable,boolean localIndex) throws Exception {
  String dataTableName=generateUniqueName();
  String fullDataTableName=INDEX_DATA_SCHEMA + QueryConstants.NAME_SEPARATOR + dataTableName;
  String indexName=generateUniqueName();
  Properties props=PropertiesUtil.deepCopy(TEST_PROPERTIES);
  Connection conn=DriverManager.getConnection(getUrl(),props);
  try {
    conn.setAutoCommit(false);
    createDataTable(conn,fullDataTableName,mutable ? ""String_Node_Str"" : ""String_Node_Str"");
    populateDataTable(conn,fullDataTableName);
    String ddl=""String_Node_Str"" + (localIndex ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ indexName+ ""String_Node_Str""+ fullDataTableName+ ""String_Node_Str"";
    conn=DriverManager.getConnection(getUrl(),props);
    conn.setAutoCommit(false);
    PreparedStatement stmt=conn.prepareStatement(ddl);
    stmt.execute();
    String sql=""String_Node_Str"" + fullDataTableName + ""String_Node_Str"";
    ResultSet rs=conn.createStatement().executeQuery(""String_Node_Str"" + sql);
    assertEquals(""String_Node_Str"" + (localIndex ? ""String_Node_Str"" + fullDataTableName + ""String_Node_Str"" : ""String_Node_Str"" + fullDataTableName + ""String_Node_Str""),QueryUtil.getExplainPlan(rs));
    rs=conn.createStatement().executeQuery(sql);
    assertTrue(rs.next());
    assertEquals(2,rs.getInt(1));
    assertEquals(1,rs.getInt(2));
    assertFalse(rs.next());
    conn.createStatement().execute(""String_Node_Str"" + indexName + ""String_Node_Str""+ fullDataTableName);
  }
  finally {
    conn.close();
  }
}","protected void helpTestSelectColOnlyInDataTable(boolean mutable,boolean localIndex) throws Exception {
  String dataTableName=generateUniqueName();
  String fullDataTableName=INDEX_DATA_SCHEMA + QueryConstants.NAME_SEPARATOR + dataTableName;
  String indexName=generateUniqueName();
  Properties props=PropertiesUtil.deepCopy(TEST_PROPERTIES);
  Connection conn=DriverManager.getConnection(getUrl(),props);
  try {
    conn.setAutoCommit(false);
    createDataTable(conn,fullDataTableName,mutable ? ""String_Node_Str"" : ""String_Node_Str"");
    populateDataTable(conn,fullDataTableName);
    String ddl=""String_Node_Str"" + (localIndex ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ indexName+ ""String_Node_Str""+ fullDataTableName+ ""String_Node_Str"";
    conn=DriverManager.getConnection(getUrl(),props);
    conn.setAutoCommit(false);
    conn.createStatement().execute(ddl);
    String sql=""String_Node_Str"" + fullDataTableName + ""String_Node_Str"";
    ResultSet rs=conn.createStatement().executeQuery(""String_Node_Str"" + sql);
    assertEquals(""String_Node_Str"" + (localIndex ? ""String_Node_Str"" + fullDataTableName + ""String_Node_Str"" : ""String_Node_Str"" + fullDataTableName + ""String_Node_Str""),QueryUtil.getExplainPlan(rs));
    rs=conn.createStatement().executeQuery(sql);
    assertTrue(rs.next());
    assertEquals(2,rs.getInt(1));
    assertEquals(1,rs.getInt(2));
    assertFalse(rs.next());
    conn.createStatement().execute(""String_Node_Str"" + indexName + ""String_Node_Str""+ fullDataTableName);
  }
  finally {
    conn.close();
  }
}",0.9733671528218136
112423,"protected void helpTestDeleteIndexedExpression(boolean mutable,boolean localIndex) throws Exception {
  String dataTableName=generateUniqueName();
  String fullDataTableName=INDEX_DATA_SCHEMA + QueryConstants.NAME_SEPARATOR + dataTableName;
  String indexName=generateUniqueName();
  String fullIndexTableName=INDEX_DATA_SCHEMA + QueryConstants.NAME_SEPARATOR + indexName;
  Properties props=PropertiesUtil.deepCopy(TEST_PROPERTIES);
  Connection conn=DriverManager.getConnection(getUrl(),props);
  try {
    conn.setAutoCommit(false);
    createDataTable(conn,fullDataTableName,mutable ? ""String_Node_Str"" : ""String_Node_Str"");
    populateDataTable(conn,fullDataTableName);
    String ddl=""String_Node_Str"" + (localIndex ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ indexName+ ""String_Node_Str""+ fullDataTableName+ ""String_Node_Str"";
    PreparedStatement stmt=conn.prepareStatement(ddl);
    stmt.execute();
    ResultSet rs;
    rs=conn.createStatement().executeQuery(""String_Node_Str"" + fullDataTableName);
    assertTrue(rs.next());
    assertEquals(2,rs.getInt(1));
    rs=conn.createStatement().executeQuery(""String_Node_Str"" + fullIndexTableName);
    assertTrue(rs.next());
    assertEquals(2,rs.getInt(1));
    conn.setAutoCommit(true);
    String dml=""String_Node_Str"" + fullDataTableName + ""String_Node_Str"";
    try {
      conn.createStatement().execute(dml);
      if (!mutable) {
        fail();
      }
    }
 catch (    SQLException e) {
      if (!mutable) {
        assertEquals(SQLExceptionCode.INVALID_FILTER_ON_IMMUTABLE_ROWS.getErrorCode(),e.getErrorCode());
      }
    }
    if (!mutable) {
      dml=""String_Node_Str"" + fullDataTableName + ""String_Node_Str"";
      conn.createStatement().execute(dml);
    }
    rs=conn.createStatement().executeQuery(""String_Node_Str"" + fullDataTableName);
    assertTrue(rs.next());
    assertEquals(1,rs.getInt(1));
    rs=conn.createStatement().executeQuery(""String_Node_Str"" + fullIndexTableName);
    assertTrue(rs.next());
    assertEquals(1,rs.getInt(1));
    conn.createStatement().execute(""String_Node_Str"" + indexName + ""String_Node_Str""+ fullDataTableName);
  }
  finally {
    conn.close();
  }
}","protected void helpTestDeleteIndexedExpression(boolean mutable,boolean localIndex) throws Exception {
  String dataTableName=generateUniqueName();
  String fullDataTableName=INDEX_DATA_SCHEMA + QueryConstants.NAME_SEPARATOR + dataTableName;
  String indexName=generateUniqueName();
  String fullIndexTableName=INDEX_DATA_SCHEMA + QueryConstants.NAME_SEPARATOR + indexName;
  Properties props=PropertiesUtil.deepCopy(TEST_PROPERTIES);
  Connection conn=DriverManager.getConnection(getUrl(),props);
  try {
    conn.setAutoCommit(false);
    createDataTable(conn,fullDataTableName,mutable ? ""String_Node_Str"" : ""String_Node_Str"");
    populateDataTable(conn,fullDataTableName);
    String ddl=""String_Node_Str"" + (localIndex ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ indexName+ ""String_Node_Str""+ fullDataTableName+ ""String_Node_Str"";
    conn.createStatement().execute(ddl);
    ResultSet rs;
    rs=conn.createStatement().executeQuery(""String_Node_Str"" + fullDataTableName);
    assertTrue(rs.next());
    assertEquals(2,rs.getInt(1));
    rs=conn.createStatement().executeQuery(""String_Node_Str"" + fullIndexTableName);
    assertTrue(rs.next());
    assertEquals(2,rs.getInt(1));
    conn.setAutoCommit(true);
    String dml=""String_Node_Str"" + fullDataTableName + ""String_Node_Str"";
    try {
      conn.createStatement().execute(dml);
      if (!mutable) {
        fail();
      }
    }
 catch (    SQLException e) {
      if (!mutable) {
        assertEquals(SQLExceptionCode.INVALID_FILTER_ON_IMMUTABLE_ROWS.getErrorCode(),e.getErrorCode());
      }
    }
    if (!mutable) {
      dml=""String_Node_Str"" + fullDataTableName + ""String_Node_Str"";
      conn.createStatement().execute(dml);
    }
    rs=conn.createStatement().executeQuery(""String_Node_Str"" + fullDataTableName);
    assertTrue(rs.next());
    assertEquals(1,rs.getInt(1));
    rs=conn.createStatement().executeQuery(""String_Node_Str"" + fullIndexTableName);
    assertTrue(rs.next());
    assertEquals(1,rs.getInt(1));
    conn.createStatement().execute(""String_Node_Str"" + indexName + ""String_Node_Str""+ fullDataTableName);
  }
  finally {
    conn.close();
  }
}",0.9764976958525344
112424,"protected void helpTestCreateAndUpdate(boolean mutable,boolean localIndex) throws Exception {
  String dataTableName=generateUniqueName();
  String fullDataTableName=INDEX_DATA_SCHEMA + QueryConstants.NAME_SEPARATOR + dataTableName;
  String indexName=generateUniqueName();
  Properties props=PropertiesUtil.deepCopy(TEST_PROPERTIES);
  Connection conn=DriverManager.getConnection(getUrl(),props);
  try {
    conn.setAutoCommit(false);
    createDataTable(conn,fullDataTableName,mutable ? ""String_Node_Str"" : ""String_Node_Str"");
    populateDataTable(conn,fullDataTableName);
    String ddl=""String_Node_Str"" + (localIndex ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ indexName+ ""String_Node_Str""+ fullDataTableName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    PreparedStatement stmt=conn.prepareStatement(ddl);
    stmt.execute();
    String whereSql=""String_Node_Str"" + fullDataTableName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    stmt=conn.prepareStatement(whereSql);
    stmt.setString(1,""String_Node_Str"");
    stmt.setInt(2,3);
    Date date=DateUtil.parseDate(""String_Node_Str"");
    stmt.setDate(3,date);
    stmt.setDate(4,date);
    stmt.setDate(5,date);
    ResultSet rs=stmt.executeQuery(""String_Node_Str"" + whereSql);
    assertEquals(localIndex ? ""String_Node_Str"" + dataTableName + ""String_Node_Str"" : ""String_Node_Str"" + indexName + ""String_Node_Str"",QueryUtil.getExplainPlan(rs));
    rs=stmt.executeQuery();
    assertTrue(rs.next());
    assertEquals(1,rs.getInt(1));
    assertEquals(1,rs.getInt(2));
    assertFalse(rs.next());
    String indexSelectSql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ fullDataTableName;
    rs=conn.createStatement().executeQuery(""String_Node_Str"" + indexSelectSql);
    assertEquals(localIndex ? ""String_Node_Str"" + fullDataTableName + ""String_Node_Str"" : ""String_Node_Str"" + indexName,QueryUtil.getExplainPlan(rs));
    rs=conn.createStatement().executeQuery(indexSelectSql);
    verifyResult(rs,1);
    verifyResult(rs,2);
    String upsert=""String_Node_Str"" + fullDataTableName + ""String_Node_Str"";
    stmt=conn.prepareStatement(upsert);
    insertRow(stmt,3);
    insertRow(stmt,4);
    conn.commit();
    rs=conn.createStatement().executeQuery(indexSelectSql);
    verifyResult(rs,1);
    verifyResult(rs,2);
    verifyResult(rs,3);
    verifyResult(rs,4);
    conn.createStatement().execute(""String_Node_Str"" + indexName + ""String_Node_Str""+ fullDataTableName);
  }
  finally {
    conn.close();
  }
}","protected void helpTestCreateAndUpdate(boolean mutable,boolean localIndex) throws Exception {
  String dataTableName=generateUniqueName();
  String fullDataTableName=INDEX_DATA_SCHEMA + QueryConstants.NAME_SEPARATOR + dataTableName;
  String indexName=generateUniqueName();
  Properties props=PropertiesUtil.deepCopy(TEST_PROPERTIES);
  Connection conn=DriverManager.getConnection(getUrl(),props);
  try {
    conn.setAutoCommit(false);
    createDataTable(conn,fullDataTableName,mutable ? ""String_Node_Str"" : ""String_Node_Str"");
    populateDataTable(conn,fullDataTableName);
    String ddl=""String_Node_Str"" + (localIndex ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ indexName+ ""String_Node_Str""+ fullDataTableName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    conn.createStatement().execute(ddl);
    String whereSql=""String_Node_Str"" + fullDataTableName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    PreparedStatement stmt=conn.prepareStatement(whereSql);
    stmt.setString(1,""String_Node_Str"");
    stmt.setInt(2,3);
    Date date=DateUtil.parseDate(""String_Node_Str"");
    stmt.setDate(3,date);
    stmt.setDate(4,date);
    stmt.setDate(5,date);
    ResultSet rs=stmt.executeQuery(""String_Node_Str"" + whereSql);
    assertEquals(localIndex ? ""String_Node_Str"" + dataTableName + ""String_Node_Str"" : ""String_Node_Str"" + indexName + ""String_Node_Str"",QueryUtil.getExplainPlan(rs));
    rs=stmt.executeQuery();
    assertTrue(rs.next());
    assertEquals(1,rs.getInt(1));
    assertEquals(1,rs.getInt(2));
    assertFalse(rs.next());
    String indexSelectSql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ fullDataTableName;
    rs=conn.createStatement().executeQuery(""String_Node_Str"" + indexSelectSql);
    assertEquals(localIndex ? ""String_Node_Str"" + fullDataTableName + ""String_Node_Str"" : ""String_Node_Str"" + indexName,QueryUtil.getExplainPlan(rs));
    rs=conn.createStatement().executeQuery(indexSelectSql);
    verifyResult(rs,1);
    verifyResult(rs,2);
    String upsert=""String_Node_Str"" + fullDataTableName + ""String_Node_Str"";
    stmt=conn.prepareStatement(upsert);
    insertRow(stmt,3);
    insertRow(stmt,4);
    conn.commit();
    rs=conn.createStatement().executeQuery(indexSelectSql);
    verifyResult(rs,1);
    verifyResult(rs,2);
    verifyResult(rs,3);
    verifyResult(rs,4);
    conn.createStatement().execute(""String_Node_Str"" + indexName + ""String_Node_Str""+ fullDataTableName);
  }
  finally {
    conn.close();
  }
}",0.9803695150115472
112425,"protected void helpTestGroupByCount(boolean mutable,boolean localIndex) throws Exception {
  String dataTableName=generateUniqueName();
  String fullDataTableName=INDEX_DATA_SCHEMA + QueryConstants.NAME_SEPARATOR + dataTableName;
  String indexName=generateUniqueName();
  Properties props=PropertiesUtil.deepCopy(TEST_PROPERTIES);
  Connection conn=DriverManager.getConnection(getUrl(),props);
  try {
    conn.setAutoCommit(false);
    createDataTable(conn,fullDataTableName,mutable ? ""String_Node_Str"" : ""String_Node_Str"");
    populateDataTable(conn,fullDataTableName);
    String ddl=""String_Node_Str"" + (localIndex ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ indexName+ ""String_Node_Str""+ fullDataTableName+ ""String_Node_Str"";
    PreparedStatement stmt=conn.prepareStatement(ddl);
    stmt.execute();
    String groupBySql=""String_Node_Str"" + fullDataTableName + ""String_Node_Str"";
    ResultSet rs=conn.createStatement().executeQuery(""String_Node_Str"" + groupBySql);
    String expectedPlan=""String_Node_Str"" + (localIndex ? ""String_Node_Str"" + fullDataTableName + ""String_Node_Str"" : ""String_Node_Str"" + indexName) + ""String_Node_Str""+ (localIndex ? ""String_Node_Str"" : ""String_Node_Str"");
    assertEquals(expectedPlan,QueryUtil.getExplainPlan(rs));
    rs=conn.createStatement().executeQuery(groupBySql);
    assertTrue(rs.next());
    assertEquals(1,rs.getInt(2));
    assertTrue(rs.next());
    assertEquals(1,rs.getInt(2));
    assertFalse(rs.next());
    conn.createStatement().execute(""String_Node_Str"" + indexName + ""String_Node_Str""+ fullDataTableName);
  }
  finally {
    conn.close();
  }
}","protected void helpTestGroupByCount(boolean mutable,boolean localIndex) throws Exception {
  String dataTableName=generateUniqueName();
  String fullDataTableName=INDEX_DATA_SCHEMA + QueryConstants.NAME_SEPARATOR + dataTableName;
  String indexName=generateUniqueName();
  Properties props=PropertiesUtil.deepCopy(TEST_PROPERTIES);
  Connection conn=DriverManager.getConnection(getUrl(),props);
  try {
    conn.setAutoCommit(false);
    createDataTable(conn,fullDataTableName,mutable ? ""String_Node_Str"" : ""String_Node_Str"");
    populateDataTable(conn,fullDataTableName);
    String ddl=""String_Node_Str"" + (localIndex ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ indexName+ ""String_Node_Str""+ fullDataTableName+ ""String_Node_Str"";
    conn.createStatement().execute(ddl);
    String groupBySql=""String_Node_Str"" + fullDataTableName + ""String_Node_Str"";
    ResultSet rs=conn.createStatement().executeQuery(""String_Node_Str"" + groupBySql);
    String expectedPlan=""String_Node_Str"" + (localIndex ? ""String_Node_Str"" + fullDataTableName + ""String_Node_Str"" : ""String_Node_Str"" + indexName) + ""String_Node_Str""+ (localIndex ? ""String_Node_Str"" : ""String_Node_Str"");
    assertEquals(expectedPlan,QueryUtil.getExplainPlan(rs));
    rs=conn.createStatement().executeQuery(groupBySql);
    assertTrue(rs.next());
    assertEquals(1,rs.getInt(2));
    assertTrue(rs.next());
    assertEquals(1,rs.getInt(2));
    assertFalse(rs.next());
    conn.createStatement().execute(""String_Node_Str"" + indexName + ""String_Node_Str""+ fullDataTableName);
  }
  finally {
    conn.close();
  }
}",0.968362282878412
112426,"protected void helpTestInClauseWithIndex(boolean mutable,boolean localIndex) throws Exception {
  String dataTableName=generateUniqueName();
  String fullDataTableName=INDEX_DATA_SCHEMA + QueryConstants.NAME_SEPARATOR + dataTableName;
  String indexName=generateUniqueName();
  Properties props=PropertiesUtil.deepCopy(TEST_PROPERTIES);
  Connection conn=DriverManager.getConnection(getUrl(),props);
  try {
    conn.setAutoCommit(false);
    createDataTable(conn,fullDataTableName,mutable ? ""String_Node_Str"" : ""String_Node_Str"");
    populateDataTable(conn,fullDataTableName);
    String ddl=""String_Node_Str"" + (localIndex ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ indexName+ ""String_Node_Str""+ fullDataTableName+ ""String_Node_Str"";
    PreparedStatement stmt=conn.prepareStatement(ddl);
    stmt.execute();
    String sql=""String_Node_Str"" + fullDataTableName + ""String_Node_Str"";
    ResultSet rs=conn.createStatement().executeQuery(""String_Node_Str"" + sql);
    assertEquals(""String_Node_Str"" + (localIndex ? fullDataTableName + ""String_Node_Str"" : ""String_Node_Str"" + indexName + ""String_Node_Str""),QueryUtil.getExplainPlan(rs));
    rs=conn.createStatement().executeQuery(sql);
    assertTrue(rs.next());
    assertEquals(2,rs.getInt(1));
    assertFalse(rs.next());
    conn.createStatement().execute(""String_Node_Str"" + indexName + ""String_Node_Str""+ fullDataTableName);
  }
  finally {
    conn.close();
  }
}","protected void helpTestInClauseWithIndex(boolean mutable,boolean localIndex) throws Exception {
  String dataTableName=generateUniqueName();
  String fullDataTableName=INDEX_DATA_SCHEMA + QueryConstants.NAME_SEPARATOR + dataTableName;
  String indexName=generateUniqueName();
  Properties props=PropertiesUtil.deepCopy(TEST_PROPERTIES);
  Connection conn=DriverManager.getConnection(getUrl(),props);
  try {
    conn.setAutoCommit(false);
    createDataTable(conn,fullDataTableName,mutable ? ""String_Node_Str"" : ""String_Node_Str"");
    populateDataTable(conn,fullDataTableName);
    String ddl=""String_Node_Str"" + (localIndex ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ indexName+ ""String_Node_Str""+ fullDataTableName+ ""String_Node_Str"";
    conn.createStatement().execute(ddl);
    String sql=""String_Node_Str"" + fullDataTableName + ""String_Node_Str"";
    ResultSet rs=conn.createStatement().executeQuery(""String_Node_Str"" + sql);
    assertEquals(""String_Node_Str"" + (localIndex ? fullDataTableName + ""String_Node_Str"" : ""String_Node_Str"" + indexName + ""String_Node_Str""),QueryUtil.getExplainPlan(rs));
    rs=conn.createStatement().executeQuery(sql);
    assertTrue(rs.next());
    assertEquals(2,rs.getInt(1));
    assertFalse(rs.next());
    conn.createStatement().execute(""String_Node_Str"" + indexName + ""String_Node_Str""+ fullDataTableName);
  }
  finally {
    conn.close();
  }
}",0.9641602248770204
112427,"protected void helpTestCaseSensitiveFunctionIndex(boolean mutable,boolean localIndex) throws Exception {
  Properties props=PropertiesUtil.deepCopy(TEST_PROPERTIES);
  Connection conn=DriverManager.getConnection(getUrl(),props);
  String dataTableName=generateUniqueName();
  String indexName=generateUniqueName();
  try {
    conn.createStatement().execute(""String_Node_Str"" + dataTableName + ""String_Node_Str""+ (mutable ? ""String_Node_Str"" : ""String_Node_Str""));
    String query=""String_Node_Str"" + dataTableName;
    ResultSet rs=conn.createStatement().executeQuery(query);
    assertFalse(rs.next());
    String ddl=""String_Node_Str"" + (localIndex ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ indexName+ ""String_Node_Str""+ dataTableName+ ""String_Node_Str"";
    PreparedStatement stmt=conn.prepareStatement(ddl);
    stmt.execute();
    query=""String_Node_Str"" + indexName;
    rs=conn.createStatement().executeQuery(query);
    assertFalse(rs.next());
    stmt=conn.prepareStatement(""String_Node_Str"" + dataTableName + ""String_Node_Str"");
    stmt.setString(1,""String_Node_Str"");
    stmt.setString(2,""String_Node_Str"");
    stmt.execute();
    stmt.setString(1,""String_Node_Str"");
    stmt.setString(2,""String_Node_Str"");
    stmt.execute();
    conn.commit();
    query=""String_Node_Str"" + dataTableName + ""String_Node_Str"";
    rs=conn.createStatement().executeQuery(""String_Node_Str"" + query);
    if (localIndex) {
      assertEquals(""String_Node_Str"" + dataTableName + ""String_Node_Str""+ ""String_Node_Str"",QueryUtil.getExplainPlan(rs));
    }
 else {
      assertEquals(""String_Node_Str"" + indexName + ""String_Node_Str""+ ""String_Node_Str"",QueryUtil.getExplainPlan(rs));
    }
    rs=conn.createStatement().executeQuery(query);
    assertTrue(rs.next());
    assertEquals(""String_Node_Str"",rs.getString(1));
    assertFalse(rs.next());
  }
  finally {
    conn.close();
  }
}","protected void helpTestCaseSensitiveFunctionIndex(boolean mutable,boolean localIndex) throws Exception {
  Properties props=PropertiesUtil.deepCopy(TEST_PROPERTIES);
  Connection conn=DriverManager.getConnection(getUrl(),props);
  String dataTableName=generateUniqueName();
  String indexName=generateUniqueName();
  try {
    conn.createStatement().execute(""String_Node_Str"" + dataTableName + ""String_Node_Str""+ (mutable ? ""String_Node_Str"" : ""String_Node_Str""));
    String query=""String_Node_Str"" + dataTableName;
    ResultSet rs=conn.createStatement().executeQuery(query);
    assertFalse(rs.next());
    String ddl=""String_Node_Str"" + (localIndex ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ indexName+ ""String_Node_Str""+ dataTableName+ ""String_Node_Str"";
    conn.createStatement().execute(ddl);
    query=""String_Node_Str"" + indexName;
    rs=conn.createStatement().executeQuery(query);
    assertFalse(rs.next());
    PreparedStatement stmt=conn.prepareStatement(""String_Node_Str"" + dataTableName + ""String_Node_Str"");
    stmt.setString(1,""String_Node_Str"");
    stmt.setString(2,""String_Node_Str"");
    stmt.execute();
    stmt.setString(1,""String_Node_Str"");
    stmt.setString(2,""String_Node_Str"");
    stmt.execute();
    conn.commit();
    query=""String_Node_Str"" + dataTableName + ""String_Node_Str"";
    rs=conn.createStatement().executeQuery(""String_Node_Str"" + query);
    if (localIndex) {
      assertEquals(""String_Node_Str"" + dataTableName + ""String_Node_Str""+ ""String_Node_Str"",QueryUtil.getExplainPlan(rs));
    }
 else {
      assertEquals(""String_Node_Str"" + indexName + ""String_Node_Str""+ ""String_Node_Str"",QueryUtil.getExplainPlan(rs));
    }
    rs=conn.createStatement().executeQuery(query);
    assertTrue(rs.next());
    assertEquals(""String_Node_Str"",rs.getString(1));
    assertFalse(rs.next());
  }
  finally {
    conn.close();
  }
}",0.9683210137275609
112428,"protected void helpTestDeleteCoveredCol(boolean mutable,boolean localIndex) throws Exception {
  String dataTableName=generateUniqueName();
  String fullDataTableName=INDEX_DATA_SCHEMA + QueryConstants.NAME_SEPARATOR + dataTableName;
  String indexName=generateUniqueName();
  String fullIndexTableName=INDEX_DATA_SCHEMA + QueryConstants.NAME_SEPARATOR + indexName;
  Properties props=PropertiesUtil.deepCopy(TEST_PROPERTIES);
  Connection conn=DriverManager.getConnection(getUrl(),props);
  try {
    conn.setAutoCommit(false);
    createDataTable(conn,fullDataTableName,mutable ? ""String_Node_Str"" : ""String_Node_Str"");
    populateDataTable(conn,fullDataTableName);
    String ddl=""String_Node_Str"" + (localIndex ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ indexName+ ""String_Node_Str""+ fullDataTableName+ ""String_Node_Str""+ ""String_Node_Str"";
    PreparedStatement stmt=conn.prepareStatement(ddl);
    stmt.execute();
    ResultSet rs;
    rs=conn.createStatement().executeQuery(""String_Node_Str"" + fullDataTableName);
    assertTrue(rs.next());
    assertEquals(2,rs.getInt(1));
    rs=conn.createStatement().executeQuery(""String_Node_Str"" + fullIndexTableName);
    assertTrue(rs.next());
    assertEquals(2,rs.getInt(1));
    String dml=""String_Node_Str"" + fullDataTableName + ""String_Node_Str"";
    assertEquals(1,conn.createStatement().executeUpdate(dml));
    conn.commit();
    String query=""String_Node_Str"" + fullDataTableName;
    rs=conn.createStatement().executeQuery(query);
    assertTrue(rs.next());
    assertEquals(1L,rs.getLong(1));
    assertEquals(""String_Node_Str"",rs.getString(2));
    assertEquals(2L,rs.getLong(3));
    assertEquals(""String_Node_Str"",rs.getString(4));
    assertFalse(rs.next());
    query=""String_Node_Str"" + fullDataTableName;
    rs=conn.createStatement().executeQuery(query);
    assertTrue(rs.next());
    assertEquals(1L,rs.getLong(1));
    assertEquals(""String_Node_Str"",rs.getString(2));
    assertEquals(2L,rs.getLong(3));
    assertEquals(""String_Node_Str"",rs.getString(4));
    assertFalse(rs.next());
    query=""String_Node_Str"" + fullIndexTableName;
    rs=conn.createStatement().executeQuery(query);
    assertTrue(rs.next());
    assertEquals(1L,rs.getLong(1));
    assertEquals(""String_Node_Str"",rs.getString(2));
    assertEquals(2L,rs.getLong(3));
    assertEquals(""String_Node_Str"",rs.getString(4));
    assertFalse(rs.next());
    conn.createStatement().execute(""String_Node_Str"" + indexName + ""String_Node_Str""+ fullDataTableName);
  }
  finally {
    conn.close();
  }
}","protected void helpTestDeleteCoveredCol(boolean mutable,boolean localIndex) throws Exception {
  String dataTableName=generateUniqueName();
  String fullDataTableName=INDEX_DATA_SCHEMA + QueryConstants.NAME_SEPARATOR + dataTableName;
  String indexName=generateUniqueName();
  String fullIndexTableName=INDEX_DATA_SCHEMA + QueryConstants.NAME_SEPARATOR + indexName;
  Properties props=PropertiesUtil.deepCopy(TEST_PROPERTIES);
  Connection conn=DriverManager.getConnection(getUrl(),props);
  try {
    conn.setAutoCommit(false);
    createDataTable(conn,fullDataTableName,mutable ? ""String_Node_Str"" : ""String_Node_Str"");
    populateDataTable(conn,fullDataTableName);
    String ddl=""String_Node_Str"" + (localIndex ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ indexName+ ""String_Node_Str""+ fullDataTableName+ ""String_Node_Str""+ ""String_Node_Str"";
    conn.createStatement().execute(ddl);
    ResultSet rs;
    rs=conn.createStatement().executeQuery(""String_Node_Str"" + fullDataTableName);
    assertTrue(rs.next());
    assertEquals(2,rs.getInt(1));
    rs=conn.createStatement().executeQuery(""String_Node_Str"" + fullIndexTableName);
    assertTrue(rs.next());
    assertEquals(2,rs.getInt(1));
    String dml=""String_Node_Str"" + fullDataTableName + ""String_Node_Str"";
    assertEquals(1,conn.createStatement().executeUpdate(dml));
    conn.commit();
    String query=""String_Node_Str"" + fullDataTableName;
    rs=conn.createStatement().executeQuery(query);
    assertTrue(rs.next());
    assertEquals(1L,rs.getLong(1));
    assertEquals(""String_Node_Str"",rs.getString(2));
    assertEquals(2L,rs.getLong(3));
    assertEquals(""String_Node_Str"",rs.getString(4));
    assertFalse(rs.next());
    query=""String_Node_Str"" + fullDataTableName;
    rs=conn.createStatement().executeQuery(query);
    assertTrue(rs.next());
    assertEquals(1L,rs.getLong(1));
    assertEquals(""String_Node_Str"",rs.getString(2));
    assertEquals(2L,rs.getLong(3));
    assertEquals(""String_Node_Str"",rs.getString(4));
    assertFalse(rs.next());
    query=""String_Node_Str"" + fullIndexTableName;
    rs=conn.createStatement().executeQuery(query);
    assertTrue(rs.next());
    assertEquals(1L,rs.getLong(1));
    assertEquals(""String_Node_Str"",rs.getString(2));
    assertEquals(2L,rs.getLong(3));
    assertEquals(""String_Node_Str"",rs.getString(4));
    assertFalse(rs.next());
    conn.createStatement().execute(""String_Node_Str"" + indexName + ""String_Node_Str""+ fullDataTableName);
  }
  finally {
    conn.close();
  }
}",0.983451536643026
112429,"protected void helpTestIndexWithCaseSensitiveCols(boolean mutable,boolean localIndex) throws Exception {
  String dataTableName=generateUniqueName();
  String indexName=generateUniqueName();
  Properties props=PropertiesUtil.deepCopy(TEST_PROPERTIES);
  Connection conn=DriverManager.getConnection(getUrl(),props);
  try {
    conn.createStatement().execute(""String_Node_Str"" + dataTableName + ""String_Node_Str""+ (mutable ? ""String_Node_Str"" : ""String_Node_Str""));
    String query=""String_Node_Str"" + dataTableName;
    ResultSet rs=conn.createStatement().executeQuery(query);
    assertFalse(rs.next());
    String ddl=""String_Node_Str"" + (localIndex ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ indexName+ ""String_Node_Str""+ dataTableName+ ""String_Node_Str"";
    PreparedStatement stmt=conn.prepareStatement(ddl);
    stmt.execute();
    query=""String_Node_Str"" + indexName;
    rs=conn.createStatement().executeQuery(query);
    assertFalse(rs.next());
    stmt=conn.prepareStatement(""String_Node_Str"" + dataTableName + ""String_Node_Str"");
    stmt.setString(1,""String_Node_Str"");
    stmt.setString(2,""String_Node_Str"");
    stmt.setString(3,""String_Node_Str"");
    stmt.execute();
    stmt.setString(1,""String_Node_Str"");
    stmt.setString(2,""String_Node_Str"");
    stmt.setString(3,""String_Node_Str"");
    stmt.execute();
    conn.commit();
    query=""String_Node_Str"" + dataTableName + ""String_Node_Str"";
    rs=conn.createStatement().executeQuery(""String_Node_Str"" + query);
    if (localIndex) {
      assertEquals(""String_Node_Str"" + dataTableName + ""String_Node_Str""+ ""String_Node_Str"",QueryUtil.getExplainPlan(rs));
    }
 else {
      assertEquals(""String_Node_Str"" + indexName + ""String_Node_Str"",QueryUtil.getExplainPlan(rs));
    }
    rs=conn.createStatement().executeQuery(query);
    assertTrue(rs.next());
    assertEquals(""String_Node_Str"",rs.getString(1));
    assertEquals(""String_Node_Str"",rs.getString(2));
    assertEquals(""String_Node_Str"",rs.getString(3));
    assertEquals(""String_Node_Str"",rs.getString(4));
    assertEquals(""String_Node_Str"",rs.getString(""String_Node_Str""));
    assertEquals(""String_Node_Str"",rs.getString(""String_Node_Str""));
    assertEquals(""String_Node_Str"",rs.getString(""String_Node_Str""));
    assertEquals(""String_Node_Str"",rs.getString(""String_Node_Str""));
    assertFalse(rs.next());
    query=""String_Node_Str"" + dataTableName + ""String_Node_Str"";
    rs=conn.createStatement().executeQuery(""String_Node_Str"" + query);
    if (localIndex) {
      assertEquals(""String_Node_Str"" + dataTableName + ""String_Node_Str"",QueryUtil.getExplainPlan(rs));
    }
 else {
      assertEquals(""String_Node_Str"" + indexName,QueryUtil.getExplainPlan(rs));
    }
    rs=conn.createStatement().executeQuery(query);
    assertTrue(rs.next());
    assertEquals(""String_Node_Str"",rs.getString(1));
    assertEquals(""String_Node_Str"",rs.getString(""String_Node_Str""));
    assertEquals(""String_Node_Str"",rs.getString(2));
    assertEquals(""String_Node_Str"",rs.getString(""String_Node_Str""));
    assertEquals(""String_Node_Str"",rs.getString(3));
    assertEquals(""String_Node_Str"",rs.getString(""String_Node_Str""));
    assertEquals(""String_Node_Str"",rs.getString(4));
    assertEquals(""String_Node_Str"",rs.getString(""String_Node_Str""));
    assertEquals(""String_Node_Str"",rs.getString(5));
    assertEquals(""String_Node_Str"",rs.getString(""String_Node_Str""));
    assertTrue(rs.next());
    assertEquals(""String_Node_Str"",rs.getString(1));
    assertEquals(""String_Node_Str"",rs.getString(""String_Node_Str""));
    assertEquals(""String_Node_Str"",rs.getString(2));
    assertEquals(""String_Node_Str"",rs.getString(""String_Node_Str""));
    assertEquals(""String_Node_Str"",rs.getString(3));
    assertEquals(""String_Node_Str"",rs.getString(""String_Node_Str""));
    assertEquals(""String_Node_Str"",rs.getString(4));
    assertEquals(""String_Node_Str"",rs.getString(""String_Node_Str""));
    assertEquals(""String_Node_Str"",rs.getString(5));
    assertEquals(""String_Node_Str"",rs.getString(""String_Node_Str""));
    assertFalse(rs.next());
    conn.createStatement().execute(""String_Node_Str"" + indexName + ""String_Node_Str""+ dataTableName);
  }
  finally {
    conn.close();
  }
}","protected void helpTestIndexWithCaseSensitiveCols(boolean mutable,boolean localIndex) throws Exception {
  String dataTableName=generateUniqueName();
  String indexName=generateUniqueName();
  Properties props=PropertiesUtil.deepCopy(TEST_PROPERTIES);
  Connection conn=DriverManager.getConnection(getUrl(),props);
  try {
    conn.createStatement().execute(""String_Node_Str"" + dataTableName + ""String_Node_Str""+ (mutable ? ""String_Node_Str"" : ""String_Node_Str""));
    String query=""String_Node_Str"" + dataTableName;
    ResultSet rs=conn.createStatement().executeQuery(query);
    assertFalse(rs.next());
    String ddl=""String_Node_Str"" + (localIndex ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ indexName+ ""String_Node_Str""+ dataTableName+ ""String_Node_Str"";
    conn.createStatement().execute(ddl);
    query=""String_Node_Str"" + indexName;
    rs=conn.createStatement().executeQuery(query);
    assertFalse(rs.next());
    PreparedStatement stmt=conn.prepareStatement(""String_Node_Str"" + dataTableName + ""String_Node_Str"");
    stmt.setString(1,""String_Node_Str"");
    stmt.setString(2,""String_Node_Str"");
    stmt.setString(3,""String_Node_Str"");
    stmt.execute();
    stmt.setString(1,""String_Node_Str"");
    stmt.setString(2,""String_Node_Str"");
    stmt.setString(3,""String_Node_Str"");
    stmt.execute();
    conn.commit();
    query=""String_Node_Str"" + dataTableName + ""String_Node_Str"";
    rs=conn.createStatement().executeQuery(""String_Node_Str"" + query);
    if (localIndex) {
      assertEquals(""String_Node_Str"" + dataTableName + ""String_Node_Str""+ ""String_Node_Str"",QueryUtil.getExplainPlan(rs));
    }
 else {
      assertEquals(""String_Node_Str"" + indexName + ""String_Node_Str"",QueryUtil.getExplainPlan(rs));
    }
    rs=conn.createStatement().executeQuery(query);
    assertTrue(rs.next());
    assertEquals(""String_Node_Str"",rs.getString(1));
    assertEquals(""String_Node_Str"",rs.getString(2));
    assertEquals(""String_Node_Str"",rs.getString(3));
    assertEquals(""String_Node_Str"",rs.getString(4));
    assertEquals(""String_Node_Str"",rs.getString(""String_Node_Str""));
    assertEquals(""String_Node_Str"",rs.getString(""String_Node_Str""));
    assertEquals(""String_Node_Str"",rs.getString(""String_Node_Str""));
    assertEquals(""String_Node_Str"",rs.getString(""String_Node_Str""));
    assertFalse(rs.next());
    query=""String_Node_Str"" + dataTableName + ""String_Node_Str"";
    rs=conn.createStatement().executeQuery(""String_Node_Str"" + query);
    if (localIndex) {
      assertEquals(""String_Node_Str"" + dataTableName + ""String_Node_Str"",QueryUtil.getExplainPlan(rs));
    }
 else {
      assertEquals(""String_Node_Str"" + indexName,QueryUtil.getExplainPlan(rs));
    }
    rs=conn.createStatement().executeQuery(query);
    assertTrue(rs.next());
    assertEquals(""String_Node_Str"",rs.getString(1));
    assertEquals(""String_Node_Str"",rs.getString(""String_Node_Str""));
    assertEquals(""String_Node_Str"",rs.getString(2));
    assertEquals(""String_Node_Str"",rs.getString(""String_Node_Str""));
    assertEquals(""String_Node_Str"",rs.getString(3));
    assertEquals(""String_Node_Str"",rs.getString(""String_Node_Str""));
    assertEquals(""String_Node_Str"",rs.getString(4));
    assertEquals(""String_Node_Str"",rs.getString(""String_Node_Str""));
    assertEquals(""String_Node_Str"",rs.getString(5));
    assertEquals(""String_Node_Str"",rs.getString(""String_Node_Str""));
    assertTrue(rs.next());
    assertEquals(""String_Node_Str"",rs.getString(1));
    assertEquals(""String_Node_Str"",rs.getString(""String_Node_Str""));
    assertEquals(""String_Node_Str"",rs.getString(2));
    assertEquals(""String_Node_Str"",rs.getString(""String_Node_Str""));
    assertEquals(""String_Node_Str"",rs.getString(3));
    assertEquals(""String_Node_Str"",rs.getString(""String_Node_Str""));
    assertEquals(""String_Node_Str"",rs.getString(4));
    assertEquals(""String_Node_Str"",rs.getString(""String_Node_Str""));
    assertEquals(""String_Node_Str"",rs.getString(5));
    assertEquals(""String_Node_Str"",rs.getString(""String_Node_Str""));
    assertFalse(rs.next());
    conn.createStatement().execute(""String_Node_Str"" + indexName + ""String_Node_Str""+ dataTableName);
  }
  finally {
    conn.close();
  }
}",0.9619862200047518
112430,"protected void helpTestSelectDistinct(boolean mutable,boolean localIndex) throws Exception {
  String dataTableName=generateUniqueName();
  String fullDataTableName=INDEX_DATA_SCHEMA + QueryConstants.NAME_SEPARATOR + dataTableName;
  String indexName=generateUniqueName();
  Properties props=PropertiesUtil.deepCopy(TEST_PROPERTIES);
  Connection conn=DriverManager.getConnection(getUrl(),props);
  try {
    conn.setAutoCommit(false);
    createDataTable(conn,fullDataTableName,mutable ? ""String_Node_Str"" : ""String_Node_Str"");
    populateDataTable(conn,fullDataTableName);
    String ddl=""String_Node_Str"" + (localIndex ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ indexName+ ""String_Node_Str""+ fullDataTableName+ ""String_Node_Str"";
    PreparedStatement stmt=conn.prepareStatement(ddl);
    stmt.execute();
    String sql=""String_Node_Str"" + fullDataTableName + ""String_Node_Str"";
    ResultSet rs=conn.createStatement().executeQuery(""String_Node_Str"" + sql);
    String expectedPlan=""String_Node_Str"" + (localIndex ? fullDataTableName + ""String_Node_Str"" : ""String_Node_Str"" + indexName + ""String_Node_Str"") + ""String_Node_Str""+ (localIndex ? ""String_Node_Str"" : ""String_Node_Str"");
    assertEquals(expectedPlan,QueryUtil.getExplainPlan(rs));
    rs=conn.createStatement().executeQuery(sql);
    assertTrue(rs.next());
    assertEquals(2,rs.getInt(1));
    assertTrue(rs.next());
    assertEquals(3,rs.getInt(1));
    assertFalse(rs.next());
    conn.createStatement().execute(""String_Node_Str"" + indexName + ""String_Node_Str""+ fullDataTableName);
  }
  finally {
    conn.close();
  }
}","protected void helpTestSelectDistinct(boolean mutable,boolean localIndex) throws Exception {
  String dataTableName=generateUniqueName();
  String fullDataTableName=INDEX_DATA_SCHEMA + QueryConstants.NAME_SEPARATOR + dataTableName;
  String indexName=generateUniqueName();
  Properties props=PropertiesUtil.deepCopy(TEST_PROPERTIES);
  Connection conn=DriverManager.getConnection(getUrl(),props);
  try {
    conn.setAutoCommit(false);
    createDataTable(conn,fullDataTableName,mutable ? ""String_Node_Str"" : ""String_Node_Str"");
    populateDataTable(conn,fullDataTableName);
    String ddl=""String_Node_Str"" + (localIndex ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ indexName+ ""String_Node_Str""+ fullDataTableName+ ""String_Node_Str"";
    conn.createStatement().execute(ddl);
    String sql=""String_Node_Str"" + fullDataTableName + ""String_Node_Str"";
    ResultSet rs=conn.createStatement().executeQuery(""String_Node_Str"" + sql);
    String expectedPlan=""String_Node_Str"" + (localIndex ? fullDataTableName + ""String_Node_Str"" : ""String_Node_Str"" + indexName + ""String_Node_Str"") + ""String_Node_Str""+ (localIndex ? ""String_Node_Str"" : ""String_Node_Str"");
    assertEquals(expectedPlan,QueryUtil.getExplainPlan(rs));
    rs=conn.createStatement().executeQuery(sql);
    assertTrue(rs.next());
    assertEquals(2,rs.getInt(1));
    assertTrue(rs.next());
    assertEquals(3,rs.getInt(1));
    assertFalse(rs.next());
    conn.createStatement().execute(""String_Node_Str"" + indexName + ""String_Node_Str""+ fullDataTableName);
  }
  finally {
    conn.close();
  }
}",0.967984934086629
112431,"protected void helpTestSelectAliasAndOrderByWithIndex(boolean mutable,boolean localIndex) throws Exception {
  String dataTableName=generateUniqueName();
  String fullDataTableName=INDEX_DATA_SCHEMA + QueryConstants.NAME_SEPARATOR + dataTableName;
  String indexName=generateUniqueName();
  Properties props=PropertiesUtil.deepCopy(TEST_PROPERTIES);
  Connection conn=DriverManager.getConnection(getUrl(),props);
  try {
    conn.setAutoCommit(false);
    createDataTable(conn,fullDataTableName,mutable ? ""String_Node_Str"" : ""String_Node_Str"");
    populateDataTable(conn,fullDataTableName);
    String ddl=""String_Node_Str"" + (localIndex ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ indexName+ ""String_Node_Str""+ fullDataTableName+ ""String_Node_Str"";
    PreparedStatement stmt=conn.prepareStatement(ddl);
    stmt.execute();
    String sql=""String_Node_Str"" + fullDataTableName + ""String_Node_Str"";
    ResultSet rs=conn.createStatement().executeQuery(""String_Node_Str"" + sql);
    assertEquals(""String_Node_Str"" + (localIndex ? ""String_Node_Str"" + fullDataTableName + ""String_Node_Str"" : ""String_Node_Str"" + indexName + ""String_Node_Str""),QueryUtil.getExplainPlan(rs));
    rs=conn.createStatement().executeQuery(sql);
    assertTrue(rs.next());
    assertEquals(2,rs.getInt(1));
    assertTrue(rs.next());
    assertEquals(3,rs.getInt(1));
    assertFalse(rs.next());
    conn.createStatement().execute(""String_Node_Str"" + indexName + ""String_Node_Str""+ fullDataTableName);
  }
  finally {
    conn.close();
  }
}","protected void helpTestSelectAliasAndOrderByWithIndex(boolean mutable,boolean localIndex) throws Exception {
  String dataTableName=generateUniqueName();
  String fullDataTableName=INDEX_DATA_SCHEMA + QueryConstants.NAME_SEPARATOR + dataTableName;
  String indexName=generateUniqueName();
  Properties props=PropertiesUtil.deepCopy(TEST_PROPERTIES);
  Connection conn=DriverManager.getConnection(getUrl(),props);
  try {
    conn.setAutoCommit(false);
    createDataTable(conn,fullDataTableName,mutable ? ""String_Node_Str"" : ""String_Node_Str"");
    populateDataTable(conn,fullDataTableName);
    String ddl=""String_Node_Str"" + (localIndex ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ indexName+ ""String_Node_Str""+ fullDataTableName+ ""String_Node_Str"";
    conn.createStatement().execute(ddl);
    String sql=""String_Node_Str"" + fullDataTableName + ""String_Node_Str"";
    ResultSet rs=conn.createStatement().executeQuery(""String_Node_Str"" + sql);
    assertEquals(""String_Node_Str"" + (localIndex ? ""String_Node_Str"" + fullDataTableName + ""String_Node_Str"" : ""String_Node_Str"" + indexName + ""String_Node_Str""),QueryUtil.getExplainPlan(rs));
    rs=conn.createStatement().executeQuery(sql);
    assertTrue(rs.next());
    assertEquals(2,rs.getInt(1));
    assertTrue(rs.next());
    assertEquals(3,rs.getInt(1));
    assertFalse(rs.next());
    conn.createStatement().execute(""String_Node_Str"" + indexName + ""String_Node_Str""+ fullDataTableName);
  }
  finally {
    conn.close();
  }
}",0.966381015161503
112432,"@Test public void testIndexWithNullableDateCol() throws Exception {
  String tableName=""String_Node_Str"" + generateUniqueName();
  String indexName=""String_Node_Str"" + generateUniqueName();
  String fullTableName=SchemaUtil.getTableName(TestUtil.DEFAULT_SCHEMA_NAME,tableName);
  String fullIndexName=SchemaUtil.getTableName(TestUtil.DEFAULT_SCHEMA_NAME,indexName);
  Properties props=PropertiesUtil.deepCopy(TEST_PROPERTIES);
  try (Connection conn=DriverManager.getConnection(getUrl(),props)){
    conn.setAutoCommit(false);
    Date date=new Date(System.currentTimeMillis());
    TestUtil.createMultiCFTestTable(conn,fullTableName,tableDDLOptions);
    populateMultiCFTestTable(fullTableName,date);
    String ddl=""String_Node_Str"" + (localIndex ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ indexName+ ""String_Node_Str""+ fullTableName+ ""String_Node_Str"";
    PreparedStatement stmt=conn.prepareStatement(ddl);
    stmt.execute();
    String query=""String_Node_Str"" + fullTableName;
    ResultSet rs=conn.createStatement().executeQuery(""String_Node_Str"" + query);
    if (localIndex) {
      assertEquals(""String_Node_Str"" + fullTableName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",QueryUtil.getExplainPlan(rs));
    }
 else {
      assertEquals(""String_Node_Str"" + fullIndexName + ""String_Node_Str""+ ""String_Node_Str"",QueryUtil.getExplainPlan(rs));
    }
    rs=conn.createStatement().executeQuery(query);
    assertTrue(rs.next());
    assertEquals(2,rs.getInt(1));
    assertTrue(rs.next());
    assertEquals(1,rs.getInt(1));
    assertTrue(rs.next());
    assertEquals(3,rs.getInt(1));
    assertFalse(rs.next());
    query=""String_Node_Str"" + fullTableName + ""String_Node_Str"";
    rs=conn.createStatement().executeQuery(""String_Node_Str"" + query);
    if (localIndex) {
      assertEquals(""String_Node_Str"" + fullTableName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",QueryUtil.getExplainPlan(rs));
    }
 else {
      assertEquals(""String_Node_Str"" + fullIndexName + ""String_Node_Str""+ ""String_Node_Str"",QueryUtil.getExplainPlan(rs));
    }
    rs=conn.createStatement().executeQuery(query);
    assertTrue(rs.next());
    assertEquals(date,rs.getDate(1));
    assertTrue(rs.next());
    assertEquals(new Date(date.getTime() + MILLIS_IN_DAY),rs.getDate(1));
    assertTrue(rs.next());
    assertEquals(new Date(date.getTime() + 2 * MILLIS_IN_DAY),rs.getDate(1));
    assertFalse(rs.next());
  }
 }","@Test public void testIndexWithNullableDateCol() throws Exception {
  String tableName=""String_Node_Str"" + generateUniqueName();
  String indexName=""String_Node_Str"" + generateUniqueName();
  String fullTableName=SchemaUtil.getTableName(TestUtil.DEFAULT_SCHEMA_NAME,tableName);
  String fullIndexName=SchemaUtil.getTableName(TestUtil.DEFAULT_SCHEMA_NAME,indexName);
  Properties props=PropertiesUtil.deepCopy(TEST_PROPERTIES);
  try (Connection conn=DriverManager.getConnection(getUrl(),props)){
    conn.setAutoCommit(false);
    Date date=new Date(System.currentTimeMillis());
    TestUtil.createMultiCFTestTable(conn,fullTableName,tableDDLOptions);
    populateMultiCFTestTable(fullTableName,date);
    String ddl=""String_Node_Str"" + (localIndex ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ indexName+ ""String_Node_Str""+ fullTableName+ ""String_Node_Str"";
    conn.createStatement().execute(ddl);
    String query=""String_Node_Str"" + fullTableName;
    ResultSet rs=conn.createStatement().executeQuery(""String_Node_Str"" + query);
    if (localIndex) {
      assertEquals(""String_Node_Str"" + fullTableName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",QueryUtil.getExplainPlan(rs));
    }
 else {
      assertEquals(""String_Node_Str"" + fullIndexName + ""String_Node_Str""+ ""String_Node_Str"",QueryUtil.getExplainPlan(rs));
    }
    rs=conn.createStatement().executeQuery(query);
    assertTrue(rs.next());
    assertEquals(2,rs.getInt(1));
    assertTrue(rs.next());
    assertEquals(1,rs.getInt(1));
    assertTrue(rs.next());
    assertEquals(3,rs.getInt(1));
    assertFalse(rs.next());
    query=""String_Node_Str"" + fullTableName + ""String_Node_Str"";
    rs=conn.createStatement().executeQuery(""String_Node_Str"" + query);
    if (localIndex) {
      assertEquals(""String_Node_Str"" + fullTableName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",QueryUtil.getExplainPlan(rs));
    }
 else {
      assertEquals(""String_Node_Str"" + fullIndexName + ""String_Node_Str""+ ""String_Node_Str"",QueryUtil.getExplainPlan(rs));
    }
    rs=conn.createStatement().executeQuery(query);
    assertTrue(rs.next());
    assertEquals(date,rs.getDate(1));
    assertTrue(rs.next());
    assertEquals(new Date(date.getTime() + MILLIS_IN_DAY),rs.getDate(1));
    assertTrue(rs.next());
    assertEquals(new Date(date.getTime() + 2 * MILLIS_IN_DAY),rs.getDate(1));
    assertFalse(rs.next());
  }
 }",0.9790468364831552
112433,"@Test public void testSelectDistinctOnTableWithSecondaryImmutableIndex() throws Exception {
  Properties props=PropertiesUtil.deepCopy(TEST_PROPERTIES);
  String tableName=""String_Node_Str"" + generateUniqueName();
  String indexName=""String_Node_Str"" + generateUniqueName();
  String fullTableName=SchemaUtil.getTableName(TestUtil.DEFAULT_SCHEMA_NAME,tableName);
  try (Connection conn=DriverManager.getConnection(getUrl(),props)){
    conn.setAutoCommit(false);
    String ddl=""String_Node_Str"" + fullTableName + TestUtil.TEST_TABLE_SCHEMA+ tableDDLOptions;
    Statement stmt=conn.createStatement();
    stmt.execute(ddl);
    BaseTest.populateTestTable(fullTableName);
    ddl=""String_Node_Str"" + (localIndex ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ indexName+ ""String_Node_Str""+ fullTableName+ ""String_Node_Str"";
    PreparedStatement pstmt=conn.prepareStatement(ddl);
    pstmt.execute();
    ResultSet rs=conn.createStatement().executeQuery(""String_Node_Str"" + fullTableName + ""String_Node_Str"");
    assertTrue(rs.next());
    assertEquals(3,rs.getInt(1));
    assertTrue(rs.next());
    assertEquals(4,rs.getInt(1));
    assertTrue(rs.next());
    assertEquals(5,rs.getInt(1));
    assertFalse(rs.next());
  }
 }","@Test public void testSelectDistinctOnTableWithSecondaryImmutableIndex() throws Exception {
  Properties props=PropertiesUtil.deepCopy(TEST_PROPERTIES);
  String tableName=""String_Node_Str"" + generateUniqueName();
  String indexName=""String_Node_Str"" + generateUniqueName();
  String fullTableName=SchemaUtil.getTableName(TestUtil.DEFAULT_SCHEMA_NAME,tableName);
  try (Connection conn=DriverManager.getConnection(getUrl(),props)){
    conn.setAutoCommit(false);
    String ddl=""String_Node_Str"" + fullTableName + TestUtil.TEST_TABLE_SCHEMA+ tableDDLOptions;
    Statement stmt=conn.createStatement();
    stmt.execute(ddl);
    BaseTest.populateTestTable(fullTableName);
    ddl=""String_Node_Str"" + (localIndex ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ indexName+ ""String_Node_Str""+ fullTableName+ ""String_Node_Str"";
    conn.createStatement().execute(ddl);
    ResultSet rs=conn.createStatement().executeQuery(""String_Node_Str"" + fullTableName + ""String_Node_Str"");
    assertTrue(rs.next());
    assertEquals(3,rs.getInt(1));
    assertTrue(rs.next());
    assertEquals(4,rs.getInt(1));
    assertTrue(rs.next());
    assertEquals(5,rs.getInt(1));
    assertFalse(rs.next());
  }
 }",0.964840556009812
112434,"@Test public void testIndexWithDecimalCol() throws Exception {
  Properties props=PropertiesUtil.deepCopy(TEST_PROPERTIES);
  String tableName=""String_Node_Str"" + generateUniqueName();
  String indexName=""String_Node_Str"" + generateUniqueName();
  String fullTableName=SchemaUtil.getTableName(TestUtil.DEFAULT_SCHEMA_NAME,tableName);
  String fullIndexName=SchemaUtil.getTableName(TestUtil.DEFAULT_SCHEMA_NAME,indexName);
  try (Connection conn=DriverManager.getConnection(getUrl(),props)){
    conn.setAutoCommit(false);
    String query;
    ResultSet rs;
    Date date=new Date(System.currentTimeMillis());
    TestUtil.createMultiCFTestTable(conn,fullTableName,tableDDLOptions);
    populateMultiCFTestTable(fullTableName,date);
    String ddl=null;
    ddl=""String_Node_Str"" + (localIndex ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ indexName+ ""String_Node_Str""+ fullTableName+ ""String_Node_Str"";
    PreparedStatement stmt=conn.prepareStatement(ddl);
    stmt.execute();
    query=""String_Node_Str"" + fullTableName;
    rs=conn.createStatement().executeQuery(""String_Node_Str"" + query);
    if (localIndex) {
      assertEquals(""String_Node_Str"" + fullTableName + ""String_Node_Str"",QueryUtil.getExplainPlan(rs));
    }
 else {
      assertEquals(""String_Node_Str"" + fullIndexName,QueryUtil.getExplainPlan(rs));
    }
    rs=conn.createStatement().executeQuery(query);
    assertTrue(rs.next());
    assertEquals(new BigDecimal(""String_Node_Str""),rs.getBigDecimal(1));
    assertEquals(new BigDecimal(""String_Node_Str""),rs.getBigDecimal(2));
    assertEquals(new BigDecimal(""String_Node_Str""),rs.getBigDecimal(3));
    assertTrue(rs.next());
    assertEquals(new BigDecimal(""String_Node_Str""),rs.getBigDecimal(1));
    assertEquals(new BigDecimal(""String_Node_Str""),rs.getBigDecimal(2));
    assertEquals(new BigDecimal(""String_Node_Str""),rs.getBigDecimal(3));
    assertTrue(rs.next());
    assertEquals(new BigDecimal(""String_Node_Str""),rs.getBigDecimal(1));
    assertEquals(new BigDecimal(""String_Node_Str""),rs.getBigDecimal(2));
    assertEquals(new BigDecimal(""String_Node_Str""),rs.getBigDecimal(3));
    assertFalse(rs.next());
  }
 }","@Test public void testIndexWithDecimalCol() throws Exception {
  Properties props=PropertiesUtil.deepCopy(TEST_PROPERTIES);
  String tableName=""String_Node_Str"" + generateUniqueName();
  String indexName=""String_Node_Str"" + generateUniqueName();
  String fullTableName=SchemaUtil.getTableName(TestUtil.DEFAULT_SCHEMA_NAME,tableName);
  String fullIndexName=SchemaUtil.getTableName(TestUtil.DEFAULT_SCHEMA_NAME,indexName);
  try (Connection conn=DriverManager.getConnection(getUrl(),props)){
    conn.setAutoCommit(false);
    String query;
    ResultSet rs;
    Date date=new Date(System.currentTimeMillis());
    TestUtil.createMultiCFTestTable(conn,fullTableName,tableDDLOptions);
    populateMultiCFTestTable(fullTableName,date);
    String ddl=null;
    ddl=""String_Node_Str"" + (localIndex ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ indexName+ ""String_Node_Str""+ fullTableName+ ""String_Node_Str"";
    conn.createStatement().execute(ddl);
    query=""String_Node_Str"" + fullTableName;
    rs=conn.createStatement().executeQuery(""String_Node_Str"" + query);
    if (localIndex) {
      assertEquals(""String_Node_Str"" + fullTableName + ""String_Node_Str"",QueryUtil.getExplainPlan(rs));
    }
 else {
      assertEquals(""String_Node_Str"" + fullIndexName,QueryUtil.getExplainPlan(rs));
    }
    rs=conn.createStatement().executeQuery(query);
    assertTrue(rs.next());
    assertEquals(new BigDecimal(""String_Node_Str""),rs.getBigDecimal(1));
    assertEquals(new BigDecimal(""String_Node_Str""),rs.getBigDecimal(2));
    assertEquals(new BigDecimal(""String_Node_Str""),rs.getBigDecimal(3));
    assertTrue(rs.next());
    assertEquals(new BigDecimal(""String_Node_Str""),rs.getBigDecimal(1));
    assertEquals(new BigDecimal(""String_Node_Str""),rs.getBigDecimal(2));
    assertEquals(new BigDecimal(""String_Node_Str""),rs.getBigDecimal(3));
    assertTrue(rs.next());
    assertEquals(new BigDecimal(""String_Node_Str""),rs.getBigDecimal(1));
    assertEquals(new BigDecimal(""String_Node_Str""),rs.getBigDecimal(2));
    assertEquals(new BigDecimal(""String_Node_Str""),rs.getBigDecimal(3));
    assertFalse(rs.next());
  }
 }",0.9804378202142524
112435,"private void testNoDuplicatesAfterUpdateStats(String splitKey) throws Throwable {
  Connection conn;
  PreparedStatement stmt;
  ResultSet rs;
  Properties props=PropertiesUtil.deepCopy(TEST_PROPERTIES);
  conn=DriverManager.getConnection(getUrl(),props);
  conn.createStatement().execute(""String_Node_Str"" + fullTableName + ""String_Node_Str""+ (splitKey != null ? ""String_Node_Str"" + splitKey + ""String_Node_Str"" : ""String_Node_Str""));
  conn.createStatement().execute(""String_Node_Str"" + fullTableName + ""String_Node_Str"");
  conn.createStatement().execute(""String_Node_Str"" + fullTableName + ""String_Node_Str"");
  conn.commit();
  stmt=conn.prepareStatement(""String_Node_Str"" + fullTableName);
  stmt.execute();
  rs=conn.createStatement().executeQuery(""String_Node_Str"" + fullTableName + ""String_Node_Str"");
  assertTrue(rs.next());
  assertEquals(""String_Node_Str"",rs.getString(1));
  assertTrue(rs.next());
  assertEquals(""String_Node_Str"",rs.getString(1));
  assertTrue(!rs.next());
  conn.close();
}","private void testNoDuplicatesAfterUpdateStats(String splitKey) throws Throwable {
  Connection conn;
  PreparedStatement stmt;
  ResultSet rs;
  Properties props=PropertiesUtil.deepCopy(TEST_PROPERTIES);
  conn=DriverManager.getConnection(getUrl(),props);
  conn.createStatement().execute(""String_Node_Str"" + fullTableName + ""String_Node_Str""+ tableDDLOptions+ (splitKey != null ? ""String_Node_Str"" + splitKey + ""String_Node_Str"" : ""String_Node_Str""));
  conn.createStatement().execute(""String_Node_Str"" + fullTableName + ""String_Node_Str"");
  conn.createStatement().execute(""String_Node_Str"" + fullTableName + ""String_Node_Str"");
  conn.commit();
  stmt=conn.prepareStatement(""String_Node_Str"" + fullTableName);
  stmt.execute();
  rs=conn.createStatement().executeQuery(""String_Node_Str"" + fullTableName + ""String_Node_Str"");
  assertTrue(rs.next());
  assertEquals(""String_Node_Str"",rs.getString(1));
  assertTrue(rs.next());
  assertEquals(""String_Node_Str"",rs.getString(1));
  assertTrue(!rs.next());
  conn.close();
}",0.9916214884179398
112436,"public Pherf(String[] args) throws Exception {
  CommandLineParser parser=new PosixParser();
  CommandLine command=null;
  HelpFormatter hf=new HelpFormatter();
  try {
    command=parser.parse(options,args);
  }
 catch (  ParseException e) {
    hf.printHelp(""String_Node_Str"",options);
    System.exit(1);
  }
  properties=PherfConstants.create().getProperties(PherfConstants.PHERF_PROPERTIES,false);
  dropPherfTablesRegEx=command.getOptionValue(""String_Node_Str"",null);
  monitor=command.hasOption(""String_Node_Str"");
  String monitorFrequency=(command.hasOption(""String_Node_Str"") && command.hasOption(""String_Node_Str"")) ? command.getOptionValue(""String_Node_Str"") : properties.getProperty(""String_Node_Str"");
  properties.setProperty(""String_Node_Str"",monitorFrequency);
  logger.debug(""String_Node_Str"" + monitor);
  logger.debug(""String_Node_Str"" + monitorFrequency);
  preLoadData=command.hasOption(""String_Node_Str"");
  executeQuerySets=command.hasOption(""String_Node_Str"");
  zookeeper=command.getOptionValue(""String_Node_Str"",""String_Node_Str"");
  queryHint=command.getOptionValue(""String_Node_Str"",null);
  exportCSV=command.hasOption(""String_Node_Str"");
  isFunctional=command.hasOption(""String_Node_Str"");
  listFiles=command.hasOption(""String_Node_Str"");
  applySchema=!command.hasOption(""String_Node_Str"");
  writeRuntimeResults=!command.hasOption(""String_Node_Str"");
  scenarioFile=command.hasOption(""String_Node_Str"") ? command.getOptionValue(""String_Node_Str"") : null;
  schemaFile=command.hasOption(""String_Node_Str"") ? command.getOptionValue(""String_Node_Str"") : null;
  rowCountOverride=Integer.parseInt(command.getOptionValue(""String_Node_Str"",""String_Node_Str""));
  generateStatistics=command.hasOption(""String_Node_Str"") ? GeneratePhoenixStats.YES : GeneratePhoenixStats.NO;
  String writerThreadPoolSize=command.getOptionValue(""String_Node_Str"",properties.getProperty(""String_Node_Str""));
  properties.setProperty(""String_Node_Str"",writerThreadPoolSize);
  label=command.getOptionValue(""String_Node_Str"",null);
  compareResults=command.getOptionValue(""String_Node_Str"",null);
  if ((command.hasOption(""String_Node_Str"") || (args == null || args.length == 0)) && !command.hasOption(""String_Node_Str"")) {
    hf.printHelp(""String_Node_Str"",options);
    System.exit(1);
  }
  PhoenixUtil.setZookeeper(zookeeper);
  PhoenixUtil.setRowCountOverride(rowCountOverride);
  ResultUtil.setFileSuffix(label);
}","public Pherf(String[] args) throws Exception {
  CommandLineParser parser=new PosixParser();
  CommandLine command=null;
  HelpFormatter hf=new HelpFormatter();
  try {
    command=parser.parse(options,args);
  }
 catch (  ParseException e) {
    hf.printHelp(""String_Node_Str"",options);
    System.exit(1);
  }
  properties=PherfConstants.create().getProperties(PherfConstants.PHERF_PROPERTIES,false);
  dropPherfTablesRegEx=command.getOptionValue(""String_Node_Str"",null);
  monitor=command.hasOption(""String_Node_Str"");
  String monitorFrequency=(command.hasOption(""String_Node_Str"") && command.hasOption(""String_Node_Str"")) ? command.getOptionValue(""String_Node_Str"") : properties.getProperty(""String_Node_Str"");
  properties.setProperty(""String_Node_Str"",monitorFrequency);
  logger.debug(""String_Node_Str"" + monitor);
  logger.debug(""String_Node_Str"" + monitorFrequency);
  preLoadData=command.hasOption(""String_Node_Str"");
  executeQuerySets=command.hasOption(""String_Node_Str"");
  zookeeper=command.getOptionValue(""String_Node_Str"",""String_Node_Str"");
  queryHint=command.getOptionValue(""String_Node_Str"",null);
  isFunctional=command.hasOption(""String_Node_Str"");
  listFiles=command.hasOption(""String_Node_Str"");
  applySchema=!command.hasOption(""String_Node_Str"");
  writeRuntimeResults=!command.hasOption(""String_Node_Str"");
  scenarioFile=command.hasOption(""String_Node_Str"") ? command.getOptionValue(""String_Node_Str"") : null;
  schemaFile=command.hasOption(""String_Node_Str"") ? command.getOptionValue(""String_Node_Str"") : null;
  rowCountOverride=Integer.parseInt(command.getOptionValue(""String_Node_Str"",""String_Node_Str""));
  generateStatistics=command.hasOption(""String_Node_Str"") ? GeneratePhoenixStats.YES : GeneratePhoenixStats.NO;
  String writerThreadPoolSize=command.getOptionValue(""String_Node_Str"",properties.getProperty(""String_Node_Str""));
  properties.setProperty(""String_Node_Str"",writerThreadPoolSize);
  label=command.getOptionValue(""String_Node_Str"",null);
  compareResults=command.getOptionValue(""String_Node_Str"",null);
  if ((command.hasOption(""String_Node_Str"") || (args == null || args.length == 0)) && !command.hasOption(""String_Node_Str"")) {
    hf.printHelp(""String_Node_Str"",options);
    System.exit(1);
  }
  PhoenixUtil.setZookeeper(zookeeper);
  PhoenixUtil.setRowCountOverride(rowCountOverride);
  ResultUtil.setFileSuffix(label);
}",0.9895963379109448
112437,"/** 
 * Multithreaded Differ
 * @param threadName
 * @param query
 * @param threadName
 * @param threadTime
 * @param numberOfExecutions
 * @param executionDurationInMs
 */
MultithreadedDiffer(String threadName,Query query,ThreadTime threadTime,long numberOfExecutions,long executionDurationInMs){
  this.query=query;
  this.threadName=threadName;
  this.threadTime=threadTime;
  this.numberOfExecutions=numberOfExecutions;
  this.executionDurationInMs=executionDurationInMs;
}","/** 
 * Multithreaded Differ
 * @param threadName
 * @param query
 * @param threadName
 * @param threadTime
 * @param numberOfExecutions
 * @param executionDurationInMs
 */
MultithreadedDiffer(String threadName,Query query,ThreadTime threadTime,long numberOfExecutions,long executionDurationInMs){
  this.query=query;
  this.threadTime=threadTime;
  this.numberOfExecutions=numberOfExecutions;
  this.executionDurationInMs=executionDurationInMs;
}",0.7943722943722944
112438,"public void setColumn(List<Column> column){
  this.column=column;
}","@SuppressWarnings(""String_Node_Str"") public void setColumn(List<Column> column){
  this.column=column;
}",0.783625730994152
112439,"public void setQuery(List<Query> query){
  this.query=query;
}","@SuppressWarnings(""String_Node_Str"") public void setQuery(List<Query> query){
  this.query=query;
}",0.7701863354037267
112440,"public void setQuerySet(List<QuerySet> querySet){
  this.querySet=querySet;
}","@SuppressWarnings(""String_Node_Str"") public void setQuerySet(List<QuerySet> querySet){
  this.querySet=querySet;
}",0.806282722513089
112441,"public static void writeDataModel(DataModel data,OutputStream output) throws JAXBException {
  JAXBContext jaxbContext=JAXBContext.newInstance(DataModel.class);
  Marshaller jaxbMarshaller=jaxbContext.createMarshaller();
  jaxbMarshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT,Boolean.TRUE);
  jaxbMarshaller.marshal(data,output);
}","@SuppressWarnings(""String_Node_Str"") public static void writeDataModel(DataModel data,OutputStream output) throws JAXBException {
  JAXBContext jaxbContext=JAXBContext.newInstance(DataModel.class);
  Marshaller jaxbMarshaller=jaxbContext.createMarshaller();
  jaxbMarshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT,Boolean.TRUE);
  jaxbMarshaller.marshal(data,output);
}",0.9481065918653576
112442,"public FileLoaderException(String message,Exception e){
  super(message,e);
}","@SuppressWarnings(""String_Node_Str"") public FileLoaderException(String message,Exception e){
  super(message,e);
}",0.806282722513089
112443,"/** 
 * Default the writers to use up all available cores for threads.
 * @param parser
 * @throws Exception
 */
public DataLoader(Properties properties,XMLConfigParser parser) throws Exception {
  this.parser=parser;
  this.properties=properties;
  this.rulesApplier=new RulesApplier(this.parser);
  this.resultUtil=new ResultUtil();
  int size=Integer.parseInt(properties.getProperty(""String_Node_Str""));
  this.threadPoolSize=(size == 0) ? Runtime.getRuntime().availableProcessors() : size;
  this.pool=Executors.newFixedThreadPool(this.threadPoolSize);
  String bSize=properties.getProperty(""String_Node_Str"");
  this.batchSize=(bSize == null) ? PherfConstants.DEFAULT_BATCH_SIZE : Integer.parseInt(bSize);
}","/** 
 * Default the writers to use up all available cores for threads.
 * @param parser
 * @throws Exception
 */
public DataLoader(Properties properties,XMLConfigParser parser) throws Exception {
  this.parser=parser;
  this.rulesApplier=new RulesApplier(this.parser);
  this.resultUtil=new ResultUtil();
  int size=Integer.parseInt(properties.getProperty(""String_Node_Str""));
  this.threadPoolSize=(size == 0) ? Runtime.getRuntime().availableProcessors() : size;
  this.pool=Executors.newFixedThreadPool(this.threadPoolSize);
  String bSize=properties.getProperty(""String_Node_Str"");
  this.batchSize=(bSize == null) ? PherfConstants.DEFAULT_BATCH_SIZE : Integer.parseInt(bSize);
}",0.9784791965566716
112444,"public void setScenarioResult(List<ScenarioResult> scenarioResult){
  this.scenarioResult=scenarioResult;
}","@SuppressWarnings(""String_Node_Str"") public void setScenarioResult(List<ScenarioResult> scenarioResult){
  this.scenarioResult=scenarioResult;
}",0.852589641434263
112445,"public QueryResult(){
}","@SuppressWarnings(""String_Node_Str"") public QueryResult(){
}",0.5542168674698795
112446,"public synchronized void setThreadTimes(List<ThreadTime> threadTimes){
  this.threadTimes=threadTimes;
}","@SuppressWarnings(""String_Node_Str"") public synchronized void setThreadTimes(List<ThreadTime> threadTimes){
  this.threadTimes=threadTimes;
}",0.8489795918367347
112447,"public void setQueryResults(List<QueryResult> queryResults){
  this.queryResults=queryResults;
}","@SuppressWarnings(""String_Node_Str"") public void setQueryResults(List<QueryResult> queryResults){
  this.queryResults=queryResults;
}",0.8384279475982532
112448,"@Test public void testGetInstanceString(){
  DateTimeZone instance=JodaTimezoneCache.getInstance(""String_Node_Str"");
  assertTrue(instance instanceof DateTimeZone);
}","@Test public void testGetInstanceString(){
  DateTimeZone instance=JodaTimezoneCache.getInstance(""String_Node_Str"");
  assertNotNull(instance);
}",0.8938906752411575
112449,"@Test public void testGetInstanceByteBufferUTC(){
  DateTimeZone instance=JodaTimezoneCache.getInstance(ByteBuffer.wrap(Bytes.toBytes(""String_Node_Str"")));
  assertTrue(instance instanceof DateTimeZone);
}","@Test public void testGetInstanceByteBufferUTC(){
  DateTimeZone instance=JodaTimezoneCache.getInstance(ByteBuffer.wrap(Bytes.toBytes(""String_Node_Str"")));
  assertNotNull(instance);
}",0.9151670951156812
112450,"@Test public void testGetInstanceImmutableBytesWritable(){
  ImmutableBytesWritable ptr=new ImmutableBytesWritable(Bytes.toBytes(""String_Node_Str""));
  DateTimeZone instance=JodaTimezoneCache.getInstance(ptr);
  assertTrue(instance instanceof DateTimeZone);
}","@Test public void testGetInstanceImmutableBytesWritable(){
  ImmutableBytesWritable ptr=new ImmutableBytesWritable(Bytes.toBytes(""String_Node_Str""));
  DateTimeZone instance=JodaTimezoneCache.getInstance(ptr);
  assertNotNull(instance);
}",0.89738430583501
112451,"@Test public void testInsertingRetrivingTimestamp() throws Exception {
  Connection conn=DriverManager.getConnection(getUrl());
  String ddl=""String_Node_Str"";
  conn.createStatement().execute(ddl);
  String dml=""String_Node_Str"";
  PreparedStatement stmt=conn.prepareStatement(dml);
  stmt.setInt(1,1);
  Calendar cal=Calendar.getInstance();
  cal.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
  long time=System.currentTimeMillis();
  stmt.setTimestamp(2,new Timestamp(time),cal);
  stmt.executeUpdate();
  conn.commit();
  String query=""String_Node_Str"";
  ResultSet rs=conn.createStatement().executeQuery(query);
  rs.next();
  assertEquals(new Timestamp(time),rs.getTimestamp(1));
}","@Test public void testInsertingRetrivingTimestamp() throws Exception {
  Connection conn=DriverManager.getConnection(getUrl());
  String ddl=""String_Node_Str"";
  conn.createStatement().execute(ddl);
  String dml=""String_Node_Str"";
  PreparedStatement stmt=conn.prepareStatement(dml);
  stmt.setInt(1,1);
  Calendar cal=Calendar.getInstance();
  cal.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
  long time=System.currentTimeMillis();
  stmt.setTimestamp(2,new Timestamp(time),cal);
  stmt.executeUpdate();
  conn.commit();
  String query=""String_Node_Str"";
  ResultSet rs=conn.createStatement().executeQuery(query);
  rs.next();
  assertEquals(new Timestamp(time),rs.getTimestamp(1));
  assertEquals(new Timestamp(time),rs.getTimestamp(""String_Node_Str""));
  assertEquals(new Timestamp(time),rs.getTimestamp(1,cal));
  assertEquals(new Timestamp(time),rs.getTimestamp(""String_Node_Str"",cal));
}",0.869837296620776
112452,"@Test public void testGetDateParser_DefaultTimeZone() throws ParseException {
  Date date=(Date)DateUtil.getDateParser(""String_Node_Str"").parseDateTime(""String_Node_Str"");
  assertEquals(0,date.getTime());
}","@Test public void testGetDateParser_DefaultTimeZone() throws ParseException {
  Date date=DateUtil.getDateParser(""String_Node_Str"").parseDateTime(""String_Node_Str"");
  assertEquals(0,date.getTime());
}",0.9852941176470588
112453,"@Test public void testGetDateParser_CustomTimeZone() throws ParseException {
  Date date=(Date)DateUtil.getDateParser(""String_Node_Str"",TimeZone.getTimeZone(""String_Node_Str"")).parseDateTime(""String_Node_Str"");
  assertEquals(-ONE_HOUR_IN_MILLIS,date.getTime());
}","@Test public void testGetDateParser_CustomTimeZone() throws ParseException {
  Date date=DateUtil.getDateParser(""String_Node_Str"",TimeZone.getTimeZone(""String_Node_Str"")).parseDateTime(""String_Node_Str"");
  assertEquals(-ONE_HOUR_IN_MILLIS,date.getTime());
}",0.9885057471264368
112454,"@Test public void testGetDateParser_LocalTimeZone() throws ParseException {
  Date date=(Date)DateUtil.getDateParser(""String_Node_Str"",TimeZone.getDefault()).parseDateTime(""String_Node_Str"");
  assertEquals(Date.valueOf(""String_Node_Str""),date);
}","@Test public void testGetDateParser_LocalTimeZone() throws ParseException {
  Date date=DateUtil.getDateParser(""String_Node_Str"",TimeZone.getDefault()).parseDateTime(""String_Node_Str"");
  assertEquals(Date.valueOf(""String_Node_Str""),date);
}",0.9877049180327868
112455,"@Override public ParseNode visit(ColumnParseNode node) throws SQLException {
  if (useFullNameForAlias && node.getAlias() != null && node.getTableName() != null && SchemaUtil.normalizeIdentifier(node.getAlias()).equals(node.getName())) {
    node=NODE_FACTORY.column(NODE_FACTORY.table(node.getSchemaName(),node.getTableName()),node.isCaseSensitive() ? '""' + node.getName() + '""' : node.getName(),node.getFullName());
  }
  return super.visit(node);
}","@Override public ParseNode visit(ColumnParseNode node) throws SQLException {
  if (useFullNameForAlias && node.getAlias() != null && node.getTableName() != null && SchemaUtil.normalizeIdentifier(node.getAlias()).equals(node.getName())) {
    node=NODE_FACTORY.column(NODE_FACTORY.table(node.getSchemaName(),node.getTableName()),node.isCaseSensitive() ? '""' + node.getName() + '""' : node.getName(),node.isCaseSensitive() ? '""' + node.getFullName() + '""' : node.getFullName());
  }
  return super.visit(node);
}",0.9395833333333332
112456,"/** 
 * Get array of ColumnInfos that contain Column Name and its associated PDataType
 * @param columns
 * @return
 * @throws SQLException
 */
private ColumnInfo[] generateColumnInfo(List<String> columns) throws SQLException {
  Map<String,Integer> columnNameToTypeMap=Maps.newLinkedHashMap();
  DatabaseMetaData dbmd=conn.getMetaData();
  String escapedTableName=StringUtil.escapeLike(tableName);
  String[] schemaAndTable=escapedTableName.split(""String_Node_Str"");
  ResultSet rs=null;
  try {
    rs=dbmd.getColumns(null,(schemaAndTable.length == 1 ? ""String_Node_Str"" : schemaAndTable[0]),(schemaAndTable.length == 1 ? escapedTableName : schemaAndTable[1]),null);
    while (rs.next()) {
      columnNameToTypeMap.put(rs.getString(QueryUtil.COLUMN_NAME_POSITION),rs.getInt(QueryUtil.DATA_TYPE_POSITION));
    }
  }
  finally {
    if (rs != null) {
      rs.close();
    }
  }
  ColumnInfo[] columnType;
  if (columns == null) {
    int i=0;
    columnType=new ColumnInfo[columnNameToTypeMap.size()];
    for (    Map.Entry<String,Integer> entry : columnNameToTypeMap.entrySet()) {
      columnType[i++]=new ColumnInfo(entry.getKey(),entry.getValue());
    }
  }
 else {
    columnType=new ColumnInfo[columns.size()];
    for (int i=0; i < columns.size(); i++) {
      String columnName=SchemaUtil.normalizeIdentifier(columns.get(i).trim());
      Integer sqlType=columnNameToTypeMap.get(columnName);
      if (sqlType == null) {
        if (isStrict) {
          throw new SQLExceptionInfo.Builder(SQLExceptionCode.COLUMN_NOT_FOUND).setColumnName(columnName).setTableName(tableName).build().buildException();
        }
        unfoundColumnCount++;
      }
 else {
        columnType[i]=new ColumnInfo(columnName,sqlType);
      }
    }
    if (unfoundColumnCount == columns.size()) {
      throw new SQLExceptionInfo.Builder(SQLExceptionCode.COLUMN_NOT_FOUND).setColumnName(Arrays.toString(columns.toArray(new String[0]))).setTableName(tableName).build().buildException();
    }
  }
  return columnType;
}","/** 
 * Get array of ColumnInfos that contain Column Name and its associated PDataType
 * @param columns
 * @return
 * @throws SQLException
 */
private ColumnInfo[] generateColumnInfo(List<String> columns) throws SQLException {
  Map<String,Integer> columnNameToTypeMap=Maps.newLinkedHashMap();
  DatabaseMetaData dbmd=conn.getMetaData();
  String escapedTableName=StringUtil.escapeLike(tableName);
  String[] schemaAndTable=escapedTableName.split(""String_Node_Str"");
  ResultSet rs=null;
  try {
    rs=dbmd.getColumns(null,(schemaAndTable.length == 1 ? ""String_Node_Str"" : schemaAndTable[0]),(schemaAndTable.length == 1 ? escapedTableName : schemaAndTable[1]),null);
    while (rs.next()) {
      columnNameToTypeMap.put(rs.getString(QueryUtil.COLUMN_NAME_POSITION),rs.getInt(QueryUtil.DATA_TYPE_POSITION));
    }
  }
  finally {
    if (rs != null) {
      rs.close();
    }
  }
  ColumnInfo[] columnType;
  if (columns == null) {
    int i=0;
    columnType=new ColumnInfo[columnNameToTypeMap.size()];
    for (    Map.Entry<String,Integer> entry : columnNameToTypeMap.entrySet()) {
      columnType[i++]=new ColumnInfo('""' + entry.getKey() + '""',entry.getValue());
    }
  }
 else {
    columnType=new ColumnInfo[columns.size()];
    for (int i=0; i < columns.size(); i++) {
      String columnName=SchemaUtil.normalizeIdentifier(columns.get(i).trim());
      Integer sqlType=columnNameToTypeMap.get(columnName);
      if (sqlType == null) {
        if (isStrict) {
          throw new SQLExceptionInfo.Builder(SQLExceptionCode.COLUMN_NOT_FOUND).setColumnName(columnName).setTableName(tableName).build().buildException();
        }
        unfoundColumnCount++;
      }
 else {
        columnType[i]=new ColumnInfo('""' + columnName + '""',sqlType);
      }
    }
    if (unfoundColumnCount == columns.size()) {
      throw new SQLExceptionInfo.Builder(SQLExceptionCode.COLUMN_NOT_FOUND).setColumnName(Arrays.toString(columns.toArray(new String[0]))).setTableName(tableName).build().buildException();
    }
  }
  return columnType;
}",0.9891304347826086
112457,"@SuppressWarnings(""String_Node_Str"") public HashJoinRegionScanner(RegionScanner scanner,ScanProjector projector,HashJoinInfo joinInfo,ImmutableBytesWritable tenantId,RegionCoprocessorEnvironment env) throws IOException {
  assert(projector != null);
  this.scanner=scanner;
  this.projector=projector;
  this.joinInfo=joinInfo;
  this.resultQueue=new LinkedList<Tuple>();
  this.hasMore=true;
  if (joinInfo != null) {
    for (    JoinType type : joinInfo.getJoinTypes()) {
      if (type != JoinType.Inner && type != JoinType.Left)       throw new IOException(""String_Node_Str"" + type + ""String_Node_Str"");
    }
    int count=joinInfo.getJoinIds().length;
    this.tempTuples=new List[count];
    this.hashCaches=new HashCache[count];
    this.tempSrcBitSet=new ValueBitSet[count];
    TenantCache cache=GlobalCache.getTenantCache(env,tenantId);
    for (int i=0; i < count; i++) {
      ImmutableBytesPtr joinId=joinInfo.getJoinIds()[i];
      HashCache hashCache=(HashCache)cache.getServerCache(joinId);
      if (hashCache == null)       throw new IOException(""String_Node_Str"" + Bytes.toString(joinId.get(),joinId.getOffset(),joinId.getLength()));
      hashCaches[i]=hashCache;
      tempSrcBitSet[i]=ValueBitSet.newInstance(joinInfo.getSchemas()[i]);
    }
    if (this.projector != null) {
      this.tempDestBitSet=ValueBitSet.newInstance(joinInfo.getJoinedSchema());
      this.projector.setValueBitSet(tempDestBitSet);
    }
  }
}","@SuppressWarnings(""String_Node_Str"") public HashJoinRegionScanner(RegionScanner scanner,ScanProjector projector,HashJoinInfo joinInfo,ImmutableBytesWritable tenantId,RegionCoprocessorEnvironment env) throws IOException {
  this.scanner=scanner;
  this.projector=projector;
  this.joinInfo=joinInfo;
  this.resultQueue=new LinkedList<Tuple>();
  this.hasMore=true;
  if (joinInfo != null) {
    for (    JoinType type : joinInfo.getJoinTypes()) {
      if (type != JoinType.Inner && type != JoinType.Left)       throw new IOException(""String_Node_Str"" + type + ""String_Node_Str"");
    }
    int count=joinInfo.getJoinIds().length;
    this.tempTuples=new List[count];
    this.hashCaches=new HashCache[count];
    this.tempSrcBitSet=new ValueBitSet[count];
    TenantCache cache=GlobalCache.getTenantCache(env,tenantId);
    for (int i=0; i < count; i++) {
      ImmutableBytesPtr joinId=joinInfo.getJoinIds()[i];
      HashCache hashCache=(HashCache)cache.getServerCache(joinId);
      if (hashCache == null)       throw new IOException(""String_Node_Str"" + Bytes.toString(joinId.get(),joinId.getOffset(),joinId.getLength()));
      hashCaches[i]=hashCache;
      tempSrcBitSet[i]=ValueBitSet.newInstance(joinInfo.getSchemas()[i]);
    }
    if (this.projector != null) {
      this.tempDestBitSet=ValueBitSet.newInstance(joinInfo.getJoinedSchema());
      this.projector.setValueBitSet(tempDestBitSet);
    }
  }
}",0.9898494924746236
112458,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  flowTextView=(FlowTextView)findViewById(R.id.ftv);
  flowTextView.setText(getString(R.string.lorem));
  Button btnIncreasefontSize=(Button)findViewById(R.id.btn_increase_font_size);
  btnIncreasefontSize.setOnClickListener(this);
  Button btnDecreasefontSize=(Button)findViewById(R.id.btn_decrease_font_size);
  btnDecreasefontSize.setOnClickListener(this);
  Button btnReset=(Button)findViewById(R.id.btn_reset);
  btnReset.setOnClickListener(this);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  flowTextView=(FlowTextView)findViewById(R.id.ftv);
  String content=getString(R.string.lorem);
  Spanned html=Html.fromHtml(content);
  flowTextView.setText(html);
  Button btnIncreasefontSize=(Button)findViewById(R.id.btn_increase_font_size);
  btnIncreasefontSize.setOnClickListener(this);
  Button btnDecreasefontSize=(Button)findViewById(R.id.btn_decrease_font_size);
  btnDecreasefontSize.setOnClickListener(this);
  Button btnReset=(Button)findViewById(R.id.btn_reset);
  btnReset.setOnClickListener(this);
}",0.912280701754386
112459,"/** 
 * Gets the workspace with the given ID.
 * @param workspaceId the ID of your workspace
 * @return a Workspace instance
 * @throws StructurizrClientException   if there are problems related to the network, authorization, JSON deserialization, etc
 */
public Workspace getWorkspace(long workspaceId) throws StructurizrClientException {
  if (workspaceId <= 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    log.info(""String_Node_Str"" + workspaceId);
    CloseableHttpClient httpClient=HttpClients.createSystem();
    HttpGet httpGet=new HttpGet(url + WORKSPACE_PATH + workspaceId);
    addHeaders(httpGet,""String_Node_Str"",""String_Node_Str"");
    debugRequest(httpGet,null);
    try (CloseableHttpResponse response=httpClient.execute(httpGet)){
      debugResponse(response);
      String json=EntityUtils.toString(response.getEntity());
      if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {
        archiveWorkspace(workspaceId,json);
        if (encryptionStrategy == null) {
          return new JsonReader().read(new StringReader(json));
        }
 else {
          EncryptedWorkspace encryptedWorkspace=new EncryptedJsonReader().read(new StringReader(json));
          encryptedWorkspace.getEncryptionStrategy().setPassphrase(encryptionStrategy.getPassphrase());
          return encryptedWorkspace.getWorkspace();
        }
      }
 else {
        ApiError apiError=ApiError.parse(json);
        throw new StructurizrClientException(apiError.getMessage());
      }
    }
   }
 catch (  Exception e) {
    log.error(e);
    throw new StructurizrClientException(e);
  }
}","/** 
 * Gets the workspace with the given ID.
 * @param workspaceId the ID of your workspace
 * @return a Workspace instance
 * @throws StructurizrClientException   if there are problems related to the network, authorization, JSON deserialization, etc
 */
public Workspace getWorkspace(long workspaceId) throws StructurizrClientException {
  if (workspaceId <= 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    log.info(""String_Node_Str"" + workspaceId);
    CloseableHttpClient httpClient=HttpClients.createSystem();
    HttpGet httpGet=new HttpGet(url + WORKSPACE_PATH + workspaceId);
    addHeaders(httpGet,""String_Node_Str"",""String_Node_Str"");
    debugRequest(httpGet,null);
    try (CloseableHttpResponse response=httpClient.execute(httpGet)){
      debugResponse(response);
      String json=EntityUtils.toString(response.getEntity());
      if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {
        archiveWorkspace(workspaceId,json);
        if (encryptionStrategy == null) {
          return new JsonReader().read(new StringReader(json));
        }
 else {
          EncryptedWorkspace encryptedWorkspace=new EncryptedJsonReader().read(new StringReader(json));
          if (encryptedWorkspace.getEncryptionStrategy() != null) {
            encryptedWorkspace.getEncryptionStrategy().setPassphrase(encryptionStrategy.getPassphrase());
            return encryptedWorkspace.getWorkspace();
          }
 else {
            return new JsonReader().read(new StringReader(json));
          }
        }
      }
 else {
        ApiError apiError=ApiError.parse(json);
        throw new StructurizrClientException(apiError.getMessage());
      }
    }
   }
 catch (  Exception e) {
    log.error(e);
    throw new StructurizrClientException(e);
  }
}",0.9504084014002334
112460,"public void hydrate(){
  for (  SystemLandscapeView view : getSystemLandscapeViews()) {
    view.setModel(model);
    hydrateView(view);
  }
  for (  SystemContextView view : systemContextViews) {
    view.setSoftwareSystem(model.getSoftwareSystemWithId(view.getSoftwareSystemId()));
    hydrateView(view);
  }
  for (  ContainerView view : containerViews) {
    view.setSoftwareSystem(model.getSoftwareSystemWithId(view.getSoftwareSystemId()));
    hydrateView(view);
  }
  for (  ComponentView view : componentViews) {
    view.setSoftwareSystem(model.getSoftwareSystemWithId(view.getSoftwareSystemId()));
    view.setContainer(view.getSoftwareSystem().getContainerWithId(view.getContainerId()));
    hydrateView(view);
  }
  for (  DynamicView view : dynamicViews) {
    view.setModel(model);
    hydrateView(view);
  }
  for (  DeploymentView view : deploymentViews) {
    view.setSoftwareSystem(model.getSoftwareSystemWithId(view.getSoftwareSystemId()));
    view.setModel(model);
    hydrateView(view);
  }
  for (  FilteredView filteredView : filteredViews) {
    filteredView.setView(getViewWithKey(filteredView.getBaseViewKey()));
  }
}","public void hydrate(){
  for (  SystemLandscapeView view : getSystemLandscapeViews()) {
    view.setModel(model);
    hydrateView(view);
  }
  for (  SystemContextView view : systemContextViews) {
    view.setSoftwareSystem(model.getSoftwareSystemWithId(view.getSoftwareSystemId()));
    hydrateView(view);
  }
  for (  ContainerView view : containerViews) {
    view.setSoftwareSystem(model.getSoftwareSystemWithId(view.getSoftwareSystemId()));
    hydrateView(view);
  }
  for (  ComponentView view : componentViews) {
    view.setSoftwareSystem(model.getSoftwareSystemWithId(view.getSoftwareSystemId()));
    view.setContainer(view.getSoftwareSystem().getContainerWithId(view.getContainerId()));
    hydrateView(view);
  }
  for (  DynamicView view : dynamicViews) {
    view.setModel(model);
    hydrateView(view);
  }
  for (  DeploymentView view : deploymentViews) {
    if (!isNullOrEmpty(view.getSoftwareSystemId())) {
      view.setSoftwareSystem(model.getSoftwareSystemWithId(view.getSoftwareSystemId()));
    }
    view.setModel(model);
    hydrateView(view);
  }
  for (  FilteredView filteredView : filteredViews) {
    filteredView.setView(getViewWithKey(filteredView.getBaseViewKey()));
  }
}",0.9736394557823128
112461,"protected Set<Component> findClassesWithAnnotation(Class<? extends Annotation> type,String technology,boolean includePublicTypesOnly){
  Set<Component> components=new HashSet<>();
  Set<Class<?>> componentTypes=findTypesAnnotatedWith(type);
  for (  Class<?> componentType : componentTypes) {
    if (!includePublicTypesOnly || Modifier.isPublic(componentType.getModifiers())) {
      components.add(getComponentFinder().getContainer().addComponent(componentType.getSimpleName(),componentType.getCanonicalName(),""String_Node_Str"",technology));
    }
  }
  return components;
}","protected Set<Component> findClassesWithAnnotation(Class<? extends Annotation> type,String technology,boolean includePublicTypesOnly){
  Set<Component> components=new HashSet<>();
  Set<Class<?>> componentTypes=findTypesAnnotatedWith(type);
  for (  Class<?> componentType : componentTypes) {
    if (!includePublicTypesOnly || Modifier.isPublic(componentType.getModifiers())) {
      final Container container=getComponentFinder().getContainer();
      if (container.getComponentWithName(componentType.getSimpleName()) == null) {
        components.add(container.addComponent(componentType.getSimpleName(),componentType.getCanonicalName(),""String_Node_Str"",technology));
      }
    }
  }
  return components;
}",0.8711180124223602
112462,"@Override protected Set<Component> doFindComponents(){
  Set<Component> components=new HashSet<>();
  Set<Class<?>> componentTypes=findTypesAnnotatedWith(com.structurizr.annotation.Component.class);
  for (  Class<?> componentType : componentTypes) {
    Component component=getComponentFinder().getContainer().addComponent(componentType.getSimpleName(),componentType,componentType.getAnnotation(com.structurizr.annotation.Component.class).description(),componentType.getAnnotation(com.structurizr.annotation.Component.class).technology());
    components.add(component);
  }
  return components;
}","@Override protected Set<Component> doFindComponents(){
  Set<Component> components=new HashSet<>();
  Container container=getComponentFinder().getContainer();
  Set<Class<?>> componentTypes=findTypesAnnotatedWith(com.structurizr.annotation.Component.class);
  for (  Class<?> componentType : componentTypes) {
    if (container.getComponentWithName(componentType.getSimpleName()) == null) {
      Component component=container.addComponent(componentType.getSimpleName(),componentType,componentType.getAnnotation(com.structurizr.annotation.Component.class).description(),componentType.getAnnotation(com.structurizr.annotation.Component.class).technology());
      components.add(component);
    }
  }
  return components;
}",0.4318181818181818
112463,"@Test public void test_findComponents_IgnoresNonPublicTypesByDefault() throws Exception {
  Workspace workspace=new Workspace(""String_Node_Str"",""String_Node_Str"");
  Model model=workspace.getModel();
  SoftwareSystem softwareSystem=model.addSoftwareSystem(""String_Node_Str"",""String_Node_Str"");
  Container container=softwareSystem.addContainer(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  ComponentFinder componentFinder=new ComponentFinder(container,""String_Node_Str"",new SpringComponentFinderStrategy());
  componentFinder.findComponents();
  assertEquals(2,container.getComponents().size());
  Component component=container.getComponentWithName(""String_Node_Str"");
  assertEquals(""String_Node_Str"",component.getType().getType());
  component=container.getComponentWithName(""String_Node_Str"");
  assertEquals(""String_Node_Str"",component.getType().getType());
}","@Test public void test_findComponents_IgnoresNonPublicTypesByDefault() throws Exception {
  Workspace workspace=new Workspace(""String_Node_Str"",""String_Node_Str"");
  Model model=workspace.getModel();
  SoftwareSystem softwareSystem=model.addSoftwareSystem(""String_Node_Str"",""String_Node_Str"");
  Container container=softwareSystem.addContainer(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  ComponentFinder componentFinder=new ComponentFinder(container,""String_Node_Str"",new SpringComponentFinderStrategy());
  componentFinder.findComponents();
  assertEquals(2,container.getComponents().size());
  componentFinder.findComponents();
  assertEquals(2,container.getComponents().size());
  Component component=container.getComponentWithName(""String_Node_Str"");
  assertEquals(""String_Node_Str"",component.getType().getType());
  component=container.getComponentWithName(""String_Node_Str"");
  assertEquals(""String_Node_Str"",component.getType().getType());
}",0.8258977149075082
112464,"@Test public void test_findComponents_DoesNotIgnoreNonPublicTypes_WhenConfiguredToIncludeNonPublicTypes() throws Exception {
  Workspace workspace=new Workspace(""String_Node_Str"",""String_Node_Str"");
  Model model=workspace.getModel();
  SoftwareSystem softwareSystem=model.addSoftwareSystem(""String_Node_Str"",""String_Node_Str"");
  Container container=softwareSystem.addContainer(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  SpringComponentFinderStrategy springComponentFinderStrategy=new SpringComponentFinderStrategy();
  springComponentFinderStrategy.setIncludePublicTypesOnly(false);
  ComponentFinder componentFinder=new ComponentFinder(container,""String_Node_Str"",springComponentFinderStrategy);
  componentFinder.findComponents();
  assertEquals(3,container.getComponents().size());
  Component component=container.getComponentWithName(""String_Node_Str"");
  assertEquals(""String_Node_Str"",component.getType().getType());
  component=container.getComponentWithName(""String_Node_Str"");
  assertEquals(""String_Node_Str"",component.getType().getType());
  component=container.getComponentWithName(""String_Node_Str"");
  assertEquals(""String_Node_Str"",component.getType().getType());
}","@Test public void test_findComponents_DoesNotIgnoreNonPublicTypes_WhenConfiguredToIncludeNonPublicTypes() throws Exception {
  Workspace workspace=new Workspace(""String_Node_Str"",""String_Node_Str"");
  Model model=workspace.getModel();
  SoftwareSystem softwareSystem=model.addSoftwareSystem(""String_Node_Str"",""String_Node_Str"");
  Container container=softwareSystem.addContainer(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  SpringComponentFinderStrategy springComponentFinderStrategy=new SpringComponentFinderStrategy();
  springComponentFinderStrategy.setIncludePublicTypesOnly(false);
  ComponentFinder componentFinder=new ComponentFinder(container,""String_Node_Str"",springComponentFinderStrategy);
  componentFinder.findComponents();
  assertEquals(3,container.getComponents().size());
  componentFinder.findComponents();
  assertEquals(3,container.getComponents().size());
  Component component=container.getComponentWithName(""String_Node_Str"");
  assertEquals(""String_Node_Str"",component.getType().getType());
  component=container.getComponentWithName(""String_Node_Str"");
  assertEquals(""String_Node_Str"",component.getType().getType());
  component=container.getComponentWithName(""String_Node_Str"");
  assertEquals(""String_Node_Str"",component.getType().getType());
}",0.871071716357776
112465,"/** 
 * Sets the name of this element.
 * @param name  the name, as a String
 */
public void setName(String name){
  if (name == null || name.trim().length() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.name=name;
}","/** 
 * Sets the name of this element.
 * @param name  the name, as a String
 */
void setName(String name){
  if (name == null || name.trim().length() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.name=name;
}",0.985685071574642
112466,"@Test public void test_getCanonicalName_WhenNameContainsASlashCharacter(){
  container.setName(""String_Node_Str"");
  assertEquals(""String_Node_Str"",container.getCanonicalName());
}","@Test public void test_getCanonicalName_WhenNameContainsASlashCharacter(){
  container=softwareSystem.addContainer(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",container.getCanonicalName());
}",0.8269230769230769
112467,"@Test public void test_getCanonicalName_WhenTheDeploymentNodeHasNoParent(){
  DeploymentNode deploymentNode=new DeploymentNode();
  deploymentNode.setName(""String_Node_Str"");
  assertEquals(""String_Node_Str"",deploymentNode.getCanonicalName());
}","@Test public void test_getCanonicalName_WhenTheDeploymentNodeHasNoParent(){
  DeploymentNode deploymentNode=model.addDeploymentNode(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",deploymentNode.getCanonicalName());
}",0.8469184890656064
112468,"@Test public void test_getParent_ReturnsTheParentDeploymentNode(){
  DeploymentNode parent=new DeploymentNode();
  assertNull(parent.getParent());
  DeploymentNode child=new DeploymentNode();
  child.setParent(parent);
  assertSame(parent,child.getParent());
}","@Test public void test_getParent_ReturnsTheParentDeploymentNode(){
  DeploymentNode parent=model.addDeploymentNode(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertNull(parent.getParent());
  DeploymentNode child=parent.addDeploymentNode(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  child.setParent(parent);
  assertSame(parent,child.getParent());
}",0.6970172684458399
112469,"@Test public void test_getCanonicalName_WhenTheDeploymentNodeHasAParent(){
  DeploymentNode parent=new DeploymentNode();
  parent.setName(""String_Node_Str"");
  DeploymentNode child=new DeploymentNode();
  child.setName(""String_Node_Str"");
  child.setParent(parent);
  assertEquals(""String_Node_Str"",child.getCanonicalName());
}","@Test public void test_getCanonicalName_WhenTheDeploymentNodeHasAParent(){
  DeploymentNode parent=model.addDeploymentNode(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  DeploymentNode child=parent.addDeploymentNode(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",child.getCanonicalName());
}",0.5216095380029806
112470,"/** 
 * Creates a new instance based upon a package to scan and a set of exclusions.
 * @param packageToScan     the fully qualified package name
 * @param exclusions        a Set of Pattern objects
 */
public DefaultTypeRepository(String packageToScan,Set<Pattern> exclusions){
  this.packageToScan=packageToScan;
  if (exclusions != null) {
    this.exclusions.addAll(exclusions);
  }
  Reflections reflections=new Reflections(new ConfigurationBuilder().setUrls(ClasspathHelper.forJavaClassPath()).filterInputsBy(new FilterBuilder().includePackage(packageToScan)).setScanners(new SubTypesScanner(false)));
  types=filter(reflections.getSubTypesOf(Object.class));
}","/** 
 * Creates a new instance based upon a package to scan and a set of exclusions.
 * @param packageToScan     the fully qualified package name
 * @param exclusions        a Set of Pattern objects
 */
DefaultTypeRepository(String packageToScan,Set<Pattern> exclusions){
  this.packageToScan=packageToScan;
  if (exclusions != null) {
    this.exclusions.addAll(exclusions);
  }
  AllTypesScanner allTypesScanner=new AllTypesScanner();
  Reflections reflections=new Reflections(new ConfigurationBuilder().setUrls(ClasspathHelper.forJavaClassPath()).filterInputsBy(new FilterBuilder().includePackage(packageToScan)).setScanners(new SubTypesScanner(false),allTypesScanner));
  types=new HashSet<>();
  types.addAll(ReflectionUtils.forNames(allTypesScanner.types,reflections.getConfiguration().getClassLoaders()));
  for (  Class<?> c : types) {
    System.out.println(""String_Node_Str"" + c);
  }
}",0.7848911651728553
112471,"@Override public void findDependencies() throws Exception {
  runJavaDoc();
  JavadocCommentFilter filter=new JavadocCommentFilter(maxDescriptionLength);
  for (  ClassDoc classDoc : ROOTDOC.classes()) {
    String type=classDoc.qualifiedTypeName();
    String comment=filter.filterAndTruncate(classDoc.commentText());
    String pathToSourceFile=classDoc.position().file().getCanonicalPath();
    typeToSourceFile.put(type,new File(pathToSourceFile));
    typeToDescription.put(type,comment);
  }
  for (  Component component : getComponentFinder().getContainer().getComponents()) {
    long count=0;
    File sourceFile=typeToSourceFile.get(component.getType());
    if (sourceFile != null) {
      count+=Files.lines(Paths.get(sourceFile.toURI())).count();
    }
    component.setDescription(typeToDescription.getOrDefault(component.getType(),null));
    for (    CodeElement codeElement : component.getCode()) {
      codeElement.setDescription(typeToDescription.getOrDefault(codeElement.getType(),null));
      sourceFile=typeToSourceFile.get(codeElement.getType());
      if (sourceFile != null) {
        long numberOfLinesInFile=Files.lines(Paths.get(sourceFile.toURI())).count();
        codeElement.setUrl(sourceFile.toURI().toString());
        codeElement.setSize(numberOfLinesInFile);
        count+=numberOfLinesInFile;
      }
    }
    if (count > 0) {
      component.setSize(count);
    }
  }
}","@Override public void findDependencies() throws Exception {
  runJavaDoc();
  JavadocCommentFilter filter=new JavadocCommentFilter(maxDescriptionLength);
  for (  ClassDoc classDoc : ROOTDOC.classes()) {
    String type=classDoc.qualifiedTypeName();
    String comment=filter.filterAndTruncate(classDoc.commentText());
    String pathToSourceFile=classDoc.position().file().getCanonicalPath();
    typeToSourceFile.put(type,new File(pathToSourceFile));
    typeToDescription.put(type,comment);
  }
  for (  Component component : getComponentFinder().getContainer().getComponents()) {
    long count=0;
    component.setDescription(typeToDescription.getOrDefault(component.getType(),null));
    for (    CodeElement codeElement : component.getCode()) {
      codeElement.setDescription(typeToDescription.getOrDefault(codeElement.getType(),null));
      File sourceFile=typeToSourceFile.get(codeElement.getType());
      if (sourceFile != null) {
        long numberOfLinesInFile=Files.lines(Paths.get(sourceFile.toURI())).count();
        codeElement.setUrl(sourceFile.toURI().toString());
        codeElement.setSize(numberOfLinesInFile);
        count+=numberOfLinesInFile;
      }
    }
    if (count > 0) {
      component.setSize(count);
    }
  }
}",0.7212007504690432
112472,"public static void main(String[] args){
  Workspace workspace=ExampleWorkspace.create(false);
  StringWriter stringWriter=new StringWriter();
  DotWriter dotWriter=new DotWriter();
  dotWriter.write(workspace,stringWriter);
  System.out.println(stringWriter);
}","public static void main(String[] args){
  Workspace workspace=ExampleWorkspace.create();
  StringWriter stringWriter=new StringWriter();
  DotWriter dotWriter=new DotWriter();
  dotWriter.write(workspace,stringWriter);
  System.out.println(stringWriter);
}",0.4061895551257253
112473,"private void addEfferentDependencies(Component component,String type,Set<String> typesVisited){
  typesVisited.add(type);
  try {
    ClassPool pool=ClassPool.getDefault();
    CtClass cc=pool.get(type);
    for (    Object referencedType : cc.getRefClasses()) {
      String referencedTypeName=(String)referencedType;
      Component destinationComponent=componentFinder.getContainer().getComponentOfType(referencedTypeName);
      if (destinationComponent != null) {
        if (component != destinationComponent) {
          component.uses(destinationComponent,""String_Node_Str"");
        }
      }
 else       if (!typesVisited.contains(referencedTypeName)) {
        addEfferentDependencies(component,referencedTypeName,typesVisited);
      }
    }
  }
 catch (  NotFoundException nfe) {
    System.err.println(nfe.getMessage() + ""String_Node_Str"");
  }
catch (  Exception e) {
    System.err.println(e.getMessage());
  }
}","private void addEfferentDependencies(Component component,String type,Set<String> typesVisited){
  typesVisited.add(type);
  try {
    ClassPool pool=ClassPool.getDefault();
    CtClass cc=pool.get(type);
    for (    Object referencedType : cc.getRefClasses()) {
      String referencedTypeName=(String)referencedType;
      if (!isAJavaPlatformType(referencedTypeName)) {
        Component destinationComponent=componentFinder.getContainer().getComponentOfType(referencedTypeName);
        if (destinationComponent != null) {
          if (component != destinationComponent) {
            component.uses(destinationComponent,""String_Node_Str"");
          }
        }
 else         if (!typesVisited.contains(referencedTypeName)) {
          addEfferentDependencies(component,referencedTypeName,typesVisited);
        }
      }
    }
  }
 catch (  NotFoundException nfe) {
    System.err.println(nfe.getMessage() + ""String_Node_Str"");
  }
catch (  Exception e) {
    System.err.println(e.getMessage());
  }
}",0.9586776859504132
112474,"private void findElementsToShow(Element element,Set<String> elementIds,int depth){
  if (elementViews.contains(new ElementView(element))) {
    elementIds.add(element.getId());
    if (depth < MAX_DEPTH) {
      element.getRelationships().forEach(r -> findElementsToShow(r.getDestination(),elementIds,depth + 1));
    }
  }
}","private void findElementsToShow(Element startingElement,Element element,Set<String> elementIdsToShow,Set<String> elementIdsVisited){
  if (!elementIdsVisited.contains(element.getId()) && elementViews.contains(new ElementView(element))) {
    elementIdsVisited.add(element.getId());
    elementIdsToShow.add(element.getId());
    if (!element.hasEfferentRelationshipWith(startingElement)) {
      element.getRelationships().forEach(r -> findElementsToShow(startingElement,r.getDestination(),elementIdsToShow,elementIdsVisited));
    }
  }
}",0.4282407407407407
112475,"/** 
 * Removes all elements that cannot be reached by traversing the graph of relationships starting with the specified element.
 * @param element       the starting element
 */
public void removeElementsThatCantBeReachedFrom(Element element){
  if (element != null) {
    Set<String> elementIdsToShow=new HashSet<>();
    findElementsToShow(element,elementIdsToShow,1);
    elementViews.removeIf(ev -> !elementIdsToShow.contains(ev.getId()));
  }
}","/** 
 * Removes all elements that cannot be reached by traversing the graph of relationships starting with the specified element.
 * @param element       the starting element
 */
public void removeElementsThatCantBeReachedFrom(Element element){
  if (element != null) {
    Set<String> elementIdsToShow=new HashSet<>();
    Set<String> elementIdsVisited=new HashSet<>();
    findElementsToShow(element,element,elementIdsToShow,elementIdsVisited);
    elementViews.removeIf(ev -> !elementIdsToShow.contains(ev.getId()));
  }
}",0.921025641025641
112476,"/** 
 * Updates the hit object.
 * @param overlap true if the next object's start time has already passed
 * @param delta the delta interval since the last call
 * @param mouseX the x coordinate of the mouse
 * @param mouseY the y coordinate of the mouse
 * @param keyPressed whether or not a game key is currently pressed
 * @param trackPosition the track position
 * @return true if object ended
 */
public boolean update(boolean overlap,int delta,int mouseX,int mouseY,boolean keyPressed,int trackPosition);","/** 
 * Updates the hit object.
 * @param delta the delta interval since the last call
 * @param mouseX the x coordinate of the mouse
 * @param mouseY the y coordinate of the mouse
 * @param keyPressed whether or not a game key is currently pressed
 * @param trackPosition the track position
 * @return true if object ended
 */
public boolean update(int delta,int mouseX,int mouseY,boolean keyPressed,int trackPosition);",0.3053763440860215
112477,"@Override public boolean update(boolean overlap,int delta,int mouseX,int mouseY,boolean keyPressed,int trackPosition){
  if (overlap || trackPosition > hitObject.getEndTime()) {
    hitResult();
    return true;
  }
  if (isSpinning && !(keyPressed || GameMod.RELAX.isActive()))   isSpinning=false;
  deltaOverflow+=delta;
  float angleDiff=0;
  if (GameMod.AUTO.isActive()) {
    angleDiff=delta * AUTO_MULTIPLIER;
    isSpinning=true;
  }
 else   if (GameMod.SPUN_OUT.isActive() || GameMod.AUTOPILOT.isActive()) {
    angleDiff=delta * SPUN_OUT_MULTIPLIER;
    isSpinning=true;
  }
 else {
    float angle=(float)Math.atan2(mouseY - (height / 2),mouseX - (width / 2));
    if (!isSpinning && (keyPressed || GameMod.RELAX.isActive())) {
      lastAngle=angle;
      isSpinning=true;
      return false;
    }
    angleDiff=angle - lastAngle;
    if (Math.abs(angleDiff) > 0.01f)     lastAngle=angle;
 else     angleDiff=0;
  }
  if (angleDiff < -Math.PI)   angleDiff+=TWO_PI;
 else   if (angleDiff > Math.PI)   angleDiff-=TWO_PI;
  if (isSpinning)   deltaAngleOverflow+=angleDiff;
  while (deltaOverflow >= DELTA_UPDATE_TIME) {
    float deltaAngle=0;
    if (isSpinning) {
      deltaAngle=deltaAngleOverflow * DELTA_UPDATE_TIME / deltaOverflow;
      deltaAngleOverflow-=deltaAngle;
      deltaAngle=Utils.clamp(deltaAngle,-MAX_ANG_DIFF,MAX_ANG_DIFF);
    }
    sumDeltaAngle-=storedDeltaAngle[deltaAngleIndex];
    sumDeltaAngle+=deltaAngle;
    storedDeltaAngle[deltaAngleIndex++]=deltaAngle;
    deltaAngleIndex%=storedDeltaAngle.length;
    deltaOverflow-=DELTA_UPDATE_TIME;
    float rotationAngle=sumDeltaAngle / maxStoredDeltaAngles;
    rotationAngle=Utils.clamp(rotationAngle,-MAX_ANG_DIFF,MAX_ANG_DIFF);
    float rotationPerSec=rotationAngle * (1000 / DELTA_UPDATE_TIME) / TWO_PI;
    drawnRPM=(int)(Math.abs(rotationPerSec * 60));
    rotate(rotationAngle);
  }
  return false;
}","@Override public boolean update(int delta,int mouseX,int mouseY,boolean keyPressed,int trackPosition){
  if (trackPosition > hitObject.getEndTime()) {
    hitResult();
    return true;
  }
  if (isSpinning && !(keyPressed || GameMod.RELAX.isActive()))   isSpinning=false;
  deltaOverflow+=delta;
  float angleDiff=0;
  if (GameMod.AUTO.isActive()) {
    angleDiff=delta * AUTO_MULTIPLIER;
    isSpinning=true;
  }
 else   if (GameMod.SPUN_OUT.isActive() || GameMod.AUTOPILOT.isActive()) {
    angleDiff=delta * SPUN_OUT_MULTIPLIER;
    isSpinning=true;
  }
 else {
    float angle=(float)Math.atan2(mouseY - (height / 2),mouseX - (width / 2));
    if (!isSpinning && (keyPressed || GameMod.RELAX.isActive())) {
      lastAngle=angle;
      isSpinning=true;
      return false;
    }
    angleDiff=angle - lastAngle;
    if (Math.abs(angleDiff) > 0.01f)     lastAngle=angle;
 else     angleDiff=0;
  }
  if (angleDiff < -Math.PI)   angleDiff+=TWO_PI;
 else   if (angleDiff > Math.PI)   angleDiff-=TWO_PI;
  if (isSpinning)   deltaAngleOverflow+=angleDiff;
  while (deltaOverflow >= DELTA_UPDATE_TIME) {
    float deltaAngle=0;
    if (isSpinning) {
      deltaAngle=deltaAngleOverflow * DELTA_UPDATE_TIME / deltaOverflow;
      deltaAngleOverflow-=deltaAngle;
      deltaAngle=Utils.clamp(deltaAngle,-MAX_ANG_DIFF,MAX_ANG_DIFF);
    }
    sumDeltaAngle-=storedDeltaAngle[deltaAngleIndex];
    sumDeltaAngle+=deltaAngle;
    storedDeltaAngle[deltaAngleIndex++]=deltaAngle;
    deltaAngleIndex%=storedDeltaAngle.length;
    deltaOverflow-=DELTA_UPDATE_TIME;
    float rotationAngle=sumDeltaAngle / maxStoredDeltaAngles;
    rotationAngle=Utils.clamp(rotationAngle,-MAX_ANG_DIFF,MAX_ANG_DIFF);
    float rotationPerSec=rotationAngle * (1000 / DELTA_UPDATE_TIME) / TWO_PI;
    drawnRPM=(int)(Math.abs(rotationPerSec * 60));
    rotate(rotationAngle);
  }
  return false;
}",0.9928210582291944
112478,"/** 
 * Renders all options.
 * @param g the graphics context
 */
private void renderOptions(Graphics g){
  int y=(int)(-scrolling.getPosition() + optionStartY);
  maxScrollOffset=optionStartY;
  boolean render=true;
  int lastNonSkippedSectionIndex=0;
  int groupIndex=0;
  for (; groupIndex < groups.length; groupIndex++) {
    lastNonSkippedSectionIndex=groupIndex;
    OptionGroup section=groups[groupIndex];
    if (section.isFiltered()) {
      continue;
    }
    int lineStartY=(int)(y + Fonts.LARGE.getLineHeight() * 0.6f);
    if (render) {
      if (section.getOptions() == null) {
        Utils.drawRightAligned(Fonts.XLARGE,width,-paddingRight,(int)(y + Fonts.XLARGE.getLineHeight() * 0.3f),section.getName(),COL_CYAN);
      }
 else {
        Fonts.MEDIUMBOLD.drawString(paddingTextLeft,lineStartY,section.getName(),COL_WHITE);
      }
    }
    y+=Fonts.LARGE.getLineHeight() * 1.5f;
    maxScrollOffset+=Fonts.LARGE.getLineHeight() * 1.5f;
    if (section.getOptions() == null) {
      continue;
    }
    int lineHeight=(int)(Fonts.LARGE.getLineHeight() * 0.9f);
    for (int optionIndex=0; optionIndex < section.getOptions().length; optionIndex++) {
      GameOption option=section.getOptions()[optionIndex];
      if (option.isFiltered()) {
        continue;
      }
      if ((y > -optionHeight && render) || (isListOptionOpen && hoverOption == option)) {
        renderOption(g,option,y);
      }
      y+=optionHeight;
      maxScrollOffset+=optionHeight;
      lineHeight+=optionHeight;
      if (y > height) {
        render=false;
        groupIndex=groups.length;
        maxScrollOffset+=(section.getOptions().length - optionIndex - 1) * optionHeight;
      }
    }
    g.setColor(COL_GREY);
    g.fillRect(paddingLeft,lineStartY,LINEWIDTH,lineHeight);
  }
  for (groupIndex=lastNonSkippedSectionIndex + 1; groupIndex < groups.length; groupIndex++) {
    maxScrollOffset+=Fonts.LARGE.getLineHeight() * 1.5f;
    if (groups[groupIndex].getOptions() != null) {
      maxScrollOffset+=groups[groupIndex].getOptions().length * optionHeight;
    }
  }
  maxScrollOffset-=height * 2 / 3;
  if (maxScrollOffset < 0) {
    maxScrollOffset=0;
  }
  if (scrolling.getPosition() > maxScrollOffset) {
    scrolling.setPosition(maxScrollOffset);
  }
  scrolling.setMinMax(0,maxScrollOffset);
}","/** 
 * Renders all options.
 * @param g the graphics context
 */
private void renderOptions(Graphics g){
  int y=(int)(-scrolling.getPosition() + optionStartY);
  maxScrollOffset=optionStartY;
  boolean render=true;
  int groupIndex=0;
  for (; groupIndex < groups.length && render; groupIndex++) {
    OptionGroup section=groups[groupIndex];
    if (section.isFiltered()) {
      continue;
    }
    int lineStartY=(int)(y + Fonts.LARGE.getLineHeight() * 0.6f);
    if (section.getOptions() == null) {
      Utils.drawRightAligned(Fonts.XLARGE,width,-paddingRight,(int)(y + Fonts.XLARGE.getLineHeight() * 0.3f),section.getName(),COL_CYAN);
    }
 else {
      Fonts.MEDIUMBOLD.drawString(paddingTextLeft,lineStartY,section.getName(),COL_WHITE);
    }
    y+=Fonts.LARGE.getLineHeight() * 1.5f;
    maxScrollOffset+=Fonts.LARGE.getLineHeight() * 1.5f;
    if (section.getOptions() == null) {
      continue;
    }
    int lineHeight=(int)(Fonts.LARGE.getLineHeight() * 0.9f);
    for (int optionIndex=0; optionIndex < section.getOptions().length; optionIndex++) {
      GameOption option=section.getOptions()[optionIndex];
      if (option.isFiltered()) {
        continue;
      }
      if (y > -optionHeight || (isListOptionOpen && hoverOption == option)) {
        renderOption(g,option,y);
      }
      y+=optionHeight;
      maxScrollOffset+=optionHeight;
      lineHeight+=optionHeight;
      if (y > height) {
        render=false;
        maxScrollOffset+=(section.getOptions().length - optionIndex - 1) * optionHeight;
        break;
      }
    }
    g.setColor(COL_GREY);
    g.fillRect(paddingLeft,lineStartY,LINEWIDTH,lineHeight);
  }
  for (; groupIndex < groups.length; groupIndex++) {
    maxScrollOffset+=Fonts.LARGE.getLineHeight() * 1.5f;
    if (groups[groupIndex].getOptions() != null) {
      maxScrollOffset+=groups[groupIndex].getOptions().length * optionHeight;
    }
  }
  maxScrollOffset-=height * 2 / 3;
  if (maxScrollOffset < 0) {
    maxScrollOffset=0;
  }
  if (scrolling.getPosition() > maxScrollOffset) {
    scrolling.setPosition(maxScrollOffset);
  }
  scrolling.setMinMax(0,maxScrollOffset);
}",0.893444469475107
112479,"/** 
 * Creates the options overlay.
 * @param container the game container
 * @param groups the option groups
 * @param listener the event listener
 */
public OptionsOverlay(GameContainer container,OptionGroup[] groups,OptionsOverlayListener listener){
  super(container);
  this.container=container;
  this.groups=groups;
  this.listener=listener;
  this.input=container.getInput();
  this.containerWidth=container.getWidth();
  this.containerHeight=container.getHeight();
  this.iconSize=(int)(18 * GameImage.getUIscale());
  this.sliderBallImg=GameImage.CONTROL_SLIDER_BALL.getImage().getScaledCopy(iconSize,iconSize);
  this.checkOnImg=GameImage.CONTROL_CHECK_ON.getImage().getScaledCopy(iconSize,iconSize);
  this.checkOffImg=GameImage.CONTROL_CHECK_OFF.getImage().getScaledCopy(iconSize,iconSize);
  int chevronSize=iconSize - 4;
  this.chevronDownImg=GameImage.CHEVRON_DOWN.getImage().getScaledCopy(chevronSize,chevronSize);
  this.chevronRightImg=GameImage.CHEVRON_RIGHT.getImage().getScaledCopy(chevronSize,chevronSize);
  int searchImgSize=(int)(Fonts.LARGE.getLineHeight() * 0.75f);
  searchImg=GameImage.SEARCH.getImage().getScaledCopy(searchImgSize,searchImgSize);
  this.x=0;
  this.y=0;
  this.targetWidth=(int)(containerWidth * 0.42f);
  this.height=containerHeight;
  this.paddingRight=(int)(containerWidth * 0.009375f);
  this.paddingLeft=(int)(containerWidth * 0.0180f);
  this.paddingTextLeft=paddingLeft + LINEWIDTH + (int)(containerWidth * 0.00625f);
  this.optionStartX=paddingTextLeft;
  this.textOptionsY=Fonts.LARGE.getLineHeight() * 2;
  this.textChangeY=textOptionsY + Fonts.LARGE.getLineHeight();
  this.posSearchY=textChangeY + Fonts.MEDIUM.getLineHeight() * 2;
  this.textSearchYOffset=Fonts.MEDIUM.getLineHeight() / 2;
  this.optionStartY=posSearchY + Fonts.MEDIUM.getLineHeight() + Fonts.LARGE.getLineHeight();
  int paddingX=24;
  this.optionWidth=targetWidth - paddingX * 2;
  this.optionHeight=(int)(Fonts.MEDIUM.getLineHeight() * 1.3f);
  this.optionGroupPadding=(int)(Fonts.LARGE.getLineHeight() * 1.5f);
  this.optionTextOffsetY=(int)((optionHeight - Fonts.MEDIUM.getLineHeight()) / 2f);
  this.listItemHeight=(int)(optionHeight * 4f / 5f);
  this.controlImageSize=(int)(Fonts.MEDIUM.getLineHeight() * 0.7f);
  this.controlImagePadding=(optionHeight - controlImageSize) / 2;
  int backSize=Fonts.XLARGE.getLineHeight() * 2 / 3;
  Image backArrow=GameImage.CHEVRON_LEFT.getImage().getScaledCopy(backSize,backSize);
  this.backButton=new MenuButton(backArrow,0,0);
  backButton.setHoverExpand(1.5f);
  Image restartImg=GameImage.UPDATE.getImage().getScaledCopy(backSize,backSize);
  this.restartButton=new MenuButton(restartImg,0,0);
  restartButton.setHoverAnimationDuration(2000);
  restartButton.setHoverRotate(360);
  searchField=new TextField(container,null,0,0,0,0);
  searchField.setFocus(true);
  this.scrolling=new KineticScrolling();
  scrolling.setMinMax(0f,maxScrollOffset);
}","/** 
 * Creates the options overlay.
 * @param container the game container
 * @param groups the option groups
 * @param listener the event listener
 */
public OptionsOverlay(GameContainer container,OptionGroup[] groups,OptionsOverlayListener listener){
  super(container);
  this.container=container;
  this.groups=groups;
  this.listener=listener;
  this.input=container.getInput();
  this.containerWidth=container.getWidth();
  this.containerHeight=container.getHeight();
  this.iconSize=(int)(18 * GameImage.getUIscale());
  this.sliderBallImg=GameImage.CONTROL_SLIDER_BALL.getImage().getScaledCopy(iconSize,iconSize);
  this.checkOnImg=GameImage.CONTROL_CHECK_ON.getImage().getScaledCopy(iconSize,iconSize);
  this.checkOffImg=GameImage.CONTROL_CHECK_OFF.getImage().getScaledCopy(iconSize,iconSize);
  int chevronSize=iconSize - 4;
  this.chevronDownImg=GameImage.CHEVRON_DOWN.getImage().getScaledCopy(chevronSize,chevronSize);
  this.chevronRightImg=GameImage.CHEVRON_RIGHT.getImage().getScaledCopy(chevronSize,chevronSize);
  int searchImgSize=(int)(Fonts.LARGE.getLineHeight() * 0.75f);
  searchImg=GameImage.SEARCH.getImage().getScaledCopy(searchImgSize,searchImgSize);
  this.x=0;
  this.y=0;
  this.targetWidth=(int)(containerWidth * 0.42f);
  this.height=containerHeight;
  this.paddingRight=(int)(containerWidth * 0.009375f);
  this.paddingLeft=(int)(containerWidth * 0.0180f);
  this.paddingTextLeft=paddingLeft + LINEWIDTH + (int)(containerWidth * 0.00625f);
  this.optionStartX=paddingTextLeft;
  this.textOptionsY=Fonts.LARGE.getLineHeight() * 2;
  this.textChangeY=textOptionsY + Fonts.LARGE.getLineHeight();
  this.posSearchY=textChangeY + Fonts.MEDIUM.getLineHeight() * 2;
  this.textSearchYOffset=Fonts.MEDIUM.getLineHeight() / 2;
  this.optionStartY=posSearchY + Fonts.MEDIUM.getLineHeight() + Fonts.LARGE.getLineHeight();
  int paddingX=24;
  this.optionWidth=targetWidth - paddingX * 2;
  this.optionHeight=(int)(Fonts.MEDIUM.getLineHeight() * 1.3f);
  this.optionGroupPadding=(int)(Fonts.LARGE.getLineHeight() * 1.5f);
  this.optionTextOffsetY=(int)((optionHeight - Fonts.MEDIUM.getLineHeight()) / 2f);
  this.listItemHeight=(int)(optionHeight * 4f / 5f);
  this.controlImageSize=(int)(Fonts.MEDIUM.getLineHeight() * 0.7f);
  this.controlImagePadding=(optionHeight - controlImageSize) / 2;
  int backSize=Fonts.XLARGE.getLineHeight() * 2 / 3;
  Image backArrow=GameImage.CHEVRON_LEFT.getImage().getScaledCopy(backSize,backSize);
  this.backButton=new MenuButton(backArrow,0,0);
  backButton.setHoverExpand(1.5f);
  Image restartImg=GameImage.UPDATE.getImage().getScaledCopy(backSize,backSize);
  this.restartButton=new MenuButton(restartImg,0,0);
  restartButton.setHoverAnimationDuration(2000);
  restartButton.setHoverRotate(360);
  searchField=new TextField(container,null,0,0,0,0);
  searchField.setFocus(true);
  this.scrolling=new KineticScrolling();
}",0.992597693234636
112480,"@Override public void start() throws SlickException {
  try {
    setup();
    ErrorHandler.setGlString();
    getDelta();
    while (running())     gameLoop();
  }
  finally {
    close_sub();
    destroy();
    if (e != null) {
      ErrorHandler.error(null,e,true);
      e=null;
    }
  }
  if (forceExit) {
    Opsu.close();
    System.exit(0);
  }
}","@Override public void start() throws SlickException {
  try {
    setup();
    ErrorHandler.setGlString();
    getDelta();
    while (running())     gameLoop();
  }
 catch (  Exception e) {
    this.e=e;
  }
  try {
    close_sub();
  }
 catch (  Exception e) {
    if (this.e == null)     this.e=e;
  }
  destroy();
  if (e != null) {
    ErrorHandler.error(null,e,true);
    e=null;
    forceExit=true;
  }
  if (forceExit) {
    Opsu.close();
    System.exit(0);
  }
}",0.5738498789346247
112481,"@Override public boolean closeRequested(){
  int id=this.getCurrentStateID();
  if (id == STATE_GAME || id == STATE_GAMEPAUSEMENU || id == STATE_GAMERANKING) {
    SongMenu songMenu=(SongMenu)this.getState(Opsu.STATE_SONGMENU);
    if (id == STATE_GAMERANKING) {
      GameData data=((GameRanking)this.getState(Opsu.STATE_GAMERANKING)).getGameData();
      if (data != null && data.isGameplay())       songMenu.resetTrackOnLoad();
    }
 else {
      if (id == STATE_GAME) {
        MusicController.pause();
        MusicController.resume();
      }
 else       songMenu.resetTrackOnLoad();
    }
    if (UI.getCursor().isBeatmapSkinned())     UI.getCursor().reset();
    songMenu.resetGameDataOnLoad();
    this.enterState(Opsu.STATE_SONGMENU,new EasedFadeOutTransition(),new FadeInTransition());
    return false;
  }
  if (DownloadList.get().hasActiveDownloads() && UI.showExitConfirmation(DownloadList.EXIT_CONFIRMATION))   return false;
  if (Updater.get().getStatus() == Updater.Status.UPDATE_DOWNLOADING && UI.showExitConfirmation(Updater.EXIT_CONFIRMATION))   return false;
  return true;
}","@Override public boolean closeRequested(){
  int id=this.getCurrentStateID();
  if (id == STATE_GAME || id == STATE_GAMEPAUSEMENU || id == STATE_GAMERANKING) {
    SongMenu songMenu=(SongMenu)this.getState(Opsu.STATE_SONGMENU);
    if (id == STATE_GAMERANKING) {
      GameData data=((GameRanking)this.getState(Opsu.STATE_GAMERANKING)).getGameData();
      if (data != null && data.isGameplay())       songMenu.resetTrackOnLoad();
    }
 else {
      if (id == STATE_GAME) {
        MusicController.pause();
        MusicController.setPitch(1.0f);
        MusicController.resume();
      }
 else       songMenu.resetTrackOnLoad();
    }
    if (UI.getCursor().isBeatmapSkinned())     UI.getCursor().reset();
    songMenu.resetGameDataOnLoad();
    this.enterState(Opsu.STATE_SONGMENU,new EasedFadeOutTransition(),new FadeInTransition());
    return false;
  }
  if (DownloadList.get().hasActiveDownloads() && UI.showExitConfirmation(DownloadList.EXIT_CONFIRMATION))   return false;
  if (Updater.get().getStatus() == Updater.Status.UPDATE_DOWNLOADING && UI.showExitConfirmation(Updater.EXIT_CONFIRMATION))   return false;
  return true;
}",0.9821109123434704
112482,"@Override public void enter(GameContainer container,StateBasedGame game) throws SlickException {
  UI.enter();
  if (beatmap == null || beatmap.objects == null)   throw new RuntimeException(""String_Node_Str"");
  previousScores=ScoreDB.getMapScores(beatmap);
  lastRankUpdateTime=-1000;
  if (previousScores != null)   currentRank=previousScores.length;
  scoreboardVisible=true;
  currentScoreboardAlpha=0f;
  FrameBufferCache.getInstance().freeMap();
  if (restart != Restart.FALSE) {
    if (isReplay) {
      previousMods=GameMod.getModState();
      GameMod.loadModState(replay.mods);
    }
    data.setGameplay(true);
    if (restart == Restart.NEW) {
      loadImages();
      setMapModifiers();
      retries=0;
    }
 else     if (restart == Restart.MANUAL) {
      retries++;
    }
 else     if (restart == Restart.REPLAY)     retries=0;
    gameObjects=new GameObject[beatmap.objects.length];
    playbackSpeed=PlaybackSpeed.NORMAL;
    resetGameData();
    if (!beatmap.timingPoints.isEmpty()) {
      TimingPoint timingPoint=beatmap.timingPoints.get(0);
      if (!timingPoint.isInherited()) {
        setBeatLength(timingPoint,true);
        timingPointIndex++;
      }
    }
    Color[] combo=beatmap.getComboColors();
    for (int i=0; i < beatmap.objects.length; i++) {
      HitObject hitObject=beatmap.objects[i];
      boolean comboEnd=false;
      if (i + 1 >= beatmap.objects.length || beatmap.objects[i + 1].isNewCombo())       comboEnd=true;
      Color color=combo[hitObject.getComboIndex()];
      int hitObjectTime=hitObject.getTime();
      while (timingPointIndex < beatmap.timingPoints.size()) {
        TimingPoint timingPoint=beatmap.timingPoints.get(timingPointIndex);
        if (timingPoint.getTime() > hitObjectTime)         break;
        setBeatLength(timingPoint,false);
        timingPointIndex++;
      }
      try {
        if (hitObject.isCircle())         gameObjects[i]=new Circle(hitObject,this,data,color,comboEnd);
 else         if (hitObject.isSlider())         gameObjects[i]=new Slider(hitObject,this,data,color,comboEnd);
 else         if (hitObject.isSpinner())         gameObjects[i]=new Spinner(hitObject,this,data);
      }
 catch (      Exception e) {
        ErrorHandler.error(String.format(""String_Node_Str"",hitObject.getTypeName(),i,hitObject.toString()),e,true);
        gameObjects[i]=new DummyObject(hitObject);
        continue;
      }
    }
    calculateStacks();
    timingPointIndex=0;
    beatLengthBase=beatLength=1;
    if (!beatmap.timingPoints.isEmpty()) {
      TimingPoint timingPoint=beatmap.timingPoints.get(0);
      if (!timingPoint.isInherited()) {
        setBeatLength(timingPoint,true);
        timingPointIndex++;
      }
    }
    if (GameMod.AUTO.isActive() || isReplay)     UI.getCursor().show();
    if (isReplay) {
      replayX=container.getWidth() / 2;
      replayY=container.getHeight() / 2;
      replayKeyPressed=false;
      replaySkipTime=-1;
      for (replayIndex=0; replayIndex < replay.frames.length; replayIndex++) {
        ReplayFrame frame=replay.frames[replayIndex];
        if (frame.getY() < 0) {
          if (frame.getTime() >= 0 && replayIndex > 0)           replaySkipTime=frame.getTime();
        }
 else         if (frame.getTime() == 0) {
          replayX=frame.getScaledX();
          replayY=frame.getScaledY();
          replayKeyPressed=frame.isKeyPressed();
        }
 else         break;
      }
    }
 else {
      lastKeysPressed=ReplayFrame.KEY_NONE;
      replaySkipTime=-1;
      replayFrames=new LinkedList<ReplayFrame>();
      replayFrames.add(new ReplayFrame(0,0,input.getMouseX(),input.getMouseY(),0));
    }
    leadInTime=beatmap.audioLeadIn + approachTime;
    restart=Restart.FALSE;
    MusicController.play(false);
    MusicController.setPosition(0);
    MusicController.setPitch(GameMod.getSpeedMultiplier());
    MusicController.pause();
    SoundController.mute(false);
  }
  skipButton.resetHover();
  if (isReplay || GameMod.AUTO.isActive())   playbackSpeed.getButton().resetHover();
  MusicController.setPitch(GameMod.getSpeedMultiplier() * playbackSpeed.getModifier());
}","@Override public void enter(GameContainer container,StateBasedGame game) throws SlickException {
  UI.enter();
  if (beatmap == null || beatmap.objects == null)   throw new RuntimeException(""String_Node_Str"");
  previousScores=ScoreDB.getMapScores(beatmap,replay == null ? null : replay.getReplayFilename());
  lastRankUpdateTime=-1000;
  if (previousScores != null)   currentRank=previousScores.length;
  scoreboardVisible=true;
  currentScoreboardAlpha=0f;
  FrameBufferCache.getInstance().freeMap();
  if (restart != Restart.FALSE) {
    if (isReplay) {
      previousMods=GameMod.getModState();
      GameMod.loadModState(replay.mods);
    }
    data.setGameplay(true);
    if (restart == Restart.NEW) {
      loadImages();
      setMapModifiers();
      retries=0;
    }
 else     if (restart == Restart.MANUAL) {
      retries++;
    }
 else     if (restart == Restart.REPLAY)     retries=0;
    gameObjects=new GameObject[beatmap.objects.length];
    playbackSpeed=PlaybackSpeed.NORMAL;
    resetGameData();
    if (!beatmap.timingPoints.isEmpty()) {
      TimingPoint timingPoint=beatmap.timingPoints.get(0);
      if (!timingPoint.isInherited()) {
        setBeatLength(timingPoint,true);
        timingPointIndex++;
      }
    }
    Color[] combo=beatmap.getComboColors();
    for (int i=0; i < beatmap.objects.length; i++) {
      HitObject hitObject=beatmap.objects[i];
      boolean comboEnd=false;
      if (i + 1 >= beatmap.objects.length || beatmap.objects[i + 1].isNewCombo())       comboEnd=true;
      Color color=combo[hitObject.getComboIndex()];
      int hitObjectTime=hitObject.getTime();
      while (timingPointIndex < beatmap.timingPoints.size()) {
        TimingPoint timingPoint=beatmap.timingPoints.get(timingPointIndex);
        if (timingPoint.getTime() > hitObjectTime)         break;
        setBeatLength(timingPoint,false);
        timingPointIndex++;
      }
      try {
        if (hitObject.isCircle())         gameObjects[i]=new Circle(hitObject,this,data,color,comboEnd);
 else         if (hitObject.isSlider())         gameObjects[i]=new Slider(hitObject,this,data,color,comboEnd);
 else         if (hitObject.isSpinner())         gameObjects[i]=new Spinner(hitObject,this,data);
      }
 catch (      Exception e) {
        ErrorHandler.error(String.format(""String_Node_Str"",hitObject.getTypeName(),i,hitObject.toString()),e,true);
        gameObjects[i]=new DummyObject(hitObject);
        continue;
      }
    }
    calculateStacks();
    timingPointIndex=0;
    beatLengthBase=beatLength=1;
    if (!beatmap.timingPoints.isEmpty()) {
      TimingPoint timingPoint=beatmap.timingPoints.get(0);
      if (!timingPoint.isInherited()) {
        setBeatLength(timingPoint,true);
        timingPointIndex++;
      }
    }
    if (GameMod.AUTO.isActive() || isReplay)     UI.getCursor().show();
    if (isReplay) {
      replayX=container.getWidth() / 2;
      replayY=container.getHeight() / 2;
      replayKeyPressed=false;
      replaySkipTime=-1;
      for (replayIndex=0; replayIndex < replay.frames.length; replayIndex++) {
        ReplayFrame frame=replay.frames[replayIndex];
        if (frame.getY() < 0) {
          if (frame.getTime() >= 0 && replayIndex > 0)           replaySkipTime=frame.getTime();
        }
 else         if (frame.getTime() == 0) {
          replayX=frame.getScaledX();
          replayY=frame.getScaledY();
          replayKeyPressed=frame.isKeyPressed();
        }
 else         break;
      }
    }
 else {
      lastKeysPressed=ReplayFrame.KEY_NONE;
      replaySkipTime=-1;
      replayFrames=new LinkedList<ReplayFrame>();
      replayFrames.add(new ReplayFrame(0,0,input.getMouseX(),input.getMouseY(),0));
    }
    leadInTime=beatmap.audioLeadIn + approachTime;
    restart=Restart.FALSE;
    MusicController.play(false);
    MusicController.setPosition(0);
    MusicController.setPitch(GameMod.getSpeedMultiplier());
    MusicController.pause();
    SoundController.mute(false);
  }
  skipButton.resetHover();
  if (isReplay || GameMod.AUTO.isActive())   playbackSpeed.getButton().resetHover();
  MusicController.setPitch(GameMod.getSpeedMultiplier() * playbackSpeed.getModifier());
}",0.9938413235116532
112483,"@Override public void update(GameContainer container,StateBasedGame game,int delta) throws SlickException {
  UI.update(delta);
  if (reloadThread == null)   MusicController.loopTrackIfEnded(true);
  int mouseX=input.getMouseX(), mouseY=input.getMouseY();
  UI.getBackButton().hoverUpdate(delta,mouseX,mouseY);
  selectModsButton.hoverUpdate(delta,mouseX,mouseY);
  selectRandomButton.hoverUpdate(delta,mouseX,mouseY);
  selectMapOptionsButton.hoverUpdate(delta,mouseX,mouseY);
  selectOptionsButton.hoverUpdate(delta,mouseX,mouseY);
  if (beatmapMenuTimer > -1) {
    beatmapMenuTimer+=delta;
    if (beatmapMenuTimer >= BEATMAP_MENU_DELAY) {
      beatmapMenuTimer=-1;
      if (focusNode != null) {
        ((ButtonMenu)game.getState(Opsu.STATE_BUTTONMENU)).setMenuState(MenuState.BEATMAP,focusNode);
        game.enterState(Opsu.STATE_BUTTONMENU);
      }
      return;
    }
  }
  if (focusNode != null) {
    Beatmap focusNodeBeatmap=focusNode.getSelectedBeatmap();
    if (!focusNodeBeatmap.isBackgroundLoading())     bgAlpha.update(delta);
    songChangeTimer.update(delta);
    if (!MusicController.isTrackLoading())     musicIconBounceTimer.update(delta);
  }
  starStream.update(delta);
  search.setFocus(true);
  searchTimer+=delta;
  if (searchTimer >= SEARCH_DELAY && reloadThread == null && beatmapMenuTimer == -1) {
    searchTimer=0;
    if (focusNode != null)     oldFocusNode=new SongNode(BeatmapSetList.get().getBaseNode(focusNode.index),focusNode.beatmapIndex);
    if (BeatmapSetList.get().search(search.getText())) {
      randomStack=new Stack<SongNode>();
      if (search.getText().isEmpty())       searchResultString=null;
      startNode=focusNode=null;
      scoreMap=null;
      focusScores=null;
      if (BeatmapSetList.get().size() > 0) {
        BeatmapSetList.get().init();
        if (search.getText().isEmpty()) {
          if (oldFocusNode != null)           setFocus(oldFocusNode.getNode(),oldFocusNode.getIndex(),true,true);
 else           setFocus(BeatmapSetList.get().getRandomNode(),-1,true,true);
        }
 else {
          int size=BeatmapSetList.get().size();
          searchResultString=String.format(""String_Node_Str"",size,(size == 1) ? ""String_Node_Str"" : ""String_Node_Str"");
          setFocus(BeatmapSetList.get().getRandomNode(),-1,true,true);
        }
        oldFocusNode=null;
      }
 else       if (!search.getText().isEmpty())       searchResultString=""String_Node_Str"";
    }
  }
  if (searchTransitionTimer < SEARCH_TRANSITION_TIME) {
    searchTransitionTimer+=delta;
    if (searchTransitionTimer > SEARCH_TRANSITION_TIME)     searchTransitionTimer=SEARCH_TRANSITION_TIME;
  }
  if (focusScores != null) {
    startScorePos.setMinMax(0,(focusScores.length - MAX_SCORE_BUTTONS) * ScoreData.getButtonOffset());
    startScorePos.update(delta);
  }
  songScrolling.update(delta);
  if (isScrollingToFocusNode) {
    float distanceDiff=Math.abs(songScrolling.getPosition() - songScrolling.getTargetPosition());
    if (distanceDiff <= buttonOffset / 8f) {
      songScrolling.scrollToPosition(songScrolling.getTargetPosition());
      songScrolling.setSpeedMultiplier(1f);
      isScrollingToFocusNode=false;
    }
  }
  updateDrawnSongPosition();
  BeatmapSetNode node=getNodeAtPosition(mouseX,mouseY);
  if (node != null) {
    if (node == hoverIndex)     hoverOffset.update(delta);
 else {
      hoverIndex=node;
      hoverOffset.setTime(0);
    }
    return;
  }
 else {
    hoverOffset.setTime(0);
    hoverIndex=null;
  }
  if (focusScores != null && ScoreData.areaContains(mouseX,mouseY)) {
    int startScore=(int)(startScorePos.getPosition() / ScoreData.getButtonOffset());
    int offset=(int)(-startScorePos.getPosition() + startScore * ScoreData.getButtonOffset());
    int scoreButtons=Math.min(focusScores.length - startScore,MAX_SCORE_BUTTONS);
    for (int i=0, rank=startScore; i < scoreButtons; i++, rank++) {
      if (rank < 0)       continue;
      if (ScoreData.buttonContains(mouseX,mouseY - offset,i)) {
        UI.updateTooltip(delta,focusScores[rank].getTooltipString(),true);
        break;
      }
    }
  }
}","@Override public void update(GameContainer container,StateBasedGame game,int delta) throws SlickException {
  UI.update(delta);
  if (reloadThread == null)   MusicController.loopTrackIfEnded(true);
 else   if (reloadThread.isFinished()) {
    if (BeatmapSetList.get().size() > 0) {
      BeatmapSetList.get().init();
      setFocus(BeatmapSetList.get().getRandomNode(),-1,true,true);
    }
 else     MusicController.playThemeSong();
    reloadThread=null;
  }
  int mouseX=input.getMouseX(), mouseY=input.getMouseY();
  UI.getBackButton().hoverUpdate(delta,mouseX,mouseY);
  selectModsButton.hoverUpdate(delta,mouseX,mouseY);
  selectRandomButton.hoverUpdate(delta,mouseX,mouseY);
  selectMapOptionsButton.hoverUpdate(delta,mouseX,mouseY);
  selectOptionsButton.hoverUpdate(delta,mouseX,mouseY);
  if (beatmapMenuTimer > -1) {
    beatmapMenuTimer+=delta;
    if (beatmapMenuTimer >= BEATMAP_MENU_DELAY) {
      beatmapMenuTimer=-1;
      if (focusNode != null) {
        ((ButtonMenu)game.getState(Opsu.STATE_BUTTONMENU)).setMenuState(MenuState.BEATMAP,focusNode);
        game.enterState(Opsu.STATE_BUTTONMENU);
      }
      return;
    }
  }
  if (focusNode != null) {
    Beatmap focusNodeBeatmap=focusNode.getSelectedBeatmap();
    if (!focusNodeBeatmap.isBackgroundLoading())     bgAlpha.update(delta);
    songChangeTimer.update(delta);
    if (!MusicController.isTrackLoading())     musicIconBounceTimer.update(delta);
  }
  starStream.update(delta);
  search.setFocus(true);
  searchTimer+=delta;
  if (searchTimer >= SEARCH_DELAY && reloadThread == null && beatmapMenuTimer == -1) {
    searchTimer=0;
    if (focusNode != null)     oldFocusNode=new SongNode(BeatmapSetList.get().getBaseNode(focusNode.index),focusNode.beatmapIndex);
    if (BeatmapSetList.get().search(search.getText())) {
      randomStack=new Stack<SongNode>();
      if (search.getText().isEmpty())       searchResultString=null;
      startNode=focusNode=null;
      scoreMap=null;
      focusScores=null;
      if (BeatmapSetList.get().size() > 0) {
        BeatmapSetList.get().init();
        if (search.getText().isEmpty()) {
          if (oldFocusNode != null)           setFocus(oldFocusNode.getNode(),oldFocusNode.getIndex(),true,true);
 else           setFocus(BeatmapSetList.get().getRandomNode(),-1,true,true);
        }
 else {
          int size=BeatmapSetList.get().size();
          searchResultString=String.format(""String_Node_Str"",size,(size == 1) ? ""String_Node_Str"" : ""String_Node_Str"");
          setFocus(BeatmapSetList.get().getRandomNode(),-1,true,true);
        }
        oldFocusNode=null;
      }
 else       if (!search.getText().isEmpty())       searchResultString=""String_Node_Str"";
    }
  }
  if (searchTransitionTimer < SEARCH_TRANSITION_TIME) {
    searchTransitionTimer+=delta;
    if (searchTransitionTimer > SEARCH_TRANSITION_TIME)     searchTransitionTimer=SEARCH_TRANSITION_TIME;
  }
  if (focusScores != null) {
    startScorePos.setMinMax(0,(focusScores.length - MAX_SCORE_BUTTONS) * ScoreData.getButtonOffset());
    startScorePos.update(delta);
  }
  songScrolling.update(delta);
  if (isScrollingToFocusNode) {
    float distanceDiff=Math.abs(songScrolling.getPosition() - songScrolling.getTargetPosition());
    if (distanceDiff <= buttonOffset / 8f) {
      songScrolling.scrollToPosition(songScrolling.getTargetPosition());
      songScrolling.setSpeedMultiplier(1f);
      isScrollingToFocusNode=false;
    }
  }
  updateDrawnSongPosition();
  BeatmapSetNode node=getNodeAtPosition(mouseX,mouseY);
  if (node != null) {
    if (node == hoverIndex)     hoverOffset.update(delta);
 else {
      hoverIndex=node;
      hoverOffset.setTime(0);
    }
    return;
  }
 else {
    hoverOffset.setTime(0);
    hoverIndex=null;
  }
  if (focusScores != null && ScoreData.areaContains(mouseX,mouseY)) {
    int startScore=(int)(startScorePos.getPosition() / ScoreData.getButtonOffset());
    int offset=(int)(-startScorePos.getPosition() + startScore * ScoreData.getButtonOffset());
    int scoreButtons=Math.min(focusScores.length - startScore,MAX_SCORE_BUTTONS);
    for (int i=0, rank=startScore; i < scoreButtons; i++, rank++) {
      if (rank < 0)       continue;
      if (ScoreData.buttonContains(mouseX,mouseY - offset,i)) {
        UI.updateTooltip(delta,focusScores[rank].getTooltipString(),true);
        break;
      }
    }
  }
}",0.9690380524698652
112484,"@Override public void run(){
  File beatmapDir=Options.getBeatmapDir();
  if (fullReload) {
    BeatmapDB.clearDatabase();
    OszUnpacker.unpackAllFiles(Options.getOSZDir(),beatmapDir);
  }
  BeatmapParser.parseAllFiles(beatmapDir);
  if (BeatmapSetList.get().size() > 0) {
    BeatmapSetList.get().init();
    setFocus(BeatmapSetList.get().getRandomNode(),-1,true,true);
  }
 else   MusicController.playThemeSong();
  reloadThread=null;
}","@Override public void run(){
  try {
    reloadBeatmaps();
  }
  finally {
    finished=true;
  }
}",0.2894248608534323
112485,"/** 
 * Reloads all beatmaps.
 * @param fullReload if true, also clear the beatmap cache and invoke the unpacker
 */
private void reloadBeatmaps(final boolean fullReload){
  songFolderChanged=false;
  MusicController.reset();
  startNode=focusNode=null;
  scoreMap=null;
  focusScores=null;
  oldFocusNode=null;
  randomStack=new Stack<SongNode>();
  songInfo=null;
  hoverOffset.setTime(0);
  hoverIndex=null;
  search.setText(""String_Node_Str"");
  searchTimer=SEARCH_DELAY;
  searchTransitionTimer=SEARCH_TRANSITION_TIME;
  searchResultString=null;
  lastBackgroundImage=null;
  reloadThread=new Thread(){
    @Override public void run(){
      File beatmapDir=Options.getBeatmapDir();
      if (fullReload) {
        BeatmapDB.clearDatabase();
        OszUnpacker.unpackAllFiles(Options.getOSZDir(),beatmapDir);
      }
      BeatmapParser.parseAllFiles(beatmapDir);
      if (BeatmapSetList.get().size() > 0) {
        BeatmapSetList.get().init();
        setFocus(BeatmapSetList.get().getRandomNode(),-1,true,true);
      }
 else       MusicController.playThemeSong();
      reloadThread=null;
    }
  }
;
  reloadThread.start();
}","/** 
 * Reloads all beatmaps.
 * @param fullReload if true, also clear the beatmap cache and invoke the unpacker
 */
private void reloadBeatmaps(final boolean fullReload){
  songFolderChanged=false;
  MusicController.reset();
  startNode=focusNode=null;
  scoreMap=null;
  focusScores=null;
  oldFocusNode=null;
  randomStack=new Stack<SongNode>();
  songInfo=null;
  hoverOffset.setTime(0);
  hoverIndex=null;
  search.setText(""String_Node_Str"");
  searchTimer=SEARCH_DELAY;
  searchTransitionTimer=SEARCH_TRANSITION_TIME;
  searchResultString=null;
  lastBackgroundImage=null;
  reloadThread=new BeatmapReloadThread(fullReload);
  reloadThread.start();
}",0.6707589285714286
112486,"@Override public void mouseReleased(int button,int x,int y){
  startDownloadIndexPos.release();
  startResultPos.release();
}","@Override public void mouseReleased(int button,int x,int y){
  startDownloadIndexPos.released();
  startResultPos.released();
}",0.992063492063492
112487,"/** 
 * Handles a slider tick result.
 * @param time the tick start time
 * @param result the hit result (HIT_* constants)
 * @param x the x coordinate
 * @param y the y coordinate
 * @param hitObject the hit object
 * @param repeat the current repeat number
 */
public void sliderTickResult(int time,int result,float x,float y,HitObject hitObject,int repeat){
  int hitValue=0;
switch (result) {
case HIT_SLIDER30:
    hitValue=30;
  changeHealth(1f);
SoundController.playHitSound(hitObject.getEdgeHitSoundType(repeat),hitObject.getSampleSet(repeat),hitObject.getAdditionSampleSet(repeat));
break;
case HIT_SLIDER10:
hitValue=10;
SoundController.playHitSound(HitSound.SLIDERTICK);
break;
case HIT_MISS:
resetComboStreak();
break;
default :
return;
}
if (hitValue > 0) {
score+=hitValue;
incrementComboStreak();
if (!Options.isPerfectHitBurstEnabled()) ;
 else hitResultList.add(new HitObjectResult(time,result,x,y,null,HitObjectType.SLIDERTICK,null,false));
}
fullObjectCount++;
}","/** 
 * Handles a slider tick result.
 * @param time the tick start time
 * @param result the hit result (HIT_* constants)
 * @param x the x coordinate
 * @param y the y coordinate
 * @param hitObject the hit object
 * @param repeat the current repeat number
 */
public void sliderTickResult(int time,int result,float x,float y,HitObject hitObject,int repeat){
  int hitValue=0;
switch (result) {
case HIT_SLIDER30:
    hitValue=30;
  changeHealth(1f);
SoundController.playHitSound(hitObject.getEdgeHitSoundType(repeat),hitObject.getSampleSet(repeat),hitObject.getAdditionSampleSet(repeat));
break;
case HIT_SLIDER10:
hitValue=10;
SoundController.playHitSound(HitSound.SLIDERTICK);
break;
case HIT_MISS:
resetComboStreak();
break;
default :
return;
}
if (hitValue > 0) {
score+=hitValue;
incrementComboStreak();
if (!Options.isPerfectHitBurstEnabled()) ;
 else hitResultList.add(new HitObjectResult(time,result,x,y,null,HitObjectType.SLIDERTICK,null,false,false));
}
fullObjectCount++;
}",0.9969512195121952
112488,"/** 
 * Constructor.
 * @param time the result's starting track position
 * @param result the hit result (HIT_* constants)
 * @param x the center x coordinate
 * @param y the center y coordinate
 * @param color the color of the hit object
 * @param curve the slider curve (or null if not applicable)
 * @param expand whether or not the hit result animation should expand (if applicable)
 */
public HitObjectResult(int time,int result,float x,float y,Color color,HitObjectType hitResultType,Curve curve,boolean expand){
  this.time=time;
  this.result=result;
  this.x=x;
  this.y=y;
  this.color=color;
  this.hitResultType=hitResultType;
  this.curve=curve;
  this.expand=expand;
}","/** 
 * Constructor.
 * @param time the result's starting track position
 * @param result the hit result (HIT_* constants)
 * @param x the center x coordinate
 * @param y the center y coordinate
 * @param color the color of the hit object
 * @param curve the slider curve (or null if not applicable)
 * @param expand whether or not the hit result animation should expand (if applicable)
 * @param hideResult whether or not to hide the hit result (but still show the other animations)
 */
public HitObjectResult(int time,int result,float x,float y,Color color,HitObjectType hitResultType,Curve curve,boolean expand,boolean hideResult){
  this.time=time;
  this.result=result;
  this.x=x;
  this.y=y;
  this.color=color;
  this.hitResultType=hitResultType;
  this.curve=curve;
  this.expand=expand;
  this.hideResult=hideResult;
}",0.9033112582781456
112489,"/** 
 * Draws stored hit results and removes them from the list as necessary.
 * @param trackPosition the current track position (in ms)
 */
public void drawHitResults(int trackPosition){
  Iterator<HitObjectResult> iter=hitResultList.iterator();
  while (iter.hasNext()) {
    HitObjectResult hitResult=iter.next();
    if (hitResult.time + HITRESULT_TIME > trackPosition) {
      if (hitResult.hitResultType == HitObjectType.SPINNER && hitResult.result != HIT_MISS) {
        Image spinnerOsu=GameImage.SPINNER_OSU.getImage();
        spinnerOsu.setAlpha(hitResult.alpha);
        spinnerOsu.drawCentered(width / 2,height / 4);
        spinnerOsu.setAlpha(1f);
      }
 else       if (Options.isHitLightingEnabled() && hitResult.result != HIT_MISS && hitResult.result != HIT_SLIDER30 && hitResult.result != HIT_SLIDER10) {
        Image lighting=GameImage.LIGHTING.getImage();
        lighting.setAlpha(hitResult.alpha);
        lighting.drawCentered(hitResult.x,hitResult.y,hitResult.color);
      }
      if (hitResult.result != HIT_MISS && (hitResult.hitResultType == HitObjectType.CIRCLE || hitResult.hitResultType == HitObjectType.SLIDER_FIRST || hitResult.hitResultType == HitObjectType.SLIDER_LAST)) {
        float scale=(!hitResult.expand) ? 1f : Utils.easeOut(Utils.clamp(trackPosition - hitResult.time,0,HITCIRCLE_FADE_TIME),1f,HITCIRCLE_ANIM_SCALE - 1f,HITCIRCLE_FADE_TIME);
        float alpha=Utils.easeOut(Utils.clamp(trackPosition - hitResult.time,0,HITCIRCLE_FADE_TIME),1f,-1f,HITCIRCLE_FADE_TIME);
        if (hitResult.curve != null) {
          float oldWhiteAlpha=Utils.COLOR_WHITE_FADE.a;
          float oldColorAlpha=hitResult.color.a;
          Utils.COLOR_WHITE_FADE.a=alpha;
          hitResult.color.a=alpha;
          hitResult.curve.draw(hitResult.color);
          Utils.COLOR_WHITE_FADE.a=oldWhiteAlpha;
          hitResult.color.a=oldColorAlpha;
        }
        Image scaledHitCircle=GameImage.HITCIRCLE.getImage().getScaledCopy(scale);
        Image scaledHitCircleOverlay=GameImage.HITCIRCLE_OVERLAY.getImage().getScaledCopy(scale);
        scaledHitCircle.setAlpha(alpha);
        scaledHitCircleOverlay.setAlpha(alpha);
        scaledHitCircle.drawCentered(hitResult.x,hitResult.y,hitResult.color);
        scaledHitCircleOverlay.drawCentered(hitResult.x,hitResult.y);
      }
      if (hitResult.hitResultType == HitObjectType.CIRCLE || hitResult.hitResultType == HitObjectType.SPINNER || hitResult.curve != null) {
        float scale=Utils.easeBounce(Utils.clamp(trackPosition - hitResult.time,0,HITCIRCLE_TEXT_BOUNCE_TIME),1f,HITCIRCLE_TEXT_ANIM_SCALE - 1f,HITCIRCLE_TEXT_BOUNCE_TIME);
        float alpha=Utils.easeOut(Utils.clamp((trackPosition - hitResult.time) - HITCIRCLE_FADE_TIME,0,HITCIRCLE_TEXT_FADE_TIME),1f,-1f,HITCIRCLE_TEXT_FADE_TIME);
        Image scaledHitResult=hitResults[hitResult.result].getScaledCopy(scale);
        scaledHitResult.setAlpha(alpha);
        scaledHitResult.drawCentered(hitResult.x,hitResult.y);
      }
      hitResult.alpha=1 - ((float)(trackPosition - hitResult.time) / HITRESULT_FADE_TIME);
    }
 else {
      if (hitResult.curve != null)       hitResult.curve.discardCache();
      iter.remove();
    }
  }
}","/** 
 * Draws stored hit results and removes them from the list as necessary.
 * @param trackPosition the current track position (in ms)
 */
public void drawHitResults(int trackPosition){
  Iterator<HitObjectResult> iter=hitResultList.iterator();
  while (iter.hasNext()) {
    HitObjectResult hitResult=iter.next();
    if (hitResult.time + HITRESULT_TIME > trackPosition) {
      if (hitResult.hitResultType == HitObjectType.SPINNER && hitResult.result != HIT_MISS) {
        Image spinnerOsu=GameImage.SPINNER_OSU.getImage();
        spinnerOsu.setAlpha(hitResult.alpha);
        spinnerOsu.drawCentered(width / 2,height / 4);
        spinnerOsu.setAlpha(1f);
      }
 else       if (Options.isHitLightingEnabled() && !hitResult.hideResult && hitResult.result != HIT_MISS && hitResult.result != HIT_SLIDER30 && hitResult.result != HIT_SLIDER10) {
        Image lighting=GameImage.LIGHTING.getImage();
        lighting.setAlpha(hitResult.alpha);
        lighting.drawCentered(hitResult.x,hitResult.y,hitResult.color);
      }
      if (hitResult.result != HIT_MISS && (hitResult.hitResultType == HitObjectType.CIRCLE || hitResult.hitResultType == HitObjectType.SLIDER_FIRST || hitResult.hitResultType == HitObjectType.SLIDER_LAST)) {
        float progress=AnimationEquation.OUT_CUBIC.calc((float)Utils.clamp(trackPosition - hitResult.time,0,HITCIRCLE_FADE_TIME) / HITCIRCLE_FADE_TIME);
        float scale=(!hitResult.expand) ? 1f : 1f + (HITCIRCLE_ANIM_SCALE - 1f) * progress;
        float alpha=1f - progress;
        if (hitResult.curve != null) {
          float oldWhiteAlpha=Utils.COLOR_WHITE_FADE.a;
          float oldColorAlpha=hitResult.color.a;
          Utils.COLOR_WHITE_FADE.a=alpha;
          hitResult.color.a=alpha;
          hitResult.curve.draw(hitResult.color);
          Utils.COLOR_WHITE_FADE.a=oldWhiteAlpha;
          hitResult.color.a=oldColorAlpha;
        }
        if (!(hitResult.hitResultType == HitObjectType.CIRCLE && GameMod.HIDDEN.isActive())) {
          Image scaledHitCircle=GameImage.HITCIRCLE.getImage().getScaledCopy(scale);
          Image scaledHitCircleOverlay=GameImage.HITCIRCLE_OVERLAY.getImage().getScaledCopy(scale);
          scaledHitCircle.setAlpha(alpha);
          scaledHitCircleOverlay.setAlpha(alpha);
          scaledHitCircle.drawCentered(hitResult.x,hitResult.y,hitResult.color);
          scaledHitCircleOverlay.drawCentered(hitResult.x,hitResult.y);
        }
      }
      if (!hitResult.hideResult && (hitResult.hitResultType == HitObjectType.CIRCLE || hitResult.hitResultType == HitObjectType.SPINNER || hitResult.curve != null)) {
        float scaleProgress=AnimationEquation.IN_OUT_BOUNCE.calc((float)Utils.clamp(trackPosition - hitResult.time,0,HITCIRCLE_TEXT_BOUNCE_TIME) / HITCIRCLE_TEXT_BOUNCE_TIME);
        float scale=1f + (HITCIRCLE_TEXT_ANIM_SCALE - 1f) * scaleProgress;
        float fadeProgress=AnimationEquation.OUT_CUBIC.calc((float)Utils.clamp((trackPosition - hitResult.time) - HITCIRCLE_FADE_TIME,0,HITCIRCLE_TEXT_FADE_TIME) / HITCIRCLE_TEXT_FADE_TIME);
        float alpha=1f - fadeProgress;
        Image scaledHitResult=hitResults[hitResult.result].getScaledCopy(scale);
        scaledHitResult.setAlpha(alpha);
        scaledHitResult.drawCentered(hitResult.x,hitResult.y);
      }
      hitResult.alpha=1 - ((float)(trackPosition - hitResult.time) / HITRESULT_FADE_TIME);
    }
 else {
      if (hitResult.curve != null)       hitResult.curve.discardCache();
      iter.remove();
    }
  }
}",0.7492890285885346
112490,"/** 
 * Handles a hit result.
 * @param time the object start time
 * @param result the hit result (HIT_* constants)
 * @param x the x coordinate
 * @param y the y coordinate
 * @param color the combo color
 * @param end true if this is the last hit object in the combo
 * @param hitObject the hit object
 * @param hitResultType the type of hit object for the result
 * @param expand whether or not the hit result animation should expand (if applicable)
 * @param repeat the current repeat number (for sliders, or 0 otherwise)
 * @param curve the slider curve (or null if not applicable)
 * @param sliderHeldToEnd whether or not the slider was held to the end (if applicable)
 */
public void hitResult(int time,int result,float x,float y,Color color,boolean end,HitObject hitObject,HitObjectType hitResultType,boolean expand,int repeat,Curve curve,boolean sliderHeldToEnd){
  int hitResult=handleHitResult(time,result,x,y,color,end,hitObject,hitResultType,repeat,(curve != null && !sliderHeldToEnd));
  if ((hitResult == HIT_300 || hitResult == HIT_300G || hitResult == HIT_300K) && !Options.isPerfectHitBurstEnabled())   ;
 else   if (hitResult == HIT_MISS && (GameMod.RELAX.isActive() || GameMod.AUTOPILOT.isActive()))   ;
 else {
    hitResultList.add(new HitObjectResult(time,hitResult,x,y,color,hitResultType,curve,expand));
    if (curve != null) {
      boolean isFirst=(hitResultType == HitObjectType.SLIDER_FIRST);
      float[] p=curve.pointAt((isFirst) ? 1f : 0f);
      HitObjectType type=(isFirst) ? HitObjectType.SLIDER_LAST : HitObjectType.SLIDER_FIRST;
      hitResultList.add(new HitObjectResult(time,hitResult,p[0],p[1],color,type,null,expand));
    }
  }
}","/** 
 * Handles a hit result.
 * @param time the object start time
 * @param result the hit result (HIT_* constants)
 * @param x the x coordinate
 * @param y the y coordinate
 * @param color the combo color
 * @param end true if this is the last hit object in the combo
 * @param hitObject the hit object
 * @param hitResultType the type of hit object for the result
 * @param expand whether or not the hit result animation should expand (if applicable)
 * @param repeat the current repeat number (for sliders, or 0 otherwise)
 * @param curve the slider curve (or null if not applicable)
 * @param sliderHeldToEnd whether or not the slider was held to the end (if applicable)
 */
public void hitResult(int time,int result,float x,float y,Color color,boolean end,HitObject hitObject,HitObjectType hitResultType,boolean expand,int repeat,Curve curve,boolean sliderHeldToEnd){
  int hitResult=handleHitResult(time,result,x,y,color,end,hitObject,hitResultType,repeat,(curve != null && !sliderHeldToEnd));
  if (hitResult == HIT_MISS && (GameMod.RELAX.isActive() || GameMod.AUTOPILOT.isActive()))   return;
  boolean hideResult=(hitResult == HIT_300 || hitResult == HIT_300G || hitResult == HIT_300K) && !Options.isPerfectHitBurstEnabled();
  hitResultList.add(new HitObjectResult(time,hitResult,x,y,color,hitResultType,curve,expand,hideResult));
  if (curve != null) {
    boolean isFirst=(hitResultType == HitObjectType.SLIDER_FIRST);
    float[] p=curve.pointAt((isFirst) ? 1f : 0f);
    HitObjectType type=(isFirst) ? HitObjectType.SLIDER_LAST : HitObjectType.SLIDER_FIRST;
    hitResultList.add(new HitObjectResult(time,hitResult,p[0],p[1],color,type,null,expand,hideResult));
  }
}",0.8668453976764968
112491,"/** 
 * Updates the slider object.
 * @param overlap true if the next object's start time has already passed
 * @param delta the delta interval since the last call
 * @param mouseX the x coordinate of the mouse
 * @param mouseY the y coordinate of the mouse
 * @return true if slider ended
 */
public boolean update(boolean overlap,int delta,int mouseX,int mouseY){
  int repeatCount=hitObject.getRepeatCount();
  if (sliderTimeTotal == 0f) {
    this.sliderTime=game.getBeatLength() * (hitObject.getPixelLength() / sliderMultiplier) / 100f;
    this.sliderTimeTotal=sliderTime * repeatCount;
    float tickLengthDiv=100f * sliderMultiplier / sliderTickRate / game.getTimingPointMultiplier();
    int tickCount=(int)Math.ceil(hitObject.getPixelLength() / tickLengthDiv) - 1;
    if (tickCount > 0) {
      this.ticksT=new float[tickCount];
      float tickTOffset=1f / (tickCount + 1);
      float t=tickTOffset;
      for (int i=0; i < tickCount; i++, t+=tickTOffset)       ticksT[i]=t;
    }
  }
  byte hitSound=hitObject.getHitSoundType();
  int trackPosition=MusicController.getPosition();
  int[] hitResultOffset=game.getHitResultOffsets();
  int lastIndex=hitObject.getSliderX().length - 1;
  boolean isAutoMod=GameMod.AUTO.isActive();
  if (!sliderClicked) {
    int time=hitObject.getTime();
    if (trackPosition > time + hitResultOffset[GameScore.HIT_50]) {
      sliderClicked=true;
      if (isAutoMod) {
        ticksHit++;
        score.sliderTickResult(time,GameScore.HIT_SLIDER30,hitObject.getX(),hitObject.getY(),hitSound);
      }
 else       score.sliderTickResult(time,GameScore.HIT_MISS,hitObject.getX(),hitObject.getY(),hitSound);
    }
 else     if (isAutoMod) {
      if (Math.abs(trackPosition - time) < hitResultOffset[GameScore.HIT_300]) {
        ticksHit++;
        sliderClicked=true;
        score.sliderTickResult(time,GameScore.HIT_SLIDER30,hitObject.getX(),hitObject.getY(),hitSound);
      }
    }
  }
  if (overlap || trackPosition > hitObject.getTime() + sliderTimeTotal) {
    tickIntervals++;
    if (isAutoMod)     ticksHit++;
 else     if (Utils.isGameKeyPressed()) {
      double distance=Math.hypot(hitObject.getSliderX()[lastIndex] - mouseX,hitObject.getSliderY()[lastIndex] - mouseY);
      int followCircleRadius=GameImage.SLIDER_FOLLOWCIRCLE.getImage().getWidth() / 2;
      if (distance < followCircleRadius)       ticksHit++;
    }
    hitResult();
    return true;
  }
  boolean isNewRepeat=false;
  if (repeatCount - 1 > currentRepeats) {
    float t=getT(trackPosition,true);
    if (Math.floor(t) > currentRepeats) {
      currentRepeats++;
      tickIntervals++;
      isNewRepeat=true;
    }
  }
  boolean isNewTick=false;
  if (ticksT != null && tickIntervals < (ticksT.length * (currentRepeats + 1)) + repeatCount && tickIntervals < (ticksT.length * repeatCount) + repeatCount) {
    float t=getT(trackPosition,true);
    if (t - Math.floor(t) >= ticksT[tickIndex]) {
      tickIntervals++;
      tickIndex=(tickIndex + 1) % ticksT.length;
      isNewTick=true;
    }
  }
  float[] c=bezier.pointAt(getT(trackPosition,false));
  double distance=Math.hypot(c[0] - mouseX,c[1] - mouseY);
  int followCircleRadius=GameImage.SLIDER_FOLLOWCIRCLE.getImage().getWidth() / 2;
  if ((Utils.isGameKeyPressed() && distance < followCircleRadius) || isAutoMod) {
    followCircleActive=true;
    score.changeHealth(delta * GameScore.HP_DRAIN_MULTIPLIER);
    if (isNewRepeat) {
      ticksHit++;
      if (currentRepeats % 2 > 0)       score.sliderTickResult(trackPosition,GameScore.HIT_SLIDER30,hitObject.getSliderX()[lastIndex],hitObject.getSliderY()[lastIndex],hitSound);
 else       score.sliderTickResult(trackPosition,GameScore.HIT_SLIDER30,c[0],c[1],hitSound);
    }
    if (isNewTick) {
      ticksHit++;
      score.sliderTickResult(trackPosition,GameScore.HIT_SLIDER10,c[0],c[1],(byte)-1);
    }
  }
 else {
    followCircleActive=false;
    if (isNewRepeat)     score.sliderTickResult(trackPosition,GameScore.HIT_MISS,0,0,hitSound);
    if (isNewTick)     score.sliderTickResult(trackPosition,GameScore.HIT_MISS,0,0,(byte)-1);
  }
  return false;
}","/** 
 * Updates the slider object.
 * @param overlap true if the next object's start time has already passed
 * @param delta the delta interval since the last call
 * @param mouseX the x coordinate of the mouse
 * @param mouseY the y coordinate of the mouse
 * @return true if slider ended
 */
public boolean update(boolean overlap,int delta,int mouseX,int mouseY){
  int repeatCount=hitObject.getRepeatCount();
  if (sliderTimeTotal == 0f) {
    this.sliderTime=game.getBeatLength() * (hitObject.getPixelLength() / sliderMultiplier) / 100f;
    this.sliderTimeTotal=sliderTime * repeatCount;
    float tickLengthDiv=100f * sliderMultiplier / sliderTickRate / game.getTimingPointMultiplier();
    int tickCount=(int)Math.ceil(hitObject.getPixelLength() / tickLengthDiv) - 1;
    if (tickCount > 0) {
      this.ticksT=new float[tickCount];
      float tickTOffset=1f / (tickCount + 1);
      float t=tickTOffset;
      for (int i=0; i < tickCount; i++, t+=tickTOffset)       ticksT[i]=t;
    }
  }
  byte hitSound=hitObject.getHitSoundType();
  int trackPosition=MusicController.getPosition();
  int[] hitResultOffset=game.getHitResultOffsets();
  int lastIndex=hitObject.getSliderX().length - 1;
  boolean isAutoMod=GameMod.AUTO.isActive();
  if (!sliderClicked) {
    int time=hitObject.getTime();
    if (trackPosition > time + hitResultOffset[GameScore.HIT_50]) {
      sliderClicked=true;
      if (isAutoMod) {
        ticksHit++;
        score.sliderTickResult(time,GameScore.HIT_SLIDER30,hitObject.getX(),hitObject.getY(),hitSound);
      }
 else       score.sliderTickResult(time,GameScore.HIT_MISS,hitObject.getX(),hitObject.getY(),hitSound);
    }
 else     if (isAutoMod) {
      if (Math.abs(trackPosition - time) < hitResultOffset[GameScore.HIT_300]) {
        ticksHit++;
        sliderClicked=true;
        score.sliderTickResult(time,GameScore.HIT_SLIDER30,hitObject.getX(),hitObject.getY(),hitSound);
      }
    }
  }
  if (overlap || trackPosition > hitObject.getTime() + sliderTimeTotal) {
    tickIntervals++;
    if (isAutoMod)     ticksHit++;
 else     if (Utils.isGameKeyPressed()) {
      float[] c=bezier.pointAt(getT(trackPosition,false));
      double distance=Math.hypot(c[0] - mouseX,c[1] - mouseY);
      int followCircleRadius=GameImage.SLIDER_FOLLOWCIRCLE.getImage().getWidth() / 2;
      if (distance < followCircleRadius)       ticksHit++;
    }
    hitResult();
    return true;
  }
  boolean isNewRepeat=false;
  if (repeatCount - 1 > currentRepeats) {
    float t=getT(trackPosition,true);
    if (Math.floor(t) > currentRepeats) {
      currentRepeats++;
      tickIntervals++;
      isNewRepeat=true;
    }
  }
  boolean isNewTick=false;
  if (ticksT != null && tickIntervals < (ticksT.length * (currentRepeats + 1)) + repeatCount && tickIntervals < (ticksT.length * repeatCount) + repeatCount) {
    float t=getT(trackPosition,true);
    if (t - Math.floor(t) >= ticksT[tickIndex]) {
      tickIntervals++;
      tickIndex=(tickIndex + 1) % ticksT.length;
      isNewTick=true;
    }
  }
  float[] c=bezier.pointAt(getT(trackPosition,false));
  double distance=Math.hypot(c[0] - mouseX,c[1] - mouseY);
  int followCircleRadius=GameImage.SLIDER_FOLLOWCIRCLE.getImage().getWidth() / 2;
  if ((Utils.isGameKeyPressed() && distance < followCircleRadius) || isAutoMod) {
    followCircleActive=true;
    score.changeHealth(delta * GameScore.HP_DRAIN_MULTIPLIER);
    if (isNewRepeat) {
      ticksHit++;
      if (currentRepeats % 2 > 0)       score.sliderTickResult(trackPosition,GameScore.HIT_SLIDER30,hitObject.getSliderX()[lastIndex],hitObject.getSliderY()[lastIndex],hitSound);
 else       score.sliderTickResult(trackPosition,GameScore.HIT_SLIDER30,c[0],c[1],hitSound);
    }
    if (isNewTick) {
      ticksHit++;
      score.sliderTickResult(trackPosition,GameScore.HIT_SLIDER10,c[0],c[1],(byte)-1);
    }
  }
 else {
    followCircleActive=false;
    if (isNewRepeat)     score.sliderTickResult(trackPosition,GameScore.HIT_MISS,0,0,(byte)-1);
    if (isNewTick)     score.sliderTickResult(trackPosition,GameScore.HIT_MISS,0,0,(byte)-1);
  }
  return false;
}",0.9828195442914583
112492,"public static void main(String[] args){
  Log.setVerbose(false);
  try {
    DefaultLogSystem.out=new PrintStream(new FileOutputStream(Options.LOG_FILE,true));
  }
 catch (  FileNotFoundException e) {
    Log.error(e);
  }
  Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler(){
    @Override public void uncaughtException(    Thread t,    Throwable e){
      Log.error(""String_Node_Str"",e);
    }
  }
);
  Options.parseOptions();
  try {
    SERVER_SOCKET=new ServerSocket(Options.getPort());
  }
 catch (  IOException e) {
    Log.error(String.format(""String_Node_Str"",Options.getPort()),e);
    System.exit(1);
  }
  ResourceLoader.removeAllResourceLocations();
  ResourceLoader.addResourceLocation(new FileSystemLocation(Options.getSkinDir()));
  ResourceLoader.addResourceLocation(new ClasspathLocation());
  ResourceLoader.addResourceLocation(new FileSystemLocation(new File(""String_Node_Str"")));
  ResourceLoader.addResourceLocation(new FileSystemLocation(new File(""String_Node_Str"")));
  if (!Options.TMP_DIR.mkdir()) {
    for (    File tmp : Options.TMP_DIR.listFiles())     tmp.delete();
  }
  Options.TMP_DIR.deleteOnExit();
  Opsu opsu=new Opsu(""String_Node_Str"");
  try {
    AppGameContainer app=new AppGameContainer(opsu);
    int[] containerSize=Options.getContainerSize();
    app.setDisplayMode(containerSize[0],containerSize[1],false);
    String[] icons={""String_Node_Str"",""String_Node_Str""};
    app.setIcons(icons);
    app.start();
  }
 catch (  SlickException e) {
    Log.error(""String_Node_Str"",e);
  }
}","public static void main(String[] args){
  Log.setVerbose(false);
  try {
    DefaultLogSystem.out=new PrintStream(new FileOutputStream(Options.LOG_FILE,true));
  }
 catch (  FileNotFoundException e) {
    Log.error(e);
  }
  Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler(){
    @Override public void uncaughtException(    Thread t,    Throwable e){
      if (!(e instanceof ThreadDeath))       Log.error(""String_Node_Str"",e);
    }
  }
);
  Options.parseOptions();
  try {
    SERVER_SOCKET=new ServerSocket(Options.getPort());
  }
 catch (  IOException e) {
    Log.error(String.format(""String_Node_Str"",Options.getPort()),e);
    System.exit(1);
  }
  ResourceLoader.removeAllResourceLocations();
  ResourceLoader.addResourceLocation(new FileSystemLocation(Options.getSkinDir()));
  ResourceLoader.addResourceLocation(new ClasspathLocation());
  ResourceLoader.addResourceLocation(new FileSystemLocation(new File(""String_Node_Str"")));
  ResourceLoader.addResourceLocation(new FileSystemLocation(new File(""String_Node_Str"")));
  if (!Options.TMP_DIR.mkdir()) {
    for (    File tmp : Options.TMP_DIR.listFiles())     tmp.delete();
  }
  Options.TMP_DIR.deleteOnExit();
  Opsu opsu=new Opsu(""String_Node_Str"");
  try {
    AppGameContainer app=new AppGameContainer(opsu);
    int[] containerSize=Options.getContainerSize();
    app.setDisplayMode(containerSize[0],containerSize[1],false);
    String[] icons={""String_Node_Str"",""String_Node_Str""};
    app.setIcons(icons);
    app.start();
  }
 catch (  SlickException e) {
    Log.error(""String_Node_Str"",e);
  }
}",0.9876386687797148
112493,"@Override public void uncaughtException(Thread t,Throwable e){
  Log.error(""String_Node_Str"",e);
}","@Override public void uncaughtException(Thread t,Throwable e){
  if (!(e instanceof ThreadDeath))   Log.error(""String_Node_Str"",e);
}",0.8484848484848485
112494,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  mInnerRectF.set(0,0,mViewSize,mViewSize);
  mInnerRectF.offset((getWidth() - mViewSize) / 2,(getHeight() - mViewSize) / 2);
  final int halfBorder=(int)(mStrokePaint.getStrokeWidth() / 2f + 0.5f);
  mInnerRectF.inset(halfBorder,halfBorder);
  float centerX=mInnerRectF.centerX();
  float centerY=mInnerRectF.centerY();
  canvas.drawArc(mInnerRectF,0,360,true,mBackgroundPaint);
switch (mProgressFillType) {
case FILL_TYPE_RADIAL:
    float sweepAngle=360 * mProgress / mMax;
  canvas.drawArc(mInnerRectF,mStartAngle,sweepAngle,true,mProgressPaint);
break;
case FILL_TYPE_CENTER:
float radius=(mViewSize / 2) * ((float)mProgress / mMax);
canvas.drawCircle(centerX,centerY,radius + 0.5f - mStrokePaint.getStrokeWidth(),mProgressPaint);
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + mProgressFillType);
}
if (!TextUtils.isEmpty(mText) && mShowText) {
if (!TextUtils.isEmpty(mTypeface)) {
Typeface typeface=sTypefaceCache.get(mTypeface);
if (null == typeface && null != getResources()) {
AssetManager assets=getResources().getAssets();
if (null != assets) {
typeface=Typeface.createFromAsset(assets,mTypeface);
sTypefaceCache.put(mTypeface,typeface);
}
}
mTextPaint.setTypeface(typeface);
}
int xPos=(int)centerX;
int yPos=(int)(centerY - (mTextPaint.descent() + mTextPaint.ascent()) / 2);
canvas.drawText(mText,xPos,yPos,mTextPaint);
}
if (null != mImage && mShowImage) {
int drawableSize=mImage.getIntrinsicWidth();
mImageRect.set(0,0,drawableSize,drawableSize);
mImageRect.offset((getWidth() - drawableSize) / 2,(getHeight() - drawableSize) / 2);
mImage.setBounds(mImageRect);
mImage.draw(canvas);
}
if (mShowStroke) {
canvas.drawOval(mInnerRectF,mStrokePaint);
}
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  mInnerRectF.set(0,0,mViewSize,mViewSize);
  mInnerRectF.offset((getWidth() - mViewSize) / 2,(getHeight() - mViewSize) / 2);
  if (mShowStroke) {
    final int halfBorder=(int)(mStrokePaint.getStrokeWidth() / 2f + 0.5f);
    mInnerRectF.inset(halfBorder,halfBorder);
  }
  float centerX=mInnerRectF.centerX();
  float centerY=mInnerRectF.centerY();
  canvas.drawArc(mInnerRectF,0,360,true,mBackgroundPaint);
switch (mProgressFillType) {
case FILL_TYPE_RADIAL:
    float sweepAngle=360 * mProgress / mMax;
  canvas.drawArc(mInnerRectF,mStartAngle,sweepAngle,true,mProgressPaint);
break;
case FILL_TYPE_CENTER:
float radius=(mViewSize / 2) * ((float)mProgress / mMax);
if (mShowStroke) {
radius=radius + 0.5f - mStrokePaint.getStrokeWidth();
}
canvas.drawCircle(centerX,centerY,radius,mProgressPaint);
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + mProgressFillType);
}
if (!TextUtils.isEmpty(mText) && mShowText) {
if (!TextUtils.isEmpty(mTypeface)) {
Typeface typeface=sTypefaceCache.get(mTypeface);
if (null == typeface && null != getResources()) {
AssetManager assets=getResources().getAssets();
if (null != assets) {
typeface=Typeface.createFromAsset(assets,mTypeface);
sTypefaceCache.put(mTypeface,typeface);
}
}
mTextPaint.setTypeface(typeface);
}
int xPos=(int)centerX;
int yPos=(int)(centerY - (mTextPaint.descent() + mTextPaint.ascent()) / 2);
canvas.drawText(mText,xPos,yPos,mTextPaint);
}
if (null != mImage && mShowImage) {
int drawableSize=mImage.getIntrinsicWidth();
mImageRect.set(0,0,drawableSize,drawableSize);
mImageRect.offset((getWidth() - drawableSize) / 2,(getHeight() - drawableSize) / 2);
mImage.setBounds(mImageRect);
mImage.draw(canvas);
}
if (mShowStroke) {
canvas.drawOval(mInnerRectF,mStrokePaint);
}
}",0.9546340105761202
112495,"/** 
 * Runs the calibration and checks that all the trades used in the curve calibration have a PV of 0.
 * @param args  -p to run the performance estimate
 */
public static void main(String[] args){
  System.out.println(""String_Node_Str"");
  Pair<List<Trade>,Results> results=calculate();
  System.out.println(""String_Node_Str"");
  for (int i=0; i < results.getFirst().size(); i++) {
    Trade trade=results.getFirst().get(i);
    Result<?> pv=results.getSecond().getCells().get(i);
    String output=""String_Node_Str"" + trade.getClass().getSimpleName() + ""String_Node_Str""+ pv.isSuccess();
    Object pvValue=pv.getValue();
    ArgChecker.isTrue(pvValue instanceof CurrencyAmount,""String_Node_Str"");
    CurrencyAmount ca=(CurrencyAmount)pvValue;
    output+=""String_Node_Str"" + ca;
    System.out.println(output);
    ArgChecker.isTrue(Math.abs(ca.getAmount()) < TOLERANCE_PV,""String_Node_Str"");
  }
  if (args.length > 0) {
    if (args[0].equals(""String_Node_Str"")) {
      performance_calibration_pricing();
    }
  }
  System.out.println(""String_Node_Str"");
}","/** 
 * Runs the calibration and checks that all the trades used in the curve calibration have a PV of 0.
 * @param args  -p to run the performance estimate
 */
public static void main(String[] args){
  System.out.println(""String_Node_Str"");
  Pair<List<Trade>,Results> results=calculate();
  System.out.println(""String_Node_Str"");
  for (int i=0; i < results.getFirst().size(); i++) {
    Trade trade=results.getFirst().get(i);
    Result<?> pv=results.getSecond().getCells().get(i);
    String output=""String_Node_Str"" + trade.getClass().getSimpleName() + ""String_Node_Str""+ pv.isSuccess();
    Object pvValue=pv.getValue();
    ArgChecker.isTrue(pvValue instanceof CurrencyAmount,""String_Node_Str"");
    CurrencyAmount ca=(CurrencyAmount)pvValue;
    output+=""String_Node_Str"" + ca;
    System.out.println(output);
    ArgChecker.isTrue(Math.abs(ca.getAmount()) < TOLERANCE_PV,""String_Node_Str"");
  }
  if (args.length > 0) {
    if (args[0].equals(""String_Node_Str"")) {
      performanceCalibrationPricing();
    }
  }
  System.out.println(""String_Node_Str"");
}",0.99718574108818
112496,"/** 
 * Runs the calibration and checks that all the trades used in the curve calibration have a PV of 0.
 * @param args  -p to run the performance estimate
 */
public static void main(String[] args){
  System.out.println(""String_Node_Str"");
  Pair<List<Trade>,Results> results=calculate();
  System.out.println(""String_Node_Str"");
  for (int i=0; i < results.getFirst().size(); i++) {
    Trade trade=results.getFirst().get(i);
    Result<?> pv=results.getSecond().getCells().get(i);
    String output=""String_Node_Str"" + trade.getClass().getSimpleName() + ""String_Node_Str""+ pv.isSuccess();
    Object pvValue=pv.getValue();
    ArgChecker.isTrue(pvValue instanceof CurrencyAmount,""String_Node_Str"");
    CurrencyAmount ca=(CurrencyAmount)pvValue;
    output+=""String_Node_Str"" + ca;
    System.out.println(output);
    ArgChecker.isTrue(Math.abs(ca.getAmount()) < TOLERANCE_PV,""String_Node_Str"");
  }
  if (args.length > 0) {
    if (args[0].equals(""String_Node_Str"")) {
      performance_calibration_pricing();
    }
  }
  System.out.println(""String_Node_Str"");
}","/** 
 * Runs the calibration and checks that all the trades used in the curve calibration have a PV of 0.
 * @param args  -p to run the performance estimate
 */
public static void main(String[] args){
  System.out.println(""String_Node_Str"");
  Pair<List<Trade>,Results> results=calculate();
  System.out.println(""String_Node_Str"");
  for (int i=0; i < results.getFirst().size(); i++) {
    Trade trade=results.getFirst().get(i);
    Result<?> pv=results.getSecond().getCells().get(i);
    String output=""String_Node_Str"" + trade.getClass().getSimpleName() + ""String_Node_Str""+ pv.isSuccess();
    Object pvValue=pv.getValue();
    ArgChecker.isTrue(pvValue instanceof CurrencyAmount,""String_Node_Str"");
    CurrencyAmount ca=(CurrencyAmount)pvValue;
    output+=""String_Node_Str"" + ca;
    System.out.println(output);
    ArgChecker.isTrue(Math.abs(ca.getAmount()) < TOLERANCE_PV,""String_Node_Str"");
  }
  if (args.length > 0) {
    if (args[0].equals(""String_Node_Str"")) {
      performanceCalibrationPricing();
    }
  }
  System.out.println(""String_Node_Str"");
}",0.99718574108818
112497,"/** 
 * Runs the calibration and checks that all the trades used in the curve calibration have a PV of 0.
 * @param args  -p to run the performance estimate
 */
public static void main(String[] args){
  System.out.println(""String_Node_Str"");
  Pair<List<Trade>,Results> results=calculate();
  System.out.println(""String_Node_Str"");
  for (int i=0; i < results.getFirst().size(); i++) {
    Trade trade=results.getFirst().get(i);
    Result<?> pv=results.getSecond().getCells().get(i);
    String output=""String_Node_Str"" + trade.getClass().getSimpleName() + ""String_Node_Str""+ pv.isSuccess();
    Object pvValue=pv.getValue();
    ArgChecker.isTrue(pvValue instanceof CurrencyAmount,""String_Node_Str"");
    CurrencyAmount ca=(CurrencyAmount)pvValue;
    output+=""String_Node_Str"" + ca;
    System.out.println(output);
    ArgChecker.isTrue(Math.abs(ca.getAmount()) < TOLERANCE_PV,""String_Node_Str"");
  }
  if (args.length > 0) {
    if (args[0].equals(""String_Node_Str"")) {
      performance_calibration_pricing();
    }
  }
  System.out.println(""String_Node_Str"");
}","/** 
 * Runs the calibration and checks that all the trades used in the curve calibration have a PV of 0.
 * @param args  -p to run the performance estimate
 */
public static void main(String[] args){
  System.out.println(""String_Node_Str"");
  Pair<List<Trade>,Results> results=calculate();
  System.out.println(""String_Node_Str"");
  for (int i=0; i < results.getFirst().size(); i++) {
    Trade trade=results.getFirst().get(i);
    Result<?> pv=results.getSecond().getCells().get(i);
    String output=""String_Node_Str"" + trade.getClass().getSimpleName() + ""String_Node_Str""+ pv.isSuccess();
    Object pvValue=pv.getValue();
    ArgChecker.isTrue(pvValue instanceof CurrencyAmount,""String_Node_Str"");
    CurrencyAmount ca=(CurrencyAmount)pvValue;
    output+=""String_Node_Str"" + ca;
    System.out.println(output);
    ArgChecker.isTrue(Math.abs(ca.getAmount()) < TOLERANCE_PV,""String_Node_Str"");
  }
  if (args.length > 0) {
    if (args[0].equals(""String_Node_Str"")) {
      performanceCalibrationPricing();
    }
  }
  System.out.println(""String_Node_Str"");
}",0.99718574108818
112498,"/** 
 * Runs the calibration and checks that all the trades used in the curve calibration have a PV of 0.
 * @param args  -p to run the performance estimate
 */
public static void main(String[] args){
  System.out.println(""String_Node_Str"");
  Pair<List<Trade>,Results> results=calculate();
  System.out.println(""String_Node_Str"");
  for (int i=0; i < results.getFirst().size(); i++) {
    Trade trade=results.getFirst().get(i);
    Result<?> pv=results.getSecond().getCells().get(i);
    String output=""String_Node_Str"" + trade.getClass().getSimpleName() + ""String_Node_Str""+ pv.isSuccess();
    Object pvValue=pv.getValue();
    ArgChecker.isTrue((pvValue instanceof CurrencyAmount),""String_Node_Str"");
    CurrencyAmount ca=(CurrencyAmount)pvValue;
    output=output + ""String_Node_Str"" + ca;
    System.out.println(output);
    ArgChecker.isTrue(Math.abs(ca.getAmount()) < TOLERANCE_PV,""String_Node_Str"");
  }
  if (args.length > 0) {
    if (args[0].equals(""String_Node_Str"")) {
      performance_calibration_pricing();
    }
  }
  System.out.println(""String_Node_Str"");
}","/** 
 * Runs the calibration and checks that all the trades used in the curve calibration have a PV of 0.
 * @param args  -p to run the performance estimate
 */
public static void main(String[] args){
  System.out.println(""String_Node_Str"");
  Pair<List<Trade>,Results> results=calculate();
  System.out.println(""String_Node_Str"");
  for (int i=0; i < results.getFirst().size(); i++) {
    Trade trade=results.getFirst().get(i);
    Result<?> pv=results.getSecond().getCells().get(i);
    String output=""String_Node_Str"" + trade.getClass().getSimpleName() + ""String_Node_Str""+ pv.isSuccess();
    Object pvValue=pv.getValue();
    ArgChecker.isTrue((pvValue instanceof CurrencyAmount),""String_Node_Str"");
    CurrencyAmount ca=(CurrencyAmount)pvValue;
    output=output + ""String_Node_Str"" + ca;
    System.out.println(output);
    ArgChecker.isTrue(Math.abs(ca.getAmount()) < TOLERANCE_PV,""String_Node_Str"");
  }
  if (args.length > 0) {
    if (args[0].equals(""String_Node_Str"")) {
      performanceCalibrationPricing();
    }
  }
  System.out.println(""String_Node_Str"");
}",0.9972118959107806
112499,"private static Pair<List<Trade>,Results> calculate(CalculationRunner runner){
  ReferenceData refData=ReferenceData.standard();
  ImmutableMap<QuoteId,Double> quotes=QuotesCsvLoader.load(VAL_DATE,QUOTES_RESOURCE);
  Map<ObservableId,LocalDateDoubleTimeSeries> FIXINGS_US_CPI_U=FixingSeriesCsvLoader.load(FIXING_RESOURCE);
  MarketData marketData=ImmutableMarketData.builder(VAL_DATE).addValueMap(quotes).addTimeSeriesMap(FIXINGS_US_CPI_U).build();
  Map<CurveGroupName,CurveGroupDefinition> defns=RatesCalibrationCsvLoader.load(GROUPS_RESOURCE,SETTINGS_RESOURCE,CALIBRATION_RESOURCE);
  CurveGroupDefinition curveGroupDefinition=defns.get(CURVE_GROUP_NAME).filtered(VAL_DATE,refData);
  List<Trade> trades=curveGroupDefinition.getCurveDefinitions().stream().flatMap(defn -> defn.getNodes().stream()).filter(node -> !(node instanceof IborFixingDepositCurveNode)).map(node -> node.trade(1d,marketData,refData)).collect(toImmutableList());
  List<Column> columns=ImmutableList.of(Column.of(Measures.PRESENT_VALUE));
  MarketDataConfig marketDataConfig=MarketDataConfig.builder().add(CURVE_GROUP_NAME,curveGroupDefinition).build();
  CalculationFunctions functions=StandardComponents.calculationFunctions();
  RatesMarketDataLookup ratesLookup=RatesMarketDataLookup.of(curveGroupDefinition);
  CalculationRules rules=CalculationRules.of(functions,ratesLookup);
  MarketDataRequirements reqs=MarketDataRequirements.of(rules,trades,columns,refData);
  MarketData calibratedMarketData=marketDataFactory().create(reqs,marketDataConfig,marketData,refData);
  Results results=runner.calculate(rules,trades,columns,calibratedMarketData,refData);
  return Pair.of(trades,results);
}","private static Pair<List<Trade>,Results> calculate(CalculationRunner runner){
  ReferenceData refData=ReferenceData.standard();
  ImmutableMap<QuoteId,Double> quotes=QuotesCsvLoader.load(VAL_DATE,QUOTES_RESOURCE);
  Map<ObservableId,LocalDateDoubleTimeSeries> fixings=FixingSeriesCsvLoader.load(FIXING_RESOURCE);
  MarketData marketData=ImmutableMarketData.builder(VAL_DATE).addValueMap(quotes).addTimeSeriesMap(fixings).build();
  Map<CurveGroupName,CurveGroupDefinition> defns=RatesCalibrationCsvLoader.load(GROUPS_RESOURCE,SETTINGS_RESOURCE,CALIBRATION_RESOURCE);
  CurveGroupDefinition curveGroupDefinition=defns.get(CURVE_GROUP_NAME).filtered(VAL_DATE,refData);
  List<Trade> trades=curveGroupDefinition.getCurveDefinitions().stream().flatMap(defn -> defn.getNodes().stream()).filter(node -> !(node instanceof IborFixingDepositCurveNode)).map(node -> node.trade(1d,marketData,refData)).collect(toImmutableList());
  List<Column> columns=ImmutableList.of(Column.of(Measures.PRESENT_VALUE));
  MarketDataConfig marketDataConfig=MarketDataConfig.builder().add(CURVE_GROUP_NAME,curveGroupDefinition).build();
  CalculationFunctions functions=StandardComponents.calculationFunctions();
  RatesMarketDataLookup ratesLookup=RatesMarketDataLookup.of(curveGroupDefinition);
  CalculationRules rules=CalculationRules.of(functions,ratesLookup);
  MarketDataRequirements reqs=MarketDataRequirements.of(rules,trades,columns,refData);
  MarketData calibratedMarketData=marketDataFactory().create(reqs,marketDataConfig,marketData,refData);
  Results results=runner.calculate(rules,trades,columns,calibratedMarketData,refData);
  return Pair.of(trades,results);
}",0.9861529199277544
112500,"/** 
 * Runs the calibration and checks that all the trades used in the curve calibration have a PV of 0.
 * @param args  -p to run the performance estimate
 */
public static void main(String[] args){
  System.out.println(""String_Node_Str"");
  Pair<List<Trade>,Results> results=calculate();
  System.out.println(""String_Node_Str"");
  for (int i=0; i < results.getFirst().size(); i++) {
    Trade trade=results.getFirst().get(i);
    Result<?> pv=results.getSecond().getCells().get(i);
    String output=""String_Node_Str"" + trade.getClass().getSimpleName() + ""String_Node_Str""+ pv.isSuccess();
    Object pvValue=pv.getValue();
    ArgChecker.isTrue((pvValue instanceof CurrencyAmount),""String_Node_Str"");
    CurrencyAmount ca=(CurrencyAmount)pvValue;
    output=output + ""String_Node_Str"" + ca;
    System.out.println(output);
    ArgChecker.isTrue(Math.abs(ca.getAmount()) < TOLERANCE_PV,""String_Node_Str"");
  }
  if (args.length > 0) {
    if (args[0].equals(""String_Node_Str"")) {
      performance_calibration_pricing();
    }
  }
  System.out.println(""String_Node_Str"");
}","/** 
 * Runs the calibration and checks that all the trades used in the curve calibration have a PV of 0.
 * @param args  -p to run the performance estimate
 */
public static void main(String[] args){
  System.out.println(""String_Node_Str"");
  Pair<List<Trade>,Results> results=calculate();
  System.out.println(""String_Node_Str"");
  for (int i=0; i < results.getFirst().size(); i++) {
    Trade trade=results.getFirst().get(i);
    Result<?> pv=results.getSecond().getCells().get(i);
    String output=""String_Node_Str"" + trade.getClass().getSimpleName() + ""String_Node_Str""+ pv.isSuccess();
    Object pvValue=pv.getValue();
    ArgChecker.isTrue((pvValue instanceof CurrencyAmount),""String_Node_Str"");
    CurrencyAmount ca=(CurrencyAmount)pvValue;
    output=output + ""String_Node_Str"" + ca;
    System.out.println(output);
    ArgChecker.isTrue(Math.abs(ca.getAmount()) < TOLERANCE_PV,""String_Node_Str"");
  }
  if (args.length > 0) {
    if (args[0].equals(""String_Node_Str"")) {
      performanceCalibrationPricing();
    }
  }
  System.out.println(""String_Node_Str"");
}",0.9972118959107806
112501,"/** 
 * Runs the calibration and checks that all the trades used in the curve calibration have a PV of 0.
 * @param args  -p to run the performance estimate
 */
public static void main(String[] args){
  System.out.println(""String_Node_Str"");
  Pair<List<Trade>,Results> results=calculate();
  System.out.println(""String_Node_Str"");
  for (int i=0; i < results.getFirst().size(); i++) {
    Trade trade=results.getFirst().get(i);
    Result<?> pv=results.getSecond().getCells().get(i);
    String output=""String_Node_Str"" + trade.getClass().getSimpleName() + ""String_Node_Str""+ pv.isSuccess();
    Object pvValue=pv.getValue();
    ArgChecker.isTrue(pvValue instanceof CurrencyAmount,""String_Node_Str"");
    CurrencyAmount ca=(CurrencyAmount)pvValue;
    output+=""String_Node_Str"" + ca;
    System.out.println(output);
    ArgChecker.isTrue(Math.abs(ca.getAmount()) < TOLERANCE_PV,""String_Node_Str"");
  }
  if (args.length > 0) {
    if (args[0].equals(""String_Node_Str"")) {
      performance_calibration_pricing();
    }
  }
  System.out.println(""String_Node_Str"");
}","/** 
 * Runs the calibration and checks that all the trades used in the curve calibration have a PV of 0.
 * @param args  -p to run the performance estimate
 */
public static void main(String[] args){
  System.out.println(""String_Node_Str"");
  Pair<List<Trade>,Results> results=calculate();
  System.out.println(""String_Node_Str"");
  for (int i=0; i < results.getFirst().size(); i++) {
    Trade trade=results.getFirst().get(i);
    Result<?> pv=results.getSecond().getCells().get(i);
    String output=""String_Node_Str"" + trade.getClass().getSimpleName() + ""String_Node_Str""+ pv.isSuccess();
    Object pvValue=pv.getValue();
    ArgChecker.isTrue(pvValue instanceof CurrencyAmount,""String_Node_Str"");
    CurrencyAmount ca=(CurrencyAmount)pvValue;
    output+=""String_Node_Str"" + ca;
    System.out.println(output);
    ArgChecker.isTrue(Math.abs(ca.getAmount()) < TOLERANCE_PV,""String_Node_Str"");
  }
  if (args.length > 0) {
    if (args[0].equals(""String_Node_Str"")) {
      performanceCalibrationPricing();
    }
  }
  System.out.println(""String_Node_Str"");
}",0.99718574108818
112502,"/** 
 * Runs the example, serializing and deserializing the portfolio and printing to the screen.
 * @param args  ignored
 */
public static void main(String[] args){
  String xmlString=serializePretty(tradeList);
  System.out.println(""String_Node_Str"" + tradeList.toString());
  System.out.println(""String_Node_Str"" + xmlString);
  TradeList deserializedPortfolioFromString=deserialize(xmlString);
  System.out.println(""String_Node_Str"" + deserializedPortfolioFromString.toString());
  TradeList deserializedPortfolioFromFile=deserialize(loadExamplePortfolio());
  System.out.println(""String_Node_Str"" + deserializedPortfolioFromFile.toString());
}","/** 
 * Runs the example, serializing and deserializing the portfolio and printing to the screen.
 * @param args  ignored
 */
public static void main(String[] args){
  String xmlString=serializePretty(TRADE_LIST);
  System.out.println(""String_Node_Str"" + TRADE_LIST.toString());
  System.out.println(""String_Node_Str"" + xmlString);
  TradeList deserializedPortfolioFromString=deserialize(xmlString);
  System.out.println(""String_Node_Str"" + deserializedPortfolioFromString.toString());
  TradeList deserializedPortfolioFromFile=deserialize(loadExamplePortfolio());
  System.out.println(""String_Node_Str"" + deserializedPortfolioFromFile.toString());
}",0.9738058551617874
112503,"public void test_load_from_classpath(){
  String xmlStringFromClasspath=CdsTradeExample.loadExamplePortfolio();
  String xmlStringFromClasspathCompact=CdsTradeExample.serializeCompact(CdsTradeExample.deserialize(xmlStringFromClasspath));
  String xmlStringFromCode=CdsTradeExample.serializeCompact(CdsTradeExample.tradeList);
  assertEquals(xmlStringFromClasspathCompact,xmlStringFromCode);
}","public void test_load_from_classpath(){
  String xmlStringFromClasspath=CdsTradeExample.loadExamplePortfolio();
  String xmlStringFromClasspathCompact=CdsTradeExample.serializeCompact(CdsTradeExample.deserialize(xmlStringFromClasspath));
  String xmlStringFromCode=CdsTradeExample.serializeCompact(CdsTradeExample.TRADE_LIST);
  assertEquals(xmlStringFromClasspathCompact,xmlStringFromCode);
}",0.978343949044586
112504,"/** 
 * Creates a stream that wraps a stream with the index. <p> Each input object is decorated with an   {@link ObjIntPair}. The   {@code int} is the index of the element in the stream.
 * @param < T >  the type of the stream
 * @param stream  the stream to index
 * @return a stream of pairs, containing the element and index
 */
public static <T>Stream<ObjIntPair<T>> zipWithIndex(Stream<T> stream){
  Spliterator<T> split1=stream.spliterator();
  Iterator<T> it1=Spliterators.iterator(split1);
  Iterator<ObjIntPair<T>> it=new Iterator<ObjIntPair<T>>(){
    int index=0;
    @Override public boolean hasNext(){
      return it1.hasNext();
    }
    @Override public ObjIntPair<T> next(){
      return ObjIntPair.of(it1.next(),index++);
    }
  }
;
  Spliterator<ObjIntPair<T>> split=Spliterators.spliterator(it,split1.getExactSizeIfKnown(),split1.characteristics());
  return StreamSupport.stream(split,false);
}","/** 
 * Creates a stream that wraps a stream with the index. <p> Each input object is decorated with an   {@link ObjIntPair}. The   {@code int} is the index of the element in the stream.
 * @param < T >  the type of the stream
 * @param stream  the stream to index
 * @return a stream of pairs, containing the element and index
 */
public static <T>Stream<ObjIntPair<T>> zipWithIndex(Stream<T> stream){
  Spliterator<T> split1=stream.spliterator();
  Iterator<T> it1=Spliterators.iterator(split1);
  Iterator<ObjIntPair<T>> it=new Iterator<ObjIntPair<T>>(){
    private int index;
    @Override public boolean hasNext(){
      return it1.hasNext();
    }
    @Override public ObjIntPair<T> next(){
      return ObjIntPair.of(it1.next(),index++);
    }
  }
;
  Spliterator<ObjIntPair<T>> split=Spliterators.spliterator(it,split1.getExactSizeIfKnown(),split1.characteristics());
  return StreamSupport.stream(split,false);
}",0.984766050054407
112505,"/** 
 * Builds a set of market data from the data in this builder. <p> It is possible to continue to add more data to a builder after calling   {@code build()}. Any  {@code BaseMarketData} instances built previously will be unaffected.
 * @return a set of market data from the data in this builder
 */
public MarketEnvironment build(){
  return new MarketEnvironment(valuationDate,scenarioCount,values,timeSeries,valueFailures,timeSeriesFailures);
}","/** 
 * Builds a set of market data from the data in this builder. <p> It is possible to continue to add more data to a builder after calling   {@code build()}. Any  {@code BaseMarketData} instances built previously will be unaffected.
 * @return a set of market data from the data in this builder
 */
public MarketEnvironment build(){
  if (valuationDate.getScenarioCount() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return new MarketEnvironment(valuationDate,scenarioCount,values,timeSeries,valueFailures,timeSeriesFailures);
}",0.6924603174603174
112506,"/** 
 * Creates a new function for building curve groups that delegates to   {@code curveBuilder} to perform calibration.
 * @param rootFinderConfig  the configuration for the root finder used when calibrating curves
 * @param measures  the measures used for calibration
 */
public CurveGroupMarketDataFunction(RootFinderConfig rootFinderConfig,CalibrationMeasures measures){
  this.curveCalibrator=CurveCalibrator.of(rootFinderConfig.getAbsoluteTolerance(),rootFinderConfig.getRelativeTolerance(),rootFinderConfig.getMaximumSteps(),measures);
}","/** 
 * Creates a new function for building curve groups that delegates to   {@code curveCalibrator} to perform calibration.
 * @param curveCalibrator  performs the calibration
 */
public CurveGroupMarketDataFunction(CurveCalibrator curveCalibrator){
  this.curveCalibrator=curveCalibrator;
}",0.3918757467144564
112507,"/** 
 * Extracts the underlying quotes from the   {@link CurveInputs} instances and returns them in a map.
 * @param inputs  input data for the curve
 * @return the underlying quotes from the input data
 */
private static MarketData inputsByKey(List<CurveInputs> inputs){
  Map<? extends MarketDataKey<?>,?> valueMap=inputs.stream().flatMap(pr -> pr.getMarketData().entrySet().stream()).collect(toMap(Map.Entry::getKey,Map.Entry::getValue));
  return MarketData.of(valueMap);
}","/** 
 * Extracts the underlying quotes from the   {@link CurveInputs} instances and returns them in a map.
 * @param inputs  input data for the curve
 * @return the underlying quotes from the input data
 */
private static MarketData inputsByKey(List<CurveInputs> inputs){
  BinaryOperator<Object> mergeFunction=(v1,v2) -> checkValuesEqual(v1,v2);
  Map<? extends MarketDataKey<?>,?> valueMap=inputs.stream().flatMap(pr -> pr.getMarketData().entrySet().stream()).collect(toMap(Map.Entry::getKey,Map.Entry::getValue,mergeFunction));
  return MarketData.of(valueMap);
}",0.9146692233940557
112508,"private static ScenarioDefinition buildHistoricalScenarios(Map<LocalDate,Map<RateCurveId,Curve>> historicalCurves,List<LocalDate> scenarioDates){
  CurveGroupName curveGroup=CurveGroupName.of(""String_Node_Str"");
  DiscountCurveId discountCurveId=DiscountCurveId.of(Currency.USD,curveGroup);
  RateIndexCurveId libor3mCurveId=RateIndexCurveId.of(IborIndices.USD_LIBOR_3M,curveGroup);
  RateIndexCurveId libor6mCurveId=RateIndexCurveId.of(IborIndices.USD_LIBOR_6M,curveGroup);
  Set<RateCurveId> curveIds=ImmutableSet.of(discountCurveId,libor3mCurveId,libor6mCurveId);
  LocalDate firstScenarioDate=scenarioDates.get(0);
  Map<RateCurveId,Curve> previousCurves=historicalCurves.get(firstScenarioDate);
  List<Perturbation<Curve>> baseScenario=ImmutableList.of(Perturbation.none());
  Map<RateCurveId,List<Perturbation<Curve>>> curvePerturbations=previousCurves.keySet().stream().collect(toImmutableMap(id -> id,k -> Lists.newArrayList(baseScenario)));
  for (int i=1; i < scenarioDates.size(); i++) {
    LocalDate scenarioDate=scenarioDates.get(i);
    Map<RateCurveId,Curve> curves=historicalCurves.get(scenarioDate);
    for (    RateCurveId curveId : curveIds) {
      NodalCurve curve=(NodalCurve)curves.get(curveId);
      NodalCurve previousCurve=(NodalCurve)previousCurves.get(curveId);
      List<CurveParameterMetadata> curveNodeMetadata=curve.getMetadata().getParameters().get();
      CurvePointShiftBuilder shiftBuilder=CurvePointShift.builder(ShiftType.ABSOLUTE);
      for (int curveNodeIdx=0; curveNodeIdx < curve.getParameterCount(); curveNodeIdx++) {
        double zeroRate=curve.getYValues()[curveNodeIdx];
        double previousZeroRate=previousCurve.getYValues()[curveNodeIdx];
        double shift=(zeroRate - previousZeroRate);
        shiftBuilder.addShift(curveNodeMetadata.get(curveNodeIdx).getIdentifier(),shift);
      }
      curvePerturbations.get(curveId).add(shiftBuilder.build());
    }
    previousCurves=curves;
  }
  PerturbationMapping<Curve> discountCurveMappings=PerturbationMapping.of(Curve.class,AnyDiscountCurveFilter.INSTANCE,curvePerturbations.get(discountCurveId));
  PerturbationMapping<Curve> libor3mMappings=PerturbationMapping.of(Curve.class,CurveRateIndexFilter.of(IborIndices.USD_LIBOR_3M),curvePerturbations.get(libor3mCurveId));
  PerturbationMapping<Curve> libor6mMappings=PerturbationMapping.of(Curve.class,CurveRateIndexFilter.of(IborIndices.USD_LIBOR_6M),curvePerturbations.get(libor3mCurveId));
  return ScenarioDefinition.ofMappings(discountCurveMappings,libor3mMappings,libor6mMappings);
}","private static ScenarioDefinition buildHistoricalScenarios(Map<LocalDate,Map<RateCurveId,Curve>> historicalCurves,List<LocalDate> scenarioDates){
  CurveGroupName curveGroup=CurveGroupName.of(""String_Node_Str"");
  DiscountCurveId discountCurveId=DiscountCurveId.of(Currency.USD,curveGroup);
  RateIndexCurveId libor3mCurveId=RateIndexCurveId.of(IborIndices.USD_LIBOR_3M,curveGroup);
  RateIndexCurveId libor6mCurveId=RateIndexCurveId.of(IborIndices.USD_LIBOR_6M,curveGroup);
  Set<RateCurveId> curveIds=ImmutableSet.of(discountCurveId,libor3mCurveId,libor6mCurveId);
  LocalDate firstScenarioDate=scenarioDates.get(0);
  Map<RateCurveId,Curve> previousCurves=historicalCurves.get(firstScenarioDate);
  List<Perturbation<Curve>> baseScenario=ImmutableList.of(Perturbation.none());
  Map<RateCurveId,List<Perturbation<Curve>>> curvePerturbations=previousCurves.keySet().stream().collect(toImmutableMap(id -> id,k -> Lists.newArrayList(baseScenario)));
  for (int i=1; i < scenarioDates.size(); i++) {
    LocalDate scenarioDate=scenarioDates.get(i);
    Map<RateCurveId,Curve> curves=historicalCurves.get(scenarioDate);
    for (    RateCurveId curveId : curveIds) {
      NodalCurve curve=(NodalCurve)curves.get(curveId);
      NodalCurve previousCurve=(NodalCurve)previousCurves.get(curveId);
      List<CurveParameterMetadata> curveNodeMetadata=curve.getMetadata().getParameters().get();
      CurvePointShiftBuilder shiftBuilder=CurvePointShift.builder(ShiftType.ABSOLUTE);
      for (int curveNodeIdx=0; curveNodeIdx < curve.getParameterCount(); curveNodeIdx++) {
        double zeroRate=curve.getYValues()[curveNodeIdx];
        double previousZeroRate=previousCurve.getYValues()[curveNodeIdx];
        double shift=(zeroRate - previousZeroRate);
        shiftBuilder.addShift(curveNodeMetadata.get(curveNodeIdx).getIdentifier(),shift);
      }
      curvePerturbations.get(curveId).add(shiftBuilder.build());
    }
    previousCurves=curves;
  }
  PerturbationMapping<Curve> discountCurveMappings=PerturbationMapping.of(Curve.class,AnyDiscountCurveFilter.INSTANCE,curvePerturbations.get(discountCurveId));
  PerturbationMapping<Curve> libor3mMappings=PerturbationMapping.of(Curve.class,CurveRateIndexFilter.of(IborIndices.USD_LIBOR_3M),curvePerturbations.get(libor3mCurveId));
  PerturbationMapping<Curve> libor6mMappings=PerturbationMapping.of(Curve.class,CurveRateIndexFilter.of(IborIndices.USD_LIBOR_6M),curvePerturbations.get(libor6mCurveId));
  return ScenarioDefinition.ofMappings(discountCurveMappings,libor3mMappings,libor6mMappings);
}",0.9690074539034916
112509,"/** 
 * Creates an instance from a given classpath resource root location, using the given class loader to find the resource. <p> This is designed to handle resource roots which may physically correspond to a directory on disk, or be located within a jar file.
 * @param resourceRoot  the resource root path
 * @param classLoader  the class loader with which to find the resource
 * @return the market data builder
 */
public static MarketDataBuilder ofResource(String resourceRoot,ClassLoader classLoader){
  String qualifiedResourceRoot=resourceRoot.startsWith(File.separator) ? resourceRoot.substring(1) : resourceRoot;
  URL url=classLoader.getResource(qualifiedResourceRoot);
  if (url == null) {
    throw new IllegalArgumentException(Messages.format(""String_Node_Str"",resourceRoot));
  }
  if (url.getProtocol() != null && ""String_Node_Str"".equals(url.getProtocol().toLowerCase())) {
    int classSeparatorIdx=url.getFile().indexOf(""String_Node_Str"");
    if (classSeparatorIdx == -1) {
      throw new IllegalArgumentException(Messages.format(""String_Node_Str"",url));
    }
    String jarPath=url.getFile().substring(""String_Node_Str"".length(),classSeparatorIdx);
    File jarFile;
    try {
      jarFile=new File(jarPath);
    }
 catch (    Exception e) {
      throw new IllegalArgumentException(Messages.format(""String_Node_Str"",jarPath),e);
    }
    return new JarMarketDataBuilder(jarFile,resourceRoot);
  }
 else {
    File file;
    try {
      file=new File(url.toURI());
    }
 catch (    URISyntaxException e) {
      throw new IllegalArgumentException(Messages.format(""String_Node_Str"",url),e);
    }
    return new DirectoryMarketDataBuilder(file.toPath());
  }
}","/** 
 * Creates an instance from a given classpath resource root location, using the given class loader to find the resource. <p> This is designed to handle resource roots which may physically correspond to a directory on disk, or be located within a jar file.
 * @param resourceRoot  the resource root path
 * @param classLoader  the class loader with which to find the resource
 * @return the market data builder
 */
public static MarketDataBuilder ofResource(String resourceRoot,ClassLoader classLoader){
  String qualifiedResourceRoot=resourceRoot.startsWith(File.separator) ? resourceRoot.substring(1) : resourceRoot;
  if (!qualifiedResourceRoot.endsWith(File.separator)) {
    qualifiedResourceRoot+=File.separator;
  }
  URL url=classLoader.getResource(qualifiedResourceRoot);
  if (url == null) {
    throw new IllegalArgumentException(Messages.format(""String_Node_Str"",resourceRoot));
  }
  if (url.getProtocol() != null && ""String_Node_Str"".equals(url.getProtocol().toLowerCase())) {
    int classSeparatorIdx=url.getFile().indexOf(""String_Node_Str"");
    if (classSeparatorIdx == -1) {
      throw new IllegalArgumentException(Messages.format(""String_Node_Str"",url));
    }
    String jarPath=url.getFile().substring(""String_Node_Str"".length(),classSeparatorIdx);
    File jarFile;
    try {
      jarFile=new File(jarPath);
    }
 catch (    Exception e) {
      throw new IllegalArgumentException(Messages.format(""String_Node_Str"",jarPath),e);
    }
    return new JarMarketDataBuilder(jarFile,resourceRoot);
  }
 else {
    File file;
    try {
      file=new File(url.toURI());
    }
 catch (    URISyntaxException e) {
      throw new IllegalArgumentException(Messages.format(""String_Node_Str"",url),e);
    }
    return new DirectoryMarketDataBuilder(file.toPath());
  }
}",0.970063327576281
112510,"private void appendToZip(File sourceRootDir,String destRootPath,File currentFile,ZipOutputStream zipOutput) throws IOException {
  if (currentFile.isDirectory()) {
    zipOutput.putNextEntry(getEntry(sourceRootDir,destRootPath,currentFile));
    zipOutput.closeEntry();
    for (    File content : currentFile.listFiles()) {
      appendToZip(sourceRootDir,destRootPath,content,zipOutput);
    }
  }
 else {
    zipOutput.putNextEntry(getEntry(sourceRootDir,destRootPath,currentFile));
    try (FileInputStream fileIn=new FileInputStream(currentFile)){
      byte[] b=new byte[1024];
      int len;
      while ((len=fileIn.read(b)) != -1) {
        zipOutput.write(b,0,len);
      }
    }
     zipOutput.closeEntry();
  }
}","private void appendToZip(File sourceRootDir,String destRootPath,File currentFile,ZipOutputStream zipOutput) throws IOException {
  if (currentFile.isDirectory()) {
    String entryName=getEntryName(sourceRootDir,destRootPath,currentFile) + File.separator;
    zipOutput.putNextEntry(new ZipEntry(entryName));
    zipOutput.closeEntry();
    for (    File content : currentFile.listFiles()) {
      appendToZip(sourceRootDir,destRootPath,content,zipOutput);
    }
  }
 else {
    String entryName=getEntryName(sourceRootDir,destRootPath,currentFile);
    zipOutput.putNextEntry(new ZipEntry(entryName));
    try (FileInputStream fileIn=new FileInputStream(currentFile)){
      byte[] b=new byte[1024];
      int len;
      while ((len=fileIn.read(b)) != -1) {
        zipOutput.write(b,0,len);
      }
    }
     zipOutput.closeEntry();
  }
}",0.823003194888179
112511,"/** 
 * Assert that the   {@code Result} is a failure with thespecified  {@link FailureReason}.
 * @return this if a failure with the specified reason, elsethrow an  {@code AssertionError}
 */
public ResultAssert isFailure(FailureReason expected){
  isNotNull();
  FailureReason actualReason=actual.getFailure().getReason();
  if (actualReason != expected) {
    failWithMessage(""String_Node_Str"",expected,actualReason);
  }
  return this;
}","/** 
 * Assert that the   {@code Result} is a failure with thespecified  {@link FailureReason}.
 * @return this if a failure with the specified reason, elsethrow an  {@code AssertionError}
 */
public ResultAssert isFailure(FailureReason expected){
  isFailure();
  FailureReason actualReason=actual.getFailure().getReason();
  if (actualReason != expected) {
    failWithMessage(""String_Node_Str"",expected,actualReason);
  }
  return this;
}",0.984126984126984
112512,"/** 
 * If z doesn't contain the key, it's initialized at 0.0 and therefore less than laplace which is always >= 0.0
 */
public double getRegularizedWeight(String feature){
  if (z.containsKey(feature)) {
    double z_i=z.getCoordinate(feature);
    if (Math.abs(z_i) <= laplace) {
      return 0.0d;
    }
 else {
      double n_i=n.getCoordinate(feature);
      double w_i=-(((beta + Math.sqrt(n_i)) / alpha) + gaussian) * (z_i - Math.signum(z_i) * laplace);
      return w_i;
    }
  }
 else {
    return 0.0;
  }
}","/** 
 * If z doesn't contain the key, it's initialized at 0.0 and therefore less than laplace which is always >= 0.0
 */
public double getRegularizedWeight(String feature){
  if (z.containsKey(feature)) {
    double z_i=z.getCoordinate(feature);
    if (Math.abs(z_i) <= laplace) {
      return 0.0d;
    }
 else {
      double n_i=n.getCoordinate(feature);
      double w_i=-1.0 / (((beta + Math.sqrt(n_i)) / alpha) + gaussian) * (z_i - Math.signum(z_i) * laplace);
      return w_i;
    }
  }
 else {
    return 0.0;
  }
}",0.9942418426103646
112513,"public double getFeatureLearningRate(String feature){
  return initialLearningRate / Math.sqrt(gradients.getCoordinate(feature));
}","public double getFeatureLearningRate(String feature){
  return initialLearningRate / Math.sqrt(summedGradients.getCoordinate(feature));
}",0.9701492537313432
112514,"public double adagradL1(String feature,double param,long iter){
  double eta=(initialLearningRate * iter) / Math.sqrt(gradients.getCoordinate(feature));
  double u=unnormalizedGradients.getCoordinate(feature);
  double normalizedGradient=u / iter;
  if (Math.abs(normalizedGradient) <= laplace) {
    param=0.0;
  }
 else {
    param=-(Math.signum(u) * eta * (normalizedGradient - laplace));
  }
  return param;
}","public double adagradL1(String feature,double param,long iter){
  double eta=(initialLearningRate * iter) / Math.sqrt(summedGradients.getCoordinate(feature));
  double u=unnormalizedGradients.getCoordinate(feature);
  double normalizedGradient=u / iter;
  if (Math.abs(normalizedGradient) <= laplace) {
    param=0.0;
  }
 else {
    param=-(Math.signum(u) * eta * (normalizedGradient - laplace));
  }
  return param;
}",0.9903846153846154
112515,"@Override public StringKeyedVector getUpdate(LabeledInstance instance){
  StringKeyedVector gradients=model.getGradients(instance);
  Iterator it=gradients.iterator();
  while (it.hasNext()) {
    Map.Entry<String,Double> pairs=(Map.Entry)it.next();
    String feature=pairs.getKey();
    double gradient=pairs.getValue();
    double featureLearningRate=updateAndGetFeatureLearningRate(feature,gradient);
    gradients.setCoordinate(feature,gradient * featureLearningRate);
  }
  return gradients;
}","@Override public StringKeyedVector getUpdate(LabeledInstance instance){
  StringKeyedVector gradients=model.getGradients(instance);
  Iterator it=gradients.iterator();
  while (it.hasNext()) {
    Map.Entry<String,Double> pairs=(Map.Entry)it.next();
    String feature=pairs.getKey();
    double gradient=pairs.getValue();
    double featureLearningRate=updateAndGetFeatureLearningRate(feature,gradient);
    summedGradients.setCoordinate(feature,gradient * featureLearningRate);
  }
  return gradients;
}",0.9920318725099602
112516,"/** 
 * Update adaptive feature specific learning rates
 */
public double updateAndGetFeatureLearningRate(String feature,double gradient){
  double gradUpdate=0.0;
  if (gradients.containsKey(feature)) {
    gradUpdate=gradient * gradient;
  }
 else {
    gradUpdate=1d + (gradient * gradient);
  }
  gradients.addToCoordinate(feature,gradUpdate);
  unnormalizedGradients.addToCoordinate(feature,gradient);
  return getFeatureLearningRate(feature);
}","/** 
 * Update adaptive feature specific learning rates
 */
public double updateAndGetFeatureLearningRate(String feature,double gradient){
  double gradUpdate=0.0;
  if (summedGradients.containsKey(feature)) {
    gradUpdate=gradient * gradient;
  }
 else {
    gradUpdate=1d + (gradient * gradient);
  }
  summedGradients.addToCoordinate(feature,gradUpdate);
  unnormalizedGradients.addToCoordinate(feature,gradient);
  return getFeatureLearningRate(feature);
}",0.9824561403508772
112517,"@Override public void teardown(){
  gradients=new StringKeyedVector();
  unnormalizedGradients=new StringKeyedVector();
}","@Override public void teardown(){
  summedGradients=new StringKeyedVector();
  unnormalizedGradients=new StringKeyedVector();
}",0.967741935483871
112518,"public double getFeatureLearningRate(String feature){
  return initialLearningRate / Math.sqrt(gradients.getCoordinate(feature));
}","public double getFeatureLearningRate(String feature){
  return initialLearningRate / Math.sqrt(summedGradients.getCoordinate(feature));
}",0.9701492537313432
112519,"@Override public StringKeyedVector getUpdate(LabeledInstance instance){
  StringKeyedVector gradients=model.getGradients(instance);
  Iterator it=gradients.iterator();
  while (it.hasNext()) {
    Map.Entry<String,Double> pairs=(Map.Entry)it.next();
    String feature=pairs.getKey();
    double gradient=pairs.getValue();
    double featureLearningRate=updateAndGetFeatureLearningRate(feature,gradient);
    gradients.setCoordinate(feature,gradient * featureLearningRate);
  }
  return gradients;
}","@Override public StringKeyedVector getUpdate(LabeledInstance instance){
  StringKeyedVector gradients=model.getGradients(instance);
  Iterator it=gradients.iterator();
  while (it.hasNext()) {
    Map.Entry<String,Double> pairs=(Map.Entry)it.next();
    String feature=pairs.getKey();
    double gradient=pairs.getValue();
    double featureLearningRate=updateAndGetFeatureLearningRate(feature,gradient);
    summedGradients.setCoordinate(feature,gradient * featureLearningRate);
  }
  return gradients;
}",0.9920318725099602
112520,"/** 
 * Update adaptive feature specific learning rates
 */
public double updateAndGetFeatureLearningRate(String feature,double gradient){
  double gradUpdate=0.0;
  if (gradients.containsKey(feature)) {
    gradUpdate=gradient * gradient;
  }
 else {
    gradUpdate=1d + (gradient * gradient);
  }
  gradients.addToCoordinate(feature,gradUpdate);
  return getFeatureLearningRate(feature);
}","/** 
 * Update adaptive feature specific learning rates
 */
public double updateAndGetFeatureLearningRate(String feature,double gradient){
  double gradUpdate=0.0;
  if (summedGradients.containsKey(feature)) {
    gradUpdate=gradient * gradient;
  }
 else {
    gradUpdate=1d + (gradient * gradient);
  }
  summedGradients.addToCoordinate(feature,gradUpdate);
  return getFeatureLearningRate(feature);
}",0.9798488664987406
112521,"@Override public void teardown(){
  gradients=new StringKeyedVector();
}","@Override public void teardown(){
  summedGradients=new StringKeyedVector();
}",0.9466666666666668
112522,"@Override public StringKeyedVector getUpdate(LabeledInstance instance){
  StringKeyedVector gradients=model.getGradients(instance);
  double learningRate=getDecreasingLearningRate(model.epoch);
  gradients.mul(learningRate);
  return gradients;
}","@Override public StringKeyedVector getUpdate(LabeledInstance instance){
  StringKeyedVector gradients=model.getGradients(instance);
  double learningRate=getDecreasingLearningRate(model.epoch);
  gradients.mul(-learningRate);
  return gradients;
}",0.9979716024340772
112523,"@Override public double loss(LabeledInstance<BinaryLabel> instance){
  double hypothesis=Utilities.logistic(param.dot(instance.getVector()));
  double label=instance.getLabel().getAsPlusMinus();
  double z=hypothesis * label;
  if (z <= this.threshold) {
    return this.threshold - z;
  }
 else {
    return 0.0;
  }
}","@Override public double loss(LabeledInstance<BinaryLabel> instance){
  double inner=param.dot(instance.getVector());
  double label=instance.getLabel().getAsPlusMinus();
  double z=inner * label;
  if (z <= this.threshold) {
    return this.threshold - z;
  }
 else {
    return 0.0;
  }
}",0.7401315789473685
112524,"@Override public StringKeyedVector getGradients(LabeledInstance<BinaryLabel> instance){
  StringKeyedVector gradients=instance.getVector().copy();
  double hypothesis=(param.dot(instance.getVector()));
  double label=instance.getLabel().getAsPlusMinus();
  if (hypothesis * label <= this.threshold) {
    gradients.mul(-label);
    return gradients;
  }
 else {
    return new StringKeyedVector();
  }
}","@Override public StringKeyedVector getGradients(LabeledInstance<BinaryLabel> instance){
  StringKeyedVector gradients=instance.getVector().copy();
  double inner=param.dot(instance.getVector());
  double label=instance.getLabel().getAsPlusMinus();
  double z=inner * label;
  if (z <= this.threshold) {
    gradients.mul(-label);
    return gradients;
  }
 else {
    return new StringKeyedVector();
  }
}",0.7252475247524752
112525,"@Override public StringKeyedVector getGradients(LabeledInstance<BinaryLabel> instance){
  StringKeyedVector gradients=instance.getVector().copy();
  double label=instance.getLabel().getAsPlusMinus();
  double inner=instance.getVector().dot(param);
  double gradient=-label * Utilities.logistic(-label * inner);
  gradients.mul(gradient);
  return gradients;
}","@Override public StringKeyedVector getGradients(LabeledInstance<BinaryLabel> instance){
  StringKeyedVector gradients=instance.getVector().copy();
  double label=instance.getLabel().getAsPlusMinus();
  double inner=instance.getVector().dot(param);
  double gradient=-label / (Math.exp(label * inner) + 1.0);
  gradients.mul(gradient);
  return gradients;
}",0.911888111888112
112526,"/** 
 * Single gradient update
 */
public void update(LabeledInstance<L> instance){
  optimizer.model=this;
  if (epoch > 0) {
    param.incrementIteration();
  }
  StringKeyedVector update=optimizer.getUpdate(instance);
  param.addScaled(update,-1.0);
  truncate(instance);
  epoch++;
}","/** 
 * Single gradient update
 */
public void update(LabeledInstance<L> instance){
  optimizer.model=this;
  if (epoch > 0) {
    param.incrementIteration();
  }
  StringKeyedVector update=optimizer.getUpdate(instance);
  param.add(update);
  truncate(instance);
  epoch++;
}",0.955595026642984
112527,"/** 
 * Call to syncUser method
 */
public void postUser(){
  new SyncUser().getUserID(email,personName);
}","/** 
 * Call to syncUser method
 */
public void postUser(){
  userID=new SyncUser().getUserID(email,personName);
}",0.9683257918552036
112528,"@Override public View getView(int position,View convertView,ViewGroup arg2){
  final ViewHolder holder;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=inflater.inflate(R.layout.saved_tab,null);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.txtName=(TextView)convertView.findViewById(R.id.svd_name);
  holder.txtDate=(TextView)convertView.findViewById(R.id.svd_date);
  holder.txtsync=(TextView)convertView.findViewById(R.id.svd_sync);
  holder.img=(ImageView)convertView.findViewById(R.id.svd_image);
  holder.txtName.setText(list.get(position).getPersonName());
  holder.txtDate.setText(list.get(position).getPersonEmail());
  holder.txtsync.setText(list.get(position).getCreated());
  if (list.get(position).isSynced()) {
    holder.img.setImageResource(R.drawable.pro_pic);
  }
  return convertView;
}","@Override public View getView(int position,View convertView,ViewGroup arg2){
  final ViewHolder holder;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=inflater.inflate(R.layout.saved_tab,null);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  holder.txtName=(TextView)convertView.findViewById(R.id.svd_name);
  holder.txtDate=(TextView)convertView.findViewById(R.id.svd_date);
  holder.txtsync=(TextView)convertView.findViewById(R.id.svd_sync);
  holder.img=(ImageView)convertView.findViewById(R.id.svd_image);
  holder.txtName.setText(list.get(position).getPersonName());
  holder.txtDate.setText(list.get(position).getPersonEmail());
  holder.txtsync.setText(list.get(position).getCreated());
  if (list.get(position).isSynced()) {
    holder.img.setImageResource(R.drawable.synced);
  }
  return convertView;
}",0.9926677946982516
112529,"@Override public String convertInputStreamToString(InputStream inputStream) throws IOException {
  BufferedReader bufferedReader=new BufferedReader(new InputStreamReader(inputStream));
  String line=""String_Node_Str"";
  String result=""String_Node_Str"";
  while ((line=bufferedReader.readLine()) != null)   result+=line;
  inputStream.close();
  System.out.println(""String_Node_Str"" + result);
  JSONObject jObject;
  String out=null;
  try {
    jObject=new JSONObject(result);
    out=jObject.getString(""String_Node_Str"");
    jObject=new JSONObject(""String_Node_Str"");
  }
 catch (  JSONException e) {
    e.printStackTrace();
  }
  return out;
}","@Override public String convertInputStreamToString(InputStream inputStream) throws IOException {
  BufferedReader bufferedReader=new BufferedReader(new InputStreamReader(inputStream));
  String line=""String_Node_Str"";
  String result=""String_Node_Str"";
  while ((line=bufferedReader.readLine()) != null)   result+=line;
  inputStream.close();
  System.out.println(""String_Node_Str"" + result);
  JSONObject jObject;
  String out=null;
  try {
    jObject=new JSONObject(result);
    out=jObject.getString(""String_Node_Str"");
    jObject=new JSONObject(out);
    out=jObject.getString(""String_Node_Str"");
  }
 catch (  JSONException e) {
    e.printStackTrace();
  }
  return out;
}",0.9759036144578314
112530,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_create);
  btnCreate=(Button)findViewById(R.id.create_btn_create);
  btnCreate.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      if (setData()) {
      }
 else {
      }
    }
  }
);
  spnUnits=(Spinner)findViewById(R.id.create_spn_unit);
  ArrayAdapter<CharSequence> uitsAdapter=ArrayAdapter.createFromResource(this,R.array.units_array,android.R.layout.simple_spinner_item);
  spnUnits.setAdapter(uitsAdapter);
  spnGender=(Spinner)findViewById(R.id.create_spn_gender);
  ArrayAdapter<CharSequence> genderAdapter=ArrayAdapter.createFromResource(this,R.array.gender_array,android.R.layout.simple_spinner_item);
  spnGender.setAdapter(genderAdapter);
  context=this;
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_create);
  btnCreate=(Button)findViewById(R.id.create_btn_create);
  btnCreate.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      if (!setData()) {
        dialog(""String_Node_Str"",""String_Node_Str"");
      }
    }
  }
);
  spnUnits=(Spinner)findViewById(R.id.create_spn_unit);
  ArrayAdapter<CharSequence> uitsAdapter=ArrayAdapter.createFromResource(this,R.array.units_array,android.R.layout.simple_spinner_item);
  spnUnits.setAdapter(uitsAdapter);
  spnGender=(Spinner)findViewById(R.id.create_spn_gender);
  ArrayAdapter<CharSequence> genderAdapter=ArrayAdapter.createFromResource(this,R.array.gender_array,android.R.layout.simple_spinner_item);
  spnGender.setAdapter(genderAdapter);
  context=this;
}",0.9676674364896074
112531,"public void dialog(String title,String message){
  AlertDialog.Builder builder=new AlertDialog.Builder(this);
  builder.setTitle(title).setMessage(message).setIcon(R.drawable.warning).setCancelable(false).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      dialog.cancel();
      closer();
    }
  }
);
  alertDialog=builder.create();
  alertDialog.show();
}","public void dialog(String title,String message){
  AlertDialog.Builder builder=new AlertDialog.Builder(this);
  builder.setTitle(title).setMessage(message).setIcon(R.drawable.warning).setCancelable(false).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      dialog.cancel();
    }
  }
);
  alertDialog=builder.create();
  alertDialog.show();
}",0.8510158013544018
112532,"public void onClick(DialogInterface dialog,int id){
  dialog.cancel();
  closer();
}","public void onClick(DialogInterface dialog,int id){
  dialog.cancel();
}",0.9230769230769232
112533,"private void setMeasurement(String name,String email){
  person=new Person(email,name,spnGender.getSelectedItemPosition());
  int personID=PersonManager.getInstance(this.getApplicationContext()).getPerson(person);
  if (personID == -1) {
    PersonManager.getInstance(this).addPerson(person);
    personID=PersonManager.getInstance(this.getApplicationContext()).getPerson(person);
  }
  System.out.println(personID);
  person.setID(personID);
  String userID=UserManager.getInstance(this).getCurrent();
  System.out.println(userID + ""String_Node_Str"");
  if (userID != null) {
    System.out.println(userID + ""String_Node_Str"");
    measurement=new Measurement(getID(),userID,person.getID(),spnUnits.getSelectedItemPosition());
    SimpleDateFormat dateformat=new SimpleDateFormat(""String_Node_Str"");
    String dateText=""String_Node_Str"";
    try {
      Date date=new Date();
      dateText=dateformat.format(date);
      System.out.println(""String_Node_Str"" + dateText);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    measurement.setCreated(dateText);
    if (userID.equals(""String_Node_Str"")) {
      dialog(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      closer();
    }
  }
 else {
    System.out.println(""String_Node_Str"");
    Log.d(""String_Node_Str"",""String_Node_Str"");
    measurement=new Measurement(getID(),""String_Node_Str"",person.getID(),spnUnits.getSelectedItemPosition());
    SimpleDateFormat dateformat=new SimpleDateFormat(""String_Node_Str"");
    String dateText=""String_Node_Str"";
    try {
      Date date=new Date();
      dateText=dateformat.format(date);
      System.out.println(""String_Node_Str"" + dateText);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    measurement.setCreated(dateText);
    dialog(""String_Node_Str"",""String_Node_Str"");
  }
}","private void setMeasurement(String name,String email){
  person=new Person(email,name,spnGender.getSelectedItemPosition());
  int personID=PersonManager.getInstance(this.getApplicationContext()).getPerson(person);
  if (personID == -1) {
    PersonManager.getInstance(this).addPerson(person);
    personID=PersonManager.getInstance(this.getApplicationContext()).getPerson(person);
  }
  System.out.println(personID);
  person.setID(personID);
  String userID=UserManager.getInstance(this).getCurrent();
  System.out.println(userID + ""String_Node_Str"");
  if (userID != null) {
    System.out.println(userID + ""String_Node_Str"");
    measurement=new Measurement(getID(),userID,person.getID(),spnUnits.getSelectedItemPosition());
    SimpleDateFormat dateformat=new SimpleDateFormat(""String_Node_Str"");
    String dateText=""String_Node_Str"";
    try {
      Date date=new Date();
      dateText=dateformat.format(date);
      System.out.println(""String_Node_Str"" + dateText);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    measurement.setCreated(dateText);
    closer();
  }
 else {
    System.out.println(""String_Node_Str"");
    Log.d(""String_Node_Str"",""String_Node_Str"");
    measurement=new Measurement(getID(),""String_Node_Str"",person.getID(),spnUnits.getSelectedItemPosition());
    SimpleDateFormat dateformat=new SimpleDateFormat(""String_Node_Str"");
    String dateText=""String_Node_Str"";
    try {
      Date date=new Date();
      dateText=dateformat.format(date);
      System.out.println(""String_Node_Str"" + dateText);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    measurement.setCreated(dateText);
    closer();
  }
}",0.9474285714285714
112534,"@Override public Fragment getItem(int i){
switch (i) {
case RECEIVE:
case SEND:
case BALANCE:
    return getFragmentOrCreate(fm,account,i);
default :
  throw new RuntimeException(""String_Node_Str"" + i);
}
}","@Override public Fragment getItem(int i){
switch (i) {
case RECEIVE:
    if (request == null)     request=createFragment(account,i);
  return request;
case SEND:
if (send == null) send=createFragment(account,i);
return send;
case BALANCE:
if (balance == null) balance=createFragment(account,i);
return balance;
default :
throw new RuntimeException(""String_Node_Str"" + i);
}
}",0.5645438898450946
112535,"private static Fragment createFragment(WalletAccount account,int item){
  String accountId=account.getId();
switch (item) {
case RECEIVE:
    return AddressRequestFragment.newInstance(accountId);
case BALANCE:
  return BalanceFragment.newInstance(accountId);
case SEND:
return SendFragment.newInstance(accountId);
default :
throw new RuntimeException(""String_Node_Str"" + item);
}
}","@SuppressWarnings({""String_Node_Str""}) private static <T extends Fragment>T createFragment(WalletAccount account,int item){
  String accountId=account.getId();
switch (item) {
case RECEIVE:
    return (T)AddressRequestFragment.newInstance(accountId);
case BALANCE:
  return (T)BalanceFragment.newInstance(accountId);
case SEND:
return (T)SendFragment.newInstance(accountId);
default :
throw new RuntimeException(""String_Node_Str"" + item);
}
}",0.9258809234507898
112536,"@Override public void onViewStateRestored(@Nullable Bundle savedInstanceState){
  if (savedInstanceState != null) {
    currentScreen=savedInstanceState.getInt(ACCOUNT_CURRENT_SCREEN,BALANCE);
    updateView();
  }
  super.onViewStateRestored(savedInstanceState);
}","@Override public void onViewStateRestored(@Nullable Bundle savedInstanceState){
  if (savedInstanceState != null) {
    currentScreen=savedInstanceState.getInt(ACCOUNT_CURRENT_SCREEN,BALANCE);
  }
 else {
    currentScreen=BALANCE;
  }
  updateView();
  super.onViewStateRestored(savedInstanceState);
}",0.7548500881834215
112537,"public AppSectionsPagerAdapter(Context context,FragmentManager fm,WalletAccount account){
  super(fm);
  this.context=context;
  this.fm=fm;
  this.account=account;
}","public AppSectionsPagerAdapter(Context context,FragmentManager fm,WalletAccount account){
  super(fm);
  receiveTitle=context.getString(R.string.wallet_title_request);
  sendTitle=context.getString(R.string.wallet_title_send);
  balanceTitle=context.getString(R.string.wallet_title_balance);
  this.account=account;
}",0.505175983436853
112538,"@Override public void onCreate(@Nullable Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setHasOptionsMenu(true);
  setRetainInstance(true);
}","@Override public void onCreate(@Nullable Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setHasOptionsMenu(true);
  account=application.getAccount(getArguments().getString(Constants.ARG_ACCOUNT_ID));
}",0.741514360313316
112539,"public void setupArgs(String accountId){
  getArguments().putString(Constants.ARG_ACCOUNT_ID,accountId);
}","private void setupArgs(String accountId){
  getArguments().putString(Constants.ARG_ACCOUNT_ID,accountId);
}",0.9577464788732394
112540,"@Nullable private SendFragment getSendFragment(){
  return (SendFragment)getFragment(getFragmentManager(),SEND);
}","@Nullable private SendFragment getSendFragment(){
  return (SendFragment)getFragment(getChildFragmentManager(),SEND);
}",0.9785407725321889
112541,"@Override public CharSequence getPageTitle(int position){
switch (position) {
case RECEIVE:
    return context.getString(R.string.wallet_title_request);
case SEND:
  return context.getString(R.string.wallet_title_send);
case BALANCE:
default :
return context.getString(R.string.wallet_title_balance);
}
}","@Override public CharSequence getPageTitle(int i){
switch (i) {
case RECEIVE:
    return receiveTitle;
case SEND:
  return sendTitle;
case BALANCE:
return balanceTitle;
default :
throw new RuntimeException(""String_Node_Str"" + i);
}
}",0.547486033519553
112542,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View view=inflater.inflate(R.layout.fragment_account,container,false);
  ButterKnife.bind(this,view);
  mNavigationDrawerFragment=(NavigationDrawerFragment)getFragmentManager().findFragmentById(R.id.navigation_drawer);
  viewPager.setOffscreenPageLimit(OFF_SCREEN_LIMIT);
  viewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener(){
    @Override public void onPageScrolled(    int pos,    float posOffset,    int posOffsetPixels){
    }
    @Override public void onPageSelected(    int position){
      currentScreen=position;
      if (position == BALANCE)       Keyboard.hideKeyboard(getActivity());
      if (listener != null) {
switch (position) {
case RECEIVE:
          listener.onReceiveSelected();
        break;
case BALANCE:
      listener.onBalanceSelected();
    break;
case SEND:
  listener.onSendSelected();
break;
default :
throw new RuntimeException(""String_Node_Str"" + position);
}
}
}
@Override public void onPageScrollStateChanged(int state){
}
}
);
return view;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View view=inflater.inflate(R.layout.fragment_account,container,false);
  ButterKnife.bind(this,view);
  mNavigationDrawerFragment=(NavigationDrawerFragment)getFragmentManager().findFragmentById(R.id.navigation_drawer);
  viewPager.setOffscreenPageLimit(OFF_SCREEN_LIMIT);
  viewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener(){
    @Override public void onPageSelected(    int position){
      currentScreen=position;
      if (position == BALANCE)       Keyboard.hideKeyboard(getActivity());
      if (listener != null) {
switch (position) {
case RECEIVE:
          listener.onReceiveSelected();
        break;
case BALANCE:
      listener.onBalanceSelected();
    break;
case SEND:
  listener.onSendSelected();
break;
default :
throw new RuntimeException(""String_Node_Str"" + position);
}
}
}
@Override public void onPageScrolled(int pos,float posOffset,int posOffsetPixels){
}
@Override public void onPageScrollStateChanged(int state){
}
}
);
viewPager.setAdapter(new AppSectionsPagerAdapter(getActivity(),getChildFragmentManager(),account));
return view;
}",0.8734729493891797
112543,"@Nullable private static Fragment getFragment(FragmentManager fm,int item){
  for (  Fragment f : fm.getFragments()) {
switch (item) {
case RECEIVE:
      if (f instanceof AddressRequestFragment)       return f;
    break;
case BALANCE:
  if (f instanceof BalanceFragment)   return f;
break;
case SEND:
if (f instanceof SendFragment) return f;
break;
default :
throw new RuntimeException(""String_Node_Str"" + item);
}
}
return null;
}","@Nullable private static Fragment getFragment(FragmentManager fm,int item){
  if (fm.getFragments() == null)   return null;
  for (  Fragment f : fm.getFragments()) {
switch (item) {
case RECEIVE:
      if (f instanceof AddressRequestFragment)       return f;
    break;
case BALANCE:
  if (f instanceof BalanceFragment)   return f;
break;
case SEND:
if (f instanceof SendFragment) return f;
break;
default :
throw new RuntimeException(""String_Node_Str"" + item);
}
}
return null;
}",0.9474835886214442
112544,"@Override public void running(){
  if (isActivelyConnected()) {
    log.info(""String_Node_Str"",type.getName(),lastServerAddress);
    broadcastOnConnection();
    retrySeconds=0;
  }
}","@Override public void running(){
  if (isActivelyConnected()) {
    log.info(""String_Node_Str"",type.getName(),lastServerAddress);
    broadcastOnConnection();
    reschedule(connectionCheckTask,CONNECTION_STABILIZATION,TimeUnit.SECONDS);
  }
}",0.8056206088992974
112545,"@Override public void terminated(Service.State from){
  log.info(""String_Node_Str"",type.getName());
  broadcastOnDisconnect();
  failedAddresses.add(lastServerAddress);
  lastServerAddress=null;
  stratumClient=null;
  if (!stopped) {
    log.info(""String_Node_Str"",type.getName(),retrySeconds);
    connectionExec.remove(reconnectTask);
    if (retrySeconds > 0) {
      connectionExec.schedule(reconnectTask,retrySeconds,TimeUnit.SECONDS);
    }
 else {
      connectionExec.execute(reconnectTask);
    }
  }
}","@Override public void terminated(Service.State from){
  log.info(""String_Node_Str"",type.getName());
  broadcastOnDisconnect();
  failedAddresses.add(lastServerAddress);
  lastServerAddress=null;
  stratumClient=null;
  if (!stopped) {
    log.info(""String_Node_Str"",type.getName(),retrySeconds);
    connectionExec.remove(connectionCheckTask);
    connectionExec.remove(reconnectTask);
    if (retrySeconds > 0) {
      reconnectAt=System.currentTimeMillis() + retrySeconds * 1000;
      connectionExec.schedule(reconnectTask,retrySeconds,TimeUnit.SECONDS);
    }
 else {
      connectionExec.execute(reconnectTask);
    }
  }
}",0.8824561403508772
112546,"private ServerAddress getServerAddress(){
  if (failedAddresses.size() == addresses.size()) {
    failedAddresses.clear();
    retrySeconds=Math.min(Math.max(1,retrySeconds * 2),MAX_WAIT);
  }
  ServerAddress address;
  while (true) {
    address=addresses.get(RANDOM.nextInt(addresses.size()));
    if (!failedAddresses.contains(address))     break;
  }
  return address;
}","private ServerAddress getServerAddress(){
  if (failedAddresses.size() == addresses.size()) {
    failedAddresses.clear();
  }
  retrySeconds=Math.min(Math.max(1,retrySeconds * 2),MAX_WAIT);
  ServerAddress address;
  while (true) {
    address=addresses.get(RANDOM.nextInt(addresses.size()));
    if (!failedAddresses.contains(address))     break;
  }
  return address;
}",0.9919571045576407
112547,"@Override protected void onResume(){
  super.onResume();
  cameraThread=new HandlerThread(""String_Node_Str"",Process.THREAD_PRIORITY_BACKGROUND);
  cameraThread.start();
  cameraHandler=new Handler(cameraThread.getLooper());
  final SurfaceView surfaceView=(SurfaceView)findViewById(R.id.scan_activity_preview);
  surfaceHolder=surfaceView.getHolder();
  surfaceHolder.addCallback(this);
  surfaceHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
}","@Override protected void onResume(){
  super.onResume();
  cameraThread=new HandlerThread(""String_Node_Str"",Process.THREAD_PRIORITY_BACKGROUND);
  cameraThread.start();
  cameraHandler=new Handler(cameraThread.getLooper());
  final SurfaceView surfaceView=(SurfaceView)findViewById(R.id.scan_activity_preview);
  surfaceHolder=surfaceView.getHolder();
  surfaceHolder.addCallback(this);
  if (!hasCameraPermission()) {
    askCameraPermission();
  }
 else {
    openCamera();
  }
}",0.8406417112299466
112548,"@Override public void surfaceCreated(final SurfaceHolder holder){
  cameraHandler.post(openRunnable);
}","@Override public void surfaceCreated(final SurfaceHolder holder){
  isSurfaceCreated=true;
  openCamera();
}",0.7488151658767772
112549,"@Deprecated public AddCoinTask(Listener listener,CoinType type,Wallet wallet,@Nullable CharSequence password){
  this.listener=listener;
  this.type=type;
  this.wallet=wallet;
  this.password=password;
  description=null;
}","public AddCoinTask(Listener listener,CoinType type,Wallet wallet,@Nullable String description,@Nullable CharSequence password){
  this.listener=listener;
  this.type=type;
  this.wallet=wallet;
  this.description=description;
  this.password=password;
}",0.7337526205450734
112550,"@Override public void addCoin(String description,CharSequence password){
  if (selectedCoin != null && addCoinTask == null) {
    addCoinTask=new AddCoinTask(this,selectedCoin,wallet,description,password);
    addCoinTask.execute();
  }
}","@Override public void addCoin(CoinType type,String description,CharSequence password){
  if (type != null && addCoinTask == null) {
    addCoinTask=new AddCoinTask(this,type,wallet,description,password);
    addCoinTask.execute();
  }
}",0.9029535864978904
112551,"private void showAddCoinDialog(){
  Dialogs.dismissAllowingStateLoss(getFM(),ADD_COIN_DIALOG_TAG);
  ConfirmAddCoinUnlockWalletDialog.getInstance(selectedCoin.getName(),wallet.isEncrypted()).show(getFM(),ADD_COIN_DIALOG_TAG);
}","private void showAddCoinDialog(){
  Dialogs.dismissAllowingStateLoss(getFM(),ADD_COIN_DIALOG_TAG);
  ConfirmAddCoinUnlockWalletDialog.getInstance(selectedCoin,wallet.isEncrypted()).show(getFM(),ADD_COIN_DIALOG_TAG);
}",0.9774774774774776
112552,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_fragment_wrapper);
  containerRes=R.id.container;
  if (savedInstanceState == null) {
    getSupportFragmentManager().beginTransaction().add(containerRes,new TradeSelectFragment()).commit();
  }
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_fragment_wrapper);
  containerRes=R.id.container;
  if (savedInstanceState == null) {
    getSupportFragmentManager().beginTransaction().add(containerRes,new TradeSelectFragment(),TRADE_SELECT_FRAGMENT_TAG).commit();
  }
}",0.9622093023255814
112553,"@Override public void onClick(DialogInterface dialog,int which){
  String email=emailView.getText().toString();
}","@Override public void onClick(View v){
  String accountId=null;
  for (  WalletAccount account : accounts) {
    if (account.getTransaction(txId) != null) {
      accountId=account.getId();
      break;
    }
  }
  if (accountId != null && txId != null) {
    Intent intent=new Intent(getActivity(),TransactionDetailsActivity.class);
    intent.putExtra(Constants.ARG_ACCOUNT_ID,accountId);
    intent.putExtra(Constants.ARG_TRANSACTION_ID,txId);
    startActivity(intent);
  }
 else {
    if (Constants.COINS_BLOCK_EXPLORERS.containsKey(withdrawType)) {
      String url=String.format(Constants.COINS_BLOCK_EXPLORERS.get(withdrawType),txId);
      Intent i=new Intent(Intent.ACTION_VIEW);
      i.setData(Uri.parse(url));
      startActivity(i);
    }
 else {
      Toast.makeText(getActivity(),R.string.error_generic,Toast.LENGTH_SHORT).show();
    }
  }
}",0.0762100926879505
112554,"/** 
 * Get the description of the wallet. See   {@link WalletPocketHD#setDescription(String))}
 */
@Override public String getDescription(){
  if (description == null || description.trim().equals(""String_Node_Str"")) {
    return type.getName();
  }
 else {
    return description;
  }
}","/** 
 * Get the description of the wallet. See   {@link WalletPocketHD#setDescription(String))}
 */
@Override @Nullable public String getDescription(){
  return description;
}",0.7142857142857143
112555,"/** 
 * <p>Loads wallet data from the given protocol buffer and inserts it into the given Wallet object. This is primarily useful when you wish to pre-register extension objects. Note that if loading fails the provided Wallet object may be in an indeterminate state and should be thrown away.</p> <p>A wallet can be unreadable for various reasons, such as inability to open the file, corrupt data, internally inconsistent data, a wallet extension marked as mandatory that cannot be handled and so on. You should always handle   {@link UnreadableWalletException} and communicate failure to the user in an appropriate manner.</p>
 * @throws UnreadableWalletException thrown in various error conditions (see description).
 */
public static Wallet readWallet(Protos.Wallet walletProto) throws UnreadableWalletException {
  if (walletProto.getVersion() > 2)   throw new UnreadableWalletException.FutureVersion();
  if (walletProto.getVersion() < 2) {
    walletProto=updateV1toV2Proto(walletProto);
  }
  final KeyCrypter crypter=getKeyCrypter(walletProto);
  DeterministicSeed seed=null;
  if (walletProto.hasSeed()) {
    Protos.Key key=walletProto.getSeed();
    if (key.hasSecretBytes()) {
      List<String> mnemonic=Splitter.on(""String_Node_Str"").splitToList(key.getSecretBytes().toStringUtf8());
      seed=new DeterministicSeed(new byte[16],mnemonic,0);
    }
 else     if (key.hasEncryptedData()) {
      EncryptedData data=new EncryptedData(key.getEncryptedData().getInitialisationVector().toByteArray(),key.getEncryptedData().getEncryptedPrivateKey().toByteArray());
      seed=new DeterministicSeed(data,null,0);
    }
 else {
      throw new UnreadableWalletException(""String_Node_Str"" + key.toString());
    }
  }
  DeterministicKey masterKey=KeyUtils.getDeterministicKey(walletProto.getMasterKey(),null,crypter);
  Wallet wallet=new Wallet(masterKey,seed);
  if (walletProto.hasVersion()) {
    wallet.setVersion(walletProto.getVersion());
  }
  WalletPocketProtobufSerializer pocketSerializer=new WalletPocketProtobufSerializer();
  NxtFamilyWalletProtobufSerializer nxtPocketSerializer=new NxtFamilyWalletProtobufSerializer();
  for (  Protos.WalletPocket pocketProto : walletProto.getPocketsList()) {
    CoinType type=getType(pocketProto);
    AbstractWallet pocket;
    if (type instanceof BitFamily) {
      pocket=pocketSerializer.readWallet(pocketProto,crypter);
    }
 else     if (type instanceof NxtFamily) {
      pocket=nxtPocketSerializer.readWallet(pocketProto,crypter);
    }
 else {
      throw new UnreadableWalletException(""String_Node_Str"" + type);
    }
    wallet.addAccount(pocket);
  }
  if (wallet.getVersion() < 2) {
    updateV1toV2(wallet);
  }
  return wallet;
}","/** 
 * <p>Loads wallet data from the given protocol buffer and inserts it into the given Wallet object. This is primarily useful when you wish to pre-register extension objects. Note that if loading fails the provided Wallet object may be in an indeterminate state and should be thrown away.</p> <p>A wallet can be unreadable for various reasons, such as inability to open the file, corrupt data, internally inconsistent data, a wallet extension marked as mandatory that cannot be handled and so on. You should always handle   {@link UnreadableWalletException} and communicate failure to the user in an appropriate manner.</p>
 * @throws UnreadableWalletException thrown in various error conditions (see description).
 */
public static Wallet readWallet(Protos.Wallet walletProto) throws UnreadableWalletException {
  if (walletProto.getVersion() > 3)   throw new UnreadableWalletException.FutureVersion();
  walletProto=applyProtoUpdates(walletProto);
  final KeyCrypter crypter=getKeyCrypter(walletProto);
  DeterministicSeed seed=null;
  if (walletProto.hasSeed()) {
    Protos.Key key=walletProto.getSeed();
    if (key.hasSecretBytes()) {
      List<String> mnemonic=Splitter.on(""String_Node_Str"").splitToList(key.getSecretBytes().toStringUtf8());
      seed=new DeterministicSeed(new byte[16],mnemonic,0);
    }
 else     if (key.hasEncryptedData()) {
      EncryptedData data=new EncryptedData(key.getEncryptedData().getInitialisationVector().toByteArray(),key.getEncryptedData().getEncryptedPrivateKey().toByteArray());
      seed=new DeterministicSeed(data,null,0);
    }
 else {
      throw new UnreadableWalletException(""String_Node_Str"" + key.toString());
    }
  }
  DeterministicKey masterKey=KeyUtils.getDeterministicKey(walletProto.getMasterKey(),null,crypter);
  Wallet wallet=new Wallet(masterKey,seed);
  if (walletProto.hasVersion()) {
    wallet.setVersion(walletProto.getVersion());
  }
  WalletPocketProtobufSerializer pocketSerializer=new WalletPocketProtobufSerializer();
  NxtFamilyWalletProtobufSerializer nxtPocketSerializer=new NxtFamilyWalletProtobufSerializer();
  for (  Protos.WalletPocket pocketProto : walletProto.getPocketsList()) {
    CoinType type=getType(pocketProto);
    AbstractWallet pocket;
    if (type instanceof BitFamily) {
      pocket=pocketSerializer.readWallet(pocketProto,crypter);
    }
 else     if (type instanceof NxtFamily) {
      pocket=nxtPocketSerializer.readWallet(pocketProto,crypter);
    }
 else {
      throw new UnreadableWalletException(""String_Node_Str"" + type);
    }
    wallet.addAccount(pocket);
  }
  applyWalletUpdates(wallet);
  return wallet;
}",0.9630046948356809
112556,"@Override public Dialog onCreateDialog(final Bundle savedInstanceState){
  final Bundle args=getArguments();
  final WalletAccount account=checkNotNull(app.getAccount(args.getString(ARG_ACCOUNT_ID)));
  final LayoutInflater inflater=LayoutInflater.from(context);
  final DialogBuilder dialog=new DialogBuilder(context);
  final View view=inflater.inflate(R.layout.edit_account_dialog,null);
  final EditText descriptionView=ButterKnife.findById(view,R.id.edit_account_description);
  descriptionView.setText(account.getDescription());
  dialog.setTitle(R.string.edit_account_title);
  dialog.setView(view);
  final DialogInterface.OnClickListener onClickListener=new DialogInterface.OnClickListener(){
    @Override public void onClick(    final DialogInterface dialog,    final int which){
      if (which == DialogInterface.BUTTON_POSITIVE) {
        final String newDescription=descriptionView.getText().toString().trim();
        account.setDescription(newDescription);
        if (listener != null)         listener.onAccountModified(account);
      }
      dismiss();
    }
  }
;
  dialog.setPositiveButton(R.string.button_save,onClickListener);
  dialog.setNegativeButton(R.string.button_cancel,onClickListener);
  return dialog.create();
}","@Override public Dialog onCreateDialog(final Bundle savedInstanceState){
  final Bundle args=getArguments();
  final WalletAccount account=checkNotNull(app.getAccount(args.getString(ARG_ACCOUNT_ID)));
  final LayoutInflater inflater=LayoutInflater.from(context);
  final DialogBuilder dialog=new DialogBuilder(context);
  final View view=inflater.inflate(R.layout.edit_account_dialog,null);
  final EditText descriptionView=ButterKnife.findById(view,R.id.edit_account_description);
  descriptionView.setText(account.getDescription());
  descriptionView.setHint(account.getCoinType().getName());
  dialog.setTitle(R.string.edit_account_title);
  dialog.setView(view);
  final DialogInterface.OnClickListener onClickListener=new DialogInterface.OnClickListener(){
    @Override public void onClick(    final DialogInterface dialog,    final int which){
      if (which == DialogInterface.BUTTON_POSITIVE) {
        final String newDescription=descriptionView.getText().toString().trim();
        account.setDescription(newDescription);
        if (listener != null)         listener.onAccountModified(account);
      }
      dismiss();
    }
  }
;
  dialog.setPositiveButton(R.string.button_save,onClickListener);
  dialog.setNegativeButton(R.string.button_cancel,onClickListener);
  return dialog.create();
}",0.9765074393108848
112557,"private void bindView(View row,WalletAccount account){
  final ImageView icon=(ImageView)row.findViewById(R.id.account_icon);
  icon.setImageResource(Constants.COINS_ICONS.get(account.getCoinType()));
  final TextView rowLabel=(TextView)row.findViewById(R.id.account_description);
  rowLabel.setText(account.getDescription());
  final Amount rowValue=(Amount)row.findViewById(R.id.account_balance);
  rowValue.setAmount(GenericUtils.formatFiatValue(account.getBalance(),4,0));
  rowValue.setSymbol(account.getCoinType().getSymbol());
  ExchangeRatesProvider.ExchangeRate rate=rates.get(account.getCoinType().getSymbol());
  final Amount rowBalanceRateValue=(Amount)row.findViewById(R.id.account_balance_rate);
  if (rate != null && account.getCoinType() != null) {
    Value localAmount=rate.rate.convert(account.getBalance());
    GenericUtils.formatCoinValue(localAmount.type,localAmount,true);
    rowBalanceRateValue.setAmount(GenericUtils.formatFiatValue(localAmount,2,0));
    rowBalanceRateValue.setSymbol(localAmount.type.getSymbol());
    rowBalanceRateValue.setVisibility(View.VISIBLE);
  }
 else {
    rowBalanceRateValue.setVisibility(View.GONE);
  }
  final Amount rowRateValue=(Amount)row.findViewById(R.id.exchange_rate_row_rate);
  if (rate != null && account.getCoinType() != null) {
    Value localAmount=rate.rate.convert(account.getCoinType().oneCoin());
    GenericUtils.formatCoinValue(localAmount.type,localAmount,true);
    rowRateValue.setAmount(GenericUtils.formatFiatValue(localAmount,2,0));
    rowRateValue.setSymbol(localAmount.type.getSymbol());
    rowRateValue.setVisibility(View.VISIBLE);
  }
 else {
    rowRateValue.setVisibility(View.GONE);
  }
}","private void bindView(View row,WalletAccount account){
  final ImageView icon=(ImageView)row.findViewById(R.id.account_icon);
  icon.setImageResource(Constants.COINS_ICONS.get(account.getCoinType()));
  final TextView rowLabel=(TextView)row.findViewById(R.id.account_description);
  rowLabel.setText(account.getDescriptionOrCoinName());
  final Amount rowValue=(Amount)row.findViewById(R.id.account_balance);
  rowValue.setAmount(GenericUtils.formatFiatValue(account.getBalance(),4,0));
  rowValue.setSymbol(account.getCoinType().getSymbol());
  ExchangeRatesProvider.ExchangeRate rate=rates.get(account.getCoinType().getSymbol());
  final Amount rowBalanceRateValue=(Amount)row.findViewById(R.id.account_balance_rate);
  if (rate != null && account.getCoinType() != null) {
    Value localAmount=rate.rate.convert(account.getBalance());
    GenericUtils.formatCoinValue(localAmount.type,localAmount,true);
    rowBalanceRateValue.setAmount(GenericUtils.formatFiatValue(localAmount,2,0));
    rowBalanceRateValue.setSymbol(localAmount.type.getSymbol());
    rowBalanceRateValue.setVisibility(View.VISIBLE);
  }
 else {
    rowBalanceRateValue.setVisibility(View.GONE);
  }
  final Amount rowRateValue=(Amount)row.findViewById(R.id.exchange_rate_row_rate);
  if (rate != null && account.getCoinType() != null) {
    Value localAmount=rate.rate.convert(account.getCoinType().oneCoin());
    GenericUtils.formatCoinValue(localAmount.type,localAmount,true);
    rowRateValue.setAmount(GenericUtils.formatFiatValue(localAmount,2,0));
    rowRateValue.setSymbol(localAmount.type.getSymbol());
    rowRateValue.setVisibility(View.VISIBLE);
  }
 else {
    rowRateValue.setVisibility(View.GONE);
  }
}",0.9970379146919433
112558,"public void setAccount(WalletAccount account){
  this.type=account.getCoinType();
  title.setText(WalletUtils.getDescriptionOrCoinName(account));
  icon.setImageResource(WalletUtils.getIconRes(account));
}","public void setAccount(WalletAccount account){
  this.type=account.getCoinType();
  title.setText(account.getDescriptionOrCoinName());
  icon.setImageResource(WalletUtils.getIconRes(account));
}",0.9473684210526316
112559,"public ExchangeRateLoader(final Context context,final Configuration config,final String localSymbol){
  super(context,ExchangeRatesProvider.contentUriToCrypto(context.getPackageName(),localSymbol,false),null,null,new String[]{null},null);
  this.config=config;
  this.packageName=context.getPackageName();
  this.context=context;
}","public ExchangeRateLoader(final Context context,final Configuration config,final String localSymbol){
  super(context,ExchangeRatesProvider.contentUriToCrypto(context.getPackageName(),localSymbol,false),null,null,new String[]{null},null);
  this.config=config;
  this.packageName=context.getPackageName();
  this.context=context;
  this.localCurrency=localSymbol;
}",0.9511494252873564
112560,"@Override protected void onStartLoading(){
  super.onStartLoading();
  config.registerOnSharedPreferenceChangeListener(this);
  final IntentFilter intentFilter=new IntentFilter();
  intentFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
  intentFilter.addAction(Intent.ACTION_TIME_TICK);
  context.registerReceiver(broadcastReceiver,intentFilter);
  forceLoad();
}","@Override protected void onStartLoading(){
  super.onStartLoading();
  refreshUri(config.getExchangeCurrencyCode());
  config.registerOnSharedPreferenceChangeListener(this);
  final IntentFilter intentFilter=new IntentFilter();
  intentFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
  intentFilter.addAction(Intent.ACTION_TIME_TICK);
  context.registerReceiver(broadcastReceiver,intentFilter);
  forceLoad();
}",0.9396984924623116
112561,"private void onCurrencyChange(){
  final String localCurrency=config.getExchangeCurrencyCode();
  Uri newUri=ExchangeRatesProvider.contentUriToCrypto(packageName,localCurrency,false);
  setUri(newUri);
  forceLoad();
}","private void onCurrencyChange(){
  refreshUri(config.getExchangeCurrencyCode());
  forceLoad();
}",0.5650793650793651
112562,"@Override protected void onCreate(final Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_fragment_wrapper);
  if (savedInstanceState == null) {
    ExchangeRatesFragment fragment=new ExchangeRatesFragment();
    fragment.setArguments(getIntent().getExtras());
    getSupportFragmentManager().beginTransaction().add(R.id.container,fragment).commit();
  }
  getSupportActionBar().setDisplayHomeAsUpEnabled(true);
  getSupportActionBar().setDisplayShowHomeEnabled(false);
}","@Override protected void onCreate(final Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_fragment_wrapper);
  if (savedInstanceState == null) {
    ExchangeRatesFragment fragment=new ExchangeRatesFragment();
    fragment.setArguments(getIntent().getExtras());
    getSupportFragmentManager().beginTransaction().add(R.id.container,fragment).commit();
  }
  ActionBar actionBar=getSupportActionBar();
  if (actionBar != null) {
    actionBar.setDisplayHomeAsUpEnabled(true);
    actionBar.setDisplayShowHomeEnabled(false);
  }
}",0.9109090909090908
112563,"@Override public void onListItemClick(final ListView l,final View v,final int position,final long id){
  final Cursor cursor=(Cursor)adapter.getItem(position);
  final ExchangeRate exchangeRate=ExchangeRatesProvider.getExchangeRate(cursor);
  defaultCurrency=exchangeRate.currencyCodeId;
  config.setExchangeCurrencyCode(defaultCurrency);
  updateView();
  Toast.makeText(getActivity(),getString(R.string.set_local_currency,defaultCurrency),Toast.LENGTH_SHORT).show();
  getActivity().finish();
}","@Override public void onListItemClick(final ListView l,final View v,final int position,final long id){
  final Cursor cursor=(Cursor)adapter.getItem(position);
  final ExchangeRate exchangeRate=ExchangeRatesProvider.getExchangeRate(cursor);
  defaultCurrency=exchangeRate.currencyCodeId;
  config.setExchangeCurrencyCode(defaultCurrency);
  Toast.makeText(getActivity(),getString(R.string.set_local_currency,defaultCurrency),Toast.LENGTH_SHORT).show();
  getActivity().finish();
}",0.9836065573770492
112564,"@Override public void onDestroy(){
  loaderManager.destroyLoader(ID_TRANSACTION_LOADER);
  loaderManager.destroyLoader(ID_RATE_LOADER);
  super.onDestroy();
}","@Override public void onDestroy(){
  getLoaderManager().destroyLoader(ID_RATE_LOADER);
  super.onDestroy();
}",0.7865168539325843
112565,"public void updateView(){
  if (currentBalance != null) {
    String newBalanceStr=GenericUtils.formatFiatValue(currentBalance);
    mainAmount.setAmount(newBalanceStr);
    mainAmount.setSymbol(currentBalance.type.getSymbol());
  }
 else {
    mainAmount.setAmount(""String_Node_Str"");
    mainAmount.setSymbol(""String_Node_Str"");
  }
  exchangeRates=ExchangeRatesProvider.getRates(application.getApplicationContext(),config.getExchangeCurrencyCode());
  adapter.setExchangeRates(exchangeRates);
  adapter.notifyDataSetChanged();
}","public void updateView(){
  if (currentBalance != null) {
    String newBalanceStr=GenericUtils.formatFiatValue(currentBalance);
    mainAmount.setAmount(newBalanceStr);
    mainAmount.setSymbol(currentBalance.type.getSymbol());
  }
 else {
    mainAmount.setAmount(""String_Node_Str"");
    mainAmount.setSymbol(""String_Node_Str"");
  }
}",0.7750865051903114
112566,"@Override protected void weakHandleMessage(OverviewFragment ref,Message msg){
switch (msg.what) {
case WALLET_CHANGED:
    ref.updateWallet();
case UPDATE_VIEW:
  ref.updateView();
break;
}
}","@Override @SuppressWarnings(""String_Node_Str"") protected void weakHandleMessage(OverviewFragment ref,Message msg){
switch (msg.what) {
case WALLET_CHANGED:
    ref.updateWallet();
  break;
case SET_EXCHANGE_RATES:
ref.setExchangeRates((Map<String,ExchangeRate>)msg.obj);
break;
case UPDATE_VIEW:
ref.updateView();
break;
}
}",0.7339805825242719
112567,"@Override public void onAttach(final Context context){
  super.onAttach(context);
  try {
    listener=(Listener)context;
  }
 catch (  ClassCastException e) {
    throw new ClassCastException(context.toString() + ""String_Node_Str"" + Listener.class);
  }
  application=(WalletApplication)context.getApplicationContext();
  config=application.getConfiguration();
  loaderManager=getLoaderManager();
}","@Override public void onAttach(final Context context){
  super.onAttach(context);
  try {
    listener=(Listener)context;
  }
 catch (  ClassCastException e) {
    throw new ClassCastException(context.toString() + ""String_Node_Str"" + Listener.class);
  }
  application=(WalletApplication)context.getApplicationContext();
  config=application.getConfiguration();
}",0.952755905511811
112568,"public void updateWallet(){
  if (wallet != null) {
    adapter.replace(wallet);
    currentBalance=null;
    Map<String,ExchangeRate> rates=ExchangeRatesProvider.getRates(application,config.getExchangeCurrencyCode());
    for (    WalletAccount w : wallet.getAllAccounts()) {
      ExchangeRate rate=rates.get(w.getCoinType().getSymbol());
      if (rate == null) {
        log.info(""String_Node_Str"",w.getCoinType().getName());
        continue;
      }
      if (currentBalance != null) {
        currentBalance=currentBalance.add(rate.rate.convert(w.getBalance()));
      }
 else {
        currentBalance=rate.rate.convert(w.getBalance());
      }
    }
  }
}","public void updateWallet(){
  if (wallet != null) {
    adapter.replace(wallet);
    calculateNewBalance();
    updateView();
  }
}",0.3173803526448362
112569,"private void processAddress(String addressStr) throws CoinURIParseException, AddressMalformedException {
  List<CoinType> possibleTypes=GenericUtils.getPossibleTypes(addressStr);
  WalletAccount currentAccount=getAccount(lastAccountId);
  if (currentAccount != null && possibleTypes.contains(currentAccount.getCoinType())) {
    AbstractAddress address=currentAccount.getCoinType().newAddress(addressStr);
    processUri(CoinURI.convertToCoinURI(address,null,null,null));
  }
 else   if (possibleTypes.size() == 1) {
    AbstractAddress address=possibleTypes.get(0).newAddress(addressStr);
    processUri(CoinURI.convertToCoinURI(address,null,null,null));
  }
 else {
    List<WalletAccount> possibleAccounts=getAccounts(possibleTypes);
    AbstractAddress addressOfAccount=null;
    for (    WalletAccount account : possibleAccounts) {
      AbstractAddress testAddress=account.getCoinType().newAddress(addressStr);
      if (account.isAddressMine(testAddress)) {
        addressOfAccount=testAddress;
        break;
      }
    }
    if (addressOfAccount != null) {
      processUri(CoinURI.convertToCoinURI(addressOfAccount,null,null,null));
    }
 else {
      showPayToDialog(addressStr);
    }
  }
}","private void processAddress(String addressStr) throws CoinURIParseException, AddressMalformedException {
  List<CoinType> possibleTypes=GenericUtils.getPossibleTypes(addressStr);
  if (possibleTypes.size() == 1) {
    AbstractAddress address=possibleTypes.get(0).newAddress(addressStr);
    processUri(CoinURI.convertToCoinURI(address,null,null,null));
  }
 else {
    List<WalletAccount> possibleAccounts=getAccounts(possibleTypes);
    AbstractAddress addressOfAccount=null;
    for (    WalletAccount account : possibleAccounts) {
      AbstractAddress testAddress=account.getCoinType().newAddress(addressStr);
      if (account.isAddressMine(testAddress)) {
        addressOfAccount=testAddress;
        break;
      }
    }
    if (addressOfAccount != null) {
      processUri(CoinURI.convertToCoinURI(addressOfAccount,null,null,null));
    }
 else {
      showPayToDialog(addressStr);
    }
  }
}",0.4394874228761272
112570,"void setHeight(int height){
  this.height=height;
}","@Override public void setHeight(int height){
  this.height=height;
}",0.8571428571428571
112571,"public void setConfirmations(int confirmations){
  this.confirmations=confirmations;
}","@Override public void setConfirmations(int confirmations){
  this.confirmations=confirmations;
}",0.945054945054945
112572,"public Long getEcBlockId(){
  return Convert.parseLong(ecBlockId);
}","public Long getEcBlockId(){
  return Convert.parseUnsignedLong(ecBlockId);
}",0.9444444444444444
112573,"@VisibleForTesting void addNewTransactionIfNeeded(Transaction tx){
  lock.lock();
  try {
    log.info(""String_Node_Str"");
    if (getTransaction(tx.getFullHash()) == null) {
      log.info(""String_Node_Str"");
      rawtransactions.put(new Sha256Hash(tx.getFullHash()),tx);
      queueOnNewBalance();
    }
  }
  finally {
    lock.unlock();
  }
}","@VisibleForTesting void addNewTransactionIfNeeded(Transaction tx){
  lock.lock();
  try {
    log.info(""String_Node_Str"");
    Transaction storedTx=getTransaction(tx.getFullHash());
    if (storedTx == null) {
      log.info(""String_Node_Str"");
      rawtransactions.put(new Sha256Hash(tx.getFullHash()),tx);
      queueOnNewBalance();
    }
 else {
      storedTx.setConfirmations(tx.getConfirmations());
      if (storedTx.getHeight() == Integer.MAX_VALUE) {
        storedTx.setHeight(tx.getHeight());
      }
    }
  }
  finally {
    lock.unlock();
  }
}",0.7571743929359823
112574,"private void setupConnectivityStatus(){
  setConnectivityStatus(WalletPocketConnectivity.CONNECTED);
  new Handler().postDelayed(new Runnable(){
    @Override public void run(){
      if (pocket != null) {
        setConnectivityStatus(pocket.getConnectivityStatus());
      }
    }
  }
,2000);
}","private void setupConnectivityStatus(){
  setConnectivityStatus(WalletPocketConnectivity.CONNECTED);
  handler.postDelayed(new Runnable(){
    @Override public void run(){
      if (pocket != null) {
        setConnectivityStatus(pocket.getConnectivityStatus());
      }
    }
  }
,2000);
}",0.9658703071672357
112575,"void selectAccount(String accountId){
  selectAccount(application.getAccount(accountId));
}","public void selectAccount(String accountId,boolean closeDrawer){
  selectAccount(application.getAccount(accountId),closeDrawer);
}",0.8235294117647058
112576,"private void selectItem(int position,boolean closeDrawer){
  if (position < 0) {
    position=0;
  }
  mCurrentSelectedPosition=position;
  if (mDrawerListView != null) {
    mDrawerListView.setItemChecked(position,true);
  }
  if (closeDrawer) {
    closeDrawer();
  }
  if (mCallbacks != null && application.getWallet() != null) {
    WalletAccount item=application.getWallet().getAllAccounts().get(position);
    mCallbacks.onAccountSelected(item);
  }
}","private void selectItem(int position,boolean closeDrawer,boolean enableCallbacks){
  if (position < 0) {
    position=0;
  }
  mCurrentSelectedPosition=position;
  if (mDrawerListView != null) {
    mDrawerListView.setItemChecked(position,true);
  }
  if (closeDrawer) {
    closeDrawer();
  }
  if (enableCallbacks && mCallbacks != null && application.getWallet() != null) {
    WalletAccount item=application.getWallet().getAllAccounts().get(position);
    mCallbacks.onAccountSelected(item);
  }
}",0.955067920585162
112577,"void notifyDataSetChanged(){
  ((NavDrawerListAdapter)mDrawerListView.getAdapter()).notifyDataSetChanged();
}","public void notifyDataSetChanged(){
  ((NavDrawerListAdapter)mDrawerListView.getAdapter()).notifyDataSetChanged();
}",0.9688888888888888
112578,"@Override public void onActivityResult(final int requestCode,final int resultCode,final Intent intent){
  super.onActivityResult(requestCode,resultCode,intent);
  if (requestCode == REQUEST_CODE_SCAN) {
    if (resultCode == Activity.RESULT_OK) {
      final String input=intent.getStringExtra(ScanActivity.INTENT_EXTRA_RESULT);
      try {
        final CoinURI coinUri=new CoinURI(input);
        CoinType scannedType=coinUri.getType();
        if (!Constants.SUPPORTED_COINS.contains(scannedType)) {
          String error=getResources().getString(R.string.unsupported_coin,scannedType.getName());
          throw new CoinURIParseException(error);
        }
 else         if (!getWalletApplication().isAccountExists(scannedType)) {
          String error=getResources().getString(R.string.coin_not_added,scannedType.getName());
          throw new CoinURIParseException(error);
        }
        setSendFromCoin(coinUri);
      }
 catch (      final CoinURIParseException e) {
        String error=getResources().getString(R.string.uri_error,e.getMessage());
        Toast.makeText(this,error,Toast.LENGTH_LONG).show();
      }
    }
  }
 else   if (requestCode == ADD_COIN) {
    if (resultCode == Activity.RESULT_OK) {
      String accountId=intent.getStringExtra(Constants.ARG_ACCOUNT_ID);
      mNavigationDrawerFragment.notifyDataSetChanged();
      mNavigationDrawerFragment.selectAccount(accountId);
    }
  }
}","@Override public void onActivityResult(final int requestCode,final int resultCode,final Intent intent){
  super.onActivityResult(requestCode,resultCode,intent);
  handler.post(new Runnable(){
    @Override public void run(){
      if (requestCode == REQUEST_CODE_SCAN) {
        if (resultCode == Activity.RESULT_OK) {
          final String input=intent.getStringExtra(ScanActivity.INTENT_EXTRA_RESULT);
          try {
            final CoinURI coinUri=new CoinURI(input);
            CoinType scannedType=coinUri.getType();
            if (!Constants.SUPPORTED_COINS.contains(scannedType)) {
              String error=getResources().getString(R.string.unsupported_coin,scannedType.getName());
              throw new CoinURIParseException(error);
            }
 else             if (!getWalletApplication().isAccountExists(scannedType)) {
              String error=getResources().getString(R.string.coin_not_added,scannedType.getName());
              throw new CoinURIParseException(error);
            }
            setSendFromCoin(coinUri);
          }
 catch (          final CoinURIParseException e) {
            String error=getResources().getString(R.string.uri_error,e.getMessage());
            Toast.makeText(WalletActivity.this,error,Toast.LENGTH_LONG).show();
          }
        }
      }
 else       if (requestCode == ADD_COIN) {
        if (resultCode == Activity.RESULT_OK) {
          final String accountId=intent.getStringExtra(Constants.ARG_ACCOUNT_ID);
          mNavigationDrawerFragment.notifyDataSetChanged();
          openPocket(accountId);
        }
      }
    }
  }
);
}",0.9137760158572844
112579,"private void openPocket(WalletAccount account){
  if (mViewPager != null && !account.getId().equals(currentAccountId)) {
    currentAccountId=account.getId();
    CoinType type=account.getCoinType();
    mTitle=type.getName();
    coinIconRes=Constants.COINS_ICONS.get(type);
    AppSectionsPagerAdapter adapter=new AppSectionsPagerAdapter(this,account);
    mViewPager.setAdapter(adapter);
    mViewPager.setCurrentItem(BALANCE);
    mViewPager.getAdapter().notifyDataSetChanged();
    getWalletApplication().getConfiguration().touchLastAccountId(currentAccountId);
    connectCoinService();
  }
}","private void openPocket(WalletAccount account,boolean selectInNavDrawer){
  if (account != null && mViewPager != null && !account.getId().equals(currentAccountId)) {
    currentAccountId=account.getId();
    CoinType type=account.getCoinType();
    mTitle=type.getName();
    coinIconRes=Constants.COINS_ICONS.get(type);
    AppSectionsPagerAdapter adapter=new AppSectionsPagerAdapter(this,account);
    mViewPager.setAdapter(adapter);
    mViewPager.setCurrentItem(BALANCE);
    mViewPager.getAdapter().notifyDataSetChanged();
    getWalletApplication().getConfiguration().touchLastAccountId(currentAccountId);
    connectCoinService();
    if (selectInNavDrawer && mNavigationDrawerFragment != null) {
      mNavigationDrawerFragment.selectAccount(account);
    }
  }
}",0.8736303871439006
112580,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_wallet);
  if (getWalletApplication().getWallet() == null) {
    startIntro();
    finish();
    return;
  }
  if (getIntent().getBooleanExtra(Constants.ARG_TEST_WALLET,false)) {
    new AlertDialog.Builder(this).setTitle(R.string.test_wallet).setMessage(R.string.test_wallet_message).setNeutralButton(R.string.button_ok,null).create().show();
  }
  if (savedInstanceState == null) {
    checkAlerts();
  }
  mTitle=getTitle();
  getSupportActionBar().setElevation(0);
  mNavigationDrawerFragment=(NavigationDrawerFragment)getSupportFragmentManager().findFragmentById(R.id.navigation_drawer);
  mNavigationDrawerFragment.setUp(R.id.navigation_drawer,(DrawerLayout)findViewById(R.id.drawer_layout));
  mViewPager=(ViewPager)findViewById(R.id.pager);
  mViewPager.setOffscreenPageLimit(2);
  mViewPager.setOnPageChangeListener(new ViewPager.OnPageChangeListener(){
    @Override public void onPageScrolled(    int pos,    float posOffset,    int posOffsetPixels){
    }
    @Override public void onPageSelected(    int position){
      if (position == BALANCE)       Keyboard.hideKeyboard(WalletActivity.this);
    }
    @Override public void onPageScrollStateChanged(    int state){
    }
  }
);
  String lastAccountId=getWalletApplication().getConfiguration().getLastAccountId();
  mNavigationDrawerFragment.selectAccountInit(lastAccountId);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_wallet);
  wallet=getWallet();
  if (getWalletApplication().getWallet() == null) {
    startIntro();
    finish();
    return;
  }
  if (getIntent().getBooleanExtra(Constants.ARG_TEST_WALLET,false)) {
    new AlertDialog.Builder(this).setTitle(R.string.test_wallet).setMessage(R.string.test_wallet_message).setNeutralButton(R.string.button_ok,null).create().show();
  }
  if (savedInstanceState == null) {
    checkAlerts();
  }
  mTitle=getTitle();
  getSupportActionBar().setElevation(0);
  mNavigationDrawerFragment=(NavigationDrawerFragment)getSupportFragmentManager().findFragmentById(R.id.navigation_drawer);
  mNavigationDrawerFragment.setUp(R.id.navigation_drawer,(DrawerLayout)findViewById(R.id.drawer_layout));
  mViewPager=(ViewPager)findViewById(R.id.pager);
  mViewPager.setOffscreenPageLimit(2);
  mViewPager.setOnPageChangeListener(new ViewPager.OnPageChangeListener(){
    @Override public void onPageScrolled(    int pos,    float posOffset,    int posOffsetPixels){
    }
    @Override public void onPageSelected(    int position){
      if (position == BALANCE)       Keyboard.hideKeyboard(WalletActivity.this);
    }
    @Override public void onPageScrollStateChanged(    int state){
    }
  }
);
  WalletAccount lastAccount=getAccount(getWalletApplication().getConfiguration().getLastAccountId());
  if (lastAccount != null) {
    mNavigationDrawerFragment.selectAccount(lastAccount,false);
    openPocket(lastAccount,false);
  }
}",0.9050570962479608
112581,"@Override public void onAccountSelected(WalletAccount account){
  log.info(""String_Node_Str"",account.getId());
  openPocket(account);
}","@Override public void onAccountSelected(WalletAccount account){
  log.info(""String_Node_Str"",account.getId());
  openPocket(account,false);
}",0.9782608695652174
112582,"private void setSendFromCoin(CoinURI coinUri) throws CoinURIParseException {
  List<WalletAccount> accounts=getAccounts(coinUri.getType());
  if (mViewPager != null && mNavigationDrawerFragment != null && accounts.size() > 0) {
    WalletAccount account;
    if (accounts.size() > 1) {
      Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
    }
    account=accounts.get(0);
    mNavigationDrawerFragment.selectAccount(account);
    mViewPager.setCurrentItem(SEND);
    for (    Fragment fragment : getSupportFragmentManager().getFragments()) {
      if (fragment instanceof SendFragment) {
        ((SendFragment)fragment).updateStateFrom(coinUri.getAddress(),coinUri.getAmount(),coinUri.getLabel());
        break;
      }
    }
  }
}","private void setSendFromCoin(final CoinURI coinUri) throws CoinURIParseException {
  List<WalletAccount> accounts=getAccounts(coinUri.getType());
  if (mViewPager != null && mNavigationDrawerFragment != null && accounts.size() > 0) {
    final WalletAccount account;
    if (accounts.size() > 1) {
      Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
    }
    account=accounts.get(0);
    openPocket(account);
    mViewPager.setCurrentItem(SEND);
    for (    Fragment fragment : getSupportFragmentManager().getFragments()) {
      if (fragment instanceof SendFragment) {
        ((SendFragment)fragment).updateStateFrom(coinUri.getAddress(),coinUri.getAmount(),coinUri.getLabel());
        break;
      }
    }
  }
}",0.960429242119383
112583,"public void onMakeTransaction(Address toAddress,Coin amount){
  Intent intent=new Intent(getActivity(),SignTransactionActivity.class);
  try {
    if (pocket == null) {
      throw new NoSuchPocketException(""String_Node_Str"" + type.getName());
    }
    intent.putExtra(Constants.ARG_ACCOUNT_ID,type.getId());
    intent.putExtra(Constants.ARG_SEND_TO_ADDRESS,toAddress.toString());
    intent.putExtra(Constants.ARG_SEND_AMOUNT,amount.getValue());
    startActivityForResult(intent,SIGN_TRANSACTION);
  }
 catch (  NoSuchPocketException e) {
    Toast.makeText(getActivity(),R.string.no_such_pocket_error,Toast.LENGTH_LONG).show();
  }
}","public void onMakeTransaction(Address toAddress,Coin amount){
  Intent intent=new Intent(getActivity(),SignTransactionActivity.class);
  try {
    if (pocket == null) {
      throw new NoSuchPocketException(""String_Node_Str"" + type.getName());
    }
    intent.putExtra(Constants.ARG_ACCOUNT_ID,pocket.getId());
    intent.putExtra(Constants.ARG_SEND_TO_ADDRESS,toAddress.toString());
    intent.putExtra(Constants.ARG_SEND_AMOUNT,amount.getValue());
    startActivityForResult(intent,SIGN_TRANSACTION);
  }
 catch (  NoSuchPocketException e) {
    Toast.makeText(getActivity(),R.string.no_such_pocket_error,Toast.LENGTH_LONG).show();
  }
}",0.9921752738654148
112584,"@Override protected Exception doInBackground(Void... params){
  Wallet wallet=application.getWallet();
  if (wallet == null)   return new NoSuchPocketException(""String_Node_Str"");
  Exception error=null;
  try {
    if (wallet.isEncrypted()) {
      KeyCrypter crypter=checkNotNull(wallet.getKeyCrypter());
      request.aesKey=crypter.deriveKey(password);
    }
    request.signInputs=true;
    pocket.completeTx(request);
    pocket.broadcastTx(request.tx);
  }
 catch (  Exception e) {
    error=e;
  }
  return error;
}","@Override protected Exception doInBackground(Void... params){
  Wallet wallet=application.getWallet();
  if (wallet == null)   return new NoSuchPocketException(""String_Node_Str"");
  Exception error=null;
  try {
    if (wallet.isEncrypted()) {
      KeyCrypter crypter=checkNotNull(wallet.getKeyCrypter());
      request.aesKey=crypter.deriveKey(password);
    }
    request.signInputs=true;
    pocket.completeAndSignTx(request);
    pocket.broadcastTx(request.tx);
  }
 catch (  Exception e) {
    error=e;
  }
  return error;
}",0.99335232668566
112585,"private View.OnClickListener getOnNextListener(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      verifyMnemonic();
    }
  }
;
}","private View.OnClickListener getOnNextListener(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      verifyMnemonicAndProceed();
    }
  }
;
}",0.9715909090909092
112586,"@Override public void onActivityResult(final int requestCode,final int resultCode,final Intent intent){
  if (requestCode == REQUEST_CODE_SCAN) {
    if (resultCode == Activity.RESULT_OK) {
      mnemonicTextView.setText(intent.getStringExtra(ScanActivity.INTENT_EXTRA_RESULT));
    }
  }
}","@Override public void onActivityResult(final int requestCode,final int resultCode,final Intent intent){
  if (requestCode == REQUEST_CODE_SCAN) {
    if (resultCode == Activity.RESULT_OK) {
      mnemonicTextView.setText(intent.getStringExtra(ScanActivity.INTENT_EXTRA_RESULT));
      verifyMnemonic();
    }
  }
}",0.9602649006622516
112587,"private View.OnClickListener getOnSkipListener(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      log.info(""String_Node_Str"");
      mnemonicTextView.setText(""String_Node_Str"");
      verifyMnemonic(seed,true);
    }
  }
;
}","private View.OnClickListener getOnSkipListener(){
  return new View.OnClickListener(){
    @Override public void onClick(    View v){
      log.info(""String_Node_Str"");
      mnemonicTextView.setText(""String_Node_Str"");
      verifyMnemonicAndProceed(seed,true);
    }
  }
;
}",0.981549815498155
112588,"private void clearError(){
  if (errorΜessage.isShown())   errorΜessage.setVisibility(View.GONE);
}","private void clearError(){
  if (errorΜessage.getVisibility() == View.VISIBLE) {
    errorΜessage.setVisibility(View.GONE);
  }
}",0.8245614035087719
112589,"private void verifyMnemonic(String seedText,boolean skipSeedEntry){
  log.info(""String_Node_Str"");
  ArrayList<String> seedWords=new ArrayList<String>();
  for (  String word : seedText.trim().split(""String_Node_Str"")) {
    if (word.isEmpty())     continue;
    seedWords.add(word);
  }
  boolean isValid=false;
  try {
    MnemonicCode.INSTANCE.check(seedWords);
    clearError();
    isValid=true;
  }
 catch (  MnemonicException.MnemonicChecksumException e) {
    log.info(""String_Node_Str"",e.getMessage());
    setError(R.string.restore_error_checksum);
  }
catch (  MnemonicException.MnemonicWordException e) {
    log.info(""String_Node_Str"",e.getMessage());
    setError(R.string.restore_error_words);
  }
catch (  MnemonicException e) {
    log.info(""String_Node_Str"",e.getMessage());
    setError(R.string.restore_error,e.getMessage());
  }
  if (seed != null && !seedText.trim().equals(seed.trim())) {
    log.info(""String_Node_Str"");
    setError(R.string.restore_error_mismatch);
    isValid=false;
  }
  if (isValid && skipSeedEntry) {
    SkipDialogFragment skipDialog=SkipDialogFragment.newInstance(seedText);
    skipDialog.show(getFragmentManager(),null);
  }
 else   if (isValid && isNewSeed) {
    if (mListener != null)     mListener.onNewSeedVerified(seedText);
  }
 else   if (isValid) {
    if (mListener != null)     mListener.onExistingSeedVerified(seedText,isSeedProtected);
  }
}","private boolean verifyMnemonic(String seedText){
  log.info(""String_Node_Str"");
  ArrayList<String> seedWords=new ArrayList<String>();
  for (  String word : seedText.trim().split(""String_Node_Str"")) {
    if (word.isEmpty())     continue;
    seedWords.add(word);
  }
  boolean isValid=false;
  try {
    MnemonicCode.INSTANCE.check(seedWords);
    clearError();
    isValid=true;
  }
 catch (  MnemonicException.MnemonicChecksumException e) {
    log.info(""String_Node_Str"",e.getMessage());
    setError(R.string.restore_error_checksum);
  }
catch (  MnemonicException.MnemonicWordException e) {
    log.info(""String_Node_Str"",e.getMessage());
    setError(R.string.restore_error_words);
  }
catch (  MnemonicException e) {
    log.info(""String_Node_Str"",e.getMessage());
    setError(R.string.restore_error,e.getMessage());
  }
  if (seed != null && !seedText.trim().equals(seed.trim())) {
    log.info(""String_Node_Str"");
    setError(R.string.restore_error_mismatch);
    isValid=false;
  }
  return isValid;
}",0.8252788104089219
112590,"/** 
 * <p> Disables auto-saving, after it had been enabled with  {@link Wallet#autosaveToFile(java.io.File,long,java.util.concurrent.TimeUnit,com.coinomi.core.wallet.WalletFiles.Listener)}before. This method blocks until finished. </p>
 */
public void shutdownAutosaveAndWait(){
  lock.lock();
  try {
    WalletFiles files=vFileManager;
    vFileManager=null;
    checkState(files != null,""String_Node_Str"");
    files.shutdownAndWait();
  }
  finally {
    lock.unlock();
  }
}","/** 
 * <p> Disables auto-saving, after it had been enabled with  {@link Wallet#autosaveToFile(java.io.File,long,java.util.concurrent.TimeUnit,com.coinomi.core.wallet.WalletFiles.Listener)}before. This method blocks until finished. </p>
 */
public void shutdownAutosaveAndWait(){
  lock.lock();
  try {
    WalletFiles files=vFileManager;
    vFileManager=null;
    if (files != null) {
      files.shutdownAndWait();
    }
  }
  finally {
    lock.unlock();
  }
}",0.8389830508474576
112591,"private void updateAppearance(){
  if (type != null) {
    symbol.setText(type.getSymbol());
    symbol.setVisibility(VISIBLE);
  }
 else   if (localCurrencyCode != null) {
    symbol.setText(localCurrencyCode);
    symbol.setVisibility(VISIBLE);
  }
 else {
    symbol.setText(null);
    symbol.setVisibility(GONE);
  }
  final Spannable hintSpannable=new MonetarySpannable(hintFormat,hint != null ? hint : Coin.ZERO);
  textView.setHint(hintSpannable);
}","private void updateAppearance(){
  if (type != null) {
    symbol.setText(type.getSymbol());
    symbol.setVisibility(VISIBLE);
  }
 else   if (localCurrencyCode != null) {
    symbol.setText(localCurrencyCode);
    symbol.setVisibility(VISIBLE);
  }
 else {
    symbol.setText(null);
    symbol.setVisibility(GONE);
  }
  final Spannable hintSpannable=new MonetarySpannable(hintFormat,amountSigned,hint != null ? hint : Coin.ZERO,type);
  textView.setHint(hintSpannable);
}",0.9806451612903224
112592,"private void selectItem(int position){
  if (position < 0) {
    position=0;
  }
  mCurrentSelectedPosition=position;
  if (mDrawerListView != null) {
    mDrawerListView.setItemChecked(position,true);
  }
  if (mDrawerLayout != null) {
    mDrawerLayout.closeDrawer(mFragmentContainerView);
  }
  if (mCallbacks != null && application.getWallet() != null) {
    mCallbacks.onNavigationDrawerCoinSelected(application.getWallet().getCoinTypes().get(position));
  }
}","private void selectItem(int position,boolean closeDrawer){
  if (position < 0) {
    position=0;
  }
  mCurrentSelectedPosition=position;
  if (mDrawerListView != null) {
    mDrawerListView.setItemChecked(position,true);
  }
  if (mDrawerLayout != null && closeDrawer) {
    mDrawerLayout.closeDrawer(mFragmentContainerView);
  }
  if (mCallbacks != null && application.getWallet() != null) {
    mCallbacks.onNavigationDrawerCoinSelected(application.getWallet().getCoinTypes().get(position));
  }
}",0.9637305699481864
112593,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_wallet);
  if (getWalletApplication().getWallet() == null) {
    startIntro();
    finish();
    return;
  }
  mTitle=getTitle();
  mNavigationDrawerFragment=(NavigationDrawerFragment)getSupportFragmentManager().findFragmentById(R.id.navigation_drawer);
  mNavigationDrawerFragment.setUp(R.id.navigation_drawer,(DrawerLayout)findViewById(R.id.drawer_layout));
  mViewPager=(ViewPager)findViewById(R.id.pager);
  mViewPager.setOffscreenPageLimit(2);
  CoinType lastPocket=getWalletApplication().getConfiguration().getLastPocket();
  mNavigationDrawerFragment.selectItem(lastPocket);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_wallet);
  if (getWalletApplication().getWallet() == null) {
    startIntro();
    finish();
    return;
  }
  mTitle=getTitle();
  mNavigationDrawerFragment=(NavigationDrawerFragment)getSupportFragmentManager().findFragmentById(R.id.navigation_drawer);
  mNavigationDrawerFragment.setUp(R.id.navigation_drawer,(DrawerLayout)findViewById(R.id.drawer_layout));
  mViewPager=(ViewPager)findViewById(R.id.pager);
  mViewPager.setOffscreenPageLimit(2);
  CoinType lastPocket=getWalletApplication().getConfiguration().getLastPocket();
  mNavigationDrawerFragment.selectCoinInit(lastPocket);
}",0.9930555555555556
112594,"@Override public void running(){
  if (stratumClient != null && stratumClient.isConnected()) {
    log.info(""String_Node_Str"",type.getName(),lastServerAddress);
    broadcastOnConnection();
    retrySeconds=1;
  }
}","@Override public void running(){
  if (isConnected()) {
    log.info(""String_Node_Str"",type.getName(),lastServerAddress);
    broadcastOnConnection();
    retrySeconds=1;
  }
}",0.9002557544757033
112595,"/** 
 * Removes the given event listener object. Returns true if the listener was removed, false if that listener was never added.
 */
public boolean removeEventListener(ConnectionEventListener listener){
  return ListenerRegistration.removeFromList(listener,eventListeners);
}","/** 
 * Removes the given event listener object. Returns true if the listener was removed, false if that listener was never added.
 */
private boolean removeEventListener(ConnectionEventListener listener){
  return ListenerRegistration.removeFromList(listener,eventListeners);
}",0.9801801801801802
112596,"/** 
 * Adds an event listener object. Methods on this object are called when something interesting happens, like new connection to a server. The listener is executed by the given executor.
 */
public void addEventListener(ConnectionEventListener listener,Executor executor){
  eventListeners.add(new ListenerRegistration<ConnectionEventListener>(listener,executor));
}","/** 
 * Adds an event listener object. Methods on this object are called when something interesting happens, like new connection to a server. The listener is executed by the given executor.
 */
private void addEventListener(ConnectionEventListener listener,Executor executor){
  eventListeners.add(new ListenerRegistration<ConnectionEventListener>(listener,executor));
}",0.9851150202976996
112597,"public ServerClients(List<CoinAddress> coins,Wallet wallet){
  connections=new HashMap<CoinType,ServerClient>(coins.size());
  for (  CoinAddress coinAddress : coins) {
    ServerClient client=new ServerClient(coinAddress);
    client.addEventListener(wallet.getPocket(coinAddress.getType()));
    connections.put(coinAddress.getType(),client);
  }
}","public ServerClients(List<CoinAddress> coins,Wallet wallet){
  connections=new HashMap<CoinType,ServerClient>(coins.size());
  for (  CoinAddress coinAddress : coins) {
    ServerClient client=new ServerClient(coinAddress);
    connections.put(coinAddress.getType(),client);
  }
  setWallet(wallet);
}",0.7680491551459293
112598,"public void refresh(){
  lock.lock();
  try {
    for (    WalletPocket pocket : getPockets()) {
      pocket.refresh();
    }
    saveNow();
  }
  finally {
    lock.unlock();
  }
}","public void refresh(){
  lock.lock();
  try {
    for (    WalletPocket pocket : getPockets()) {
      pocket.refresh();
    }
    saveLater();
  }
  finally {
    lock.unlock();
  }
}",0.9781420765027322
112599,"private void connectTransaction(Transaction tx){
  checkState(lock.isHeldByCurrentThread());
  if (tx.getConfidence().getConfidenceType() != ConfidenceType.BUILDING)   return;
  if (log.isInfoEnabled())   log.info(""String_Node_Str"",tx.getHash());
  for (  TransactionInput txi : tx.getInputs()) {
    if (txi.getConnectedOutput() != null)     continue;
    Sha256Hash outputHash=txi.getOutpoint().getHash();
    Transaction fromTx=transactions.get(outputHash);
    if (fromTx != null) {
      for (int i=2; i > 0; i--) {
        ConnectionResult result=txi.connect(fromTx,ConnectMode.DISCONNECT_ON_CONFLICT);
        if (result == ConnectionResult.NO_SUCH_TX) {
          log.error(""String_Node_Str"",txi.getOutpoint(),fromTx.getHash());
        }
 else         if (result == ConnectionResult.ALREADY_SPENT) {
          TransactionOutput out=fromTx.getOutput((int)txi.getOutpoint().getIndex());
          log.warn(""String_Node_Str"",out);
          out.markAsUnspent();
        }
 else {
          log.info(""String_Node_Str"",fromTx.getHash(),txi.getOutpoint().getIndex());
          break;
        }
      }
      maybeMovePool(fromTx);
    }
 else {
      log.warn(""String_Node_Str"",txi.getParentTransaction().getHash(),txi.getOutpoint().getIndex());
    }
  }
  maybeMovePool(tx);
}","private void connectTransaction(Transaction tx){
  checkState(lock.isHeldByCurrentThread());
  if (tx.getConfidence().getConfidenceType() != ConfidenceType.BUILDING)   return;
  if (log.isInfoEnabled())   log.info(""String_Node_Str"",tx.getHash());
  for (  TransactionInput txi : tx.getInputs()) {
    if (txi.getConnectedOutput() != null)     continue;
    Sha256Hash outputHash=txi.getOutpoint().getHash();
    Transaction fromTx=transactions.get(outputHash);
    if (fromTx != null) {
      for (int i=2; i > 0; i--) {
        ConnectionResult result=txi.connect(fromTx,ConnectMode.DISCONNECT_ON_CONFLICT);
        if (result == ConnectionResult.NO_SUCH_TX) {
          log.error(""String_Node_Str"",txi.getOutpoint(),fromTx.getHash());
        }
 else         if (result == ConnectionResult.ALREADY_SPENT) {
          TransactionOutput out=fromTx.getOutput((int)txi.getOutpoint().getIndex());
          log.warn(""String_Node_Str"",out);
          out.markAsUnspent();
        }
 else {
          log.info(""String_Node_Str"",fromTx.getHash(),txi.getOutpoint().getIndex());
          break;
        }
      }
      maybeMovePool(fromTx);
    }
 else {
      log.info(""String_Node_Str"",txi.getParentTransaction().getHash(),txi.getOutpoint().getIndex());
    }
  }
  maybeMovePool(tx);
}",0.9968798751950078
112600,"public DarkcoinMain(){
  id=""String_Node_Str"";
  addressHeader=76;
  p2shHeader=5;
  acceptableAddressCodes=new int[]{addressHeader,p2shHeader};
  name=""String_Node_Str"";
  symbol=""String_Node_Str"";
  uriScheme=""String_Node_Str"";
  bip44Index=5;
}","public DarkcoinMain(){
  id=""String_Node_Str"";
  addressHeader=76;
  p2shHeader=5;
  acceptableAddressCodes=new int[]{addressHeader,p2shHeader};
  name=""String_Node_Str"";
  symbol=""String_Node_Str"";
  uriScheme=""String_Node_Str"";
  bip44Index=10;
  throw new RuntimeException(name + ""String_Node_Str"" + bip44Index+ ""String_Node_Str"");
}",0.8439108061749572
112601,"public PeercoinMain(){
  id=""String_Node_Str"";
  addressHeader=55;
  p2shHeader=117;
  acceptableAddressCodes=new int[]{addressHeader,p2shHeader};
  name=""String_Node_Str"";
  symbol=""String_Node_Str"";
  uriScheme=""String_Node_Str"";
  bip44Index=4;
}","public PeercoinMain(){
  id=""String_Node_Str"";
  addressHeader=55;
  p2shHeader=117;
  acceptableAddressCodes=new int[]{addressHeader,p2shHeader};
  name=""String_Node_Str"";
  symbol=""String_Node_Str"";
  uriScheme=""String_Node_Str"";
  bip44Index=13;
  feePerKb=Coin.valueOf(1);
  minNonDust=Coin.valueOf(1);
  throw new RuntimeException(name + ""String_Node_Str"" + bip44Index+ ""String_Node_Str"");
}",0.772093023255814
112602,"public JSONObject put(String key,Collection value) throws JSONException {
  this.put(key,new JSONArray(value));
  return this;
}","public JSONObject put(String key,@Nullable Collection value) throws JSONException {
  if (value != null) {
    this.put(key,new JSONArray(value));
  }
  return this;
}",0.8677966101694915
112603,"public void setParams(Collection params){
  try {
    put(""String_Node_Str"",params);
  }
 catch (  JSONException e) {
    throw new RuntimeException(e);
  }
}","public void setParams(@Nullable Collection params){
  if (params == null)   return;
  try {
    put(""String_Node_Str"",params);
  }
 catch (  JSONException e) {
    throw new RuntimeException(e);
  }
}",0.88268156424581
112604,"public StatePublisher(int port){
  context=ZMQ.context(1);
  socket=context.socket(ZMQ.PUB);
  socket.bind(""String_Node_Str"" + port);
}","public StatePublisher(int port){
  context=ZMQ.context(1);
  socket=context.socket(ZMQ.PUB);
  socket.bind(""String_Node_Str"" + port);
  this.setDaemon(true);
  this.start();
}",0.8709677419354839
112605,"@Override public void publish(String id,State state){
  try {
    JSONObject json=state.inner.toMonitorJSON();
    json.put(""String_Node_Str"",id);
    socket.send(json.toString());
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e.getMessage());
    e.printStackTrace();
  }
}","@Override public void publish(String id,TrackerServer.State state){
  try {
    JSONObject json=state.inner.toMonitorJSON();
    json.put(""String_Node_Str"",id);
    queue.put(json.toString());
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e.getMessage());
    e.printStackTrace();
  }
}",0.9429530201342282
112606,"@Override public void run(){
  Stopwatch sw=new Stopwatch();
  sw.start();
  vector.set(matcher.execute(state.inner.vector(),state.inner.sample(),sample));
  sw.stop();
  logger.info(""String_Node_Str"",sample.id(),sw.ms());
}","@Override public void run(){
  while (true) {
    try {
      String message=queue.take();
      socket.send(message);
    }
 catch (    InterruptedException e) {
      logger.warn(""String_Node_Str"");
      return;
    }
  }
}",0.24
112607,"@Override public void delete(String id,long time){
  try {
    JSONObject json=new JSONObject();
    json.put(""String_Node_Str"",id);
    json.put(""String_Node_Str"",time);
    socket.send(json.toString());
    logger.info(""String_Node_Str"",id);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e.getMessage());
    e.printStackTrace();
  }
}","@Override public void delete(String id,long time){
  try {
    JSONObject json=new JSONObject();
    json.put(""String_Node_Str"",id);
    json.put(""String_Node_Str"",time);
    queue.put(json.toString());
    logger.info(""String_Node_Str"",id);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e.getMessage());
    e.printStackTrace();
  }
}",0.9717514124293786
112608,"private Map<P,Tuple<P,List<E>>> msmt(final Set<P> sources,final Set<P> targets,Cost<E> cost,Cost<E> bound,Double max){
class Mark extends Quadruple<E,E,Double,Double> implements Comparable<Mark> {
    private static final long serialVersionUID=1L;
    /** 
 * Constructor of an entry.
 * @param one {@link AbstractEdge} defining the route mark.
 * @param two Predecessor {@link AbstractEdge}.
 * @param three Cost value to this route mark.
 * @param four Bounding cost value to this route mark.
 */
    public Mark(    E one,    E two,    Double three,    Double four){
      super(one,two,three,four);
    }
    @Override public int compareTo(    Mark other){
      return (this.three() < other.three()) ? -1 : (this.three() > other.three()) ? 1 : 0;
    }
  }
  Map<E,Set<P>> targetEdges=new HashMap<>();
  for (  P target : targets) {
    logger.trace(""String_Node_Str"",target,target.edge().id(),target.fraction());
    if (!targetEdges.containsKey(target)) {
      targetEdges.put(target.edge(),new HashSet<>(Arrays.asList(target)));
    }
 else {
      targetEdges.get(target.edge()).add(target);
    }
  }
  PriorityQueue<Mark> priorities=new PriorityQueue<>();
  Map<E,Mark> entries=new HashMap<>();
  Map<P,Mark> finishs=new HashMap<>();
  Map<Mark,P> reaches=new HashMap<>();
  Map<Mark,P> starts=new HashMap<>();
  for (  P source : sources) {
    double startcost=cost.cost(source.edge(),1 - source.fraction());
    double startbound=bound != null ? bound.cost(source.edge(),1 - source.fraction()) : 0.0;
    logger.trace(""String_Node_Str"",source,source.edge().id(),source.fraction(),startcost);
    if (targetEdges.containsKey(source.edge())) {
      for (      P target : targetEdges.get(source.edge())) {
        if (target.fraction() < source.fraction()) {
          continue;
        }
        double reachcost=startcost - cost.cost(source.edge(),1 - target.fraction());
        double reachbound=bound != null ? startcost - bound.cost(source.edge(),1 - target.fraction()) : 0.0;
        logger.trace(""String_Node_Str"",target,source.edge().id(),source.fraction(),target.fraction(),reachcost);
        Mark reach=new Mark(source.edge(),null,reachcost,reachbound);
        reaches.put(reach,target);
        starts.put(reach,source);
        priorities.add(reach);
      }
    }
    Mark start=entries.get(source.edge());
    if (start == null) {
      logger.trace(""String_Node_Str"",source,source.edge().id(),source.fraction(),startcost);
      start=new Mark(source.edge(),null,startcost,startbound);
      entries.put(source.edge(),start);
      starts.put(start,source);
      priorities.add(start);
    }
 else     if (startcost < start.three()) {
      logger.trace(""String_Node_Str"",source,source.edge().id(),source.fraction(),startcost);
      start=new Mark(source.edge(),null,startcost,startbound);
      entries.put(source.edge(),start);
      starts.put(start,source);
      priorities.remove(start);
      priorities.add(start);
    }
  }
  while (priorities.size() > 0) {
    Mark current=priorities.poll();
    if (targetEdges.isEmpty()) {
      logger.trace(""String_Node_Str"");
      break;
    }
    if (max != null && current.four() > max) {
      logger.trace(""String_Node_Str"");
      break;
    }
    if (reaches.containsKey(current)) {
      P target=reaches.get(current);
      if (finishs.containsKey(target)) {
        continue;
      }
 else {
        logger.trace(""String_Node_Str"",target,current.one(),target.fraction(),current.three());
        finishs.put(target,current);
        Set<P> edges=targetEdges.get(current.one());
        edges.remove(target);
        if (edges.isEmpty()) {
          targetEdges.remove(current.one());
        }
        continue;
      }
    }
    logger.trace(""String_Node_Str"",current.one().id(),current.three());
    Iterator<E> successors=current.one().successors();
    while (successors.hasNext()) {
      E successor=successors.next();
      double succcost=current.three() + cost.cost(successor);
      double succbound=bound != null ? current.four() + bound.cost(successor) : 0.0;
      if (targetEdges.containsKey(successor)) {
        for (        P target : targetEdges.get(successor)) {
          double reachcost=succcost - cost.cost(successor,1 - target.fraction());
          double reachbound=bound != null ? succbound - bound.cost(successor,1 - target.fraction()) : 0.0;
          logger.trace(""String_Node_Str"",target,successor.id(),target.fraction(),reachcost);
          Mark reach=new Mark(successor,current.one(),reachcost,reachbound);
          reaches.put(reach,target);
          priorities.add(reach);
        }
      }
      if (!entries.containsKey(successor)) {
        logger.trace(""String_Node_Str"",successor.id(),succcost);
        Mark mark=new Mark(successor,current.one(),succcost,succbound);
        entries.put(successor,mark);
        priorities.add(mark);
      }
    }
  }
  Map<P,Tuple<P,List<E>>> paths=new HashMap<>();
  for (  P target : targets) {
    if (!finishs.containsKey(target)) {
      paths.put(target,null);
    }
 else {
      LinkedList<E> path=new LinkedList<>();
      Mark iterator=finishs.get(target);
      Mark start=null;
      while (iterator != null) {
        path.addFirst(iterator.one());
        start=iterator;
        iterator=iterator.two() != null ? entries.get(iterator.two()) : null;
      }
      paths.put(target,new Tuple<P,List<E>>(starts.get(start),path));
    }
  }
  entries.clear();
  finishs.clear();
  reaches.clear();
  priorities.clear();
  return paths;
}","private Map<P,Tuple<P,List<E>>> msmt(final Set<P> sources,final Set<P> targets,Cost<E> cost,Cost<E> bound,Double max){
class Mark extends Quadruple<E,E,Double,Double> implements Comparable<Mark> {
    private static final long serialVersionUID=1L;
    /** 
 * Constructor of an entry.
 * @param one {@link AbstractEdge} defining the route mark.
 * @param two Predecessor {@link AbstractEdge}.
 * @param three Cost value to this route mark.
 * @param four Bounding cost value to this route mark.
 */
    public Mark(    E one,    E two,    Double three,    Double four){
      super(one,two,three,four);
    }
    @Override public int compareTo(    Mark other){
      return (this.three() < other.three()) ? -1 : (this.three() > other.three()) ? 1 : 0;
    }
  }
  Map<E,Set<P>> targetEdges=new HashMap<>();
  for (  P target : targets) {
    logger.trace(""String_Node_Str"",target,target.edge().id(),target.fraction());
    if (!targetEdges.containsKey(target.edge())) {
      targetEdges.put(target.edge(),new HashSet<>(Arrays.asList(target)));
    }
 else {
      targetEdges.get(target.edge()).add(target);
    }
  }
  PriorityQueue<Mark> priorities=new PriorityQueue<>();
  Map<E,Mark> entries=new HashMap<>();
  Map<P,Mark> finishs=new HashMap<>();
  Map<Mark,P> reaches=new HashMap<>();
  Map<Mark,P> starts=new HashMap<>();
  for (  P source : sources) {
    double startcost=cost.cost(source.edge(),1 - source.fraction());
    double startbound=bound != null ? bound.cost(source.edge(),1 - source.fraction()) : 0.0;
    logger.trace(""String_Node_Str"",source,source.edge().id(),source.fraction(),startcost);
    if (targetEdges.containsKey(source.edge())) {
      for (      P target : targetEdges.get(source.edge())) {
        if (target.fraction() < source.fraction()) {
          continue;
        }
        double reachcost=startcost - cost.cost(source.edge(),1 - target.fraction());
        double reachbound=bound != null ? startcost - bound.cost(source.edge(),1 - target.fraction()) : 0.0;
        logger.trace(""String_Node_Str"",target,source.edge().id(),source.fraction(),target.fraction(),reachcost);
        Mark reach=new Mark(source.edge(),null,reachcost,reachbound);
        reaches.put(reach,target);
        starts.put(reach,source);
        priorities.add(reach);
      }
    }
    Mark start=entries.get(source.edge());
    if (start == null) {
      logger.trace(""String_Node_Str"",source,source.edge().id(),source.fraction(),startcost);
      start=new Mark(source.edge(),null,startcost,startbound);
      entries.put(source.edge(),start);
      starts.put(start,source);
      priorities.add(start);
    }
 else     if (startcost < start.three()) {
      logger.trace(""String_Node_Str"",source,source.edge().id(),source.fraction(),startcost);
      start=new Mark(source.edge(),null,startcost,startbound);
      entries.put(source.edge(),start);
      starts.put(start,source);
      priorities.remove(start);
      priorities.add(start);
    }
  }
  while (priorities.size() > 0) {
    Mark current=priorities.poll();
    if (targetEdges.isEmpty()) {
      logger.trace(""String_Node_Str"");
      break;
    }
    if (max != null && current.four() > max) {
      logger.trace(""String_Node_Str"");
      break;
    }
    if (reaches.containsKey(current)) {
      P target=reaches.get(current);
      if (finishs.containsKey(target)) {
        continue;
      }
 else {
        logger.trace(""String_Node_Str"",target,current.one(),target.fraction(),current.three());
        finishs.put(target,current);
        Set<P> edges=targetEdges.get(current.one());
        edges.remove(target);
        if (edges.isEmpty()) {
          targetEdges.remove(current.one());
        }
        continue;
      }
    }
    logger.trace(""String_Node_Str"",current.one().id(),current.three());
    Iterator<E> successors=current.one().successors();
    while (successors.hasNext()) {
      E successor=successors.next();
      double succcost=current.three() + cost.cost(successor);
      double succbound=bound != null ? current.four() + bound.cost(successor) : 0.0;
      if (targetEdges.containsKey(successor)) {
        for (        P target : targetEdges.get(successor)) {
          double reachcost=succcost - cost.cost(successor,1 - target.fraction());
          double reachbound=bound != null ? succbound - bound.cost(successor,1 - target.fraction()) : 0.0;
          logger.trace(""String_Node_Str"",target,successor.id(),target.fraction(),reachcost);
          Mark reach=new Mark(successor,current.one(),reachcost,reachbound);
          reaches.put(reach,target);
          priorities.add(reach);
        }
      }
      if (!entries.containsKey(successor)) {
        logger.trace(""String_Node_Str"",successor.id(),succcost);
        Mark mark=new Mark(successor,current.one(),succcost,succbound);
        entries.put(successor,mark);
        priorities.add(mark);
      }
    }
  }
  Map<P,Tuple<P,List<E>>> paths=new HashMap<>();
  for (  P target : targets) {
    if (!finishs.containsKey(target)) {
      paths.put(target,null);
    }
 else {
      LinkedList<E> path=new LinkedList<>();
      Mark iterator=finishs.get(target);
      Mark start=null;
      while (iterator != null) {
        path.addFirst(iterator.one());
        start=iterator;
        iterator=iterator.two() != null ? entries.get(iterator.two()) : null;
      }
      paths.put(target,new Tuple<P,List<E>>(starts.get(start),path));
    }
  }
  entries.clear();
  finishs.clear();
  reaches.clear();
  priorities.clear();
  return paths;
}",0.9993662290629244
112609,"@Test public void testShortestPath(){
{
    Graph<Road> map=new Graph<>();
    map.add(new Road(0,0,1,100));
    map.add(new Road(1,1,0,100));
    map.add(new Road(2,0,2,160));
    map.add(new Road(3,2,0,160));
    map.add(new Road(4,1,2,50));
    map.add(new Road(5,2,1,50));
    map.add(new Road(6,1,3,200));
    map.add(new Road(7,3,1,200));
    map.add(new Road(8,2,3,100));
    map.add(new Road(9,3,2,100));
    map.add(new Road(10,2,4,40));
    map.add(new Road(11,4,2,40));
    map.add(new Road(12,3,4,100));
    map.add(new Road(13,4,3,100));
    map.add(new Road(14,3,5,200));
    map.add(new Road(15,5,3,200));
    map.add(new Road(16,4,5,60));
    map.add(new Road(17,5,4,60));
    map.construct();
    Router<Road,Point<Road>> router=new Dijkstra<>();
{
      Set<Point<Road>> sources=new HashSet<>();
      sources.add(new Point<>(map.get(0),0.3));
      sources.add(new Point<>(map.get(1),0.7));
      Set<Point<Road>> targets=new HashSet<>();
      targets.add(new Point<>(map.get(14),0.3));
      targets.add(new Point<>(map.get(15),0.7));
      Map<Point<Road>,Tuple<Point<Road>,List<Road>>> routes=router.route(sources,targets,new Weight(),null,null);
      Map<Long,List<Long>> paths=new HashMap<>();
      paths.put(14L,new LinkedList<>(Arrays.asList(0L,4L,8L,14L)));
      paths.put(15L,new LinkedList<>(Arrays.asList(0L,4L,10L,16L,15L)));
      assertEquals(paths.size(),routes.size());
      for (      Entry<Point<Road>,Tuple<Point<Road>,List<Road>>> pair : routes.entrySet()) {
        List<Road> route=pair.getValue().two();
        assertNotNull(paths.get(pair.getKey().edge().id()));
        List<Long> path=paths.get(pair.getKey().edge().id());
        assertNotNull(route);
        assertEquals(path.get(0).longValue(),pair.getValue().one().edge().id());
        assertEquals(path.size(),route.size());
        int i=0;
        for (        Road road : route) {
          assertEquals((long)path.get(i++),road.id());
        }
      }
    }
{
      Set<Point<Road>> sources=new HashSet<>();
      sources.add(new Point<>(map.get(0),0.3));
      sources.add(new Point<>(map.get(1),0.7));
      Set<Point<Road>> targets=new HashSet<>();
      targets.add(new Point<>(map.get(14),0.1));
      targets.add(new Point<>(map.get(15),0.9));
      Map<Point<Road>,Tuple<Point<Road>,List<Road>>> routes=router.route(sources,targets,new Weight(),null,null);
      Map<Long,List<Long>> paths=new HashMap<>();
      paths.put(14L,new LinkedList<>(Arrays.asList(0L,4L,8L,14L)));
      paths.put(15L,new LinkedList<>(Arrays.asList(0L,4L,10L,16L,15L)));
      assertEquals(paths.size(),routes.size());
      for (      Entry<Point<Road>,Tuple<Point<Road>,List<Road>>> pair : routes.entrySet()) {
        List<Road> route=pair.getValue().two();
        List<Long> path=paths.get(pair.getKey().edge().id());
        assertNotNull(route);
        assertEquals(path.get(0).longValue(),pair.getValue().one().edge().id());
        assertEquals(path.size(),route.size());
        int i=0;
        for (        Road road : route) {
          assertEquals((long)path.get(i++),road.id());
        }
      }
    }
{
      Point<Road> source=new Point<>(map.get(0),0.3);
      Point<Road> target=new Point<>(map.get(14),0.1);
      List<Road> route=router.route(source,target,new Weight(),new Weight(),200d);
      assertNull(route);
    }
  }
}","@Test public void testShortestPath(){
{
    Graph<Road> map=new Graph<>();
    map.add(new Road(0,0,1,100));
    map.add(new Road(1,1,0,100));
    map.add(new Road(2,0,2,160));
    map.add(new Road(3,2,0,160));
    map.add(new Road(4,1,2,50));
    map.add(new Road(5,2,1,50));
    map.add(new Road(6,1,3,200));
    map.add(new Road(7,3,1,200));
    map.add(new Road(8,2,3,100));
    map.add(new Road(9,3,2,100));
    map.add(new Road(10,2,4,40));
    map.add(new Road(11,4,2,40));
    map.add(new Road(12,3,4,100));
    map.add(new Road(13,4,3,100));
    map.add(new Road(14,3,5,200));
    map.add(new Road(15,5,3,200));
    map.add(new Road(16,4,5,60));
    map.add(new Road(17,5,4,60));
    map.construct();
    Router<Road,Point<Road>> router=new Dijkstra<>();
{
      Set<Point<Road>> sources=new HashSet<>();
      sources.add(new Point<>(map.get(0),0.3));
      sources.add(new Point<>(map.get(1),0.7));
      Set<Point<Road>> targets=new HashSet<>();
      targets.add(new Point<>(map.get(14),0.3));
      targets.add(new Point<>(map.get(15),0.7));
      Map<Point<Road>,Tuple<Point<Road>,List<Road>>> routes=router.route(sources,targets,new Weight(),null,null);
      Map<Long,List<Long>> paths=new HashMap<>();
      paths.put(14L,new LinkedList<>(Arrays.asList(0L,4L,8L,14L)));
      paths.put(15L,new LinkedList<>(Arrays.asList(0L,4L,10L,16L,15L)));
      assertEquals(paths.size(),routes.size());
      for (      Entry<Point<Road>,Tuple<Point<Road>,List<Road>>> pair : routes.entrySet()) {
        List<Road> route=pair.getValue().two();
        assertNotNull(paths.get(pair.getKey().edge().id()));
        List<Long> path=paths.get(pair.getKey().edge().id());
        assertNotNull(route);
        assertEquals(path.get(0).longValue(),pair.getValue().one().edge().id());
        assertEquals(path.size(),route.size());
        int i=0;
        for (        Road road : route) {
          assertEquals((long)path.get(i++),road.id());
        }
      }
    }
{
      Set<Point<Road>> sources=new HashSet<>();
      sources.add(new Point<>(map.get(0),0.3));
      sources.add(new Point<>(map.get(1),0.7));
      Set<Point<Road>> targets=new HashSet<>();
      targets.add(new Point<>(map.get(14),0.1));
      targets.add(new Point<>(map.get(15),0.9));
      Map<Point<Road>,Tuple<Point<Road>,List<Road>>> routes=router.route(sources,targets,new Weight(),null,null);
      Map<Long,List<Long>> paths=new HashMap<>();
      paths.put(14L,new LinkedList<>(Arrays.asList(0L,4L,8L,14L)));
      paths.put(15L,new LinkedList<>(Arrays.asList(0L,4L,10L,16L,15L)));
      assertEquals(paths.size(),routes.size());
      for (      Entry<Point<Road>,Tuple<Point<Road>,List<Road>>> pair : routes.entrySet()) {
        List<Road> route=pair.getValue().two();
        List<Long> path=paths.get(pair.getKey().edge().id());
        assertNotNull(route);
        assertEquals(path.get(0).longValue(),pair.getValue().one().edge().id());
        assertEquals(path.size(),route.size());
        int i=0;
        for (        Road road : route) {
          assertEquals((long)path.get(i++),road.id());
        }
      }
    }
{
      Point<Road> source=new Point<>(map.get(0),0.3);
      Point<Road> target=new Point<>(map.get(14),0.1);
      List<Road> route=router.route(source,target,new Weight(),new Weight(),200d);
      assertNull(route);
    }
{
      Set<Point<Road>> sources=new HashSet<>();
      sources.add(new Point<>(map.get(0),0.3));
      sources.add(new Point<>(map.get(1),0.7));
      Set<Point<Road>> targets=new HashSet<>();
      targets.add(new Point<>(map.get(14),0.1));
      targets.add(new Point<>(map.get(14),0.8));
      Map<Point<Road>,Tuple<Point<Road>,List<Road>>> routes=router.route(sources,targets,new Weight(),null,null);
      Map<Long,List<Long>> paths=new HashMap<>();
      paths.put(14L,new LinkedList<>(Arrays.asList(0L,4L,8L,14L)));
      assertEquals(2,routes.size());
      for (      Entry<Point<Road>,Tuple<Point<Road>,List<Road>>> pair : routes.entrySet()) {
        List<Road> route=pair.getValue().two();
        List<Long> path=paths.get(pair.getKey().edge().id());
        assertNotNull(route);
        assertEquals(path.get(0).longValue(),pair.getValue().one().edge().id());
        assertEquals(path.size(),route.size());
        int i=0;
        for (        Road road : route) {
          assertEquals((long)path.get(i++),road.id());
        }
      }
    }
  }
}",0.8630737493553378
112610,"@Bean public MongoClient mongoClient(){
  List<ServerAddress> serverAddresses=new ArrayList();
  MongoClient mongoClient=null;
  try {
    for (    String mongoHost : configurationContext.getMongoHosts()) {
      String[] elements=mongoHost.split(""String_Node_Str"");
      if (elements.length < 2) {
        serverAddresses.add(new ServerAddress(elements[0]));
      }
 else {
        serverAddresses.add(new ServerAddress(elements[0],Integer.parseInt(elements[1])));
      }
    }
    if (configurationContext.getMongoUsername() != null && configurationContext.getMongoPassword() != null) {
      mongoClient=new MongoClient(serverAddresses,Arrays.asList(MongoCredential.createPlainCredential(configurationContext.getMongoUsername(),""String_Node_Str"",configurationContext.getMongoPassword().toCharArray())));
    }
 else {
      log.warn(""String_Node_Str"",configurationContext.getMongoUsername(),configurationContext.getMongoPassword());
      mongoClient=new MongoClient(serverAddresses);
    }
  }
 catch (  UnknownHostException e) {
    e.printStackTrace();
  }
  log.error(""String_Node_Str"");
  return mongoClient;
}","@Bean public MongoClient mongoClient(){
  List<ServerAddress> serverAddresses=new ArrayList();
  MongoClient mongoClient=null;
  try {
    for (    String mongoHost : configurationContext.getMongoHosts()) {
      String[] elements=mongoHost.split(""String_Node_Str"");
      if (elements.length < 2) {
        serverAddresses.add(new ServerAddress(elements[0]));
      }
 else {
        serverAddresses.add(new ServerAddress(elements[0],Integer.parseInt(elements[1])));
      }
    }
    if (configurationContext.getMongoUsername() != null && configurationContext.getMongoPassword() != null) {
      mongoClient=new MongoClient(serverAddresses,Arrays.asList(MongoCredential.createPlainCredential(configurationContext.getMongoUsername(),""String_Node_Str"",configurationContext.getMongoPassword().toCharArray())));
    }
 else {
      log.warn(""String_Node_Str"",configurationContext.getMongoUsername(),configurationContext.getMongoPassword());
      mongoClient=new MongoClient(serverAddresses);
    }
  }
 catch (  UnknownHostException e) {
    e.printStackTrace();
  }
  log.debug(""String_Node_Str"");
  return mongoClient;
}",0.9955396966993756
112611,"@Override public void process(Iterable<StratioStreamingMessage> messages) throws Exception {
  Integer partitionSize=maxBatchSize;
  if (partitionSize <= 0) {
    partitionSize=Iterables.size(messages);
  }
  Iterable<List<StratioStreamingMessage>> partitionIterables=Iterables.partition(messages,partitionSize);
  try {
    for (    List<StratioStreamingMessage> messageList : partitionIterables) {
      BatchStatement batch=new BatchStatement(batchType);
      for (      StratioStreamingMessage stratioStreamingMessage : messageList) {
        Set<String> columns=getColumnSet(stratioStreamingMessage.getColumns());
        if (getCassandraTableOperationsService().getTableNames().get(stratioStreamingMessage.getStreamName()) == null) {
          getCassandraTableOperationsService().createTable(stratioStreamingMessage.getStreamName(),stratioStreamingMessage.getColumns(),TIMESTAMP_FIELD);
          getCassandraTableOperationsService().refreshTablenames();
        }
        if (getCassandraTableOperationsService().getTableNames().get(stratioStreamingMessage.getStreamName()) != columns.hashCode()) {
          getCassandraTableOperationsService().alterTable(stratioStreamingMessage.getStreamName(),columns,stratioStreamingMessage.getColumns());
          getCassandraTableOperationsService().refreshTablenames();
        }
        batch.add(getCassandraTableOperationsService().createInsertStatement(stratioStreamingMessage.getStreamName(),stratioStreamingMessage.getColumns(),TIMESTAMP_FIELD));
      }
      getCassandraTableOperationsService().getSession().execute(batch);
    }
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",Iterables.size(partitionIterables),e.getMessage());
  }
}","@Override public void process(Iterable<StratioStreamingMessage> messages) throws Exception {
  Integer partitionSize=maxBatchSize;
  if (partitionSize <= 0) {
    partitionSize=Iterables.size(messages);
  }
  Iterable<List<StratioStreamingMessage>> partitionIterables=Iterables.partition(messages,partitionSize);
  try {
    getCassandraTableOperationsService().checkKeyspace();
    for (    List<StratioStreamingMessage> messageList : partitionIterables) {
      BatchStatement batch=new BatchStatement(batchType);
      for (      StratioStreamingMessage stratioStreamingMessage : messageList) {
        Set<String> columns=getColumnSet(stratioStreamingMessage.getColumns());
        if (getCassandraTableOperationsService().getTableNames().get(stratioStreamingMessage.getStreamName()) == null) {
          getCassandraTableOperationsService().createTable(stratioStreamingMessage.getStreamName(),stratioStreamingMessage.getColumns(),TIMESTAMP_FIELD);
          getCassandraTableOperationsService().refreshTablenames();
        }
        if (getCassandraTableOperationsService().getTableNames().get(stratioStreamingMessage.getStreamName()) != columns.hashCode()) {
          getCassandraTableOperationsService().alterTable(stratioStreamingMessage.getStreamName(),columns,stratioStreamingMessage.getColumns());
          getCassandraTableOperationsService().refreshTablenames();
        }
        batch.add(getCassandraTableOperationsService().createInsertStatement(stratioStreamingMessage.getStreamName(),stratioStreamingMessage.getColumns(),TIMESTAMP_FIELD));
      }
      getCassandraTableOperationsService().getSession().execute(batch);
    }
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",Iterables.size(partitionIterables),e.getMessage());
  }
}",0.9833045480713876
112612,"@Override public void process(Iterable<StratioStreamingMessage> messages) throws Exception {
}","@Override public void process(Iterable<StratioStreamingMessage> messages) throws Exception {
  try {
    BulkProcessor bulkProcessor=BulkProcessor.builder(getClient(),new BulkProcessor.Listener(){
      @Override public void beforeBulk(      long executionId,      BulkRequest request){
        log.debug(""String_Node_Str"",request.numberOfActions());
      }
      @Override public void afterBulk(      long executionId,      BulkRequest request,      BulkResponse response){
        log.debug(""String_Node_Str"",request.numberOfActions());
      }
      @Override public void afterBulk(      long executionId,      BulkRequest request,      Throwable failure){
        log.error(""String_Node_Str"",failure);
      }
    }
).setBulkActions(maxBatchSize).build();
    for (    StratioStreamingMessage stratioStreamingMessage : messages) {
      try {
        XContentBuilder contentBuilder=XContentFactory.jsonBuilder().startObject();
        for (        ColumnNameTypeValue column : stratioStreamingMessage.getColumns()) {
          contentBuilder=contentBuilder.field(column.getColumn(),column.getValue());
        }
        contentBuilder=contentBuilder.field(""String_Node_Str"",elasicSearchTimestampFormat.format(stratioStreamingMessage.getTimestamp()));
        contentBuilder=contentBuilder.endObject();
        IndexRequestBuilder request=getClient().prepareIndex(INDEX_NAME,stratioStreamingMessage.getStreamName()).setSource(contentBuilder);
        bulkProcessor.add(request.request());
      }
 catch (      IOException e) {
        log.error(""String_Node_Str"",stratioStreamingMessage.getStreamName(),e);
      }
    }
    bulkProcessor.close();
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + e.getMessage());
  }
}",0.1026200873362445
112613,"public StreamStatusDTO(String streamName,Boolean userDefined,List<ColumnNameTypeValue> columns){
  this.streamName=streamName;
  this.userDefined=userDefined;
  this.actionsEnabled=new HashSet<>();
  this.addedQueries=new HashMap<>();
  this.streamDefinition=columns != null ? columns : new ArrayList<>();
  this.engineActionsEnabled=new HashMap<>();
  this.streamColumns=new HashMap();
  streamDefinition.forEach(column -> streamColumns.put(column.getColumn(),column));
}","public StreamStatusDTO(String streamName,Boolean userDefined,List<ColumnNameTypeValue> columns){
  this.streamName=streamName;
  this.userDefined=userDefined;
  this.actionsEnabled=new HashSet<>();
  this.addedQueries=new HashMap<>();
  this.engineActionsEnabled=new HashMap<>();
  this.streamColumns=new HashMap();
  this.streamDefinition=new ArrayList<>();
  columns.forEach(column -> {
    streamDefinition.add(column);
    streamColumns.put(column.getColumn(),column);
  }
);
}",0.5897166841552991
112614,"public void enableAction(String streamName,StreamAction action){
  if (streamStatusDao.getEnabledActions(streamName).size() == 0) {
    String actionQueryId=siddhiManager.addQuery(QueryFactory.createQuery().from(QueryFactory.inputStream(streamName)).insertInto(STREAMING.STATS_NAMES.SINK_STREAM_PREFIX.concat(streamName)));
    streamStatusDao.setActionQuery(streamName,actionQueryId);
    siddhiManager.addCallback(actionQueryId,callbackService.add(streamName,streamStatusDao.getEnabledActions(streamName),configurationContext.getClusterId()));
  }
  streamStatusDao.enableAction(streamName,action);
}","public void enableAction(String streamName,StreamAction action){
  if (streamStatusDao.getEnabledActions(streamName).size() == 0) {
    String actionQueryId=siddhiManager.addQuery(QueryFactory.createQuery().from(QueryFactory.inputStream(streamName)).insertInto(STREAMING.STATS_NAMES.SINK_STREAM_PREFIX.concat(streamName)));
    streamStatusDao.setActionQuery(streamName,actionQueryId);
    String clusterId=null;
    if (configurationContext != null) {
      clusterId=configurationContext.getClusterId();
    }
    siddhiManager.addCallback(actionQueryId,callbackService.add(streamName,streamStatusDao.getEnabledActions(streamName),clusterId));
  }
  streamStatusDao.enableAction(streamName,action);
}",0.8711656441717791
112615,"public void addQuery(String streamName,String queryString){
  String queryId=siddhiManager.addQuery(queryString);
  streamStatusDao.addQuery(streamName,queryId,queryString);
  for (  StreamDefinition streamDefinition : siddhiManager.getStreamDefinitions()) {
    streamStatusDao.createInferredStream(streamName,castToColumnNameTypeValue(streamDefinition.getAttributeList()));
  }
}","public void addQuery(String streamName,String queryString){
  String queryId=siddhiManager.addQuery(queryString);
  streamStatusDao.addQuery(streamName,queryId,queryString);
  for (  StreamDefinition streamDefinition : siddhiManager.getStreamDefinitions()) {
    streamStatusDao.createInferredStream(streamDefinition.getStreamId(),castToColumnNameTypeValue(streamDefinition.getAttributeList()));
  }
}",0.9641943734015346
112616,"public void addQuery(String streamName,String queryString){
  String queryId=siddhiManager.addQuery(queryString);
  streamStatusDao.addQuery(streamName,queryId,queryString);
  for (  StreamDefinition streamDefinition : siddhiManager.getStreamDefinitions()) {
    streamStatusDao.createInferredStream(streamName,castToColumnNameTypeValue(streamDefinition.getAttributeList()));
  }
}","public void addQuery(String streamName,String queryString){
  String queryId=siddhiManager.addQuery(queryString);
  streamStatusDao.addQuery(streamName,queryId,queryString);
  for (  StreamDefinition streamDefinition : siddhiManager.getStreamDefinitions()) {
    streamStatusDao.createInferredStream(streamDefinition.getStreamId(),castToColumnNameTypeValue(streamDefinition.getAttributeList()));
  }
}",0.9641943734015346
112617,"public synchronized void load() throws Exception {
  FailoverPersistenceStoreModel failoverPersistenceStoreModel=streamingFailoverDao.load();
  if (failoverPersistenceStoreModel != null) {
    streamStatusDao.putAll(failoverPersistenceStoreModel.getStreamStatuses());
    Map<String,StreamStatusDTO> streamsStatus=failoverPersistenceStoreModel.getStreamStatuses();
    for (    Map.Entry<String,StreamStatusDTO> entry : streamsStatus.entrySet()) {
      StreamStatusDTO stream=entry.getValue();
      streamOperationService.createStream(stream.getStreamName(),stream.getStreamDefinition());
      for (      Map.Entry<String,QueryDTO> query : stream.getAddedQueries().entrySet()) {
        streamOperationService.addQuery(entry.getKey(),query.getValue().getQueryRaw());
      }
      for (      StreamAction action : stream.getActionsEnabled()) {
        streamOperationService.enableAction(entry.getKey(),action);
      }
    }
  }
}","public synchronized void load() throws Exception {
  FailoverPersistenceStoreModel failoverPersistenceStoreModel=streamingFailoverDao.load();
  if (failoverPersistenceStoreModel != null) {
    streamStatusDao.putAll(failoverPersistenceStoreModel.getStreamStatuses());
    Map<String,StreamStatusDTO> streamsStatus=failoverPersistenceStoreModel.getStreamStatuses();
    for (    Map.Entry<String,StreamStatusDTO> entry : streamsStatus.entrySet()) {
      StreamStatusDTO stream=entry.getValue();
      streamOperationService.createStream(stream.getStreamName(),stream.getStreamDefinition());
      for (      Map.Entry<String,QueryDTO> query : stream.getAddedQueries().entrySet()) {
        streamOperationService.addQuery(entry.getKey(),query.getValue().getQueryRaw());
      }
      for (      StreamAction action : stream.getActionsEnabled()) {
        streamOperationService.enableAction(entry.getKey(),action);
      }
    }
    streamMetadataService.setSnapshot(failoverPersistenceStoreModel.getSiddhiSnapshot());
  }
}",0.9540347293156282
112618,"public synchronized void save() throws Exception {
  streamingFailoverDao.save(new FailoverPersistenceStoreModel(streamStatusDao.getAll(),null));
}","public synchronized void save() throws Exception {
  streamingFailoverDao.save(new FailoverPersistenceStoreModel(streamStatusDao.getAll(),streamMetadataService.getSnapshot()));
}",0.8861538461538462
112619,"public StreamingFailoverService(StreamStatusDao streamStatusDao,StreamMetadataService streamMetadataService,StreamingFailoverDao streamingFailoverDao,StreamOperationService streamOperationService){
  this.streamStatusDao=streamStatusDao;
  this.streamMetadataService=streamMetadataService;
  this.streamingFailoverDao=streamingFailoverDao;
  this.streamOperationService=streamOperationService;
}","public StreamingFailoverService(StreamStatusDao streamStatusDao,StreamMetadataService streamMetadataService,StreamingFailoverDao streamingFailoverDao){
  this.streamStatusDao=streamStatusDao;
  this.streamMetadataService=streamMetadataService;
  this.streamingFailoverDao=streamingFailoverDao;
}",0.855072463768116
112620,"@Override public void process(Iterable<StratioStreamingMessage> messages) throws Exception {
  Map<String,Collection<SolrInputDocument>> elemntsToInsert=new HashMap<String,Collection<SolrInputDocument>>();
  for (  StratioStreamingMessage stratioStreamingMessage : messages) {
    SolrInputDocument document=new SolrInputDocument();
    document.addField(""String_Node_Str"",stratioStreamingMessage.getTimestamp());
    for (    ColumnNameTypeValue column : stratioStreamingMessage.getColumns()) {
      document.addField(column.getColumn(),column.getValue());
    }
    checkCore(stratioStreamingMessage);
    Collection<SolrInputDocument> collection=elemntsToInsert.get(stratioStreamingMessage.getStreamName());
    collection.add(document);
    elemntsToInsert.put(stratioStreamingMessage.getStreamName(),collection);
    getClient(stratioStreamingMessage).add(document);
  }
  for (  Map.Entry<String,Collection<SolrInputDocument>> elem : elemntsToInsert.entrySet()) {
    getSolrclient(elem.getKey()).add(elem.getValue());
  }
  flushClients();
}","@Override public void process(Iterable<StratioStreamingMessage> messages) throws Exception {
  Map<String,Collection<SolrInputDocument>> elemntsToInsert=new HashMap<String,Collection<SolrInputDocument>>();
  for (  StratioStreamingMessage stratioStreamingMessage : messages) {
    SolrInputDocument document=new SolrInputDocument();
    document.addField(""String_Node_Str"",stratioStreamingMessage.getTimestamp());
    for (    ColumnNameTypeValue column : stratioStreamingMessage.getColumns()) {
      document.addField(column.getColumn(),column.getValue());
    }
    checkCore(stratioStreamingMessage);
    Collection<SolrInputDocument> collection=elemntsToInsert.get(stratioStreamingMessage.getStreamName());
    collection.add(document);
    elemntsToInsert.put(stratioStreamingMessage.getStreamName(),collection);
  }
  for (  Map.Entry<String,Collection<SolrInputDocument>> elem : elemntsToInsert.entrySet()) {
    getSolrclient(elem.getKey()).add(elem.getValue());
  }
  flushClients();
}",0.9735812133072408
112621,"public void createInternalStream(String streamName,List<ColumnNameTypeValue> columns){
  StreamDefinition newStream=QueryFactory.createStreamDefinition().name(streamName);
  for (  ColumnNameTypeValue column : columns) {
    newStream.attribute(column.getColumn(),getSiddhiType(column.getType()));
  }
  siddhiManager.defineStream(newStream);
  streamStatusDao.createInferredStream(streamName);
}","public void createInternalStream(String streamName,List<ColumnNameTypeValue> columns){
  StreamDefinition newStream=QueryFactory.createStreamDefinition().name(streamName);
  for (  ColumnNameTypeValue column : columns) {
    newStream.attribute(column.getColumn(),getSiddhiType(column.getType()));
  }
  siddhiManager.defineStream(newStream);
  streamStatusDao.createInferredStream(streamName,columns);
}",0.99
112622,"public void createStream(String streamName,List<ColumnNameTypeValue> columns){
  StreamDefinition newStream=QueryFactory.createStreamDefinition().name(streamName);
  for (  ColumnNameTypeValue column : columns) {
    newStream.attribute(column.getColumn(),getSiddhiType(column.getType()));
  }
  siddhiManager.defineStream(newStream);
  streamStatusDao.create(streamName);
}","public void createStream(String streamName,List<ColumnNameTypeValue> columns){
  StreamDefinition newStream=QueryFactory.createStreamDefinition().name(streamName);
  for (  ColumnNameTypeValue column : columns) {
    newStream.attribute(column.getColumn(),getSiddhiType(column.getType()));
  }
  siddhiManager.defineStream(newStream);
  streamStatusDao.create(streamName,columns);
}",0.9894179894179894
112623,"public void addQuery(String streamName,String queryString){
  String queryId=siddhiManager.addQuery(queryString);
  streamStatusDao.addQuery(streamName,queryId,queryString);
  for (  StreamDefinition streamDefinition : siddhiManager.getStreamDefinitions()) {
    streamStatusDao.createInferredStream(streamDefinition.getStreamId());
  }
}","public void addQuery(String streamName,String queryString){
  String queryId=siddhiManager.addQuery(queryString);
  streamStatusDao.addQuery(streamName,queryId,queryString);
  for (  StreamDefinition streamDefinition : siddhiManager.getStreamDefinitions()) {
    streamStatusDao.createInferredStream(streamName,castToColumnNameTypeValue(streamDefinition.getAttributeList()));
  }
}",0.8762169680111266
112624,"public synchronized void load(){
  CassandraPersistenceStoreModel cassandraPersistenceStoreModel=streamingFailoverDao.load();
  if (cassandraPersistenceStoreModel != null) {
    streamStatusDao.putAll(cassandraPersistenceStoreModel.getStreamStatuses());
    streamMetadataService.setSnapshot(cassandraPersistenceStoreModel.getSiddhiSnapshot());
  }
}","public synchronized void load(){
  CassandraPersistenceStoreModel cassandraPersistenceStoreModel=streamingFailoverDao.load();
  if (cassandraPersistenceStoreModel != null) {
    Map<String,StreamStatusDTO> streamsStatus=cassandraPersistenceStoreModel.getStreamStatuses();
    streamStatusDao.putAll(cassandraPersistenceStoreModel.getStreamStatuses());
    for (    Map.Entry<String,StreamStatusDTO> entry : streamsStatus.entrySet()) {
      StreamStatusDTO streamStatusDTO=entry.getValue();
      streamOperationService.createStream(streamStatusDTO.getStreamName(),streamStatusDTO.getStreamDefinition());
    }
    streamMetadataService.setSnapshot(cassandraPersistenceStoreModel.getSiddhiSnapshot());
  }
}",0.6054872280037843
112625,"public StreamingFailoverService(StreamStatusDao streamStatusDao,StreamMetadataService streamMetadataService,StreamingFailoverDao streamingFailoverDao){
  this.streamStatusDao=streamStatusDao;
  this.streamMetadataService=streamMetadataService;
  this.streamingFailoverDao=streamingFailoverDao;
}","public StreamingFailoverService(StreamStatusDao streamStatusDao,StreamMetadataService streamMetadataService,StreamingFailoverDao streamingFailoverDao,StreamOperationService streamOperationService){
  this.streamStatusDao=streamStatusDao;
  this.streamMetadataService=streamMetadataService;
  this.streamingFailoverDao=streamingFailoverDao;
  this.streamOperationService=streamOperationService;
}",0.855072463768116
112626,"public String getStreamDefinition(){
  return streamDefinition;
}","public List<ColumnNameTypeValue> getStreamDefinition(){
  return streamDefinition;
}",0.8187919463087249
112627,"public void setStreamDefinition(String streamDefinition){
  this.streamDefinition=streamDefinition;
}","public void setStreamDefinition(List<ColumnNameTypeValue> streamDefinition){
  this.streamDefinition=streamDefinition;
}",0.8778280542986425
112628,"public StreamStatusDTO(String streamName,Boolean userDefined){
  this.streamName=streamName;
  this.userDefined=userDefined;
  this.actionsEnabled=new HashSet<>();
  this.addedQueries=new HashMap<>();
}","public StreamStatusDTO(String streamName,Boolean userDefined,List<ColumnNameTypeValue> columns){
  this.streamName=streamName;
  this.userDefined=userDefined;
  this.actionsEnabled=new HashSet<>();
  this.addedQueries=new HashMap<>();
  this.streamDefinition=columns;
}",0.8577494692144374
112629,"@Test public void addQueryTest(){
  createBaseStream();
  streamOperationService.addQuery(STREAM_NAME_GOOD,""String_Node_Str"" + STREAM_NAME_GOOD + ""String_Node_Str""+ INFERRED_STREAM_GOOD+ ""String_Node_Str"");
  Mockito.verify(streamStatusDao,VerificationModeFactory.times(2)).createInferredStream(Mockito.anyString());
  Assert.assertEquals(2,sm.getStreamDefinitions().size());
}","@Test public void addQueryTest(){
  createBaseStream();
  streamOperationService.addQuery(STREAM_NAME_GOOD,""String_Node_Str"" + STREAM_NAME_GOOD + ""String_Node_Str""+ INFERRED_STREAM_GOOD+ ""String_Node_Str"");
  Mockito.verify(streamStatusDao,VerificationModeFactory.times(2)).createInferredStream(Mockito.anyString(),null);
  Assert.assertEquals(2,sm.getStreamDefinitions().size());
}",0.9934123847167324
112630,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String drop(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    cachedStreamsDAO.dropStream(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException|StratioAPISecurityException|StratioEngineOperationException e) {
    throw new StreamingShellException(e);
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String drop(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    cachedStreamsDAO.dropStream(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException|StratioAPISecurityException|StratioEngineOperationException|StratioEngineConnectionException e) {
    throw new StreamingShellException(e);
  }
}",0.9676787463271302
112631,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String create(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true) final String streamName,@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true) final ColumnNameTypeList columns){
  try {
    cachedStreamsDAO.newStream(streamName,columns);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException|StratioAPISecurityException|StratioEngineOperationException e) {
    throw new StreamingShellException(e);
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String create(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true) final String streamName,@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true) final ColumnNameTypeList columns){
  try {
    cachedStreamsDAO.newStream(streamName,columns);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException|StratioAPISecurityException|StratioEngineOperationException|StratioEngineConnectionException e) {
    throw new StreamingShellException(e);
  }
}",0.9722455845248108
112632,"@Bean public CachedStreamsDAO cachedStreamsDao(){
  return new CachedStreamsDAOImpl(stratioStreamingApi);
}","@Bean public CachedStreamsDAO cachedStreamsDao(){
  return new CachedStreamsDAOImpl(ssaw);
}",0.9045226130653268
112633,"List<StratioStream> listUncachedStreams() throws StratioEngineStatusException, StratioAPIGenericException ;","List<StratioStream> listUncachedStreams() throws StratioEngineStatusException, StratioAPIGenericException, StratioEngineConnectionException ;",0.8629032258064516
112634,"List<StratioStream> listStreams() throws StratioEngineStatusException, StratioAPIGenericException ;","List<StratioStream> listStreams() throws StratioEngineStatusException, StratioAPIGenericException, StratioEngineConnectionException ;",0.853448275862069
112635,"void newStream(String name,List<ColumnNameType> columns) throws StratioEngineStatusException, StratioAPISecurityException, StratioEngineOperationException ;","void newStream(String name,List<ColumnNameType> columns) throws StratioEngineStatusException, StratioAPISecurityException, StratioEngineOperationException, StratioEngineConnectionException ;",0.9017341040462428
112636,"void dropStream(String name) throws StratioEngineStatusException, StratioAPISecurityException, StratioEngineOperationException ;","void dropStream(String name) throws StratioEngineStatusException, StratioAPISecurityException, StratioEngineOperationException, StratioEngineConnectionException ;",0.8827586206896552
112637,"public CachedStreamsDAOImpl(IStratioStreamingAPI stratioStreamingApi){
  this.stratioStreamingApi=stratioStreamingApi;
}","public CachedStreamsDAOImpl(StratioStreamingApiWrapper ssaw){
  this.ssaw=ssaw;
}",0.6467661691542289
112638,"@Override @Caching(evict=@CacheEvict(value=""String_Node_Str"",allEntries=true,beforeInvocation=true),cacheable=@Cacheable(value=""String_Node_Str"")) public List<StratioStream> listUncachedStreams() throws StratioEngineStatusException, StratioAPIGenericException {
  return stratioStreamingApi.listStreams();
}","@Override @Caching(evict=@CacheEvict(value=""String_Node_Str"",allEntries=true,beforeInvocation=true),cacheable=@Cacheable(value=""String_Node_Str"")) public List<StratioStream> listUncachedStreams() throws StratioEngineStatusException, StratioAPIGenericException, StratioEngineConnectionException {
  return ssaw.api().listStreams();
}",0.9045383411580594
112639,"@Cacheable(value=""String_Node_Str"") @Override public List<StratioStream> listStreams() throws StratioEngineStatusException, StratioAPIGenericException {
  return stratioStreamingApi.listStreams();
}","@Cacheable(value=""String_Node_Str"") @Override public List<StratioStream> listStreams() throws StratioEngineStatusException, StratioAPIGenericException, StratioEngineConnectionException {
  return ssaw.api().listStreams();
}",0.8551068883610451
112640,"@CacheEvict(value=""String_Node_Str"",allEntries=true) @Override public void newStream(String name,List<ColumnNameType> columns) throws StratioEngineStatusException, StratioAPISecurityException, StratioEngineOperationException {
  stratioStreamingApi.createStream(name,columns);
}","@CacheEvict(value=""String_Node_Str"",allEntries=true) @Override public void newStream(String name,List<ColumnNameType> columns) throws StratioEngineStatusException, StratioAPISecurityException, StratioEngineOperationException, StratioEngineConnectionException {
  ssaw.api().createStream(name,columns);
}",0.8950086058519794
112641,"@CacheEvict(value=""String_Node_Str"",allEntries=true) @Override public void dropStream(String name) throws StratioEngineStatusException, StratioAPISecurityException, StratioEngineOperationException {
  stratioStreamingApi.dropStream(name);
}","@CacheEvict(value=""String_Node_Str"",allEntries=true) @Override public void dropStream(String name) throws StratioEngineStatusException, StratioAPISecurityException, StratioEngineOperationException, StratioEngineConnectionException {
  ssaw.api().dropStream(name);
}",0.8792079207920792
112642,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String saveMongoStart(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    stratioStreamingApi.saveToMongo(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException e) {
    throw new StreamingShellException(e);
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String saveMongoStart(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    ssaw.api().saveToMongo(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException|StratioEngineConnectionException e) {
    throw new StreamingShellException(e);
  }
}",0.8608695652173913
112643,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String saveMongoStop(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    stratioStreamingApi.stopSaveToMongo(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException e) {
    throw new StreamingShellException(e);
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String saveMongoStop(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    ssaw.api().stopSaveToMongo(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException|StratioEngineConnectionException e) {
    throw new StreamingShellException(e);
  }
}",0.8617710583153347
112644,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String saveCassandraStart(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    stratioStreamingApi.saveToCassandra(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException e) {
    throw new StreamingShellException(e);
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String saveCassandraStart(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    ssaw.api().saveToCassandra(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException|StratioEngineConnectionException e) {
    throw new StreamingShellException(e);
  }
}",0.8632478632478633
112645,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String listenStart(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    stratioStreamingApi.listenStream(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException|StratioAPISecurityException e) {
    throw new StreamingShellException(e);
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String listenStart(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    ssaw.api().listenStream(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException|StratioEngineConnectionException|StratioAPISecurityException e) {
    throw new StreamingShellException(e);
  }
}",0.9382716049382716
112646,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String indexStop(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    stratioStreamingApi.stopIndexStream(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException e) {
    throw new StreamingShellException(e);
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String indexStop(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    ssaw.api().stopIndexStream(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException|StratioEngineConnectionException e) {
    throw new StreamingShellException(e);
  }
}",0.934640522875817
112647,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String saveCassandraStop(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    stratioStreamingApi.stopSaveToCassandra(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException e) {
    throw new StreamingShellException(e);
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String saveCassandraStop(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    ssaw.api().stopSaveToCassandra(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException|StratioEngineConnectionException e) {
    throw new StreamingShellException(e);
  }
}",0.8641188959660298
112648,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String indexStart(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    stratioStreamingApi.indexStream(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException e) {
    throw new StreamingShellException(e);
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String indexStart(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    ssaw.api().indexStream(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException|StratioEngineConnectionException e) {
    throw new StreamingShellException(e);
  }
}",0.9342105263157896
112649,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String listenStop(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    stratioStreamingApi.stopListenStream(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException|StratioAPISecurityException e) {
    throw new StreamingShellException(e);
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String listenStop(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    ssaw.api().stopListenStream(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException|StratioEngineConnectionException|StratioAPISecurityException e) {
    throw new StreamingShellException(e);
  }
}",0.9386503067484664
112650,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String drop(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName,@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true) final String queryId){
  try {
    stratioStreamingApi.removeQuery(streamName,queryId);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"".concat(queryId));
  }
 catch (  StratioEngineStatusException|StratioEngineOperationException e) {
    throw new StreamingShellException(e);
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String drop(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName,@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true) final String queryId){
  try {
    ssaw.api().removeQuery(streamName,queryId);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"".concat(queryId));
  }
 catch (  StratioEngineStatusException|StratioEngineOperationException|StratioEngineConnectionException e) {
    throw new StreamingShellException(e);
  }
}",0.8935108153078203
112651,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String create(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName,@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true) final String query){
  try {
    String queryId=stratioStreamingApi.addQuery(streamName,query);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"".concat(queryId));
  }
 catch (  StratioEngineStatusException|StratioAPISecurityException|StratioEngineOperationException e) {
    throw new StreamingShellException(e);
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String create(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName,@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true) final String query){
  try {
    String queryId=ssaw.api().addQuery(streamName,query);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"".concat(queryId));
  }
 catch (  StratioEngineStatusException|StratioAPISecurityException|StratioEngineOperationException|StratioEngineConnectionException e) {
    throw new StreamingShellException(e);
  }
}",0.9530516431924884
112652,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String listQuerys(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    List<ColumnNameTypeValue> columnsValues=stratioStreamingApi.columnsFromStream(streamName);
    List<String> columns=Arrays.asList(""String_Node_Str"",""String_Node_Str"");
    List<Map<String,Object>> data=new ArrayList<>();
    for (    ColumnNameTypeValue columnValue : columnsValues) {
      Map<String,Object> row=new HashMap<>();
      row.put(""String_Node_Str"",columnValue.getColumn());
      row.put(""String_Node_Str"",columnValue.getType());
      data.add(row);
    }
    return TableRenderer.renderMapDataAsTable(data,columns);
  }
 catch (  StratioEngineOperationException e) {
    throw new StreamingShellException(e);
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String listQuerys(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    List<ColumnNameTypeValue> columnsValues=ssaw.api().columnsFromStream(streamName);
    List<String> columns=Arrays.asList(""String_Node_Str"",""String_Node_Str"");
    List<Map<String,Object>> data=new ArrayList<>();
    for (    ColumnNameTypeValue columnValue : columnsValues) {
      Map<String,Object> row=new HashMap<>();
      row.put(""String_Node_Str"",columnValue.getColumn());
      row.put(""String_Node_Str"",columnValue.getType());
      data.add(row);
    }
    return TableRenderer.renderMapDataAsTable(data,columns);
  }
 catch (  StratioEngineOperationException|StratioEngineConnectionException e) {
    throw new StreamingShellException(e);
  }
}",0.926605504587156
112653,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String insert(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName,@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true) final ColumnNameValueList columns){
  try {
    stratioStreamingApi.insertData(streamName,columns);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException|StratioAPISecurityException e) {
    throw new StreamingShellException(e);
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String insert(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName,@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true) final ColumnNameValueList columns){
  try {
    ssaw.api().insertData(streamName,columns);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException|StratioEngineConnectionException|StratioAPISecurityException e) {
    throw new StreamingShellException(e);
  }
}",0.9495798319327732
112654,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String alter(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName,@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true) final ColumnNameTypeList columns){
  try {
    stratioStreamingApi.alterStream(streamName,columns);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException|StratioAPISecurityException|StratioEngineOperationException e) {
    throw new StreamingShellException(e);
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String alter(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName,@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true) final ColumnNameTypeList columns){
  try {
    ssaw.api().alterStream(streamName,columns);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException|StratioEngineConnectionException|StratioAPISecurityException|StratioEngineOperationException e) {
    throw new StreamingShellException(e);
  }
}",0.952076677316294
112655,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String saveMongoStart(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    ssaw.api().saveToMongo(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException|StratioEngineConnectionException e) {
    throw new StreamingShellException(e);
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String saveMongoStart(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    ssaw.api().saveToMongo(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioStreamingException e) {
    throw new StreamingShellException(e);
  }
}",0.8656387665198237
112656,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String saveMongoStop(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    ssaw.api().stopSaveToMongo(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException|StratioEngineConnectionException e) {
    throw new StreamingShellException(e);
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String saveMongoStop(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    ssaw.api().stopSaveToMongo(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioStreamingException e) {
    throw new StreamingShellException(e);
  }
}",0.8665207877461707
112657,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String saveCassandraStart(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    ssaw.api().saveToCassandra(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException|StratioEngineConnectionException e) {
    throw new StreamingShellException(e);
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String saveCassandraStart(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    ssaw.api().saveToCassandra(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioStreamingException e) {
    throw new StreamingShellException(e);
  }
}",0.8679653679653679
112658,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String listenStart(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    ssaw.api().listenStream(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException|StratioEngineConnectionException|StratioAPISecurityException e) {
    throw new StreamingShellException(e);
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String listenStart(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    ssaw.api().listenStream(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioStreamingException e) {
    throw new StreamingShellException(e);
  }
}",0.8390557939914163
112659,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String indexStop(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    ssaw.api().stopIndexStream(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException|StratioEngineConnectionException e) {
    throw new StreamingShellException(e);
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String indexStop(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    ssaw.api().stopIndexStream(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioStreamingException e) {
    throw new StreamingShellException(e);
  }
}",0.8653421633554084
112660,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String saveCassandraStop(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    ssaw.api().stopSaveToCassandra(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException|StratioEngineConnectionException e) {
    throw new StreamingShellException(e);
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String saveCassandraStop(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    ssaw.api().stopSaveToCassandra(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioStreamingException e) {
    throw new StreamingShellException(e);
  }
}",0.8688172043010752
112661,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String indexStart(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    ssaw.api().indexStream(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException|StratioEngineConnectionException e) {
    throw new StreamingShellException(e);
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String indexStart(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    ssaw.api().indexStream(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioStreamingException e) {
    throw new StreamingShellException(e);
  }
}",0.8644444444444445
112662,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String listenStop(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    ssaw.api().stopListenStream(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException|StratioEngineConnectionException|StratioAPISecurityException e) {
    throw new StreamingShellException(e);
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String listenStop(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    ssaw.api().stopListenStream(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioStreamingException e) {
    throw new StreamingShellException(e);
  }
}",0.8400852878464818
112663,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String drop(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName,@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true) final String queryId){
  try {
    ssaw.api().removeQuery(streamName,queryId);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"".concat(queryId));
  }
 catch (  StratioEngineStatusException|StratioEngineOperationException|StratioEngineConnectionException e) {
    throw new StreamingShellException(e);
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String drop(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName,@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true) final String queryId){
  try {
    ssaw.api().removeQuery(streamName,queryId);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"".concat(queryId));
  }
 catch (  StratioStreamingException e) {
    throw new StreamingShellException(e);
  }
}",0.8670120898100173
112664,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String create(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName,@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true) final String query){
  try {
    String queryId=ssaw.api().addQuery(streamName,query);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"".concat(queryId));
  }
 catch (  StratioEngineStatusException|StratioAPISecurityException|StratioEngineOperationException|StratioEngineConnectionException e) {
    throw new StreamingShellException(e);
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String create(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName,@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true) final String query){
  try {
    String queryId=ssaw.api().addQuery(streamName,query);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"".concat(queryId));
  }
 catch (  StratioStreamingException e) {
    throw new StreamingShellException(e);
  }
}",0.8490878938640133
112665,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String drop(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    cachedStreamsDAO.dropStream(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException|StratioAPISecurityException|StratioEngineOperationException|StratioEngineConnectionException e) {
    throw new StreamingShellException(e);
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String drop(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    cachedStreamsDAO.dropStream(streamName);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioStreamingException e) {
    throw new StreamingShellException(e);
  }
}",0.8100208768267223
112666,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String listQuerys(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    List<ColumnNameTypeValue> columnsValues=ssaw.api().columnsFromStream(streamName);
    List<String> columns=Arrays.asList(""String_Node_Str"",""String_Node_Str"");
    List<Map<String,Object>> data=new ArrayList<>();
    for (    ColumnNameTypeValue columnValue : columnsValues) {
      Map<String,Object> row=new HashMap<>();
      row.put(""String_Node_Str"",columnValue.getColumn());
      row.put(""String_Node_Str"",columnValue.getType());
      data.add(row);
    }
    return TableRenderer.renderMapDataAsTable(data,columns);
  }
 catch (  StratioEngineOperationException|StratioEngineConnectionException e) {
    throw new StreamingShellException(e);
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String listQuerys(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName){
  try {
    List<ColumnNameTypeValue> columnsValues=ssaw.api().columnsFromStream(streamName);
    List<String> columns=Arrays.asList(""String_Node_Str"",""String_Node_Str"");
    List<Map<String,Object>> data=new ArrayList<>();
    for (    ColumnNameTypeValue columnValue : columnsValues) {
      Map<String,Object> row=new HashMap<>();
      row.put(""String_Node_Str"",columnValue.getColumn());
      row.put(""String_Node_Str"",columnValue.getType());
      data.add(row);
    }
    return TableRenderer.renderMapDataAsTable(data,columns);
  }
 catch (  StratioStreamingException e) {
    throw new StreamingShellException(e);
  }
}",0.927703875072296
112667,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String create(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true) final String streamName,@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true) final ColumnNameTypeList columns){
  try {
    cachedStreamsDAO.newStream(streamName,columns);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException|StratioAPISecurityException|StratioEngineOperationException|StratioEngineConnectionException e) {
    throw new StreamingShellException(e);
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String create(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true) final String streamName,@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true) final ColumnNameTypeList columns){
  try {
    cachedStreamsDAO.newStream(streamName,columns);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioStreamingException e) {
    throw new StreamingShellException(e);
  }
}",0.8383658969804618
112668,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String insert(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName,@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true) final ColumnNameValueList columns){
  try {
    ssaw.api().insertData(streamName,columns);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException|StratioEngineConnectionException|StratioAPISecurityException e) {
    throw new StreamingShellException(e);
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String insert(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName,@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true) final ColumnNameValueList columns){
  try {
    ssaw.api().insertData(streamName,columns);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioStreamingException e) {
    throw new StreamingShellException(e);
  }
}",0.8695652173913043
112669,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String alter(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName,@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true) final ColumnNameTypeList columns){
  try {
    ssaw.api().alterStream(streamName,columns);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioEngineStatusException|StratioEngineConnectionException|StratioAPISecurityException|StratioEngineOperationException e) {
    throw new StreamingShellException(e);
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public String alter(@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true,optionContext=""String_Node_Str"") final String streamName,@CliOption(key={""String_Node_Str""},help=""String_Node_Str"",mandatory=true) final ColumnNameTypeList columns){
  try {
    ssaw.api().alterStream(streamName,columns);
    return ""String_Node_Str"".concat(streamName).concat(""String_Node_Str"");
  }
 catch (  StratioStreamingException e) {
    throw new StreamingShellException(e);
  }
}",0.8457627118644068
112670,"public static void main(String[] args) throws IOException, NumberFormatException, InterruptedException {
  if (args.length < 4) {
    log.info(""String_Node_Str"");
  }
 else {
    Producer<String,String> producer=new Producer<String,String>(createProducerConfig(args[3]));
    Gson gson=new Gson();
    Reader in=new FileReader(args[0]);
    CSVParser parser=CSVFormat.DEFAULT.parse(in);
    List<String> columnNames=new ArrayList<>();
    for (    CSVRecord csvRecord : parser.getRecords()) {
      if (columnNames.size() == 0) {
        Iterator<String> iterator=csvRecord.iterator();
        while (iterator.hasNext()) {
          columnNames.add(iterator.next());
        }
      }
 else {
        StratioStreamingMessage message=new StratioStreamingMessage();
        message.setOperation(STREAM_OPERATIONS.MANIPULATION.INSERT);
        message.setStreamName(args[1]);
        message.setTimestamp(System.currentTimeMillis());
        message.setSession_id(String.valueOf(System.currentTimeMillis()));
        message.setRequest_id(String.valueOf(System.currentTimeMillis()));
        message.setRequest(""String_Node_Str"");
        List<ColumnNameTypeValue> sensorData=new ArrayList<>();
        for (int i=0; i < columnNames.size(); i++) {
          Object value=null;
          try {
            value=Double.valueOf(csvRecord.get(i));
          }
 catch (          NumberFormatException e) {
            value=csvRecord.get(i);
          }
          sensorData.add(new ColumnNameTypeValue(columnNames.get(i),null,value));
        }
        message.setColumns(sensorData);
        String json=gson.toJson(message);
        log.info(""String_Node_Str"",json);
        producer.send(new KeyedMessage<String,String>(InternalTopic.TOPIC_DATA.getTopicName(),json));
        log.info(""String_Node_Str"",args[2]);
        Thread.sleep(Long.valueOf(args[2]));
      }
    }
    log.info(""String_Node_Str"");
  }
}","public static void main(String[] args) throws IOException, NumberFormatException, InterruptedException {
  if (args.length < 4) {
    log.info(""String_Node_Str"");
  }
 else {
    Producer<String,String> producer=new Producer<String,String>(createProducerConfig(args[3]));
    Gson gson=new Gson();
    Reader in=new FileReader(args[0]);
    CSVParser parser=CSVFormat.DEFAULT.parse(in);
    List<String> columnNames=new ArrayList<>();
    for (    CSVRecord csvRecord : parser.getRecords()) {
      if (columnNames.size() == 0) {
        Iterator<String> iterator=csvRecord.iterator();
        while (iterator.hasNext()) {
          columnNames.add(iterator.next());
        }
      }
 else {
        StratioStreamingMessage message=new StratioStreamingMessage();
        message.setOperation(STREAM_OPERATIONS.MANIPULATION.INSERT.toLowerCase());
        message.setStreamName(args[1]);
        message.setTimestamp(System.currentTimeMillis());
        message.setSession_id(String.valueOf(System.currentTimeMillis()));
        message.setRequest_id(String.valueOf(System.currentTimeMillis()));
        message.setRequest(""String_Node_Str"");
        List<ColumnNameTypeValue> sensorData=new ArrayList<>();
        for (int i=0; i < columnNames.size(); i++) {
          Object value=null;
          try {
            value=Double.valueOf(csvRecord.get(i));
          }
 catch (          NumberFormatException e) {
            value=csvRecord.get(i);
          }
          sensorData.add(new ColumnNameTypeValue(columnNames.get(i),null,value));
        }
        message.setColumns(sensorData);
        String json=gson.toJson(message);
        log.info(""String_Node_Str"",json);
        producer.send(new KeyedMessage<String,String>(InternalTopic.TOPIC_DATA.getTopicName(),STREAM_OPERATIONS.MANIPULATION.INSERT,json));
        log.info(""String_Node_Str"",args[2]);
        Thread.sleep(Long.valueOf(args[2]));
      }
    }
    log.info(""String_Node_Str"");
  }
}",0.9865494050698396
112671,"public CassandraPersistenceStoreModel(Map<String,StreamStatusDTO> streamStatuses,byte[] siddhiSnapshot){
  this.streamStatuses=streamStatuses;
  this.siddhiSnapshot=siddhiSnapshot;
}","public CassandraPersistenceStoreModel(Map<String,StreamStatusDTO> streamStatuses,byte[] siddhiSnapshot){
  this.streamStatuses=streamStatuses;
  this.siddhiSnapshot=siddhiSnapshot.clone();
}",0.978494623655914
112672,"@Override protected boolean startAction(StratioStreamingMessage message) throws RequestValidationException {
  List<StratioStreamingMessage> existingStreams=getStreamOperationService().list();
  try {
    ZKUtils.getZKUtils(getZookeeperHost()).createZNodeJsonReply(message,new ListStreamsMessage(existingStreams.size(),System.currentTimeMillis(),existingStreams));
  }
 catch (  Exception e) {
    throw new RequestValidationException(ReplyCode.KO_GENERAL_ERROR.getCode(),e);
  }
  return false;
}","@Override protected boolean startAction(StratioStreamingMessage message) throws RequestValidationException {
  List<StratioStreamingMessage> existingStreams=getStreamOperationService().list();
  try {
    ZKUtils.getZKUtils(getZookeeperHost()).createZNodeJsonReply(message,new ListStreamsMessage(existingStreams.size(),System.currentTimeMillis(),existingStreams));
  }
 catch (  Exception e) {
    throw new RequestValidationException(ReplyCode.KO_GENERAL_ERROR.getCode(),e.getMessage());
  }
  return false;
}",0.987090367428004
112673,"/** 
 * - Launch the main process: spark context, kafkaInputDstream and siddhi CEP engine - Filter the incoming messages (kafka) by key in order to separate the different commands - Parse the request contained in the payload - execute related command for each request
 * @param sparkMaster
 * @param zkCluster
 * @param kafkaCluster
 * @param topics
 * @throws Exception
 */
private static void launchStratioStreamingEngine() throws Exception {
  ConfigurationContext cc=new ConfigurationContext();
  String topics=BUS.TOPICS;
  ZKUtils.getZKUtils(cc.getZookeeperHostsQuorum()).createEphemeralZNode(STREAMING.ZK_BASE_PATH + ""String_Node_Str"" + ""String_Node_Str"",String.valueOf(System.currentTimeMillis()).getBytes());
  streamingBaseContext=new JavaStreamingContext(cc.getSparkHost(),StreamingEngine.class.getName(),new Duration(cc.getStreamingBatchTime()));
  streamingBaseContext.sparkContext().getConf().setJars(JavaStreamingContext.jarOfClass(StreamingEngine.class));
  KeepPayloadFromMessageFunction keepPayloadFromMessageFunction=new KeepPayloadFromMessageFunction();
  CreateStreamFunction createStreamFunction=new CreateStreamFunction(getSiddhiManager(),cc.getZookeeperHostsQuorum());
  AlterStreamFunction alterStreamFunction=new AlterStreamFunction(getSiddhiManager(),cc.getZookeeperHostsQuorum());
  InsertIntoStreamFunction insertIntoStreamFunction=new InsertIntoStreamFunction(getSiddhiManager(),cc.getZookeeperHostsQuorum());
  AddQueryToStreamFunction addQueryToStreamFunction=new AddQueryToStreamFunction(getSiddhiManager(),cc.getZookeeperHostsQuorum());
  ListenStreamFunction listenStreamFunction=new ListenStreamFunction(getSiddhiManager(),cc.getZookeeperHostsQuorum(),cc.getKafkaHostsQuorum());
  ListStreamsFunction listStreamsFunction=new ListStreamsFunction(getSiddhiManager(),cc.getZookeeperHostsQuorum());
  SaveToCassandraStreamFunction saveToCassandraStreamFunction=new SaveToCassandraStreamFunction(getSiddhiManager(),cc.getZookeeperHostsQuorum(),cc.getCassandraHostsQuorum());
  Map<String,Integer> topicMap=new HashMap<String,Integer>();
  String[] topic_list=topics.split(""String_Node_Str"");
  HostAndPort kafkaHostAndPort=HostAndPort.fromString(cc.getKafkaHosts().get(0));
  TopicService topicService=new KafkaTopicService(cc.getZookeeperHostsQuorum(),kafkaHostAndPort.getHostText(),kafkaHostAndPort.getPort(),cc.getKafkaConnectionTimeout(),cc.getKafkaSessionTimeout());
  for (  String topic : topic_list) {
    topicService.createTopicIfNotExist(topic,cc.getKafkaReplicationFactor(),cc.getKafkaPartitions());
    Integer partitions=topicService.getNumPartitionsForTopic(topic);
    if (partitions == 0) {
      partitions=cc.getKafkaPartitions();
    }
    topicMap.put(topic,partitions);
  }
  JavaPairDStream<String,String> messages=KafkaUtils.createStream(streamingBaseContext,cc.getZookeeperHostsQuorum(),BUS.STREAMING_GROUP_ID,topicMap);
  messages.cache();
  if (cc.getElasticSearchHost() != null) {
    IndexStreamFunction indexStreamFunction=new IndexStreamFunction(getSiddhiManager(),cc.getZookeeperHostsQuorum(),cc.getElasticSearchHost(),cc.getElasticSearchPort());
    JavaDStream<StratioStreamingMessage> streamToIndexer_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.ACTION.INDEX)).map(keepPayloadFromMessageFunction);
    JavaDStream<StratioStreamingMessage> stopStreamToIndexer_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.ACTION.STOP_INDEX)).map(keepPayloadFromMessageFunction);
    streamToIndexer_requests.foreachRDD(indexStreamFunction);
    stopStreamToIndexer_requests.foreachRDD(indexStreamFunction);
  }
 else {
    logger.warn(""String_Node_Str"");
  }
  if (cc.getMongoHost() != null) {
    SaveToMongoStreamFunction saveToMongoStreamFunction=new SaveToMongoStreamFunction(getSiddhiManager(),cc.getZookeeperHostsQuorum(),cc.getMongoHost(),cc.getMongoPort(),cc.getMongoUsername(),cc.getMongoPassword());
    JavaDStream<StratioStreamingMessage> saveToMongo_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.ACTION.SAVETO_MONGO)).map(keepPayloadFromMessageFunction);
    JavaDStream<StratioStreamingMessage> stop_saveToMongo_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.ACTION.STOP_SAVETO_MONGO)).map(keepPayloadFromMessageFunction);
    saveToMongo_requests.foreachRDD(saveToMongoStreamFunction);
    stop_saveToMongo_requests.foreach(saveToMongoStreamFunction);
  }
 else {
    logger.warn(""String_Node_Str"");
  }
  JavaDStream<StratioStreamingMessage> create_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.DEFINITION.CREATE)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> alter_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.DEFINITION.ALTER)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> insert_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.MANIPULATION.INSERT)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> add_query_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.DEFINITION.ADD_QUERY)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> remove_query_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.DEFINITION.REMOVE_QUERY)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> listen_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.ACTION.LISTEN)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> stop_listen_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.ACTION.STOP_LISTEN)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> saveToCassandra_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.ACTION.SAVETO_CASSANDRA)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> stop_saveToCassandra_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.ACTION.STOP_SAVETO_CASSANDRA)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> list_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.MANIPULATION.LIST)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> drop_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.DEFINITION.DROP)).map(keepPayloadFromMessageFunction);
  create_requests.foreachRDD(createStreamFunction);
  alter_requests.foreachRDD(alterStreamFunction);
  insert_requests.foreachRDD(insertIntoStreamFunction);
  add_query_requests.foreachRDD(addQueryToStreamFunction);
  remove_query_requests.foreachRDD(addQueryToStreamFunction);
  listen_requests.foreachRDD(listenStreamFunction);
  stop_listen_requests.foreachRDD(listenStreamFunction);
  saveToCassandra_requests.foreachRDD(saveToCassandraStreamFunction);
  stop_saveToCassandra_requests.foreach(saveToCassandraStreamFunction);
  list_requests.foreachRDD(listStreamsFunction);
  drop_requests.foreachRDD(createStreamFunction);
  if (cc.isAuditEnabled() || cc.isStatsEnabled()) {
    JavaDStream<StratioStreamingMessage> allRequests=create_requests.union(alter_requests).union(insert_requests).union(add_query_requests).union(remove_query_requests).union(listen_requests).union(stop_listen_requests).union(saveToCassandra_requests).union(list_requests).union(drop_requests);
    if (cc.isAuditEnabled()) {
      SaveRequestsToAuditLogFunction saveRequestsToAuditLogFunction=new SaveRequestsToAuditLogFunction(getSiddhiManager(),cc.getZookeeperHostsQuorum(),cc.getKafkaHostsQuorum(),cc.getCassandraHostsQuorum());
      allRequests.window(new Duration(2000),new Duration(6000)).foreachRDD(saveRequestsToAuditLogFunction);
    }
    if (cc.isStatsEnabled()) {
      CollectRequestForStatsFunction collectRequestForStatsFunction=new CollectRequestForStatsFunction(getSiddhiManager(),cc.getZookeeperHostsQuorum(),cc.getKafkaHostsQuorum());
      allRequests.window(new Duration(2000),new Duration(6000)).foreachRDD(collectRequestForStatsFunction);
    }
  }
  StreamPersistence.saveStreamingEngineStatus(getSiddhiManager());
  if (cc.isPrintStreams()) {
    messages.count().foreach(new Function<JavaRDD<Long>,Void>(){
      private static final long serialVersionUID=-2371501158355376325L;
      @Override public Void call(      JavaRDD<Long> arg0) throws Exception {
        StringBuffer sb=new StringBuffer();
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(siddhiManager.getStreamDefinitions().size());
        sb.append(""String_Node_Str"");
        sb.append(getSiddhiManager().getSiddhiContext().getHazelcastInstance().getMap(STREAMING.STREAM_STATUS_MAP).size());
        sb.append(""String_Node_Str"");
        for (        StreamDefinition streamMetaData : getSiddhiManager().getStreamDefinitions()) {
          StringBuffer streamDefinition=new StringBuffer();
          streamDefinition.append(streamMetaData.getStreamId());
          for (          Attribute column : streamMetaData.getAttributeList()) {
            streamDefinition.append(""String_Node_Str"" + column.getName() + ""String_Node_Str""+ column.getType());
          }
          if (StreamSharedStatus.getStreamStatus(streamMetaData.getStreamId(),getSiddhiManager()) != null) {
            HashMap<String,QueryDTO> attachedQueries=StreamSharedStatus.getStreamStatus(streamMetaData.getStreamId(),getSiddhiManager()).getAddedQueries();
            streamDefinition.append(""String_Node_Str"" + attachedQueries.size() + ""String_Node_Str"");
            for (            String queryId : attachedQueries.keySet()) {
              streamDefinition.append(queryId + ""String_Node_Str"");
            }
            streamDefinition.append(""String_Node_Str"" + StreamSharedStatus.getStreamStatus(streamMetaData.getStreamId(),getSiddhiManager()).isUserDefined() + ""String_Node_Str"");
            streamDefinition.append(""String_Node_Str"" + StreamSharedStatus.getStreamStatus(streamMetaData.getStreamId(),getSiddhiManager()).isActionEnabled(StreamAction.LISTEN) + ""String_Node_Str"");
          }
          sb.append(""String_Node_Str"".concat(streamDefinition.toString()).concat(""String_Node_Str""));
        }
        sb.append(""String_Node_Str"");
        logger.info(sb.toString());
        StreamPersistence.saveStreamingEngineStatus(getSiddhiManager());
        return null;
      }
    }
);
  }
  streamingBaseContext.start();
  logger.info(""String_Node_Str"",new Date());
  streamingBaseContext.awaitTermination();
}","/** 
 * - Launch the main process: spark context, kafkaInputDstream and siddhi CEP engine - Filter the incoming messages (kafka) by key in order to separate the different commands - Parse the request contained in the payload - execute related command for each request
 * @param sparkMaster
 * @param zkCluster
 * @param kafkaCluster
 * @param topics
 * @throws Exception
 */
private static void launchStratioStreamingEngine() throws Exception {
  ConfigurationContext cc=new ConfigurationContext();
  String topics=BUS.TOPICS;
  ZKUtils.getZKUtils(cc.getZookeeperHostsQuorum()).createEphemeralZNode(STREAMING.ZK_BASE_PATH + ""String_Node_Str"" + ""String_Node_Str"",String.valueOf(System.currentTimeMillis()).getBytes());
  streamingBaseContext=new JavaStreamingContext(cc.getSparkHost(),StreamingEngine.class.getName(),new Duration(cc.getStreamingBatchTime()));
  streamingBaseContext.sparkContext().getConf().setJars(JavaStreamingContext.jarOfClass(StreamingEngine.class));
  KeepPayloadFromMessageFunction keepPayloadFromMessageFunction=new KeepPayloadFromMessageFunction();
  CreateStreamFunction createStreamFunction=new CreateStreamFunction(getSiddhiManager(),cc.getZookeeperHostsQuorum());
  AlterStreamFunction alterStreamFunction=new AlterStreamFunction(getSiddhiManager(),cc.getZookeeperHostsQuorum());
  InsertIntoStreamFunction insertIntoStreamFunction=new InsertIntoStreamFunction(getSiddhiManager(),cc.getZookeeperHostsQuorum());
  AddQueryToStreamFunction addQueryToStreamFunction=new AddQueryToStreamFunction(getSiddhiManager(),cc.getZookeeperHostsQuorum());
  ListenStreamFunction listenStreamFunction=new ListenStreamFunction(getSiddhiManager(),cc.getZookeeperHostsQuorum(),cc.getKafkaHostsQuorum());
  ListStreamsFunction listStreamsFunction=new ListStreamsFunction(getSiddhiManager(),cc.getZookeeperHostsQuorum());
  SaveToCassandraStreamFunction saveToCassandraStreamFunction=new SaveToCassandraStreamFunction(getSiddhiManager(),cc.getZookeeperHostsQuorum(),cc.getCassandraHostsQuorum());
  Map<String,Integer> topicMap=new HashMap<String,Integer>();
  String[] topicList=topics.split(""String_Node_Str"");
  HostAndPort kafkaHostAndPort=HostAndPort.fromString(cc.getKafkaHosts().get(0));
  TopicService topicService=new KafkaTopicService(cc.getZookeeperHostsQuorum(),kafkaHostAndPort.getHostText(),kafkaHostAndPort.getPort(),cc.getKafkaConnectionTimeout(),cc.getKafkaSessionTimeout());
  for (  String topic : topicList) {
    topicService.createTopicIfNotExist(topic,cc.getKafkaReplicationFactor(),cc.getKafkaPartitions());
    Integer partitions=topicService.getNumPartitionsForTopic(topic);
    if (partitions == 0) {
      partitions=cc.getKafkaPartitions();
    }
    topicMap.put(topic,partitions);
  }
  JavaPairDStream<String,String> messages=KafkaUtils.createStream(streamingBaseContext,cc.getZookeeperHostsQuorum(),BUS.STREAMING_GROUP_ID,topicMap);
  messages.cache();
  if (cc.getElasticSearchHost() != null) {
    IndexStreamFunction indexStreamFunction=new IndexStreamFunction(getSiddhiManager(),cc.getZookeeperHostsQuorum(),cc.getElasticSearchHost(),cc.getElasticSearchPort());
    JavaDStream<StratioStreamingMessage> streamToIndexerRequests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.ACTION.INDEX)).map(keepPayloadFromMessageFunction);
    JavaDStream<StratioStreamingMessage> stopStreamToIndexerRequests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.ACTION.STOP_INDEX)).map(keepPayloadFromMessageFunction);
    streamToIndexerRequests.foreachRDD(indexStreamFunction);
    stopStreamToIndexerRequests.foreachRDD(indexStreamFunction);
  }
 else {
    logger.warn(""String_Node_Str"");
  }
  if (cc.getMongoHost() != null) {
    SaveToMongoStreamFunction saveToMongoStreamFunction=new SaveToMongoStreamFunction(getSiddhiManager(),cc.getZookeeperHostsQuorum(),cc.getMongoHost(),cc.getMongoPort(),cc.getMongoUsername(),cc.getMongoPassword());
    JavaDStream<StratioStreamingMessage> saveToMongoRequests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.ACTION.SAVETO_MONGO)).map(keepPayloadFromMessageFunction);
    JavaDStream<StratioStreamingMessage> stopSaveToMongoRequests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.ACTION.STOP_SAVETO_MONGO)).map(keepPayloadFromMessageFunction);
    saveToMongoRequests.foreachRDD(saveToMongoStreamFunction);
    stopSaveToMongoRequests.foreach(saveToMongoStreamFunction);
  }
 else {
    logger.warn(""String_Node_Str"");
  }
  JavaDStream<StratioStreamingMessage> createRequests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.DEFINITION.CREATE)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> alterRequests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.DEFINITION.ALTER)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> insertRequests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.MANIPULATION.INSERT)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> addQueryRequests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.DEFINITION.ADD_QUERY)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> removeQueryRequests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.DEFINITION.REMOVE_QUERY)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> listenRequests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.ACTION.LISTEN)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> stopListenRequests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.ACTION.STOP_LISTEN)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> saveToCassandraRequests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.ACTION.SAVETO_CASSANDRA)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> stopSaveToCassandraRequests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.ACTION.STOP_SAVETO_CASSANDRA)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> listRequests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.MANIPULATION.LIST)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> dropRequests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.DEFINITION.DROP)).map(keepPayloadFromMessageFunction);
  createRequests.foreachRDD(createStreamFunction);
  alterRequests.foreachRDD(alterStreamFunction);
  insertRequests.foreachRDD(insertIntoStreamFunction);
  addQueryRequests.foreachRDD(addQueryToStreamFunction);
  removeQueryRequests.foreachRDD(addQueryToStreamFunction);
  listenRequests.foreachRDD(listenStreamFunction);
  stopListenRequests.foreachRDD(listenStreamFunction);
  saveToCassandraRequests.foreachRDD(saveToCassandraStreamFunction);
  stopSaveToCassandraRequests.foreach(saveToCassandraStreamFunction);
  listRequests.foreachRDD(listStreamsFunction);
  dropRequests.foreachRDD(createStreamFunction);
  if (cc.isAuditEnabled() || cc.isStatsEnabled()) {
    JavaDStream<StratioStreamingMessage> allRequests=createRequests.union(alterRequests).union(insertRequests).union(addQueryRequests).union(removeQueryRequests).union(listenRequests).union(stopListenRequests).union(saveToCassandraRequests).union(listRequests).union(dropRequests);
    if (cc.isAuditEnabled()) {
      SaveRequestsToAuditLogFunction saveRequestsToAuditLogFunction=new SaveRequestsToAuditLogFunction(getSiddhiManager(),cc.getZookeeperHostsQuorum(),cc.getKafkaHostsQuorum(),cc.getCassandraHostsQuorum());
      allRequests.window(new Duration(2000),new Duration(6000)).foreachRDD(saveRequestsToAuditLogFunction);
    }
    if (cc.isStatsEnabled()) {
      CollectRequestForStatsFunction collectRequestForStatsFunction=new CollectRequestForStatsFunction(getSiddhiManager(),cc.getZookeeperHostsQuorum(),cc.getKafkaHostsQuorum());
      allRequests.window(new Duration(2000),new Duration(6000)).foreachRDD(collectRequestForStatsFunction);
    }
  }
  StreamPersistence.saveStreamingEngineStatus(getSiddhiManager());
  if (cc.isPrintStreams()) {
    messages.count().foreach(new Function<JavaRDD<Long>,Void>(){
      private static final long serialVersionUID=-2371501158355376325L;
      @Override public Void call(      JavaRDD<Long> arg0) throws Exception {
        StringBuffer sb=new StringBuffer();
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(siddhiManager.getStreamDefinitions().size());
        sb.append(""String_Node_Str"");
        sb.append(getSiddhiManager().getSiddhiContext().getHazelcastInstance().getMap(STREAMING.STREAM_STATUS_MAP).size());
        sb.append(""String_Node_Str"");
        for (        StreamDefinition streamMetaData : getSiddhiManager().getStreamDefinitions()) {
          StringBuffer streamDefinition=new StringBuffer();
          streamDefinition.append(streamMetaData.getStreamId());
          for (          Attribute column : streamMetaData.getAttributeList()) {
            streamDefinition.append(""String_Node_Str"" + column.getName() + ""String_Node_Str""+ column.getType());
          }
          if (StreamSharedStatus.getStreamStatus(streamMetaData.getStreamId(),getSiddhiManager()) != null) {
            HashMap<String,QueryDTO> attachedQueries=StreamSharedStatus.getStreamStatus(streamMetaData.getStreamId(),getSiddhiManager()).getAddedQueries();
            streamDefinition.append(""String_Node_Str"" + attachedQueries.size() + ""String_Node_Str"");
            for (            String queryId : attachedQueries.keySet()) {
              streamDefinition.append(queryId + ""String_Node_Str"");
            }
            streamDefinition.append(""String_Node_Str"" + StreamSharedStatus.getStreamStatus(streamMetaData.getStreamId(),getSiddhiManager()).isUserDefined() + ""String_Node_Str"");
            streamDefinition.append(""String_Node_Str"" + StreamSharedStatus.getStreamStatus(streamMetaData.getStreamId(),getSiddhiManager()).isActionEnabled(StreamAction.LISTEN) + ""String_Node_Str"");
          }
          sb.append(""String_Node_Str"".concat(streamDefinition.toString()).concat(""String_Node_Str""));
        }
        sb.append(""String_Node_Str"");
        logger.info(sb.toString());
        StreamPersistence.saveStreamingEngineStatus(getSiddhiManager());
        return null;
      }
    }
);
  }
  streamingBaseContext.start();
  logger.info(""String_Node_Str"",new Date());
  streamingBaseContext.awaitTermination();
}",0.981840250221745
112674,"@Override public void receive(Event[] events){
  if (running) {
    List<StratioStreamingMessage> collected_events=Lists.newArrayList();
    for (    Event e : events) {
      if (e instanceof InEvent) {
        InEvent ie=(InEvent)e;
        List<ColumnNameTypeValue> columns=Lists.newArrayList();
        for (        Attribute column : streamDefinition.getAttributeList()) {
          if (ie.getData().length >= streamDefinition.getAttributePosition(column.getName()) + 1) {
            columns.add(new ColumnNameTypeValue(column.getName(),SiddhiUtils.encodeSiddhiType(column.getType()),ie.getData(streamDefinition.getAttributePosition(column.getName()))));
          }
        }
        collected_events.add(new StratioStreamingMessage(streamDefinition.getStreamId(),ie.getTimeStamp(),columns));
      }
    }
    persistEventsToCassandra(collected_events);
  }
}","@Override public void receive(Event[] events){
  if (running) {
    List<StratioStreamingMessage> collectedEvents=Lists.newArrayList();
    for (    Event e : events) {
      if (e instanceof InEvent) {
        InEvent ie=(InEvent)e;
        List<ColumnNameTypeValue> columns=Lists.newArrayList();
        for (        Attribute column : streamDefinition.getAttributeList()) {
          if (ie.getData().length >= streamDefinition.getAttributePosition(column.getName()) + 1) {
            columns.add(new ColumnNameTypeValue(column.getName(),SiddhiUtils.encodeSiddhiType(column.getType()),ie.getData(streamDefinition.getAttributePosition(column.getName()))));
          }
        }
        collectedEvents.add(new StratioStreamingMessage(streamDefinition.getStreamId(),ie.getTimeStamp(),columns));
      }
    }
    persistEventsToCassandra(collectedEvents);
  }
}",0.9948006932409011
112675,"private void persistEventsToCassandra(List<StratioStreamingMessage> collected_events){
  List<Insert> statements=Lists.newArrayList();
  HashMap<String,String> fieldsAndTypes=getStreamFieldsAndTypes();
  for (  StratioStreamingMessage event : collected_events) {
    if (fieldsAndTypes.size() > (cassandraSession.getCluster().getMetadata().getKeyspace(STREAMING.STREAMING_KEYSPACE_NAME).getTable(streamDefinition.getStreamId()).getColumns().size() - 1)) {
      logger.debug(""String_Node_Str"" + generateCassandraAlterTableForStream());
      cassandraSession.execute(generateCassandraAlterTableForStream());
    }
    Object[] values=new Object[event.getColumns().size() + 1];
    String[] fields=new String[fieldsAndTypes.size() + 1];
    fields[0]=""String_Node_Str"";
    values[0]=UUIDs.startOf(System.currentTimeMillis());
    int i=1;
    for (    String field : fieldsAndTypes.keySet()) {
      fields[i]=field;
      values[i]=event.getColumns().get(event.getColumns().indexOf(new ColumnNameTypeValue(field,null,null))).getValue();
      i++;
    }
    Insert hola=com.datastax.driver.core.querybuilder.QueryBuilder.insertInto(STREAMING.STREAMING_KEYSPACE_NAME,streamDefinition.getStreamId()).values(fields,values);
    logger.debug(""String_Node_Str"" + hola.getQueryString());
    statements.add(hola);
  }
  for (  Insert statement : statements) {
    cassandraSession.execute(statement);
  }
}","private void persistEventsToCassandra(List<StratioStreamingMessage> collectedEvents){
  List<Insert> statements=Lists.newArrayList();
  HashMap<String,String> fieldsAndTypes=getStreamFieldsAndTypes();
  for (  StratioStreamingMessage event : collectedEvents) {
    if (fieldsAndTypes.size() > (cassandraSession.getCluster().getMetadata().getKeyspace(STREAMING.STREAMING_KEYSPACE_NAME).getTable(streamDefinition.getStreamId()).getColumns().size() - 1)) {
      logger.debug(""String_Node_Str"" + generateCassandraAlterTableForStream());
      cassandraSession.execute(generateCassandraAlterTableForStream());
    }
    Object[] values=new Object[event.getColumns().size() + 1];
    String[] fields=new String[fieldsAndTypes.size() + 1];
    fields[0]=""String_Node_Str"";
    values[0]=UUIDs.startOf(System.currentTimeMillis());
    int i=1;
    for (    String field : fieldsAndTypes.keySet()) {
      fields[i]=field;
      values[i]=event.getColumns().get(event.getColumns().indexOf(new ColumnNameTypeValue(field,null,null))).getValue();
      i++;
    }
    Insert hola=com.datastax.driver.core.querybuilder.QueryBuilder.insertInto(STREAMING.STREAMING_KEYSPACE_NAME,streamDefinition.getStreamId()).values(fields,values);
    logger.debug(""String_Node_Str"" + hola.getQueryString());
    statements.add(hola);
  }
  for (  Insert statement : statements) {
    cassandraSession.execute(statement);
  }
}",0.9978571428571428
112676,"@Override public void receive(Event[] events){
  if (running) {
    List<StratioStreamingMessage> collected_events=Lists.newArrayList();
    for (    Event e : events) {
      if (e instanceof InEvent) {
        InEvent ie=(InEvent)e;
        List<ColumnNameTypeValue> columns=Lists.newArrayList();
        for (        Attribute column : streamDefinition.getAttributeList()) {
          if (ie.getData().length >= streamDefinition.getAttributePosition(column.getName()) + 1) {
            columns.add(new ColumnNameTypeValue(column.getName(),SiddhiUtils.encodeSiddhiType(column.getType()),ie.getData(streamDefinition.getAttributePosition(column.getName()))));
          }
        }
        collected_events.add(new StratioStreamingMessage(streamDefinition.getStreamId(),ie.getTimeStamp(),columns));
      }
    }
    persistEventsToMongo(collected_events);
  }
}","@Override public void receive(Event[] events){
  if (running) {
    List<StratioStreamingMessage> collectedEvents=Lists.newArrayList();
    for (    Event e : events) {
      if (e instanceof InEvent) {
        InEvent ie=(InEvent)e;
        List<ColumnNameTypeValue> columns=Lists.newArrayList();
        for (        Attribute column : streamDefinition.getAttributeList()) {
          if (ie.getData().length >= streamDefinition.getAttributePosition(column.getName()) + 1) {
            columns.add(new ColumnNameTypeValue(column.getName(),SiddhiUtils.encodeSiddhiType(column.getType()),ie.getData(streamDefinition.getAttributePosition(column.getName()))));
          }
        }
        collectedEvents.add(new StratioStreamingMessage(streamDefinition.getStreamId(),ie.getTimeStamp(),columns));
      }
    }
    persistEventsToMongo(collectedEvents);
  }
}",0.9947765525246662
112677,"private void persistEventsToMongo(List<StratioStreamingMessage> collected_events){
  long time=System.currentTimeMillis();
  Map<String,BulkWriteOperation> elementsToInsert=new HashMap<String,BulkWriteOperation>();
  for (  StratioStreamingMessage event : collected_events) {
    BasicDBObject object=new BasicDBObject(""String_Node_Str"",time);
    for (    ColumnNameTypeValue columnNameTypeValue : event.getColumns()) {
      object.append(columnNameTypeValue.getColumn(),columnNameTypeValue.getValue());
    }
    BulkWriteOperation bulkInsertOperation=elementsToInsert.get(event.getStreamName());
    if (bulkInsertOperation == null) {
      bulkInsertOperation=streamingDb.getCollection(event.getStreamName()).initializeUnorderedBulkOperation();
      elementsToInsert.put(event.getStreamName(),bulkInsertOperation);
      streamingDb.getCollection(event.getStreamName()).createIndex(new BasicDBObject(""String_Node_Str"",-1));
    }
    bulkInsertOperation.insert(object);
  }
  for (  Entry<String,BulkWriteOperation> stratioStreamingMessage : elementsToInsert.entrySet()) {
    stratioStreamingMessage.getValue().execute();
  }
}","private void persistEventsToMongo(List<StratioStreamingMessage> collectedEvents){
  long time=System.currentTimeMillis();
  Map<String,BulkWriteOperation> elementsToInsert=new HashMap<String,BulkWriteOperation>();
  for (  StratioStreamingMessage event : collectedEvents) {
    BasicDBObject object=new BasicDBObject(""String_Node_Str"",time);
    for (    ColumnNameTypeValue columnNameTypeValue : event.getColumns()) {
      object.append(columnNameTypeValue.getColumn(),columnNameTypeValue.getValue());
    }
    BulkWriteOperation bulkInsertOperation=elementsToInsert.get(event.getStreamName());
    if (bulkInsertOperation == null) {
      bulkInsertOperation=streamingDb.getCollection(event.getStreamName()).initializeUnorderedBulkOperation();
      elementsToInsert.put(event.getStreamName(),bulkInsertOperation);
      streamingDb.getCollection(event.getStreamName()).createIndex(new BasicDBObject(""String_Node_Str"",-1));
    }
    bulkInsertOperation.insert(object);
  }
  for (  Entry<String,BulkWriteOperation> stratioStreamingMessage : elementsToInsert.entrySet()) {
    stratioStreamingMessage.getValue().execute();
  }
}",0.997352162400706
112678,"public NodeSnapshot(String nodeID,byte[] data){
  super();
  this.nodeID=nodeID;
  this.data=data;
}","public NodeSnapshot(String nodeID,byte[] data){
  super();
  this.nodeID=nodeID;
  this.data=data.clone();
}",0.9615384615384616
112679,"public StreamToMongoCallback(StreamDefinition streamDefinition,String mongoHost,int mongoPort,String username,String password) throws UnknownHostException {
  this.streamDefinition=streamDefinition;
  running=Boolean.TRUE;
  List<ServerAddress> adresses=Arrays.asList(new ServerAddress(mongoHost,mongoPort));
  if (username != null && password != null) {
    mongoClient=new MongoClient(adresses,Arrays.asList(MongoCredential.createPlainCredential(username,""String_Node_Str"",password.toCharArray())));
  }
 else {
    logger.warn(""String_Node_Str"",username,password);
    mongoClient=new MongoClient(adresses);
  }
  streamingDb=mongoClient.getDB(""String_Node_Str"");
}","public StreamToMongoCallback(StreamDefinition streamDefinition,String mongoHost,int mongoPort,String username,String password) throws UnknownHostException {
  this.streamDefinition=streamDefinition;
  running=Boolean.TRUE;
  List<ServerAddress> adresses=Arrays.asList(new ServerAddress(mongoHost,mongoPort));
  if (username != null && password != null) {
    mongoClient=new MongoClient(adresses,Arrays.asList(MongoCredential.createPlainCredential(username,""String_Node_Str"",password.toCharArray())));
  }
 else {
    logger.warn(""String_Node_Str"",username,password);
    mongoClient=new MongoClient(adresses);
  }
  streamingDb=mongoClient.getDB(STREAMING.STREAMING_KEYSPACE_NAME);
}",0.9659763313609468
112680,"private void persistEventsToMongo(List<StratioStreamingMessage> collected_events){
  long time=System.currentTimeMillis();
  Map<String,BulkWriteOperation> elementsToInsert=new HashMap<String,BulkWriteOperation>();
  for (  StratioStreamingMessage event : collected_events) {
    BasicDBObject object=new BasicDBObject(""String_Node_Str"",time);
    for (    ColumnNameTypeValue columnNameTypeValue : event.getColumns()) {
      object.append(columnNameTypeValue.getColumn(),columnNameTypeValue.getValue());
    }
    BulkWriteOperation bulkInsertOperation=elementsToInsert.get(event.getStreamName());
    if (bulkInsertOperation == null) {
      bulkInsertOperation=elementsToInsert.put(event.getStreamName(),streamingDb.getCollection(event.getStreamName()).initializeUnorderedBulkOperation());
      streamingDb.getCollection(event.getStreamName()).createIndex(new BasicDBObject(""String_Node_Str"",-1));
    }
    bulkInsertOperation.insert(object);
  }
  for (  Entry<String,BulkWriteOperation> stratioStreamingMessage : elementsToInsert.entrySet()) {
    stratioStreamingMessage.getValue().execute();
  }
}","private void persistEventsToMongo(List<StratioStreamingMessage> collected_events){
  long time=System.currentTimeMillis();
  Map<String,BulkWriteOperation> elementsToInsert=new HashMap<String,BulkWriteOperation>();
  for (  StratioStreamingMessage event : collected_events) {
    BasicDBObject object=new BasicDBObject(""String_Node_Str"",time);
    for (    ColumnNameTypeValue columnNameTypeValue : event.getColumns()) {
      object.append(columnNameTypeValue.getColumn(),columnNameTypeValue.getValue());
    }
    BulkWriteOperation bulkInsertOperation=elementsToInsert.get(event.getStreamName());
    if (bulkInsertOperation == null) {
      bulkInsertOperation=streamingDb.getCollection(event.getStreamName()).initializeUnorderedBulkOperation();
      elementsToInsert.put(event.getStreamName(),bulkInsertOperation);
      streamingDb.getCollection(event.getStreamName()).createIndex(new BasicDBObject(""String_Node_Str"",-1));
    }
    bulkInsertOperation.insert(object);
  }
  for (  Entry<String,BulkWriteOperation> stratioStreamingMessage : elementsToInsert.entrySet()) {
    stratioStreamingMessage.getValue().execute();
  }
}",0.9495760821062026
112681,"public ActionBaseFunction(SiddhiManager siddhiManager,String zookeeperHost){
  this.stopValidators=new HashSet<>();
  this.startValidators=new HashSet<>();
  this.siddhiManager=siddhiManager;
  this.zookeeperHost=zookeeperHost;
  startValidators.add(new StreamAllowedValidation(getSiddhiManager()));
  stopValidators.add(new StreamAllowedValidation(getSiddhiManager()));
  addStartRequestsValidations(startValidators);
  addStopRequestsValidations(stopValidators);
}","public ActionBaseFunction(SiddhiManager siddhiManager,String zookeeperHost){
  this.stopValidators=new LinkedHashSet<>();
  this.startValidators=new LinkedHashSet<>();
  this.siddhiManager=siddhiManager;
  this.zookeeperHost=zookeeperHost;
  startValidators.add(new StreamAllowedValidation(getSiddhiManager()));
  stopValidators.add(new StreamAllowedValidation(getSiddhiManager()));
  addStartRequestsValidations(startValidators);
  addStopRequestsValidations(stopValidators);
}",0.9872881355932204
112682,"/** 
 * - Launch the main process: spark context, kafkaInputDstream and siddhi CEP engine - Filter the incoming messages (kafka) by key in order to separate the different commands - Parse the request contained in the payload - execute related command for each request
 * @param sparkMaster
 * @param zkCluster
 * @param kafkaCluster
 * @param topics
 * @throws Exception
 */
private static void launchStratioStreamingEngine(Config config) throws Exception {
  cassandraCluster=config.getString(""String_Node_Str"");
  failOverEnabled=config.getBoolean(""String_Node_Str"");
  String kafkaCluster=config.getString(""String_Node_Str"");
  String zkCluster=config.getString(""String_Node_Str"");
  String elasticSearchUrl=config.getString(""String_Node_Str"");
  boolean enableAuditing=config.getBoolean(""String_Node_Str"");
  boolean enableStats=config.getBoolean(""String_Node_Str"");
  boolean printStreams=config.getBoolean(""String_Node_Str"");
  long streamingBatchTime=config.getDuration(""String_Node_Str"",TimeUnit.MILLISECONDS);
  String topics=BUS.TOPICS;
  ZKUtils.getZKUtils(zkCluster).createEphemeralZNode(STREAMING.ZK_BASE_PATH + ""String_Node_Str"" + ""String_Node_Str"",String.valueOf(System.currentTimeMillis()).getBytes());
  jssc=new JavaStreamingContext(config.getString(""String_Node_Str""),StreamingEngine.class.getName(),new Duration(streamingBatchTime));
  jssc.sparkContext().getConf().setJars(JavaStreamingContext.jarOfClass(StreamingEngine.class));
  KeepPayloadFromMessageFunction keepPayloadFromMessageFunction=new KeepPayloadFromMessageFunction();
  CreateStreamFunction createStreamFunction=new CreateStreamFunction(getSiddhiManager(),zkCluster);
  AlterStreamFunction alterStreamFunction=new AlterStreamFunction(getSiddhiManager(),zkCluster);
  InsertIntoStreamFunction insertIntoStreamFunction=new InsertIntoStreamFunction(getSiddhiManager(),zkCluster);
  AddQueryToStreamFunction addQueryToStreamFunction=new AddQueryToStreamFunction(getSiddhiManager(),zkCluster);
  ListenStreamFunction listenStreamFunction=new ListenStreamFunction(getSiddhiManager(),zkCluster,kafkaCluster);
  CollectRequestForStatsFunction collectRequestForStatsFunction=new CollectRequestForStatsFunction(getSiddhiManager(),zkCluster,kafkaCluster);
  ListStreamsFunction listStreamsFunction=new ListStreamsFunction(getSiddhiManager(),zkCluster);
  SaveRequestsToAuditLogFunction saveRequestsToAuditLogFunction=new SaveRequestsToAuditLogFunction(getSiddhiManager(),zkCluster,kafkaCluster,cassandraCluster,enableAuditing);
  SaveToCassandraStreamFunction saveToCassandraStreamFunction=new SaveToCassandraStreamFunction(getSiddhiManager(),zkCluster,cassandraCluster);
  HostAndPort elasticSearchConnectionData=HostAndPort.fromString(elasticSearchUrl);
  IndexStreamFunction indexStreamFunction=new IndexStreamFunction(getSiddhiManager(),zkCluster,elasticSearchConnectionData.getHostText(),elasticSearchConnectionData.getPortOrDefault(9300));
  Map<String,Integer> topicMap=new HashMap<String,Integer>();
  String[] topic_list=topics.split(""String_Node_Str"");
  HostAndPort kafkaConnectionData=HostAndPort.fromString(kafkaCluster);
  TopicService topicService=new KafkaTopicService(zkCluster,kafkaConnectionData.getHostText(),kafkaConnectionData.getPortOrDefault(9092),config.getInt(""String_Node_Str""),config.getInt(""String_Node_Str""));
  for (  String topic : topic_list) {
    topicService.createTopicIfNotExist(topic,config.getInt(""String_Node_Str""),config.getInt(""String_Node_Str""));
    Integer partitions=topicService.getNumPartitionsForTopic(topic);
    topicMap.put(topic,partitions);
  }
  JavaPairDStream<String,String> messages=KafkaUtils.createStream(jssc,zkCluster,BUS.STREAMING_GROUP_ID,topicMap);
  messages.cache();
  JavaDStream<StratioStreamingMessage> create_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.DEFINITION.CREATE)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> alter_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.DEFINITION.ALTER)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> insert_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.MANIPULATION.INSERT)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> add_query_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.DEFINITION.ADD_QUERY)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> remove_query_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.DEFINITION.REMOVE_QUERY)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> listen_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.ACTION.LISTEN)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> stop_listen_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.ACTION.STOP_LISTEN)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> saveToCassandra_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.ACTION.SAVETO_CASSANDRA)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> stop_saveToCassandra_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.ACTION.STOP_SAVETO_CASSANDRA)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> streamToIndexer_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.ACTION.INDEX)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> stopStreamToIndexer_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.ACTION.STOP_INDEX)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> list_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.MANIPULATION.LIST)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> drop_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.DEFINITION.DROP)).map(keepPayloadFromMessageFunction);
  create_requests.foreachRDD(createStreamFunction);
  alter_requests.foreachRDD(alterStreamFunction);
  insert_requests.foreachRDD(insertIntoStreamFunction);
  add_query_requests.foreachRDD(addQueryToStreamFunction);
  remove_query_requests.foreachRDD(addQueryToStreamFunction);
  listen_requests.foreachRDD(listenStreamFunction);
  stop_listen_requests.foreachRDD(listenStreamFunction);
  saveToCassandra_requests.foreachRDD(saveToCassandraStreamFunction);
  stop_saveToCassandra_requests.foreach(saveToCassandraStreamFunction);
  streamToIndexer_requests.foreachRDD(indexStreamFunction);
  stopStreamToIndexer_requests.foreachRDD(indexStreamFunction);
  list_requests.foreachRDD(listStreamsFunction);
  drop_requests.foreachRDD(createStreamFunction);
  if (enableAuditing || enableStats) {
    JavaDStream<StratioStreamingMessage> allRequests=create_requests.union(alter_requests).union(insert_requests).union(add_query_requests).union(remove_query_requests).union(listen_requests).union(stop_listen_requests).union(saveToCassandra_requests).union(list_requests).union(drop_requests);
    if (enableAuditing) {
      allRequests.foreachRDD(saveRequestsToAuditLogFunction);
    }
    if (enableStats) {
      allRequests.foreachRDD(collectRequestForStatsFunction);
    }
  }
  StreamPersistence.saveStreamingEngineStatus(getSiddhiManager());
  if (printStreams) {
    messages.count().foreach(new Function<JavaRDD<Long>,Void>(){
      private static final long serialVersionUID=-2371501158355376325L;
      @Override public Void call(      JavaRDD<Long> arg0) throws Exception {
        StringBuffer sb=new StringBuffer();
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(siddhiManager.getStreamDefinitions().size());
        sb.append(""String_Node_Str"");
        sb.append(getSiddhiManager().getSiddhiContext().getHazelcastInstance().getMap(STREAMING.STREAM_STATUS_MAP).size());
        sb.append(""String_Node_Str"");
        for (        StreamDefinition streamMetaData : getSiddhiManager().getStreamDefinitions()) {
          StringBuffer streamDefinition=new StringBuffer();
          streamDefinition.append(streamMetaData.getStreamId());
          for (          Attribute column : streamMetaData.getAttributeList()) {
            streamDefinition.append(""String_Node_Str"" + column.getName() + ""String_Node_Str""+ column.getType());
          }
          if (StreamSharedStatus.getStreamStatus(streamMetaData.getStreamId(),getSiddhiManager()) != null) {
            HashMap<String,String> attachedQueries=StreamSharedStatus.getStreamStatus(streamMetaData.getStreamId(),getSiddhiManager()).getAddedQueries();
            streamDefinition.append(""String_Node_Str"" + attachedQueries.size() + ""String_Node_Str"");
            for (            String queryId : attachedQueries.keySet()) {
              streamDefinition.append(queryId + ""String_Node_Str"");
            }
            streamDefinition.append(""String_Node_Str"" + StreamSharedStatus.getStreamStatus(streamMetaData.getStreamId(),getSiddhiManager()).isUserDefined() + ""String_Node_Str"");
            streamDefinition.append(""String_Node_Str"" + StreamSharedStatus.getStreamStatus(streamMetaData.getStreamId(),getSiddhiManager()).isActionEnabled(StreamAction.LISTEN) + ""String_Node_Str"");
          }
          sb.append(""String_Node_Str"".concat(streamDefinition.toString()).concat(""String_Node_Str""));
        }
        sb.append(""String_Node_Str"");
        logger.info(sb.toString());
        StreamPersistence.saveStreamingEngineStatus(getSiddhiManager());
        return null;
      }
    }
);
  }
  jssc.start();
  logger.info(""String_Node_Str"",new Date());
  jssc.awaitTermination();
}","/** 
 * - Launch the main process: spark context, kafkaInputDstream and siddhi CEP engine - Filter the incoming messages (kafka) by key in order to separate the different commands - Parse the request contained in the payload - execute related command for each request
 * @param sparkMaster
 * @param zkCluster
 * @param kafkaCluster
 * @param topics
 * @throws Exception
 */
private static void launchStratioStreamingEngine(Config config) throws Exception {
  cassandraCluster=config.getString(""String_Node_Str"");
  failOverEnabled=config.getBoolean(""String_Node_Str"");
  String kafkaCluster=config.getString(""String_Node_Str"");
  String zkCluster=config.getString(""String_Node_Str"");
  String elasticSearchUrl=config.getString(""String_Node_Str"");
  boolean enableAuditing=config.getBoolean(""String_Node_Str"");
  boolean enableStats=config.getBoolean(""String_Node_Str"");
  boolean printStreams=config.getBoolean(""String_Node_Str"");
  long streamingBatchTime=config.getDuration(""String_Node_Str"",TimeUnit.MILLISECONDS);
  String topics=BUS.TOPICS;
  ZKUtils.getZKUtils(zkCluster).createEphemeralZNode(STREAMING.ZK_BASE_PATH + ""String_Node_Str"" + ""String_Node_Str"",String.valueOf(System.currentTimeMillis()).getBytes());
  jssc=new JavaStreamingContext(config.getString(""String_Node_Str""),StreamingEngine.class.getName(),new Duration(streamingBatchTime));
  jssc.sparkContext().getConf().setJars(JavaStreamingContext.jarOfClass(StreamingEngine.class));
  KeepPayloadFromMessageFunction keepPayloadFromMessageFunction=new KeepPayloadFromMessageFunction();
  CreateStreamFunction createStreamFunction=new CreateStreamFunction(getSiddhiManager(),zkCluster);
  AlterStreamFunction alterStreamFunction=new AlterStreamFunction(getSiddhiManager(),zkCluster);
  InsertIntoStreamFunction insertIntoStreamFunction=new InsertIntoStreamFunction(getSiddhiManager(),zkCluster);
  AddQueryToStreamFunction addQueryToStreamFunction=new AddQueryToStreamFunction(getSiddhiManager(),zkCluster);
  ListenStreamFunction listenStreamFunction=new ListenStreamFunction(getSiddhiManager(),zkCluster,kafkaCluster);
  CollectRequestForStatsFunction collectRequestForStatsFunction=new CollectRequestForStatsFunction(getSiddhiManager(),zkCluster,kafkaCluster);
  ListStreamsFunction listStreamsFunction=new ListStreamsFunction(getSiddhiManager(),zkCluster);
  SaveRequestsToAuditLogFunction saveRequestsToAuditLogFunction=new SaveRequestsToAuditLogFunction(getSiddhiManager(),zkCluster,kafkaCluster,cassandraCluster,enableAuditing);
  SaveToCassandraStreamFunction saveToCassandraStreamFunction=new SaveToCassandraStreamFunction(getSiddhiManager(),zkCluster,cassandraCluster);
  HostAndPort elasticSearchConnectionData=HostAndPort.fromString(elasticSearchUrl);
  IndexStreamFunction indexStreamFunction=new IndexStreamFunction(getSiddhiManager(),zkCluster,elasticSearchConnectionData.getHostText(),elasticSearchConnectionData.getPortOrDefault(9300));
  Map<String,Integer> topicMap=new HashMap<String,Integer>();
  String[] topic_list=topics.split(""String_Node_Str"");
  HostAndPort kafkaConnectionData=HostAndPort.fromString(kafkaCluster);
  TopicService topicService=new KafkaTopicService(zkCluster,kafkaConnectionData.getHostText(),kafkaConnectionData.getPortOrDefault(9092),config.getInt(""String_Node_Str""),config.getInt(""String_Node_Str""));
  for (  String topic : topic_list) {
    topicService.createTopicIfNotExist(topic,config.getInt(""String_Node_Str""),config.getInt(""String_Node_Str""));
    Integer partitions=topicService.getNumPartitionsForTopic(topic);
    if (partitions == 0) {
      partitions=config.getInt(""String_Node_Str"");
    }
    topicMap.put(topic,partitions);
  }
  JavaPairDStream<String,String> messages=KafkaUtils.createStream(jssc,zkCluster,BUS.STREAMING_GROUP_ID,topicMap);
  messages.cache();
  JavaDStream<StratioStreamingMessage> create_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.DEFINITION.CREATE)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> alter_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.DEFINITION.ALTER)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> insert_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.MANIPULATION.INSERT)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> add_query_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.DEFINITION.ADD_QUERY)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> remove_query_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.DEFINITION.REMOVE_QUERY)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> listen_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.ACTION.LISTEN)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> stop_listen_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.ACTION.STOP_LISTEN)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> saveToCassandra_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.ACTION.SAVETO_CASSANDRA)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> stop_saveToCassandra_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.ACTION.STOP_SAVETO_CASSANDRA)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> streamToIndexer_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.ACTION.INDEX)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> stopStreamToIndexer_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.ACTION.STOP_INDEX)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> list_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.MANIPULATION.LIST)).map(keepPayloadFromMessageFunction);
  JavaDStream<StratioStreamingMessage> drop_requests=messages.filter(new FilterMessagesByOperationFunction(STREAM_OPERATIONS.DEFINITION.DROP)).map(keepPayloadFromMessageFunction);
  create_requests.foreachRDD(createStreamFunction);
  alter_requests.foreachRDD(alterStreamFunction);
  insert_requests.foreachRDD(insertIntoStreamFunction);
  add_query_requests.foreachRDD(addQueryToStreamFunction);
  remove_query_requests.foreachRDD(addQueryToStreamFunction);
  listen_requests.foreachRDD(listenStreamFunction);
  stop_listen_requests.foreachRDD(listenStreamFunction);
  saveToCassandra_requests.foreachRDD(saveToCassandraStreamFunction);
  stop_saveToCassandra_requests.foreach(saveToCassandraStreamFunction);
  streamToIndexer_requests.foreachRDD(indexStreamFunction);
  stopStreamToIndexer_requests.foreachRDD(indexStreamFunction);
  list_requests.foreachRDD(listStreamsFunction);
  drop_requests.foreachRDD(createStreamFunction);
  if (enableAuditing || enableStats) {
    JavaDStream<StratioStreamingMessage> allRequests=create_requests.union(alter_requests).union(insert_requests).union(add_query_requests).union(remove_query_requests).union(listen_requests).union(stop_listen_requests).union(saveToCassandra_requests).union(list_requests).union(drop_requests);
    if (enableAuditing) {
      allRequests.foreachRDD(saveRequestsToAuditLogFunction);
    }
    if (enableStats) {
      allRequests.foreachRDD(collectRequestForStatsFunction);
    }
  }
  StreamPersistence.saveStreamingEngineStatus(getSiddhiManager());
  if (printStreams) {
    messages.count().foreach(new Function<JavaRDD<Long>,Void>(){
      private static final long serialVersionUID=-2371501158355376325L;
      @Override public Void call(      JavaRDD<Long> arg0) throws Exception {
        StringBuffer sb=new StringBuffer();
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(""String_Node_Str"");
        sb.append(siddhiManager.getStreamDefinitions().size());
        sb.append(""String_Node_Str"");
        sb.append(getSiddhiManager().getSiddhiContext().getHazelcastInstance().getMap(STREAMING.STREAM_STATUS_MAP).size());
        sb.append(""String_Node_Str"");
        for (        StreamDefinition streamMetaData : getSiddhiManager().getStreamDefinitions()) {
          StringBuffer streamDefinition=new StringBuffer();
          streamDefinition.append(streamMetaData.getStreamId());
          for (          Attribute column : streamMetaData.getAttributeList()) {
            streamDefinition.append(""String_Node_Str"" + column.getName() + ""String_Node_Str""+ column.getType());
          }
          if (StreamSharedStatus.getStreamStatus(streamMetaData.getStreamId(),getSiddhiManager()) != null) {
            HashMap<String,String> attachedQueries=StreamSharedStatus.getStreamStatus(streamMetaData.getStreamId(),getSiddhiManager()).getAddedQueries();
            streamDefinition.append(""String_Node_Str"" + attachedQueries.size() + ""String_Node_Str"");
            for (            String queryId : attachedQueries.keySet()) {
              streamDefinition.append(queryId + ""String_Node_Str"");
            }
            streamDefinition.append(""String_Node_Str"" + StreamSharedStatus.getStreamStatus(streamMetaData.getStreamId(),getSiddhiManager()).isUserDefined() + ""String_Node_Str"");
            streamDefinition.append(""String_Node_Str"" + StreamSharedStatus.getStreamStatus(streamMetaData.getStreamId(),getSiddhiManager()).isActionEnabled(StreamAction.LISTEN) + ""String_Node_Str"");
          }
          sb.append(""String_Node_Str"".concat(streamDefinition.toString()).concat(""String_Node_Str""));
        }
        sb.append(""String_Node_Str"");
        logger.info(sb.toString());
        StreamPersistence.saveStreamingEngineStatus(getSiddhiManager());
        return null;
      }
    }
);
  }
  jssc.start();
  logger.info(""String_Node_Str"",new Date());
  jssc.awaitTermination();
}",0.9957771968630604
112683,"public StreamToIndexerCallback(StreamDefinition streamDefinition,String elasticSearchHost,int elasticSearchPort){
  this.streamDefinition=streamDefinition;
  Settings settings=ImmutableSettings.settingsBuilder().put(""String_Node_Str"",true).build();
  this.elasticSearchClient=new TransportClient(settings).addTransportAddress(new InetSocketTransportAddress(elasticSearchHost,elasticSearchPort));
  running=Boolean.FALSE;
}","public StreamToIndexerCallback(StreamDefinition streamDefinition,String elasticSearchHost,int elasticSearchPort){
  this.streamDefinition=streamDefinition;
  Settings settings=ImmutableSettings.settingsBuilder().put(""String_Node_Str"",true).build();
  this.elasticSearchClient=new TransportClient(settings).addTransportAddress(new InetSocketTransportAddress(elasticSearchHost,elasticSearchPort));
  running=Boolean.TRUE;
}",0.9916963226571768
112684,"@Override public Void call(JavaRDD<StratioStreamingMessage> rdd) throws Exception {
  for (  StratioStreamingMessage message : rdd.collect()) {
    try {
      if (validOperation(message)) {
        boolean defaultResponse=false;
        if (getStartOperationCommand() != null && getStartOperationCommand().equalsIgnoreCase(message.getOperation())) {
          defaultResponse=startAction(message);
        }
 else         if (getStopOperationCommand() != null && getStopOperationCommand().equalsIgnoreCase(message.getOperation())) {
          defaultResponse=stopAction(message);
        }
        if (defaultResponse) {
          ackStreamingOperation(message,new ActionCallbackDto(REPLY_CODES.OK));
        }
      }
    }
 catch (    RequestValidationException e) {
      log.error(""String_Node_Str"",e);
      ackStreamingOperation(message,new ActionCallbackDto(e.getCode(),e.getMessage()));
    }
catch (    Exception e) {
      log.error(""String_Node_Str"",e);
      ackStreamingOperation(message,new ActionCallbackDto(REPLY_CODES.KO_GENERAL_ERROR,e.getMessage()));
    }
  }
  return null;
}","@Override public Void call(JavaRDD<StratioStreamingMessage> rdd) throws Exception {
  for (  StratioStreamingMessage message : rdd.collect()) {
    try {
      boolean defaultResponse=false;
      if (getStartOperationCommand() != null && getStartOperationCommand().equalsIgnoreCase(message.getOperation())) {
        if (validOperation(message,startValidators)) {
          defaultResponse=startAction(message);
        }
      }
 else       if (getStopOperationCommand() != null && getStopOperationCommand().equalsIgnoreCase(message.getOperation())) {
        if (validOperation(message,stopValidators)) {
          defaultResponse=stopAction(message);
        }
      }
      if (defaultResponse) {
        ackStreamingOperation(message,new ActionCallbackDto(REPLY_CODES.OK));
      }
    }
 catch (    RequestValidationException e) {
      log.error(""String_Node_Str"",e);
      ackStreamingOperation(message,new ActionCallbackDto(e.getCode(),e.getMessage()));
    }
catch (    Exception e) {
      log.error(""String_Node_Str"",e);
      ackStreamingOperation(message,new ActionCallbackDto(REPLY_CODES.KO_GENERAL_ERROR,e.getMessage()));
    }
  }
  return null;
}",0.9106984969053936
112685,"private boolean validOperation(StratioStreamingMessage request) throws Exception {
  log.debug(""String_Node_Str"",request.getRequest_id(),request.getSession_id());
  for (  RequestValidation validation : validators) {
    try {
      validation.validate(request);
    }
 catch (    RequestValidationException e) {
      log.error(""String_Node_Str"",e);
      ackStreamingOperation(request,new ActionCallbackDto(e.getCode(),e.getMessage()));
      return false;
    }
  }
  return true;
}","private boolean validOperation(StratioStreamingMessage request,Set<RequestValidation> validators) throws Exception {
  log.debug(""String_Node_Str"",request.getRequest_id(),request.getSession_id());
  for (  RequestValidation validation : validators) {
    try {
      validation.validate(request);
    }
 catch (    RequestValidationException e) {
      log.error(""String_Node_Str"",e);
      ackStreamingOperation(request,new ActionCallbackDto(e.getCode(),e.getMessage()));
      return false;
    }
  }
  return true;
}",0.9661354581673308
112686,"public ActionBaseFunction(SiddhiManager siddhiManager,String zookeeperHost){
  this.validators=new HashSet<>();
  this.siddhiManager=siddhiManager;
  this.zookeeperHost=zookeeperHost;
  validators.add(new StreamAllowedValidation(getSiddhiManager()));
  addRequestsValidations(validators);
}","public ActionBaseFunction(SiddhiManager siddhiManager,String zookeeperHost){
  this.stopValidators=new HashSet<>();
  this.startValidators=new HashSet<>();
  this.siddhiManager=siddhiManager;
  this.zookeeperHost=zookeeperHost;
  startValidators.add(new StreamAllowedValidation(getSiddhiManager()));
  stopValidators.add(new StreamAllowedValidation(getSiddhiManager()));
  addStartRequestsValidations(startValidators);
  addStopRequestsValidations(stopValidators);
}",0.7513227513227513
112687,"@Override public Void call(JavaRDD<StratioStreamingMessage> rdd) throws Exception {
  for (  StratioStreamingMessage message : rdd.collect()) {
    try {
      if (validOperation(message)) {
        boolean defaultResponse=false;
        if (getStartOperationCommand() != null && getStartOperationCommand().equals(message.getOperation())) {
          defaultResponse=startAction(message);
        }
 else         if (getStopOperationCommand() != null && getStopOperationCommand().equals(message.getOperation())) {
          defaultResponse=stopAction(message);
        }
        if (defaultResponse) {
          ackStreamingOperation(message,new ActionCallbackDto(REPLY_CODES.OK));
        }
      }
    }
 catch (    RequestValidationException e) {
      log.error(""String_Node_Str"",e);
      ackStreamingOperation(message,new ActionCallbackDto(e.getCode(),e.getMessage()));
    }
catch (    Exception e) {
      log.error(""String_Node_Str"",e);
      ackStreamingOperation(message,new ActionCallbackDto(REPLY_CODES.KO_GENERAL_ERROR,e.getMessage()));
    }
  }
  return null;
}","@Override public Void call(JavaRDD<StratioStreamingMessage> rdd) throws Exception {
  for (  StratioStreamingMessage message : rdd.collect()) {
    try {
      if (validOperation(message)) {
        boolean defaultResponse=false;
        if (getStartOperationCommand() != null && getStartOperationCommand().equalsIgnoreCase(message.getOperation())) {
          defaultResponse=startAction(message);
        }
 else         if (getStopOperationCommand() != null && getStopOperationCommand().equalsIgnoreCase(message.getOperation())) {
          defaultResponse=stopAction(message);
        }
        if (defaultResponse) {
          ackStreamingOperation(message,new ActionCallbackDto(REPLY_CODES.OK));
        }
      }
    }
 catch (    RequestValidationException e) {
      log.error(""String_Node_Str"",e);
      ackStreamingOperation(message,new ActionCallbackDto(e.getCode(),e.getMessage()));
    }
catch (    Exception e) {
      log.error(""String_Node_Str"",e);
      ackStreamingOperation(message,new ActionCallbackDto(REPLY_CODES.KO_GENERAL_ERROR,e.getMessage()));
    }
  }
  return null;
}",0.9908003679852806
112688,"public HearthTreeNode heroAbilityUsedEvent(PlayerSide thisMinionPlayerSide,PlayerSide heroAbilityUsedSide,Minion heroAbilityTargetCharacter,HearthTreeNode boardState){
  EffectCharacter<T> effect=this.getInspireEffect();
  FilterCharacterInterface filter=this.getInspireFilter();
  HearthTreeNode toRet=boardState;
  ArrayList<BoardModel.MinionPlayerPair> minions=new ArrayList<>();
  for (  BoardModel.MinionPlayerPair mp : toRet.data_.getAllMinionsFIFOList()) {
    minions.add(mp);
  }
  for (  BoardModel.MinionPlayerPair mp : minions) {
    if (mp.getPlayerSide() == PlayerSide.CURRENT_PLAYER && filter.targetMatches(thisMinionPlayerSide,this,mp.getPlayerSide(),mp.getMinion(),boardState.data_)) {
      toRet=effect.applyEffect(mp.getPlayerSide(),mp.getMinion(),toRet);
    }
  }
  if (filter.targetMatches(thisMinionPlayerSide,this,PlayerSide.CURRENT_PLAYER,toRet.data_.getCharacter(PlayerSide.CURRENT_PLAYER,CharacterIndex.HERO),boardState.data_)) {
    toRet=effect.applyEffect(PlayerSide.CURRENT_PLAYER,toRet.data_.getCharacter(PlayerSide.CURRENT_PLAYER,CharacterIndex.HERO),toRet);
  }
  return toRet;
}","public HearthTreeNode heroAbilityUsedEvent(PlayerSide thisMinionPlayerSide,PlayerSide heroAbilityUsedSide,Minion heroAbilityTargetCharacter,HearthTreeNode boardState){
  EffectCharacter<T> effect=this.getInspireEffect();
  FilterCharacterInterface filter=this.getInspireFilter();
  HearthTreeNode toRet=boardState;
  ArrayList<BoardModel.MinionPlayerPair> minions=new ArrayList<>();
  for (  BoardModel.MinionPlayerPair mp : toRet.data_.getAllMinionsFIFOList()) {
    minions.add(mp);
  }
  for (  BoardModel.MinionPlayerPair mp : minions) {
    if (mp.getPlayerSide() == PlayerSide.CURRENT_PLAYER && filter.targetMatches(thisMinionPlayerSide,this,mp.getPlayerSide(),mp.getMinion(),boardState.data_)) {
      HearthTreeNode tempNode=effect.applyEffect(mp.getPlayerSide(),mp.getMinion(),toRet);
      if (tempNode != null)       toRet=tempNode;
    }
  }
  if (filter.targetMatches(thisMinionPlayerSide,this,PlayerSide.CURRENT_PLAYER,toRet.data_.getCharacter(PlayerSide.CURRENT_PLAYER,CharacterIndex.HERO),boardState.data_)) {
    toRet=effect.applyEffect(PlayerSide.CURRENT_PLAYER,toRet.data_.getCharacter(PlayerSide.CURRENT_PLAYER,CharacterIndex.HERO),toRet);
  }
  return toRet;
}",0.96602787456446
112689,"@Override public int hashCode(){
  int result=super.hashCode();
  result=31 * result + (taunt_ ? 1 : 0);
  result=31 * result + (divineShield_ ? 1 : 0);
  result=31 * result + (windFury_ ? 1 : 0);
  result=31 * result + (charge_ ? 1 : 0);
  result=31 * result + (hasAttacked_ ? 1 : 0);
  result=31 * result + (hasWindFuryAttacked_ ? 1 : 0);
  result=31 * result + (frozen_ ? 1 : 0);
  result=31 * result + (silenced_ ? 1 : 0);
  result=31 * result + (stealthedUntilRevealed ? 1 : 0);
  result=31 * result + (stealthedUntilNextTurn ? 1 : 0);
  result=31 * result + (heroTargetable_ ? 1 : 0);
  result=31 * result + health_;
  result=31 * result + maxHealth_;
  result=31 * result + this.getBaseHealth();
  result=31 * result + auraHealth_;
  result=31 * result + attack_;
  result=31 * result + this.getBaseAttack();
  result=31 * result + extraAttackUntilTurnEnd_;
  result=31 * result + auraAttack_;
  result=31 * result + (destroyOnTurnStart_ ? 1 : 0);
  result=31 * result + (destroyOnTurnEnd_ ? 1 : 0);
  result=31 * result + spellDamage_;
  result=31 * result + (deathrattleAction_ != null ? deathrattleAction_.hashCode() : 0);
  result=31 * result + (this.getPlacementImportant() ? 1 : 0);
  return result;
}","@Override public int hashCode(){
  int result=super.hashCode();
  result=31 * result + (taunt_ ? 1 : 0);
  result=31 * result + (divineShield_ ? 1 : 0);
  result=31 * result + (windFury_ ? 1 : 0);
  result=31 * result + (charge_ ? 1 : 0);
  result=31 * result + (hasAttacked_ ? 1 : 0);
  result=31 * result + (hasWindFuryAttacked_ ? 1 : 0);
  result=31 * result + (frozen_ ? 1 : 0);
  result=31 * result + (silenced_ ? 1 : 0);
  result=31 * result + (stealthedUntilRevealed ? 1 : 0);
  result=31 * result + (stealthedUntilNextTurn ? 1 : 0);
  result=31 * result + (heroTargetable_ ? 1 : 0);
  result=31 * result + health_;
  result=31 * result + maxHealth_;
  result=31 * result + this.getBaseHealth();
  result=31 * result + auraHealth_;
  result=31 * result + attack_;
  result=31 * result + this.getBaseAttack();
  result=31 * result + extraAttackUntilTurnEnd_;
  result=31 * result + auraAttack_;
  result=31 * result + (destroyOnTurnStart_ ? 1 : 0);
  result=31 * result + (destroyOnTurnEnd_ ? 1 : 0);
  result=31 * result + spellDamage_;
  result=31 * result + (immune_ ? 1 : 0);
  result=31 * result + (cantAttack ? 1 : 0);
  result=31 * result + (deathrattleAction_ != null ? deathrattleAction_.hashCode() : 0);
  result=31 * result + (this.getPlacementImportant() ? 1 : 0);
  return result;
}",0.965407554671968
112690,"/** 
 * Deep copy of the object Note: the event actions are not actually deep copied.
 */
@Override public Card deepCopy(){
  Minion minion=(Minion)super.deepCopy();
  minion.attack_=attack_;
  minion.health_=health_;
  minion.extraAttackUntilTurnEnd_=extraAttackUntilTurnEnd_;
  minion.auraAttack_=auraAttack_;
  minion.maxHealth_=maxHealth_;
  minion.auraHealth_=auraHealth_;
  minion.spellDamage_=spellDamage_;
  minion.taunt_=taunt_;
  minion.divineShield_=divineShield_;
  minion.windFury_=windFury_;
  minion.charge_=charge_;
  minion.hasAttacked_=hasAttacked_;
  minion.hasWindFuryAttacked_=hasWindFuryAttacked_;
  minion.frozen_=frozen_;
  minion.silenced_=silenced_;
  minion.stealthedUntilRevealed=stealthedUntilRevealed;
  minion.stealthedUntilNextTurn=stealthedUntilNextTurn;
  minion.heroTargetable_=heroTargetable_;
  minion.destroyOnTurnStart_=destroyOnTurnStart_;
  minion.destroyOnTurnEnd_=destroyOnTurnEnd_;
  minion.deathrattleAction_=deathrattleAction_;
  minion.inHand=inHand;
  minion.hasBeenUsed=hasBeenUsed;
  return minion;
}","/** 
 * Deep copy of the object Note: the event actions are not actually deep copied.
 */
@Override public Card deepCopy(){
  Minion minion=(Minion)super.deepCopy();
  minion.attack_=attack_;
  minion.health_=health_;
  minion.extraAttackUntilTurnEnd_=extraAttackUntilTurnEnd_;
  minion.auraAttack_=auraAttack_;
  minion.maxHealth_=maxHealth_;
  minion.auraHealth_=auraHealth_;
  minion.spellDamage_=spellDamage_;
  minion.taunt_=taunt_;
  minion.divineShield_=divineShield_;
  minion.windFury_=windFury_;
  minion.charge_=charge_;
  minion.hasAttacked_=hasAttacked_;
  minion.hasWindFuryAttacked_=hasWindFuryAttacked_;
  minion.frozen_=frozen_;
  minion.silenced_=silenced_;
  minion.stealthedUntilRevealed=stealthedUntilRevealed;
  minion.stealthedUntilNextTurn=stealthedUntilNextTurn;
  minion.heroTargetable_=heroTargetable_;
  minion.destroyOnTurnStart_=destroyOnTurnStart_;
  minion.destroyOnTurnEnd_=destroyOnTurnEnd_;
  minion.deathrattleAction_=deathrattleAction_;
  minion.immune_=immune_;
  minion.cantAttack=cantAttack;
  minion.inHand=inHand;
  minion.hasBeenUsed=hasBeenUsed;
  return minion;
}",0.9731232622798888
112691,"@Override public boolean equals(Object other){
  if (!super.equals(other)) {
    return false;
  }
  Minion otherMinion=(Minion)other;
  if (health_ != otherMinion.health_)   return false;
  if (maxHealth_ != otherMinion.maxHealth_)   return false;
  if (auraHealth_ != otherMinion.auraHealth_)   return false;
  if (attack_ != otherMinion.attack_)   return false;
  if (extraAttackUntilTurnEnd_ != otherMinion.extraAttackUntilTurnEnd_)   return false;
  if (auraAttack_ != otherMinion.auraAttack_)   return false;
  if (taunt_ != otherMinion.taunt_)   return false;
  if (divineShield_ != otherMinion.divineShield_)   return false;
  if (windFury_ != otherMinion.windFury_)   return false;
  if (charge_ != otherMinion.charge_)   return false;
  if (stealthedUntilRevealed != otherMinion.stealthedUntilRevealed)   return false;
  if (stealthedUntilNextTurn != otherMinion.stealthedUntilNextTurn)   return false;
  if (hasAttacked_ != otherMinion.hasAttacked_)   return false;
  if (heroTargetable_ != otherMinion.heroTargetable_)   return false;
  if (hasWindFuryAttacked_ != otherMinion.hasWindFuryAttacked_)   return false;
  if (frozen_ != otherMinion.frozen_)   return false;
  if (silenced_ != otherMinion.silenced_)   return false;
  if (destroyOnTurnStart_ != otherMinion.destroyOnTurnStart_)   return false;
  if (destroyOnTurnEnd_ != otherMinion.destroyOnTurnEnd_)   return false;
  if (spellDamage_ != otherMinion.spellDamage_)   return false;
  if (deathrattleAction_ == null && ((Minion)other).deathrattleAction_ != null)   return false;
  if (deathrattleAction_ != null && !deathrattleAction_.equals(((Minion)other).deathrattleAction_))   return false;
  return true;
}","@Override public boolean equals(Object other){
  if (!super.equals(other)) {
    return false;
  }
  Minion otherMinion=(Minion)other;
  if (health_ != otherMinion.health_)   return false;
  if (maxHealth_ != otherMinion.maxHealth_)   return false;
  if (auraHealth_ != otherMinion.auraHealth_)   return false;
  if (attack_ != otherMinion.attack_)   return false;
  if (extraAttackUntilTurnEnd_ != otherMinion.extraAttackUntilTurnEnd_)   return false;
  if (auraAttack_ != otherMinion.auraAttack_)   return false;
  if (taunt_ != otherMinion.taunt_)   return false;
  if (divineShield_ != otherMinion.divineShield_)   return false;
  if (windFury_ != otherMinion.windFury_)   return false;
  if (charge_ != otherMinion.charge_)   return false;
  if (stealthedUntilRevealed != otherMinion.stealthedUntilRevealed)   return false;
  if (stealthedUntilNextTurn != otherMinion.stealthedUntilNextTurn)   return false;
  if (hasAttacked_ != otherMinion.hasAttacked_)   return false;
  if (heroTargetable_ != otherMinion.heroTargetable_)   return false;
  if (hasWindFuryAttacked_ != otherMinion.hasWindFuryAttacked_)   return false;
  if (frozen_ != otherMinion.frozen_)   return false;
  if (silenced_ != otherMinion.silenced_)   return false;
  if (destroyOnTurnStart_ != otherMinion.destroyOnTurnStart_)   return false;
  if (destroyOnTurnEnd_ != otherMinion.destroyOnTurnEnd_)   return false;
  if (spellDamage_ != otherMinion.spellDamage_)   return false;
  if (immune_ != otherMinion.immune_)   return false;
  if (cantAttack != otherMinion.cantAttack)   return false;
  if (deathrattleAction_ == null && ((Minion)other).deathrattleAction_ != null)   return false;
  if (deathrattleAction_ != null && !deathrattleAction_.equals(((Minion)other).deathrattleAction_))   return false;
  return true;
}",0.9672413793103448
112692,"@Override public int hashCode(){
  int result=this.getName() != null ? this.getName().hashCode() : 0;
  result=31 * result + this.getBaseManaCost();
  result=31 * result + (hasBeenUsed ? 1 : 0);
  result=31 * result + (inHand ? 1 : 0);
  return result;
}","@Override public int hashCode(){
  int result=this.getName() != null ? this.getName().hashCode() : 0;
  result=31 * result + this.getBaseManaCost();
  result=31 * result + (hasBeenUsed ? 1 : 0);
  result=31 * result + (inHand ? 1 : 0);
  result=31 * result + (deathrattleTriggered ? 1 : 0);
  return result;
}",0.9023090586145648
112693,"@Override public Card deepCopy(){
  Card copy=null;
  try {
    copy=getClass().newInstance();
  }
 catch (  InstantiationException e) {
    Card.log.error(""String_Node_Str"",e);
  }
catch (  IllegalAccessException e) {
    Card.log.error(""String_Node_Str"",e);
  }
  if (copy == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  copy.hasBeenUsed=this.hasBeenUsed;
  copy.inHand=this.inHand;
  copy.manaDelta=this.manaDelta;
  return copy;
}","@Override public Card deepCopy(){
  Card copy=null;
  try {
    copy=getClass().newInstance();
  }
 catch (  InstantiationException e) {
    Card.log.error(""String_Node_Str"",e);
  }
catch (  IllegalAccessException e) {
    Card.log.error(""String_Node_Str"",e);
  }
  if (copy == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  copy.hasBeenUsed=this.hasBeenUsed;
  copy.inHand=this.inHand;
  copy.manaDelta=this.manaDelta;
  copy.deathrattleTriggered=deathrattleTriggered;
  return copy;
}",0.9478079331941544
112694,"@Override public boolean equals(Object other){
  if (other == null) {
    return false;
  }
  if (this.getClass() != other.getClass()) {
    return false;
  }
  if (this.getManaDelta() != ((Card)other).getManaDelta())   return false;
  if (this.getBaseManaCost() != ((Card)other).getBaseManaCost())   return false;
  if (hasBeenUsed != ((Card)other).hasBeenUsed)   return false;
  if (inHand != ((Card)other).inHand)   return false;
  if (this.getName() == null) {
    if (((Card)other).getName() != null) {
      return false;
    }
  }
 else   if (!this.getName().equals(((Card)other).getName())) {
    return false;
  }
  return true;
}","@Override public boolean equals(Object other){
  if (other == null) {
    return false;
  }
  if (this.getClass() != other.getClass()) {
    return false;
  }
  if (this.getManaDelta() != ((Card)other).getManaDelta())   return false;
  if (this.getBaseManaCost() != ((Card)other).getBaseManaCost())   return false;
  if (hasBeenUsed != ((Card)other).hasBeenUsed)   return false;
  if (inHand != ((Card)other).inHand)   return false;
  if (deathrattleTriggered != ((Card)other).deathrattleTriggered)   return false;
  if (this.getName() == null) {
    if (((Card)other).getName() != null) {
      return false;
    }
  }
 else   if (!this.getName().equals(((Card)other).getName())) {
    return false;
  }
  return true;
}",0.9397058823529412
112695,"protected void initFromImplementedCard(ImplementedCardList.ImplementedCard implementedCard){
  this.hasBeenUsed=false;
  this.inHand=true;
}","protected void initFromImplementedCard(ImplementedCardList.ImplementedCard implementedCard){
  this.hasBeenUsed=false;
  this.inHand=true;
  this.deathrattleTriggered=false;
}",0.8888888888888888
112696,"/** 
 * Battlecry: Destroy your opponent's weapon
 */
@Override public EffectCharacter getBattlecryEffect(){
  return (originSide,origin,targetSide,targetCharacterIndex,boardState) -> {
    HearthTreeNode toRet=boardState;
    Hero theHero=toRet.data_.getCurrentPlayer().getHero();
    WeaponCard newWeapon=new BattleAxe();
    newWeapon.hasBeenUsed(true);
    DeathrattleAction action=theHero.setWeapon(newWeapon);
    if (action != null) {
      toRet=action.performAction(null,PlayerSide.CURRENT_PLAYER,toRet);
    }
    return toRet;
  }
;
}","@Override public EffectCharacter getBattlecryEffect(){
  return (originSide,origin,targetSide,targetCharacterIndex,boardState) -> {
    HearthTreeNode toRet=boardState;
    Hero theHero=toRet.data_.getCurrentPlayer().getHero();
    WeaponCard newWeapon=new BattleAxe();
    newWeapon.hasBeenUsed(true);
    DeathrattleAction action=theHero.setWeapon(newWeapon);
    if (action != null) {
      toRet=action.performAction(null,PlayerSide.CURRENT_PLAYER,toRet);
    }
    return toRet;
  }
;
}",0.947876447876448
112697,"/** 
 * Called when this minion dies (destroyAndNotify) <p> Always use this function to ""kill"" minions
 * @param thisPlayerSide
 * @param boardState
 * @throws HSInvalidPlayerIndexException
 */
public HearthTreeNode destroyAndNotify(PlayerSide thisPlayerSide,HearthTreeNode boardState){
  health_=0;
  HearthTreeNode toRet=boardState;
  if (deathrattleAction_ != null) {
    toRet=deathrattleAction_.performAction(this,thisPlayerSide,toRet);
  }
  toRet=toRet.notifyMinionDead(thisPlayerSide,this);
  return toRet;
}","/** 
 * Called when this minion dies (destroyAndNotify) <p> Always use this function to ""kill"" minions
 * @param thisPlayerSide
 * @param boardState
 * @throws HSInvalidPlayerIndexException
 */
public HearthTreeNode destroyAndNotify(PlayerSide thisPlayerSide,HearthTreeNode boardState){
  health_=0;
  HearthTreeNode toRet=boardState;
  if (deathrattleAction_ != null) {
    toRet=deathrattleAction_.performAction(this,thisPlayerSide,toRet);
  }
  if (toRet != null)   toRet=toRet.notifyMinionDead(thisPlayerSide,this);
 else   return boardState;
  return toRet;
}",0.9314814814814816
112698,"/** 
 * Perform the action
 * @param origin      The minion that is performing the action (aka, the dying minion)
 * @param playerSide
 * @param boardState
 */
public HearthTreeNode performAction(T origin,PlayerSide playerSide,HearthTreeNode boardState){
  return boardState;
}","/** 
 * Perform the action
 * @param origin      The minion that is performing the action (aka, the dying minion)
 * @param playerSide
 * @param boardState
 */
public HearthTreeNode performAction(T origin,PlayerSide playerSide,HearthTreeNode boardState){
  if (origin == null)   return boardState;
  if (origin.isDeathrattleTriggered())   return null;
 else   origin.setDeathrattleTriggered(true);
  return boardState;
}",0.7948350071736011
112699,"@Override public HearthTreeNode performAction(Card origin,PlayerSide playerSide,HearthTreeNode boardState){
  HearthTreeNode toRet=super.performAction(origin,playerSide,boardState);
  PlayerModel targetPlayer=toRet.data_.modelForSide(playerSide);
  PlayerSide targetPlayerSide=playerSide;
  if (sideToSummon == PlayerSide.WAITING_PLAYER) {
    targetPlayer=toRet.data_.modelForSide(playerSide.getOtherPlayer());
    targetPlayerSide=playerSide.getOtherPlayer();
  }
  CharacterIndex targetIndex=CharacterIndex.fromInteger(targetPlayer.getNumMinions());
  if (origin instanceof Minion && targetPlayerSide == playerSide) {
    targetIndex=targetPlayer.getIndexForCharacter((Minion)origin);
    toRet.data_.removeMinion((Minion)origin);
  }
  int numMinionsToActuallySummon=numMinions_;
  if (targetPlayer.getNumEmptyBoardSpace() < numMinionsToActuallySummon) {
    numMinionsToActuallySummon=targetPlayer.getNumEmptyBoardSpace();
  }
  for (int index=0; index < numMinionsToActuallySummon; ++index) {
    try {
      Minion newMinion=minionClass_.newInstance();
      if (sideToSummon == PlayerSide.WAITING_PLAYER)       toRet=newMinion.summonMinion(targetPlayerSide,targetIndex,toRet,false);
 else       toRet=newMinion.summonMinion(targetPlayerSide,targetIndex.indexToLeft(),toRet,false);
    }
 catch (    InstantiationException|IllegalAccessException e) {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
  return toRet;
}","@Override public HearthTreeNode performAction(Card origin,PlayerSide playerSide,HearthTreeNode boardState){
  HearthTreeNode toRet=super.performAction(origin,playerSide,boardState);
  if (toRet == null)   return boardState;
  PlayerModel targetPlayer=toRet.data_.modelForSide(playerSide);
  PlayerSide targetPlayerSide=playerSide;
  if (sideToSummon == PlayerSide.WAITING_PLAYER) {
    targetPlayer=toRet.data_.modelForSide(playerSide.getOtherPlayer());
    targetPlayerSide=playerSide.getOtherPlayer();
  }
  CharacterIndex targetIndex=CharacterIndex.fromInteger(targetPlayer.getNumMinions());
  if (origin instanceof Minion && targetPlayerSide == playerSide) {
    targetIndex=targetPlayer.getIndexForCharacter((Minion)origin);
    toRet.data_.removeMinion((Minion)origin);
  }
  int numMinionsToActuallySummon=numMinions_;
  if (targetPlayer.getNumEmptyBoardSpace() < numMinionsToActuallySummon) {
    numMinionsToActuallySummon=targetPlayer.getNumEmptyBoardSpace();
  }
  for (int index=0; index < numMinionsToActuallySummon; ++index) {
    try {
      Minion newMinion=minionClass_.newInstance();
      if (sideToSummon == PlayerSide.WAITING_PLAYER)       toRet=newMinion.summonMinion(targetPlayerSide,targetIndex,toRet,false);
 else       toRet=newMinion.summonMinion(targetPlayerSide,targetIndex.indexToLeft(),toRet,false);
    }
 catch (    InstantiationException|IllegalAccessException e) {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
  return toRet;
}",0.9856065798492116
112700,"public void applyAurasToCardInHand(PlayerSide targetSide,Card target){
  Iterator<CharacterIndex.CharacterLocation> characterIterator=this.characterIterator();
  while (characterIterator.hasNext()) {
    CharacterIndex.CharacterLocation location=characterIterator.next();
    Minion character=this.getCharacter(location);
    if (character instanceof ActiveEffectHand) {
      ActiveEffectHand activeEffect=(ActiveEffectHand)character;
      if (activeEffect.isActive(location.getPlayerSide(),character,this)) {
        FilterHand filter=activeEffect.getActiveFilter();
        SimpleEffectHand effect=activeEffect.getActiveEffect();
        if (filter.targetMatches(location.getPlayerSide(),character,targetSide,target,this)) {
          effect.applyEffect(location.getPlayerSide(),character,targetSide,target,this);
        }
      }
    }
  }
}","public void applyAurasToCardInHand(PlayerSide targetSide,Card target){
  if (target == null)   return;
  Iterator<CharacterIndex.CharacterLocation> characterIterator=this.characterIterator();
  while (characterIterator.hasNext()) {
    CharacterIndex.CharacterLocation location=characterIterator.next();
    Minion character=this.getCharacter(location);
    if (character instanceof ActiveEffectHand) {
      ActiveEffectHand activeEffect=(ActiveEffectHand)character;
      if (activeEffect.isActive(location.getPlayerSide(),character,this)) {
        FilterHand filter=activeEffect.getActiveFilter();
        SimpleEffectHand effect=activeEffect.getActiveEffect();
        if (filter.targetMatches(location.getPlayerSide(),character,targetSide,target,this)) {
          effect.applyEffect(location.getPlayerSide(),character,targetSide,target,this);
        }
      }
    }
  }
}",0.981460023174971
112701,"@Override public HearthTreeNode minionSummonEvent(PlayerSide thisMinionPlayerSide,PlayerSide summonedMinionPlayerSide,Minion summonedMinion,HearthTreeNode boardState){
  if (!ShipsCannon.triggerFilter.targetMatches(thisMinionPlayerSide,this,summonedMinionPlayerSide,summonedMinion,boardState.data_)) {
    return boardState;
  }
  Collection<HearthTreeNode> rngChildren=this.effectRandomCharacterUsingFilter(ShipsCannon.effect,null,ShipsCannon.effectFilter,boardState);
  return this.createRngNodeWithChildren(boardState,rngChildren);
}","@Override public HearthTreeNode minionSummonEvent(PlayerSide thisMinionPlayerSide,PlayerSide summonedMinionPlayerSide,Minion summonedMinion,HearthTreeNode boardState){
  if (!ShipsCannon.triggerFilter.targetMatches(thisMinionPlayerSide,this,summonedMinionPlayerSide,summonedMinion,boardState.data_)) {
    return boardState;
  }
  Collection<HearthTreeNode> rngChildren=this.effectRandomCharacterUsingFilter(ShipsCannon.effect,null,ShipsCannon.effectFilter,summonedMinionPlayerSide,boardState);
  return this.createRngNodeWithChildren(boardState,rngChildren);
}",0.9772105742935278
112702,"/** 
 * Places a minion on the board via a summon effect This function is meant to be used when summoning minions through means other than a direct card usage.
 * @param targetSide
 * @param targetIndex The target character (can be a Hero). The new minion is always placed to the right of (higher index) the target minion. If the target minion is a hero, then it is placed at the left-most position.
 * @param boardState The BoardState before this card has performed its action. It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 * @throws HSException
 */
protected HearthTreeNode summonMinion_core(PlayerSide targetSide,CharacterIndex targetIndex,HearthTreeNode boardState){
  boardState.data_.placeMinion(targetSide,this,targetIndex);
  if (!charge_) {
    hasAttacked_=true;
  }
  hasBeenUsed=true;
  return boardState;
}","/** 
 * Places a minion on the board via a summon effect This function is meant to be used when summoning minions through means other than a direct card usage.
 * @param targetSide
 * @param targetIndex The target character (can be a Hero). The new minion is always placed to the right of (higher index) the target minion. If the target minion is a hero, then it is placed at the left-most position.
 * @param boardState The BoardState before this card has performed its action. It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 * @throws HSException
 */
protected HearthTreeNode summonMinion_core(PlayerSide targetSide,CharacterIndex targetIndex,HearthTreeNode boardState){
  if (boardState.data_.modelForSide(targetSide).getNumMinions() < targetIndex.getInt()) {
    targetIndex=CharacterIndex.fromInteger(boardState.data_.modelForSide(targetSide).getNumMinions());
  }
  boardState.data_.placeMinion(targetSide,this,targetIndex);
  if (!charge_) {
    hasAttacked_=true;
  }
  hasBeenUsed=true;
  return boardState;
}",0.8977685521536066
112703,"/** 
 * Use the card on the given target Summons either Huffer, Leokk, or Misha
 * @param side
 * @param boardState The BoardState before this card has performed its action. It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public Collection<HearthTreeNode> createChildren(PlayerSide originSide,int originIndex,HearthTreeNode boardState){
  HearthTreeNode newState;
  ArrayList<HearthTreeNode> children=new ArrayList<>();
  for (  Minion minion : new Minion[]{new Huffer(),new Leokk(),new Misha()}) {
    newState=new HearthTreeNode(boardState.data_.deepCopy());
    newState.data_.modelForSide(originSide).getHand().remove(originIndex);
    newState=minion.summonMinionAtEnd(originSide,newState,false);
    children.add(newState);
  }
  return children;
}","/** 
 * Use the card on the given target Summons either Huffer, Leokk, or Misha
 * @param originSide
 * @param boardState The BoardState before this card has performed its action. It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public Collection<HearthTreeNode> createChildren(PlayerSide originSide,int originIndex,HearthTreeNode boardState){
  HearthTreeNode newState;
  ArrayList<HearthTreeNode> children=new ArrayList<>();
  for (  Minion minion : new Minion[]{new Huffer(),new Leokk(),new Misha()}) {
    newState=new HearthTreeNode(boardState.data_.deepCopy());
    newState.data_.modelForSide(originSide).getHand().remove(originIndex);
    newState=minion.summonMinionAtEnd(originSide,newState,false);
    if (newState != null)     children.add(newState);
  }
  return children;
}",0.9794437726723096
112704,"@Override public HearthTreeNode applyEffect(PlayerSide targetSide,HearthTreeNode boardState){
  if (boardState.data_.modelForSide(targetSide).isHandFull()) {
    return null;
  }
  try {
    Card newCard=this.cardClass.newInstance();
    boardState.data_.placeCardHand(targetSide,newCard);
  }
 catch (  InstantiationException|IllegalAccessException e) {
    logger.error(""String_Node_Str"",e);
  }
  return boardState;
}","@Override public HearthTreeNode applyEffect(PlayerSide targetSide,HearthTreeNode boardState){
  if (boardState.data_.modelForSide(targetSide).isHandFull()) {
    return boardState;
  }
  try {
    Card newCard=this.cardClass.newInstance();
    boardState.data_.placeCardHand(targetSide,newCard);
  }
 catch (  InstantiationException|IllegalAccessException e) {
    logger.error(""String_Node_Str"",e);
  }
  return boardState;
}",0.983451536643026
112705,"@Override public HearthTreeNode applyEffect(PlayerSide originSide,Card origin,PlayerSide targetSide,HearthTreeNode boardState){
  WeaponCard newWeapon=this.weapon;
  if (origin == null) {
    newWeapon=weapon.deepCopy();
  }
  newWeapon.hasBeenUsed(true);
  DeathrattleAction weaponDeathrattle=boardState.data_.getCurrentPlayer().getHero().setWeapon(newWeapon);
  if (weaponDeathrattle != null) {
    boardState=weaponDeathrattle.performAction(origin,targetSide,boardState);
  }
  return boardState;
}","@Override public HearthTreeNode applyEffect(PlayerSide originSide,Card origin,PlayerSide targetSide,HearthTreeNode boardState){
  WeaponCard newWeapon=this.weapon;
  if (origin == null) {
    newWeapon=weapon.deepCopy();
  }
  newWeapon.hasBeenUsed(true);
  DeathrattleAction weaponDeathrattle=boardState.data_.getCurrentPlayer().getHero().setWeapon(newWeapon);
  if (weaponDeathrattle != null) {
    boardState=weaponDeathrattle.performAction(null,targetSide,boardState);
  }
  return boardState;
}",0.99
112706,"/** 
 * Handles dead minions For each dead minion, the function calls its deathrattle in the correct order, and then removes the dead minions from the board.
 * @return true if there are dead minions left (minions might have died during deathrattle). false otherwise.
 * @throws HSException
 */
public static HearthTreeNode handleDeadMinions(HearthTreeNode boardState){
  HearthTreeNode toRet=boardState;
  IdentityLinkedList<BoardModel.MinionPlayerPair> deadMinions=new IdentityLinkedList<>();
  for (  BoardModel.MinionPlayerPair minionIdPair : toRet.data_.getAllMinionsFIFOList()) {
    if (minionIdPair.getMinion().getTotalHealth() <= 0) {
      deadMinions.add(minionIdPair);
    }
  }
  for (  BoardModel.MinionPlayerPair minionIdPair : deadMinions) {
    PlayerSide playerSide=minionIdPair.getPlayerSide();
    toRet=minionIdPair.getMinion().destroyAndNotify(playerSide,toRet);
    toRet.data_.removeMinion(minionIdPair);
  }
  if (toRet.data_.hasDeadMinions())   return BoardStateFactoryBase.handleDeadMinions(toRet);
 else   return toRet;
}","/** 
 * Handles dead minions For each dead minion, the function calls its deathrattle in the correct order, and then removes the dead minions from the board.
 * @return true if there are dead minions left (minions might have died during deathrattle). false otherwise.
 * @throws HSException
 */
public static HearthTreeNode handleDeadMinions(HearthTreeNode boardState){
  HearthTreeNode toRet=boardState;
  IdentityLinkedList<BoardModel.MinionPlayerPair> deadMinions=new IdentityLinkedList<>();
  for (  BoardModel.MinionPlayerPair minionIdPair : toRet.data_.getAllMinionsFIFOList()) {
    if (minionIdPair.getMinion().getTotalHealth() <= 0) {
      deadMinions.add(minionIdPair);
    }
  }
  for (  BoardModel.MinionPlayerPair minionIdPair : deadMinions) {
    PlayerSide playerSide=minionIdPair.getPlayerSide();
    toRet=minionIdPair.getMinion().destroyAndNotify(playerSide,toRet);
  }
  for (  BoardModel.MinionPlayerPair minionIdPair : deadMinions) {
    toRet.data_.removeMinion(minionIdPair);
  }
  if (toRet.data_.hasDeadMinions())   return BoardStateFactoryBase.handleDeadMinions(toRet);
 else   return toRet;
}",0.96726602120793
112707,"/** 
 * Called at the start of the turn <p> This function is called at the start of the turn. Any derived class must override it to implement whatever ""start of the turn"" effect the card has.
 */
@Override public HearthTreeNode startTurn(PlayerSide thisMinionPlayerIndex,HearthTreeNode boardModel) throws HSException {
  if (destroyOnTurnStart_) {
    this.setHealth((byte)-99);
  }
  if (stealthedUntilNextTurn)   this.setStealthedUntilNextTurn(false);
  return boardModel;
}","/** 
 * Called at the start of the turn <p> This function is called at the start of the turn. Any derived class must override it to implement whatever ""start of the turn"" effect the card has.
 */
@Override public HearthTreeNode startTurn(PlayerSide thisMinionPlayerIndex,HearthTreeNode boardModel) throws HSException {
  if (destroyOnTurnStart_) {
    this.setHealth((byte)-99);
  }
  if (stealthedUntilNextTurn && thisMinionPlayerIndex == PlayerSide.CURRENT_PLAYER)   this.setStealthedUntilNextTurn(false);
  return boardModel;
}",0.9463220675944334
112708,"protected HearthTreeNode createNodeWithChildren(HearthTreeNode boardState,Collection<HearthTreeNode> children){
  if (children != null) {
    if (children.size() == 1) {
      boardState=children.stream().findAny().get();
    }
 else     if (children.size() > 1) {
      boardState.addChildren(children);
    }
  }
  return boardState;
}","protected HearthTreeNode createNodeWithChildren(HearthTreeNode boardState,Collection<HearthTreeNode> children){
  if (children != null) {
    boardState.addChildren(children);
  }
  return boardState;
}",0.6419294990723562
112709,"@Override public HearthTreeNode performAction(Card origin,PlayerSide playerSide,HearthTreeNode boardState){
  HearthTreeNode toRet=super.performAction(origin,playerSide,boardState);
  if (playerSide == PlayerSide.CURRENT_PLAYER) {
    if (toRet instanceof CardDrawNode) {
      ((CardDrawNode)toRet).addNumCardsToDraw(numCards_);
    }
 else {
      toRet=new CardDrawNode(toRet,numCards_);
    }
  }
 else {
    toRet.data_.drawCardFromWaitingPlayerDeck(numCards_);
  }
  return toRet;
}","@Override public HearthTreeNode performAction(Card origin,PlayerSide playerSide,HearthTreeNode boardState){
  HearthTreeNode toRet=super.performAction(origin,playerSide,boardState);
  if (toRet == null)   return null;
  if (playerSide == PlayerSide.CURRENT_PLAYER) {
    if (toRet instanceof CardDrawNode) {
      ((CardDrawNode)toRet).addNumCardsToDraw(numCards_);
    }
 else {
      toRet=new CardDrawNode(toRet,numCards_);
    }
  }
 else {
    toRet.data_.drawCardFromWaitingPlayerDeck(numCards_);
  }
  return toRet;
}",0.9644268774703556
112710,"/** 
 * Use the card on the given target Transform a minion into 1/1 sheep
 * @param side
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public EffectCharacter getTargetableEffect(){
  if (this.effect == null) {
    this.effect=(originSide,origin,targetSide,targetCharacterIndex,boardState) -> {
      Sheep sheep=new Sheep();
      boardState.data_.removeMinion(targetSide,targetCharacterIndex);
      boardState.data_.placeMinion(targetSide,sheep,targetCharacterIndex);
      return boardState;
    }
;
  }
  return this.effect;
}","/** 
 * Use the card on the given target Transform a minion into 1/1 sheep
 * @param side
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public EffectCharacter getTargetableEffect(){
  if (this.effect == null) {
    this.effect=(originSide,origin,targetSide,targetCharacterIndex,boardState) -> {
      Sheep sheep=new Sheep();
      boardState.data_.removeMinion(targetSide,targetCharacterIndex);
      boardState.data_.placeMinion(targetSide,sheep,targetCharacterIndex.indexToLeft());
      return boardState;
    }
;
  }
  return this.effect;
}",0.9896602658788776
112711,"@Override public HearthTreeNode minionSummonEvent(PlayerSide thisMinionPlayerSide,PlayerSide summonedMinionPlayerSide,Minion summonedMinion,HearthTreeNode boardState){
  if (!KnifeJuggler.triggerFilter.targetMatches(thisMinionPlayerSide,this,summonedMinionPlayerSide,summonedMinion,boardState.data_)) {
    return boardState;
  }
  Collection<HearthTreeNode> rngChildren=this.effectRandomCharacterUsingFilter(KnifeJuggler.effect,null,KnifeJuggler.effectFilter,boardState);
  return this.createRngNodeWithChildren(boardState,rngChildren);
}","@Override public HearthTreeNode minionSummonEvent(PlayerSide thisMinionPlayerSide,PlayerSide summonedMinionPlayerSide,Minion summonedMinion,HearthTreeNode boardState){
  if (!KnifeJuggler.triggerFilter.targetMatches(thisMinionPlayerSide,this,summonedMinionPlayerSide,summonedMinion,boardState.data_)) {
    return boardState;
  }
  Collection<HearthTreeNode> rngChildren=this.effectRandomCharacterUsingFilter(KnifeJuggler.effect,null,KnifeJuggler.effectFilter,thisMinionPlayerSide,boardState);
  return this.createRngNodeWithChildren(boardState,rngChildren);
}",0.9808917197452228
112712,"/** 
 * Draw a card whenever this minion takes damage
 */
@Override public HearthTreeNode minionDeadEvent(PlayerSide thisMinionPlayerSide,PlayerSide deadMinionPlayerSide,Minion deadMinion,HearthTreeNode boardState){
  if (this.isInHand()) {
    return boardState;
  }
  if (!MekgineerThermaplugg.filter.targetMatches(thisMinionPlayerSide,this,deadMinionPlayerSide,deadMinion,boardState.data_)) {
    return boardState;
  }
  if (!this.isAlive()) {
    return boardState;
  }
  EffectCharacter<Minion> effect=new EffectCharacterSummon<>(new LeperGnome());
  return effect.applyEffect(thisMinionPlayerSide,this,thisMinionPlayerSide,this,boardState);
}","/** 
 * Draw a card whenever this minion takes damage
 */
@Override public HearthTreeNode minionDeadEvent(PlayerSide thisMinionPlayerSide,PlayerSide deadMinionPlayerSide,Minion deadMinion,HearthTreeNode boardState){
  if (this.isInHand()) {
    return boardState;
  }
  if (!MekgineerThermaplugg.filter.targetMatches(thisMinionPlayerSide,this,deadMinionPlayerSide,deadMinion,boardState.data_)) {
    return boardState;
  }
  if (!this.isAlive() || boardState.data_.modelForSide(thisMinionPlayerSide).isBoardFull()) {
    return boardState;
  }
  EffectCharacter<Minion> effect=new EffectCharacterSummon<>(new LeperGnome());
  return effect.applyEffect(thisMinionPlayerSide,this,thisMinionPlayerSide,this,boardState);
}",0.9495245062179956
112713,"/** 
 * Draw a card whenever this minion takes damage
 */
@Override public HearthTreeNode minionDeadEvent(PlayerSide thisMinionPlayerSide,PlayerSide deadMinionPlayerSide,Minion deadMinion,HearthTreeNode boardState){
  if (this.setInHand()) {
    return boardState;
  }
  if (!MekgineerThermaplugg.filter.targetMatches(thisMinionPlayerSide,this,deadMinionPlayerSide,deadMinion,boardState.data_)) {
    return boardState;
  }
  if (!this.isAlive() || boardState.data_.modelForSide(thisMinionPlayerSide).isBoardFull()) {
    return boardState;
  }
  EffectCharacter<Minion> effect=new EffectCharacterSummon<>(new LeperGnome());
  return effect.applyEffect(thisMinionPlayerSide,this,thisMinionPlayerSide,this,boardState);
}","/** 
 * Draw a card whenever this minion takes damage
 */
@Override public HearthTreeNode minionDeadEvent(PlayerSide thisMinionPlayerSide,PlayerSide deadMinionPlayerSide,Minion deadMinion,HearthTreeNode boardState){
  if (this.setInHand()) {
    return boardState;
  }
  if (!MekgineerThermaplugg.filter.targetMatches(thisMinionPlayerSide,this,deadMinionPlayerSide,deadMinion,boardState.data_)) {
    return boardState;
  }
  if (!this.isAlive() || boardState.data_.modelForSide(thisMinionPlayerSide).isBoardFull()) {
    return boardState;
  }
  if (boardState.data_.modelForSide(thisMinionPlayerSide).getNumMinions() >= 7) {
    return boardState;
  }
  EffectCharacter<Minion> effect=new EffectCharacterSummon<>(new LeperGnome());
  return effect.applyEffect(thisMinionPlayerSide,this,thisMinionPlayerSide,this,boardState);
}",0.929541047188106
112714,"@Test public void checkIncludeSpecifiedCardsLimitedCopies(){
  Random gen=new Random();
  ImplementedCard card1, card2;
  card1=referenceCards.get(gen.nextInt(referenceCards.size()));
  card2=referenceCards.get(gen.nextInt(referenceCards.size()));
  DeckFactoryBuilder builder=new DeckFactoryBuilder();
  builder.includeSpecificCards(card1,card2);
  Deck testDeck=builder.buildDeckFactory().generateRandomDeck();
  boolean test1Passed=false;
  boolean test2Passed=false;
  for (int i=0; i < 30; i++)   if (testDeck.drawCard(i).getName().equals(card1.name_))   test1Passed=true;
 else   if (testDeck.drawCard(i).getName().equals(card2.name_))   test2Passed=true;
  assertTrue(test1Passed);
  assertTrue(test2Passed);
}","@Test public void checkIncludeSpecifiedCardsLimitedCopies(){
  Random gen=new Random();
  ImplementedCard card1, card2;
  card1=referenceCards.get(gen.nextInt(referenceCards.size()));
  card2=referenceCards.get(gen.nextInt(referenceCards.size()));
  DeckFactoryBuilder builder=new DeckFactoryBuilder();
  builder.includeSpecificCards(card1,card2);
  Deck testDeck=builder.buildDeckFactory().generateRandomDeck();
  boolean test1Passed=false;
  boolean test2Passed=false;
  for (int i=0; i < 30; i++) {
    if (testDeck.drawCard(i).getName().equals(card1.name_))     test1Passed=true;
    if (testDeck.drawCard(i).getName().equals(card2.name_))     test2Passed=true;
  }
  assertTrue(card1.name_,test1Passed);
  assertTrue(card2.name_,test2Passed);
}",0.9727148703956344
112715,"@Test public void checkIncludeSpecifiedCardsUnlimitedCopies(){
  Random gen=new Random();
  ImplementedCard card1, card2;
  card1=referenceCards.get(gen.nextInt(referenceCards.size()));
  card2=referenceCards.get(gen.nextInt(referenceCards.size()));
  DeckFactoryBuilder builder=new DeckFactoryBuilder();
  builder.includeSpecificCards(card1,card2);
  builder.allowUnlimitedCopiesOfCards();
  Deck testDeck=builder.buildDeckFactory().generateRandomDeck();
  boolean test1Passed=false;
  boolean test2Passed=false;
  for (int i=0; i < 30; i++)   if (testDeck.drawCard(i).getName().equals(card1.name_))   test1Passed=true;
 else   if (testDeck.drawCard(i).getName().equals(card2.name_))   test2Passed=true;
  assertTrue(test1Passed);
  assertTrue(test2Passed);
}","@Test public void checkIncludeSpecifiedCardsUnlimitedCopies(){
  Random gen=new Random();
  ImplementedCard card1, card2;
  card1=referenceCards.get(gen.nextInt(referenceCards.size()));
  card2=referenceCards.get(gen.nextInt(referenceCards.size()));
  DeckFactoryBuilder builder=new DeckFactoryBuilder();
  builder.includeSpecificCards(card1,card2);
  builder.allowUnlimitedCopiesOfCards();
  Deck testDeck=builder.buildDeckFactory().generateRandomDeck();
  boolean test1Passed=false;
  boolean test2Passed=false;
  for (int i=0; i < 30; i++) {
    if (testDeck.drawCard(i).getName().equals(card1.name_))     test1Passed=true;
    if (testDeck.drawCard(i).getName().equals(card2.name_))     test2Passed=true;
  }
  assertTrue(card1.name_,test1Passed);
  assertTrue(card2.name_,test2Passed);
}",0.9742268041237112
112716,"/** 
 * Battlecry: Gain +1 Health for each card in your hand.
 */
@Override public EffectCharacter<Minion> getBattlecryEffect(){
  return (  PlayerSide originSide,  Minion origin,  PlayerSide targetSide,  int minionPlacementIndex,  HearthTreeNode boardState) -> {
    this.addHealth((byte)boardState.data_.getCurrentPlayer().getHand().size());
    return boardState;
  }
;
}","/** 
 * Battlecry: Gain +1 Health for each card in your hand.
 */
@Override public EffectCharacter<Minion> getBattlecryEffect(){
  return (  PlayerSide originSide,  Minion origin,  PlayerSide targetSide,  int minionPlacementIndex,  HearthTreeNode boardState) -> {
    this.addHealth((byte)boardState.data_.getCurrentPlayer().getHand().size());
    this.addMaxHealth((byte)boardState.data_.getCurrentPlayer().getHand().size());
    return boardState;
  }
;
}",0.8592057761732852
112717,"@Override public HearthTreeNode performAction(Card origin,PlayerSide playerSide,HearthTreeNode boardState,boolean singleRealizationOnly){
  List<BoardModel.CharacterLocation> locations=new ArrayList<>();
  for (  BoardModel.CharacterLocation location : boardState.data_) {
    if (this.filter.targetMatches(playerSide,origin,location.getPlayerSide(),location.getIndex(),boardState.data_)) {
      locations.add(location);
    }
  }
switch (locations.size()) {
case 0:
    break;
case 1:
  this.effect.applyEffect(playerSide,origin,locations.get(0).getPlayerSide(),locations.get(0).getIndex(),boardState);
break;
default :
RandomEffectNode rngNode=new RandomEffectNode(boardState,boardState.getAction());
for (BoardModel.CharacterLocation location : locations) {
HearthTreeNode newState=new HearthTreeNode(rngNode.data_.deepCopy());
this.cleanupBoard(playerSide,origin,boardState.data_,newState.data_);
this.effect.applyEffect(playerSide,origin,location.getPlayerSide(),location.getIndex(),newState);
rngNode.addChild(newState);
}
boardState=rngNode;
break;
}
return boardState;
}","@Override public HearthTreeNode performAction(Card origin,PlayerSide playerSide,HearthTreeNode boardState,boolean singleRealizationOnly){
  List<BoardModel.CharacterLocation> locations=new ArrayList<>();
  for (  BoardModel.CharacterLocation location : boardState.data_) {
    if (this.filter.targetMatches(playerSide,origin,location.getPlayerSide(),location.getIndex(),boardState.data_)) {
      locations.add(location);
    }
  }
switch (locations.size()) {
case 0:
    break;
case 1:
  this.effect.applyEffect(playerSide,origin,locations.get(0).getPlayerSide(),locations.get(0).getIndex(),boardState);
break;
default :
RandomEffectNode rngNode=new RandomEffectNode(boardState,boardState.getAction());
for (BoardModel.CharacterLocation location : locations) {
HearthTreeNode newState=new HearthTreeNode(rngNode.data_.deepCopy());
if (origin instanceof Minion) {
Card originReferenceInNewState=newState.data_.modelForSide(playerSide).getCharacter(boardState.data_.modelForSide(playerSide).getIndexForCharacter((Minion)origin));
this.effect.applyEffect(playerSide,origin,location.getPlayerSide(),location.getIndex(),newState);
this.cleanupBoard(originReferenceInNewState,newState.data_);
}
 else {
this.effect.applyEffect(playerSide,origin,location.getPlayerSide(),location.getIndex(),newState);
}
BoardStateFactoryBase.handleDeadMinions(newState,singleRealizationOnly);
rngNode.addChild(newState);
}
boardState=rngNode;
break;
}
return boardState;
}",0.6990905496243575
112718,"private void cleanupBoard(PlayerSide originSide,Card origin,BoardModel parent,BoardModel child){
  if (origin instanceof Minion) {
    int originIndex=parent.modelForSide(originSide).getIndexForCharacter((Minion)origin);
    child.removeMinion(originSide,originIndex - 1);
  }
}","private void cleanupBoard(Card originReferenceInNewState,BoardModel newState){
  if (originReferenceInNewState instanceof Minion) {
    newState.removeMinion((Minion)originReferenceInNewState);
  }
}",0.5241090146750524
112719,"@Override public HearthTreeNode performAction(Card origin,PlayerSide playerSide,HearthTreeNode boardState,boolean singleRealizationOnly){
  HearthTreeNode toRet=super.performAction(origin,playerSide,boardState,singleRealizationOnly);
  PlayerModel targetPlayer=toRet.data_.modelForSide(playerSide);
  int targetIndex=targetPlayer.getNumMinions();
  if (origin instanceof Minion) {
    targetIndex=targetPlayer.getIndexForCharacter((Minion)origin) - 1;
    toRet.data_.removeMinion((Minion)origin);
  }
  int numMinionsToActuallySummon=numMinions_;
  if (targetPlayer.isBoardFull()) {
    numMinionsToActuallySummon=7 - targetPlayer.getNumMinions();
  }
  for (int index=0; index < numMinionsToActuallySummon; ++index) {
    try {
      Minion newMinion=minionClass_.newInstance();
      toRet=newMinion.summonMinion(playerSide,targetIndex,toRet,false,true);
    }
 catch (    InstantiationException|IllegalAccessException e) {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
  return toRet;
}","@Override public HearthTreeNode performAction(Card origin,PlayerSide playerSide,HearthTreeNode boardState,boolean singleRealizationOnly){
  HearthTreeNode toRet=super.performAction(origin,playerSide,boardState,singleRealizationOnly);
  PlayerModel targetPlayer=toRet.data_.modelForSide(playerSide);
  int targetIndex=targetPlayer.getNumMinions();
  if (origin instanceof Minion) {
    targetIndex=targetPlayer.getIndexForCharacter((Minion)origin) - 1;
    toRet.data_.removeMinion((Minion)origin);
  }
  int numMinionsToActuallySummon=numMinions_;
  if (targetPlayer.getNumEmptyBoardSpace() < numMinionsToActuallySummon) {
    numMinionsToActuallySummon=targetPlayer.getNumEmptyBoardSpace();
  }
  for (int index=0; index < numMinionsToActuallySummon; ++index) {
    try {
      Minion newMinion=minionClass_.newInstance();
      toRet=newMinion.summonMinion(playerSide,targetIndex,toRet,false,true);
    }
 catch (    InstantiationException|IllegalAccessException e) {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
  return toRet;
}",0.9606222654350997
112720,"@Override public HearthTreeNode performAction(Card origin,PlayerSide playerSide,HearthTreeNode boardState,boolean singleRealizationOnly){
  PlayerModel owner=boardState.data_.modelForSide(playerSide);
  PlayerModel opposing=boardState.data_.modelForSide(playerSide.getOtherPlayer());
  List<Minion> friendlyTargets=new ArrayList<>();
  for (  Minion minion : owner.getMinions()) {
    if (this.filter.targetMatches(playerSide,origin,playerSide,minion,boardState.data_)) {
      friendlyTargets.add(minion);
    }
  }
  List<Minion> enemyTargets=new ArrayList<>();
  for (  Minion minion : opposing.getMinions()) {
    if (this.filter.targetMatches(playerSide,origin,playerSide.getOtherPlayer(),minion,boardState.data_)) {
      enemyTargets.add(minion);
    }
  }
  int totalTargets=friendlyTargets.size() + enemyTargets.size();
  Minion targetMinion;
switch (totalTargets) {
case 0:
    break;
case 1:
  targetMinion=friendlyTargets.size() > 0 ? friendlyTargets.get(0) : enemyTargets.get(0);
this.effect.applyEffect(playerSide,origin,playerSide,targetMinion,boardState);
break;
default :
RandomEffectNode rngNode=new RandomEffectNode(boardState,boardState.getAction());
for (Minion possibleTarget : friendlyTargets) {
int targetIndex=owner.getIndexForCharacter(possibleTarget);
HearthTreeNode newState=new HearthTreeNode(rngNode.data_.deepCopy());
this.cleanupBoard(playerSide,origin,boardState.data_,newState.data_);
this.effect.applyEffect(playerSide,origin,playerSide,targetIndex,newState);
rngNode.addChild(newState);
}
for (Minion possibleTarget : enemyTargets) {
int targetIndex=opposing.getIndexForCharacter(possibleTarget);
HearthTreeNode newState=new HearthTreeNode(rngNode.data_.deepCopy());
this.cleanupBoard(playerSide,origin,boardState.data_,newState.data_);
this.effect.applyEffect(playerSide,origin,playerSide.getOtherPlayer(),targetIndex,newState);
rngNode.addChild(newState);
}
boardState=rngNode;
break;
}
return boardState;
}","@Override public HearthTreeNode performAction(Card origin,PlayerSide playerSide,HearthTreeNode boardState,boolean singleRealizationOnly){
  List<BoardModel.CharacterLocation> locations=new ArrayList<>();
  for (  BoardModel.CharacterLocation location : boardState.data_) {
    if (this.filter.targetMatches(playerSide,origin,location.getPlayerSide(),location.getIndex(),boardState.data_)) {
      locations.add(location);
    }
  }
switch (locations.size()) {
case 0:
    break;
case 1:
  this.effect.applyEffect(playerSide,origin,locations.get(0).getPlayerSide(),locations.get(0).getIndex(),boardState);
break;
default :
RandomEffectNode rngNode=new RandomEffectNode(boardState,boardState.getAction());
for (BoardModel.CharacterLocation location : locations) {
HearthTreeNode newState=new HearthTreeNode(rngNode.data_.deepCopy());
this.cleanupBoard(playerSide,origin,boardState.data_,newState.data_);
this.effect.applyEffect(playerSide,origin,location.getPlayerSide(),location.getIndex(),newState);
rngNode.addChild(newState);
}
boardState=rngNode;
break;
}
return boardState;
}",0.25
112721,"/** 
 * Use the card on the given target <p> This is the core implementation of card's ability
 * @param side
 * @param boardState The BoardState before this card has performed its action. It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
protected HearthTreeNode use_core(PlayerSide side,Minion targetMinion,HearthTreeNode boardState,boolean singleRealizationOnly) throws HSException {
  HearthTreeNode toRet=boardState;
  CardEffectCharacter effect=null;
  if (this instanceof CardEffectTargetableInterface) {
    effect=((CardEffectTargetableInterface)this).getTargetableEffect();
  }
  byte manaCost=this.getManaCost(PlayerSide.CURRENT_PLAYER,boardState.data_);
  if (this instanceof SpellRandomInterface) {
    int originIndex=boardState.data_.modelForSide(PlayerSide.CURRENT_PLAYER).getHand().indexOf(this);
    int targetIndex=boardState.data_.modelForSide(side).getIndexForCharacter(targetMinion);
    toRet=new RandomEffectNode(toRet,new HearthAction(HearthAction.Verb.USE_CARD,side,0,side,0));
    Collection<HearthTreeNode> children=((SpellRandomInterface)this).createChildren(PlayerSide.CURRENT_PLAYER,originIndex,toRet);
    for (    HearthTreeNode child : children) {
      if (effect != null) {
        child=effect.applyEffect(PlayerSide.CURRENT_PLAYER,null,side,targetIndex,child);
      }
      child.data_.modelForSide(PlayerSide.CURRENT_PLAYER).subtractMana(manaCost);
      toRet.addChild(child);
    }
  }
 else {
    boolean removeCard=true;
    if (this instanceof CardEffectAoeInterface) {
      toRet=this.effectAllUsingFilter(((CardEffectAoeInterface)this).getAoeEffect(),((CardEffectAoeInterface)this).getAoeFilter(),toRet);
    }
 else     if (this instanceof CardEffectRandomTargetInterface) {
      removeCard=false;
      CardEffectRandomTargetInterface that=(CardEffectRandomTargetInterface)this;
      toRet=new RandomEffectNode(toRet,new HearthAction(HearthAction.Verb.USE_CARD,side,0,side,0));
      Collection<HearthTreeNode> children=this.effectRandomCharacterUsingFilter(that.getRandomTargetEffect(),that.getRandomTargetFilter(),toRet);
switch (children.size()) {
case 0:
        toRet=null;
      break;
case 1:
    toRet=children.stream().findAny().get();
  break;
default :
for (HearthTreeNode child : children) {
  child.data_.modelForSide(PlayerSide.CURRENT_PLAYER).subtractMana(manaCost);
  this.notifyCardPlayResolve(child,singleRealizationOnly);
  toRet.addChild(child);
}
}
}
 else if (effect != null) {
toRet=effect.applyEffect(PlayerSide.CURRENT_PLAYER,this,side,targetMinion,toRet);
}
if (toRet != null) {
PlayerModel currentPlayer=toRet.data_.getCurrentPlayer();
currentPlayer.subtractMana(manaCost);
if (removeCard) {
currentPlayer.getHand().remove(this);
}
}
}
return toRet;
}","/** 
 * Use the card on the given target <p> This is the core implementation of card's ability
 * @param side
 * @param boardState The BoardState before this card has performed its action. It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
protected HearthTreeNode use_core(PlayerSide side,Minion targetMinion,HearthTreeNode boardState,boolean singleRealizationOnly) throws HSException {
  HearthTreeNode toRet=boardState;
  int targetIndex=boardState.data_.modelForSide(side).getIndexForCharacter(targetMinion);
  CardEffectCharacter effect=null;
  if (this instanceof CardEffectTargetableInterface) {
    effect=((CardEffectTargetableInterface)this).getTargetableEffect();
  }
  byte manaCost=this.getManaCost(PlayerSide.CURRENT_PLAYER,boardState.data_);
  boolean doEffect=true;
  Collection<HearthTreeNode> rngChildren=null;
  if (this instanceof SpellRandomInterface) {
    int originIndex=boardState.data_.modelForSide(PlayerSide.CURRENT_PLAYER).getHand().indexOf(this);
    rngChildren=((SpellRandomInterface)this).createChildren(PlayerSide.CURRENT_PLAYER,originIndex,toRet);
  }
 else   if (this instanceof CardEffectRandomTargetInterface) {
    doEffect=false;
    CardEffectRandomTargetInterface that=(CardEffectRandomTargetInterface)this;
    rngChildren=this.effectRandomCharacterUsingFilter(that.getRandomTargetEffect(),that.getRandomTargetFilter(),toRet);
  }
 else   if (this instanceof CardEffectAoeInterface) {
    doEffect=false;
    toRet=this.effectAllUsingFilter(((CardEffectAoeInterface)this).getAoeEffect(),((CardEffectAoeInterface)this).getAoeFilter(),toRet);
  }
  if (toRet == null) {
    return null;
  }
  if (rngChildren != null) {
    toRet=new RandomEffectNode(toRet,new HearthAction(HearthAction.Verb.USE_CARD,side,0,side,0));
switch (rngChildren.size()) {
case 0:
      toRet=null;
    break;
case 1:
  toRet=rngChildren.stream().findAny().get();
toRet.data_.modelForSide(PlayerSide.CURRENT_PLAYER).subtractMana(manaCost);
if (doEffect && effect != null) {
toRet=effect.applyEffect(PlayerSide.CURRENT_PLAYER,null,side,targetIndex,toRet);
}
break;
default :
toRet=new RandomEffectNode(toRet,new HearthAction(HearthAction.Verb.USE_CARD,side,0,side,0));
for (HearthTreeNode child : rngChildren) {
if (doEffect && effect != null) {
child=effect.applyEffect(PlayerSide.CURRENT_PLAYER,null,side,targetIndex,child);
}
child.data_.modelForSide(PlayerSide.CURRENT_PLAYER).subtractMana(manaCost);
toRet.addChild(child);
}
}
}
 else {
if (doEffect && effect != null) {
toRet=effect.applyEffect(PlayerSide.CURRENT_PLAYER,this,side,targetMinion,toRet);
}
if (toRet != null) {
PlayerModel currentPlayer=toRet.data_.getCurrentPlayer();
toRet.data_.modelForSide(PlayerSide.CURRENT_PLAYER).subtractMana(manaCost);
currentPlayer.getHand().remove(this);
}
}
return toRet;
}",0.4730645736710667
112722,"@Override public HearthTreeNode useUntargetableBattlecry_core(int minionPlacementIndex,HearthTreeNode boardState,boolean singleRealizationOnly){
  return this.effectAllUsingFilter(this.getAoeEffect(),this.getAoeFilter(),boardState);
}","@Override public HearthTreeNode useUntargetableBattlecry_core(int minionPlacementIndex,HearthTreeNode boardState,boolean singleRealizationOnly){
  return this.effectAllUsingFilter(ColdlightSeer.effect,ColdlightSeer.filter,boardState);
}",0.8382978723404255
112723,"/** 
 * Battlecry: Heals friendly characters for 2
 */
@Override public HearthTreeNode useUntargetableBattlecry_core(int minionPlacementIndex,HearthTreeNode boardState,boolean singleRealizationOnly){
  return this.effectAllUsingFilter(this.getAoeEffect(),this.getAoeFilter(),boardState);
}","/** 
 * Battlecry: Heals friendly characters for 2
 */
@Override public HearthTreeNode useUntargetableBattlecry_core(int minionPlacementIndex,HearthTreeNode boardState,boolean singleRealizationOnly){
  return this.effectAllUsingFilter(DarkscaleHealer.effect,DarkscaleHealer.filter,boardState);
}",0.863013698630137
112724,"@Override public HearthTreeNode startTurn(PlayerSide thisMinionPlayerIndex,HearthTreeNode boardModel) throws HSException {
  HearthTreeNode toRet=boardModel;
  if (thisMinionPlayerIndex == PlayerSide.CURRENT_PLAYER) {
    toRet=this.effectAllUsingFilter(this.getAoeEffect(),this.getAoeFilter(),toRet);
  }
  return super.startTurn(thisMinionPlayerIndex,toRet);
}","@Override public HearthTreeNode startTurn(PlayerSide thisMinionPlayerIndex,HearthTreeNode boardModel) throws HSException {
  HearthTreeNode toRet=boardModel;
  if (thisMinionPlayerIndex == PlayerSide.CURRENT_PLAYER) {
    toRet=this.effectAllUsingFilter(Doomsayer.effect,Doomsayer.filter,toRet);
  }
  return super.startTurn(thisMinionPlayerIndex,toRet);
}",0.9164345403899722
112725,"/** 
 * Battlecry: Deals 1 damage to all characters
 */
@Override public HearthTreeNode useUntargetableBattlecry_core(int minionPlacementIndex,HearthTreeNode boardState,boolean singleRealizationOnly){
  return this.effectAllUsingFilter(this.getAoeEffect(),this.getAoeFilter(),boardState);
}","/** 
 * Battlecry: Deals 1 damage to all characters
 */
@Override public HearthTreeNode useUntargetableBattlecry_core(int minionPlacementIndex,HearthTreeNode boardState,boolean singleRealizationOnly){
  return this.effectAllUsingFilter(DreadInfernal.effect,DreadInfernal.filter,boardState);
}",0.8694158075601375
112726,"/** 
 * Use a targetable battlecry. This will add battlecry nodes to boardState as children.
 * @param side
 * @param targetMinion
 * @param boardState
 * @param deckPlayer0
 * @param deckPlayer1
 * @return
 * @throws HSException
 */
public HearthTreeNode useTargetableBattlecry(PlayerSide side,Minion targetMinion,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1,boolean singleRealizationOnly) throws HSException {
  if (this instanceof MinionTargetableBattlecry) {
    MinionTargetableBattlecry battlecryMinion=(MinionTargetableBattlecry)this;
    HearthTreeNode node=new HearthTreeNode(boardState.data_.deepCopy());
    int targetMinionIndex=side.getPlayer(boardState).getMinions().indexOf(targetMinion);
    if (targetMinionIndex >= 0) {
      node=battlecryMinion.useTargetableBattlecry_core(side,side.getPlayer(node).getMinions().get(targetMinionIndex),node,deckPlayer0,deckPlayer1);
    }
 else     if (targetMinion instanceof Hero) {
      node=battlecryMinion.useTargetableBattlecry_core(side,side.getPlayer(node).getHero(),node,deckPlayer0,deckPlayer1);
    }
 else {
      node=null;
    }
    if (node != null) {
      node=BoardStateFactoryBase.handleDeadMinions(node,deckPlayer0,deckPlayer1,singleRealizationOnly);
      boardState.addChild(node);
    }
  }
  return boardState;
}","/** 
 * Use a targetable battlecry. This will add battlecry nodes to boardState as children.
 * @param side
 * @param targetMinion
 * @param boardState
 * @param deckPlayer0
 * @param deckPlayer1
 * @return
 * @throws HSException
 */
public HearthTreeNode useTargetableBattlecry(PlayerSide side,Minion targetMinion,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1,boolean singleRealizationOnly) throws HSException {
  if (this instanceof MinionTargetableBattlecry) {
    HearthTreeNode node=new HearthTreeNode(boardState.data_.deepCopy());
    int originMinionIndex=PlayerSide.CURRENT_PLAYER.getPlayer(boardState).getMinions().indexOf(this);
    MinionTargetableBattlecry battlecryMinion=(MinionTargetableBattlecry)PlayerSide.CURRENT_PLAYER.getPlayer(node).getMinions().get(originMinionIndex);
    int targetMinionIndex=side.getPlayer(boardState).getMinions().indexOf(targetMinion);
    if (targetMinionIndex >= 0) {
      node=battlecryMinion.useTargetableBattlecry_core(side,side.getPlayer(node).getMinions().get(targetMinionIndex),node,deckPlayer0,deckPlayer1);
    }
 else     if (targetMinion instanceof Hero) {
      node=battlecryMinion.useTargetableBattlecry_core(side,side.getPlayer(node).getHero(),node,deckPlayer0,deckPlayer1);
    }
 else {
      node=null;
    }
    if (node != null) {
      node=BoardStateFactoryBase.handleDeadMinions(node,deckPlayer0,deckPlayer1,singleRealizationOnly);
      boardState.addChild(node);
    }
  }
  return boardState;
}",0.8732495511669659
112727,"@Override public HearthTreeNode performAction(Minion minion,PlayerSide playerSide,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  HearthTreeNode toRet=super.performAction(minion,playerSide,boardState,deckPlayer0,deckPlayer1);
  for (int index=0; index < numMinions_; ++index) {
    try {
      Minion newMinion=(Minion)minionClass_.newInstance();
      Minion placementTarget=toRet.data_.getCharacter(playerSide,toRet.data_.getMinions(playerSide).indexOf(minion));
      toRet.data_.removeMinion(minion);
      toRet=newMinion.summonMinion(playerSide,placementTarget,toRet,deckPlayer0,deckPlayer1,false,true);
    }
 catch (    InstantiationException|IllegalAccessException e) {
      throw new HSException();
    }
  }
  return toRet;
}","@Override public HearthTreeNode performAction(Minion minion,PlayerSide playerSide,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  HearthTreeNode toRet=super.performAction(minion,playerSide,boardState,deckPlayer0,deckPlayer1);
  Minion placementTarget=toRet.data_.getCharacter(playerSide,toRet.data_.getMinions(playerSide).indexOf(minion));
  toRet.data_.removeMinion(minion);
  int numMinionsToActuallySummon=numMinions_;
  if (playerSide.getPlayer(toRet).getMinions().size() + numMinions_ > 7)   numMinionsToActuallySummon=7 - playerSide.getPlayer(toRet).getMinions().size();
  for (int index=0; index < numMinionsToActuallySummon; ++index) {
    try {
      Minion newMinion=(Minion)minionClass_.newInstance();
      toRet=newMinion.summonMinion(playerSide,placementTarget,toRet,deckPlayer0,deckPlayer1,false,true);
    }
 catch (    InstantiationException|IllegalAccessException e) {
      throw new HSException();
    }
  }
  return toRet;
}",0.7001140250855188
112728,"protected HearthTreeNode notifyCardPlayResolve(HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1,boolean singleRealizationOnly) throws HSException {
  HearthTreeNode toRet=boardState;
  ArrayList<CardPlayAfterInterface> matches=new ArrayList<CardPlayAfterInterface>();
  for (  Card card : toRet.data_.getCurrentPlayerHand()) {
    if (card instanceof CardPlayAfterInterface) {
      matches.add((CardPlayAfterInterface)card);
    }
  }
  Card hero=toRet.data_.getCurrentPlayerHero();
  if (hero instanceof CardPlayAfterInterface) {
    matches.add((CardPlayAfterInterface)hero);
  }
  for (  Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced()) {
      if (minion instanceof CardPlayAfterInterface) {
        matches.add((CardPlayAfterInterface)minion);
      }
    }
  }
  for (  CardPlayAfterInterface match : matches) {
    toRet=match.onCardPlayResolve(PlayerSide.CURRENT_PLAYER,PlayerSide.CURRENT_PLAYER,this,toRet,deckPlayer0,deckPlayer1,singleRealizationOnly);
  }
  matches.clear();
  for (  Card card : toRet.data_.getWaitingPlayerHand()) {
    if (card instanceof CardPlayAfterInterface) {
      matches.add((CardPlayAfterInterface)card);
    }
  }
  hero=toRet.data_.getWaitingPlayerHero();
  if (hero instanceof CardPlayAfterInterface) {
    matches.add((CardPlayAfterInterface)hero);
  }
  for (  Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced()) {
      if (minion instanceof CardPlayAfterInterface) {
        matches.add((CardPlayAfterInterface)minion);
      }
    }
  }
  for (  CardPlayAfterInterface match : matches) {
    toRet=match.onCardPlayResolve(PlayerSide.WAITING_PLAYER,PlayerSide.CURRENT_PLAYER,this,toRet,deckPlayer0,deckPlayer1,singleRealizationOnly);
  }
  toRet=BoardStateFactoryBase.handleDeadMinions(toRet,deckPlayer0,deckPlayer1);
  return toRet;
}","protected HearthTreeNode notifyCardPlayResolve(HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1,boolean singleRealizationOnly) throws HSException {
  HearthTreeNode toRet=boardState;
  ArrayList<CardPlayAfterInterface> matches=new ArrayList<CardPlayAfterInterface>();
  for (  Card card : toRet.data_.getCurrentPlayerHand()) {
    if (card instanceof CardPlayAfterInterface) {
      matches.add((CardPlayAfterInterface)card);
    }
  }
  Card hero=toRet.data_.getCurrentPlayerHero();
  if (hero instanceof CardPlayAfterInterface) {
    matches.add((CardPlayAfterInterface)hero);
  }
  for (  Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced() && minion instanceof CardPlayAfterInterface) {
      matches.add((CardPlayAfterInterface)minion);
    }
  }
  for (  CardPlayAfterInterface match : matches) {
    toRet=match.onCardPlayResolve(PlayerSide.CURRENT_PLAYER,PlayerSide.CURRENT_PLAYER,this,toRet,deckPlayer0,deckPlayer1,singleRealizationOnly);
  }
  matches.clear();
  for (  Card card : toRet.data_.getWaitingPlayerHand()) {
    if (card instanceof CardPlayAfterInterface) {
      matches.add((CardPlayAfterInterface)card);
    }
  }
  hero=toRet.data_.getWaitingPlayerHero();
  if (hero instanceof CardPlayAfterInterface) {
    matches.add((CardPlayAfterInterface)hero);
  }
  for (  Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced() && minion instanceof CardPlayAfterInterface) {
      matches.add((CardPlayAfterInterface)minion);
    }
  }
  for (  CardPlayAfterInterface match : matches) {
    toRet=match.onCardPlayResolve(PlayerSide.WAITING_PLAYER,PlayerSide.CURRENT_PLAYER,this,toRet,deckPlayer0,deckPlayer1,singleRealizationOnly);
  }
  toRet=BoardStateFactoryBase.handleDeadMinions(toRet,deckPlayer0,deckPlayer1);
  return toRet;
}",0.942614240170032
112729,"protected HearthTreeNode notifyCardPlayBegin(HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1,boolean singleRealizationOnly) throws HSException {
  HearthTreeNode toRet=boardState;
  ArrayList<CardPlayBeginInterface> matches=new ArrayList<CardPlayBeginInterface>();
  for (  Card card : toRet.data_.getCurrentPlayerHand()) {
    if (card instanceof CardPlayBeginInterface) {
      matches.add((CardPlayBeginInterface)card);
    }
  }
  Card hero=toRet.data_.getCurrentPlayerHero();
  if (hero instanceof CardPlayBeginInterface) {
    matches.add((CardPlayBeginInterface)hero);
  }
  for (  Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced()) {
      if (minion instanceof CardPlayBeginInterface) {
        matches.add((CardPlayBeginInterface)minion);
      }
    }
  }
  for (  CardPlayBeginInterface match : matches) {
    toRet=match.onCardPlayBegin(PlayerSide.CURRENT_PLAYER,PlayerSide.CURRENT_PLAYER,this,toRet,deckPlayer0,deckPlayer1,singleRealizationOnly);
  }
  matches.clear();
  for (  Card card : toRet.data_.getWaitingPlayerHand()) {
    if (card instanceof CardPlayBeginInterface) {
      matches.add((CardPlayBeginInterface)card);
    }
  }
  hero=toRet.data_.getWaitingPlayerHero();
  if (hero instanceof CardPlayBeginInterface) {
    matches.add((CardPlayBeginInterface)hero);
  }
  for (  Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced()) {
      if (minion instanceof CardPlayBeginInterface) {
        matches.add((CardPlayBeginInterface)minion);
      }
    }
  }
  for (  CardPlayBeginInterface match : matches) {
    toRet=match.onCardPlayBegin(PlayerSide.WAITING_PLAYER,PlayerSide.CURRENT_PLAYER,this,toRet,deckPlayer0,deckPlayer1,singleRealizationOnly);
  }
  toRet=BoardStateFactoryBase.handleDeadMinions(toRet,deckPlayer0,deckPlayer1);
  return toRet;
}","protected HearthTreeNode notifyCardPlayBegin(HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1,boolean singleRealizationOnly) throws HSException {
  HearthTreeNode toRet=boardState;
  ArrayList<CardPlayBeginInterface> matches=new ArrayList<CardPlayBeginInterface>();
  for (  Card card : toRet.data_.getCurrentPlayerHand()) {
    if (card instanceof CardPlayBeginInterface) {
      matches.add((CardPlayBeginInterface)card);
    }
  }
  Card hero=toRet.data_.getCurrentPlayerHero();
  if (hero instanceof CardPlayBeginInterface) {
    matches.add((CardPlayBeginInterface)hero);
  }
  for (  Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced() && minion instanceof CardPlayBeginInterface) {
      matches.add((CardPlayBeginInterface)minion);
    }
  }
  for (  CardPlayBeginInterface match : matches) {
    toRet=match.onCardPlayBegin(PlayerSide.CURRENT_PLAYER,PlayerSide.CURRENT_PLAYER,this,toRet,deckPlayer0,deckPlayer1,singleRealizationOnly);
  }
  matches.clear();
  for (  Card card : toRet.data_.getWaitingPlayerHand()) {
    if (card instanceof CardPlayBeginInterface) {
      matches.add((CardPlayBeginInterface)card);
    }
  }
  hero=toRet.data_.getWaitingPlayerHero();
  if (hero instanceof CardPlayBeginInterface) {
    matches.add((CardPlayBeginInterface)hero);
  }
  for (  Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced() && minion instanceof CardPlayBeginInterface) {
      matches.add((CardPlayBeginInterface)minion);
    }
  }
  for (  CardPlayBeginInterface match : matches) {
    toRet=match.onCardPlayBegin(PlayerSide.WAITING_PLAYER,PlayerSide.CURRENT_PLAYER,this,toRet,deckPlayer0,deckPlayer1,singleRealizationOnly);
  }
  toRet=BoardStateFactoryBase.handleDeadMinions(toRet,deckPlayer0,deckPlayer1);
  return toRet;
}",0.9424307036247336
112730,"/** 
 * Returns whether this card can be used on the given target or not This function is an optional optimization feature. Some cards in Hearthstone have limited targets; Shadow Bolt cannot be used on heroes, Mind Blast can only target enemy heroes, etc. Even in this situation though, BoardStateFactory will still try to play non- sensical moves because it doesn't know that such moves are invalid until it tries to play them. The problem is, the BoardStateFactory has to go and make a deep copy of the current BoardState before it can go and try to play the invalid move, and it turns out that 98% of execution time in HearthSim is BoardStateFactory calling BoardState.deepCopy(). By overriding this function and returning false on appropriate occasions, we can save some calls to deepCopy and get better performance out of the code. By default, this function only checks mana cost.
 * @param playerSide
 * @param boardModel
 * @return
 */
public boolean canBeUsedOn(PlayerSide playerSide,Minion minion,BoardModel boardModel){
  return (this.getManaCost(PlayerSide.CURRENT_PLAYER,boardModel) <= boardModel.getCurrentPlayer().getMana());
}","/** 
 * Returns whether this card can be used on the given target or not This function is an optional optimization feature. Some cards in Hearthstone have limited targets; Shadow Bolt cannot be used on heroes, Mind Blast can only target enemy heroes, etc. Even in this situation though, BoardStateFactory will still try to play non- sensical moves because it doesn't know that such moves are invalid until it tries to play them. The problem is, the BoardStateFactory has to go and make a deep copy of the current BoardState before it can go and try to play the invalid move, and it turns out that 98% of execution time in HearthSim is BoardStateFactory calling BoardState.deepCopy(). By overriding this function and returning false on appropriate occasions, we can save some calls to deepCopy and get better performance out of the code. By default, this function only checks mana cost.
 * @param playerSide
 * @param boardModel
 * @return
 */
public boolean canBeUsedOn(PlayerSide playerSide,Minion minion,BoardModel boardModel){
  return this.getManaCost(PlayerSide.CURRENT_PLAYER,boardModel) <= boardModel.getCurrentPlayer().getMana();
}",0.999122807017544
112731,"protected HearthTreeNode notifyMinionSummon(HearthTreeNode boardState,PlayerSide targetSide,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  HearthTreeNode toRet=boardState;
  ArrayList<MinionSummonedInterface> matches=new ArrayList<MinionSummonedInterface>();
  Card hero=toRet.data_.getCurrentPlayerHero();
  if (hero instanceof MinionSummonedInterface) {
    matches.add((MinionSummonedInterface)hero);
  }
  for (  Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced()) {
      if (minion instanceof MinionSummonedInterface) {
        matches.add((MinionSummonedInterface)minion);
      }
    }
  }
  for (  MinionSummonedInterface match : matches) {
    toRet=match.minionSummonEvent(PlayerSide.CURRENT_PLAYER,targetSide,this,toRet,deckPlayer0,deckPlayer1);
  }
  matches.clear();
  hero=toRet.data_.getWaitingPlayerHero();
  if (hero instanceof MinionSummonedInterface) {
    matches.add((MinionSummonedInterface)hero);
  }
  for (  Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced()) {
      if (minion instanceof MinionSummonedInterface) {
        matches.add((MinionSummonedInterface)minion);
      }
    }
  }
  for (  MinionSummonedInterface match : matches) {
    toRet=match.minionSummonEvent(PlayerSide.WAITING_PLAYER,targetSide,this,toRet,deckPlayer0,deckPlayer1);
  }
  return toRet;
}","protected HearthTreeNode notifyMinionSummon(HearthTreeNode boardState,PlayerSide targetSide,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  HearthTreeNode toRet=boardState;
  ArrayList<MinionSummonedInterface> matches=new ArrayList<MinionSummonedInterface>();
  Card hero=toRet.data_.getCurrentPlayerHero();
  if (hero instanceof MinionSummonedInterface) {
    matches.add((MinionSummonedInterface)hero);
  }
  for (  Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced() && minion instanceof MinionSummonedInterface) {
      matches.add((MinionSummonedInterface)minion);
    }
  }
  for (  MinionSummonedInterface match : matches) {
    toRet=match.minionSummonEvent(PlayerSide.CURRENT_PLAYER,targetSide,this,toRet,deckPlayer0,deckPlayer1);
  }
  matches.clear();
  hero=toRet.data_.getWaitingPlayerHero();
  if (hero instanceof MinionSummonedInterface) {
    matches.add((MinionSummonedInterface)hero);
  }
  for (  Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced() && minion instanceof MinionSummonedInterface) {
      matches.add((MinionSummonedInterface)minion);
    }
  }
  for (  MinionSummonedInterface match : matches) {
    toRet=match.minionSummonEvent(PlayerSide.WAITING_PLAYER,targetSide,this,toRet,deckPlayer0,deckPlayer1);
  }
  return toRet;
}",0.9210337401292176
112732,"protected HearthTreeNode notifyMinionPlayed(HearthTreeNode boardState,PlayerSide targetSide,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  HearthTreeNode toRet=boardState;
  ArrayList<MinionPlayedInterface> matches=new ArrayList<MinionPlayedInterface>();
  Card hero=toRet.data_.getCurrentPlayerHero();
  if (hero instanceof MinionPlayedInterface) {
    matches.add((MinionPlayedInterface)hero);
  }
  for (  Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced()) {
      if (minion instanceof MinionPlayedInterface) {
        matches.add((MinionPlayedInterface)minion);
      }
    }
  }
  for (  MinionPlayedInterface match : matches) {
    toRet=match.minionPlayedEvent(PlayerSide.CURRENT_PLAYER,targetSide,this,toRet,deckPlayer0,deckPlayer1);
  }
  matches.clear();
  hero=toRet.data_.getWaitingPlayerHero();
  if (hero instanceof MinionPlayedInterface) {
    matches.add((MinionPlayedInterface)hero);
  }
  for (  Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced()) {
      if (minion instanceof MinionPlayedInterface) {
        matches.add((MinionPlayedInterface)minion);
      }
    }
  }
  for (  MinionPlayedInterface match : matches) {
    toRet=match.minionPlayedEvent(PlayerSide.WAITING_PLAYER,targetSide,this,toRet,deckPlayer0,deckPlayer1);
  }
  return toRet;
}","protected HearthTreeNode notifyMinionPlayed(HearthTreeNode boardState,PlayerSide targetSide,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  HearthTreeNode toRet=boardState;
  ArrayList<MinionPlayedInterface> matches=new ArrayList<MinionPlayedInterface>();
  Card hero=toRet.data_.getCurrentPlayerHero();
  if (hero instanceof MinionPlayedInterface) {
    matches.add((MinionPlayedInterface)hero);
  }
  for (  Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced() && minion instanceof MinionPlayedInterface) {
      matches.add((MinionPlayedInterface)minion);
    }
  }
  for (  MinionPlayedInterface match : matches) {
    toRet=match.minionPlayedEvent(PlayerSide.CURRENT_PLAYER,targetSide,this,toRet,deckPlayer0,deckPlayer1);
  }
  matches.clear();
  hero=toRet.data_.getWaitingPlayerHero();
  if (hero instanceof MinionPlayedInterface) {
    matches.add((MinionPlayedInterface)hero);
  }
  for (  Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced() && minion instanceof MinionPlayedInterface) {
      matches.add((MinionPlayedInterface)minion);
    }
  }
  for (  MinionPlayedInterface match : matches) {
    toRet=match.minionPlayedEvent(PlayerSide.WAITING_PLAYER,targetSide,this,toRet,deckPlayer0,deckPlayer1);
  }
  return toRet;
}",0.9225712198685172
112733,"protected HearthTreeNode notifyMinionHealed(HearthTreeNode boardState,PlayerSide targetSide,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  HearthTreeNode toRet=boardState;
  ArrayList<MinionHealedInterface> matches=new ArrayList<MinionHealedInterface>();
  Card hero=toRet.data_.getCurrentPlayerHero();
  if (hero instanceof MinionHealedInterface) {
    matches.add((MinionHealedInterface)hero);
  }
  for (  Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced()) {
      if (minion instanceof MinionHealedInterface) {
        matches.add((MinionHealedInterface)minion);
      }
    }
  }
  for (  MinionHealedInterface match : matches) {
    toRet=match.minionHealedEvent(PlayerSide.CURRENT_PLAYER,targetSide,this,toRet,deckPlayer0,deckPlayer1);
  }
  matches.clear();
  hero=toRet.data_.getWaitingPlayerHero();
  if (hero instanceof MinionHealedInterface) {
    matches.add((MinionHealedInterface)hero);
  }
  for (  Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced()) {
      if (minion instanceof MinionHealedInterface) {
        matches.add((MinionHealedInterface)minion);
      }
    }
  }
  for (  MinionHealedInterface match : matches) {
    toRet=match.minionHealedEvent(PlayerSide.WAITING_PLAYER,targetSide,this,toRet,deckPlayer0,deckPlayer1);
  }
  return toRet;
}","protected HearthTreeNode notifyMinionHealed(HearthTreeNode boardState,PlayerSide targetSide,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  HearthTreeNode toRet=boardState;
  ArrayList<MinionHealedInterface> matches=new ArrayList<MinionHealedInterface>();
  Card hero=toRet.data_.getCurrentPlayerHero();
  if (hero instanceof MinionHealedInterface) {
    matches.add((MinionHealedInterface)hero);
  }
  for (  Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced() && minion instanceof MinionHealedInterface) {
      matches.add((MinionHealedInterface)minion);
    }
  }
  for (  MinionHealedInterface match : matches) {
    toRet=match.minionHealedEvent(PlayerSide.CURRENT_PLAYER,targetSide,this,toRet,deckPlayer0,deckPlayer1);
  }
  matches.clear();
  hero=toRet.data_.getWaitingPlayerHero();
  if (hero instanceof MinionHealedInterface) {
    matches.add((MinionHealedInterface)hero);
  }
  for (  Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced() && minion instanceof MinionHealedInterface) {
      matches.add((MinionHealedInterface)minion);
    }
  }
  for (  MinionHealedInterface match : matches) {
    toRet=match.minionHealedEvent(PlayerSide.WAITING_PLAYER,targetSide,this,toRet,deckPlayer0,deckPlayer1);
  }
  return toRet;
}",0.9225712198685172
112734,"protected HearthTreeNode notifyMinionPlacement(HearthTreeNode boardState,PlayerSide targetSide,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  HearthTreeNode toRet=boardState;
  ArrayList<MinionPlacedInterface> matches=new ArrayList<MinionPlacedInterface>();
  Card hero=toRet.data_.getCurrentPlayerHero();
  if (hero instanceof MinionPlacedInterface) {
    matches.add((MinionPlacedInterface)hero);
  }
  for (  Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced()) {
      if (minion instanceof MinionPlacedInterface) {
        matches.add((MinionPlacedInterface)minion);
      }
    }
  }
  for (  MinionPlacedInterface match : matches) {
    toRet=match.minionPlacedEvent(PlayerSide.CURRENT_PLAYER,targetSide,this,toRet,deckPlayer0,deckPlayer1);
  }
  matches.clear();
  hero=toRet.data_.getWaitingPlayerHero();
  if (hero instanceof MinionPlacedInterface) {
    matches.add((MinionPlacedInterface)hero);
  }
  for (  Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced()) {
      if (minion instanceof MinionPlacedInterface) {
        matches.add((MinionPlacedInterface)minion);
      }
    }
  }
  for (  MinionPlacedInterface match : matches) {
    toRet=match.minionPlacedEvent(PlayerSide.WAITING_PLAYER,targetSide,this,toRet,deckPlayer0,deckPlayer1);
  }
  return toRet;
}","protected HearthTreeNode notifyMinionPlacement(HearthTreeNode boardState,PlayerSide targetSide,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  HearthTreeNode toRet=boardState;
  ArrayList<MinionPlacedInterface> matches=new ArrayList<MinionPlacedInterface>();
  Card hero=toRet.data_.getCurrentPlayerHero();
  if (hero instanceof MinionPlacedInterface) {
    matches.add((MinionPlacedInterface)hero);
  }
  for (  Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced() && minion instanceof MinionPlacedInterface) {
      matches.add((MinionPlacedInterface)minion);
    }
  }
  for (  MinionPlacedInterface match : matches) {
    toRet=match.minionPlacedEvent(PlayerSide.CURRENT_PLAYER,targetSide,this,toRet,deckPlayer0,deckPlayer1);
  }
  matches.clear();
  hero=toRet.data_.getWaitingPlayerHero();
  if (hero instanceof MinionPlacedInterface) {
    matches.add((MinionPlacedInterface)hero);
  }
  for (  Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced() && minion instanceof MinionPlacedInterface) {
      matches.add((MinionPlacedInterface)minion);
    }
  }
  for (  MinionPlacedInterface match : matches) {
    toRet=match.minionPlacedEvent(PlayerSide.WAITING_PLAYER,targetSide,this,toRet,deckPlayer0,deckPlayer1);
  }
  return toRet;
}",0.922740524781341
112735,"protected HearthTreeNode notifyMinionDamaged(HearthTreeNode boardState,PlayerSide targetSide,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  HearthTreeNode toRet=boardState;
  ArrayList<MinionDamagedInterface> matches=new ArrayList<MinionDamagedInterface>();
  Card hero=toRet.data_.getCurrentPlayerHero();
  if (hero instanceof MinionDamagedInterface) {
    matches.add((MinionDamagedInterface)hero);
  }
  for (  Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced()) {
      if (minion instanceof MinionDamagedInterface) {
        matches.add((MinionDamagedInterface)minion);
      }
    }
  }
  for (  MinionDamagedInterface match : matches) {
    toRet=match.minionDamagedEvent(PlayerSide.CURRENT_PLAYER,targetSide,this,toRet,deckPlayer0,deckPlayer1);
  }
  matches.clear();
  hero=toRet.data_.getWaitingPlayerHero();
  if (hero instanceof MinionDamagedInterface) {
    matches.add((MinionDamagedInterface)hero);
  }
  for (  Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced()) {
      if (minion instanceof MinionDamagedInterface) {
        matches.add((MinionDamagedInterface)minion);
      }
    }
  }
  for (  MinionDamagedInterface match : matches) {
    toRet=match.minionDamagedEvent(PlayerSide.WAITING_PLAYER,targetSide,this,toRet,deckPlayer0,deckPlayer1);
  }
  return toRet;
}","protected HearthTreeNode notifyMinionDamaged(HearthTreeNode boardState,PlayerSide targetSide,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  HearthTreeNode toRet=boardState;
  ArrayList<MinionDamagedInterface> matches=new ArrayList<MinionDamagedInterface>();
  Card hero=toRet.data_.getCurrentPlayerHero();
  if (hero instanceof MinionDamagedInterface) {
    matches.add((MinionDamagedInterface)hero);
  }
  for (  Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced() && minion instanceof MinionDamagedInterface) {
      matches.add((MinionDamagedInterface)minion);
    }
  }
  for (  MinionDamagedInterface match : matches) {
    toRet=match.minionDamagedEvent(PlayerSide.CURRENT_PLAYER,targetSide,this,toRet,deckPlayer0,deckPlayer1);
  }
  matches.clear();
  hero=toRet.data_.getWaitingPlayerHero();
  if (hero instanceof MinionDamagedInterface) {
    matches.add((MinionDamagedInterface)hero);
  }
  for (  Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced() && minion instanceof MinionDamagedInterface) {
      matches.add((MinionDamagedInterface)minion);
    }
  }
  for (  MinionDamagedInterface match : matches) {
    toRet=match.minionDamagedEvent(PlayerSide.WAITING_PLAYER,targetSide,this,toRet,deckPlayer0,deckPlayer1);
  }
  return toRet;
}",0.9219653179190752
112736,"protected HearthTreeNode notifyMinionDead(PlayerSide deadMinionPlayerSide,Minion deadMinion,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  HearthTreeNode toRet=boardState;
  ArrayList<MinionDeadInterface> matches=new ArrayList<MinionDeadInterface>();
  Card hero=toRet.data_.getCurrentPlayerHero();
  if (hero instanceof MinionDeadInterface) {
    matches.add((MinionDeadInterface)hero);
  }
  for (  Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced()) {
      if (minion instanceof MinionDeadInterface) {
        matches.add((MinionDeadInterface)minion);
      }
    }
  }
  for (  MinionDeadInterface match : matches) {
    toRet=match.minionDeadEvent(PlayerSide.CURRENT_PLAYER,deadMinionPlayerSide,deadMinion,toRet,deckPlayer0,deckPlayer1);
  }
  matches.clear();
  hero=toRet.data_.getWaitingPlayerHero();
  if (hero instanceof MinionDeadInterface) {
    matches.add((MinionDeadInterface)hero);
  }
  for (  Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced()) {
      if (minion instanceof MinionDeadInterface) {
        matches.add((MinionDeadInterface)minion);
      }
    }
  }
  for (  MinionDeadInterface match : matches) {
    toRet=match.minionDeadEvent(PlayerSide.WAITING_PLAYER,deadMinionPlayerSide,deadMinion,toRet,deckPlayer0,deckPlayer1);
  }
  return toRet;
}","protected HearthTreeNode notifyMinionDead(PlayerSide deadMinionPlayerSide,Minion deadMinion,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  HearthTreeNode toRet=boardState;
  ArrayList<MinionDeadInterface> matches=new ArrayList<MinionDeadInterface>();
  Card hero=toRet.data_.getCurrentPlayerHero();
  if (hero instanceof MinionDeadInterface) {
    matches.add((MinionDeadInterface)hero);
  }
  for (  Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced() && minion instanceof MinionDeadInterface) {
      matches.add((MinionDeadInterface)minion);
    }
  }
  for (  MinionDeadInterface match : matches) {
    toRet=match.minionDeadEvent(PlayerSide.CURRENT_PLAYER,deadMinionPlayerSide,deadMinion,toRet,deckPlayer0,deckPlayer1);
  }
  matches.clear();
  hero=toRet.data_.getWaitingPlayerHero();
  if (hero instanceof MinionDeadInterface) {
    matches.add((MinionDeadInterface)hero);
  }
  for (  Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
    if (!minion.isSilenced() && minion instanceof MinionDeadInterface) {
      matches.add((MinionDeadInterface)minion);
    }
  }
  for (  MinionDeadInterface match : matches) {
    toRet=match.minionDeadEvent(PlayerSide.WAITING_PLAYER,deadMinionPlayerSide,deadMinion,toRet,deckPlayer0,deckPlayer1);
  }
  return toRet;
}",0.9270907791279486
112737,"public Game(PlayerModel playerModel0,PlayerModel playerModel1,ArtificialPlayer ai0,ArtificialPlayer ai1,boolean shufflePlayOrder){
  playerGoingFirst=playerModel0;
  playerGoingSecond=playerModel1;
  aiForPlayerGoingFirst=ai0;
  aiForPlayerGoingSecond=ai1;
  if (shufflePlayOrder && Math.random() > 0.5) {
    playerGoingFirst=playerModel1;
    playerGoingSecond=playerModel0;
    aiForPlayerGoingFirst=ai1;
    aiForPlayerGoingSecond=ai0;
  }
  log.debug(""String_Node_Str"",shufflePlayOrder);
  log.debug(""String_Node_Str"",playerGoingFirst.getPlayerId());
  boardModel=new BoardModel(playerGoingFirst,playerGoingSecond);
}","public Game(PlayerModel playerModel0,PlayerModel playerModel1,ArtificialPlayer ai0,ArtificialPlayer ai1,boolean shufflePlayOrder){
  this(playerModel0,playerModel1,ai0,ai1,(shufflePlayOrder && Math.random() >= 0.5) ? 0 : 1);
}",0.4245283018867924
112738,"public void setWindfury(boolean value){
  windFury_=value;
}","public void setWindfury(boolean value){
  windFury_=value;
  if (hasAttacked_) {
    hasAttacked_=false;
    hasWindFuryAttacked_=true;
  }
}",0.5970149253731343
112739,"@Test @Ignore(""String_Node_Str"") public void testWindfuryPostAttack() throws HSException {
  Minion target=board.data_.getCharacter(PlayerSide.WAITING_PLAYER,0);
  HearthTreeNode ret=raptor.attack(PlayerSide.WAITING_PLAYER,target,board,null,null);
  assertEquals(board,ret);
  assertFalse(raptor.canAttack());
  assertEquals(30,board.data_.getCurrentPlayerHero().getHealth());
  assertEquals(27,board.data_.getWaitingPlayerHero().getHealth());
  raptor.setWindfury(true);
  assertTrue(raptor.canAttack());
  ret=raptor.attack(PlayerSide.WAITING_PLAYER,target,board,null,null);
  assertEquals(board,ret);
  assertFalse(raptor.canAttack());
  assertEquals(30,board.data_.getCurrentPlayerHero().getHealth());
  assertEquals(24,board.data_.getWaitingPlayerHero().getHealth());
}","@Test public void testWindfuryPostAttack() throws HSException {
  Minion target=board.data_.getCharacter(PlayerSide.WAITING_PLAYER,0);
  HearthTreeNode ret=raptor.attack(PlayerSide.WAITING_PLAYER,target,board,null,null);
  assertEquals(board,ret);
  assertFalse(raptor.canAttack());
  assertEquals(30,board.data_.getCurrentPlayerHero().getHealth());
  assertEquals(27,board.data_.getWaitingPlayerHero().getHealth());
  raptor.setWindfury(true);
  assertTrue(raptor.canAttack());
  ret=raptor.attack(PlayerSide.WAITING_PLAYER,target,board,null,null);
  assertEquals(board,ret);
  assertFalse(raptor.canAttack());
  assertEquals(30,board.data_.getCurrentPlayerHero().getHealth());
  assertEquals(24,board.data_.getWaitingPlayerHero().getHealth());
}",0.9822485207100592
112740,"public GameResult runGame() throws HSException {
  curTurn_=0;
  boardModel_.placeCardHandCurrentPlayer(0);
  boardModel_.placeCardHandCurrentPlayer(1);
  boardModel_.placeCardHandCurrentPlayer(2);
  boardModel_.setDeckPos_p0(3);
  boardModel_.placeCardHandWaitingPlayer(0);
  boardModel_.placeCardHandWaitingPlayer(1);
  boardModel_.placeCardHandWaitingPlayer(2);
  boardModel_.placeCardHandWaitingPlayer(3);
  boardModel_.placeCardHandWaitingPlayer(new TheCoin());
  boardModel_.setDeckPos_p1(4);
  GameRecord record=new GameSimpleRecord();
  record.put(0,PlayerSide.CURRENT_PLAYER,(BoardModel)boardModel_.deepCopy(),null);
  record.put(0,PlayerSide.CURRENT_PLAYER,(BoardModel)boardModel_.flipPlayers().deepCopy(),null);
  GameResult gameResult;
  for (int turnCount=0; turnCount < maxTurns_; ++turnCount) {
    log.debug(""String_Node_Str"" + turnCount);
    long turnStart=System.currentTimeMillis();
    gameResult=playTurn(turnCount,record,aiForPlayerGoingFirst);
    if (gameResult != null)     return gameResult;
    gameResult=playTurn(turnCount,record,aiForPlayerGoingSecond);
    if (gameResult != null)     return gameResult;
    long turnEnd=System.currentTimeMillis();
    long turnDelta=turnEnd - turnStart;
    if (turnDelta > aiForPlayerGoingFirst.getMaxThinkTime() / 2) {
      log.warn(""String_Node_Str"",turnDelta,aiForPlayerGoingFirst.getMaxThinkTime());
    }
 else {
      log.debug(""String_Node_Str"",turnDelta);
    }
  }
  return new GameResult(playerGoingFirst.getPlayerId(),-1,0,record);
}","public GameResult runGame() throws HSException {
  curTurn_=0;
  boardModel.placeCardHandCurrentPlayer(0);
  boardModel.placeCardHandCurrentPlayer(1);
  boardModel.placeCardHandCurrentPlayer(2);
  boardModel.setDeckPos_p0(3);
  boardModel.placeCardHandWaitingPlayer(0);
  boardModel.placeCardHandWaitingPlayer(1);
  boardModel.placeCardHandWaitingPlayer(2);
  boardModel.placeCardHandWaitingPlayer(3);
  boardModel.placeCardHandWaitingPlayer(new TheCoin());
  boardModel.setDeckPos_p1(4);
  GameRecord record=new GameSimpleRecord();
  record.put(0,PlayerSide.CURRENT_PLAYER,(BoardModel)boardModel.deepCopy(),null);
  record.put(0,PlayerSide.CURRENT_PLAYER,(BoardModel)boardModel.flipPlayers().deepCopy(),null);
  GameResult gameResult;
  for (int turnCount=0; turnCount < maxTurns_; ++turnCount) {
    log.debug(""String_Node_Str"" + turnCount);
    long turnStart=System.currentTimeMillis();
    gameResult=playTurn(turnCount,record,aiForPlayerGoingFirst);
    if (gameResult != null)     return gameResult;
    gameResult=playTurn(turnCount,record,aiForPlayerGoingSecond);
    if (gameResult != null)     return gameResult;
    long turnEnd=System.currentTimeMillis();
    long turnDelta=turnEnd - turnStart;
    if (turnDelta > aiForPlayerGoingFirst.getMaxThinkTime() / 2) {
      log.warn(""String_Node_Str"",turnDelta,aiForPlayerGoingFirst.getMaxThinkTime());
    }
 else {
      log.debug(""String_Node_Str"",turnDelta);
    }
  }
  return new GameResult(playerGoingFirst.getPlayerId(),-1,0,record);
}",0.8566688785666888
112741,"public Game(PlayerModel playerModel0,PlayerModel playerModel1,ArtificialPlayer ai0,ArtificialPlayer ai1,boolean shufflePlayOrder){
  playerGoingFirst=playerModel0;
  playerGoingSecond=playerModel1;
  aiForPlayerGoingFirst=ai0;
  aiForPlayerGoingSecond=ai1;
  if (shufflePlayOrder && Math.random() > 0.5) {
    playerGoingFirst=playerModel1;
    playerGoingSecond=playerModel0;
    aiForPlayerGoingFirst=ai1;
    aiForPlayerGoingSecond=ai0;
  }
  log.debug(""String_Node_Str"",shufflePlayOrder);
  log.debug(""String_Node_Str"",playerGoingFirst.getPlayerId());
  boardModel_=new BoardModel(playerGoingFirst,playerGoingSecond);
}","public Game(PlayerModel playerModel0,PlayerModel playerModel1,ArtificialPlayer ai0,ArtificialPlayer ai1,boolean shufflePlayOrder){
  playerGoingFirst=playerModel0;
  playerGoingSecond=playerModel1;
  aiForPlayerGoingFirst=ai0;
  aiForPlayerGoingSecond=ai1;
  if (shufflePlayOrder && Math.random() > 0.5) {
    playerGoingFirst=playerModel1;
    playerGoingSecond=playerModel0;
    aiForPlayerGoingFirst=ai1;
    aiForPlayerGoingSecond=ai0;
  }
  log.debug(""String_Node_Str"",shufflePlayOrder);
  log.debug(""String_Node_Str"",playerGoingFirst.getPlayerId());
  boardModel=new BoardModel(playerGoingFirst,playerGoingSecond);
}",0.9991967871485944
112742,"public GameResult checkGameOver(int turnCount,GameRecord record){
  if (!boardModel_.isAlive(PlayerSide.CURRENT_PLAYER)) {
    PlayerModel winner=boardModel_.modelForSide(PlayerSide.WAITING_PLAYER);
    return new GameResult(playerGoingFirst.getPlayerId(),winner.getPlayerId(),turnCount + 1,record);
  }
 else   if (!boardModel_.isAlive(PlayerSide.WAITING_PLAYER)) {
    PlayerModel winner=boardModel_.modelForSide(PlayerSide.CURRENT_PLAYER);
    return new GameResult(playerGoingFirst.getPlayerId(),winner.getPlayerId(),turnCount + 1,record);
  }
  return null;
}","public GameResult checkGameOver(int turnCount,GameRecord record){
  if (!boardModel.isAlive(PlayerSide.CURRENT_PLAYER)) {
    PlayerModel winner=boardModel.modelForSide(PlayerSide.WAITING_PLAYER);
    return new GameResult(playerGoingFirst.getPlayerId(),winner.getPlayerId(),turnCount + 1,record);
  }
 else   if (!boardModel.isAlive(PlayerSide.WAITING_PLAYER)) {
    PlayerModel winner=boardModel.modelForSide(PlayerSide.CURRENT_PLAYER);
    return new GameResult(playerGoingFirst.getPlayerId(),winner.getPlayerId(),turnCount + 1,record);
  }
  return null;
}",0.99644128113879
112743,"private GameResult playTurn(int turnCount,GameRecord record,ArtificialPlayer ai) throws HSException {
  beginTurn(boardModel_);
  GameResult gameResult;
  gameResult=checkGameOver(turnCount,record);
  if (gameResult != null)   return gameResult;
  List<HearthActionBoardPair> allMoves=playAITurn(turnCount,boardModel_,ai);
  if (allMoves.size() > 0) {
    boardModel_=allMoves.get(allMoves.size() - 1).board;
  }
  boardModel_=endTurn(boardModel_);
  record.put(turnCount + 1,PlayerSide.CURRENT_PLAYER,(BoardModel)boardModel_.deepCopy(),allMoves);
  gameResult=checkGameOver(turnCount,record);
  if (gameResult != null)   return gameResult;
  boardModel_=boardModel_.flipPlayers();
  return null;
}","private GameResult playTurn(int turnCount,GameRecord record,ArtificialPlayer ai) throws HSException {
  beginTurn(boardModel);
  GameResult gameResult;
  gameResult=checkGameOver(turnCount,record);
  if (gameResult != null)   return gameResult;
  List<HearthActionBoardPair> allMoves=playAITurn(turnCount,boardModel,ai);
  if (allMoves.size() > 0) {
    boardModel=allMoves.get(allMoves.size() - 1).board;
  }
  boardModel=endTurn(boardModel);
  record.put(turnCount + 1,PlayerSide.CURRENT_PLAYER,(BoardModel)boardModel.deepCopy(),allMoves);
  gameResult=checkGameOver(turnCount,record);
  if (gameResult != null)   return gameResult;
  boardModel=boardModel.flipPlayers();
  return null;
}",0.978386167146974
112744,"/** 
 * Discards a random card
 * @param side
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public HearthTreeNode useOn(PlayerSide side,Minion targetMinion,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1,boolean singleRealizationOnly) throws HSException {
  HearthTreeNode toRet=null;
  if (singleRealizationOnly) {
    toRet=super.useOn(side,targetMinion,boardState,deckPlayer0,deckPlayer1,singleRealizationOnly);
    IdentityLinkedList<Card> hand=PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getHand();
    if (hand.size() > 0) {
      Card targetCard=hand.get((int)(Math.random() * hand.size()));
      toRet.data_.removeCard_hand(targetCard);
    }
  }
 else {
    int targetCharacterIndex=targetMinion instanceof Hero ? 0 : side.getPlayer(boardState).getMinions().indexOf(targetMinion) + 1;
    int thisCardIndex=side.getPlayer(boardState).getHand().indexOf(this);
    toRet=new RandomEffectNode(boardState,new HearthAction(HearthAction.Verb.USE_CARD,PlayerSide.CURRENT_PLAYER,0,side,targetCharacterIndex));
    for (int indx=0; indx < toRet.data_.getCurrentPlayerHand().size(); ++indx) {
      if (indx != thisCardIndex) {
        HearthTreeNode cNode=new HearthTreeNode((BoardModel)toRet.data_.deepCopy());
        Minion cTargetMinion=cNode.data_.getCurrentPlayerCharacter(targetCharacterIndex);
        Soulfire cCard=(Soulfire)cNode.data_.getCurrentPlayerHand().get(thisCardIndex);
        cNode=cCard.callSuperUseOn(side,cTargetMinion,cNode,deckPlayer0,deckPlayer1,false);
        if (cNode != null) {
          cNode.data_.removeCard_hand(cNode.data_.getCurrentPlayerHand().get(indx < thisCardIndex ? indx : indx - 1));
          toRet.addChild(cNode);
        }
      }
    }
  }
  return toRet;
}","/** 
 * Discards a random card
 * @param side
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public HearthTreeNode useOn(PlayerSide side,Minion targetMinion,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1,boolean singleRealizationOnly) throws HSException {
  HearthTreeNode toRet=null;
  if (singleRealizationOnly) {
    toRet=super.useOn(side,targetMinion,boardState,deckPlayer0,deckPlayer1,singleRealizationOnly);
    IdentityLinkedList<Card> hand=PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getHand();
    if (hand.size() > 0) {
      Card targetCard=hand.get((int)(Math.random() * hand.size()));
      toRet.data_.removeCard_hand(targetCard);
    }
  }
 else {
    int targetCharacterIndex=targetMinion instanceof Hero ? 0 : side.getPlayer(boardState).getMinions().indexOf(targetMinion) + 1;
    int thisCardIndex=PlayerSide.CURRENT_PLAYER.getPlayer(boardState).getHand().indexOf(this);
    if (boardState.data_.getCurrentPlayerHand().size() == 1) {
      toRet=this.callSuperUseOn(side,targetMinion,boardState,deckPlayer0,deckPlayer1,false);
    }
 else {
      toRet=new RandomEffectNode(boardState,new HearthAction(HearthAction.Verb.USE_CARD,PlayerSide.CURRENT_PLAYER,thisCardIndex,side,targetCharacterIndex));
      for (int indx=0; indx < toRet.data_.getCurrentPlayerHand().size(); ++indx) {
        if (indx != thisCardIndex) {
          HearthTreeNode cNode=new HearthTreeNode((BoardModel)toRet.data_.deepCopy());
          Minion cTargetMinion=cNode.data_.getCharacter(side,targetCharacterIndex);
          Soulfire cCard=(Soulfire)cNode.data_.getCurrentPlayerHand().get(thisCardIndex);
          cNode=cCard.callSuperUseOn(side,cTargetMinion,cNode,deckPlayer0,deckPlayer1,false);
          if (cNode != null) {
            cNode.data_.removeCard_hand(cNode.data_.getCurrentPlayerHand().get(indx < thisCardIndex ? indx : indx - 1));
            toRet.addChild(cNode);
          }
        }
      }
    }
  }
  return toRet;
}",0.8674271229404309
112745,"public List<HearthActionBoardPair> playTurn(int turn,BoardModel board,int maxThinkTime) throws HSException {
  PlayerModel playerModel0=board.getCurrentPlayer();
  PlayerModel playerModel1=board.getWaitingPlayer();
  log.debug(""String_Node_Str"" + playerModel0.getName());
  log.debug(""String_Node_Str"",board);
  HearthTreeNode toRet=new HearthTreeNode(board);
  BoardStateFactoryBase factory=null;
  if (useSparseBoardStateFactory_) {
    factory=new SparseBoardStateFactory(playerModel0.getDeck(),playerModel1.getDeck(),maxThinkTime);
  }
 else {
    factory=new BoardStateFactoryBase(playerModel0.getDeck(),playerModel1.getDeck(),maxThinkTime);
  }
  HearthTreeNode allMoves=factory.doMoves(toRet,this);
  ArrayList<HearthActionBoardPair> retList=new ArrayList<HearthActionBoardPair>();
  HearthTreeNode curMove=allMoves;
  while (curMove.getChildren() != null) {
    curMove=curMove.getChildren().get(0);
    if (curMove instanceof StopNode) {
      HearthTreeNode allEffectsDone=((StopNode)curMove).finishAllEffects(playerModel0.getDeck(),playerModel1.getDeck());
      List<HearthActionBoardPair> nextMoves=this.playTurn(turn,allEffectsDone.data_,maxThinkTime);
      for (      HearthActionBoardPair actionBoard : nextMoves) {
        retList.add(actionBoard);
      }
      break;
    }
 else {
      retList.add(new HearthActionBoardPair(curMove.getAction(),curMove.data_));
    }
  }
  return retList;
}","public List<HearthActionBoardPair> playTurn(int turn,BoardModel board,int maxThinkTime) throws HSException {
  PlayerModel playerModel0=board.getCurrentPlayer();
  PlayerModel playerModel1=board.getWaitingPlayer();
  log.debug(""String_Node_Str"" + playerModel0.getName());
  log.debug(""String_Node_Str"",board);
  HearthTreeNode toRet=new HearthTreeNode(board);
  BoardStateFactoryBase factory=null;
  if (useSparseBoardStateFactory_) {
    factory=new SparseBoardStateFactory(playerModel0.getDeck(),playerModel1.getDeck(),maxThinkTime);
  }
 else {
    factory=new BoardStateFactoryBase(playerModel0.getDeck(),playerModel1.getDeck(),maxThinkTime);
  }
  HearthTreeNode allMoves=factory.doMoves(toRet,this);
  ArrayList<HearthActionBoardPair> retList=new ArrayList<HearthActionBoardPair>();
  HearthTreeNode curMove=allMoves;
  while (curMove.getChildren() != null) {
    curMove=curMove.getChildren().get(0);
    if (curMove instanceof StopNode) {
      HearthTreeNode allEffectsDone=((StopNode)curMove).finishAllEffects(playerModel0.getDeck(),playerModel1.getDeck());
      List<HearthActionBoardPair> nextMoves=this.playTurn(turn,allEffectsDone.data_,maxThinkTime);
      if (nextMoves.size() > 0) {
        for (        HearthActionBoardPair actionBoard : nextMoves) {
          retList.add(actionBoard);
        }
      }
 else {
        retList.add(new HearthActionBoardPair(allEffectsDone.getAction(),allEffectsDone.data_));
      }
      break;
    }
 else {
      retList.add(new HearthActionBoardPair(curMove.getAction(),curMove.data_));
    }
  }
  return retList;
}",0.9420823568798126
112746,"@Test public void testHeropower() throws HSException {
  Hero hero=board.data_.getCurrentPlayerHero();
  Minion target=board.data_.getCharacter(PlayerSide.CURRENT_PLAYER,0);
  HearthTreeNode ret=hero.useHeroAbility(PlayerSide.CURRENT_PLAYER,target,board,deck,null);
  assertNotNull(ret);
  assertEquals(board.data_.getNumCards_hand(),0);
  assertTrue(hero.hasBeenUsed());
  assertEquals(board.data_.getCurrentPlayer().getMana(),6);
  assertEquals(board.data_.getWaitingPlayer().getMana(),8);
  assertEquals(board.data_.getCurrentPlayer().getMana(),6);
  assertEquals(board.data_.getCurrentPlayerHero().getHealth(),30);
  assertEquals(board.data_.getWaitingPlayerHero().getHealth(),30);
  assertEquals(board.data_.getCurrentPlayerHero().getArmor(),1);
  assertEquals(board.data_.getWaitingPlayerHero().getArmor(),0);
  assertEquals(board.data_.getCurrentPlayerHero().getTotalAttack(),1);
  assertEquals(board.data_.getWaitingPlayerHero().getTotalAttack(),0);
  assertEquals(board.data_.getCurrentPlayerHero().getExtraAttackUntilTurnEnd(),1);
  assertEquals(board.data_.getWaitingPlayerHero().getExtraAttackUntilTurnEnd(),0);
}","@Test public void testHeropower() throws HSException {
  Hero hero=board.data_.getCurrentPlayerHero();
  Minion target=board.data_.getCharacter(PlayerSide.CURRENT_PLAYER,0);
  HearthTreeNode ret=hero.useHeroAbility(PlayerSide.CURRENT_PLAYER,target,board,deck,null);
  assertNotNull(ret);
  assertEquals(board.data_.getNumCards_hand(),0);
}",0.4631147540983606
112747,"@Test public void testCannotTargetOpponent() throws HSException {
  Minion target=board.data_.getCharacter(PlayerSide.WAITING_PLAYER,0);
  Hero hero=board.data_.getCurrentPlayerHero();
  HearthTreeNode ret=hero.useHeroAbility(PlayerSide.WAITING_PLAYER,target,board,deck,null);
  assertNull(ret);
  assertEquals(board.data_.getNumCards_hand(),0);
  assertEquals(board.data_.getCurrentPlayer().getMana(),8);
  assertEquals(board.data_.getWaitingPlayer().getMana(),8);
  assertEquals(board.data_.getCurrentPlayerHero().getHealth(),30);
  assertEquals(board.data_.getWaitingPlayerHero().getHealth(),30);
  assertEquals(board.data_.getCurrentPlayerHero().getArmor(),0);
  assertEquals(board.data_.getWaitingPlayerHero().getArmor(),0);
  assertEquals(board.data_.getCurrentPlayerHero().getTotalAttack(),0);
  assertEquals(board.data_.getWaitingPlayerHero().getTotalAttack(),0);
  assertEquals(board.data_.getCurrentPlayerHero().getExtraAttackUntilTurnEnd(),0);
  assertEquals(board.data_.getWaitingPlayerHero().getExtraAttackUntilTurnEnd(),0);
}","@Test public void testCannotTargetOpponent() throws HSException {
  Minion target=board.data_.getCharacter(PlayerSide.WAITING_PLAYER,0);
  Hero hero=board.data_.getCurrentPlayerHero();
  HearthTreeNode ret=hero.useHeroAbility(PlayerSide.WAITING_PLAYER,target,board,deck,null);
  assertNull(ret);
  assertEquals(board.data_.getNumCards_hand(),0);
}",0.5007215007215007
112748,"@Test @Ignore(""String_Node_Str"") public void testCannotTargetMinion() throws HSException {
  Minion raidLeader=board.data_.getCharacter(PlayerSide.CURRENT_PLAYER,0);
  Hero hero=board.data_.getCurrentPlayerHero();
  HearthTreeNode ret=hero.useHeroAbility(PlayerSide.CURRENT_PLAYER,raidLeader,board,deck,null);
  assertNull(ret);
  assertEquals(board.data_.getNumCards_hand(),1);
  assertEquals(board.data_.getCurrentPlayer().getMana(),8);
  assertEquals(board.data_.getWaitingPlayer().getMana(),8);
  assertEquals(board.data_.getCurrentPlayerHero().getHealth(),30);
  assertEquals(board.data_.getWaitingPlayerHero().getHealth(),30);
  assertEquals(board.data_.getCurrentPlayerHero().getArmor(),0);
  assertEquals(board.data_.getWaitingPlayerHero().getArmor(),0);
  assertEquals(board.data_.getCurrentPlayerHero().getTotalAttack(),0);
  assertEquals(board.data_.getWaitingPlayerHero().getTotalAttack(),0);
  assertEquals(board.data_.getCurrentPlayerHero().getExtraAttackUntilTurnEnd(),0);
  assertEquals(board.data_.getWaitingPlayerHero().getExtraAttackUntilTurnEnd(),0);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(0).getAttack(),2);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(0).getTotalAttack(),2);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(0).getHealth(),2);
}","@Test public void testCannotTargetMinion() throws HSException {
  Minion raidLeader=board.data_.getCharacter(PlayerSide.CURRENT_PLAYER,1);
  Hero hero=board.data_.getCurrentPlayerHero();
  HearthTreeNode ret=hero.useHeroAbility(PlayerSide.CURRENT_PLAYER,raidLeader,board,deck,null);
  assertNull(ret);
  assertEquals(board.data_.getCurrentPlayer().getMana(),8);
  assertEquals(board.data_.getCurrentPlayerHero().getArmor(),0);
  assertEquals(board.data_.getCurrentPlayerHero().getTotalAttack(),0);
  assertEquals(board.data_.getCurrentPlayerHero().getExtraAttackUntilTurnEnd(),0);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(0).getAttack(),2);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(0).getTotalAttack(),2);
}",0.4939081537019681
112749,"@Test public void testHeropower() throws HSException {
  Minion target=board.data_.getCharacter(PlayerSide.WAITING_PLAYER,0);
  Hero hunter=board.data_.getCurrentPlayerHero();
  HearthTreeNode ret=hunter.useHeroAbility(PlayerSide.WAITING_PLAYER,target,board,deck,null);
  assertNotNull(ret);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getNumMinions(),2);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getNumMinions(),2);
  assertEquals(board.data_.getCurrentPlayer().getMana(),6);
  assertEquals(board.data_.getWaitingPlayer().getMana(),8);
  assertEquals(board.data_.getCurrentPlayerHero().getHealth(),30);
  assertEquals(board.data_.getWaitingPlayerHero().getHealth(),28);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(0).getHealth(),2);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(1).getHealth(),7);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(0).getHealth(),2);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(1).getHealth(),7);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(0).getTotalAttack(),2);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(1).getTotalAttack(),7);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(0).getTotalAttack(),2);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(1).getTotalAttack(),7);
}","@Test public void testHeropower() throws HSException {
  Minion target=board.data_.getCharacter(PlayerSide.WAITING_PLAYER,0);
  Hero hunter=board.data_.getCurrentPlayerHero();
  HearthTreeNode ret=hunter.useHeroAbility(PlayerSide.WAITING_PLAYER,target,board,deck,null);
  assertNotNull(ret);
  assertEquals(board.data_.getCurrentPlayer().getMana(),6);
  assertEquals(board.data_.getWaitingPlayerHero().getHealth(),28);
}",0.4010554089709762
112750,"@Test public void testHeropowerCannotTargetMinion() throws HSException {
  Minion target=board.data_.getCharacter(PlayerSide.WAITING_PLAYER,2);
  Hero hunter=board.data_.getCurrentPlayerHero();
  HearthTreeNode ret=hunter.useHeroAbility(PlayerSide.WAITING_PLAYER,target,board,deck,null);
  assertNull(ret);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getNumMinions(),2);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getNumMinions(),2);
  assertEquals(board.data_.getCurrentPlayer().getMana(),8);
  assertEquals(board.data_.getWaitingPlayer().getMana(),8);
  assertEquals(board.data_.getCurrentPlayerHero().getHealth(),30);
  assertEquals(board.data_.getWaitingPlayerHero().getHealth(),30);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(0).getHealth(),2);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(1).getHealth(),7);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(0).getHealth(),2);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(1).getHealth(),7);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(0).getTotalAttack(),2);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(1).getTotalAttack(),7);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(0).getTotalAttack(),2);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(1).getTotalAttack(),7);
}","@Test public void testHeropowerCannotTargetMinion() throws HSException {
  Minion target=board.data_.getCharacter(PlayerSide.WAITING_PLAYER,2);
  Hero hunter=board.data_.getCurrentPlayerHero();
  HearthTreeNode ret=hunter.useHeroAbility(PlayerSide.WAITING_PLAYER,target,board,deck,null);
  assertNull(ret);
  assertEquals(board.data_.getCurrentPlayer().getMana(),8);
  assertEquals(board.data_.getWaitingPlayerHero().getHealth(),30);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(1).getHealth(),7);
}",0.4180287270926201
112751,"@Test public void testHeropowerCannotTargetSelf() throws HSException {
  Minion target=board.data_.getCharacter(PlayerSide.CURRENT_PLAYER,0);
  Hero hunter=board.data_.getCurrentPlayerHero();
  HearthTreeNode ret=hunter.useHeroAbility(PlayerSide.CURRENT_PLAYER,target,board,deck,null);
  assertNull(ret);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getNumMinions(),2);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getNumMinions(),2);
  assertEquals(board.data_.getCurrentPlayer().getMana(),8);
  assertEquals(board.data_.getWaitingPlayer().getMana(),8);
  assertEquals(board.data_.getCurrentPlayerHero().getHealth(),30);
  assertEquals(board.data_.getWaitingPlayerHero().getHealth(),30);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(0).getHealth(),2);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(1).getHealth(),7);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(0).getHealth(),2);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(1).getHealth(),7);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(0).getTotalAttack(),2);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(1).getTotalAttack(),7);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(0).getTotalAttack(),2);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(1).getTotalAttack(),7);
}","@Test public void testHeropowerCannotTargetSelf() throws HSException {
  Minion target=board.data_.getCharacter(PlayerSide.CURRENT_PLAYER,0);
  Hero hunter=board.data_.getCurrentPlayerHero();
  HearthTreeNode ret=hunter.useHeroAbility(PlayerSide.CURRENT_PLAYER,target,board,deck,null);
  assertNull(ret);
  assertEquals(board.data_.getCurrentPlayer().getMana(),8);
  assertEquals(board.data_.getCurrentPlayerHero().getHealth(),30);
  assertEquals(board.data_.getWaitingPlayerHero().getHealth(),30);
}",0.4808853118712273
112752,"@Test public void testHeropowerKillsMinion() throws HSException {
  Minion target=board.data_.getCharacter(PlayerSide.WAITING_PLAYER,1);
  target.setHealth((byte)1);
  Hero mage=board.data_.getCurrentPlayerHero();
  HearthTreeNode ret=mage.useHeroAbility(PlayerSide.WAITING_PLAYER,target,board,deck,null);
  assertNotNull(ret);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getNumMinions(),2);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getNumMinions(),1);
  assertEquals(board.data_.getCurrentPlayer().getMana(),6);
  assertEquals(board.data_.getWaitingPlayer().getMana(),8);
  assertEquals(board.data_.getCurrentPlayerHero().getHealth(),30);
  assertEquals(board.data_.getWaitingPlayerHero().getHealth(),30);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(0).getHealth(),5);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(1).getHealth(),7);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(0).getHealth(),7);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(0).getTotalAttack(),4);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(1).getTotalAttack(),6);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(0).getTotalAttack(),6);
}","@Test public void testHeropowerKillsMinion() throws HSException {
  Minion target=board.data_.getCharacter(PlayerSide.WAITING_PLAYER,1);
  target.setHealth((byte)1);
  Hero mage=board.data_.getCurrentPlayerHero();
  HearthTreeNode ret=mage.useHeroAbility(PlayerSide.WAITING_PLAYER,target,board,deck,null);
  assertNotNull(ret);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getNumMinions(),2);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getNumMinions(),1);
  assertEquals(board.data_.getCurrentPlayer().getMana(),6);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(0).getHealth(),5);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(1).getHealth(),7);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(0).getHealth(),7);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(0).getTotalAttack(),4);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(1).getTotalAttack(),6);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(0).getTotalAttack(),6);
}",0.9205569205569204
112753,"@Test public void testHeropowerAgainstOpponent() throws HSException {
  Minion target=board.data_.getCharacter(PlayerSide.WAITING_PLAYER,0);
  Hero mage=board.data_.getCurrentPlayerHero();
  HearthTreeNode ret=mage.useHeroAbility(PlayerSide.WAITING_PLAYER,target,board,deck,null);
  assertNotNull(ret);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getNumMinions(),2);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getNumMinions(),2);
  assertEquals(board.data_.getCurrentPlayer().getMana(),6);
  assertEquals(board.data_.getWaitingPlayer().getMana(),8);
  assertEquals(board.data_.getCurrentPlayerHero().getHealth(),30);
  assertEquals(board.data_.getWaitingPlayerHero().getHealth(),29);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(0).getHealth(),5);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(1).getHealth(),7);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(0).getHealth(),5);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(1).getHealth(),7);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(0).getTotalAttack(),4);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(1).getTotalAttack(),6);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(0).getTotalAttack(),4);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(1).getTotalAttack(),6);
}","@Test public void testHeropowerAgainstOpponent() throws HSException {
  Minion target=board.data_.getCharacter(PlayerSide.WAITING_PLAYER,0);
  Hero mage=board.data_.getCurrentPlayerHero();
  HearthTreeNode ret=mage.useHeroAbility(PlayerSide.WAITING_PLAYER,target,board,deck,null);
  assertNotNull(ret);
  assertEquals(board.data_.getCurrentPlayer().getMana(),6);
  assertEquals(board.data_.getWaitingPlayerHero().getHealth(),29);
}",0.4079290558163798
112754,"@Before public void setup(){
  board=new HearthTreeNode(new BoardModel(new Mage(),new TestHero()));
  Minion minion0_0=new ChillwindYeti();
  Minion minion0_1=new BoulderfistOgre();
  Minion minion1_0=new ChillwindYeti();
  Minion minion1_1=new BoulderfistOgre();
  board.data_.placeCardHandCurrentPlayer(minion0_1);
  board.data_.placeCardHandCurrentPlayer(minion0_0);
  board.data_.placeCardHandWaitingPlayer(minion1_1);
  board.data_.placeCardHandWaitingPlayer(minion1_0);
  Card cards[]=new Card[10];
  for (int index=0; index < 10; ++index) {
    cards[index]=new TheCoin();
  }
  deck=new Deck(cards);
  board.data_.getCurrentPlayer().setMana((byte)9);
  board.data_.getWaitingPlayer().setMana((byte)9);
  board.data_.getCurrentPlayer().setMaxMana((byte)8);
  board.data_.getWaitingPlayer().setMaxMana((byte)8);
  HearthTreeNode tmpBoard=new HearthTreeNode(board.data_.flipPlayers());
  try {
    tmpBoard.data_.getCurrentPlayerCardHand(0).useOn(PlayerSide.CURRENT_PLAYER,tmpBoard.data_.getCurrentPlayerHero(),tmpBoard,deck,null);
    tmpBoard.data_.getCurrentPlayerCardHand(0).useOn(PlayerSide.CURRENT_PLAYER,tmpBoard.data_.getCurrentPlayerHero(),tmpBoard,deck,null);
  }
 catch (  HSException e) {
    e.printStackTrace();
  }
  board=new HearthTreeNode(tmpBoard.data_.flipPlayers());
  try {
    board.data_.getCurrentPlayerCardHand(0).useOn(PlayerSide.CURRENT_PLAYER,board.data_.getCurrentPlayerHero(),board,deck,null);
    board.data_.getCurrentPlayerCardHand(0).useOn(PlayerSide.CURRENT_PLAYER,board.data_.getCurrentPlayerHero(),board,deck,null);
  }
 catch (  HSException e) {
    e.printStackTrace();
  }
  board.data_.resetMana();
  board.data_.resetMinions();
}","@Before public void setup(){
  board=new HearthTreeNode(new BoardModel(new Mage(),new TestHero()));
  Minion minion0_0=new ChillwindYeti();
  Minion minion0_1=new BoulderfistOgre();
  Minion minion1_0=new ChillwindYeti();
  Minion minion1_1=new BoulderfistOgre();
  board.data_.placeCardHandCurrentPlayer(minion0_1);
  board.data_.placeCardHandCurrentPlayer(minion0_0);
  board.data_.placeCardHandWaitingPlayer(minion1_1);
  board.data_.placeCardHandWaitingPlayer(minion1_0);
  Card cards[]=new Card[10];
  for (int index=0; index < 10; ++index) {
    cards[index]=new TheCoin();
  }
  deck=new Deck(cards);
  board.data_.getCurrentPlayer().setMana((byte)11);
  board.data_.getWaitingPlayer().setMana((byte)11);
  board.data_.getCurrentPlayer().setMaxMana((byte)8);
  board.data_.getWaitingPlayer().setMaxMana((byte)8);
  HearthTreeNode tmpBoard=new HearthTreeNode(board.data_.flipPlayers());
  try {
    tmpBoard.data_.getCurrentPlayerCardHand(0).useOn(PlayerSide.CURRENT_PLAYER,tmpBoard.data_.getCurrentPlayerHero(),tmpBoard,deck,null);
    tmpBoard.data_.getCurrentPlayerCardHand(0).useOn(PlayerSide.CURRENT_PLAYER,tmpBoard.data_.getCurrentPlayerHero(),tmpBoard,deck,null);
  }
 catch (  HSException e) {
    e.printStackTrace();
  }
  board=new HearthTreeNode(tmpBoard.data_.flipPlayers());
  try {
    board.data_.getCurrentPlayerCardHand(0).useOn(PlayerSide.CURRENT_PLAYER,board.data_.getCurrentPlayerHero(),board,deck,null);
    board.data_.getCurrentPlayerCardHand(0).useOn(PlayerSide.CURRENT_PLAYER,board.data_.getCurrentPlayerHero(),board,deck,null);
  }
 catch (  HSException e) {
    e.printStackTrace();
  }
  board.data_.resetMana();
  board.data_.resetMinions();
}",0.9982121573301548
112755,"@Test public void testHeropowerAgainstSelf() throws HSException {
  Minion target=board.data_.getCharacter(PlayerSide.CURRENT_PLAYER,0);
  Hero mage=board.data_.getCurrentPlayerHero();
  HearthTreeNode ret=mage.useHeroAbility(PlayerSide.WAITING_PLAYER,target,board,deck,null);
  assertNotNull(ret);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getNumMinions(),2);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getNumMinions(),2);
  assertEquals(board.data_.getCurrentPlayer().getMana(),6);
  assertEquals(board.data_.getWaitingPlayer().getMana(),8);
  assertEquals(board.data_.getCurrentPlayerHero().getHealth(),29);
  assertEquals(board.data_.getWaitingPlayerHero().getHealth(),30);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(0).getHealth(),5);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(1).getHealth(),7);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(0).getHealth(),5);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(1).getHealth(),7);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(0).getTotalAttack(),4);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(1).getTotalAttack(),6);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(0).getTotalAttack(),4);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(1).getTotalAttack(),6);
}","@Test public void testHeropowerAgainstSelf() throws HSException {
  Minion target=board.data_.getCharacter(PlayerSide.CURRENT_PLAYER,0);
  Hero mage=board.data_.getCurrentPlayerHero();
  HearthTreeNode ret=mage.useHeroAbility(PlayerSide.WAITING_PLAYER,target,board,deck,null);
  assertNotNull(ret);
  assertEquals(board.data_.getCurrentPlayer().getMana(),6);
  assertEquals(board.data_.getCurrentPlayerHero().getHealth(),29);
}",0.4127815610267155
112756,"@Test public void testHeropowerAgainstMinion() throws HSException {
  Minion target=board.data_.getCharacter(PlayerSide.WAITING_PLAYER,1);
  Hero mage=board.data_.getCurrentPlayerHero();
  HearthTreeNode ret=mage.useHeroAbility(PlayerSide.WAITING_PLAYER,target,board,deck,null);
  assertNotNull(ret);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getNumMinions(),2);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getNumMinions(),2);
  assertEquals(board.data_.getCurrentPlayer().getMana(),6);
  assertEquals(board.data_.getWaitingPlayer().getMana(),8);
  assertEquals(board.data_.getCurrentPlayerHero().getHealth(),30);
  assertEquals(board.data_.getWaitingPlayerHero().getHealth(),30);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(0).getHealth(),5);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(1).getHealth(),7);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(0).getHealth(),4);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(1).getHealth(),7);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(0).getTotalAttack(),4);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(1).getTotalAttack(),6);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(0).getTotalAttack(),4);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(1).getTotalAttack(),6);
}","@Test public void testHeropowerAgainstMinion() throws HSException {
  Minion target=board.data_.getCharacter(PlayerSide.WAITING_PLAYER,1);
  Hero mage=board.data_.getCurrentPlayerHero();
  HearthTreeNode ret=mage.useHeroAbility(PlayerSide.WAITING_PLAYER,target,board,deck,null);
  assertNotNull(ret);
  assertEquals(board.data_.getCurrentPlayer().getMana(),6);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(0).getHealth(),5);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(1).getHealth(),7);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(0).getHealth(),4);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(1).getHealth(),7);
}",0.4995499549954995
112757,"@Test public void testHeropowerAgainstOwnMinion() throws HSException {
  Minion target=board.data_.getCharacter(PlayerSide.CURRENT_PLAYER,1);
  Hero mage=board.data_.getCurrentPlayerHero();
  HearthTreeNode ret=mage.useHeroAbility(PlayerSide.WAITING_PLAYER,target,board,deck,null);
  assertNotNull(ret);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getNumMinions(),2);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getNumMinions(),2);
  assertEquals(board.data_.getCurrentPlayer().getMana(),6);
  assertEquals(board.data_.getWaitingPlayer().getMana(),8);
  assertEquals(board.data_.getCurrentPlayerHero().getHealth(),30);
  assertEquals(board.data_.getWaitingPlayerHero().getHealth(),30);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(0).getHealth(),4);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(1).getHealth(),7);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(0).getHealth(),5);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(1).getHealth(),7);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(0).getTotalAttack(),4);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(1).getTotalAttack(),6);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(0).getTotalAttack(),4);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(1).getTotalAttack(),6);
}","@Test public void testHeropowerAgainstOwnMinion() throws HSException {
  Minion target=board.data_.getCharacter(PlayerSide.CURRENT_PLAYER,1);
  Hero mage=board.data_.getCurrentPlayerHero();
  HearthTreeNode ret=mage.useHeroAbility(PlayerSide.WAITING_PLAYER,target,board,deck,null);
  assertNotNull(ret);
  assertEquals(board.data_.getCurrentPlayer().getMana(),6);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(0).getHealth(),4);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getMinions().get(1).getHealth(),7);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(0).getHealth(),5);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getMinions().get(1).getHealth(),7);
}",0.5008976660682226
112758,"@Test public void testHeropowerCannotTargetOpponent() throws HSException {
  Minion target=board.data_.getCharacter(PlayerSide.WAITING_PLAYER,0);
  Hero hunter=board.data_.getCurrentPlayerHero();
  HearthTreeNode ret=hunter.useHeroAbility(PlayerSide.WAITING_PLAYER,target,board,deck,null);
  assertNull(ret);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getNumMinions(),2);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getNumMinions(),2);
  assertEquals(board.data_.getCurrentPlayer().getMana(),8);
  assertEquals(board.data_.getWaitingPlayer().getMana(),8);
  assertEquals(board.data_.getCurrentPlayerHero().getHealth(),30);
  assertEquals(board.data_.getWaitingPlayerHero().getHealth(),30);
  assertEquals(board.data_.getCurrentPlayerHero().getArmor(),0);
  assertEquals(board.data_.getWaitingPlayerHero().getArmor(),0);
}","@Test public void testHeropowerCannotTargetOpponent() throws HSException {
  Minion target=board.data_.getCharacter(PlayerSide.WAITING_PLAYER,0);
  Hero hunter=board.data_.getCurrentPlayerHero();
  HearthTreeNode ret=hunter.useHeroAbility(PlayerSide.WAITING_PLAYER,target,board,deck,null);
  assertNull(ret);
  assertEquals(board.data_.getCurrentPlayer().getMana(),8);
  assertEquals(board.data_.getCurrentPlayerHero().getArmor(),0);
  assertEquals(board.data_.getWaitingPlayerHero().getArmor(),0);
}",0.5866666666666667
112759,"@Test public void testHeropower() throws HSException {
  Minion target=board.data_.getCharacter(PlayerSide.CURRENT_PLAYER,0);
  Hero hunter=board.data_.getCurrentPlayerHero();
  HearthTreeNode ret=hunter.useHeroAbility(PlayerSide.CURRENT_PLAYER,target,board,deck,null);
  assertNotNull(ret);
  assertEquals(board.data_.getCurrentPlayerHero().getArmor(),2);
  assertEquals(board.data_.getWaitingPlayerHero().getArmor(),0);
}","@Test public void testHeropower() throws HSException {
  Minion target=board.data_.getCharacter(PlayerSide.CURRENT_PLAYER,0);
  Hero hunter=board.data_.getCurrentPlayerHero();
  HearthTreeNode ret=hunter.useHeroAbility(PlayerSide.CURRENT_PLAYER,target,board,deck,null);
  assertNotNull(ret);
  assertEquals(board.data_.getCurrentPlayerHero().getArmor(),2);
}",0.9167733674775927
112760,"@Test public void testHeropowerCannotTargetMinion() throws HSException {
  Minion target=board.data_.getCharacter(PlayerSide.WAITING_PLAYER,2);
  Hero hunter=board.data_.getCurrentPlayerHero();
  HearthTreeNode ret=hunter.useHeroAbility(PlayerSide.WAITING_PLAYER,target,board,deck,null);
  assertNull(ret);
  assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getNumMinions(),2);
  assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getNumMinions(),2);
  assertEquals(board.data_.getCurrentPlayer().getMana(),8);
  assertEquals(board.data_.getWaitingPlayer().getMana(),8);
  assertEquals(board.data_.getCurrentPlayerHero().getArmor(),0);
  assertEquals(board.data_.getWaitingPlayerHero().getArmor(),0);
}","@Test public void testHeropowerCannotTargetMinion() throws HSException {
  Minion target=board.data_.getCharacter(PlayerSide.WAITING_PLAYER,2);
  Hero hunter=board.data_.getCurrentPlayerHero();
  HearthTreeNode ret=hunter.useHeroAbility(PlayerSide.WAITING_PLAYER,target,board,deck,null);
  assertNull(ret);
  assertEquals(board.data_.getCurrentPlayer().getMana(),8);
  assertEquals(board.data_.getCurrentPlayerHero().getArmor(),0);
  assertEquals(board.data_.getWaitingPlayerHero().getArmor(),0);
}",0.5841584158415841
112761,"@Before public void setup(){
  board=new HearthTreeNode(new BoardModel(new Warrior(),new TestHero()));
  Minion minion0_0=new BoulderfistOgre();
  Minion minion0_1=new RaidLeader();
  Minion minion1_0=new BoulderfistOgre();
  Minion minion1_1=new RaidLeader();
  board.data_.placeCardHandCurrentPlayer(minion0_0);
  board.data_.placeCardHandCurrentPlayer(minion0_1);
  board.data_.placeCardHandWaitingPlayer(minion1_0);
  board.data_.placeCardHandWaitingPlayer(minion1_1);
  Card cards[]=new Card[10];
  for (int index=0; index < 10; ++index) {
    cards[index]=new TheCoin();
  }
  deck=new Deck(cards);
  Card fb=new WildGrowth();
  board.data_.placeCardHandCurrentPlayer(fb);
  board.data_.getCurrentPlayer().setMana((byte)9);
  board.data_.getWaitingPlayer().setMana((byte)9);
  board.data_.getCurrentPlayer().setMaxMana((byte)8);
  board.data_.getWaitingPlayer().setMaxMana((byte)8);
  HearthTreeNode tmpBoard=new HearthTreeNode(board.data_.flipPlayers());
  try {
    tmpBoard.data_.getCurrentPlayerCardHand(0).useOn(PlayerSide.CURRENT_PLAYER,tmpBoard.data_.getCurrentPlayerHero(),tmpBoard,deck,null);
    tmpBoard.data_.getCurrentPlayerCardHand(0).useOn(PlayerSide.CURRENT_PLAYER,tmpBoard.data_.getCurrentPlayerHero(),tmpBoard,deck,null);
  }
 catch (  HSException e) {
    e.printStackTrace();
  }
  board=new HearthTreeNode(tmpBoard.data_.flipPlayers());
  try {
    board.data_.getCurrentPlayerCardHand(0).useOn(PlayerSide.CURRENT_PLAYER,board.data_.getCurrentPlayerHero(),board,deck,null);
    board.data_.getCurrentPlayerCardHand(0).useOn(PlayerSide.CURRENT_PLAYER,board.data_.getCurrentPlayerHero(),board,deck,null);
  }
 catch (  HSException e) {
    e.printStackTrace();
  }
  board.data_.resetMana();
  board.data_.resetMinions();
}","@Before public void setup(){
  board=new HearthTreeNode(new BoardModel(new Warrior(),new TestHero()));
  Minion minion0_0=new BoulderfistOgre();
  Minion minion0_1=new RaidLeader();
  Minion minion1_0=new BoulderfistOgre();
  Minion minion1_1=new RaidLeader();
  board.data_.placeCardHandCurrentPlayer(minion0_0);
  board.data_.placeCardHandCurrentPlayer(minion0_1);
  board.data_.placeCardHandWaitingPlayer(minion1_0);
  board.data_.placeCardHandWaitingPlayer(minion1_1);
  Card cards[]=new Card[10];
  for (int index=0; index < 10; ++index) {
    cards[index]=new TheCoin();
  }
  deck=new Deck(cards);
  board.data_.getCurrentPlayer().setMana((byte)9);
  board.data_.getWaitingPlayer().setMana((byte)9);
  board.data_.getCurrentPlayer().setMaxMana((byte)8);
  board.data_.getWaitingPlayer().setMaxMana((byte)8);
  HearthTreeNode tmpBoard=new HearthTreeNode(board.data_.flipPlayers());
  try {
    tmpBoard.data_.getCurrentPlayerCardHand(0).useOn(PlayerSide.CURRENT_PLAYER,tmpBoard.data_.getCurrentPlayerHero(),tmpBoard,deck,null);
    tmpBoard.data_.getCurrentPlayerCardHand(0).useOn(PlayerSide.CURRENT_PLAYER,tmpBoard.data_.getCurrentPlayerHero(),tmpBoard,deck,null);
  }
 catch (  HSException e) {
    e.printStackTrace();
  }
  board=new HearthTreeNode(tmpBoard.data_.flipPlayers());
  try {
    board.data_.getCurrentPlayerCardHand(0).useOn(PlayerSide.CURRENT_PLAYER,board.data_.getCurrentPlayerHero(),board,deck,null);
    board.data_.getCurrentPlayerCardHand(0).useOn(PlayerSide.CURRENT_PLAYER,board.data_.getCurrentPlayerHero(),board,deck,null);
  }
 catch (  HSException e) {
    e.printStackTrace();
  }
  board.data_.resetMana();
  board.data_.resetMinions();
}",0.978375219170076
112762,"public HSCardSelectionList(){
  super();
  list_=new ImplementedCardList();
  editing_=false;
  DefaultListModel<ImplementedCard> model=new DefaultListModel<ImplementedCard>();
  cards_=list_.getCardList();
  Collections.sort(cards_);
  for (  ImplementedCard card : list_.getCardList()) {
    if (!card.isHero && card.collectible)     model.addElement(card);
  }
  this.setModel(model);
  this.addMouseListener(new MouseAdapter(){
    public void mousePressed(    MouseEvent evt){
      JList list=(JList)evt.getSource();
      int index=list.locationToIndex(evt.getPoint());
      log.debug(""String_Node_Str"" + index + ""String_Node_Str""+ cards_.get(index).name_);
      if (editing_ && cardListPane_ != null) {
        ((SortedListModel<ImplementedCard>)cardListPane_.getModel()).addElement(cards_.get(index));
      }
      cardListPane_.repaint();
    }
  }
);
  this.setCellRenderer(new CardSelectionCellRenderer());
}","public HSCardSelectionList(){
  super();
  list_=new ImplementedCardList();
  editing_=false;
  DefaultListModel<ImplementedCard> model=new DefaultListModel<ImplementedCard>();
  cards_=new ArrayList<ImplementedCard>();
  for (  ImplementedCard card : list_.getCardList()) {
    if (!card.isHero && card.collectible)     cards_.add(card);
  }
  Collections.sort(cards_);
  for (  ImplementedCard card : cards_) {
    model.addElement(card);
  }
  this.setModel(model);
  this.addMouseListener(new MouseAdapter(){
    public void mousePressed(    MouseEvent evt){
      JList list=(JList)evt.getSource();
      int index=list.locationToIndex(evt.getPoint());
      log.debug(""String_Node_Str"" + index + ""String_Node_Str""+ cards_.get(index).name_);
      if (editing_ && cardListPane_ != null) {
        ((SortedListModel<ImplementedCard>)cardListPane_.getModel()).addElement(cards_.get(index));
      }
      cardListPane_.repaint();
    }
  }
);
  this.setCellRenderer(new CardSelectionCellRenderer());
}",0.9102231447846392
112763,"/** 
 * Use the card on the given target
 * @param side
 * @param targetMinion
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @param deckPlayer0
 * @param deckPlayer1
 * @param singleRealizationOnly
 * @return The boardState is manipulated and returned
 */
@Override protected HearthTreeNode use_core(PlayerSide side,Minion targetMinion,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1,boolean singleRealizationOnly) throws HSException {
  HearthTreeNode toRet=super.use_core(side,targetMinion,boardState,deckPlayer0,deckPlayer1,singleRealizationOnly);
  if (toRet != null) {
    int numHoundsToSummon=PlayerSide.WAITING_PLAYER.getPlayer(toRet).getNumMinions();
    if (numHoundsToSummon + PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getNumMinions() > 7)     numHoundsToSummon=7 - PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getNumMinions();
    for (int indx=0; indx < numHoundsToSummon; ++indx) {
      toRet=new Hound().summonMinion(PlayerSide.CURRENT_PLAYER,PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions().getLast(),toRet,deckPlayer0,deckPlayer1,false);
    }
  }
  return boardState;
}","/** 
 * Use the card on the given target
 * @param side
 * @param targetMinion
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @param deckPlayer0
 * @param deckPlayer1
 * @param singleRealizationOnly
 * @return The boardState is manipulated and returned
 */
@Override protected HearthTreeNode use_core(PlayerSide side,Minion targetMinion,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1,boolean singleRealizationOnly) throws HSException {
  HearthTreeNode toRet=super.use_core(side,targetMinion,boardState,deckPlayer0,deckPlayer1,singleRealizationOnly);
  if (toRet != null) {
    int numHoundsToSummon=PlayerSide.WAITING_PLAYER.getPlayer(toRet).getNumMinions();
    if (numHoundsToSummon + PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getNumMinions() > 7)     numHoundsToSummon=7 - PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getNumMinions();
    for (int indx=0; indx < numHoundsToSummon; ++indx) {
      Minion placementTarget=PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getNumMinions() > 0 ? PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions().getLast() : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getHero();
      toRet=new Hound().summonMinion(PlayerSide.CURRENT_PLAYER,placementTarget,toRet,deckPlayer0,deckPlayer1,false);
    }
  }
  return boardState;
}",0.91132224861441
112764,"@Override public GameResult runSingleGame() throws IOException, HSException {
  return super.runSingleGame(ai0_,hero0_,deck0_,ai1_,hero1_,deck1_,true);
}","@Override public GameResult runSingleGame() throws IOException, HSException {
  return super.runSingleGame((ArtificialPlayer)ai0_.deepCopy(),(Hero)hero0_.deepCopy(),(Deck)deck0_.deepCopy(),(ArtificialPlayer)ai1_.deepCopy(),(Hero)hero1_.deepCopy(),(Deck)deck1_.deepCopy(),true);
}",0.6851851851851852
112765,"/** 
 * Battlecry: Destroy
 */
@Override public HearthTreeNode useUntargetableBattlecry_core(Minion minionPlacementTarget,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1,boolean singleRealizationOnly) throws HSException {
  HearthTreeNode toRet=boardState;
  if (singleRealizationOnly) {
    if (toRet != null) {
      List<Minion> possibleTargets=new ArrayList<Minion>();
      for (      Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
        if (minion.getTotalAttack() <= 2)         possibleTargets.add(minion);
      }
      if (possibleTargets.size() > 0) {
        Minion targetMinion=possibleTargets.get((int)(Math.random() * possibleTargets.size()));
        targetMinion.setHealth((byte)-99);
      }
    }
  }
 else {
    int placementTargetIndex=minionPlacementTarget instanceof Hero ? 0 : PlayerSide.CURRENT_PLAYER.getPlayer(boardState).getMinions().indexOf(minionPlacementTarget) + 1;
    int thisMinionIndex=PlayerSide.CURRENT_PLAYER.getPlayer(boardState).getMinions().indexOf(this) + 1;
    toRet=new RandomEffectNode(boardState,new HearthAction(HearthAction.Verb.USE_CARD,PlayerSide.CURRENT_PLAYER,thisMinionIndex,PlayerSide.CURRENT_PLAYER,placementTargetIndex));
    if (toRet != null) {
      List<Minion> possibleTargets=new ArrayList<Minion>();
      for (      Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
        if (minion.getTotalAttack() <= 2)         possibleTargets.add(minion);
      }
      if (possibleTargets.size() > 0) {
        PlayerModel targetPlayer=PlayerSide.WAITING_PLAYER.getPlayer(toRet);
        for (        Minion possibleTarget : possibleTargets) {
          HearthTreeNode newState=new HearthTreeNode((BoardModel)toRet.data_.deepCopy());
          Minion targetMinion=PlayerSide.WAITING_PLAYER.getPlayer(newState).getMinions().get(targetPlayer.getMinions().indexOf(possibleTarget));
          targetMinion.setHealth((byte)-99);
          newState=BoardStateFactoryBase.handleDeadMinions(newState,deckPlayer0,deckPlayer1);
          toRet.addChild(newState);
        }
      }
    }
  }
  return toRet;
}","/** 
 * Battlecry: Destroy
 */
@Override public HearthTreeNode useUntargetableBattlecry_core(Minion minionPlacementTarget,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1,boolean singleRealizationOnly) throws HSException {
  HearthTreeNode toRet=boardState;
  if (singleRealizationOnly) {
    if (toRet != null) {
      List<Minion> possibleTargets=new ArrayList<Minion>();
      for (      Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
        if (minion.getTotalAttack() <= 2)         possibleTargets.add(minion);
      }
      if (possibleTargets.size() > 0) {
        Minion targetMinion=possibleTargets.get((int)(Math.random() * possibleTargets.size()));
        targetMinion.setHealth((byte)-99);
      }
    }
  }
 else {
    int placementTargetIndex=minionPlacementTarget instanceof Hero ? 0 : PlayerSide.CURRENT_PLAYER.getPlayer(boardState).getMinions().indexOf(minionPlacementTarget) + 1;
    int thisMinionIndex=PlayerSide.CURRENT_PLAYER.getPlayer(boardState).getMinions().indexOf(this) + 1;
    List<Minion> possibleTargets=new ArrayList<Minion>();
    for (    Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
      if (minion.getTotalAttack() <= 2)       possibleTargets.add(minion);
    }
    if (possibleTargets.size() > 0) {
      toRet=new RandomEffectNode(boardState,new HearthAction(HearthAction.Verb.UNTARGETABLE_BATTLECRY,PlayerSide.CURRENT_PLAYER,thisMinionIndex,PlayerSide.CURRENT_PLAYER,placementTargetIndex));
      PlayerModel targetPlayer=PlayerSide.WAITING_PLAYER.getPlayer(toRet);
      for (      Minion possibleTarget : possibleTargets) {
        HearthTreeNode newState=new HearthTreeNode((BoardModel)toRet.data_.deepCopy());
        Minion targetMinion=PlayerSide.WAITING_PLAYER.getPlayer(newState).getMinions().get(targetPlayer.getMinions().indexOf(possibleTarget));
        targetMinion.setHealth((byte)-99);
        newState=BoardStateFactoryBase.handleDeadMinions(newState,deckPlayer0,deckPlayer1);
        toRet.addChild(newState);
      }
    }
  }
  return toRet;
}",0.7598378249463391
112766,"public HearthTreeNode perform(HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  HearthTreeNode toRet=boardState;
switch (verb_) {
case USE_CARD:
{
      Card card=boardState.data_.getCard_hand(actionPerformerPlayerSide,cardOrCharacterIndex_);
      Minion target=boardState.data_.getCharacter(targetPlayerSide,targetCharacterIndex_);
      toRet=card.useOn(targetPlayerSide,target,toRet,deckPlayer0,deckPlayer1,true);
    }
  break;
case HERO_ABILITY:
{
  Hero hero=boardState.data_.getHero(actionPerformerPlayerSide);
  Minion target=boardState.data_.getCharacter(targetPlayerSide,targetCharacterIndex_);
  toRet=hero.useHeroAbility(targetPlayerSide,target,toRet,deckPlayer0,deckPlayer1,true);
}
break;
case ATTACK:
{
Minion attacker=boardState.data_.getCharacter(actionPerformerPlayerSide,cardOrCharacterIndex_);
Minion target=boardState.data_.getCharacter(targetPlayerSide,targetCharacterIndex_);
toRet=attacker.attack(targetPlayerSide,target,toRet,deckPlayer0,deckPlayer1);
}
break;
}
return toRet;
}","public HearthTreeNode perform(HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  HearthTreeNode toRet=boardState;
switch (verb_) {
case USE_CARD:
{
      Card card=boardState.data_.getCard_hand(actionPerformerPlayerSide,cardOrCharacterIndex_);
      Minion target=boardState.data_.getCharacter(targetPlayerSide,targetCharacterIndex_);
      toRet=card.useOn(targetPlayerSide,target,toRet,deckPlayer0,deckPlayer1,true);
    }
  break;
case HERO_ABILITY:
{
  Hero hero=boardState.data_.getHero(actionPerformerPlayerSide);
  Minion target=boardState.data_.getCharacter(targetPlayerSide,targetCharacterIndex_);
  toRet=hero.useHeroAbility(targetPlayerSide,target,toRet,deckPlayer0,deckPlayer1,true);
}
break;
case ATTACK:
{
Minion attacker=boardState.data_.getCharacter(actionPerformerPlayerSide,cardOrCharacterIndex_);
Minion target=boardState.data_.getCharacter(targetPlayerSide,targetCharacterIndex_);
toRet=attacker.attack(targetPlayerSide,target,toRet,deckPlayer0,deckPlayer1);
}
break;
case UNTARGETABLE_BATTLECRY:
{
Minion minion=boardState.data_.getCharacter(actionPerformerPlayerSide,cardOrCharacterIndex_);
Minion placementTarget=boardState.data_.getCharacter(targetPlayerSide,targetCharacterIndex_);
toRet=minion.useUntargetableBattlecry(placementTarget,toRet,deckPlayer0,deckPlayer1,true);
}
case TARGETABLE_BATTLECRY:
{
Minion minion=boardState.data_.getCharacter(actionPerformerPlayerSide,cardOrCharacterIndex_);
Minion battlecryTarget=boardState.data_.getCharacter(targetPlayerSide,targetCharacterIndex_);
toRet=minion.useTargetableBattlecry(targetPlayerSide,battlecryTarget,toRet,deckPlayer0,deckPlayer1);
}
}
return toRet;
}",0.758493353028065
112767,"@Override public HearthTreeNode finishAllEffects(Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  for (int i=0; i < numCardsToDraw_; ++i)   this.drawCard(deckPlayer0);
  return new HearthTreeNode(this.data_,this.score_,this.depth_,this.children_,this.numNodesTried_);
}","@Override public HearthTreeNode finishAllEffects(Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  for (int i=0; i < numCardsToDraw_; ++i)   this.drawCard(deckPlayer0);
  return new HearthTreeNode(this.data_,this.action,this.score_,this.depth_,this.children_,this.numNodesTried_);
}",0.9788732394366196
112768,"public HearthTreeNode(BoardModel data,double score,byte depth,List<HearthTreeNode> children,int numNodesTried){
  data_=data;
  score_=score;
  children_=children;
  depth_=depth;
  numNodesTried_=numNodesTried;
}","public HearthTreeNode(BoardModel data,HearthAction action,double score,byte depth,List<HearthTreeNode> children,int numNodesTried){
  data_=data;
  this.action=action;
  score_=score;
  children_=children;
  depth_=depth;
  numNodesTried_=numNodesTried;
}",0.9102564102564102
112769,"@Override public HearthTreeNode finishAllEffects(Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  return action_.perform(new HearthTreeNode(this.data_,this.score_,this.depth_,this.children_,this.numNodesTried_),deckPlayer0,deckPlayer1);
}","@Override public HearthTreeNode finishAllEffects(Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  return action_.perform(new HearthTreeNode(this.data_,this.action,this.score_,this.depth_,this.children_,this.numNodesTried_),deckPlayer0,deckPlayer1);
}",0.9762845849802372
112770,"public StopNode(HearthTreeNode origNode){
  super(origNode.data_,origNode.score_,origNode.depth_);
  children_=origNode.children_;
  numNodesTried_=origNode.numNodesTried_;
}","public StopNode(HearthTreeNode origNode){
  super(origNode.data_,origNode.action,origNode.score_,origNode.depth_);
  children_=origNode.children_;
  numNodesTried_=origNode.numNodesTried_;
}",0.956043956043956
112771,"/** 
 * Override for battlecry Battlecry: Give adjacent minions +1/+1 and Taunt
 * @param side
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public HearthTreeNode use_core(PlayerSide side,Minion targetMinion,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1,boolean singleRealizationOnly) throws HSException {
  HearthTreeNode toRet=super.use_core(side,targetMinion,boardState,deckPlayer0,deckPlayer1,singleRealizationOnly);
  if (toRet != null) {
    int thisMinionIndex=toRet.data_.getMinions(side).indexOf(this);
    int numMinions=side.getPlayer(boardState).getNumMinions();
    if (numMinions > 1) {
      int minionToTheLeft=thisMinionIndex > 0 ? thisMinionIndex - 1 : -1;
      int minionToTheRight=thisMinionIndex < numMinions - 1 ? thisMinionIndex - 1 : -1;
      if (minionToTheLeft >= 0) {
        Minion minionToBuff=toRet.data_.getMinion(side,minionToTheLeft);
        minionToBuff.setAttack((byte)(minionToBuff.getAttack() + 1));
        minionToBuff.setHealth((byte)(minionToBuff.getHealth() + 1));
        minionToBuff.setTaunt(true);
      }
      if (minionToTheRight >= 0) {
        Minion minionToBuff=toRet.data_.getMinion(side,minionToTheRight);
        minionToBuff.setAttack((byte)(minionToBuff.getAttack() + 1));
        minionToBuff.setHealth((byte)(minionToBuff.getHealth() + 1));
        minionToBuff.setTaunt(true);
      }
    }
  }
  return toRet;
}","/** 
 * Override for battlecry Battlecry: Give adjacent minions +1/+1 and Taunt
 * @param side
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public HearthTreeNode use_core(PlayerSide side,Minion targetMinion,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1,boolean singleRealizationOnly) throws HSException {
  HearthTreeNode toRet=super.use_core(side,targetMinion,boardState,deckPlayer0,deckPlayer1,singleRealizationOnly);
  if (toRet != null) {
    int thisMinionIndex=toRet.data_.getMinions(side).indexOf(this);
    int numMinions=side.getPlayer(boardState).getNumMinions();
    if (numMinions > 1) {
      int minionToTheLeft=thisMinionIndex > 0 ? thisMinionIndex - 1 : -1;
      int minionToTheRight=thisMinionIndex < numMinions - 1 ? thisMinionIndex + 1 : -1;
      if (minionToTheLeft >= 0) {
        Minion minionToBuff=toRet.data_.getMinion(side,minionToTheLeft);
        minionToBuff.setAttack((byte)(minionToBuff.getAttack() + 1));
        minionToBuff.setHealth((byte)(minionToBuff.getHealth() + 1));
        minionToBuff.setTaunt(true);
      }
      if (minionToTheRight >= 0) {
        Minion minionToBuff=toRet.data_.getMinion(side,minionToTheRight);
        minionToBuff.setAttack((byte)(minionToBuff.getAttack() + 1));
        minionToBuff.setHealth((byte)(minionToBuff.getHealth() + 1));
        minionToBuff.setTaunt(true);
      }
    }
  }
  return toRet;
}",0.999345977763244
112772,"public GameResult checkGameOver(int turnCount,GameRecord record){
  if (!boardModel_.isAlive_p0()) {
    return new GameResult(s0_,s1_,turnCount + 1,record);
  }
 else   if (!boardModel_.isAlive_p1()) {
    return new GameResult(s0_,s0_,turnCount + 1,record);
  }
  return null;
}","public GameResult checkGameOver(int turnCount,int activePlayerIndex,GameRecord record){
  int inactivePlayerIndex=(activePlayerIndex + 1) % 2;
  if (!boardModel_.isAlive_p0()) {
    return new GameResult(s0_,inactivePlayerIndex,turnCount + 1,record);
  }
 else   if (!boardModel_.isAlive_p1()) {
    return new GameResult(s0_,activePlayerIndex,turnCount + 1,record);
  }
  return null;
}",0.8215892053973014
112773,"private GameResult playTurn(int turnCount,GameRecord record,int activePlayerIndex,ArtificialPlayer ai) throws HSException {
  beginTurn(turnCount,boardModel_);
  GameResult gameResult;
  gameResult=checkGameOver(turnCount,record);
  if (gameResult != null)   return gameResult;
  boardModel_=playAITurn(turnCount,boardModel_,ai);
  endTurn(boardModel_);
  record.put(turnCount + 1,activePlayerIndex,(BoardModel)boardModel_.deepCopy());
  gameResult=checkGameOver(turnCount,record);
  if (gameResult != null)   return gameResult;
  boardModel_=boardModel_.flipPlayers();
  return null;
}","private GameResult playTurn(int turnCount,GameRecord record,int activePlayerIndex,ArtificialPlayer ai) throws HSException {
  beginTurn(turnCount,boardModel_);
  GameResult gameResult;
  gameResult=checkGameOver(turnCount,activePlayerIndex,record);
  if (gameResult != null)   return gameResult;
  boardModel_=playAITurn(turnCount,boardModel_,ai);
  endTurn(boardModel_);
  record.put(turnCount + 1,activePlayerIndex,(BoardModel)boardModel_.deepCopy());
  gameResult=checkGameOver(turnCount,activePlayerIndex,record);
  if (gameResult != null)   return gameResult;
  boardModel_=boardModel_.flipPlayers();
  return null;
}",0.9701986754966888
112774,"public BoardModel flipPlayers(){
  BoardModel newState=(BoardModel)this.deepCopy();
  MinionList p0_minions=newState.getMinions_p0();
  MinionList p1_minions=newState.getMinions_p1();
  int p0_mana=newState.getMana_p0();
  int p1_mana=newState.getMana_p1();
  int p0_maxMana=newState.getMaxMana_p0();
  int p1_maxMana=newState.getMaxMana_p1();
  newState.currentPlayer=waitingPlayer;
  newState.waitingPlayer=currentPlayer;
  newState.p0_hero_=p1_hero_;
  newState.p1_hero_=p0_hero_;
  newState.setMinions_p0(p1_minions);
  newState.setMinions_p1(p0_minions);
  newState.setMana_p0(p1_mana);
  newState.setMana_p1(p0_mana);
  newState.setMaxMana_p0(p1_maxMana);
  newState.setMaxMana_p1(p0_maxMana);
  newState.p0_hand_=p1_hand_;
  newState.p1_hand_=p0_hand_;
  newState.p0_deckPos_=p1_deckPos_;
  newState.p1_deckPos_=p0_deckPos_;
  newState.p0_fatigueDamage_=p1_fatigueDamage_;
  newState.p1_fatigueDamage_=p0_fatigueDamage_;
  newState.p0_spellDamage_=p1_spellDamage_;
  newState.p1_spellDamage_=p0_spellDamage_;
  for (  MinionPlayerIDPair minionIdPair : newState.allMinionsFIFOList_) {
    minionIdPair.playerIndex_=minionIdPair.playerIndex_ == 0 ? 1 : 0;
  }
  return newState;
}","public BoardModel flipPlayers(){
  BoardModel newState=(BoardModel)this.deepCopy();
  MinionList p0_minions=newState.getMinions_p0();
  MinionList p1_minions=newState.getMinions_p1();
  int p0_mana=newState.getMana_p0();
  int p1_mana=newState.getMana_p1();
  int p0_maxMana=newState.getMaxMana_p0();
  int p1_maxMana=newState.getMaxMana_p1();
  newState.currentPlayer=waitingPlayer;
  newState.waitingPlayer=currentPlayer;
  newState.playerModel0=playerModel1;
  newState.playerModel1=playerModel0;
  newState.p0_hero_=p1_hero_;
  newState.p1_hero_=p0_hero_;
  newState.setMinions_p0(p1_minions);
  newState.setMinions_p1(p0_minions);
  newState.setMana_p0(p1_mana);
  newState.setMana_p1(p0_mana);
  newState.setMaxMana_p0(p1_maxMana);
  newState.setMaxMana_p1(p0_maxMana);
  newState.p0_hand_=p1_hand_;
  newState.p1_hand_=p0_hand_;
  newState.p0_deckPos_=p1_deckPos_;
  newState.p1_deckPos_=p0_deckPos_;
  newState.p0_fatigueDamage_=p1_fatigueDamage_;
  newState.p1_fatigueDamage_=p0_fatigueDamage_;
  newState.p0_spellDamage_=p1_spellDamage_;
  newState.p1_spellDamage_=p0_spellDamage_;
  for (  MinionPlayerIDPair minionIdPair : newState.allMinionsFIFOList_) {
    minionIdPair.playerIndex_=minionIdPair.playerIndex_ == 0 ? 1 : 0;
  }
  return newState;
}",0.9689288634505316
112775,"public GameResult runGame() throws HSException {
  curTurn_=0;
  boardModel_.placeCardHandCurrentPlayer(0);
  boardModel_.placeCardHandCurrentPlayer(1);
  boardModel_.placeCardHandCurrentPlayer(2);
  boardModel_.setDeckPos_p0(3);
  boardModel_.placeCardHandWaitingPlayer(0);
  boardModel_.placeCardHandWaitingPlayer(1);
  boardModel_.placeCardHandWaitingPlayer(2);
  boardModel_.placeCardHandWaitingPlayer(3);
  boardModel_.placeCardHandWaitingPlayer(new TheCoin());
  boardModel_.setDeckPos_p1(4);
  GameRecord record=new GameSimpleRecord();
  record.put(0,PlayerSide.CURRENT_PLAYER,(BoardModel)boardModel_.deepCopy());
  record.put(0,PlayerSide.WAITING_PLAYER,(BoardModel)boardModel_.flipPlayers().deepCopy());
  GameResult gameResult;
  for (int turnCount=0; turnCount < maxTurns_; ++turnCount) {
    log.info(""String_Node_Str"" + turnCount);
    long turnStart=System.currentTimeMillis();
    gameResult=playTurn(turnCount,record,ais[s0_]);
    if (gameResult != null)     return gameResult;
    gameResult=playTurn(turnCount,record,ais[s1_]);
    if (gameResult != null)     return gameResult;
    long turnEnd=System.currentTimeMillis();
    long turnDelta=turnEnd - turnStart;
    if (turnDelta > ArtificialPlayer.MAX_THINK_TIME / 2) {
      log.warn(""String_Node_Str"",turnDelta,ArtificialPlayer.MAX_THINK_TIME);
    }
 else {
      log.debug(""String_Node_Str"",turnDelta);
    }
  }
  return new GameResult(s0_,-1,0,record);
}","public GameResult runGame() throws HSException {
  curTurn_=0;
  boardModel_.placeCardHandCurrentPlayer(0);
  boardModel_.placeCardHandCurrentPlayer(1);
  boardModel_.placeCardHandCurrentPlayer(2);
  boardModel_.setDeckPos_p0(3);
  boardModel_.placeCardHandWaitingPlayer(0);
  boardModel_.placeCardHandWaitingPlayer(1);
  boardModel_.placeCardHandWaitingPlayer(2);
  boardModel_.placeCardHandWaitingPlayer(3);
  boardModel_.placeCardHandWaitingPlayer(new TheCoin());
  boardModel_.setDeckPos_p1(4);
  GameRecord record=new GameSimpleRecord();
  record.put(0,PlayerSide.CURRENT_PLAYER,(BoardModel)boardModel_.deepCopy());
  record.put(0,PlayerSide.CURRENT_PLAYER,(BoardModel)boardModel_.flipPlayers().deepCopy());
  GameResult gameResult;
  for (int turnCount=0; turnCount < maxTurns_; ++turnCount) {
    log.info(""String_Node_Str"" + turnCount);
    long turnStart=System.currentTimeMillis();
    gameResult=playTurn(turnCount,record,aiForPlayerGoingFirst);
    if (gameResult != null)     return gameResult;
    gameResult=playTurn(turnCount,record,aiForPlayerGoingSecond);
    if (gameResult != null)     return gameResult;
    long turnEnd=System.currentTimeMillis();
    long turnDelta=turnEnd - turnStart;
    if (turnDelta > ArtificialPlayer.MAX_THINK_TIME / 2) {
      log.warn(""String_Node_Str"",turnDelta,ArtificialPlayer.MAX_THINK_TIME);
    }
 else {
      log.debug(""String_Node_Str"",turnDelta);
    }
  }
  return new GameResult(playerGoingFirst.getPlayerId(),-1,0,record);
}",0.9671007539410555
112776,"public Game(PlayerModel playerModel0,PlayerModel playerModel1,ArtificialPlayer ai0,ArtificialPlayer ai1,boolean shufflePlayOrder){
  s0_=0;
  s1_=1;
  firstPlayerIndex=0;
  secondPlayerIndex=1;
  PlayerModel firstPlayer=playerModel0;
  if (shufflePlayOrder && Math.random() > 0.5) {
    s0_=1;
    s1_=0;
    firstPlayerIndex=1;
    secondPlayerIndex=0;
    firstPlayer=playerModel1;
  }
  log.debug(""String_Node_Str"",shufflePlayOrder);
  log.debug(""String_Node_Str"",s0_);
  boardModel_=new BoardModel(playerModel0,playerModel1,firstPlayer);
  boardModel_.getCurrentPlayer().setFirstPlayer(true);
  boardModel_.getWaitingPlayer().setFirstPlayer(false);
  this.ais=new ArtificialPlayer[2];
  this.ais[0]=ai0;
  this.ais[1]=ai1;
}","public Game(PlayerModel playerModel0,PlayerModel playerModel1,ArtificialPlayer ai0,ArtificialPlayer ai1,boolean shufflePlayOrder){
  playerGoingFirst=playerModel0;
  playerGoingSecond=playerModel1;
  aiForPlayerGoingFirst=ai0;
  aiForPlayerGoingSecond=ai1;
  if (shufflePlayOrder && Math.random() > 0.5) {
    playerGoingFirst=playerModel1;
    playerGoingSecond=playerModel0;
    aiForPlayerGoingFirst=ai1;
    aiForPlayerGoingSecond=ai0;
  }
  log.debug(""String_Node_Str"",shufflePlayOrder);
  log.debug(""String_Node_Str"",playerGoingFirst.getPlayerId());
  boardModel_=new BoardModel(playerGoingFirst,playerGoingSecond);
}",0.4441154700222057
112777,"public GameResult checkGameOver(int turnCount,GameRecord record){
  if (!boardModel_.isAlive(PlayerSide.CURRENT_PLAYER)) {
    PlayerModel winner=boardModel_.modelForSide(PlayerSide.WAITING_PLAYER);
    if (winner.isFirstPlayer()) {
      return new GameResult(s0_,firstPlayerIndex,turnCount + 1,record);
    }
 else {
      return new GameResult(s0_,secondPlayerIndex,turnCount + 1,record);
    }
  }
 else   if (!boardModel_.isAlive(PlayerSide.WAITING_PLAYER)) {
    PlayerModel winner=boardModel_.modelForSide(PlayerSide.CURRENT_PLAYER);
    if (winner.isFirstPlayer()) {
      return new GameResult(s0_,firstPlayerIndex,turnCount + 1,record);
    }
 else {
      return new GameResult(s0_,secondPlayerIndex,turnCount + 1,record);
    }
  }
  return null;
}","public GameResult checkGameOver(int turnCount,GameRecord record){
  if (!boardModel_.isAlive(PlayerSide.CURRENT_PLAYER)) {
    PlayerModel winner=boardModel_.modelForSide(PlayerSide.WAITING_PLAYER);
    return new GameResult(playerGoingFirst.getPlayerId(),winner.getPlayerId(),turnCount + 1,record);
  }
 else   if (!boardModel_.isAlive(PlayerSide.WAITING_PLAYER)) {
    PlayerModel winner=boardModel_.modelForSide(PlayerSide.CURRENT_PLAYER);
    return new GameResult(playerGoingFirst.getPlayerId(),winner.getPlayerId(),turnCount + 1,record);
  }
  return null;
}",0.6344410876132931
112778,"/** 
 * Run a single game
 * @param ai0 AI for player 0
 * @param hero0 Hero class for player 0
 * @param deck0 Deck for player 0
 * @param ai1 AI for player 1
 * @param hero1 Hero class for player 1
 * @param deck1 Deck for player 1
 * @param shufflePlayOrder Randomizes the play order if set to true
 * @return
 * @throws HSException
 */
protected GameResult runSingleGame(ArtificialPlayer ai0,Hero hero0,Deck deck0,ArtificialPlayer ai1,Hero hero1,Deck deck1,boolean shufflePlayOrder) throws HSException {
  deck0.shuffle();
  deck1.shuffle();
  PlayerModel playerModel0=new PlayerModel(""String_Node_Str"",hero0,deck0);
  PlayerModel playerModel1=new PlayerModel(""String_Node_Str"",hero1,deck1);
  Game game=new Game(playerModel0,playerModel1,ai0,ai1,shufflePlayOrder);
  return game.runGame();
}","/** 
 * Run a single game
 * @param ai0 AI for player 0
 * @param hero0 Hero class for player 0
 * @param deck0 Deck for player 0
 * @param ai1 AI for player 1
 * @param hero1 Hero class for player 1
 * @param deck1 Deck for player 1
 * @param shufflePlayOrder Randomizes the play order if set to true
 * @return
 * @throws HSException
 */
protected GameResult runSingleGame(ArtificialPlayer ai0,Hero hero0,Deck deck0,ArtificialPlayer ai1,Hero hero1,Deck deck1,boolean shufflePlayOrder) throws HSException {
  deck0.shuffle();
  deck1.shuffle();
  PlayerModel playerModel0=new PlayerModel(0,""String_Node_Str"",hero0,deck0);
  PlayerModel playerModel1=new PlayerModel(1,""String_Node_Str"",hero1,deck1);
  Game game=new Game(playerModel0,playerModel1,ai0,ai1,shufflePlayOrder);
  return game.runGame();
}",0.9974937343358397
112779,"public BoardModel(Hero p0_hero,Hero p1_hero){
  this.currentPlayer=new PlayerModel(""String_Node_Str"",p0_hero,null);
  this.waitingPlayer=new PlayerModel(""String_Node_Str"",p1_hero,null);
  buildModel();
}","public BoardModel(Hero p0_hero,Hero p1_hero){
  this.currentPlayer=new PlayerModel(0,""String_Node_Str"",p0_hero,null);
  this.waitingPlayer=new PlayerModel(0,""String_Node_Str"",p1_hero,null);
  buildModel();
}",0.9902439024390244
112780,"@Override public Object deepCopy(){
  PlayerModel copiedPlayerModel=new PlayerModel(this.name,(Hero)this.hero.deepCopy(),this.deck);
  copiedPlayerModel.setMana(mana);
  copiedPlayerModel.setOverload(overload);
  copiedPlayerModel.setFirstPlayer(isFirstPlayer);
  for (  Minion minion : minions) {
    copiedPlayerModel.getMinions().add((Minion)(minion).deepCopy());
  }
  copiedPlayerModel.setSpellDamage(spellDamage);
  for (  final Card card : hand) {
    Card tc=(Card)card.deepCopy();
    copiedPlayerModel.placeCardHand(tc);
  }
  return copiedPlayerModel;
}","@Override public Object deepCopy(){
  PlayerModel copiedPlayerModel=new PlayerModel(this.playerId,this.name,(Hero)this.hero.deepCopy(),this.deck);
  copiedPlayerModel.setMana(mana);
  copiedPlayerModel.setOverload(overload);
  for (  Minion minion : minions) {
    copiedPlayerModel.getMinions().add((Minion)(minion).deepCopy());
  }
  copiedPlayerModel.setSpellDamage(spellDamage);
  for (  final Card card : hand) {
    Card tc=(Card)card.deepCopy();
    copiedPlayerModel.placeCardHand(tc);
  }
  return copiedPlayerModel;
}",0.9404216315307058
112781,"public PlayerModel(String name,Hero hero,Deck deck){
  this.name=name;
  this.hero=hero;
  this.deck=deck;
  this.minions=new MinionList();
  this.hand=new IdentityLinkedList<>();
}","public PlayerModel(int playerId,String name,Hero hero,Deck deck){
  this.playerId=playerId;
  this.name=name;
  this.hero=hero;
  this.deck=deck;
  this.minions=new MinionList();
  this.hand=new IdentityLinkedList<>();
}",0.9027431421446384
112782,"@Override public int getNumCardsInHand(int playerIndex,int turn,int activePlayerIndex){
  try {
    BoardModel boardModel=boards_.get(activePlayerIndex).get(turn);
    PlayerSide playerByIndex=boardModel.getPlayerByIndex(playerIndex);
    PlayerSide otherPlayer=playerByIndex.getOtherPlayer();
    return boardModel.getNumCards_hand(otherPlayer);
  }
 catch (  HSInvalidPlayerIndexException e) {
    return 0;
  }
}","@Override public int getNumCardsInHand(int playerId,int turn,int currentPlayerId){
  try {
    BoardModel boardModel=boards_.get(currentPlayerId).get(turn);
    PlayerSide playerByIndex=boardModel.getPlayerByIndex(playerId);
    PlayerSide otherPlayer=playerByIndex.getOtherPlayer();
    return boardModel.getNumCards_hand(otherPlayer);
  }
 catch (  HSInvalidPlayerIndexException e) {
    return 0;
  }
}",0.9097560975609756
112783,"@Override public int getHeroArmor(int playerIndex,int turn,int activePlayerIndex){
  try {
    BoardModel boardModel=boards_.get(activePlayerIndex).get(turn);
    PlayerSide playerByIndex=boardModel.getPlayerByIndex(playerIndex);
    PlayerSide otherPlayer=playerByIndex.getOtherPlayer();
    return boardModel.getHero(otherPlayer).getArmor();
  }
 catch (  HSInvalidPlayerIndexException e) {
    return 0;
  }
}","@Override public int getHeroArmor(int playerId,int turn,int currentPlayerId){
  try {
    BoardModel boardModel=boards_.get(currentPlayerId).get(turn);
    PlayerSide playerByIndex=boardModel.getPlayerByIndex(playerId);
    PlayerSide otherPlayer=playerByIndex.getOtherPlayer();
    return boardModel.getHero(otherPlayer).getArmor();
  }
 catch (  HSInvalidPlayerIndexException e) {
    return 0;
  }
}",0.9090909090909092
112784,"@Override public int getHeroHealth(int playerIndex,int turn,int activePlayerIndex){
  try {
    BoardModel boardModel=boards_.get(activePlayerIndex).get(turn);
    PlayerSide playerByIndex=boardModel.getPlayerByIndex(playerIndex);
    PlayerSide otherPlayer=playerByIndex.getOtherPlayer();
    return boardModel.getHero(otherPlayer).getHealth();
  }
 catch (  HSInvalidPlayerIndexException e) {
    return 0;
  }
}","@Override public int getHeroHealth(int playerId,int turn,int currentPlayerId){
  try {
    BoardModel boardModel=boards_.get(currentPlayerId).get(turn);
    PlayerSide playerByIndex=boardModel.getPlayerByIndex(playerId);
    PlayerSide otherPlayer=playerByIndex.getOtherPlayer();
    return boardModel.getHero(otherPlayer).getHealth();
  }
 catch (  HSInvalidPlayerIndexException e) {
    return 0;
  }
}",0.9095354523227384
112785,"@Override public int getRecordLength(int playerID){
  return boards_.get(playerID).size();
}","@Override public int getRecordLength(int playerId){
  return boards_.get(playerId).size();
}",0.9782608695652174
112786,"@Override public int getNumMinions(int playerIndex,int turn,int activePlayerIndex){
  BoardModel boardModel=boards_.get(activePlayerIndex).get(turn);
  PlayerSide playerByIndex=boardModel.getPlayerByIndex(playerIndex);
  PlayerSide otherPlayer=playerByIndex.getOtherPlayer();
  return otherPlayer.getPlayer(boardModel).getNumMinions();
}","@Override public int getNumMinions(int playerId,int turn,int currentPlayerId){
  BoardModel boardModel=boards_.get(currentPlayerId).get(turn);
  PlayerSide playerByIndex=boardModel.getPlayerByIndex(playerId);
  PlayerSide otherPlayer=playerByIndex.getOtherPlayer();
  return otherPlayer.getPlayer(boardModel).getNumMinions();
}",0.608433734939759
112787,"/** 
 * Returns the number of cards in the hand of a given player
 * @param playerIndex The index of the player for which to return the data
 * @param turn Turn number
 * @param activePlayerIndex The index of the player that just played a turn
 * @return
 */
public int getNumCardsInHand(int playerIndex,int turn,int activePlayerIndex);","/** 
 * Returns the number of cards in the hand of a given player
 * @param playerId The id of the player for which to return the data
 * @param turn Turn number
 * @param currentPlayerId The id of the player that just played a turn
 * @return
 */
public int getNumCardsInHand(int playerId,int turn,int currentPlayerId);",0.9146341463414634
112788,"/** 
 * Get the armor of a given player's hero
 * @param playerIndex The index of the player for which to return the data
 * @param turn Turn number
 * @param activePlayerIndex The index of the player that just played a turn
 * @return
 */
public int getHeroArmor(int playerIndex,int turn,int activePlayerIndex);","/** 
 * Get the armor of a given player's hero
 * @param playerId The id of the player for which to return the data
 * @param turn Turn number
 * @param currentPlayerId The id of the player that just played a turn
 * @return
 */
public int getHeroArmor(int playerId,int turn,int currentPlayerId);",0.9078947368421052
112789,"/** 
 * Get the health of a given player's hero
 * @param playerIndex The index of the player for which to return the data
 * @param turn Turn number
 * @param activePlayerIndex The index of the player that just played a turn
 * @return
 */
public int getHeroHealth(int playerIndex,int turn,int activePlayerIndex);","/** 
 * Get the health of a given player's hero
 * @param playerId The id of the player for which to return the data
 * @param turn Turn number
 * @param currentPlayerId The id of the player that just played a turn
 * @return
 */
public int getHeroHealth(int playerId,int turn,int currentPlayerId);",0.9084967320261438
112790,"/** 
 * Returns the number of minions on a player's board
 * @param playerIndex The index of the player for which to return the data
 * @param turn Turn number
 * @param activePlayerIndex The index of the player that just played a turn
 * @return
 */
public int getNumMinions(int playerIndex,int turn,int activePlayerIndex);","/** 
 * Returns the number of minions on a player's board
 * @param playerId The id of the player for which to return the data
 * @param turn Turn number
 * @param currentPlayerId The id of the player that just played a turn
 * @return
 */
public int getNumMinions(int playerId,int turn,int currentPlayerId);",0.9177215189873418
112791,"/** 
 * Override for battlecry Battlecry: Give adjacent minions +1/+1 and Taunt
 * @param side
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public HearthTreeNode use_core(PlayerSide side,Minion targetMinion,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1,boolean singleRealizationOnly) throws HSException {
  HearthTreeNode toRet=super.use_core(side,targetMinion,boardState,deckPlayer0,deckPlayer1,singleRealizationOnly);
  if (toRet != null) {
    int thisMinionIndex=toRet.data_.getMinions(side).indexOf(this);
    if (thisMinionIndex == 0) {
      Minion minionToBuff=toRet.data_.getMinion(side,1);
      minionToBuff.setAttack((byte)(minionToBuff.getAttack() + 1));
      minionToBuff.setHealth((byte)(minionToBuff.getHealth() + 1));
      minionToBuff.setTaunt(true);
    }
 else     if (thisMinionIndex == 6) {
      Minion minionToBuff=toRet.data_.getMinion(side,5);
      minionToBuff.setAttack((byte)(minionToBuff.getAttack() + 1));
      minionToBuff.setHealth((byte)(minionToBuff.getHealth() + 1));
      minionToBuff.setTaunt(true);
    }
 else {
      Minion minionToBuff0=toRet.data_.getMinion(side,thisMinionIndex - 1);
      minionToBuff0.setAttack((byte)(minionToBuff0.getAttack() + 1));
      minionToBuff0.setHealth((byte)(minionToBuff0.getHealth() + 1));
      minionToBuff0.setTaunt(true);
      Minion minionToBuff1=toRet.data_.getMinion(side,thisMinionIndex + 1);
      minionToBuff1.setAttack((byte)(minionToBuff1.getAttack() + 1));
      minionToBuff1.setHealth((byte)(minionToBuff1.getHealth() + 1));
      minionToBuff1.setTaunt(true);
    }
  }
  return toRet;
}","/** 
 * Override for battlecry Battlecry: Give adjacent minions +1/+1 and Taunt
 * @param side
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public HearthTreeNode use_core(PlayerSide side,Minion targetMinion,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1,boolean singleRealizationOnly) throws HSException {
  HearthTreeNode toRet=super.use_core(side,targetMinion,boardState,deckPlayer0,deckPlayer1,singleRealizationOnly);
  if (toRet != null) {
    int thisMinionIndex=toRet.data_.getMinions(side).indexOf(this);
    int numMinions=side.getPlayer(boardState).getNumMinions();
    if (numMinions > 1) {
      int minionToTheLeft=thisMinionIndex > 0 ? thisMinionIndex - 1 : -1;
      int minionToTheRight=thisMinionIndex < numMinions - 1 ? thisMinionIndex - 1 : -1;
      if (minionToTheLeft >= 0) {
        Minion minionToBuff=toRet.data_.getMinion(side,minionToTheLeft);
        minionToBuff.setAttack((byte)(minionToBuff.getAttack() + 1));
        minionToBuff.setHealth((byte)(minionToBuff.getHealth() + 1));
        minionToBuff.setTaunt(true);
      }
      if (minionToTheRight >= 0) {
        Minion minionToBuff=toRet.data_.getMinion(side,minionToTheRight);
        minionToBuff.setAttack((byte)(minionToBuff.getAttack() + 1));
        minionToBuff.setHealth((byte)(minionToBuff.getHealth() + 1));
        minionToBuff.setTaunt(true);
      }
    }
  }
  return toRet;
}",0.7007031488841333
112792,"public GameResult runGame() throws HSException {
  curTurn_=0;
  curPlayer_=0;
  boardModel_.placeCard_hand_p0(0);
  boardModel_.placeCard_hand_p0(1);
  boardModel_.placeCard_hand_p0(2);
  boardModel_.setDeckPos_p0(3);
  boardModel_.placeCard_hand_p1(0);
  boardModel_.placeCard_hand_p1(1);
  boardModel_.placeCard_hand_p1(2);
  boardModel_.placeCard_hand_p1(3);
  boardModel_.placeCard_hand_p1(new TheCoin());
  boardModel_.setDeckPos_p1(4);
  GameRecord record=new GameSimpleRecord();
  record.put(0,s0_,(BoardModel)boardModel_.deepCopy());
  record.put(0,s1_,(BoardModel)boardModel_.flipPlayers().deepCopy());
  GameResult gameResult;
  for (int turnCount=0; turnCount < maxTurns_; ++turnCount) {
    log.info(""String_Node_Str"" + turnCount);
    long turnStart=System.currentTimeMillis();
    gameResult=playTurn(turnCount,record,ais[s0_]);
    if (gameResult != null)     return gameResult;
    gameResult=playTurn(turnCount,record,ais[s1_]);
    if (gameResult != null)     return gameResult;
    long turnEnd=System.currentTimeMillis();
    long turnDelta=turnEnd - turnStart;
    if (turnDelta > ArtificialPlayer.MAX_THINK_TIME / 2) {
      log.warn(""String_Node_Str"",turnDelta);
    }
 else {
      log.debug(""String_Node_Str"",turnDelta);
    }
  }
  return new GameResult(s0_,-1,0,record);
}","public GameResult runGame() throws HSException {
  curTurn_=0;
  curPlayer_=0;
  boardModel_.placeCard_hand_p0(0);
  boardModel_.placeCard_hand_p0(1);
  boardModel_.placeCard_hand_p0(2);
  boardModel_.setDeckPos_p0(3);
  boardModel_.placeCard_hand_p1(0);
  boardModel_.placeCard_hand_p1(1);
  boardModel_.placeCard_hand_p1(2);
  boardModel_.placeCard_hand_p1(3);
  boardModel_.placeCard_hand_p1(new TheCoin());
  boardModel_.setDeckPos_p1(4);
  GameRecord record=new GameSimpleRecord();
  record.put(0,s0_,(BoardModel)boardModel_.deepCopy());
  record.put(0,s1_,(BoardModel)boardModel_.flipPlayers().deepCopy());
  GameResult gameResult;
  for (int turnCount=0; turnCount < maxTurns_; ++turnCount) {
    log.info(""String_Node_Str"" + turnCount);
    long turnStart=System.currentTimeMillis();
    gameResult=playTurn(turnCount,record,s0_,ais[s0_]);
    if (gameResult != null)     return gameResult;
    gameResult=playTurn(turnCount,record,s1_,ais[s1_]);
    if (gameResult != null)     return gameResult;
    long turnEnd=System.currentTimeMillis();
    long turnDelta=turnEnd - turnStart;
    if (turnDelta > ArtificialPlayer.MAX_THINK_TIME / 2) {
      log.warn(""String_Node_Str"",turnDelta);
    }
 else {
      log.debug(""String_Node_Str"",turnDelta);
    }
  }
  return new GameResult(s0_,-1,0,record);
}",0.9969325153374232
112793,"private GameResult playTurn(int turnCount,GameRecord record,ArtificialPlayer ai) throws HSException {
  beginTurn(turnCount,boardModel_);
  GameResult gameResult;
  gameResult=checkGameOver(turnCount,record);
  if (gameResult != null)   return gameResult;
  boardModel_=playAITurn(turnCount,boardModel_,ai);
  endTurn(boardModel_);
  record.put(turnCount + 1,s0_,(BoardModel)boardModel_.deepCopy());
  gameResult=checkGameOver(turnCount,record);
  if (gameResult != null)   return gameResult;
  boardModel_=boardModel_.flipPlayers();
  return null;
}","private GameResult playTurn(int turnCount,GameRecord record,int activePlayerIndex,ArtificialPlayer ai) throws HSException {
  beginTurn(turnCount,boardModel_);
  GameResult gameResult;
  gameResult=checkGameOver(turnCount,record);
  if (gameResult != null)   return gameResult;
  boardModel_=playAITurn(turnCount,boardModel_,ai);
  endTurn(boardModel_);
  record.put(turnCount + 1,activePlayerIndex,(BoardModel)boardModel_.deepCopy());
  gameResult=checkGameOver(turnCount,record);
  if (gameResult != null)   return gameResult;
  boardModel_=boardModel_.flipPlayers();
  return null;
}",0.9630281690140844
112794,"public ImplementedCardList(){
  list_=new ArrayList<ImplementedCard>();
  map_=new HashMap<Class<?>,ImplementedCard>();
{
    ImplementedCard card=new ImplementedCard(Abomination.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,4,4);
    list_.add(card);
    map_.put(Abomination.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(AbusiveSergeant.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,2,1);
    list_.add(card);
    map_.put(AbusiveSergeant.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(AcidicSwampOoze.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,3,2);
    list_.add(card);
    map_.put(AcidicSwampOoze.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(AcolyteOfPain.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,1,3);
    list_.add(card);
    map_.put(AcolyteOfPain.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(AlAkirTheWindlord.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",8,3,5);
    list_.add(card);
    map_.put(AlAkirTheWindlord.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(AldorPeacekeeper.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,3,3);
    list_.add(card);
    map_.put(AldorPeacekeeper.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Alexstrasza.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",9,8,8);
    list_.add(card);
    map_.put(Alexstrasza.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(AmaniBerserker.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,2,3);
    list_.add(card);
    map_.put(AmaniBerserker.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(AncestralHealing.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0,-1,-1);
    list_.add(card);
    map_.put(AncestralHealing.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(AncestralSpirit.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,-1,-1);
    list_.add(card);
    map_.put(AncestralSpirit.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(AncientOfLore.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",7,5,5);
    list_.add(card);
    map_.put(AncientOfLore.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(AncientOfWar.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",7,5,5);
    list_.add(card);
    map_.put(AncientOfWar.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(AngryChicken.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,1,1);
    list_.add(card);
    map_.put(AngryChicken.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ArcaneExplosion.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,-1,-1);
    list_.add(card);
    map_.put(ArcaneExplosion.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ArcaneGolem.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,4,2);
    list_.add(card);
    map_.put(ArcaneGolem.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ArcaneIntellect.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,-1,-1);
    list_.add(card);
    map_.put(ArcaneIntellect.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ArcaneShot.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(ArcaneShot.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ArcaniteReaper.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,5,-1);
    list_.add(card);
    map_.put(ArcaniteReaper.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Archmage.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",6,4,7);
    list_.add(card);
    map_.put(Archmage.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ArchmageAntonidas.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",7,5,7);
    list_.add(card);
    map_.put(ArchmageAntonidas.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ArgentCommander.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",6,4,2);
    list_.add(card);
    map_.put(ArgentCommander.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ArgentProtector.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,2,2);
    list_.add(card);
    map_.put(ArgentProtector.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ArgentSquire.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,1,1);
    list_.add(card);
    map_.put(ArgentSquire.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Armorsmith.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,1,4);
    list_.add(card);
    map_.put(Armorsmith.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(AssassinsBlade.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,3,-1);
    list_.add(card);
    map_.put(AssassinsBlade.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Assassinate.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,-1,-1);
    list_.add(card);
    map_.put(Assassinate.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(AzureDrake.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,4,4);
    list_.add(card);
    map_.put(AzureDrake.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Backstab.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0,-1,-1);
    list_.add(card);
    map_.put(Backstab.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(BigGameHunter.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,4,2);
    list_.add(card);
    map_.put(BigGameHunter.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(BlessingOfKings.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,-1,-1);
    list_.add(card);
    map_.put(BlessingOfKings.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(BlessingOfMight.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(BlessingOfMight.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(BloodfenRaptor.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,3,2);
    list_.add(card);
    map_.put(BloodfenRaptor.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Bloodlust.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,-1,-1);
    list_.add(card);
    map_.put(Bloodlust.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(BloodmageThalnos.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,1,1);
    list_.add(card);
    map_.put(BloodmageThalnos.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(BluegillWarrior.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,2,1);
    list_.add(card);
    map_.put(BluegillWarrior.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(BootyBayBodyguard.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,5,4);
    list_.add(card);
    map_.put(BootyBayBodyguard.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(BoulderfistOgre.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",6,6,7);
    list_.add(card);
    map_.put(BoulderfistOgre.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(CairneBloodhoof.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",6,4,5);
    list_.add(card);
    map_.put(CairneBloodhoof.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Charge.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,-1,-1);
    list_.add(card);
    map_.put(Charge.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ChillwindYeti.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,4,5);
    list_.add(card);
    map_.put(ChillwindYeti.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(CircleOfHealing.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0,-1,-1);
    list_.add(card);
    map_.put(CircleOfHealing.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Claw.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(Claw.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ColdlightOracle.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,2,2);
    list_.add(card);
    map_.put(ColdlightOracle.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Consecration.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,-1,-1);
    list_.add(card);
    map_.put(Consecration.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(CoreHound.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",7,9,5);
    list_.add(card);
    map_.put(CoreHound.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Corruption.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(Corruption.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(CrazedAlchemist.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,2,2);
    list_.add(card);
    map_.put(CrazedAlchemist.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(CruelTaskmaster.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,2,2);
    list_.add(card);
    map_.put(CruelTaskmaster.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(DalaranMage.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,1,4);
    list_.add(card);
    map_.put(DalaranMage.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(DarkscaleHealer.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,4,5);
    list_.add(card);
    map_.put(DarkscaleHealer.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(DeadlyPoison.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(DeadlyPoison.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(DefenderOfArgus.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,2,3);
    list_.add(card);
    map_.put(DefenderOfArgus.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(DivineSpirit.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,-1,-1);
    list_.add(card);
    map_.put(DivineSpirit.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(DragonlingMechanic.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,2,4);
    list_.add(card);
    map_.put(DragonlingMechanic.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(DrainLife.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,-1,-1);
    list_.add(card);
    map_.put(DrainLife.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(DreadInfernal.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",6,6,6);
    list_.add(card);
    map_.put(DreadInfernal.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(DustDevil.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,3,1);
    list_.add(card);
    map_.put(DustDevil.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(EarthElemental.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,7,8);
    list_.add(card);
    map_.put(EarthElemental.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ElvenArcher.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,1,1);
    list_.add(card);
    map_.put(ElvenArcher.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Execute.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(Execute.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(FanOfKnives.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,-1,-1);
    list_.add(card);
    map_.put(FanOfKnives.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(FenCreeper.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,3,6);
    list_.add(card);
    map_.put(FenCreeper.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(FieryWarAxe.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,3,-1);
    list_.add(card);
    map_.put(FieryWarAxe.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(FireElemental.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",6,6,5);
    list_.add(card);
    map_.put(FireElemental.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Fireball.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,-1,-1);
    list_.add(card);
    map_.put(Fireball.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Flamestrike.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",7,-1,-1);
    list_.add(card);
    map_.put(Flamestrike.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(FlesheatingGhoul.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,2,3);
    list_.add(card);
    map_.put(FlesheatingGhoul.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(FrostNova.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,-1,-1);
    list_.add(card);
    map_.put(FrostNova.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(FrostShock.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(FrostShock.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Frostbolt.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,-1,-1);
    list_.add(card);
    map_.put(Frostbolt.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(FrostwolfGrunt.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,2,2);
    list_.add(card);
    map_.put(FrostwolfGrunt.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(FrostwolfWarlord.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,4,4);
    list_.add(card);
    map_.put(FrostwolfWarlord.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(GnomishInventor.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,2,4);
    list_.add(card);
    map_.put(GnomishInventor.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(GoldshireFootman.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,1,2);
    list_.add(card);
    map_.put(GoldshireFootman.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(GrimscaleOracle.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,1,1);
    list_.add(card);
    map_.put(GrimscaleOracle.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(GrommashHellscream.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",8,4,9);
    list_.add(card);
    map_.put(GrommashHellscream.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(GuardianOfKings.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",7,5,6);
    list_.add(card);
    map_.put(GuardianOfKings.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(GurubashiBerserker.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,2,7);
    list_.add(card);
    map_.put(GurubashiBerserker.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(HammerOfWrath.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,-1,-1);
    list_.add(card);
    map_.put(HammerOfWrath.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(HandOfProtection.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(HandOfProtection.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(HarvestGolem.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,2,3);
    list_.add(card);
    map_.put(HarvestGolem.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(HealingTouch.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,-1,-1);
    list_.add(card);
    map_.put(HealingTouch.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Hellfire.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,-1,-1);
    list_.add(card);
    map_.put(Hellfire.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(HeroicStrike.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,-1,-1);
    list_.add(card);
    map_.put(HeroicStrike.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Hex.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,-1,-1);
    list_.add(card);
    map_.put(Hex.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(HolyFire.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",6,-1,-1);
    list_.add(card);
    map_.put(HolyFire.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(HolyLight.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,-1,-1);
    list_.add(card);
    map_.put(HolyLight.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(HolyNova.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,-1,-1);
    list_.add(card);
    map_.put(HolyNova.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(HolySmite.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(HolySmite.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Houndmaster.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,4,3);
    list_.add(card);
    map_.put(Houndmaster.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Humility.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(Humility.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(HuntersMark.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0,-1,-1);
    list_.add(card);
    map_.put(HuntersMark.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(InjuredBlademaster.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,4,7);
    list_.add(card);
    map_.put(InjuredBlademaster.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(InnerFire.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(InnerFire.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(InnerRage.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0,-1,-1);
    list_.add(card);
    map_.put(InnerRage.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Innervate.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0,-1,-1);
    list_.add(card);
    map_.put(Innervate.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(IronbarkProtector.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",8,8,8);
    list_.add(card);
    map_.put(IronbarkProtector.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(IronbeakOwl.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,2,1);
    list_.add(card);
    map_.put(IronbeakOwl.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(IronforgeRifleman.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,2,2);
    list_.add(card);
    map_.put(IronforgeRifleman.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(IronfurGrizzly.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,3,3);
    list_.add(card);
    map_.put(IronfurGrizzly.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(JunglePanther.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,4,2);
    list_.add(card);
    map_.put(JunglePanther.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(KillCommand.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,-1,-1);
    list_.add(card);
    map_.put(KillCommand.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(KingKrush.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",9,8,8);
    list_.add(card);
    map_.put(KingKrush.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(KoboldGeomancer.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,2,2);
    list_.add(card);
    map_.put(KoboldGeomancer.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(KorkronElite.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,4,3);
    list_.add(card);
    map_.put(KorkronElite.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(LayOnHands.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",8,-1,-1);
    list_.add(card);
    map_.put(LayOnHands.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(LeperGnome.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,2,1);
    list_.add(card);
    map_.put(LeperGnome.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(LightsJustice.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,1,-1);
    list_.add(card);
    map_.put(LightsJustice.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(LootHoarder.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,2,1);
    list_.add(card);
    map_.put(LootHoarder.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(LordOfTheArena.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",6,6,5);
    list_.add(card);
    map_.put(LordOfTheArena.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(MagmaRager.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,5,1);
    list_.add(card);
    map_.put(MagmaRager.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Malygos.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",9,4,12);
    list_.add(card);
    map_.put(Malygos.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(MarkOfTheWild.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,-1,-1);
    list_.add(card);
    map_.put(MarkOfTheWild.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(MindBlast.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,-1,-1);
    list_.add(card);
    map_.put(MindBlast.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(MindControl.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",10,-1,-1);
    list_.add(card);
    map_.put(MindControl.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(MirrorImage.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(MirrorImage.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(MogushanWarden.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,1,7);
    list_.add(card);
    map_.put(MogushanWarden.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Moonfire.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0,-1,-1);
    list_.add(card);
    map_.put(Moonfire.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(MortalCoil.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(MortalCoil.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(MurlocRaider.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,2,1);
    list_.add(card);
    map_.put(MurlocRaider.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(MurlocTidehunter.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,2,1);
    list_.add(card);
    map_.put(MurlocTidehunter.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Nightblade.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,4,4);
    list_.add(card);
    map_.put(Nightblade.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(NorthshireCleric.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,1,3);
    list_.add(card);
    map_.put(NorthshireCleric.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(NoviceEngineer.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,1,1);
    list_.add(card);
    map_.put(NoviceEngineer.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(OasisSnapjaw.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,2,7);
    list_.add(card);
    map_.put(OasisSnapjaw.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(OgreMagi.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,4,4);
    list_.add(card);
    map_.put(OgreMagi.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Polymorph.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,-1,-1);
    list_.add(card);
    map_.put(Polymorph.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(PowerWordShield.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(PowerWordShield.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(PriestessOfElune.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",6,5,4);
    list_.add(card);
    map_.put(PriestessOfElune.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Pyroblast.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",10,-1,-1);
    list_.add(card);
    map_.put(Pyroblast.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(RagingWorgen.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,3,3);
    list_.add(card);
    map_.put(RagingWorgen.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(RaidLeader.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,2,2);
    list_.add(card);
    map_.put(RaidLeader.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(RavenholdtAssassin.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",7,7,5);
    list_.add(card);
    map_.put(RavenholdtAssassin.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(RazorfenHunter.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,2,3);
    list_.add(card);
    map_.put(RazorfenHunter.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(RecklessRocketeer.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",6,5,2);
    list_.add(card);
    map_.put(RecklessRocketeer.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(RiverCrocolisk.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,2,3);
    list_.add(card);
    map_.put(RiverCrocolisk.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(RockbiterWeapon.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(RockbiterWeapon.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(SacrificialPact.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0,-1,-1);
    list_.add(card);
    map_.put(SacrificialPact.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Sap.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,-1,-1);
    list_.add(card);
    map_.put(Sap.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(SavageRoar.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,-1,-1);
    list_.add(card);
    map_.put(SavageRoar.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(SavannahHighmane.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",6,6,5);
    list_.add(card);
    map_.put(SavannahHighmane.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ScarletCrusader.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,3,1);
    list_.add(card);
    map_.put(ScarletCrusader.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(SenjinShieldmasta.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,3,5);
    list_.add(card);
    map_.put(SenjinShieldmasta.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ShadowBolt.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,-1,-1);
    list_.add(card);
    map_.put(ShadowBolt.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ShadowWordDeath.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,-1,-1);
    list_.add(card);
    map_.put(ShadowWordDeath.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ShadowWordPain.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,-1,-1);
    list_.add(card);
    map_.put(ShadowWordPain.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ShatteredSunCleric.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,3,2);
    list_.add(card);
    map_.put(ShatteredSunCleric.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ShieldBlock.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,-1,-1);
    list_.add(card);
    map_.put(ShieldBlock.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Shieldbearer.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,0,4);
    list_.add(card);
    map_.put(Shieldbearer.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Shiv.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,-1,-1);
    list_.add(card);
    map_.put(Shiv.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Silence.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0,-1,-1);
    list_.add(card);
    map_.put(Silence.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(SilverHandKnight.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,4,4);
    list_.add(card);
    map_.put(SilverHandKnight.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(SilverbackPatriarch.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,1,4);
    list_.add(card);
    map_.put(SilverbackPatriarch.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(SilvermoonGuardian.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,3,3);
    list_.add(card);
    map_.put(SilvermoonGuardian.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(SinisterStrike.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(SinisterStrike.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Slam.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,-1,-1);
    list_.add(card);
    map_.put(Slam.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Spellbreaker.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,4,3);
    list_.add(card);
    map_.put(Spellbreaker.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Sprint.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",7,-1,-1);
    list_.add(card);
    map_.put(Sprint.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Starfire.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",6,-1,-1);
    list_.add(card);
    map_.put(Starfire.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(StarvingBuzzard.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,2,1);
    list_.add(card);
    map_.put(StarvingBuzzard.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(StonetuskBoar.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,1,1);
    list_.add(card);
    map_.put(StonetuskBoar.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(StormforgedAxe.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,2,-1);
    list_.add(card);
    map_.put(StormforgedAxe.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(StormpikeCommando.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,4,2);
    list_.add(card);
    map_.put(StormpikeCommando.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(StormwindChampion.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",7,6,6);
    list_.add(card);
    map_.put(StormwindChampion.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(StormwindKnight.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,2,5);
    list_.add(card);
    map_.put(StormwindKnight.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(StranglethornTiger.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,5,5);
    list_.add(card);
    map_.put(StranglethornTiger.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Sunwalker.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",6,4,5);
    list_.add(card);
    map_.put(Sunwalker.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Swipe.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,-1,-1);
    list_.add(card);
    map_.put(Swipe.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(TaurenWarrior.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,2,3);
    list_.add(card);
    map_.put(TaurenWarrior.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(TempleEnforcer.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",6,6,6);
    list_.add(card);
    map_.put(TempleEnforcer.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ThrallmarFarseer.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,2,3);
    list_.add(card);
    map_.put(ThrallmarFarseer.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(TimberWolf.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,1,1);
    list_.add(card);
    map_.put(TimberWolf.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(TotemicMight.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0,-1,-1);
    list_.add(card);
    map_.put(TotemicMight.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(UnstableGhoul.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,1,3);
    list_.add(card);
    map_.put(UnstableGhoul.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(VioletTeacher.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,3,5);
    list_.add(card);
    map_.put(VioletTeacher.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Voidwalker.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,1,3);
    list_.add(card);
    map_.put(Voidwalker.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(VoodooDoctor.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,2,1);
    list_.add(card);
    map_.put(VoodooDoctor.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(WarGolem.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",7,7,7);
    list_.add(card);
    map_.put(WarGolem.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(WaterElemental.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,3,6);
    list_.add(card);
    map_.put(WaterElemental.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Whirlwind.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(Whirlwind.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(WildGrowth.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,-1,-1);
    list_.add(card);
    map_.put(WildGrowth.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Windfury.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,-1,-1);
    list_.add(card);
    map_.put(Windfury.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(WindfuryHarpy.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",6,4,5);
    list_.add(card);
    map_.put(WindfuryHarpy.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Windspeaker.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,3,3);
    list_.add(card);
    map_.put(Windspeaker.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Wisp.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0,1,1);
    list_.add(card);
    map_.put(Wisp.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Wolfrider.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,3,1);
    list_.add(card);
    map_.put(Wolfrider.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(WorgenInfiltrator.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,2,1);
    list_.add(card);
    map_.put(WorgenInfiltrator.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(YoungDragonhawk.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,1,1);
    list_.add(card);
    map_.put(YoungDragonhawk.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ZombieChow.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,2,3);
    list_.add(card);
    map_.put(ZombieChow.class,card);
  }
}","public ImplementedCardList(){
  list_=new ArrayList<ImplementedCard>();
  map_=new HashMap<Class<?>,ImplementedCard>();
{
    ImplementedCard card=new ImplementedCard(Abomination.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,4,4);
    list_.add(card);
    map_.put(Abomination.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(AbusiveSergeant.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,2,1);
    list_.add(card);
    map_.put(AbusiveSergeant.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(AcidicSwampOoze.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,3,2);
    list_.add(card);
    map_.put(AcidicSwampOoze.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(AcolyteOfPain.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,1,3);
    list_.add(card);
    map_.put(AcolyteOfPain.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(AlAkirTheWindlord.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",8,3,5);
    list_.add(card);
    map_.put(AlAkirTheWindlord.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(AldorPeacekeeper.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,3,3);
    list_.add(card);
    map_.put(AldorPeacekeeper.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Alexstrasza.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",9,8,8);
    list_.add(card);
    map_.put(Alexstrasza.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(AmaniBerserker.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,2,3);
    list_.add(card);
    map_.put(AmaniBerserker.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(AncestralHealing.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0,-1,-1);
    list_.add(card);
    map_.put(AncestralHealing.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(AncestralSpirit.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,-1,-1);
    list_.add(card);
    map_.put(AncestralSpirit.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(AncientOfLore.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",7,5,5);
    list_.add(card);
    map_.put(AncientOfLore.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(AncientOfWar.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",7,5,5);
    list_.add(card);
    map_.put(AncientOfWar.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(AngryChicken.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,1,1);
    list_.add(card);
    map_.put(AngryChicken.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ArcaneExplosion.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,-1,-1);
    list_.add(card);
    map_.put(ArcaneExplosion.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ArcaneGolem.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,4,2);
    list_.add(card);
    map_.put(ArcaneGolem.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ArcaneIntellect.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,-1,-1);
    list_.add(card);
    map_.put(ArcaneIntellect.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ArcaneShot.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(ArcaneShot.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ArcaniteReaper.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,5,-1);
    list_.add(card);
    map_.put(ArcaniteReaper.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Archmage.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",6,4,7);
    list_.add(card);
    map_.put(Archmage.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ArchmageAntonidas.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",7,5,7);
    list_.add(card);
    map_.put(ArchmageAntonidas.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ArgentCommander.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",6,4,2);
    list_.add(card);
    map_.put(ArgentCommander.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ArgentProtector.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,2,2);
    list_.add(card);
    map_.put(ArgentProtector.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ArgentSquire.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,1,1);
    list_.add(card);
    map_.put(ArgentSquire.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Armorsmith.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,1,4);
    list_.add(card);
    map_.put(Armorsmith.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(AssassinsBlade.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,3,-1);
    list_.add(card);
    map_.put(AssassinsBlade.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Assassinate.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,-1,-1);
    list_.add(card);
    map_.put(Assassinate.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(AzureDrake.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,4,4);
    list_.add(card);
    map_.put(AzureDrake.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Backstab.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0,-1,-1);
    list_.add(card);
    map_.put(Backstab.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(BigGameHunter.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,4,2);
    list_.add(card);
    map_.put(BigGameHunter.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(BlessingOfKings.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,-1,-1);
    list_.add(card);
    map_.put(BlessingOfKings.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(BlessingOfMight.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(BlessingOfMight.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(BloodfenRaptor.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,3,2);
    list_.add(card);
    map_.put(BloodfenRaptor.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Bloodlust.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,-1,-1);
    list_.add(card);
    map_.put(Bloodlust.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(BloodmageThalnos.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,1,1);
    list_.add(card);
    map_.put(BloodmageThalnos.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(BluegillWarrior.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,2,1);
    list_.add(card);
    map_.put(BluegillWarrior.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(BootyBayBodyguard.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,5,4);
    list_.add(card);
    map_.put(BootyBayBodyguard.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(BoulderfistOgre.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",6,6,7);
    list_.add(card);
    map_.put(BoulderfistOgre.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(CairneBloodhoof.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",6,4,5);
    list_.add(card);
    map_.put(CairneBloodhoof.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Charge.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,-1,-1);
    list_.add(card);
    map_.put(Charge.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ChillwindYeti.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,4,5);
    list_.add(card);
    map_.put(ChillwindYeti.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(CircleOfHealing.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0,-1,-1);
    list_.add(card);
    map_.put(CircleOfHealing.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Claw.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(Claw.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ColdlightOracle.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,2,2);
    list_.add(card);
    map_.put(ColdlightOracle.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Consecration.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,-1,-1);
    list_.add(card);
    map_.put(Consecration.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(CoreHound.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",7,9,5);
    list_.add(card);
    map_.put(CoreHound.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Corruption.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(Corruption.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(CrazedAlchemist.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,2,2);
    list_.add(card);
    map_.put(CrazedAlchemist.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(CruelTaskmaster.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,2,2);
    list_.add(card);
    map_.put(CruelTaskmaster.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(DalaranMage.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,1,4);
    list_.add(card);
    map_.put(DalaranMage.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(DarkscaleHealer.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,4,5);
    list_.add(card);
    map_.put(DarkscaleHealer.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(DeadlyPoison.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(DeadlyPoison.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(DefenderOfArgus.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,2,3);
    list_.add(card);
    map_.put(DefenderOfArgus.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(DivineSpirit.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,-1,-1);
    list_.add(card);
    map_.put(DivineSpirit.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(DragonlingMechanic.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,2,4);
    list_.add(card);
    map_.put(DragonlingMechanic.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(DrainLife.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,-1,-1);
    list_.add(card);
    map_.put(DrainLife.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(DreadInfernal.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",6,6,6);
    list_.add(card);
    map_.put(DreadInfernal.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(DustDevil.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,3,1);
    list_.add(card);
    map_.put(DustDevil.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(EarthElemental.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,7,8);
    list_.add(card);
    map_.put(EarthElemental.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ElvenArcher.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,1,1);
    list_.add(card);
    map_.put(ElvenArcher.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Execute.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(Execute.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(FanOfKnives.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,-1,-1);
    list_.add(card);
    map_.put(FanOfKnives.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(FenCreeper.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,3,6);
    list_.add(card);
    map_.put(FenCreeper.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(FieryWarAxe.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,3,-1);
    list_.add(card);
    map_.put(FieryWarAxe.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(FireElemental.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",6,6,5);
    list_.add(card);
    map_.put(FireElemental.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Fireball.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,-1,-1);
    list_.add(card);
    map_.put(Fireball.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Flamestrike.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",7,-1,-1);
    list_.add(card);
    map_.put(Flamestrike.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(FlesheatingGhoul.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,2,3);
    list_.add(card);
    map_.put(FlesheatingGhoul.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(FrostNova.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,-1,-1);
    list_.add(card);
    map_.put(FrostNova.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(FrostShock.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(FrostShock.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Frostbolt.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,-1,-1);
    list_.add(card);
    map_.put(Frostbolt.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(FrostwolfGrunt.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,2,2);
    list_.add(card);
    map_.put(FrostwolfGrunt.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(FrostwolfWarlord.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,4,4);
    list_.add(card);
    map_.put(FrostwolfWarlord.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(GnomishInventor.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,2,4);
    list_.add(card);
    map_.put(GnomishInventor.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(GoldshireFootman.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,1,2);
    list_.add(card);
    map_.put(GoldshireFootman.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(GrimscaleOracle.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,1,1);
    list_.add(card);
    map_.put(GrimscaleOracle.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(GrommashHellscream.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",8,4,9);
    list_.add(card);
    map_.put(GrommashHellscream.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(GuardianOfKings.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",7,5,6);
    list_.add(card);
    map_.put(GuardianOfKings.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(GurubashiBerserker.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,2,7);
    list_.add(card);
    map_.put(GurubashiBerserker.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(HammerOfWrath.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,-1,-1);
    list_.add(card);
    map_.put(HammerOfWrath.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(HandOfProtection.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(HandOfProtection.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(HarvestGolem.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,2,3);
    list_.add(card);
    map_.put(HarvestGolem.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(HealingTouch.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,-1,-1);
    list_.add(card);
    map_.put(HealingTouch.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Hellfire.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,-1,-1);
    list_.add(card);
    map_.put(Hellfire.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(HeroicStrike.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,-1,-1);
    list_.add(card);
    map_.put(HeroicStrike.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Hex.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,-1,-1);
    list_.add(card);
    map_.put(Hex.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(HolyFire.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",6,-1,-1);
    list_.add(card);
    map_.put(HolyFire.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(HolyLight.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,-1,-1);
    list_.add(card);
    map_.put(HolyLight.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(HolyNova.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,-1,-1);
    list_.add(card);
    map_.put(HolyNova.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(HolySmite.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(HolySmite.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Houndmaster.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,4,3);
    list_.add(card);
    map_.put(Houndmaster.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Humility.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(Humility.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(HuntersMark.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0,-1,-1);
    list_.add(card);
    map_.put(HuntersMark.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(InjuredBlademaster.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,4,7);
    list_.add(card);
    map_.put(InjuredBlademaster.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(InnerFire.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(InnerFire.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(InnerRage.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0,-1,-1);
    list_.add(card);
    map_.put(InnerRage.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Innervate.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0,-1,-1);
    list_.add(card);
    map_.put(Innervate.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(IronbarkProtector.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",8,8,8);
    list_.add(card);
    map_.put(IronbarkProtector.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(IronforgeRifleman.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,2,2);
    list_.add(card);
    map_.put(IronforgeRifleman.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(IronfurGrizzly.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,3,3);
    list_.add(card);
    map_.put(IronfurGrizzly.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(JunglePanther.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,4,2);
    list_.add(card);
    map_.put(JunglePanther.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(KillCommand.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,-1,-1);
    list_.add(card);
    map_.put(KillCommand.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(KingKrush.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",9,8,8);
    list_.add(card);
    map_.put(KingKrush.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(KoboldGeomancer.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,2,2);
    list_.add(card);
    map_.put(KoboldGeomancer.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(KorkronElite.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,4,3);
    list_.add(card);
    map_.put(KorkronElite.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(LayOnHands.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",8,-1,-1);
    list_.add(card);
    map_.put(LayOnHands.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(LeperGnome.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,2,1);
    list_.add(card);
    map_.put(LeperGnome.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(LightsJustice.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,1,-1);
    list_.add(card);
    map_.put(LightsJustice.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(LootHoarder.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,2,1);
    list_.add(card);
    map_.put(LootHoarder.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(LordOfTheArena.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",6,6,5);
    list_.add(card);
    map_.put(LordOfTheArena.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(MagmaRager.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,5,1);
    list_.add(card);
    map_.put(MagmaRager.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Malygos.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",9,4,12);
    list_.add(card);
    map_.put(Malygos.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(MarkOfTheWild.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,-1,-1);
    list_.add(card);
    map_.put(MarkOfTheWild.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(MindBlast.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,-1,-1);
    list_.add(card);
    map_.put(MindBlast.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(MindControl.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",10,-1,-1);
    list_.add(card);
    map_.put(MindControl.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(MirrorImage.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(MirrorImage.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(MogushanWarden.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,1,7);
    list_.add(card);
    map_.put(MogushanWarden.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Moonfire.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0,-1,-1);
    list_.add(card);
    map_.put(Moonfire.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(MortalCoil.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(MortalCoil.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(MurlocRaider.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,2,1);
    list_.add(card);
    map_.put(MurlocRaider.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(MurlocTidehunter.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,2,1);
    list_.add(card);
    map_.put(MurlocTidehunter.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Nightblade.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,4,4);
    list_.add(card);
    map_.put(Nightblade.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(NorthshireCleric.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,1,3);
    list_.add(card);
    map_.put(NorthshireCleric.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(NoviceEngineer.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,1,1);
    list_.add(card);
    map_.put(NoviceEngineer.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(OasisSnapjaw.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,2,7);
    list_.add(card);
    map_.put(OasisSnapjaw.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(OgreMagi.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,4,4);
    list_.add(card);
    map_.put(OgreMagi.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Polymorph.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,-1,-1);
    list_.add(card);
    map_.put(Polymorph.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(PowerWordShield.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(PowerWordShield.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(PriestessOfElune.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",6,5,4);
    list_.add(card);
    map_.put(PriestessOfElune.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Pyroblast.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",10,-1,-1);
    list_.add(card);
    map_.put(Pyroblast.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(RagingWorgen.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,3,3);
    list_.add(card);
    map_.put(RagingWorgen.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(RaidLeader.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,2,2);
    list_.add(card);
    map_.put(RaidLeader.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(RavenholdtAssassin.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",7,7,5);
    list_.add(card);
    map_.put(RavenholdtAssassin.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(RazorfenHunter.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,2,3);
    list_.add(card);
    map_.put(RazorfenHunter.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(RecklessRocketeer.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",6,5,2);
    list_.add(card);
    map_.put(RecklessRocketeer.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(RiverCrocolisk.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,2,3);
    list_.add(card);
    map_.put(RiverCrocolisk.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(RockbiterWeapon.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(RockbiterWeapon.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(SacrificialPact.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0,-1,-1);
    list_.add(card);
    map_.put(SacrificialPact.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Sap.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,-1,-1);
    list_.add(card);
    map_.put(Sap.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(SavageRoar.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,-1,-1);
    list_.add(card);
    map_.put(SavageRoar.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(SavannahHighmane.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",6,6,5);
    list_.add(card);
    map_.put(SavannahHighmane.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ScarletCrusader.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,3,1);
    list_.add(card);
    map_.put(ScarletCrusader.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(SenjinShieldmasta.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,3,5);
    list_.add(card);
    map_.put(SenjinShieldmasta.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ShadowBolt.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,-1,-1);
    list_.add(card);
    map_.put(ShadowBolt.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ShadowWordDeath.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,-1,-1);
    list_.add(card);
    map_.put(ShadowWordDeath.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ShadowWordPain.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,-1,-1);
    list_.add(card);
    map_.put(ShadowWordPain.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ShatteredSunCleric.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,3,2);
    list_.add(card);
    map_.put(ShatteredSunCleric.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ShieldBlock.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,-1,-1);
    list_.add(card);
    map_.put(ShieldBlock.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Shieldbearer.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,0,4);
    list_.add(card);
    map_.put(Shieldbearer.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Shiv.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,-1,-1);
    list_.add(card);
    map_.put(Shiv.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Silence.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0,-1,-1);
    list_.add(card);
    map_.put(Silence.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(SilverHandKnight.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,4,4);
    list_.add(card);
    map_.put(SilverHandKnight.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(SilverbackPatriarch.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,1,4);
    list_.add(card);
    map_.put(SilverbackPatriarch.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(SilvermoonGuardian.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,3,3);
    list_.add(card);
    map_.put(SilvermoonGuardian.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(SinisterStrike.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(SinisterStrike.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Slam.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,-1,-1);
    list_.add(card);
    map_.put(Slam.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Sprint.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",7,-1,-1);
    list_.add(card);
    map_.put(Sprint.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Starfire.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",6,-1,-1);
    list_.add(card);
    map_.put(Starfire.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(StarvingBuzzard.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,2,1);
    list_.add(card);
    map_.put(StarvingBuzzard.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(StonetuskBoar.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,1,1);
    list_.add(card);
    map_.put(StonetuskBoar.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(StormpikeCommando.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,4,2);
    list_.add(card);
    map_.put(StormpikeCommando.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(StormwindChampion.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",7,6,6);
    list_.add(card);
    map_.put(StormwindChampion.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(StormwindKnight.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,2,5);
    list_.add(card);
    map_.put(StormwindKnight.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(StranglethornTiger.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5,5,5);
    list_.add(card);
    map_.put(StranglethornTiger.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Sunwalker.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",6,4,5);
    list_.add(card);
    map_.put(Sunwalker.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Swipe.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,-1,-1);
    list_.add(card);
    map_.put(Swipe.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(TaurenWarrior.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,2,3);
    list_.add(card);
    map_.put(TaurenWarrior.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ThrallmarFarseer.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,2,3);
    list_.add(card);
    map_.put(ThrallmarFarseer.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(TimberWolf.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,1,1);
    list_.add(card);
    map_.put(TimberWolf.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(TotemicMight.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0,-1,-1);
    list_.add(card);
    map_.put(TotemicMight.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(UnstableGhoul.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,1,3);
    list_.add(card);
    map_.put(UnstableGhoul.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(VioletTeacher.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,3,5);
    list_.add(card);
    map_.put(VioletTeacher.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Voidwalker.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,1,3);
    list_.add(card);
    map_.put(Voidwalker.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(VoodooDoctor.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,2,1);
    list_.add(card);
    map_.put(VoodooDoctor.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(WarGolem.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",7,7,7);
    list_.add(card);
    map_.put(WarGolem.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(WaterElemental.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,3,6);
    list_.add(card);
    map_.put(WaterElemental.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Whirlwind.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,-1,-1);
    list_.add(card);
    map_.put(Whirlwind.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(WildGrowth.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,-1,-1);
    list_.add(card);
    map_.put(WildGrowth.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Windfury.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",2,-1,-1);
    list_.add(card);
    map_.put(Windfury.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(WindfuryHarpy.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",6,4,5);
    list_.add(card);
    map_.put(WindfuryHarpy.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Windspeaker.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4,3,3);
    list_.add(card);
    map_.put(Windspeaker.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Wisp.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",0,1,1);
    list_.add(card);
    map_.put(Wisp.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(Wolfrider.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",3,3,1);
    list_.add(card);
    map_.put(Wolfrider.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(WorgenInfiltrator.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,2,1);
    list_.add(card);
    map_.put(WorgenInfiltrator.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(YoungDragonhawk.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,1,1);
    list_.add(card);
    map_.put(YoungDragonhawk.class,card);
  }
{
    ImplementedCard card=new ImplementedCard(ZombieChow.class,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",1,2,3);
    list_.add(card);
    map_.put(ZombieChow.class,card);
  }
}",0.8581026886907599
112795,"/** 
 * Use the card on the given target Deals 2 damage to a minion.  If the target minion survives, draw a card. 
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override protected HearthTreeNode use_core(int targetPlayerIndex,Minion targetMinion,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1,boolean singleRealizationOnly) throws HSException {
  if (targetMinion instanceof Hero)   return null;
  HearthTreeNode toRet=super.use_core(targetPlayerIndex,targetMinion,boardState,deckPlayer0,deckPlayer1,singleRealizationOnly);
  if (toRet != null) {
    if (targetMinion.getTotalHealth() > 0) {
      if (toRet instanceof CardDrawNode) {
        ((CardDrawNode)toRet).addNumCardsToDraw(1);
      }
 else {
        toRet=new CardDrawNode(toRet,1);
      }
    }
  }
  return toRet;
}","/** 
 * Use the card on the given target Deals 2 damage to a minion.  If the target minion survives, draw a card. 
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override protected HearthTreeNode use_core(int targetPlayerIndex,Minion targetMinion,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1,boolean singleRealizationOnly) throws HSException {
  if (targetMinion instanceof Hero)   return null;
  HearthTreeNode toRet=super.use_core(targetPlayerIndex,targetMinion,boardState,deckPlayer0,deckPlayer1,singleRealizationOnly);
  if (toRet != null && targetMinion.getTotalHealth() > 0) {
    if (toRet instanceof CardDrawNode) {
      ((CardDrawNode)toRet).addNumCardsToDraw(1);
    }
 else {
      toRet=new CardDrawNode(toRet,1);
    }
  }
  return toRet;
}",0.9740932642487048
112796,"/** 
 * Called at the end of a turn
 */
@Override public BoardState endTurn(int thisMinionPlayerIndex,BoardState boardState,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  BoardState tmpState=super.endTurn(thisMinionPlayerIndex,boardState,deckPlayer0,deckPlayer1);
  if (thisMinionPlayerIndex > 0)   return tmpState;
  HearthTreeNode toRet=new HearthTreeNode(tmpState);
  for (  Minion minion : toRet.data_.getMinions_p0()) {
    toRet=minion.takeHeal((byte)2,0,toRet,deckPlayer0,deckPlayer1);
  }
  for (  Minion minion : toRet.data_.getMinions_p1()) {
    toRet=minion.takeHeal((byte)2,1,toRet,deckPlayer0,deckPlayer1);
  }
  if (toRet instanceof CardDrawNode) {
    toRet=((CardDrawNode)toRet).finishAllEffects(deckPlayer0,deckPlayer1);
  }
  return toRet.data_;
}","/** 
 * Called at the end of a turn At the end of your turn, restore 1 Health to all friendly minions
 */
@Override public BoardState endTurn(int thisMinionPlayerIndex,BoardState boardState,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  BoardState tmpState=super.endTurn(thisMinionPlayerIndex,boardState,deckPlayer0,deckPlayer1);
  if (thisMinionPlayerIndex > 0)   return tmpState;
  HearthTreeNode toRet=new HearthTreeNode(tmpState);
  for (  Minion minion : toRet.data_.getMinions_p0()) {
    toRet=minion.takeHeal((byte)1,0,toRet,deckPlayer0,deckPlayer1);
  }
  if (toRet instanceof CardDrawNode) {
    toRet=((CardDrawNode)toRet).finishAllEffects(deckPlayer0,deckPlayer1);
  }
  return toRet.data_;
}",0.868632707774799
112797,"/** 
 * Use the hero ability on a given target Warlock: place random totem on the board
 * @param targetPlayerIndex The player index of the target character
 * @param targetMinion The target minion
 * @param boardState
 * @param deckPlayer0
 * @param deckPlayer1
 * @return
 */
@Override public HearthTreeNode useHeroAbility_core(int targetPlayerIndex,Minion targetMinion,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1,boolean singleRealizationOnly) throws HSException {
  if (targetPlayerIndex != 0 || !(targetMinion instanceof Hero))   return null;
  int numMinions=boardState.data_.getNumMinions(targetPlayerIndex);
  if (numMinions >= 7) {
    return null;
  }
  if (singleRealizationOnly) {
    HearthTreeNode toRet=boardState;
    Minion minionToSummon=null;
    Minion[] allTotems={new SearingTotem(),new StoneclawTotem(),new HealingTotem(),new WrathOfAirTotem()};
    for (int i=allTotems.length - 1; i > 0; --i) {
      int j=(int)(Math.random() * (i + 1));
      Minion ci=allTotems[i];
      allTotems[i]=allTotems[j];
      allTotems[j]=ci;
    }
    for (int index=0; index < 4; ++index) {
      boolean totemAlreadySummoned=false;
      for (      Minion minion : toRet.data_.getMinions(targetPlayerIndex)) {
        if (minion.getClass().equals(allTotems[index].getClass())) {
          totemAlreadySummoned=true;
        }
      }
      if (!totemAlreadySummoned) {
        minionToSummon=allTotems[index];
        break;
      }
    }
    if (minionToSummon == null)     return null;
    this.hasBeenUsed_=true;
    toRet.data_.setMana_p0(toRet.data_.getMana_p0() - HERO_ABILITY_COST);
    Minion summonTarget=toRet.data_.getCharacter(targetPlayerIndex,numMinions);
    toRet=minionToSummon.summonMinion(targetPlayerIndex,summonTarget,toRet,deckPlayer0,deckPlayer1,false);
    return toRet;
  }
  HearthTreeNode toRet=new RandomEffectNode(boardState,new HearthAction(HearthAction.Verb.HERO_ABILITY,0,0,targetPlayerIndex,0));
  if (toRet != null) {
    this.hasBeenUsed_=true;
    Minion[] minions={new SearingTotem(),new StoneclawTotem(),new HealingTotem(),new WrathOfAirTotem()};
    boolean allTotemsNotSummonable=true;
    for (    Minion minionToSummon : minions) {
      boolean totemAlreadySummoned=false;
      for (      Minion minion : toRet.data_.getMinions(targetPlayerIndex)) {
        if (minion.getClass().equals(minionToSummon.getClass())) {
          totemAlreadySummoned=true;
        }
 else {
          allTotemsNotSummonable=false;
        }
      }
      if (allTotemsNotSummonable)       return null;
      if (!totemAlreadySummoned) {
        HearthTreeNode newState=toRet.addChild(new HearthTreeNode((BoardState)toRet.data_.deepCopy()));
        Minion summonTarget=newState.data_.getCharacter(targetPlayerIndex,numMinions);
        newState.data_.setMana_p0(newState.data_.getMana_p0() - HERO_ABILITY_COST);
        newState=minionToSummon.summonMinion(targetPlayerIndex,summonTarget,newState,deckPlayer0,deckPlayer1,false);
      }
    }
  }
  return toRet;
}","/** 
 * Use the hero ability on a given target Warlock: place random totem on the board
 * @param targetPlayerIndex The player index of the target character
 * @param targetMinion The target minion
 * @param boardState
 * @param deckPlayer0
 * @param deckPlayer1
 * @return
 */
@Override public HearthTreeNode useHeroAbility_core(int targetPlayerIndex,Minion targetMinion,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1,boolean singleRealizationOnly) throws HSException {
  if (targetPlayerIndex != 0 || !(targetMinion instanceof Hero))   return null;
  int numMinions=boardState.data_.getNumMinions(targetPlayerIndex);
  if (numMinions >= 7) {
    return null;
  }
  if (singleRealizationOnly) {
    HearthTreeNode toRet=boardState;
    Minion minionToSummon=null;
    Minion[] allTotems={new SearingTotem(),new StoneclawTotem(),new HealingTotem(),new WrathOfAirTotem()};
    for (int i=allTotems.length - 1; i > 0; --i) {
      int j=(int)(Math.random() * (i + 1));
      Minion ci=allTotems[i];
      allTotems[i]=allTotems[j];
      allTotems[j]=ci;
    }
    for (int index=0; index < 4; ++index) {
      boolean totemAlreadySummoned=false;
      for (      Minion minion : toRet.data_.getMinions(targetPlayerIndex)) {
        if (minion.getClass().equals(allTotems[index].getClass())) {
          totemAlreadySummoned=true;
        }
      }
      if (!totemAlreadySummoned) {
        minionToSummon=allTotems[index];
        break;
      }
    }
    if (minionToSummon == null)     return null;
    this.hasBeenUsed_=true;
    toRet.data_.setMana_p0(toRet.data_.getMana_p0() - HERO_ABILITY_COST);
    Minion summonTarget=toRet.data_.getCharacter(targetPlayerIndex,numMinions);
    toRet=minionToSummon.summonMinion(targetPlayerIndex,summonTarget,toRet,deckPlayer0,deckPlayer1,false);
    return toRet;
  }
  HearthTreeNode toRet=new RandomEffectNode(boardState,new HearthAction(HearthAction.Verb.HERO_ABILITY,0,0,targetPlayerIndex,0));
  if (toRet != null) {
    Minion[] totems={new SearingTotem(),new StoneclawTotem(),new HealingTotem(),new WrathOfAirTotem()};
    boolean allTotemsNotSummonable=true;
    for (    Minion totemToSummon : totems) {
      boolean totemAlreadySummoned=false;
      for (      Minion minion : toRet.data_.getMinions(targetPlayerIndex)) {
        if (minion.getClass().equals(totemToSummon.getClass())) {
          totemAlreadySummoned=true;
          break;
        }
      }
      if (!totemAlreadySummoned) {
        allTotemsNotSummonable=false;
        HearthTreeNode newState=toRet.addChild(new HearthTreeNode((BoardState)toRet.data_.deepCopy()));
        Minion summonTarget=newState.data_.getCharacter(targetPlayerIndex,numMinions);
        newState.data_.setMana_p0(newState.data_.getMana_p0() - HERO_ABILITY_COST);
        newState.data_.getHero_p0().hasBeenUsed(true);
        newState=totemToSummon.summonMinion(targetPlayerIndex,summonTarget,newState,deckPlayer0,deckPlayer1,false);
      }
    }
    if (allTotemsNotSummonable)     return null;
  }
  return toRet;
}",0.9412737799834574
112798,"/** 
 * Use the hero ability on a given target Warlock: draw a card and take 2 damage
 * @param targetPlayerIndex The player index of the target character
 * @param targetMinion The target minion
 * @param boardState
 * @param deckPlayer0
 * @param deckPlayer1
 * @return
 */
@Override public HearthTreeNode useHeroAbility_core(int targetPlayerIndex,Minion targetMinion,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  if (targetPlayerIndex != 0 || !(targetMinion instanceof Hero))   return null;
  HearthTreeNode toRet=targetMinion.takeDamage((byte)2,0,0,boardState,deckPlayer0,deckPlayer1,false,false);
  if (toRet != null) {
    toRet=new CardDrawNode(toRet,1);
  }
  return toRet;
}","/** 
 * Use the hero ability on a given target Warlock: draw a card and take 2 damage
 * @param targetPlayerIndex The player index of the target character
 * @param targetMinion The target minion
 * @param boardState
 * @param deckPlayer0
 * @param deckPlayer1
 * @return
 */
@Override public HearthTreeNode useHeroAbility_core(int targetPlayerIndex,Minion targetMinion,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  if (targetPlayerIndex != 0 || !(targetMinion instanceof Hero))   return null;
  HearthTreeNode toRet=targetMinion.takeDamage((byte)2,0,0,boardState,deckPlayer0,deckPlayer1,false,false);
  if (toRet != null) {
    if (toRet instanceof CardDrawNode) {
      ((CardDrawNode)toRet).addNumCardsToDraw(1);
    }
 else {
      toRet=new CardDrawNode(toRet,1);
    }
  }
  return toRet;
}",0.919614147909968
112799,"public double cardDrawScore(Deck deck,ArtificialPlayer ai){
  int numCardsInDeck=deck.getNumCards();
  int numCardsRemaining=numCardsInDeck - data_.getDeckPos_p0();
  int numCardsToActuallyDraw=numCardsToDraw_;
  int totalFatigueDamage=0;
  if (numCardsRemaining < numCardsToDraw_) {
    int fatigueDamage=data_.getFatigueDamage_p0();
    for (int i=0; i < numCardsToDraw_ - numCardsRemaining; ++i) {
      totalFatigueDamage+=fatigueDamage;
      fatigueDamage+=1;
    }
    numCardsToActuallyDraw=numCardsRemaining;
  }
  double averageCardScore=0.0;
  for (int indx=data_.getDeckPos_p0(); indx < numCardsInDeck; ++indx) {
    averageCardScore+=ai.cardInHandScore(deck.drawCard(indx));
  }
  averageCardScore/=numCardsRemaining;
  double toRet=averageCardScore * numCardsToActuallyDraw;
  int heroHealth=data_.getHero_p0().getHealth();
  int heroArmor=data_.getHero_p0().getArmor();
  int armorLeft=heroArmor > totalFatigueDamage ? heroArmor - totalFatigueDamage : 0;
  int healthLeft=armorLeft > 0 ? heroHealth : heroHealth - (totalFatigueDamage - heroArmor);
  toRet+=ai.heroHealthScore_p0(healthLeft,armorLeft) - ai.heroHealthScore_p0(heroHealth,heroArmor);
  double depthPenalty=1.e-4 * depth_;
  toRet-=depthPenalty;
  return toRet;
}","public double cardDrawScore(Deck deck,ArtificialPlayer ai){
  int numCardsInDeck=deck.getNumCards();
  int numCardsRemaining=numCardsInDeck - data_.getDeckPos_p0();
  int numCardsToActuallyDraw=numCardsToDraw_;
  int totalFatigueDamage=0;
  if (numCardsRemaining < numCardsToDraw_) {
    int fatigueDamage=data_.getFatigueDamage_p0();
    for (int i=0; i < numCardsToDraw_ - numCardsRemaining; ++i) {
      totalFatigueDamage+=fatigueDamage;
      fatigueDamage+=1;
    }
    numCardsToActuallyDraw=numCardsRemaining;
  }
  double averageCardScore=0.0;
  for (int indx=data_.getDeckPos_p0(); indx < numCardsInDeck; ++indx) {
    averageCardScore+=ai.cardInHandScore(deck.drawCard(indx));
  }
  averageCardScore=numCardsRemaining <= 0 ? 0.0 : averageCardScore / numCardsRemaining;
  double toRet=averageCardScore * numCardsToActuallyDraw;
  int heroHealth=data_.getHero_p0().getHealth();
  int heroArmor=data_.getHero_p0().getArmor();
  int armorLeft=heroArmor > totalFatigueDamage ? heroArmor - totalFatigueDamage : 0;
  int healthLeft=armorLeft > 0 ? heroHealth : heroHealth - (totalFatigueDamage - heroArmor);
  toRet+=ai.heroHealthScore_p0(healthLeft,armorLeft) - ai.heroHealthScore_p0(heroHealth,heroArmor);
  double depthPenalty=1.e-4 * depth_;
  toRet-=depthPenalty;
  return toRet;
}",0.9798498617147372
112800,"@Before public void setup(){
  board=new HearthTreeNode(new BoardState(new Warlock(),new Hero()));
  Minion minion0_0=new BoulderfistOgre();
  Minion minion0_1=new RaidLeader();
  Minion minion1_0=new BoulderfistOgre();
  Minion minion1_1=new RaidLeader();
  board.data_.placeCard_hand_p0(minion0_0);
  board.data_.placeCard_hand_p0(minion0_1);
  board.data_.placeCard_hand_p1(minion1_0);
  board.data_.placeCard_hand_p1(minion1_1);
  Card cards[]=new Card[10];
  for (int index=0; index < 10; ++index) {
    cards[index]=new TheCoin();
  }
  deck=new Deck(cards);
  Card fb=new WildGrowth();
  board.data_.placeCard_hand_p0(fb);
  board.data_.setMana_p0((byte)8);
  board.data_.setMana_p1((byte)8);
  board.data_.setMaxMana_p0((byte)8);
  board.data_.setMaxMana_p1((byte)8);
  HearthTreeNode tmpBoard=new HearthTreeNode(board.data_.flipPlayers());
  try {
    tmpBoard.data_.getCard_hand_p0(0).useOn(0,tmpBoard.data_.getHero_p0(),tmpBoard,deck,null);
    tmpBoard.data_.getCard_hand_p0(0).useOn(0,tmpBoard.data_.getHero_p0(),tmpBoard,deck,null);
  }
 catch (  HSException e) {
    e.printStackTrace();
  }
  board=new HearthTreeNode(tmpBoard.data_.flipPlayers());
  try {
    board.data_.getCard_hand_p0(0).useOn(0,board.data_.getHero_p0(),board,deck,null);
    board.data_.getCard_hand_p0(0).useOn(0,board.data_.getHero_p0(),board,deck,null);
  }
 catch (  HSException e) {
    e.printStackTrace();
  }
  board.data_.resetMana();
  board.data_.resetMinions();
}","@Before public void setup(){
  board=new HearthTreeNode(new BoardState(new Warlock(),new Hero()));
  Minion minion0_0=new BoulderfistOgre();
  Minion minion0_1=new RaidLeader();
  Minion minion1_0=new BoulderfistOgre();
  Minion minion1_1=new RaidLeader();
  board.data_.placeCard_hand_p0(minion0_0);
  board.data_.placeCard_hand_p0(minion0_1);
  board.data_.placeCard_hand_p1(minion1_0);
  board.data_.placeCard_hand_p1(minion1_1);
  Card cards[]=new Card[30];
  for (int index=0; index < 30; ++index) {
    cards[index]=new TheCoin();
  }
  deck=new Deck(cards);
  Card fb=new WildGrowth();
  board.data_.placeCard_hand_p0(fb);
  board.data_.setMana_p0((byte)8);
  board.data_.setMana_p1((byte)8);
  board.data_.setMaxMana_p0((byte)8);
  board.data_.setMaxMana_p1((byte)8);
  HearthTreeNode tmpBoard=new HearthTreeNode(board.data_.flipPlayers());
  try {
    tmpBoard.data_.getCard_hand_p0(0).useOn(0,tmpBoard.data_.getHero_p0(),tmpBoard,deck,null);
    tmpBoard.data_.getCard_hand_p0(0).useOn(0,tmpBoard.data_.getHero_p0(),tmpBoard,deck,null);
  }
 catch (  HSException e) {
    e.printStackTrace();
  }
  board=new HearthTreeNode(tmpBoard.data_.flipPlayers());
  try {
    board.data_.getCard_hand_p0(0).useOn(0,board.data_.getHero_p0(),board,deck,null);
    board.data_.getCard_hand_p0(0).useOn(0,board.data_.getHero_p0(),board,deck,null);
  }
 catch (  HSException e) {
    e.printStackTrace();
  }
  board.data_.resetMana();
  board.data_.resetMinions();
}",0.9986329460013672
112801,"/** 
 * Use the hero ability on a given target Warlock: place random totem on the board
 * @param targetPlayerIndex The player index of the target character
 * @param targetMinion The target minion
 * @param boardState
 * @param deckPlayer0
 * @param deckPlayer1
 * @return
 */
@Override public HearthTreeNode useHeroAbility_core(int targetPlayerIndex,Minion targetMinion,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1,boolean singleRealizationOnly) throws HSException {
  if (targetPlayerIndex != 0 || !(targetMinion instanceof Hero))   return null;
  if (singleRealizationOnly) {
    HearthTreeNode toRet=boardState;
    int numMinions=toRet.data_.getNumMinions(targetPlayerIndex);
    if (numMinions < 7) {
      Minion minionToSummon=null;
      Minion[] allTotems={new SearingTotem(),new StoneclawTotem(),new HealingTotem(),new WrathOfAirTotem()};
      for (int i=allTotems.length - 1; i > 0; --i) {
        int j=(int)(Math.random() * (i + 1));
        Minion ci=allTotems[i];
        allTotems[i]=allTotems[j];
        allTotems[j]=ci;
      }
      for (int index=0; index < 4; ++index) {
        boolean totemAlreadySummoned=false;
        for (        Minion minion : toRet.data_.getMinions(targetPlayerIndex)) {
          if (minion.getClass().equals(allTotems[index].getClass())) {
            totemAlreadySummoned=true;
          }
        }
        if (!totemAlreadySummoned) {
          minionToSummon=allTotems[index];
          break;
        }
      }
      if (minionToSummon == null)       return null;
      this.hasBeenUsed_=true;
      toRet.data_.setMana_p0(toRet.data_.getMana_p0() - HERO_ABILITY_COST);
      Minion summonTarget=toRet.data_.getCharacter(targetPlayerIndex,numMinions);
      toRet=minionToSummon.summonMinion(targetPlayerIndex,summonTarget,toRet,deckPlayer0,deckPlayer1,false);
      return toRet;
    }
 else {
      return null;
    }
  }
  HearthTreeNode toRet=new RandomEffectNode(boardState,new HearthAction(HearthAction.Verb.HERO_ABILITY,0,0,targetPlayerIndex,0));
  if (toRet != null) {
    this.hasBeenUsed_=true;
    int numMinions=toRet.data_.getNumMinions(targetPlayerIndex);
    if (numMinions < 7) {
      Minion[] minions={new SearingTotem(),new StoneclawTotem(),new HealingTotem(),new WrathOfAirTotem()};
      for (      Minion minionToSummon : minions) {
        boolean totemAlreadySummoned=false;
        for (        Minion minion : toRet.data_.getMinions(targetPlayerIndex)) {
          if (minion.getClass().equals(minionToSummon.getClass())) {
            totemAlreadySummoned=true;
          }
        }
        if (!totemAlreadySummoned) {
          HearthTreeNode newState=toRet.addChild(new HearthTreeNode((BoardState)toRet.data_.deepCopy()));
          Minion summonTarget=newState.data_.getCharacter(targetPlayerIndex,numMinions);
          newState.data_.setMana_p0(newState.data_.getMana_p0() - HERO_ABILITY_COST);
          newState=minionToSummon.summonMinion(targetPlayerIndex,summonTarget,newState,deckPlayer0,deckPlayer1,false);
        }
      }
    }
  }
  return toRet;
}","/** 
 * Use the hero ability on a given target Warlock: place random totem on the board
 * @param targetPlayerIndex The player index of the target character
 * @param targetMinion The target minion
 * @param boardState
 * @param deckPlayer0
 * @param deckPlayer1
 * @return
 */
@Override public HearthTreeNode useHeroAbility_core(int targetPlayerIndex,Minion targetMinion,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1,boolean singleRealizationOnly) throws HSException {
  if (targetPlayerIndex != 0 || !(targetMinion instanceof Hero))   return null;
  int numMinions=boardState.data_.getNumMinions(targetPlayerIndex);
  if (numMinions >= 7) {
    return null;
  }
  if (singleRealizationOnly) {
    HearthTreeNode toRet=boardState;
    Minion minionToSummon=null;
    Minion[] allTotems={new SearingTotem(),new StoneclawTotem(),new HealingTotem(),new WrathOfAirTotem()};
    for (int i=allTotems.length - 1; i > 0; --i) {
      int j=(int)(Math.random() * (i + 1));
      Minion ci=allTotems[i];
      allTotems[i]=allTotems[j];
      allTotems[j]=ci;
    }
    for (int index=0; index < 4; ++index) {
      boolean totemAlreadySummoned=false;
      for (      Minion minion : toRet.data_.getMinions(targetPlayerIndex)) {
        if (minion.getClass().equals(allTotems[index].getClass())) {
          totemAlreadySummoned=true;
        }
      }
      if (!totemAlreadySummoned) {
        minionToSummon=allTotems[index];
        break;
      }
    }
    if (minionToSummon == null)     return null;
    this.hasBeenUsed_=true;
    toRet.data_.setMana_p0(toRet.data_.getMana_p0() - HERO_ABILITY_COST);
    Minion summonTarget=toRet.data_.getCharacter(targetPlayerIndex,numMinions);
    toRet=minionToSummon.summonMinion(targetPlayerIndex,summonTarget,toRet,deckPlayer0,deckPlayer1,false);
    return toRet;
  }
  HearthTreeNode toRet=new RandomEffectNode(boardState,new HearthAction(HearthAction.Verb.HERO_ABILITY,0,0,targetPlayerIndex,0));
  if (toRet != null) {
    this.hasBeenUsed_=true;
    Minion[] minions={new SearingTotem(),new StoneclawTotem(),new HealingTotem(),new WrathOfAirTotem()};
    for (    Minion minionToSummon : minions) {
      boolean totemAlreadySummoned=false;
      for (      Minion minion : toRet.data_.getMinions(targetPlayerIndex)) {
        if (minion.getClass().equals(minionToSummon.getClass())) {
          totemAlreadySummoned=true;
        }
      }
      if (!totemAlreadySummoned) {
        HearthTreeNode newState=toRet.addChild(new HearthTreeNode((BoardState)toRet.data_.deepCopy()));
        Minion summonTarget=newState.data_.getCharacter(targetPlayerIndex,numMinions);
        newState.data_.setMana_p0(newState.data_.getMana_p0() - HERO_ABILITY_COST);
        newState=minionToSummon.summonMinion(targetPlayerIndex,summonTarget,newState,deckPlayer0,deckPlayer1,false);
      }
    }
  }
  return toRet;
}",0.9030190588632148
112802,"/** 
 * Use the hero ability on a given target Warlock: place random totem on the board
 * @param targetPlayerIndex The player index of the target character
 * @param targetMinion The target minion
 * @param boardState
 * @param deckPlayer0
 * @param deckPlayer1
 * @return
 */
@Override public HearthTreeNode useHeroAbility_core(int targetPlayerIndex,Minion targetMinion,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1,boolean singleRealizationOnly) throws HSException {
  if (targetPlayerIndex != 0 || !(targetMinion instanceof Hero))   return null;
  int numMinions=boardState.data_.getNumMinions(targetPlayerIndex);
  if (numMinions >= 7) {
    return null;
  }
  if (singleRealizationOnly) {
    HearthTreeNode toRet=boardState;
    Minion minionToSummon=null;
    Minion[] allTotems={new SearingTotem(),new StoneclawTotem(),new HealingTotem(),new WrathOfAirTotem()};
    for (int i=allTotems.length - 1; i > 0; --i) {
      int j=(int)(Math.random() * (i + 1));
      Minion ci=allTotems[i];
      allTotems[i]=allTotems[j];
      allTotems[j]=ci;
    }
    for (int index=0; index < 4; ++index) {
      boolean totemAlreadySummoned=false;
      for (      Minion minion : toRet.data_.getMinions(targetPlayerIndex)) {
        if (minion.getClass().equals(allTotems[index].getClass())) {
          totemAlreadySummoned=true;
        }
      }
      if (!totemAlreadySummoned) {
        minionToSummon=allTotems[index];
        break;
      }
    }
    if (minionToSummon == null)     return null;
    this.hasBeenUsed_=true;
    toRet.data_.setMana_p0(toRet.data_.getMana_p0() - HERO_ABILITY_COST);
    Minion summonTarget=toRet.data_.getCharacter(targetPlayerIndex,numMinions);
    toRet=minionToSummon.summonMinion(targetPlayerIndex,summonTarget,toRet,deckPlayer0,deckPlayer1,false);
    return toRet;
  }
  HearthTreeNode toRet=new RandomEffectNode(boardState,new HearthAction(HearthAction.Verb.HERO_ABILITY,0,0,targetPlayerIndex,0));
  if (toRet != null) {
    this.hasBeenUsed_=true;
    Minion[] minions={new SearingTotem(),new StoneclawTotem(),new HealingTotem(),new WrathOfAirTotem()};
    for (    Minion minionToSummon : minions) {
      boolean totemAlreadySummoned=false;
      for (      Minion minion : toRet.data_.getMinions(targetPlayerIndex)) {
        if (minion.getClass().equals(minionToSummon.getClass())) {
          totemAlreadySummoned=true;
        }
      }
      if (!totemAlreadySummoned) {
        HearthTreeNode newState=toRet.addChild(new HearthTreeNode((BoardState)toRet.data_.deepCopy()));
        Minion summonTarget=newState.data_.getCharacter(targetPlayerIndex,numMinions);
        newState.data_.setMana_p0(newState.data_.getMana_p0() - HERO_ABILITY_COST);
        newState=minionToSummon.summonMinion(targetPlayerIndex,summonTarget,newState,deckPlayer0,deckPlayer1,false);
      }
    }
  }
  return toRet;
}","/** 
 * Use the hero ability on a given target Warlock: place random totem on the board
 * @param targetPlayerIndex The player index of the target character
 * @param targetMinion The target minion
 * @param boardState
 * @param deckPlayer0
 * @param deckPlayer1
 * @return
 */
@Override public HearthTreeNode useHeroAbility_core(int targetPlayerIndex,Minion targetMinion,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1,boolean singleRealizationOnly) throws HSException {
  if (targetPlayerIndex != 0 || !(targetMinion instanceof Hero))   return null;
  int numMinions=boardState.data_.getNumMinions(targetPlayerIndex);
  if (numMinions >= 7) {
    return null;
  }
  if (singleRealizationOnly) {
    HearthTreeNode toRet=boardState;
    Minion minionToSummon=null;
    Minion[] allTotems={new SearingTotem(),new StoneclawTotem(),new HealingTotem(),new WrathOfAirTotem()};
    for (int i=allTotems.length - 1; i > 0; --i) {
      int j=(int)(Math.random() * (i + 1));
      Minion ci=allTotems[i];
      allTotems[i]=allTotems[j];
      allTotems[j]=ci;
    }
    for (int index=0; index < 4; ++index) {
      boolean totemAlreadySummoned=false;
      for (      Minion minion : toRet.data_.getMinions(targetPlayerIndex)) {
        if (minion.getClass().equals(allTotems[index].getClass())) {
          totemAlreadySummoned=true;
        }
      }
      if (!totemAlreadySummoned) {
        minionToSummon=allTotems[index];
        break;
      }
    }
    if (minionToSummon == null)     return null;
    this.hasBeenUsed_=true;
    toRet.data_.setMana_p0(toRet.data_.getMana_p0() - HERO_ABILITY_COST);
    Minion summonTarget=toRet.data_.getCharacter(targetPlayerIndex,numMinions);
    toRet=minionToSummon.summonMinion(targetPlayerIndex,summonTarget,toRet,deckPlayer0,deckPlayer1,false);
    return toRet;
  }
  HearthTreeNode toRet=new RandomEffectNode(boardState,new HearthAction(HearthAction.Verb.HERO_ABILITY,0,0,targetPlayerIndex,0));
  if (toRet != null) {
    this.hasBeenUsed_=true;
    Minion[] minions={new SearingTotem(),new StoneclawTotem(),new HealingTotem(),new WrathOfAirTotem()};
    boolean allTotemsNotSummonable=true;
    for (    Minion minionToSummon : minions) {
      boolean totemAlreadySummoned=false;
      for (      Minion minion : toRet.data_.getMinions(targetPlayerIndex)) {
        if (minion.getClass().equals(minionToSummon.getClass())) {
          totemAlreadySummoned=true;
        }
 else {
          allTotemsNotSummonable=false;
        }
      }
      if (allTotemsNotSummonable)       return null;
      if (!totemAlreadySummoned) {
        HearthTreeNode newState=toRet.addChild(new HearthTreeNode((BoardState)toRet.data_.deepCopy()));
        Minion summonTarget=newState.data_.getCharacter(targetPlayerIndex,numMinions);
        newState.data_.setMana_p0(newState.data_.getMana_p0() - HERO_ABILITY_COST);
        newState=minionToSummon.summonMinion(targetPlayerIndex,summonTarget,newState,deckPlayer0,deckPlayer1,false);
      }
    }
  }
  return toRet;
}",0.9741408642395372
112803,"/** 
 * Use the card on the given target
 * @param targetPlayerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param targetMinion The target minion (can be a Hero)
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
public HearthTreeNode useOn(int targetPlayerIndex,Minion targetMinion,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  HearthTreeNode toRet=this.use_core(targetPlayerIndex,targetMinion,boardState,deckPlayer0,deckPlayer1);
  if (toRet != null) {
    for (Iterator<Card> iter=toRet.data_.getCards_hand_p0().iterator(); iter.hasNext(); ) {
      toRet=(iter.next()).otherCardUsedEvent(toRet,deckPlayer0,deckPlayer1);
    }
    toRet=toRet.data_.getHero_p0().otherCardUsedEvent(toRet,deckPlayer0,deckPlayer1);
    for (Iterator<Minion> iter=toRet.data_.getMinions_p0().iterator(); iter.hasNext(); ) {
      Minion minion=iter.next();
      if (!minion.isSilenced())       toRet=minion.otherCardUsedEvent(toRet,deckPlayer0,deckPlayer1);
    }
    toRet=toRet.data_.getHero_p1().otherCardUsedEvent(toRet,deckPlayer0,deckPlayer1);
    for (Iterator<Minion> iter=toRet.data_.getMinions_p1().iterator(); iter.hasNext(); ) {
      Minion minion=iter.next();
      if (!minion.isSilenced())       toRet=minion.otherCardUsedEvent(toRet,deckPlayer0,deckPlayer1);
    }
    Iterator<Minion> iter0=toRet.data_.getMinions_p0().iterator();
    while (iter0.hasNext()) {
      Minion tMinion=iter0.next();
      if (tMinion.getHealth() <= 0) {
        toRet=tMinion.destroyed(0,toRet,deckPlayer0,deckPlayer1);
        iter0.remove();
        toRet.data_.getMinions_p0().remove(tMinion);
      }
    }
    Iterator<Minion> iter1=toRet.data_.getMinions_p1().iterator();
    while (iter1.hasNext()) {
      Minion tMinion=iter1.next();
      if (tMinion.getHealth() <= 0) {
        toRet=tMinion.destroyed(1,toRet,deckPlayer0,deckPlayer1);
        iter1.remove();
        toRet.data_.getMinions_p1().remove(tMinion);
      }
    }
  }
  return toRet;
}","/** 
 * Use the card on the given target
 * @param targetPlayerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param targetMinion The target minion (can be a Hero)
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
public HearthTreeNode useOn(int targetPlayerIndex,Minion targetMinion,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  HearthTreeNode toRet=this.use_core(targetPlayerIndex,targetMinion,boardState,deckPlayer0,deckPlayer1);
  if (toRet != null) {
    for (Iterator<Card> iter=toRet.data_.getCards_hand_p0().iterator(); iter.hasNext(); ) {
      toRet=(iter.next()).otherCardUsedEvent(toRet,deckPlayer0,deckPlayer1);
    }
    toRet=toRet.data_.getHero_p0().otherCardUsedEvent(toRet,deckPlayer0,deckPlayer1);
    for (Iterator<Minion> iter=toRet.data_.getMinions_p0().iterator(); iter.hasNext(); ) {
      Minion minion=iter.next();
      if (!minion.isSilenced())       toRet=minion.otherCardUsedEvent(toRet,deckPlayer0,deckPlayer1);
    }
    toRet=toRet.data_.getHero_p1().otherCardUsedEvent(toRet,deckPlayer0,deckPlayer1);
    for (Iterator<Minion> iter=toRet.data_.getMinions_p1().iterator(); iter.hasNext(); ) {
      Minion minion=iter.next();
      if (!minion.isSilenced())       toRet=minion.otherCardUsedEvent(toRet,deckPlayer0,deckPlayer1);
    }
    Iterator<Minion> iter0=toRet.data_.getMinions_p0().iterator();
    ArrayList<Minion> listOfMinionsToCheck0=new ArrayList<Minion>(toRet.data_.getNumMinions_p0());
    while (iter0.hasNext()) {
      listOfMinionsToCheck0.add(iter0.next());
    }
    for (    Minion tMinion : listOfMinionsToCheck0) {
      if (tMinion.getHealth() <= 0) {
        toRet=tMinion.destroyed(0,toRet,deckPlayer0,deckPlayer1);
        toRet.data_.getMinions_p0().remove(tMinion);
      }
    }
    Iterator<Minion> iter1=toRet.data_.getMinions_p1().iterator();
    ArrayList<Minion> listOfMinionsToCheck1=new ArrayList<Minion>(toRet.data_.getNumMinions_p1());
    while (iter1.hasNext()) {
      listOfMinionsToCheck1.add(iter1.next());
    }
    for (    Minion tMinion : listOfMinionsToCheck1) {
      if (tMinion.getHealth() <= 0) {
        toRet=tMinion.destroyed(1,toRet,deckPlayer0,deckPlayer1);
        toRet.data_.getMinions_p1().remove(tMinion);
      }
    }
  }
  return toRet;
}",0.7558239861949957
112804,"/** 
 * Places a minion on the board via a summon effect This function is meant to be used when summoning minions through means other than a direct card usage.
 * @param targetPlayerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param targetMinion The target minion (can be a Hero).  The new minion is always placed to the right of (higher index) the target minion.  If the target minion is a hero, then it is placed at the left-most position.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @param deckPlayer0 The deck of player0
 * @param deckPlayer0 The deck of player1
 * @return The boardState is manipulated and returned
 * @throws HSException 
 */
protected HearthTreeNode summonMinion_core(int targetPlayerIndex,Minion targetMinion,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  if (boardState.data_.getNumMinions_p0() < 7) {
    if (!charge_) {
      hasAttacked_=true;
    }
    hasBeenUsed_=true;
    if (targetMinion instanceof Hero)     boardState.data_.placeMinion(targetPlayerIndex,this,0);
 else     boardState.data_.placeMinion(targetPlayerIndex,this,boardState.data_.getMinions(targetPlayerIndex).indexOf(targetMinion) + 1);
    return boardState;
  }
 else {
    return null;
  }
}","/** 
 * Places a minion on the board via a summon effect This function is meant to be used when summoning minions through means other than a direct card usage.
 * @param targetPlayerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param targetMinion The target minion (can be a Hero).  The new minion is always placed to the right of (higher index) the target minion.  If the target minion is a hero, then it is placed at the left-most position.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @param deckPlayer0 The deck of player0
 * @param deckPlayer0 The deck of player1
 * @return The boardState is manipulated and returned
 * @throws HSException 
 */
protected HearthTreeNode summonMinion_core(int targetPlayerIndex,Minion targetMinion,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  if (boardState.data_.getNumMinions(targetPlayerIndex) < 7) {
    if (!charge_) {
      hasAttacked_=true;
    }
    hasBeenUsed_=true;
    if (targetMinion instanceof Hero)     boardState.data_.placeMinion(targetPlayerIndex,this,0);
 else     boardState.data_.placeMinion(targetPlayerIndex,this,boardState.data_.getMinions(targetPlayerIndex).indexOf(targetMinion) + 1);
    return boardState;
  }
 else {
    return null;
  }
}",0.9927641099855282
112805,"/** 
 * Attack with the minion
 * @param targetMinionPlayerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param targetMinion The target minion
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @param deckPlayer0 The deck of player0
 * @param deckPlayer0 The deck of player1
 * @return The boardState is manipulated and returned
 */
protected HearthTreeNode attack_core(int targetMinionPlayerIndex,Minion targetMinion,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  if (hasAttacked_) {
    return null;
  }
  if (targetMinionPlayerIndex == 0) {
    return null;
  }
  if (attack_ + extraAttackUntilTurnEnd_ <= 0)   return null;
  HearthTreeNode toRet=boardState;
  byte origAttack=targetMinion.attack_;
  toRet=targetMinion.takeDamage((byte)(this.attack_ + this.extraAttackUntilTurnEnd_),0,targetMinionPlayerIndex,toRet,deckPlayer0,deckPlayer1);
  toRet=this.takeDamage(origAttack,targetMinionPlayerIndex,0,toRet,deckPlayer0,deckPlayer1);
  if (!(targetMinion instanceof Hero)) {
    if (targetMinion.getHealth() <= 0) {
      toRet=targetMinion.destroyed(targetMinionPlayerIndex,boardState,deckPlayer0,deckPlayer1);
      toRet.data_.removeMinion_p1(targetMinion);
    }
  }
  if (!(this instanceof Hero)) {
    if (health_ <= 0) {
      toRet=this.destroyed(0,boardState,deckPlayer0,deckPlayer1);
      toRet.data_.removeMinion_p0(this);
    }
  }
  if (windFury_ && !hasWindFuryAttacked_)   hasWindFuryAttacked_=true;
 else   hasAttacked_=true;
  return toRet;
}","/** 
 * Attack with the minion
 * @param targetMinionPlayerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param targetMinion The target minion
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @param deckPlayer0 The deck of player0
 * @param deckPlayer0 The deck of player1
 * @return The boardState is manipulated and returned
 */
protected HearthTreeNode attack_core(int targetMinionPlayerIndex,Minion targetMinion,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  if (hasAttacked_) {
    return null;
  }
  if (targetMinionPlayerIndex == 0) {
    return null;
  }
  if (attack_ + extraAttackUntilTurnEnd_ <= 0)   return null;
  HearthTreeNode toRet=boardState;
  byte origAttack=targetMinion.attack_;
  toRet=targetMinion.takeDamage((byte)(this.attack_ + this.extraAttackUntilTurnEnd_),0,targetMinionPlayerIndex,toRet,deckPlayer0,deckPlayer1);
  toRet=this.takeDamage(origAttack,targetMinionPlayerIndex,0,toRet,deckPlayer0,deckPlayer1);
  if (!(targetMinion instanceof Hero)) {
    if (targetMinion.getHealth() <= 0) {
      toRet=targetMinion.destroyed(targetMinionPlayerIndex,toRet,deckPlayer0,deckPlayer1);
      toRet.data_.removeMinion_p1(targetMinion);
    }
  }
  if (!(this instanceof Hero)) {
    if (health_ <= 0) {
      toRet=this.destroyed(0,toRet,deckPlayer0,deckPlayer1);
      toRet.data_.removeMinion_p0(this);
    }
  }
  if (windFury_ && !hasWindFuryAttacked_)   hasWindFuryAttacked_=true;
 else   hasAttacked_=true;
  return toRet;
}",0.9908031882280808
112806,"@Override public HearthTreeNode performAction(Minion minion,int thisPlayerIndex,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  HearthTreeNode toRet=super.performAction(minion,thisPlayerIndex,boardState,deckPlayer0,deckPlayer1);
  if (toRet != null) {
    toRet=toRet.data_.getHero_p1().takeDamage(damage_,(thisPlayerIndex + 1) % 2,thisPlayerIndex,boardState,deckPlayer0,deckPlayer1);
  }
  return toRet;
}","@Override public HearthTreeNode performAction(Minion minion,int thisPlayerIndex,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  HearthTreeNode toRet=super.performAction(minion,thisPlayerIndex,boardState,deckPlayer0,deckPlayer1);
  if (toRet != null) {
    toRet=toRet.data_.getHero_p1().takeDamage(damage_,(thisPlayerIndex + 1) % 2,thisPlayerIndex,toRet,deckPlayer0,deckPlayer1);
  }
  return toRet;
}",0.9829351535836176
112807,"@Override public HearthTreeNode performAction(Minion minion,int thisPlayerIndex,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  HearthTreeNode toRet=super.performAction(minion,thisPlayerIndex,boardState,deckPlayer0,deckPlayer1);
  for (int index=0; index < numMinions_; ++index) {
    try {
      Minion newMinion=(Minion)minionClass_.newInstance();
      toRet=newMinion.summonMinion(thisPlayerIndex,minion,toRet,deckPlayer0,deckPlayer1,false);
    }
 catch (    InstantiationException|IllegalAccessException e) {
      throw new HSException();
    }
  }
  return toRet;
}","@Override public HearthTreeNode performAction(Minion minion,int thisPlayerIndex,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  HearthTreeNode toRet=super.performAction(minion,thisPlayerIndex,boardState,deckPlayer0,deckPlayer1);
  for (int index=0; index < numMinions_; ++index) {
    try {
      Minion newMinion=(Minion)minionClass_.newInstance();
      Minion placementTarget=toRet.data_.getCharacter(thisPlayerIndex,toRet.data_.getMinions(thisPlayerIndex).indexOf(minion));
      toRet.data_.removeMinion(thisPlayerIndex,minion);
      toRet=newMinion.summonMinion(thisPlayerIndex,placementTarget,toRet,deckPlayer0,deckPlayer1,false);
    }
 catch (    InstantiationException|IllegalAccessException e) {
      throw new HSException();
    }
  }
  return toRet;
}",0.8547129695251595
112808,"public DeathrattleSummonMinionAction(Class minionClass,int numMnions){
  numMinions_=numMnions;
  minionClass_=minionClass;
}","public DeathrattleSummonMinionAction(Class<?> minionClass,int numMnions){
  numMinions_=numMnions;
  minionClass_=minionClass;
}",0.9881422924901184
112809,"/** 
 * Override for battlecry Battlecry: Change an enemy minion's attack to 1
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public HearthTreeNode use_core(int targetPlayerIndex,Minion targetMinion,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  HearthTreeNode toRet=super.use_core(targetPlayerIndex,targetMinion,boardState,deckPlayer0,deckPlayer1);
  if (toRet != null) {
    for (int index=0; index < toRet.data_.getNumMinions_p1(); ++index) {
      if (index != toRet.data_.getMinions_p1().indexOf(this)) {
        HearthTreeNode newState=toRet.addChild(new HearthTreeNode((BoardState)toRet.data_.deepCopy()));
        newState.data_.getMinion_p0(index).setAttack((byte)1);
      }
    }
    return toRet;
  }
 else {
    return null;
  }
}","/** 
 * Override for battlecry Battlecry: Change an enemy minion's attack to 1
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public HearthTreeNode use_core(int targetPlayerIndex,Minion targetMinion,HearthTreeNode boardState,Deck deckPlayer0,Deck deckPlayer1) throws HSException {
  HearthTreeNode toRet=super.use_core(targetPlayerIndex,targetMinion,boardState,deckPlayer0,deckPlayer1);
  if (toRet != null) {
    for (int index=0; index < toRet.data_.getNumMinions_p1(); ++index) {
      if (index != toRet.data_.getMinions_p1().indexOf(this)) {
        HearthTreeNode newState=toRet.addChild(new HearthTreeNode((BoardState)toRet.data_.deepCopy()));
        newState.data_.getMinion_p1(index).setAttack((byte)1);
      }
    }
    return toRet;
  }
 else {
    return null;
  }
}",0.9991423670668954
112810,"@Override public void simulationFinished(){
  btnRun.setBackground(HSColors.SUCCESS_BUTTON_COLOR);
  btnRun.setText(""String_Node_Str"");
}","@Override public void simulationFinished(){
  btnRun.setBackground(HSColors.SUCCESS_BUTTON_COLOR);
  btnRun.setText(""String_Node_Str"");
  isRunning_=false;
}",0.9319727891156464
112811,"/** 
 * Create the application.
 */
public HearthSim(){
  hsModel_=new HSMainFrameModel(this);
  initialize();
  hsModel_.getSimulation().addSimulationEventListener(this);
}","/** 
 * Create the application.
 */
public HearthSim(){
  hsModel_=new HSMainFrameModel(this);
  isRunning_=false;
  initialize();
  hsModel_.getSimulation().addSimulationEventListener(this);
}",0.9453551912568308
112812,"/** 
 * Initialize the contents of the frame.
 */
private void initialize(){
  frame=new JFrame();
  frame.getContentPane().setBackground(HSColors.BACKGROUND_COLOR);
  frame.setBounds(100,100,960,640);
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  SpringLayout springLayout=new SpringLayout();
  frame.getContentPane().setLayout(springLayout);
  JPanel Player0Panel=new JPanel();
  Player0Panel.setBorder(new MatteBorder(0,0,0,1,(Color)Color.GRAY));
  Player0Panel.setOpaque(false);
  Player0Panel.setBackground(Color.DARK_GRAY);
  springLayout.putConstraint(SpringLayout.NORTH,Player0Panel,0,SpringLayout.NORTH,frame.getContentPane());
  springLayout.putConstraint(SpringLayout.WEST,Player0Panel,0,SpringLayout.WEST,frame.getContentPane());
  springLayout.putConstraint(SpringLayout.SOUTH,Player0Panel,0,SpringLayout.SOUTH,frame.getContentPane());
  springLayout.putConstraint(SpringLayout.EAST,Player0Panel,200,SpringLayout.WEST,frame.getContentPane());
  frame.getContentPane().add(Player0Panel);
  SpringLayout sl_Player0Panel=new SpringLayout();
  Player0Panel.setLayout(sl_Player0Panel);
  JPanel HeroPane_0=new JPanel();
  sl_Player0Panel.putConstraint(SpringLayout.SOUTH,HeroPane_0,50,SpringLayout.NORTH,Player0Panel);
  HeroPane_0.setOpaque(false);
  HeroPane_0.setBackground(Color.DARK_GRAY);
  sl_Player0Panel.putConstraint(SpringLayout.NORTH,HeroPane_0,0,SpringLayout.NORTH,Player0Panel);
  sl_Player0Panel.putConstraint(SpringLayout.WEST,HeroPane_0,0,SpringLayout.WEST,Player0Panel);
  sl_Player0Panel.putConstraint(SpringLayout.EAST,HeroPane_0,0,SpringLayout.EAST,Player0Panel);
  springLayout.putConstraint(SpringLayout.NORTH,HeroPane_0,0,SpringLayout.NORTH,Player0Panel);
  springLayout.putConstraint(SpringLayout.WEST,HeroPane_0,0,SpringLayout.WEST,Player0Panel);
  springLayout.putConstraint(SpringLayout.SOUTH,HeroPane_0,50,SpringLayout.NORTH,Player0Panel);
  springLayout.putConstraint(SpringLayout.EAST,HeroPane_0,0,SpringLayout.EAST,Player0Panel);
  Player0Panel.add(HeroPane_0);
  JScrollPane DeckPane_0=new JScrollPane();
  sl_Player0Panel.putConstraint(SpringLayout.WEST,DeckPane_0,5,SpringLayout.WEST,Player0Panel);
  DeckPane_0.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);
  DeckPane_0.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
  DeckPane_0.setOpaque(false);
  DeckPane_0.setBackground(Color.DARK_GRAY);
  DeckPane_0.setLayout(new ScrollPaneLayout());
  DeckPane_0.getViewport().setOpaque(false);
  DeckPane_0.setBorder(BorderFactory.createEmptyBorder());
  sl_Player0Panel.putConstraint(SpringLayout.NORTH,DeckPane_0,0,SpringLayout.SOUTH,HeroPane_0);
  HeroPane_0.setLayout(null);
  lblHero_0=new JLabel(""String_Node_Str"");
  lblHero_0.setHorizontalAlignment(SwingConstants.CENTER);
  lblHero_0.setBounds(0,0,200,50);
  lblHero_0.setFont(new Font(""String_Node_Str"",Font.PLAIN,20));
  lblHero_0.setForeground(Color.WHITE);
  HeroPane_0.add(lblHero_0);
  JButton btnDeckCreate_0=new HSDeckCreateButton();
  btnDeckCreate_0.setBounds(160,18,20,15);
  btnDeckCreate_0.setBackground(HSColors.BACKGROUND_COLOR);
  btnDeckCreate_0.setForeground(Color.WHITE);
  HeroPane_0.add(btnDeckCreate_0);
  sl_Player0Panel.putConstraint(SpringLayout.EAST,DeckPane_0,0,SpringLayout.EAST,Player0Panel);
  Player0Panel.add(DeckPane_0);
  JPanel ControlPane_0=new JPanel();
  sl_Player0Panel.putConstraint(SpringLayout.SOUTH,DeckPane_0,-20,SpringLayout.NORTH,ControlPane_0);
  ControlPane_0.setBackground(Color.DARK_GRAY);
  ControlPane_0.setOpaque(false);
  deckList_0=new HSCardList();
  deckList_0.setForeground(Color.WHITE);
  deckList_0.setBackground(HSColors.BACKGROUND_COLOR);
  deckList_0.setOpaque(false);
  DeckPane_0.setViewportView(deckList_0);
  sl_Player0Panel.putConstraint(SpringLayout.NORTH,ControlPane_0,-40,SpringLayout.SOUTH,Player0Panel);
  sl_Player0Panel.putConstraint(SpringLayout.WEST,ControlPane_0,0,SpringLayout.WEST,Player0Panel);
  sl_Player0Panel.putConstraint(SpringLayout.SOUTH,ControlPane_0,0,SpringLayout.SOUTH,Player0Panel);
  sl_Player0Panel.putConstraint(SpringLayout.EAST,ControlPane_0,0,SpringLayout.EAST,Player0Panel);
  Player0Panel.add(ControlPane_0);
  SpringLayout sl_ControlPane_0=new SpringLayout();
  ControlPane_0.setLayout(sl_ControlPane_0);
  HSButton p0_load=new HSButton(""String_Node_Str"");
  p0_load.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      if (fileChooser_ == null)       fileChooser_=new JFileChooser();
      int retVal=fileChooser_.showOpenDialog(frame);
      if (retVal == JFileChooser.APPROVE_OPTION) {
        try {
          DeckListFile deckList=new DeckListFile(fileChooser_.getSelectedFile().toPath());
          ((SortedListModel)deckList_0.getModel()).clear();
          for (int indx=0; indx < deckList.getDeck().getNumCards(); ++indx) {
            Card card=deckList.getDeck().drawCard(indx);
            ((SortedListModel)deckList_0.getModel()).addElement(IMPLEMENTED_CARD_LIST.getCardForClass(card.getClass()));
          }
          hsModel_.getSimulation().setDeck_p0(deckList.getDeck());
          hsModel_.getSimulation().setHero_p0(deckList.getHero());
          lblHero_0.setText(deckList.getHero().getName());
        }
 catch (        HSInvalidCardException|HSInvalidHeroException|IOException e1) {
          JOptionPane.showMessageDialog(frame,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
        }
      }
    }
  }
);
  p0_load.setForeground(Color.WHITE);
  p0_load.setBackground(HSColors.DEFAULT_BUTTON_COLOR);
  p0_load.setPreferredSize(new Dimension(80,30));
  sl_ControlPane_0.putConstraint(SpringLayout.NORTH,p0_load,5,SpringLayout.NORTH,ControlPane_0);
  sl_ControlPane_0.putConstraint(SpringLayout.WEST,p0_load,5,SpringLayout.WEST,ControlPane_0);
  ControlPane_0.add(p0_load);
  JButton p0_save=new HSButton(""String_Node_Str"");
  p0_save.setForeground(Color.WHITE);
  p0_save.setBackground(HSColors.DISABLED_BUTTON_COLOR);
  sl_ControlPane_0.putConstraint(SpringLayout.EAST,p0_save,-5,SpringLayout.EAST,ControlPane_0);
  p0_save.setPreferredSize(new Dimension(80,30));
  sl_ControlPane_0.putConstraint(SpringLayout.NORTH,p0_save,5,SpringLayout.NORTH,ControlPane_0);
  ControlPane_0.add(p0_save);
  middlePanel=new JPanel();
  middlePanel.setForeground(Color.WHITE);
  middlePanel.setBackground(HSColors.BACKGROUND_COLOR);
  springLayout.putConstraint(SpringLayout.NORTH,ControlPane,-40,SpringLayout.SOUTH,middlePanel);
  springLayout.putConstraint(SpringLayout.WEST,ControlPane,0,SpringLayout.WEST,middlePanel);
  springLayout.putConstraint(SpringLayout.SOUTH,ControlPane,0,SpringLayout.SOUTH,middlePanel);
  springLayout.putConstraint(SpringLayout.EAST,ControlPane,0,SpringLayout.EAST,middlePanel);
  springLayout.putConstraint(SpringLayout.NORTH,middlePanel,0,SpringLayout.NORTH,frame.getContentPane());
  springLayout.putConstraint(SpringLayout.WEST,middlePanel,0,SpringLayout.EAST,Player0Panel);
  springLayout.putConstraint(SpringLayout.SOUTH,middlePanel,0,SpringLayout.SOUTH,frame.getContentPane());
  frame.getContentPane().add(middlePanel);
  SpringLayout sl_middlePanel=new SpringLayout();
  sl_middlePanel.putConstraint(SpringLayout.NORTH,ControlPane,-40,SpringLayout.SOUTH,middlePanel);
  sl_middlePanel.putConstraint(SpringLayout.WEST,ControlPane,0,SpringLayout.WEST,middlePanel);
  sl_middlePanel.putConstraint(SpringLayout.SOUTH,ControlPane,0,SpringLayout.SOUTH,middlePanel);
  sl_middlePanel.putConstraint(SpringLayout.EAST,ControlPane,0,SpringLayout.EAST,middlePanel);
  middlePanel.setLayout(sl_middlePanel);
  JPanel InfoPane=new JPanel();
  sl_middlePanel.putConstraint(SpringLayout.NORTH,InfoPane,0,SpringLayout.NORTH,middlePanel);
  sl_middlePanel.putConstraint(SpringLayout.WEST,InfoPane,0,SpringLayout.WEST,middlePanel);
  sl_middlePanel.putConstraint(SpringLayout.SOUTH,InfoPane,240,SpringLayout.NORTH,middlePanel);
  sl_middlePanel.putConstraint(SpringLayout.EAST,InfoPane,0,SpringLayout.EAST,middlePanel);
  springLayout.putConstraint(SpringLayout.NORTH,InfoPane,0,SpringLayout.NORTH,middlePanel);
  springLayout.putConstraint(SpringLayout.WEST,InfoPane,0,SpringLayout.WEST,middlePanel);
  springLayout.putConstraint(SpringLayout.SOUTH,InfoPane,250,SpringLayout.NORTH,middlePanel);
  springLayout.putConstraint(SpringLayout.EAST,InfoPane,0,SpringLayout.EAST,middlePanel);
  middlePanel.add(InfoPane);
  InfoPane.setOpaque(false);
  SpringLayout sl_InfoPane=new SpringLayout();
  InfoPane.setLayout(sl_InfoPane);
  JPanel Player0Info=new JPanel();
  sl_InfoPane.putConstraint(SpringLayout.WEST,Player0Info,25,SpringLayout.WEST,InfoPane);
  sl_InfoPane.putConstraint(SpringLayout.SOUTH,Player0Info,-5,SpringLayout.SOUTH,InfoPane);
  sl_InfoPane.putConstraint(SpringLayout.EAST,Player0Info,170,SpringLayout.WEST,InfoPane);
  Player0Info.setOpaque(false);
  sl_InfoPane.putConstraint(SpringLayout.NORTH,Player0Info,5,SpringLayout.NORTH,InfoPane);
  InfoPane.add(Player0Info);
  JLabel lblLabel1_0=new JLabel(""String_Node_Str"");
  lblLabel1_0.setFont(new Font(""String_Node_Str"",Font.PLAIN,18));
  lblLabel1_0.setForeground(Color.WHITE);
  Player0Info.add(lblLabel1_0);
  Component rigidArea_2=Box.createRigidArea(new Dimension(20,20));
  rigidArea_2.setPreferredSize(new Dimension(135,10));
  Player0Info.add(rigidArea_2);
  lblWin_0=new JLabel(""String_Node_Str"");
  lblWin_0.setFont(new Font(""String_Node_Str"",Font.PLAIN,24));
  lblWin_0.setHorizontalAlignment(SwingConstants.CENTER);
  lblWin_0.setPreferredSize(new Dimension(135,40));
  lblWin_0.setForeground(Color.WHITE);
  Player0Info.add(lblWin_0);
  Component rigidArea_1=Box.createRigidArea(new Dimension(20,10));
  rigidArea_1.setPreferredSize(new Dimension(135,2));
  Player0Info.add(rigidArea_1);
  lblWinRate_0=new JLabel(""String_Node_Str"");
  lblWinRate_0.setFont(new Font(""String_Node_Str"",Font.PLAIN,24));
  lblWinRate_0.setHorizontalAlignment(SwingConstants.CENTER);
  lblWinRate_0.setHorizontalTextPosition(SwingConstants.CENTER);
  lblWinRate_0.setForeground(Color.WHITE);
  lblWinRate_0.setPreferredSize(new Dimension(135,40));
  Player0Info.add(lblWinRate_0);
  Component rigidArea=Box.createRigidArea(new Dimension(20,20));
  rigidArea.setPreferredSize(new Dimension(135,20));
  Player0Info.add(rigidArea);
  JLabel lblConf_0=new JLabel(""String_Node_Str"");
  lblConf_0.setForeground(Color.WHITE);
  lblConf_0.setFont(new Font(""String_Node_Str"",Font.PLAIN,12));
  Player0Info.add(lblConf_0);
  lblConfNum_0=new JLabel(""String_Node_Str"");
  lblConfNum_0.setHorizontalAlignment(SwingConstants.CENTER);
  lblConfNum_0.setPreferredSize(new Dimension(135,30));
  lblConfNum_0.setFont(new Font(""String_Node_Str"",Font.PLAIN,16));
  lblConfNum_0.setForeground(Color.WHITE);
  Player0Info.add(lblConfNum_0);
  JPanel Player1Info=new JPanel();
  sl_InfoPane.putConstraint(SpringLayout.WEST,Player1Info,-170,SpringLayout.EAST,InfoPane);
  sl_InfoPane.putConstraint(SpringLayout.EAST,Player1Info,-25,SpringLayout.EAST,InfoPane);
  Player1Info.setOpaque(false);
  sl_InfoPane.putConstraint(SpringLayout.NORTH,Player1Info,5,SpringLayout.NORTH,InfoPane);
  sl_InfoPane.putConstraint(SpringLayout.SOUTH,Player1Info,-5,SpringLayout.SOUTH,InfoPane);
  InfoPane.add(Player1Info);
  JLabel lblLabel1_1=new JLabel(""String_Node_Str"");
  lblLabel1_1.setFont(new Font(""String_Node_Str"",Font.PLAIN,18));
  lblLabel1_1.setForeground(Color.WHITE);
  Player1Info.add(lblLabel1_1);
  Component rigidArea_1_0=Box.createRigidArea(new Dimension(20,20));
  rigidArea_1_0.setPreferredSize(new Dimension(135,10));
  Player1Info.add(rigidArea_1_0);
  lblWin_1=new JLabel(""String_Node_Str"");
  lblWin_1.setFont(new Font(""String_Node_Str"",Font.PLAIN,24));
  lblWin_1.setHorizontalAlignment(SwingConstants.CENTER);
  lblWin_1.setPreferredSize(new Dimension(135,40));
  lblWin_1.setForeground(Color.WHITE);
  Player1Info.add(lblWin_1);
  Component rigidArea_1_1=Box.createRigidArea(new Dimension(20,20));
  rigidArea_1_1.setPreferredSize(new Dimension(135,2));
  Player1Info.add(rigidArea_1_1);
  lblWinRate_1=new JLabel(""String_Node_Str"");
  lblWinRate_1.setFont(new Font(""String_Node_Str"",Font.PLAIN,24));
  lblWinRate_1.setHorizontalAlignment(SwingConstants.CENTER);
  lblWinRate_1.setHorizontalTextPosition(SwingConstants.CENTER);
  lblWinRate_1.setForeground(Color.WHITE);
  lblWinRate_1.setPreferredSize(new Dimension(135,40));
  Player1Info.add(lblWinRate_1);
  Component rigidArea_0_2=Box.createRigidArea(new Dimension(20,20));
  rigidArea_0_2.setPreferredSize(new Dimension(135,20));
  Player1Info.add(rigidArea_0_2);
  JLabel lblConf_1=new JLabel(""String_Node_Str"");
  lblConf_1.setForeground(Color.WHITE);
  lblConf_1.setFont(new Font(""String_Node_Str"",Font.PLAIN,12));
  Player1Info.add(lblConf_1);
  lblConfNum_1=new JLabel(""String_Node_Str"");
  lblConfNum_1.setHorizontalAlignment(SwingConstants.CENTER);
  lblConfNum_1.setPreferredSize(new Dimension(135,30));
  lblConfNum_1.setFont(new Font(""String_Node_Str"",Font.PLAIN,16));
  lblConfNum_1.setForeground(Color.WHITE);
  Player1Info.add(lblConfNum_1);
  JPanel generalInfo=new JPanel();
  generalInfo.setForeground(Color.WHITE);
  generalInfo.setBackground(HSColors.BACKGROUND_COLOR);
  sl_InfoPane.putConstraint(SpringLayout.NORTH,generalInfo,0,SpringLayout.NORTH,InfoPane);
  sl_InfoPane.putConstraint(SpringLayout.WEST,generalInfo,0,SpringLayout.EAST,Player0Info);
  sl_InfoPane.putConstraint(SpringLayout.SOUTH,generalInfo,0,SpringLayout.SOUTH,InfoPane);
  sl_InfoPane.putConstraint(SpringLayout.EAST,generalInfo,0,SpringLayout.WEST,Player1Info);
  InfoPane.add(generalInfo);
  JPanel Player1Panel=new JPanel();
  springLayout.putConstraint(SpringLayout.EAST,middlePanel,0,SpringLayout.WEST,Player1Panel);
  JPanel PlotPane=new JPanel();
  sl_middlePanel.putConstraint(SpringLayout.NORTH,PlotPane,0,SpringLayout.SOUTH,InfoPane);
  sl_middlePanel.putConstraint(SpringLayout.WEST,PlotPane,0,SpringLayout.WEST,middlePanel);
  sl_middlePanel.putConstraint(SpringLayout.SOUTH,PlotPane,0,SpringLayout.NORTH,ControlPane);
  sl_middlePanel.putConstraint(SpringLayout.EAST,PlotPane,0,SpringLayout.EAST,middlePanel);
  springLayout.putConstraint(SpringLayout.NORTH,PlotPane,0,SpringLayout.SOUTH,InfoPane);
  springLayout.putConstraint(SpringLayout.WEST,PlotPane,0,SpringLayout.WEST,middlePanel);
  springLayout.putConstraint(SpringLayout.SOUTH,PlotPane,0,SpringLayout.NORTH,middlePanel);
  springLayout.putConstraint(SpringLayout.EAST,PlotPane,0,SpringLayout.EAST,middlePanel);
  middlePanel.add(PlotPane);
  PlotPane.setBorder(null);
  PlotPane.setOpaque(false);
  SpringLayout sl_PlotPane=new SpringLayout();
  PlotPane.setLayout(sl_PlotPane);
  JPanel plotTabPane=new JPanel();
  sl_PlotPane.putConstraint(SpringLayout.SOUTH,plotTabPane,20,SpringLayout.NORTH,PlotPane);
  FlowLayout flowLayout=(FlowLayout)plotTabPane.getLayout();
  flowLayout.setVgap(1);
  flowLayout.setHgap(1);
  plotTabPane.setBackground(HSColors.BACKGROUND_COLOR);
  sl_PlotPane.putConstraint(SpringLayout.NORTH,plotTabPane,0,SpringLayout.NORTH,PlotPane);
  sl_PlotPane.putConstraint(SpringLayout.WEST,plotTabPane,0,SpringLayout.WEST,PlotPane);
  sl_PlotPane.putConstraint(SpringLayout.EAST,plotTabPane,0,SpringLayout.EAST,PlotPane);
  PlotPane.add(plotTabPane);
  plotCardPane=new JPanel();
  sl_PlotPane.putConstraint(SpringLayout.NORTH,plotCardPane,0,SpringLayout.SOUTH,plotTabPane);
  HSTabButton tabAveMinions=new HSTabButton(""String_Node_Str"");
  tabAveMinions.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      CardLayout cl=(CardLayout)(plotCardPane.getLayout());
      cl.show(plotCardPane,""String_Node_Str"");
    }
  }
);
  tabAveMinions.setBorder(null);
  tabAveMinions.setFont(new Font(""String_Node_Str"",Font.PLAIN,10));
  tabAveMinions.setBackground(HSColors.WARNING_BUTTON_COLOR);
  tabAveMinions.setForeground(Color.WHITE);
  plotTabPane.add(tabAveMinions);
  HSTabButton tabAveCards=new HSTabButton(""String_Node_Str"");
  tabAveCards.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      CardLayout cl=(CardLayout)(plotCardPane.getLayout());
      cl.show(plotCardPane,""String_Node_Str"");
    }
  }
);
  tabAveCards.setBorder(null);
  tabAveCards.setFont(new Font(""String_Node_Str"",Font.PLAIN,10));
  tabAveCards.setBackground(HSColors.WARNING_BUTTON_COLOR);
  tabAveCards.setForeground(Color.WHITE);
  plotTabPane.add(tabAveCards);
  sl_PlotPane.putConstraint(SpringLayout.WEST,plotCardPane,0,SpringLayout.WEST,PlotPane);
  sl_PlotPane.putConstraint(SpringLayout.SOUTH,plotCardPane,0,SpringLayout.SOUTH,PlotPane);
  sl_PlotPane.putConstraint(SpringLayout.EAST,plotCardPane,0,SpringLayout.EAST,PlotPane);
  PlotPane.add(plotCardPane);
  plotCardPane.setLayout(new CardLayout(0,0));
  plot_aveMinions=new Plot();
  FlowLayout flowLayout_1=(FlowLayout)plot_aveMinions.getLayout();
  flowLayout_1.setVgap(0);
  plot_aveMinions.setYRange(0,6.0);
  plot_aveMinions.setXRange(0,30.0);
  plot_aveMinions.setTitle(""String_Node_Str"");
  plot_aveMinions.addLegend(0,""String_Node_Str"");
  plot_aveMinions.addLegend(1,""String_Node_Str"");
  plot_aveMinions.setXLabel(""String_Node_Str"");
  plot_aveMinions.setBackground(HSColors.BACKGROUND_COLOR);
  plot_aveMinions.setForeground(Color.WHITE);
  plot_aveMinions.setGrid(false);
  plot_aveMinions.setLabelFont(""String_Node_Str"");
  plotCardPane.add(plot_aveMinions,""String_Node_Str"");
  plot_aveCards=new Plot();
  FlowLayout flowLayout_2=(FlowLayout)plot_aveCards.getLayout();
  flowLayout_2.setVgap(0);
  plot_aveCards.setYRange(0,6.0);
  plot_aveCards.setXRange(0,30.0);
  plot_aveCards.setTitle(""String_Node_Str"");
  plot_aveCards.addLegend(0,""String_Node_Str"");
  plot_aveCards.addLegend(1,""String_Node_Str"");
  plot_aveCards.setXLabel(""String_Node_Str"");
  plot_aveCards.setBackground(HSColors.BACKGROUND_COLOR);
  plot_aveCards.setForeground(Color.WHITE);
  plot_aveCards.setGrid(false);
  plot_aveCards.setLabelFont(""String_Node_Str"");
  plotCardPane.add(plot_aveCards,""String_Node_Str"");
  middlePanel.add(ControlPane);
  ControlPane.setOpaque(false);
  HSButton btnSetting=new HSButton(""String_Node_Str"");
  btnSetting.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      HSSimulationSettingsFrame settingsFrame=new HSSimulationSettingsFrame(frame,hsModel_.getSimulation());
      settingsFrame.setVisible(true);
    }
  }
);
  btnSetting.setForeground(Color.WHITE);
  btnSetting.setBackground(HSColors.DEFAULT_BUTTON_COLOR);
  ControlPane.add(btnSetting);
  Component rigidArea_3=Box.createRigidArea(new Dimension(20,20));
  rigidArea_3.setPreferredSize(new Dimension(100,20));
  ControlPane.add(rigidArea_3);
  HSButton btnReset=new HSButton(""String_Node_Str"");
  btnReset.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      hsModel_.resetSimulationResults();
      HearthSim.this.updatePlotPanel();
      HearthSim.this.updateInfoPanel();
    }
  }
);
  btnReset.setForeground(Color.WHITE);
  btnReset.setBackground(HSColors.DEFAULT_BUTTON_COLOR);
  ControlPane.add(btnReset);
  btnRun=new HSButton(""String_Node_Str"");
  btnRun.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      if (hsModel_.getSimulation().getDeck_p0() == null) {
        JOptionPane.showMessageDialog(frame,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
        return;
      }
      if (hsModel_.getSimulation().getDeck_p1() == null) {
        JOptionPane.showMessageDialog(frame,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
        return;
      }
      Runnable runner=new Runnable(){
        public void run(){
          hsModel_.runSimulation();
        }
      }
;
      new Thread(runner).start();
    }
  }
);
  btnRun.setBackground(HSColors.SUCCESS_BUTTON_COLOR);
  btnRun.setForeground(Color.WHITE);
  ControlPane.add(btnRun);
  Player1Panel.setBorder(new MatteBorder(0,1,0,0,(Color)Color.GRAY));
  Player1Panel.setOpaque(false);
  springLayout.putConstraint(SpringLayout.NORTH,Player1Panel,0,SpringLayout.NORTH,frame.getContentPane());
  springLayout.putConstraint(SpringLayout.WEST,Player1Panel,-200,SpringLayout.EAST,frame.getContentPane());
  springLayout.putConstraint(SpringLayout.SOUTH,Player1Panel,0,SpringLayout.SOUTH,frame.getContentPane());
  springLayout.putConstraint(SpringLayout.EAST,Player1Panel,0,SpringLayout.EAST,frame.getContentPane());
  frame.getContentPane().add(Player1Panel);
  SpringLayout sl_Player1Panel=new SpringLayout();
  Player1Panel.setLayout(sl_Player1Panel);
  JPanel HeroPane_1=new JPanel();
  sl_Player1Panel.putConstraint(SpringLayout.SOUTH,HeroPane_1,50,SpringLayout.NORTH,Player1Panel);
  HeroPane_1.setOpaque(false);
  sl_Player1Panel.putConstraint(SpringLayout.NORTH,HeroPane_1,0,SpringLayout.NORTH,Player1Panel);
  sl_Player1Panel.putConstraint(SpringLayout.WEST,HeroPane_1,0,SpringLayout.WEST,Player1Panel);
  sl_Player1Panel.putConstraint(SpringLayout.EAST,HeroPane_1,0,SpringLayout.EAST,Player1Panel);
  Player1Panel.add(HeroPane_1);
  JButton btnDeckCreate_1=new HSDeckCreateButton();
  btnDeckCreate_1.setBounds(20,18,20,15);
  btnDeckCreate_1.setBackground(HSColors.BACKGROUND_COLOR);
  btnDeckCreate_1.setForeground(Color.WHITE);
  HeroPane_1.add(btnDeckCreate_1);
  JScrollPane DeckPane_1=new JScrollPane();
  sl_Player1Panel.putConstraint(SpringLayout.WEST,DeckPane_1,5,SpringLayout.WEST,Player1Panel);
  DeckPane_1.setOpaque(false);
  DeckPane_1.setBackground(Color.DARK_GRAY);
  DeckPane_1.setLayout(new ScrollPaneLayout());
  DeckPane_1.getViewport().setOpaque(false);
  DeckPane_1.setBorder(BorderFactory.createEmptyBorder());
  sl_Player1Panel.putConstraint(SpringLayout.NORTH,DeckPane_1,0,SpringLayout.SOUTH,HeroPane_1);
  HeroPane_1.setLayout(null);
  lblHero_1=new JLabel(""String_Node_Str"");
  lblHero_1.setBounds(0,0,200,50);
  lblHero_1.setHorizontalAlignment(SwingConstants.CENTER);
  lblHero_1.setForeground(Color.WHITE);
  lblHero_1.setFont(new Font(""String_Node_Str"",Font.PLAIN,20));
  HeroPane_1.add(lblHero_1);
  sl_Player1Panel.putConstraint(SpringLayout.EAST,DeckPane_1,0,SpringLayout.EAST,Player1Panel);
  Player1Panel.add(DeckPane_1);
  JPanel ControlPane_1=new JPanel();
  sl_Player1Panel.putConstraint(SpringLayout.SOUTH,DeckPane_1,-20,SpringLayout.NORTH,ControlPane_1);
  ControlPane_1.setOpaque(false);
  sl_Player1Panel.putConstraint(SpringLayout.NORTH,ControlPane_1,-40,SpringLayout.SOUTH,Player1Panel);
  sl_Player1Panel.putConstraint(SpringLayout.WEST,ControlPane_1,0,SpringLayout.WEST,Player1Panel);
  sl_Player1Panel.putConstraint(SpringLayout.SOUTH,ControlPane_1,0,SpringLayout.SOUTH,Player1Panel);
  sl_Player1Panel.putConstraint(SpringLayout.EAST,ControlPane_1,0,SpringLayout.EAST,Player1Panel);
  Player1Panel.add(ControlPane_1);
  SpringLayout sl_ControlPane_1=new SpringLayout();
  ControlPane_1.setLayout(sl_ControlPane_1);
  deckList_1=new HSCardList();
  deckList_1.setForeground(Color.WHITE);
  deckList_1.setBackground(HSColors.BACKGROUND_COLOR);
  deckList_1.setOpaque(false);
  DeckPane_1.setViewportView(deckList_1);
  sl_Player1Panel.putConstraint(SpringLayout.NORTH,ControlPane_1,-40,SpringLayout.SOUTH,Player1Panel);
  sl_Player1Panel.putConstraint(SpringLayout.WEST,ControlPane_1,0,SpringLayout.WEST,Player1Panel);
  sl_Player1Panel.putConstraint(SpringLayout.SOUTH,ControlPane_1,0,SpringLayout.SOUTH,Player1Panel);
  sl_Player1Panel.putConstraint(SpringLayout.EAST,ControlPane_1,0,SpringLayout.EAST,Player1Panel);
  HSButton p1_Load=new HSButton(""String_Node_Str"");
  p1_Load.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      if (fileChooser_ == null)       fileChooser_=new JFileChooser();
      int retVal=fileChooser_.showOpenDialog(frame);
      if (retVal == JFileChooser.APPROVE_OPTION) {
        try {
          DeckListFile deckList=new DeckListFile(fileChooser_.getSelectedFile().toPath());
          ((SortedListModel)deckList_1.getModel()).clear();
          for (int indx=0; indx < deckList.getDeck().getNumCards(); ++indx) {
            Card card=deckList.getDeck().drawCard(indx);
            ((SortedListModel)deckList_1.getModel()).addElement(IMPLEMENTED_CARD_LIST.getCardForClass(card.getClass()));
          }
          hsModel_.getSimulation().setDeck_p1(deckList.getDeck());
          hsModel_.getSimulation().setHero_p1(deckList.getHero());
          lblHero_1.setText(deckList.getHero().getName());
        }
 catch (        HSInvalidCardException|HSInvalidHeroException|IOException e1) {
          JOptionPane.showMessageDialog(frame,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
        }
      }
    }
  }
);
  sl_ControlPane_1.putConstraint(SpringLayout.NORTH,p1_Load,5,SpringLayout.NORTH,ControlPane_1);
  sl_ControlPane_1.putConstraint(SpringLayout.WEST,p1_Load,5,SpringLayout.WEST,ControlPane_1);
  p1_Load.setPreferredSize(new Dimension(80,30));
  p1_Load.setForeground(Color.WHITE);
  p1_Load.setBackground(HSColors.DEFAULT_BUTTON_COLOR);
  ControlPane_1.add(p1_Load);
  JButton p1_save=new HSButton(""String_Node_Str"");
  p1_save.setForeground(Color.WHITE);
  p1_save.setBackground(HSColors.DISABLED_BUTTON_COLOR);
  p1_save.setPreferredSize(new Dimension(80,30));
  sl_ControlPane_1.putConstraint(SpringLayout.EAST,p1_save,-5,SpringLayout.EAST,ControlPane_1);
  sl_ControlPane_1.putConstraint(SpringLayout.NORTH,p1_save,5,SpringLayout.NORTH,ControlPane_1);
  ControlPane_1.add(p1_save);
  JPanel cardCountPanel_0=new JPanel();
  cardCountPanel_0.setBackground(HSColors.BACKGROUND_COLOR);
  cardCountPanel_0.setForeground(HSColors.TEXT_COLOR);
  sl_Player0Panel.putConstraint(SpringLayout.NORTH,cardCountPanel_0,0,SpringLayout.SOUTH,DeckPane_0);
  sl_Player0Panel.putConstraint(SpringLayout.WEST,cardCountPanel_0,0,SpringLayout.WEST,DeckPane_0);
  sl_Player0Panel.putConstraint(SpringLayout.SOUTH,cardCountPanel_0,0,SpringLayout.NORTH,ControlPane_0);
  sl_Player0Panel.putConstraint(SpringLayout.EAST,cardCountPanel_0,0,SpringLayout.EAST,Player0Panel);
  Player0Panel.add(cardCountPanel_0);
  cardCountPanel_0.setLayout(null);
  cardCount_0=new JLabel(""String_Node_Str"");
  cardCount_0.setHorizontalAlignment(SwingConstants.CENTER);
  cardCount_0.setBounds(0,0,195,20);
  cardCount_0.setFont(new Font(""String_Node_Str"",Font.PLAIN,12));
  cardCount_0.setForeground(HSColors.TEXT_COLOR);
  cardCountPanel_0.add(cardCount_0);
  JPanel cardCountPanel_1=new JPanel();
  cardCountPanel_1.setBackground(HSColors.BACKGROUND_COLOR);
  cardCountPanel_1.setForeground(HSColors.TEXT_COLOR);
  sl_Player1Panel.putConstraint(SpringLayout.NORTH,cardCountPanel_1,0,SpringLayout.SOUTH,DeckPane_1);
  sl_Player1Panel.putConstraint(SpringLayout.WEST,cardCountPanel_1,0,SpringLayout.WEST,DeckPane_1);
  sl_Player1Panel.putConstraint(SpringLayout.SOUTH,cardCountPanel_1,0,SpringLayout.NORTH,ControlPane_1);
  sl_Player1Panel.putConstraint(SpringLayout.EAST,cardCountPanel_1,0,SpringLayout.EAST,Player1Panel);
  Player1Panel.add(cardCountPanel_1);
  cardCountPanel_1.setLayout(null);
  cardCount_1=new JLabel(""String_Node_Str"");
  cardCount_1.setHorizontalAlignment(SwingConstants.CENTER);
  cardCount_1.setBounds(0,0,195,20);
  cardCount_1.setFont(new Font(""String_Node_Str"",Font.PLAIN,12));
  cardCount_1.setForeground(HSColors.TEXT_COLOR);
  cardCountPanel_1.add(cardCount_1);
  deckList_0.getModel().addListDataListener(new ListDataListener(){
    @Override public void intervalAdded(    ListDataEvent e){
    }
    @Override public void intervalRemoved(    ListDataEvent e){
    }
    @Override public void contentsChanged(    ListDataEvent e){
      cardCount_0.setText(deckList_0.getModel().getSize() + ""String_Node_Str"");
    }
  }
);
  deckList_1.getModel().addListDataListener(new ListDataListener(){
    @Override public void intervalAdded(    ListDataEvent e){
    }
    @Override public void intervalRemoved(    ListDataEvent e){
    }
    @Override public void contentsChanged(    ListDataEvent e){
      cardCount_1.setText(deckList_1.getModel().getSize() + ""String_Node_Str"");
    }
  }
);
  btnDeckCreate_0.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      if (middlePanel.isVisible()) {
        middlePanel.setVisible(false);
        deckCreatePanel_0.setVisible(true);
        deckCreatePanel_0.setEditing(true);
      }
 else       if (deckCreatePanel_0.isVisible()) {
        middlePanel.setVisible(true);
        deckCreatePanel_0.setVisible(false);
        deckCreatePanel_0.setEditing(false);
        if (deckList_0.getModel().getSize() > 0)         hsModel_.getSimulation().setDeck_p0(deckList_0.getDeck());
      }
    }
  }
);
  btnDeckCreate_1.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      if (middlePanel.isVisible()) {
        middlePanel.setVisible(false);
        deckCreatePanel_1.setVisible(true);
        deckCreatePanel_1.setEditing(true);
      }
 else       if (deckCreatePanel_1.isVisible()) {
        middlePanel.setVisible(true);
        deckCreatePanel_1.setVisible(false);
        deckCreatePanel_1.setEditing(false);
        if (deckList_1.getModel().getSize() > 0)         hsModel_.getSimulation().setDeck_p1(deckList_1.getDeck());
      }
    }
  }
);
  deckCreatePanel_0=new HSDeckCreatePanel();
  deckCreatePanel_0.setForeground(Color.WHITE);
  deckCreatePanel_0.setBackground(HSColors.LIGHTER_BACKGROUND_COLOR);
  springLayout.putConstraint(SpringLayout.WEST,deckCreatePanel_0,0,SpringLayout.EAST,Player0Panel);
  springLayout.putConstraint(SpringLayout.EAST,deckCreatePanel_0,0,SpringLayout.WEST,Player1Panel);
  springLayout.putConstraint(SpringLayout.NORTH,deckCreatePanel_0,0,SpringLayout.NORTH,frame.getContentPane());
  springLayout.putConstraint(SpringLayout.SOUTH,deckCreatePanel_0,0,SpringLayout.SOUTH,frame.getContentPane());
  deckCreatePanel_0.setPlayer(0);
  deckCreatePanel_0.setVisible(false);
  deckCreatePanel_0.setCardListPane(deckList_0);
  frame.getContentPane().add(deckCreatePanel_0);
  deckCreatePanel_1=new HSDeckCreatePanel();
  deckCreatePanel_1.setForeground(Color.WHITE);
  deckCreatePanel_1.setBackground(HSColors.LIGHTER_BACKGROUND_COLOR);
  springLayout.putConstraint(SpringLayout.WEST,deckCreatePanel_1,0,SpringLayout.EAST,Player0Panel);
  springLayout.putConstraint(SpringLayout.EAST,deckCreatePanel_1,0,SpringLayout.WEST,Player1Panel);
  springLayout.putConstraint(SpringLayout.NORTH,deckCreatePanel_1,0,SpringLayout.NORTH,frame.getContentPane());
  springLayout.putConstraint(SpringLayout.SOUTH,deckCreatePanel_1,0,SpringLayout.SOUTH,frame.getContentPane());
  deckCreatePanel_1.setPlayer(1);
  deckCreatePanel_1.setVisible(false);
  deckCreatePanel_1.setCardListPane(deckList_1);
  frame.getContentPane().add(deckCreatePanel_1);
}","/** 
 * Initialize the contents of the frame.
 */
private void initialize(){
  frame=new JFrame();
  frame.getContentPane().setBackground(HSColors.BACKGROUND_COLOR);
  frame.setBounds(100,100,960,640);
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  SpringLayout springLayout=new SpringLayout();
  frame.getContentPane().setLayout(springLayout);
  JPanel Player0Panel=new JPanel();
  Player0Panel.setBorder(new MatteBorder(0,0,0,1,(Color)Color.GRAY));
  Player0Panel.setOpaque(false);
  Player0Panel.setBackground(Color.DARK_GRAY);
  springLayout.putConstraint(SpringLayout.NORTH,Player0Panel,0,SpringLayout.NORTH,frame.getContentPane());
  springLayout.putConstraint(SpringLayout.WEST,Player0Panel,0,SpringLayout.WEST,frame.getContentPane());
  springLayout.putConstraint(SpringLayout.SOUTH,Player0Panel,0,SpringLayout.SOUTH,frame.getContentPane());
  springLayout.putConstraint(SpringLayout.EAST,Player0Panel,200,SpringLayout.WEST,frame.getContentPane());
  frame.getContentPane().add(Player0Panel);
  SpringLayout sl_Player0Panel=new SpringLayout();
  Player0Panel.setLayout(sl_Player0Panel);
  JPanel HeroPane_0=new JPanel();
  sl_Player0Panel.putConstraint(SpringLayout.SOUTH,HeroPane_0,50,SpringLayout.NORTH,Player0Panel);
  HeroPane_0.setOpaque(false);
  HeroPane_0.setBackground(Color.DARK_GRAY);
  sl_Player0Panel.putConstraint(SpringLayout.NORTH,HeroPane_0,0,SpringLayout.NORTH,Player0Panel);
  sl_Player0Panel.putConstraint(SpringLayout.WEST,HeroPane_0,0,SpringLayout.WEST,Player0Panel);
  sl_Player0Panel.putConstraint(SpringLayout.EAST,HeroPane_0,0,SpringLayout.EAST,Player0Panel);
  springLayout.putConstraint(SpringLayout.NORTH,HeroPane_0,0,SpringLayout.NORTH,Player0Panel);
  springLayout.putConstraint(SpringLayout.WEST,HeroPane_0,0,SpringLayout.WEST,Player0Panel);
  springLayout.putConstraint(SpringLayout.SOUTH,HeroPane_0,50,SpringLayout.NORTH,Player0Panel);
  springLayout.putConstraint(SpringLayout.EAST,HeroPane_0,0,SpringLayout.EAST,Player0Panel);
  Player0Panel.add(HeroPane_0);
  JScrollPane DeckPane_0=new JScrollPane();
  sl_Player0Panel.putConstraint(SpringLayout.WEST,DeckPane_0,5,SpringLayout.WEST,Player0Panel);
  DeckPane_0.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);
  DeckPane_0.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
  DeckPane_0.setOpaque(false);
  DeckPane_0.setBackground(Color.DARK_GRAY);
  DeckPane_0.setLayout(new ScrollPaneLayout());
  DeckPane_0.getViewport().setOpaque(false);
  DeckPane_0.setBorder(BorderFactory.createEmptyBorder());
  sl_Player0Panel.putConstraint(SpringLayout.NORTH,DeckPane_0,0,SpringLayout.SOUTH,HeroPane_0);
  HeroPane_0.setLayout(null);
  lblHero_0=new JLabel(""String_Node_Str"");
  lblHero_0.setHorizontalAlignment(SwingConstants.CENTER);
  lblHero_0.setBounds(0,0,200,50);
  lblHero_0.setFont(new Font(""String_Node_Str"",Font.PLAIN,20));
  lblHero_0.setForeground(Color.WHITE);
  HeroPane_0.add(lblHero_0);
  JButton btnDeckCreate_0=new HSDeckCreateButton();
  btnDeckCreate_0.setBounds(160,18,20,15);
  btnDeckCreate_0.setBackground(HSColors.BACKGROUND_COLOR);
  btnDeckCreate_0.setForeground(Color.WHITE);
  HeroPane_0.add(btnDeckCreate_0);
  sl_Player0Panel.putConstraint(SpringLayout.EAST,DeckPane_0,0,SpringLayout.EAST,Player0Panel);
  Player0Panel.add(DeckPane_0);
  JPanel ControlPane_0=new JPanel();
  sl_Player0Panel.putConstraint(SpringLayout.SOUTH,DeckPane_0,-20,SpringLayout.NORTH,ControlPane_0);
  ControlPane_0.setBackground(Color.DARK_GRAY);
  ControlPane_0.setOpaque(false);
  deckList_0=new HSCardList();
  deckList_0.setForeground(Color.WHITE);
  deckList_0.setBackground(HSColors.BACKGROUND_COLOR);
  deckList_0.setOpaque(false);
  DeckPane_0.setViewportView(deckList_0);
  sl_Player0Panel.putConstraint(SpringLayout.NORTH,ControlPane_0,-40,SpringLayout.SOUTH,Player0Panel);
  sl_Player0Panel.putConstraint(SpringLayout.WEST,ControlPane_0,0,SpringLayout.WEST,Player0Panel);
  sl_Player0Panel.putConstraint(SpringLayout.SOUTH,ControlPane_0,0,SpringLayout.SOUTH,Player0Panel);
  sl_Player0Panel.putConstraint(SpringLayout.EAST,ControlPane_0,0,SpringLayout.EAST,Player0Panel);
  Player0Panel.add(ControlPane_0);
  SpringLayout sl_ControlPane_0=new SpringLayout();
  ControlPane_0.setLayout(sl_ControlPane_0);
  HSButton p0_load=new HSButton(""String_Node_Str"");
  p0_load.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      if (fileChooser_ == null)       fileChooser_=new JFileChooser();
      int retVal=fileChooser_.showOpenDialog(frame);
      if (retVal == JFileChooser.APPROVE_OPTION) {
        try {
          DeckListFile deckList=new DeckListFile(fileChooser_.getSelectedFile().toPath());
          ((SortedListModel)deckList_0.getModel()).clear();
          for (int indx=0; indx < deckList.getDeck().getNumCards(); ++indx) {
            Card card=deckList.getDeck().drawCard(indx);
            ((SortedListModel)deckList_0.getModel()).addElement(IMPLEMENTED_CARD_LIST.getCardForClass(card.getClass()));
          }
          hsModel_.getSimulation().setDeck_p0(deckList.getDeck());
          hsModel_.getSimulation().setHero_p0(deckList.getHero());
          lblHero_0.setText(deckList.getHero().getName());
        }
 catch (        HSInvalidCardException|HSInvalidHeroException|IOException e1) {
          JOptionPane.showMessageDialog(frame,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
        }
      }
    }
  }
);
  p0_load.setForeground(Color.WHITE);
  p0_load.setBackground(HSColors.DEFAULT_BUTTON_COLOR);
  p0_load.setPreferredSize(new Dimension(80,30));
  sl_ControlPane_0.putConstraint(SpringLayout.NORTH,p0_load,5,SpringLayout.NORTH,ControlPane_0);
  sl_ControlPane_0.putConstraint(SpringLayout.WEST,p0_load,5,SpringLayout.WEST,ControlPane_0);
  ControlPane_0.add(p0_load);
  JButton p0_save=new HSButton(""String_Node_Str"");
  p0_save.setForeground(Color.WHITE);
  p0_save.setBackground(HSColors.DISABLED_BUTTON_COLOR);
  sl_ControlPane_0.putConstraint(SpringLayout.EAST,p0_save,-5,SpringLayout.EAST,ControlPane_0);
  p0_save.setPreferredSize(new Dimension(80,30));
  sl_ControlPane_0.putConstraint(SpringLayout.NORTH,p0_save,5,SpringLayout.NORTH,ControlPane_0);
  ControlPane_0.add(p0_save);
  middlePanel=new JPanel();
  middlePanel.setForeground(Color.WHITE);
  middlePanel.setBackground(HSColors.BACKGROUND_COLOR);
  springLayout.putConstraint(SpringLayout.NORTH,ControlPane,-40,SpringLayout.SOUTH,middlePanel);
  springLayout.putConstraint(SpringLayout.WEST,ControlPane,0,SpringLayout.WEST,middlePanel);
  springLayout.putConstraint(SpringLayout.SOUTH,ControlPane,0,SpringLayout.SOUTH,middlePanel);
  springLayout.putConstraint(SpringLayout.EAST,ControlPane,0,SpringLayout.EAST,middlePanel);
  springLayout.putConstraint(SpringLayout.NORTH,middlePanel,0,SpringLayout.NORTH,frame.getContentPane());
  springLayout.putConstraint(SpringLayout.WEST,middlePanel,0,SpringLayout.EAST,Player0Panel);
  springLayout.putConstraint(SpringLayout.SOUTH,middlePanel,0,SpringLayout.SOUTH,frame.getContentPane());
  frame.getContentPane().add(middlePanel);
  SpringLayout sl_middlePanel=new SpringLayout();
  sl_middlePanel.putConstraint(SpringLayout.NORTH,ControlPane,-40,SpringLayout.SOUTH,middlePanel);
  sl_middlePanel.putConstraint(SpringLayout.WEST,ControlPane,0,SpringLayout.WEST,middlePanel);
  sl_middlePanel.putConstraint(SpringLayout.SOUTH,ControlPane,0,SpringLayout.SOUTH,middlePanel);
  sl_middlePanel.putConstraint(SpringLayout.EAST,ControlPane,0,SpringLayout.EAST,middlePanel);
  middlePanel.setLayout(sl_middlePanel);
  JPanel InfoPane=new JPanel();
  sl_middlePanel.putConstraint(SpringLayout.NORTH,InfoPane,0,SpringLayout.NORTH,middlePanel);
  sl_middlePanel.putConstraint(SpringLayout.WEST,InfoPane,0,SpringLayout.WEST,middlePanel);
  sl_middlePanel.putConstraint(SpringLayout.SOUTH,InfoPane,240,SpringLayout.NORTH,middlePanel);
  sl_middlePanel.putConstraint(SpringLayout.EAST,InfoPane,0,SpringLayout.EAST,middlePanel);
  springLayout.putConstraint(SpringLayout.NORTH,InfoPane,0,SpringLayout.NORTH,middlePanel);
  springLayout.putConstraint(SpringLayout.WEST,InfoPane,0,SpringLayout.WEST,middlePanel);
  springLayout.putConstraint(SpringLayout.SOUTH,InfoPane,250,SpringLayout.NORTH,middlePanel);
  springLayout.putConstraint(SpringLayout.EAST,InfoPane,0,SpringLayout.EAST,middlePanel);
  middlePanel.add(InfoPane);
  InfoPane.setOpaque(false);
  SpringLayout sl_InfoPane=new SpringLayout();
  InfoPane.setLayout(sl_InfoPane);
  JPanel Player0Info=new JPanel();
  sl_InfoPane.putConstraint(SpringLayout.WEST,Player0Info,25,SpringLayout.WEST,InfoPane);
  sl_InfoPane.putConstraint(SpringLayout.SOUTH,Player0Info,-5,SpringLayout.SOUTH,InfoPane);
  sl_InfoPane.putConstraint(SpringLayout.EAST,Player0Info,170,SpringLayout.WEST,InfoPane);
  Player0Info.setOpaque(false);
  sl_InfoPane.putConstraint(SpringLayout.NORTH,Player0Info,5,SpringLayout.NORTH,InfoPane);
  InfoPane.add(Player0Info);
  JLabel lblLabel1_0=new JLabel(""String_Node_Str"");
  lblLabel1_0.setFont(new Font(""String_Node_Str"",Font.PLAIN,18));
  lblLabel1_0.setForeground(Color.WHITE);
  Player0Info.add(lblLabel1_0);
  Component rigidArea_2=Box.createRigidArea(new Dimension(20,20));
  rigidArea_2.setPreferredSize(new Dimension(135,10));
  Player0Info.add(rigidArea_2);
  lblWin_0=new JLabel(""String_Node_Str"");
  lblWin_0.setFont(new Font(""String_Node_Str"",Font.PLAIN,24));
  lblWin_0.setHorizontalAlignment(SwingConstants.CENTER);
  lblWin_0.setPreferredSize(new Dimension(135,40));
  lblWin_0.setForeground(Color.WHITE);
  Player0Info.add(lblWin_0);
  Component rigidArea_1=Box.createRigidArea(new Dimension(20,10));
  rigidArea_1.setPreferredSize(new Dimension(135,2));
  Player0Info.add(rigidArea_1);
  lblWinRate_0=new JLabel(""String_Node_Str"");
  lblWinRate_0.setFont(new Font(""String_Node_Str"",Font.PLAIN,24));
  lblWinRate_0.setHorizontalAlignment(SwingConstants.CENTER);
  lblWinRate_0.setHorizontalTextPosition(SwingConstants.CENTER);
  lblWinRate_0.setForeground(Color.WHITE);
  lblWinRate_0.setPreferredSize(new Dimension(135,40));
  Player0Info.add(lblWinRate_0);
  Component rigidArea=Box.createRigidArea(new Dimension(20,20));
  rigidArea.setPreferredSize(new Dimension(135,20));
  Player0Info.add(rigidArea);
  JLabel lblConf_0=new JLabel(""String_Node_Str"");
  lblConf_0.setForeground(Color.WHITE);
  lblConf_0.setFont(new Font(""String_Node_Str"",Font.PLAIN,12));
  Player0Info.add(lblConf_0);
  lblConfNum_0=new JLabel(""String_Node_Str"");
  lblConfNum_0.setHorizontalAlignment(SwingConstants.CENTER);
  lblConfNum_0.setPreferredSize(new Dimension(135,30));
  lblConfNum_0.setFont(new Font(""String_Node_Str"",Font.PLAIN,16));
  lblConfNum_0.setForeground(Color.WHITE);
  Player0Info.add(lblConfNum_0);
  JPanel Player1Info=new JPanel();
  sl_InfoPane.putConstraint(SpringLayout.WEST,Player1Info,-170,SpringLayout.EAST,InfoPane);
  sl_InfoPane.putConstraint(SpringLayout.EAST,Player1Info,-25,SpringLayout.EAST,InfoPane);
  Player1Info.setOpaque(false);
  sl_InfoPane.putConstraint(SpringLayout.NORTH,Player1Info,5,SpringLayout.NORTH,InfoPane);
  sl_InfoPane.putConstraint(SpringLayout.SOUTH,Player1Info,-5,SpringLayout.SOUTH,InfoPane);
  InfoPane.add(Player1Info);
  JLabel lblLabel1_1=new JLabel(""String_Node_Str"");
  lblLabel1_1.setFont(new Font(""String_Node_Str"",Font.PLAIN,18));
  lblLabel1_1.setForeground(Color.WHITE);
  Player1Info.add(lblLabel1_1);
  Component rigidArea_1_0=Box.createRigidArea(new Dimension(20,20));
  rigidArea_1_0.setPreferredSize(new Dimension(135,10));
  Player1Info.add(rigidArea_1_0);
  lblWin_1=new JLabel(""String_Node_Str"");
  lblWin_1.setFont(new Font(""String_Node_Str"",Font.PLAIN,24));
  lblWin_1.setHorizontalAlignment(SwingConstants.CENTER);
  lblWin_1.setPreferredSize(new Dimension(135,40));
  lblWin_1.setForeground(Color.WHITE);
  Player1Info.add(lblWin_1);
  Component rigidArea_1_1=Box.createRigidArea(new Dimension(20,20));
  rigidArea_1_1.setPreferredSize(new Dimension(135,2));
  Player1Info.add(rigidArea_1_1);
  lblWinRate_1=new JLabel(""String_Node_Str"");
  lblWinRate_1.setFont(new Font(""String_Node_Str"",Font.PLAIN,24));
  lblWinRate_1.setHorizontalAlignment(SwingConstants.CENTER);
  lblWinRate_1.setHorizontalTextPosition(SwingConstants.CENTER);
  lblWinRate_1.setForeground(Color.WHITE);
  lblWinRate_1.setPreferredSize(new Dimension(135,40));
  Player1Info.add(lblWinRate_1);
  Component rigidArea_0_2=Box.createRigidArea(new Dimension(20,20));
  rigidArea_0_2.setPreferredSize(new Dimension(135,20));
  Player1Info.add(rigidArea_0_2);
  JLabel lblConf_1=new JLabel(""String_Node_Str"");
  lblConf_1.setForeground(Color.WHITE);
  lblConf_1.setFont(new Font(""String_Node_Str"",Font.PLAIN,12));
  Player1Info.add(lblConf_1);
  lblConfNum_1=new JLabel(""String_Node_Str"");
  lblConfNum_1.setHorizontalAlignment(SwingConstants.CENTER);
  lblConfNum_1.setPreferredSize(new Dimension(135,30));
  lblConfNum_1.setFont(new Font(""String_Node_Str"",Font.PLAIN,16));
  lblConfNum_1.setForeground(Color.WHITE);
  Player1Info.add(lblConfNum_1);
  JPanel generalInfo=new JPanel();
  generalInfo.setForeground(Color.WHITE);
  generalInfo.setBackground(HSColors.BACKGROUND_COLOR);
  sl_InfoPane.putConstraint(SpringLayout.NORTH,generalInfo,0,SpringLayout.NORTH,InfoPane);
  sl_InfoPane.putConstraint(SpringLayout.WEST,generalInfo,0,SpringLayout.EAST,Player0Info);
  sl_InfoPane.putConstraint(SpringLayout.SOUTH,generalInfo,0,SpringLayout.SOUTH,InfoPane);
  sl_InfoPane.putConstraint(SpringLayout.EAST,generalInfo,0,SpringLayout.WEST,Player1Info);
  InfoPane.add(generalInfo);
  JPanel Player1Panel=new JPanel();
  springLayout.putConstraint(SpringLayout.EAST,middlePanel,0,SpringLayout.WEST,Player1Panel);
  JPanel PlotPane=new JPanel();
  sl_middlePanel.putConstraint(SpringLayout.NORTH,PlotPane,0,SpringLayout.SOUTH,InfoPane);
  sl_middlePanel.putConstraint(SpringLayout.WEST,PlotPane,0,SpringLayout.WEST,middlePanel);
  sl_middlePanel.putConstraint(SpringLayout.SOUTH,PlotPane,0,SpringLayout.NORTH,ControlPane);
  sl_middlePanel.putConstraint(SpringLayout.EAST,PlotPane,0,SpringLayout.EAST,middlePanel);
  springLayout.putConstraint(SpringLayout.NORTH,PlotPane,0,SpringLayout.SOUTH,InfoPane);
  springLayout.putConstraint(SpringLayout.WEST,PlotPane,0,SpringLayout.WEST,middlePanel);
  springLayout.putConstraint(SpringLayout.SOUTH,PlotPane,0,SpringLayout.NORTH,middlePanel);
  springLayout.putConstraint(SpringLayout.EAST,PlotPane,0,SpringLayout.EAST,middlePanel);
  middlePanel.add(PlotPane);
  PlotPane.setBorder(null);
  PlotPane.setOpaque(false);
  SpringLayout sl_PlotPane=new SpringLayout();
  PlotPane.setLayout(sl_PlotPane);
  JPanel plotTabPane=new JPanel();
  sl_PlotPane.putConstraint(SpringLayout.SOUTH,plotTabPane,20,SpringLayout.NORTH,PlotPane);
  FlowLayout flowLayout=(FlowLayout)plotTabPane.getLayout();
  flowLayout.setVgap(1);
  flowLayout.setHgap(1);
  plotTabPane.setBackground(HSColors.BACKGROUND_COLOR);
  sl_PlotPane.putConstraint(SpringLayout.NORTH,plotTabPane,0,SpringLayout.NORTH,PlotPane);
  sl_PlotPane.putConstraint(SpringLayout.WEST,plotTabPane,0,SpringLayout.WEST,PlotPane);
  sl_PlotPane.putConstraint(SpringLayout.EAST,plotTabPane,0,SpringLayout.EAST,PlotPane);
  PlotPane.add(plotTabPane);
  plotCardPane=new JPanel();
  sl_PlotPane.putConstraint(SpringLayout.NORTH,plotCardPane,0,SpringLayout.SOUTH,plotTabPane);
  HSTabButton tabAveMinions=new HSTabButton(""String_Node_Str"");
  tabAveMinions.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      CardLayout cl=(CardLayout)(plotCardPane.getLayout());
      cl.show(plotCardPane,""String_Node_Str"");
    }
  }
);
  tabAveMinions.setBorder(null);
  tabAveMinions.setFont(new Font(""String_Node_Str"",Font.PLAIN,10));
  tabAveMinions.setBackground(HSColors.WARNING_BUTTON_COLOR);
  tabAveMinions.setForeground(Color.WHITE);
  plotTabPane.add(tabAveMinions);
  HSTabButton tabAveCards=new HSTabButton(""String_Node_Str"");
  tabAveCards.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      CardLayout cl=(CardLayout)(plotCardPane.getLayout());
      cl.show(plotCardPane,""String_Node_Str"");
    }
  }
);
  tabAveCards.setBorder(null);
  tabAveCards.setFont(new Font(""String_Node_Str"",Font.PLAIN,10));
  tabAveCards.setBackground(HSColors.WARNING_BUTTON_COLOR);
  tabAveCards.setForeground(Color.WHITE);
  plotTabPane.add(tabAveCards);
  sl_PlotPane.putConstraint(SpringLayout.WEST,plotCardPane,0,SpringLayout.WEST,PlotPane);
  sl_PlotPane.putConstraint(SpringLayout.SOUTH,plotCardPane,0,SpringLayout.SOUTH,PlotPane);
  sl_PlotPane.putConstraint(SpringLayout.EAST,plotCardPane,0,SpringLayout.EAST,PlotPane);
  PlotPane.add(plotCardPane);
  plotCardPane.setLayout(new CardLayout(0,0));
  plot_aveMinions=new Plot();
  FlowLayout flowLayout_1=(FlowLayout)plot_aveMinions.getLayout();
  flowLayout_1.setVgap(0);
  plot_aveMinions.setYRange(0,6.0);
  plot_aveMinions.setXRange(0,30.0);
  plot_aveMinions.setTitle(""String_Node_Str"");
  plot_aveMinions.addLegend(0,""String_Node_Str"");
  plot_aveMinions.addLegend(1,""String_Node_Str"");
  plot_aveMinions.setXLabel(""String_Node_Str"");
  plot_aveMinions.setBackground(HSColors.BACKGROUND_COLOR);
  plot_aveMinions.setForeground(Color.WHITE);
  plot_aveMinions.setGrid(false);
  plot_aveMinions.setLabelFont(""String_Node_Str"");
  plotCardPane.add(plot_aveMinions,""String_Node_Str"");
  plot_aveCards=new Plot();
  FlowLayout flowLayout_2=(FlowLayout)plot_aveCards.getLayout();
  flowLayout_2.setVgap(0);
  plot_aveCards.setYRange(0,6.0);
  plot_aveCards.setXRange(0,30.0);
  plot_aveCards.setTitle(""String_Node_Str"");
  plot_aveCards.addLegend(0,""String_Node_Str"");
  plot_aveCards.addLegend(1,""String_Node_Str"");
  plot_aveCards.setXLabel(""String_Node_Str"");
  plot_aveCards.setBackground(HSColors.BACKGROUND_COLOR);
  plot_aveCards.setForeground(Color.WHITE);
  plot_aveCards.setGrid(false);
  plot_aveCards.setLabelFont(""String_Node_Str"");
  plotCardPane.add(plot_aveCards,""String_Node_Str"");
  middlePanel.add(ControlPane);
  ControlPane.setOpaque(false);
  HSButton btnSetting=new HSButton(""String_Node_Str"");
  btnSetting.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      HSSimulationSettingsFrame settingsFrame=new HSSimulationSettingsFrame(frame,hsModel_.getSimulation());
      settingsFrame.setVisible(true);
    }
  }
);
  btnSetting.setForeground(Color.WHITE);
  btnSetting.setBackground(HSColors.DEFAULT_BUTTON_COLOR);
  ControlPane.add(btnSetting);
  Component rigidArea_3=Box.createRigidArea(new Dimension(20,20));
  rigidArea_3.setPreferredSize(new Dimension(100,20));
  ControlPane.add(rigidArea_3);
  HSButton btnReset=new HSButton(""String_Node_Str"");
  btnReset.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      hsModel_.resetSimulationResults();
      HearthSim.this.updatePlotPanel();
      HearthSim.this.updateInfoPanel();
    }
  }
);
  btnReset.setForeground(Color.WHITE);
  btnReset.setBackground(HSColors.DEFAULT_BUTTON_COLOR);
  ControlPane.add(btnReset);
  btnRun=new HSButton(""String_Node_Str"");
  btnRun.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      if (!isRunning_) {
        if (hsModel_.getSimulation().getDeck_p0() == null) {
          JOptionPane.showMessageDialog(frame,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
          return;
        }
        if (hsModel_.getSimulation().getDeck_p1() == null) {
          JOptionPane.showMessageDialog(frame,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
          return;
        }
        Runnable runner=new Runnable(){
          public void run(){
            hsModel_.runSimulation();
          }
        }
;
        new Thread(runner).start();
      }
    }
  }
);
  btnRun.setBackground(HSColors.SUCCESS_BUTTON_COLOR);
  btnRun.setForeground(Color.WHITE);
  ControlPane.add(btnRun);
  Player1Panel.setBorder(new MatteBorder(0,1,0,0,(Color)Color.GRAY));
  Player1Panel.setOpaque(false);
  springLayout.putConstraint(SpringLayout.NORTH,Player1Panel,0,SpringLayout.NORTH,frame.getContentPane());
  springLayout.putConstraint(SpringLayout.WEST,Player1Panel,-200,SpringLayout.EAST,frame.getContentPane());
  springLayout.putConstraint(SpringLayout.SOUTH,Player1Panel,0,SpringLayout.SOUTH,frame.getContentPane());
  springLayout.putConstraint(SpringLayout.EAST,Player1Panel,0,SpringLayout.EAST,frame.getContentPane());
  frame.getContentPane().add(Player1Panel);
  SpringLayout sl_Player1Panel=new SpringLayout();
  Player1Panel.setLayout(sl_Player1Panel);
  JPanel HeroPane_1=new JPanel();
  sl_Player1Panel.putConstraint(SpringLayout.SOUTH,HeroPane_1,50,SpringLayout.NORTH,Player1Panel);
  HeroPane_1.setOpaque(false);
  sl_Player1Panel.putConstraint(SpringLayout.NORTH,HeroPane_1,0,SpringLayout.NORTH,Player1Panel);
  sl_Player1Panel.putConstraint(SpringLayout.WEST,HeroPane_1,0,SpringLayout.WEST,Player1Panel);
  sl_Player1Panel.putConstraint(SpringLayout.EAST,HeroPane_1,0,SpringLayout.EAST,Player1Panel);
  Player1Panel.add(HeroPane_1);
  JButton btnDeckCreate_1=new HSDeckCreateButton();
  btnDeckCreate_1.setBounds(20,18,20,15);
  btnDeckCreate_1.setBackground(HSColors.BACKGROUND_COLOR);
  btnDeckCreate_1.setForeground(Color.WHITE);
  HeroPane_1.add(btnDeckCreate_1);
  JScrollPane DeckPane_1=new JScrollPane();
  sl_Player1Panel.putConstraint(SpringLayout.WEST,DeckPane_1,5,SpringLayout.WEST,Player1Panel);
  DeckPane_1.setOpaque(false);
  DeckPane_1.setBackground(Color.DARK_GRAY);
  DeckPane_1.setLayout(new ScrollPaneLayout());
  DeckPane_1.getViewport().setOpaque(false);
  DeckPane_1.setBorder(BorderFactory.createEmptyBorder());
  sl_Player1Panel.putConstraint(SpringLayout.NORTH,DeckPane_1,0,SpringLayout.SOUTH,HeroPane_1);
  HeroPane_1.setLayout(null);
  lblHero_1=new JLabel(""String_Node_Str"");
  lblHero_1.setBounds(0,0,200,50);
  lblHero_1.setHorizontalAlignment(SwingConstants.CENTER);
  lblHero_1.setForeground(Color.WHITE);
  lblHero_1.setFont(new Font(""String_Node_Str"",Font.PLAIN,20));
  HeroPane_1.add(lblHero_1);
  sl_Player1Panel.putConstraint(SpringLayout.EAST,DeckPane_1,0,SpringLayout.EAST,Player1Panel);
  Player1Panel.add(DeckPane_1);
  JPanel ControlPane_1=new JPanel();
  sl_Player1Panel.putConstraint(SpringLayout.SOUTH,DeckPane_1,-20,SpringLayout.NORTH,ControlPane_1);
  ControlPane_1.setOpaque(false);
  sl_Player1Panel.putConstraint(SpringLayout.NORTH,ControlPane_1,-40,SpringLayout.SOUTH,Player1Panel);
  sl_Player1Panel.putConstraint(SpringLayout.WEST,ControlPane_1,0,SpringLayout.WEST,Player1Panel);
  sl_Player1Panel.putConstraint(SpringLayout.SOUTH,ControlPane_1,0,SpringLayout.SOUTH,Player1Panel);
  sl_Player1Panel.putConstraint(SpringLayout.EAST,ControlPane_1,0,SpringLayout.EAST,Player1Panel);
  Player1Panel.add(ControlPane_1);
  SpringLayout sl_ControlPane_1=new SpringLayout();
  ControlPane_1.setLayout(sl_ControlPane_1);
  deckList_1=new HSCardList();
  deckList_1.setForeground(Color.WHITE);
  deckList_1.setBackground(HSColors.BACKGROUND_COLOR);
  deckList_1.setOpaque(false);
  DeckPane_1.setViewportView(deckList_1);
  sl_Player1Panel.putConstraint(SpringLayout.NORTH,ControlPane_1,-40,SpringLayout.SOUTH,Player1Panel);
  sl_Player1Panel.putConstraint(SpringLayout.WEST,ControlPane_1,0,SpringLayout.WEST,Player1Panel);
  sl_Player1Panel.putConstraint(SpringLayout.SOUTH,ControlPane_1,0,SpringLayout.SOUTH,Player1Panel);
  sl_Player1Panel.putConstraint(SpringLayout.EAST,ControlPane_1,0,SpringLayout.EAST,Player1Panel);
  HSButton p1_Load=new HSButton(""String_Node_Str"");
  p1_Load.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      if (fileChooser_ == null)       fileChooser_=new JFileChooser();
      int retVal=fileChooser_.showOpenDialog(frame);
      if (retVal == JFileChooser.APPROVE_OPTION) {
        try {
          DeckListFile deckList=new DeckListFile(fileChooser_.getSelectedFile().toPath());
          ((SortedListModel)deckList_1.getModel()).clear();
          for (int indx=0; indx < deckList.getDeck().getNumCards(); ++indx) {
            Card card=deckList.getDeck().drawCard(indx);
            ((SortedListModel)deckList_1.getModel()).addElement(IMPLEMENTED_CARD_LIST.getCardForClass(card.getClass()));
          }
          hsModel_.getSimulation().setDeck_p1(deckList.getDeck());
          hsModel_.getSimulation().setHero_p1(deckList.getHero());
          lblHero_1.setText(deckList.getHero().getName());
        }
 catch (        HSInvalidCardException|HSInvalidHeroException|IOException e1) {
          JOptionPane.showMessageDialog(frame,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
        }
      }
    }
  }
);
  sl_ControlPane_1.putConstraint(SpringLayout.NORTH,p1_Load,5,SpringLayout.NORTH,ControlPane_1);
  sl_ControlPane_1.putConstraint(SpringLayout.WEST,p1_Load,5,SpringLayout.WEST,ControlPane_1);
  p1_Load.setPreferredSize(new Dimension(80,30));
  p1_Load.setForeground(Color.WHITE);
  p1_Load.setBackground(HSColors.DEFAULT_BUTTON_COLOR);
  ControlPane_1.add(p1_Load);
  JButton p1_save=new HSButton(""String_Node_Str"");
  p1_save.setForeground(Color.WHITE);
  p1_save.setBackground(HSColors.DISABLED_BUTTON_COLOR);
  p1_save.setPreferredSize(new Dimension(80,30));
  sl_ControlPane_1.putConstraint(SpringLayout.EAST,p1_save,-5,SpringLayout.EAST,ControlPane_1);
  sl_ControlPane_1.putConstraint(SpringLayout.NORTH,p1_save,5,SpringLayout.NORTH,ControlPane_1);
  ControlPane_1.add(p1_save);
  JPanel cardCountPanel_0=new JPanel();
  cardCountPanel_0.setBackground(HSColors.BACKGROUND_COLOR);
  cardCountPanel_0.setForeground(HSColors.TEXT_COLOR);
  sl_Player0Panel.putConstraint(SpringLayout.NORTH,cardCountPanel_0,0,SpringLayout.SOUTH,DeckPane_0);
  sl_Player0Panel.putConstraint(SpringLayout.WEST,cardCountPanel_0,0,SpringLayout.WEST,DeckPane_0);
  sl_Player0Panel.putConstraint(SpringLayout.SOUTH,cardCountPanel_0,0,SpringLayout.NORTH,ControlPane_0);
  sl_Player0Panel.putConstraint(SpringLayout.EAST,cardCountPanel_0,0,SpringLayout.EAST,Player0Panel);
  Player0Panel.add(cardCountPanel_0);
  cardCountPanel_0.setLayout(null);
  cardCount_0=new JLabel(""String_Node_Str"");
  cardCount_0.setHorizontalAlignment(SwingConstants.CENTER);
  cardCount_0.setBounds(0,0,195,20);
  cardCount_0.setFont(new Font(""String_Node_Str"",Font.PLAIN,12));
  cardCount_0.setForeground(HSColors.TEXT_COLOR);
  cardCountPanel_0.add(cardCount_0);
  JPanel cardCountPanel_1=new JPanel();
  cardCountPanel_1.setBackground(HSColors.BACKGROUND_COLOR);
  cardCountPanel_1.setForeground(HSColors.TEXT_COLOR);
  sl_Player1Panel.putConstraint(SpringLayout.NORTH,cardCountPanel_1,0,SpringLayout.SOUTH,DeckPane_1);
  sl_Player1Panel.putConstraint(SpringLayout.WEST,cardCountPanel_1,0,SpringLayout.WEST,DeckPane_1);
  sl_Player1Panel.putConstraint(SpringLayout.SOUTH,cardCountPanel_1,0,SpringLayout.NORTH,ControlPane_1);
  sl_Player1Panel.putConstraint(SpringLayout.EAST,cardCountPanel_1,0,SpringLayout.EAST,Player1Panel);
  Player1Panel.add(cardCountPanel_1);
  cardCountPanel_1.setLayout(null);
  cardCount_1=new JLabel(""String_Node_Str"");
  cardCount_1.setHorizontalAlignment(SwingConstants.CENTER);
  cardCount_1.setBounds(0,0,195,20);
  cardCount_1.setFont(new Font(""String_Node_Str"",Font.PLAIN,12));
  cardCount_1.setForeground(HSColors.TEXT_COLOR);
  cardCountPanel_1.add(cardCount_1);
  deckList_0.getModel().addListDataListener(new ListDataListener(){
    @Override public void intervalAdded(    ListDataEvent e){
    }
    @Override public void intervalRemoved(    ListDataEvent e){
    }
    @Override public void contentsChanged(    ListDataEvent e){
      cardCount_0.setText(deckList_0.getModel().getSize() + ""String_Node_Str"");
    }
  }
);
  deckList_1.getModel().addListDataListener(new ListDataListener(){
    @Override public void intervalAdded(    ListDataEvent e){
    }
    @Override public void intervalRemoved(    ListDataEvent e){
    }
    @Override public void contentsChanged(    ListDataEvent e){
      cardCount_1.setText(deckList_1.getModel().getSize() + ""String_Node_Str"");
    }
  }
);
  btnDeckCreate_0.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      if (middlePanel.isVisible()) {
        middlePanel.setVisible(false);
        deckCreatePanel_0.setVisible(true);
        deckCreatePanel_0.setEditing(true);
      }
 else       if (deckCreatePanel_0.isVisible()) {
        middlePanel.setVisible(true);
        deckCreatePanel_0.setVisible(false);
        deckCreatePanel_0.setEditing(false);
        if (deckList_0.getModel().getSize() > 0)         hsModel_.getSimulation().setDeck_p0(deckList_0.getDeck());
      }
    }
  }
);
  btnDeckCreate_1.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      if (middlePanel.isVisible()) {
        middlePanel.setVisible(false);
        deckCreatePanel_1.setVisible(true);
        deckCreatePanel_1.setEditing(true);
      }
 else       if (deckCreatePanel_1.isVisible()) {
        middlePanel.setVisible(true);
        deckCreatePanel_1.setVisible(false);
        deckCreatePanel_1.setEditing(false);
        if (deckList_1.getModel().getSize() > 0)         hsModel_.getSimulation().setDeck_p1(deckList_1.getDeck());
      }
    }
  }
);
  deckCreatePanel_0=new HSDeckCreatePanel();
  deckCreatePanel_0.setForeground(Color.WHITE);
  deckCreatePanel_0.setBackground(HSColors.LIGHTER_BACKGROUND_COLOR);
  springLayout.putConstraint(SpringLayout.WEST,deckCreatePanel_0,0,SpringLayout.EAST,Player0Panel);
  springLayout.putConstraint(SpringLayout.EAST,deckCreatePanel_0,0,SpringLayout.WEST,Player1Panel);
  springLayout.putConstraint(SpringLayout.NORTH,deckCreatePanel_0,0,SpringLayout.NORTH,frame.getContentPane());
  springLayout.putConstraint(SpringLayout.SOUTH,deckCreatePanel_0,0,SpringLayout.SOUTH,frame.getContentPane());
  deckCreatePanel_0.setPlayer(0);
  deckCreatePanel_0.setVisible(false);
  deckCreatePanel_0.setCardListPane(deckList_0);
  frame.getContentPane().add(deckCreatePanel_0);
  deckCreatePanel_1=new HSDeckCreatePanel();
  deckCreatePanel_1.setForeground(Color.WHITE);
  deckCreatePanel_1.setBackground(HSColors.LIGHTER_BACKGROUND_COLOR);
  springLayout.putConstraint(SpringLayout.WEST,deckCreatePanel_1,0,SpringLayout.EAST,Player0Panel);
  springLayout.putConstraint(SpringLayout.EAST,deckCreatePanel_1,0,SpringLayout.WEST,Player1Panel);
  springLayout.putConstraint(SpringLayout.NORTH,deckCreatePanel_1,0,SpringLayout.NORTH,frame.getContentPane());
  springLayout.putConstraint(SpringLayout.SOUTH,deckCreatePanel_1,0,SpringLayout.SOUTH,frame.getContentPane());
  deckCreatePanel_1.setPlayer(1);
  deckCreatePanel_1.setVisible(false);
  deckCreatePanel_1.setCardListPane(deckList_1);
  frame.getContentPane().add(deckCreatePanel_1);
}",0.9984898920191604
112813,"@Override public void simulationStarted(){
  btnRun.setBackground(HSColors.ERROR_BUTTON_COLOR);
  btnRun.setText(""String_Node_Str"");
}","@Override public void simulationStarted(){
  btnRun.setBackground(HSColors.ERROR_BUTTON_COLOR);
  btnRun.setText(""String_Node_Str"");
  isRunning_=true;
}",0.9337979094076656
112814,"@Override public void run(){
  try {
    GameResult res=runSingleGame();
synchronized (writer_) {
      System.out.println(""String_Node_Str"" + gameId_ + ""String_Node_Str""+ res.winnerPlayerIndex_+ ""String_Node_Str"");
      JSONObject json=new JSONObject();
      json.put(""String_Node_Str"",res.winnerPlayerIndex_);
      json.put(""String_Node_Str"",res.gameDuration_);
      json.put(""String_Node_Str"",res.record_.toJSON());
      writer_.write(json.toString() + ""String_Node_Str"");
      writer_.flush();
      results_[gameId_]=res;
    }
  }
 catch (  HSException|IOException e) {
    e.printStackTrace();
  }
}","@Override public void run(){
  try {
    GameResult res=runSingleGame();
synchronized (writer_) {
      System.out.println(""String_Node_Str"" + gameId_ + ""String_Node_Str""+ res.winnerPlayerIndex_+ ""String_Node_Str"");
      JSONObject json=new JSONObject();
      json.put(""String_Node_Str"",res.winnerPlayerIndex_);
      json.put(""String_Node_Str"",res.gameDuration_);
      json.put(""String_Node_Str"",res.record_.toJSON());
      writer_.write(json.toString() + ""String_Node_Str"");
      writer_.flush();
      results_[gameId_]=res;
    }
  }
 catch (  HSException|IOException e) {
    System.out.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
}",0.963021243115657
112815,"/** 
 * Play a turn This function is called by GameMaster, and it should return a BoardState resulting from the AI playing its turn.
 * @param turn Turn number, 1-based
 * @param board The board state at the beginning of the turn (after all card draws and minion deaths)
 * @param player The player playing the turn
 * @return
 * @throws HSException
 */
public BoardState playTurn(int turn,BoardState board,Player player0,Player player1) throws HSException {
  HearthTreeNode toRet=new HearthTreeNode(board);
  BoardStateFactory factory=new BoardStateFactory(player0.getDeck(),player1.getDeck());
  HearthTreeNode allMoves=factory.doMoves(toRet,this);
  HearthTreeNode bestPlay=allMoves.findMaxOfFunc(this);
  while (bestPlay instanceof StopNode) {
    HearthTreeNode allEffectsDone=((StopNode)bestPlay).finishAllEffects(player0.getDeck());
    HearthTreeNode allMovesAtferStopNode=factory.doMoves(allEffectsDone,this);
    bestPlay=allMovesAtferStopNode.findMaxOfFunc(this);
  }
  return bestPlay.data_;
}","/** 
 * Play a turn This function is called by GameMaster, and it should return a BoardState resulting from the AI playing its turn.
 * @param turn Turn number, 1-based
 * @param board The board state at the beginning of the turn (after all card draws and minion deaths)
 * @param player The player playing the turn
 * @return
 * @throws HSException
 */
public BoardState playTurn(int turn,BoardState board,Player player0,Player player1) throws HSException {
  HearthTreeNode toRet=new HearthTreeNode(board);
  BoardStateFactory factory=new BoardStateFactory(player0.getDeck(),player1.getDeck());
  HearthTreeNode allMoves=factory.doMoves(toRet,this);
  HearthTreeNode bestPlay=allMoves.findMaxOfFunc(this);
  while (bestPlay instanceof StopNode) {
    HearthTreeNode allEffectsDone=((StopNode)bestPlay).finishAllEffects(player0.getDeck());
    factory.resetTimeOut();
    HearthTreeNode allMovesAtferStopNode=factory.doMoves(allEffectsDone,this);
    bestPlay=allMovesAtferStopNode.findMaxOfFunc(this);
  }
  return bestPlay.data_;
}",0.9862745098039216
112816,"public void run(){
  Runnable r;
  while (true) {
synchronized (queue) {
      if (queue.isEmpty()) {
        break;
      }
      r=(Runnable)queue.removeFirst();
    }
    try {
      r.run();
    }
 catch (    RuntimeException e) {
    }
  }
}","public void run(){
  Runnable r;
  while (true) {
synchronized (queue) {
      if (queue.isEmpty()) {
        break;
      }
      r=(Runnable)queue.removeFirst();
    }
    try {
      r.run();
    }
 catch (    RuntimeException e) {
      e.printStackTrace();
    }
  }
}",0.9210019267822736
112817,"public double heroHealthScore_p1(double heroHealth,double heroArmor){
  double toRet=enemy_wHeroHealth_ * (heroHealth + heroArmor);
  if (heroHealth <= 0) {
    toRet+=100000.0;
  }
  return toRet;
}","public double heroHealthScore_p1(double heroHealth,double heroArmor){
  double toRet=-enemy_wHeroHealth_ * (heroHealth + heroArmor);
  if (heroHealth <= 0) {
    toRet+=100000.0;
  }
  return toRet;
}",0.9974937343358397
112818,"/** 
 * Board score function The all important board score function.  It is a function that measures how 'good' the given board is.  As a convention, this function should be an increasing function of the board's goodness.
 * @param board The current board state
 * @return
 */
public double boardScore(BoardState board){
  LinkedList<Minion> myBoardCards;
  LinkedList<Minion> opBoardCards;
  LinkedList<Card> myHandCards;
  myBoardCards=board.getMinions_p0();
  opBoardCards=board.getMinions_p1();
  myHandCards=board.getCards_hand_p0();
  double myScore=0.0;
  for (  final Minion minion : myBoardCards) {
    myScore+=minion.getAttack() * my_wAttack_;
    myScore+=minion.getHealth() * my_wHealth_;
    myScore+=(minion.getTaunt() ? 1.0 : 0.0) * wTaunt_;
    if (minion.getDivineShield())     myScore+=((minion.getAttack() + minion.getHealth()) * my_wDivineShield_);
  }
  double opScore=0.0;
  for (  final Minion minion : opBoardCards) {
    opScore+=minion.getAttack() * enemy_wAttack_;
    opScore+=minion.getHealth() * enemy_wHealth_;
    opScore+=(minion.getTaunt() ? 1.0 : 0.0) * wTaunt_;
    if (minion.getDivineShield())     opScore+=(minion.getAttack() + minion.getHealth()) * enemy_wDivineShield_;
  }
  double weaponScore=0.0;
  weaponScore+=board.getHero_p0().getAttack() * board.getHero_p0().getWeaponCharge() * my_wWeapon_;
  weaponScore-=board.getHero_p1().getAttack() * board.getHero_p1().getWeaponCharge() * enemy_wWeapon_;
  double handScore=0.0;
  for (  final Card card : myHandCards) {
    handScore+=this.cardInHandScore(card);
  }
  double heroScore=0;
  heroScore+=heroHealthScore_p0(board.getHero_p0().getHealth(),board.getHero_p0().getArmor());
  heroScore-=heroHealthScore_p1(board.getHero_p1().getHealth(),board.getHero_p1().getArmor());
  double minionScore=0.0;
  minionScore+=my_wNumMinions_ * (board.getNumMinions_p0());
  minionScore-=enemy_wNumMinions_ * (board.getNumMinions_p1());
  double score=myScore - opScore + handScore + heroScore + minionScore + weaponScore;
  return score;
}","/** 
 * Board score function The all important board score function.  It is a function that measures how 'good' the given board is.  As a convention, this function should be an increasing function of the board's goodness.
 * @param board The current board state
 * @return
 */
public double boardScore(BoardState board){
  LinkedList<Minion> myBoardCards;
  LinkedList<Minion> opBoardCards;
  LinkedList<Card> myHandCards;
  myBoardCards=board.getMinions_p0();
  opBoardCards=board.getMinions_p1();
  myHandCards=board.getCards_hand_p0();
  double myScore=0.0;
  for (  final Minion minion : myBoardCards) {
    myScore+=minion.getAttack() * my_wAttack_;
    myScore+=minion.getHealth() * my_wHealth_;
    myScore+=(minion.getTaunt() ? 1.0 : 0.0) * wTaunt_;
    if (minion.getDivineShield())     myScore+=((minion.getAttack() + minion.getHealth()) * my_wDivineShield_);
  }
  double opScore=0.0;
  for (  final Minion minion : opBoardCards) {
    opScore+=minion.getAttack() * enemy_wAttack_;
    opScore+=minion.getHealth() * enemy_wHealth_;
    opScore+=(minion.getTaunt() ? 1.0 : 0.0) * wTaunt_;
    if (minion.getDivineShield())     opScore+=(minion.getAttack() + minion.getHealth()) * enemy_wDivineShield_;
  }
  double weaponScore=0.0;
  weaponScore+=board.getHero_p0().getAttack() * board.getHero_p0().getWeaponCharge() * my_wWeapon_;
  weaponScore-=board.getHero_p1().getAttack() * board.getHero_p1().getWeaponCharge() * enemy_wWeapon_;
  double handScore=0.0;
  for (  final Card card : myHandCards) {
    handScore+=this.cardInHandScore(card);
  }
  double heroScore=0;
  heroScore+=heroHealthScore_p0(board.getHero_p0().getHealth(),board.getHero_p0().getArmor());
  heroScore+=heroHealthScore_p1(board.getHero_p1().getHealth(),board.getHero_p1().getArmor());
  double minionScore=0.0;
  minionScore+=my_wNumMinions_ * (board.getNumMinions_p0());
  minionScore-=enemy_wNumMinions_ * (board.getNumMinions_p1());
  double score=myScore - opScore + handScore + heroScore + minionScore + weaponScore;
  return score;
}",0.9995059288537548
112819,"/** 
 * Play a turn This function is called by GameMaster, and it should return a BoardState resulting from the AI playing its turn.
 * @param turn Turn number, 1-based
 * @param board The board state at the beginning of the turn (after all card draws and minion deaths)
 * @param player The player playing the turn
 * @return
 * @throws HSException
 */
public BoardState playTurn(int turn,BoardState board,Player player0,Player player1) throws HSException {
  HearthTreeNode toRet=new HearthTreeNode(board);
  BoardStateFactory factory=new BoardStateFactory(player0.getDeck(),player1.getDeck());
  HearthTreeNode allMoves=factory.doMoves(toRet,this);
  HearthTreeNode bestPlay=allMoves.findMaxOfFunc(this);
  while (bestPlay instanceof StopNode) {
    HearthTreeNode allEffectsDone=((StopNode)bestPlay).finishAllEffects(player0.getDeck());
    HearthTreeNode allMovesAtferStopNode=factory.doMoves(allEffectsDone,this);
    bestPlay=allMovesAtferStopNode.findMaxOfFunc(this);
  }
  return bestPlay.data_;
}","/** 
 * Play a turn This function is called by GameMaster, and it should return a BoardState resulting from the AI playing its turn.
 * @param turn Turn number, 1-based
 * @param board The board state at the beginning of the turn (after all card draws and minion deaths)
 * @param player The player playing the turn
 * @return
 * @throws HSException
 */
public BoardState playTurn(int turn,BoardState board,Player player0,Player player1) throws HSException {
  HearthTreeNode toRet=new HearthTreeNode(board);
  BoardStateFactory factory=new BoardStateFactory(player0.getDeck(),player1.getDeck(),2000000000);
  HearthTreeNode allMoves=factory.doMoves(toRet,this);
  HearthTreeNode bestPlay=allMoves.findMaxOfFunc(this);
  while (bestPlay instanceof StopNode) {
    HearthTreeNode allEffectsDone=((StopNode)bestPlay).finishAllEffects(player0.getDeck());
    HearthTreeNode allMovesAtferStopNode=factory.doMoves(allEffectsDone,this);
    bestPlay=allMovesAtferStopNode.findMaxOfFunc(this);
  }
  return bestPlay.data_;
}",0.9945625308947108
112820,"/** 
 * Get the Hero
 * @return
 */
public Hero getHero(){
  return new Hero();
}","/** 
 * Get the Hero
 * @return
 */
public Hero getHero(){
  return hero_;
}",0.9426751592356688
112821,"/** 
 * Recursively generate all possible moves This function recursively generates all possible moves that can be done starting from a given BoardState. While generating the moves, it applies the scoring function to each BoardState generated, and it will only keep the highest scoring branch. The results are stored in a tree structure and returned as a tree of BoardState class.
 * @param boardStateNode The initial BoardState wrapped in a HearthTreeNode.
 * @param scoreFunc The scoring function for AI.
 * @return boardStateNode manipulated such that all subsequent actions are children of the original boardStateNode input.
 */
public HearthTreeNode doMoves(HearthTreeNode boardStateNode,StateFunction<BoardState> scoreFunc) throws HSException {
  if (lethal_) {
    return null;
  }
  if (timedOut_) {
    return null;
  }
  if (System.currentTimeMillis() - startTime_ > maxTime_) {
    timedOut_=true;
    return null;
  }
  if (boardStateNode.numChildren() > 0) {
    for (    HearthTreeNode child : boardStateNode.getChildren()) {
      this.doMoves(child,scoreFunc);
    }
    return boardStateNode;
  }
  boolean lethalFound=false;
  if ((!boardStateNode.data_.isAlive_p0()) || (!boardStateNode.data_.isAlive_p1())) {
    if (!boardStateNode.data_.isAlive_p1()) {
      lethal_=true;
      lethalFound=true;
    }
  }
  if (!lethalFound) {
    boolean heroAbilityUsable=false;
    if (!boardStateNode.data_.getHero_p0().hasBeenUsed()) {
      for (int i=0; i <= boardStateNode.data_.getNumMinions_p0(); ++i) {
        HearthTreeNode newState=new HearthTreeNode((BoardState)boardStateNode.data_.deepCopy());
        newState=newState.data_.getHero_p0().useHeroAbility(0,0,i,newState,deck_);
        if (newState != null) {
          if (newState instanceof StopNode) {
          }
 else {
            newState=this.doMoves(newState,scoreFunc);
            if (newState != null)             boardStateNode.addChild(newState);
            heroAbilityUsable=true;
          }
        }
      }
      for (int i=0; i <= boardStateNode.data_.getNumMinions_p1(); ++i) {
        HearthTreeNode newState=new HearthTreeNode((BoardState)boardStateNode.data_.deepCopy());
        newState=newState.data_.getHero_p0().useHeroAbility(0,1,i,newState,deck_);
        if (newState != null) {
          if (newState instanceof StopNode) {
          }
 else {
            newState=this.doMoves(newState,scoreFunc);
            if (newState != null)             boardStateNode.addChild(newState);
            heroAbilityUsable=true;
          }
        }
      }
      if (heroAbilityUsable) {
        HearthTreeNode newState=new HearthTreeNode((BoardState)boardStateNode.data_.deepCopy());
        newState.data_.getHero_p0().hasBeenUsed(true);
        newState=this.doMoves(newState,scoreFunc);
        if (newState != null)         boardStateNode.addChild(newState);
      }
    }
    boolean allUsed=true;
    for (    final Card card : boardStateNode.data_.getCards_hand_p0()) {
      allUsed=allUsed && card.hasBeenUsed();
    }
    if (!allUsed) {
      HearthTreeNode newState=new HearthTreeNode((BoardState)boardStateNode.data_.deepCopy());
      for (      Card card : newState.data_.getCards_hand_p0()) {
        card.hasBeenUsed(true);
      }
      newState=this.doMoves(newState,scoreFunc);
      if (newState != null)       boardStateNode.addChild(newState);
    }
    int mana=boardStateNode.data_.getMana_p0();
    for (int ic=0; ic < boardStateNode.data_.getNumCards_hand(); ++ic) {
      if (boardStateNode.data_.getCard_hand_p0(ic).getMana() <= mana && !boardStateNode.data_.getCard_hand_p0(ic).hasBeenUsed()) {
        for (int i=0; i <= boardStateNode.data_.getNumMinions_p0() + 1; ++i) {
          HearthTreeNode newState=new HearthTreeNode((BoardState)boardStateNode.data_.deepCopy());
          Card card=newState.data_.getCard_hand_p0(ic);
          newState=card.useOn(ic,0,i,newState,deck_);
          if (newState != null) {
            if (newState instanceof StopNode) {
            }
 else {
              newState=this.doMoves(newState,scoreFunc);
              if (newState != null)               boardStateNode.addChild(newState);
            }
          }
        }
        for (int i=0; i <= boardStateNode.data_.getNumMinions_p1() + 1; ++i) {
          HearthTreeNode newState=new HearthTreeNode((BoardState)boardStateNode.data_.deepCopy());
          Card card=newState.data_.getCard_hand_p0(ic);
          newState=card.useOn(ic,1,i,newState,deck_);
          if (newState != null) {
            if (newState instanceof StopNode) {
            }
 else {
              newState=this.doMoves(newState,scoreFunc);
              if (newState != null)               boardStateNode.addChild(newState);
            }
          }
        }
      }
    }
    boolean allAttacked=true;
    for (    final Minion minion : boardStateNode.data_.getMinions_p0()) {
      allAttacked=allAttacked && minion.hasAttacked();
    }
    if (!allAttacked) {
      HearthTreeNode newState=new HearthTreeNode((BoardState)boardStateNode.data_.deepCopy());
      for (      Minion minion : newState.data_.getMinions_p0()) {
        minion.hasAttacked(true);
      }
      newState=this.doMoves(newState,scoreFunc);
      if (newState != null)       boardStateNode.addChild(newState);
    }
    for (int ic=1; ic < boardStateNode.data_.getNumMinions_p0() + 1; ++ic) {
      final Minion minion=boardStateNode.data_.getMinion_p0(ic - 1);
      if (minion.hasAttacked()) {
        continue;
      }
      ArrayList<Integer> attackable=boardStateNode.data_.getAttackableMinions_p1();
      for (      final Integer integer : attackable) {
        int i=integer.intValue();
        HearthTreeNode newState=new HearthTreeNode((BoardState)boardStateNode.data_.deepCopy());
        Minion tempMinion=newState.data_.getMinion_p0(ic - 1);
        newState=tempMinion.attack(ic,1,i,newState,deck_);
        if (newState != null) {
          if (newState instanceof StopNode) {
          }
 else {
            newState=this.doMoves(newState,scoreFunc);
            if (newState != null)             boardStateNode.addChild(newState);
          }
        }
      }
    }
  }
  if (boardStateNode.isLeaf()) {
    boardStateNode.setScore(scoreFunc.apply(boardStateNode.data_));
    boardStateNode.setNumNodesTries(1);
  }
 else {
    double tmpScore=-1.e300;
    int tmpNumNodesTried=0;
    Iterator<HearthTreeNode> iter=boardStateNode.getChildren().iterator();
    while (iter.hasNext()) {
      HearthTreeNode child=iter.next();
      tmpNumNodesTried+=child.getNumNodesTried();
      if (child.getScore() > tmpScore) {
        tmpScore=child.getScore();
      }
 else {
        iter.remove();
      }
    }
    boardStateNode.setScore(tmpScore);
    boardStateNode.setNumNodesTries(tmpNumNodesTried);
  }
  return boardStateNode;
}","/** 
 * Recursively generate all possible moves This function recursively generates all possible moves that can be done starting from a given BoardState. While generating the moves, it applies the scoring function to each BoardState generated, and it will only keep the highest scoring branch. The results are stored in a tree structure and returned as a tree of BoardState class.
 * @param boardStateNode The initial BoardState wrapped in a HearthTreeNode.
 * @param scoreFunc The scoring function for AI.
 * @return boardStateNode manipulated such that all subsequent actions are children of the original boardStateNode input.
 */
public HearthTreeNode doMoves(HearthTreeNode boardStateNode,StateFunction<BoardState> scoreFunc) throws HSException {
  if (lethal_) {
    return null;
  }
  if (timedOut_) {
    return null;
  }
  if (System.currentTimeMillis() - startTime_ > maxTime_) {
    timedOut_=true;
    return null;
  }
  if (boardStateNode.numChildren() > 0) {
    for (    HearthTreeNode child : boardStateNode.getChildren()) {
      this.doMoves(child,scoreFunc);
    }
    return boardStateNode;
  }
  boolean lethalFound=false;
  if ((!boardStateNode.data_.isAlive_p0()) || (!boardStateNode.data_.isAlive_p1())) {
    if (!boardStateNode.data_.isAlive_p1()) {
      lethal_=true;
      lethalFound=true;
    }
  }
  if (!lethalFound) {
    boolean heroAbilityUsable=false;
    if (!boardStateNode.data_.getHero_p0().hasBeenUsed()) {
      for (int i=0; i <= boardStateNode.data_.getNumMinions_p0(); ++i) {
        HearthTreeNode newState=new HearthTreeNode((BoardState)boardStateNode.data_.deepCopy());
        newState=newState.data_.getHero_p0().useHeroAbility(0,0,i,newState,deck_);
        if (newState != null) {
          if (newState instanceof StopNode) {
          }
 else {
            newState=this.doMoves(newState,scoreFunc);
            if (newState != null)             boardStateNode.addChild(newState);
            heroAbilityUsable=true;
          }
        }
      }
      for (int i=0; i <= boardStateNode.data_.getNumMinions_p1(); ++i) {
        HearthTreeNode newState=new HearthTreeNode((BoardState)boardStateNode.data_.deepCopy());
        newState=newState.data_.getHero_p0().useHeroAbility(0,1,i,newState,deck_);
        if (newState != null) {
          if (newState instanceof StopNode) {
          }
 else {
            newState=this.doMoves(newState,scoreFunc);
            if (newState != null)             boardStateNode.addChild(newState);
            heroAbilityUsable=true;
          }
        }
      }
      if (heroAbilityUsable) {
        HearthTreeNode newState=new HearthTreeNode((BoardState)boardStateNode.data_.deepCopy());
        newState.data_.getHero_p0().hasBeenUsed(true);
        newState=this.doMoves(newState,scoreFunc);
        if (newState != null)         boardStateNode.addChild(newState);
      }
    }
    boolean allUsed=true;
    for (    final Card card : boardStateNode.data_.getCards_hand_p0()) {
      allUsed=allUsed && card.hasBeenUsed();
    }
    if (!allUsed) {
      HearthTreeNode newState=new HearthTreeNode((BoardState)boardStateNode.data_.deepCopy());
      for (      Card card : newState.data_.getCards_hand_p0()) {
        card.hasBeenUsed(true);
      }
      newState=this.doMoves(newState,scoreFunc);
      if (newState != null)       boardStateNode.addChild(newState);
    }
    int mana=boardStateNode.data_.getMana_p0();
    for (int ic=0; ic < boardStateNode.data_.getNumCards_hand(); ++ic) {
      if (boardStateNode.data_.getCard_hand_p0(ic).getMana() <= mana && !boardStateNode.data_.getCard_hand_p0(ic).hasBeenUsed()) {
        for (int i=0; i <= boardStateNode.data_.getNumMinions_p0() + 1; ++i) {
          HearthTreeNode newState=new HearthTreeNode((BoardState)boardStateNode.data_.deepCopy());
          Card card=newState.data_.getCard_hand_p0(ic);
          newState=card.useOn(ic,0,i,newState,deck_);
          if (newState != null) {
            if (newState instanceof StopNode) {
            }
 else {
              newState=this.doMoves(newState,scoreFunc);
              if (newState != null)               boardStateNode.addChild(newState);
            }
          }
        }
        for (int i=0; i <= boardStateNode.data_.getNumMinions_p1() + 1; ++i) {
          HearthTreeNode newState=new HearthTreeNode((BoardState)boardStateNode.data_.deepCopy());
          Card card=newState.data_.getCard_hand_p0(ic);
          newState=card.useOn(ic,1,i,newState,deck_);
          if (newState != null) {
            if (newState instanceof StopNode) {
            }
 else {
              newState=this.doMoves(newState,scoreFunc);
              if (newState != null)               boardStateNode.addChild(newState);
            }
          }
        }
      }
    }
    boolean allAttacked=true;
    for (    final Minion minion : boardStateNode.data_.getMinions_p0()) {
      allAttacked=allAttacked && minion.hasAttacked();
    }
    if (!allAttacked) {
      HearthTreeNode newState=new HearthTreeNode((BoardState)boardStateNode.data_.deepCopy());
      for (      Minion minion : newState.data_.getMinions_p0()) {
        minion.hasAttacked(true);
      }
      newState=this.doMoves(newState,scoreFunc);
      if (newState != null)       boardStateNode.addChild(newState);
    }
    for (int ic=1; ic < boardStateNode.data_.getNumMinions_p0() + 1; ++ic) {
      final Minion minion=boardStateNode.data_.getMinion_p0(ic - 1);
      if (minion.hasAttacked()) {
        continue;
      }
      ArrayList<Integer> attackable=boardStateNode.data_.getAttackableMinions_p1();
      for (      final Integer integer : attackable) {
        int i=integer.intValue();
        HearthTreeNode newState=new HearthTreeNode((BoardState)boardStateNode.data_.deepCopy());
        Minion tempMinion=newState.data_.getMinion_p0(ic - 1);
        newState=tempMinion.attack(ic,1,i,newState,deck_);
        if (newState != null) {
          if (newState instanceof StopNode) {
          }
 else {
            newState=this.doMoves(newState,scoreFunc);
            if (newState != null)             boardStateNode.addChild(newState);
          }
        }
      }
    }
  }
  if (boardStateNode.isLeaf()) {
    boardStateNode.setScore(scoreFunc.apply(boardStateNode.data_));
    boardStateNode.setNumNodesTries(1);
  }
 else {
    double tmpScore=-1.e300;
    int tmpNumNodesTried=0;
    Iterator<HearthTreeNode> iter=boardStateNode.getChildren().iterator();
    HearthTreeNode bestBranch=null;
    while (iter.hasNext()) {
      HearthTreeNode child=iter.next();
      tmpNumNodesTried+=child.getNumNodesTried();
      if (child.getScore() > tmpScore) {
        tmpScore=child.getScore();
        bestBranch=child;
      }
    }
    boardStateNode.clearChildren();
    boardStateNode.addChild(bestBranch);
    boardStateNode.setScore(tmpScore);
    boardStateNode.setNumNodesTries(tmpNumNodesTried);
  }
  return boardStateNode;
}",0.9877800407331976
112822,"@Before public void setup(){
  board=new HearthTreeNode(new BoardState(new Priest(),new Hero()));
  Minion minion0_0=new BoulderfistOgre();
  Minion minion0_1=new RaidLeader();
  Minion minion1_0=new BoulderfistOgre();
  Minion minion1_1=new RaidLeader();
  board.data_.placeCard_hand_p0(minion0_0);
  board.data_.placeCard_hand_p0(minion0_1);
  board.data_.placeCard_hand_p1(minion1_0);
  board.data_.placeCard_hand_p1(minion1_1);
  Card cards[]=new Card[10];
  for (int index=0; index < 10; ++index) {
    cards[index]=new TheCoin();
  }
  deck=new Deck(cards);
  Card fb=new WildGrowth();
  board.data_.placeCard_hand_p0(fb);
  board.data_.setMana_p0((byte)8);
  board.data_.setMana_p1((byte)8);
  board.data_.setMaxMana_p0((byte)8);
  board.data_.setMaxMana_p1((byte)8);
  HearthTreeNode tmpBoard=new HearthTreeNode(board.data_.flipPlayers());
  try {
    tmpBoard.data_.getCard_hand_p0(0).useOn(0,0,1,tmpBoard,deck);
    tmpBoard.data_.getCard_hand_p0(0).useOn(0,0,1,tmpBoard,deck);
  }
 catch (  HSInvalidPlayerIndexException e) {
    e.printStackTrace();
  }
  board=new HearthTreeNode(tmpBoard.data_.flipPlayers());
  try {
    board.data_.getCard_hand_p0(0).useOn(0,0,1,board,deck);
    board.data_.getCard_hand_p0(0).useOn(0,0,1,board,deck);
  }
 catch (  HSInvalidPlayerIndexException e) {
    e.printStackTrace();
  }
  board.data_.resetMana();
  board.data_.resetMinions();
}","@Before public void setup(){
  board=new HearthTreeNode(new BoardState(new Priest(),new Hero()));
  Minion minion0_0=new ChillwindYeti();
  Minion minion0_1=new ChillwindYeti();
  Minion minion1_0=new ChillwindYeti();
  Minion minion1_1=new ChillwindYeti();
  board.data_.placeCard_hand_p0(minion0_0);
  board.data_.placeCard_hand_p0(minion0_1);
  board.data_.placeCard_hand_p1(minion1_0);
  board.data_.placeCard_hand_p1(minion1_1);
  Card cards[]=new Card[10];
  for (int index=0; index < 10; ++index) {
    cards[index]=new TheCoin();
  }
  deck=new Deck(cards);
  board.data_.setMana_p0((byte)8);
  board.data_.setMana_p1((byte)8);
  board.data_.setMaxMana_p0((byte)8);
  board.data_.setMaxMana_p1((byte)8);
  HearthTreeNode tmpBoard=new HearthTreeNode(board.data_.flipPlayers());
  try {
    tmpBoard.data_.getCard_hand_p0(0).useOn(0,0,1,tmpBoard,deck);
    tmpBoard.data_.getCard_hand_p0(0).useOn(0,0,1,tmpBoard,deck);
  }
 catch (  HSInvalidPlayerIndexException e) {
    e.printStackTrace();
  }
  board=new HearthTreeNode(tmpBoard.data_.flipPlayers());
  try {
    board.data_.getCard_hand_p0(0).useOn(0,0,1,board,deck);
    board.data_.getCard_hand_p0(0).useOn(0,0,1,board,deck);
  }
 catch (  HSInvalidPlayerIndexException e) {
    e.printStackTrace();
  }
  board.data_.resetMana();
  board.data_.resetMinions();
}",0.938444526354589
112823,"@Test public void test0() throws HSException {
  Minion minion=board.data_.getMinion_p0(0);
  HearthTreeNode ret=minion.attack(0,1,0,board,deck);
  assertFalse(ret == null);
  assertEquals(board.data_.getNumCards_hand(),1);
  assertEquals(board.data_.getNumMinions_p0(),2);
  assertEquals(board.data_.getNumMinions_p1(),2);
  assertEquals(board.data_.getMana_p0(),8);
  assertEquals(board.data_.getMana_p1(),8);
  assertEquals(board.data_.getHero_p0().getHealth(),30);
  assertEquals(board.data_.getHero_p1().getHealth(),28);
  assertEquals(board.data_.getMinion_p0(0).getHealth(),2);
  assertEquals(board.data_.getMinion_p0(1).getHealth(),7);
  assertEquals(board.data_.getMinion_p1(0).getHealth(),2);
  assertEquals(board.data_.getMinion_p1(1).getHealth(),7);
  assertEquals(board.data_.getMinion_p0(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p0(1).getAttack(),7);
  assertEquals(board.data_.getMinion_p1(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p1(1).getAttack(),7);
  Hero hero=board.data_.getHero_p0();
  ret=hero.useHeroAbility(0,1,0,board,deck);
  assertEquals(board.data_.getNumCards_hand(),1);
  assertEquals(board.data_.getNumMinions_p0(),2);
  assertEquals(board.data_.getNumMinions_p1(),2);
  assertEquals(board.data_.getMana_p0(),6);
  assertEquals(board.data_.getMana_p1(),8);
  assertEquals(board.data_.getHero_p0().getHealth(),30);
  assertEquals(board.data_.getHero_p1().getHealth(),30);
  assertEquals(board.data_.getMinion_p0(0).getHealth(),2);
  assertEquals(board.data_.getMinion_p0(1).getHealth(),7);
  assertEquals(board.data_.getMinion_p1(0).getHealth(),2);
  assertEquals(board.data_.getMinion_p1(1).getHealth(),7);
  assertEquals(board.data_.getMinion_p0(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p0(1).getAttack(),7);
  assertEquals(board.data_.getMinion_p1(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p1(1).getAttack(),7);
  minion.hasAttacked(false);
  ret=minion.attack(0,1,2,board,deck);
  assertEquals(board.data_.getNumCards_hand(),1);
  assertEquals(board.data_.getNumMinions_p0(),2);
  assertEquals(board.data_.getNumMinions_p1(),2);
  assertEquals(board.data_.getMana_p0(),6);
  assertEquals(board.data_.getMana_p1(),8);
  assertEquals(board.data_.getHero_p0().getHealth(),30);
  assertEquals(board.data_.getHero_p1().getHealth(),30);
  assertEquals(board.data_.getMinion_p0(0).getHealth(),0);
  assertEquals(board.data_.getMinion_p0(1).getHealth(),7);
  assertEquals(board.data_.getMinion_p1(0).getHealth(),2);
  assertEquals(board.data_.getMinion_p1(1).getHealth(),5);
  assertEquals(board.data_.getMinion_p0(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p0(1).getAttack(),6);
  assertEquals(board.data_.getMinion_p1(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p1(1).getAttack(),7);
  minion.hasAttacked(false);
  ret=hero.useHeroAbility(0,1,2,board,deck);
  assertEquals(board.data_.getNumCards_hand(),1);
  assertEquals(board.data_.getNumMinions_p0(),2);
  assertEquals(board.data_.getNumMinions_p1(),2);
  assertEquals(board.data_.getMana_p0(),4);
  assertEquals(board.data_.getMana_p1(),8);
  assertEquals(board.data_.getHero_p0().getHealth(),30);
  assertEquals(board.data_.getHero_p1().getHealth(),30);
  assertEquals(board.data_.getMinion_p0(0).getHealth(),0);
  assertEquals(board.data_.getMinion_p0(1).getHealth(),7);
  assertEquals(board.data_.getMinion_p1(0).getHealth(),2);
  assertEquals(board.data_.getMinion_p1(1).getHealth(),7);
  assertEquals(board.data_.getMinion_p0(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p0(1).getAttack(),6);
  assertEquals(board.data_.getMinion_p1(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p1(1).getAttack(),7);
}","@Test public void test0() throws HSException {
  Minion minion=board.data_.getMinion_p0(0);
  HearthTreeNode ret=minion.attack(0,1,0,board,deck);
  assertFalse(ret == null);
  assertEquals(board.data_.getNumCards_hand(),0);
  assertEquals(board.data_.getNumMinions_p0(),2);
  assertEquals(board.data_.getNumMinions_p1(),2);
  assertEquals(board.data_.getMana_p0(),8);
  assertEquals(board.data_.getMana_p1(),8);
  assertEquals(board.data_.getHero_p0().getHealth(),30);
  assertEquals(board.data_.getHero_p1().getHealth(),26);
  assertEquals(board.data_.getMinion_p0(0).getHealth(),5);
  assertEquals(board.data_.getMinion_p0(1).getHealth(),5);
  assertEquals(board.data_.getMinion_p1(0).getHealth(),5);
  assertEquals(board.data_.getMinion_p1(1).getHealth(),5);
  assertEquals(board.data_.getMinion_p0(0).getAttack(),4);
  assertEquals(board.data_.getMinion_p0(1).getAttack(),4);
  assertEquals(board.data_.getMinion_p1(0).getAttack(),4);
  assertEquals(board.data_.getMinion_p1(1).getAttack(),4);
  Hero hero=board.data_.getHero_p0();
  ret=hero.useHeroAbility(0,1,0,board,deck);
  assertEquals(board.data_.getNumCards_hand(),0);
  assertEquals(board.data_.getNumMinions_p0(),2);
  assertEquals(board.data_.getNumMinions_p1(),2);
  assertEquals(board.data_.getMana_p0(),6);
  assertEquals(board.data_.getMana_p1(),8);
  assertEquals(board.data_.getHero_p0().getHealth(),30);
  assertEquals(board.data_.getHero_p1().getHealth(),28);
  assertEquals(board.data_.getMinion_p0(0).getHealth(),5);
  assertEquals(board.data_.getMinion_p0(1).getHealth(),5);
  assertEquals(board.data_.getMinion_p1(0).getHealth(),5);
  assertEquals(board.data_.getMinion_p1(1).getHealth(),5);
  assertEquals(board.data_.getMinion_p0(0).getAttack(),4);
  assertEquals(board.data_.getMinion_p0(1).getAttack(),4);
  assertEquals(board.data_.getMinion_p1(0).getAttack(),4);
  assertEquals(board.data_.getMinion_p1(1).getAttack(),4);
  minion.hasAttacked(false);
  ret=minion.attack(0,1,2,board,deck);
  assertEquals(board.data_.getNumCards_hand(),0);
  assertEquals(board.data_.getNumMinions_p0(),2);
  assertEquals(board.data_.getNumMinions_p1(),2);
  assertEquals(board.data_.getMana_p0(),6);
  assertEquals(board.data_.getMana_p1(),8);
  assertEquals(board.data_.getHero_p0().getHealth(),30);
  assertEquals(board.data_.getHero_p1().getHealth(),28);
  assertEquals(board.data_.getMinion_p0(0).getHealth(),1);
  assertEquals(board.data_.getMinion_p0(1).getHealth(),5);
  assertEquals(board.data_.getMinion_p1(0).getHealth(),5);
  assertEquals(board.data_.getMinion_p1(1).getHealth(),1);
  assertEquals(board.data_.getMinion_p0(0).getAttack(),4);
  assertEquals(board.data_.getMinion_p0(1).getAttack(),4);
  assertEquals(board.data_.getMinion_p1(0).getAttack(),4);
  assertEquals(board.data_.getMinion_p1(1).getAttack(),4);
  minion.hasAttacked(false);
  ret=hero.useHeroAbility(0,1,2,board,deck);
  assertEquals(board.data_.getNumCards_hand(),0);
  assertEquals(board.data_.getNumMinions_p0(),2);
  assertEquals(board.data_.getNumMinions_p1(),2);
  assertEquals(board.data_.getMana_p0(),4);
  assertEquals(board.data_.getMana_p1(),8);
  assertEquals(board.data_.getHero_p0().getHealth(),30);
  assertEquals(board.data_.getHero_p1().getHealth(),28);
  assertEquals(board.data_.getMinion_p0(0).getHealth(),1);
  assertEquals(board.data_.getMinion_p0(1).getHealth(),5);
  assertEquals(board.data_.getMinion_p1(0).getHealth(),5);
  assertEquals(board.data_.getMinion_p1(1).getHealth(),3);
  assertEquals(board.data_.getMinion_p0(0).getAttack(),4);
  assertEquals(board.data_.getMinion_p0(1).getAttack(),4);
  assertEquals(board.data_.getMinion_p1(0).getAttack(),4);
  assertEquals(board.data_.getMinion_p1(1).getAttack(),4);
}",0.4377705627705627
112824,"public double boardScore(BoardState board){
  LinkedList<Minion> myBoardCards;
  LinkedList<Minion> opBoardCards;
  LinkedList<Card> myHandCards;
  myBoardCards=board.getMinions_p0();
  opBoardCards=board.getMinions_p1();
  myHandCards=board.getCards_hand_p0();
  double myScore=0.0;
  for (  final Minion card : myBoardCards) {
    myScore+=card.getAttack() * my_wAttack_ + card.getHealth() * my_wHealth_ + (card.getTaunt() ? 1.0 : 0.0) * wTaunt_ + (card.getAttack() + card.getHealth()) * my_wDivineShield_;
  }
  double opScore=0.0;
  for (  final Minion card : opBoardCards) {
    opScore+=card.getAttack() * enemy_wAttack_ + card.getHealth() * enemy_wHealth_ + (card.getTaunt() ? 1.0 : 0.0) * wTaunt_ + (card.getAttack() + card.getHealth()) * enemy_wDivineShield_;
  }
  double handScore=0.0;
  for (  final Card card : myHandCards) {
    if (card instanceof SpellDamage)     handScore+=((SpellDamage)card).getAttack() * wSd_mult_ + wSd_add_;
 else     handScore+=card.getMana() * wMana_;
  }
  double heroScore=my_wHeroHealth_ * board.getHero_p0().getHealth() - enemy_wHeroHealth_ * board.getHero_p1().getHealth();
  if (board.getHero_p1().getHealth() <= 0) {
    heroScore+=100000.0;
  }
  if (board.getHero_p0().getHealth() <= 0) {
    heroScore-=100000000.0;
  }
  double minionScore=0.0;
  minionScore+=my_wNumMinions_ * (board.getNumMinions_p0());
  minionScore-=enemy_wNumMinions_ * (board.getNumMinions_p1());
  double score=myScore - opScore + handScore + heroScore + minionScore;
  return score;
}","public double boardScore(BoardState board){
  LinkedList<Minion> myBoardCards;
  LinkedList<Minion> opBoardCards;
  LinkedList<Card> myHandCards;
  myBoardCards=board.getMinions_p0();
  opBoardCards=board.getMinions_p1();
  myHandCards=board.getCards_hand_p0();
  double myScore=0.0;
  for (  final Minion minion : myBoardCards) {
    myScore+=minion.getAttack() * my_wAttack_;
    myScore+=minion.getHealth() * my_wHealth_;
    myScore+=(minion.getTaunt() ? 1.0 : 0.0) * wTaunt_;
    if (minion.getDivineShield())     myScore+=((minion.getAttack() + minion.getHealth()) * my_wDivineShield_);
  }
  double opScore=0.0;
  for (  final Minion minion : opBoardCards) {
    opScore+=minion.getAttack() * enemy_wAttack_;
    opScore+=minion.getHealth() * enemy_wHealth_;
    opScore+=(minion.getTaunt() ? 1.0 : 0.0) * wTaunt_;
    if (minion.getDivineShield())     opScore+=(minion.getAttack() + minion.getHealth()) * enemy_wDivineShield_;
  }
  double handScore=0.0;
  for (  final Card card : myHandCards) {
    if (card instanceof SpellDamage)     handScore+=((SpellDamage)card).getAttack() * wSd_mult_ + wSd_add_;
 else     handScore+=card.getMana() * wMana_;
  }
  double heroScore=my_wHeroHealth_ * board.getHero_p0().getHealth() - enemy_wHeroHealth_ * board.getHero_p1().getHealth();
  if (board.getHero_p1().getHealth() <= 0) {
    heroScore+=100000.0;
  }
  if (board.getHero_p0().getHealth() <= 0) {
    heroScore-=100000000.0;
  }
  double minionScore=0.0;
  minionScore+=my_wNumMinions_ * (board.getNumMinions_p0());
  minionScore-=enemy_wNumMinions_ * (board.getNumMinions_p1());
  double score=myScore - opScore + handScore + heroScore + minionScore;
  return score;
}",0.9040150564617316
112825,"/** 
 * Called when this minion takes damage Always use this function to take damage... it properly notifies all others of its damage and possibly of its death
 * @param damage The amount of damage to take
 * @param attackerPlayerIndex The player index of the attacker.  This is needed to do things like +spell damage.
 * @param thisPlayerIndex The player index of this minion
 * @param thisMinionIndex The minion index of this minion
 * @param boardState 
 * @param deck
 * @param isSpellDamage True if this is a spell damage
 * @throws HSInvalidPlayerIndexException
 */
public void takeDamage(byte damage,int attackerPlayerIndex,int thisPlayerIndex,int thisMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck,boolean isSpellDamage) throws HSInvalidPlayerIndexException {
  if (!divineShield_) {
    byte totalDamage=isSpellDamage ? (byte)(damage + boardState.data_.getSpellDamage(attackerPlayerIndex)) : damage;
    health_=(byte)(health_ - totalDamage);
    HearthTreeNode<BoardState> toRet=boardState;
    toRet=toRet.data_.getHero_p0().minionDamagedEvent(0,0,thisPlayerIndex,thisMinionIndex,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p0(); ++j) {
      toRet=toRet.data_.getMinion_p0(j).minionDamagedEvent(0,j + 1,thisPlayerIndex,thisMinionIndex,toRet,deck);
    }
    toRet=toRet.data_.getHero_p1().minionDamagedEvent(1,0,thisPlayerIndex,thisMinionIndex,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p1(); ++j) {
      toRet=toRet.data_.getMinion_p1(j).minionDamagedEvent(1,j + 1,thisPlayerIndex,thisMinionIndex,toRet,deck);
    }
    if (health_ <= 0) {
      this.destroyed(thisPlayerIndex,thisMinionIndex,boardState,deck);
    }
  }
 else {
    divineShield_=false;
  }
}","/** 
 * Called when this minion takes damage Always use this function to take damage... it properly notifies all others of its damage and possibly of its death
 * @param damage The amount of damage to take
 * @param attackerPlayerIndex The player index of the attacker.  This is needed to do things like +spell damage.
 * @param thisPlayerIndex The player index of this minion
 * @param thisMinionIndex The minion index of this minion
 * @param boardState 
 * @param deck
 * @param isSpellDamage True if this is a spell damage
 * @throws HSInvalidPlayerIndexException
 */
public void takeDamage(byte damage,int attackerPlayerIndex,int thisPlayerIndex,int thisMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck,boolean isSpellDamage) throws HSInvalidPlayerIndexException {
  if (!divineShield_) {
    byte totalDamage=isSpellDamage ? (byte)(damage + boardState.data_.getSpellDamage(attackerPlayerIndex)) : damage;
    health_=(byte)(health_ - totalDamage);
    HearthTreeNode<BoardState> toRet=boardState;
    toRet=toRet.data_.getHero_p0().minionDamagedEvent(0,0,thisPlayerIndex,thisMinionIndex,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p0(); ++j) {
      toRet=toRet.data_.getMinion_p0(j).minionDamagedEvent(0,j + 1,thisPlayerIndex,thisMinionIndex,toRet,deck);
    }
    toRet=toRet.data_.getHero_p1().minionDamagedEvent(1,0,thisPlayerIndex,thisMinionIndex,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p1(); ++j) {
      toRet=toRet.data_.getMinion_p1(j).minionDamagedEvent(1,j + 1,thisPlayerIndex,thisMinionIndex,toRet,deck);
    }
    if (health_ <= 0) {
      this.destroyed(thisPlayerIndex,thisMinionIndex,boardState,deck);
    }
  }
 else {
    if (damage > 0)     divineShield_=false;
  }
}",0.9942229924898902
112826,"@Test public void test2() throws HSInvalidPlayerIndexException {
  Card theCard=board.data_.getCard_hand_p0(0);
  HearthTreeNode<BoardState> ret=theCard.useOn(0,0,3,board,deck);
  assertFalse(ret == null);
  assertEquals(board.data_.getNumCards_hand(),0);
  assertEquals(board.data_.getNumMinions_p0(),3);
  assertEquals(board.data_.getNumMinions_p1(),3);
  assertEquals(board.data_.getMana_p0(),5);
  assertEquals(board.data_.getMana_p1(),8);
  assertEquals(board.data_.getHero_p0().getHealth(),30);
  assertEquals(board.data_.getHero_p1().getHealth(),30);
  assertEquals(board.data_.getMinion_p0(0).getHealth(),2);
  assertEquals(board.data_.getMinion_p0(1).getHealth(),7);
  assertEquals(board.data_.getMinion_p0(2).getHealth(),1);
  assertEquals(board.data_.getMinion_p1(0).getHealth(),1);
  assertEquals(board.data_.getMinion_p1(1).getHealth(),2);
  assertEquals(board.data_.getMinion_p1(2).getHealth(),7);
  assertEquals(board.data_.getMinion_p0(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p0(1).getAttack(),7);
  assertEquals(board.data_.getMinion_p0(2).getAttack(),4);
  assertEquals(board.data_.getMinion_p1(0).getAttack(),4);
  assertEquals(board.data_.getMinion_p1(1).getAttack(),2);
  assertEquals(board.data_.getMinion_p1(2).getAttack(),7);
  assertTrue(board.data_.getMinion_p1(0).getDivineShield());
  assertTrue(board.data_.getMinion_p0(2).getDivineShield());
  Minion m1=board.data_.getMinion_p0(2);
  m1.hasAttacked(false);
  ret=m1.attack(3,1,3,board,deck);
  assertEquals(board.data_.getNumCards_hand(),0);
  assertEquals(board.data_.getNumMinions_p0(),3);
  assertEquals(board.data_.getNumMinions_p1(),3);
  assertEquals(board.data_.getMana_p0(),5);
  assertEquals(board.data_.getMana_p1(),8);
  assertEquals(board.data_.getHero_p0().getHealth(),30);
  assertEquals(board.data_.getHero_p1().getHealth(),30);
  assertEquals(board.data_.getMinion_p0(0).getHealth(),2);
  assertEquals(board.data_.getMinion_p0(1).getHealth(),7);
  assertEquals(board.data_.getMinion_p0(2).getHealth(),1);
  assertEquals(board.data_.getMinion_p1(0).getHealth(),1);
  assertEquals(board.data_.getMinion_p1(1).getHealth(),2);
  assertEquals(board.data_.getMinion_p1(2).getHealth(),3);
  assertEquals(board.data_.getMinion_p0(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p0(1).getAttack(),7);
  assertEquals(board.data_.getMinion_p0(2).getAttack(),4);
  assertEquals(board.data_.getMinion_p1(0).getAttack(),4);
  assertEquals(board.data_.getMinion_p1(1).getAttack(),2);
  assertEquals(board.data_.getMinion_p1(2).getAttack(),7);
  assertTrue(board.data_.getMinion_p1(0).getDivineShield());
  assertFalse(board.data_.getMinion_p0(2).getDivineShield());
  Minion m2=board.data_.getMinion_p0(1);
  m2.hasAttacked(false);
  ret=m2.attack(2,1,1,board,deck);
  assertEquals(board.data_.getNumCards_hand(),0);
  assertEquals(board.data_.getNumMinions_p0(),3);
  assertEquals(board.data_.getNumMinions_p1(),3);
  assertEquals(board.data_.getMana_p0(),5);
  assertEquals(board.data_.getMana_p1(),8);
  assertEquals(board.data_.getHero_p0().getHealth(),30);
  assertEquals(board.data_.getHero_p1().getHealth(),30);
  assertEquals(board.data_.getMinion_p0(0).getHealth(),2);
  assertEquals(board.data_.getMinion_p0(1).getHealth(),3);
  assertEquals(board.data_.getMinion_p0(2).getHealth(),1);
  assertEquals(board.data_.getMinion_p1(0).getHealth(),1);
  assertEquals(board.data_.getMinion_p1(1).getHealth(),2);
  assertEquals(board.data_.getMinion_p1(2).getHealth(),3);
  assertEquals(board.data_.getMinion_p0(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p0(1).getAttack(),7);
  assertEquals(board.data_.getMinion_p0(2).getAttack(),4);
  assertEquals(board.data_.getMinion_p1(0).getAttack(),4);
  assertEquals(board.data_.getMinion_p1(1).getAttack(),2);
  assertEquals(board.data_.getMinion_p1(2).getAttack(),7);
  assertFalse(board.data_.getMinion_p1(0).getDivineShield());
  assertFalse(board.data_.getMinion_p0(2).getDivineShield());
}","@Test public void test2() throws HSInvalidPlayerIndexException {
  Card theCard=board.data_.getCard_hand_p0(0);
  HearthTreeNode<BoardState> ret=theCard.useOn(0,0,3,board,deck);
  assertFalse(ret == null);
  assertEquals(board.data_.getNumCards_hand(),0);
  assertEquals(board.data_.getNumMinions_p0(),3);
  assertEquals(board.data_.getNumMinions_p1(),3);
  assertEquals(board.data_.getMana_p0(),5);
  assertEquals(board.data_.getMana_p1(),8);
  assertEquals(board.data_.getHero_p0().getHealth(),30);
  assertEquals(board.data_.getHero_p1().getHealth(),30);
  assertEquals(board.data_.getMinion_p0(0).getHealth(),2);
  assertEquals(board.data_.getMinion_p0(1).getHealth(),7);
  assertEquals(board.data_.getMinion_p0(2).getHealth(),1);
  assertEquals(board.data_.getMinion_p1(0).getHealth(),1);
  assertEquals(board.data_.getMinion_p1(1).getHealth(),2);
  assertEquals(board.data_.getMinion_p1(2).getHealth(),7);
  assertEquals(board.data_.getMinion_p0(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p0(1).getAttack(),7);
  assertEquals(board.data_.getMinion_p0(2).getAttack(),4);
  assertEquals(board.data_.getMinion_p1(0).getAttack(),4);
  assertEquals(board.data_.getMinion_p1(1).getAttack(),2);
  assertEquals(board.data_.getMinion_p1(2).getAttack(),7);
  assertTrue(board.data_.getMinion_p1(0).getDivineShield());
  assertTrue(board.data_.getMinion_p0(2).getDivineShield());
  Minion m0=board.data_.getMinion_p0(2);
  m0.hasAttacked(false);
  ret=m0.attack(3,1,0,board,deck);
  assertEquals(board.data_.getNumCards_hand(),0);
  assertEquals(board.data_.getNumMinions_p0(),3);
  assertEquals(board.data_.getNumMinions_p1(),3);
  assertEquals(board.data_.getMana_p0(),5);
  assertEquals(board.data_.getMana_p1(),8);
  assertEquals(board.data_.getHero_p0().getHealth(),30);
  assertEquals(board.data_.getHero_p1().getHealth(),26);
  assertEquals(board.data_.getMinion_p0(0).getHealth(),2);
  assertEquals(board.data_.getMinion_p0(1).getHealth(),7);
  assertEquals(board.data_.getMinion_p0(2).getHealth(),1);
  assertEquals(board.data_.getMinion_p1(0).getHealth(),1);
  assertEquals(board.data_.getMinion_p1(1).getHealth(),2);
  assertEquals(board.data_.getMinion_p1(2).getHealth(),7);
  assertEquals(board.data_.getMinion_p0(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p0(1).getAttack(),7);
  assertEquals(board.data_.getMinion_p0(2).getAttack(),4);
  assertEquals(board.data_.getMinion_p1(0).getAttack(),4);
  assertEquals(board.data_.getMinion_p1(1).getAttack(),2);
  assertEquals(board.data_.getMinion_p1(2).getAttack(),7);
  assertTrue(board.data_.getMinion_p1(0).getDivineShield());
  assertTrue(board.data_.getMinion_p0(2).getDivineShield());
  Minion m1=board.data_.getMinion_p0(2);
  m1.hasAttacked(false);
  ret=m1.attack(3,1,3,board,deck);
  assertEquals(board.data_.getNumCards_hand(),0);
  assertEquals(board.data_.getNumMinions_p0(),3);
  assertEquals(board.data_.getNumMinions_p1(),3);
  assertEquals(board.data_.getMana_p0(),5);
  assertEquals(board.data_.getMana_p1(),8);
  assertEquals(board.data_.getHero_p0().getHealth(),30);
  assertEquals(board.data_.getHero_p1().getHealth(),26);
  assertEquals(board.data_.getMinion_p0(0).getHealth(),2);
  assertEquals(board.data_.getMinion_p0(1).getHealth(),7);
  assertEquals(board.data_.getMinion_p0(2).getHealth(),1);
  assertEquals(board.data_.getMinion_p1(0).getHealth(),1);
  assertEquals(board.data_.getMinion_p1(1).getHealth(),2);
  assertEquals(board.data_.getMinion_p1(2).getHealth(),3);
  assertEquals(board.data_.getMinion_p0(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p0(1).getAttack(),7);
  assertEquals(board.data_.getMinion_p0(2).getAttack(),4);
  assertEquals(board.data_.getMinion_p1(0).getAttack(),4);
  assertEquals(board.data_.getMinion_p1(1).getAttack(),2);
  assertEquals(board.data_.getMinion_p1(2).getAttack(),7);
  assertTrue(board.data_.getMinion_p1(0).getDivineShield());
  assertFalse(board.data_.getMinion_p0(2).getDivineShield());
  Minion m2=board.data_.getMinion_p0(1);
  m2.hasAttacked(false);
  ret=m2.attack(2,1,1,board,deck);
  assertEquals(board.data_.getNumCards_hand(),0);
  assertEquals(board.data_.getNumMinions_p0(),3);
  assertEquals(board.data_.getNumMinions_p1(),3);
  assertEquals(board.data_.getMana_p0(),5);
  assertEquals(board.data_.getMana_p1(),8);
  assertEquals(board.data_.getHero_p0().getHealth(),30);
  assertEquals(board.data_.getHero_p1().getHealth(),26);
  assertEquals(board.data_.getMinion_p0(0).getHealth(),2);
  assertEquals(board.data_.getMinion_p0(1).getHealth(),3);
  assertEquals(board.data_.getMinion_p0(2).getHealth(),1);
  assertEquals(board.data_.getMinion_p1(0).getHealth(),1);
  assertEquals(board.data_.getMinion_p1(1).getHealth(),2);
  assertEquals(board.data_.getMinion_p1(2).getHealth(),3);
  assertEquals(board.data_.getMinion_p0(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p0(1).getAttack(),7);
  assertEquals(board.data_.getMinion_p0(2).getAttack(),4);
  assertEquals(board.data_.getMinion_p1(0).getAttack(),4);
  assertEquals(board.data_.getMinion_p1(1).getAttack(),2);
  assertEquals(board.data_.getMinion_p1(2).getAttack(),7);
  assertFalse(board.data_.getMinion_p1(0).getDivineShield());
  assertFalse(board.data_.getMinion_p0(2).getDivineShield());
  Minion m3=board.data_.getMinion_p0(2);
  m3.hasAttacked(false);
  ret=m3.attack(3,1,3,board,deck);
  assertEquals(board.data_.getNumCards_hand(),0);
  assertEquals(board.data_.getNumMinions_p0(),2);
  assertEquals(board.data_.getNumMinions_p1(),2);
  assertEquals(board.data_.getMana_p0(),5);
  assertEquals(board.data_.getMana_p1(),8);
  assertEquals(board.data_.getHero_p0().getHealth(),30);
  assertEquals(board.data_.getHero_p1().getHealth(),26);
  assertEquals(board.data_.getMinion_p0(0).getHealth(),2);
  assertEquals(board.data_.getMinion_p0(1).getHealth(),3);
  assertEquals(board.data_.getMinion_p1(0).getHealth(),1);
  assertEquals(board.data_.getMinion_p1(1).getHealth(),2);
  assertEquals(board.data_.getMinion_p0(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p0(1).getAttack(),7);
  assertEquals(board.data_.getMinion_p1(0).getAttack(),4);
  assertEquals(board.data_.getMinion_p1(1).getAttack(),2);
  assertFalse(board.data_.getMinion_p1(0).getDivineShield());
}",0.7757706656194777
112827,"@Test public void test0() throws HSException {
  Minion minion=board.data_.getMinion_p0(0);
  HearthTreeNode<BoardState> ret=minion.attack(0,1,0,board,deck);
  assertFalse(ret == null);
  assertEquals(board.data_.getNumCards_hand(),1);
  assertEquals(board.data_.getNumMinions_p0(),2);
  assertEquals(board.data_.getNumMinions_p1(),2);
  assertEquals(board.data_.getMana_p0(),8);
  assertEquals(board.data_.getMana_p1(),8);
  assertEquals(board.data_.getHero_p0().getHealth(),30);
  assertEquals(board.data_.getHero_p1().getHealth(),28);
  assertEquals(board.data_.getMinion_p0(0).getHealth(),2);
  assertEquals(board.data_.getMinion_p0(1).getHealth(),7);
  assertEquals(board.data_.getMinion_p1(0).getHealth(),2);
  assertEquals(board.data_.getMinion_p1(1).getHealth(),7);
  assertEquals(board.data_.getMinion_p0(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p0(1).getAttack(),7);
  assertEquals(board.data_.getMinion_p1(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p1(1).getAttack(),7);
  Hero hero=board.data_.getHero_p0();
  ret=hero.useHeroAbility(0,1,0,board,deck);
  assertTrue(ret == null);
  assertEquals(board.data_.getNumCards_hand(),1);
  assertEquals(board.data_.getNumMinions_p0(),2);
  assertEquals(board.data_.getNumMinions_p1(),2);
  assertEquals(board.data_.getMana_p0(),8);
  assertEquals(board.data_.getMana_p1(),8);
  assertEquals(board.data_.getHero_p0().getHealth(),30);
  assertEquals(board.data_.getHero_p1().getHealth(),28);
  assertEquals(board.data_.getMinion_p0(0).getHealth(),2);
  assertEquals(board.data_.getMinion_p0(1).getHealth(),7);
  assertEquals(board.data_.getMinion_p1(0).getHealth(),2);
  assertEquals(board.data_.getMinion_p1(1).getHealth(),7);
  assertEquals(board.data_.getMinion_p0(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p0(1).getAttack(),7);
  assertEquals(board.data_.getMinion_p1(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p1(1).getAttack(),7);
  minion.hasAttacked(false);
  ret=minion.attack(0,1,2,board,deck);
  assertEquals(board.data_.getNumCards_hand(),1);
  assertEquals(board.data_.getNumMinions_p0(),2);
  assertEquals(board.data_.getNumMinions_p1(),2);
  assertEquals(board.data_.getMana_p0(),8);
  assertEquals(board.data_.getMana_p1(),8);
  assertEquals(board.data_.getHero_p0().getHealth(),30);
  assertEquals(board.data_.getHero_p1().getHealth(),28);
  assertEquals(board.data_.getMinion_p0(0).getHealth(),0);
  assertEquals(board.data_.getMinion_p0(1).getHealth(),7);
  assertEquals(board.data_.getMinion_p1(0).getHealth(),2);
  assertEquals(board.data_.getMinion_p1(1).getHealth(),5);
  assertEquals(board.data_.getMinion_p0(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p0(1).getAttack(),6);
  assertEquals(board.data_.getMinion_p1(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p1(1).getAttack(),7);
  minion.hasAttacked(false);
  ret=hero.useHeroAbility(0,0,0,board,deck);
  assertFalse(ret == null);
  assertEquals(board.data_.getNumCards_hand(),1);
  assertEquals(board.data_.getNumMinions_p0(),2);
  assertEquals(board.data_.getNumMinions_p1(),2);
  assertEquals(board.data_.getMana_p0(),6);
  assertEquals(board.data_.getMana_p1(),8);
  assertEquals(board.data_.getHero_p0().getHealth(),30);
  assertEquals(board.data_.getHero_p1().getHealth(),28);
  assertEquals(board.data_.getHero_p0().getArmor(),0);
  assertEquals(board.data_.getHero_p1().getArmor(),0);
  assertEquals(board.data_.getHero_p0().getAttack(),1);
  assertEquals(board.data_.getHero_p1().getAttack(),0);
  assertEquals(board.data_.getHero_p0().getAttack(),1);
  assertEquals(board.data_.getHero_p1().getAttack(),0);
  assertEquals(board.data_.getMinion_p0(0).getHealth(),0);
  assertEquals(board.data_.getMinion_p0(1).getHealth(),7);
  assertEquals(board.data_.getMinion_p1(0).getHealth(),2);
  assertEquals(board.data_.getMinion_p1(1).getHealth(),5);
  assertEquals(board.data_.getMinion_p0(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p0(1).getAttack(),6);
  assertEquals(board.data_.getMinion_p1(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p1(1).getAttack(),7);
}","@Test public void test0() throws HSException {
  Minion minion=board.data_.getMinion_p0(0);
  HearthTreeNode<BoardState> ret=minion.attack(0,1,0,board,deck);
  assertFalse(ret == null);
  assertEquals(board.data_.getNumCards_hand(),1);
  assertEquals(board.data_.getNumMinions_p0(),2);
  assertEquals(board.data_.getNumMinions_p1(),2);
  assertEquals(board.data_.getMana_p0(),8);
  assertEquals(board.data_.getMana_p1(),8);
  assertEquals(board.data_.getHero_p0().getHealth(),30);
  assertEquals(board.data_.getHero_p1().getHealth(),28);
  assertEquals(board.data_.getMinion_p0(0).getHealth(),2);
  assertEquals(board.data_.getMinion_p0(1).getHealth(),7);
  assertEquals(board.data_.getMinion_p1(0).getHealth(),2);
  assertEquals(board.data_.getMinion_p1(1).getHealth(),7);
  assertEquals(board.data_.getMinion_p0(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p0(1).getAttack(),7);
  assertEquals(board.data_.getMinion_p1(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p1(1).getAttack(),7);
  Hero hero=board.data_.getHero_p0();
  ret=hero.useHeroAbility(0,1,0,board,deck);
  assertTrue(ret == null);
  assertEquals(board.data_.getNumCards_hand(),1);
  assertEquals(board.data_.getNumMinions_p0(),2);
  assertEquals(board.data_.getNumMinions_p1(),2);
  assertEquals(board.data_.getMana_p0(),8);
  assertEquals(board.data_.getMana_p1(),8);
  assertEquals(board.data_.getHero_p0().getHealth(),30);
  assertEquals(board.data_.getHero_p1().getHealth(),28);
  assertEquals(board.data_.getMinion_p0(0).getHealth(),2);
  assertEquals(board.data_.getMinion_p0(1).getHealth(),7);
  assertEquals(board.data_.getMinion_p1(0).getHealth(),2);
  assertEquals(board.data_.getMinion_p1(1).getHealth(),7);
  assertEquals(board.data_.getMinion_p0(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p0(1).getAttack(),7);
  assertEquals(board.data_.getMinion_p1(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p1(1).getAttack(),7);
  minion.hasAttacked(false);
  ret=minion.attack(0,1,2,board,deck);
  assertEquals(board.data_.getNumCards_hand(),1);
  assertEquals(board.data_.getNumMinions_p0(),2);
  assertEquals(board.data_.getNumMinions_p1(),2);
  assertEquals(board.data_.getMana_p0(),8);
  assertEquals(board.data_.getMana_p1(),8);
  assertEquals(board.data_.getHero_p0().getHealth(),30);
  assertEquals(board.data_.getHero_p1().getHealth(),28);
  assertEquals(board.data_.getMinion_p0(0).getHealth(),0);
  assertEquals(board.data_.getMinion_p0(1).getHealth(),7);
  assertEquals(board.data_.getMinion_p1(0).getHealth(),2);
  assertEquals(board.data_.getMinion_p1(1).getHealth(),5);
  assertEquals(board.data_.getMinion_p0(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p0(1).getAttack(),6);
  assertEquals(board.data_.getMinion_p1(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p1(1).getAttack(),7);
  minion.hasAttacked(false);
  ret=hero.useHeroAbility(0,0,0,board,deck);
  assertFalse(ret == null);
  assertEquals(board.data_.getNumCards_hand(),1);
  assertEquals(board.data_.getNumMinions_p0(),2);
  assertEquals(board.data_.getNumMinions_p1(),2);
  assertEquals(board.data_.getMana_p0(),6);
  assertEquals(board.data_.getMana_p1(),8);
  assertEquals(board.data_.getHero_p0().getHealth(),30);
  assertEquals(board.data_.getHero_p1().getHealth(),28);
  assertEquals(board.data_.getHero_p0().getArmor(),0);
  assertEquals(board.data_.getHero_p1().getArmor(),0);
  assertEquals(board.data_.getHero_p0().getAttack(),1);
  assertEquals(board.data_.getHero_p1().getAttack(),0);
  assertEquals(board.data_.getHero_p0().getWeaponCharge(),2);
  assertEquals(board.data_.getHero_p1().getWeaponCharge(),0);
  assertEquals(board.data_.getMinion_p0(0).getHealth(),0);
  assertEquals(board.data_.getMinion_p0(1).getHealth(),7);
  assertEquals(board.data_.getMinion_p1(0).getHealth(),2);
  assertEquals(board.data_.getMinion_p1(1).getHealth(),5);
  assertEquals(board.data_.getMinion_p0(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p0(1).getAttack(),6);
  assertEquals(board.data_.getMinion_p1(0).getAttack(),2);
  assertEquals(board.data_.getMinion_p1(1).getAttack(),7);
}",0.8912990494759931
112828,"/** 
 * Called whenever another minion is summoned using a spell
 * @param playerIndex The index of the created minion's player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the created minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
public HearthTreeNode<BoardState> minionSummonedEvent(int summonedMinionPlayerIndex,int summeonedMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  return boardState;
}","/** 
 * Called whenever another minion is summoned using a spell
 * @param playerIndex The index of the created minion's player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the created minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
public HearthTreeNode<BoardState> minionSummonedEvent(int thisMinionPlayerIndex,int thisMinionIndex,int summonedMinionPlayerIndex,int summeonedMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  return boardState;
}",0.9657738095238096
112829,"/** 
 * Called whenever another minion is summoned using a spell
 * @param playerIndex The index of the created minion's player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the created minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
public HearthTreeNode<BoardState> minionTransformedEvent(int transformedMinionPlayerIndex,int transformedMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  return boardState;
}","/** 
 * Called whenever another minion is summoned using a spell
 * @param playerIndex The index of the created minion's player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the created minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
public HearthTreeNode<BoardState> minionTransformedEvent(int thisMinionPlayerIndex,int thisMinionIndex,int transformedMinionPlayerIndex,int transformedMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  return boardState;
}",0.9661764705882352
112830,"/** 
 * Called whenever another minion is damaged
 * @param playerIndex The index of the damaged minion's player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the damaged minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
public HearthTreeNode<BoardState> minionDamagedEvent(int damagedPlayerIndex,int damagedMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  return boardState;
}","/** 
 * Called whenever another minion is damaged
 * @param playerIndex The index of the damaged minion's player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the damaged minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
public HearthTreeNode<BoardState> minionDamagedEvent(int thisMinionPlayerIndex,int thisMinionIndex,int damagedPlayerIndex,int damagedMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  return boardState;
}",0.964451313755796
112831,"/** 
 * Use the card on the given target
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public HearthTreeNode<BoardState> useOn(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  HearthTreeNode<BoardState> toRet=this.use_core(thisCardIndex,playerIndex,minionIndex,boardState,deck);
  if (toRet != null) {
    if (!transformed_) {
      for (int j=0; j < toRet.data_.getNumCards_hand(); ++j) {
        toRet=toRet.data_.getCard_hand_p0(j).otherCardUsedEvent(j,toRet,deck);
      }
      toRet=toRet.data_.getHero_p0().otherCardUsedEvent(0,toRet,deck);
      for (int j=0; j < toRet.data_.getNumMinions_p0(); ++j) {
        toRet=toRet.data_.getMinion_p0(j).otherCardUsedEvent(j,toRet,deck);
      }
      toRet=toRet.data_.getHero_p1().otherCardUsedEvent(0,toRet,deck);
      for (int j=0; j < toRet.data_.getNumMinions_p1(); ++j) {
        toRet=toRet.data_.getMinion_p1(j).otherCardUsedEvent(j,toRet,deck);
      }
    }
    if (summoned_) {
      toRet=toRet.data_.getHero_p0().minionSummonedEvent(playerIndex,minionIndex,toRet,deck);
      for (int j=0; j < toRet.data_.getNumMinions_p0(); ++j) {
        toRet=toRet.data_.getMinion_p0(j).minionSummonedEvent(playerIndex,minionIndex,toRet,deck);
      }
      toRet=toRet.data_.getHero_p1().minionSummonedEvent(playerIndex,minionIndex,toRet,deck);
      for (int j=0; j < toRet.data_.getNumMinions_p1(); ++j) {
        toRet=toRet.data_.getMinion_p1(j).minionSummonedEvent(playerIndex,minionIndex,toRet,deck);
      }
    }
 else {
      toRet=toRet.data_.getHero_p0().minionPlacedEvent(playerIndex,minionIndex,toRet,deck);
      for (int j=0; j < toRet.data_.getNumMinions_p0(); ++j) {
        toRet=toRet.data_.getMinion_p0(j).minionPlacedEvent(playerIndex,minionIndex,toRet,deck);
      }
      toRet=toRet.data_.getHero_p1().minionPlacedEvent(playerIndex,minionIndex,toRet,deck);
      for (int j=0; j < toRet.data_.getNumMinions_p1(); ++j) {
        toRet=toRet.data_.getMinion_p1(j).minionPlacedEvent(playerIndex,minionIndex,toRet,deck);
      }
    }
  }
  return toRet;
}","/** 
 * Use the card on the given target
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public HearthTreeNode<BoardState> useOn(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  HearthTreeNode<BoardState> toRet=this.use_core(thisCardIndex,playerIndex,minionIndex,boardState,deck);
  if (toRet != null) {
    if (!transformed_) {
      for (int j=0; j < toRet.data_.getNumCards_hand(); ++j) {
        toRet=toRet.data_.getCard_hand_p0(j).otherCardUsedEvent(j,toRet,deck);
      }
      toRet=toRet.data_.getHero_p0().otherCardUsedEvent(0,toRet,deck);
      for (int j=0; j < toRet.data_.getNumMinions_p0(); ++j) {
        toRet=toRet.data_.getMinion_p0(j).otherCardUsedEvent(j,toRet,deck);
      }
      toRet=toRet.data_.getHero_p1().otherCardUsedEvent(0,toRet,deck);
      for (int j=0; j < toRet.data_.getNumMinions_p1(); ++j) {
        toRet=toRet.data_.getMinion_p1(j).otherCardUsedEvent(j,toRet,deck);
      }
    }
    if (summoned_) {
      toRet=toRet.data_.getHero_p0().minionSummonedEvent(0,0,playerIndex,minionIndex,toRet,deck);
      for (int j=0; j < toRet.data_.getNumMinions_p0(); ++j) {
        toRet=toRet.data_.getMinion_p0(j).minionSummonedEvent(0,j + 1,playerIndex,minionIndex,toRet,deck);
      }
      toRet=toRet.data_.getHero_p1().minionSummonedEvent(1,0,playerIndex,minionIndex,toRet,deck);
      for (int j=0; j < toRet.data_.getNumMinions_p1(); ++j) {
        toRet=toRet.data_.getMinion_p1(j).minionSummonedEvent(1,j + 1,playerIndex,minionIndex,toRet,deck);
      }
    }
 else {
      toRet=toRet.data_.getHero_p0().minionPlacedEvent(0,0,playerIndex,minionIndex,toRet,deck);
      for (int j=0; j < toRet.data_.getNumMinions_p0(); ++j) {
        toRet=toRet.data_.getMinion_p0(j).minionPlacedEvent(0,j + 1,playerIndex,minionIndex,toRet,deck);
      }
      toRet=toRet.data_.getHero_p1().minionPlacedEvent(1,0,playerIndex,minionIndex,toRet,deck);
      for (int j=0; j < toRet.data_.getNumMinions_p1(); ++j) {
        toRet=toRet.data_.getMinion_p1(j).minionPlacedEvent(1,j + 1,playerIndex,minionIndex,toRet,deck);
      }
    }
  }
  return toRet;
}",0.9905175819834058
112832,"/** 
 * Called when this minion takes damage Always use this function to take damage... it properly notifies all others of its damage and possibly of its death
 * @param damage The amount of damage to take
 * @param attackerPlayerIndex The player index of the attacker.  This is needed to do things like +spell damage.
 * @param thisPlayerIndex The player index of this minion
 * @param thisMinionIndex The minion index of this minion
 * @param boardState 
 * @param deck
 * @param isSpellDamage True if this is a spell damage
 * @throws HSInvalidPlayerIndexException
 */
public void takeDamage(byte damage,int attackerPlayerIndex,int thisPlayerIndex,int thisMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck,boolean isSpellDamage) throws HSInvalidPlayerIndexException {
  if (!divineShield_) {
    byte totalDamage=isSpellDamage ? (byte)(damage + boardState.data_.getSpellDamage(attackerPlayerIndex)) : damage;
    health_=(byte)(health_ - totalDamage);
    HearthTreeNode<BoardState> toRet=boardState;
    toRet=toRet.data_.getHero_p0().minionDamagedEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p0(); ++j) {
      toRet=toRet.data_.getMinion_p0(j).minionDamagedEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
    }
    toRet=toRet.data_.getHero_p1().minionDamagedEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p1(); ++j) {
      toRet=toRet.data_.getMinion_p1(j).minionDamagedEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
    }
    if (health_ <= 0) {
      this.destroyed(thisPlayerIndex,thisMinionIndex,boardState,deck);
    }
  }
 else {
    divineShield_=false;
  }
}","/** 
 * Called when this minion takes damage Always use this function to take damage... it properly notifies all others of its damage and possibly of its death
 * @param damage The amount of damage to take
 * @param attackerPlayerIndex The player index of the attacker.  This is needed to do things like +spell damage.
 * @param thisPlayerIndex The player index of this minion
 * @param thisMinionIndex The minion index of this minion
 * @param boardState 
 * @param deck
 * @param isSpellDamage True if this is a spell damage
 * @throws HSInvalidPlayerIndexException
 */
public void takeDamage(byte damage,int attackerPlayerIndex,int thisPlayerIndex,int thisMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck,boolean isSpellDamage) throws HSInvalidPlayerIndexException {
  if (!divineShield_) {
    byte totalDamage=isSpellDamage ? (byte)(damage + boardState.data_.getSpellDamage(attackerPlayerIndex)) : damage;
    health_=(byte)(health_ - totalDamage);
    HearthTreeNode<BoardState> toRet=boardState;
    toRet=toRet.data_.getHero_p0().minionDamagedEvent(0,0,thisPlayerIndex,thisMinionIndex,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p0(); ++j) {
      toRet=toRet.data_.getMinion_p0(j).minionDamagedEvent(0,j + 1,thisPlayerIndex,thisMinionIndex,toRet,deck);
    }
    toRet=toRet.data_.getHero_p1().minionDamagedEvent(1,0,thisPlayerIndex,thisMinionIndex,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p1(); ++j) {
      toRet=toRet.data_.getMinion_p1(j).minionDamagedEvent(1,j + 1,thisPlayerIndex,thisMinionIndex,toRet,deck);
    }
    if (health_ <= 0) {
      this.destroyed(thisPlayerIndex,thisMinionIndex,boardState,deck);
    }
  }
 else {
    divineShield_=false;
  }
}",0.9929783499122292
112833,"/** 
 * Called whenever another minion dies
 * @param playerIndex The index of the dead minion's player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the dead minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
public HearthTreeNode<BoardState> minionDeadEvent(int deadMinionPlayerIndex,int deadMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  return boardState;
}","/** 
 * Called whenever another minion dies
 * @param playerIndex The index of the dead minion's player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the dead minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
public HearthTreeNode<BoardState> minionDeadEvent(int thisMinionPlayerIndex,int thisMinionIndex,int deadMinionPlayerIndex,int deadMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  return boardState;
}",0.9636075949367088
112834,"/** 
 * Called when this minion dies (destroyed) Always use this function to ""kill"" minions
 * @param thisPlayerIndex The player index of this minion
 * @param thisMinionIndex The minion index of this minion
 * @param boardState 
 * @param deck
 * @throws HSInvalidPlayerIndexException
 */
public void destroyed(int thisPlayerIndex,int thisMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  health_=0;
  HearthTreeNode<BoardState> toRet=boardState;
  toRet=toRet.data_.getHero_p0().minionDeadEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
  for (int j=0; j < toRet.data_.getNumMinions_p0(); ++j) {
    toRet=toRet.data_.getMinion_p0(j).minionDeadEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
  }
  toRet=toRet.data_.getHero_p1().minionDeadEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
  for (int j=0; j < toRet.data_.getNumMinions_p1(); ++j) {
    toRet=toRet.data_.getMinion_p1(j).minionDeadEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
  }
}","/** 
 * Called when this minion dies (destroyed) Always use this function to ""kill"" minions
 * @param thisPlayerIndex The player index of this minion
 * @param thisMinionIndex The minion index of this minion
 * @param boardState 
 * @param deck
 * @throws HSInvalidPlayerIndexException
 */
public void destroyed(int thisPlayerIndex,int thisMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  health_=0;
  HearthTreeNode<BoardState> toRet=boardState;
  toRet=toRet.data_.getHero_p0().minionDeadEvent(0,0,thisPlayerIndex,thisMinionIndex,toRet,deck);
  for (int j=0; j < toRet.data_.getNumMinions_p0(); ++j) {
    toRet=toRet.data_.getMinion_p0(j).minionDeadEvent(0,j + 1,thisPlayerIndex,thisMinionIndex,toRet,deck);
  }
  toRet=toRet.data_.getHero_p1().minionDeadEvent(1,0,thisPlayerIndex,thisMinionIndex,toRet,deck);
  for (int j=0; j < toRet.data_.getNumMinions_p1(); ++j) {
    toRet=toRet.data_.getMinion_p1(j).minionDeadEvent(1,j + 1,thisPlayerIndex,thisMinionIndex,toRet,deck);
  }
}",0.9882926829268291
112835,"/** 
 * Called whenever another minion comes on board
 * @param playerIndex The index of the created minion's player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the created minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
public HearthTreeNode<BoardState> minionPlacedEvent(int placedMinionPlayerIndex,int placedMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  return boardState;
}","/** 
 * Called whenever another minion comes on board
 * @param playerIndex The index of the created minion's player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the created minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
public HearthTreeNode<BoardState> minionPlacedEvent(int thisMinionPlayerIndex,int thisMinionIndex,int placedMinionPlayerIndex,int placedMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  return boardState;
}",0.9648318042813456
112836,"/** 
 * Called when this minion is silenced Override for the aura effect
 * @param thisPlayerIndex The player index of this minion
 * @param thisMinionIndex The minion index of this minion
 * @param boardState 
 * @param deck
 * @throws HSInvalidPlayerIndexException
 */
public void silenced(int thisPlayerIndex,int thisMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  for (  Minion minion : boardState.data_.getMinions_p0()) {
    if (minion instanceof Murloc && minion != this) {
      minion.setAttack((byte)(minion.getAttack() - 1));
    }
  }
  for (  Minion minion : boardState.data_.getMinions_p1()) {
    if (minion instanceof Murloc && minion != this) {
      minion.setAttack((byte)(minion.getAttack() - 1));
    }
  }
}","/** 
 * Called when this minion is silenced Override for the aura effect
 * @param thisPlayerIndex The player index of this minion
 * @param thisMinionIndex The minion index of this minion
 * @param boardState 
 * @param deck
 * @throws HSInvalidPlayerIndexException
 */
@Override public void silenced(int thisPlayerIndex,int thisMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  for (  Minion minion : boardState.data_.getMinions_p0()) {
    if (minion instanceof Murloc && minion != this) {
      minion.setAttack((byte)(minion.getAttack() - 1));
    }
  }
  for (  Minion minion : boardState.data_.getMinions_p1()) {
    if (minion instanceof Murloc && minion != this) {
      minion.setAttack((byte)(minion.getAttack() - 1));
    }
  }
}",0.9936548223350252
112837,"/** 
 * Called when this minion dies (destroyed) Override for the aura effect
 * @param thisPlayerIndex The player index of this minion
 * @param thisMinionIndex The minion index of this minion
 * @param boardState 
 * @param deck
 * @throws HSInvalidPlayerIndexException
 */
public void destroyed(int thisPlayerIndex,int thisMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  for (  Minion minion : boardState.data_.getMinions_p0()) {
    if (minion instanceof Murloc && minion != this) {
      minion.setAttack((byte)(minion.getAttack() - 1));
    }
  }
  for (  Minion minion : boardState.data_.getMinions_p1()) {
    if (minion instanceof Murloc && minion != this) {
      minion.setAttack((byte)(minion.getAttack() - 1));
    }
  }
  super.destroyed(thisPlayerIndex,thisMinionIndex,boardState,deck);
}","/** 
 * Called when this minion dies (destroyed) Override for the aura effect
 * @param thisPlayerIndex The player index of this minion
 * @param thisMinionIndex The minion index of this minion
 * @param boardState 
 * @param deck
 * @throws HSInvalidPlayerIndexException
 */
@Override public void destroyed(int thisPlayerIndex,int thisMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  for (  Minion minion : boardState.data_.getMinions_p0()) {
    if (minion instanceof Murloc && minion != this) {
      minion.setAttack((byte)(minion.getAttack() - 1));
    }
  }
  for (  Minion minion : boardState.data_.getMinions_p1()) {
    if (minion instanceof Murloc && minion != this) {
      minion.setAttack((byte)(minion.getAttack() - 1));
    }
  }
  super.destroyed(thisPlayerIndex,thisMinionIndex,boardState,deck);
}",0.994199535962877
112838,"private HearthTreeNode<BoardState> doBuffs(int targetMinionPlayerIndex,int targetMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  Minion minion=boardState.data_.getMinion(targetMinionPlayerIndex,targetMinionIndex - 1);
  if (minion != this)   minion.setAttack((byte)(minion.getAttack() + 1));
  return boardState;
}","private HearthTreeNode<BoardState> doBuffs(int thisMinionPlayerIndex,int thisMinionIndex,int targetMinionPlayerIndex,int targetMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  Minion minion=boardState.data_.getMinion(targetMinionPlayerIndex,targetMinionIndex - 1);
  if (minion instanceof Murloc && minion != this)   minion.setAttack((byte)(minion.getAttack() + 1));
  return boardState;
}",0.908641975308642
112839,"/** 
 * Called whenever another minion is placed on board Override for the aura effect
 * @param playerIndex The index of the created minion's player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the created minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public HearthTreeNode<BoardState> minionPlacedEvent(int placedMinionPlayerIndex,int placedMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  return this.doBuffs(placedMinionPlayerIndex,placedMinionIndex,boardState,deck);
}","/** 
 * Called whenever another minion is placed on board Override for the aura effect
 * @param playerIndex The index of the created minion's player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the created minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public HearthTreeNode<BoardState> minionPlacedEvent(int thisMinionPlayerIndex,int thisMinionIndex,int placedMinionPlayerIndex,int placedMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  return this.doBuffs(thisMinionPlayerIndex,thisMinionIndex,placedMinionPlayerIndex,placedMinionIndex,boardState,deck);
}",0.945945945945946
112840,"/** 
 * Called whenever another minion comes on board Override for the aura effect
 * @param playerIndex The index of the created minion's player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the created minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
public HearthTreeNode<BoardState> minionSummonedEvent(int summonedMinionPlayerIndex,int summeonedMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  return this.doBuffs(summonedMinionPlayerIndex,summeonedMinionIndex,boardState,deck);
}","/** 
 * Called whenever another minion comes on board Override for the aura effect
 * @param playerIndex The index of the created minion's player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the created minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public HearthTreeNode<BoardState> minionSummonedEvent(int thisMinionPlayerIndex,int thisMinionIndex,int summonedMinionPlayerIndex,int summeonedMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  return this.doBuffs(thisMinionPlayerIndex,thisMinionIndex,summonedMinionPlayerIndex,summeonedMinionIndex,boardState,deck);
}",0.9397435897435896
112841,"/** 
 * Called whenever another minion is summoned using a spell
 * @param playerIndex The index of the created minion's player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the created minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
public HearthTreeNode<BoardState> minionTransformedEvent(int transformedMinionPlayerIndex,int transformedMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  return this.doBuffs(transformedMinionPlayerIndex,transformedMinionIndex,boardState,deck);
}","/** 
 * Called whenever another minion is summoned using a spell
 * @param playerIndex The index of the created minion's player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the created minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public HearthTreeNode<BoardState> minionTransformedEvent(int thisMinionPlayerIndex,int thisMinionIndex,int transformedMinionPlayerIndex,int transformedMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  return this.doBuffs(thisMinionPlayerIndex,thisMinionIndex,transformedMinionPlayerIndex,transformedMinionIndex,boardState,deck);
}",0.9393548387096774
112842,"/** 
 * Called when this minion takes damage Override for special ability: gain +3 attack whenever this minion takes damage
 * @param damage The amount of damage to take
 * @param attackerPlayerIndex The player index of the attacker.  This is needed to do things like +spell damage.
 * @param thisPlayerIndex The player index of this minion
 * @param thisMinionIndex The minion index of this minion
 * @param boardState 
 * @param deck
 * @param isSpellDamage True if this is a spell damage
 * @throws HSInvalidPlayerIndexException
 */
public void takeDamage(byte damage,int attackerPlayerIndex,int thisPlayerIndex,int thisMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck,boolean isSpellDamage) throws HSInvalidPlayerIndexException {
  if (!divineShield_) {
    byte totalDamage=isSpellDamage ? (byte)(damage + boardState.data_.getSpellDamage(attackerPlayerIndex)) : damage;
    health_=(byte)(health_ - totalDamage);
    HearthTreeNode<BoardState> toRet=boardState;
    toRet=toRet.data_.getHero_p0().minionDamagedEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p0(); ++j) {
      toRet=toRet.data_.getMinion_p0(j).minionDamagedEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
    }
    toRet=toRet.data_.getHero_p1().minionDamagedEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p1(); ++j) {
      toRet=toRet.data_.getMinion_p1(j).minionDamagedEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
    }
    if (health_ <= 0) {
      this.destroyed(thisPlayerIndex,thisMinionIndex,boardState,deck);
    }
    this.attack_=(byte)(this.attack_ + 3);
  }
 else {
    divineShield_=false;
  }
}","/** 
 * Called when this minion takes damage Override for special ability: gain +3 attack whenever this minion takes damage
 * @param damage The amount of damage to take
 * @param attackerPlayerIndex The player index of the attacker.  This is needed to do things like +spell damage.
 * @param thisPlayerIndex The player index of this minion
 * @param thisMinionIndex The minion index of this minion
 * @param boardState 
 * @param deck
 * @param isSpellDamage True if this is a spell damage
 * @throws HSInvalidPlayerIndexException
 */
public void takeDamage(byte damage,int attackerPlayerIndex,int thisPlayerIndex,int thisMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck,boolean isSpellDamage) throws HSInvalidPlayerIndexException {
  if (!divineShield_) {
    byte totalDamage=isSpellDamage ? (byte)(damage + boardState.data_.getSpellDamage(attackerPlayerIndex)) : damage;
    health_=(byte)(health_ - totalDamage);
    HearthTreeNode<BoardState> toRet=boardState;
    toRet=toRet.data_.getHero_p0().minionDamagedEvent(0,0,thisPlayerIndex,thisMinionIndex,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p0(); ++j) {
      toRet=toRet.data_.getMinion_p0(j).minionDamagedEvent(0,j + 1,thisPlayerIndex,thisMinionIndex,toRet,deck);
    }
    toRet=toRet.data_.getHero_p1().minionDamagedEvent(1,0,thisPlayerIndex,thisMinionIndex,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p1(); ++j) {
      toRet=toRet.data_.getMinion_p1(j).minionDamagedEvent(1,j + 1,thisPlayerIndex,thisMinionIndex,toRet,deck);
    }
    if (health_ <= 0) {
      this.destroyed(thisPlayerIndex,thisMinionIndex,boardState,deck);
    }
    this.attack_=(byte)(this.attack_ + 3);
  }
 else {
    divineShield_=false;
  }
}",0.993006993006993
112843,"/** 
 * Called when this minion is silenced Override for the aura effect
 * @param thisPlayerIndex The player index of this minion
 * @param thisMinionIndex The minion index of this minion
 * @param boardState 
 * @param deck
 * @throws HSInvalidPlayerIndexException
 */
public void silenced(int thisPlayerIndex,int thisMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  for (  Minion minion : boardState.data_.getMinions_p0()) {
    if (minion != this) {
      minion.setAttack((byte)(minion.getAttack() - 1));
    }
  }
}","/** 
 * Called when this minion is silenced Override for the aura effect
 * @param thisPlayerIndex The player index of this minion
 * @param thisMinionIndex The minion index of this minion
 * @param boardState 
 * @param deck
 * @throws HSInvalidPlayerIndexException
 */
@Override public void silenced(int thisPlayerIndex,int thisMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  for (  Minion minion : boardState.data_.getMinions(thisPlayerIndex)) {
    if (minion != this) {
      minion.setAttack((byte)(minion.getAttack() - 1));
    }
  }
}",0.9743589743589745
112844,"/** 
 * Called when this minion dies (destroyed) Override for the aura effect
 * @param thisPlayerIndex The player index of this minion
 * @param thisMinionIndex The minion index of this minion
 * @param boardState 
 * @param deck
 * @throws HSInvalidPlayerIndexException
 */
public void destroyed(int thisPlayerIndex,int thisMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  for (  Minion minion : boardState.data_.getMinions_p0()) {
    if (minion != this) {
      minion.setAttack((byte)(minion.getAttack() - 1));
    }
  }
  super.destroyed(thisPlayerIndex,thisMinionIndex,boardState,deck);
}","/** 
 * Called when this minion dies (destroyed) Override for the aura effect
 * @param thisPlayerIndex The player index of this minion
 * @param thisMinionIndex The minion index of this minion
 * @param boardState 
 * @param deck
 * @throws HSInvalidPlayerIndexException
 */
@Override public void destroyed(int thisPlayerIndex,int thisMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  for (  Minion minion : boardState.data_.getMinions(thisPlayerIndex)) {
    if (minion != this) {
      minion.setAttack((byte)(minion.getAttack() - 1));
    }
  }
  super.destroyed(thisPlayerIndex,thisMinionIndex,boardState,deck);
}",0.977238239757208
112845,"private HearthTreeNode<BoardState> doBuffs(int targetMinionPlayerIndex,int targetMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck){
  if (targetMinionPlayerIndex == 1)   return boardState;
  Minion minion=boardState.data_.getMinion_p0(targetMinionIndex - 1);
  if (minion != this)   minion.setAttack((byte)(minion.getAttack() + 1));
  return boardState;
}","private HearthTreeNode<BoardState> doBuffs(int thisMinionPlayerIndex,int thisMinionIndex,int targetMinionPlayerIndex,int targetMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  if (targetMinionPlayerIndex != thisMinionPlayerIndex)   return boardState;
  Minion minion=boardState.data_.getMinion(thisMinionPlayerIndex,targetMinionIndex - 1);
  if (minion != this)   minion.setAttack((byte)(minion.getAttack() + 1));
  return boardState;
}",0.839766081871345
112846,"/** 
 * Called whenever another minion is placed on board Override for the aura effect
 * @param playerIndex The index of the created minion's player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the created minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public HearthTreeNode<BoardState> minionPlacedEvent(int placedMinionPlayerIndex,int placedMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck){
  return this.doBuffs(placedMinionPlayerIndex,placedMinionIndex,boardState,deck);
}","/** 
 * Called whenever another minion is placed on board Override for the aura effect
 * @param playerIndex The index of the created minion's player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the created minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public HearthTreeNode<BoardState> minionPlacedEvent(int thisMinionPlayerIndex,int thisMinionIndex,int placedMinionPlayerIndex,int placedMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  return this.doBuffs(thisMinionPlayerIndex,thisMinionIndex,placedMinionPlayerIndex,placedMinionIndex,boardState,deck);
}",0.9195250659630608
112847,"/** 
 * Called whenever another minion comes on board Override for the aura effect
 * @param playerIndex The index of the created minion's player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the created minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
public HearthTreeNode<BoardState> minionSummonedEvent(int summonedMinionPlayerIndex,int summeonedMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck){
  return this.doBuffs(summonedMinionPlayerIndex,summeonedMinionIndex,boardState,deck);
}","/** 
 * Called whenever another minion comes on board Override for the aura effect
 * @param playerIndex The index of the created minion's player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the created minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public HearthTreeNode<BoardState> minionSummonedEvent(int thisMinionPlayerIndex,int thisMinionIndex,int summonedMinionPlayerIndex,int summeonedMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  return this.doBuffs(thisMinionPlayerIndex,thisMinionIndex,summonedMinionPlayerIndex,summeonedMinionIndex,boardState,deck);
}",0.9132720105124836
112848,"/** 
 * Called whenever another minion is summoned using a spell
 * @param playerIndex The index of the created minion's player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the created minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
public HearthTreeNode<BoardState> minionTransformedEvent(int transformedMinionPlayerIndex,int transformedMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck){
  return this.doBuffs(transformedMinionPlayerIndex,transformedMinionIndex,boardState,deck);
}","/** 
 * Called whenever another minion is summoned using a spell
 * @param playerIndex The index of the created minion's player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the created minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public HearthTreeNode<BoardState> minionTransformedEvent(int thisMinionPlayerIndex,int thisMinionIndex,int transformedMinionPlayerIndex,int transformedMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  return this.doBuffs(thisMinionPlayerIndex,thisMinionIndex,transformedMinionPlayerIndex,transformedMinionIndex,boardState,deck);
}",0.9126984126984128
112849,"/** 
 * Called when this minion is silenced Override for the aura effect
 * @param thisPlayerIndex The player index of this minion
 * @param thisMinionIndex The minion index of this minion
 * @param boardState 
 * @param deck
 * @throws HSInvalidPlayerIndexException
 */
public void silenced(int thisPlayerIndex,int thisMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  for (  Minion minion : boardState.data_.getMinions_p0()) {
    if (minion != this) {
      minion.setAttack((byte)(minion.getAttack() - 1));
    }
  }
}","/** 
 * Called when this minion is silenced Override for the aura effect
 * @param thisPlayerIndex The player index of this minion
 * @param thisMinionIndex The minion index of this minion
 * @param boardState 
 * @param deck
 * @throws HSInvalidPlayerIndexException
 */
@Override public void silenced(int thisPlayerIndex,int thisMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  for (  Minion minion : boardState.data_.getMinions(thisPlayerIndex)) {
    if (minion != this) {
      minion.setAttack((byte)(minion.getAttack() - 1));
    }
  }
}",0.9743589743589745
112850,"/** 
 * Called when this minion dies (destroyed) Override for the aura effect
 * @param thisPlayerIndex The player index of this minion
 * @param thisMinionIndex The minion index of this minion
 * @param boardState 
 * @param deck
 * @throws HSInvalidPlayerIndexException
 */
public void destroyed(int thisPlayerIndex,int thisMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  for (  Minion minion : boardState.data_.getMinions_p0()) {
    if (minion != this) {
      minion.setAttack((byte)(minion.getAttack() - 1));
    }
  }
  super.destroyed(thisPlayerIndex,thisMinionIndex,boardState,deck);
}","/** 
 * Called when this minion dies (destroyed) Override for the aura effect
 * @param thisPlayerIndex The player index of this minion
 * @param thisMinionIndex The minion index of this minion
 * @param boardState 
 * @param deck
 * @throws HSInvalidPlayerIndexException
 */
@Override public void destroyed(int thisPlayerIndex,int thisMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  for (  Minion minion : boardState.data_.getMinions(thisPlayerIndex)) {
    if (minion != this) {
      minion.setAttack((byte)(minion.getAttack() - 1));
    }
  }
  super.destroyed(thisPlayerIndex,thisMinionIndex,boardState,deck);
}",0.977238239757208
112851,"private HearthTreeNode<BoardState> doBuffs(int targetMinionPlayerIndex,int targetMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck){
  if (targetMinionPlayerIndex == 1)   return boardState;
  Minion minion=boardState.data_.getMinion_p0(targetMinionIndex - 1);
  if (minion != this)   minion.setAttack((byte)(minion.getAttack() + 1));
  return boardState;
}","private HearthTreeNode<BoardState> doBuffs(int thisMinionPlayerIndex,int thisMinionIndex,int targetMinionPlayerIndex,int targetMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  if (targetMinionPlayerIndex != thisMinionPlayerIndex)   return boardState;
  Minion minion=boardState.data_.getMinion(thisMinionPlayerIndex,targetMinionIndex - 1);
  if (minion != this)   minion.setAttack((byte)(minion.getAttack() + 1));
  return boardState;
}",0.839766081871345
112852,"/** 
 * Called whenever another minion is placed on board Override for the aura effect
 * @param playerIndex The index of the created minion's player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the created minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public HearthTreeNode<BoardState> minionPlacedEvent(int placedMinionPlayerIndex,int placedMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck){
  return this.doBuffs(placedMinionPlayerIndex,placedMinionIndex,boardState,deck);
}","/** 
 * Called whenever another minion is placed on board Override for the aura effect
 * @param playerIndex The index of the created minion's player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the created minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public HearthTreeNode<BoardState> minionPlacedEvent(int thisMinionPlayerIndex,int thisMinionIndex,int placedMinionPlayerIndex,int placedMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  return this.doBuffs(thisMinionPlayerIndex,thisMinionIndex,placedMinionPlayerIndex,placedMinionIndex,boardState,deck);
}",0.9195250659630608
112853,"/** 
 * Called whenever another minion comes on board Override for the aura effect
 * @param playerIndex The index of the created minion's player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the created minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
public HearthTreeNode<BoardState> minionSummonedEvent(int summonedMinionPlayerIndex,int summeonedMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck){
  return this.doBuffs(summonedMinionPlayerIndex,summeonedMinionIndex,boardState,deck);
}","/** 
 * Called whenever another minion comes on board Override for the aura effect
 * @param playerIndex The index of the created minion's player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the created minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public HearthTreeNode<BoardState> minionSummonedEvent(int thisMinionPlayerIndex,int thisMinionIndex,int summonedMinionPlayerIndex,int summeonedMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  return this.doBuffs(thisMinionPlayerIndex,thisMinionIndex,summonedMinionPlayerIndex,summeonedMinionIndex,boardState,deck);
}",0.9132720105124836
112854,"/** 
 * Called whenever another minion is summoned using a spell
 * @param playerIndex The index of the created minion's player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the created minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
public HearthTreeNode<BoardState> minionTransformedEvent(int transformedMinionPlayerIndex,int transformedMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck){
  return this.doBuffs(transformedMinionPlayerIndex,transformedMinionIndex,boardState,deck);
}","/** 
 * Called whenever another minion is summoned using a spell
 * @param playerIndex The index of the created minion's player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the created minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public HearthTreeNode<BoardState> minionTransformedEvent(int thisMinionPlayerIndex,int thisMinionIndex,int transformedMinionPlayerIndex,int transformedMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  return this.doBuffs(thisMinionPlayerIndex,thisMinionIndex,transformedMinionPlayerIndex,transformedMinionIndex,boardState,deck);
}",0.9126984126984128
112855,"/** 
 * Use the card on the given target This card heals the target minion up to full health and gives it taunt.  Cannot be used on heroes.
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override protected HearthTreeNode<BoardState> use_core(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  if (minionIndex == 0) {
    return null;
  }
  Minion targetMinion=boardState.data_.getMinion(playerIndex,minionIndex - 1);
  targetMinion.setHealth((byte)(targetMinion.getHealth() * 2));
  if (targetMinion.getMaxHealth() < targetMinion.getHealth())   targetMinion.setMaxHealth(targetMinion.getHealth());
  return super.use_core(thisCardIndex,playerIndex,minionIndex,boardState,deck);
}","/** 
 * Use the card on the given target This card heals the target minion up to full health and gives it taunt.  Cannot be used on heroes.
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override protected HearthTreeNode<BoardState> use_core(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  if (minionIndex == 0) {
    return null;
  }
  Minion targetMinion=boardState.data_.getMinion(playerIndex,minionIndex - 1);
  byte healthDiff=targetMinion.getHealth();
  targetMinion.setHealth((byte)(targetMinion.getHealth() * 2));
  targetMinion.setMaxHealth((byte)(targetMinion.getMaxHealth() + healthDiff));
  return super.use_core(thisCardIndex,playerIndex,minionIndex,boardState,deck);
}",0.9207317073170732
112856,"/** 
 * Called when this minion takes damage Overridden from Minion.  Need to handle armor.
 * @param damage The amount of damage to take
 * @param thisPlayerIndex The player index of this minion
 * @param thisMinionIndex The minion index of this minion
 * @param boardState 
 * @param deck
 * @throws HSInvalidPlayerIndexException
 */
@Override public void takeDamage(byte damage,int thisPlayerIndex,int thisMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  byte damageRemaining=(byte)(damage - armor_);
  if (damageRemaining > 0) {
    armor_=0;
    super.takeDamage(damageRemaining,thisPlayerIndex,thisMinionIndex,boardState,deck);
  }
 else {
    armor_=(byte)(armor_ - damage);
    super.takeDamage((byte)0,thisPlayerIndex,thisMinionIndex,boardState,deck);
  }
}","/** 
 * Called when this minion takes damage Overridden from Minion.  Need to handle armor.
 * @param damage The amount of damage to take
 * @param attackerPlayerIndex The player index of the attacker.  This is needed to do things like +spell damage.
 * @param thisPlayerIndex The player index of this minion
 * @param thisMinionIndex The minion index of this minion
 * @param boardState 
 * @param deck
 * @throws HSInvalidPlayerIndexException
 */
@Override public void takeDamage(byte damage,int attackerPlayerIndex,int thisPlayerIndex,int thisMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  byte damageRemaining=(byte)(damage - armor_);
  if (damageRemaining > 0) {
    armor_=0;
    super.takeDamage(damageRemaining,attackerPlayerIndex,thisPlayerIndex,thisMinionIndex,boardState,deck);
  }
 else {
    armor_=(byte)(armor_ - damage);
    super.takeDamage((byte)0,attackerPlayerIndex,thisPlayerIndex,thisMinionIndex,boardState,deck);
  }
}",0.9024793388429752
112857,"/** 
 * Called when this minion takes damage Always use this function to take damage... it properly notifies all others of its damage and possibly of its death
 * @param damage The amount of damage to take
 * @param thisPlayerIndex The player index of this minion
 * @param thisMinionIndex The minion index of this minion
 * @param boardState 
 * @param deck
 * @param isSpellDamage True if this is a spell damage
 * @throws HSInvalidPlayerIndexException
 */
public void takeDamage(byte damage,int thisPlayerIndex,int thisMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck,boolean isSpellDamage) throws HSInvalidPlayerIndexException {
  if (!divineShield_) {
    byte totalDamage=isSpellDamage ? (byte)(damage + boardState.data_.getSpellDamage(0)) : damage;
    health_=(byte)(health_ - totalDamage);
    HearthTreeNode<BoardState> toRet=boardState;
    toRet=toRet.data_.getHero_p0().minionDamagedEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p0(); ++j) {
      toRet=toRet.data_.getMinion_p0(j).minionDamagedEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
    }
    toRet=toRet.data_.getHero_p1().minionDamagedEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p1(); ++j) {
      toRet=toRet.data_.getMinion_p1(j).minionDamagedEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
    }
    if (health_ <= 0) {
      this.destroyed(thisPlayerIndex,thisMinionIndex,boardState,deck);
    }
  }
 else {
    divineShield_=false;
  }
}","/** 
 * Called when this minion takes damage Always use this function to take damage... it properly notifies all others of its damage and possibly of its death
 * @param damage The amount of damage to take
 * @param attackerPlayerIndex The player index of the attacker.  This is needed to do things like +spell damage.
 * @param thisPlayerIndex The player index of this minion
 * @param thisMinionIndex The minion index of this minion
 * @param boardState 
 * @param deck
 * @param isSpellDamage True if this is a spell damage
 * @throws HSInvalidPlayerIndexException
 */
public void takeDamage(byte damage,int attackerPlayerIndex,int thisPlayerIndex,int thisMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck,boolean isSpellDamage) throws HSInvalidPlayerIndexException {
  if (!divineShield_) {
    byte totalDamage=isSpellDamage ? (byte)(damage + boardState.data_.getSpellDamage(attackerPlayerIndex)) : damage;
    health_=(byte)(health_ - totalDamage);
    HearthTreeNode<BoardState> toRet=boardState;
    toRet=toRet.data_.getHero_p0().minionDamagedEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p0(); ++j) {
      toRet=toRet.data_.getMinion_p0(j).minionDamagedEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
    }
    toRet=toRet.data_.getHero_p1().minionDamagedEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p1(); ++j) {
      toRet=toRet.data_.getMinion_p1(j).minionDamagedEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
    }
    if (health_ <= 0) {
      this.destroyed(thisPlayerIndex,thisMinionIndex,boardState,deck);
    }
  }
 else {
    divineShield_=false;
  }
}",0.8650818153751157
112858,"/** 
 * Attack with the minion
 * @param thisMinionIndex Attacking minion's index (note: attacking player index is assumed to be 0)
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
protected HearthTreeNode<BoardState> attack_core(int thisMinionIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  if (hasAttacked_) {
    return null;
  }
  if (playerIndex == 0) {
    return null;
  }
  if (minionIndex == 0) {
    boardState.data_.getHero_p1().takeDamage(this.attack_,playerIndex,minionIndex,boardState,deck);
    this.takeDamage(boardState.data_.getHero_p1().attack_,0,thisMinionIndex,boardState,deck);
    if (windFury_ && !hasWindFuryAttacked_)     hasWindFuryAttacked_=true;
 else     hasAttacked_=true;
    return boardState;
  }
 else {
    Minion target=boardState.data_.getMinion_p1(minionIndex - 1);
    target.takeDamage(this.attack_,playerIndex,minionIndex,boardState,deck);
    this.takeDamage(target.attack_,0,thisMinionIndex,boardState,deck);
    if (target.getHealth() <= 0) {
      boardState.data_.removeMinion_p1(target);
    }
    if (health_ <= 0) {
      boardState.data_.removeMinion_p0(thisMinionIndex - 1);
    }
    if (windFury_ && !hasWindFuryAttacked_)     hasWindFuryAttacked_=true;
 else     hasAttacked_=true;
    return boardState;
  }
}","/** 
 * Attack with the minion
 * @param thisMinionIndex Attacking minion's index (note: attacking player index is assumed to be 0)
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
protected HearthTreeNode<BoardState> attack_core(int thisMinionIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  if (hasAttacked_) {
    return null;
  }
  if (playerIndex == 0) {
    return null;
  }
  if (minionIndex == 0) {
    boardState.data_.getHero_p1().takeDamage(this.attack_,0,playerIndex,minionIndex,boardState,deck);
    this.takeDamage(boardState.data_.getHero_p1().attack_,playerIndex,0,thisMinionIndex,boardState,deck);
    if (windFury_ && !hasWindFuryAttacked_)     hasWindFuryAttacked_=true;
 else     hasAttacked_=true;
    return boardState;
  }
 else {
    Minion target=boardState.data_.getMinion_p1(minionIndex - 1);
    target.takeDamage(this.attack_,0,playerIndex,minionIndex,boardState,deck);
    this.takeDamage(target.attack_,playerIndex,0,thisMinionIndex,boardState,deck);
    if (target.getHealth() <= 0) {
      boardState.data_.removeMinion_p1(target);
    }
    if (health_ <= 0) {
      boardState.data_.removeMinion_p0(thisMinionIndex - 1);
    }
    if (windFury_ && !hasWindFuryAttacked_)     hasWindFuryAttacked_=true;
 else     hasAttacked_=true;
    return boardState;
  }
}",0.9915865384615384
112859,"public void attack(Minion minion,int targetPlayerIndex,int targetMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  minion.takeDamage(damage_,targetPlayerIndex,targetMinionIndex,boardState,deck,true);
}","public void attack(Minion minion,int targetPlayerIndex,int targetMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  minion.takeDamage(damage_,0,targetPlayerIndex,targetMinionIndex,boardState,deck,true);
}",0.9960629921259844
112860,"/** 
 * Use the card on the given target This card damages all enemy minions by 1
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override protected HearthTreeNode<BoardState> use_core(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  if (playerIndex == 0) {
    return null;
  }
  if (minionIndex > 0) {
    return null;
  }
  for (int indx=0; indx < boardState.data_.getNumMinions_p1(); ++indx) {
    Minion targetMinion=boardState.data_.getMinion_p1(indx);
    targetMinion.takeDamage((byte)1,1,indx + 1,boardState,deck,true);
  }
  Iterator<Minion> iter=boardState.data_.getMinions_p1().iterator();
  while (iter.hasNext()) {
    Minion targetMinion=iter.next();
    if (targetMinion.getHealth() <= 0) {
      iter.remove();
    }
  }
  return super.use_core(thisCardIndex,playerIndex,minionIndex,boardState,deck);
}","/** 
 * Use the card on the given target This card damages all enemy minions by 1
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override protected HearthTreeNode<BoardState> use_core(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  if (playerIndex == 0) {
    return null;
  }
  if (minionIndex > 0) {
    return null;
  }
  for (int indx=0; indx < boardState.data_.getNumMinions_p1(); ++indx) {
    Minion targetMinion=boardState.data_.getMinion_p1(indx);
    targetMinion.takeDamage((byte)1,0,1,indx + 1,boardState,deck,true);
  }
  Iterator<Minion> iter=boardState.data_.getMinions_p1().iterator();
  while (iter.hasNext()) {
    Minion targetMinion=iter.next();
    if (targetMinion.getHealth() <= 0) {
      iter.remove();
    }
  }
  return super.use_core(thisCardIndex,playerIndex,minionIndex,boardState,deck);
}",0.9992229992229992
112861,"/** 
 * Use the card on the given target Deals 1 damage to three random enemy characters.  The characters can repeat.
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override protected HearthTreeNode<BoardState> use_core(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  if (playerIndex == 0) {
    return null;
  }
  if (minionIndex > 0) {
    return null;
  }
  int numMissiles=3 + boardState.data_.getSpellDamage(0);
  int numTargets=boardState.data_.getNumMinions_p1() + 1;
  int index=0;
  while (index < numMissiles) {
    int targetIndex=(int)(numTargets * Math.random());
    if (targetIndex == 0 && boardState.data_.getHero_p1().getHealth() > 0) {
      boardState.data_.getHero_p1().takeDamage((byte)1,1,targetIndex,boardState,deck);
      ++index;
    }
 else     if (targetIndex > 0 && boardState.data_.getMinion_p1(targetIndex - 1).getHealth() > 0) {
      boardState.data_.getMinion_p1(targetIndex - 1).takeDamage((byte)1,1,targetIndex,boardState,deck);
      ++index;
    }
    if (boardState.data_.getHero_p1().getHealth() <= 0) {
      break;
    }
  }
  Iterator<Minion> iter=boardState.data_.getMinions_p1().iterator();
  while (iter.hasNext()) {
    Minion targetMinion=iter.next();
    if (targetMinion.getHealth() <= 0) {
      iter.remove();
    }
  }
  return super.use_core(thisCardIndex,playerIndex,minionIndex,boardState,deck);
}","/** 
 * Use the card on the given target Deals 1 damage to three random enemy characters.  The characters can repeat.
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override protected HearthTreeNode<BoardState> use_core(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  if (playerIndex == 0) {
    return null;
  }
  if (minionIndex > 0) {
    return null;
  }
  int numMissiles=3 + boardState.data_.getSpellDamage(0);
  int numTargets=boardState.data_.getNumMinions_p1() + 1;
  int index=0;
  while (index < numMissiles) {
    int targetIndex=(int)(numTargets * Math.random());
    if (targetIndex == 0 && boardState.data_.getHero_p1().getHealth() > 0) {
      boardState.data_.getHero_p1().takeDamage((byte)1,0,1,targetIndex,boardState,deck);
      ++index;
    }
 else     if (targetIndex > 0 && boardState.data_.getMinion_p1(targetIndex - 1).getHealth() > 0) {
      boardState.data_.getMinion_p1(targetIndex - 1).takeDamage((byte)1,0,1,targetIndex,boardState,deck);
      ++index;
    }
    if (boardState.data_.getHero_p1().getHealth() <= 0) {
      break;
    }
  }
  Iterator<Minion> iter=boardState.data_.getMinions_p1().iterator();
  while (iter.hasNext()) {
    Minion targetMinion=iter.next();
    if (targetMinion.getHealth() <= 0) {
      iter.remove();
    }
  }
  return super.use_core(thisCardIndex,playerIndex,minionIndex,boardState,deck);
}",0.8771929824561403
112862,"/** 
 * Hellfire Deals 3 damage to all characters
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override protected HearthTreeNode<BoardState> use_core(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  if (playerIndex > 0 || minionIndex > 0)   return null;
  HearthTreeNode<BoardState> toRet=boardState;
  boardState.data_.getHero_p1().takeDamage(DAMAGE_AMOUNT,0,0,boardState,deck);
  for (int indx=0; indx < boardState.data_.getNumMinions_p1(); ++indx) {
    Minion targetMinion=boardState.data_.getMinion_p1(indx);
    targetMinion.takeDamage(DAMAGE_AMOUNT,1,indx + 1,boardState,deck,true);
  }
  boardState.data_.getHero_p0().takeDamage(DAMAGE_AMOUNT,0,0,boardState,deck);
  for (int indx=0; indx < boardState.data_.getNumMinions_p0(); ++indx) {
    Minion targetMinion=boardState.data_.getMinion_p0(indx);
    targetMinion.takeDamage(DAMAGE_AMOUNT,0,indx + 1,boardState,deck,true);
  }
  Iterator<Minion> iter=boardState.data_.getMinions_p0().iterator();
  while (iter.hasNext()) {
    Minion targetMinion=iter.next();
    if (targetMinion.getHealth() <= 0) {
      iter.remove();
    }
  }
  iter=boardState.data_.getMinions_p1().iterator();
  while (iter.hasNext()) {
    Minion targetMinion=iter.next();
    if (targetMinion.getHealth() <= 0) {
      iter.remove();
    }
  }
  return super.use_core(thisCardIndex,playerIndex,minionIndex,boardState,deck);
}","/** 
 * Hellfire Deals 3 damage to all characters
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override protected HearthTreeNode<BoardState> use_core(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  if (playerIndex > 0 || minionIndex > 0)   return null;
  HearthTreeNode<BoardState> toRet=boardState;
  boardState.data_.getHero_p1().takeDamage(DAMAGE_AMOUNT,0,0,0,boardState,deck);
  for (int indx=0; indx < boardState.data_.getNumMinions_p1(); ++indx) {
    Minion targetMinion=boardState.data_.getMinion_p1(indx);
    targetMinion.takeDamage(DAMAGE_AMOUNT,0,1,indx + 1,boardState,deck,true);
  }
  boardState.data_.getHero_p0().takeDamage(DAMAGE_AMOUNT,0,0,0,boardState,deck);
  for (int indx=0; indx < boardState.data_.getNumMinions_p0(); ++indx) {
    Minion targetMinion=boardState.data_.getMinion_p0(indx);
    targetMinion.takeDamage(DAMAGE_AMOUNT,0,0,indx + 1,boardState,deck,true);
  }
  Iterator<Minion> iter=boardState.data_.getMinions_p0().iterator();
  while (iter.hasNext()) {
    Minion targetMinion=iter.next();
    if (targetMinion.getHealth() <= 0) {
      iter.remove();
    }
  }
  iter=boardState.data_.getMinions_p1().iterator();
  while (iter.hasNext()) {
    Minion targetMinion=iter.next();
    if (targetMinion.getHealth() <= 0) {
      iter.remove();
    }
  }
  return super.use_core(thisCardIndex,playerIndex,minionIndex,boardState,deck);
}",0.9978201634877384
112863,"/** 
 * Hellfire Deals 3 damage to all characters
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override protected HearthTreeNode<BoardState> use_core(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  if (playerIndex > 0 || minionIndex > 0)   return null;
  HearthTreeNode<BoardState> toRet=boardState;
  boardState.data_.getHero_p1().takeDamage(DAMAGE_AMOUNT,0,0,0,boardState,deck);
  for (int indx=0; indx < boardState.data_.getNumMinions_p1(); ++indx) {
    Minion targetMinion=boardState.data_.getMinion_p1(indx);
    targetMinion.takeDamage(DAMAGE_AMOUNT,0,1,indx + 1,boardState,deck,true);
  }
  boardState.data_.getHero_p0().takeDamage(DAMAGE_AMOUNT,0,0,0,boardState,deck);
  for (int indx=0; indx < boardState.data_.getNumMinions_p0(); ++indx) {
    Minion targetMinion=boardState.data_.getMinion_p0(indx);
    targetMinion.takeDamage(DAMAGE_AMOUNT,0,0,indx + 1,boardState,deck,true);
  }
  Iterator<Minion> iter=boardState.data_.getMinions_p0().iterator();
  while (iter.hasNext()) {
    Minion targetMinion=iter.next();
    if (targetMinion.getHealth() <= 0) {
      iter.remove();
    }
  }
  iter=boardState.data_.getMinions_p1().iterator();
  while (iter.hasNext()) {
    Minion targetMinion=iter.next();
    if (targetMinion.getHealth() <= 0) {
      iter.remove();
    }
  }
  return super.use_core(thisCardIndex,playerIndex,minionIndex,boardState,deck);
}","/** 
 * Hellfire Deals 3 damage to all characters
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override protected HearthTreeNode<BoardState> use_core(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  if (playerIndex > 0 || minionIndex > 0)   return null;
  HearthTreeNode<BoardState> toRet=boardState;
  boardState.data_.getHero_p1().takeDamage(DAMAGE_AMOUNT,0,0,0,boardState,deck,true);
  for (int indx=0; indx < boardState.data_.getNumMinions_p1(); ++indx) {
    Minion targetMinion=boardState.data_.getMinion_p1(indx);
    targetMinion.takeDamage(DAMAGE_AMOUNT,0,1,indx + 1,boardState,deck,true);
  }
  boardState.data_.getHero_p0().takeDamage(DAMAGE_AMOUNT,0,0,0,boardState,deck,true);
  for (int indx=0; indx < boardState.data_.getNumMinions_p0(); ++indx) {
    Minion targetMinion=boardState.data_.getMinion_p0(indx);
    targetMinion.takeDamage(DAMAGE_AMOUNT,0,0,indx + 1,boardState,deck,true);
  }
  Iterator<Minion> iter=boardState.data_.getMinions_p0().iterator();
  while (iter.hasNext()) {
    Minion targetMinion=iter.next();
    if (targetMinion.getHealth() <= 0) {
      iter.remove();
    }
  }
  iter=boardState.data_.getMinions_p1().iterator();
  while (iter.hasNext()) {
    Minion targetMinion=iter.next();
    if (targetMinion.getHealth() <= 0) {
      iter.remove();
    }
  }
  return super.use_core(thisCardIndex,playerIndex,minionIndex,boardState,deck);
}",0.997288503253796
112864,"/** 
 * Use the card on the given target Summons either Huffer, Leokk, or Misha
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override protected HearthTreeNode<BoardState> use_core(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  if (minionIndex > 0 || playerIndex == 1) {
    return null;
  }
  int numMinions=boardState.data_.getNumMinions_p0();
  if (numMinions >= 7)   return null;
  double rnd=Math.random();
  Minion minion=null;
  if (rnd < 0.333333333333333333333333333) {
    minion=new Huffer();
  }
 else   if (rnd > 0.66666666666666666666666666666) {
    minion=new Leokk();
  }
 else {
    minion=new Misha();
  }
  boardState.data_.placeCard_hand_p0(minion);
  HearthTreeNode<BoardState> toRet=minion.useOn(boardState.data_.getNumCards_hand() - 1,playerIndex,numMinions + 1,boardState,deck);
  return super.use_core(thisCardIndex,playerIndex,minionIndex,toRet,deck);
}","/** 
 * Use the card on the given target Summons either Huffer, Leokk, or Misha
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override protected HearthTreeNode<BoardState> use_core(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  if (minionIndex > 0 || playerIndex == 1) {
    return null;
  }
  int numMinions=boardState.data_.getNumMinions_p0();
  if (numMinions >= 7)   return null;
  double rnd=Math.random();
  Minion minion=null;
  if (rnd < 0.333333333333333333333333333) {
    minion=new Huffer();
  }
 else   if (rnd > 0.66666666666666666666666666666) {
    minion=new Leokk();
  }
 else {
    minion=new Misha();
  }
  boardState.data_.setMana_p0(boardState.data_.getMana_p0() + 3);
  boardState.data_.placeCard_hand_p0(minion);
  HearthTreeNode<BoardState> toRet=minion.useOn(boardState.data_.getNumCards_hand() - 1,playerIndex,numMinions + 1,boardState,deck);
  return super.use_core(thisCardIndex,playerIndex,minionIndex,toRet,deck);
}",0.976156069364162
112865,"@Test public void test1() throws HSInvalidPlayerIndexException {
  Card theCard=board.data_.getCard_hand_p0(0);
  HearthTreeNode<BoardState> ret=theCard.useOn(0,0,0,board,deck);
  assertFalse(ret == null);
  assertEquals(board.data_.getNumCards_hand(),0);
  assertEquals(board.data_.getNumMinions_p0(),3);
  assertEquals(board.data_.getNumMinions_p1(),2);
  assertEquals(board.data_.getHero_p0().getHealth(),30);
  assertEquals(board.data_.getHero_p1().getHealth(),30);
  assertEquals(board.data_.getMinion_p0(0).getHealth(),health0);
  assertEquals(board.data_.getMinion_p0(1).getHealth(),health1 - 1);
  assertEquals(board.data_.getMinion_p1(0).getHealth(),health0);
  assertEquals(board.data_.getMinion_p1(1).getHealth(),health1 - 1);
  if (board.data_.getMinion_p0(2) instanceof Leokk) {
    assertEquals(board.data_.getMinion_p0(0).getAttack(),attack0 + 1);
    assertEquals(board.data_.getMinion_p0(1).getAttack(),attack0 + 1);
  }
 else {
    assertEquals(board.data_.getMinion_p0(0).getAttack(),attack0);
    assertEquals(board.data_.getMinion_p0(1).getAttack(),attack0);
  }
  assertEquals(board.data_.getMinion_p1(0).getAttack(),attack0);
  assertEquals(board.data_.getMinion_p1(1).getAttack(),attack0);
}","@Test public void test1() throws HSInvalidPlayerIndexException {
  Card theCard=board.data_.getCard_hand_p0(0);
  HearthTreeNode<BoardState> ret=theCard.useOn(0,0,0,board,deck);
  assertFalse(ret == null);
  assertEquals(0,board.data_.getNumCards_hand());
  assertEquals(1,board.data_.getMana_p0());
  assertEquals(3,board.data_.getNumMinions_p0());
  assertEquals(2,board.data_.getNumMinions_p1());
  assertEquals(30,board.data_.getHero_p0().getHealth());
  assertEquals(30,board.data_.getHero_p1().getHealth());
  assertEquals(health0,board.data_.getMinion_p0(0).getHealth());
  assertEquals(health1 - 1,board.data_.getMinion_p0(1).getHealth());
  assertEquals(health0,board.data_.getMinion_p1(0).getHealth());
  assertEquals(health1 - 1,board.data_.getMinion_p1(1).getHealth());
  if (board.data_.getMinion_p0(2) instanceof Leokk) {
    assertEquals(board.data_.getMinion_p0(0).getAttack(),attack0 + 1);
    assertEquals(board.data_.getMinion_p0(1).getAttack(),attack0 + 1);
  }
 else {
    assertEquals(board.data_.getMinion_p0(0).getAttack(),attack0);
    assertEquals(board.data_.getMinion_p0(1).getAttack(),attack0);
  }
  assertEquals(board.data_.getMinion_p1(0).getAttack(),attack0);
  assertEquals(board.data_.getMinion_p1(1).getAttack(),attack0);
}",0.5804365400161682
112866,"/** 
 * Use the weapon card
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override protected HearthTreeNode<BoardState> use_core(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  if (this.hasBeenUsed()) {
    return null;
  }
  this.hasBeenUsed(true);
  if (playerIndex == 1 || minionIndex > 0) {
    return null;
  }
  HearthTreeNode<BoardState> toRet=boardState;
  if (toRet != null) {
    toRet.data_.getHero_p0().setAttack(this.weaponDamage_);
    toRet.data_.getHero_p0().setWeaponCharge(this.weaponCharge_);
  }
  return super.use_core(thisCardIndex,playerIndex,minionIndex,toRet,deck);
}","/** 
 * Use the weapon card
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override protected HearthTreeNode<BoardState> use_core(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  if (this.hasBeenUsed()) {
    return null;
  }
  if (playerIndex == 1 || minionIndex > 0) {
    return null;
  }
  HearthTreeNode<BoardState> toRet=boardState;
  if (toRet != null) {
    toRet.data_.getHero_p0().setAttack(this.weaponDamage_);
    toRet.data_.getHero_p0().setWeaponCharge(this.weaponCharge_);
    this.hasBeenUsed(true);
  }
  return super.use_core(thisCardIndex,playerIndex,minionIndex,toRet,deck);
}",0.9746001881467544
112867,"/** 
 * Use the card on the given target
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
public HearthTreeNode<BoardState> useOn(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck){
  HearthTreeNode<BoardState> toRet=this.use_core(thisCardIndex,playerIndex,minionIndex,boardState,deck);
  if (toRet != null) {
    for (int j=0; j < toRet.data_.getNumCards_hand(); ++j) {
      toRet=toRet.data_.getCard_hand_p0(j).otherCardUsedEvent(j,toRet,deck);
    }
    toRet=toRet.data_.getHero_p0().otherCardUsedEvent(0,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p0(); ++j) {
      toRet=toRet.data_.getMinion_p0(j).otherCardUsedEvent(j,toRet,deck);
    }
    toRet=toRet.data_.getHero_p1().otherCardUsedEvent(0,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p1(); ++j) {
      toRet=toRet.data_.getMinion_p1(j).otherCardUsedEvent(j,toRet,deck);
    }
  }
  return toRet;
}","/** 
 * Use the card on the given target
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
public HearthTreeNode<BoardState> useOn(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  HearthTreeNode<BoardState> toRet=this.use_core(thisCardIndex,playerIndex,minionIndex,boardState,deck);
  if (toRet != null) {
    for (int j=0; j < toRet.data_.getNumCards_hand(); ++j) {
      toRet=toRet.data_.getCard_hand_p0(j).otherCardUsedEvent(j,toRet,deck);
    }
    toRet=toRet.data_.getHero_p0().otherCardUsedEvent(0,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p0(); ++j) {
      toRet=toRet.data_.getMinion_p0(j).otherCardUsedEvent(j,toRet,deck);
    }
    toRet=toRet.data_.getHero_p1().otherCardUsedEvent(0,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p1(); ++j) {
      toRet=toRet.data_.getMinion_p1(j).otherCardUsedEvent(j,toRet,deck);
    }
  }
  return toRet;
}",0.9857784431137724
112868,"/** 
 * Use the card on the given target This is the core implementation of card's ability
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
protected HearthTreeNode<BoardState> use_core(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck){
  boardState.data_.setMana_p0(boardState.data_.getMana_p0() - this.mana_);
  boardState.data_.removeCard_hand(thisCardIndex);
  return boardState;
}","/** 
 * Use the card on the given target This is the core implementation of card's ability
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
protected HearthTreeNode<BoardState> use_core(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  boardState.data_.setMana_p0(boardState.data_.getMana_p0() - this.mana_);
  boardState.data_.removeCard_hand(thisCardIndex);
  return boardState;
}",0.9770253929866988
112869,"public void takeHeal(byte healAmount,int thisMinionIndex,int thisPlayerIndex,HearthTreeNode<BoardState> boardState,Deck deck){
  if (health_ < maxHealth_) {
    if (health_ + healAmount > maxHealth_)     health_=maxHealth_;
 else     health_=(byte)(health_ + healAmount);
    HearthTreeNode<BoardState> toRet=boardState;
    toRet=toRet.data_.getHero_p0().minionHealedEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p0(); ++j) {
      toRet=toRet.data_.getMinion_p0(j).minionHealedEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
    }
    toRet=toRet.data_.getHero_p1().minionHealedEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p1(); ++j) {
      toRet=toRet.data_.getMinion_p1(j).minionHealedEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
    }
  }
}","public void takeHeal(byte healAmount,int thisPlayerIndex,int thisMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  if (health_ < maxHealth_) {
    if (health_ + healAmount > maxHealth_)     health_=maxHealth_;
 else     health_=(byte)(health_ + healAmount);
    HearthTreeNode<BoardState> toRet=boardState;
    toRet=toRet.data_.getHero_p0().minionHealedEvent(0,0,thisPlayerIndex,thisMinionIndex,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p0(); ++j) {
      toRet=toRet.data_.getMinion_p0(j).minionHealedEvent(0,j + 1,thisPlayerIndex,thisMinionIndex,toRet,deck);
    }
    toRet=toRet.data_.getHero_p1().minionHealedEvent(0,0,thisPlayerIndex,thisMinionIndex,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p1(); ++j) {
      toRet=toRet.data_.getMinion_p1(j).minionHealedEvent(0,j + 1,thisPlayerIndex,thisMinionIndex,toRet,deck);
    }
  }
}",0.942889137737962
112870,"/** 
 * Use the card on the given target
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override protected HearthTreeNode<BoardState> use_core(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck){
  if (hasBeenUsed_) {
    return null;
  }
  if (playerIndex == 1 || minionIndex == 0)   return null;
  if (boardState.data_.getNumMinions_p0() < 7) {
    if (!charge_) {
      hasAttacked_=true;
    }
    hasBeenUsed_=true;
    boardState.data_.placeMinion_p0(this,minionIndex - 1);
    boardState.data_.setMana_p0(boardState.data_.getMana_p0() - this.mana_);
    boardState.data_.removeCard_hand(thisCardIndex);
    return boardState;
  }
 else {
    return null;
  }
}","/** 
 * Use the card on the given target
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override protected HearthTreeNode<BoardState> use_core(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  if (hasBeenUsed_) {
    return null;
  }
  if (playerIndex == 1 || minionIndex == 0)   return null;
  if (boardState.data_.getNumMinions_p0() < 7) {
    if (!charge_) {
      hasAttacked_=true;
    }
    hasBeenUsed_=true;
    boardState.data_.placeMinion_p0(this,minionIndex - 1);
    boardState.data_.setMana_p0(boardState.data_.getMana_p0() - this.mana_);
    boardState.data_.removeCard_hand(thisCardIndex);
    return boardState;
  }
 else {
    return null;
  }
}",0.9828828828828828
112871,"/** 
 * Attack with the minion
 * @param thisMinionIndex Attacking minion's index (note: attacking player index is assumed to be 0)
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
public final HearthTreeNode<BoardState> attack(int thisMinionIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck){
  HearthTreeNode<BoardState> toRet=boardState;
  if (playerIndex == 0 && toRet != null) {
    toRet=toRet.data_.getHero_p0().minionAttackingEvent(0,thisMinionIndex,playerIndex,minionIndex,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p0(); ++j) {
      toRet=toRet.data_.getMinion_p0(j).minionAttackingEvent(0,thisMinionIndex,playerIndex,minionIndex,toRet,deck);
    }
    toRet=toRet.data_.getHero_p1().minionAttackingEvent(0,thisMinionIndex,playerIndex,minionIndex,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p1(); ++j) {
      toRet=toRet.data_.getMinion_p1(j).minionAttackingEvent(0,thisMinionIndex,playerIndex,minionIndex,toRet,deck);
    }
  }
  toRet=this.attack_core(thisMinionIndex,playerIndex,minionIndex,boardState,deck);
  return toRet;
}","/** 
 * Attack with the minion
 * @param thisMinionIndex Attacking minion's index (note: attacking player index is assumed to be 0)
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
public final HearthTreeNode<BoardState> attack(int thisMinionIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  HearthTreeNode<BoardState> toRet=boardState;
  if (toRet != null) {
    toRet=toRet.data_.getHero_p0().minionAttackingEvent(0,thisMinionIndex,playerIndex,minionIndex,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p0(); ++j) {
      toRet=toRet.data_.getMinion_p0(j).minionAttackingEvent(0,thisMinionIndex,playerIndex,minionIndex,toRet,deck);
    }
    toRet=toRet.data_.getHero_p1().minionAttackingEvent(0,thisMinionIndex,playerIndex,minionIndex,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p1(); ++j) {
      toRet=toRet.data_.getMinion_p1(j).minionAttackingEvent(0,thisMinionIndex,playerIndex,minionIndex,toRet,deck);
    }
  }
  toRet=this.attack_core(thisMinionIndex,playerIndex,minionIndex,boardState,deck);
  return toRet;
}",0.979663394109397
112872,"/** 
 * Use the card on the given target
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public final HearthTreeNode<BoardState> useOn(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck){
  HearthTreeNode<BoardState> toRet=super.useOn(thisCardIndex,playerIndex,minionIndex,boardState,deck);
  if (playerIndex == 0 && toRet != null) {
    toRet=toRet.data_.getHero_p0().otherCardUsedEvent(0,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p0(); ++j) {
      toRet=toRet.data_.getMinion_p0(j).minionCreatedEvent(playerIndex,minionIndex,toRet,deck);
    }
    toRet=toRet.data_.getHero_p1().otherCardUsedEvent(0,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p1(); ++j) {
      toRet=toRet.data_.getMinion_p1(j).minionCreatedEvent(playerIndex,minionIndex,toRet,deck);
    }
  }
  return toRet;
}","/** 
 * Use the card on the given target
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public final HearthTreeNode<BoardState> useOn(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  HearthTreeNode<BoardState> toRet=super.useOn(thisCardIndex,playerIndex,minionIndex,boardState,deck);
  if (playerIndex == 0 && toRet != null) {
    toRet=toRet.data_.getHero_p0().otherCardUsedEvent(0,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p0(); ++j) {
      toRet=toRet.data_.getMinion_p0(j).minionCreatedEvent(playerIndex,minionIndex,toRet,deck);
    }
    toRet=toRet.data_.getHero_p1().otherCardUsedEvent(0,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p1(); ++j) {
      toRet=toRet.data_.getMinion_p1(j).minionCreatedEvent(playerIndex,minionIndex,toRet,deck);
    }
  }
  return toRet;
}",0.9850393700787402
112873,"public void takeDamage(byte damage,int thisMinionIndex,int thisPlayerIndex,HearthTreeNode<BoardState> boardState,Deck deck){
  if (!divineShield_) {
    health_=(byte)(health_ - damage);
    HearthTreeNode<BoardState> toRet=boardState;
    toRet=toRet.data_.getHero_p0().minionDamagedEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p0(); ++j) {
      toRet=toRet.data_.getMinion_p0(j).minionDamagedEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
    }
    toRet=toRet.data_.getHero_p1().minionDamagedEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p1(); ++j) {
      toRet=toRet.data_.getMinion_p1(j).minionDamagedEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
    }
    if (health_ <= 0) {
      toRet=toRet.data_.getHero_p0().minionDeadEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
      for (int j=0; j < toRet.data_.getNumMinions_p0(); ++j) {
        toRet=toRet.data_.getMinion_p0(j).minionDeadEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
      }
      toRet=toRet.data_.getHero_p1().minionDeadEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
      for (int j=0; j < toRet.data_.getNumMinions_p1(); ++j) {
        toRet=toRet.data_.getMinion_p1(j).minionDeadEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
      }
    }
  }
 else {
    divineShield_=false;
  }
}","public void takeDamage(byte damage,int thisPlayerIndex,int thisMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  if (!divineShield_) {
    health_=(byte)(health_ - damage);
    HearthTreeNode<BoardState> toRet=boardState;
    toRet=toRet.data_.getHero_p0().minionDamagedEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p0(); ++j) {
      toRet=toRet.data_.getMinion_p0(j).minionDamagedEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
    }
    toRet=toRet.data_.getHero_p1().minionDamagedEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
    for (int j=0; j < toRet.data_.getNumMinions_p1(); ++j) {
      toRet=toRet.data_.getMinion_p1(j).minionDamagedEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
    }
    if (health_ <= 0) {
      toRet=toRet.data_.getHero_p0().minionDeadEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
      for (int j=0; j < toRet.data_.getNumMinions_p0(); ++j) {
        toRet=toRet.data_.getMinion_p0(j).minionDeadEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
      }
      toRet=toRet.data_.getHero_p1().minionDeadEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
      for (int j=0; j < toRet.data_.getNumMinions_p1(); ++j) {
        toRet=toRet.data_.getMinion_p1(j).minionDeadEvent(thisPlayerIndex,thisMinionIndex,toRet,deck);
      }
    }
  }
 else {
    divineShield_=false;
  }
}",0.9723600283486888
112874,"/** 
 * Attack with the minion
 * @param thisMinionIndex Attacking minion's index (note: attacking player index is assumed to be 0)
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
protected HearthTreeNode<BoardState> attack_core(int thisMinionIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck){
  if (hasAttacked_) {
    return null;
  }
  if (minionIndex == 0) {
    boardState.data_.getHero_p1().takeDamage(this.attack_,playerIndex,minionIndex,boardState,deck);
    this.takeDamage(boardState.data_.getHero_p1().attack_,0,thisMinionIndex,boardState,deck);
    if (windFury_ && !hasWindFuryAttacked_)     hasWindFuryAttacked_=true;
 else     hasAttacked_=true;
    return boardState;
  }
 else {
    Minion target=boardState.data_.getMinion_p1(minionIndex - 1);
    target.takeDamage(this.attack_,playerIndex,minionIndex,boardState,deck);
    this.takeDamage(target.attack_,0,thisMinionIndex,boardState,deck);
    if (target.getHealth() <= 0) {
      boardState.data_.removeMinion_p1(target);
    }
    if (health_ <= 0) {
      boardState.data_.removeMinion_p0(thisMinionIndex - 1);
    }
    if (windFury_ && !hasWindFuryAttacked_)     hasWindFuryAttacked_=true;
 else     hasAttacked_=true;
    return boardState;
  }
}","/** 
 * Attack with the minion
 * @param thisMinionIndex Attacking minion's index (note: attacking player index is assumed to be 0)
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
protected HearthTreeNode<BoardState> attack_core(int thisMinionIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  if (hasAttacked_) {
    return null;
  }
  if (minionIndex == 0) {
    boardState.data_.getHero_p1().takeDamage(this.attack_,playerIndex,minionIndex,boardState,deck);
    this.takeDamage(boardState.data_.getHero_p1().attack_,0,thisMinionIndex,boardState,deck);
    if (windFury_ && !hasWindFuryAttacked_)     hasWindFuryAttacked_=true;
 else     hasAttacked_=true;
    return boardState;
  }
 else {
    Minion target=boardState.data_.getMinion_p1(minionIndex - 1);
    target.takeDamage(this.attack_,playerIndex,minionIndex,boardState,deck);
    this.takeDamage(target.attack_,0,thisMinionIndex,boardState,deck);
    if (target.getHealth() <= 0) {
      boardState.data_.removeMinion_p1(target);
    }
    if (health_ <= 0) {
      boardState.data_.removeMinion_p0(thisMinionIndex - 1);
    }
    if (windFury_ && !hasWindFuryAttacked_)     hasWindFuryAttacked_=true;
 else     hasAttacked_=true;
    return boardState;
  }
}",0.9880050505050504
112875,"/** 
 * Called whenever another character (including the hero) is healed
 * @param playerIndex The index of the healed minion's player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the healed minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
protected HearthTreeNode<BoardState> minionHealedEvent(int healedMinionPlayerIndex,int healedMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck){
  return boardState;
}","/** 
 * Called whenever another character (including the hero) is healed
 * @param playerIndex The index of the healed minion's player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the healed minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
protected HearthTreeNode<BoardState> minionHealedEvent(int thisMinionPlayerIndex,int thisMinionIndex,int healedMinionPlayerIndex,int healedMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  return boardState;
}",0.9358778625954198
112876,"/** 
 * Use the card on the given target This is an abstract function, at least conceptually.
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public HearthTreeNode<BoardState> use_core(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck){
  boardState.data_.setMana_p0(boardState.data_.getMana_p0() - this.mana_);
  boardState.data_.removeCard_hand(thisCardIndex);
  return boardState;
}","/** 
 * Use the card on the given target This is an abstract function, at least conceptually.
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override protected HearthTreeNode<BoardState> use_core(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  boardState.data_.setMana_p0(boardState.data_.getMana_p0() - this.mana_);
  boardState.data_.removeCard_hand(thisCardIndex);
  return boardState;
}",0.9695885509838998
112877,"public void attack(Minion minion,int targetPlayerIndex,int targetMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck){
  minion.takeDamage(damage_,targetPlayerIndex,targetMinionIndex,boardState,deck);
}","public void attack(Minion minion,int targetPlayerIndex,int targetMinionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  minion.takeDamage(damage_,targetPlayerIndex,targetMinionIndex,boardState,deck);
}",0.9170305676855895
112878,"/** 
 * Use the card on the given target
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public HearthTreeNode<BoardState> use_core(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck){
  if (this.hasBeenUsed()) {
    return null;
  }
  this.hasBeenUsed(true);
  if (minionIndex == 0) {
    if (playerIndex == 0) {
      this.attack(boardState.data_.getHero_p0(),playerIndex,minionIndex,boardState,deck);
    }
 else {
      this.attack(boardState.data_.getHero_p1(),playerIndex,minionIndex,boardState,deck);
    }
    boardState.data_.setMana_p0(boardState.data_.getMana_p0() - this.mana_);
    boardState.data_.removeCard_hand(thisCardIndex);
    return boardState;
  }
 else {
    Minion target=null;
    if (playerIndex == 0) {
      if (boardState.data_.getNumMinions_p0() + 1 > minionIndex)       target=boardState.data_.getMinion_p0(minionIndex - 1);
 else       return null;
    }
 else {
      if (boardState.data_.getNumMinions_p1() + 1 > minionIndex)       target=boardState.data_.getMinion_p1(minionIndex - 1);
 else       return null;
    }
    this.attack(target,playerIndex,minionIndex,boardState,deck);
    boardState.data_.setMana_p0(boardState.data_.getMana_p0() - this.mana_);
    boardState.data_.removeCard_hand(thisCardIndex);
    if (target.getHealth() <= 0) {
      if (playerIndex == 0)       boardState.data_.removeMinion_p0(target);
 else       boardState.data_.removeMinion_p1(target);
    }
    return boardState;
  }
}","/** 
 * Use the card on the given target
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override protected HearthTreeNode<BoardState> use_core(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  if (this.hasBeenUsed()) {
    return null;
  }
  this.hasBeenUsed(true);
  if (minionIndex == 0) {
    if (playerIndex == 0) {
      this.attack(boardState.data_.getHero_p0(),playerIndex,minionIndex,boardState,deck);
    }
 else {
      this.attack(boardState.data_.getHero_p1(),playerIndex,minionIndex,boardState,deck);
    }
    boardState.data_.setMana_p0(boardState.data_.getMana_p0() - this.mana_);
    boardState.data_.removeCard_hand(thisCardIndex);
    return boardState;
  }
 else {
    Minion target=null;
    if (playerIndex == 0) {
      if (boardState.data_.getNumMinions_p0() + 1 > minionIndex)       target=boardState.data_.getMinion_p0(minionIndex - 1);
 else       return null;
    }
 else {
      if (boardState.data_.getNumMinions_p1() + 1 > minionIndex)       target=boardState.data_.getMinion_p1(minionIndex - 1);
 else       return null;
    }
    this.attack(target,playerIndex,minionIndex,boardState,deck);
    boardState.data_.setMana_p0(boardState.data_.getMana_p0() - this.mana_);
    boardState.data_.removeCard_hand(thisCardIndex);
    if (target.getHealth() <= 0) {
      if (playerIndex == 0)       boardState.data_.removeMinion_p0(target);
 else       boardState.data_.removeMinion_p1(target);
    }
    return boardState;
  }
}",0.9871018689128718
112879,"/** 
 * Use the card on the given target This card heals the target minion up to full health and gives it taunt.  Cannot be used on heroes.
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public HearthTreeNode<BoardState> use_core(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck){
  if (minionIndex == 0) {
    return null;
  }
  Minion targetMinion;
  if (playerIndex == 0) {
    targetMinion=boardState.data_.getMinion_p0(minionIndex - 1);
  }
 else {
    targetMinion=boardState.data_.getMinion_p1(minionIndex - 1);
  }
  targetMinion.setHealth(targetMinion.getMaxHealth());
  targetMinion.setTaunt(true);
  return super.useOn(thisCardIndex,playerIndex,minionIndex,boardState,deck);
}","/** 
 * Use the card on the given target This card heals the target minion up to full health and gives it taunt.  Cannot be used on heroes.
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override protected HearthTreeNode<BoardState> use_core(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  if (minionIndex == 0) {
    return null;
  }
  Minion targetMinion;
  if (playerIndex == 0) {
    targetMinion=boardState.data_.getMinion_p0(minionIndex - 1);
  }
 else {
    targetMinion=boardState.data_.getMinion_p1(minionIndex - 1);
  }
  targetMinion.setHealth(targetMinion.getMaxHealth());
  targetMinion.setTaunt(true);
  return super.use_core(thisCardIndex,playerIndex,minionIndex,boardState,deck);
}",0.9755244755244756
112880,"/** 
 * Use the card on the given target This card damages all enemy minions by 1
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public HearthTreeNode<BoardState> use_core(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck){
  if (playerIndex == 0) {
    return null;
  }
  if (minionIndex > 0) {
    return null;
  }
  Iterator<Minion> iter=boardState.data_.getMinions_p1().iterator();
  while (iter.hasNext()) {
    Minion targetMinion=iter.next();
    targetMinion.setHealth((byte)(targetMinion.getHealth() - 1));
    if (targetMinion.getHealth() <= 0) {
      iter.remove();
    }
  }
  return super.useOn(thisCardIndex,playerIndex,minionIndex,boardState,deck);
}","/** 
 * Use the card on the given target This card damages all enemy minions by 1
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override protected HearthTreeNode<BoardState> use_core(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  if (playerIndex == 0) {
    return null;
  }
  if (minionIndex > 0) {
    return null;
  }
  Iterator<Minion> iter=boardState.data_.getMinions_p1().iterator();
  while (iter.hasNext()) {
    Minion targetMinion=iter.next();
    targetMinion.setHealth((byte)(targetMinion.getHealth() - 1));
    if (targetMinion.getHealth() <= 0) {
      iter.remove();
    }
  }
  return super.use_core(thisCardIndex,playerIndex,minionIndex,boardState,deck);
}",0.9750445632798574
112881,"/** 
 * Use the card on the given target This card draws 2 cards from the deck.
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public HearthTreeNode<BoardState> use_core(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck){
  if (playerIndex == 1 || minionIndex > 0) {
    return null;
  }
  for (int index=0; index < 2; ++index) {
    Card card=deck.drawCard(boardState.data_.getDeckPos_p0());
    if (card == null) {
      byte fatigueDamage=boardState.data_.getFatigueDamage_p0();
      boardState.data_.setFatigueDamage_p0((byte)(fatigueDamage + 1));
      boardState.data_.getHero_p0().setHealth((byte)(boardState.data_.getHero_p0().getHealth() - fatigueDamage));
    }
 else {
      boardState.data_.placeCard_hand_p0(card);
      boardState.data_.setDeckPos_p0(boardState.data_.getDeckPos_p0() + 1);
    }
  }
  return super.useOn(thisCardIndex,playerIndex,minionIndex,boardState,deck);
}","/** 
 * Use the card on the given target This card draws 2 cards from the deck.
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override protected HearthTreeNode<BoardState> use_core(int thisCardIndex,int playerIndex,int minionIndex,HearthTreeNode<BoardState> boardState,Deck deck) throws HSInvalidPlayerIndexException {
  if (playerIndex == 1 || minionIndex > 0) {
    return null;
  }
  for (int index=0; index < 2; ++index) {
    Card card=deck.drawCard(boardState.data_.getDeckPos_p0());
    if (card == null) {
      byte fatigueDamage=boardState.data_.getFatigueDamage_p0();
      boardState.data_.setFatigueDamage_p0((byte)(fatigueDamage + 1));
      boardState.data_.getHero_p0().setHealth((byte)(boardState.data_.getHero_p0().getHealth() - fatigueDamage));
    }
 else {
      boardState.data_.placeCard_hand_p0(card);
      boardState.data_.setDeckPos_p0(boardState.data_.getDeckPos_p0() + 1);
    }
  }
  return super.use_core(thisCardIndex,playerIndex,minionIndex,boardState,deck);
}",0.9785025945144552
112882,"/** 
 * Use the card on the given target The Minion class can have two states: one as a card in the hand, and the other as a minion on the field.
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public BoardState useOn(int thisCardIndex,int playerIndex,int minionIndex,BoardState boardState){
  if (this.hasBeenUsed_) {
    return null;
  }
  if (playerIndex == 0) {
    if (isInHand_ && boardState.getNumMinions_p0() < 7) {
      if (minionIndex == 0) {
        return null;
      }
      if (!charge_) {
        this.hasAttacked_=true;
        this.hasBeenUsed_=true;
      }
      boardState.placeMinion_p0(this,minionIndex - 1);
      boardState.setMana_p0(boardState.getMana_p0() - this.mana_);
      boardState.removeCard_hand(thisCardIndex);
      return boardState;
    }
 else {
      return null;
    }
  }
 else {
    if (!isInHand_) {
      if (minionIndex == 0) {
        this.attack(boardState.getHero_p1());
        if (windFury_ && !hasWindFuryAttacked_)         hasWindFuryAttacked_=true;
 else         hasAttacked_=true;
        return boardState;
      }
 else {
        Minion target=boardState.getMinion_p1(minionIndex - 1);
        this.attack(target);
        if (target.getHealth() <= 0) {
          boardState.removeMinion_p1(target);
        }
        if (health_ <= 0) {
          boardState.removeMinion_p0(thisCardIndex);
        }
        if (windFury_ && !hasWindFuryAttacked_)         hasWindFuryAttacked_=true;
 else         hasAttacked_=true;
        return boardState;
      }
    }
 else {
      return null;
    }
  }
}","/** 
 * Use the card on the given target The Minion class can have two states: one as a card in the hand, and the other as a minion on the field.
 * @param thisCardIndex The index (position) of the card in the hand
 * @param playerIndex The index of the target player.  0 if targeting yourself or your own minions, 1 if targeting the enemy
 * @param minionIndex The index of the target minion.
 * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
 * @return The boardState is manipulated and returned
 */
@Override public BoardState useOn(int thisCardIndex,int playerIndex,int minionIndex,BoardState boardState){
  if (hasBeenUsed_ && hasAttacked_) {
    return null;
  }
  if (playerIndex == 0) {
    if (isInHand_ && boardState.getNumMinions_p0() < 7) {
      if (minionIndex == 0) {
        return null;
      }
      if (!charge_) {
        hasAttacked_=true;
      }
      hasBeenUsed_=true;
      boardState.placeMinion_p0(this,minionIndex - 1);
      boardState.setMana_p0(boardState.getMana_p0() - this.mana_);
      boardState.removeCard_hand(thisCardIndex);
      return boardState;
    }
 else {
      return null;
    }
  }
 else {
    if (!isInHand_) {
      if (minionIndex == 0) {
        this.attack(boardState.getHero_p1());
        if (windFury_ && !hasWindFuryAttacked_)         hasWindFuryAttacked_=true;
 else         hasAttacked_=true;
        return boardState;
      }
 else {
        Minion target=boardState.getMinion_p1(minionIndex - 1);
        this.attack(target);
        if (target.getHealth() <= 0) {
          boardState.removeMinion_p1(target);
        }
        if (health_ <= 0) {
          boardState.removeMinion_p0(thisCardIndex);
        }
        if (windFury_ && !hasWindFuryAttacked_)         hasWindFuryAttacked_=true;
 else         hasAttacked_=true;
        return boardState;
      }
    }
 else {
      return null;
    }
  }
}",0.9873678783191544
112883,"/** 
 * Object2Parcelable
 * @param obj
 * @return
 */
public static Parcelable convertParcelable(Object obj){
  ProxyInfo pi=new ProxyInfo(obj.getClass().getCanonicalName());
  try {
    Class<?> clazz=Class.forName(pi.getFullName());
    Constructor<?> constructor=clazz.getConstructor(obj.getClass());
    return (Parcelable)constructor.newInstance(obj);
  }
 catch (  Exception e) {
  }
  return null;
}","/** 
 * Object2Parcelable
 * @param obj
 * @return
 */
public static Parcelable convertParcelable(Object obj){
  if (obj instanceof Parcelable) {
    return (Parcelable)obj;
  }
  ProxyInfo pi=new ProxyInfo(obj.getClass().getCanonicalName());
  try {
    Class<?> clazz=Class.forName(pi.getFullName());
    Constructor<?> constructor=clazz.getConstructor(obj.getClass());
    return (Parcelable)constructor.newInstance(obj);
  }
 catch (  Exception e) {
  }
  return null;
}",0.923950056753689
112884,"private static void log(String log){
  Log.i(""String_Node_Str"",log);
}","private static void log(String log){
}",0.7037037037037037
112885,"@Override public void onClick(View v){
  Intent intent=new Intent(this,ShowUserActivity.class);
  User user=new User();
  user.setName(""String_Node_Str"");
  user.setAge(18);
  user.setBalance(100.85);
  user.setId(11111l);
  user.setList(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  user.setVip(true);
  HashMap<Integer,String> map=new HashMap<Integer,String>();
  map.put(1,""String_Node_Str"");
  map.put(2,""String_Node_Str"");
  user.setMap(map);
  user.setStrArray(new String[]{""String_Node_Str"",""String_Node_Str""});
  user.setIntArray(new int[]{1,2,3,4,5});
  intent.putExtra(""String_Node_Str"",PG.createParcelable(user));
  startActivity(intent);
}","@Override public void onClick(View v){
  User user=new User();
  user.setName(""String_Node_Str"");
  user.setAge(18);
  user.setBalance(100.85);
  user.setId(11111l);
  user.setList(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  user.setVip(true);
  HashMap<Integer,String> map=new HashMap<Integer,String>();
  map.put(1,""String_Node_Str"");
  map.put(2,""String_Node_Str"");
  user.setMap(map);
  user.setStrArray(new String[]{""String_Node_Str"",""String_Node_Str""});
  user.setIntArray(new int[]{1,2,3,4,5});
  Intent intent=new Intent(this,ShowUserActivity.class);
  intent.putExtra(""String_Node_Str"",PG.createParcelable(user));
  startActivity(intent);
}",0.915929203539823
112886,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  User user=getIntent().getParcelableExtra(""String_Node_Str"");
  TextView tv=(TextView)findViewById(R.id.textView);
  tv.setText(user.toString());
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  TextView tv=(TextView)findViewById(R.id.textView);
  User user=getIntent().getParcelableExtra(""String_Node_Str"");
  tv.setText(user.toString());
}",0.7965517241379311
112887,"@Override public GeoWaveMetadata apply(final Result result){
  return new GeoWaveMetadata(result.getRow(),columnQualifier,null,getMergedStats(result,clientsideStatsMerge));
}","@Override public GeoWaveMetadata apply(final Result result){
  byte[] resultantCQ;
  if (columnQualifier == null) {
    NavigableMap<byte[],byte[]> familyMap=result.getFamilyMap(columnFamily);
    if (familyMap != null && !familyMap.isEmpty()) {
      resultantCQ=familyMap.firstKey();
    }
 else {
      resultantCQ=new byte[0];
    }
  }
 else {
    resultantCQ=columnQualifier;
  }
  return new GeoWaveMetadata(result.getRow(),resultantCQ,null,getMergedStats(result,clientsideStatsMerge));
}",0.3467862481315396
112888,"@Override public CloseableIterator<GeoWaveMetadata> query(final MetadataQuery query){
  final Scan scanner=new Scan();
  try {
    final byte[] columnFamily=StringUtils.stringToBinary(metadataType.name());
    final byte[] columnQualifier=query.getSecondaryId();
    if (columnFamily != null) {
      if (columnQualifier != null) {
        scanner.addColumn(columnFamily,columnQualifier);
      }
 else {
        scanner.addFamily(columnFamily);
      }
    }
    if (query.hasPrimaryId()) {
      scanner.setStartRow(query.getPrimaryId());
      scanner.setStopRow(query.getPrimaryId());
    }
    final boolean clientsideStatsMerge=(metadataType == MetadataType.STATS) && !options.isServerSideLibraryEnabled();
    if (clientsideStatsMerge) {
      scanner.setMaxVersions();
    }
    final ResultScanner rS=operations.getScannedResults(scanner,AbstractGeoWavePersistence.METADATA_TABLE,query.getAuthorizations());
    final Iterator<Result> it=rS.iterator();
    return new CloseableIteratorWrapper<>(new ScannerClosableWrapper(rS),Iterators.transform(it,new com.google.common.base.Function<Result,GeoWaveMetadata>(){
      @Override public GeoWaveMetadata apply(      final Result result){
        return new GeoWaveMetadata(result.getRow(),columnQualifier,null,getMergedStats(result,clientsideStatsMerge));
      }
    }
));
  }
 catch (  final Exception e) {
    LOGGER.warn(""String_Node_Str"",e);
  }
  return new CloseableIterator.Wrapper<>(Iterators.emptyIterator());
}","@Override public CloseableIterator<GeoWaveMetadata> query(final MetadataQuery query){
  final Scan scanner=new Scan();
  try {
    final byte[] columnFamily=StringUtils.stringToBinary(metadataType.name());
    final byte[] columnQualifier=query.getSecondaryId();
    if (columnQualifier != null) {
      scanner.addColumn(columnFamily,columnQualifier);
    }
 else {
      scanner.addFamily(columnFamily);
    }
    if (query.hasPrimaryId()) {
      scanner.setStartRow(query.getPrimaryId());
      scanner.setStopRow(query.getPrimaryId());
    }
    final boolean clientsideStatsMerge=(metadataType == MetadataType.STATS) && !options.isServerSideLibraryEnabled();
    if (clientsideStatsMerge) {
      scanner.setMaxVersions();
    }
    final ResultScanner rS=operations.getScannedResults(scanner,AbstractGeoWavePersistence.METADATA_TABLE,query.getAuthorizations());
    final Iterator<Result> it=rS.iterator();
    return new CloseableIteratorWrapper<>(new ScannerClosableWrapper(rS),Iterators.transform(it,new com.google.common.base.Function<Result,GeoWaveMetadata>(){
      @Override public GeoWaveMetadata apply(      final Result result){
        byte[] resultantCQ;
        if (columnQualifier == null) {
          NavigableMap<byte[],byte[]> familyMap=result.getFamilyMap(columnFamily);
          if (familyMap != null && !familyMap.isEmpty()) {
            resultantCQ=familyMap.firstKey();
          }
 else {
            resultantCQ=new byte[0];
          }
        }
 else {
          resultantCQ=columnQualifier;
        }
        return new GeoWaveMetadata(result.getRow(),resultantCQ,null,getMergedStats(result,clientsideStatsMerge));
      }
    }
));
  }
 catch (  final Exception e) {
    LOGGER.warn(""String_Node_Str"",e);
  }
  return new CloseableIterator.Wrapper<>(Iterators.emptyIterator());
}",0.8102034618888552
112889,"private void initContext(){
  if (jsc == null) {
    String jar=""String_Node_Str"";
    try {
      jar=KMeansRunner.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
    }
 catch (    final URISyntaxException e) {
      LOGGER.error(""String_Node_Str"",e);
    }
    SparkConf addonOptions=new SparkConf();
    addonOptions=addonOptions.setAppName(appName).setMaster(master).set(""String_Node_Str"",host).set(""String_Node_Str"",jar);
    session=GeoWaveSparkConf.createDefaultSession(addonOptions);
    jsc=JavaSparkContext.fromSparkContext(session.sparkContext());
  }
}","private void initContext(){
  if (jsc == null) {
    String jar=""String_Node_Str"";
    try {
      jar=KMeansRunner.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
    }
 catch (    final URISyntaxException e) {
      LOGGER.error(""String_Node_Str"",e);
    }
    session=GeoWaveSparkConf.createSessionFromParams(appName,master,host,jar);
    jsc=JavaSparkContext.fromSparkContext(session.sparkContext());
  }
}",0.6627906976744186
112890,"private void initContext(){
  if (session == null) {
    String jar=""String_Node_Str"";
    try {
      jar=KMeansRunner.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
    }
 catch (    final URISyntaxException e) {
      LOGGER.error(""String_Node_Str"",e);
    }
    SparkConf addonOptions=new SparkConf();
    addonOptions=addonOptions.setAppName(appName).setMaster(master).set(""String_Node_Str"",host).set(""String_Node_Str"",jar);
    session=GeoWaveSparkConf.createDefaultSession(addonOptions);
  }
}","private void initContext(){
  if (session == null) {
    String jar=""String_Node_Str"";
    try {
      jar=SqlQueryRunner.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
    }
 catch (    final URISyntaxException e) {
      LOGGER.error(""String_Node_Str"",e);
    }
    session=GeoWaveSparkConf.createSessionFromParams(appName,master,host,jar);
  }
}",0.7092511013215859
112891,"private void initContext(){
  if (session == null) {
    String jar=""String_Node_Str"";
    try {
      jar=SpatialJoinRunner.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
    }
 catch (    final URISyntaxException e) {
      LOGGER.error(""String_Node_Str"",e);
    }
    SparkConf addonOptions=new SparkConf();
    addonOptions=addonOptions.setAppName(appName).setMaster(master).set(""String_Node_Str"",host).set(""String_Node_Str"",jar);
    if (partCount != -1) {
      addonOptions=addonOptions.set(""String_Node_Str"",partCount.toString());
    }
    session=GeoWaveSparkConf.createDefaultSession(addonOptions);
  }
  sc=session.sparkContext();
}","private void initContext(){
  if (session == null) {
    String jar=""String_Node_Str"";
    try {
      jar=SpatialJoinRunner.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
    }
 catch (    final URISyntaxException e) {
      LOGGER.error(""String_Node_Str"",e);
    }
    SparkConf addonOptions=new SparkConf();
    addonOptions=addonOptions.setAppName(appName).setMaster(master).set(""String_Node_Str"",jar);
    if (master != ""String_Node_Str"") {
      addonOptions=addonOptions.set(""String_Node_Str"",host);
    }
    if (partCount != -1) {
      addonOptions=addonOptions.set(""String_Node_Str"",partCount.toString());
    }
    session=GeoWaveSparkConf.createDefaultSession(addonOptions);
  }
  sc=session.sparkContext();
}",0.906030855539972
112892,"/** 
 * Main method to execute the MapReduce analytic.
 */
@SuppressWarnings(""String_Node_Str"") public int runJob() throws Exception {
  Configuration conf=super.getConf();
  if (conf == null) {
    conf=new Configuration();
    setConf(conf);
  }
  PrimaryIndex inputPrimaryIndex=null;
  final CloseableIterator<Index<?,?>> it1=inputDataStoreOptions.createIndexStore().getIndices();
  while (it1.hasNext()) {
    Index<?,?> index=it1.next();
    if (index instanceof PrimaryIndex) {
      inputPrimaryIndex=(PrimaryIndex)index;
      break;
    }
  }
  CoordinateReferenceSystem inputIndexCrs=GeometryUtils.getIndexCrs(inputPrimaryIndex);
  String inputCrsCode=GeometryUtils.getCrsCode(inputIndexCrs);
  PrimaryIndex outputPrimaryIndex=outputIndex;
  CoordinateReferenceSystem outputIndexCrs=null;
  String outputCrsCode=null;
  if (outputPrimaryIndex != null) {
    outputIndexCrs=GeometryUtils.getIndexCrs(outputPrimaryIndex);
    outputCrsCode=GeometryUtils.getCrsCode(outputIndexCrs);
  }
 else {
    SpatialDimensionalityTypeProvider sdp=new SpatialDimensionalityTypeProvider();
    SpatialOptions so=sdp.createOptions();
    so.setCrs(inputCrsCode);
    outputPrimaryIndex=sdp.createPrimaryIndex(so);
    outputIndexCrs=inputIndexCrs;
    outputCrsCode=inputCrsCode;
  }
  CoordinateSystem cs=outputIndexCrs.getCoordinateSystem();
  CoordinateSystemAxis csx=cs.getAxis(0);
  CoordinateSystemAxis csy=cs.getAxis(1);
  double xMax=csx.getMaximumValue();
  double xMin=csx.getMinimumValue();
  double yMax=csy.getMaximumValue();
  double yMin=csy.getMinimumValue();
  if (xMax == Double.POSITIVE_INFINITY || xMin == Double.NEGATIVE_INFINITY || yMax == Double.POSITIVE_INFINITY || yMin == Double.NEGATIVE_INFINITY) {
    LOGGER.error(""String_Node_Str"");
    throw new RuntimeException(""String_Node_Str"");
  }
  DataStorePluginOptions rasterResizeOutputDataStoreOptions;
  String kdeCoverageName;
  if ((kdeCommandLineOptions.getTileSize() > 1)) {
    rasterResizeOutputDataStoreOptions=outputDataStoreOptions;
    final Map<String,String> configOptions=outputDataStoreOptions.getOptionsAsMap();
    final StoreFactoryOptions options=ConfigUtils.populateOptionsFromList(outputDataStoreOptions.getFactoryFamily().getDataStoreFactory().createOptionsInstance(),configOptions);
    options.setGeowaveNamespace(outputDataStoreOptions.getGeowaveNamespace() + ""String_Node_Str"");
    outputDataStoreOptions=new DataStorePluginOptions(options);
    kdeCoverageName=kdeCommandLineOptions.getCoverageName() + TMP_COVERAGE_SUFFIX;
  }
 else {
    rasterResizeOutputDataStoreOptions=null;
    kdeCoverageName=kdeCommandLineOptions.getCoverageName();
  }
  if (kdeCommandLineOptions.getHdfsHostPort() == null) {
    Properties configProperties=ConfigOptions.loadProperties(configFile);
    String hdfsFSUrl=ConfigHDFSCommand.getHdfsUrl(configProperties);
    kdeCommandLineOptions.setHdfsHostPort(hdfsFSUrl);
  }
  GeoWaveConfiguratorBase.setRemoteInvocationParams(kdeCommandLineOptions.getHdfsHostPort(),kdeCommandLineOptions.getJobTrackerOrResourceManHostPort(),conf);
  conf.setInt(MAX_LEVEL_KEY,kdeCommandLineOptions.getMaxLevel());
  conf.setInt(MIN_LEVEL_KEY,kdeCommandLineOptions.getMinLevel());
  conf.set(COVERAGE_NAME_KEY,kdeCoverageName);
  if (kdeCommandLineOptions.getCqlFilter() != null) {
    conf.set(GaussianCellMapper.CQL_FILTER_KEY,kdeCommandLineOptions.getCqlFilter());
  }
  conf.setDouble(X_MIN_KEY,xMin);
  conf.setDouble(X_MAX_KEY,xMax);
  conf.setDouble(Y_MIN_KEY,yMin);
  conf.setDouble(Y_MAX_KEY,yMax);
  conf.set(INPUT_CRSCODE_KEY,inputCrsCode);
  conf.set(OUTPUT_CRSCODE_KEY,outputCrsCode);
  preJob1Setup(conf);
  final Job job=new Job(conf);
  job.setJarByClass(this.getClass());
  addJobClasspathDependencies(job,conf);
  job.setJobName(getJob1Name());
  job.setMapperClass(getJob1Mapper());
  job.setCombinerClass(CellSummationCombiner.class);
  job.setReducerClass(getJob1Reducer());
  job.setMapOutputKeyClass(LongWritable.class);
  job.setMapOutputValueClass(DoubleWritable.class);
  job.setOutputKeyClass(DoubleWritable.class);
  job.setOutputValueClass(LongWritable.class);
  job.setInputFormatClass(GeoWaveInputFormat.class);
  job.setOutputFormatClass(SequenceFileOutputFormat.class);
  job.setNumReduceTasks(8);
  job.setSpeculativeExecution(false);
  final AdapterStore adapterStore=inputDataStoreOptions.createAdapterStore();
  final IndexStore indexStore=inputDataStoreOptions.createIndexStore();
  final DataAdapter<?> adapter=adapterStore.getAdapter(new ByteArrayId(kdeCommandLineOptions.getFeatureType()));
  final QueryOptions queryOptions=new QueryOptions(adapter);
  if (kdeCommandLineOptions.getIndexId() != null) {
    final Index index=indexStore.getIndex(new ByteArrayId(kdeCommandLineOptions.getIndexId()));
    if ((index != null) && (index instanceof PrimaryIndex)) {
      queryOptions.setIndex((PrimaryIndex)index);
    }
  }
  GeoWaveInputFormat.setQueryOptions(job.getConfiguration(),queryOptions);
  GeoWaveInputFormat.setMinimumSplitCount(job.getConfiguration(),kdeCommandLineOptions.getMinSplits());
  GeoWaveInputFormat.setMaximumSplitCount(job.getConfiguration(),kdeCommandLineOptions.getMaxSplits());
  GeoWaveInputFormat.setStoreOptions(job.getConfiguration(),inputDataStoreOptions);
  if (kdeCommandLineOptions.getCqlFilter() != null) {
    Geometry bbox=null;
    if (adapter instanceof FeatureDataAdapter) {
      final String geometryAttribute=((FeatureDataAdapter)adapter).getFeatureType().getGeometryDescriptor().getLocalName();
      final Filter filter=ECQL.toFilter(kdeCommandLineOptions.getCqlFilter());
      final ExtractGeometryFilterVisitorResult geoAndCompareOpData=(ExtractGeometryFilterVisitorResult)filter.accept(new ExtractGeometryFilterVisitor(GeometryUtils.DEFAULT_CRS,geometryAttribute),null);
      bbox=geoAndCompareOpData.getGeometry();
    }
    if ((bbox != null) && !bbox.equals(GeometryUtils.infinity())) {
      GeoWaveInputFormat.setQuery(job.getConfiguration(),new SpatialQuery(bbox));
    }
  }
  FileSystem fs=null;
  try {
    fs=FileSystem.get(conf);
    fs.delete(new Path(""String_Node_Str"" + inputDataStoreOptions.getGeowaveNamespace() + ""String_Node_Str""+ kdeCommandLineOptions.getMinLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getMaxLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getCoverageName()),true);
    FileOutputFormat.setOutputPath(job,new Path(""String_Node_Str"" + inputDataStoreOptions.getGeowaveNamespace() + ""String_Node_Str""+ kdeCommandLineOptions.getMinLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getMaxLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getCoverageName()+ ""String_Node_Str""));
    final boolean job1Success=job.waitForCompletion(true);
    boolean job2Success=false;
    boolean postJob2Success=false;
    if (job1Success) {
      setupEntriesPerLevel(job,conf);
      final Job statsReducer=new Job(conf);
      statsReducer.setJarByClass(this.getClass());
      addJobClasspathDependencies(statsReducer,conf);
      statsReducer.setJobName(getJob2Name());
      statsReducer.setMapperClass(IdentityMapper.class);
      statsReducer.setPartitionerClass(getJob2Partitioner());
      statsReducer.setReducerClass(getJob2Reducer());
      statsReducer.setNumReduceTasks(getJob2NumReducers((kdeCommandLineOptions.getMaxLevel() - kdeCommandLineOptions.getMinLevel()) + 1));
      statsReducer.setMapOutputKeyClass(DoubleWritable.class);
      statsReducer.setMapOutputValueClass(LongWritable.class);
      statsReducer.setOutputKeyClass(getJob2OutputKeyClass());
      statsReducer.setOutputValueClass(getJob2OutputValueClass());
      statsReducer.setInputFormatClass(SequenceFileInputFormat.class);
      statsReducer.setOutputFormatClass(getJob2OutputFormatClass());
      FileInputFormat.setInputPaths(statsReducer,new Path(""String_Node_Str"" + inputDataStoreOptions.getGeowaveNamespace() + ""String_Node_Str""+ kdeCommandLineOptions.getMinLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getMaxLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getCoverageName()+ ""String_Node_Str""));
      setupJob2Output(conf,statsReducer,outputDataStoreOptions.getGeowaveNamespace(),kdeCoverageName,outputPrimaryIndex);
      job2Success=statsReducer.waitForCompletion(true);
      if (job2Success) {
        postJob2Success=postJob2Actions(conf,outputDataStoreOptions.getGeowaveNamespace(),kdeCoverageName);
      }
    }
 else {
      job2Success=false;
    }
    if (rasterResizeOutputDataStoreOptions != null) {
      final ResizeCommand resizeCommand=new ResizeCommand();
      File configFile=File.createTempFile(""String_Node_Str"",null);
      ManualOperationParams params=new ManualOperationParams();
      params.getContext().put(ConfigOptions.PROPERTIES_FILE_CONTEXT,configFile);
      AddStoreCommand addStore=new AddStoreCommand();
      addStore.setParameters(""String_Node_Str"");
      addStore.setPluginOptions(outputDataStoreOptions);
      addStore.execute(params);
      addStore.setParameters(""String_Node_Str"");
      addStore.setPluginOptions(rasterResizeOutputDataStoreOptions);
      addStore.execute(params);
      resizeCommand.setParameters(""String_Node_Str"",""String_Node_Str"");
      resizeCommand.getOptions().setInputCoverageName(kdeCoverageName);
      resizeCommand.getOptions().setMinSplits(kdeCommandLineOptions.getMinSplits());
      resizeCommand.getOptions().setMaxSplits(kdeCommandLineOptions.getMaxSplits());
      resizeCommand.getOptions().setHdfsHostPort(kdeCommandLineOptions.getHdfsHostPort());
      resizeCommand.getOptions().setJobTrackerOrResourceManHostPort(kdeCommandLineOptions.getJobTrackerOrResourceManHostPort());
      resizeCommand.getOptions().setOutputCoverageName(kdeCommandLineOptions.getCoverageName());
      resizeCommand.getOptions().setOutputTileSize(kdeCommandLineOptions.getTileSize());
      final int resizeStatus=ToolRunner.run(resizeCommand.createRunner(params),new String[]{});
      if (resizeStatus == 0) {
        final ClearCommand clearCommand=new ClearCommand();
        clearCommand.setParameters(""String_Node_Str"");
        clearCommand.execute(params);
      }
 else {
        LOGGER.warn(""String_Node_Str"" + resizeStatus + ""String_Node_Str""+ outputDataStoreOptions.getGeowaveNamespace()+ ""String_Node_Str"");
      }
    }
    fs.delete(new Path(""String_Node_Str"" + inputDataStoreOptions.getGeowaveNamespace() + ""String_Node_Str""+ kdeCommandLineOptions.getMinLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getMaxLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getCoverageName()),true);
    return (job1Success && job2Success && postJob2Success) ? 0 : 1;
  }
  finally {
    if (fs != null) {
      try {
        fs.close();
      }
 catch (      IOException e) {
        LOGGER.info(e.getMessage());
      }
    }
  }
}","/** 
 * Main method to execute the MapReduce analytic.
 */
@SuppressWarnings(""String_Node_Str"") public int runJob() throws Exception {
  Configuration conf=super.getConf();
  if (conf == null) {
    conf=new Configuration();
    setConf(conf);
  }
  PrimaryIndex inputPrimaryIndex=null;
  final CloseableIterator<Index<?,?>> it1=inputDataStoreOptions.createIndexStore().getIndices();
  while (it1.hasNext()) {
    Index<?,?> index=it1.next();
    if (index instanceof PrimaryIndex) {
      inputPrimaryIndex=(PrimaryIndex)index;
      break;
    }
  }
  CoordinateReferenceSystem inputIndexCrs=GeometryUtils.getIndexCrs(inputPrimaryIndex);
  String inputCrsCode=GeometryUtils.getCrsCode(inputIndexCrs);
  PrimaryIndex outputPrimaryIndex=outputIndex;
  CoordinateReferenceSystem outputIndexCrs=null;
  String outputCrsCode=null;
  if (outputPrimaryIndex != null) {
    outputIndexCrs=GeometryUtils.getIndexCrs(outputPrimaryIndex);
    outputCrsCode=GeometryUtils.getCrsCode(outputIndexCrs);
  }
 else {
    SpatialDimensionalityTypeProvider sdp=new SpatialDimensionalityTypeProvider();
    SpatialOptions so=sdp.createOptions();
    so.setCrs(inputCrsCode);
    outputPrimaryIndex=sdp.createPrimaryIndex(so);
    outputIndexCrs=inputIndexCrs;
    outputCrsCode=inputCrsCode;
  }
  CoordinateSystem cs=outputIndexCrs.getCoordinateSystem();
  CoordinateSystemAxis csx=cs.getAxis(0);
  CoordinateSystemAxis csy=cs.getAxis(1);
  double xMax=csx.getMaximumValue();
  double xMin=csx.getMinimumValue();
  double yMax=csy.getMaximumValue();
  double yMin=csy.getMinimumValue();
  if (xMax == Double.POSITIVE_INFINITY || xMin == Double.NEGATIVE_INFINITY || yMax == Double.POSITIVE_INFINITY || yMin == Double.NEGATIVE_INFINITY) {
    LOGGER.error(""String_Node_Str"");
    throw new RuntimeException(""String_Node_Str"");
  }
  DataStorePluginOptions rasterResizeOutputDataStoreOptions;
  String kdeCoverageName;
  if ((kdeCommandLineOptions.getTileSize() > 1)) {
    rasterResizeOutputDataStoreOptions=outputDataStoreOptions;
    final Map<String,String> configOptions=outputDataStoreOptions.getOptionsAsMap();
    final StoreFactoryOptions options=ConfigUtils.populateOptionsFromList(outputDataStoreOptions.getFactoryFamily().getDataStoreFactory().createOptionsInstance(),configOptions);
    options.setGeowaveNamespace(outputDataStoreOptions.getGeowaveNamespace() + ""String_Node_Str"");
    outputDataStoreOptions=new DataStorePluginOptions(options);
    kdeCoverageName=kdeCommandLineOptions.getCoverageName() + TMP_COVERAGE_SUFFIX;
  }
 else {
    rasterResizeOutputDataStoreOptions=null;
    kdeCoverageName=kdeCommandLineOptions.getCoverageName();
  }
  if (kdeCommandLineOptions.getHdfsHostPort() == null) {
    Properties configProperties=ConfigOptions.loadProperties(configFile);
    String hdfsFSUrl=ConfigHDFSCommand.getHdfsUrl(configProperties);
    kdeCommandLineOptions.setHdfsHostPort(hdfsFSUrl);
  }
  GeoWaveConfiguratorBase.setRemoteInvocationParams(kdeCommandLineOptions.getHdfsHostPort(),kdeCommandLineOptions.getJobTrackerOrResourceManHostPort(),conf);
  conf.setInt(MAX_LEVEL_KEY,kdeCommandLineOptions.getMaxLevel());
  conf.setInt(MIN_LEVEL_KEY,kdeCommandLineOptions.getMinLevel());
  conf.set(COVERAGE_NAME_KEY,kdeCoverageName);
  if (kdeCommandLineOptions.getCqlFilter() != null) {
    conf.set(GaussianCellMapper.CQL_FILTER_KEY,kdeCommandLineOptions.getCqlFilter());
  }
  conf.setDouble(X_MIN_KEY,xMin);
  conf.setDouble(X_MAX_KEY,xMax);
  conf.setDouble(Y_MIN_KEY,yMin);
  conf.setDouble(Y_MAX_KEY,yMax);
  conf.set(INPUT_CRSCODE_KEY,inputCrsCode);
  conf.set(OUTPUT_CRSCODE_KEY,outputCrsCode);
  preJob1Setup(conf);
  final Job job=new Job(conf);
  job.setJarByClass(this.getClass());
  addJobClasspathDependencies(job,conf);
  job.setJobName(getJob1Name());
  job.setMapperClass(getJob1Mapper());
  job.setCombinerClass(CellSummationCombiner.class);
  job.setReducerClass(getJob1Reducer());
  job.setMapOutputKeyClass(LongWritable.class);
  job.setMapOutputValueClass(DoubleWritable.class);
  job.setOutputKeyClass(DoubleWritable.class);
  job.setOutputValueClass(LongWritable.class);
  job.setInputFormatClass(GeoWaveInputFormat.class);
  job.setOutputFormatClass(SequenceFileOutputFormat.class);
  job.setNumReduceTasks(8);
  job.setSpeculativeExecution(false);
  final AdapterStore adapterStore=inputDataStoreOptions.createAdapterStore();
  final IndexStore indexStore=inputDataStoreOptions.createIndexStore();
  final DataAdapter<?> adapter=adapterStore.getAdapter(new ByteArrayId(kdeCommandLineOptions.getFeatureType()));
  final QueryOptions queryOptions=new QueryOptions(adapter);
  if (kdeCommandLineOptions.getIndexId() != null) {
    final Index index=indexStore.getIndex(new ByteArrayId(kdeCommandLineOptions.getIndexId()));
    if ((index != null) && (index instanceof PrimaryIndex)) {
      queryOptions.setIndex((PrimaryIndex)index);
    }
  }
  GeoWaveInputFormat.setQueryOptions(job.getConfiguration(),queryOptions);
  GeoWaveInputFormat.setMinimumSplitCount(job.getConfiguration(),kdeCommandLineOptions.getMinSplits());
  GeoWaveInputFormat.setMaximumSplitCount(job.getConfiguration(),kdeCommandLineOptions.getMaxSplits());
  GeoWaveInputFormat.setStoreOptions(job.getConfiguration(),inputDataStoreOptions);
  if (kdeCommandLineOptions.getCqlFilter() != null) {
    Geometry bbox=null;
    if (adapter instanceof FeatureDataAdapter) {
      final String geometryAttribute=((FeatureDataAdapter)adapter).getFeatureType().getGeometryDescriptor().getLocalName();
      final Filter filter=ECQL.toFilter(kdeCommandLineOptions.getCqlFilter());
      final ExtractGeometryFilterVisitorResult geoAndCompareOpData=(ExtractGeometryFilterVisitorResult)filter.accept(new ExtractGeometryFilterVisitor(GeometryUtils.getDefaultCRS(),geometryAttribute),null);
      bbox=geoAndCompareOpData.getGeometry();
    }
    if ((bbox != null) && !bbox.equals(GeometryUtils.infinity())) {
      GeoWaveInputFormat.setQuery(job.getConfiguration(),new SpatialQuery(bbox));
    }
  }
  FileSystem fs=null;
  try {
    fs=FileSystem.get(conf);
    fs.delete(new Path(""String_Node_Str"" + inputDataStoreOptions.getGeowaveNamespace() + ""String_Node_Str""+ kdeCommandLineOptions.getMinLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getMaxLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getCoverageName()),true);
    FileOutputFormat.setOutputPath(job,new Path(""String_Node_Str"" + inputDataStoreOptions.getGeowaveNamespace() + ""String_Node_Str""+ kdeCommandLineOptions.getMinLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getMaxLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getCoverageName()+ ""String_Node_Str""));
    final boolean job1Success=job.waitForCompletion(true);
    boolean job2Success=false;
    boolean postJob2Success=false;
    if (job1Success) {
      setupEntriesPerLevel(job,conf);
      final Job statsReducer=new Job(conf);
      statsReducer.setJarByClass(this.getClass());
      addJobClasspathDependencies(statsReducer,conf);
      statsReducer.setJobName(getJob2Name());
      statsReducer.setMapperClass(IdentityMapper.class);
      statsReducer.setPartitionerClass(getJob2Partitioner());
      statsReducer.setReducerClass(getJob2Reducer());
      statsReducer.setNumReduceTasks(getJob2NumReducers((kdeCommandLineOptions.getMaxLevel() - kdeCommandLineOptions.getMinLevel()) + 1));
      statsReducer.setMapOutputKeyClass(DoubleWritable.class);
      statsReducer.setMapOutputValueClass(LongWritable.class);
      statsReducer.setOutputKeyClass(getJob2OutputKeyClass());
      statsReducer.setOutputValueClass(getJob2OutputValueClass());
      statsReducer.setInputFormatClass(SequenceFileInputFormat.class);
      statsReducer.setOutputFormatClass(getJob2OutputFormatClass());
      FileInputFormat.setInputPaths(statsReducer,new Path(""String_Node_Str"" + inputDataStoreOptions.getGeowaveNamespace() + ""String_Node_Str""+ kdeCommandLineOptions.getMinLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getMaxLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getCoverageName()+ ""String_Node_Str""));
      setupJob2Output(conf,statsReducer,outputDataStoreOptions.getGeowaveNamespace(),kdeCoverageName,outputPrimaryIndex);
      job2Success=statsReducer.waitForCompletion(true);
      if (job2Success) {
        postJob2Success=postJob2Actions(conf,outputDataStoreOptions.getGeowaveNamespace(),kdeCoverageName);
      }
    }
 else {
      job2Success=false;
    }
    if (rasterResizeOutputDataStoreOptions != null) {
      final ResizeCommand resizeCommand=new ResizeCommand();
      File configFile=File.createTempFile(""String_Node_Str"",null);
      ManualOperationParams params=new ManualOperationParams();
      params.getContext().put(ConfigOptions.PROPERTIES_FILE_CONTEXT,configFile);
      AddStoreCommand addStore=new AddStoreCommand();
      addStore.setParameters(""String_Node_Str"");
      addStore.setPluginOptions(outputDataStoreOptions);
      addStore.execute(params);
      addStore.setParameters(""String_Node_Str"");
      addStore.setPluginOptions(rasterResizeOutputDataStoreOptions);
      addStore.execute(params);
      resizeCommand.setParameters(""String_Node_Str"",""String_Node_Str"");
      resizeCommand.getOptions().setInputCoverageName(kdeCoverageName);
      resizeCommand.getOptions().setMinSplits(kdeCommandLineOptions.getMinSplits());
      resizeCommand.getOptions().setMaxSplits(kdeCommandLineOptions.getMaxSplits());
      resizeCommand.getOptions().setHdfsHostPort(kdeCommandLineOptions.getHdfsHostPort());
      resizeCommand.getOptions().setJobTrackerOrResourceManHostPort(kdeCommandLineOptions.getJobTrackerOrResourceManHostPort());
      resizeCommand.getOptions().setOutputCoverageName(kdeCommandLineOptions.getCoverageName());
      resizeCommand.getOptions().setOutputTileSize(kdeCommandLineOptions.getTileSize());
      final int resizeStatus=ToolRunner.run(resizeCommand.createRunner(params),new String[]{});
      if (resizeStatus == 0) {
        final ClearCommand clearCommand=new ClearCommand();
        clearCommand.setParameters(""String_Node_Str"");
        clearCommand.execute(params);
      }
 else {
        LOGGER.warn(""String_Node_Str"" + resizeStatus + ""String_Node_Str""+ outputDataStoreOptions.getGeowaveNamespace()+ ""String_Node_Str"");
      }
    }
    fs.delete(new Path(""String_Node_Str"" + inputDataStoreOptions.getGeowaveNamespace() + ""String_Node_Str""+ kdeCommandLineOptions.getMinLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getMaxLevel()+ ""String_Node_Str""+ kdeCommandLineOptions.getCoverageName()),true);
    return (job1Success && job2Success && postJob2Success) ? 0 : 1;
  }
  finally {
    if (fs != null) {
      try {
        fs.close();
      }
 catch (      IOException e) {
        LOGGER.info(e.getMessage());
      }
    }
  }
}",0.99916130835896
112893,"public void run() throws IOException {
  initContext();
  if (inputDataStore == null) {
    LOGGER.error(""String_Node_Str"");
    throw new IOException(""String_Node_Str"");
  }
  if (isUseTime()) {
    ByteArrayId adapterByte=null;
    if (adapterId != null) {
      adapterByte=new ByteArrayId(adapterId);
    }
    scaledRange=KMeansUtils.setRunnerTimeParams(this,inputDataStore,adapterByte);
    if (scaledRange == null) {
      LOGGER.error(""String_Node_Str"");
      throw new ParameterException(""String_Node_Str"");
    }
  }
  List<ByteArrayId> featureAdapterIds;
  if (adapterId != null) {
    featureAdapterIds=new ArrayList<>();
    featureAdapterIds.add(new ByteArrayId(adapterId));
  }
 else {
    featureAdapterIds=FeatureDataUtils.getFeatureAdapterIds(inputDataStore);
  }
  final QueryOptions queryOptions=new QueryOptions();
  queryOptions.setAdapterIds(featureAdapterIds);
  final AdapterStore adapterStore=inputDataStore.createAdapterStore();
  queryOptions.getAdaptersArray(adapterStore);
  DistributableQuery query=null;
  try {
    if (cqlFilter != null) {
      Geometry bbox=null;
      ByteArrayId cqlAdapterId;
      if (adapterId == null) {
        cqlAdapterId=featureAdapterIds.get(0);
      }
 else {
        cqlAdapterId=new ByteArrayId(adapterId);
      }
      final DataAdapter adapter=adapterStore.getAdapter(cqlAdapterId);
      if (adapter instanceof FeatureDataAdapter) {
        final String geometryAttribute=((FeatureDataAdapter)adapter).getFeatureType().getGeometryDescriptor().getLocalName();
        Filter filter;
        filter=ECQL.toFilter(cqlFilter);
        final ExtractGeometryFilterVisitorResult geoAndCompareOpData=(ExtractGeometryFilterVisitorResult)filter.accept(new ExtractGeometryFilterVisitor(GeometryUtils.DEFAULT_CRS,geometryAttribute),null);
        bbox=geoAndCompareOpData.getGeometry();
      }
      if ((bbox != null) && !bbox.equals(GeometryUtils.infinity())) {
        query=new SpatialQuery(bbox);
      }
    }
  }
 catch (  final CQLException e) {
    LOGGER.error(""String_Node_Str"" + cqlFilter);
  }
  RDDOptions kmeansOpts=new RDDOptions();
  kmeansOpts.setMinSplits(minSplits);
  kmeansOpts.setMaxSplits(maxSplits);
  kmeansOpts.setQuery(query);
  kmeansOpts.setQueryOptions(queryOptions);
  GeoWaveRDD kmeansRDD=GeoWaveRDDLoader.loadRDD(jsc.sc(),inputDataStore,kmeansOpts);
  centroidVectors=RDDUtils.rddFeatureVectors(kmeansRDD,timeField,scaledTimeRange);
  centroidVectors.cache();
  final KMeans kmeans=new KMeans();
  kmeans.setInitializationMode(""String_Node_Str"");
  kmeans.setK(numClusters);
  kmeans.setMaxIterations(numIterations);
  if (epsilon > -1.0) {
    kmeans.setEpsilon(epsilon);
  }
  outputModel=kmeans.run(centroidVectors.rdd());
  writeToOutputStore();
}","public void run() throws IOException {
  initContext();
  if (inputDataStore == null) {
    LOGGER.error(""String_Node_Str"");
    throw new IOException(""String_Node_Str"");
  }
  if (isUseTime()) {
    ByteArrayId adapterByte=null;
    if (adapterId != null) {
      adapterByte=new ByteArrayId(adapterId);
    }
    scaledRange=KMeansUtils.setRunnerTimeParams(this,inputDataStore,adapterByte);
    if (scaledRange == null) {
      LOGGER.error(""String_Node_Str"");
      throw new ParameterException(""String_Node_Str"");
    }
  }
  List<ByteArrayId> featureAdapterIds;
  if (adapterId != null) {
    featureAdapterIds=new ArrayList<>();
    featureAdapterIds.add(new ByteArrayId(adapterId));
  }
 else {
    featureAdapterIds=FeatureDataUtils.getFeatureAdapterIds(inputDataStore);
  }
  final QueryOptions queryOptions=new QueryOptions();
  queryOptions.setAdapterIds(featureAdapterIds);
  final AdapterStore adapterStore=inputDataStore.createAdapterStore();
  queryOptions.getAdaptersArray(adapterStore);
  DistributableQuery query=null;
  try {
    if (cqlFilter != null) {
      Geometry bbox=null;
      ByteArrayId cqlAdapterId;
      if (adapterId == null) {
        cqlAdapterId=featureAdapterIds.get(0);
      }
 else {
        cqlAdapterId=new ByteArrayId(adapterId);
      }
      final DataAdapter adapter=adapterStore.getAdapter(cqlAdapterId);
      if (adapter instanceof FeatureDataAdapter) {
        final String geometryAttribute=((FeatureDataAdapter)adapter).getFeatureType().getGeometryDescriptor().getLocalName();
        Filter filter;
        filter=ECQL.toFilter(cqlFilter);
        final ExtractGeometryFilterVisitorResult geoAndCompareOpData=(ExtractGeometryFilterVisitorResult)filter.accept(new ExtractGeometryFilterVisitor(GeometryUtils.getDefaultCRS(),geometryAttribute),null);
        bbox=geoAndCompareOpData.getGeometry();
      }
      if ((bbox != null) && !bbox.equals(GeometryUtils.infinity())) {
        query=new SpatialQuery(bbox);
      }
    }
  }
 catch (  final CQLException e) {
    LOGGER.error(""String_Node_Str"" + cqlFilter);
  }
  RDDOptions kmeansOpts=new RDDOptions();
  kmeansOpts.setMinSplits(minSplits);
  kmeansOpts.setMaxSplits(maxSplits);
  kmeansOpts.setQuery(query);
  kmeansOpts.setQueryOptions(queryOptions);
  GeoWaveRDD kmeansRDD=GeoWaveRDDLoader.loadRDD(jsc.sc(),inputDataStore,kmeansOpts);
  centroidVectors=RDDUtils.rddFeatureVectors(kmeansRDD,timeField,scaledTimeRange);
  centroidVectors.cache();
  final KMeans kmeans=new KMeans();
  kmeans.setInitializationMode(""String_Node_Str"");
  kmeans.setK(numClusters);
  kmeans.setMaxIterations(numIterations);
  if (epsilon > -1.0) {
    kmeans.setEpsilon(epsilon);
  }
  outputModel=kmeans.run(centroidVectors.rdd());
  writeToOutputStore();
}",0.9963609898107716
112894,"private List<QueryRequest> addQueryRanges(final String tableName,final SinglePartitionQueryRanges r,final List<ByteArrayId> adapterIds,final AdapterStore adapterStore){
  List<QueryRequest> retVal=new ArrayList<>();
  final ByteArrayId partitionKey=r.getPartitionKey();
  final byte[] partitionId=((partitionKey == null) || (partitionKey.getBytes().length == 0)) ? DynamoDBWriter.EMPTY_PARTITION_KEY : partitionKey.getBytes();
  if ((adapterIds == null || adapterIds.isEmpty()) && (adapterStore != null)) {
    final CloseableIterator<DataAdapter<?>> adapters=adapterStore.getAdapters();
    final List<ByteArrayId> adapterIDList=new ArrayList<ByteArrayId>();
    adapters.forEachRemaining(new Consumer<DataAdapter<?>>(){
      @Override public void accept(      final DataAdapter<?> t){
        adapterIDList.add(t.getAdapterId());
      }
    }
);
    adapterIds.addAll(adapterIDList);
  }
  for (  final ByteArrayId adapterId : adapterIds) {
    final Collection<ByteArrayRange> sortKeyRanges=r.getSortKeyRanges();
    if (sortKeyRanges != null && !sortKeyRanges.isEmpty()) {
      sortKeyRanges.forEach((sortKeyRange -> retVal.add(getQuery(tableName,partitionId,sortKeyRange,adapterId))));
    }
 else {
      retVal.add(getQuery(tableName,partitionId,null,adapterId));
    }
  }
  return retVal;
}","private List<QueryRequest> addQueryRanges(final String tableName,final SinglePartitionQueryRanges r,List<ByteArrayId> adapterIds,final AdapterStore adapterStore){
  List<QueryRequest> retVal=new ArrayList<>();
  final ByteArrayId partitionKey=r.getPartitionKey();
  final byte[] partitionId=((partitionKey == null) || (partitionKey.getBytes().length == 0)) ? DynamoDBWriter.EMPTY_PARTITION_KEY : partitionKey.getBytes();
  if ((adapterIds == null || adapterIds.isEmpty()) && (adapterStore != null)) {
    final CloseableIterator<DataAdapter<?>> adapters=adapterStore.getAdapters();
    adapterIds=new ArrayList<>();
    final List<ByteArrayId> adapterIDList=new ArrayList<ByteArrayId>();
    adapters.forEachRemaining(new Consumer<DataAdapter<?>>(){
      @Override public void accept(      final DataAdapter<?> t){
        adapterIDList.add(t.getAdapterId());
      }
    }
);
    adapterIds.addAll(adapterIDList);
  }
  for (  final ByteArrayId adapterId : adapterIds) {
    final Collection<ByteArrayRange> sortKeyRanges=r.getSortKeyRanges();
    if (sortKeyRanges != null && !sortKeyRanges.isEmpty()) {
      sortKeyRanges.forEach((sortKeyRange -> retVal.add(getQuery(tableName,partitionId,sortKeyRange,adapterId))));
    }
 else {
      retVal.add(getQuery(tableName,partitionId,null,adapterId));
    }
  }
  return retVal;
}",0.9848024316109424
112895,"@Override public CloseableIterator<Index<?,?>> getIndices(final Map<ByteArrayId,DataStatistics<SimpleFeature>> stats,final BasicQuery query,final PrimaryIndex[] indices){
  return new CloseableIterator<Index<?,?>>(){
    PrimaryIndex nextIdx=null;
    boolean done=false;
    int i=0;
    @Override public boolean hasNext(){
      double bestIndexBitsUsed=-1;
      int bestIndexDimensionCount=-1;
      PrimaryIndex bestIdx=null;
      while (!done && (i < indices.length)) {
        nextIdx=indices[i++];
        if (nextIdx.getIndexStrategy().getOrderedDimensionDefinitions().length == 0) {
          continue;
        }
        final List<MultiDimensionalNumericData> queryRanges=query.getIndexConstraints(nextIdx);
        if (IndexUtils.isFullTableScan(queryRanges)) {
          if (bestIdx == null) {
            bestIdx=nextIdx;
          }
        }
 else {
          double currentBitsUsed=0;
          final int currentDimensionCount=nextIdx.getIndexStrategy().getOrderedDimensionDefinitions().length;
          if (currentDimensionCount >= bestIndexDimensionCount) {
            for (            final MultiDimensionalNumericData qr : queryRanges) {
              final double[] dataRangePerDimension=new double[qr.getDimensionCount()];
              for (int d=0; d < dataRangePerDimension.length; d++) {
                dataRangePerDimension[d]=qr.getMaxValuesPerDimension()[d] - qr.getMinValuesPerDimension()[d];
              }
              currentBitsUsed+=IndexUtils.getDimensionalBitsUsed(nextIdx.getIndexStrategy(),dataRangePerDimension);
            }
            if ((currentDimensionCount > bestIndexDimensionCount) || (currentBitsUsed > bestIndexBitsUsed)) {
              bestIndexBitsUsed=currentBitsUsed;
              bestIndexDimensionCount=currentDimensionCount;
              bestIdx=nextIdx;
            }
          }
        }
      }
      nextIdx=bestIdx;
      done=true;
      return nextIdx != null;
    }
    @Override public Index<?,?> next() throws NoSuchElementException {
      if (nextIdx == null) {
        throw new NoSuchElementException();
      }
      final Index<?,?> returnVal=nextIdx;
      nextIdx=null;
      return returnVal;
    }
    @Override public void remove(){
    }
    @Override public void close() throws IOException {
    }
  }
;
}","@Override public CloseableIterator<Index<?,?>> getIndices(final Map<ByteArrayId,DataStatistics<SimpleFeature>> stats,final BasicQuery query,final PrimaryIndex[] indices){
  return new CloseableIterator<Index<?,?>>(){
    PrimaryIndex nextIdx=null;
    boolean done=false;
    int i=0;
    @Override public boolean hasNext(){
      double bestIndexBitsUsed=-1;
      int bestIndexDimensionCount=-1;
      PrimaryIndex bestIdx=null;
      while (!done && (i < indices.length)) {
        nextIdx=indices[i++];
        if (nextIdx.getIndexStrategy().getOrderedDimensionDefinitions().length == 0) {
          continue;
        }
        final List<MultiDimensionalNumericData> queryRanges=query.getIndexConstraints(nextIdx);
        final int currentDimensionCount=nextIdx.getIndexStrategy().getOrderedDimensionDefinitions().length;
        if (IndexUtils.isFullTableScan(queryRanges) || !queryRangeDimensionsMatch(currentDimensionCount,queryRanges)) {
          if (bestIdx == null) {
            bestIdx=nextIdx;
          }
        }
 else {
          double currentBitsUsed=0;
          if (currentDimensionCount >= bestIndexDimensionCount) {
            for (            final MultiDimensionalNumericData qr : queryRanges) {
              final double[] dataRangePerDimension=new double[qr.getDimensionCount()];
              for (int d=0; d < dataRangePerDimension.length; d++) {
                dataRangePerDimension[d]=qr.getMaxValuesPerDimension()[d] - qr.getMinValuesPerDimension()[d];
              }
              currentBitsUsed+=IndexUtils.getDimensionalBitsUsed(nextIdx.getIndexStrategy(),dataRangePerDimension);
            }
            if ((currentDimensionCount > bestIndexDimensionCount) || (currentBitsUsed > bestIndexBitsUsed)) {
              bestIndexBitsUsed=currentBitsUsed;
              bestIndexDimensionCount=currentDimensionCount;
              bestIdx=nextIdx;
            }
          }
        }
      }
      nextIdx=bestIdx;
      done=true;
      return nextIdx != null;
    }
    @Override public Index<?,?> next() throws NoSuchElementException {
      if (nextIdx == null) {
        throw new NoSuchElementException();
      }
      final Index<?,?> returnVal=nextIdx;
      nextIdx=null;
      return returnVal;
    }
    @Override public void remove(){
    }
    @Override public void close() throws IOException {
    }
  }
;
}",0.9392834155760568
112896,"@Override public boolean hasNext(){
  double bestIndexBitsUsed=-1;
  int bestIndexDimensionCount=-1;
  PrimaryIndex bestIdx=null;
  while (!done && (i < indices.length)) {
    nextIdx=indices[i++];
    if (nextIdx.getIndexStrategy().getOrderedDimensionDefinitions().length == 0) {
      continue;
    }
    final List<MultiDimensionalNumericData> queryRanges=query.getIndexConstraints(nextIdx);
    if (IndexUtils.isFullTableScan(queryRanges)) {
      if (bestIdx == null) {
        bestIdx=nextIdx;
      }
    }
 else {
      double currentBitsUsed=0;
      final int currentDimensionCount=nextIdx.getIndexStrategy().getOrderedDimensionDefinitions().length;
      if (currentDimensionCount >= bestIndexDimensionCount) {
        for (        final MultiDimensionalNumericData qr : queryRanges) {
          final double[] dataRangePerDimension=new double[qr.getDimensionCount()];
          for (int d=0; d < dataRangePerDimension.length; d++) {
            dataRangePerDimension[d]=qr.getMaxValuesPerDimension()[d] - qr.getMinValuesPerDimension()[d];
          }
          currentBitsUsed+=IndexUtils.getDimensionalBitsUsed(nextIdx.getIndexStrategy(),dataRangePerDimension);
        }
        if ((currentDimensionCount > bestIndexDimensionCount) || (currentBitsUsed > bestIndexBitsUsed)) {
          bestIndexBitsUsed=currentBitsUsed;
          bestIndexDimensionCount=currentDimensionCount;
          bestIdx=nextIdx;
        }
      }
    }
  }
  nextIdx=bestIdx;
  done=true;
  return nextIdx != null;
}","@Override public boolean hasNext(){
  double bestIndexBitsUsed=-1;
  int bestIndexDimensionCount=-1;
  PrimaryIndex bestIdx=null;
  while (!done && (i < indices.length)) {
    nextIdx=indices[i++];
    if (nextIdx.getIndexStrategy().getOrderedDimensionDefinitions().length == 0) {
      continue;
    }
    final List<MultiDimensionalNumericData> queryRanges=query.getIndexConstraints(nextIdx);
    final int currentDimensionCount=nextIdx.getIndexStrategy().getOrderedDimensionDefinitions().length;
    if (IndexUtils.isFullTableScan(queryRanges) || !queryRangeDimensionsMatch(currentDimensionCount,queryRanges)) {
      if (bestIdx == null) {
        bestIdx=nextIdx;
      }
    }
 else {
      double currentBitsUsed=0;
      if (currentDimensionCount >= bestIndexDimensionCount) {
        for (        final MultiDimensionalNumericData qr : queryRanges) {
          final double[] dataRangePerDimension=new double[qr.getDimensionCount()];
          for (int d=0; d < dataRangePerDimension.length; d++) {
            dataRangePerDimension[d]=qr.getMaxValuesPerDimension()[d] - qr.getMinValuesPerDimension()[d];
          }
          currentBitsUsed+=IndexUtils.getDimensionalBitsUsed(nextIdx.getIndexStrategy(),dataRangePerDimension);
        }
        if ((currentDimensionCount > bestIndexDimensionCount) || (currentBitsUsed > bestIndexBitsUsed)) {
          bestIndexBitsUsed=currentBitsUsed;
          bestIndexDimensionCount=currentDimensionCount;
          bestIdx=nextIdx;
        }
      }
    }
  }
  nextIdx=bestIdx;
  done=true;
  return nextIdx != null;
}",0.758531036724082
112897,"@Test public void testMax() throws IllegalArgumentException, NoSuchElementException, IOException {
  final FeatureReader<SimpleFeatureType,SimpleFeature> reader=dataStore.getFeatureReader(query,Transaction.AUTO_COMMIT);
  final MaxVisitor visitor=new MaxVisitor(""String_Node_Str"",type);
  unwrapDelegatingFeatureReader(reader).getFeatureCollection().accepts(visitor,null);
  assertTrue(visitor.getMax().equals(etime));
}","@Test public void testMax() throws IllegalArgumentException, NoSuchElementException, IOException {
  final FeatureReader<SimpleFeatureType,SimpleFeature> reader=dataStore.getFeatureReader(query,Transaction.AUTO_COMMIT);
  final MaxVisitor visitor=new MaxVisitor(""String_Node_Str"",type);
  unwrapDelegatingFeatureReader(reader).getFeatureCollection().accepts(visitor,null);
  assertTrue(visitor.getMax().equals(mtime));
}",0.9976190476190476
112898,"@Before public void setup() throws SchemaException, CQLException, Exception {
  dataStore=createDataStore();
  type=DataUtilities.createType(""String_Node_Str"",""String_Node_Str"");
  dataStore.createSchema(type);
  stime=DateUtilities.parseISO(""String_Node_Str"");
  etime=DateUtilities.parseISO(""String_Node_Str"");
  final Transaction transaction1=new DefaultTransaction();
  final FeatureWriter<SimpleFeatureType,SimpleFeature> writer=dataStore.getFeatureWriter(type.getTypeName(),transaction1);
  assertFalse(writer.hasNext());
  SimpleFeature newFeature=writer.next();
  newFeature.setAttribute(""String_Node_Str"",Long.valueOf(100));
  newFeature.setAttribute(""String_Node_Str"",""String_Node_Str"" + UUID.randomUUID().toString());
  newFeature.setAttribute(""String_Node_Str"",stime);
  newFeature.setAttribute(""String_Node_Str"",etime);
  newFeature.setAttribute(""String_Node_Str"",factory.createPoint(new Coordinate(27.25,41.25)));
  fids.add(newFeature.getID());
  pids.add(newFeature.getAttribute(""String_Node_Str"").toString());
  writer.write();
  newFeature=writer.next();
  newFeature.setAttribute(""String_Node_Str"",Long.valueOf(101));
  newFeature.setAttribute(""String_Node_Str"",""String_Node_Str"" + UUID.randomUUID().toString());
  newFeature.setAttribute(""String_Node_Str"",etime);
  newFeature.setAttribute(""String_Node_Str"",factory.createPoint(new Coordinate(28.25,41.25)));
  fids.add(newFeature.getID());
  pids.add(newFeature.getAttribute(""String_Node_Str"").toString());
  writer.write();
  writer.close();
  transaction1.commit();
  transaction1.close();
  query=new Query(""String_Node_Str"",ECQL.toFilter(""String_Node_Str"" + fids.get(0) + ""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
}","@Before public void setup() throws SchemaException, CQLException, Exception {
  dataStore=createDataStore();
  type=DataUtilities.createType(""String_Node_Str"",""String_Node_Str"");
  ((GeoWaveGTDataStore)dataStore).getIndexStore().addIndex(new SpatialIndexBuilder().createIndex());
  ((GeoWaveGTDataStore)dataStore).getIndexStore().addIndex(new SpatialTemporalIndexBuilder().createIndex());
  dataStore.createSchema(type);
  stime=DateUtilities.parseISO(""String_Node_Str"");
  mtime=DateUtilities.parseISO(""String_Node_Str"");
  etime=DateUtilities.parseISO(""String_Node_Str"");
  final Transaction transaction1=new DefaultTransaction();
  final FeatureWriter<SimpleFeatureType,SimpleFeature> writer=dataStore.getFeatureWriter(type.getTypeName(),transaction1);
  assertFalse(writer.hasNext());
  SimpleFeature newFeature=writer.next();
  newFeature.setAttribute(""String_Node_Str"",Long.valueOf(100));
  newFeature.setAttribute(""String_Node_Str"",""String_Node_Str"" + UUID.randomUUID().toString());
  newFeature.setAttribute(""String_Node_Str"",stime);
  newFeature.setAttribute(""String_Node_Str"",mtime);
  newFeature.setAttribute(""String_Node_Str"",factory.createPoint(new Coordinate(27.25,41.25)));
  fids.add(newFeature.getID());
  pids.add(newFeature.getAttribute(""String_Node_Str"").toString());
  writer.write();
  newFeature=writer.next();
  newFeature.setAttribute(""String_Node_Str"",Long.valueOf(101));
  newFeature.setAttribute(""String_Node_Str"",""String_Node_Str"" + UUID.randomUUID().toString());
  newFeature.setAttribute(""String_Node_Str"",mtime);
  newFeature.setAttribute(""String_Node_Str"",etime);
  newFeature.setAttribute(""String_Node_Str"",factory.createPoint(new Coordinate(28.25,41.25)));
  fids.add(newFeature.getID());
  pids.add(newFeature.getAttribute(""String_Node_Str"").toString());
  writer.write();
  writer.close();
  transaction1.commit();
  transaction1.close();
  query=new Query(""String_Node_Str"",ECQL.toFilter(""String_Node_Str"" + fids.get(0) + ""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
}",0.9160223940282592
112899,"@Override public NumericDimensionField<?>[] getDimensions(){
  return dimensions;
}","@Override public NumericDimensionField<? extends CommonIndexValue>[] getDimensions(){
  return dimensions;
}",0.8691099476439791
112900,"@Override public Void computeResults(final OperationParams params) throws Exception {
  final File propFile=getGeoWaveConfigFile(params);
  final Properties existingProps=ConfigOptions.loadProperties(propFile,null);
  if (url != null) {
    existingProps.setProperty(GEOSERVER_URL,url);
  }
  if (getName() != null) {
    existingProps.setProperty(GEOSERVER_USER,getName());
  }
  if (getPass() != null) {
    existingProps.setProperty(GEOSERVER_PASS,getPass());
  }
  if (getWorkspace() != null) {
    existingProps.setProperty(GEOSERVER_WORKSPACE,getWorkspace());
  }
  ConfigOptions.writeProperties(propFile,existingProps);
  GeoServerRestClient.invalidateInstance();
  return null;
}","@Override public String computeResults(final OperationParams params) throws Exception {
  if (parameters.size() != 1) {
    throw new ParameterException(""String_Node_Str"");
  }
  url=parameters.get(0);
  final Properties existingProps=getGeoWaveConfigProperties(params);
  if (url != null) {
    existingProps.setProperty(GEOSERVER_URL,url);
  }
  if (getName() != null) {
    existingProps.setProperty(GEOSERVER_USER,getName());
  }
  if (getPass() != null) {
    existingProps.setProperty(GEOSERVER_PASS,getPass());
  }
  if (getWorkspace() != null) {
    existingProps.setProperty(GEOSERVER_WORKSPACE,getWorkspace());
  }
  sslConfigOptions.saveProperties(existingProps);
  ConfigOptions.writeProperties(getGeoWaveConfigFile(params),existingProps,this.getClass(),GEOSERVER_NAMESPACE_PREFIX);
  GeoServerRestClient.invalidateInstance();
  StringBuilder builder=new StringBuilder();
  for (  Object key : existingProps.keySet()) {
    if (key.toString().startsWith(""String_Node_Str"")) {
      builder.append(key.toString() + ""String_Node_Str"" + existingProps.getProperty(key.toString())+ ""String_Node_Str"");
    }
  }
  return builder.toString();
}",0.5773420479302832
112901,"@Override public void execute(final OperationParams params) throws Exception {
  if (parameters.size() != 1) {
    throw new ParameterException(""String_Node_Str"");
  }
  url=parameters.get(0);
  final Properties existingProps=getGeoWaveConfigProperties(params);
  if (url != null) {
    existingProps.setProperty(GEOSERVER_URL,url);
  }
  if (getName() != null) {
    existingProps.setProperty(GEOSERVER_USER,getName());
  }
  if (getPass() != null) {
    existingProps.setProperty(GEOSERVER_PASS,getPass());
  }
  if (getWorkspace() != null) {
    existingProps.setProperty(GEOSERVER_WORKSPACE,getWorkspace());
  }
  sslConfigOptions.saveProperties(existingProps);
  ConfigOptions.writeProperties(getGeoWaveConfigFile(params),existingProps,this.getClass(),GEOSERVER_NAMESPACE_PREFIX);
}","@Override public void execute(final OperationParams params) throws Exception {
  JCommander.getConsole().println(computeResults(params));
}",0.2354211663066954
112902,"@Override public String computeResults(final OperationParams params) throws Exception {
  layerName=parameters.get(0);
  final Response getLayerResponse=geoserverClient.getFeatureLayer(layerName);
  if (getLayerResponse.getStatus() == Status.OK.getStatusCode()) {
    final JSONObject jsonResponse=JSONObject.fromObject(getLayerResponse.getEntity());
    return ""String_Node_Str"" + layerName + ""String_Node_Str""+ jsonResponse.toString(2);
  }
  return ""String_Node_Str"" + layerName + ""String_Node_Str""+ getLayerResponse.getStatus();
}","@Override public String computeResults(final OperationParams params) throws Exception {
  if (parameters.size() != 1) {
    throw new ParameterException(""String_Node_Str"");
  }
  layerName=parameters.get(0);
  final Response getLayerResponse=geoserverClient.getFeatureLayer(layerName);
  if (getLayerResponse.getStatus() == Status.OK.getStatusCode()) {
    final JSONObject jsonResponse=JSONObject.fromObject(getLayerResponse.getEntity());
    return ""String_Node_Str"" + layerName + ""String_Node_Str""+ jsonResponse.toString(2);
  }
  return ""String_Node_Str"" + layerName + ""String_Node_Str""+ getLayerResponse.getStatus();
}",0.9230769230769232
112903,"@Override public void execute(final OperationParams params) throws Exception {
  if (parameters.size() != 1) {
    throw new ParameterException(""String_Node_Str"");
  }
  JCommander.getConsole().println(computeResults(params));
}","@Override public void execute(final OperationParams params) throws Exception {
  JCommander.getConsole().println(computeResults(params));
}",0.7574931880108992
112904,"@Override public List<String> computeResults(final OperationParams params) throws Exception {
  storeName=parameters.get(0);
  final ArrayList<String> adapterList=geoserverClient.getStoreAdapters(storeName,null);
  return adapterList;
}","@Override public List<String> computeResults(final OperationParams params) throws Exception {
  if (parameters.size() != 1) {
    throw new ParameterException(""String_Node_Str"");
  }
  storeName=parameters.get(0);
  final List<String> adapterList=geoserverClient.getStoreAdapters(storeName,null);
  return adapterList;
}",0.4892086330935252
112905,"@Override public void execute(final OperationParams params) throws Exception {
  if (parameters.size() != 1) {
    throw new ParameterException(""String_Node_Str"");
  }
  JCommander.getConsole().println(""String_Node_Str"" + storeName + ""String_Node_Str"");
  for (  final String adapterId : computeResults(params)) {
    JCommander.getConsole().println(adapterId);
  }
}","@Override public void execute(final OperationParams params) throws Exception {
  List<String> adapterList=computeResults(params);
  JCommander.getConsole().println(""String_Node_Str"" + storeName + ""String_Node_Str"");
  for (  final String adapterId : adapterList) {
    JCommander.getConsole().println(adapterId);
  }
}",0.4321167883211679
112906,"@Override public String computeResults(final OperationParams params) throws Exception {
  style=parameters.get(0);
  final Response getStyleResponse=geoserverClient.getStyle(style);
  if (getStyleResponse.getStatus() == Status.OK.getStatusCode()) {
    final String style=IOUtils.toString((InputStream)getStyleResponse.getEntity());
    return ""String_Node_Str"" + style + ""String_Node_Str""+ style;
  }
  return ""String_Node_Str"" + style + ""String_Node_Str""+ getStyleResponse.getStatus();
}","@Override public String computeResults(final OperationParams params) throws Exception {
  if (parameters.size() != 1) {
    throw new ParameterException(""String_Node_Str"");
  }
  style=parameters.get(0);
  final Response getStyleResponse=geoserverClient.getStyle(style);
  if (getStyleResponse.getStatus() == Status.OK.getStatusCode()) {
    final String style=IOUtils.toString((InputStream)getStyleResponse.getEntity());
    return ""String_Node_Str"" + style + ""String_Node_Str""+ style;
  }
  return ""String_Node_Str"" + style + ""String_Node_Str""+ getStyleResponse.getStatus();
}",0.916588566073102
112907,"@Override public void execute(final OperationParams params) throws Exception {
  if (parameters.size() != 1) {
    throw new ParameterException(""String_Node_Str"");
  }
  JCommander.getConsole().println(computeResults(params));
}","@Override public void execute(final OperationParams params) throws Exception {
  JCommander.getConsole().println(computeResults(params));
}",0.7574931880108992
112908,"@Override public void execute(final OperationParams params) throws Exception {
}","@Override public void execute(final OperationParams params) throws Exception {
  JCommander.getConsole().println(computeResults(params));
}",0.730593607305936
112909,"@Override public String computeResults(final OperationParams params) throws Exception {
  if ((workspace == null) || workspace.isEmpty()) {
    workspace=geoserverClient.getConfig().getWorkspace();
  }
  csName=parameters.get(0);
  final Response getCvgStoreResponse=geoserverClient.getCoverages(workspace,csName);
  if (getCvgStoreResponse.getStatus() == Status.OK.getStatusCode()) {
    final JSONObject jsonResponse=JSONObject.fromObject(getCvgStoreResponse.getEntity());
    final JSONArray cvgArray=jsonResponse.getJSONArray(""String_Node_Str"");
    return ""String_Node_Str"" + csName + ""String_Node_Str""+ cvgArray.toString(2);
  }
  return ""String_Node_Str"" + csName + ""String_Node_Str""+ getCvgStoreResponse.getStatus();
}","@Override public String computeResults(final OperationParams params) throws Exception {
  if (parameters.size() != 1) {
    throw new ParameterException(""String_Node_Str"");
  }
  if ((workspace == null) || workspace.isEmpty()) {
    workspace=geoserverClient.getConfig().getWorkspace();
  }
  csName=parameters.get(0);
  final Response getCvgStoreResponse=geoserverClient.getCoverages(workspace,csName);
  if (getCvgStoreResponse.getStatus() == Status.OK.getStatusCode()) {
    final JSONObject jsonResponse=JSONObject.fromObject(getCvgStoreResponse.getEntity());
    final JSONArray cvgArray=jsonResponse.getJSONArray(""String_Node_Str"");
    return ""String_Node_Str"" + csName + ""String_Node_Str""+ cvgArray.toString(2);
  }
  return ""String_Node_Str"" + csName + ""String_Node_Str""+ getCvgStoreResponse.getStatus();
}",0.9422452952628164
112910,"@Override public void execute(final OperationParams params) throws Exception {
  if (parameters.size() != 1) {
    throw new ParameterException(""String_Node_Str"");
  }
  JCommander.getConsole().println(computeResults(params));
}","@Override public void execute(final OperationParams params) throws Exception {
  JCommander.getConsole().println(computeResults(params));
}",0.7574931880108992
112911,"@Override public String computeResults(final OperationParams params) throws Exception {
  if ((workspace == null) || workspace.isEmpty()) {
    workspace=geoserverClient.getConfig().getWorkspace();
  }
  cvgName=parameters.get(0);
  final Response getCvgResponse=geoserverClient.deleteCoverage(workspace,cvgstore,cvgName);
  if (getCvgResponse.getStatus() == Status.OK.getStatusCode()) {
    return ""String_Node_Str"" + cvgName + ""String_Node_Str"";
  }
  return ""String_Node_Str"" + cvgName + ""String_Node_Str""+ getCvgResponse.getStatus();
}","@Override public String computeResults(final OperationParams params) throws Exception {
  if (parameters.size() != 1) {
    throw new ParameterException(""String_Node_Str"");
  }
  if ((workspace == null) || workspace.isEmpty()) {
    workspace=geoserverClient.getConfig().getWorkspace();
  }
  cvgName=parameters.get(0);
  final Response getCvgResponse=geoserverClient.deleteCoverage(workspace,cvgstore,cvgName);
  if (getCvgResponse.getStatus() == Status.OK.getStatusCode()) {
    return ""String_Node_Str"" + cvgName + ""String_Node_Str"";
  }
  return ""String_Node_Str"" + cvgName + ""String_Node_Str""+ getCvgResponse.getStatus();
}",0.9237360754070264
112912,"@Override public void execute(final OperationParams params) throws Exception {
  if (parameters.size() != 1) {
    throw new ParameterException(""String_Node_Str"");
  }
  JCommander.getConsole().println(computeResults(params));
}","@Override public void execute(final OperationParams params) throws Exception {
  JCommander.getConsole().println(computeResults(params));
}",0.7574931880108992
112913,"@Override public String computeResults(final OperationParams params) throws Exception {
  if ((workspace == null) || workspace.isEmpty()) {
    workspace=geoserverClient.getConfig().getWorkspace();
  }
  cvgstoreName=parameters.get(0);
  final Response deleteCvgStoreResponse=geoserverClient.deleteCoverageStore(workspace,cvgstoreName);
  if (deleteCvgStoreResponse.getStatus() == Status.OK.getStatusCode()) {
    return ""String_Node_Str"" + cvgstoreName + ""String_Node_Str""+ workspace+ ""String_Node_Str"";
  }
  return ""String_Node_Str"" + cvgstoreName + ""String_Node_Str""+ workspace+ ""String_Node_Str""+ deleteCvgStoreResponse.getStatus();
}","@Override public String computeResults(final OperationParams params) throws Exception {
  if (parameters.size() != 1) {
    throw new ParameterException(""String_Node_Str"");
  }
  if ((workspace == null) || workspace.isEmpty()) {
    workspace=geoserverClient.getConfig().getWorkspace();
  }
  cvgstoreName=parameters.get(0);
  final Response deleteCvgStoreResponse=geoserverClient.deleteCoverageStore(workspace,cvgstoreName);
  if (deleteCvgStoreResponse.getStatus() == Status.OK.getStatusCode()) {
    return ""String_Node_Str"" + cvgstoreName + ""String_Node_Str""+ workspace+ ""String_Node_Str"";
  }
  return ""String_Node_Str"" + cvgstoreName + ""String_Node_Str""+ workspace+ ""String_Node_Str""+ deleteCvgStoreResponse.getStatus();
}",0.9348939283101684
112914,"@Override public void execute(final OperationParams params) throws Exception {
  if (parameters.size() != 1) {
    throw new ParameterException(""String_Node_Str"");
  }
  JCommander.getConsole().println(computeResults(params));
}","@Override public void execute(final OperationParams params) throws Exception {
  JCommander.getConsole().println(computeResults(params));
}",0.7574931880108992
112915,"@Override public String computeResults(final OperationParams params) throws Exception {
  if ((workspace == null) || workspace.isEmpty()) {
    workspace=geoserverClient.getConfig().getWorkspace();
  }
  datastoreName=parameters.get(0);
  final Response deleteStoreResponse=geoserverClient.deleteDatastore(workspace,datastoreName);
  if (deleteStoreResponse.getStatus() == Status.OK.getStatusCode()) {
    return ""String_Node_Str"" + datastoreName + ""String_Node_Str""+ workspace+ ""String_Node_Str"";
  }
  return ""String_Node_Str"" + datastoreName + ""String_Node_Str""+ workspace+ ""String_Node_Str""+ deleteStoreResponse.getStatus();
}","@Override public String computeResults(final OperationParams params) throws Exception {
  if (parameters.size() != 1) {
    throw new ParameterException(""String_Node_Str"");
  }
  if ((workspace == null) || workspace.isEmpty()) {
    workspace=geoserverClient.getConfig().getWorkspace();
  }
  datastoreName=parameters.get(0);
  final Response deleteStoreResponse=geoserverClient.deleteDatastore(workspace,datastoreName);
  if (deleteStoreResponse.getStatus() == Status.OK.getStatusCode()) {
    return ""String_Node_Str"" + datastoreName + ""String_Node_Str""+ workspace+ ""String_Node_Str"";
  }
  return ""String_Node_Str"" + datastoreName + ""String_Node_Str""+ workspace+ ""String_Node_Str""+ deleteStoreResponse.getStatus();
}",0.9340252038547072
112916,"@Override public void execute(final OperationParams params) throws Exception {
  if (parameters.size() != 1) {
    throw new ParameterException(""String_Node_Str"");
  }
  JCommander.getConsole().println(computeResults(params));
}","@Override public void execute(final OperationParams params) throws Exception {
  JCommander.getConsole().println(computeResults(params));
}",0.7574931880108992
112917,"@Override public String computeResults(final OperationParams params) throws Exception {
  layerName=parameters.get(0);
  final Response deleteLayerResponse=geoserverClient.deleteFeatureLayer(layerName);
  if (deleteLayerResponse.getStatus() == Status.OK.getStatusCode()) {
    final JSONObject listObj=JSONObject.fromObject(deleteLayerResponse.getEntity());
    return ""String_Node_Str"" + layerName + ""String_Node_Str""+ listObj.toString(2);
  }
  return ""String_Node_Str"" + layerName + ""String_Node_Str""+ deleteLayerResponse.getStatus();
}","@Override public String computeResults(final OperationParams params) throws Exception {
  if (parameters.size() != 1) {
    throw new ParameterException(""String_Node_Str"");
  }
  layerName=parameters.get(0);
  final Response deleteLayerResponse=geoserverClient.deleteFeatureLayer(layerName);
  if (deleteLayerResponse.getStatus() == Status.OK.getStatusCode()) {
    final JSONObject listObj=JSONObject.fromObject(deleteLayerResponse.getEntity());
    return ""String_Node_Str"" + layerName + ""String_Node_Str""+ listObj.toString(2);
  }
  return ""String_Node_Str"" + layerName + ""String_Node_Str""+ deleteLayerResponse.getStatus();
}",0.9237360754070264
112918,"@Override public void execute(final OperationParams params) throws Exception {
  if (parameters.size() != 1) {
    throw new ParameterException(""String_Node_Str"");
  }
  JCommander.getConsole().println(computeResults(params));
}","@Override public void execute(final OperationParams params) throws Exception {
  JCommander.getConsole().println(computeResults(params));
}",0.7574931880108992
112919,"@Override public String computeResults(final OperationParams params) throws Exception {
  styleName=parameters.get(0);
  final Response deleteStyleResponse=geoserverClient.deleteStyle(styleName);
  if (deleteStyleResponse.getStatus() == Status.OK.getStatusCode()) {
    return ""String_Node_Str"" + styleName + ""String_Node_Str"";
  }
  return ""String_Node_Str"" + styleName + ""String_Node_Str""+ deleteStyleResponse.getStatus();
}","@Override public String computeResults(final OperationParams params) throws Exception {
  if (parameters.size() != 1) {
    throw new ParameterException(""String_Node_Str"");
  }
  styleName=parameters.get(0);
  final Response deleteStyleResponse=geoserverClient.deleteStyle(styleName);
  if (deleteStyleResponse.getStatus() == Status.OK.getStatusCode()) {
    return ""String_Node_Str"" + styleName + ""String_Node_Str"";
  }
  return ""String_Node_Str"" + styleName + ""String_Node_Str""+ deleteStyleResponse.getStatus();
}",0.9054197662061636
112920,"@Override public void execute(final OperationParams params) throws Exception {
  if (parameters.size() != 1) {
    throw new ParameterException(""String_Node_Str"");
  }
  JCommander.getConsole().println(computeResults(params));
}","@Override public void execute(final OperationParams params) throws Exception {
  JCommander.getConsole().println(computeResults(params));
}",0.7574931880108992
112921,"/** 
 * This helper function will load the properties file, or return null if it can't. It's designed to be used by other commands.
 * @param delimiter
 */
public static Properties loadProperties(final File configFile,final String pattern){
  Pattern p=null;
  if (pattern != null) {
    p=Pattern.compile(pattern);
  }
  final Properties properties=new Properties();
  InputStream is=null;
  try {
    if (p != null) {
      try (FileInputStream input=new FileInputStream(configFile);Scanner s=new Scanner(input,CHARSET)){
        final ByteArrayOutputStream out=new ByteArrayOutputStream();
        final PrintWriter writer=new PrintWriter(new OutputStreamWriter(out,CHARSET));
        while (s.hasNext()) {
          final String line=s.nextLine();
          if (p.matcher(line).find()) {
            writer.println(line);
          }
        }
        writer.flush();
        is=new ByteArrayInputStream(out.toByteArray());
      }
     }
 else {
      is=new FileInputStream(configFile);
    }
    properties.load(is);
  }
 catch (  final IOException e) {
    LOGGER.error(""String_Node_Str"" + configFile,e);
    return null;
  }
 finally {
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
        LOGGER.error(e.getMessage(),e);
      }
    }
  }
  return properties;
}","/** 
 * This helper function will load the properties file, or return null if it can't. It's designed to be used by other commands.
 * @param delimiter
 */
public static Properties loadProperties(final File configFile,final String pattern){
  final Properties properties=new Properties();
  if (configFile.exists()) {
    Pattern p=null;
    if (pattern != null) {
      p=Pattern.compile(pattern);
    }
    InputStream is=null;
    try {
      if (p != null) {
        try (FileInputStream input=new FileInputStream(configFile);Scanner s=new Scanner(input,CHARSET)){
          final ByteArrayOutputStream out=new ByteArrayOutputStream();
          final PrintWriter writer=new PrintWriter(new OutputStreamWriter(out,CHARSET));
          while (s.hasNext()) {
            final String line=s.nextLine();
            if (p.matcher(line).find()) {
              writer.println(line);
            }
          }
          writer.flush();
          is=new ByteArrayInputStream(out.toByteArray());
        }
       }
 else {
        is=new FileInputStream(configFile);
      }
      properties.load(is);
    }
 catch (    final IOException e) {
      LOGGER.error(""String_Node_Str"" + configFile,e);
      return null;
    }
 finally {
      if (is != null) {
        try {
          is.close();
        }
 catch (        IOException e) {
          LOGGER.error(e.getMessage(),e);
        }
      }
    }
  }
  return properties;
}",0.8713087860007291
112922,"/** 
 * processes uploaded file, storing in a temporary directory
 * @param entity
 * @return the directory storing the uploaded file
 * @throws Exception
 */
@Post public UploadedFile accept(final Representation entity) throws Exception {
  UploadedFile result;
  if ((entity != null) && MediaType.MULTIPART_FORM_DATA.equals(entity.getMediaType(),true)) {
    final DiskFileItemFactory factory=new DiskFileItemFactory();
    factory.setSizeThreshold(1000240);
    final RestletFileUpload upload=new RestletFileUpload(factory);
    final String tempDir=System.getProperty(""String_Node_Str"");
    final File dir=new File(tempDir);
    final File filename=File.createTempFile(""String_Node_Str"",""String_Node_Str"",dir);
    result=new UploadedFile(filename.getAbsolutePath());
    final List<FileItem> fileList=upload.parseRepresentation(entity);
    if (fileList.size() != 1) {
      throw new ResourceException(Status.CLIENT_ERROR_BAD_REQUEST);
    }
    FileUtils.copyInputStreamToFile(fileList.get(0).getInputStream(),filename);
  }
 else {
    throw new ResourceException(Status.CLIENT_ERROR_UNSUPPORTED_MEDIA_TYPE);
  }
  return result;
}","/** 
 * processes uploaded file, storing in a temporary directory
 * @param entity
 * @return the directory storing the uploaded file
 * @throws Exception
 */
@Post public UploadedFile accept(final Representation entity) throws Exception {
  UploadedFile result;
  if ((entity != null) && MediaType.MULTIPART_FORM_DATA.equals(entity.getMediaType(),true)) {
    final DiskFileItemFactory factory=new DiskFileItemFactory();
    factory.setSizeThreshold(1000240);
    final RestletFileUpload upload=new RestletFileUpload(factory);
    final List<FileItem> fileList=upload.parseRepresentation(entity);
    if (fileList.size() != 1) {
      throw new ResourceException(Status.CLIENT_ERROR_BAD_REQUEST);
    }
    FileItem item=fileList.get(0);
    final String tempDir=System.getProperty(""String_Node_Str"");
    final File dir=new File(tempDir);
    final File filename=File.createTempFile(""String_Node_Str"",""String_Node_Str"" + item.getName(),dir);
    result=new UploadedFile(filename.getAbsolutePath());
    FileUtils.copyInputStreamToFile(item.getInputStream(),filename);
  }
 else {
    throw new ResourceException(Status.CLIENT_ERROR_UNSUPPORTED_MEDIA_TYPE);
  }
  return result;
}",0.7910383455407152
112923,"/** 
 * Prompt a user for a password and return the input
 * @param promptMessage
 * @return
 */
public static String promptAndReadPassword(String promptMessage){
  LOGGER.trace(""String_Node_Str"");
  PropertiesUtils propsUtils=new PropertiesUtils(getProperties());
  boolean defaultEchoEnabled=propsUtils.getBoolean(Constants.CONSOLE_DEFAULT_ECHO_ENABLED_KEY,false);
  boolean passwordEchoEnabled=propsUtils.getBoolean(Constants.CONSOLE_PASSWORD_ECHO_ENABLED_KEY,defaultEchoEnabled);
  LOGGER.debug(""String_Node_Str"",new Object[]{passwordEchoEnabled ? ""String_Node_Str"" : ""String_Node_Str""});
  getConsole().print(promptMessage);
  char[] passwordChars=getConsole().readPassword(passwordEchoEnabled);
  return new String(passwordChars);
}","/** 
 * Prompt a user for a password and return the input
 * @param promptMessage
 * @return
 */
public static String promptAndReadPassword(String promptMessage){
  LOGGER.trace(""String_Node_Str"");
  PropertiesUtils propsUtils=new PropertiesUtils(getProperties());
  boolean defaultEchoEnabled=propsUtils.getBoolean(Constants.CONSOLE_DEFAULT_ECHO_ENABLED_KEY,false);
  boolean passwordEchoEnabled=propsUtils.getBoolean(Constants.CONSOLE_PASSWORD_ECHO_ENABLED_KEY,defaultEchoEnabled);
  LOGGER.debug(""String_Node_Str"",new Object[]{passwordEchoEnabled ? ""String_Node_Str"" : ""String_Node_Str""});
  getConsole().print(promptMessage);
  char[] passwordChars=getConsole().readPassword(passwordEchoEnabled);
  String strPassword=new String(passwordChars);
  passwordChars=null;
  return strPassword;
}",0.9216710182767625
112924,"/** 
 * Prompt a user for a standard value and return the input
 * @param promptMessage
 * @return
 */
public static String promptAndReadValue(String promptMessage){
  LOGGER.trace(""String_Node_Str"");
  PropertiesUtils propsUtils=new PropertiesUtils(getProperties());
  boolean defaultEchoEnabled=propsUtils.getBoolean(Constants.CONSOLE_DEFAULT_ECHO_ENABLED_KEY,false);
  LOGGER.debug(""String_Node_Str"",new Object[]{defaultEchoEnabled ? ""String_Node_Str"" : ""String_Node_Str""});
  getConsole().print(promptMessage);
  char[] passwordChars=getConsole().readPassword(defaultEchoEnabled);
  return new String(passwordChars);
}","/** 
 * Prompt a user for a standard value and return the input
 * @param promptMessage
 * @return
 */
public static String promptAndReadValue(String promptMessage){
  LOGGER.trace(""String_Node_Str"");
  PropertiesUtils propsUtils=new PropertiesUtils(getProperties());
  boolean defaultEchoEnabled=propsUtils.getBoolean(Constants.CONSOLE_DEFAULT_ECHO_ENABLED_KEY,false);
  LOGGER.debug(""String_Node_Str"",new Object[]{defaultEchoEnabled ? ""String_Node_Str"" : ""String_Node_Str""});
  getConsole().print(promptMessage);
  char[] responseChars=getConsole().readPassword(defaultEchoEnabled);
  String response=new String(responseChars);
  responseChars=null;
  return response;
}",0.8284389489953632
112925,"public static String getUrl(String url) throws URISyntaxException, MalformedURLException {
  if (url != null) {
    if (isValidURL(url)) {
      return url;
    }
    boolean valid=false;
    for (    String scheme : getSchemes()) {
      if (scheme.toLowerCase().startsWith(scheme + ""String_Node_Str"")) {
        valid=true;
      }
    }
    if (!valid) {
      url=HTTP + ""String_Node_Str"" + url;
    }
    URI uri=new URI(url);
    if (uri.getScheme() == null) {
      uri=new URI(HTTP + ""String_Node_Str"" + url);
    }
    URL targetURL=uri.toURL();
    if (targetURL.getPort() == -1) {
      targetURL=new URL(targetURL.getProtocol(),targetURL.getHost(),targetURL.getDefaultPort(),targetURL.getFile());
    }
    if (String.valueOf(targetURL.getPort()).endsWith(""String_Node_Str"")) {
      targetURL=new URL(HTTPS,targetURL.getHost(),targetURL.getPort(),targetURL.getFile());
    }
    return targetURL.toString();
  }
  return url;
}","public static String getUrl(String url) throws URISyntaxException, MalformedURLException {
  if (url != null) {
    if (isValidURL(url)) {
      return url;
    }
    boolean valid=isValidScheme(url);
    if (!valid) {
      url=HTTP + ""String_Node_Str"" + url;
    }
    URI uri=new URI(url);
    if (uri.getScheme() == null) {
      uri=new URI(HTTP + ""String_Node_Str"" + url);
    }
    URL targetURL=uri.toURL();
    if (targetURL.getPort() == -1) {
      targetURL=new URL(targetURL.getProtocol(),targetURL.getHost(),targetURL.getDefaultPort(),targetURL.getFile());
    }
    if (String.valueOf(targetURL.getPort()).endsWith(""String_Node_Str"")) {
      targetURL=new URL(HTTPS,targetURL.getHost(),targetURL.getPort(),targetURL.getFile());
    }
    return targetURL.toString();
  }
  return url;
}",0.9052268811028144
112926,"public void setEntryName(String entryName){
  this.parameters=new ArrayList<String>();
  this.parameters.add(entryName);
}","public void setEntryName(final String entryName){
  parameters=new ArrayList<String>();
  parameters.add(entryName);
}",0.9333333333333332
112927,"public void execute(OperationParams params,String pattern){
  Properties existingProps=getGeoWaveConfigProperties(params);
  Set<String> keysToRemove=new HashSet<String>();
  for (  String key : existingProps.stringPropertyNames()) {
    if (key.startsWith(pattern)) {
      keysToRemove.add(key);
    }
  }
  for (  String key : keysToRemove) {
    existingProps.remove(key);
  }
  ConfigOptions.writeProperties(getGeoWaveConfigFile(params),existingProps);
}","public void execute(final OperationParams params,final String patternPrefix){
  final String pattern=patternPrefix + ""String_Node_Str"";
  final Properties existingProps=getGeoWaveConfigProperties(params);
  final Set<String> keysToRemove=new HashSet<String>();
  for (  final String key : existingProps.stringPropertyNames()) {
    if (key.startsWith(pattern)) {
      keysToRemove.add(key);
    }
  }
  for (  final String key : keysToRemove) {
    existingProps.remove(key);
  }
  ConfigOptions.writeProperties(getGeoWaveConfigFile(params),existingProps);
}",0.8271119842829077
112928,"@Override public RecordWriter<GeoWaveOutputKey<Object>,Object> getRecordWriter(final TaskAttemptContext context) throws IOException, InterruptedException {
  try {
    final Map<String,String> configOptions=getStoreOptionsMap(context);
    final AdapterStore persistentAdapterStore=GeoWaveStoreFinder.createAdapterStore(configOptions);
    final DataAdapter<?>[] adapters=JobContextAdapterStore.getDataAdapters(context);
    for (    final DataAdapter<?> a : adapters) {
      if (!persistentAdapterStore.adapterExists(a.getAdapterId())) {
        persistentAdapterStore.addAdapter(a);
      }
    }
    final IndexStore persistentIndexStore=GeoWaveStoreFinder.createIndexStore(configOptions);
    final Index[] indices=JobContextIndexStore.getIndices(context);
    if (LOGGER.isDebugEnabled()) {
      final StringBuilder sbDebug=new StringBuilder();
      sbDebug.append(""String_Node_Str"");
      for (      final Map.Entry<String,String> entry : configOptions.entrySet()) {
        sbDebug.append(entry.getKey() + ""String_Node_Str"" + entry.getValue()+ ""String_Node_Str"");
      }
      sbDebug.append(""String_Node_Str"" + indices.length);
      sbDebug.append(""String_Node_Str"" + persistentIndexStore);
      final String filename=""String_Node_Str"";
      final InputStream is=context.getClass().getResourceAsStream(filename);
      if (is == null) {
        sbDebug.append(""String_Node_Str"" + filename + ""String_Node_Str"");
      }
 else {
        sbDebug.append(""String_Node_Str"" + IOUtils.toString(is,""String_Node_Str""));
      }
      LOGGER.debug(sbDebug.toString());
    }
    for (    final Index i : indices) {
      if (!persistentIndexStore.indexExists(i.getId())) {
        persistentIndexStore.addIndex(i);
      }
    }
    final AdapterStore jobContextAdapterStore=new JobContextAdapterStore(context,persistentAdapterStore);
    final IndexStore jobContextIndexStore=new JobContextIndexStore(context,persistentIndexStore);
    final DataStore dataStore=GeoWaveStoreFinder.createDataStore(configOptions);
    return new GeoWaveRecordWriter(context,dataStore,jobContextIndexStore,jobContextAdapterStore);
  }
 catch (  final Exception e) {
    throw new IOException(e);
  }
}","@Override public RecordWriter<GeoWaveOutputKey<Object>,Object> getRecordWriter(final TaskAttemptContext context) throws IOException, InterruptedException {
  try {
    final Map<String,String> configOptions=getStoreOptionsMap(context);
    final AdapterStore persistentAdapterStore=GeoWaveStoreFinder.createAdapterStore(configOptions);
    final DataAdapter<?>[] adapters=JobContextAdapterStore.getDataAdapters(context);
    for (    final DataAdapter<?> a : adapters) {
      if (!persistentAdapterStore.adapterExists(a.getAdapterId())) {
        persistentAdapterStore.addAdapter(a);
      }
    }
    final IndexStore persistentIndexStore=GeoWaveStoreFinder.createIndexStore(configOptions);
    final Index[] indices=JobContextIndexStore.getIndices(context);
    if (LOGGER.isDebugEnabled()) {
      final StringBuilder sbDebug=new StringBuilder();
      sbDebug.append(""String_Node_Str"");
      for (      final Map.Entry<String,String> entry : configOptions.entrySet()) {
        sbDebug.append(entry.getKey() + ""String_Node_Str"" + entry.getValue()+ ""String_Node_Str"");
      }
      sbDebug.append(""String_Node_Str"" + indices.length);
      sbDebug.append(""String_Node_Str"" + persistentIndexStore);
      final String filename=""String_Node_Str"";
      final InputStream is=context.getClass().getResourceAsStream(filename);
      if (is == null) {
        sbDebug.append(""String_Node_Str"" + filename + ""String_Node_Str"");
      }
 else {
        sbDebug.append(""String_Node_Str"" + IOUtils.toString(is,""String_Node_Str""));
        is.close();
      }
      LOGGER.debug(sbDebug.toString());
    }
    for (    final Index i : indices) {
      if (!persistentIndexStore.indexExists(i.getId())) {
        persistentIndexStore.addIndex(i);
      }
    }
    final AdapterStore jobContextAdapterStore=new JobContextAdapterStore(context,persistentAdapterStore);
    final IndexStore jobContextIndexStore=new JobContextIndexStore(context,persistentIndexStore);
    final DataStore dataStore=GeoWaveStoreFinder.createDataStore(configOptions);
    return new GeoWaveRecordWriter(context,dataStore,jobContextIndexStore,jobContextAdapterStore);
  }
 catch (  final Exception e) {
    throw new IOException(e);
  }
}",0.9954524783992724
112929,"private void init(final File scenesDir,final boolean onlyScenesSinceLastRun,final boolean useCachedScenes,final boolean nBestScenesByPathRow,final int nBestScenes,final WRS2GeometryStore geometryStore,final Filter cqlFilter) throws IOException {
  if (!scenesDir.exists() && !scenesDir.mkdirs()) {
    LOGGER.warn(""String_Node_Str"" + scenesDir.getAbsolutePath() + ""String_Node_Str"");
  }
  final File csvFile=new File(scenesDir,CSV_FILE_NAME);
  long startLine=0;
  if (!csvFile.exists() || !useCachedScenes) {
    final File compressedFile=new File(scenesDir,COMPRESSED_FILE_NAME);
    final File tempCsvFile=new File(scenesDir,TEMP_CSV_FILE_NAME);
    if (compressedFile.exists()) {
      if (!compressedFile.delete()) {
        LOGGER.warn(""String_Node_Str"" + compressedFile.getAbsolutePath() + ""String_Node_Str"");
      }
    }
    if (tempCsvFile.exists()) {
      if (!tempCsvFile.delete()) {
        LOGGER.warn(""String_Node_Str"" + tempCsvFile.getAbsolutePath() + ""String_Node_Str"");
      }
    }
    InputStream in=null;
    try {
      in=new URL(SCENES_GZ_URL).openStream();
      final FileOutputStream outStream=new FileOutputStream(compressedFile);
      IOUtils.copyLarge(in,outStream);
      outStream.close();
    }
 catch (    final IOException e) {
      LOGGER.warn(""String_Node_Str"",e);
      throw e;
    }
 finally {
      if (in != null) {
        IOUtils.closeQuietly(in);
      }
    }
    GzipCompressorInputStream gzIn=null;
    FileOutputStream out=null;
    FileInputStream fin=null;
    BufferedInputStream bin=null;
    try {
      fin=new FileInputStream(compressedFile);
      bin=new BufferedInputStream(fin);
      out=new FileOutputStream(tempCsvFile);
      gzIn=new GzipCompressorInputStream(bin);
      final byte[] buffer=new byte[1024];
      int n=0;
      while (-1 != (n=gzIn.read(buffer))) {
        out.write(buffer,0,n);
      }
      fin.close();
      if (!compressedFile.delete()) {
        LOGGER.warn(""String_Node_Str"" + compressedFile.getAbsolutePath() + ""String_Node_Str"");
      }
      out.close();
    }
 catch (    final IOException e) {
      LOGGER.warn(""String_Node_Str"",e);
      throw e;
    }
 finally {
      if (out != null) {
        IOUtils.closeQuietly(out);
      }
      if (gzIn != null) {
        IOUtils.closeQuietly(gzIn);
      }
      if (fin != null) {
        IOUtils.closeQuietly(fin);
      }
      if (bin != null) {
        IOUtils.closeQuietly(bin);
      }
    }
    if (onlyScenesSinceLastRun && csvFile.exists()) {
      try (final FileInputStream is=new FileInputStream(csvFile)){
        final LineReader lines=new LineReader(new InputStreamReader(is,StringUtils.UTF8_CHAR_SET));
        while (lines.readLine() != null) {
          startLine++;
        }
      }
     }
    if (csvFile.exists()) {
      if (!csvFile.delete()) {
        LOGGER.warn(""String_Node_Str"" + csvFile.getAbsolutePath() + ""String_Node_Str"");
      }
    }
    if (!tempCsvFile.renameTo(csvFile)) {
      LOGGER.warn(""String_Node_Str"" + tempCsvFile.getAbsolutePath() + ""String_Node_Str""+ csvFile.getAbsolutePath()+ ""String_Node_Str"");
    }
  }
  type=createFeatureType();
  setupCsvToFeatureIterator(csvFile,startLine,geometryStore,cqlFilter);
  if (nBestScenes > 0) {
    nBestScenes(nBestScenesByPathRow,nBestScenes);
  }
}","private void init(final File scenesDir,final boolean onlyScenesSinceLastRun,final boolean useCachedScenes,final boolean nBestScenesByPathRow,final int nBestScenes,final WRS2GeometryStore geometryStore,final Filter cqlFilter) throws IOException {
  if (!scenesDir.exists() && !scenesDir.mkdirs()) {
    LOGGER.warn(""String_Node_Str"" + scenesDir.getAbsolutePath() + ""String_Node_Str"");
  }
  final File csvFile=new File(scenesDir,CSV_FILE_NAME);
  long startLine=0;
  if (!csvFile.exists() || !useCachedScenes) {
    final File compressedFile=new File(scenesDir,COMPRESSED_FILE_NAME);
    final File tempCsvFile=new File(scenesDir,TEMP_CSV_FILE_NAME);
    if (compressedFile.exists()) {
      if (!compressedFile.delete()) {
        LOGGER.warn(""String_Node_Str"" + compressedFile.getAbsolutePath() + ""String_Node_Str"");
      }
    }
    if (tempCsvFile.exists()) {
      if (!tempCsvFile.delete()) {
        LOGGER.warn(""String_Node_Str"" + tempCsvFile.getAbsolutePath() + ""String_Node_Str"");
      }
    }
    InputStream in=null;
    final FileOutputStream outStream=new FileOutputStream(compressedFile);
    try {
      in=new URL(SCENES_GZ_URL).openStream();
      IOUtils.copyLarge(in,outStream);
    }
 catch (    final IOException e) {
      LOGGER.warn(""String_Node_Str"",e);
      throw e;
    }
 finally {
      if (outStream != null) {
        outStream.close();
      }
      if (in != null) {
        IOUtils.closeQuietly(in);
      }
    }
    GzipCompressorInputStream gzIn=null;
    FileOutputStream out=null;
    FileInputStream fin=null;
    BufferedInputStream bin=null;
    try {
      fin=new FileInputStream(compressedFile);
      bin=new BufferedInputStream(fin);
      out=new FileOutputStream(tempCsvFile);
      gzIn=new GzipCompressorInputStream(bin);
      final byte[] buffer=new byte[1024];
      int n=0;
      while (-1 != (n=gzIn.read(buffer))) {
        out.write(buffer,0,n);
      }
      fin.close();
      if (!compressedFile.delete()) {
        LOGGER.warn(""String_Node_Str"" + compressedFile.getAbsolutePath() + ""String_Node_Str"");
      }
      out.close();
    }
 catch (    final IOException e) {
      LOGGER.warn(""String_Node_Str"",e);
      throw e;
    }
 finally {
      if (out != null) {
        IOUtils.closeQuietly(out);
      }
      if (gzIn != null) {
        IOUtils.closeQuietly(gzIn);
      }
      if (fin != null) {
        IOUtils.closeQuietly(fin);
      }
      if (bin != null) {
        IOUtils.closeQuietly(bin);
      }
    }
    if (onlyScenesSinceLastRun && csvFile.exists()) {
      try (final FileInputStream is=new FileInputStream(csvFile)){
        final LineReader lines=new LineReader(new InputStreamReader(is,StringUtils.UTF8_CHAR_SET));
        while (lines.readLine() != null) {
          startLine++;
        }
      }
     }
    if (csvFile.exists()) {
      if (!csvFile.delete()) {
        LOGGER.warn(""String_Node_Str"" + csvFile.getAbsolutePath() + ""String_Node_Str"");
      }
    }
    if (!tempCsvFile.renameTo(csvFile)) {
      LOGGER.warn(""String_Node_Str"" + tempCsvFile.getAbsolutePath() + ""String_Node_Str""+ csvFile.getAbsolutePath()+ ""String_Node_Str"");
    }
  }
  type=createFeatureType();
  setupCsvToFeatureIterator(csvFile,startLine,geometryStore,cqlFilter);
  if (nBestScenes > 0) {
    nBestScenes(nBestScenesByPathRow,nBestScenes);
  }
}",0.9632985953783416
112930,"@Override public RecordWriter<GeoWaveOutputKey<Object>,Object> getRecordWriter(final TaskAttemptContext context) throws IOException, InterruptedException {
  try {
    final Map<String,String> configOptions=getStoreOptionsMap(context);
    final AdapterStore persistentAdapterStore=GeoWaveStoreFinder.createAdapterStore(configOptions);
    final DataAdapter<?>[] adapters=JobContextAdapterStore.getDataAdapters(context);
    for (    final DataAdapter<?> a : adapters) {
      if (!persistentAdapterStore.adapterExists(a.getAdapterId())) {
        persistentAdapterStore.addAdapter(a);
      }
    }
    final IndexStore persistentIndexStore=GeoWaveStoreFinder.createIndexStore(configOptions);
    final Index[] indices=JobContextIndexStore.getIndices(context);
    if (LOGGER.isDebugEnabled()) {
      final StringBuilder sbDebug=new StringBuilder();
      sbDebug.append(""String_Node_Str"");
      for (      final Map.Entry<String,String> entry : configOptions.entrySet()) {
        sbDebug.append(entry.getKey() + ""String_Node_Str"" + entry.getValue()+ ""String_Node_Str"");
      }
      sbDebug.append(""String_Node_Str"" + indices.length);
      sbDebug.append(""String_Node_Str"" + persistentIndexStore);
      final String filename=""String_Node_Str"";
      final InputStream is=context.getClass().getResourceAsStream(filename);
      if (is == null) {
        sbDebug.append(""String_Node_Str"" + filename + ""String_Node_Str"");
      }
 else {
        sbDebug.append(""String_Node_Str"" + IOUtils.toString(is,""String_Node_Str""));
      }
      LOGGER.debug(sbDebug.toString());
    }
    for (    final Index i : indices) {
      if (!persistentIndexStore.indexExists(i.getId())) {
        persistentIndexStore.addIndex(i);
      }
    }
    final AdapterStore jobContextAdapterStore=new JobContextAdapterStore(context,persistentAdapterStore);
    final IndexStore jobContextIndexStore=new JobContextIndexStore(context,persistentIndexStore);
    final DataStore dataStore=GeoWaveStoreFinder.createDataStore(configOptions);
    return new GeoWaveRecordWriter(context,dataStore,jobContextIndexStore,jobContextAdapterStore);
  }
 catch (  final Exception e) {
    throw new IOException(e);
  }
}","@Override public RecordWriter<GeoWaveOutputKey<Object>,Object> getRecordWriter(final TaskAttemptContext context) throws IOException, InterruptedException {
  try {
    final Map<String,String> configOptions=getStoreOptionsMap(context);
    final AdapterStore persistentAdapterStore=GeoWaveStoreFinder.createAdapterStore(configOptions);
    final DataAdapter<?>[] adapters=JobContextAdapterStore.getDataAdapters(context);
    for (    final DataAdapter<?> a : adapters) {
      if (!persistentAdapterStore.adapterExists(a.getAdapterId())) {
        persistentAdapterStore.addAdapter(a);
      }
    }
    final IndexStore persistentIndexStore=GeoWaveStoreFinder.createIndexStore(configOptions);
    final Index[] indices=JobContextIndexStore.getIndices(context);
    if (LOGGER.isDebugEnabled()) {
      final StringBuilder sbDebug=new StringBuilder();
      sbDebug.append(""String_Node_Str"");
      for (      final Map.Entry<String,String> entry : configOptions.entrySet()) {
        sbDebug.append(entry.getKey() + ""String_Node_Str"" + entry.getValue()+ ""String_Node_Str"");
      }
      sbDebug.append(""String_Node_Str"" + indices.length);
      sbDebug.append(""String_Node_Str"" + persistentIndexStore);
      final String filename=""String_Node_Str"";
      final InputStream is=context.getClass().getResourceAsStream(filename);
      if (is == null) {
        sbDebug.append(""String_Node_Str"" + filename + ""String_Node_Str"");
      }
 else {
        sbDebug.append(""String_Node_Str"" + IOUtils.toString(is,""String_Node_Str""));
        is.close();
      }
      LOGGER.debug(sbDebug.toString());
    }
    for (    final Index i : indices) {
      if (!persistentIndexStore.indexExists(i.getId())) {
        persistentIndexStore.addIndex(i);
      }
    }
    final AdapterStore jobContextAdapterStore=new JobContextAdapterStore(context,persistentAdapterStore);
    final IndexStore jobContextIndexStore=new JobContextIndexStore(context,persistentIndexStore);
    final DataStore dataStore=GeoWaveStoreFinder.createDataStore(configOptions);
    return new GeoWaveRecordWriter(context,dataStore,jobContextIndexStore,jobContextAdapterStore);
  }
 catch (  final Exception e) {
    throw new IOException(e);
  }
}",0.9954524783992724
112931,"private void init(final File scenesDir,final boolean onlyScenesSinceLastRun,final boolean useCachedScenes,final boolean nBestScenesByPathRow,final int nBestScenes,final WRS2GeometryStore geometryStore,final Filter cqlFilter) throws IOException {
  if (!scenesDir.exists() && !scenesDir.mkdirs()) {
    LOGGER.warn(""String_Node_Str"" + scenesDir.getAbsolutePath() + ""String_Node_Str"");
  }
  final File csvFile=new File(scenesDir,CSV_FILE_NAME);
  long startLine=0;
  if (!csvFile.exists() || !useCachedScenes) {
    final File compressedFile=new File(scenesDir,COMPRESSED_FILE_NAME);
    final File tempCsvFile=new File(scenesDir,TEMP_CSV_FILE_NAME);
    if (compressedFile.exists()) {
      if (!compressedFile.delete()) {
        LOGGER.warn(""String_Node_Str"" + compressedFile.getAbsolutePath() + ""String_Node_Str"");
      }
    }
    if (tempCsvFile.exists()) {
      if (!tempCsvFile.delete()) {
        LOGGER.warn(""String_Node_Str"" + tempCsvFile.getAbsolutePath() + ""String_Node_Str"");
      }
    }
    InputStream in=null;
    try {
      in=new URL(SCENES_GZ_URL).openStream();
      final FileOutputStream outStream=new FileOutputStream(compressedFile);
      IOUtils.copyLarge(in,outStream);
      outStream.close();
    }
 catch (    final IOException e) {
      LOGGER.warn(""String_Node_Str"",e);
      throw e;
    }
 finally {
      if (in != null) {
        IOUtils.closeQuietly(in);
      }
    }
    GzipCompressorInputStream gzIn=null;
    FileOutputStream out=null;
    FileInputStream fin=null;
    BufferedInputStream bin=null;
    try {
      fin=new FileInputStream(compressedFile);
      bin=new BufferedInputStream(fin);
      out=new FileOutputStream(tempCsvFile);
      gzIn=new GzipCompressorInputStream(bin);
      final byte[] buffer=new byte[1024];
      int n=0;
      while (-1 != (n=gzIn.read(buffer))) {
        out.write(buffer,0,n);
      }
      fin.close();
      if (!compressedFile.delete()) {
        LOGGER.warn(""String_Node_Str"" + compressedFile.getAbsolutePath() + ""String_Node_Str"");
      }
      out.close();
    }
 catch (    final IOException e) {
      LOGGER.warn(""String_Node_Str"",e);
      throw e;
    }
 finally {
      if (out != null) {
        IOUtils.closeQuietly(out);
      }
      if (gzIn != null) {
        IOUtils.closeQuietly(gzIn);
      }
      if (fin != null) {
        IOUtils.closeQuietly(fin);
      }
      if (bin != null) {
        IOUtils.closeQuietly(bin);
      }
    }
    if (onlyScenesSinceLastRun && csvFile.exists()) {
      try (final FileInputStream is=new FileInputStream(csvFile)){
        final LineReader lines=new LineReader(new InputStreamReader(is,StringUtils.UTF8_CHAR_SET));
        while (lines.readLine() != null) {
          startLine++;
        }
      }
     }
    if (csvFile.exists()) {
      if (!csvFile.delete()) {
        LOGGER.warn(""String_Node_Str"" + csvFile.getAbsolutePath() + ""String_Node_Str"");
      }
    }
    if (!tempCsvFile.renameTo(csvFile)) {
      LOGGER.warn(""String_Node_Str"" + tempCsvFile.getAbsolutePath() + ""String_Node_Str""+ csvFile.getAbsolutePath()+ ""String_Node_Str"");
    }
  }
  type=createFeatureType();
  setupCsvToFeatureIterator(csvFile,startLine,geometryStore,cqlFilter);
  if (nBestScenes > 0) {
    nBestScenes(nBestScenesByPathRow,nBestScenes);
  }
}","private void init(final File scenesDir,final boolean onlyScenesSinceLastRun,final boolean useCachedScenes,final boolean nBestScenesByPathRow,final int nBestScenes,final WRS2GeometryStore geometryStore,final Filter cqlFilter) throws IOException {
  if (!scenesDir.exists() && !scenesDir.mkdirs()) {
    LOGGER.warn(""String_Node_Str"" + scenesDir.getAbsolutePath() + ""String_Node_Str"");
  }
  final File csvFile=new File(scenesDir,CSV_FILE_NAME);
  long startLine=0;
  if (!csvFile.exists() || !useCachedScenes) {
    final File compressedFile=new File(scenesDir,COMPRESSED_FILE_NAME);
    final File tempCsvFile=new File(scenesDir,TEMP_CSV_FILE_NAME);
    if (compressedFile.exists()) {
      if (!compressedFile.delete()) {
        LOGGER.warn(""String_Node_Str"" + compressedFile.getAbsolutePath() + ""String_Node_Str"");
      }
    }
    if (tempCsvFile.exists()) {
      if (!tempCsvFile.delete()) {
        LOGGER.warn(""String_Node_Str"" + tempCsvFile.getAbsolutePath() + ""String_Node_Str"");
      }
    }
    InputStream in=null;
    final FileOutputStream outStream=new FileOutputStream(compressedFile);
    try {
      in=new URL(SCENES_GZ_URL).openStream();
      IOUtils.copyLarge(in,outStream);
    }
 catch (    final IOException e) {
      LOGGER.warn(""String_Node_Str"",e);
      throw e;
    }
 finally {
      if (outStream != null) {
        outStream.close();
      }
      if (in != null) {
        IOUtils.closeQuietly(in);
      }
    }
    GzipCompressorInputStream gzIn=null;
    FileOutputStream out=null;
    FileInputStream fin=null;
    BufferedInputStream bin=null;
    try {
      fin=new FileInputStream(compressedFile);
      bin=new BufferedInputStream(fin);
      out=new FileOutputStream(tempCsvFile);
      gzIn=new GzipCompressorInputStream(bin);
      final byte[] buffer=new byte[1024];
      int n=0;
      while (-1 != (n=gzIn.read(buffer))) {
        out.write(buffer,0,n);
      }
      fin.close();
      if (!compressedFile.delete()) {
        LOGGER.warn(""String_Node_Str"" + compressedFile.getAbsolutePath() + ""String_Node_Str"");
      }
      out.close();
    }
 catch (    final IOException e) {
      LOGGER.warn(""String_Node_Str"",e);
      throw e;
    }
 finally {
      if (out != null) {
        IOUtils.closeQuietly(out);
      }
      if (gzIn != null) {
        IOUtils.closeQuietly(gzIn);
      }
      if (fin != null) {
        IOUtils.closeQuietly(fin);
      }
      if (bin != null) {
        IOUtils.closeQuietly(bin);
      }
    }
    if (onlyScenesSinceLastRun && csvFile.exists()) {
      try (final FileInputStream is=new FileInputStream(csvFile)){
        final LineReader lines=new LineReader(new InputStreamReader(is,StringUtils.UTF8_CHAR_SET));
        while (lines.readLine() != null) {
          startLine++;
        }
      }
     }
    if (csvFile.exists()) {
      if (!csvFile.delete()) {
        LOGGER.warn(""String_Node_Str"" + csvFile.getAbsolutePath() + ""String_Node_Str"");
      }
    }
    if (!tempCsvFile.renameTo(csvFile)) {
      LOGGER.warn(""String_Node_Str"" + tempCsvFile.getAbsolutePath() + ""String_Node_Str""+ csvFile.getAbsolutePath()+ ""String_Node_Str"");
    }
  }
  type=createFeatureType();
  setupCsvToFeatureIterator(csvFile,startLine,geometryStore,cqlFilter);
  if (nBestScenes > 0) {
    nBestScenes(nBestScenesByPathRow,nBestScenes);
  }
}",0.9632985953783416
112932,"private void initStores(File configFile,String sql,String outputStoreName){
  String inputStoreInfo1=null;
  String inputStoreInfo2=null;
  String escapedSpaceRegex=java.util.regex.Pattern.quote(""String_Node_Str"");
  LOGGER.debug(""String_Node_Str"" + sql);
  String[] sqlSplits=sql.split(escapedSpaceRegex);
  int splitIndex=0;
  while (splitIndex < sqlSplits.length) {
    String split=sqlSplits[splitIndex];
    if (split.equalsIgnoreCase(""String_Node_Str"")) {
      if (splitIndex < sqlSplits.length - 1) {
        splitIndex++;
        inputStoreInfo1=sqlSplits[splitIndex];
        LOGGER.debug(""String_Node_Str"" + inputStoreInfo1);
      }
    }
 else     if (split.equalsIgnoreCase(""String_Node_Str"")) {
      if (splitIndex < sqlSplits.length - 1) {
        splitIndex++;
        inputStoreInfo2=sqlSplits[splitIndex];
        LOGGER.debug(""String_Node_Str"" + inputStoreInfo2);
      }
    }
    splitIndex++;
  }
  String escapedDelimRegex=java.util.regex.Pattern.quote(STORE_ADAPTER_DELIM);
  if (inputStoreInfo1 != null) {
    String inputStoreName=inputStoreInfo1;
    String adapterName=null;
    if (inputStoreInfo1.contains(STORE_ADAPTER_DELIM)) {
      String[] infoParts=inputStoreInfo1.split(escapedDelimRegex);
      if (infoParts.length > 2) {
        throw new ParameterException(""String_Node_Str"" + inputStoreInfo1);
      }
      inputStoreName=infoParts[0];
      adapterName=infoParts[1];
    }
    LOGGER.debug(""String_Node_Str"" + inputStoreName);
    LOGGER.debug(""String_Node_Str"" + adapterName);
    final StoreLoader inputStoreLoader=new StoreLoader(inputStoreName);
    if (!inputStoreLoader.loadFromConfig(configFile)) {
      throw new ParameterException(""String_Node_Str"" + inputStoreLoader.getStoreName());
    }
    inputDataStore1=inputStoreLoader.getDataStorePlugin();
    if (adapterName != null) {
      adapterId1=new ByteArrayId(adapterName);
    }
    tempView1=inputStoreInfo1;
  }
  if (inputStoreInfo2 != null) {
    String inputStoreName=inputStoreInfo2;
    String adapterName=null;
    if (inputStoreInfo2.contains(STORE_ADAPTER_DELIM)) {
      String[] infoParts=inputStoreInfo2.split(escapedDelimRegex);
      if (infoParts.length > 2) {
        throw new ParameterException(""String_Node_Str"" + inputStoreInfo2);
      }
      inputStoreName=infoParts[0];
      adapterName=infoParts[1];
    }
    LOGGER.debug(""String_Node_Str"" + inputStoreName);
    LOGGER.debug(""String_Node_Str"" + adapterName);
    final StoreLoader inputStoreLoader=new StoreLoader(inputStoreName);
    if (!inputStoreLoader.loadFromConfig(configFile)) {
      throw new ParameterException(""String_Node_Str"" + inputStoreLoader.getStoreName());
    }
    inputDataStore2=inputStoreLoader.getDataStorePlugin();
    if (adapterName != null) {
      adapterId2=new ByteArrayId(adapterName);
    }
    tempView2=inputStoreInfo2;
  }
  if (outputStoreName != null) {
    final StoreLoader outputStoreLoader=new StoreLoader(outputStoreName);
    if (!outputStoreLoader.loadFromConfig(configFile)) {
      throw new ParameterException(""String_Node_Str"" + outputStoreLoader.getStoreName());
    }
    outputDataStore=outputStoreLoader.getDataStorePlugin();
  }
}","private void initStores(File configFile,String sql,String outputStoreName){
  String inputStoreInfo1=null;
  String inputStoreInfo2=null;
  String escapedSpaceRegex=java.util.regex.Pattern.quote(""String_Node_Str"");
  LOGGER.debug(""String_Node_Str"" + sql);
  String[] sqlSplits=sql.split(escapedSpaceRegex);
  int splitIndex=0;
  while (splitIndex < sqlSplits.length) {
    String split=sqlSplits[splitIndex];
    if (split.equalsIgnoreCase(""String_Node_Str"")) {
      if (splitIndex < sqlSplits.length - 1) {
        splitIndex++;
        inputStoreInfo1=sqlSplits[splitIndex];
        LOGGER.debug(""String_Node_Str"" + inputStoreInfo1);
      }
    }
 else     if (split.equalsIgnoreCase(""String_Node_Str"")) {
      if (splitIndex < sqlSplits.length - 1) {
        splitIndex++;
        inputStoreInfo2=sqlSplits[splitIndex];
        LOGGER.debug(""String_Node_Str"" + inputStoreInfo2);
      }
    }
    splitIndex++;
  }
  String escapedDelimRegex=java.util.regex.Pattern.quote(STORE_ADAPTER_DELIM);
  if (inputStoreInfo1 != null) {
    String inputStoreName=inputStoreInfo1;
    String adapterName=null;
    if (inputStoreInfo1.contains(STORE_ADAPTER_DELIM)) {
      String[] infoParts=inputStoreInfo1.split(escapedDelimRegex);
      if (infoParts.length > 2) {
        throw new ParameterException(""String_Node_Str"" + STORE_ADAPTER_DELIM + ""String_Node_Str""+ inputStoreInfo1);
      }
      inputStoreName=infoParts[0];
      adapterName=infoParts[1];
    }
    LOGGER.debug(""String_Node_Str"" + inputStoreName);
    LOGGER.debug(""String_Node_Str"" + adapterName);
    final StoreLoader inputStoreLoader=new StoreLoader(inputStoreName);
    if (!inputStoreLoader.loadFromConfig(configFile)) {
      throw new ParameterException(""String_Node_Str"" + inputStoreLoader.getStoreName());
    }
    inputDataStore1=inputStoreLoader.getDataStorePlugin();
    if (adapterName != null) {
      adapterId1=new ByteArrayId(adapterName);
    }
    tempView1=inputStoreInfo1;
  }
  if (inputStoreInfo2 != null) {
    String inputStoreName=inputStoreInfo2;
    String adapterName=null;
    if (inputStoreInfo2.contains(STORE_ADAPTER_DELIM)) {
      String[] infoParts=inputStoreInfo2.split(escapedDelimRegex);
      if (infoParts.length > 2) {
        throw new ParameterException(""String_Node_Str"" + STORE_ADAPTER_DELIM + ""String_Node_Str""+ inputStoreInfo2);
      }
      inputStoreName=infoParts[0];
      adapterName=infoParts[1];
    }
    LOGGER.debug(""String_Node_Str"" + inputStoreName);
    LOGGER.debug(""String_Node_Str"" + adapterName);
    final StoreLoader inputStoreLoader=new StoreLoader(inputStoreName);
    if (!inputStoreLoader.loadFromConfig(configFile)) {
      throw new ParameterException(""String_Node_Str"" + inputStoreLoader.getStoreName());
    }
    inputDataStore2=inputStoreLoader.getDataStorePlugin();
    if (adapterName != null) {
      adapterId2=new ByteArrayId(adapterName);
    }
    tempView2=inputStoreInfo2;
  }
  if (outputStoreName != null) {
    final StoreLoader outputStoreLoader=new StoreLoader(outputStoreName);
    if (!outputStoreLoader.loadFromConfig(configFile)) {
      throw new ParameterException(""String_Node_Str"" + outputStoreLoader.getStoreName());
    }
    outputDataStore=outputStoreLoader.getDataStorePlugin();
  }
}",0.6408582089552238
112933,"@Test public void testMosaic() throws Exception {
  MapProjection.SKIP_SANITY_CHECKS=true;
  TestUtils.deleteAll(dataStoreOptions);
  final Landsat8BasicCommandLineOptions analyzeOptions=new Landsat8BasicCommandLineOptions();
  analyzeOptions.setCqlFilter(String.format(""String_Node_Str"",SceneFeatureIterator.SHAPE_ATTRIBUTE_NAME,WEST,SOUTH,EAST,NORTH,BandFeatureIterator.BAND_ATTRIBUTE_NAME,SceneFeatureIterator.ACQUISITION_DATE_ATTRIBUTE_NAME,""String_Node_Str"",MIN_PATH,MAX_PATH,MIN_ROW,MAX_ROW));
  analyzeOptions.setNBestPerSpatial(true);
  analyzeOptions.setNBestScenes(1);
  analyzeOptions.setUseCachedScenes(true);
  final Landsat8DownloadCommandLineOptions downloadOptions=new Landsat8DownloadCommandLineOptions();
  final Landsat8RasterIngestCommandLineOptions ingestOptions=new Landsat8RasterIngestCommandLineOptions();
  ingestOptions.setRetainImages(true);
  ingestOptions.setCreatePyramid(true);
  ingestOptions.setCreateHistogram(true);
  ingestOptions.setCoverageName(""String_Node_Str"");
  ingestOptions.setCropToSpatialConstraint(true);
  final RasterIngestTester runner=new RasterIngestTester(dataStoreOptions,analyzeOptions,downloadOptions,ingestOptions,null);
  runner.runInternal(null);
  final StringBuilder str=new StringBuilder(StoreFactoryOptions.GEOWAVE_NAMESPACE_OPTION).append(""String_Node_Str"").append(dataStoreOptions.getGeowaveNamespace()).append(""String_Node_Str"").append(Interpolation.INTERP_NEAREST);
  str.append(""String_Node_Str"").append(GeoWaveStoreFinder.STORE_HINT_KEY).append(""String_Node_Str"").append(dataStoreOptions.getType());
  final Map<String,String> options=dataStoreOptions.getOptionsAsMap();
  for (  final Entry<String,String> entry : options.entrySet()) {
    if (!entry.getKey().equals(StoreFactoryOptions.GEOWAVE_NAMESPACE_OPTION)) {
      str.append(""String_Node_Str"").append(entry.getKey()).append(""String_Node_Str"").append(entry.getValue());
    }
  }
  final GeneralEnvelope queryEnvelope=new GeneralEnvelope(new double[]{WEST,SOUTH},new double[]{EAST,NORTH});
  queryEnvelope.setCoordinateReferenceSystem(GeoWaveGTRasterFormat.DEFAULT_CRS);
  final GeoWaveRasterReader reader=new GeoWaveRasterReader(GeoWaveRasterConfig.readFromConfigParams(str.toString()));
  final GridCoverage2D gridCoverage=reader.renderGridCoverage(""String_Node_Str"",new Rectangle(0,0,1024,1024),queryEnvelope,null,null,null);
  final RenderedImage result=gridCoverage.getRenderedImage();
  final BufferedImage reference=ImageIO.read(new File(REFERENCE_LANDSAT_IMAGE_PATH));
  TestUtils.testTileAgainstReference(PlanarImage.wrapRenderedImage(result).getAsBufferedImage(),reference,0,0.005);
  MapProjection.SKIP_SANITY_CHECKS=false;
}","@Test public void testMosaic() throws Exception {
  JAIExt.initJAIEXT();
  MapProjection.SKIP_SANITY_CHECKS=true;
  TestUtils.deleteAll(dataStoreOptions);
  final Landsat8BasicCommandLineOptions analyzeOptions=new Landsat8BasicCommandLineOptions();
  analyzeOptions.setCqlFilter(String.format(""String_Node_Str"",SceneFeatureIterator.SHAPE_ATTRIBUTE_NAME,WEST,SOUTH,EAST,NORTH,BandFeatureIterator.BAND_ATTRIBUTE_NAME,SceneFeatureIterator.ACQUISITION_DATE_ATTRIBUTE_NAME,""String_Node_Str"",MIN_PATH,MAX_PATH,MIN_ROW,MAX_ROW));
  analyzeOptions.setNBestPerSpatial(true);
  analyzeOptions.setNBestScenes(1);
  analyzeOptions.setUseCachedScenes(true);
  final Landsat8DownloadCommandLineOptions downloadOptions=new Landsat8DownloadCommandLineOptions();
  final Landsat8RasterIngestCommandLineOptions ingestOptions=new Landsat8RasterIngestCommandLineOptions();
  ingestOptions.setRetainImages(true);
  ingestOptions.setCreatePyramid(true);
  ingestOptions.setCreateHistogram(true);
  ingestOptions.setCoverageName(""String_Node_Str"");
  ingestOptions.setCropToSpatialConstraint(true);
  final RasterIngestTester runner=new RasterIngestTester(dataStoreOptions,analyzeOptions,downloadOptions,ingestOptions,null);
  runner.runInternal(null);
  final StringBuilder str=new StringBuilder(StoreFactoryOptions.GEOWAVE_NAMESPACE_OPTION).append(""String_Node_Str"").append(dataStoreOptions.getGeowaveNamespace()).append(""String_Node_Str"").append(Interpolation.INTERP_NEAREST);
  str.append(""String_Node_Str"").append(GeoWaveStoreFinder.STORE_HINT_KEY).append(""String_Node_Str"").append(dataStoreOptions.getType());
  final Map<String,String> options=dataStoreOptions.getOptionsAsMap();
  for (  final Entry<String,String> entry : options.entrySet()) {
    if (!entry.getKey().equals(StoreFactoryOptions.GEOWAVE_NAMESPACE_OPTION)) {
      str.append(""String_Node_Str"").append(entry.getKey()).append(""String_Node_Str"").append(entry.getValue());
    }
  }
  final GeneralEnvelope queryEnvelope=new GeneralEnvelope(new double[]{WEST,SOUTH},new double[]{EAST,NORTH});
  queryEnvelope.setCoordinateReferenceSystem(GeoWaveGTRasterFormat.DEFAULT_CRS);
  final GeoWaveRasterReader reader=new GeoWaveRasterReader(GeoWaveRasterConfig.readFromConfigParams(str.toString()));
  final GridCoverage2D gridCoverage=reader.renderGridCoverage(""String_Node_Str"",new Rectangle(0,0,1024,1024),queryEnvelope,null,null,null);
  final RenderedImage result=gridCoverage.getRenderedImage();
  final BufferedImage reference=ImageIO.read(new File(REFERENCE_LANDSAT_IMAGE_PATH));
  TestUtils.testTileAgainstReference(PlanarImage.wrapRenderedImage(result).getAsBufferedImage(),reference,0,0.005);
  MapProjection.SKIP_SANITY_CHECKS=false;
}",0.9957017379928984
112934,"@Override protected void processParameters(final OperationParams params) throws Exception {
  store=dataStoreOptions.createDataStore();
  indices=new PrimaryIndex[]{new SpatialIndexBuilder().createIndex()};
  coverageNameTemplate=new Template(""String_Node_Str"",new StringReader(ingestOptions.getCoverageName()),new Configuration());
}","@Override protected void processParameters(final OperationParams params) throws Exception {
  store=dataStoreOptions.createDataStore();
  dataStorePluginOptions=dataStoreOptions;
  indices=new PrimaryIndex[]{new SpatialIndexBuilder().createIndex()};
  coverageNameTemplate=new Template(""String_Node_Str"",new StringReader(ingestOptions.getCoverageName()),new Configuration());
}",0.939521800281294
112935,"/** 
 * Prompt a user for a password and return the input
 * @param promptMessage
 * @return
 */
protected static String promptAndReadPassword(String promptMessage){
  LOGGER.trace(""String_Node_Str"");
  PropertiesUtils propsUtils=new PropertiesUtils(getProperties());
  boolean defaultEchoEnabled=propsUtils.getBoolean(Constants.CONSOLE_DEFAULT_ECHO_ENABLED_KEY,false);
  boolean passwordEchoEnabled=propsUtils.getBoolean(Constants.CONSOLE_PASSWORD_ECHO_ENABLED_KEY,defaultEchoEnabled);
  LOGGER.debug(""String_Node_Str"",new Object[]{passwordEchoEnabled ? ""String_Node_Str"" : ""String_Node_Str""});
  getConsole().print(promptMessage);
  char[] passwordChars=getConsole().readPassword(passwordEchoEnabled);
  return new String(passwordChars);
}","/** 
 * Prompt a user for a password and return the input
 * @param promptMessage
 * @return
 */
public static String promptAndReadPassword(String promptMessage){
  LOGGER.trace(""String_Node_Str"");
  PropertiesUtils propsUtils=new PropertiesUtils(getProperties());
  boolean defaultEchoEnabled=propsUtils.getBoolean(Constants.CONSOLE_DEFAULT_ECHO_ENABLED_KEY,false);
  boolean passwordEchoEnabled=propsUtils.getBoolean(Constants.CONSOLE_PASSWORD_ECHO_ENABLED_KEY,defaultEchoEnabled);
  LOGGER.debug(""String_Node_Str"",new Object[]{passwordEchoEnabled ? ""String_Node_Str"" : ""String_Node_Str""});
  getConsole().print(promptMessage);
  char[] passwordChars=getConsole().readPassword(passwordEchoEnabled);
  return new String(passwordChars);
}",0.991210277214334
112936,"/** 
 * Prompt a user for a standard value and return the input
 * @param promptMessage
 * @return
 */
protected static String promptAndReadValue(String promptMessage){
  LOGGER.trace(""String_Node_Str"");
  PropertiesUtils propsUtils=new PropertiesUtils(getProperties());
  boolean defaultEchoEnabled=propsUtils.getBoolean(Constants.CONSOLE_DEFAULT_ECHO_ENABLED_KEY,false);
  LOGGER.debug(""String_Node_Str"",new Object[]{defaultEchoEnabled ? ""String_Node_Str"" : ""String_Node_Str""});
  getConsole().print(promptMessage);
  char[] passwordChars=getConsole().readPassword(defaultEchoEnabled);
  return new String(passwordChars);
}","/** 
 * Prompt a user for a standard value and return the input
 * @param promptMessage
 * @return
 */
public static String promptAndReadValue(String promptMessage){
  LOGGER.trace(""String_Node_Str"");
  PropertiesUtils propsUtils=new PropertiesUtils(getProperties());
  boolean defaultEchoEnabled=propsUtils.getBoolean(Constants.CONSOLE_DEFAULT_ECHO_ENABLED_KEY,false);
  LOGGER.debug(""String_Node_Str"",new Object[]{defaultEchoEnabled ? ""String_Node_Str"" : ""String_Node_Str""});
  getConsole().print(promptMessage);
  char[] passwordChars=getConsole().readPassword(defaultEchoEnabled);
  return new String(passwordChars);
}",0.9895749799518844
112937,"private List<QueryRequest> addQueryRanges(final String tableName,final ByteArrayRange r,final List<ByteArrayId> adapterIDs,final DynamoDBAdapterStore adapterStore){
  final List<QueryRequest> retVal=getPartitionRequests(tableName);
  for (  final QueryRequest queryRequest : retVal) {
    if (adapterIDs.isEmpty()) {
      CloseableIterator<DataAdapter<?>> adapters=adapterStore.getAdapters();
      List<ByteArrayId> adapterIDList=new ArrayList<ByteArrayId>();
      adapters.forEachRemaining(new Consumer<DataAdapter<?>>(){
        @Override public void accept(        DataAdapter<?> t){
          adapterIDList.add(t.getAdapterId());
        }
      }
);
      adapterIDs.addAll(adapterIDList);
    }
    for (    final ByteArrayId adapterID : adapterIDs) {
      addQueryRange(r,queryRequest,adapterID);
    }
  }
  return retVal;
}","private List<QueryRequest> addQueryRanges(final String tableName,final ByteArrayRange r,final List<ByteArrayId> adapterIds,final AdapterStore adapterStore){
  List<QueryRequest> retVal=null;
  if (adapterIds.isEmpty()) {
    final CloseableIterator<DataAdapter<?>> adapters=adapterStore.getAdapters();
    final List<ByteArrayId> adapterIDList=new ArrayList<ByteArrayId>();
    adapters.forEachRemaining(new Consumer<DataAdapter<?>>(){
      @Override public void accept(      final DataAdapter<?> t){
        adapterIDList.add(t.getAdapterId());
      }
    }
);
    adapterIds.addAll(adapterIDList);
  }
  for (  final ByteArrayId adapterId : adapterIds) {
    final List<QueryRequest> internalRequests=getPartitionRequests(tableName);
    for (    final QueryRequest queryRequest : internalRequests) {
      addQueryRange(r,queryRequest,adapterId);
    }
    if (retVal == null) {
      retVal=internalRequests;
    }
 else {
      retVal.addAll(internalRequests);
    }
  }
  if (retVal == null) {
    return Collections.EMPTY_LIST;
  }
  return retVal;
}",0.7007915567282322
112938,"protected Iterator<Map<String,AttributeValue>> getResults(final double[] maxResolutionSubsamplingPerDimension,final Integer limit,final AdapterStore adapterStore){
  final List<ByteArrayRange> ranges=getRanges();
  final String tableName=dynamodbOperations.getQualifiedTableName(StringUtils.stringFromBinary(index.getId().getBytes()));
  if ((ranges != null) && !ranges.isEmpty()) {
    final List<QueryRequest> requests=new ArrayList<>();
    if (ranges.size() == 1 && (adapterIds.size() == 1)) {
      final List<QueryRequest> queries=getPartitionRequests(tableName);
      final ByteArrayRange r=ranges.get(0);
      if (r.isSingleValue()) {
        for (        final QueryRequest query : queries) {
          for (          final ByteArrayId adapterID : adapterIds) {
            byte[] start=ByteArrayUtils.combineArrays(adapterID.getBytes(),r.getStart().getBytes());
            query.addQueryFilterEntry(DynamoDBRow.GW_RANGE_KEY,new Condition().withAttributeValueList(new AttributeValue().withB(ByteBuffer.wrap(start))).withComparisonOperator(ComparisonOperator.EQ));
          }
        }
      }
 else {
        for (        final QueryRequest query : queries) {
          for (          final ByteArrayId adapterID : adapterIds) {
            addQueryRange(r,query,adapterID);
          }
        }
      }
      requests.addAll(queries);
    }
 else {
      ranges.forEach((r -> requests.addAll(addQueryRanges(tableName,r,adapterIds,(DynamoDBAdapterStore)adapterStore))));
    }
    return Iterators.concat(requests.parallelStream().map(this::executeQueryRequest).iterator());
  }
  final ScanRequest request=new ScanRequest(tableName);
  final ScanResult scanResult=dynamodbOperations.getClient().scan(request);
  return new LazyPaginatedScan(scanResult,request,dynamodbOperations.getClient());
}","protected Iterator<Map<String,AttributeValue>> getResults(final double[] maxResolutionSubsamplingPerDimension,final Integer limit,final AdapterStore adapterStore){
  final List<ByteArrayRange> ranges=getRanges();
  final String tableName=dynamodbOperations.getQualifiedTableName(StringUtils.stringFromBinary(index.getId().getBytes()));
  if ((ranges != null) && !ranges.isEmpty()) {
    final List<QueryRequest> requests=new ArrayList<>();
    if ((ranges.size() == 1) && (adapterIds.size() == 1)) {
      final List<QueryRequest> queries=getPartitionRequests(tableName);
      final ByteArrayRange r=ranges.get(0);
      if (r.isSingleValue()) {
        for (        final QueryRequest query : queries) {
          for (          final ByteArrayId adapterID : adapterIds) {
            final byte[] start=ByteArrayUtils.combineArrays(adapterID.getBytes(),r.getStart().getBytes());
            query.addQueryFilterEntry(DynamoDBRow.GW_RANGE_KEY,new Condition().withAttributeValueList(new AttributeValue().withB(ByteBuffer.wrap(start))).withComparisonOperator(ComparisonOperator.EQ));
          }
        }
      }
 else {
        for (        final QueryRequest query : queries) {
          for (          final ByteArrayId adapterID : adapterIds) {
            addQueryRange(r,query,adapterID);
          }
        }
      }
      requests.addAll(queries);
    }
 else {
      ranges.forEach((r -> requests.addAll(addQueryRanges(tableName,r,adapterIds,adapterStore))));
    }
    return Iterators.concat(requests.parallelStream().map(this::executeQueryRequest).iterator());
  }
 else   if ((adapterIds != null) && !adapterIds.isEmpty()) {
    final List<QueryRequest> queries=getAdapterOnlyQueryRequests(tableName);
    return Iterators.concat(queries.parallelStream().map(this::executeQueryRequest).iterator());
  }
  final ScanRequest request=new ScanRequest(tableName);
  final ScanResult scanResult=dynamodbOperations.getClient().scan(request);
  return new LazyPaginatedScan(scanResult,request,dynamodbOperations.getClient());
}",0.9300026021337496
112939,"private void addQueryRange(final ByteArrayRange r,final QueryRequest query,final ByteArrayId adapterID){
  byte[] start=ByteArrayUtils.combineArrays(adapterID.getBytes(),r.getStart().getBytes());
  byte[] end=ByteArrayUtils.combineArrays(adapterID.getBytes(),r.getEndAsNextPrefix().getBytes());
  query.addKeyConditionsEntry(DynamoDBRow.GW_RANGE_KEY,new Condition().withComparisonOperator(ComparisonOperator.BETWEEN).withAttributeValueList(new AttributeValue().withB(ByteBuffer.wrap(start)),new AttributeValue().withB(ByteBuffer.wrap(end))));
}","private void addQueryRange(final ByteArrayRange r,final QueryRequest query,final ByteArrayId adapterID){
  final byte[] start=ByteArrayUtils.combineArrays(adapterID.getBytes(),r.getStart().getBytes());
  final byte[] end=ByteArrayUtils.combineArrays(adapterID.getBytes(),r.getEndAsNextPrefix().getBytes());
  query.addKeyConditionsEntry(DynamoDBRow.GW_RANGE_KEY,new Condition().withComparisonOperator(ComparisonOperator.BETWEEN).withAttributeValueList(new AttributeValue().withB(ByteBuffer.wrap(start)),new AttributeValue().withB(ByteBuffer.wrap(end))));
}",0.9890909090909092
112940,"@Override public void accept(DataAdapter<?> t){
  adapterIDList.add(t.getAdapterId());
}","@Override public void accept(final DataAdapter<?> t){
  adapterIDList.add(t.getAdapterId());
}",0.967032967032967
112941,"public InputFormatDynamoDBRangeQuery(final BaseDataStore dataStore,final AdapterStore adapterStore,final DynamoDBOperations dynamoDBOperations,final PrimaryIndex index,final ByteArrayRange range,final List<QueryFilter> queryFilters,final boolean isOutputWritable,final QueryOptions queryOptions){
  super(dataStore,dynamoDBOperations,getAdapterIds(index,adapterStore,queryOptions),index,null,queryFilters != null ? queryFilters : new ArrayList<QueryFilter>(),null,(ScanCallback<?,DynamoDBRow>)queryOptions.getScanCallback(),null,null,null,null,null,queryOptions.getAuthorizations());
  this.range=range;
  this.isOutputWritable=isOutputWritable;
}","public InputFormatDynamoDBRangeQuery(final BaseDataStore dataStore,final AdapterStore adapterStore,final DynamoDBOperations dynamoDBOperations,final PrimaryIndex index,final ByteArrayRange range,final List<QueryFilter> queryFilters,final boolean isOutputWritable,final QueryOptions queryOptions){
  super(dataStore,dynamoDBOperations,getAdapterIds(adapterStore,queryOptions),index,null,queryFilters != null ? queryFilters : new ArrayList<QueryFilter>(),null,(ScanCallback<?,DynamoDBRow>)queryOptions.getScanCallback(),null,null,null,null,null,queryOptions.getAuthorizations());
  this.range=range;
  this.isOutputWritable=isOutputWritable;
}",0.9953416149068324
112942,"private static List<ByteArrayId> getAdapterIds(final PrimaryIndex index,final AdapterStore adapterStore,final QueryOptions queryOptions){
  try {
    return queryOptions.getAdapterIds(adapterStore);
  }
 catch (  final IOException e) {
    LOGGER.error(""String_Node_Str"",e);
  }
  return Collections.emptyList();
}","private static List<ByteArrayId> getAdapterIds(final AdapterStore adapterStore,final QueryOptions queryOptions){
  try {
    return queryOptions.getAdapterIds(adapterStore);
  }
 catch (  final IOException e) {
    LOGGER.error(""String_Node_Str"",e);
  }
  return Collections.emptyList();
}",0.9585406301824212
112943,"private boolean inBounds(final Cell cell){
  final MultiDimensionalCoordinates coordinates=indexStrategy.getCoordinatesPerDimension(new ByteArrayId(new GeowaveRowId(cell.getRowArray(),cell.getRowLength()).getInsertionId()));
  return rangeCache.inBounds(coordinates);
}","private boolean inBounds(final Cell cell){
  final MultiDimensionalCoordinates coordinates=indexStrategy.getCoordinatesPerDimension(new ByteArrayId(new GeowaveRowId(cell.getRowArray(),cell.getRowOffset(),cell.getRowLength()).getInsertionId()));
  return rangeCache.inBounds(coordinates);
}",0.96415770609319
112944,"public static synchronized ConfigOption[] getAllOptions(){
  final List<ConfigOption> allOptions=new ArrayList<ConfigOption>();
  for (  final StoreFactoryFamilySpi f : getRegisteredStoreFactoryFamilies().values()) {
    final ConfigOption[] factoryOptions=ConfigUtils.createConfigOptionsFromJCommander(f.getDataStoreFactory().createOptionsInstance());
    allOptions.addAll(Arrays.asList(factoryOptions));
  }
  return allOptions.toArray(new ConfigOption[]{});
}","public static synchronized ConfigOption[] getAllOptions(final StoreFactoryFamilySpi storeFactoryFamily,boolean includeHidden){
  final List<ConfigOption> allOptions=new ArrayList<ConfigOption>();
  allOptions.addAll(Arrays.asList(ConfigUtils.createConfigOptionsFromJCommander(storeFactoryFamily.getDataStoreFactory().createOptionsInstance(),includeHidden)));
  return allOptions.toArray(new ConfigOption[]{});
}",0.4576659038901602
112945,"private static List<String> getMatchingRequiredOptions(final StoreFactoryFamilySpi factory,final Map<String,String> configOptions){
  final ConfigOption[] options=ConfigUtils.createConfigOptionsFromJCommander(factory.getDataStoreFactory().createOptionsInstance());
  final List<String> matching=new ArrayList<String>();
  for (  final ConfigOption option : options) {
    if (!option.isOptional() && configOptions.containsKey(option.getName())) {
      matching.add(option.getName());
    }
  }
  return matching;
}","private static List<String> getMatchingRequiredOptions(final StoreFactoryFamilySpi factory,final Map<String,String> configOptions){
  final ConfigOption[] options=ConfigUtils.createConfigOptionsFromJCommander(factory.getDataStoreFactory().createOptionsInstance(),false);
  final List<String> matching=new ArrayList<String>();
  for (  final ConfigOption option : options) {
    if (!option.isOptional() && configOptions.containsKey(option.getName())) {
      matching.add(option.getName());
    }
  }
  return matching;
}",0.9942084942084942
112946,"public static boolean exactMatch(final StoreFactoryFamilySpi geowaveStoreFactoryFamily,final Map<String,String> params){
  final ConfigOption[] requiredOptions=GeoWaveStoreFinder.getRequiredOptions(geowaveStoreFactoryFamily);
  for (  final ConfigOption requiredOption : requiredOptions) {
    if (!params.containsKey(requiredOption.getName())) {
      return false;
    }
  }
  final Set<String> availableOptions=new HashSet<String>();
  for (  final ConfigOption option : GeoWaveStoreFinder.getAllOptions(geowaveStoreFactoryFamily)) {
    availableOptions.add(option.getName());
  }
  for (  final String optionName : params.keySet()) {
    if (!availableOptions.contains(optionName) && !STORE_HINT_KEY.equals(optionName)) {
      return false;
    }
  }
  try {
    final StoreFactoryOptions options=ConfigUtils.populateOptionsFromList(geowaveStoreFactoryFamily.getDataStoreFactory().createOptionsInstance(),params);
    geowaveStoreFactoryFamily.getIndexStoreFactory().createStore(options);
  }
 catch (  final Exception e) {
    LOGGER.info(""String_Node_Str"",e);
    return false;
  }
  return true;
}","public static boolean exactMatch(final StoreFactoryFamilySpi geowaveStoreFactoryFamily,final Map<String,String> params){
  final ConfigOption[] requiredOptions=GeoWaveStoreFinder.getRequiredOptions(geowaveStoreFactoryFamily);
  for (  final ConfigOption requiredOption : requiredOptions) {
    if (!params.containsKey(requiredOption.getName())) {
      return false;
    }
  }
  final Set<String> availableOptions=new HashSet<String>();
  for (  final ConfigOption option : GeoWaveStoreFinder.getAllOptions(geowaveStoreFactoryFamily,true)) {
    availableOptions.add(option.getName());
  }
  for (  final String optionName : params.keySet()) {
    if (!availableOptions.contains(optionName) && !STORE_HINT_KEY.equals(optionName)) {
      return false;
    }
  }
  try {
    final StoreFactoryOptions options=ConfigUtils.populateOptionsFromList(geowaveStoreFactoryFamily.getDataStoreFactory().createOptionsInstance(),params);
    geowaveStoreFactoryFamily.getIndexStoreFactory().createStore(options);
  }
 catch (  final Exception e) {
    LOGGER.info(""String_Node_Str"",e);
    return false;
  }
  return true;
}",0.997744700045106
112947,"public static StoreFactoryFamilySpi findStoreFamily(final Map<String,String> configOptions){
  final Object storeHint=configOptions.get(STORE_HINT_KEY);
  final Map<String,StoreFactoryFamilySpi> internalStoreFamilies=getRegisteredStoreFactoryFamilies();
  if (storeHint != null) {
    final StoreFactoryFamilySpi factory=internalStoreFamilies.get(storeHint.toString());
    if (factory != null) {
      final List<String> missingOptions=getMissingRequiredOptions(factory,configOptions);
      if (missingOptions.isEmpty()) {
        return factory;
      }
      LOGGER.error(""String_Node_Str"" + storeHint.toString() + ""String_Node_Str""+ ConfigUtils.getOptions(missingOptions));
      return null;
    }
 else {
      LOGGER.error(""String_Node_Str"" + storeHint.toString() + ""String_Node_Str"");
      return null;
    }
  }
  for (  final Entry<String,StoreFactoryFamilySpi> entry : internalStoreFamilies.entrySet()) {
    if (exactMatch(entry.getValue(),configOptions)) {
      return entry.getValue();
    }
  }
  int matchingFactoryRequiredOptionsCount=-1;
  StoreFactoryFamilySpi matchingFactory=null;
  boolean matchingFactoriesHaveSameRequiredOptionsCount=false;
  LOGGER.debug(""String_Node_Str"" + internalStoreFamilies.size());
  for (  final Entry<String,StoreFactoryFamilySpi> entry : internalStoreFamilies.entrySet()) {
    final StoreFactoryFamilySpi factory=entry.getValue();
    final List<String> missingOptions=getMissingRequiredOptions(factory,configOptions);
    final List<String> matchingOptions=getMatchingRequiredOptions(factory,configOptions);
    final ConfigOption[] factoryOptions=ConfigUtils.createConfigOptionsFromJCommander(factory.getDataStoreFactory().createOptionsInstance());
    LOGGER.debug(""String_Node_Str"" + factoryOptions.length + ""String_Node_Str""+ factory.getType());
    if (missingOptions.isEmpty() && ((matchingFactory == null) || (matchingOptions.size() >= matchingFactoryRequiredOptionsCount))) {
      matchingFactory=factory;
      matchingFactoriesHaveSameRequiredOptionsCount=(matchingOptions.size() == matchingFactoryRequiredOptionsCount);
      matchingFactoryRequiredOptionsCount=matchingOptions.size();
    }
  }
  if (matchingFactory == null) {
    LOGGER.error(""String_Node_Str"");
  }
 else   if (matchingFactoriesHaveSameRequiredOptionsCount) {
    LOGGER.warn(""String_Node_Str"");
    LOGGER.warn(matchingFactory.getType() + ""String_Node_Str"");
  }
  return matchingFactory;
}","public static StoreFactoryFamilySpi findStoreFamily(final Map<String,String> configOptions){
  final Object storeHint=configOptions.get(STORE_HINT_KEY);
  final Map<String,StoreFactoryFamilySpi> internalStoreFamilies=getRegisteredStoreFactoryFamilies();
  if (storeHint != null) {
    final StoreFactoryFamilySpi factory=internalStoreFamilies.get(storeHint.toString());
    if (factory != null) {
      final List<String> missingOptions=getMissingRequiredOptions(factory,configOptions);
      if (missingOptions.isEmpty()) {
        return factory;
      }
      LOGGER.error(""String_Node_Str"" + storeHint.toString() + ""String_Node_Str""+ ConfigUtils.getOptions(missingOptions));
      return null;
    }
 else {
      LOGGER.error(""String_Node_Str"" + storeHint.toString() + ""String_Node_Str"");
      return null;
    }
  }
  for (  final Entry<String,StoreFactoryFamilySpi> entry : internalStoreFamilies.entrySet()) {
    if (exactMatch(entry.getValue(),configOptions)) {
      return entry.getValue();
    }
  }
  int matchingFactoryRequiredOptionsCount=-1;
  StoreFactoryFamilySpi matchingFactory=null;
  boolean matchingFactoriesHaveSameRequiredOptionsCount=false;
  LOGGER.debug(""String_Node_Str"" + internalStoreFamilies.size());
  for (  final Entry<String,StoreFactoryFamilySpi> entry : internalStoreFamilies.entrySet()) {
    final StoreFactoryFamilySpi factory=entry.getValue();
    final List<String> missingOptions=getMissingRequiredOptions(factory,configOptions);
    final List<String> matchingOptions=getMatchingRequiredOptions(factory,configOptions);
    if (missingOptions.isEmpty() && ((matchingFactory == null) || (matchingOptions.size() >= matchingFactoryRequiredOptionsCount))) {
      matchingFactory=factory;
      matchingFactoriesHaveSameRequiredOptionsCount=(matchingOptions.size() == matchingFactoryRequiredOptionsCount);
      matchingFactoryRequiredOptionsCount=matchingOptions.size();
    }
  }
  if (matchingFactory == null) {
    LOGGER.error(""String_Node_Str"");
  }
 else   if (matchingFactoriesHaveSameRequiredOptionsCount) {
    LOGGER.warn(""String_Node_Str"");
    LOGGER.warn(matchingFactory.getType() + ""String_Node_Str"");
  }
  return matchingFactory;
}",0.7411255411255411
112948,"private static List<String> getMissingRequiredOptions(final StoreFactoryFamilySpi factory,final Map<String,String> configOptions){
  final ConfigOption[] options=ConfigUtils.createConfigOptionsFromJCommander(factory.getDataStoreFactory().createOptionsInstance());
  final List<String> missing=new ArrayList<String>();
  for (  final ConfigOption option : options) {
    if (!option.isOptional() && !configOptions.containsKey(option.getName())) {
      missing.add(option.getName());
    }
  }
  return missing;
}","private static List<String> getMissingRequiredOptions(final StoreFactoryFamilySpi factory,final Map<String,String> configOptions){
  final ConfigOption[] options=ConfigUtils.createConfigOptionsFromJCommander(factory.getDataStoreFactory().createOptionsInstance(),false);
  final List<String> missing=new ArrayList<String>();
  for (  final ConfigOption option : options) {
    if (!option.isOptional() && !configOptions.containsKey(option.getName())) {
      missing.add(option.getName());
    }
  }
  return missing;
}",0.9941747572815534
112949,"public static synchronized ConfigOption[] getRequiredOptions(final StoreFactoryFamilySpi storeFactoryFamily){
  final List<ConfigOption> requiredOptions=new ArrayList<ConfigOption>();
  for (  final ConfigOption option : getAllOptions(storeFactoryFamily)) {
    if (!option.isOptional()) {
      requiredOptions.add(option);
    }
  }
  return requiredOptions.toArray(new ConfigOption[]{});
}","public static synchronized ConfigOption[] getRequiredOptions(final StoreFactoryFamilySpi storeFactoryFamily){
  final List<ConfigOption> requiredOptions=new ArrayList<ConfigOption>();
  for (  final ConfigOption option : getAllOptions(storeFactoryFamily,false)) {
    if (!option.isOptional()) {
      requiredOptions.add(option);
    }
  }
  return requiredOptions.toArray(new ConfigOption[]{});
}",0.9924050632911392
112950,"/** 
 * This method will use the parameter descriptions from JCommander to create/populate an AbstractConfigOptions map.
 */
public static ConfigOption[] createConfigOptionsFromJCommander(final Object createOptionsInstance){
  ConfigOption[] opts=null;
  if (createOptionsInstance != null) {
    final JCommanderPrefixTranslator translator=new JCommanderPrefixTranslator();
    translator.addObject(createOptionsInstance);
    final JCommanderTranslationMap map=translator.translate();
    final Collection<TranslationEntry> entries=map.getEntries().values();
    final List<ConfigOption> options=new ArrayList<ConfigOption>();
    for (    final TranslationEntry entry : entries) {
      if (!entry.isHidden()) {
        final ConfigOption opt=new ConfigOption(entry.getAsPropertyName(),entry.getDescription(),!entry.isRequired(),entry.getParam().getType());
        opt.setPassword(entry.isPassword());
        options.add(opt);
      }
    }
    opts=options.toArray(new ConfigOption[options.size()]);
  }
 else {
    opts=new ConfigOption[0];
  }
  return opts;
}","/** 
 * This method will use the parameter descriptions from JCommander to create/populate an AbstractConfigOptions map.
 */
public static ConfigOption[] createConfigOptionsFromJCommander(final Object createOptionsInstance,boolean includeHidden){
  ConfigOption[] opts=null;
  if (createOptionsInstance != null) {
    final JCommanderPrefixTranslator translator=new JCommanderPrefixTranslator();
    translator.addObject(createOptionsInstance);
    final JCommanderTranslationMap map=translator.translate();
    final Collection<TranslationEntry> entries=map.getEntries().values();
    final List<ConfigOption> options=new ArrayList<ConfigOption>();
    for (    final TranslationEntry entry : entries) {
      if (includeHidden || !entry.isHidden()) {
        final ConfigOption opt=new ConfigOption(entry.getAsPropertyName(),entry.getDescription(),!entry.isRequired(),entry.getParam().getType());
        opt.setPassword(entry.isPassword());
        options.add(opt);
      }
    }
    opts=options.toArray(new ConfigOption[options.size()]);
  }
 else {
    opts=new ConfigOption[0];
  }
  return opts;
}",0.9820524620340544
112951,"public synchronized static List<Param> getPluginParams(final StoreFactoryFamilySpi storeFactoryFamily){
  List<Param> params=paramMap.get(storeFactoryFamily.getType());
  if (params == null) {
    final ConfigOption[] configOptions=GeoWaveStoreFinder.getAllOptions(storeFactoryFamily);
    params=new ArrayList<Param>(Lists.transform(Lists.newArrayList(configOptions),new GeoWaveConfigOptionToGeoToolsConfigOption()));
    params.addAll(BASE_GEOWAVE_PLUGIN_PARAMS);
    paramMap.put(storeFactoryFamily.getType(),params);
  }
  return params;
}","public synchronized static List<Param> getPluginParams(final StoreFactoryFamilySpi storeFactoryFamily){
  List<Param> params=paramMap.get(storeFactoryFamily.getType());
  if (params == null) {
    final ConfigOption[] configOptions=GeoWaveStoreFinder.getAllOptions(storeFactoryFamily,false);
    params=new ArrayList<Param>(Lists.transform(Lists.newArrayList(configOptions),new GeoWaveConfigOptionToGeoToolsConfigOption()));
    params.addAll(BASE_GEOWAVE_PLUGIN_PARAMS);
    paramMap.put(storeFactoryFamily.getType(),params);
  }
  return params;
}",0.9945054945054944
112952,"@Test public void testServices() throws IOException, SchemaException {
  geoserverServiceClient=new GeoserverServiceClient(ServicesTestEnvironment.GEOWAVE_BASE_URL,ServicesTestEnvironment.GEOSERVER_USER,ServicesTestEnvironment.GEOSERVER_PASS);
  infoServiceClient=new InfoServiceClient(ServicesTestEnvironment.GEOWAVE_BASE_URL);
  ingestServiceClient=new IngestServiceClient(ServicesTestEnvironment.GEOWAVE_BASE_URL);
  boolean success=false;
  LOGGER.info(""String_Node_Str"");
  success=ingestServiceClient.localIngest(new File[]{new File(ASHLAND_GPX_FILE)},((TestDataStoreOptions)dataStoreOptions).getStoreType().name(),TestUtils.TEST_NAMESPACE,null,ASHLAND_INGEST_TYPE,null,false);
  assertTrue(""String_Node_Str"" + ASHLAND_GPX_FILE + ""String_Node_Str"",success);
  success=false;
  TestUtils.deleteAll(dataStoreOptions);
  LOGGER.info(""String_Node_Str"");
  success=ingestServiceClient.hdfsIngest(new File[]{new File(ASHLAND_GPX_FILE)},((TestDataStoreOptions)dataStoreOptions).getStoreType().name(),TestUtils.TEST_NAMESPACE,null,ASHLAND_INGEST_TYPE,null,false);
  assertTrue(""String_Node_Str"" + ASHLAND_GPX_FILE + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  final JSONArray adapters=infoServiceClient.getAdapters(((TestDataStoreOptions)dataStoreOptions).getStoreType().name()).getJSONArray(""String_Node_Str"");
  for (int i=0; i < adapters.size(); i++) {
    if (adapters.getJSONObject(i).getString(""String_Node_Str"").equals(GpxUtils.GPX_WAYPOINT_FEATURE)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + GpxUtils.GPX_WAYPOINT_FEATURE + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  final JSONArray indices=infoServiceClient.getIndices(((TestDataStoreOptions)dataStoreOptions).getStoreType().name()).getJSONArray(""String_Node_Str"");
  for (int i=0; i < indices.size(); i++) {
    if (indices.getJSONObject(i).getString(""String_Node_Str"").equals(TestUtils.DEFAULT_SPATIAL_INDEX.getId().getString())) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + TestUtils.DEFAULT_SPATIAL_INDEX.getId().getString() + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_WORKSPACE + ""String_Node_Str"",geoserverServiceClient.createWorkspace(ServicesTestEnvironment.TEST_WORKSPACE));
  LOGGER.info(""String_Node_Str"");
  final JSONArray workspaces=geoserverServiceClient.getWorkspaces().getJSONArray(""String_Node_Str"");
  for (int i=0; i < workspaces.size(); i++) {
    if (workspaces.getJSONObject(i).getString(""String_Node_Str"").equals(ServicesTestEnvironment.TEST_WORKSPACE)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_WORKSPACE + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE + ""String_Node_Str"",geoserverServiceClient.publishStyle(new File[]{new File(ServicesTestEnvironment.TEST_SLD_NO_DIFFERENCE_FILE)}));
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_MINOR_SUBSAMPLE + ""String_Node_Str"",geoserverServiceClient.publishStyle(new File[]{new File(ServicesTestEnvironment.TEST_SLD_MINOR_SUBSAMPLE_FILE)}));
  LOGGER.info(""String_Node_Str"");
  final JSONArray styles=geoserverServiceClient.getStyles().getJSONArray(""String_Node_Str"");
  for (int i=0; i < styles.size(); i++) {
    if (styles.getJSONObject(i).getString(""String_Node_Str"").equals(ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE + ""String_Node_Str"",success);
  success=false;
  for (int i=0; i < styles.size(); i++) {
    if (styles.getJSONObject(i).getString(""String_Node_Str"").equals(ServicesTestEnvironment.TEST_STYLE_NAME_MINOR_SUBSAMPLE)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_MINOR_SUBSAMPLE + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  final String style=IOUtils.toString(geoserverServiceClient.getStyle(ServicesTestEnvironment.TEST_SLD_NO_DIFFERENCE_FILE));
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE + ""String_Node_Str"",(style != null) && !style.isEmpty());
  LOGGER.info(""String_Node_Str"");
  assertTrue(""String_Node_Str"",geoserverServiceClient.publishDatastore(dataStoreOptions.getType(),dataStoreOptions.getOptionsAsMap(),TestUtils.TEST_NAMESPACE,null,null,null,null,ServicesTestEnvironment.TEST_WORKSPACE));
  LOGGER.info(""String_Node_Str"");
  final JSONArray datastores=geoserverServiceClient.getDatastores(ServicesTestEnvironment.TEST_WORKSPACE).getJSONArray(""String_Node_Str"");
  JSONObject dsInfo=null;
  for (int i=0; i < datastores.size(); i++) {
    if (datastores.getJSONObject(i).getString(""String_Node_Str"").equals(TestUtils.TEST_NAMESPACE)) {
      dsInfo=datastores.getJSONObject(i);
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"",success);
  success=false;
  if (dsInfo != null) {
    final Map<String,String> options=dataStoreOptions.getOptionsAsMap();
    final List<ConfigOption> configOptions=Arrays.asList(ConfigUtils.createConfigOptionsFromJCommander(dataStoreOptions));
    final Collection<String> nonPasswordRequiredFields=Collections2.transform(Collections2.filter(configOptions,new Predicate<ConfigOption>(){
      @Override public boolean apply(      final ConfigOption input){
        return !input.isPassword() && !input.isOptional();
      }
    }
),new Function<ConfigOption,String>(){
      @Override public String apply(      final ConfigOption input){
        return input.getName();
      }
    }
);
    for (    final Entry<String,String> entry : options.entrySet()) {
      if (nonPasswordRequiredFields.contains(entry.getKey())) {
        assertTrue(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"",dsInfo.getString(entry.getKey()).equals(entry.getValue()));
      }
    }
  }
  LOGGER.info(""String_Node_Str"");
  final JSONObject datastore=geoserverServiceClient.getDatastore(TestUtils.TEST_NAMESPACE,ServicesTestEnvironment.TEST_WORKSPACE);
  assertTrue(""String_Node_Str"",datastore.getJSONObject(""String_Node_Str"").getString(""String_Node_Str"").equals(TestUtils.TEST_NAMESPACE));
  LOGGER.info(""String_Node_Str"");
  assertTrue(""String_Node_Str"" + GpxUtils.GPX_WAYPOINT_FEATURE + ""String_Node_Str"",geoserverServiceClient.publishLayer(TestUtils.TEST_NAMESPACE,ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE,GpxUtils.GPX_WAYPOINT_FEATURE,ServicesTestEnvironment.TEST_WORKSPACE));
  LOGGER.info(""String_Node_Str"");
  final JSONArray layers=geoserverServiceClient.getLayers().getJSONArray(""String_Node_Str"").getJSONObject(0).getJSONArray(""String_Node_Str"");
  for (int i=0; i < layers.size(); i++) {
    if (layers.getJSONObject(i).getString(""String_Node_Str"").equals(GpxUtils.GPX_WAYPOINT_FEATURE)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + GpxUtils.GPX_WAYPOINT_FEATURE + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  final JSONObject layer=geoserverServiceClient.getLayer(GpxUtils.GPX_WAYPOINT_FEATURE);
  assertTrue(""String_Node_Str"",layer.getJSONObject(""String_Node_Str"").getString(""String_Node_Str"").equals(GpxUtils.GPX_WAYPOINT_FEATURE));
  LOGGER.info(""String_Node_Str"");
  assertTrue(""String_Node_Str"" + GpxUtils.GPX_WAYPOINT_FEATURE + ""String_Node_Str"",geoserverServiceClient.deleteLayer(GpxUtils.GPX_WAYPOINT_FEATURE));
  assertTrue(""String_Node_Str"",geoserverServiceClient.deleteDatastore(TestUtils.TEST_NAMESPACE,ServicesTestEnvironment.TEST_WORKSPACE));
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE + ""String_Node_Str"",geoserverServiceClient.deleteStyle(ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE));
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_MINOR_SUBSAMPLE + ""String_Node_Str"",geoserverServiceClient.deleteStyle(ServicesTestEnvironment.TEST_STYLE_NAME_MINOR_SUBSAMPLE));
  assertTrue(""String_Node_Str"",geoserverServiceClient.deleteWorkspace(ServicesTestEnvironment.TEST_WORKSPACE));
}","@Test public void testServices() throws IOException, SchemaException {
  geoserverServiceClient=new GeoserverServiceClient(ServicesTestEnvironment.GEOWAVE_BASE_URL,ServicesTestEnvironment.GEOSERVER_USER,ServicesTestEnvironment.GEOSERVER_PASS);
  infoServiceClient=new InfoServiceClient(ServicesTestEnvironment.GEOWAVE_BASE_URL);
  ingestServiceClient=new IngestServiceClient(ServicesTestEnvironment.GEOWAVE_BASE_URL);
  boolean success=false;
  LOGGER.info(""String_Node_Str"");
  success=ingestServiceClient.localIngest(new File[]{new File(ASHLAND_GPX_FILE)},((TestDataStoreOptions)dataStoreOptions).getStoreType().name(),TestUtils.TEST_NAMESPACE,null,ASHLAND_INGEST_TYPE,null,false);
  assertTrue(""String_Node_Str"" + ASHLAND_GPX_FILE + ""String_Node_Str"",success);
  success=false;
  TestUtils.deleteAll(dataStoreOptions);
  LOGGER.info(""String_Node_Str"");
  success=ingestServiceClient.hdfsIngest(new File[]{new File(ASHLAND_GPX_FILE)},((TestDataStoreOptions)dataStoreOptions).getStoreType().name(),TestUtils.TEST_NAMESPACE,null,ASHLAND_INGEST_TYPE,null,false);
  assertTrue(""String_Node_Str"" + ASHLAND_GPX_FILE + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  final JSONArray adapters=infoServiceClient.getAdapters(((TestDataStoreOptions)dataStoreOptions).getStoreType().name()).getJSONArray(""String_Node_Str"");
  for (int i=0; i < adapters.size(); i++) {
    if (adapters.getJSONObject(i).getString(""String_Node_Str"").equals(GpxUtils.GPX_WAYPOINT_FEATURE)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + GpxUtils.GPX_WAYPOINT_FEATURE + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  final JSONArray indices=infoServiceClient.getIndices(((TestDataStoreOptions)dataStoreOptions).getStoreType().name()).getJSONArray(""String_Node_Str"");
  for (int i=0; i < indices.size(); i++) {
    if (indices.getJSONObject(i).getString(""String_Node_Str"").equals(TestUtils.DEFAULT_SPATIAL_INDEX.getId().getString())) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + TestUtils.DEFAULT_SPATIAL_INDEX.getId().getString() + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_WORKSPACE + ""String_Node_Str"",geoserverServiceClient.createWorkspace(ServicesTestEnvironment.TEST_WORKSPACE));
  LOGGER.info(""String_Node_Str"");
  final JSONArray workspaces=geoserverServiceClient.getWorkspaces().getJSONArray(""String_Node_Str"");
  for (int i=0; i < workspaces.size(); i++) {
    if (workspaces.getJSONObject(i).getString(""String_Node_Str"").equals(ServicesTestEnvironment.TEST_WORKSPACE)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_WORKSPACE + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE + ""String_Node_Str"",geoserverServiceClient.publishStyle(new File[]{new File(ServicesTestEnvironment.TEST_SLD_NO_DIFFERENCE_FILE)}));
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_MINOR_SUBSAMPLE + ""String_Node_Str"",geoserverServiceClient.publishStyle(new File[]{new File(ServicesTestEnvironment.TEST_SLD_MINOR_SUBSAMPLE_FILE)}));
  LOGGER.info(""String_Node_Str"");
  final JSONArray styles=geoserverServiceClient.getStyles().getJSONArray(""String_Node_Str"");
  for (int i=0; i < styles.size(); i++) {
    if (styles.getJSONObject(i).getString(""String_Node_Str"").equals(ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE + ""String_Node_Str"",success);
  success=false;
  for (int i=0; i < styles.size(); i++) {
    if (styles.getJSONObject(i).getString(""String_Node_Str"").equals(ServicesTestEnvironment.TEST_STYLE_NAME_MINOR_SUBSAMPLE)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_MINOR_SUBSAMPLE + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  final String style=IOUtils.toString(geoserverServiceClient.getStyle(ServicesTestEnvironment.TEST_SLD_NO_DIFFERENCE_FILE));
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE + ""String_Node_Str"",(style != null) && !style.isEmpty());
  LOGGER.info(""String_Node_Str"");
  assertTrue(""String_Node_Str"",geoserverServiceClient.publishDatastore(dataStoreOptions.getType(),dataStoreOptions.getOptionsAsMap(),TestUtils.TEST_NAMESPACE,null,null,null,null,ServicesTestEnvironment.TEST_WORKSPACE));
  LOGGER.info(""String_Node_Str"");
  final JSONArray datastores=geoserverServiceClient.getDatastores(ServicesTestEnvironment.TEST_WORKSPACE).getJSONArray(""String_Node_Str"");
  JSONObject dsInfo=null;
  for (int i=0; i < datastores.size(); i++) {
    if (datastores.getJSONObject(i).getString(""String_Node_Str"").equals(TestUtils.TEST_NAMESPACE)) {
      dsInfo=datastores.getJSONObject(i);
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"",success);
  success=false;
  if (dsInfo != null) {
    final Map<String,String> options=dataStoreOptions.getOptionsAsMap();
    final List<ConfigOption> configOptions=Arrays.asList(ConfigUtils.createConfigOptionsFromJCommander(dataStoreOptions,false));
    final Collection<String> nonPasswordRequiredFields=Collections2.transform(Collections2.filter(configOptions,new Predicate<ConfigOption>(){
      @Override public boolean apply(      final ConfigOption input){
        return !input.isPassword() && !input.isOptional();
      }
    }
),new Function<ConfigOption,String>(){
      @Override public String apply(      final ConfigOption input){
        return input.getName();
      }
    }
);
    for (    final Entry<String,String> entry : options.entrySet()) {
      if (nonPasswordRequiredFields.contains(entry.getKey())) {
        assertTrue(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"",dsInfo.getString(entry.getKey()).equals(entry.getValue()));
      }
    }
  }
  LOGGER.info(""String_Node_Str"");
  final JSONObject datastore=geoserverServiceClient.getDatastore(TestUtils.TEST_NAMESPACE,ServicesTestEnvironment.TEST_WORKSPACE);
  assertTrue(""String_Node_Str"",datastore.getJSONObject(""String_Node_Str"").getString(""String_Node_Str"").equals(TestUtils.TEST_NAMESPACE));
  LOGGER.info(""String_Node_Str"");
  assertTrue(""String_Node_Str"" + GpxUtils.GPX_WAYPOINT_FEATURE + ""String_Node_Str"",geoserverServiceClient.publishLayer(TestUtils.TEST_NAMESPACE,ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE,GpxUtils.GPX_WAYPOINT_FEATURE,ServicesTestEnvironment.TEST_WORKSPACE));
  LOGGER.info(""String_Node_Str"");
  final JSONArray layers=geoserverServiceClient.getLayers().getJSONArray(""String_Node_Str"").getJSONObject(0).getJSONArray(""String_Node_Str"");
  for (int i=0; i < layers.size(); i++) {
    if (layers.getJSONObject(i).getString(""String_Node_Str"").equals(GpxUtils.GPX_WAYPOINT_FEATURE)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + GpxUtils.GPX_WAYPOINT_FEATURE + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  final JSONObject layer=geoserverServiceClient.getLayer(GpxUtils.GPX_WAYPOINT_FEATURE);
  assertTrue(""String_Node_Str"",layer.getJSONObject(""String_Node_Str"").getString(""String_Node_Str"").equals(GpxUtils.GPX_WAYPOINT_FEATURE));
  LOGGER.info(""String_Node_Str"");
  assertTrue(""String_Node_Str"" + GpxUtils.GPX_WAYPOINT_FEATURE + ""String_Node_Str"",geoserverServiceClient.deleteLayer(GpxUtils.GPX_WAYPOINT_FEATURE));
  assertTrue(""String_Node_Str"",geoserverServiceClient.deleteDatastore(TestUtils.TEST_NAMESPACE,ServicesTestEnvironment.TEST_WORKSPACE));
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE + ""String_Node_Str"",geoserverServiceClient.deleteStyle(ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE));
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_MINOR_SUBSAMPLE + ""String_Node_Str"",geoserverServiceClient.deleteStyle(ServicesTestEnvironment.TEST_STYLE_NAME_MINOR_SUBSAMPLE));
  assertTrue(""String_Node_Str"",geoserverServiceClient.deleteWorkspace(ServicesTestEnvironment.TEST_WORKSPACE));
}",0.999639379733141
112953,"protected static boolean isAuthorized(final byte[] visibility,final String[] authorizations){
  if ((visibility == null) || (visibility.length == 0)) {
    return true;
  }
  VisibilityExpression expr;
  try {
    expr=new VisibilityExpressionParser().parse(visibility);
  }
 catch (  final IOException e) {
    LOGGER.error(""String_Node_Str"" + Arrays.toString(visibility),e);
    return false;
  }
  return expr.ok(authorizations);
}","protected static boolean isAuthorized(final byte[] visibility,final String[] authorizations){
  if ((visibility == null) || (visibility.length == 0)) {
    return true;
  }
  VisibilityExpression expr;
  try {
    expr=new VisibilityExpressionParser().parse(visibility);
  }
 catch (  final IOException e) {
    LOGGER.error(""String_Node_Str"",e);
    return false;
  }
  return expr.ok(authorizations);
}",0.8210023866348448
112954,"private String createCoverageXml(Map<String,String> geowaveStoreConfig,Boolean equalizeHistogramOverride,String interpolationOverride,Boolean scaleTo8Bit){
  String coverageXml=null;
  String workspace=geowaveStoreConfig.get(GeoServerConfig.GEOSERVER_WORKSPACE);
  String cvgstoreName=geowaveStoreConfig.get(GeoServerConfig.GEOSERVER_CS);
  try {
    DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
    factory.setFeature(""String_Node_Str"",false);
    factory.setFeature(""String_Node_Str"",false);
    Document xmlDoc=factory.newDocumentBuilder().newDocument();
    Element rootEl=xmlDoc.createElement(""String_Node_Str"");
    xmlDoc.appendChild(rootEl);
    Element nameEl=xmlDoc.createElement(""String_Node_Str"");
    nameEl.appendChild(xmlDoc.createTextNode(cvgstoreName));
    rootEl.appendChild(nameEl);
    Element wsEl=xmlDoc.createElement(""String_Node_Str"");
    wsEl.appendChild(xmlDoc.createTextNode(workspace));
    rootEl.appendChild(wsEl);
    Element typeEl=xmlDoc.createElement(""String_Node_Str"");
    typeEl.appendChild(xmlDoc.createTextNode(""String_Node_Str""));
    rootEl.appendChild(typeEl);
    Element enabledEl=xmlDoc.createElement(""String_Node_Str"");
    enabledEl.appendChild(xmlDoc.createTextNode(""String_Node_Str""));
    rootEl.appendChild(enabledEl);
    Element configEl=xmlDoc.createElement(""String_Node_Str"");
    configEl.appendChild(xmlDoc.createTextNode(""String_Node_Str""));
    rootEl.appendChild(configEl);
    String storeConfigUrl=createParamUrl(geowaveStoreConfig,equalizeHistogramOverride,interpolationOverride,scaleTo8Bit);
    Element urlEl=xmlDoc.createElement(""String_Node_Str"");
    urlEl.appendChild(xmlDoc.createTextNode(storeConfigUrl));
    rootEl.appendChild(urlEl);
    TransformerFactory xformerFactory=TransformerFactory.newInstance();
    xformerFactory.setFeature(""String_Node_Str"",false);
    xformerFactory.setFeature(""String_Node_Str"",false);
    xformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD,""String_Node_Str"");
    xformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET,""String_Node_Str"");
    Transformer xformer=xformerFactory.newTransformer();
    DOMSource source=new DOMSource(xmlDoc);
    StreamResult result=new StreamResult(new StringWriter());
    xformer.transform(source,result);
    coverageXml=result.getWriter().toString();
  }
 catch (  TransformerException e) {
    LOGGER.error(""String_Node_Str"",e);
  }
catch (  ParserConfigurationException e1) {
    LOGGER.error(""String_Node_Str"",e1);
  }
  return coverageXml;
}","private String createCoverageXml(Map<String,String> geowaveStoreConfig,Boolean equalizeHistogramOverride,String interpolationOverride,Boolean scaleTo8Bit){
  String coverageXml=null;
  String workspace=geowaveStoreConfig.get(GeoServerConfig.GEOSERVER_WORKSPACE);
  String cvgstoreName=geowaveStoreConfig.get(GeoServerConfig.GEOSERVER_CS);
  StreamResult result=null;
  try {
    DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
    factory.setFeature(""String_Node_Str"",false);
    factory.setFeature(""String_Node_Str"",false);
    Document xmlDoc=factory.newDocumentBuilder().newDocument();
    Element rootEl=xmlDoc.createElement(""String_Node_Str"");
    xmlDoc.appendChild(rootEl);
    Element nameEl=xmlDoc.createElement(""String_Node_Str"");
    nameEl.appendChild(xmlDoc.createTextNode(cvgstoreName));
    rootEl.appendChild(nameEl);
    Element wsEl=xmlDoc.createElement(""String_Node_Str"");
    wsEl.appendChild(xmlDoc.createTextNode(workspace));
    rootEl.appendChild(wsEl);
    Element typeEl=xmlDoc.createElement(""String_Node_Str"");
    typeEl.appendChild(xmlDoc.createTextNode(""String_Node_Str""));
    rootEl.appendChild(typeEl);
    Element enabledEl=xmlDoc.createElement(""String_Node_Str"");
    enabledEl.appendChild(xmlDoc.createTextNode(""String_Node_Str""));
    rootEl.appendChild(enabledEl);
    Element configEl=xmlDoc.createElement(""String_Node_Str"");
    configEl.appendChild(xmlDoc.createTextNode(""String_Node_Str""));
    rootEl.appendChild(configEl);
    String storeConfigUrl=createParamUrl(geowaveStoreConfig,equalizeHistogramOverride,interpolationOverride,scaleTo8Bit);
    Element urlEl=xmlDoc.createElement(""String_Node_Str"");
    urlEl.appendChild(xmlDoc.createTextNode(storeConfigUrl));
    rootEl.appendChild(urlEl);
    TransformerFactory xformerFactory=TransformerFactory.newInstance();
    xformerFactory.setFeature(""String_Node_Str"",false);
    xformerFactory.setFeature(""String_Node_Str"",false);
    xformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD,""String_Node_Str"");
    xformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET,""String_Node_Str"");
    Transformer xformer=xformerFactory.newTransformer();
    DOMSource source=new DOMSource(xmlDoc);
    result=new StreamResult(new StringWriter());
    xformer.transform(source,result);
    coverageXml=result.getWriter().toString();
  }
 catch (  TransformerException e) {
    LOGGER.error(""String_Node_Str"",e);
  }
catch (  ParserConfigurationException e1) {
    LOGGER.error(""String_Node_Str"",e1);
  }
 finally {
    if (result != null && result.getWriter() != null) {
      try {
        result.getWriter().close();
      }
 catch (      IOException e) {
        LOGGER.error(e);
      }
    }
  }
  return coverageXml;
}",0.9549754067347712
112955,"private static String setupPathingJarClassPath(final File dir,final Class context) throws IOException {
  final String classpath=getClasspath(context);
  final File jarDir=new File(dir.getParentFile().getAbsolutePath() + File.separator + ""String_Node_Str"");
  if (!jarDir.exists()) {
    try {
      jarDir.mkdirs();
    }
 catch (    final Exception e) {
      LOGGER.error(""String_Node_Str"" + e);
      return null;
    }
  }
  final File jarFile=new File(jarDir,""String_Node_Str"");
  if (jarFile.exists()) {
    try {
      jarFile.delete();
    }
 catch (    final Exception e) {
      LOGGER.error(""String_Node_Str"" + e);
      return null;
    }
  }
  final Manifest manifest=new Manifest();
  manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION,""String_Node_Str"");
  manifest.getMainAttributes().put(Attributes.Name.CLASS_PATH,classpath);
  final JarOutputStream target=new JarOutputStream(new FileOutputStream(jarFile),manifest);
  target.close();
  return jarFile.getAbsolutePath();
}","private static String setupPathingJarClassPath(final File dir,final Class context) throws IOException {
  final String classpath=getClasspath(context);
  final File jarDir=new File(dir.getParentFile().getAbsolutePath() + File.separator + ""String_Node_Str"");
  if (!jarDir.exists()) {
    try {
      jarDir.mkdirs();
    }
 catch (    final Exception e) {
      LOGGER.error(""String_Node_Str"" + e);
      return null;
    }
  }
  final File jarFile=new File(jarDir,""String_Node_Str"");
  if (jarFile.exists()) {
    try {
      jarFile.delete();
    }
 catch (    final Exception e) {
      LOGGER.error(""String_Node_Str"" + e);
      return null;
    }
  }
  final Manifest manifest=new Manifest();
  manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION,""String_Node_Str"");
  manifest.getMainAttributes().put(Attributes.Name.CLASS_PATH,classpath);
  try (final JarOutputStream target=new JarOutputStream(new FileOutputStream(jarFile),manifest)){
    target.close();
  }
   return jarFile.getAbsolutePath();
}",0.9738529847064628
112956,"private synchronized DataStore getSingletonInstance(){
  if (dataStore != null) {
    return dataStore;
  }
  String confPropFilename=context.getInitParameter(""String_Node_Str"");
  LOGGER.info(""String_Node_Str"" + confPropFilename);
  InputStream is=context.getResourceAsStream(confPropFilename);
  final Properties props=ServiceUtils.loadProperties(is);
  LOGGER.info(""String_Node_Str"" + props.size() + ""String_Node_Str"");
  final Map<String,String> strMap=new HashMap<String,String>();
  final Set<Object> keySet=props.keySet();
  final Iterator<Object> it=keySet.iterator();
  while (it.hasNext()) {
    final String key=it.next().toString();
    final String value=ServiceUtils.getProperty(props,key);
    strMap.put(key,value);
    LOGGER.info(""String_Node_Str"" + key + ""String_Node_Str""+ value);
  }
  GeoWaveStoreFinder.getRegisteredStoreFactoryFamilies();
  dataStore=GeoWaveStoreFinder.createDataStore(strMap);
  if (dataStore == null) {
    LOGGER.error(""String_Node_Str"");
  }
  return dataStore;
}","private synchronized DataStore getSingletonInstance(){
  if (dataStore != null) {
    return dataStore;
  }
  String confPropFilename=context.getInitParameter(""String_Node_Str"");
  LOGGER.info(""String_Node_Str"" + confPropFilename);
  Properties props=null;
  try (InputStream is=context.getResourceAsStream(confPropFilename)){
    props=ServiceUtils.loadProperties(is);
  }
 catch (  IOException e) {
    LOGGER.error(e);
  }
  LOGGER.info(""String_Node_Str"" + props.size() + ""String_Node_Str"");
  final Map<String,String> strMap=new HashMap<String,String>();
  final Set<Object> keySet=props.keySet();
  final Iterator<Object> it=keySet.iterator();
  while (it.hasNext()) {
    final String key=it.next().toString();
    final String value=ServiceUtils.getProperty(props,key);
    strMap.put(key,value);
    LOGGER.info(""String_Node_Str"" + key + ""String_Node_Str""+ value);
  }
  GeoWaveStoreFinder.getRegisteredStoreFactoryFamilies();
  dataStore=GeoWaveStoreFinder.createDataStore(strMap);
  if (dataStore == null) {
    LOGGER.error(""String_Node_Str"");
  }
  return dataStore;
}",0.9185823754789272
112957,"private static StrippedGeometry stripGeometry(final MultiDimensionalNumericData query,final NumericDimensionField<?>[] dimensionDefinitions){
  final Set<ByteArrayId> geometryFieldIds=new HashSet<ByteArrayId>();
  final List<NumericData> numericDataPerDimension=new ArrayList<NumericData>();
  final List<NumericDimensionField<?>> fields=new ArrayList<NumericDimensionField<?>>();
  final NumericData[] data=query.getDataPerDimension();
  for (int d=0; d < dimensionDefinitions.length; d++) {
    if (isSpatial(dimensionDefinitions[d])) {
      geometryFieldIds.add(dimensionDefinitions[d].getFieldId());
    }
 else {
      numericDataPerDimension.add(data[d]);
      fields.add(dimensionDefinitions[d]);
    }
  }
  return new StrippedGeometry(new BasicNumericDataset(numericDataPerDimension.toArray(new NumericData[numericDataPerDimension.size()])),fields.toArray(new NumericDimensionField<?>[fields.size()]),geometryFieldIds);
}","private static StrippedGeometry stripGeometry(final MultiDimensionalNumericData query,final NumericDimensionField<?>[] orderedConstrainedDimensionDefinitions,final NumericDimensionField<?>[] unconstrainedDimensionDefinitions){
  final Set<ByteArrayId> geometryFieldIds=new HashSet<ByteArrayId>();
  final List<NumericData> numericDataPerDimension=new ArrayList<NumericData>();
  final List<NumericDimensionField<?>> fields=new ArrayList<NumericDimensionField<?>>();
  final NumericData[] data=query.getDataPerDimension();
  for (int d=0; d < orderedConstrainedDimensionDefinitions.length; d++) {
    if (isSpatial(orderedConstrainedDimensionDefinitions[d])) {
      geometryFieldIds.add(orderedConstrainedDimensionDefinitions[d].getFieldId());
    }
 else {
      numericDataPerDimension.add(data[d]);
      fields.add(orderedConstrainedDimensionDefinitions[d]);
    }
  }
  for (int d=0; d < unconstrainedDimensionDefinitions.length; d++) {
    if (isSpatial(unconstrainedDimensionDefinitions[d])) {
      geometryFieldIds.add(unconstrainedDimensionDefinitions[d].getFieldId());
    }
  }
  return new StrippedGeometry(new BasicNumericDataset(numericDataPerDimension.toArray(new NumericData[numericDataPerDimension.size()])),fields.toArray(new NumericDimensionField<?>[fields.size()]),geometryFieldIds);
}",0.8284182305630027
112958,"@Override protected DistributableQueryFilter createQueryFilter(final MultiDimensionalNumericData constraints,final NumericDimensionField<?>[] dimensionFields){
  return new SpatialQueryFilter(constraints,dimensionFields,queryGeometry,compareOp);
}","@Override protected DistributableQueryFilter createQueryFilter(final MultiDimensionalNumericData constraints,final NumericDimensionField<?>[] orderedConstrainedDimensionFields,final NumericDimensionField<?>[] unconstrainedDimensionDefinitions){
  return new SpatialQueryFilter(constraints,orderedConstrainedDimensionFields,unconstrainedDimensionDefinitions,queryGeometry,compareOp);
}",0.694136291600634
112959,"@Test public void testPredefinedSpatialEntries() throws Exception {
  final NumericIndexStrategy strategy=new SpatialDimensionalityTypeProvider().createPrimaryIndex().getIndexStrategy();
  for (int sfcIndex=0; sfcIndex < DEFINED_BITS_OF_PRECISION.length; sfcIndex++) {
    final NumericData[] dataPerDimension=new NumericData[2];
    final double precision=360 / Math.pow(2,DEFINED_BITS_OF_PRECISION[sfcIndex]);
    if (precision > 180) {
      dataPerDimension[0]=new NumericRange(-180,180);
      dataPerDimension[1]=new NumericRange(-90,90);
    }
 else {
      dataPerDimension[0]=new NumericRange(0,precision);
      dataPerDimension[1]=new NumericRange(-precision,0);
    }
    final MultiDimensionalNumericData indexedData=new BasicNumericDataset(dataPerDimension);
    final List<ByteArrayId> ids=strategy.getInsertionIds(indexedData);
    final NumericData[] queryRangePerDimension=new NumericData[2];
    queryRangePerDimension[0]=new NumericRange(dataPerDimension[0].getMin() + QUERY_RANGE_EPSILON,dataPerDimension[0].getMax() - QUERY_RANGE_EPSILON);
    queryRangePerDimension[1]=new NumericRange(dataPerDimension[1].getMin() + QUERY_RANGE_EPSILON,dataPerDimension[1].getMax() - QUERY_RANGE_EPSILON);
    final MultiDimensionalNumericData queryData=new BasicNumericDataset(queryRangePerDimension);
    final List<ByteArrayRange> queryRanges=strategy.getQueryRanges(queryData);
    final Set<Byte> queryRangeTiers=new HashSet<Byte>();
    boolean rangeAtTierFound=false;
    for (    final ByteArrayRange range : queryRanges) {
      final byte tier=range.getStart().getBytes()[0];
      queryRangeTiers.add(range.getStart().getBytes()[0]);
      if (tier == DEFINED_BITS_OF_PRECISION[sfcIndex]) {
        if (rangeAtTierFound) {
          throw new Exception(""String_Node_Str"" + tier);
        }
        assertEquals(""String_Node_Str"" + DEFINED_BITS_OF_PRECISION[sfcIndex],range.getStart(),range.getEnd());
        rangeAtTierFound=true;
      }
    }
    if (!rangeAtTierFound) {
      throw new Exception(""String_Node_Str"" + DEFINED_BITS_OF_PRECISION[sfcIndex]);
    }
    if ((ids.get(0).getBytes()[0] == 0) || ((sfcIndex == (DEFINED_BITS_OF_PRECISION.length - 1)) || (DEFINED_BITS_OF_PRECISION[sfcIndex + 1] != (DEFINED_BITS_OF_PRECISION[sfcIndex] + 1)))) {
      assertEquals(""String_Node_Str"" + DEFINED_BITS_OF_PRECISION[sfcIndex],DEFINED_BITS_OF_PRECISION[sfcIndex],ids.get(0).getBytes()[0]);
      assertEquals(""String_Node_Str"" + DEFINED_BITS_OF_PRECISION[sfcIndex],1,ids.size());
    }
 else {
      assertEquals(""String_Node_Str"" + DEFINED_BITS_OF_PRECISION[sfcIndex + 1],DEFINED_BITS_OF_PRECISION[sfcIndex + 1],ids.get(0).getBytes()[0]);
      final int expectedIds=(precision > 90) && (precision <= 180) ? 2 : 4;
      assertEquals(""String_Node_Str"" + expectedIds + ""String_Node_Str""+ DEFINED_BITS_OF_PRECISION[sfcIndex + 1],expectedIds,ids.size());
    }
  }
}","@Test public void testPredefinedSpatialEntries() throws Exception {
  final NumericIndexStrategy strategy=TieredSFCIndexFactory.createDefinedPrecisionTieredStrategy(new NumericDimensionDefinition[]{new LongitudeDefinition(),new LatitudeDefinition(true)},new int[][]{DEFINED_BITS_OF_PRECISION.clone(),DEFINED_BITS_OF_PRECISION.clone()},SFCType.HILBERT);
  for (int sfcIndex=0; sfcIndex < DEFINED_BITS_OF_PRECISION.length; sfcIndex++) {
    final NumericData[] dataPerDimension=new NumericData[2];
    final double precision=360 / Math.pow(2,DEFINED_BITS_OF_PRECISION[sfcIndex]);
    if (precision > 180) {
      dataPerDimension[0]=new NumericRange(-180,180);
      dataPerDimension[1]=new NumericRange(-90,90);
    }
 else {
      dataPerDimension[0]=new NumericRange(0,precision);
      dataPerDimension[1]=new NumericRange(-precision,0);
    }
    final MultiDimensionalNumericData indexedData=new BasicNumericDataset(dataPerDimension);
    final List<ByteArrayId> ids=strategy.getInsertionIds(indexedData);
    final NumericData[] queryRangePerDimension=new NumericData[2];
    queryRangePerDimension[0]=new NumericRange(dataPerDimension[0].getMin() + QUERY_RANGE_EPSILON,dataPerDimension[0].getMax() - QUERY_RANGE_EPSILON);
    queryRangePerDimension[1]=new NumericRange(dataPerDimension[1].getMin() + QUERY_RANGE_EPSILON,dataPerDimension[1].getMax() - QUERY_RANGE_EPSILON);
    final MultiDimensionalNumericData queryData=new BasicNumericDataset(queryRangePerDimension);
    final List<ByteArrayRange> queryRanges=strategy.getQueryRanges(queryData);
    final Set<Byte> queryRangeTiers=new HashSet<Byte>();
    boolean rangeAtTierFound=false;
    for (    final ByteArrayRange range : queryRanges) {
      final byte tier=range.getStart().getBytes()[0];
      queryRangeTiers.add(range.getStart().getBytes()[0]);
      if (tier == DEFINED_BITS_OF_PRECISION[sfcIndex]) {
        if (rangeAtTierFound) {
          throw new Exception(""String_Node_Str"" + tier);
        }
        assertEquals(""String_Node_Str"" + DEFINED_BITS_OF_PRECISION[sfcIndex],range.getStart(),range.getEnd());
        rangeAtTierFound=true;
      }
    }
    if (!rangeAtTierFound) {
      throw new Exception(""String_Node_Str"" + DEFINED_BITS_OF_PRECISION[sfcIndex]);
    }
    if ((ids.get(0).getBytes()[0] == 0) || ((sfcIndex == (DEFINED_BITS_OF_PRECISION.length - 1)) || (DEFINED_BITS_OF_PRECISION[sfcIndex + 1] != (DEFINED_BITS_OF_PRECISION[sfcIndex] + 1)))) {
      assertEquals(""String_Node_Str"" + DEFINED_BITS_OF_PRECISION[sfcIndex],DEFINED_BITS_OF_PRECISION[sfcIndex],ids.get(0).getBytes()[0]);
      assertEquals(""String_Node_Str"" + DEFINED_BITS_OF_PRECISION[sfcIndex],1,ids.size());
    }
 else {
      assertEquals(""String_Node_Str"" + DEFINED_BITS_OF_PRECISION[sfcIndex + 1],DEFINED_BITS_OF_PRECISION[sfcIndex + 1],ids.get(0).getBytes()[0]);
      final int expectedIds=(precision > 90) && (precision <= 180) ? 2 : 4;
      assertEquals(""String_Node_Str"" + expectedIds + ""String_Node_Str""+ DEFINED_BITS_OF_PRECISION[sfcIndex + 1],expectedIds,ids.size());
    }
  }
}",0.9477938699898956
112960,"protected boolean overlaps(final NumericData[] insertTileRange,final PrimaryIndex index){
  @SuppressWarnings(""String_Node_Str"") final NumericDimensionDefinition[] dimensions=index.getIndexStrategy().getOrderedDimensionDefinitions();
  final NumericDimensionField[] fields=index.getIndexModel().getDimensions();
  Map<Class,NumericDimensionField> dimensionTypeToFieldMap=new HashMap<>();
  for (  NumericDimensionField field : fields) {
    dimensionTypeToFieldMap.put(field.getBaseDefinition().getClass(),field);
  }
  final Map<ByteArrayId,DimensionRangePair> fieldsRangeData=new HashMap<ByteArrayId,DimensionRangePair>(dimensions.length);
  for (int d=0; d < dimensions.length; d++) {
    NumericDimensionField field=dimensionTypeToFieldMap.get(dimensions[d].getClass());
    if (field != null) {
      final ByteArrayId fieldId=field.getFieldId();
      final DimensionRangePair fieldData=fieldsRangeData.get(fieldId);
      if (fieldData == null) {
        fieldsRangeData.put(fieldId,new DimensionRangePair(field,insertTileRange[d]));
      }
 else {
        fieldData.add(field,insertTileRange[d]);
      }
    }
  }
  for (  final Entry<ByteArrayId,DimensionRangePair> entry : fieldsRangeData.entrySet()) {
    PersistentDataset<CommonIndexValue> commonData=getCommonData();
    if (commonData != null) {
      CommonIndexValue value=commonData.getValue(entry.getKey());
      if (value != null && !value.overlaps(entry.getValue().dimensions,entry.getValue().dataPerDimension)) {
        return false;
      }
    }
  }
  return true;
}","protected boolean overlaps(final NumericData[] insertTileRange,final PrimaryIndex index){
  @SuppressWarnings(""String_Node_Str"") final NumericDimensionDefinition[] dimensions=index.getIndexStrategy().getOrderedDimensionDefinitions();
  final NumericDimensionField[] fields=index.getIndexModel().getDimensions();
  Map<Class,NumericDimensionField> dimensionTypeToFieldMap=new HashMap<>();
  for (  NumericDimensionField field : fields) {
    dimensionTypeToFieldMap.put(field.getBaseDefinition().getClass(),field);
  }
  final Map<ByteArrayId,DimensionRangePair> fieldsRangeData=new HashMap<ByteArrayId,DimensionRangePair>(dimensions.length);
  for (int d=0; d < dimensions.length; d++) {
    Class baseDefinitionCls;
    if (dimensions[d] instanceof SFCDimensionDefinition) {
      baseDefinitionCls=((SFCDimensionDefinition)dimensions[d]).getDimensionDefinition().getClass();
    }
 else {
      baseDefinitionCls=dimensions[d].getClass();
    }
    NumericDimensionField field=dimensionTypeToFieldMap.get(baseDefinitionCls);
    if (field != null) {
      final ByteArrayId fieldId=field.getFieldId();
      final DimensionRangePair fieldData=fieldsRangeData.get(fieldId);
      if (fieldData == null) {
        fieldsRangeData.put(fieldId,new DimensionRangePair(field,insertTileRange[d]));
      }
 else {
        fieldData.add(field,insertTileRange[d]);
      }
    }
  }
  for (  final Entry<ByteArrayId,DimensionRangePair> entry : fieldsRangeData.entrySet()) {
    PersistentDataset<CommonIndexValue> commonData=getCommonData();
    if (commonData != null) {
      CommonIndexValue value=commonData.getValue(entry.getKey());
      if (value != null && !value.overlaps(entry.getValue().dimensions,entry.getValue().dataPerDimension)) {
        return false;
      }
    }
  }
  return true;
}",0.911377245508982
112961,"protected DistributableQueryFilter createQueryFilter(final MultiDimensionalNumericData constraints,final NumericDimensionField<?>[] dimensionFields){
  return new BasicQueryFilter(constraints,dimensionFields);
}","protected DistributableQueryFilter createQueryFilter(final MultiDimensionalNumericData constraints,final NumericDimensionField<?>[] orderedConstrainedDimensionFields,final NumericDimensionField<?>[] unconstrainedDimensionFields){
  return new BasicQueryFilter(constraints,orderedConstrainedDimensionFields);
}",0.8038461538461539
112962,"protected DistributableQueryFilter createFilter(final CommonIndexModel indexModel,final BasicQuery basicQuery){
  NumericDimensionField<?>[] dimensionFields=indexModel.getDimensions();
  NumericData[] orderedConstraintsPerDimension=new NumericData[dimensionFields.length];
  final Set<Integer> fieldsToTrim=new HashSet<Integer>();
  for (int d=0; d < dimensionFields.length; d++) {
    final ConstraintData nd=constraintsPerTypeOfDimensionDefinition.get(dimensionFields[d].getBaseDefinition().getClass());
    if (nd == null) {
      fieldsToTrim.add(d);
    }
 else {
      orderedConstraintsPerDimension[d]=constraintsPerTypeOfDimensionDefinition.get(dimensionFields[d].getBaseDefinition().getClass()).range;
    }
  }
  if (!fieldsToTrim.isEmpty()) {
    final NumericDimensionField<?>[] newDimensionFields=new NumericDimensionField[dimensionFields.length - fieldsToTrim.size()];
    final NumericData[] newOrderedConstraintsPerDimension=new NumericData[newDimensionFields.length];
    int newDimensionCtr=0;
    for (int i=0; i < dimensionFields.length; i++) {
      if (!fieldsToTrim.contains(i)) {
        newDimensionFields[newDimensionCtr]=dimensionFields[i];
        newOrderedConstraintsPerDimension[newDimensionCtr++]=orderedConstraintsPerDimension[i];
      }
    }
    dimensionFields=newDimensionFields;
    orderedConstraintsPerDimension=newOrderedConstraintsPerDimension;
  }
  return basicQuery.createQueryFilter(new BasicNumericDataset(orderedConstraintsPerDimension),dimensionFields);
}","protected DistributableQueryFilter createFilter(final CommonIndexModel indexModel,final BasicQuery basicQuery){
  final NumericDimensionField<?>[] dimensionFields=indexModel.getDimensions();
  NumericDimensionField<?>[] orderedConstrainedDimensionFields=dimensionFields;
  NumericDimensionField<?>[] unconstrainedDimensionFields;
  NumericData[] orderedConstraintsPerDimension=new NumericData[dimensionFields.length];
  final Set<Integer> fieldsToTrim=new HashSet<Integer>();
  for (int d=0; d < dimensionFields.length; d++) {
    final ConstraintData nd=constraintsPerTypeOfDimensionDefinition.get(dimensionFields[d].getBaseDefinition().getClass());
    if (nd == null) {
      fieldsToTrim.add(d);
    }
 else {
      orderedConstraintsPerDimension[d]=constraintsPerTypeOfDimensionDefinition.get(dimensionFields[d].getBaseDefinition().getClass()).range;
    }
  }
  if (!fieldsToTrim.isEmpty()) {
    final NumericDimensionField<?>[] newDimensionFields=new NumericDimensionField[dimensionFields.length - fieldsToTrim.size()];
    unconstrainedDimensionFields=new NumericDimensionField[fieldsToTrim.size()];
    final NumericData[] newOrderedConstraintsPerDimension=new NumericData[newDimensionFields.length];
    int newDimensionCtr=0;
    int constrainedCtr=0;
    for (int i=0; i < dimensionFields.length; i++) {
      if (!fieldsToTrim.contains(i)) {
        newDimensionFields[newDimensionCtr]=dimensionFields[i];
        newOrderedConstraintsPerDimension[newDimensionCtr++]=orderedConstraintsPerDimension[i];
      }
 else {
        unconstrainedDimensionFields[constrainedCtr++]=dimensionFields[i];
      }
    }
    orderedConstrainedDimensionFields=newDimensionFields;
    orderedConstraintsPerDimension=newOrderedConstraintsPerDimension;
  }
 else {
    unconstrainedDimensionFields=new NumericDimensionField[]{};
  }
  return basicQuery.createQueryFilter(new BasicNumericDataset(orderedConstraintsPerDimension),orderedConstrainedDimensionFields,unconstrainedDimensionFields);
}",0.4779622209502003
112963,"private boolean subsetRequested(){
  if (query == null)   return false;
  return !(query.getPropertyNames() == Query.ALL_NAMES);
}","private boolean subsetRequested(){
  if (query == null) {
    return false;
  }
  return !(query.getPropertyNames() == Query.ALL_NAMES);
}",0.9701492537313432
112964,"private List<String> getSubset(){
  if (query == null)   return Collections.emptyList();
  return Arrays.asList(query.getPropertyNames());
}","private List<String> getSubset(){
  if (query == null) {
    return Collections.emptyList();
  }
  return Arrays.asList(query.getPropertyNames());
}",0.9722222222222222
112965,"public static DistributableQuery createOptimalQuery(final String cql,final GeotoolsFeatureDataAdapter adapter,final CompareOperation geoCompareOp,final PrimaryIndex index) throws CQLException {
  final Filter cqlFilter=CQL.toFilter(cql);
  final ExtractAttributesFilter attributesVisitor=new ExtractAttributesFilter();
  final Object obj=cqlFilter.accept(attributesVisitor,null);
  final Collection<String> attrs;
  if ((obj != null) && (obj instanceof Collection)) {
    attrs=(Collection<String>)obj;
  }
 else {
    attrs=new ArrayList<String>();
  }
  final boolean isSpatial=index == null ? false : hasAtLeastSpatial(index);
  final boolean isTemporal=index == null ? false : hasTime(index) && adapter.hasTemporalConstraints();
  if (isSpatial) {
    final String geomName=adapter.getType().getGeometryDescriptor().getLocalName();
    attrs.remove(geomName);
  }
  if (isTemporal) {
    final TimeDescriptors timeDescriptors=adapter.getTimeDescriptors();
    if (timeDescriptors != null) {
      final AttributeDescriptor timeDesc=timeDescriptors.getTime();
      if (timeDesc != null) {
        attrs.remove(timeDesc.getLocalName());
      }
      final AttributeDescriptor startDesc=timeDescriptors.getStartRange();
      if (startDesc != null) {
        attrs.remove(startDesc.getLocalName());
      }
      final AttributeDescriptor endDesc=timeDescriptors.getEndRange();
      if (endDesc != null) {
        attrs.remove(endDesc.getLocalName());
      }
    }
  }
  DistributableQuery baseQuery=null;
  final Geometry geometry=ExtractGeometryFilterVisitor.getConstraints(cqlFilter,adapter.getType().getCoordinateReferenceSystem());
  final TemporalConstraintsSet timeConstraintSet=new ExtractTimeFilterVisitor(adapter.getTimeDescriptors()).getConstraints(cqlFilter);
  if (geometry != null) {
    Constraints constraints=GeometryUtils.basicConstraintsFromGeometry(geometry);
    if ((timeConstraintSet != null) && !timeConstraintSet.isEmpty()) {
      final TemporalConstraints temporalConstraints=QueryIndexHelper.getTemporalConstraintsForDescriptors(adapter.getTimeDescriptors(),timeConstraintSet);
      final Constraints timeConstraints=SpatialTemporalQuery.createConstraints(temporalConstraints,false);
      constraints=constraints.merge(timeConstraints);
    }
    baseQuery=new SpatialQuery(constraints,geometry,geoCompareOp);
  }
 else   if ((timeConstraintSet != null) && !timeConstraintSet.isEmpty()) {
    final TemporalConstraints temporalConstraints=QueryIndexHelper.getTemporalConstraintsForDescriptors(adapter.getTimeDescriptors(),timeConstraintSet);
    baseQuery=new TemporalQuery(temporalConstraints);
  }
  if (attrs.isEmpty()) {
    return baseQuery;
  }
 else {
    return new CQLQuery(baseQuery,cqlFilter,adapter);
  }
}","public static DistributableQuery createOptimalQuery(final Filter cqlFilter,final GeotoolsFeatureDataAdapter adapter,final CompareOperation geoCompareOp,final PrimaryIndex index){
  final ExtractAttributesFilter attributesVisitor=new ExtractAttributesFilter();
  final Object obj=cqlFilter.accept(attributesVisitor,null);
  final Collection<String> attrs;
  if ((obj != null) && (obj instanceof Collection)) {
    attrs=(Collection<String>)obj;
  }
 else {
    attrs=new ArrayList<String>();
  }
  final boolean isSpatial=index == null ? false : hasAtLeastSpatial(index);
  final boolean isTemporal=index == null ? false : hasTime(index) && adapter.hasTemporalConstraints();
  if (isSpatial) {
    final String geomName=adapter.getType().getGeometryDescriptor().getLocalName();
    attrs.remove(geomName);
  }
  if (isTemporal) {
    final TimeDescriptors timeDescriptors=adapter.getTimeDescriptors();
    if (timeDescriptors != null) {
      final AttributeDescriptor timeDesc=timeDescriptors.getTime();
      if (timeDesc != null) {
        attrs.remove(timeDesc.getLocalName());
      }
      final AttributeDescriptor startDesc=timeDescriptors.getStartRange();
      if (startDesc != null) {
        attrs.remove(startDesc.getLocalName());
      }
      final AttributeDescriptor endDesc=timeDescriptors.getEndRange();
      if (endDesc != null) {
        attrs.remove(endDesc.getLocalName());
      }
    }
  }
  DistributableQuery baseQuery=null;
  final Geometry geometry=ExtractGeometryFilterVisitor.getConstraints(cqlFilter,adapter.getType().getCoordinateReferenceSystem());
  final TemporalConstraintsSet timeConstraintSet=new ExtractTimeFilterVisitor(adapter.getTimeDescriptors()).getConstraints(cqlFilter);
  if (geometry != null) {
    Constraints constraints=GeometryUtils.basicConstraintsFromGeometry(geometry);
    if ((timeConstraintSet != null) && !timeConstraintSet.isEmpty()) {
      final TemporalConstraints temporalConstraints=QueryIndexHelper.getTemporalConstraintsForDescriptors(adapter.getTimeDescriptors(),timeConstraintSet);
      final Constraints timeConstraints=SpatialTemporalQuery.createConstraints(temporalConstraints,false);
      constraints=constraints.merge(timeConstraints);
    }
    baseQuery=new SpatialQuery(constraints,geometry,geoCompareOp);
  }
 else   if ((timeConstraintSet != null) && !timeConstraintSet.isEmpty()) {
    final TemporalConstraints temporalConstraints=QueryIndexHelper.getTemporalConstraintsForDescriptors(adapter.getTimeDescriptors(),timeConstraintSet);
    baseQuery=new TemporalQuery(temporalConstraints);
  }
  if (attrs.isEmpty()) {
    return baseQuery;
  }
 else {
    return new CQLQuery(baseQuery,cqlFilter,adapter);
  }
}",0.984762254451992
112966,"/** 
 * Recursively decompose geometry into a set of envelopes to create a single set.
 * @param geometry
 * @param destinationListOfSets
 */
private static void constructListOfConstraintSetsFromGeometry(final Geometry geometry,final List<ConstraintSet> destinationListOfSets){
  int n=geometry.getNumGeometries();
  if (n > 1) {
    for (int gi=0; gi < n; gi++) {
      constructListOfConstraintSetsFromGeometry(geometry.getGeometryN(gi),destinationListOfSets);
    }
  }
 else {
    final Envelope env=geometry.getEnvelopeInternal();
    destinationListOfSets.add(basicConstraintSetFromEnvelope(env));
  }
}","/** 
 * Recursively decompose geometry into a set of envelopes to create a single set.
 * @param geometry
 * @param destinationListOfSets
 * @param checkTopoEquality
 */
private static boolean constructListOfConstraintSetsFromGeometry(final Geometry geometry,final List<ConstraintSet> destinationListOfSets,final boolean checkTopoEquality){
  final int n=geometry.getNumGeometries();
  boolean retVal=true;
  if (n > 1) {
    retVal=false;
    for (int gi=0; gi < n; gi++) {
      constructListOfConstraintSetsFromGeometry(geometry.getGeometryN(gi),destinationListOfSets,checkTopoEquality);
    }
  }
 else {
    final Envelope env=geometry.getEnvelopeInternal();
    destinationListOfSets.add(basicConstraintSetFromEnvelope(env));
    if (checkTopoEquality) {
      retVal=new GeometryFactory().toGeometry(env).equalsTopo(geometry);
    }
  }
  return retVal;
}",0.822569680489463
112967,"/** 
 * This utility method will convert a JTS geometry to contraints that can be used in a GeoWave query.
 * @return Constraints as a mapping of NumericData objects representingranges for a latitude dimension and a longitude dimension
 */
public static Constraints basicConstraintsFromGeometry(final Geometry geometry){
  List<ConstraintSet> set=new LinkedList<ConstraintSet>();
  constructListOfConstraintSetsFromGeometry(geometry,set);
  return new Constraints(set);
}","public static Constraints basicConstraintsFromGeometry(final Geometry geometry){
  final List<ConstraintSet> set=new LinkedList<ConstraintSet>();
  constructListOfConstraintSetsFromGeometry(geometry,set,false);
  return new Constraints(set);
}",0.6470588235294118
112968,"public Date getMinOr(final Date min){
  return (constraints.isEmpty()) ? min : constraints.getFirst().getStartTime();
}","public Date getMinOr(final Date min,int exclusivityIncrement){
  return (constraints.isEmpty()) ? min : exclusivityIncrement == 0 ? constraints.getFirst().getStartTime() : new Date(constraints.getFirst().getStartTime().getTime() + exclusivityIncrement);
}",0.6363636363636364
112969,"public Date getMaxOr(final Date max){
  return (constraints.isEmpty()) ? max : constraints.getLast().getEndTime();
}","public Date getMaxOr(final Date max,int exclusivityIncrement){
  return (constraints.isEmpty()) ? max : exclusivityIncrement == 0 ? constraints.getLast().getEndTime() : new Date(constraints.getLast().getEndTime().getTime() + exclusivityIncrement);
}",0.6356164383561644
112970,"/** 
 * @param binId a unique ID associated with the BinnedQuery object
 * @param indexRanges multi-dimensional range data
 */
public BinnedNumericDataset(final byte[] binId,final MultiDimensionalNumericData indexRanges){
  this.binId=binId;
  this.indexRanges=indexRanges;
}","/** 
 * @param binId a unique ID associated with the BinnedQuery object
 * @param indexRanges multi-dimensional range data
 */
public BinnedNumericDataset(final byte[] binId,final MultiDimensionalNumericData indexRanges,final boolean fullExtent){
  this.binId=binId;
  this.indexRanges=indexRanges;
  this.fullExtent=fullExtent;
}",0.9090909090909092
112971,"/** 
 * This method is responsible for translating a query into appropriate normalized and binned (if necessary) queries that can be used by the underlying index implementation. For example, for unbounded dimensions such as time, an incoming query of July 2012 to July 2013 may get translated into 2 binned queries representing the 2012 portion of the query and the 2013 portion, each normalized to millis from the beginning of the year.
 * @param numericData the incoming query into the index implementation, to be translated into normalized, binned queries
 * @param dimensionDefinitions the definition for the dimensions
 * @return normalized indexes
 */
public static BinnedNumericDataset[] applyBins(final MultiDimensionalNumericData numericData,final NumericDimensionDefinition[] dimensionDefinitions){
  if (dimensionDefinitions.length == 0) {
    return new BinnedNumericDataset[0];
  }
  final BinRange[][] binRangesPerDimension=new BinRange[dimensionDefinitions.length][];
  int numBinnedQueries=1;
  for (int d=0; d < dimensionDefinitions.length; d++) {
    binRangesPerDimension[d]=dimensionDefinitions[d].getNormalizedRanges(numericData.getDataPerDimension()[d]);
    numBinnedQueries*=binRangesPerDimension[d].length;
  }
  final BinnedNumericDataset[] binnedQueries=new BinnedNumericDataset[numBinnedQueries];
  for (int d=0; d < dimensionDefinitions.length; d++) {
    for (int b=0; b < binRangesPerDimension[d].length; b++) {
      for (int i=b; i < numBinnedQueries; i+=binRangesPerDimension[d].length) {
        final NumericData[] rangePerDimension;
        if (binnedQueries[i] == null) {
          rangePerDimension=new NumericRange[dimensionDefinitions.length];
          binnedQueries[i]=new BinnedNumericDataset(binRangesPerDimension[d][b].getBinId(),new BasicNumericDataset(rangePerDimension));
        }
 else {
          rangePerDimension=binnedQueries[i].getDataPerDimension();
          final byte[] combinedBinId=ByteArrayUtils.combineArrays(binnedQueries[i].getBinId(),binRangesPerDimension[d][b].getBinId());
          binnedQueries[i]=new BinnedNumericDataset(combinedBinId,new BasicNumericDataset(rangePerDimension));
        }
        rangePerDimension[d]=new NumericRange(binRangesPerDimension[d][b].getNormalizedMin(),binRangesPerDimension[d][b].getNormalizedMax());
      }
    }
  }
  return binnedQueries;
}","/** 
 * This method is responsible for translating a query into appropriate normalized and binned (if necessary) queries that can be used by the underlying index implementation. For example, for unbounded dimensions such as time, an incoming query of July 2012 to July 2013 may get translated into 2 binned queries representing the 2012 portion of the query and the 2013 portion, each normalized to millis from the beginning of the year.
 * @param numericData the incoming query into the index implementation, to be translated into normalized, binned queries
 * @param dimensionDefinitions the definition for the dimensions
 * @return normalized indexes
 */
public static BinnedNumericDataset[] applyBins(final MultiDimensionalNumericData numericData,final NumericDimensionDefinition[] dimensionDefinitions){
  if (dimensionDefinitions.length == 0) {
    return new BinnedNumericDataset[0];
  }
  final BinRange[][] binRangesPerDimension=new BinRange[dimensionDefinitions.length][];
  int numBinnedQueries=1;
  for (int d=0; d < dimensionDefinitions.length; d++) {
    binRangesPerDimension[d]=dimensionDefinitions[d].getNormalizedRanges(numericData.getDataPerDimension()[d]);
    numBinnedQueries*=binRangesPerDimension[d].length;
  }
  final BinnedNumericDataset[] binnedQueries=new BinnedNumericDataset[numBinnedQueries];
  for (int d=0; d < dimensionDefinitions.length; d++) {
    for (int b=0; b < binRangesPerDimension[d].length; b++) {
      for (int i=b; i < numBinnedQueries; i+=binRangesPerDimension[d].length) {
        final NumericData[] rangePerDimension;
        if (binnedQueries[i] == null) {
          rangePerDimension=new NumericRange[dimensionDefinitions.length];
          binnedQueries[i]=new BinnedNumericDataset(binRangesPerDimension[d][b].getBinId(),new BasicNumericDataset(rangePerDimension),binRangesPerDimension[d][b].isFullExtent());
        }
 else {
          rangePerDimension=binnedQueries[i].getDataPerDimension();
          final byte[] combinedBinId=ByteArrayUtils.combineArrays(binnedQueries[i].getBinId(),binRangesPerDimension[d][b].getBinId());
          binnedQueries[i]=new BinnedNumericDataset(combinedBinId,new BasicNumericDataset(rangePerDimension),binnedQueries[i].fullExtent|=binRangesPerDimension[d][b].isFullExtent());
        }
        rangePerDimension[d]=new NumericRange(binRangesPerDimension[d][b].getNormalizedMin(),binRangesPerDimension[d][b].getNormalizedMax());
      }
    }
  }
  return binnedQueries;
}",0.8900436499688215
112972,"@Override public byte[] toBinary(){
  final byte[] indexRangesBinary=PersistenceUtils.toBinary(indexRanges);
  final ByteBuffer buf=ByteBuffer.allocate(4 + indexRangesBinary.length + binId.length);
  buf.putInt(binId.length);
  buf.put(binId);
  buf.put(indexRangesBinary);
  return null;
}","@Override public byte[] toBinary(){
  final byte[] indexRangesBinary=PersistenceUtils.toBinary(indexRanges);
  final ByteBuffer buf=ByteBuffer.allocate(5 + indexRangesBinary.length + binId.length);
  buf.put((byte)(fullExtent ? 1 : 0));
  buf.putInt(binId.length);
  buf.put(binId);
  buf.put(indexRangesBinary);
  return null;
}",0.9337641357027464
112973,"@Override public void fromBinary(final byte[] bytes){
  final ByteBuffer buf=ByteBuffer.wrap(bytes);
  binId=new byte[buf.getInt()];
  buf.get(binId);
  final byte[] indexRangesBinary=new byte[bytes.length - 4 - binId.length];
  buf.get(indexRangesBinary);
  indexRanges=PersistenceUtils.fromBinary(indexRangesBinary,MultiDimensionalNumericData.class);
}","@Override public void fromBinary(final byte[] bytes){
  final ByteBuffer buf=ByteBuffer.wrap(bytes);
  fullExtent=(buf.get() == 1);
  binId=new byte[buf.getInt()];
  buf.get(binId);
  final byte[] indexRangesBinary=new byte[bytes.length - 5 - binId.length];
  buf.get(indexRangesBinary);
  indexRanges=PersistenceUtils.fromBinary(indexRangesBinary,MultiDimensionalNumericData.class);
}",0.9553450608930988
112974,"private <T>void populateResults(final List<CloseableIterator<T>> results,final DataAdapter<Object> adapter,final PrimaryIndex index,final Query query,final DedupeFilter filter,final QueryOptions queryOptions,final boolean isDelete,final DataStoreCallbackManager callbackCache){
  final TreeSet<EntryRow> set=getRowsForIndex(index.getId());
  final Iterator<EntryRow> rowIt=((query == null) || query.isSupported(index)) ? ((TreeSet<EntryRow>)set.clone()).iterator() : Collections.<EntryRow>emptyIterator();
  final List<QueryFilter> filters=(query == null) ? new ArrayList<QueryFilter>() : new ArrayList<QueryFilter>(query.createFilters(index.getIndexModel()));
  filters.add(new QueryFilter(){
    @Override public boolean accept(    final CommonIndexModel indexModel,    final IndexedPersistenceEncoding persistenceEncoding){
      if (adapter.getAdapterId().equals(persistenceEncoding.getAdapterId())) {
        return true;
      }
      return false;
    }
  }
);
  if (filter != null)   filters.add(filter);
  results.add(new CloseableIterator<T>(){
    EntryRow nextRow=null;
    EntryRow currentRow=null;
    IndexedPersistenceEncoding encoding=null;
    private boolean getNext(){
      while ((nextRow == null) && rowIt.hasNext()) {
        final EntryRow row=rowIt.next();
        final DataAdapter<?> adapter=adapterStore.getAdapter(new ByteArrayId(row.getTableRowId().getAdapterId()));
        encoding=DataStoreUtils.getEncoding(index.getIndexModel(),adapter,row);
        boolean ok=true;
        for (        final QueryFilter filter : filters) {
          if (!filter.accept(index.getIndexModel(),encoding)) {
            ok=false;
            break;
          }
        }
        ok&=isAuthorized(row,queryOptions.getAuthorizations());
        if (ok) {
          nextRow=row;
          break;
        }
      }
      return (nextRow != null);
    }
    @Override public boolean hasNext(){
      return getNext();
    }
    @Override public T next(){
      currentRow=nextRow;
      if (isDelete) {
        final DataAdapter<T> adapter=(DataAdapter<T>)adapterStore.getAdapter(encoding.getAdapterId());
        if (adapter instanceof WritableDataAdapter) {
          callbackCache.getDeleteCallback((WritableDataAdapter<T>)adapter,index).entryDeleted(currentRow.getInfo(),(T)currentRow.entry);
        }
      }
      ((ScanCallback<T>)queryOptions.getScanCallback()).entryScanned(currentRow.getInfo(),(T)currentRow.entry);
      nextRow=null;
      return (T)currentRow.entry;
    }
    @Override public void remove(){
      if (currentRow != null) {
        set.remove(currentRow);
      }
    }
    @Override public void close() throws IOException {
      final ScanCallback<?> callback=queryOptions.getScanCallback();
      if ((callback != null) && (callback instanceof Closeable)) {
        ((Closeable)callback).close();
      }
    }
  }
);
}","private <T>void populateResults(final List<CloseableIterator<T>> results,final DataAdapter<Object> adapter,final PrimaryIndex index,final Query query,final DedupeFilter filter,final QueryOptions queryOptions,final boolean isDelete,final DataStoreCallbackManager callbackCache){
  final TreeSet<EntryRow> set=getRowsForIndex(index.getId());
  final Iterator<EntryRow> rowIt=((TreeSet<EntryRow>)set.clone()).iterator();
  final List<QueryFilter> filters=(query == null) ? new ArrayList<QueryFilter>() : new ArrayList<QueryFilter>(query.createFilters(index.getIndexModel()));
  filters.add(new QueryFilter(){
    @Override public boolean accept(    final CommonIndexModel indexModel,    final IndexedPersistenceEncoding persistenceEncoding){
      if (adapter.getAdapterId().equals(persistenceEncoding.getAdapterId())) {
        return true;
      }
      return false;
    }
  }
);
  if (filter != null)   filters.add(filter);
  results.add(new CloseableIterator<T>(){
    EntryRow nextRow=null;
    EntryRow currentRow=null;
    IndexedPersistenceEncoding encoding=null;
    private boolean getNext(){
      while ((nextRow == null) && rowIt.hasNext()) {
        final EntryRow row=rowIt.next();
        final DataAdapter<?> adapter=adapterStore.getAdapter(new ByteArrayId(row.getTableRowId().getAdapterId()));
        encoding=DataStoreUtils.getEncoding(index.getIndexModel(),adapter,row);
        boolean ok=true;
        for (        final QueryFilter filter : filters) {
          if (!filter.accept(index.getIndexModel(),encoding)) {
            ok=false;
            break;
          }
        }
        ok&=isAuthorized(row,queryOptions.getAuthorizations());
        if (ok) {
          nextRow=row;
          break;
        }
      }
      return (nextRow != null);
    }
    @Override public boolean hasNext(){
      return getNext();
    }
    @Override public T next(){
      currentRow=nextRow;
      if (isDelete) {
        final DataAdapter<T> adapter=(DataAdapter<T>)adapterStore.getAdapter(encoding.getAdapterId());
        if (adapter instanceof WritableDataAdapter) {
          callbackCache.getDeleteCallback((WritableDataAdapter<T>)adapter,index).entryDeleted(currentRow.getInfo(),(T)currentRow.entry);
        }
      }
      ((ScanCallback<T>)queryOptions.getScanCallback()).entryScanned(currentRow.getInfo(),(T)currentRow.entry);
      nextRow=null;
      return (T)currentRow.entry;
    }
    @Override public void remove(){
      if (currentRow != null) {
        set.remove(currentRow);
      }
    }
    @Override public void close() throws IOException {
      final ScanCallback<?> callback=queryOptions.getScanCallback();
      if ((callback != null) && (callback instanceof Closeable)) {
        ((Closeable)callback).close();
      }
    }
  }
);
}",0.9844082211197732
112975,"@Override protected void addScanIteratorSettings(final ScannerBase scanner){
  addFieldSubsettingToIterator(scanner);
  if ((distributableFilters != null) && !distributableFilters.isEmpty() && queryFiltersEnabled) {
    final IteratorSetting iteratorSettings;
    if (isAggregation()) {
      iteratorSettings=new IteratorSetting(QueryFilterIterator.QUERY_ITERATOR_PRIORITY,QueryFilterIterator.QUERY_ITERATOR_NAME,AggregationIterator.class);
      iteratorSettings.addOption(AggregationIterator.ADAPTER_OPTION_NAME,ByteArrayUtils.byteArrayToString(PersistenceUtils.toBinary(aggregation.getLeft())));
      final Aggregation aggr=aggregation.getRight();
      iteratorSettings.addOption(AggregationIterator.AGGREGATION_OPTION_NAME,aggr.getClass().getName());
      if (aggr.getParameters() != null) {
        iteratorSettings.addOption(AggregationIterator.CONSTRAINTS_OPTION_NAME,ByteArrayUtils.byteArrayToString((PersistenceUtils.toBinary(aggr.getParameters()))));
      }
      iteratorSettings.addOption(AggregationIterator.INDEX_STRATEGY_OPTION_NAME,ByteArrayUtils.byteArrayToString(PersistenceUtils.toBinary(index.getIndexStrategy())));
    }
 else {
      iteratorSettings=new IteratorSetting(QueryFilterIterator.QUERY_ITERATOR_PRIORITY,QueryFilterIterator.QUERY_ITERATOR_NAME,QueryFilterIterator.class);
    }
    final DistributableQueryFilter filterList=new DistributableFilterList(distributableFilters);
    iteratorSettings.addOption(QueryFilterIterator.FILTER,ByteArrayUtils.byteArrayToString(PersistenceUtils.toBinary(filterList)));
    iteratorSettings.addOption(QueryFilterIterator.MODEL,ByteArrayUtils.byteArrayToString(PersistenceUtils.toBinary(index.getIndexModel())));
    scanner.addScanIterator(iteratorSettings);
  }
 else {
    final IteratorSetting iteratorSettings=new IteratorSetting(QueryFilterIterator.WHOLE_ROW_ITERATOR_PRIORITY,QueryFilterIterator.WHOLE_ROW_ITERATOR_NAME,WholeRowIterator.class);
    scanner.addScanIterator(iteratorSettings);
  }
}","@Override protected void addScanIteratorSettings(final ScannerBase scanner){
  addFieldSubsettingToIterator(scanner);
  if ((distributableFilters != null) && !distributableFilters.isEmpty() && queryFiltersEnabled) {
    final IteratorSetting iteratorSettings;
    if (isAggregation()) {
      iteratorSettings=new IteratorSetting(QueryFilterIterator.QUERY_ITERATOR_PRIORITY,QueryFilterIterator.QUERY_ITERATOR_NAME,AggregationIterator.class);
      iteratorSettings.addOption(AggregationIterator.ADAPTER_OPTION_NAME,ByteArrayUtils.byteArrayToString(PersistenceUtils.toBinary(aggregation.getLeft())));
      final Aggregation aggr=aggregation.getRight();
      iteratorSettings.addOption(AggregationIterator.AGGREGATION_OPTION_NAME,aggr.getClass().getName());
      iteratorSettings.addOption(AggregationIterator.CONSTRAINTS_OPTION_NAME,ByteArrayUtils.byteArrayToString((PersistenceUtils.toBinary((List)constraints))));
      if (aggr.getParameters() != null) {
        iteratorSettings.addOption(AggregationIterator.PARAMETER_OPTION_NAME,ByteArrayUtils.byteArrayToString((PersistenceUtils.toBinary(aggr.getParameters()))));
      }
      iteratorSettings.addOption(AggregationIterator.INDEX_STRATEGY_OPTION_NAME,ByteArrayUtils.byteArrayToString(PersistenceUtils.toBinary(index.getIndexStrategy())));
    }
 else {
      iteratorSettings=new IteratorSetting(QueryFilterIterator.QUERY_ITERATOR_PRIORITY,QueryFilterIterator.QUERY_ITERATOR_NAME,QueryFilterIterator.class);
    }
    final DistributableQueryFilter filterList=new DistributableFilterList(distributableFilters);
    iteratorSettings.addOption(QueryFilterIterator.FILTER,ByteArrayUtils.byteArrayToString(PersistenceUtils.toBinary(filterList)));
    iteratorSettings.addOption(QueryFilterIterator.MODEL,ByteArrayUtils.byteArrayToString(PersistenceUtils.toBinary(index.getIndexModel())));
    scanner.addScanIterator(iteratorSettings);
  }
 else {
    final IteratorSetting iteratorSettings=new IteratorSetting(QueryFilterIterator.WHOLE_ROW_ITERATOR_PRIORITY,QueryFilterIterator.WHOLE_ROW_ITERATOR_NAME,WholeRowIterator.class);
    scanner.addScanIterator(iteratorSettings);
  }
}",0.9562469615945552
112976,"@Override protected void addScanIteratorSettings(final ScannerBase scanner){
  addFieldSubsettingToIterator(scanner);
  if ((distributableFilters != null) && !distributableFilters.isEmpty() && queryFiltersEnabled) {
    final IteratorSetting iteratorSettings;
    if (isAggregation()) {
      iteratorSettings=new IteratorSetting(QueryFilterIterator.QUERY_ITERATOR_PRIORITY,QueryFilterIterator.QUERY_ITERATOR_NAME,AggregationIterator.class);
      iteratorSettings.addOption(AggregationIterator.ADAPTER_OPTION_NAME,ByteArrayUtils.byteArrayToString(PersistenceUtils.toBinary(aggregation.getLeft())));
      final Aggregation aggr=aggregation.getRight();
      iteratorSettings.addOption(AggregationIterator.AGGREGATION_OPTION_NAME,aggr.getClass().getName());
      iteratorSettings.addOption(AggregationIterator.CONSTRAINTS_OPTION_NAME,ByteArrayUtils.byteArrayToString((PersistenceUtils.toBinary((List)constraints))));
      iteratorSettings.addOption(AggregationIterator.INDEX_STRATEGY_OPTION_NAME,ByteArrayUtils.byteArrayToString(PersistenceUtils.toBinary(index.getIndexStrategy())));
    }
 else {
      iteratorSettings=new IteratorSetting(QueryFilterIterator.QUERY_ITERATOR_PRIORITY,QueryFilterIterator.QUERY_ITERATOR_NAME,QueryFilterIterator.class);
    }
    final DistributableQueryFilter filterList=new DistributableFilterList(distributableFilters);
    iteratorSettings.addOption(QueryFilterIterator.FILTER,ByteArrayUtils.byteArrayToString(PersistenceUtils.toBinary(filterList)));
    iteratorSettings.addOption(QueryFilterIterator.MODEL,ByteArrayUtils.byteArrayToString(PersistenceUtils.toBinary(index.getIndexModel())));
    scanner.addScanIterator(iteratorSettings);
  }
 else {
    final IteratorSetting iteratorSettings=new IteratorSetting(QueryFilterIterator.WHOLE_ROW_ITERATOR_PRIORITY,QueryFilterIterator.WHOLE_ROW_ITERATOR_NAME,WholeRowIterator.class);
    scanner.addScanIterator(iteratorSettings);
  }
}","@Override protected void addScanIteratorSettings(final ScannerBase scanner){
  addFieldSubsettingToIterator(scanner);
  if ((distributableFilters != null) && !distributableFilters.isEmpty() && queryFiltersEnabled) {
    final IteratorSetting iteratorSettings;
    if (isAggregation()) {
      iteratorSettings=new IteratorSetting(QueryFilterIterator.QUERY_ITERATOR_PRIORITY,QueryFilterIterator.QUERY_ITERATOR_NAME,AggregationIterator.class);
      iteratorSettings.addOption(AggregationIterator.ADAPTER_OPTION_NAME,ByteArrayUtils.byteArrayToString(PersistenceUtils.toBinary(aggregation.getLeft())));
      final Aggregation aggr=aggregation.getRight();
      iteratorSettings.addOption(AggregationIterator.AGGREGATION_OPTION_NAME,aggr.getClass().getName());
      if (aggr.getParameters() != null) {
        iteratorSettings.addOption(AggregationIterator.CONSTRAINTS_OPTION_NAME,ByteArrayUtils.byteArrayToString((PersistenceUtils.toBinary(aggr.getParameters()))));
      }
      iteratorSettings.addOption(AggregationIterator.INDEX_STRATEGY_OPTION_NAME,ByteArrayUtils.byteArrayToString(PersistenceUtils.toBinary(index.getIndexStrategy())));
    }
 else {
      iteratorSettings=new IteratorSetting(QueryFilterIterator.QUERY_ITERATOR_PRIORITY,QueryFilterIterator.QUERY_ITERATOR_NAME,QueryFilterIterator.class);
    }
    final DistributableQueryFilter filterList=new DistributableFilterList(distributableFilters);
    iteratorSettings.addOption(QueryFilterIterator.FILTER,ByteArrayUtils.byteArrayToString(PersistenceUtils.toBinary(filterList)));
    iteratorSettings.addOption(QueryFilterIterator.MODEL,ByteArrayUtils.byteArrayToString(PersistenceUtils.toBinary(index.getIndexModel())));
    scanner.addScanIterator(iteratorSettings);
  }
 else {
    final IteratorSetting iteratorSettings=new IteratorSetting(QueryFilterIterator.WHOLE_ROW_ITERATOR_PRIORITY,QueryFilterIterator.WHOLE_ROW_ITERATOR_NAME,WholeRowIterator.class);
    scanner.addScanIterator(iteratorSettings);
  }
}",0.9771853370930532
112977,"@Override public void init(final SortedKeyValueIterator<Key,Value> source,final Map<String,String> options,final IteratorEnvironment env) throws IOException {
  try {
    final String className=options.get(AGGREGATION_OPTION_NAME);
    aggregationFunction=PersistenceUtils.classFactory(className,Aggregation.class);
    final String parameterStr=options.get(PARAMETER_OPTION_NAME);
    if ((parameterStr != null) && parameterStr.isEmpty()) {
      final byte[] parameterBytes=ByteArrayUtils.byteArrayFromString(parameterStr);
      final Persistable aggregationParams=PersistenceUtils.fromBinary(parameterBytes,Persistable.class);
      aggregationFunction.setParameters(aggregationParams);
    }
    final String adapterStr=options.get(ADAPTER_OPTION_NAME);
    final byte[] adapterBytes=ByteArrayUtils.byteArrayFromString(adapterStr);
    adapter=PersistenceUtils.fromBinary(adapterBytes,DataAdapter.class);
    final String indexStrategyStr=options.get(INDEX_STRATEGY_OPTION_NAME);
    final byte[] indexStrategyBytes=ByteArrayUtils.byteArrayFromString(indexStrategyStr);
    final NumericIndexStrategy strategy=PersistenceUtils.fromBinary(indexStrategyBytes,NumericIndexStrategy.class);
    final String contraintsStr=options.get(CONSTRAINTS_OPTION_NAME);
    final byte[] constraintsBytes=ByteArrayUtils.byteArrayFromString(contraintsStr);
    final List constraints=PersistenceUtils.fromBinary(constraintsBytes);
    final String maxDecomp=options.get(MAX_DECOMPOSITION_OPTION_NAME);
    Integer maxDecompInt=AccumuloConstraintsQuery.MAX_RANGE_DECOMPOSITION;
    if (maxDecomp != null) {
      try {
        maxDecompInt=Integer.parseInt(maxDecomp);
      }
 catch (      final Exception e) {
        LOGGER.warn(""String_Node_Str"" + MAX_DECOMPOSITION_OPTION_NAME + ""String_Node_Str"",e);
      }
    }
    ranges=AccumuloUtils.byteArrayRangesToAccumuloRanges(DataStoreUtils.constraintsToByteArrayRanges(constraints,strategy,maxDecompInt));
    super.init(source,options,env);
  }
 catch (  final Exception e) {
    throw new IllegalArgumentException(e);
  }
}","@Override public void init(final SortedKeyValueIterator<Key,Value> source,final Map<String,String> options,final IteratorEnvironment env) throws IOException {
  try {
    final String className=options.get(AGGREGATION_OPTION_NAME);
    aggregationFunction=PersistenceUtils.classFactory(className,Aggregation.class);
    final String parameterStr=options.get(PARAMETER_OPTION_NAME);
    if ((parameterStr != null) && !parameterStr.isEmpty()) {
      final byte[] parameterBytes=ByteArrayUtils.byteArrayFromString(parameterStr);
      final Persistable aggregationParams=PersistenceUtils.fromBinary(parameterBytes,Persistable.class);
      aggregationFunction.setParameters(aggregationParams);
    }
    final String adapterStr=options.get(ADAPTER_OPTION_NAME);
    final byte[] adapterBytes=ByteArrayUtils.byteArrayFromString(adapterStr);
    adapter=PersistenceUtils.fromBinary(adapterBytes,DataAdapter.class);
    final String indexStrategyStr=options.get(INDEX_STRATEGY_OPTION_NAME);
    final byte[] indexStrategyBytes=ByteArrayUtils.byteArrayFromString(indexStrategyStr);
    final NumericIndexStrategy strategy=PersistenceUtils.fromBinary(indexStrategyBytes,NumericIndexStrategy.class);
    final String contraintsStr=options.get(CONSTRAINTS_OPTION_NAME);
    final byte[] constraintsBytes=ByteArrayUtils.byteArrayFromString(contraintsStr);
    final List constraints=PersistenceUtils.fromBinary(constraintsBytes);
    final String maxDecomp=options.get(MAX_DECOMPOSITION_OPTION_NAME);
    Integer maxDecompInt=AccumuloConstraintsQuery.MAX_RANGE_DECOMPOSITION;
    if (maxDecomp != null) {
      try {
        maxDecompInt=Integer.parseInt(maxDecomp);
      }
 catch (      final Exception e) {
        LOGGER.warn(""String_Node_Str"" + MAX_DECOMPOSITION_OPTION_NAME + ""String_Node_Str"",e);
      }
    }
    ranges=AccumuloUtils.byteArrayRangesToAccumuloRanges(DataStoreUtils.constraintsToByteArrayRanges(constraints,strategy,maxDecompInt));
    super.init(source,options,env);
  }
 catch (  final Exception e) {
    throw new IllegalArgumentException(e);
  }
}",0.9997578106078954
112978,"@Override public boolean acceptRow(final SortedKeyValueIterator<Key,Value> rowIterator) throws IOException {
  if ((queryFilterIterator != null) && queryFilterIterator.isSet()) {
    final Key key=rowIterator.getTopKey();
    final Value value=rowIterator.getTopValue();
    final PersistentDataset<CommonIndexValue> commonData=new PersistentDataset<CommonIndexValue>();
    final List<AccumuloFieldInfo> unknownData=new ArrayList<AccumuloFieldInfo>();
    final Text currentRow=key.getRow();
    queryFilterIterator.aggregateFieldData(key,value,commonData,unknownData);
    final CommonIndexedPersistenceEncoding encoding=QueryFilterIterator.getEncoding(currentRow,commonData,unknownData);
    final boolean queryFilterResult=queryFilterIterator.applyRowFilter(encoding);
    if (queryFilterResult) {
      aggregateRow(currentRow,queryFilterIterator.model,encoding);
    }
  }
  return false;
}","@Override public boolean acceptRow(final SortedKeyValueIterator<Key,Value> rowIterator) throws IOException {
  if ((queryFilterIterator != null) && queryFilterIterator.isSet()) {
    final Key key=rowIterator.getTopKey();
    final Value value=rowIterator.getTopValue();
    final PersistentDataset<CommonIndexValue> commonData=new PersistentDataset<CommonIndexValue>();
    final List<AccumuloFieldInfo> unknownData=new ArrayList<AccumuloFieldInfo>();
    final Text currentRow=key.getRow();
    queryFilterIterator.aggregateFieldData(key,value,commonData,unknownData);
    final CommonIndexedPersistenceEncoding encoding=QueryFilterIterator.getEncoding(currentRow,commonData,unknownData);
    boolean queryFilterResult=true;
    if (queryFilterIterator.isSet()) {
      queryFilterResult=queryFilterIterator.applyRowFilter(encoding);
    }
    if (queryFilterResult) {
      aggregateRow(currentRow,queryFilterIterator.model,encoding);
    }
  }
  return false;
}",0.9564750134336378
112979,"public void deepCopyIterator(final SortedKeyValueIterator<Key,Value> iterator){
  if (iterator instanceof AggregationIterator) {
    ((AggregationIterator)iterator).startRowOfAggregation=startRowOfAggregation;
    ((AggregationIterator)iterator).adapter=adapter;
    ((AggregationIterator)iterator).aggregationFunction=aggregationFunction;
    ((AggregationIterator)iterator).aggregationReturned=aggregationReturned;
  }
}","public void deepCopyIterator(final SortedKeyValueIterator<Key,Value> iterator){
  if (iterator instanceof AggregationIterator) {
    ((AggregationIterator)iterator).startRowOfAggregation=startRowOfAggregation;
    ((AggregationIterator)iterator).adapter=adapter;
    ((AggregationIterator)iterator).queryFilterIterator=queryFilterIterator;
    ((AggregationIterator)iterator).parent=parent;
    ((AggregationIterator)iterator).aggregationFunction=aggregationFunction;
    ((AggregationIterator)iterator).aggregationReturned=aggregationReturned;
  }
}",0.845679012345679
112980,"public void setOptions(final Map<String,String> options){
  if (options == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + WholeRowQueryFilterIterator.class.getName());
  }
  try {
    final String filterStr=options.get(FILTER);
    final byte[] filterBytes=ByteArrayUtils.byteArrayFromString(filterStr);
    filter=PersistenceUtils.fromBinary(filterBytes,DistributableQueryFilter.class);
    final String modelStr=options.get(MODEL);
    final byte[] modelBytes=ByteArrayUtils.byteArrayFromString(modelStr);
    model=PersistenceUtils.fromBinary(modelBytes,CommonIndexModel.class);
    for (    final NumericDimensionField<? extends CommonIndexValue> numericDimension : model.getDimensions()) {
      commonIndexFieldIds.add(numericDimension.getFieldId());
    }
  }
 catch (  final Exception e) {
    throw new IllegalArgumentException(e);
  }
}","public void setOptions(final Map<String,String> options){
  if (options == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + QueryFilterIterator.class.getName());
  }
  try {
    if (options.containsKey(FILTER)) {
      final String filterStr=options.get(FILTER);
      final byte[] filterBytes=ByteArrayUtils.byteArrayFromString(filterStr);
      filter=PersistenceUtils.fromBinary(filterBytes,DistributableQueryFilter.class);
    }
    if (options.containsKey(MODEL)) {
      final String modelStr=options.get(MODEL);
      final byte[] modelBytes=ByteArrayUtils.byteArrayFromString(modelStr);
      model=PersistenceUtils.fromBinary(modelBytes,CommonIndexModel.class);
      for (      final NumericDimensionField<? extends CommonIndexValue> numericDimension : model.getDimensions()) {
        commonIndexFieldIds.add(numericDimension.getFieldId());
      }
    }
  }
 catch (  final Exception e) {
    throw new IllegalArgumentException(e);
  }
}",0.8576104746317512
112981,"@Override protected boolean filter(final Text currentRow,final List<Key> keys,final List<Value> values){
  if ((aggregationIterator != null) && (aggregationIterator.queryFilterIterator != null) && aggregationIterator.queryFilterIterator.isSet()) {
    final PersistentDataset<CommonIndexValue> commonData=new PersistentDataset<CommonIndexValue>();
    final List<AccumuloFieldInfo> unknownData=new ArrayList<AccumuloFieldInfo>();
    for (int i=0; (i < keys.size()) && (i < values.size()); i++) {
      final Key key=keys.get(i);
      final Value value=values.get(i);
      queryFilterIterator.aggregateFieldData(key,value,commonData,unknownData);
    }
    final CommonIndexedPersistenceEncoding encoding=QueryFilterIterator.getEncoding(currentRow,commonData,unknownData);
    final boolean queryFilterResult=queryFilterIterator.applyRowFilter(encoding);
    if (queryFilterResult) {
      aggregationIterator.aggregateRow(currentRow,queryFilterIterator.model,encoding);
    }
  }
  return false;
}","@Override protected boolean filter(final Text currentRow,final List<Key> keys,final List<Value> values){
  if ((aggregationIterator != null) && (aggregationIterator.queryFilterIterator != null)) {
    final PersistentDataset<CommonIndexValue> commonData=new PersistentDataset<CommonIndexValue>();
    final List<AccumuloFieldInfo> unknownData=new ArrayList<AccumuloFieldInfo>();
    for (int i=0; (i < keys.size()) && (i < values.size()); i++) {
      final Key key=keys.get(i);
      final Value value=values.get(i);
      aggregationIterator.queryFilterIterator.aggregateFieldData(key,value,commonData,unknownData);
    }
    final CommonIndexedPersistenceEncoding encoding=QueryFilterIterator.getEncoding(currentRow,commonData,unknownData);
    boolean queryFilterResult=true;
    if (aggregationIterator.queryFilterIterator.isSet()) {
      queryFilterResult=aggregationIterator.queryFilterIterator.applyRowFilter(encoding);
    }
    if (queryFilterResult) {
      aggregationIterator.aggregateRow(currentRow,queryFilterIterator.model,encoding);
    }
  }
  return false;
}",0.6948989412897016
112982,"private static void testQuery(final DataStore store,final String[] auths,final boolean spatial,final int expectedResultCount,final int expectedNonNullFieldCount) throws IOException {
  final QueryOptions queryOpts=new QueryOptions();
  queryOpts.setAuthorizations(auths);
  try (CloseableIterator<SimpleFeature> it=(CloseableIterator)store.query(queryOpts,spatial ? new SpatialQuery(new GeometryFactory().toGeometry(new Envelope(-1,1,-1,1))) : null)){
    int resultCount=0;
    int nonNullFieldsCount=0;
    while (it.hasNext()) {
      final SimpleFeature feature=it.next();
      for (int a=0; a < feature.getAttributeCount(); a++) {
        if (feature.getAttribute(a) != null) {
          nonNullFieldsCount++;
        }
      }
      resultCount++;
    }
    Assert.assertEquals(""String_Node_Str"" + (spatial ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ Arrays.toString(auths),expectedResultCount,resultCount);
    Assert.assertEquals(""String_Node_Str"" + (spatial ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ Arrays.toString(auths),expectedNonNullFieldCount,nonNullFieldsCount);
  }
 }","private static void testQuery(final DataStore store,final String[] auths,final boolean spatial,final int expectedResultCount,final int expectedNonNullFieldCount) throws IOException {
  final QueryOptions queryOpts=new QueryOptions();
  queryOpts.setAuthorizations(auths);
  try (CloseableIterator<SimpleFeature> it=(CloseableIterator)store.query(queryOpts,spatial ? new SpatialQuery(new GeometryFactory().toGeometry(new Envelope(-1,1,-1,1))) : null)){
    int resultCount=0;
    int nonNullFieldsCount=0;
    while (it.hasNext()) {
      final SimpleFeature feature=it.next();
      for (int a=0; a < feature.getAttributeCount(); a++) {
        if (feature.getAttribute(a) != null) {
          nonNullFieldsCount++;
        }
      }
      resultCount++;
    }
    Assert.assertEquals(""String_Node_Str"" + (spatial ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ Arrays.toString(auths),expectedResultCount,resultCount);
    Assert.assertEquals(""String_Node_Str"" + (spatial ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ Arrays.toString(auths),expectedNonNullFieldCount,nonNullFieldsCount);
  }
   queryOpts.setAggregation(new CountAggregation<>(),new FeatureDataAdapter(getType()));
  try (CloseableIterator<CountResult> it=(CloseableIterator)store.query(queryOpts,spatial ? new SpatialQuery(new GeometryFactory().toGeometry(new Envelope(-1,1,-1,1))) : null)){
    CountResult result=it.next();
    long count=0;
    if (result != null) {
      count=result.getCount();
    }
    Assert.assertEquals(""String_Node_Str"" + (spatial ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ Arrays.toString(auths),expectedResultCount,count);
  }
 }",0.8028571428571428
112983,"protected abstract List<ByteArrayId> getAltIndexRowIds(String altIdxTableName,List<ByteArrayId> dataIds,ByteArrayId adapterId);","protected abstract List<ByteArrayId> getAltIndexRowIds(final String altIdxTableName,final List<ByteArrayId> dataIds,final ByteArrayId adapterId,final String... authorizations);",0.8382838283828383
112984,"@Override public T next() throws NoSuchElementException {
  if (nextValue == null)   findNext();
  final T previousNext=nextValue;
  if (nextValue == null) {
    throw new NoSuchElementException();
  }
  nextValue=null;
  return previousNext;
}","@Override public T next() throws NoSuchElementException {
  if (nextValue == null) {
    findNext();
  }
  final T previousNext=nextValue;
  if (nextValue == null) {
    throw new NoSuchElementException();
  }
  nextValue=null;
  return previousNext;
}",0.9838709677419356
112985,"@Override public PersistableStore getValue(final PropertyManagement propertyManagement){
  try {
    return (PersistableStore)propertyManagement.getProperty(StoreParameters.StoreParam.INPUT_STORE);
  }
 catch (  final Exception e) {
    LOGGER.error(""String_Node_Str"",e);
    return null;
  }
}","@Override public PersistableStore getValue(String stringValue){
  throw new NotImplementedException(""String_Node_Str"");
}",0.4530120481927711
112986,"@Override public PersistableStore getValue(final PropertyManagement propertyManagement){
  try {
    return (PersistableStore)propertyManagement.getProperty(StoreParameters.StoreParam.OUTPUT_STORE);
  }
 catch (  final Exception e) {
    LOGGER.error(""String_Node_Str"",e);
    return null;
  }
}","@Override public PersistableStore getValue(String stringValue){
  throw new NotImplementedException(""String_Node_Str"");
}",0.4519230769230769
112987,"public T getValue(JobContext context,Class<?> scope,T defaultValue);",public T getValue(String stringValue);,0.5471698113207547
112988,"@Override public NonSerializableExample getValue(final PropertyManagement propertyManagement){
  return null;
}","@Override public NonSerializableExample getValue(String stringValue){
  throw new NotImplementedException(""String_Node_Str"");
}",0.5966386554621849
112989,"private PrimaryIndex wrapIndexWithOptions(final PrimaryIndex index){
  PrimaryIndex retVal=index;
  if ((numPartitions > 1) && partitionStrategy.equals(PartitionStrategy.HASH)) {
    retVal=new CustomIdIndex(new CompoundIndexStrategy(new HashKeyIndexStrategy(index.getIndexStrategy().getOrderedDimensionDefinitions(),numPartitions),index.getIndexStrategy()),index.getIndexModel(),new ByteArrayId(index.getId().getString() + ""String_Node_Str"" + PartitionStrategy.HASH.name()+ ""String_Node_Str""+ numPartitions));
  }
 else   if (numPartitions > 1) {
    if (partitionStrategy.equals(PartitionStrategy.NONE)) {
      LOGGER.warn(""String_Node_Str"");
    }
    retVal=new CustomIdIndex(new CompoundIndexStrategy(new RoundRobinKeyIndexStrategy(numPartitions),index.getIndexStrategy()),index.getIndexModel(),new ByteArrayId(index.getId().getString() + ""String_Node_Str"" + PartitionStrategy.ROUND_ROBIN.name()+ ""String_Node_Str""+ numPartitions));
  }
  if ((getType() != null) && (getType().length() > 0)) {
    retVal=new CustomIdIndex(retVal.getIndexStrategy(),retVal.getIndexModel(),new ByteArrayId(getType()));
  }
  return retVal;
}","private PrimaryIndex wrapIndexWithOptions(final PrimaryIndex index){
  PrimaryIndex retVal=index;
  if ((numPartitions > 1) && partitionStrategy.equals(PartitionStrategy.HASH)) {
    retVal=new CustomIdIndex(new CompoundIndexStrategy(new HashKeyIndexStrategy(index.getIndexStrategy().getOrderedDimensionDefinitions(),numPartitions),index.getIndexStrategy()),index.getIndexModel(),new ByteArrayId(index.getId().getString() + ""String_Node_Str"" + PartitionStrategy.HASH.name()+ ""String_Node_Str""+ numPartitions));
  }
 else   if (numPartitions > 1) {
    if (partitionStrategy.equals(PartitionStrategy.NONE)) {
      LOGGER.warn(""String_Node_Str"");
    }
    retVal=new CustomIdIndex(new CompoundIndexStrategy(new RoundRobinKeyIndexStrategy(numPartitions),index.getIndexStrategy()),index.getIndexModel(),new ByteArrayId(index.getId().getString() + ""String_Node_Str"" + PartitionStrategy.ROUND_ROBIN.name()+ ""String_Node_Str""+ numPartitions));
  }
  if ((getNameOverride() != null) && (getNameOverride().length() > 0)) {
    retVal=new CustomIdIndex(retVal.getIndexStrategy(),retVal.getIndexModel(),new ByteArrayId(getNameOverride()));
  }
  return retVal;
}",0.98159509202454
112990,"@Test public void testServices() throws IOException, SchemaException {
  geoserverServiceClient=new GeoserverServiceClient(ServicesTestEnvironment.GEOWAVE_BASE_URL);
  infoServiceClient=new InfoServiceClient(ServicesTestEnvironment.GEOWAVE_BASE_URL);
  ingestServiceClient=new IngestServiceClient(ServicesTestEnvironment.GEOWAVE_BASE_URL);
  boolean success=false;
  LOGGER.info(""String_Node_Str"");
  success=ingestServiceClient.localIngest(new File[]{new File(ASHLAND_GPX_FILE)},dataStoreOptions.getType(),TestUtils.TEST_NAMESPACE,null,ASHLAND_INGEST_TYPE,null,false);
  assertTrue(""String_Node_Str"" + ASHLAND_GPX_FILE + ""String_Node_Str"",success);
  success=false;
  TestUtils.deleteAll(dataStoreOptions);
  LOGGER.info(""String_Node_Str"");
  success=ingestServiceClient.hdfsIngest(new File[]{new File(ASHLAND_GPX_FILE)},dataStoreOptions.getType(),TestUtils.TEST_NAMESPACE,null,ASHLAND_INGEST_TYPE,null,false);
  assertTrue(""String_Node_Str"" + ASHLAND_GPX_FILE + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  final JSONArray adapters=infoServiceClient.getAdapters(dataStoreOptions.getType()).getJSONArray(""String_Node_Str"");
  for (int i=0; i < adapters.size(); i++) {
    if (adapters.getJSONObject(i).getString(""String_Node_Str"").equals(GpxUtils.GPX_WAYPOINT_FEATURE)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + GpxUtils.GPX_WAYPOINT_FEATURE + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  final JSONArray indices=infoServiceClient.getIndices(dataStoreOptions.getType()).getJSONArray(""String_Node_Str"");
  final String expectedIndex=new SpatialDimensionalityTypeProvider().getDimensionalityTypeName();
  for (int i=0; i < indices.size(); i++) {
    if (indices.getJSONObject(i).getString(""String_Node_Str"").equals(expectedIndex)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + expectedIndex + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_WORKSPACE + ""String_Node_Str"",geoserverServiceClient.createWorkspace(ServicesTestEnvironment.TEST_WORKSPACE));
  LOGGER.info(""String_Node_Str"");
  final JSONArray workspaces=geoserverServiceClient.getWorkspaces().getJSONArray(""String_Node_Str"");
  for (int i=0; i < workspaces.size(); i++) {
    if (workspaces.getJSONObject(i).getString(""String_Node_Str"").equals(ServicesTestEnvironment.TEST_WORKSPACE)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_WORKSPACE + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE + ""String_Node_Str"",geoserverServiceClient.publishStyle(new File[]{new File(ServicesTestEnvironment.TEST_SLD_NO_DIFFERENCE_FILE)}));
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_MINOR_SUBSAMPLE + ""String_Node_Str"",geoserverServiceClient.publishStyle(new File[]{new File(ServicesTestEnvironment.TEST_SLD_MINOR_SUBSAMPLE_FILE)}));
  LOGGER.info(""String_Node_Str"");
  final JSONArray styles=geoserverServiceClient.getStyles().getJSONArray(""String_Node_Str"");
  for (int i=0; i < styles.size(); i++) {
    if (styles.getJSONObject(i).getString(""String_Node_Str"").equals(ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE + ""String_Node_Str"",success);
  success=false;
  for (int i=0; i < styles.size(); i++) {
    if (styles.getJSONObject(i).getString(""String_Node_Str"").equals(ServicesTestEnvironment.TEST_STYLE_NAME_MINOR_SUBSAMPLE)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_MINOR_SUBSAMPLE + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  final String style=IOUtils.toString(geoserverServiceClient.getStyle(ServicesTestEnvironment.TEST_SLD_NO_DIFFERENCE_FILE));
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE + ""String_Node_Str"",(style != null) && !style.isEmpty());
  LOGGER.info(""String_Node_Str"");
  assertTrue(""String_Node_Str"",geoserverServiceClient.publishDatastore(dataStoreOptions.getType(),dataStoreOptions.getFactoryOptionsAsMap(),TestUtils.TEST_NAMESPACE,null,null,null,null,ServicesTestEnvironment.TEST_WORKSPACE));
  LOGGER.info(""String_Node_Str"");
  final JSONArray datastores=geoserverServiceClient.getDatastores(ServicesTestEnvironment.TEST_WORKSPACE).getJSONArray(""String_Node_Str"");
  JSONObject dsInfo=null;
  for (int i=0; i < datastores.size(); i++) {
    if (datastores.getJSONObject(i).getString(""String_Node_Str"").equals(TestUtils.TEST_NAMESPACE)) {
      dsInfo=datastores.getJSONObject(i);
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"",success);
  success=false;
  if (dsInfo != null) {
    final Map<String,String> options=dataStoreOptions.getFactoryOptionsAsMap();
    List<ConfigOption> configOptions=Arrays.asList(ConfigUtils.createConfigOptionsFromJCommander(dataStoreOptions));
    Collection<String> nonPasswordRequiredFields=Collections2.transform(Collections2.filter(configOptions,new Predicate<ConfigOption>(){
      @Override public boolean apply(      ConfigOption input){
        return !input.isPassword() && !input.isOptional();
      }
    }
),new Function<ConfigOption,String>(){
      @Override public String apply(      ConfigOption input){
        return input.getName();
      }
    }
);
    for (    final Entry<String,String> entry : options.entrySet()) {
      if (nonPasswordRequiredFields.contains(entry.getKey())) {
        assertTrue(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"",dsInfo.getString(entry.getKey()).equals(entry.getValue()));
      }
    }
  }
  LOGGER.info(""String_Node_Str"");
  final JSONObject datastore=geoserverServiceClient.getDatastore(TestUtils.TEST_NAMESPACE,ServicesTestEnvironment.TEST_WORKSPACE);
  assertTrue(""String_Node_Str"",datastore.getJSONObject(""String_Node_Str"").getString(""String_Node_Str"").equals(TestUtils.TEST_NAMESPACE));
  LOGGER.info(""String_Node_Str"");
  assertTrue(""String_Node_Str"" + GpxUtils.GPX_WAYPOINT_FEATURE + ""String_Node_Str"",geoserverServiceClient.publishLayer(TestUtils.TEST_NAMESPACE,ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE,GpxUtils.GPX_WAYPOINT_FEATURE,ServicesTestEnvironment.TEST_WORKSPACE));
  LOGGER.info(""String_Node_Str"");
  final JSONArray layers=geoserverServiceClient.getLayers().getJSONArray(""String_Node_Str"").getJSONObject(0).getJSONArray(""String_Node_Str"");
  for (int i=0; i < layers.size(); i++) {
    if (layers.getJSONObject(i).getString(""String_Node_Str"").equals(GpxUtils.GPX_WAYPOINT_FEATURE)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + GpxUtils.GPX_WAYPOINT_FEATURE + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  final JSONObject layer=geoserverServiceClient.getLayer(GpxUtils.GPX_WAYPOINT_FEATURE);
  assertTrue(""String_Node_Str"",layer.getJSONObject(""String_Node_Str"").getString(""String_Node_Str"").equals(GpxUtils.GPX_WAYPOINT_FEATURE));
  LOGGER.info(""String_Node_Str"");
  assertTrue(""String_Node_Str"" + GpxUtils.GPX_WAYPOINT_FEATURE + ""String_Node_Str"",geoserverServiceClient.deleteLayer(GpxUtils.GPX_WAYPOINT_FEATURE));
  assertTrue(""String_Node_Str"",geoserverServiceClient.deleteDatastore(TestUtils.TEST_NAMESPACE,ServicesTestEnvironment.TEST_WORKSPACE));
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE + ""String_Node_Str"",geoserverServiceClient.deleteStyle(ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE));
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_MINOR_SUBSAMPLE + ""String_Node_Str"",geoserverServiceClient.deleteStyle(ServicesTestEnvironment.TEST_STYLE_NAME_MINOR_SUBSAMPLE));
  assertTrue(""String_Node_Str"",geoserverServiceClient.deleteWorkspace(ServicesTestEnvironment.TEST_WORKSPACE));
}","@Test public void testServices() throws IOException, SchemaException {
  geoserverServiceClient=new GeoserverServiceClient(ServicesTestEnvironment.GEOWAVE_BASE_URL);
  infoServiceClient=new InfoServiceClient(ServicesTestEnvironment.GEOWAVE_BASE_URL);
  ingestServiceClient=new IngestServiceClient(ServicesTestEnvironment.GEOWAVE_BASE_URL);
  boolean success=false;
  LOGGER.info(""String_Node_Str"");
  success=ingestServiceClient.localIngest(new File[]{new File(ASHLAND_GPX_FILE)},dataStoreOptions.getType(),TestUtils.TEST_NAMESPACE,null,ASHLAND_INGEST_TYPE,null,false);
  assertTrue(""String_Node_Str"" + ASHLAND_GPX_FILE + ""String_Node_Str"",success);
  success=false;
  TestUtils.deleteAll(dataStoreOptions);
  LOGGER.info(""String_Node_Str"");
  success=ingestServiceClient.hdfsIngest(new File[]{new File(ASHLAND_GPX_FILE)},dataStoreOptions.getType(),TestUtils.TEST_NAMESPACE,null,ASHLAND_INGEST_TYPE,null,false);
  assertTrue(""String_Node_Str"" + ASHLAND_GPX_FILE + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  final JSONArray adapters=infoServiceClient.getAdapters(dataStoreOptions.getType()).getJSONArray(""String_Node_Str"");
  for (int i=0; i < adapters.size(); i++) {
    if (adapters.getJSONObject(i).getString(""String_Node_Str"").equals(GpxUtils.GPX_WAYPOINT_FEATURE)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + GpxUtils.GPX_WAYPOINT_FEATURE + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  final JSONArray indices=infoServiceClient.getIndices(dataStoreOptions.getType()).getJSONArray(""String_Node_Str"");
  for (int i=0; i < indices.size(); i++) {
    if (indices.getJSONObject(i).getString(""String_Node_Str"").equals(TestUtils.DEFAULT_SPATIAL_INDEX.getId().getString())) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + TestUtils.DEFAULT_SPATIAL_INDEX.getId().getString() + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_WORKSPACE + ""String_Node_Str"",geoserverServiceClient.createWorkspace(ServicesTestEnvironment.TEST_WORKSPACE));
  LOGGER.info(""String_Node_Str"");
  final JSONArray workspaces=geoserverServiceClient.getWorkspaces().getJSONArray(""String_Node_Str"");
  for (int i=0; i < workspaces.size(); i++) {
    if (workspaces.getJSONObject(i).getString(""String_Node_Str"").equals(ServicesTestEnvironment.TEST_WORKSPACE)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_WORKSPACE + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE + ""String_Node_Str"",geoserverServiceClient.publishStyle(new File[]{new File(ServicesTestEnvironment.TEST_SLD_NO_DIFFERENCE_FILE)}));
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_MINOR_SUBSAMPLE + ""String_Node_Str"",geoserverServiceClient.publishStyle(new File[]{new File(ServicesTestEnvironment.TEST_SLD_MINOR_SUBSAMPLE_FILE)}));
  LOGGER.info(""String_Node_Str"");
  final JSONArray styles=geoserverServiceClient.getStyles().getJSONArray(""String_Node_Str"");
  for (int i=0; i < styles.size(); i++) {
    if (styles.getJSONObject(i).getString(""String_Node_Str"").equals(ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE + ""String_Node_Str"",success);
  success=false;
  for (int i=0; i < styles.size(); i++) {
    if (styles.getJSONObject(i).getString(""String_Node_Str"").equals(ServicesTestEnvironment.TEST_STYLE_NAME_MINOR_SUBSAMPLE)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_MINOR_SUBSAMPLE + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  final String style=IOUtils.toString(geoserverServiceClient.getStyle(ServicesTestEnvironment.TEST_SLD_NO_DIFFERENCE_FILE));
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE + ""String_Node_Str"",(style != null) && !style.isEmpty());
  LOGGER.info(""String_Node_Str"");
  assertTrue(""String_Node_Str"",geoserverServiceClient.publishDatastore(dataStoreOptions.getType(),dataStoreOptions.getFactoryOptionsAsMap(),TestUtils.TEST_NAMESPACE,null,null,null,null,ServicesTestEnvironment.TEST_WORKSPACE));
  LOGGER.info(""String_Node_Str"");
  final JSONArray datastores=geoserverServiceClient.getDatastores(ServicesTestEnvironment.TEST_WORKSPACE).getJSONArray(""String_Node_Str"");
  JSONObject dsInfo=null;
  for (int i=0; i < datastores.size(); i++) {
    if (datastores.getJSONObject(i).getString(""String_Node_Str"").equals(TestUtils.TEST_NAMESPACE)) {
      dsInfo=datastores.getJSONObject(i);
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"",success);
  success=false;
  if (dsInfo != null) {
    final Map<String,String> options=dataStoreOptions.getFactoryOptionsAsMap();
    List<ConfigOption> configOptions=Arrays.asList(ConfigUtils.createConfigOptionsFromJCommander(dataStoreOptions));
    Collection<String> nonPasswordRequiredFields=Collections2.transform(Collections2.filter(configOptions,new Predicate<ConfigOption>(){
      @Override public boolean apply(      ConfigOption input){
        return !input.isPassword() && !input.isOptional();
      }
    }
),new Function<ConfigOption,String>(){
      @Override public String apply(      ConfigOption input){
        return input.getName();
      }
    }
);
    for (    final Entry<String,String> entry : options.entrySet()) {
      if (nonPasswordRequiredFields.contains(entry.getKey())) {
        assertTrue(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"",dsInfo.getString(entry.getKey()).equals(entry.getValue()));
      }
    }
  }
  LOGGER.info(""String_Node_Str"");
  final JSONObject datastore=geoserverServiceClient.getDatastore(TestUtils.TEST_NAMESPACE,ServicesTestEnvironment.TEST_WORKSPACE);
  assertTrue(""String_Node_Str"",datastore.getJSONObject(""String_Node_Str"").getString(""String_Node_Str"").equals(TestUtils.TEST_NAMESPACE));
  LOGGER.info(""String_Node_Str"");
  assertTrue(""String_Node_Str"" + GpxUtils.GPX_WAYPOINT_FEATURE + ""String_Node_Str"",geoserverServiceClient.publishLayer(TestUtils.TEST_NAMESPACE,ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE,GpxUtils.GPX_WAYPOINT_FEATURE,ServicesTestEnvironment.TEST_WORKSPACE));
  LOGGER.info(""String_Node_Str"");
  final JSONArray layers=geoserverServiceClient.getLayers().getJSONArray(""String_Node_Str"").getJSONObject(0).getJSONArray(""String_Node_Str"");
  for (int i=0; i < layers.size(); i++) {
    if (layers.getJSONObject(i).getString(""String_Node_Str"").equals(GpxUtils.GPX_WAYPOINT_FEATURE)) {
      success=true;
      break;
    }
  }
  assertTrue(""String_Node_Str"" + GpxUtils.GPX_WAYPOINT_FEATURE + ""String_Node_Str"",success);
  success=false;
  LOGGER.info(""String_Node_Str"");
  final JSONObject layer=geoserverServiceClient.getLayer(GpxUtils.GPX_WAYPOINT_FEATURE);
  assertTrue(""String_Node_Str"",layer.getJSONObject(""String_Node_Str"").getString(""String_Node_Str"").equals(GpxUtils.GPX_WAYPOINT_FEATURE));
  LOGGER.info(""String_Node_Str"");
  assertTrue(""String_Node_Str"" + GpxUtils.GPX_WAYPOINT_FEATURE + ""String_Node_Str"",geoserverServiceClient.deleteLayer(GpxUtils.GPX_WAYPOINT_FEATURE));
  assertTrue(""String_Node_Str"",geoserverServiceClient.deleteDatastore(TestUtils.TEST_NAMESPACE,ServicesTestEnvironment.TEST_WORKSPACE));
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE + ""String_Node_Str"",geoserverServiceClient.deleteStyle(ServicesTestEnvironment.TEST_STYLE_NAME_NO_DIFFERENCE));
  assertTrue(""String_Node_Str"" + ServicesTestEnvironment.TEST_STYLE_NAME_MINOR_SUBSAMPLE + ""String_Node_Str"",geoserverServiceClient.deleteStyle(ServicesTestEnvironment.TEST_STYLE_NAME_MINOR_SUBSAMPLE));
  assertTrue(""String_Node_Str"",geoserverServiceClient.deleteWorkspace(ServicesTestEnvironment.TEST_WORKSPACE));
}",0.9862878319950588
112991,"@GET @Path(""String_Node_Str"") @Produces(""String_Node_Str"") public Response getVideo(final @PathParam(""String_Node_Str"") String mission,final @PathParam(""String_Node_Str"") String track,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") final int targetPixelSize,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") final double speed){
  String videoNameStr=""String_Node_Str"" + mission + ""String_Node_Str""+ track+ ""String_Node_Str"";
  final DataStore dataStore=getSingletonInstance();
  final TreeMap<Long,BufferedImage> imageChips=new TreeMap<Long,BufferedImage>();
  int width=-1;
  int height=-1;
  try (CloseableIterator<Object> imageChipIt=dataStore.query(new QueryOptions(ImageChipDataAdapter.ADAPTER_ID,Stanag4676IngestPlugin.IMAGE_CHIP_INDEX.getId()),new PrefixIdQuery(new ByteArrayId(ByteArrayUtils.combineArrays(ImageChipDataAdapter.ADAPTER_ID.getBytes(),ImageChipUtils.getTrackDataIdPrefix(mission,track).getBytes()))))){
    while (imageChipIt.hasNext()) {
      final Object imageChipObj=imageChipIt.next();
      if ((imageChipObj != null) && (imageChipObj instanceof ImageChip)) {
        final ImageChip imageChip=(ImageChip)imageChipObj;
        final BufferedImage image=imageChip.getImage(targetPixelSize);
        if ((width < 0) || (image.getWidth() > width)) {
          width=image.getWidth();
        }
        if ((height < 0) || (image.getHeight() > height)) {
          height=image.getHeight();
        }
        imageChips.put(imageChip.getTimeMillis(),image);
      }
    }
  }
 catch (  Exception e1) {
    LOGGER.error(""String_Node_Str"",e1);
    return Response.serverError().entity(""String_Node_Str"" + videoNameStr + ""String_Node_Str""+ ""String_Node_Str""+ e1.getLocalizedMessage()+ ""String_Node_Str""+ e1.getStackTrace()).build();
  }
  if (imageChips.isEmpty()) {
    return Response.serverError().entity(""String_Node_Str"" + videoNameStr).build();
  }
 else {
    LOGGER.info(""String_Node_Str"" + videoNameStr);
    try {
      LOGGER.info(""String_Node_Str"");
      final File responseBody=buildVideo(mission,track,imageChips,width,height,speed);
      LOGGER.info(""String_Node_Str"" + responseBody.getAbsolutePath());
      FileInputStream fis=new FileInputStream(responseBody);
      if (!responseBody.delete()) {
        LOGGER.warn(""String_Node_Str"");
      }
      if (!responseBody.getParentFile().delete()) {
        LOGGER.warn(""String_Node_Str"");
      }
      return Response.ok().entity(fis).type(""String_Node_Str"").build();
    }
 catch (    final IOException e) {
      LOGGER.error(""String_Node_Str"",e);
      return Response.serverError().entity(""String_Node_Str"" + videoNameStr).build();
    }
  }
}","@GET @Path(""String_Node_Str"") @Produces(""String_Node_Str"") public Response getVideo(final @PathParam(""String_Node_Str"") String mission,final @PathParam(""String_Node_Str"") String track,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") final int targetPixelSize,@QueryParam(""String_Node_Str"") @DefaultValue(""String_Node_Str"") final double speed){
  String videoNameStr=""String_Node_Str"" + mission + ""String_Node_Str""+ track+ ""String_Node_Str"";
  final DataStore dataStore=getSingletonInstance();
  final TreeMap<Long,BufferedImage> imageChips=new TreeMap<Long,BufferedImage>();
  int width=-1;
  int height=-1;
  try (CloseableIterator<Object> imageChipIt=dataStore.query(new QueryOptions(ImageChipDataAdapter.ADAPTER_ID,Stanag4676IngestPlugin.IMAGE_CHIP_INDEX.getId()),new PrefixIdQuery(new ByteArrayId(ByteArrayUtils.combineArrays(ImageChipDataAdapter.ADAPTER_ID.getBytes(),ImageChipUtils.getTrackDataIdPrefix(mission,track).getBytes()))))){
    while (imageChipIt.hasNext()) {
      final Object imageChipObj=imageChipIt.next();
      if ((imageChipObj != null) && (imageChipObj instanceof ImageChip)) {
        final ImageChip imageChip=(ImageChip)imageChipObj;
        final BufferedImage image=imageChip.getImage(targetPixelSize);
        if ((width < 0) || (image.getWidth() > width)) {
          width=image.getWidth();
        }
        if ((height < 0) || (image.getHeight() > height)) {
          height=image.getHeight();
        }
        imageChips.put(imageChip.getTimeMillis(),image);
      }
    }
  }
 catch (  Exception e1) {
    LOGGER.error(""String_Node_Str"",e1);
    return Response.serverError().entity(""String_Node_Str"" + videoNameStr + ""String_Node_Str""+ ""String_Node_Str""+ e1.getLocalizedMessage()+ ""String_Node_Str""+ Arrays.toString(e1.getStackTrace())).build();
  }
  if (imageChips.isEmpty()) {
    return Response.serverError().entity(""String_Node_Str"" + videoNameStr).build();
  }
 else {
    LOGGER.info(""String_Node_Str"" + videoNameStr);
    try {
      LOGGER.info(""String_Node_Str"");
      final File responseBody=buildVideo(mission,track,imageChips,width,height,speed);
      LOGGER.info(""String_Node_Str"" + responseBody.getAbsolutePath());
      try (FileInputStream fis=new FileInputStream(responseBody)){
        if (!responseBody.delete()) {
          LOGGER.warn(""String_Node_Str"");
        }
        if (!responseBody.getParentFile().delete()) {
          LOGGER.warn(""String_Node_Str"");
        }
        return Response.ok().entity(fis).type(""String_Node_Str"").build();
      }
 catch (      final FileNotFoundException fnfe) {
        LOGGER.error(""String_Node_Str"",fnfe);
        return Response.serverError().entity(""String_Node_Str"" + videoNameStr).build();
      }
    }
 catch (    final IOException e) {
      LOGGER.error(""String_Node_Str"",e);
      return Response.serverError().entity(""String_Node_Str"" + videoNameStr).build();
    }
  }
}",0.953884801722591
112992,"public synchronized static List<Param> getPluginParams(final StoreFactoryFamilySpi storeFactoryFamily){
  List<Param> params=paramMap.get(storeFactoryFamily.getName());
  if (params == null) {
    final ConfigOption[] configOptions=GeoWaveStoreFinder.getAllOptions(storeFactoryFamily);
    params=new ArrayList<Param>(Lists.transform(Lists.newArrayList(configOptions),new GeoWaveConfigOptionToGeoToolsConfigOption()));
    params.add(GEOWAVE_NAMESPACE);
    params.add(LOCK_MGT);
    params.add(AUTH_MGT);
    params.add(AUTH_URL);
    params.add(TRANSACTION_BUFFER_SIZE_PARAM);
    params.add(QUERY_INDEX_STRATEGY);
    paramMap.put(storeFactoryFamily.getName(),params);
  }
  return params;
}","public synchronized static List<Param> getPluginParams(final StoreFactoryFamilySpi storeFactoryFamily){
  List<Param> params=paramMap.get(storeFactoryFamily.getName());
  if (params == null) {
    final ConfigOption[] configOptions=GeoWaveStoreFinder.getAllOptions(storeFactoryFamily);
    params=new ArrayList<Param>(Lists.transform(Lists.newArrayList(configOptions),new GeoWaveConfigOptionToGeoToolsConfigOption()));
    params.add(FEATURE_NAMESPACE);
    params.add(GEOWAVE_NAMESPACE);
    params.add(LOCK_MGT);
    params.add(AUTH_MGT);
    params.add(AUTH_URL);
    params.add(TRANSACTION_BUFFER_SIZE_PARAM);
    params.add(QUERY_INDEX_STRATEGY);
    paramMap.put(storeFactoryFamily.getName(),params);
  }
  return params;
}",0.9754040758959944
112993,"protected void tearDown() throws Exception {
synchronized (MUTEX) {
    if (!DEFER_CLEANUP.get()) {
      List<TestEnvironment> envs=Arrays.asList(testEnvs);
      ListIterator<TestEnvironment> it=envs.listIterator();
      while (it.hasPrevious()) {
        it.previous().tearDown();
      }
    }
  }
}","protected void tearDown() throws Exception {
synchronized (MUTEX) {
    if (!DEFER_CLEANUP.get()) {
      List<TestEnvironment> envs=Arrays.asList(testEnvs);
      ListIterator<TestEnvironment> it=envs.listIterator(envs.size());
      while (it.hasPrevious()) {
        it.previous().tearDown();
      }
    }
  }
}",0.9822294022617124
112994,"@SuppressFBWarnings(value={""String_Node_Str""},justification=""String_Node_Str"") @Override public void setup() throws Exception {
synchronized (GeoWaveITRunner.MUTEX) {
    if (jettyServer == null) {
      try {
        jettyServer=new Server();
        final SocketConnector conn=new SocketConnector();
        conn.setPort(JETTY_PORT);
        conn.setAcceptQueueSize(ACCEPT_QUEUE_SIZE);
        conn.setMaxIdleTime(MAX_IDLE_TIME);
        conn.setSoLingerTime(SO_LINGER_TIME);
        jettyServer.setConnectors(new Connector[]{conn});
        final WebAppContext gsWebapp=new WebAppContext();
        gsWebapp.setContextPath(GEOSERVER_CONTEXT_PATH);
        gsWebapp.setWar(GEOSERVER_WAR_DIR);
        final WebAppClassLoader classLoader=AccessController.doPrivileged(new PrivilegedAction<WebAppClassLoader>(){
          @Override public WebAppClassLoader run(){
            try {
              return new WebAppClassLoader(gsWebapp);
            }
 catch (            final IOException e) {
              LOGGER.error(""String_Node_Str"",e);
              return null;
            }
          }
        }
);
        if (classLoader == null) {
          throw new IOException(""String_Node_Str"");
        }
        classLoader.addClassPath(System.getProperty(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
        gsWebapp.setClassLoader(classLoader);
        gsWebapp.setParentLoaderPriority(true);
        final File warDir=new File(GEOWAVE_WAR_DIR);
        ServicesTestUtils.writeConfigFile(new File(warDir,""String_Node_Str""));
        final WebAppContext gwWebapp=new WebAppContext();
        gwWebapp.setContextPath(GEOWAVE_CONTEXT_PATH);
        gwWebapp.setWar(warDir.getAbsolutePath());
        jettyServer.setHandlers(new WebAppContext[]{gsWebapp,gwWebapp});
        gsWebapp.setTempDirectory(TestUtils.TEMP_DIR);
        gsWebapp.getServletContext().getContextHandler().setMaxFormContentSize(MAX_FORM_CONTENT_SIZE);
        final String jettyConfigFile=System.getProperty(""String_Node_Str"");
        if (jettyConfigFile != null) {
          LOGGER.info(""String_Node_Str"" + jettyConfigFile);
          (new XmlConfiguration(new FileInputStream(jettyConfigFile))).configure(jettyServer);
        }
        jettyServer.start();
        while (!jettyServer.isRunning() && !jettyServer.isStarted()) {
          Thread.sleep(1000);
        }
      }
 catch (      final RuntimeException e) {
        throw e;
      }
catch (      final Exception e) {
        LOGGER.error(""String_Node_Str"" + e.getMessage(),e);
        if (jettyServer != null) {
          try {
            jettyServer.stop();
          }
 catch (          final Exception e1) {
            LOGGER.error(""String_Node_Str"",e1);
          }
        }
      }
    }
  }
}","@SuppressFBWarnings(value={""String_Node_Str""},justification=""String_Node_Str"") @Override public void setup() throws Exception {
synchronized (GeoWaveITRunner.MUTEX) {
    if (jettyServer == null) {
      try {
        System.setProperty(""String_Node_Str"",""String_Node_Str"");
        jettyServer=new Server();
        final SocketConnector conn=new SocketConnector();
        conn.setPort(JETTY_PORT);
        conn.setAcceptQueueSize(ACCEPT_QUEUE_SIZE);
        conn.setMaxIdleTime(MAX_IDLE_TIME);
        conn.setSoLingerTime(SO_LINGER_TIME);
        jettyServer.setConnectors(new Connector[]{conn});
        final WebAppContext gsWebapp=new WebAppContext();
        gsWebapp.setContextPath(GEOSERVER_CONTEXT_PATH);
        gsWebapp.setWar(GEOSERVER_WAR_DIR);
        final WebAppClassLoader classLoader=AccessController.doPrivileged(new PrivilegedAction<WebAppClassLoader>(){
          @Override public WebAppClassLoader run(){
            try {
              return new WebAppClassLoader(gsWebapp);
            }
 catch (            final IOException e) {
              LOGGER.error(""String_Node_Str"",e);
              return null;
            }
          }
        }
);
        if (classLoader == null) {
          throw new IOException(""String_Node_Str"");
        }
        classLoader.addClassPath(System.getProperty(""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
        gsWebapp.setClassLoader(classLoader);
        gsWebapp.setParentLoaderPriority(true);
        final File warDir=new File(GEOWAVE_WAR_DIR);
        ServicesTestUtils.writeConfigFile(new File(warDir,""String_Node_Str""));
        final WebAppContext gwWebapp=new WebAppContext();
        gwWebapp.setContextPath(GEOWAVE_CONTEXT_PATH);
        gwWebapp.setWar(warDir.getAbsolutePath());
        jettyServer.setHandlers(new WebAppContext[]{gsWebapp,gwWebapp});
        gsWebapp.setTempDirectory(TestUtils.TEMP_DIR);
        gsWebapp.getServletContext().getContextHandler().setMaxFormContentSize(MAX_FORM_CONTENT_SIZE);
        final String jettyConfigFile=System.getProperty(""String_Node_Str"");
        if (jettyConfigFile != null) {
          LOGGER.info(""String_Node_Str"" + jettyConfigFile);
          (new XmlConfiguration(new FileInputStream(jettyConfigFile))).configure(jettyServer);
        }
        jettyServer.start();
        while (!jettyServer.isRunning() && !jettyServer.isStarted()) {
          Thread.sleep(1000);
        }
      }
 catch (      final RuntimeException e) {
        throw e;
      }
catch (      final Exception e) {
        LOGGER.error(""String_Node_Str"" + e.getMessage(),e);
        if (jettyServer != null) {
          try {
            jettyServer.stop();
          }
 catch (          final Exception e1) {
            LOGGER.error(""String_Node_Str"",e1);
          }
        }
      }
    }
  }
}",0.988349166517297
112995,"private void initializePositionMaps(){
  for (int i=0; i < reprojectedType.getAttributeCount(); i++) {
    final AttributeDescriptor ad=reprojectedType.getDescriptor(i);
    final ByteArrayId currFieldId=new ByteArrayId(ad.getLocalName());
    fieldToPositionMap.put(currFieldId,i);
  }
  positionToFieldMap=fieldToPositionMap.inverse();
}","private void initializePositionMaps(){
  for (int i=0; i < reprojectedType.getAttributeCount(); i++) {
    final AttributeDescriptor ad=reprojectedType.getDescriptor(i);
    final ByteArrayId currFieldId=new ByteArrayId(ad.getLocalName());
    fieldToPositionMap.forcePut(currFieldId,i);
  }
  positionToFieldMap=fieldToPositionMap.inverse();
}",0.9897510980966324
112996,"public static StoreFactoryFamilySpi findStoreFamily(final Map<String,String> configOptions){
  Map<String,StoreFactoryFamilySpi> factories=getRegisteredStoreFactoryFamilies();
  final Object storeHint=configOptions.get(STORE_HINT_KEY);
  Map<String,StoreFactoryFamilySpi> internalStoreFamilies=getRegisteredStoreFactoryFamilies();
  if (storeHint != null) {
    final StoreFactoryFamilySpi factory=internalStoreFamilies.get(storeHint.toString());
    if (factory != null) {
      final List<String> missingOptions=getMissingRequiredOptions(factory,configOptions);
      if (missingOptions.isEmpty()) {
        return factory;
      }
      LOGGER.error(""String_Node_Str"" + storeHint.toString() + ""String_Node_Str""+ ConfigUtils.getOptions(missingOptions));
      return null;
    }
 else {
      LOGGER.error(""String_Node_Str"" + storeHint.toString() + ""String_Node_Str"");
      return null;
    }
  }
  int matchingFactoryOptionCount=-1;
  StoreFactoryFamilySpi matchingFactory=null;
  boolean matchingFactoriesHaveSameOptionCount=false;
  for (  final Entry<String,StoreFactoryFamilySpi> entry : internalStoreFamilies.entrySet()) {
    final StoreFactoryFamilySpi factory=entry.getValue();
    final List<String> missingOptions=getMissingRequiredOptions(factory,configOptions);
    ConfigOption[] factoryOptions=ConfigUtils.createConfigOptionsFromJCommander(factory.getDataStoreFactory().createOptionsInstance());
    if (missingOptions.isEmpty() && ((matchingFactory == null) || (factoryOptions.length >= matchingFactoryOptionCount))) {
      matchingFactory=factory;
      matchingFactoriesHaveSameOptionCount=(factoryOptions.length == matchingFactoryOptionCount);
      matchingFactoryOptionCount=factoryOptions.length;
    }
  }
  if (matchingFactory == null) {
    LOGGER.error(""String_Node_Str"");
  }
 else   if (matchingFactoriesHaveSameOptionCount) {
    LOGGER.warn(""String_Node_Str"");
    LOGGER.warn(matchingFactory.getName() + ""String_Node_Str"");
  }
  return matchingFactory;
}","public static StoreFactoryFamilySpi findStoreFamily(final Map<String,String> configOptions){
  final Object storeHint=configOptions.get(STORE_HINT_KEY);
  Map<String,StoreFactoryFamilySpi> internalStoreFamilies=getRegisteredStoreFactoryFamilies();
  if (storeHint != null) {
    final StoreFactoryFamilySpi factory=internalStoreFamilies.get(storeHint.toString());
    if (factory != null) {
      final List<String> missingOptions=getMissingRequiredOptions(factory,configOptions);
      if (missingOptions.isEmpty()) {
        return factory;
      }
      LOGGER.error(""String_Node_Str"" + storeHint.toString() + ""String_Node_Str""+ ConfigUtils.getOptions(missingOptions));
      return null;
    }
 else {
      LOGGER.error(""String_Node_Str"" + storeHint.toString() + ""String_Node_Str"");
      return null;
    }
  }
  int matchingFactoryOptionCount=-1;
  StoreFactoryFamilySpi matchingFactory=null;
  boolean matchingFactoriesHaveSameOptionCount=false;
  for (  final Entry<String,StoreFactoryFamilySpi> entry : internalStoreFamilies.entrySet()) {
    final StoreFactoryFamilySpi factory=entry.getValue();
    final List<String> missingOptions=getMissingRequiredOptions(factory,configOptions);
    ConfigOption[] factoryOptions=ConfigUtils.createConfigOptionsFromJCommander(factory.getDataStoreFactory().createOptionsInstance());
    if (missingOptions.isEmpty() && ((matchingFactory == null) || (factoryOptions.length >= matchingFactoryOptionCount))) {
      matchingFactory=factory;
      matchingFactoriesHaveSameOptionCount=(factoryOptions.length == matchingFactoryOptionCount);
      matchingFactoryOptionCount=factoryOptions.length;
    }
  }
  if (matchingFactory == null) {
    LOGGER.error(""String_Node_Str"");
  }
 else   if (matchingFactoriesHaveSameOptionCount) {
    LOGGER.warn(""String_Node_Str"");
    LOGGER.warn(matchingFactory.getName() + ""String_Node_Str"");
  }
  return matchingFactory;
}",0.978701565306646
112997,"private void findEnd(final Iterator<Range> rangeIt,final Collection<Range> internalRanges,final Range seekRange){
  while (rangeIt.hasNext()) {
    final Range internalRange=rangeIt.next();
    if (internalRange.getEndKey().compareTo(seekRange.getEndKey()) > 0) {
      if (internalRange.getStartKey().compareTo(seekRange.getEndKey()) > 0) {
        return;
      }
 else {
        internalRanges.add(new Range(internalRange.getStartKey(),seekRange.getEndKey()));
        return;
      }
    }
 else {
      internalRanges.add(internalRange);
    }
  }
}","private void findEnd(final Iterator<Range> rangeIt,final Collection<Range> internalRanges,final Range seekRange){
  while (rangeIt.hasNext()) {
    final Range internalRange=rangeIt.next();
    if (internalRange.getEndKey() == null || internalRange.getEndKey().compareTo(seekRange.getEndKey()) > 0) {
      if (internalRange.getStartKey() != null && internalRange.getStartKey().compareTo(seekRange.getEndKey()) > 0) {
        return;
      }
 else {
        internalRanges.add(new Range(internalRange.getStartKey(),seekRange.getEndKey()));
        return;
      }
    }
 else {
      internalRanges.add(internalRange);
    }
  }
}",0.9358108108108107
112998,"private void findStart(final Iterator<Range> rangeIt,final Collection<Range> internalRanges,final Range seekRange){
  while (rangeIt.hasNext()) {
    final Range internalRange=rangeIt.next();
    if (internalRange.getEndKey().compareTo(seekRange.getStartKey()) > 0) {
      if (internalRange.getStartKey().compareTo(seekRange.getStartKey()) > 0) {
        internalRanges.add(internalRange);
        return;
      }
 else {
        internalRanges.add(new Range(seekRange.getStartKey(),internalRange.getEndKey()));
        return;
      }
    }
  }
}","private void findStart(final Iterator<Range> rangeIt,final Collection<Range> internalRanges,final Range seekRange){
  while (rangeIt.hasNext()) {
    final Range internalRange=rangeIt.next();
    if (internalRange.getEndKey() == null || internalRange.getEndKey().compareTo(seekRange.getStartKey()) > 0) {
      if (internalRange.getStartKey() != null && internalRange.getStartKey().compareTo(seekRange.getStartKey()) > 0) {
        internalRanges.add(internalRange);
        return;
      }
 else {
        internalRanges.add(new Range(seekRange.getStartKey(),internalRange.getEndKey()));
        return;
      }
    }
  }
}",0.9351535836177476
112999,"public MemoryAdapterStore(final DataAdapter<?>[] adapters){
  adapterMap=new HashMap<ByteArrayId,DataAdapter<?>>();
  for (  final DataAdapter<?> adapter : adapters) {
    adapterMap.put(adapter.getAdapterId(),adapter);
  }
}","public MemoryAdapterStore(final DataAdapter<?>[] adapters){
  adapterMap=Collections.synchronizedMap(new HashMap<ByteArrayId,DataAdapter<?>>());
  for (  final DataAdapter<?> adapter : adapters) {
    adapterMap.put(adapter.getAdapterId(),adapter);
  }
}",0.9394572025052192
113000,"private void readObject(final java.io.ObjectInputStream in) throws IOException, ClassNotFoundException {
  final int count=in.readInt();
  adapterMap=new HashMap<ByteArrayId,DataAdapter<?>>();
  for (int i=0; i < count; i++) {
    final ByteArrayId id=(ByteArrayId)in.readObject();
    final byte[] data=(byte[])in.readObject();
    adapterMap.put(id,PersistenceUtils.fromBinary(data,DataAdapter.class));
  }
}","private void readObject(final java.io.ObjectInputStream in) throws IOException, ClassNotFoundException {
  final int count=in.readInt();
  adapterMap=Collections.synchronizedMap(new HashMap<ByteArrayId,DataAdapter<?>>());
  for (int i=0; i < count; i++) {
    final ByteArrayId id=(ByteArrayId)in.readObject();
    final byte[] data=(byte[])in.readObject();
    adapterMap.put(id,PersistenceUtils.fromBinary(data,DataAdapter.class));
  }
}",0.9658421672555948
